ca65 V2.18 - N/A
Main file   : platform/platform-planck.asm
Current file: platform/platform-planck.asm

000000r 1               .segment "CODE"
000000r 1               
000000r 1               ; I/O facilities are handled in the separate kernel files because of their
000000r 1               ; hardware dependencies. See docs/memorymap.txt for a discussion of Tali's
000000r 1               ; memory layout.
000000r 1               
000000r 1               
000000r 1               ; MEMORY MAP OF RAM
000000r 1               
000000r 1               
000000r 1               ; Drawing is not only very ugly, but also not to scale. See the manual for
000000r 1               ; details on the memory map. Note that some of the values are hard-coded in
000000r 1               ; the testing routines, especially the size of the input history buffer, the
000000r 1               ; offset for PAD, and the total RAM size. If these are changed, the tests will
000000r 1               ; have to be changed as well
000000r 1               
000000r 1               
000000r 1               ;    $0000  +-------------------+  ram_start, zpage, user0
000000r 1               ;           |  User variables  |
000000r 1               ;           +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           +~~~~~~~~~~~~~~~~~~~+  <-- dsp
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Data Stack    |
000000r 1               ;           |  |                |
000000r 1               ;    $0078  +-------------------+  dsp0, stack
000000r 1               ;           |                   |
000000r 1               ;           |   (Reserved for   |
000000r 1               ;           |      kernel)      |
000000r 1               ;           |                   |
000000r 1               ;    $0100  +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Return Stack  |  <-- rsp
000000r 1               ;           |  |                |
000000r 1               ;    $0200  +-------------------+  rsp0, buffer, buffer0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Input Buffer  |
000000r 1               ;           |                   |
000000r 1               ;    $0300  +-------------------+  cp0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Dictionary    |
000000r 1               ;           |       (RAM)       |
000000r 1               ;           |                   |
000000r 1               ;   (...)   ~~~~~~~~~~~~~~~~~~~~~  <-- cp
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;    $7C00  +-------------------+  hist_buff, cp_end
000000r 1               ;           |   Input History   |
000000r 1               ;           |    for ACCEPT     |
000000r 1               ;           |  8x128B buffers   |
000000r 1               ;    $7fff  +-------------------+  ram_end
000000r 1               
000000r 1               
000000r 1               ; HARD PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Some of these are somewhat silly for the 65c02, where for example
000000r 1               ; the location of the Zero Page is fixed by hardware. However, we keep
000000r 1               ; these for easier comparisons with Liara Forth's structure and to
000000r 1               ; help people new to these things.
000000r 1               
000000r 1               ram_start = $0000          ; start of installed 32 KiB of RAM
000000r 1               ram_end =   $8000-1        ; end of installed RAM
000000r 1               zpage =     ram_start      ; begin of Zero Page ($0000-$00ff)
000000r 1               zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
000000r 1               stack0 =    $0100          ; begin of Return Stack ($0100-$01ff)
000000r 1               hist_buff = ram_end-$03ff  ; begin of history buffers
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; SOFT PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Tali currently doesn't have separate user variables for multitasking. To
000000r 1               ; prepare for this, though, we've already named the location of the user
000000r 1               ; variables user0.
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               KB_BUF =    hist_buff - $ff
000000r 1               LCD_BUF =   KB_BUF - $7f
000000r 1               LINE_BUF =  LCD_BUF - $7f
000000r 1               SD_CRC =    LINE_BUF - $1
000000r 1               SD_SLAVE =  SD_CRC - $1
000000r 1               SD_TMP =  SD_SLAVE - $1
000000r 1               SD_ARG =    SD_TMP - $4
000000r 1               SD_BUF =    SD_ARG - $1ff
000000r 1               user0 =     zpage          ; user and system variables
000000r 1               
000000r 1               rsp0 =      $ff            ; initial Return Stack Pointer (65c02 stack)
000000r 1               bsize =     $ff            ; size of input/output buffers
000000r 1               buffer0 =   stack0+$100    ; input buffer ($0200-$027f)
000000r 1               cp0 =       buffer0+bsize  ; Dictionary starts after last buffer
000000r 1               cp_end =    SD_BUF         ; Last RAM byte available for code
000000r 1               padoffset = $ff            ; offset from CP to PAD (holds number strings)
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               .include "../taliforth.asm" ; Top-level definitions, memory map
000000r 2               ; Tali Forth 2 for the 65c02
000000r 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 2               ; First version: 19. Jan 2014 (Tali Forth 1)
000000r 2               ; This version: 03. Jan 2018 (Version 1.0)
000000r 2               
000000r 2               ; This is the main file for Tali Forth 2
000000r 2               
000000r 2               ; Label used to calculate UNUSED. Silly for Tali Forth, where we assume
000000r 2               ; 32 KiB RAM and 32 KiB ROM, but kept here to make the code more useful for
000000r 2               ; other hardware configurations
000000r 2               code0:
000000r 2               
000000r 2               .include "definitions.asm"      ; Top-level definitions, memory map
000000r 3               ; Definitions for Tali Forth 2
000000r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 3               ; First version: 01. Apr 2016 (Liara Forth)
000000r 3               ; This version: 29. Jan 2020
000000r 3               
000000r 3               ; This file is included by taliforth.asm. These are the general
000000r 3               ; definitions; platform-specific definitions such as the
000000r 3               ; memory map are kept in the platform folder.
000000r 3               
000000r 3               
000000r 3               ; ZERO PAGE ADDRESSES/VARIABLES
000000r 3               
000000r 3               ; These are kept at the top of Zero Page, with the most important variables at
000000r 3               ; the top because the Data Stack grows towards this area from dsp0: If there is
000000r 3               ; an overflow, the lower, less important variables will be clobbered first,
000000r 3               ; giving the system a chance to recover. In other words, they are part of the
000000r 3               ; floodplain.
000000r 3               
000000r 3               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000000r 3               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000000r 3               
000000r 3               cp =        user0+0   ; Compiler Pointer
000000r 3               dp =        user0+2   ; Dictionary Pointer
000000r 3               workword =  user0+4   ; nt (not xt!) of word being compiled, except in
000000r 3                                          ; a :NONAME declared word (see status)
000000r 3               insrc =     user0+6   ; input Source for SOURCE-ID
000000r 3               cib =       user0+8   ; address of current input buffer
000000r 3               ciblen =    user0+10  ; length of current input buffer
000000r 3               toin =      user0+12  ; pointer to CIB (>IN in Forth)
000000r 3               ip =        user0+14  ; Instruction Pointer (current xt)
000000r 3               output =    user0+16  ; vector for EMIT
000000r 3               input =     user0+18  ; vector for KEY
000000r 3               havekey =   user0+20  ; vector for KEY?
000000r 3               state =     user0+22  ; STATE: -1 compile, 0 interpret
000000r 3               base =      user0+24  ; number radix, default decimal
000000r 3               nc_limit =   user0+26  ; limit for Native Compile size
000000r 3               uf_strip =   user0+28  ; flag to strip underflow detection code
000000r 3               up =        user0+30  ; User Pointer (Address of user variables)
000000r 3               status =    user0+32  ; internal status information
000000r 3                                          ; (used by : :NONAME ; ACCEPT)
000000r 3                                          ; Bit 7 = Redefined word message postpone
000000r 3                                          ;         When set before calling CREATE, it will
000000r 3                                          ;         not print the "redefined xxxx" message if
000000r 3                                          ;         the word exists. Instead, this bit will
000000r 3                                          ;         be reused and after CREATE has run, it will
000000r 3                                          ;         be set if the word was redefined and 0 if
000000r 3                                          ;         not. This bit should be 0 when not in use.
000000r 3                                          ; Bit 6 = 1 for normal ":" definitions
000000r 3                                          ;         WORKWORD contains nt of word being compiled
000000r 3                                          ;       = 0 for :NONAME definitions
000000r 3                                          ;         WORKWORD contains xt of word being compiled
000000r 3                                          ; Bit 5 = 1 for NUMBER returning a double word
000000r 3                                          ;       = 0 for NUMBER returning a single word
000000r 3                                          ; Bit 3 = 1 makes CTRL-n recall current history
000000r 3                                          ;       = 0 CTRL-n recalls previous history
000000r 3                                          ; Bit 2 = Current history buffer msb
000000r 3                                          ; Bit 1 = Current history buffer (0-7, wraps)
000000r 3                                          ; Bit 0 = Current history buffer lsb
000000r 3                                          ; status+1 is used by ACCEPT to hold history lengths.
000000r 3               tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
000000r 3               tmp1 =      user0+36  ; temporary storage
000000r 3               tmp2 =      user0+38  ; temporary storage
000000r 3               tmp3 =      user0+40  ; temporary storage (especially for print)
000000r 3               tmpdsp =    user0+42  ; temporary DSP (X) storage (two bytes)
000000r 3               tmptos =    user0+44  ; temporary TOS storage
000000r 3               editor1 =   user0+46  ; temporary for editors
000000r 3               editor2 =   user0+48  ; temporary for editors
000000r 3               editor3 =   user0+50  ; temporary for editors
000000r 3               tohold =    user0+52  ; pointer for formatted output
000000r 3               scratch =   user0+54  ; 8 byte scratchpad (see UM/MOD)
000000r 3               
000000r 3               ; Zero Page:
000000r 3               ; Bytes used for variables: 62 ($0000-$003D)
000000r 3               ; First usable Data Stack location: $003E (decimal 62)
000000r 3               ; Bytes avaible for Data Stack: 128-62 = 66 --> 33 16-bit cells
000000r 3               
000000r 3               dsp0 =      zpage_end-7    ; initial Data Stack Pointer
000000r 3               
000000r 3               ; User Variables:
000000r 3               ; Block variables
000000r 3               blk_offset =  0        ; BLK : UP + 0
000000r 3               scr_offset =  2        ; SCR : UP + 2
000000r 3               
000000r 3               ; Wordlists
000000r 3               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000000r 3               num_wordlists_offset =  5
000000r 3                                          ; #WORDLISTS (byte) : UP + 5
000000r 3               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000000r 3                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000000r 3               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000000r 3                                          ;          (Number of wordlists in search order)
000000r 3               search_order_offset =  31
000000r 3                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000000r 3                                          ; Allowing for 9 to keep offsets even.
000000r 3               max_wordlists =  12    ; Maximum number of wordlists supported
000000r 3                                          ; 4 Tali built-ins + 8 user wordlists
000000r 3               
000000r 3               ; Buffer variables
000000r 3               blkbuffer_offset =     40   ; Address of buffer
000000r 3               buffblocknum_offset =  42   ; Block number current in buffer
000000r 3               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000000r 3               
000000r 3               ; Block I/O vectors
000000r 3               blockread_offset =     46   ; Vector to block reading routine
000000r 3               blockwrite_offset =    48   ; Vector to block writing routine
000000r 3               
000000r 3               
000000r 3               ; ASCII CHARACTERS
000000r 3               AscCC =   $03  ; break (CTRL-c)
000000r 3               AscBELL = $07  ; bell sound
000000r 3               AscBS =   $08  ; backspace
000000r 3               AscLF =   $0a  ; line feed
000000r 3               AscCR =   $0d  ; carriage return
000000r 3               AscESC =  $1b  ; escape
000000r 3               AscSP =   $20  ; space
000000r 3               AscDEL =  $7f  ; delete (CTRL-h)
000000r 3               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000000r 3               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000000r 3               
000000r 3               ; DICTIONARY FLAGS
000000r 3               ; The first three bits are currently unused
000000r 3               CO = 1  ; Compile Only
000000r 3               AN = 2  ; Always Native Compile
000000r 3               IM = 4  ; Immediate Word
000000r 3               NN = 8  ; Never Native Compile
000000r 3               UF = 16 ; Includes Underflow Check (RESERVED)
000000r 3               HC = 32 ; Word has Code Field Area (CFA)
000000r 3               
000000r 3               
000000r 3               ; VARIOUS
000000r 3               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000000r 3               
000000r 3               ; END
000000r 3               
000000r 2               
000000r 2               ; Insert point for Tali Forth after kernel hardware setup
000000r 2               forth:
000000r 2               
000000r 2               .include "native_words.asm"     ; Native Forth words. Starts with COLD
000000r 3               ; Low-level Forth word routines
000000r 3               ; Tali Forth 2 for the 65c02
000000r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 3               ; First version: 19. Jan 2014
000000r 3               ; This version: 03. Jan 2018
000000r 3               
000000r 3               ; This list is ordered alphabetically by the names of the words, not their
000000r 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000000r 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000000r 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000000r 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000000r 3               
000000r 3               ;       TBA --> fragment --> coded --> tested --> auto
000000r 3               
000000r 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000000r 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000000r 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000000r 3               
000000r 3               ; ## COLD ( -- ) "Reset the Forth system"
000000r 3               ; ## "cold"  tested  Tali Forth
000000r 3               ;       """Reset the Forth system. Does not restart the kernel,
000000r 3               ;       use the 65c02 reset for that. Flows into ABORT.
000000r 3               ;       """
000000r 3               xt_cold:
000000r 3  D8                           cld
000001r 3               
000001r 3                               ; Set the OUTPUT vector to the default kernel_putc
000001r 3                               ; We do this really early so we can print error messages
000001r 3                               ; during debugging
000001r 3  A9 rr                        lda #<kernel_putc
000003r 3  85 10                        sta output
000005r 3  A9 rr                        lda #>kernel_putc
000007r 3  85 11                        sta output+1
000009r 3               
000009r 3                               ; Load all of the important zero page variables from ROM
000009r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
00000Br 3               
00000Br 3               @load_zp_loop:
00000Br 3                               ; This loop loads them back to front. We can use X here
00000Br 3                               ; because Tali hasn't started using the stack yet.
00000Br 3  BD rr rr                     lda cold_zp_table,x
00000Er 3  95 00                        sta zpage,x
000010r 3  CA                           dex
000011r 3  D0 F8                        bne @load_zp_loop
000013r 3               
000013r 3                               ; Copy the 0th element.
000013r 3  AD rr rr                     lda cold_zp_table
000016r 3  85 00                        sta zpage
000018r 3               
000018r 3                               ; Initialize 65c02 stack (Return Stack)
000018r 3  A2 FF                        ldx #rsp0
00001Ar 3  9A                           txs
00001Br 3               
00001Br 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
00001Br 3                               ; can load high-level words with EVALUATE
00001Br 3  A2 78                        ldx #dsp0
00001Dr 3               
00001Dr 3                               ; Initialize the user variables.
00001Dr 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
00001Fr 3  A9 00                        lda #0
000021r 3               
000021r 3               @load_user_vars_loop:
000021r 3                               ; Like the zero page variables, these are initialized
000021r 3                               ; back to front.
000021r 3  B9 rr rr                     lda cold_user_table,y
000024r 3  91 1E                        sta (up),y
000026r 3  88                           dey
000027r 3  D0 F8                        bne @load_user_vars_loop
000029r 3               
000029r 3                               ; Copy the 0th element.
000029r 3  AD rr rr                     lda cold_user_table
00002Cr 3  92 1E                        sta (up)
00002Er 3  20 rr rr                     jsr xt_cr
000031r 3               
000031r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
000031r 3                               ; you do not have any high-level words, this part can be
000031r 3                               ; commented out.
000031r 3  CA                           dex
000032r 3  CA                           dex
000033r 3  CA                           dex
000034r 3  CA                           dex
000035r 3               
000035r 3                               ; start address goes NOS
000035r 3  A9 rr                        lda #<forth_words_start
000037r 3  95 02                        sta 2,x
000039r 3  A9 rr                        lda #>forth_words_start
00003Br 3  95 03                        sta 3,x
00003Dr 3               
00003Dr 3                               ; length goes TOS
00003Dr 3  A9 rr                        lda #<forth_words_end
00003Fr 3  38                           sec
000040r 3  E9 rr                        sbc #<forth_words_start
000042r 3  95 00                        sta 0,x
000044r 3               
000044r 3  A9 rr                        lda #>forth_words_end
000046r 3  E9 rr                        sbc #>forth_words_start
000048r 3  95 01                        sta 1,x
00004Ar 3               
00004Ar 3  20 rr rr                     jsr xt_evaluate
00004Dr 3               
00004Dr 3                               ; Now define any user words via EVALUATE. If you do not have
00004Dr 3                               ; any user-defined words, this part can be commented out as
00004Dr 3                               ; well.
00004Dr 3  CA                           dex
00004Er 3  CA                           dex
00004Fr 3  CA                           dex
000050r 3  CA                           dex
000051r 3               
000051r 3                               ; start address goes NOS
000051r 3  A9 rr                        lda #<user_words_start
000053r 3  95 02                        sta 2,x
000055r 3  A9 rr                        lda #>user_words_start
000057r 3  95 03                        sta 3,x
000059r 3               
000059r 3                               ; length goes TOS
000059r 3  A9 rr                        lda #<user_words_end
00005Br 3  38                           sec
00005Cr 3  E9 rr                        sbc #<user_words_start
00005Er 3  95 00                        sta 0,x
000060r 3               
000060r 3  A9 rr                        lda #>user_words_end
000062r 3  E9 rr                        sbc #>user_words_start
000064r 3  95 01                        sta 1,x
000066r 3               
000066r 3  20 rr rr                     jsr xt_evaluate
000069r 3               
000069r 3                               ; Initialize all of the history buffers by putting a zero in
000069r 3                               ; each length byte.
000069r 3  9C 00 7C                     stz hist_buff
00006Cr 3  9C 80 7C                     stz hist_buff+$80
00006Fr 3  9C 00 7D                     stz hist_buff+$100
000072r 3  9C 80 7D                     stz hist_buff+$180
000075r 3  9C 00 7E                     stz hist_buff+$200
000078r 3  9C 80 7E                     stz hist_buff+$280
00007Br 3  9C 00 7F                     stz hist_buff+$300
00007Er 3  9C 80 7F                     stz hist_buff+$380
000081r 3               
000081r 3                               ; fall through to ABORT
000081r 3               
000081r 3               
000081r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
000081r 3               ; ## "abort"  tested  ANS core
000081r 3                       ; """https://forth-standard.org/standard/core/ABORT
000081r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
000081r 3                       ; subroutine if we want to because we are going to reset the 65c02's
000081r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
000081r 3                       ; actually delete the stuff on the Data Stack.
000081r 3                       ; """
000081r 3               xt_abort:
000081r 3  A2 78                        ldx #dsp0
000083r 3               
000083r 3                               ; fall through to QUIT
000083r 3               
000083r 3               
000083r 3               ; ## QUIT ( -- ) "Reset the input and get new input"
000083r 3               ; ## "quit"  tested  ANS core
000083r 3                       ; """https://forth-standard.org/standard/core/QUIT
000083r 3                       ; Rest the input and start command loop
000083r 3                       ; """
000083r 3               
000083r 3               xt_quit:
000083r 3                               ; Clear the Return Stack. This is a little screwed up
000083r 3                               ; because the 65c02 can only set the Return Stack via X,
000083r 3                               ; which is our Data Stack pointer. The ANS specification
000083r 3                               ; demands, however, that ABORT reset the Data Stack pointer
000083r 3  8A                           txa             ; Save the DSP that we just defined
000084r 3  A2 FF                        ldx #rsp0
000086r 3  9A                           txs
000087r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000088r 3               
000088r 3                               ; make sure instruction pointer is empty
000088r 3  64 0E                        stz ip
00008Ar 3  64 0F                        stz ip+1
00008Cr 3               
00008Cr 3                               ; SOURCE-ID is zero (keyboard input)
00008Cr 3  64 06                        stz insrc
00008Er 3  64 07                        stz insrc+1
000090r 3               
000090r 3                               ; STATE is zero (interpret, not compile)
000090r 3  64 16                        stz state
000092r 3  64 17                        stz state+1
000094r 3               @get_line:
000094r 3  A9 00                        lda #<buffer0   ; input buffer, this is paranoid
000096r 3  85 08                        sta cib
000098r 3  A9 02                        lda #>buffer0
00009Ar 3  85 09                        sta cib+1
00009Cr 3               
00009Cr 3                               ; Size of current input buffer (CIB) is zero
00009Cr 3  64 0A                        stz ciblen
00009Er 3  64 0B                        stz ciblen+1
0000A0r 3               
0000A0r 3                               ; Accept a line from the current import source. This is how
0000A0r 3                               ; modern Forths to it.
0000A0r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
0000A3r 3               
0000A3r 3                               ; Test flag: LSB of TOS
0000A3r 3  B5 00                        lda 0,x
0000A5r 3  D0 05                        bne @success
0000A7r 3               
0000A7r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
0000A7r 3                               ; need to print an error message and reset the machine. We
0000A7r 3                               ; don't need to save TOS because we're going to clobber it
0000A7r 3                               ; anyway when we go back to ABORT.
0000A7r 3  A9 06                        lda #err_refill
0000A9r 3  4C rr rr                     jmp error
0000ACr 3               
0000ACr 3               @success:
0000ACr 3                               ; Assume we have successfully accepted a string of input from
0000ACr 3                               ; a source, with address cib and length of input in ciblen. We
0000ACr 3                               ; arrive here still with the TRUE flag from REFILL as TOS
0000ACr 3  E8                           inx                     ; drop
0000ADr 3  E8                           inx
0000AEr 3               
0000AEr 3                               ; Main compile/execute routine
0000AEr 3  20 rr rr                     jsr interpret
0000B1r 3               
0000B1r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
0000B1r 3                               ; overflow because it is so rare
0000B1r 3  E0 78                        cpx #dsp0
0000B3r 3  F0 05                        beq @stack_ok
0000B5r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
0000B7r 3               
0000B7r 3  4C rr rr                     jmp underflow_error
0000BAr 3               
0000BAr 3               @stack_ok:
0000BAr 3                               ; Display system prompt if all went well. If we're interpreting,
0000BAr 3                               ; this is " ok", if we're compiling, it's " compiled". Note
0000BAr 3                               ; space at beginning of the string.
0000BAr 3  A5 16                        lda state
0000BCr 3  F0 02                        beq @print
0000BEr 3               
0000BEr 3  A9 01                        lda #1                  ; number for "compile" string
0000C0r 3               @print:
0000C0r 3  20 rr rr                     jsr print_string
0000C3r 3               
0000C3r 3                               ; Awesome line, everybody! Now get the next one.
0000C3r 3  80 CF                        bra @get_line
0000C5r 3               
0000C5r 3               z_cold:
0000C5r 3               z_abort:
0000C5r 3               z_quit:         ; no RTS required
0000C5r 3               
0000C5r 3               
0000C5r 3               
0000C5r 3               ; This table holds all of the initial values for the variables in zero page.
0000C5r 3               ; This table is used by COLD.
0000C5r 3               cold_zp_table:
0000C5r 3  FF 07                .word cp0+256+1024      ; cp moved to make room for user vars and
0000C7r 3                                               ; block buffer
0000C7r 3  rr rr                .word dictionary_start  ; dp
0000C9r 3  00 00                .word 0                 ; workword
0000CBr 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
0000CDr 3  00 02                .word buffer0           ; cib
0000CFr 3  00 00                .word 0                 ; ciblen
0000D1r 3  00 00                .word 0                 ; toin
0000D3r 3  00 00                .word 0                 ; ip
0000D5r 3  rr rr                .word kernel_putc       ; output
0000D7r 3  rr rr                .word kernel_getc       ; input
0000D9r 3  00 00                .word 0                 ; havekey
0000DBr 3  00 00                .word 0                 ; state (0 = interpret)
0000DDr 3  0A 00                .word 10                ; base
0000DFr 3  14 00                .word 20                ; nc-limit
0000E1r 3  00 00                .word 0                 ; uf_strip (off by default)
0000E3r 3  FF 02                .word cp0               ; up (user vars put right at beginning of
0000E5r 3                                               ; available RAM)
0000E5r 3  00 00                .word 0                 ; status
0000E7r 3               cold_zp_table_end:
0000E7r 3               
0000E7r 3               ; No further ZP variables are initialized. The variables past this point are
0000E7r 3               ; all temporaries.
0000E7r 3               
0000E7r 3               ; This table holds the inital values for the user variables. This table is
0000E7r 3               ; used by COLD.
0000E7r 3               cold_user_table:
0000E7r 3  00 00                .word 0                         ; BLK
0000E9r 3  00 00                .word 0                         ; SCR
0000EBr 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
0000ECr 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
0000EDr 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
0000EFr 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
0000F1r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
0000F3r 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
0000F5r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
0000F9r 3  00 00 00 00  
0000FDr 3  00 00 00 00  
000105r 3  01                   .byte 1                         ; #ORDER
000106r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
00010Ar 3  00 00 00 00  
00010Er 3  00           
00010Fr 3  FF 03                .word cp0+256                   ; Address of buffer (right after USER vars)
000111r 3  00 00                .word 0                         ; block in buffer
000113r 3  00 00                .word 0                         ; buffer status (not in use)
000115r 3  rr rr                .word xt_block_word_error       ; block-read vector
000117r 3  rr rr                .word xt_block_word_error       ; block-write vector
000119r 3               cold_user_table_end:
000119r 3               
000119r 3               
000119r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
000119r 3               ; ## "abort""  tested  ANS core
000119r 3                       ; """https://forth-standard.org/standard/core/ABORTq
000119r 3                       ; Abort and print a string.
000119r 3                       ; """
000119r 3               
000119r 3               xt_abort_quote:
000119r 3                               ; save the string
000119r 3  20 rr rr                     jsr xt_s_quote          ; S"
00011Cr 3               
00011Cr 3                               ; compile run-time part
00011Cr 3  A0 rr                        ldy #>abort_quote_runtime
00011Er 3  A9 rr                        lda #<abort_quote_runtime
000120r 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000123r 3               
000123r 3  60           z_abort_quote:  rts
000124r 3               
000124r 3               
000124r 3               abort_quote_runtime:
000124r 3                       ; """Runtime aspect of ABORT_QUOTE"""
000124r 3               
000124r 3                               ; We arrive here with ( f addr u )
000124r 3  B5 04                        lda 4,x
000126r 3  15 05                        ora 5,x
000128r 3  F0 09                        beq @done       ; if FALSE, we're done
00012Ar 3               
00012Ar 3                               ; We're true, so print string and ABORT. We follow Gforth
00012Ar 3                               ; in going to a new line after the string
00012Ar 3  20 rr rr                     jsr xt_type
00012Dr 3  20 rr rr                     jsr xt_cr
000130r 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000133r 3               @done:
000133r 3                               ; Drop three entries from the Data Stack
000133r 3  8A                           txa
000134r 3  18                           clc
000135r 3  69 06                        adc #6
000137r 3  AA                           tax
000138r 3               
000138r 3  60                           rts
000139r 3               
000139r 3               
000139r 3               
000139r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
000139r 3               ; ## "abs"  auto  ANS core
000139r 3                       ; """https://forth-standard.org/standard/core/ABS
000139r 3                       ; Return the absolute value of a number.
000139r 3                       ; """
000139r 3               
000139r 3               xt_abs:
000139r 3  20 rr rr                     jsr underflow_1
00013Cr 3               
00013Cr 3  B5 01                        lda 1,x
00013Er 3  10 0D                        bpl @done       ; positive number, easy money!
000140r 3               
000140r 3                               ; negative: calculate 0 - n
000140r 3  38                           sec
000141r 3  A9 00                        lda #0
000143r 3  F5 00                        sbc 0,x         ; LSB
000145r 3  95 00                        sta 0,x
000147r 3               
000147r 3  A9 00                        lda #0          ; MSB
000149r 3  F5 01                        sbc 1,x
00014Br 3  95 01                        sta 1,x
00014Dr 3               
00014Dr 3               @done:
00014Dr 3  60           z_abs:          rts
00014Er 3               
00014Er 3               
00014Er 3               
00014Er 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
00014Er 3               ; ## "accept"  auto  ANS core
00014Er 3                       ; """https://forth-standard.org/standard/core/ACCEPT
00014Er 3                       ; Receive a string of at most n1 characters, placing them at
00014Er 3                       ; addr. Return the actual number of characters as n2. Characters
00014Er 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
00014Er 3                       ; modern Forths.
00014Er 3                       ; """
00014Er 3               
00014Er 3               xt_accept:
00014Er 3  20 rr rr                     jsr underflow_2
000151r 3               
000151r 3                               ; Abort if we were asked to receive 0 chars
000151r 3  B5 00                        lda 0,x
000153r 3  15 01                        ora 1,x
000155r 3  D0 09                        bne @not_zero
000157r 3               
000157r 3  E8                           inx
000158r 3  E8                           inx
000159r 3  74 00                        stz 0,x
00015Br 3  74 01                        stz 1,x
00015Dr 3               
00015Dr 3  4C rr rr                     jmp accept_done
000160r 3               
000160r 3               @not_zero:
000160r 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000162r 3  85 26                        sta tmp2
000164r 3  64 27                        stz tmp2+1      ; ... but we only accept max 255 chars
000166r 3               
000166r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000168r 3  85 24                        sta tmp1
00016Ar 3  B5 03                        lda 3,x
00016Cr 3  85 25                        sta tmp1+1
00016Er 3               
00016Er 3  E8                           inx
00016Fr 3  E8                           inx
000170r 3               
000170r 3  A0 00                        ldy #0
000172r 3               
000172r 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
000172r 3                               ; from bit 2 to 3 is OK)
000172r 3  A5 20                        lda status
000174r 3  29 F7                        and #$f7
000176r 3               
000176r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000176r 3  1A                           inc
000177r 3               
000177r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000177r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000177r 3                               ; received and won't be used to calculate the history buffer
000177r 3                               ; offset.
000177r 3  09 08                        ora #$08
000179r 3  85 20                        sta status
00017Br 3               
00017Br 3               accept_loop:
00017Br 3                               ; Out of the box, py65mon catches some CTRL sequences such as
00017Br 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
00017Br 3                               ; vt100 terminal clears the screen automatically.
00017Br 3               
00017Br 3                               ; This is the internal version of KEY without all the mucking
00017Br 3                               ; about with the Data Stack while still using the input vector
00017Br 3  20 rr rr                     jsr key_a
00017Er 3               
00017Er 3                               ; We quit on both line feed and carriage return
00017Er 3  C9 0A                        cmp #AscLF
000180r 3  F0 20                        beq @eol
000182r 3  C9 0D                        cmp #AscCR
000184r 3  F0 1C                        beq @eol
000186r 3               
000186r 3                               ; BACKSPACE and DEL do the same thing for the moment
000186r 3  C9 08                        cmp #AscBS
000188r 3  F0 22                        beq @backspace
00018Ar 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
00018Cr 3  F0 1E                        beq @backspace
00018Er 3               
00018Er 3                               ; Check for CTRL-p and CTRL-n to recall input history
00018Er 3  C9 10                        cmp #AscCP
000190r 3  F0 36                        beq @ctrl_p
000192r 3  C9 0E                        cmp #AscCN
000194r 3  F0 44                        beq @ctrl_n
000196r 3               
000196r 3                               ; That's enough for now. Save and echo character.
000196r 3  91 24                        sta (tmp1),y
000198r 3  C8                           iny
000199r 3               
000199r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000199r 3  20 rr rr                     jsr emit_a
00019Cr 3               
00019Cr 3  C4 26                        cpy tmp2        ; reached character limit?
00019Er 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
0001A0r 3  80 03                        bra @buffer_full
0001A2r 3               
0001A2r 3               @eol:
0001A2r 3  20 rr rr                     jsr xt_space    ; print final space
0001A5r 3               
0001A5r 3               @buffer_full:
0001A5r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
0001A5r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
0001A7r 3  74 01                        stz 1,x         ; we only accept 256 chars
0001A9r 3               
0001A9r 3  4C rr rr                     jmp accept_done
0001ACr 3               
0001ACr 3               @backspace:
0001ACr 3                               ; Handle backspace and delete kex, which currently do the same
0001ACr 3                               ; thing
0001ACr 3  C0 00                        cpy #0          ; buffer empty?
0001AEr 3  D0 06                        bne @1
0001B0r 3               
0001B0r 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
0001B2r 3  20 rr rr                     jsr emit_a
0001B5r 3  C8                           iny
0001B6r 3               @1:
0001B6r 3  88                           dey
0001B7r 3  A9 08                        lda #AscBS      ; move back one
0001B9r 3  20 rr rr                     jsr emit_a
0001BCr 3  A9 20                        lda #AscSP      ; print a space (rubout)
0001BEr 3  20 rr rr                     jsr emit_a
0001C1r 3  A9 08                        lda #AscBS      ; move back over space
0001C3r 3  20 rr rr                     jsr emit_a
0001C6r 3               
0001C6r 3  80 B3                        bra accept_loop
0001C8r 3               
0001C8r 3               @ctrl_p:
0001C8r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
0001C8r 3               
0001C8r 3                               ; Select the previous buffer
0001C8r 3  A5 20                        lda status
0001CAr 3               
0001CAr 3                               ; Check for 0 (need to wrap back to 7)
0001CAr 3  29 07                        and #7
0001CCr 3  D0 08                        bne @ctrl_p_dec
0001CEr 3               
0001CEr 3                               ; We need to wrap back to 7.
0001CEr 3  A5 20                        lda status
0001D0r 3  09 07                        ora #7
0001D2r 3  85 20                        sta status
0001D4r 3  80 11                        bra @recall_history
0001D6r 3               
0001D6r 3               @ctrl_p_dec:
0001D6r 3                               ; It's safe to decrement the buffer index directly.
0001D6r 3  C6 20                        dec status
0001D8r 3  80 0D                        bra @recall_history
0001DAr 3               
0001DAr 3               @ctrl_n:
0001DAr 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
0001DAr 3                               ; the next buffer Check bit 3. If it's set, this is the first
0001DAr 3                               ; time CTRL-n has been pressed and we should select the CURRENT
0001DAr 3                               ; history buffer.
0001DAr 3  A9 08                        lda #$8
0001DCr 3  24 20                        bit status
0001DEr 3  D0 07                        bne @recall_history
0001E0r 3               
0001E0r 3                               ; This isn't the first time CTRL-n has been pressed, select the
0001E0r 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
0001E0r 3  A5 20                        lda status
0001E2r 3  29 F7                        and #$f7
0001E4r 3               
0001E4r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
0001E4r 3  1A                           inc
0001E5r 3               
0001E5r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
0001E5r 3                               ; be cleared below.
0001E5r 3  85 20                        sta status
0001E7r 3               
0001E7r 3                               ; Falls through to @recall_history
0001E7r 3               
0001E7r 3               @recall_history:
0001E7r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
0001E7r 3  A9 08                        lda #%00001000
0001E9r 3  14 20                        trb status
0001EBr 3               
0001EBr 3  20 rr rr                     jsr total_recall
0001EEr 3               
0001EEr 3                               ; tmp3 now has the address of the previous history buffer.
0001EEr 3                               ; First byte of buffer is length. Clear the line by sending
0001EEr 3                               ; CR, Y spaces, then CR.
0001EEr 3  A9 0D                        lda #AscCR
0001F0r 3  20 rr rr                     jsr emit_a
0001F3r 3               
0001F3r 3               input_clear:
0001F3r 3  C0 00                        cpy #0
0001F5r 3  F0 08                        beq input_cleared
0001F7r 3               
0001F7r 3  A9 20                        lda #AscSP
0001F9r 3  20 rr rr                     jsr emit_a
0001FCr 3  88                           dey
0001FDr 3  80 F4                        bra input_clear
0001FFr 3               
0001FFr 3               input_cleared:
0001FFr 3  A9 0D                        lda #AscCR
000201r 3  20 rr rr                     jsr emit_a
000204r 3               
000204r 3                               ; Save the history length byte into histinfo+1
000204r 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000204r 3  B1 28                        lda (tmp3),y
000206r 3  85 21                        sta status+1
000208r 3               
000208r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000208r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000208r 3                               ; buffer)
000208r 3  E6 28                        inc tmp3
00020Ar 3  D0 02                        bne @2           ; Increment the upper byte on carry.
00020Cr 3  E6 29                        inc tmp3+1
00020Er 3               @2:
00020Er 3                               ; Copy the history buffer into the input buffer,
00020Er 3                               ; sending the characters to the output as we go.
00020Er 3  A9 0D                        lda #AscCR
000210r 3  20 rr rr                     jsr emit_a
000213r 3               
000213r 3               @history_loop:
000213r 3                               ; See if we have reached the end of the history buffer.
000213r 3  C4 21                        cpy status+1
000215r 3  D0 03                        bne @3
000217r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
00021Ar 3               @3:
00021Ar 3                               ; See if we have reached the end of the input buffer.
00021Ar 3                               ; (only comparing to lower byte as we currently limit
00021Ar 3                               ; to 255 characters max)
00021Ar 3  C4 26                        cpy tmp2
00021Cr 3  F0 0A                        beq @hist_filled_buffer
00021Er 3               
00021Er 3                               ; Copy a character and echo.
00021Er 3  B1 28                        lda (tmp3),y
000220r 3  91 24                        sta (tmp1),y
000222r 3  20 rr rr                     jsr emit_a
000225r 3               
000225r 3                               ; Move to the next character.
000225r 3  C8                           iny
000226r 3  80 EB                        bra @history_loop
000228r 3               
000228r 3               @hist_filled_buffer:
000228r 3                               ; We don't want a history recall to EOL our buffer,
000228r 3                               ; so back up one character and return to editing.
000228r 3  88                           dey
000229r 3  4C rr rr                     jmp accept_loop
00022Cr 3               accept_done:
00022Cr 3               @done:
00022Cr 3                               ; Copy the input buffer into the currently
00022Cr 3                               ; selected history buffer.
00022Cr 3  20 rr rr                     jsr total_recall
00022Fr 3  85 21                        sta status+1
000231r 3               
000231r 3                               ; Also save it in the first buffer byte.
000231r 3  A0 00                        ldy #0
000233r 3  91 28                        sta (tmp3),y
000235r 3               
000235r 3                               ; Move path the count to the data bytes
000235r 3  E6 28                        inc tmp3
000237r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000239r 3  E6 29                        inc tmp3+1
00023Br 3               @4:
00023Br 3                               ; Copy the characters from the input buffer to the
00023Br 3                               ; history buffer.
00023Br 3               
00023Br 3               @save_history_loop:
00023Br 3  C4 21                        cpy status+1
00023Dr 3  F0 07                        beq @save_history_done
00023Fr 3               
00023Fr 3  B1 24                        lda (tmp1),y
000241r 3  91 28                        sta (tmp3),y
000243r 3  C8                           iny
000244r 3  80 F5                        bra @save_history_loop
000246r 3               
000246r 3               @save_history_done:
000246r 3               z_accept:
000246r 3  60                           rts
000247r 3               
000247r 3               total_recall:
000247r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000247r 3               
000247r 3                               ; Generate the address of the buffer in tmp3. Start with the
000247r 3                               ; base address.
000247r 3  A9 00                        lda #<hist_buff
000249r 3  85 28                        sta tmp3
00024Br 3  A9 7C                        lda #>hist_buff
00024Dr 3  85 29                        sta tmp3+1
00024Fr 3               
00024Fr 3                               ; This is a bit annoying as some bits go into each byte.
00024Fr 3                               ; .....xxx gets put into address like ......xx x.......
00024Fr 3  A5 20                        lda status
000251r 3  6A                           ror
000252r 3  29 03                        and #3
000254r 3  18                           clc
000255r 3  65 29                        adc tmp3+1
000257r 3  85 29                        sta tmp3+1
000259r 3               
000259r 3  A5 20                        lda status
00025Br 3  6A                           ror             ; Rotate through carry into msb.
00025Cr 3  6A                           ror
00025Dr 3  29 80                        and #$80
00025Fr 3  18                           clc
000260r 3  65 28                        adc tmp3
000262r 3  85 28                        sta tmp3
000264r 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000266r 3  E6 29                        inc tmp3+1
000268r 3               @1:
000268r 3                               ; Save the current length of the input buffer in
000268r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000268r 3  98                           tya
000269r 3  C9 80                        cmp #$80
00026Br 3  90 02                        bcc @2
00026Dr 3  A9 7F                        lda #$7F
00026Fr 3               @2:
00026Fr 3  60                           rts
000270r 3               
000270r 3               
000270r 3               
000270r 3               
000270r 3               
000270r 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000270r 3               ; ## "action-of"  auto  ANS core ext
000270r 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000270r 3               
000270r 3               xt_action_of:
000270r 3                               ; This is a state aware word with differet behavior
000270r 3                               ; when used while compiling vs interpreting.
000270r 3                               ; Check STATE
000270r 3  A5 16                        lda state
000272r 3  05 17                        ora state+1
000274r 3  F0 0C                        beq @interpreting
000276r 3               
000276r 3               @compiling:
000276r 3                               ; Run ['] to compile the xt of the next word
000276r 3                               ; as a literal.
000276r 3  20 rr rr                     jsr xt_bracket_tick
000279r 3               
000279r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000279r 3  A0 rr                        ldy #>xt_defer_fetch
00027Br 3  A9 rr                        lda #<xt_defer_fetch
00027Dr 3  20 rr rr                     jsr cmpl_subroutine
000280r 3  80 06                        bra @done
000282r 3               
000282r 3               @interpreting:
000282r 3  20 rr rr                     jsr xt_tick
000285r 3  20 rr rr                     jsr xt_defer_fetch
000288r 3               
000288r 3               @done:
000288r 3  60           z_action_of:           rts
000289r 3               
000289r 3               
000289r 3               
000289r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000289r 3               ; ## "again"  tested  ANS core ext
000289r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000289r 3               
000289r 3               xt_again:
000289r 3  20 rr rr                     jsr underflow_1
00028Cr 3               
00028Cr 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
00028Cr 3                               ; so we have the range and don't have to calculate the
00028Cr 3                               ; offset.
00028Cr 3  A0 00                        ldy #0
00028Er 3  A9 4C                        lda #$4C        ; JMP
000290r 3  91 00                        sta (cp),y
000292r 3  C8                           iny
000293r 3               
000293r 3  B5 00                        lda 0,x         ; LSB of address
000295r 3  91 00                        sta (cp),y
000297r 3  C8                           iny
000298r 3               
000298r 3  B5 01                        lda 1,x         ; MSB of address
00029Ar 3  91 00                        sta (cp),y
00029Cr 3  C8                           iny
00029Dr 3               
00029Dr 3                               ; Allot the space we just used
00029Dr 3  98                           tya
00029Er 3  18                           clc
00029Fr 3  65 00                        adc cp
0002A1r 3  85 00                        sta cp
0002A3r 3  90 02                        bcc @done
0002A5r 3  E6 01                        inc cp+1
0002A7r 3               @done:
0002A7r 3  E8                           inx
0002A8r 3  E8                           inx
0002A9r 3               
0002A9r 3  60           z_again:        rts
0002AAr 3               
0002AAr 3               
0002AAr 3               
0002AAr 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
0002AAr 3               ; ## "align"  auto  ANS core
0002AAr 3                       ; """https://forth-standard.org/standard/core/ALIGN
0002AAr 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
0002AAr 3                       ; routine as well, and also does nothing
0002AAr 3                       ; """
0002AAr 3               
0002AAr 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
0002AAr 3               ; ## "aligned"  auto  ANS core
0002AAr 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
0002AAr 3               
0002AAr 3               xt_align:
0002AAr 3               xt_aligned:
0002AAr 3               z_align:
0002AAr 3  60           z_aligned:      rts             ; stripped out during native compile
0002ABr 3               
0002ABr 3               
0002ABr 3               
0002ABr 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
0002ABr 3               ; ## "allot"  auto  ANS core
0002ABr 3                       ; """https://forth-standard.org/standard/core/ALLOT
0002ABr 3                       ; Reserve a certain number of bytes (not cells) or release them.
0002ABr 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
0002ABr 3                       ; to the beginning of the Dictionary. If n is positive (the most
0002ABr 3                       ; common case), reserve n bytes, but not past the end of the
0002ABr 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
0002ABr 3                       ; """
0002ABr 3               
0002ABr 3               xt_allot:
0002ABr 3  20 rr rr                     jsr underflow_1
0002AEr 3               
0002AEr 3                               ; Releasing memory is going to be a very rare operation,
0002AEr 3                               ; so we check for it at the beginning and try to make
0002AEr 3                               ; the most common case as fast as possible
0002AEr 3  B5 01                        lda 1,x
0002B0r 3  30 22                        bmi @release
0002B2r 3               
0002B2r 3                               ; Common case: We are reserving memory, not releasing it
0002B2r 3  18                           clc
0002B3r 3  A5 00                        lda cp
0002B5r 3  75 00                        adc 0,x
0002B7r 3  85 00                        sta cp
0002B9r 3               
0002B9r 3  A5 01                        lda cp+1
0002BBr 3  75 01                        adc 1,x
0002BDr 3  85 01                        sta cp+1
0002BFr 3               
0002BFr 3                               ; Wait, did we just grant more space than we have? This is
0002BFr 3                               ; a check we only do here, not for other situations like cmpl_a
0002BFr 3                               ; where smaller amounts are reserved.
0002BFr 3  A0 FD                        ldy #<cp_end
0002C1r 3  C4 00                        cpy cp
0002C3r 3  A9 77                        lda #>cp_end
0002C5r 3  E5 01                        sbc cp+1
0002C7r 3  B0 48                        bcs @done               ; we're fine.
0002C9r 3               
0002C9r 3                               ; Oops, that was too much, we're beyond the end of
0002C9r 3                               ; legal Dictionary RAM. Reduce to max memory and report
0002C9r 3                               ; an error
0002C9r 3  84 00                        sty cp                  ; still #<cp_end
0002CBr 3  A9 77                        lda #>cp_end
0002CDr 3  85 01                        sta cp+1
0002CFr 3               
0002CFr 3  A9 00                        lda #err_allot
0002D1r 3  4C rr rr                     jmp error
0002D4r 3               
0002D4r 3               @release:
0002D4r 3                  		; The ANS standard doesn't really say what to do if too much
0002D4r 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
0002D4r 3                               ; even an official test. Gforth is little help either. The good
0002D4r 3                               ; news is, this is going to be a rare case. We want to use as
0002D4r 3                               ; few bytes as possible.
0002D4r 3               
0002D4r 3                               ; What we do is let the user free anything up to the beginning
0002D4r 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
0002D4r 3                               ; their own risk. This means that the Dictionary pointer DP
0002D4r 3                               ; might end up pointing to garbage. However, an attempt to
0002D4r 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
0002D4r 3                               ; the DP pointing to the last word in RAM (should be DROP) and
0002D4r 3                               ; an error message.
0002D4r 3               
0002D4r 3                               ; We arrive here with ( n ) which is negative. First step,
0002D4r 3                               ; subtract the number TOS from the CP for a new CP
0002D4r 3  CA                           dex
0002D5r 3  CA                           dex
0002D6r 3  A5 00                        lda cp
0002D8r 3  95 00                        sta 0,x
0002DAr 3  A5 01                        lda cp+1
0002DCr 3  95 01                        sta 1,x
0002DEr 3               
0002DEr 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
0002E1r 3               
0002E1r 3                               ; Second step, see if we've gone too far. We compare the new
0002E1r 3                               ; CP on TOS (which, if we've really screwed up, might be
0002E1r 3                               ; negative) with CP0. This is a signed comparison
0002E1r 3  CA                           dex
0002E2r 3  CA                           dex                             ; new CP now NOS
0002E3r 3  A9 FF                        lda #<cp0
0002E5r 3  95 00                        sta 0,x
0002E7r 3  A9 02                        lda #>cp0
0002E9r 3  95 01                        sta 1,x                         ; CP0 is TOS
0002EBr 3               
0002EBr 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
0002EEr 3               
0002EEr 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
0002EEr 3                               ; This means we want Z=1 or N=1
0002EEr 3  F0 17                        beq @nega_done
0002F0r 3  30 15                        bmi @nega_done
0002F2r 3               
0002F2r 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
0002F2r 3                               ; word in ROM (should be DROP), and abort with an error
0002F2r 3  A9 FF                        lda #<cp0
0002F4r 3  85 00                        sta cp
0002F6r 3  A9 02                        lda #>cp0
0002F8r 3  85 01                        sta cp+1
0002FAr 3               
0002FAr 3  A9 rr                        lda #<dictionary_start
0002FCr 3  85 02                        sta dp
0002FEr 3  A9 rr                        lda #>dictionary_start
000300r 3  85 03                        sta dp+1
000302r 3               
000302r 3  A9 0A                        lda #err_negallot
000304r 3  4C rr rr                     jmp error
000307r 3               
000307r 3               @nega_done:
000307r 3                               ; Save new CP, which is NOS
000307r 3  B5 02                        lda 2,x
000309r 3  85 00                        sta cp
00030Br 3  B5 03                        lda 3,x
00030Dr 3  85 01                        sta cp+1
00030Fr 3               
00030Fr 3  E8                           inx
000310r 3  E8                           inx                     ; drop through to @done
000311r 3               @done:
000311r 3  E8                           inx
000312r 3  E8                           inx
000313r 3               z_allot:
000313r 3  60                           rts
000314r 3               
000314r 3               
000314r 3               
000314r 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000314r 3               ; ## "allow-native"  auto  Tali Forth
000314r 3               xt_allow_native:
000314r 3  20 rr rr                     jsr current_to_dp
000317r 3  A0 01                        ldy #1          ; offset for status byte
000319r 3  B1 02                        lda (dp),y
00031Br 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
00031Dr 3  91 02                        sta (dp),y
00031Fr 3               z_allow_native:
00031Fr 3  60                           rts
000320r 3               
000320r 3               
000320r 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000320r 3               ; ## "also"  auto  ANS search ext
000320r 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000320r 3               xt_also:
000320r 3  20 rr rr                     jsr xt_get_order
000323r 3  20 rr rr                     jsr xt_over
000326r 3  20 rr rr                     jsr xt_swap
000329r 3  20 rr rr                     jsr xt_one_plus
00032Cr 3  20 rr rr                     jsr xt_set_order
00032Fr 3               
00032Fr 3  60           z_also:         rts
000330r 3               
000330r 3               
000330r 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000330r 3               ; ## "always-native"  auto  Tali Forth
000330r 3               xt_always_native:
000330r 3  20 rr rr                     jsr current_to_dp
000333r 3  A0 01                        ldy #1          ; offset for status byte
000335r 3  B1 02                        lda (dp),y
000337r 3  09 02                        ora #AN         ; Make sure AN flag is set
000339r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
00033Br 3  91 02                        sta (dp),y
00033Dr 3               z_always_native:
00033Dr 3  60                           rts
00033Er 3               
00033Er 3               
00033Er 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
00033Er 3               ; ## "and"  auto  ANS core
00033Er 3                       ; """https://forth-standard.org/standard/core/AND"""
00033Er 3               xt_and:
00033Er 3  20 rr rr                     jsr underflow_2
000341r 3               
000341r 3  B5 00                        lda 0,x
000343r 3  35 02                        and 2,x
000345r 3  95 02                        sta 2,x
000347r 3               
000347r 3  B5 01                        lda 1,x
000349r 3  35 03                        and 3,x
00034Br 3  95 03                        sta 3,x
00034Dr 3               
00034Dr 3  E8                           inx
00034Er 3  E8                           inx
00034Fr 3               
00034Fr 3  60           z_and:          rts
000350r 3               
000350r 3               
000350r 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000350r 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000350r 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000350r 3                       ; assembler words to the search order so they can be used.
000350r 3                       ; See the tutorial on Wordlists and the Search Order for
000350r 3                       ; more information.
000350r 3                       ;
000350r 3                       ; This is a dummy entry, the code is shared with TWO
000350r 3                       ; """
000350r 3               
000350r 3               
000350r 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000350r 3               ; ## "at-xy"  tested  ANS facility
000350r 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000350r 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000350r 3                       ; ANSI code is ESC[<n>;<m>H
000350r 3                       ;
000350r 3                       ; Do not use U. to print the numbers because the
000350r 3                       ; trailing space will not work with xterm
000350r 3                       ; """
000350r 3               xt_at_xy:
000350r 3  20 rr rr                     jsr underflow_2
000353r 3               
000353r 3  A9 1B                        lda #AscESC
000355r 3  20 rr rr                     jsr emit_a
000358r 3  A9 5B                        lda #$5B        ; ASCII for "["
00035Ar 3  20 rr rr                     jsr emit_a
00035Dr 3  20 rr rr                     jsr print_u
000360r 3  A9 3B                        lda #$3B        ; ASCII for ";"
000362r 3  20 rr rr                     jsr emit_a
000365r 3  20 rr rr                     jsr print_u
000368r 3  A9 48                        lda #'H'
00036Ar 3  20 rr rr                     jsr emit_a
00036Dr 3               
00036Dr 3  60           z_at_xy:        rts
00036Er 3               
00036Er 3               
00036Er 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
00036Er 3               ; ## "\"  auto  ANS core ext
00036Er 3                       ; """https://forth-standard.org/standard/core/bs"""
00036Er 3               xt_backslash:
00036Er 3  A5 0A                        lda ciblen
000370r 3  85 0C                        sta toin
000372r 3  A5 0B                        lda ciblen+1
000374r 3  85 0D                        sta toin+1
000376r 3               
000376r 3  60           z_backslash:    rts
000377r 3               
000377r 3               
000377r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000377r 3               ; ## "base"  auto  ANS core
000377r 3                       ; """https://forth-standard.org/standard/core/BASE
000377r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000377r 3                       ; ingore the MSB
000377r 3                       ; """
000377r 3               xt_base:
000377r 3  CA                           dex
000378r 3  CA                           dex
000379r 3  A9 18                        lda #<base
00037Br 3  95 00                        sta 0,x         ; LSB
00037Dr 3  74 01                        stz 1,x         ; MSB is always 0
00037Fr 3               
00037Fr 3  60           z_base:         rts
000380r 3               
000380r 3               
000380r 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000380r 3               ; ## "begin"  auto  ANS core
000380r 3                       ; """https://forth-standard.org/standard/core/BEGIN
000380r 3                       ;
000380r 3                       ; This is just an immediate version of here which could just
000380r 3                       ; as well be coded in Forth as
000380r 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000380r 3                       ; Since this is a compiling word, we don't care that much about
000380r 3                       ; about speed
000380r 3                       ; """
000380r 3               
000380r 3               xt_begin:
000380r 3  20 rr rr                     jsr xt_here
000383r 3  60           z_begin:        rts
000384r 3               
000384r 3               
000384r 3               
000384r 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000384r 3               ; ## "bell"  tested  Tali Forth
000384r 3               xt_bell:
000384r 3  A9 07                        lda #7          ; ASCII value for BELl
000386r 3  20 rr rr                     jsr emit_a
000389r 3               
000389r 3  60           z_bell:         rts
00038Ar 3               
00038Ar 3               
00038Ar 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
00038Ar 3               ; ## "bl"  auto  ANS core
00038Ar 3                       ; """https://forth-standard.org/standard/core/BL"""
00038Ar 3               
00038Ar 3               xt_bl:
00038Ar 3  CA                           dex
00038Br 3  CA                           dex
00038Cr 3  A9 20                        lda #AscSP
00038Er 3  95 00                        sta 0,x
000390r 3  74 01                        stz 1,x
000392r 3               
000392r 3  60           z_bl:           rts
000393r 3               
000393r 3               
000393r 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000393r 3               ; ## "block"  auto  ANS block
000393r 3                       ; """https://forth-standard.org/standard/block/BLK"""
000393r 3               xt_blk:
000393r 3                               ; BLK is at UP + blk_offset
000393r 3  CA                           dex
000394r 3  CA                           dex
000395r 3  18                           clc
000396r 3  A5 1E                        lda up
000398r 3  69 00                        adc #blk_offset ; Add offset
00039Ar 3  95 00                        sta 0,x
00039Cr 3  A5 1F                        lda up+1
00039Er 3  69 00                        adc #0          ; Adding carry
0003A0r 3  95 01                        sta 1,x
0003A2r 3               
0003A2r 3  60           z_blk:          rts
0003A3r 3               
0003A3r 3               
0003A3r 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
0003A3r 3               ; ## "blkbuffer"  auto  Tali block
0003A3r 3               xt_blkbuffer:
0003A3r 3                               ; blkbuffer address is at UP + blkbuffer_offset.
0003A3r 3                               ; Unlike some of the other user variables, we actually
0003A3r 3                               ; want to push the address stored here, which will
0003A3r 3                               ; point to somewhere outside of the user variables.
0003A3r 3  CA                           dex
0003A4r 3  CA                           dex
0003A5r 3                               ; Put the address on the stack.
0003A5r 3  A0 28                        ldy #blkbuffer_offset
0003A7r 3  B1 1E                        lda (up),y
0003A9r 3  95 00                        sta 0,x
0003ABr 3  C8                           iny             ; Move along to the next byte
0003ACr 3  B1 1E                        lda (up),y
0003AEr 3  95 01                        sta 1,x
0003B0r 3               
0003B0r 3  60           z_blkbuffer:    rts
0003B1r 3               
0003B1r 3               
0003B1r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
0003B1r 3               ; ## "block"  auto  ANS block
0003B1r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
0003B1r 3               
0003B1r 3               xt_block:
0003B1r 3               
0003B1r 3                               ; See if the block requested is the same as the one we
0003B1r 3                               ; currently have in the buffer. Check the LSB.
0003B1r 3  A0 2A                        ldy #buffblocknum_offset
0003B3r 3  B1 1E                        lda (up),y
0003B5r 3  D5 00                        cmp 0,x
0003B7r 3  D0 0F                        bne @not_in_buffer
0003B9r 3               
0003B9r 3                               ; Check the MSB.
0003B9r 3  C8                           iny
0003BAr 3  B1 1E                        lda (up),y
0003BCr 3  D5 01                        cmp 1,x
0003BEr 3  D0 08                        bne @not_in_buffer
0003C0r 3               
0003C0r 3                               ; The block is in the buffer. See if the buffer is in use.
0003C0r 3  A0 2C                        ldy #buffstatus_offset
0003C2r 3  B1 1E                        lda (up),y
0003C4r 3  29 01                        and #1          ; Check the in-use flag (bit 0)
0003C6r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
0003C8r 3                                               ; @done will replace the block# with the
0003C8r 3                                               ; buffer address.
0003C8r 3               @not_in_buffer:
0003C8r 3                               ; Check the buffer status
0003C8r 3  A0 2C                        ldy #buffstatus_offset
0003CAr 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
0003CCr 3  C9 03                        cmp #3          ; LSB is needed.
0003CEr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
0003D0r 3               
0003D0r 3                               ; We need to save the block.
0003D0r 3  20 rr rr                     jsr xt_blkbuffer
0003D3r 3  20 rr rr                     jsr xt_buffblocknum
0003D6r 3  20 rr rr                     jsr xt_fetch
0003D9r 3  20 rr rr                     jsr xt_block_write
0003DCr 3               
0003DCr 3               @buffer_available:
0003DCr 3                               ; Save the block number.
0003DCr 3  A0 2A                        ldy #buffblocknum_offset
0003DEr 3  B5 00                        lda 0,x
0003E0r 3  91 1E                        sta (up),y
0003E2r 3  C8                           iny
0003E3r 3  B5 01                        lda 1,x
0003E5r 3  91 1E                        sta (up),y
0003E7r 3               
0003E7r 3                               ; Get the requested block.
0003E7r 3  20 rr rr                     jsr xt_blkbuffer
0003EAr 3  20 rr rr                     jsr xt_swap
0003EDr 3  20 rr rr                     jsr xt_block_read
0003F0r 3               
0003F0r 3                               ; Mark the buffer as clean and in-use.
0003F0r 3  A9 01                        lda #1
0003F2r 3  A0 2C                        ldy #buffstatus_offset
0003F4r 3  91 1E                        sta (up),y
0003F6r 3               
0003F6r 3                               ; Make room on the stack for the return address.
0003F6r 3  CA                           dex
0003F7r 3  CA                           dex
0003F8r 3               
0003F8r 3               @done:
0003F8r 3                               ; It's in the buffer. Return the buffer address.
0003F8r 3  A0 28                        ldy #blkbuffer_offset
0003FAr 3  B1 1E                        lda (up),y
0003FCr 3  95 00                        sta 0,x
0003FEr 3  C8                           iny
0003FFr 3  B1 1E                        lda (up),y
000401r 3  95 01                        sta 1,x
000403r 3               
000403r 3  60           z_block:        rts
000404r 3               
000404r 3               
000404r 3               
000404r 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000404r 3               ; ## "block-ramdrive-init"  auto  Tali block
000404r 3                       ; """Create a RAM drive, with the given number of
000404r 3                       ; blocks, in the dictionary along with setting up the block words to
000404r 3                       ; use it.  The read/write routines do not provide bounds checking.
000404r 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000404r 3                       ; """
000404r 3               
000404r 3               xt_block_ramdrive_init:
000404r 3  20 rr rr                     jsr underflow_1
000407r 3               
000407r 3                               ; Store the string to run here as a string literal.
000407r 3                               ; See SLITERAL for the format information. This way, we
000407r 3                               ; don't have the words defined below in the Dictionary until
000407r 3                               ; we really use them.
000407r 3  4C rr rr                     jmp @after_ramdrive_code
00040Ar 3               
00040Ar 3               @ramdrive_code:
00040Ar 3  62 61 73 65          .byte "base @ swap decimal"
00040Er 3  20 40 20 73  
000412r 3  77 61 70 20  
00041Dr 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000421r 3  34 20 2A     
000424r 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000428r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
00042Cr 3  66 65 72 3A  
000430r 3  20 72 61 6D  
000439r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000439r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
00043Dr 3  6C 6F 63 6B  
000441r 3  2D 72 65 61  
00044Fr 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000453r 3  64 72 69 76  
000457r 3  65 20 73 77  
000477r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
00047Br 3  6C 6F 63 6B  
00047Fr 3  2D 77 72 69  
00048Er 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000492r 3  64 72 69 76  
000496r 3  65 20 73 77  
0004B1r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
0004B5r 3  6C 6F 63 6B  
0004B9r 3  2D 72 65 61  
0004DBr 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
0004DFr 3  6C 6F 63 6B  
0004E3r 3  2D 77 72 69  
000507r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
00050Br 3  64 72 69 76  
00050Fr 3  65 20 73 77  
000522r 3               
000522r 3               @after_ramdrive_code:
000522r 3  20 rr rr                     jsr sliteral_runtime
000525r 3               
000525r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000529r 3               
000529r 3                               ; The address and length of the ramdrive code is now on the
000529r 3                               ; stack. Call EVALUATE to run it.
000529r 3  20 rr rr                     jsr xt_evaluate
00052Cr 3               
00052Cr 3               z_block_ramdrive_init:
00052Cr 3  60                           rts
00052Dr 3               
00052Dr 3               
00052Dr 3               
00052Dr 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
00052Dr 3               ; ## "block-read"  auto  Tali block
00052Dr 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00052Dr 3                       ; with their own version to read a block from storage.
00052Dr 3                       ; The stack parameters are ( buffer_address block# -- ).
00052Dr 3                       ; """
00052Dr 3               xt_block_read:
00052Dr 3                               ; Execute the BLOCK-READ-VECTOR
00052Dr 3  A0 2E                        ldy #blockread_offset
00052Fr 3  B1 1E                        lda (up),y
000531r 3  85 24                        sta tmp1
000533r 3  C8                           iny
000534r 3  B1 1E                        lda (up),y
000536r 3  85 25                        sta tmp1+1
000538r 3               
000538r 3  6C 24 00                     jmp (tmp1)
00053Br 3               
00053Br 3               z_block_read:   ; No RTS needed
00053Br 3               
00053Br 3               
00053Br 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
00053Br 3               ; ## "block-read-vector"  auto  Tali block
00053Br 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00053Br 3                       ; with their own version to read a block from storage.
00053Br 3                       ; This word gives the address of the vector so it can be replaced.
00053Br 3                       ; """
00053Br 3               xt_block_read_vector:
00053Br 3                               ; Get the BLOCK-READ-VECTOR address
00053Br 3  CA                           dex
00053Cr 3  CA                           dex
00053Dr 3  18                           clc
00053Er 3  A5 1E                        lda up
000540r 3  69 2E                        adc #blockread_offset
000542r 3  95 00                        sta 0,x
000544r 3  A5 1F                        lda up+1
000546r 3  69 00                        adc #0          ; Add carry
000548r 3  95 01                        sta 1,x
00054Ar 3               
00054Ar 3               z_block_read_vector:
00054Ar 3  60                           rts
00054Br 3               
00054Br 3               
00054Br 3               ; This is the default error message the vectored words BLOCK-READ and
00054Br 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
00054Br 3               xt_block_word_error:
00054Br 3  A9 0C                        lda #err_blockwords
00054Dr 3  4C rr rr                     jmp error       ; no RTS needed
000550r 3               z_block_word_error:
000550r 3               
000550r 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000550r 3               ; ## "block-write"  auto  Tali block
000550r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000550r 3                       ; with their own version to write a block to storage.
000550r 3                       ; The stack parameters are ( buffer_address block# -- ).
000550r 3                       ; """
000550r 3               xt_block_write:
000550r 3                               ; Execute the BLOCK-READ-VECTOR
000550r 3  A0 30                        ldy #blockwrite_offset
000552r 3  B1 1E                        lda (up),y
000554r 3  85 24                        sta tmp1
000556r 3  C8                           iny
000557r 3  B1 1E                        lda (up),y
000559r 3  85 25                        sta tmp1+1
00055Br 3  6C 24 00                     jmp (tmp1)
00055Er 3               
00055Er 3               z_block_write:  ; No RTS needed
00055Er 3               
00055Er 3               
00055Er 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
00055Er 3               ; ## "block-write-vector"  auto  Tali block
00055Er 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
00055Er 3                       ; with their own version to write a block to storage.
00055Er 3                       ; This word gives the address of the vector so it can be replaced.
00055Er 3                       ; """
00055Er 3               xt_block_write_vector:
00055Er 3                               ; Get the BLOCK-WRITE-VECTOR address
00055Er 3  CA                           dex
00055Fr 3  CA                           dex
000560r 3  18                           clc
000561r 3  A5 1E                        lda up
000563r 3  69 30                        adc #blockwrite_offset
000565r 3  95 00                        sta 0,x
000567r 3  A5 1F                        lda up+1
000569r 3  69 00                        adc #0          ; Add carry
00056Br 3  95 01                        sta 1,x
00056Dr 3               
00056Dr 3               z_block_write_vector:
00056Dr 3  60                           rts
00056Er 3               
00056Er 3               
00056Er 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
00056Er 3               ; ## "bounds"  auto  Gforth
00056Er 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
00056Er 3                       ; Given a string, return the correct Data Stack parameters for
00056Er 3                       ; a DO/LOOP loop over its characters. This is realized as
00056Er 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
00056Er 3                       ; """
00056Er 3               xt_bounds:
00056Er 3  20 rr rr                     jsr underflow_2
000571r 3               
000571r 3  18                           clc
000572r 3  B5 00                        lda 0,x                 ; LSB u
000574r 3  B4 02                        ldy 2,x                 ; LSB addr
000576r 3  75 02                        adc 2,x
000578r 3  95 02                        sta 2,x                 ; LSB addr+u
00057Ar 3  94 00                        sty 0,x
00057Cr 3               
00057Cr 3  B5 01                        lda 1,x                 ; MSB u
00057Er 3  B4 03                        ldy 3,x                 ; MSB addr
000580r 3  75 03                        adc 3,x
000582r 3  95 03                        sta 3,x                 ; MSB addr+u
000584r 3  94 01                        sty 1,x
000586r 3               
000586r 3  60           z_bounds:       rts
000587r 3               
000587r 3               
000587r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000587r 3               ; ## "[char]"  auto  ANS core
000587r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000587r 3                       ; Compile the ASCII value of a character as a literal. This is an
000587r 3                       ; immediate, compile-only word.
000587r 3                       ;
000587r 3                       ; A definition given in
000587r 3                       ; http://forth-standard.org/standard/implement is
000587r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000587r 3                       ; """
000587r 3               xt_bracket_char:
000587r 3  20 rr rr                     jsr xt_char
00058Ar 3  20 rr rr                     jsr xt_literal
00058Dr 3  60           z_bracket_char: rts
00058Er 3               
00058Er 3               
00058Er 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
00058Er 3               ; ## "[']"  auto  ANS core
00058Er 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
00058Er 3               xt_bracket_tick:
00058Er 3  20 rr rr                     jsr xt_tick
000591r 3  20 rr rr                     jsr xt_literal
000594r 3  60           z_bracket_tick: rts
000595r 3               
000595r 3               
000595r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000595r 3               ; ## "buffblocknum"  auto  Tali block
000595r 3               xt_buffblocknum:
000595r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000595r 3  CA                           dex
000596r 3  CA                           dex
000597r 3  18                           clc
000598r 3  A5 1E                        lda up
00059Ar 3  69 2A                        adc #buffblocknum_offset        ; Add offset
00059Cr 3  95 00                        sta 0,x
00059Er 3  A5 1F                        lda up+1
0005A0r 3  69 00                        adc #0                          ; Adding carry
0005A2r 3  95 01                        sta 1,x
0005A4r 3               
0005A4r 3  60           z_buffblocknum: rts
0005A5r 3               
0005A5r 3               
0005A5r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
0005A5r 3               ; ## "buffer"  auto  ANS block
0005A5r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
0005A5r 3               
0005A5r 3               xt_buffer:
0005A5r 3                               ; Check the buffer status
0005A5r 3  A0 2C                        ldy #buffstatus_offset
0005A7r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
0005A9r 3  C9 03                        cmp #3          ; LSB is needed.
0005ABr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
0005ADr 3               
0005ADr 3                               ; We need to save the block.
0005ADr 3  20 rr rr                     jsr xt_blkbuffer
0005B0r 3  20 rr rr                     jsr xt_buffblocknum
0005B3r 3  20 rr rr                     jsr xt_fetch
0005B6r 3  20 rr rr                     jsr xt_block_write
0005B9r 3               
0005B9r 3               @buffer_available:
0005B9r 3                               ; Save the block number.
0005B9r 3  A0 2A                        ldy #buffblocknum_offset
0005BBr 3  B5 00                        lda 0,x
0005BDr 3  91 1E                        sta (up),y
0005BFr 3  C8                           iny
0005C0r 3  B5 01                        lda 1,x
0005C2r 3  91 1E                        sta (up),y
0005C4r 3               
0005C4r 3                               ; Mark the buffer as clean and in-use.
0005C4r 3  A9 01                        lda #1
0005C6r 3  A0 2C                        ldy #buffstatus_offset
0005C8r 3  91 1E                        sta (up),y
0005CAr 3               
0005CAr 3               @done:
0005CAr 3                               ; Return the buffer address.
0005CAr 3  A0 28                        ldy #blkbuffer_offset
0005CCr 3  B1 1E                        lda (up),y
0005CEr 3  95 00                        sta 0,x
0005D0r 3  C8                           iny
0005D1r 3  B1 1E                        lda (up),y
0005D3r 3  95 01                        sta 1,x
0005D5r 3               
0005D5r 3  60           z_buffer:       rts
0005D6r 3               
0005D6r 3               
0005D6r 3               
0005D6r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
0005D6r 3               ; ## "buffer:"  auto  ANS core ext
0005D6r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
0005D6r 3                               ; Create a buffer of size u that puts its address on the stack
0005D6r 3                               ; when its name is used.
0005D6r 3                               ; """
0005D6r 3               xt_buffer_colon:
0005D6r 3  20 rr rr                     jsr xt_create
0005D9r 3  20 rr rr                     jsr xt_allot
0005DCr 3  60           z_buffer_colon: rts
0005DDr 3               
0005DDr 3               
0005DDr 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
0005DDr 3               ; ## "buffstatus"  auto  Tali block
0005DDr 3               xt_buffstatus:
0005DDr 3                               ; BUFFSTATUS is at UP + buffstatus_offset
0005DDr 3  CA                           dex
0005DEr 3  CA                           dex
0005DFr 3  18                           clc
0005E0r 3  A5 1E                        lda up
0005E2r 3  69 2C                        adc #buffstatus_offset  ; Add offset
0005E4r 3  95 00                        sta 0,x
0005E6r 3  A5 1F                        lda up+1
0005E8r 3  69 00                        adc #0                  ; Adding carry
0005EAr 3  95 01                        sta 1,x
0005ECr 3               
0005ECr 3  60           z_buffstatus:   rts
0005EDr 3               
0005EDr 3               
0005EDr 3               ; ## BYE ( -- ) "Break"
0005EDr 3               ; ## "bye"  tested  ANS tools ext
0005EDr 3                       ; """https://forth-standard.org/standard/tools/BYE"""
0005EDr 3               
0005EDr 3               xt_bye:
0005EDr 3                               ;brk
0005EDr 3  4C rr rr                     jmp platform_bye
0005F0r 3               z_bye:          ;rts             ; never reached
0005F0r 3               
0005F0r 3               
0005F0r 3               
0005F0r 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
0005F0r 3               ; ## "c,"  auto  ANS core
0005F0r 3                       ; """https://forth-standard.org/standard/core/CComma"""
0005F0r 3               
0005F0r 3               xt_c_comma:
0005F0r 3  20 rr rr                     jsr underflow_1
0005F3r 3               
0005F3r 3  B5 00                        lda 0,x
0005F5r 3  20 rr rr                     jsr cmpl_a
0005F8r 3               
0005F8r 3  E8                           inx
0005F9r 3  E8                           inx
0005FAr 3               
0005FAr 3  60           z_c_comma:      rts
0005FBr 3               
0005FBr 3               
0005FBr 3               
0005FBr 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
0005FBr 3               ; ## "c@"  auto  ANS core
0005FBr 3                       ; """https://forth-standard.org/standard/core/CFetch"""
0005FBr 3               xt_c_fetch:
0005FBr 3  20 rr rr                     jsr underflow_1
0005FEr 3               
0005FEr 3  A1 00                        lda (0,x)
000600r 3  95 00                        sta 0,x
000602r 3  74 01                        stz 1,x         ; Ignore LSB
000604r 3               
000604r 3  60           z_c_fetch:      rts
000605r 3               
000605r 3               
000605r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000605r 3               ; ## "c!"  auto  ANS core
000605r 3                       ; """https://forth-standard.org/standard/core/CStore"""
000605r 3               xt_c_store:
000605r 3  20 rr rr                     jsr underflow_2
000608r 3               
000608r 3  B5 02                        lda 2,x
00060Ar 3  81 00                        sta (0,x)
00060Cr 3               
00060Cr 3  E8                           inx
00060Dr 3  E8                           inx
00060Er 3  E8                           inx
00060Fr 3  E8                           inx
000610r 3               
000610r 3  60           z_c_store:      rts
000611r 3               
000611r 3               
000611r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000611r 3               ; ## "case"  auto  ANS core ext
000611r 3                       ; """http://forth-standard.org/standard/core/CASE
000611r 3                       ;
000611r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000611r 3                       ; """
000611r 3               
000611r 3               
000611r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000611r 3               ; ## "cell+"  auto  ANS core
000611r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000611r 3                       ; Add the number of bytes ("address units") that one cell needs.
000611r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000611r 3                       ; """
000611r 3               
000611r 3               xt_cell_plus:
000611r 3  20 rr rr                     jsr underflow_1
000614r 3               
000614r 3  F6 00                        inc 0,x
000616r 3  D0 02                        bne @1
000618r 3  F6 01                        inc 1,x
00061Ar 3               @1:
00061Ar 3  F6 00                        inc 0,x
00061Cr 3  D0 02                        bne @done
00061Er 3  F6 01                        inc 1,x
000620r 3               @done:
000620r 3  60           z_cell_plus:    rts
000621r 3               
000621r 3               
000621r 3               
000621r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000621r 3               ; ## "cells"  auto  ANS core
000621r 3                       ; """https://forth-standard.org/standard/core/CELLS
000621r 3                       ;
000621r 3                       ; Dummy entry for the CELLS word, the code is the same as for
000621r 3                       ; 2*, which is where the header directs us to
000621r 3                       ; """
000621r 3               
000621r 3               
000621r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000621r 3               ; ## "char"  auto  ANS core
000621r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000621r 3               
000621r 3               xt_char:
000621r 3                               ; get character from string, returns ( addr u )
000621r 3  20 rr rr                     jsr xt_parse_name
000624r 3               
000624r 3                               ; if we got back a zero, we have a problem
000624r 3  B5 00                        lda 0,x
000626r 3  15 01                        ora 1,x
000628r 3  D0 05                        bne @not_empty
00062Ar 3               
00062Ar 3  A9 05                        lda #err_noname
00062Cr 3  4C rr rr                     jmp error
00062Fr 3               
00062Fr 3               @not_empty:
00062Fr 3  E8                           inx             ; drop number of characters, leave addr
000630r 3  E8                           inx
000631r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000633r 3  95 00                        sta 0,x
000635r 3  74 01                        stz 1,x         ; MSB is always zero
000637r 3               
000637r 3  60           z_char:         rts
000638r 3               
000638r 3               
000638r 3               
000638r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000638r 3               ; ## "char+"  auto  ANS core
000638r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000638r 3                       ;
000638r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000638r 3                       ; """
000638r 3               
000638r 3               
000638r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000638r 3               ; ## "chars"  auto  ANS core
000638r 3                       ; """https://forth-standard.org/standard/core/CHARS
000638r 3                       ; Return how many address units n chars are. Since this is an 8 bit
000638r 3                       ; machine, this does absolutely nothing and is included for
000638r 3                       ; compatibility with other Forth versions
000638r 3                       ; """
000638r 3               
000638r 3               xt_chars:
000638r 3                               ; Checking for underflow seems a bit stupid because this
000638r 3                               ; routine does nothing on this machine. However, the user
000638r 3                               ; should be warned that there is something wrong with the
000638r 3                               ; code if this occurs.
000638r 3  20 rr rr                     jsr underflow_1
00063Br 3               
00063Br 3  60           z_chars:        rts
00063Cr 3               
00063Cr 3               
00063Cr 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
00063Cr 3               ; ## "cleave"  auto  Tali Forth
00063Cr 3               
00063Cr 3                       ; """Given a range of memory with words delimited by whitespace,return
00063Cr 3                       ; the first word at the top of the stack and the rest of the word
00063Cr 3                       ; following it.
00063Cr 3                       ;
00063Cr 3                       ; Example:
00063Cr 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
00063Cr 3                       ; s" w1" cleave        -> "" "w1"
00063Cr 3                       ;
00063Cr 3                       ; Since it will be used in loops a lot, we want it to work in pure
00063Cr 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
00063Cr 3                       ; strip leading delimiters.
00063Cr 3                       ; """
00063Cr 3               
00063Cr 3               xt_cleave:
00063Cr 3  20 rr rr                     jsr underflow_2
00063Fr 3               
00063Fr 3                               ; We arrive here with ( addr u ). We need to strip any leading
00063Fr 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
00063Fr 3                               ; remember how many spaces were stripped. This means we can't
00063Fr 3                               ; calculate the length of the remainder. Fortunately, Tali
00063Fr 3                               ; Forth has just the word we need for this:
00063Fr 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000642r 3               
000642r 3                               ; The main part we can turn over to PARSE-NAME, except that we
000642r 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000642r 3                               ; We get around this by cheating: We place ( addr u ) in the
000642r 3                               ; input buffer and then call PARSE-NAME.
000642r 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000645r 3               
000645r 3  B5 00                        lda 0,x         ; u is new ciblen
000647r 3  85 0A                        sta ciblen
000649r 3  B5 01                        lda 1,x
00064Br 3  85 0B                        sta ciblen+1
00064Dr 3               
00064Dr 3  B5 02                        lda 2,x         ; addr is new cib
00064Fr 3  85 08                        sta cib
000651r 3  B5 03                        lda 3,x
000653r 3  85 09                        sta cib+1
000655r 3               
000655r 3  64 0C                        stz toin        ; >IN pointer is zero
000657r 3  64 0D                        stz toin+1
000659r 3               
000659r 3                               ; PARSE-NAME gives us back the substring of the first word
000659r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
00065Cr 3               
00065Cr 3                               ; If we were given an empty string, then we're done. It's the
00065Cr 3                               ; resposibility of the user to catch this as a sign to end the
00065Cr 3                               ; any loop
00065Cr 3  B5 00                        lda 0,x
00065Er 3  15 01                        ora 1,x
000660r 3  F0 23                        beq @done
000662r 3               
000662r 3                               ; Now we have to adjust the original string
000662r 3  B5 04                        lda 4,x         ; LSB of original u
000664r 3  38                           sec
000665r 3  F5 00                        sbc 0,x
000667r 3  95 04                        sta 4,x
000669r 3               
000669r 3  B5 05                        lda 5,x         ; MSB of original u
00066Br 3  F5 01                        sbc 1,x
00066Dr 3  95 05                        sta 5,x
00066Fr 3               
00066Fr 3  B5 06                        lda 6,x         ; LSB of original addr
000671r 3  18                           clc
000672r 3  75 00                        adc 0,x
000674r 3  95 06                        sta 6,x
000676r 3               
000676r 3  B5 07                        lda 7,x         ; MSB of original addr
000678r 3  75 01                        adc 1,x
00067Ar 3  95 07                        sta 7,x
00067Cr 3               
00067Cr 3                               ; There is one small problem: PARSE-NAME will probably have
00067Cr 3                               ; left the string with the rest of the words with leading
00067Cr 3                               ; delimiters. We use our magic -LEADING again
00067Cr 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
00067Fr 3  20 rr rr                     jsr xt_minus_leading
000682r 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000685r 3               @done:
000685r 3                               ; Restore input
000685r 3  20 rr rr                     jsr xt_r_to_input
000688r 3               
000688r 3  60           z_cleave:       rts
000689r 3               
000689r 3               
000689r 3               
000689r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000689r 3               ; ## "cmove"  auto  ANS string
000689r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000689r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000689r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000689r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000689r 3                       ; "move left".
000689r 3                       ;
000689r 3                       ; There are no official tests for this word.
000689r 3                       ; """
000689r 3               
000689r 3               xt_cmove:
000689r 3  20 rr rr                     jsr underflow_3
00068Cr 3               
00068Cr 3                               ; move destination address to where we can work with it
00068Cr 3  B5 02                        lda 2,x
00068Er 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
000690r 3  B5 03                        lda 3,x
000692r 3  85 27                        sta tmp2+1
000694r 3               
000694r 3                               ; move source address to where we can work with it
000694r 3  B5 04                        lda 4,x
000696r 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
000698r 3  B5 05                        lda 5,x
00069Ar 3  85 25                        sta tmp1+1
00069Cr 3               
00069Cr 3  A0 00                        ldy #0
00069Er 3  B5 01                        lda 1,x         ; number of whole pages to move
0006A0r 3  F0 0F                        beq @dopartial
0006A2r 3               
0006A2r 3               @page:
0006A2r 3  B1 24                        lda (tmp1),y
0006A4r 3  91 26                        sta (tmp2),y
0006A6r 3  C8                           iny
0006A7r 3  D0 F9                        bne @page
0006A9r 3               
0006A9r 3  E6 25                        inc tmp1+1
0006ABr 3  E6 27                        inc tmp2+1
0006ADr 3  D6 01                        dec 1,x
0006AFr 3  D0 F1                        bne @page
0006B1r 3               
0006B1r 3               @dopartial:
0006B1r 3  B5 00                        lda 0,x         ; length of last page
0006B3r 3  F0 09                        beq @done
0006B5r 3               
0006B5r 3               @partial:
0006B5r 3  B1 24                        lda (tmp1),y
0006B7r 3  91 26                        sta (tmp2),y
0006B9r 3  C8                           iny
0006BAr 3               
0006BAr 3  D6 00                        dec 0,x
0006BCr 3  D0 F7                        bne @partial
0006BEr 3               
0006BEr 3               @done:          ; clear the stack
0006BEr 3  8A                           txa
0006BFr 3  18                           clc
0006C0r 3  69 06                        adc #6
0006C2r 3  AA                           tax
0006C3r 3               
0006C3r 3  60           z_cmove:        rts
0006C4r 3               
0006C4r 3               
0006C4r 3               
0006C4r 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
0006C4r 3               ; ## "cmove>"  auto  ANS string
0006C4r 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
0006C4r 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
0006C4r 3                       ; Routines", p. 201, where it is called "move right".
0006C4r 3                       ;
0006C4r 3                       ; There are no official tests for this word.
0006C4r 3                       ; """
0006C4r 3               
0006C4r 3               xt_cmove_up:
0006C4r 3  20 rr rr                     jsr underflow_3
0006C7r 3               
0006C7r 3                               ; Move destination address to where we can work with it
0006C7r 3  B5 02                        lda 2,x
0006C9r 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
0006CBr 3  B5 03                        lda 3,x
0006CDr 3  18                           clc
0006CEr 3  75 01                        adc 1,x
0006D0r 3  85 27                        sta tmp2+1      ; point to last page of destination
0006D2r 3               
0006D2r 3                               ; Move source address to where we can work with it
0006D2r 3  B5 04                        lda 4,x
0006D4r 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
0006D6r 3  B5 05                        lda 5,x
0006D8r 3  18                           clc
0006D9r 3  75 01                        adc 1,x
0006DBr 3  85 25                        sta tmp1+1      ; point to last page of source
0006DDr 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
0006DFr 3               
0006DFr 3                               ; Move the last partial page first
0006DFr 3  B4 00                        ldy 0,x         ; length of last page
0006E1r 3  F0 0E                        beq @nopartial
0006E3r 3               
0006E3r 3               @outerloop:
0006E3r 3  88                           dey
0006E4r 3  F0 07                        beq @finishpage
0006E6r 3               
0006E6r 3               @innerloop:
0006E6r 3  B1 24                        lda (tmp1),y
0006E8r 3  91 26                        sta (tmp2),y
0006EAr 3  88                           dey
0006EBr 3  D0 F9                        bne @innerloop
0006EDr 3               
0006EDr 3               @finishpage:
0006EDr 3  B2 24                        lda (tmp1)      ; handle y = 0 separately
0006EFr 3  92 26                        sta (tmp2)
0006F1r 3               
0006F1r 3               @nopartial:
0006F1r 3  C6 25                        dec tmp1+1      ; back up to previous pages
0006F3r 3  C6 27                        dec tmp2+1
0006F5r 3  D6 01                        dec 1,x
0006F7r 3  D0 EA                        bne @outerloop
0006F9r 3               @done:
0006F9r 3                               ; clear up the stack and leave
0006F9r 3  8A                           txa
0006FAr 3  18                           clc
0006FBr 3  69 06                        adc #6
0006FDr 3  AA                           tax
0006FEr 3               
0006FEr 3  60           z_cmove_up:     rts
0006FFr 3               
0006FFr 3               
0006FFr 3               
0006FFr 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
0006FFr 3               ; ## ":"  auto  ANS core
0006FFr 3                       ; """https://forth-standard.org/standard/core/Colon
0006FFr 3                       ;
0006FFr 3                       ; Use the CREATE routine and fill in the rest by hand.
0006FFr 3                       ; """
0006FFr 3               
0006FFr 3               xt_colon:
0006FFr 3                               ; If we're already in the compile state, complain
0006FFr 3                               ; and quit
0006FFr 3  A5 16                        lda state
000701r 3  05 17                        ora state+1
000703r 3  F0 05                        beq @1
000705r 3               
000705r 3  A9 07                        lda #err_state
000707r 3  4C rr rr                     jmp error
00070Ar 3               @1:
00070Ar 3                               ; switch to compile state
00070Ar 3  C6 16                        dec state
00070Cr 3  C6 17                        dec state+1
00070Er 3               
00070Er 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
00070Er 3                               ; word
00070Er 3  A9 40                        lda #%01000000
000710r 3  04 20                        tsb status
000712r 3               
000712r 3                               ; CREATE is going to change the DP to point to the new word's
000712r 3                               ; header. While this is fine for (say) variables, it would mean
000712r 3                               ; that FIND-NAME etc would find a half-finished word when
000712r 3                               ; looking in the Dictionary. To prevent this, we save the old
000712r 3                               ; version of DP and restore it later. The new DP is placed in
000712r 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000712r 3  20 rr rr                     jsr current_to_dp
000715r 3  A5 03                        lda dp+1            ; CREATE uses a lot of variables
000717r 3  48                           pha
000718r 3  A5 02                        lda dp
00071Ar 3  48                           pha
00071Br 3               
00071Br 3                               ; Tell create not to print warning for duplicate name.
00071Br 3  A9 80                        lda #%10000000
00071Dr 3  04 20                        tsb status
00071Fr 3               
00071Fr 3  20 rr rr                     jsr xt_create
000722r 3               
000722r 3                               ; Get the nt (not the xt!) of the new word as described above.
000722r 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000722r 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000725r 3  A5 02                        lda dp
000727r 3  85 04                        sta workword
000729r 3  A5 03                        lda dp+1
00072Br 3  85 05                        sta workword+1
00072Dr 3               
00072Dr 3                               ; Restore original DP
00072Dr 3  68                           pla
00072Er 3  85 02                        sta dp
000730r 3  68                           pla
000731r 3  85 03                        sta dp+1
000733r 3  20 rr rr                     jsr dp_to_current
000736r 3               
000736r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000736r 3                               ; back up three bytes and overwrite that.
000736r 3  A5 00                        lda cp
000738r 3  38                           sec
000739r 3  E9 03                        sbc #3
00073Br 3  85 00                        sta cp
00073Dr 3  B0 02                        bcs @done
00073Fr 3  C6 01                        dec cp+1
000741r 3               @done:
000741r 3  60           z_colon:        rts
000742r 3               
000742r 3               
000742r 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000742r 3               ; ## ":NONAME"  auto  ANS core
000742r 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000742r 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000742r 3                       ; """
000742r 3               
000742r 3               xt_colon_noname:
000742r 3                               ; If we're already in the compile state, complain
000742r 3                               ; and quit
000742r 3  A5 16                        lda state
000744r 3  05 17                        ora state+1
000746r 3  F0 05                        beq @1
000748r 3               
000748r 3  A9 07                        lda #err_state
00074Ar 3  4C rr rr                     jmp error
00074Dr 3               @1:
00074Dr 3                               ; switch to compile state
00074Dr 3  C6 16                        dec state
00074Fr 3  C6 17                        dec state+1
000751r 3               
000751r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000751r 3                               ; a :NONAME word.
000751r 3  A9 40                        lda #%01000000
000753r 3  14 20                        trb status
000755r 3               
000755r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000755r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000755r 3                               ; nt and they will modify their behavior.
000755r 3  A5 00                        lda cp
000757r 3  85 04                        sta workword
000759r 3  A5 01                        lda cp+1
00075Br 3  85 05                        sta workword+1
00075Dr 3               @done:
00075Dr 3  60           z_colon_noname:        rts
00075Er 3               
00075Er 3               
00075Er 3               
00075Er 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
00075Er 3               ; ## ","  auto  ANS core
00075Er 3                       ; """https://forth-standard.org/standard/core/Comma
00075Er 3                       ; Store TOS at current place in memory.
00075Er 3                       ;
00075Er 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
00075Er 3                       ; """
00075Er 3               
00075Er 3               xt_comma:
00075Er 3  20 rr rr                     jsr underflow_1
000761r 3               
000761r 3  B5 00                        lda 0,x
000763r 3  92 00                        sta (cp)
000765r 3               
000765r 3  E6 00                        inc cp
000767r 3  D0 02                        bne @1
000769r 3  E6 01                        inc cp+1
00076Br 3               @1:
00076Br 3  B5 01                        lda 1,x
00076Dr 3  92 00                        sta (cp)
00076Fr 3               
00076Fr 3  E6 00                        inc cp
000771r 3  D0 02                        bne @done
000773r 3  E6 01                        inc cp+1
000775r 3               @done:
000775r 3  E8                           inx
000776r 3  E8                           inx
000777r 3               
000777r 3  60           z_comma:        rts
000778r 3               
000778r 3               
000778r 3               
000778r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000778r 3               ; ## "compare"   auto  ANS string
000778r 3                       ; """https://forth-standard.org/standard/string/COMPARE
000778r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000778r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000778r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000778r 3                       ; that entirely matches the beginning of the other string, but is
000778r 3                       ; shorter, is considered less than the longer string.
000778r 3                       ; """
000778r 3               
000778r 3               xt_compare:
000778r 3  20 rr rr                     jsr underflow_4
00077Br 3               
00077Br 3                               ; Load the two string addresses into tmp1 and tmp2.
00077Br 3  B5 02                        lda 2,x
00077Dr 3  85 26                        sta tmp2
00077Fr 3  B5 03                        lda 3,x
000781r 3  85 27                        sta tmp2+1
000783r 3  B5 06                        lda 6,x
000785r 3  85 24                        sta tmp1
000787r 3  B5 07                        lda 7,x
000789r 3  85 25                        sta tmp1+1
00078Br 3                               ; The counts will be used in-place on the stack.
00078Br 3               
00078Br 3               @compare_loop:
00078Br 3                               ; Check to see if we are out of letters.
00078Br 3               
00078Br 3                               ; Check string1
00078Br 3  B5 04                        lda 4,x
00078Dr 3  15 05                        ora 5,x
00078Fr 3  F0 2C                        beq @str1_done
000791r 3               
000791r 3                               ; Check string2
000791r 3  B5 00                        lda 0,x
000793r 3  15 01                        ora 1,x
000795r 3  F0 3A                        beq @greater    ; Str2 empty first
000797r 3               
000797r 3               @check_letter:
000797r 3                               ; Both strings have at least one letter left.
000797r 3                               ; Check the letters against each other.
000797r 3  B2 24                        lda (tmp1)
000799r 3  D2 26                        cmp (tmp2)
00079Br 3  90 26                        bcc @less
00079Dr 3  D0 32                        bne @greater
00079Fr 3               @next_letter:
00079Fr 3                               ; Move both tmp pointers and decrement the counts
00079Fr 3                               ; on the stack.
00079Fr 3                               ; Increment tmp1
00079Fr 3  E6 24                        inc tmp1
0007A1r 3  D0 02                        bne @1
0007A3r 3  E6 25                        inc tmp1+1
0007A5r 3               @1:
0007A5r 3                               ; Increment tmp2
0007A5r 3  E6 26                        inc tmp2
0007A7r 3  D0 02                        bne @2
0007A9r 3  E6 27                        inc tmp2+1
0007ABr 3               @2:
0007ABr 3                               ; Decrement count1 on the stack.
0007ABr 3  B5 04                        lda 4,x
0007ADr 3  D0 02                        bne @3
0007AFr 3  D6 05                        dec 5,x
0007B1r 3               @3:
0007B1r 3  D6 04                        dec 4,x
0007B3r 3               
0007B3r 3                               ; Decrement count2 on the stack.
0007B3r 3  B5 00                        lda 0,x
0007B5r 3  D0 02                        bne @4
0007B7r 3  D6 01                        dec 1,x
0007B9r 3               @4:
0007B9r 3  D6 00                        dec 0,x
0007BBr 3               
0007BBr 3                               ; Loop around and check again.
0007BBr 3  80 CE                        bra @compare_loop
0007BDr 3               
0007BDr 3               @str1_done:
0007BDr 3                               ; String 1 is out of letters. Check string 2.
0007BDr 3  B5 00                        lda 0,x
0007BFr 3  15 01                        ora 1,x
0007C1r 3  F0 08                        beq @equal      ; Both out of letters
0007C3r 3               
0007C3r 3                               ; Falls into less (str1 is out but str2 has more)
0007C3r 3               @less:
0007C3r 3                               ; Return -1
0007C3r 3  A9 FF                        lda #$FF
0007C5r 3  95 06                        sta 6,x
0007C7r 3  95 07                        sta 7,x
0007C9r 3  80 0C                        bra @done
0007CBr 3               @equal:
0007CBr 3                               ; Return 0
0007CBr 3  74 06                        stz 6,x
0007CDr 3  74 07                        stz 7,x
0007CFr 3  80 06                        bra @done
0007D1r 3               @greater:
0007D1r 3                               ; Return 1
0007D1r 3  A9 01                        lda #1
0007D3r 3  95 06                        sta 6,x
0007D5r 3  74 07                        stz 7,x
0007D7r 3                               ; Falls into @done
0007D7r 3               @done:
0007D7r 3                               ; Remove all but the result from the stack.
0007D7r 3  8A                           txa
0007D8r 3  18                           clc
0007D9r 3  69 06                        adc #6
0007DBr 3  AA                           tax
0007DCr 3               
0007DCr 3  60           z_compare:      rts
0007DDr 3               
0007DDr 3               
0007DDr 3               
0007DDr 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
0007DDr 3               ; ## "compile,"  auto  ANS core ext
0007DDr 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
0007DDr 3                       ; Compile the given xt in the current word definition. It is an
0007DDr 3                       ; error if we are not in the compile state. Because we are using
0007DDr 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
0007DDr 3                       ; the traditional way. By default, native compiled is allowed, unless
0007DDr 3                       ; there is a NN (Never Native) flag associated. If not, we use the
0007DDr 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
0007DDr 3                       ; is too large to be natively coded: If the size is larger than
0007DDr 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
0007DDr 3                       ; Native) flag is set, the word is always natively compiled.
0007DDr 3                       ; """
0007DDr 3               
0007DDr 3               xt_compile_comma:
0007DDr 3  20 rr rr                     jsr underflow_1
0007E0r 3               
0007E0r 3                               ; See if this is an Always Native (AN) word by checking the
0007E0r 3                               ; AN flag. We need nt for this. First, save a copy of xt to
0007E0r 3                               ; the Return Stack
0007E0r 3  B5 01                        lda 1,x                 ; MSB
0007E2r 3  48                           pha
0007E3r 3  B5 00                        lda 0,x
0007E5r 3  48                           pha                     ; LSB
0007E6r 3               
0007E6r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
0007E9r 3               
0007E9r 3                               ; See if this xt even has an nt.
0007E9r 3  B5 00                        lda 0,x
0007EBr 3  15 01                        ora 1,x
0007EDr 3  D0 03                        bne @check_nt
0007EFr 3               
0007EFr 3                               ; No nt in dictionary. Just compile as a JSR.
0007EFr 3  4C rr rr                     jmp @compile_as_jump
0007F2r 3               
0007F2r 3               @check_nt:
0007F2r 3                               ; put nt away for safe keeping
0007F2r 3  B5 00                        lda 0,x
0007F4r 3  85 2C                        sta tmptos
0007F6r 3  B5 01                        lda 1,x
0007F8r 3  85 2D                        sta tmptos+1
0007FAr 3               
0007FAr 3                               ; status byte is one further down
0007FAr 3  F6 00                        inc 0,x
0007FCr 3  D0 02                        bne @1
0007FEr 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
000800r 3               @1:
000800r 3  A1 00                        lda (0,x)
000802r 3  85 28                        sta tmp3                ; keep copy of status byte for NN
000804r 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
000806r 3  F0 0D                        beq @compile_check
000808r 3               
000808r 3                               ; We're natively compiling no matter what. Get length and
000808r 3                               ; compile in code. Get the original nt back
000808r 3  A5 2C                        lda tmptos
00080Ar 3  95 00                        sta 0,x
00080Cr 3  A5 2D                        lda tmptos+1
00080Er 3  95 01                        sta 1,x
000810r 3               
000810r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000813r 3               
000813r 3  80 27                        bra @compile_as_code
000815r 3               
000815r 3               @compile_check:
000815r 3                               ; See if Native Compile is even alowed by checking the NN
000815r 3                               ; flag
000815r 3  A5 28                        lda tmp3
000817r 3  29 08                        and #NN
000819r 3  F0 03                        beq @check_size_limit
00081Br 3               
00081Br 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00081Er 3               
00081Er 3               @check_size_limit:
00081Er 3                               ; Native compile is a legal option, but we need to see what
00081Er 3                               ; limit the user set for size (in nc_limit)
00081Er 3  A5 2C                        lda tmptos
000820r 3  95 00                        sta 0,x
000822r 3  A5 2D                        lda tmptos+1
000824r 3  95 01                        sta 1,x
000826r 3               
000826r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000829r 3               
000829r 3                               ; Check the wordsize MSB against the user-defined limit.
000829r 3  B5 01                        lda 1,x
00082Br 3  C5 1B                        cmp nc_limit+1
00082Dr 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
00082Fr 3  D0 08                        bne @jumpto_compile_as_jump
000831r 3               
000831r 3                               ; Check the wordsize LSB against the user-defined limit.
000831r 3  B5 00                        lda 0,x
000833r 3  C5 1A                        cmp nc_limit            ; user-defined limit LSB
000835r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
000837r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
000839r 3               
000839r 3               @jumpto_compile_as_jump:
000839r 3                               ; If the wordsize is greater than the user-defined
000839r 3                               ; limit, it will be compiled as a subroutine jump.
000839r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00083Cr 3               
00083Cr 3               @compile_as_code:
00083Cr 3                               ; We arrive here with the length of the word's code TOS and
00083Cr 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
00083Cr 3                               ; on the data stack
00083Cr 3  CA                           dex
00083Dr 3  CA                           dex                     ; ( -- u ? )
00083Er 3  CA                           dex
00083Fr 3  CA                           dex                     ; ( -- u ? ? )
000840r 3               
000840r 3  B5 04                        lda 4,x
000842r 3  95 00                        sta 0,x                 ; LSB of u
000844r 3  B5 05                        lda 5,x
000846r 3  95 01                        sta 1,x                 ; ( -- u ? u )
000848r 3               
000848r 3  68                           pla
000849r 3  95 04                        sta 4,x                 ; LSB of xt
00084Br 3  68                           pla
00084Cr 3  95 05                        sta 5,x                 ; ( -- xt ? u )
00084Er 3               
00084Er 3  A5 00                        lda cp                  ; LSB of cp
000850r 3  95 02                        sta 2,x
000852r 3  A5 01                        lda cp+1
000854r 3  95 03                        sta 3,x                 ; ( -- xt cp u )
000856r 3               
000856r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
000856r 3               
000856r 3                               ; Native compiling allows us to strip the stack antics off
000856r 3                               ; a number of words that use the Return Stack such as >R, R>,
000856r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
000856r 3                               ; xt with the contents of the table
000856r 3  A0 00                        ldy #0
000858r 3               
000858r 3               @strip_loop:
000858r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
00085Br 3  D5 04                        cmp 4,x                 ; LSB of xt
00085Dr 3  D0 07                        bne @next_entry
00085Fr 3               
00085Fr 3                               ; LSB is the same, test MSB
00085Fr 3  B9 rr rr                     lda @strip_table+1,y
000862r 3  D5 05                        cmp 5,x
000864r 3  F0 0C                        beq @found_entry
000866r 3               
000866r 3                               ; MSB is not equal. Pretend though that we've come from LSB
000866r 3                               ; so we can use the next step for both cases
000866r 3               @next_entry:
000866r 3                               ; Not a word that needs stripping, so check next entry in table
000866r 3                               ; Let's see if we're done with the table (marked by zero entry)
000866r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
000869r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
00086Cr 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
00086Er 3               
00086Er 3  C8                           iny
00086Fr 3  C8                           iny
000870r 3  80 E6                        bra @strip_loop
000872r 3               @found_entry:
000872r 3                               ; This word is one of the ones that needs to have its size
000872r 3                               ; adjusted during native compile. We find the values in the
000872r 3                               ; next table with the same index, which is Y. However, Y is
000872r 3                               ; pointing to the MSB, so we need to go back to the LSB and
000872r 3                               ; halve the index before we can use it.
000872r 3  98                           tya
000873r 3  4A                           lsr
000874r 3  A8                           tay
000875r 3               
000875r 3                               ; Get the adjustment out of the size table. We were clever
000875r 3                               ; enough to make sure the cut on both ends of the code is
000875r 3                               ; is the same size.
000875r 3  B9 rr rr                     lda @strip_size,y
000878r 3  85 2C                        sta tmptos              ; save a copy
00087Ar 3               
00087Ar 3                               ; Adjust xt: Start later
00087Ar 3  18                           clc
00087Br 3  75 04                        adc 4,x
00087Dr 3  95 04                        sta 4,x
00087Fr 3  90 02                        bcc @2
000881r 3  F6 05                        inc 5,x                 ; we just care about the carry
000883r 3               @2:
000883r 3               
000883r 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
000883r 3                               ; bottom of the code, we have to double the value
000883r 3  06 2C                        asl tmptos
000885r 3               
000885r 3  38                           sec
000886r 3  B5 00                        lda 0,x
000888r 3  E5 2C                        sbc tmptos
00088Ar 3  95 00                        sta 0,x
00088Cr 3  B0 02                        bcs @3
00088Er 3  D6 01                        dec 1,x                 ; we just care about the borrow
000890r 3               @3:
000890r 3                               ; drop through to underflow check stripping
000890r 3               
000890r 3               @underflow_strip:
000890r 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
000890r 3               
000890r 3                               ; The user can choose to remove the unterflow testing in those
000890r 3                               ; words that have the UF flag. This shortens the word by
000890r 3                               ; 3 bytes if there is no underflow.
000890r 3               
000890r 3                               ; See if the user wants underflow stripping turned on
000890r 3  A5 1C                        lda uf_strip
000892r 3  05 1D                        ora uf_strip+1
000894r 3  F0 1C                        beq @specials_done
000896r 3               
000896r 3                               ; See if this word even contains underflow checking
000896r 3  A5 28                        lda tmp3
000898r 3  29 10                        and #UF
00089Ar 3  F0 16                        beq @specials_done
00089Cr 3               
00089Cr 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
00089Cr 3                               ; long. Note hat PICK is a special case.
00089Cr 3               
00089Cr 3                               ; Adjust xt: Start later
00089Cr 3  18                           clc
00089Dr 3  B5 04                        lda 4,x
00089Fr 3  69 03                        adc #3
0008A1r 3  95 04                        sta 4,x
0008A3r 3  90 02                        bcc @4
0008A5r 3  F6 05                        inc 5,x                  ; we just care about the carry
0008A7r 3               @4:
0008A7r 3                               ; Adjust u: End earlier
0008A7r 3  38                           sec
0008A8r 3  B5 00                        lda 0,x
0008AAr 3  E9 03                        sbc #3
0008ACr 3  95 00                        sta 0,x
0008AEr 3  B0 02                        bcs @5
0008B0r 3  D6 01                        dec 1,x                  ; we just care about the borrow
0008B2r 3               @5:
0008B2r 3               
0008B2r 3                               ; --- END OF SPECIAL CASES ---
0008B2r 3               @specials_done:
0008B2r 3                               ; Store size of area to be copied for calculation of
0008B2r 3                               ; new CP. We have to do this after all of the special cases
0008B2r 3                               ; because they might change the size
0008B2r 3  B5 01                        lda 1,x                 ; MSB
0008B4r 3  48                           pha
0008B5r 3  B5 00                        lda 0,x                 ; LSB
0008B7r 3  48                           pha
0008B8r 3               
0008B8r 3                               ; Enough of this, let's move those bytes already! We have
0008B8r 3                               ; ( xt cp u ) on the stack at this point
0008B8r 3  20 rr rr                     jsr xt_move
0008BBr 3               
0008BBr 3                               ; Update CP
0008BBr 3  18                           clc
0008BCr 3  68                           pla                     ; LSB
0008BDr 3  65 00                        adc cp
0008BFr 3  85 00                        sta cp
0008C1r 3               
0008C1r 3  68                           pla                     ; MSB
0008C2r 3  65 01                        adc cp+1
0008C4r 3  85 01                        sta cp+1
0008C6r 3               
0008C6r 3  80 2C                        bra @done
0008C8r 3               
0008C8r 3               @strip_table:
0008C8r 3                              ; List of words we strip the Return Stack antics from
0008C8r 3                              ; during native compile, zero terminated. The index here
0008C8r 3                              ; must be the same as for the sizes
0008C8r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
0008CCr 3  rr rr        
0008CEr 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
0008D2r 3  00 00        
0008D4r 3               
0008D4r 3               @strip_size:
0008D4r 3                               ; List of bytes to be stripped from the words that get their
0008D4r 3                               ; Return Stack antics removed during native compile. Index must
0008D4r 3                               ; be the same as for the xts. Zero terminated.
0008D4r 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
0008D8r 3  06 00        
0008DAr 3               
0008DAr 3               @compile_as_jump:
0008DAr 3                               ; Compile xt as a subroutine jump
0008DAr 3  A9 20                        lda #$20
0008DCr 3  92 00                        sta (cp)
0008DEr 3               
0008DEr 3  A0 01                        ldy #1
0008E0r 3  68                           pla             ; LSB
0008E1r 3  91 00                        sta (cp),y
0008E3r 3  C8                           iny
0008E4r 3  68                           pla             ; MSB
0008E5r 3  91 00                        sta (cp),y
0008E7r 3               
0008E7r 3                               ; allot space we just used
0008E7r 3  A9 03                        lda #3
0008E9r 3  18                           clc
0008EAr 3  65 00                        adc cp
0008ECr 3  85 00                        sta cp
0008EEr 3  90 02                        bcc @6
0008F0r 3  E6 01                        inc cp+1
0008F2r 3               @6:
0008F2r 3  E8                           inx             ; drop xt
0008F3r 3  E8                           inx
0008F4r 3               @done:
0008F4r 3               z_compile_comma:
0008F4r 3  60                           rts
0008F5r 3               
0008F5r 3               
0008F5r 3               
0008F5r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
0008F5r 3               ; ## "compile-only"  tested  Tali Forth
0008F5r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
0008F5r 3                       ; word.
0008F5r 3                       ;
0008F5r 3                       ; The alternative way to do this is to define a word
0008F5r 3                       ; ?COMPILE that makes sure  we're in compile mode
0008F5r 3                       ; """
0008F5r 3               
0008F5r 3               xt_compile_only:
0008F5r 3  20 rr rr                     jsr current_to_dp
0008F8r 3  A0 01                        ldy #1          ; offset for status byte
0008FAr 3  B1 02                        lda (dp),y
0008FCr 3  09 01                        ora #CO        ; make sure bit 7 is set
0008FEr 3  91 02                        sta (dp),y
000900r 3               
000900r 3  60           z_compile_only: rts
000901r 3               
000901r 3               
000901r 3               
000901r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
000901r 3               ; ## "constant"  auto  ANS core
000901r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
000901r 3                       ;
000901r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
000901r 3                       ; more in assembler and let CREATE do the heavy lifting.
000901r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
000901r 3                       ; a primer on how this works in various Forths. This is the
000901r 3                       ; same code as VALUE in our case.
000901r 3                       ; """
000901r 3               xt_value:
000901r 3               xt_constant:
000901r 3  20 rr rr                     jsr underflow_1
000904r 3               
000904r 3  20 rr rr                     jsr xt_create
000907r 3               
000907r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
000907r 3                               ; but we want DOCONST for constants. Go back two bytes and
000907r 3                               ; replace the subroutine jump target
000907r 3  38                           sec
000908r 3  A5 00                        lda cp
00090Ar 3  E9 02                        sbc #2
00090Cr 3  85 24                        sta tmp1
00090Er 3  A5 01                        lda cp+1
000910r 3  E9 00                        sbc #0
000912r 3  85 25                        sta tmp1+1
000914r 3               
000914r 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
000916r 3  92 24                        sta (tmp1)
000918r 3  A0 01                        ldy #1
00091Ar 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
00091Cr 3  91 24                        sta (tmp1),y
00091Er 3               
00091Er 3                               ; Now we save the constant number itself in the next cell
00091Er 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
000921r 3               
000921r 3               adjust_z:
000921r 3                               ; Now the length of the complete word (z_word) has increased by
000921r 3                               ; two. We need to update that number or else words such as SEE
000921r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
000921r 3                               ; VALUE and DEFER
000921r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
000924r 3               
000924r 3                               ; z_word is six bytes further down
000924r 3  B5 00                        lda 0,x
000926r 3  85 24                        sta tmp1
000928r 3  B5 01                        lda 1,x
00092Ar 3  85 25                        sta tmp1+1
00092Cr 3               
00092Cr 3  A0 06                        ldy #6
00092Er 3  B1 24                        lda (tmp1),y
000930r 3  18                           clc
000931r 3  69 02                        adc #2
000933r 3  91 24                        sta (tmp1),y
000935r 3  C8                           iny
000936r 3  B1 24                        lda (tmp1),y
000938r 3  69 00                        adc #0                  ; only need carry
00093Ar 3  91 24                        sta (tmp1),y
00093Cr 3               
00093Cr 3  E8                           inx
00093Dr 3  E8                           inx
00093Er 3               
00093Er 3               z_value:
00093Er 3  60           z_constant:     rts
00093Fr 3               
00093Fr 3               
00093Fr 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
00093Fr 3               ; ## "count"  auto  ANS core
00093Fr 3                       ; """https://forth-standard.org/standard/core/COUNT
00093Fr 3                       ; Convert old-style character string to address-length pair. Note
00093Fr 3                       ; that the length of the string c-addr is stored in character length
00093Fr 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
00093Fr 3                       ; though COUNT can also be used to step through a string character by
00093Fr 3                       ; character.
00093Fr 3                       ; """
00093Fr 3               xt_count:
00093Fr 3  20 rr rr                     jsr underflow_1
000942r 3               
000942r 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
000944r 3  A8                           tay
000945r 3               
000945r 3                               ; move start address up by one
000945r 3  F6 00                        inc 0,x         ; LSB
000947r 3  D0 02                        bne @1
000949r 3  F6 01                        inc 1,x         ; MSB
00094Br 3               
00094Br 3                               ; save number of characters to stack
00094Br 3               @1:
00094Br 3  98                           tya
00094Cr 3  CA                           dex
00094Dr 3  CA                           dex
00094Er 3  95 00                        sta 0,x         ; LSB
000950r 3  74 01                        stz 1,x         ; MSB, always zero
000952r 3               
000952r 3  60           z_count:        rts
000953r 3               
000953r 3               
000953r 3               ; ## CR ( -- ) "Print a line feed"
000953r 3               ; ## "cr"  auto  ANS core
000953r 3                       ; """https://forth-standard.org/standard/core/CR"""
000953r 3               xt_cr:
000953r 3  A9 0A                        lda #AscLF
000955r 3  20 rr rr                     jsr emit_a
000958r 3  60           z_cr:           rts
000959r 3               
000959r 3               
000959r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
000959r 3               ; ## "create"  auto  ANS core
000959r 3                       ; """https://forth-standard.org/standard/core/CREATE
000959r 3                       ;
000959r 3                       ; See the drawing in headers.asm for details on the header
000959r 3                       ; """
000959r 3               
000959r 3               xt_create:
000959r 3                               ; get string
000959r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00095Cr 3               
00095Cr 3                               ; if we were given an empty string, we complain and quit
00095Cr 3  B5 00                        lda 0,x
00095Er 3  15 01                        ora 1,x
000960r 3  D0 05                        bne @got_name
000962r 3               
000962r 3  A9 05                        lda #err_noname
000964r 3  4C rr rr                     jmp error
000967r 3               
000967r 3               @got_name:
000967r 3                               ; Enforce maximal length of string by overwriting the MSB of
000967r 3                               ; the length. There is a possible error here: If the string
000967r 3                               ; is exactly 255 chars long, then a lot of the following
000967r 3                               ; additions will fail because of wrapping
000967r 3  74 01                        stz 1,x
000969r 3               
000969r 3                               ; Check to see if this name already exists.
000969r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
00096Cr 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
00096Fr 3               
00096Fr 3  B5 00                        lda 0,x
000971r 3  15 01                        ora 1,x
000973r 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
000975r 3               
000975r 3                               ; This name already exists.  See if we are supposed to print
000975r 3                               ; the message for it.
000975r 3  E8                           inx                     ; Drop flag (nt) from find-name.
000976r 3  E8                           inx
000977r 3               
000977r 3                               ; Check bit 7
000977r 3  24 20                        bit status
000979r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
00097Br 3               
00097Br 3                               ; We aren't supposed to print the redefined message ourselves,
00097Br 3                               ; but we should indicate that it is redefined (for ; to print
00097Br 3                               ; later).
00097Br 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
00097Dr 3  05 20                        ora status
00097Fr 3  85 20                        sta status
000981r 3  80 18                        bra @process_name
000983r 3               
000983r 3               @redefined_name:
000983r 3                               ; Print the message that the name is redefined.
000983r 3  A9 02                        lda #str_redefined
000985r 3  20 rr rr                     jsr print_string_no_lf
000988r 3               
000988r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
00098Br 3  20 rr rr                     jsr xt_type
00098Er 3  20 rr rr                     jsr xt_space
000991r 3               
000991r 3  80 08                        bra @process_name
000993r 3               
000993r 3               @new_name:
000993r 3  E8                           inx                     ; Drop flag (0) from find-name.
000994r 3  E8                           inx
000995r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
000997r 3  25 20                        and status
000999r 3  85 20                        sta status
00099Br 3               
00099Br 3               @process_name:
00099Br 3  B5 00                        lda 0,x
00099Dr 3  85 26                        sta tmp2                ; store length of string in tmp2
00099Fr 3               
00099Fr 3                               ; remember the first free byte of memory as the start of
00099Fr 3                               ; the new word
00099Fr 3  A5 00                        lda cp
0009A1r 3  85 24                        sta tmp1
0009A3r 3  A5 01                        lda cp+1
0009A5r 3  85 25                        sta tmp1+1
0009A7r 3               
0009A7r 3                               ; We need 8 bytes plus the length of the string for our new header.
0009A7r 3                               ; This is also the offset for the start of the code field (the
0009A7r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
0009A7r 3                               ; just allot the space afterwards
0009A7r 3  B5 00                        lda 0,x
0009A9r 3  18                           clc
0009AAr 3  69 08                        adc #8
0009ACr 3  85 28                        sta tmp3                ; total header length
0009AEr 3               
0009AEr 3                               ; We need three more bytes for for the hardcoded code field
0009AEr 3                               ; area (CFA), the "payload" of the word which by default will
0009AEr 3                               ; be a subroutine jump to DOVAR
0009AEr 3  18                           clc
0009AFr 3  69 03                        adc #3
0009B1r 3               
0009B1r 3                               ; We overwrite the length of the string returned by PARSE-NAME
0009B1r 3                               ; and then call ALLOT
0009B1r 3  95 00                        sta 0,x
0009B3r 3  74 01                        stz 1,x         ; max header size is 255 chars
0009B5r 3  20 rr rr                     jsr xt_allot    ; ( addr )
0009B8r 3               
0009B8r 3                               ; Get the CURRENT dictionary pointer.
0009B8r 3  20 rr rr                     jsr current_to_dp
0009BBr 3               
0009BBr 3                               ; Now we walk through the header with Y as the index, adding
0009BBr 3                               ; information byte-by-byte
0009BBr 3  A0 00                        ldy #0
0009BDr 3               
0009BDr 3                               ; HEADER BYTE 0: Length of string
0009BDr 3  A5 26                        lda tmp2
0009BFr 3  91 24                        sta (tmp1),y
0009C1r 3               
0009C1r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
0009C1r 3                               ; to "never native", user will have to decide if they should
0009C1r 3                               ; be inlined
0009C1r 3  A9 08                        lda #NN
0009C3r 3               
0009C3r 3                               ; Also, words defined by CREATE are marked in the header has
0009C3r 3                               ; having a Code Field Area (CFA), which is a bit tricky for
0009C3r 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
0009C3r 3                               ; correctly with DOES> and CREATE. See the discussion at
0009C3r 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
0009C3r 3  09 20                        ora #HC
0009C5r 3  C8                           iny
0009C6r 3  91 24                        sta (tmp1),y
0009C8r 3  C8                           iny
0009C9r 3               
0009C9r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
0009C9r 3                               ; in the Dictionary
0009C9r 3  A5 02                        lda dp
0009CBr 3  91 24                        sta (tmp1),y
0009CDr 3  C8                           iny
0009CEr 3  A5 03                        lda dp+1
0009D0r 3  91 24                        sta (tmp1),y
0009D2r 3  C8                           iny
0009D3r 3               
0009D3r 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
0009D3r 3  A5 25                        lda tmp1+1
0009D5r 3  85 03                        sta dp+1
0009D7r 3  A5 24                        lda tmp1
0009D9r 3  85 02                        sta dp
0009DBr 3               
0009DBr 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
0009DBr 3                               ; This begins after the header so we take the length of the
0009DBr 3                               ; header, which we cleverly saved in tmp3, and use it as an
0009DBr 3                               ; offset to the address of the start of the word. We come here
0009DBr 3                               ; with tmp1 in A
0009DBr 3  18                           clc
0009DCr 3  65 28                        adc tmp3        ; add total header length
0009DEr 3  91 24                        sta (tmp1),y
0009E0r 3  48                           pha             ; we need this in the next step
0009E1r 3  C8                           iny
0009E2r 3               
0009E2r 3  A5 25                        lda tmp1+1
0009E4r 3  69 00                        adc #0          ; only need the carry
0009E6r 3  91 24                        sta (tmp1),y
0009E8r 3  C8                           iny
0009E9r 3               
0009E9r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
0009E9r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
0009E9r 3                               ; bytes down, and then one more byte so that the z_ label points
0009E9r 3                               ; to the (still fictional) RTS instruction for correct compilation
0009E9r 3  68                           pla             ; LSB of "z_" address
0009EAr 3  18                           clc
0009EBr 3  69 03                        adc #3
0009EDr 3  91 24                        sta (tmp1),y
0009EFr 3               
0009EFr 3  88                           dey             ; get the MSB of xt back
0009F0r 3  B1 24                        lda (tmp1),y
0009F2r 3  69 00                        adc #0          ; only need the carry
0009F4r 3  C8                           iny
0009F5r 3  C8                           iny
0009F6r 3  91 24                        sta (tmp1),y
0009F8r 3  C8                           iny
0009F9r 3               
0009F9r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
0009F9r 3                               ; length in tmp2. We subtract 8 from the address so we can
0009F9r 3                               ; use the same loop index, which is already 8 byte ahead at
0009F9r 3                               ; this point
0009F9r 3  B5 00                        lda 0,x
0009FBr 3  38                           sec
0009FCr 3  E9 08                        sbc #8
0009FEr 3  85 2C                        sta tmptos
000A00r 3               
000A00r 3  B5 01                        lda 1,x
000A02r 3  E9 00                        sbc #0          ; only need carry
000A04r 3  85 2D                        sta tmptos+1
000A06r 3               
000A06r 3               @name_loop:
000A06r 3  B1 2C                        lda (tmptos),y
000A08r 3               
000A08r 3                               ; Make sure it goes into the dictionary in lower case.
000A08r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
000A0Ar 3  B0 07                        bcs @store_name
000A0Cr 3  C9 41                        cmp #$41        ; ASCII 'A'
000A0Er 3  90 03                        bcc @store_name
000A10r 3               
000A10r 3                               ; An uppercase letter has been located. Make it
000A10r 3                               ; lowercase.
000A10r 3  18                           clc
000A11r 3  69 20                        adc #$20
000A13r 3               
000A13r 3                               ; Fall into @store_name.
000A13r 3               
000A13r 3               @store_name:
000A13r 3  91 24                        sta (tmp1),y
000A15r 3  C8                           iny
000A16r 3  C6 26                        dec tmp2
000A18r 3  D0 EC                        bne @name_loop
000A1Ar 3               
000A1Ar 3                               ; After thename string comes the code field, starting at the
000A1Ar 3                               ; current xt of this word, which is initially a jump to the
000A1Ar 3                               ; subroutine to DOVAR. We code this jump by hand
000A1Ar 3  A9 20                        lda #$20        ; opcode of JSR
000A1Cr 3  91 24                        sta (tmp1),y
000A1Er 3  C8                           iny
000A1Fr 3  A9 rr                        lda #<dovar
000A21r 3  91 24                        sta (tmp1),y
000A23r 3  C8                           iny
000A24r 3  A9 rr                        lda #>dovar
000A26r 3  91 24                        sta (tmp1),y
000A28r 3               
000A28r 3                               ; Update the CURRENT wordlist with the new DP.
000A28r 3                               ; We do this down here because this routine uses Y.
000A28r 3  20 rr rr                     jsr dp_to_current
000A2Br 3               
000A2Br 3                               ; And we're done. Restore stack
000A2Br 3  E8                           inx
000A2Cr 3  E8                           inx
000A2Dr 3               
000A2Dr 3  60           z_create:       rts
000A2Er 3               
000A2Er 3               
000A2Er 3               
000A2Er 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
000A2Er 3               ; ## "d-"  auto  ANS double
000A2Er 3                       ; """https://forth-standard.org/standard/double/DMinus"""
000A2Er 3               
000A2Er 3               xt_d_minus:
000A2Er 3  20 rr rr                     jsr underflow_4 ; two double numbers
000A31r 3               
000A31r 3  38                           sec
000A32r 3               
000A32r 3  B5 06                        lda 6,x         ; LSB of lower word
000A34r 3  F5 02                        sbc 2,x
000A36r 3  95 06                        sta 6,x
000A38r 3               
000A38r 3  B5 07                        lda 7,x         ; MSB of lower word
000A3Ar 3  F5 03                        sbc 3,x
000A3Cr 3  95 07                        sta 7,x
000A3Er 3               
000A3Er 3  B5 04                        lda 4,x         ; LSB of upper word
000A40r 3  F5 00                        sbc 0,x
000A42r 3  95 04                        sta 4,x
000A44r 3               
000A44r 3  B5 05                        lda 5,x         ; MSB of upper word
000A46r 3  F5 01                        sbc 1,x
000A48r 3  95 05                        sta 5,x
000A4Ar 3               
000A4Ar 3  E8                           inx
000A4Br 3  E8                           inx
000A4Cr 3  E8                           inx
000A4Dr 3  E8                           inx
000A4Er 3               
000A4Er 3  60           z_d_minus:      rts
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
000A4Fr 3               ; ## "d+"  auto  ANS double
000A4Fr 3                       ; """https://forth-standard.org/standard/double/DPlus"""
000A4Fr 3               
000A4Fr 3               xt_d_plus:
000A4Fr 3  20 rr rr                     jsr underflow_4 ; two double numbers
000A52r 3               
000A52r 3  18                           clc
000A53r 3  B5 02                        lda 2,x         ; LSB of lower word
000A55r 3  75 06                        adc 6,x
000A57r 3  95 06                        sta 6,x
000A59r 3               
000A59r 3  B5 03                        lda 3,x         ; MSB of lower word
000A5Br 3  75 07                        adc 7,x
000A5Dr 3  95 07                        sta 7,x
000A5Fr 3               
000A5Fr 3  B5 00                        lda 0,x         ; LSB of upper word
000A61r 3  75 04                        adc 4,x
000A63r 3  95 04                        sta 4,x
000A65r 3               
000A65r 3  B5 01                        lda 1,x         ; MSB of upper word
000A67r 3  75 05                        adc 5,x
000A69r 3  95 05                        sta 5,x
000A6Br 3               
000A6Br 3  E8                           inx
000A6Cr 3  E8                           inx
000A6Dr 3  E8                           inx
000A6Er 3  E8                           inx
000A6Fr 3               
000A6Fr 3  60           z_d_plus:       rts
000A70r 3               
000A70r 3               
000A70r 3               
000A70r 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
000A70r 3               ; ## "d>s"  auto  ANS double
000A70r 3                       ; """https://forth-standard.org/standard/double/DtoS
000A70r 3                       ; Though this is basically just DROP, we keep it
000A70r 3                       ; separate so we can test for underflow
000A70r 3                       ; """
000A70r 3               
000A70r 3               xt_d_to_s:
000A70r 3  20 rr rr                     jsr underflow_2
000A73r 3               
000A73r 3  E8                           inx
000A74r 3  E8                           inx
000A75r 3               
000A75r 3  60           z_d_to_s:       rts
000A76r 3               
000A76r 3               
000A76r 3               
000A76r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
000A76r 3               ; ## "dabs"  auto  ANS double
000A76r 3                       ; """https://forth-standard.org/standard/double/DABS"""
000A76r 3               
000A76r 3               xt_dabs:
000A76r 3  20 rr rr                     jsr underflow_2 ; double number
000A79r 3               
000A79r 3  B5 01                        lda 1,x         ; MSB of high cell
000A7Br 3  10 17                        bpl @done       ; positive, we get off light
000A7Dr 3               
000A7Dr 3                               ; negative, calculate 0 - d
000A7Dr 3  A0 00                        ldy #0
000A7Fr 3  38                           sec
000A80r 3               
000A80r 3  98                           tya
000A81r 3  F5 02                        sbc 2,x         ; LSB of low cell
000A83r 3  95 02                        sta 2,x
000A85r 3               
000A85r 3  98                           tya
000A86r 3  F5 03                        sbc 3,x         ; MSB of low cell
000A88r 3  95 03                        sta 3,x
000A8Ar 3               
000A8Ar 3  98                           tya
000A8Br 3  F5 00                        sbc 0,x         ; LSB of high cell
000A8Dr 3  95 00                        sta 0,x
000A8Fr 3               
000A8Fr 3  98                           tya
000A90r 3  F5 01                        sbc 1,x         ; MSB of high cell
000A92r 3  95 01                        sta 1,x
000A94r 3               @done:
000A94r 3  60           z_dabs:         rts
000A95r 3               
000A95r 3               
000A95r 3               
000A95r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
000A95r 3               ; ## "decimal"  auto  ANS core
000A95r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
000A95r 3               xt_decimal:
000A95r 3  A9 0A                        lda #10
000A97r 3  85 18                        sta base
000A99r 3  64 19                        stz base+1              ; paranoid
000A9Br 3               
000A9Br 3  60           z_decimal:      rts
000A9Cr 3               
000A9Cr 3               
000A9Cr 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
000A9Cr 3               ; ## "defer"  auto  ANS core ext
000A9Cr 3                       ; """https://forth-standard.org/standard/core/DEFER
000A9Cr 3                       ; Reserve an name that can be linked to various xt by IS.
000A9Cr 3                       ;
000A9Cr 3                       ; The ANS reference implementation is
000A9Cr 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
000A9Cr 3                       ; But we use this routine as a low-level word so things go faster
000A9Cr 3               
000A9Cr 3               xt_defer:
000A9Cr 3  20 rr rr                     jsr xt_create
000A9Fr 3               
000A9Fr 3                               ; CREATE by default installs a subroutine jump to DOVAR,
000A9Fr 3                               ; but we actually want DODEFER this time. Go back two
000A9Fr 3                               ; bytes and repace the subroutine jump target
000A9Fr 3  A5 00                        lda cp          ; LSB
000AA1r 3  38                           sec
000AA2r 3  E9 02                        sbc #2
000AA4r 3  85 24                        sta tmp1
000AA6r 3               
000AA6r 3  A5 01                        lda cp+1        ; MSB
000AA8r 3  E9 00                        sbc #0          ; we only care about the borrow
000AAAr 3  85 25                        sta tmp1+1
000AACr 3               
000AACr 3                               ; Save the target address
000AACr 3  A0 00                        ldy #0
000AAEr 3  A9 rr                        lda #<dodefer   ; LSB
000AB0r 3  91 24                        sta (tmp1),y
000AB2r 3  C8                           iny
000AB3r 3  A9 rr                        lda #>dodefer   ; MSB
000AB5r 3  91 24                        sta (tmp1),y
000AB7r 3               
000AB7r 3               
000AB7r 3                               ; DODEFER executes the next address it finds after
000AB7r 3                               ; its call. As default, we include the error
000AB7r 3                               ; "Defer not defined"
000AB7r 3  A9 rr                        lda #<defer_error
000AB9r 3  92 00                        sta (cp)
000ABBr 3  E6 00                        inc cp
000ABDr 3  D0 02                        bne @1
000ABFr 3  E6 01                        inc cp+1
000AC1r 3               @1:
000AC1r 3  A9 rr                        lda #>defer_error
000AC3r 3  92 00                        sta (cp)
000AC5r 3  E6 00                        inc cp
000AC7r 3  D0 02                        bne @2
000AC9r 3  E6 01                        inc cp+1
000ACBr 3               @2:
000ACBr 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
000ACEr 3               
000ACEr 3  60           z_defer:        rts
000ACFr 3               
000ACFr 3               
000ACFr 3               
000ACFr 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
000ACFr 3               ; ## "defer@"  auto  ANS core ext
000ACFr 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
000ACFr 3               
000ACFr 3               xt_defer_fetch:
000ACFr 3                               ; No underflow checking as >BODY does it.
000ACFr 3  20 rr rr                     jsr xt_to_body
000AD2r 3  20 rr rr                     jsr xt_fetch
000AD5r 3  60           z_defer_fetch:  rts
000AD6r 3               
000AD6r 3               
000AD6r 3               
000AD6r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
000AD6r 3               ; ## "defer!"  auto  ANS core ext
000AD6r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
000AD6r 3               
000AD6r 3               xt_defer_store:
000AD6r 3                               ; No underflow checking as >BODY and ! do it.
000AD6r 3  20 rr rr                     jsr xt_to_body
000AD9r 3  20 rr rr                     jsr xt_store
000ADCr 3  60           z_defer_store:  rts
000ADDr 3               
000ADDr 3               
000ADDr 3               
000ADDr 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
000ADDr 3               ; ## "definitions" auto ANS search
000ADDr 3               xt_definitions:
000ADDr 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
000ADFr 3  B1 1E                        lda (up),y                  ; SEARCH_ORDER[0] to
000AE1r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
000AE3r 3  91 1E                        sta (up),y
000AE5r 3  60           z_definitions:  rts
000AE6r 3               
000AE6r 3               
000AE6r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
000AE6r 3               ; ## "depth"  auto  ANS core
000AE6r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
000AE6r 3               xt_depth:
000AE6r 3  A9 78                        lda #dsp0
000AE8r 3  86 2A                        stx tmpdsp
000AEAr 3  38                           sec
000AEBr 3  E5 2A                        sbc tmpdsp
000AEDr 3               
000AEDr 3                               ; divide by two because each cell is two bytes
000AEDr 3  4A                           lsr
000AEEr 3               
000AEEr 3  CA                           dex
000AEFr 3  CA                           dex
000AF0r 3  95 00                        sta 0,x
000AF2r 3  74 01                        stz 1,x
000AF4r 3               
000AF4r 3  60           z_depth:        rts
000AF5r 3               
000AF5r 3               
000AF5r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
000AF5r 3               ; ## "digit?"  auto  Tali Forth
000AF5r 3                       ; """Inspired by the pForth instruction DIGIT, see
000AF5r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
000AF5r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
000AF5r 3                       ; pForth, we get the base (radix) ourselves instead of having the
000AF5r 3                       ; user provide it. There is no standard name for this routine, which
000AF5r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
000AF5r 3                       ; """
000AF5r 3               
000AF5r 3               xt_digit_question:
000AF5r 3  20 rr rr                     jsr underflow_1
000AF8r 3               
000AF8r 3                               ; one way or another, we're going to need room for the
000AF8r 3                               ; flag on the stack
000AF8r 3  CA                           dex
000AF9r 3  CA                           dex
000AFAr 3  74 00                        stz 0,x                 ; default flag is failure
000AFCr 3  74 01                        stz 1,x
000AFEr 3  74 03                        stz 3,x                 ; paranoid
000B00r 3               
000B00r 3                               ; Check the character, now in the LSB of NOS. First, make
000B00r 3                               ; sure we're not below the ASCII code for "0"
000B00r 3  B5 02                        lda 2,x
000B02r 3  C9 30                        cmp #'0'
000B04r 3  90 23                        bcc @done               ; failure flag already set
000B06r 3               
000B06r 3                               ; Next, see if we are below "9", because that would make
000B06r 3                               ; this a normal number
000B06r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
000B08r 3  90 12                        bcc @checkbase
000B0Ar 3               
000B0Ar 3                               ; Well, then let's see if this is the gap between "9" and "A"
000B0Ar 3                               ; so we can treat the whole range as a number
000B0Ar 3  C9 41                        cmp #'A'
000B0Cr 3  90 1B                        bcc @done               ; failure flag is already set
000B0Er 3               
000B0Er 3                               ; probably a letter, so we make sure it is uppercase
000B0Er 3  C9 61                        cmp #'a'
000B10r 3  90 07                        bcc @case_done          ; not lower case, too low
000B12r 3  C9 7B                        cmp #'z'+1
000B14r 3  B0 03                        bcs @case_done          ; not lower case, too high
000B16r 3               
000B16r 3  18                           clc                     ; just right
000B17r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
000B19r 3               
000B19r 3               @case_done:
000B19r 3                               ; get rid of the gap between "9" and "A" so we can treat
000B19r 3                               ; the whole range as one number
000B19r 3  38                           sec
000B1Ar 3  E9 07                        sbc #7                  ; fall through to @checkbase
000B1Cr 3               
000B1Cr 3               @checkbase:
000B1Cr 3                               ; we have a number, now see if it falls inside the range
000B1Cr 3                               ; provided by BASE
000B1Cr 3  38                           sec
000B1Dr 3  E9 30                        sbc #'0'                 ; this is also the conversion step
000B1Fr 3  C5 18                        cmp base
000B21r 3  B0 06                        bcs @done               ; already have false flag
000B23r 3               
000B23r 3                               ; Found a legal number
000B23r 3  95 02                        sta 2,x                 ; put number in NOS
000B25r 3  D6 00                        dec 0,x                 ; set success flag
000B27r 3  D6 01                        dec 1,x
000B29r 3               
000B29r 3               @done:
000B29r 3               z_digit_question:
000B29r 3  60                           rts
000B2Ar 3               
000B2Ar 3               
000B2Ar 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
000B2Ar 3               ; ## "disasm"  tested  Tali Forth
000B2Ar 3                       ; """Convert a segment of memory to assembler output. This
000B2Ar 3                       ; word is vectored so people can add their own disassembler.
000B2Ar 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
000B2Ar 3                       ; code, see the section on The Disassembler in the manual and
000B2Ar 3                       ; the file disassembler.asm for more details.
000B2Ar 3                       ; """
000B2Ar 3               xt_disasm:
000B2Ar 3  20 rr rr                     jsr underflow_2
000B2Dr 3               
000B2Dr 3  20 rr rr                     jsr disassembler
000B30r 3               
000B30r 3  60           z_disasm:       rts
000B31r 3               
000B31r 3               
000B31r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
000B31r 3               ; ## "dnegate"  auto  ANS double
000B31r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
000B31r 3               xt_dnegate:
000B31r 3  20 rr rr                     jsr underflow_2 ; double number
000B34r 3               
000B34r 3  A0 00             		ldy #0
000B36r 3  38                           sec
000B37r 3               
000B37r 3  98                           tya
000B38r 3  F5 02                        sbc 2,x         ; LSB of low cell
000B3Ar 3  95 02                        sta 2,x
000B3Cr 3               
000B3Cr 3  98                           tya
000B3Dr 3  F5 03                        sbc 3,x         ; MSB of low cell
000B3Fr 3  95 03                        sta 3,x
000B41r 3               
000B41r 3  98                           tya
000B42r 3  F5 00                        sbc 0,x         ; LSB of high cell
000B44r 3  95 00                        sta 0,x
000B46r 3               
000B46r 3  98                           tya
000B47r 3  F5 01                        sbc 1,x         ; MSB of high cell
000B49r 3  95 01                        sta 1,x
000B4Br 3               
000B4Br 3  60           z_dnegate:      rts
000B4Cr 3               
000B4Cr 3               
000B4Cr 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
000B4Cr 3               ; ## "?do"  auto  ANS core ext
000B4Cr 3                       ; """https://forth-standard.org/standard/core/qDO"""
000B4Cr 3               xt_question_do:
000B4Cr 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
000B4Cr 3                               ; to mark which is which
000B4Cr 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
000B4Er 3  85 24                        sta tmp1
000B50r 3  80 02                        bra do_common           ; skip flag for DO
000B52r 3               
000B52r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
000B52r 3               ; ## "do"  auto  ANS core
000B52r 3                       ; """https://forth-standard.org/standard/core/DO
000B52r 3                       ;
000B52r 3                       ; Compile-time part of DO. Could be realized in Forth as
000B52r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
000B52r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
000B52r 3                       ; a routine that pushes the end address to the Return Stack at run
000B52r 3                       ; time. This is based on a suggestion by Garth Wilson, see
000B52r 3                       ; the Control Flow section of the manual for details.
000B52r 3                       ;
000B52r 3                       ; This may not be native compile. Don't check for a stack underflow
000B52r 3                       ; """
000B52r 3               
000B52r 3               xt_do:
000B52r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
000B52r 3  64 24                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
000B54r 3               do_common:
000B54r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
000B54r 3                               ; compile the address we need to LDA at runtime
000B54r 3  CA                           dex
000B55r 3  CA                           dex
000B56r 3  A5 00                        lda cp
000B58r 3  95 00                        sta 0,x                 ; LSB
000B5Ar 3  A5 01                        lda cp+1
000B5Cr 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
000B5Er 3               
000B5Er 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
000B5Er 3                               ; replace by the actual LDA/PHA instructions
000B5Er 3  A9 05                        lda #5                  ; we don't really care about the value,
000B60r 3  A8                           tay                     ; so we use 5 to be tricky
000B61r 3               @loop:
000B61r 3  91 00                        sta (cp),y
000B63r 3  88                           dey
000B64r 3  10 FB                        bpl @loop
000B66r 3               
000B66r 3                               ; update CP
000B66r 3  1A                           inc             ; we used 5 as a dummy value, this is why
000B67r 3  18                           clc
000B68r 3  65 00                        adc cp
000B6Ar 3  85 00                        sta cp
000B6Cr 3  90 02                        bcc @1
000B6Er 3  E6 01                        inc cp+1
000B70r 3               @1:
000B70r 3                               ; compile the (?DO) portion of ?DO if appropriate
000B70r 3  A5 24                        lda tmp1
000B72r 3  F0 17                        beq @compile_do
000B74r 3               
000B74r 3                               ; We came from ?DO, so compile its runtime first. We do
000B74r 3                               ; this with a quick loop because we know it has to be
000B74r 3                               ; Always Native anyway
000B74r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
000B76r 3  5A                           phy             ; save counter to calculate new CP
000B77r 3               @2:
000B77r 3  B9 rr rr                     lda question_do_runtime,y
000B7Ar 3  91 00                        sta (cp),y
000B7Cr 3  88                           dey
000B7Dr 3  10 F8                        bpl @2
000B7Fr 3               
000B7Fr 3                               ; adjust CP
000B7Fr 3  68                           pla             ; retrieve counter
000B80r 3  18                           clc
000B81r 3  65 00                        adc cp
000B83r 3  85 00                        sta cp
000B85r 3  A5 01                        lda cp+1
000B87r 3  69 00                        adc #0          ; only care about carry
000B89r 3  85 01                        sta cp+1        ; fall through to @compile_do
000B8Br 3               
000B8Br 3               @compile_do:
000B8Br 3                               ; compile runtime part of DO.
000B8Br 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
000B8Dr 3  5A                           phy             ; save counter to calculate new CP
000B8Er 3               @3:
000B8Er 3  B9 rr rr                     lda do_runtime,y
000B91r 3  91 00                        sta (cp),y
000B93r 3  88                           dey
000B94r 3  10 F8                        bpl @3
000B96r 3               
000B96r 3                               ; adjust CP
000B96r 3  68                           pla             ; retrieve counter
000B97r 3  18                           clc
000B98r 3  65 00                        adc cp
000B9Ar 3  85 00                        sta cp
000B9Cr 3  A5 01                        lda cp+1
000B9Er 3  69 00                        adc #0          ; only care about carry
000BA0r 3  85 01                        sta cp+1
000BA2r 3               
000BA2r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
000BA2r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
000BA2r 3                               ; do with the HERE we're saving for LEAVE
000BA2r 3  CA                           dex
000BA3r 3  CA                           dex
000BA4r 3  A5 00                        lda cp          ; LSB
000BA6r 3  95 00                        sta 0,x
000BA8r 3  A5 01                        lda cp+1        ; MSB
000BAAr 3  95 01                        sta 1,x
000BACr 3               z_question_do:
000BACr 3  60           z_do:           rts
000BADr 3               
000BADr 3               
000BADr 3               do_runtime:
000BADr 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
000BADr 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
000BADr 3                       ; the FIG Forth loop (you can see which version you have by running
000BADr 3                       ; a loop with start and limit as the same value, for instance
000BADr 3                       ; 0 0 DO -- these will walk through the number space). We use a
000BADr 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
000BADr 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
000BADr 3                       ; for further discussion of this. The source given there for
000BADr 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
000BADr 3                       ; in some Forths. Usually, we would define this as a separate word
000BADr 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
000BADr 3                       ; However, we can do it faster if we just copy the bytes
000BADr 3                       ; of this routine with a simple loop in DO.
000BADr 3                       ; """
000BADr 3                               ; First step: create fudge factor (FUFA) by subtracting the
000BADr 3                               ; limit from $8000, the number that will trip the overflow
000BADr 3                               ; flag
000BADr 3  38                           sec
000BAEr 3  A9 00                        lda #0
000BB0r 3  F5 02                        sbc 2,x         ; LSB of limit
000BB2r 3  95 02                        sta 2,x         ; save FUFA for later use
000BB4r 3               
000BB4r 3  A9 80                        lda #$80
000BB6r 3  F5 03                        sbc 3,x         ; MSB of limit
000BB8r 3  95 03                        sta 3,x         ; save FUFA for later use
000BBAr 3  48                           pha             ; FUFA replaces limit on R stack
000BBBr 3  B5 02                        lda 2,x         ; LSB of limit
000BBDr 3  48                           pha
000BBEr 3               
000BBEr 3                               ; Second step: index is FUFA plus original index
000BBEr 3  18                           clc
000BBFr 3  B5 00                        lda 0,x         ; LSB of original index
000BC1r 3  75 02                        adc 2,x         ; add LSB of FUFA
000BC3r 3  95 00                        sta 0,x
000BC5r 3  B5 01                        lda 1,x         ; MSB of orginal index
000BC7r 3  75 03                        adc 3,x         ; add MSB of FUFA
000BC9r 3  48                           pha
000BCAr 3  B5 00                        lda 0,x         ; LSB of index
000BCCr 3  48                           pha
000BCDr 3               
000BCDr 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
000BCDr 3                               ; use it later. Clean the Data Stack
000BCDr 3  E8                           inx
000BCEr 3  E8                           inx
000BCFr 3  E8                           inx
000BD0r 3  E8                           inx             ; no RTS because this is copied into code
000BD1r 3               do_runtime_end:
000BD1r 3               
000BD1r 3               question_do_runtime:
000BD1r 3               
000BD1r 3                       ; """This is called (?DO) in some Forths. See the explanation at
000BD1r 3                       ; do_runtime for the background on this design
000BD1r 3                       ; """
000BD1r 3                               ; see if TOS and NOS are equal. Change this to assembler
000BD1r 3                               ; for speed
000BD1r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
000BD4r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
000BD7r 3               
000BD7r 3  B5 00                        lda 0,x
000BD9r 3  15 01                        ora 1,x
000BDBr 3  F0 06                        beq @do_do
000BDDr 3               
000BDDr 3                               ; We're equal, so dump everything and jump beyond the loop.
000BDDr 3                               ; But first, dump six entries off of the Data Stack
000BDDr 3  8A                           txa
000BDEr 3  18                           clc
000BDFr 3  69 06                        adc #6
000BE1r 3  AA                           tax
000BE2r 3               
000BE2r 3                               ; Then abort the whole loop
000BE2r 3  60                           rts
000BE3r 3               @do_do:
000BE3r 3  E8                           inx             ; clear flag from EQUAL off stack
000BE4r 3  E8                           inx             ; no RTS because this is copied into code
000BE5r 3               question_do_runtime_end:
000BE5r 3               
000BE5r 3               
000BE5r 3               
000BE5r 3               ; ## DOES ( -- ) "Add payload when defining new words"
000BE5r 3               ; ## "does>"  auto  ANS core
000BE5r 3                       ; """https://forth-standard.org/standard/core/DOES
000BE5r 3                       ; Create the payload for defining new defining words. See
000BE5r 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
000BE5r 3                       ; the Developer Guide in the manual for a discussion of
000BE5r 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
000BE5r 3                       ; """
000BE5r 3               
000BE5r 3               xt_does:
000BE5r 3                               ; compile a subroutine jump to runtime of DOES>
000BE5r 3  A0 rr                        ldy #>does_runtime
000BE7r 3  A9 rr                        lda #<does_runtime
000BE9r 3  20 rr rr                     jsr cmpl_subroutine
000BECr 3               
000BECr 3                               ; compile a subroutine jump to DODOES. In traditional
000BECr 3                               ; terms, this is the Code Field Area (CFA) of the new
000BECr 3                               ; word
000BECr 3  A0 rr                        ldy #>dodoes
000BEEr 3  A9 rr                        lda #<dodoes
000BF0r 3  20 rr rr                     jsr cmpl_subroutine
000BF3r 3               
000BF3r 3  60           z_does:         rts
000BF4r 3               
000BF4r 3               
000BF4r 3               does_runtime:
000BF4r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
000BF4r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
000BF4r 3                       ; address that contains a subroutine jump to DODOES. We don't
000BF4r 3                       ; jump to DODOES directly because we need to work our magic with
000BF4r 3                       ; the return addresses. This routine is also known as "(DOES)" in
000BF4r 3                       ; other Forths
000BF4r 3                       ; """
000BF4r 3               
000BF4r 3  7A                           ply             ; LSB
000BF5r 3  68                           pla             ; MSB
000BF6r 3               
000BF6r 3  C8                           iny
000BF7r 3  D0 01                        bne @1
000BF9r 3  1A                           inc
000BFAr 3               @1:
000BFAr 3  84 24                        sty tmp1
000BFCr 3  85 25                        sta tmp1+1
000BFEr 3               
000BFEr 3                               ; CREATE has also already modified the DP to point to the new
000BFEr 3                               ; word. We have no idea which instructions followed the CREATE
000BFEr 3                               ; command if there is a DOES> so the CP could point anywhere
000BFEr 3                               ; by now. The address of the word's xt is four bytes down.
000BFEr 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
000C01r 3  A5 02                        lda dp
000C03r 3  18                           clc
000C04r 3  69 04                        adc #4
000C06r 3  85 26                        sta tmp2
000C08r 3  A5 03                        lda dp+1
000C0Ar 3  69 00                        adc #0          ; we only care about the carry
000C0Cr 3  85 27                        sta tmp2+1
000C0Er 3               
000C0Er 3                               ; Now we get that address and add one byte to skip over the JSR
000C0Er 3                               ; opcode
000C0Er 3  B2 26                        lda (tmp2)
000C10r 3  18                           clc
000C11r 3  69 01                        adc #1
000C13r 3  85 28                        sta tmp3
000C15r 3  A0 01                        ldy #1
000C17r 3  B1 26                        lda (tmp2),y
000C19r 3  69 00                        adc #0          ; we only care about the carry
000C1Br 3  85 29                        sta tmp3+1
000C1Dr 3               
000C1Dr 3                               ; Replace the DOVAR address with our own
000C1Dr 3  A5 24                        lda tmp1        ; LSB
000C1Fr 3  92 28                        sta (tmp3)
000C21r 3  A5 25                        lda tmp1+1
000C23r 3  91 28                        sta (tmp3),y    ; Y is still 1
000C25r 3               
000C25r 3                               ; Since we removed the return address that brought us here, we
000C25r 3                               ; go back to whatever the main routine was. Otherwise, we we
000C25r 3                               ; smash into the subroutine jump to DODOES.
000C25r 3  60                           rts
000C26r 3               
000C26r 3               
000C26r 3               
000C26r 3               ; ## DOT ( u -- ) "Print TOS"
000C26r 3               ; ## "."  auto  ANS core
000C26r 3                       ; """https://forth-standard.org/standard/core/d"""
000C26r 3               
000C26r 3               xt_dot:
000C26r 3  20 rr rr                     jsr underflow_1
000C29r 3               
000C29r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
000C2Cr 3  20 rr rr                     jsr xt_abs                      ; ( n u )
000C2Fr 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
000C32r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
000C35r 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
000C38r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
000C3Br 3  20 rr rr                     jsr xt_sign                     ; ( ud )
000C3Er 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
000C41r 3  20 rr rr                     jsr xt_type
000C44r 3  20 rr rr                     jsr xt_space
000C47r 3               
000C47r 3  60           z_dot:          rts
000C48r 3               
000C48r 3               
000C48r 3               
000C48r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
000C48r 3               ; ## ".("  auto  ANS core
000C48r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
000C48r 3               
000C48r 3               xt_dot_paren:
000C48r 3                               ; Put a right paren on the stack.
000C48r 3  CA                           dex
000C49r 3  CA                           dex
000C4Ar 3  A9 29                        lda #41     ; Right parenthesis
000C4Cr 3  95 00                        sta 0,x
000C4Er 3  74 01                        stz 1,x
000C50r 3               
000C50r 3  20 rr rr                     jsr xt_parse
000C53r 3  20 rr rr                     jsr xt_type
000C56r 3               
000C56r 3  60           z_dot_paren:    rts
000C57r 3               
000C57r 3               
000C57r 3               
000C57r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
000C57r 3               ; ## ".""  auto  ANS core ext
000C57r 3                       ; """https://forth-standard.org/standard/core/Dotq
000C57r 3                       ; Compile string that is printed during run time. ANS Forth wants
000C57r 3                       ; this to be compile-only, even though everybody and their friend
000C57r 3                       ; uses it for everything. We follow the book here, and recommend
000C57r 3                       ; `.(` for general printing.
000C57r 3                       ; """
000C57r 3               
000C57r 3               xt_dot_quote:
000C57r 3                               ; we let S" do the heavy lifting. Since we're in
000C57r 3                               ; compile mode, it will save the string and reproduce it
000C57r 3                               ; during runtime
000C57r 3  20 rr rr                     jsr xt_s_quote
000C5Ar 3               
000C5Ar 3                               ; We then let TYPE do the actual printing
000C5Ar 3  A0 rr                        ldy #>xt_type
000C5Cr 3  A9 rr                        lda #<xt_type
000C5Er 3  20 rr rr                     jsr cmpl_subroutine
000C61r 3               
000C61r 3  60           z_dot_quote:    rts
000C62r 3               
000C62r 3               
000C62r 3               
000C62r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
000C62r 3               ; ## ".r"  tested  ANS core ext
000C62r 3                       ; """https://forth-standard.org/standard/core/DotR
000C62r 3                       ;
000C62r 3                       ; Based on the Forth code
000C62r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
000C62r 3                       ; """
000C62r 3               
000C62r 3               xt_dot_r:
000C62r 3  20 rr rr                     jsr underflow_2
000C65r 3               
000C65r 3  20 rr rr                     jsr xt_to_r
000C68r 3  20 rr rr                     jsr xt_dup
000C6Br 3  20 rr rr                     jsr xt_abs
000C6Er 3  20 rr rr                     jsr xt_zero
000C71r 3  20 rr rr                     jsr xt_less_number_sign
000C74r 3  20 rr rr                     jsr xt_number_sign_s
000C77r 3  20 rr rr                     jsr xt_rot
000C7Ar 3  20 rr rr                     jsr xt_sign
000C7Dr 3  20 rr rr                     jsr xt_number_sign_greater
000C80r 3  20 rr rr                     jsr xt_r_from
000C83r 3  20 rr rr                     jsr xt_over
000C86r 3  20 rr rr                     jsr xt_minus
000C89r 3  20 rr rr                     jsr xt_spaces
000C8Cr 3  20 rr rr                     jsr xt_type
000C8Fr 3               
000C8Fr 3  60           z_dot_r:        rts
000C90r 3               
000C90r 3               
000C90r 3               
000C90r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
000C90r 3               ; ## ".s"  tested  ANS tools
000C90r 3                       ; """https://forth-standard.org/standard/tools/DotS
000C90r 3                       ; Print content of Data Stack non-distructively. We follow the format
000C90r 3                       ; of Gforth and print the number of elements first in brackets,
000C90r 3                       ; followed by the Data Stack content (if any).
000C90r 3                       ;
000C90r 3                       ; Since this is for humans, we don't have to worry about speed.
000C90r 3                       ; """
000C90r 3               
000C90r 3               xt_dot_s:
000C90r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
000C93r 3               
000C93r 3                               ; Print stack depth in brackets
000C93r 3  A9 3C                        lda #$3c        ; ASCII for "<"
000C95r 3  20 rr rr                     jsr emit_a
000C98r 3               
000C98r 3                               ; We keep a copy of the number of the things on the stack
000C98r 3                               ; to use as a counter later down. This assumes that there
000C98r 3                               ; are less than 255 elements on the stack
000C98r 3  B5 00                        lda 0,x
000C9Ar 3  48                           pha
000C9Br 3               
000C9Br 3                               ; print unsigned number without the trailing space
000C9Br 3  CA                           dex             ; DUP
000C9Cr 3  CA                           dex
000C9Dr 3  95 00                        sta 0,x
000C9Fr 3  74 01                        stz 1,x
000CA1r 3               
000CA1r 3  20 rr rr                     jsr print_u
000CA4r 3               
000CA4r 3  A9 3E                        lda #$3e        ; ASCII for ">"
000CA6r 3  20 rr rr                     jsr emit_a
000CA9r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
000CABr 3  20 rr rr                     jsr emit_a
000CAEr 3               
000CAEr 3  E8                           inx
000CAFr 3  E8                           inx
000CB0r 3               
000CB0r 3                               ; There will be lots of cases where the stack is empty. If that
000CB0r 3                               ; is so, get out of here quickly
000CB0r 3  E0 78                        cpx #dsp0
000CB2r 3  F0 1E                        beq @done
000CB4r 3               
000CB4r 3               @have_stack:
000CB4r 3                               ; We have at least one element on the stack. The depth of the
000CB4r 3                               ; stack is on the stack, we can use it as a counter. We go
000CB4r 3                               ; from bottom to top
000CB4r 3  7A                           ply
000CB5r 3               
000CB5r 3  A9 77                        lda #dsp0-1     ; go up one to avoid garbage
000CB7r 3  85 28                        sta tmp3
000CB9r 3  64 29                        stz tmp3+1      ; must be zero page on the 65c02
000CBBr 3               @loop:
000CBBr 3  CA                           dex
000CBCr 3  CA                           dex
000CBDr 3               
000CBDr 3  B2 28                        lda (tmp3)
000CBFr 3  95 01                        sta 1,x
000CC1r 3  C6 28                        dec tmp3
000CC3r 3               
000CC3r 3  B2 28                        lda (tmp3)
000CC5r 3  95 00                        sta 0,x
000CC7r 3  C6 28                        dec tmp3
000CC9r 3  5A                           phy
000CCAr 3               
000CCAr 3  20 rr rr                     jsr xt_dot
000CCDr 3               
000CCDr 3  7A                           ply
000CCEr 3  88                           dey
000CCFr 3  D0 EA                        bne @loop
000CD1r 3               
000CD1r 3  48                           pha             ; dummy to balance stack
000CD2r 3               @done:
000CD2r 3  68                           pla
000CD3r 3  60           z_dot_s:        rts
000CD4r 3               
000CD4r 3               
000CD4r 3               
000CD4r 3               ; ## D_DOT ( d -- ) "Print double"
000CD4r 3               ; ## "d."  tested  ANS double
000CD4r 3                       ; """http://forth-standard.org/standard/double/Dd"""
000CD4r 3                       ;
000CD4r 3                       ; From the Forth code:
000CD4r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
000CD4r 3                       ; """
000CD4r 3               
000CD4r 3               xt_d_dot:
000CD4r 3  20 rr rr                     jsr underflow_2
000CD7r 3               
000CD7r 3  20 rr rr                     jsr xt_tuck
000CDAr 3  20 rr rr                     jsr xt_dabs
000CDDr 3  20 rr rr                     jsr xt_less_number_sign
000CE0r 3  20 rr rr                     jsr xt_number_sign_s
000CE3r 3  20 rr rr                     jsr xt_rot
000CE6r 3  20 rr rr                     jsr xt_sign
000CE9r 3  20 rr rr                     jsr xt_number_sign_greater
000CECr 3  20 rr rr                     jsr xt_type
000CEFr 3  20 rr rr                     jsr xt_space
000CF2r 3               
000CF2r 3  60           z_d_dot:        rts
000CF3r 3               
000CF3r 3               
000CF3r 3               
000CF3r 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
000CF3r 3               ; ## "d.r"  tested  ANS double
000CF3r 3                       ; """http://forth-standard.org/standard/double/DDotR"""
000CF3r 3                       ; Based on the Forth code
000CF3r 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
000CF3r 3                       ; """
000CF3r 3               
000CF3r 3               xt_d_dot_r:
000CF3r 3  20 rr rr                     jsr underflow_3
000CF6r 3                               ; From the forth code:
000CF6r 3  20 rr rr                     jsr xt_to_r
000CF9r 3  20 rr rr                     jsr xt_tuck
000CFCr 3  20 rr rr                     jsr xt_dabs
000CFFr 3  20 rr rr                     jsr xt_less_number_sign
000D02r 3  20 rr rr                     jsr xt_number_sign_s
000D05r 3  20 rr rr                     jsr xt_rot
000D08r 3  20 rr rr                     jsr xt_sign
000D0Br 3  20 rr rr                     jsr xt_number_sign_greater
000D0Er 3  20 rr rr                     jsr xt_r_from
000D11r 3  20 rr rr                     jsr xt_over
000D14r 3  20 rr rr                     jsr xt_minus
000D17r 3  20 rr rr                     jsr xt_spaces
000D1Ar 3  20 rr rr                     jsr xt_type
000D1Dr 3               
000D1Dr 3  60           z_d_dot_r:      rts
000D1Er 3               
000D1Er 3               
000D1Er 3               
000D1Er 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
000D1Er 3               ; ## "drop"  auto  ANS core
000D1Er 3                       ; """https://forth-standard.org/standard/core/DROP"""
000D1Er 3               xt_drop:
000D1Er 3  20 rr rr                     jsr underflow_1
000D21r 3               
000D21r 3  E8                           inx
000D22r 3  E8                           inx
000D23r 3               
000D23r 3  60           z_drop:         rts
000D24r 3               
000D24r 3               
000D24r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
000D24r 3               ; ## "dump"  tested  ANS tools
000D24r 3                       ; """https://forth-standard.org/standard/tools/DUMP
000D24r 3                       ;
000D24r 3                       ; DUMP's exact output is defined as "implementation dependent".
000D24r 3                       ; This is in assembler because it is
000D24r 3                       ; useful for testing and development, so we want to have it work
000D24r 3                       ; as soon as possible. Uses TMP2
000D24r 3                       ; """
000D24r 3               
000D24r 3               xt_dump:
000D24r 3  20 rr rr                     jsr underflow_2
000D27r 3               @row:
000D27r 3                               ; start counter for 16 numbers per row
000D27r 3  A0 10                        ldy #16
000D29r 3               
000D29r 3                               ; We use TMP2 as the index for the ASCII characters
000D29r 3                               ; that we print at the and of the hex block. We
000D29r 3                               ; start saving them at HERE (CP)
000D29r 3  64 26                        stz tmp2
000D2Br 3               
000D2Br 3  20 rr rr                     jsr xt_cr
000D2Er 3               
000D2Er 3                               ; print address number
000D2Er 3  B5 03                        lda 3,x
000D30r 3  20 rr rr                     jsr byte_to_ascii
000D33r 3  B5 02                        lda 2,x
000D35r 3  20 rr rr                     jsr byte_to_ascii
000D38r 3               
000D38r 3  20 rr rr                     jsr xt_space
000D3Br 3  20 rr rr                     jsr xt_space
000D3Er 3               @loop:
000D3Er 3                               ; if there are zero bytes left to display, we're done
000D3Er 3  B5 00                        lda 0,x
000D40r 3  15 01                        ora 1,x
000D42r 3  F0 39                        beq @all_printed
000D44r 3               
000D44r 3                               ; dump the contents
000D44r 3  A1 02                        lda (2,x)
000D46r 3  48                           pha                     ; byte_to_ascii destroys A
000D47r 3  20 rr rr                     jsr byte_to_ascii
000D4Ar 3  20 rr rr                     jsr xt_space
000D4Dr 3  68                           pla
000D4Er 3               
000D4Er 3                               ; Handle ASCII printing
000D4Er 3  20 rr rr                     jsr is_printable
000D51r 3  B0 02                        bcs @printable
000D53r 3  A9 2E                        lda #'.'                 ; Print dot if not printable
000D55r 3               @printable:
000D55r 3  5A                           phy                     ; save counter
000D56r 3  A4 26                        ldy tmp2
000D58r 3  91 00                        sta (cp),y
000D5Ar 3  E6 26                        inc tmp2
000D5Cr 3  7A                           ply
000D5Dr 3               
000D5Dr 3                               ; extra space after eight bytes
000D5Dr 3  C0 09                        cpy #9
000D5Fr 3  D0 03                        bne @next_char
000D61r 3  20 rr rr                     jsr xt_space
000D64r 3               
000D64r 3               @next_char:
000D64r 3  F6 02                        inc 2,x
000D66r 3  D0 02                        bne @counter
000D68r 3  F6 03                        inc 3,x
000D6Ar 3               
000D6Ar 3               @counter:
000D6Ar 3                               ; loop counter
000D6Ar 3  B5 00                        lda 0,x
000D6Cr 3  D0 02                        bne @1
000D6Er 3  D6 01                        dec 1,x
000D70r 3               @1:
000D70r 3  D6 00                        dec 0,x
000D72r 3  88                           dey
000D73r 3  D0 C9                        bne @loop               ; next byte
000D75r 3               
000D75r 3                               ; Done with one line, print the ASCII version of these
000D75r 3                               ; characters
000D75r 3  20 rr rr                     jsr xt_space
000D78r 3  20 rr rr                     jsr print_ascii
000D7Br 3               
000D7Br 3  80 AA                        bra @row                ; new row
000D7Dr 3               
000D7Dr 3               @all_printed:
000D7Dr 3                               ; See if there are any ASCII characters in the buffer
000D7Dr 3                               ; left to print
000D7Dr 3  A5 26                        lda tmp2
000D7Fr 3  F0 06                        beq @done
000D81r 3               
000D81r 3                               ; In theory, we could try to make the ASCII part line
000D81r 3                               ; up with the line before it. But that is a hassle (we
000D81r 3                               ; use three bytes for each missed hex entry, and
000D81r 3                               ; then there is the gap after eight entries) and it
000D81r 3                               ; makes it harder to read. We settle for one extra
000D81r 3                               ; space instead for the moment
000D81r 3  20 rr rr                     jsr xt_space
000D84r 3  20 rr rr                     jsr print_ascii
000D87r 3               @done:
000D87r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
000D8Ar 3  60           z_dump:         rts
000D8Br 3               
000D8Br 3               
000D8Br 3               print_ascii:
000D8Br 3                               ; Print the ASCII characters that we have saved from
000D8Br 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
000D8Br 3                               ; is not compiled (DUMP is probably never compiled anyway)
000D8Br 3                               ; but we keep it inside the scope of DUMP.
000D8Br 3  A0 00                        ldy #0
000D8Dr 3               @ascii_loop:
000D8Dr 3  B1 00                        lda (cp),y
000D8Fr 3  20 rr rr                     jsr emit_a
000D92r 3  C8                           iny
000D93r 3               
000D93r 3                               ; extra space after eight chars
000D93r 3  C0 08                        cpy #8
000D95r 3  D0 03                        bne @1
000D97r 3  20 rr rr                     jsr xt_space
000D9Ar 3               @1:
000D9Ar 3  C6 26                        dec tmp2
000D9Cr 3  D0 EF                        bne @ascii_loop
000D9Er 3               
000D9Er 3  60                           rts
000D9Fr 3               
000D9Fr 3               
000D9Fr 3               
000D9Fr 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
000D9Fr 3               ; ## "dup"  auto  ANS core
000D9Fr 3                       ; """https://forth-standard.org/standard/core/DUP"""
000D9Fr 3               xt_dup:
000D9Fr 3  20 rr rr                     jsr underflow_1
000DA2r 3               
000DA2r 3  CA                           dex
000DA3r 3  CA                           dex
000DA4r 3               
000DA4r 3  B5 02                        lda 2,x         ; LSB
000DA6r 3  95 00                        sta 0,x
000DA8r 3  B5 03                        lda 3,x         ; MSB
000DAAr 3  95 01                        sta 1,x
000DACr 3               
000DACr 3  60           z_dup:          rts
000DADr 3               
000DADr 3               
000DADr 3               ; ## ED ( -- u ) "Line-based editor"
000DADr 3               ; ## "ed"  fragment  Tali Forth
000DADr 3                       ; """Start the line-based editor ed6502. See separate file
000DADr 3                       ; ed.asm or the manual for details.
000DADr 3                       ; """
000DADr 3               xt_ed:
000DADr 3  20 rr rr                     jsr ed6502      ; kept in separate file
000DB0r 3               
000DB0r 3  60           z_ed:           rts
000DB1r 3               
000DB1r 3               
000DB1r 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
000DB1r 3               ; ## "editor-wordlist"  tested  Tali Editor
000DB1r 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
000DB1r 3                       ; words to the search order so they can be used.  This will need
000DB1r 3                       ; to be done before any of the words marked "Tali Editor" can be
000DB1r 3                       ; used.  See the tutorial on Wordlists and the Search Order for
000DB1r 3                       ; more information.
000DB1r 3               
000DB1r 3                       ;
000DB1r 3                       ; This is a dummy entry, the code is shared with ONE
000DB1r 3                       ; """
000DB1r 3               
000DB1r 3               
000DB1r 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
000DB1r 3               ; ## "else"  auto  ANS core
000DB1r 3                       ; """http://forth-standard.org/standard/core/ELSE
000DB1r 3                       ;
000DB1r 3                       ; The code is shared with ENDOF
000DB1r 3                       ; """
000DB1r 3               
000DB1r 3               xt_else:
000DB1r 3               xt_endof:
000DB1r 3                               ; Put an unconditional branch.
000DB1r 3  A0 rr                        ldy #>branch_runtime
000DB3r 3  A9 rr                        lda #<branch_runtime
000DB5r 3  20 rr rr                     jsr cmpl_subroutine
000DB8r 3               
000DB8r 3                               ; Put the address of the branch address on the stack.
000DB8r 3  20 rr rr                     jsr xt_here
000DBBr 3               
000DBBr 3                               ; Use zero for the branch address for now.
000DBBr 3                               ; THEN will fill it in later.
000DBBr 3  20 rr rr                     jsr xt_zero
000DBEr 3  20 rr rr                     jsr xt_comma
000DC1r 3               
000DC1r 3                               ; Get the address to jump to (just after the
000DC1r 3                               ; unconditional branch) for the IF to jump to
000DC1r 3                               ; when false.
000DC1r 3  20 rr rr                     jsr xt_here
000DC4r 3  20 rr rr                     jsr xt_rot
000DC7r 3               
000DC7r 3                               ; Update the original if 0branch address.
000DC7r 3  20 rr rr                     jsr xt_store
000DCAr 3               z_else:
000DCAr 3               z_endof:
000DCAr 3  60                           rts
000DCBr 3               
000DCBr 3               
000DCBr 3               
000DCBr 3               branch_runtime:
000DCBr 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
000DCBr 3                       ; formally part of a separate word BRANCH which was later removed.
000DCBr 3                       ; """
000DCBr 3               
000DCBr 3                               ; The address on the Return Stack points to the last byte
000DCBr 3                               ; of the JSR address, one byte below the branch literal
000DCBr 3  68                           pla
000DCCr 3  85 22                        sta tmpbranch
000DCEr 3  68                           pla
000DCFr 3  85 23                        sta tmpbranch+1
000DD1r 3               
000DD1r 3                               ; Keep in mind: the address we just popped points one byte
000DD1r 3                               ; lower than the branch literal we want to grab
000DD1r 3  A0 01                        ldy #1
000DD3r 3  B1 22                        lda (tmpbranch),y  ; LSB
000DD5r 3  85 24                        sta tmp1
000DD7r 3  C8                           iny
000DD8r 3  B1 22                        lda (tmpbranch),y  ; MSB
000DDAr 3  85 25                        sta tmp1+1
000DDCr 3               
000DDCr 3  6C 24 00                     jmp (tmp1)
000DDFr 3               
000DDFr 3               
000DDFr 3               
000DDFr 3               ; ## EMIT ( char -- ) "Print character to current output"
000DDFr 3               ; ## "emit"  auto  ANS core
000DDFr 3                       ; """https://forth-standard.org/standard/core/EMIT
000DDFr 3                       ; Run-time default for EMIT. The user can revector this by changing
000DDFr 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
000DDFr 3                       ; do not check to see if we have been given a valid ASCII character.
000DDFr 3                       ; Don't make this native compile.
000DDFr 3                       ; """
000DDFr 3               
000DDFr 3               xt_emit:
000DDFr 3  20 rr rr                     jsr underflow_1
000DE2r 3               
000DE2r 3  B5 00                        lda 0,x
000DE4r 3  E8                           inx
000DE5r 3  E8                           inx
000DE6r 3               
000DE6r 3               emit_a:
000DE6r 3                       ; We frequently want to print the character in A without fooling
000DE6r 3                       ; around with the Data Stack. This is emit_a's job, which still
000DE6r 3                       ; allows the output to be vectored. Call it with JSR as you
000DE6r 3                       ; would XT_EMIT
000DE6r 3  6C 10 00                     jmp (output)            ; JSR/RTS
000DE9r 3               
000DE9r 3               z_emit:         ; never reached
000DE9r 3               
000DE9r 3               
000DE9r 3               
000DE9r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
000DE9r 3               ; ## "empty-buffers"  tested  ANS block ext
000DE9r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
000DE9r 3               xt_empty_buffers:
000DE9r 3                               ; Set the buffer status to empty.
000DE9r 3  A0 2C                        ldy #buffstatus_offset
000DEBr 3  A9 00                        lda #0
000DEDr 3  91 1E                        sta (up),y      ; Only LSB is used.
000DEFr 3               z_empty_buffers:
000DEFr 3  60                           rts
000DF0r 3               
000DF0r 3               
000DF0r 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
000DF0r 3               ; ## "endcase"  auto  ANS core ext
000DF0r 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
000DF0r 3               
000DF0r 3               xt_endcase:
000DF0r 3                               ; Postpone DROP to remove the item
000DF0r 3                               ; being checked.
000DF0r 3  A0 rr                        ldy #>xt_drop
000DF2r 3  A9 rr                        lda #<xt_drop
000DF4r 3  20 rr rr                     jsr cmpl_subroutine
000DF7r 3               
000DF7r 3                               ; There are a number of address (of branches that need their
000DF7r 3                               ; jump addressed filled in with the address of right here).
000DF7r 3                               ; Keep calling THEN to deal with them until we reach the
000DF7r 3                               ; 0 that CASE put on the stack at the beginning.
000DF7r 3               @endcase_loop:
000DF7r 3                               ; Check for 0 on the stack.
000DF7r 3  B5 00                        lda 0,x
000DF9r 3  15 01                        ora 1,x
000DFBr 3  F0 05                        beq @done
000DFDr 3               
000DFDr 3  20 rr rr                     jsr xt_then
000E00r 3  80 F5                        bra @endcase_loop
000E02r 3               @done:
000E02r 3                               ; Remove the 0 from the stack.
000E02r 3  E8                           inx
000E03r 3  E8                           inx
000E04r 3  60           z_endcase:      rts
000E05r 3               
000E05r 3               
000E05r 3               
000E05r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
000E05r 3               ; ## "endof"  auto  ANS core ext
000E05r 3                       ; """http://forth-standard.org/standard/core/ENDOF
000E05r 3                       ; This is a dummy entry, the code is shared with ELSE
000E05r 3                       ; """
000E05r 3               
000E05r 3               
000E05r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
000E05r 3               ; ## "environment?"  auto  ANS core
000E05r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
000E05r 3                       ;
000E05r 3                       ; By ANS definition, we use upper-case strings here, see the
000E05r 3                       ; string file for details. This can be realized as a high-level
000E05r 3                       ; Forth word as
000E05r 3                       ;
000E05r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
000E05r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
000E05r 3                       ; HEX
000E05r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
000E05r 3                       ; CASE
000E05r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
000E05r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
000E05r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
000E05r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
000E05r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
000E05r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
000E05r 3                       ; S" MAX-D"              STRING_OF
000E05r 3                                                    ; 7FFFFFFF. TRUE ENDOF
000E05r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
000E05r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
000E05r 3                       ; S" MAX-UD"             STRING_OF
000E05r 3                                                    ; FFFFFFFF. TRUE ENDOF
000E05r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
000E05r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
000E05r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
000E05r 3                       ; ENDCASE ;
000E05r 3                       ;
000E05r 3                       ; but that uses lots of memory and increases the start up time. This
000E05r 3                       ; word is rarely used so we can try to keep it short at the expense
000E05r 3                       ; of speed.
000E05r 3                       ; """
000E05r 3               
000E05r 3               xt_environment_q:
000E05r 3  20 rr rr                     jsr underflow_1
000E08r 3               
000E08r 3                               ; This code is table-driven: We walk through the list of
000E08r 3                               ; strings until we find one that matches, and then we take
000E08r 3                               ; the equivalent data from the results table. This is made
000E08r 3                               ; a bit harder by the fact that some of these return a
000E08r 3                               ; double-cell number and some a single-cell one.
000E08r 3               
000E08r 3                               ; We will walk through the table with variables that return
000E08r 3                               ; a single-cell result
000E08r 3  A0 00                        ldy #00                 ; counter for table
000E0Ar 3               
000E0Ar 3                               ; We use a flag on the the stack to signal if we have a single-cell
000E0Ar 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
000E0Ar 3                               ; double-cell.
000E0Ar 3  5A                           phy
000E0Br 3               @table_loop:
000E0Br 3                               ; We arrived here with the address of the string to be checked
000E0Br 3                               ; on the stack. We make a copy. Index is in Y
000E0Br 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
000E0Er 3               
000E0Er 3                               ; We do our work on the TOS to speed things up
000E0Er 3  CA                           dex
000E0Fr 3  CA                           dex                     ; ( addr u addr u ? )
000E10r 3               
000E10r 3                               ; Get address of string to check from table
000E10r 3  B9 rr rr                     lda env_table_single,y
000E13r 3  95 00                        sta 0,x
000E15r 3  C8                           iny
000E16r 3  B9 rr rr                     lda env_table_single,y
000E19r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
000E1Br 3  C8                           iny
000E1Cr 3               
000E1Cr 3                               ; See if this is the last entry. The LSB is still in A
000E1Cr 3  15 00                        ora 0,x
000E1Er 3  F0 4D                        beq @table_done
000E20r 3               
000E20r 3                               ; We have a string entry. The address there is stored in
000E20r 3                               ; old-style address format, that is, the first byte is the
000E20r 3                               ; length of the string
000E20r 3  5A                           phy                     ; save Y, which is used by COUNT
000E21r 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
000E24r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
000E27r 3  7A                           ply
000E28r 3               
000E28r 3                               ; If we found a match (flag is zero -- COMPARE is weird
000E28r 3                               ; that way), return the result
000E28r 3  B5 00                        lda 0,x
000E2Ar 3  15 01                        ora 1,x
000E2Cr 3  F0 04                        beq @got_result
000E2Er 3               
000E2Er 3                               ; Flag is not zero, so not a perfect match, so try next
000E2Er 3                               ; word
000E2Er 3  E8                           inx                     ; DROP, now ( addr u )
000E2Fr 3  E8                           inx
000E30r 3               
000E30r 3  80 D9                        bra @table_loop
000E32r 3               
000E32r 3               @got_result:
000E32r 3                               ; We arrive here with ( addr u -1 ) and know that we've found
000E32r 3                               ; a match. The index of the match+2 is in Y.
000E32r 3  E8                           inx                     ; drop flag, now ( addr u )
000E33r 3  E8                           inx
000E34r 3  88                           dey                     ; go back to index we had
000E35r 3  88                           dey
000E36r 3               
000E36r 3                               ; See if this is a single-cell word.
000E36r 3  68                           pla
000E37r 3  D0 0D                        bne @double_result
000E39r 3               
000E39r 3                               ; Single-cell result
000E39r 3  B9 rr rr                     lda env_results_single,y
000E3Cr 3  95 02                        sta 2,x
000E3Er 3  C8                           iny
000E3Fr 3  B9 rr rr                     lda env_results_single,y
000E42r 3  95 03                        sta 3,x                 ; ( res u )
000E44r 3               
000E44r 3  80 1F                        bra @set_flag
000E46r 3               
000E46r 3               @double_result:
000E46r 3                               ; This is a double-celled result, which means we have to
000E46r 3                               ; fool around with the index some more. We also need a
000E46r 3                               ; further cell on the stack
000E46r 3  CA                           dex                     ; ( addr u ? )
000E47r 3  CA                           dex
000E48r 3               
000E48r 3                               ; We have 11 single-cell words we check, plus the 0000 as
000E48r 3                               ; a marker for the end of the table, so we arrive here
000E48r 3                               ; with Y as 22 or more. To get the index for the double-
000E48r 3                               ; cell words, we move the result
000E48r 3  98                           tya
000E49r 3  38                           sec
000E4Ar 3  E9 18                        sbc #24
000E4Cr 3               
000E4Cr 3                               ; We have four bytes per entry in the table, but the index
000E4Cr 3                               ; keeps increasing by two, so we only have to multiply by
000E4Cr 3                               ; two (shift left once) to get the right result
000E4Cr 3  0A                           asl
000E4Dr 3  A8                           tay
000E4Er 3               
000E4Er 3  B9 rr rr                     lda env_results_double,y
000E51r 3  95 02                        sta 2,x
000E53r 3  C8                           iny
000E54r 3  B9 rr rr                     lda env_results_double,y
000E57r 3  95 03                        sta 3,x                 ; ( res u ? )
000E59r 3  C8                           iny
000E5Ar 3               
000E5Ar 3  B9 rr rr                     lda env_results_double,y
000E5Dr 3  95 04                        sta 4,x
000E5Fr 3  C8                           iny
000E60r 3  B9 rr rr                     lda env_results_double,y
000E63r 3  95 05                        sta 5,x                 ; ( res res ? )
000E65r 3               
000E65r 3                               ; fall through to @set_flag
000E65r 3               @set_flag:
000E65r 3  A9 FF                        lda #$ff
000E67r 3  95 00                        sta 0,x
000E69r 3  95 01                        sta 1,x                 ; ( res f )
000E6Br 3               
000E6Br 3  80 14                        bra @done
000E6Dr 3               @table_done:
000E6Dr 3                               ; We're done with a table, because the entry was a zero.
000E6Dr 3                               ; We arrive here with ( addr u addr u 0 )
000E6Dr 3               
000E6Dr 3                               ; We take the flag from stack and increase it by one. If the
000E6Dr 3                               ; flag is zero, we have just completed the single-cell number
000E6Dr 3                               ; strings, so we in increase the flag and try again. Otherwise,
000E6Dr 3                               ; we're done with the double-cell table without having found
000E6Dr 3                               ; a match, and we're done
000E6Dr 3  68                           pla
000E6Er 3  D0 09                        bne @no_match
000E70r 3               
000E70r 3                               ; Flag is zero, increase it to one and start over to check
000E70r 3                               ; double-cell values
000E70r 3  1A                           inc
000E71r 3  48                           pha
000E72r 3               
000E72r 3  8A                           txa
000E73r 3  18                           clc
000E74r 3  69 06                        adc #6                  ; skip six bytes
000E76r 3  AA                           tax                     ; ( addr u )
000E77r 3               
000E77r 3  80 92                        bra @table_loop
000E79r 3               @no_match:
000E79r 3                               ; Bummer, not found. We arrive here with
000E79r 3                               ; ( addr u addr u 0 ) and need to return just a zero
000E79r 3  8A                           txa
000E7Ar 3  18                           clc
000E7Br 3  69 0A                        adc #10
000E7Dr 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
000E7Er 3               
000E7Er 3  20 rr rr                     jsr xt_false
000E81r 3               @done:
000E81r 3               z_environment_q:
000E81r 3  60                           rts
000E82r 3               
000E82r 3               
000E82r 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
000E82r 3               ; results and one for the double-celled results. The zero cell at the
000E82r 3               ; end of each table marks its, uh, end. The strings themselves are defined
000E82r 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
000E82r 3               ; have to adapt the result code for double printout, where we subtract 22
000E82r 3               ; (two bytes each single-cell string and two bytes for the end-of-table
000E82r 3               ; marker 0000
000E82r 3               env_table_single:
000E82r 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
000E86r 3  rr rr rr rr  
000E8Ar 3  rr rr        
000E8Cr 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
000E90r 3  rr rr rr rr  
000E94r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
000E98r 3  00 00        
000E9Ar 3               
000E9Ar 3               env_table_double:
000E9Ar 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
000E9Er 3  00 00        
000EA0r 3               
000EA0r 3               env_results_single:
000EA0r 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
000EA2r 3  FF 00                .word $00FF     ; /HOLD
000EA4r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
000EA6r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
000EA8r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
000EAAr 3  FF 00                .word $00FF     ; MAX-CHAR
000EACr 3  FF 7F                .word $7FFF     ; MAX-N
000EAEr 3  FF FF                .word $FFFF     ; MAX-U
000EB0r 3  80 00                .word $0080     ; RETURN-STACK-CELLS
000EB2r 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
000EB4r 3  09 00                .word $0009     ; WORDLISTS
000EB6r 3               
000EB6r 3               env_results_double:
000EB6r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
000EBAr 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
000EBEr 3               
000EBEr 3               
000EBEr 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
000EBEr 3               ; ## "="  auto  ANS core
000EBEr 3                       ; """https://forth-standard.org/standard/core/Equal"""
000EBEr 3               
000EBEr 3               xt_equal:
000EBEr 3  20 rr rr                     jsr underflow_2
000EC1r 3               
000EC1r 3  B5 00                        lda 0,x                 ; LSB
000EC3r 3  D5 02                        cmp 2,x
000EC5r 3  D0 0A                        bne @false
000EC7r 3               
000EC7r 3  B5 01                        lda 1,x                 ; MSB
000EC9r 3  D5 03                        cmp 3,x
000ECBr 3  D0 04                        bne @false
000ECDr 3               
000ECDr 3  A9 FF                        lda #$ff
000ECFr 3  80 02                        bra @done
000ED1r 3               
000ED1r 3  A9 00        @false:         lda #0                  ; drop thru to done
000ED3r 3               
000ED3r 3  95 02        @done:          sta 2,x
000ED5r 3  95 03                        sta 3,x
000ED7r 3               
000ED7r 3  E8                           inx
000ED8r 3  E8                           inx
000ED9r 3               
000ED9r 3  60           z_equal:        rts
000EDAr 3               
000EDAr 3               
000EDAr 3               
000EDAr 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
000EDAr 3               ; ## "blank"  auto  ANS string
000EDAr 3                       ; """https://forth-standard.org/standard/string/BLANK"""
000EDAr 3               xt_blank:
000EDAr 3                               ; We don't check for underflow here because
000EDAr 3                               ; we deal with that in FILL
000EDAr 3  CA                           dex
000EDBr 3  CA                           dex
000EDCr 3  A9 20                        lda #AscSP
000EDEr 3  95 00                        sta 0,x
000EE0r 3  74 01                        stz 1,x
000EE2r 3               
000EE2r 3  80 06                        bra xt_fill     ; skip over code for ERASE
000EE4r 3               
000EE4r 3               
000EE4r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
000EE4r 3               ; ## "erase"  auto  ANS core ext
000EE4r 3                       ; """https://forth-standard.org/standard/core/ERASE
000EE4r 3                       ; Note that ERASE works with "address" units
000EE4r 3                       ; (bytes), not cells.
000EE4r 3                       ; """
000EE4r 3               
000EE4r 3               xt_erase:
000EE4r 3                               ; We don't check for underflow here because
000EE4r 3                               ; we deal with that in FILL
000EE4r 3  CA                           dex
000EE5r 3  CA                           dex
000EE6r 3  74 00                        stz 0,x
000EE8r 3  74 01                        stz 1,x
000EEAr 3               
000EEAr 3                               ; fall through to FILL
000EEAr 3               
000EEAr 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
000EEAr 3               ; ## "fill"  auto  ANS core
000EEAr 3                       ; """https://forth-standard.org/standard/core/FILL
000EEAr 3                       ; Fill u bytes of memory with char starting at addr. Note that
000EEAr 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
000EEAr 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
000EEAr 3                       ; happens when we reach the end of the address space
000EEAr 3                       ; """
000EEAr 3               xt_fill:
000EEAr 3  20 rr rr                     jsr underflow_3
000EEDr 3               
000EEDr 3                               ; We use tmp1 to hold the address
000EEDr 3  B5 04                        lda 4,x         ; LSB
000EEFr 3  85 24                        sta tmp1
000EF1r 3  B5 05                        lda 5,x
000EF3r 3  85 25                        sta tmp1+1
000EF5r 3               
000EF5r 3                               ; We use tmp2 to hold the counter
000EF5r 3  B5 02                        lda 2,x
000EF7r 3  85 26                        sta tmp2
000EF9r 3  B5 03                        lda 3,x
000EFBr 3  85 27                        sta tmp2+1
000EFDr 3               
000EFDr 3                               ; We use Y to hold the character
000EFDr 3  B5 00                        lda 0,x
000EFFr 3  A8                           tay
000F00r 3               @loop:
000F00r 3                               ; Unfortunately, we also need to make sure that we don't
000F00r 3                               ; write further than the end of the RAM. So RAM_END must
000F00r 3                               ; be larger or equal to the current address
000F00r 3  A9 7F                        lda #>ram_end           ; MSB
000F02r 3  C5 25                        cmp tmp1+1
000F04r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
000F06r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
000F08r 3               
000F08r 3  A9 FF                        lda #<ram_end           ; LSB, because MSBs were equal
000F0Ar 3  C5 24                        cmp tmp1
000F0Cr 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
000F0Er 3               
000F0Er 3               @check_counter:
000F0Er 3                               ; See if our counter has reached zero
000F0Er 3  A5 26                        lda tmp2
000F10r 3  05 27                        ora tmp2+1
000F12r 3  F0 13                        beq @done
000F14r 3               
000F14r 3                               ; We're not in ROM and we still have stuff on the counter, so
000F14r 3                               ; let's actually do what we came here to do
000F14r 3  98                           tya
000F15r 3  92 24                        sta (tmp1)
000F17r 3               
000F17r 3                               ; Adjust the counter
000F17r 3  A5 26                        lda tmp2
000F19r 3  D0 02                        bne @1
000F1Br 3  C6 27                        dec tmp2+1
000F1Dr 3  C6 26        @1:               dec tmp2
000F1Fr 3               
000F1Fr 3                               ; Next address
000F1Fr 3  E6 24                        inc tmp1
000F21r 3  D0 DD                        bne @loop
000F23r 3  E6 25                        inc tmp1+1
000F25r 3               
000F25r 3  80 D9                        bra @loop
000F27r 3               
000F27r 3               @done:
000F27r 3                               ; Drop three cells off the Data Stack. This uses one byte
000F27r 3                               ; less than six times INX
000F27r 3  8A                           txa
000F28r 3  18                           clc
000F29r 3  69 06                        adc #6
000F2Br 3  AA                           tax
000F2Cr 3               z_blank:
000F2Cr 3               z_erase:
000F2Cr 3  60           z_fill:         rts
000F2Dr 3               
000F2Dr 3               
000F2Dr 3               
000F2Dr 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
000F2Dr 3               ; ## "execute"  auto  ANS core
000F2Dr 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
000F2Dr 3               xt_execute:
000F2Dr 3  20 rr rr                     jsr underflow_1
000F30r 3               
000F30r 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
000F33r 3               
000F33r 3  60           z_execute:      rts
000F34r 3               
000F34r 3               doexecute:
000F34r 3  B5 00                        lda 0,x
000F36r 3  85 0E                        sta ip
000F38r 3  B5 01                        lda 1,x
000F3Ar 3  85 0F                        sta ip+1
000F3Cr 3               
000F3Cr 3  E8                           inx
000F3Dr 3  E8                           inx
000F3Er 3               
000F3Er 3                               ; we don't need a RTS here because we highjack the RTS of
000F3Er 3                               ; the word we're calling to get back to xt_execute
000F3Er 3  6C 0E 00                     jmp (ip)
000F41r 3               
000F41r 3               ; end of doexecute
000F41r 3               
000F41r 3               
000F41r 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
000F41r 3               ; ## "execute-parsing"  auto  Gforth
000F41r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
000F41r 3                       ; Execute the parsing word defined by the execution token (xt) on the
000F41r 3                       ; string as if it were passed on the command line. See the file
000F41r 3                       ; tests/tali.fs for examples.
000F41r 3                       ;
000F41r 3                       ; Note that this word is coded completely
000F41r 3                       ; different in its Gforth version, see the file execute-parsing.fs
000F41r 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
000F41r 3                       ; """
000F41r 3               xt_execute_parsing:
000F41r 3  20 rr rr                     jsr underflow_3
000F44r 3               
000F44r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
000F47r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
000F4Ar 3               
000F4Ar 3  B5 00                        lda 0,x                 ; TOS is new ciblen
000F4Cr 3  85 0A                        sta ciblen
000F4Er 3  B5 01                        lda 1,x
000F50r 3  85 0B                        sta ciblen+1
000F52r 3               
000F52r 3  B5 02                        lda 2,x                 ; NOS is new cib
000F54r 3  85 08                        sta cib
000F56r 3  B5 03                        lda 3,x
000F58r 3  85 09                        sta cib+1
000F5Ar 3               
000F5Ar 3  64 0C                        stz toin                ; Set >IN to zero
000F5Cr 3  64 0D                        stz toin+1
000F5Er 3               
000F5Er 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
000F61r 3  20 rr rr                     jsr xt_execute
000F64r 3               
000F64r 3  20 rr rr                     jsr xt_r_to_input
000F67r 3               
000F67r 3               z_execute_parsing:
000F67r 3  60                           rts
000F68r 3               
000F68r 3               
000F68r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
000F68r 3               ; ## "exit"  auto  ANS core
000F68r 3                       ; """https://forth-standard.org/standard/core/EXIT
000F68r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
000F68r 3                       ; we we might have put on the Return Stack off as well. This should
000F68r 3                       ; be natively compiled.
000F68r 3                       ; """
000F68r 3               
000F68r 3               xt_exit:
000F68r 3  60                           rts             ; keep before z_exit
000F69r 3               z_exit:                         ; never reached
000F69r 3               
000F69r 3               
000F69r 3               
000F69r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
000F69r 3               ; ## "false"  auto  ANS core ext
000F69r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
000F69r 3               xt_false:
000F69r 3  CA                           dex
000F6Ar 3  CA                           dex
000F6Br 3  74 00                        stz 0,x
000F6Dr 3  74 01                        stz 1,x
000F6Fr 3               
000F6Fr 3  60           z_false:        rts
000F70r 3               
000F70r 3               
000F70r 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
000F70r 3               ; ## "@"  auto  ANS core
000F70r 3                       ; """https://forth-standard.org/standard/core/Fetch"""
000F70r 3               xt_fetch:
000F70r 3  20 rr rr                     jsr underflow_1
000F73r 3               
000F73r 3  A1 00                        lda (0,x)               ; LSB
000F75r 3  A8                           tay
000F76r 3  F6 00                        inc 0,x
000F78r 3  D0 02                        bne @1
000F7Ar 3  F6 01                        inc 1,x
000F7Cr 3               @1:
000F7Cr 3  A1 00                        lda (0,x)               ; MSB
000F7Er 3  95 01                        sta 1,x
000F80r 3  94 00                        sty 0,x
000F82r 3               
000F82r 3  60           z_fetch:        rts
000F83r 3               
000F83r 3               
000F83r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
000F83r 3               ; ## "find"  auto  ANS core
000F83r 3                       ; """https://forth-standard.org/standard/core/FIND
000F83r 3                       ; Included for backwards compatibility only, because it still
000F83r 3                       ; can be found in so may examples. It should, however, be replaced
000F83r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
000F83r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
000F83r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
000F83r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
000F83r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
000F83r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000F83r 3                       ; """
000F83r 3               
000F83r 3               xt_find:
000F83r 3  20 rr rr                     jsr underflow_1
000F86r 3               
000F86r 3                               ; Save address in case conversion fails. We use the
000F86r 3                               ; Return Stack instead of temporary variables like TMP1
000F86r 3                               ; because this is shorter and anybody still using FIND
000F86r 3                               ; can't be worried about speed anyway
000F86r 3  B5 01                        lda 1,x                 ; MSB
000F88r 3  48                           pha
000F89r 3  B5 00                        lda 0,x                 ; LSB
000F8Br 3  48                           pha
000F8Cr 3               
000F8Cr 3                               ; Convert ancient-type counted string address to
000F8Cr 3                               ; modern format
000F8Cr 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
000F8Fr 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
000F92r 3               
000F92r 3  B5 00                        lda 0,x
000F94r 3  15 01                        ora 1,x
000F96r 3  D0 0B                        bne @found_word
000F98r 3               
000F98r 3                               ; No word found. Return address of the string and a false
000F98r 3                               ; flag
000F98r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
000F9Br 3               
000F9Br 3                               ; The address needs to be restored.
000F9Br 3  68                           pla                     ; LSB of address
000F9Cr 3  95 02                        sta 2,x
000F9Er 3  68                           pla
000F9Fr 3  95 03                        sta 3,x                 ; MSB of address
000FA1r 3               
000FA1r 3  80 27                        bra @done               ; ( addr 0 )
000FA3r 3               
000FA3r 3               @found_word:
000FA3r 3                               ; We don't need the address after all, dump it
000FA3r 3  68                           pla
000FA4r 3  68                           pla
000FA5r 3               
000FA5r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
000FA5r 3                               ; convert the return values to FIND's format
000FA5r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
000FA8r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
000FABr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
000FAEr 3               
000FAEr 3  A0 00                        ldy #0                  ; Prepare flag
000FB0r 3               
000FB0r 3                               ; The flags are in the second byte of the header
000FB0r 3  F6 00                        inc 0,x
000FB2r 3  D0 02                        bne @1
000FB4r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
000FB6r 3               @1:
000FB6r 3  A1 00                        lda (0,x)               ; ( xt char )
000FB8r 3  29 04                        and #IM
000FBAr 3  D0 08                        bne @immediate          ; bit set, we're immediate
000FBCr 3               
000FBCr 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
000FBEr 3  95 00                        sta 0,x
000FC0r 3  95 01                        sta 1,x
000FC2r 3  80 06                        bra @done
000FC4r 3               
000FC4r 3               @immediate:
000FC4r 3  A9 01                        lda #1                  ; We're immediate, return 1
000FC6r 3  95 00                        sta 0,x
000FC8r 3  74 01                        stz 1,x
000FCAr 3               @done:
000FCAr 3  60           z_find:         rts
000FCBr 3               
000FCBr 3               
000FCBr 3               
000FCBr 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
000FCBr 3               ; ## "find-name"  auto  Gforth
000FCBr 3               
000FCBr 3               xt_find_name:
000FCBr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000FCBr 3                       ; Given a string, find the Name Token (nt) of a word or return
000FCBr 3                       ; zero if the word is not in the dictionary. We use this instead of
000FCBr 3                       ; ancient FIND to look up words in the Dictionary passed by
000FCBr 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
000FCBr 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
000FCBr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000FCBr 3                       ; FIND calls this word
000FCBr 3                       ; """
000FCBr 3  20 rr rr                     jsr underflow_2
000FCEr 3               
000FCEr 3                               ; check for special case of an empty string (length zero)
000FCEr 3  B5 00                        lda 0,x
000FD0r 3  15 01                        ora 1,x
000FD2r 3  D0 03                        bne @nonempty
000FD4r 3               
000FD4r 3  4C rr rr                     jmp @fail_done
000FD7r 3               
000FD7r 3               @nonempty:
000FD7r 3                               ; Set up for traversing the wordlist search order.
000FD7r 3  64 28                        stz tmp3                ; Start at the beginning
000FD9r 3               
000FD9r 3               @wordlist_loop:
000FD9r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
000FDBr 3  A5 28                        lda tmp3
000FDDr 3  D1 1E                        cmp (up),y              ; Check to see if we are done
000FDFr 3  D0 03                        bne @have_string
000FE1r 3               
000FE1r 3                               ; We ran out of wordlists to search.
000FE1r 3  4C rr rr                     jmp @fail_done
000FE4r 3               
000FE4r 3               @have_string:
000FE4r 3                               ; set up first loop iteration
000FE4r 3               
000FE4r 3                               ; Get the current wordlist id
000FE4r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
000FE5r 3  69 1F                        adc #search_order_offset
000FE7r 3  A8                           tay
000FE8r 3  B1 1E                        lda (up),y      ; Get the id byte, which is the offset
000FEAr 3                                               ; into the cell array WORDLISTS
000FEAr 3               
000FEAr 3                               ; Get the DP for that wordlist.
000FEAr 3  0A                           asl                     ; Turn offset into cells offset.
000FEBr 3  18                           clc
000FECr 3  69 06                        adc #wordlists_offset
000FEEr 3  A8                           tay
000FEFr 3  B1 1E                        lda (up),y
000FF1r 3  85 24                        sta tmp1
000FF3r 3  C8                           iny
000FF4r 3  B1 1E                        lda (up),y
000FF6r 3  85 25                        sta tmp1+1
000FF8r 3               
000FF8r 3  B5 02                        lda 2,x                 ; Address of mystery string
000FFAr 3  85 26                        sta tmp2
000FFCr 3  B5 03                        lda 3,x
000FFEr 3  85 27                        sta tmp2+1
001000r 3               
001000r 3               @loop:
001000r 3                               ; first quick test: Are strings the same length?
001000r 3  B2 24                        lda (tmp1)
001002r 3  D5 00                        cmp 0,x
001004r 3  D0 54                        bne @next_entry
001006r 3               
001006r 3               @compare_string:
001006r 3                               ; are the same length, so we now have to compare each
001006r 3                               ; character
001006r 3               
001006r 3                               ; second quick test: Is the first character the same?
001006r 3  B2 26                        lda (tmp2)      ; first character of mystery string
001008r 3               
001008r 3                               ; Lowercase the incoming charcter.
001008r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
00100Ar 3  B0 07                        bcs @compare_first
00100Cr 3  C9 41                        cmp #$41        ; ASCII 'A'
00100Er 3  90 03                        bcc @compare_first
001010r 3               
001010r 3                               ; An uppercase letter has been located.  Make it
001010r 3                               ; lowercase.
001010r 3  18                           clc
001011r 3  69 20                        adc #$20
001013r 3               
001013r 3               @compare_first:
001013r 3  A0 08                        ldy #8          ; Offset in nt to name
001015r 3  D1 24                        cmp (tmp1),y    ; first character of current word
001017r 3  D0 41                        bne @next_entry
001019r 3               
001019r 3                               ; String length is the same and the first character is the
001019r 3                               ; same. If the length of the string is 1, we're already done
001019r 3  B5 00                        lda 0,x
00101Br 3  3A                           dec
00101Cr 3  F0 2C                        beq @success
00101Er 3               
00101Er 3                               ; No such luck: The strings are the same length and the first
00101Er 3                               ; char is the same, but the word is more than one char long.
00101Er 3                               ; So we suck it up and compare every single character. We go
00101Er 3                               ; from back to front, because words like CELLS and CELL+ would
00101Er 3                               ; take longer otherwise. We can also shorten the loop by one
00101Er 3                               ; because we've already compared the first char.
00101Er 3               
00101Er 3                               ; The string of the word we're testing against is 8 bytes down
00101Er 3  A5 24                        lda tmp1
001020r 3  48                           pha             ; Preserve tmp1 on the return stack.
001021r 3  18                           clc
001022r 3  69 08                        adc #8
001024r 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001026r 3  A5 25                        lda tmp1+1
001028r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001029r 3  69 00                        adc #0          ; we only need the carry
00102Br 3  85 25                        sta tmp1+1
00102Dr 3               
00102Dr 3  B4 00                        ldy 0,x         ; index is length of string minus 1
00102Fr 3  88                           dey
001030r 3               
001030r 3               @string_loop:
001030r 3  B1 26                        lda (tmp2),y    ; last char of mystery string
001032r 3               
001032r 3                               ; Lowercase the incoming charcter.
001032r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001034r 3  B0 07                        bcs @check_char
001036r 3  C9 41                        cmp #$41        ; ASCII 'A'
001038r 3  90 03                        bcc @check_char
00103Ar 3               
00103Ar 3                               ; An uppercase letter has been located.  Make it
00103Ar 3                               ; lowercase.
00103Ar 3  18                           clc
00103Br 3  69 20                        adc #$20
00103Dr 3               
00103Dr 3               @check_char:
00103Dr 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
00103Fr 3  D0 13                        bne @next_entry_tmp1
001041r 3               
001041r 3  88                           dey
001042r 3  D0 EC                        bne @string_loop
001044r 3               
001044r 3               @success_tmp1:
001044r 3  68                           pla             ; Restore tmp1 from the return stack.
001045r 3  85 25                        sta tmp1+1
001047r 3  68                           pla
001048r 3  85 24                        sta tmp1
00104Ar 3               
00104Ar 3               @success:
00104Ar 3                               ; The strings match. Put correct nt NOS, because we'll drop
00104Ar 3                               ; TOS before we leave
00104Ar 3  A5 24                        lda tmp1
00104Cr 3  95 02                        sta 2,x
00104Er 3  A5 25                        lda tmp1+1
001050r 3  95 03                        sta 3,x
001052r 3               
001052r 3  80 20                        bra @done
001054r 3               
001054r 3               @next_entry_tmp1:
001054r 3  68                           pla             ; Restore tmp1 from the return stack.
001055r 3  85 25                        sta tmp1+1
001057r 3  68                           pla
001058r 3  85 24                        sta tmp1
00105Ar 3               
00105Ar 3               @next_entry:
00105Ar 3                               ; Not the same, so we get the next word. Next header
00105Ar 3                               ; address is two bytes down
00105Ar 3  A0 02                        ldy #2
00105Cr 3  B1 24                        lda (tmp1),y
00105Er 3  48                           pha
00105Fr 3  C8                           iny
001060r 3  B1 24                        lda (tmp1),y
001062r 3  85 25                        sta tmp1+1
001064r 3  68                           pla
001065r 3  85 24                        sta tmp1
001067r 3               
001067r 3                               ; If we got a zero, we've walked the whole Dictionary and
001067r 3                               ; return as a failure, otherwise try again
001067r 3  05 25                        ora tmp1+1
001069r 3  D0 95                        bne @loop
00106Br 3               
00106Br 3                               ; Move on to the next wordlist in the search order.
00106Br 3  E6 28                        inc tmp3
00106Dr 3  4C rr rr                     jmp @wordlist_loop
001070r 3               
001070r 3               @fail_done:
001070r 3  74 02                        stz 2,x         ; failure flag
001072r 3  74 03                        stz 3,x
001074r 3               @done:
001074r 3  E8                           inx
001075r 3  E8                           inx
001076r 3               
001076r 3  60           z_find_name:    rts
001077r 3               
001077r 3               
001077r 3               
001077r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001077r 3               ; ## "flush"  auto  ANS block
001077r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001077r 3               xt_flush:
001077r 3  20 rr rr                     jsr xt_save_buffers
00107Ar 3               
00107Ar 3                               ; Set the buffer status to empty.
00107Ar 3  A0 2C                        ldy #buffstatus_offset
00107Cr 3  A9 00                        lda #0
00107Er 3  91 1E                        sta (up),y      ; Only LSB is used.
001080r 3               z_flush:
001080r 3  60                           rts
001081r 3               
001081r 3               
001081r 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001081r 3               ; ## "fm/mod"  auto  ANS core
001081r 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001081r 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001081r 3                       ;
001081r 3                       ; There are various ways to realize this. We follow EForth with
001081r 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001081r 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001081r 3                       ; See (http://www.forth.org/eforth.html). However you can also
001081r 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001081r 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001081r 3                       ; """
001081r 3               
001081r 3               xt_fm_slash_mod:
001081r 3  20 rr rr                     jsr underflow_3
001084r 3               
001084r 3                               ; if sign of n1 is negative, negate both n1 and d
001084r 3  64 26                        stz tmp2        ; default: n is positive
001086r 3  B5 01                        lda 1,x         ; MSB of n1
001088r 3  10 0E                        bpl @check_d
00108Ar 3               
00108Ar 3  E6 26                        inc tmp2        ; set flag to negative for n1
00108Cr 3  20 rr rr                     jsr xt_negate   ; NEGATE
00108Fr 3  20 rr rr                     jsr xt_to_r     ; >R
001092r 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001095r 3  20 rr rr                     jsr xt_r_from   ; R>
001098r 3               
001098r 3               @check_d:
001098r 3                               ; If d is negative, add n1 to high cell of d
001098r 3  B5 03                        lda 3,x         ; MSB of high word of d
00109Ar 3  10 0D                        bpl @multiply
00109Cr 3               
00109Cr 3  18                           clc
00109Dr 3  B5 00                        lda 0,x         ; LSB of n1
00109Fr 3  75 02                        adc 2,x         ; LSB of dh
0010A1r 3  95 02                        sta 2,x
0010A3r 3               
0010A3r 3  B5 01                        lda 1,x         ; MSB of n1
0010A5r 3  75 03                        adc 3,x         ; MSB of dh
0010A7r 3  95 03                        sta 3,x
0010A9r 3               
0010A9r 3               @multiply:
0010A9r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
0010ACr 3               
0010ACr 3                               ; if n was negative, negate the result
0010ACr 3  A5 26                        lda tmp2
0010AEr 3  F0 07                        beq @done
0010B0r 3               
0010B0r 3  E8                           inx             ; pretend that we SWAP
0010B1r 3  E8                           inx
0010B2r 3  20 rr rr                     jsr xt_negate
0010B5r 3  CA                           dex
0010B6r 3  CA                           dex
0010B7r 3               @done:
0010B7r 3  60           z_fm_slash_mod: rts
0010B8r 3               
0010B8r 3               
0010B8r 3               
0010B8r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
0010B8r 3               ; ## "forth"  auto  ANS search ext
0010B8r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
0010B8r 3               xt_forth:
0010B8r 3  A0 1F                        ldy #search_order_offset
0010BAr 3  A9 00                        lda #0          ; The WID for Forth is 0.
0010BCr 3               
0010BCr 3  91 1E                        sta (up),y
0010BEr 3               z_forth:
0010BEr 3  60                           rts
0010BFr 3               
0010BFr 3               
0010BFr 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
0010BFr 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
0010BFr 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
0010BFr 3               load_evaluate:
0010BFr 3                               ; Set a flag (using tmp1) to not zero BLK
0010BFr 3  A9 FF                        lda #$FF
0010C1r 3  85 24                        sta tmp1
0010C3r 3  80 11                        bra load_evaluate_start
0010C5r 3               
0010C5r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
0010C5r 3               ; ## "evaluate"  auto  ANS core
0010C5r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
0010C5r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
0010C5r 3                       ; After processing the line, revert to old input source. We use this
0010C5r 3                       ; to compile high-level Forth words and user-defined words during
0010C5r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
0010C5r 3                       ; accept more than 255 characters here, even though it's a pain in
0010C5r 3                       ; the 8-bit.
0010C5r 3                       ; """
0010C5r 3               
0010C5r 3               xt_evaluate:
0010C5r 3  20 rr rr                     jsr underflow_2
0010C8r 3               
0010C8r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
0010C8r 3                               ; and will set the block number.
0010C8r 3  64 24                        stz tmp1
0010CAr 3               
0010CAr 3                               ; If u is zero (which can happen a lot for the user-defined
0010CAr 3                               ; words), just leave again
0010CAr 3  B5 00                        lda 0,x
0010CCr 3  15 01                        ora 1,x
0010CEr 3  D0 06                        bne _eval_got_work
0010D0r 3               
0010D0r 3  E8                           inx
0010D1r 3  E8                           inx
0010D2r 3  E8                           inx
0010D3r 3  E8                           inx
0010D4r 3               
0010D4r 3  80 42                        bra _eval_done
0010D6r 3               
0010D6r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
0010D6r 3               load_evaluate_start:
0010D6r 3               _eval_got_work:
0010D6r 3                               ; Save the current value of BLK on the return stack.
0010D6r 3  A0 01                        ldy #blk_offset+1
0010D8r 3  B1 1E                        lda (up),y
0010DAr 3  48                           pha
0010DBr 3  88                           dey
0010DCr 3  B1 1E                        lda (up),y
0010DEr 3  48                           pha
0010DFr 3               
0010DFr 3                               ; See if we should zero BLK.
0010DFr 3  A5 24                        lda tmp1
0010E1r 3  D0 05                        bne @nozero
0010E3r 3               
0010E3r 3                               ; Set BLK to zero.
0010E3r 3                               ; lda #0        ; A is already zero from loading tmp1
0010E3r 3  91 1E                        sta (up),y
0010E5r 3  C8                           iny
0010E6r 3  91 1E                        sta (up),y
0010E8r 3               
0010E8r 3               @nozero:
0010E8r 3                               ; Save the input state to the Return Stack
0010E8r 3  20 rr rr                     jsr xt_input_to_r
0010EBr 3               
0010EBr 3                               ; set SOURCE-ID to -1
0010EBr 3  A9 FF                        lda #$ff
0010EDr 3  85 06                        sta insrc
0010EFr 3  85 07                        sta insrc+1
0010F1r 3               
0010F1r 3                               ; set >IN to zero
0010F1r 3  64 0C                        stz toin
0010F3r 3  64 0D                        stz toin+1
0010F5r 3               
0010F5r 3                               ; move TOS and NOS to input buffers
0010F5r 3  B5 00                        lda 0,x
0010F7r 3  85 0A                        sta ciblen
0010F9r 3  B5 01                        lda 1,x
0010FBr 3  85 0B                        sta ciblen+1
0010FDr 3               
0010FDr 3  B5 02                        lda 2,x
0010FFr 3  85 08                        sta cib
001101r 3  B5 03                        lda 3,x
001103r 3  85 09                        sta cib+1
001105r 3               
001105r 3  E8                           inx             ; A clean stack is a clean mind
001106r 3  E8                           inx
001107r 3  E8                           inx
001108r 3  E8                           inx
001109r 3               
001109r 3  20 rr rr                     jsr interpret   ; ( -- )
00110Cr 3               
00110Cr 3                               ; restore variables
00110Cr 3  20 rr rr                     jsr xt_r_to_input
00110Fr 3               
00110Fr 3                               ; Restore BLK from the return stack.
00110Fr 3  A0 00                        ldy #blk_offset
001111r 3  68                           pla
001112r 3  91 1E                        sta (up),y
001114r 3  C8                           iny
001115r 3  68                           pla
001116r 3  91 1E                        sta (up),y
001118r 3               
001118r 3               _eval_done:
001118r 3  60           z_evaluate:     rts
001119r 3               
001119r 3               
001119r 3               
001119r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001119r 3               ; ## "forth-wordlist"  auto  ANS search
001119r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001119r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001119r 3               
001119r 3               
001119r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001119r 3               ; ## "get-current" auto ANS search
001119r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001119r 3               
001119r 3               xt_get_current:
001119r 3                               ; This is a little different than some of the variables
001119r 3                               ; in the user area as we want the value rather than
001119r 3                               ; the address.
001119r 3  CA                           dex
00111Ar 3  CA                           dex
00111Br 3  A0 04                        ldy #current_offset
00111Dr 3  B1 1E                        lda (up),y
00111Fr 3  95 00                        sta 0,x         ; CURRENT is a byte variable
001121r 3  74 01                        stz 1,x         ; so the MSB is zero.
001123r 3               
001123r 3  60           z_get_current:  rts
001124r 3               
001124r 3               
001124r 3               
001124r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001124r 3               ; ## "get-order" auto ANS search
001124r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001124r 3               
001124r 3               xt_get_order:
001124r 3                               ; Get #ORDER - the number of wordlists in the search order.
001124r 3  A0 1E                        ldy #num_order_offset
001126r 3  B1 1E                        lda (up),y
001128r 3  85 24                        sta tmp1
00112Ar 3  F0 16                        beq @done       ; If zero, there are no wordlists.
00112Cr 3               
00112Cr 3               @loop:
00112Cr 3                               ; Count down towards the front of the list.
00112Cr 3                               ; By decrementing first, we also turn the length into an offset.
00112Cr 3  C6 24                        dec tmp1        ; Count down by bytes.
00112Er 3               
00112Er 3                               ; Get a pointer to the current wordlist, working back to front.
00112Er 3  A9 1F                        lda #search_order_offset
001130r 3  18                           clc
001131r 3  65 24                        adc tmp1
001133r 3  A8                           tay
001134r 3               
001134r 3                               ; Put that wordlist id on the stack.
001134r 3  CA                           dex
001135r 3  CA                           dex
001136r 3  B1 1E                        lda (up),y
001138r 3  95 00                        sta 0,x         ; Search order array is bytes, so
00113Ar 3  74 01                        stz 1,x         ; put a zero in the high byte.
00113Cr 3               
00113Cr 3                               ; See if that was the last one to process (first in the list).
00113Cr 3  A9 00                        lda #0
00113Er 3  C5 24                        cmp tmp1
001140r 3  D0 EA                        bne @loop
001142r 3               
001142r 3               @done:
001142r 3                               ; Put the number of items on the stack.
001142r 3  CA                           dex
001143r 3  CA                           dex
001144r 3  A0 1E                        ldy #num_order_offset
001146r 3  B1 1E                        lda (up),y
001148r 3  95 00                        sta 0,x
00114Ar 3  74 01                        stz 1,x         ; We only support 8 wordlists.
00114Cr 3               
00114Cr 3  60           z_get_order:    rts
00114Dr 3               
00114Dr 3               
00114Dr 3               
00114Dr 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
00114Dr 3               ; ## ">"  auto  ANS core
00114Dr 3                       ; """https://forth-standard.org/standard/core/more"""
00114Dr 3               
00114Dr 3               xt_greater_than:
00114Dr 3  20 rr rr                     jsr underflow_2
001150r 3               
001150r 3  A0 00                        ldy #0          ; default false
001152r 3  20 rr rr                     jsr compare_16bit
001155r 3               
001155r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001155r 3  F0 03                        beq @false
001157r 3  10 01                        bpl @false
001159r 3               
001159r 3                               ; true
001159r 3  88                           dey
00115Ar 3               @false:
00115Ar 3  98                           tya
00115Br 3               
00115Br 3  E8                           inx
00115Cr 3  E8                           inx
00115Dr 3  95 00                        sta 0,x
00115Fr 3  95 01                        sta 1,x
001161r 3               
001161r 3  60           z_greater_than: rts
001162r 3               
001162r 3               
001162r 3               
001162r 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
001162r 3               ; ## "here"  auto  ANS core
001162r 3                       ; """https://forth-standard.org/standard/core/HERE
001162r 3                       ; This code is also used by the assembler directive ARROW
001162r 3                       ; ("->") though as immediate"""
001162r 3               xt_here:
001162r 3               xt_asm_arrow:
001162r 3  CA                           dex
001163r 3  CA                           dex
001164r 3  A5 00                        lda cp
001166r 3  95 00                        sta 0,x
001168r 3  A5 01                        lda cp+1
00116Ar 3  95 01                        sta 1,x
00116Cr 3               
00116Cr 3               z_asm_arrow:
00116Cr 3  60           z_here:         rts
00116Dr 3               
00116Dr 3               
00116Dr 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
00116Dr 3               ; ## "hex"  auto  ANS core ext
00116Dr 3                       ; """https://forth-standard.org/standard/core/HEX"""
00116Dr 3               xt_hex:
00116Dr 3  A9 10                        lda #16
00116Fr 3  85 18                        sta base
001171r 3  64 19                        stz base+1              ; paranoid
001173r 3               
001173r 3  60           z_hex:          rts
001174r 3               
001174r 3               
001174r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001174r 3               ; ## "hexstore"  auto  Tali
001174r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001174r 3                       ; by spaces, store the numbers at the address addr2, returning the
001174r 3                       ; number of elements. Non-number elements are skipped, an zero-length
001174r 3                       ; string produces a zero output.
001174r 3                       ; """
001174r 3               
001174r 3               xt_hexstore:
001174r 3  20 rr rr                     jsr underflow_3
001177r 3               
001177r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
00117Ar 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
00117Dr 3               
00117Dr 3               @loop:
00117Dr 3                               ; Loop until string is totally consumed
00117Dr 3  B5 00                        lda 0,x
00117Fr 3  15 01                        ora 1,x
001181r 3  F0 36                        beq @done
001183r 3               
001183r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001186r 3               
001186r 3                               ; Prepare the conversion of the number.
001186r 3  20 rr rr                     jsr xt_two_to_r
001189r 3  20 rr rr                     jsr xt_zero
00118Cr 3  20 rr rr                     jsr xt_zero
00118Fr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001192r 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001195r 3               
001195r 3                               ; If u4 is not zero, we have leftover chars and have to do
001195r 3                               ; things differently
001195r 3  B5 00                        lda 0,x
001197r 3  15 01                        ora 1,x
001199r 3  D0 17                        bne @have_chars_left
00119Br 3               
00119Br 3                               ; Normal case, this number is all done
00119Br 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
00119Er 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
0011A1r 3               
0011A1r 3                               ; Store the new value
0011A1r 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
0011A4r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
0011A7r 3               
0011A7r 3                               ; Increase counter
0011A7r 3  20 rr rr                     jsr xt_r_from           ; R>
0011AAr 3  20 rr rr                     jsr xt_one_plus         ; 1+
0011ADr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
0011B0r 3  80 CB                        bra @loop
0011B2r 3               
0011B2r 3               @have_chars_left:
0011B2r 3                               ; Pathological case: Drop the rest of this number off the stack
0011B2r 3                               ; and continue with the next word. Doesn't print a warning. We
0011B2r 3                               ; need to drop four cells, that is, eight bytes
0011B2r 3  8A                           txa
0011B3r 3  18                           clc
0011B4r 3  69 08                        adc #8
0011B6r 3  AA                           tax
0011B7r 3  80 C4                        bra @loop
0011B9r 3               
0011B9r 3               @done:
0011B9r 3                               ; Clean up return stack and calculate number of chars stored
0011B9r 3  E8                           inx
0011BAr 3  E8                           inx
0011BBr 3  E8                           inx
0011BCr 3  E8                           inx                     ; 2DROP
0011BDr 3               
0011BDr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
0011C0r 3  20 rr rr                     jsr xt_swap
0011C3r 3  20 rr rr                     jsr xt_minus            ; ( n )
0011C6r 3               
0011C6r 3  60           z_hexstore:     rts
0011C7r 3               
0011C7r 3               
0011C7r 3               
0011C7r 3               ; ## HOLD ( char -- ) "Insert character at current output"
0011C7r 3               ; ## "hold"  auto  ANS core
0011C7r 3                       ; """https://forth-standard.org/standard/core/HOLD
0011C7r 3                       ; Insert a character at the current position of a pictured numeric
0011C7r 3                       ; output string on
0011C7r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0011C7r 3                       ;
0011C7r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
0011C7r 3                       ; variable tohold instead of HLD.
0011C7r 3                       ; """
0011C7r 3               xt_hold:
0011C7r 3  20 rr rr                     jsr underflow_1
0011CAr 3               
0011CAr 3  A5 34                        lda tohold
0011CCr 3  D0 02                        bne @1
0011CEr 3  C6 35                        dec tohold+1
0011D0r 3               @1:
0011D0r 3  C6 34                        dec tohold
0011D2r 3               
0011D2r 3  B5 00                        lda 0,x
0011D4r 3  92 34                        sta (tohold)
0011D6r 3  E8                           inx
0011D7r 3  E8                           inx
0011D8r 3               
0011D8r 3  60           z_hold:         rts
0011D9r 3               
0011D9r 3               
0011D9r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
0011D9r 3               ; ## "i"  auto  ANS core
0011D9r 3                       ; """https://forth-standard.org/standard/core/I
0011D9r 3                       ; Note that this is not the same as R@ because we use a fudge
0011D9r 3                       ; factor for loop control; see the Control Flow section of the
0011D9r 3                       ; manual for details.
0011D9r 3                       ;
0011D9r 3                       ; We should make this native compile for speed.
0011D9r 3                       ; """
0011D9r 3               
0011D9r 3               xt_i:
0011D9r 3  CA                           dex
0011DAr 3  CA                           dex
0011DBr 3               
0011DBr 3                               ; Get the fudged index off of the top of the stack. It's
0011DBr 3                               ; easier to do math on the stack directly than to pop and
0011DBr 3                               ; push stuff around
0011DBr 3  86 2A                        stx tmpdsp
0011DDr 3  BA                           tsx
0011DEr 3               
0011DEr 3  38                           sec
0011DFr 3  BD 01 01                     lda $0101,x     ; LSB
0011E2r 3  FD 03 01                     sbc $0103,x
0011E5r 3  A8                           tay
0011E6r 3               
0011E6r 3  BD 02 01                     lda $0102,x     ; MSB
0011E9r 3  FD 04 01                     sbc $0104,x
0011ECr 3               
0011ECr 3  A6 2A                        ldx tmpdsp
0011EEr 3               
0011EEr 3  95 01                        sta 1,x         ; MSB of de-fudged index
0011F0r 3  94 00                        sty 0,x         ; LSB of de-fudged index
0011F2r 3               
0011F2r 3  60           z_i:            rts
0011F3r 3               
0011F3r 3               
0011F3r 3               
0011F3r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
0011F3r 3               ; ## "if"  auto  ANS core
0011F3r 3                       ; """http://forth-standard.org/standard/core/IF"""
0011F3r 3               
0011F3r 3               xt_if:
0011F3r 3                               ; Compile a 0BRANCH
0011F3r 3  A0 rr                        ldy #>zero_branch_runtime
0011F5r 3  A9 rr                        lda #<zero_branch_runtime
0011F7r 3  20 rr rr                     jsr cmpl_subroutine
0011FAr 3               
0011FAr 3                               ; Put the origination address on the stack for else/then
0011FAr 3  20 rr rr                     jsr xt_here
0011FDr 3               
0011FDr 3                               ; Stuff zero in for the branch address right now.
0011FDr 3                               ; THEN or ELSE will fix it later.
0011FDr 3  20 rr rr                     jsr xt_zero
001200r 3  20 rr rr                     jsr xt_comma
001203r 3  60           z_if:           rts
001204r 3               
001204r 3               
001204r 3               zero_branch_runtime:
001204r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001204r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001204r 3                       ; runtime.
001204r 3                       ; """
001204r 3               
001204r 3                               ; We use the return value on the 65c02 stack to determine
001204r 3                               ; where we want to return to.
001204r 3  68                           pla
001205r 3  85 22                        sta tmpbranch
001207r 3  68                           pla
001208r 3  85 23                        sta tmpbranch+1
00120Ar 3               
00120Ar 3                               ; See if the flag is zero, which is the whole purpose of
00120Ar 3                               ; this all
00120Ar 3  B5 00                        lda 0,x
00120Cr 3  15 01                        ora 1,x
00120Er 3  F0 0F                        beq @zero
001210r 3               
001210r 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001210r 3                               ; the part between IF and THEN
001210r 3  A5 22                        lda tmpbranch   ; LSB
001212r 3  18                           clc
001213r 3  69 02                        adc #2
001215r 3  85 24                        sta tmp1
001217r 3  A5 23                        lda tmpbranch+1 ; MSB
001219r 3  69 00                        adc #0          ; For carry
00121Br 3  85 25                        sta tmp1+1
00121Dr 3               
00121Dr 3  80 13                        bra @done
00121Fr 3               
00121Fr 3               @zero:
00121Fr 3                               ; Flag is FALSE (0) so we take the jump to the address given in
00121Fr 3                               ; the next two bytes. However, the address points to the last
00121Fr 3                               ; byte of the JSR instruction, not to the next byte afterwards
00121Fr 3  A0 01                        ldy #1
001221r 3  B1 22                        lda (tmpbranch),y
001223r 3  85 24                        sta tmp1
001225r 3  C8                           iny
001226r 3  B1 22                        lda (tmpbranch),y
001228r 3  85 25                        sta tmp1+1
00122Ar 3               
00122Ar 3                               ; Now we have to subtract one byte from the address
00122Ar 3                               ; given because of the way the 6502 calculates RTS
00122Ar 3  A5 24                        lda tmp1
00122Cr 3  D0 02                        bne @1
00122Er 3  C6 25                        dec tmp1+1
001230r 3               @1:
001230r 3  C6 24                        dec tmp1
001232r 3               
001232r 3               @done:
001232r 3                               ; However we got here, tmp1 has the value we push to jump
001232r 3                               ; to
001232r 3  A5 25                        lda tmp1+1
001234r 3  48                           pha             ; MSB first
001235r 3  A5 24                        lda tmp1
001237r 3  48                           pha
001238r 3               
001238r 3                               ; clean up the stack and jump
001238r 3  E8                           inx
001239r 3  E8                           inx
00123Ar 3               
00123Ar 3  60                           rts
00123Br 3               
00123Br 3               
00123Br 3               
00123Br 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
00123Br 3               ; ## "immediate"  auto  ANS core
00123Br 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
00123Br 3                       ; Make sure the most recently defined word is immediate. Will only
00123Br 3                       ; affect the last word in the dictionary. Note that if the word is
00123Br 3                       ; defined in ROM, this will have no affect, but will not produce an
00123Br 3                       ; error message.
00123Br 3                       ; """
00123Br 3               xt_immediate:
00123Br 3  20 rr rr                     jsr current_to_dp
00123Er 3  A0 01                        ldy #1          ; offset for status byte
001240r 3  B1 02                        lda (dp),y
001242r 3  09 04                        ora #IM        ; make sure bit 7 is set
001244r 3  91 02                        sta (dp),y
001246r 3               
001246r 3  60           z_immediate:    rts
001247r 3               
001247r 3               
001247r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001247r 3               ; ## "input" tested Tali Forth
001247r 3               
001247r 3               xt_input:
001247r 3  CA                           dex
001248r 3  CA                           dex
001249r 3  A9 12                        lda #<input
00124Br 3  95 00                        sta 0,x
00124Dr 3  A9 00                        lda #>input
00124Fr 3  95 01                        sta 1,x
001251r 3               
001251r 3  60           z_input:        rts
001252r 3               
001252r 3               
001252r 3               
001252r 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
001252r 3               ; ## "input>r"  tested  Tali Forth
001252r 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
001252r 3                       ; toin to the Return Stack. Used by EVALUTE.
001252r 3                       ;
001252r 3                       ; The naive way of doing
001252r 3                       ; this is to push each two-byte variable to the stack in the form of
001252r 3                       ;
001252r 3                       ;       lda insrc
001252r 3                       ;       pha
001252r 3                       ;       lda insrc+1
001252r 3                       ;       pha
001252r 3                       ;
001252r 3                       ; for a total of 24 byte of instruction in one direction and later
001252r 3                       ; a further 24 bytes to reverse the process. We shorten this at the
001252r 3                       ; cost of some speed by assuming the four variables are grouped
001252r 3                       ; together on the Zero Page and start with insrc (see definitions.asm
001252r 3                       ; for details). The reverse operation is r_to_input. These words must
001252r 3                       ; be flagged as Never Native. Uses tmp1
001252r 3                       ; """
001252r 3               
001252r 3               xt_input_to_r:
001252r 3                               ; We arrive here with the return address on the top of the
001252r 3                               ; 65c02's stack. We need to move it out of the way first
001252r 3  68                           pla
001253r 3  85 24                        sta tmp1
001255r 3  68                           pla
001256r 3  85 25                        sta tmp1+1
001258r 3               
001258r 3                               ; This assumes that insrc is the first of eight bytes and
001258r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001258r 3                               ; Page.
001258r 3  A0 07                        ldy #7
00125Ar 3               @loop:
00125Ar 3  B9 06 00                     lda insrc,y     ; insrc+7 is toin+1
00125Dr 3  48                           pha
00125Er 3  88                           dey
00125Fr 3  10 F9                        bpl @loop
001261r 3               
001261r 3                               ; Restore address for return jump
001261r 3  A5 25                        lda tmp1+1
001263r 3  48                           pha
001264r 3  A5 24                        lda tmp1
001266r 3  48                           pha
001267r 3               
001267r 3  60           z_input_to_r: 	rts
001268r 3               
001268r 3               
001268r 3               
001268r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001268r 3               ; ## "int>name"  auto  Tali Forth
001268r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001268r 3                       ; This is called >NAME in Gforth, but we change it to
001268r 3                       ; INT>NAME to match NAME>INT
001268r 3                       ; """
001268r 3               
001268r 3               xt_int_to_name:
001268r 3  20 rr rr                     jsr underflow_1
00126Br 3               
00126Br 3                               ; Unfortunately, to find the header, we have to walk through
00126Br 3                               ; all of the wordlists. We are running out of tmp variables.
00126Br 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
00126Br 3                               ; hold the current wordlist on the data stack. This searches
00126Br 3                               ; all of the wordlists in id order.
00126Br 3  CA                           dex
00126Cr 3  CA                           dex
00126Dr 3  74 00                        stz 0,x
00126Fr 3  74 01                        stz 1,x
001271r 3               
001271r 3               @wordlist_loop:
001271r 3                               ; A needs to have the current wordlist id in it at
001271r 3                               ; the top of this loop.
001271r 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001273r 3               
001273r 3                               ; Get the DP for that wordlist.
001273r 3  0A                           asl                     ; Turn offset into cells offset.
001274r 3  18                           clc
001275r 3  69 06                        adc #wordlists_offset
001277r 3  A8                           tay
001278r 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
00127Ar 3  85 26                        sta tmp2                ; into tmp2
00127Cr 3  C8                           iny
00127Dr 3  B1 1E                        lda (up),y
00127Fr 3  85 27                        sta tmp2+1
001281r 3               
001281r 3                               ; Check for an empty wordlist (DP will be 0)
001281r 3  A5 26                        lda tmp2
001283r 3  05 27                        ora tmp2+1
001285r 3  F0 38                        beq @next_wordlist
001287r 3               
001287r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001289r 3  85 28                        sta tmp3        ; Save target xt in tmp3
00128Br 3  B5 03                        lda 3,x
00128Dr 3  85 29                        sta tmp3+1
00128Fr 3               
00128Fr 3               @loop:
00128Fr 3  A0 04                        ldy #4          ; xt is four bytes down
001291r 3  B1 26                        lda (tmp2),y    ; LSB of xt of current nt
001293r 3  C5 28                        cmp tmp3
001295r 3  D0 07                        bne @no_match
001297r 3               
001297r 3                               ; LSB is the same, now check MSB
001297r 3  C8                           iny
001298r 3  B1 26                        lda (tmp2),y    ; MSB of xt of current nt
00129Ar 3  C5 29                        cmp tmp3+1
00129Cr 3  F0 32                        beq @match
00129Er 3               
00129Er 3               @no_match:
00129Er 3                               ; no match, so we need to get the next word. Next nt is two
00129Er 3                               ; bytes down
00129Er 3  18                           clc
00129Fr 3  A5 26                        lda tmp2
0012A1r 3  69 02                        adc #2
0012A3r 3  85 26                        sta tmp2
0012A5r 3  A5 27                        lda tmp2+1
0012A7r 3  69 00                        adc #0          ; only care about carry
0012A9r 3  85 27                        sta tmp2+1
0012ABr 3               
0012ABr 3  A0 00                        ldy #0
0012ADr 3  B1 26                        lda (tmp2),y
0012AFr 3  48                           pha
0012B0r 3  C8                           iny
0012B1r 3  11 26                        ora (tmp2),y
0012B3r 3  F0 09                        beq @zero
0012B5r 3               
0012B5r 3                               ; Not zero continue
0012B5r 3  B1 26                        lda (tmp2),y
0012B7r 3  85 27                        sta tmp2+1
0012B9r 3  68                           pla
0012BAr 3  85 26                        sta tmp2
0012BCr 3  80 D1                        bra @loop
0012BEr 3               
0012BEr 3               @zero:
0012BEr 3                               ; if next word is zero, the xt has no nt in this wordlist
0012BEr 3  68                           pla             ; Leftover from above loop
0012BFr 3               
0012BFr 3               @next_wordlist:
0012BFr 3                               ; Move on to the next wordlist.
0012BFr 3  B5 00                        lda 0,x
0012C1r 3  1A                           inc
0012C2r 3  95 00                        sta 0,x
0012C4r 3  C9 0C                        cmp #max_wordlists
0012C6r 3  D0 A9                        bne @wordlist_loop
0012C8r 3               
0012C8r 3                               ; We didn't find it in any of the wordlists.
0012C8r 3                               ; Remove the wordlist id from the stack.
0012C8r 3  E8                           inx
0012C9r 3  E8                           inx
0012CAr 3               
0012CAr 3                               ; We return a zero to indicate that we didn't find it.
0012CAr 3  74 00                        stz 0,x
0012CCr 3  74 01                        stz 1,x
0012CEr 3  80 0A                        bra z_int_to_name
0012D0r 3               
0012D0r 3               @match:
0012D0r 3                               ; We found it. Remove wordlist id from stack.
0012D0r 3  E8                           inx
0012D1r 3  E8                           inx
0012D2r 3               
0012D2r 3                               ; It's a match! Replace TOS with nt
0012D2r 3  A5 26                        lda tmp2
0012D4r 3  95 00                        sta 0,x
0012D6r 3  A5 27                        lda tmp2+1
0012D8r 3  95 01                        sta 1,x
0012DAr 3               
0012DAr 3  60           z_int_to_name:  rts
0012DBr 3               
0012DBr 3               
0012DBr 3               
0012DBr 3               ; ## INVERT ( n -- n ) "Complement of TOS"
0012DBr 3               ; ## "invert"  auto  ANS core
0012DBr 3                       ; """https://forth-standard.org/standard/core/INVERT"""
0012DBr 3               xt_invert:
0012DBr 3  20 rr rr                     jsr underflow_1
0012DEr 3               
0012DEr 3  A9 FF                        lda #$FF
0012E0r 3  55 00                        eor 0,x         ; LSB
0012E2r 3  95 00                        sta 0,x
0012E4r 3               
0012E4r 3  A9 FF                        lda #$FF
0012E6r 3  55 01                        eor 1,x         ; MSB
0012E8r 3  95 01                        sta 1,x
0012EAr 3               
0012EAr 3  60           z_invert:       rts
0012EBr 3               
0012EBr 3               
0012EBr 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
0012EBr 3               ; ## "is"  auto  ANS core ext
0012EBr 3                       ; """http://forth-standard.org/standard/core/IS"""
0012EBr 3               
0012EBr 3               xt_is:
0012EBr 3                               ; This is a state aware word with differet behavior
0012EBr 3                               ; when used while compiling vs interpreting.
0012EBr 3                               ; Check STATE
0012EBr 3  A5 16                        lda state
0012EDr 3  05 17                        ora state+1
0012EFr 3  F0 0C                        beq @interpreting
0012F1r 3               
0012F1r 3               @compiling:
0012F1r 3                               ; Run ['] to compile the xt of the next word as a literal.
0012F1r 3  20 rr rr                     jsr xt_bracket_tick
0012F4r 3               
0012F4r 3                               ; Postpone DEFER! by compiling a JSR to it.
0012F4r 3  A0 rr                        ldy #>xt_defer_store
0012F6r 3  A9 rr                        lda #<xt_defer_store
0012F8r 3  20 rr rr                     jsr cmpl_subroutine
0012FBr 3               
0012FBr 3  80 06                        bra @done
0012FDr 3               
0012FDr 3               @interpreting:
0012FDr 3  20 rr rr                     jsr xt_tick
001300r 3  20 rr rr                     jsr xt_defer_store
001303r 3               @done:
001303r 3  60           z_is:           rts
001304r 3               
001304r 3               
001304r 3               
001304r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001304r 3               ; ## "j"  auto  ANS core
001304r 3                       ; """https://forth-standard.org/standard/core/J
001304r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001304r 3                       ; a fudge factor for loop control; see the Control Flow section of
001304r 3                       ; the manual for more details.
001304r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001304r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001304r 3                       ; implementation would just have two.
001304r 3                       ;
001304r 3                       ; Make this native compiled for speed
001304r 3                       ; """
001304r 3               
001304r 3               xt_j:
001304r 3  CA                           dex
001305r 3  CA                           dex
001306r 3               
001306r 3                               ; Get the fudged index off from the stack. It's easier to
001306r 3                               ; do math on the stack directly than to pop and push stuff
001306r 3                               ; around
001306r 3  86 2A                        stx tmpdsp
001308r 3  BA                           tsx
001309r 3               
001309r 3  38                           sec
00130Ar 3  BD 07 01                     lda $0107,x     ; LSB
00130Dr 3  FD 09 01                     sbc $0109,x
001310r 3  A8                           tay
001311r 3               
001311r 3  BD 08 01                     lda $0108,x     ; MSB
001314r 3  FD 0A 01                     sbc $010A,x
001317r 3               
001317r 3  A6 2A                        ldx tmpdsp
001319r 3               
001319r 3  95 01                        sta 1,x         ; MSB of de-fudged index
00131Br 3  94 00                        sty 0,x         ; LSB of de-fudged index
00131Dr 3               
00131Dr 3  60           z_j:            rts
00131Er 3               
00131Er 3               
00131Er 3               
00131Er 3               ; ## KEY ( -- char ) "Get one character from the input"
00131Er 3               ; ## "key"  tested  ANS core
00131Er 3               xt_key:
00131Er 3                       ; """https://forth-standard.org/standard/core/KEY
00131Er 3                       ; Get a single character of input from the vectored
00131Er 3                       ; input without echoing.
00131Er 3                       ; """
00131Er 3  20 rr rr                     jsr key_a               ; returns char in A
001321r 3               
001321r 3  CA                           dex
001322r 3  CA                           dex
001323r 3  95 00                        sta 0,x
001325r 3  74 01                        stz 1,x
001327r 3               
001327r 3  60           z_key:          rts
001328r 3               
001328r 3               key_a:
001328r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001328r 3                       ; 65816, so we have to fake the indirect jump to vector it.
001328r 3                       ; This is depressingly slow. We use this routine internally
001328r 3                       ; to avoid manipulating the Data Stack when we just want a
001328r 3                       ; character
001328r 3  6C 12 00                     jmp (input)             ; JSR/RTS
00132Br 3               
00132Br 3               
00132Br 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
00132Br 3               ; ## "latestnt"  auto  Tali Forth
00132Br 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00132Br 3                       ; The Gforth version of this word is called LATEST
00132Br 3                       ; """
00132Br 3               xt_latestnt:
00132Br 3  CA                           dex
00132Cr 3  CA                           dex
00132Dr 3               
00132Dr 3  20 rr rr                     jsr current_to_dp
001330r 3               
001330r 3  A5 02                        lda dp
001332r 3  95 00                        sta 0,x
001334r 3  A5 03                        lda dp+1
001336r 3  95 01                        sta 1,x
001338r 3               
001338r 3  60           z_latestnt:     rts
001339r 3               
001339r 3               
001339r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001339r 3               ; ## "latestxt"  auto  Gforth
001339r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001339r 3               xt_latestxt:
001339r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
00133Cr 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
00133Fr 3               
00133Fr 3  60           z_latestxt:     rts
001340r 3               
001340r 3               
001340r 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
001340r 3               ; ## "leave"  auto  ANS core
001340r 3                       ; """https://forth-standard.org/standard/core/LEAVE
001340r 3                       ; Note that this does not work with anything but a DO/LOOP in
001340r 3                       ; contrast to other versions such as discussed at
001340r 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
001340r 3                       ;
001340r 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
001340r 3                       ; See the Control Flow section in the manual for details of how this works.
001340r 3                       ; This must be native compile and not IMMEDIATE
001340r 3                       ; """
001340r 3               
001340r 3               xt_leave:
001340r 3                               ; We dump the limit/start entries off the Return Stack
001340r 3                               ; (four bytes)
001340r 3  68                           pla
001341r 3  68                           pla
001342r 3  68                           pla
001343r 3  68                           pla
001344r 3               
001344r 3  60                           rts             ; this must be compiled, so keep before z_leave
001345r 3               z_leave:                        ; not reached, not compiled
001345r 3               
001345r 3               
001345r 3               
001345r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001345r 3               ; ## "["  auto  ANS core
001345r 3                       ; """https://forth-standard.org/standard/core/Bracket
001345r 3                       ; This is an immediate and compile-only word
001345r 3                       ; """
001345r 3               xt_left_bracket:
001345r 3  64 16                        stz state
001347r 3  64 17                        stz state+1
001349r 3               
001349r 3  60           z_left_bracket: rts
00134Ar 3               
00134Ar 3               
00134Ar 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
00134Ar 3               ; ## "<#"  auto  ANS core
00134Ar 3                       ; """https://forth-standard.org/standard/core/num-start
00134Ar 3                       ; Start the process to create pictured numeric output.
00134Ar 3                       ;
00134Ar 3                       ; The new
00134Ar 3                       ; string is constructed from back to front, saving the new character
00134Ar 3                       ; at the beginning of the output string. Since we use PAD as a
00134Ar 3                       ; starting address and work backward (!), the string is constructed
00134Ar 3                       ; in the space between the end of the Dictionary (as defined by CP)
00134Ar 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
00134Ar 3                       ; programs don't fool around with the PAD but still use its address.
00134Ar 3                       ; Based on pForth
00134Ar 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
00134Ar 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
00134Ar 3                       ; internal variable tohold instead of HLD.
00134Ar 3                       ; """
00134Ar 3               xt_less_number_sign:
00134Ar 3  20 rr rr                     jsr xt_pad      ; ( addr )
00134Dr 3               
00134Dr 3  B5 00                        lda 0,x
00134Fr 3  85 34                        sta tohold
001351r 3  B5 01                        lda 1,x
001353r 3  85 35                        sta tohold+1
001355r 3               
001355r 3  E8                           inx
001356r 3  E8                           inx
001357r 3               
001357r 3               z_less_number_sign:
001357r 3  60                           rts
001358r 3               
001358r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001358r 3               ; ## "<"  auto  ANS core
001358r 3                       ; """https://forth-standard.org/standard/core/less"""
001358r 3               
001358r 3               xt_less_than:
001358r 3  20 rr rr                     jsr underflow_2
00135Br 3               
00135Br 3  A0 00                        ldy #0          ; default false
00135Dr 3  20 rr rr                     jsr compare_16bit
001360r 3               
001360r 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
001360r 3  F0 03                        beq @false
001362r 3  30 01                        bmi @false
001364r 3               
001364r 3                               ; true
001364r 3  88                           dey
001365r 3               @false:
001365r 3  98                           tya
001366r 3               
001366r 3  E8                           inx
001367r 3  E8                           inx
001368r 3  95 00                        sta 0,x
00136Ar 3  95 01                        sta 1,x
00136Cr 3               
00136Cr 3  60           z_less_than:    rts
00136Dr 3               
00136Dr 3               
00136Dr 3               
00136Dr 3               ; ## LIST ( scr# -- ) "List the given screen"
00136Dr 3               ; ## "list"  tested  ANS block ext
00136Dr 3                       ; """https://forth-standard.org/standard/block/LIST"""
00136Dr 3               
00136Dr 3               xt_list:
00136Dr 3  20 rr rr                     jsr underflow_1
001370r 3               
001370r 3                               ; Save the screen number in SCR
001370r 3  20 rr rr                     jsr xt_scr
001373r 3  20 rr rr                     jsr xt_store
001376r 3               
001376r 3                               ; Use L from the editor-wordlist to display the screen.
001376r 3  20 rr rr                     jsr xt_editor_l
001379r 3               
001379r 3  60           z_list:         rts
00137Ar 3               
00137Ar 3               
00137Ar 3               
00137Ar 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
00137Ar 3               ; ## "literal"  auto  ANS core
00137Ar 3                       ; """https://forth-standard.org/standard/core/LITERAL
00137Ar 3                       ; Compile-only word to store TOS so that it is pushed on stack
00137Ar 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
00137Ar 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
00137Ar 3                       ;
00137Ar 3                       ; Note the cmpl_ routines use TMPTOS
00137Ar 3                       ; """
00137Ar 3               xt_literal:
00137Ar 3  20 rr rr                     jsr underflow_1
00137Dr 3               
00137Dr 3  A0 rr                        ldy #>literal_runtime
00137Fr 3  A9 rr                        lda #<literal_runtime
001381r 3  20 rr rr                     jsr cmpl_subroutine
001384r 3               
001384r 3                               ; Compile the value that is to be pushed on the Stack during
001384r 3                               ; runtime
001384r 3  20 rr rr                     jsr xt_comma
001387r 3               
001387r 3  60           z_literal:      rts
001388r 3               
001388r 3               literal_runtime:
001388r 3               
001388r 3                               ; During runtime, we push the value following this word back
001388r 3                               ; on the Data Stack. The subroutine jump that brought us
001388r 3                               ; here put the address to return to on the Return Stack -
001388r 3                               ; this points to the data we need to get. This routine is
001388r 3                               ; also called (LITERAL) in some Forths
001388r 3  CA                           dex
001389r 3  CA                           dex
00138Ar 3               
00138Ar 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
00138Ar 3                               ; so we are actually popping the address-1 of the literal
00138Ar 3  68                           pla             ; LSB
00138Br 3  85 24                        sta tmp1
00138Dr 3  68                           pla             ; MSB
00138Er 3  85 25                        sta tmp1+1
001390r 3               
001390r 3                               ; Fetch the actual literal value and push it on Data stack
001390r 3  A0 01                        ldy #1
001392r 3  B1 24                        lda (tmp1),y    ; LSB
001394r 3  95 00                        sta 0,x
001396r 3  C8                           iny
001397r 3  B1 24                        lda (tmp1),y    ; MSB
001399r 3  95 01                        sta 1,x
00139Br 3               
00139Br 3                               ; Adjust return address and push back on the Return Stack
00139Br 3  98                           tya
00139Cr 3  18                           clc
00139Dr 3  65 24                        adc tmp1
00139Fr 3  A8                           tay
0013A0r 3  A5 25                        lda tmp1+1
0013A2r 3  69 00                        adc #0
0013A4r 3  48                           pha
0013A5r 3  5A                           phy
0013A6r 3               
0013A6r 3  60                           rts
0013A7r 3               
0013A7r 3               
0013A7r 3               
0013A7r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
0013A7r 3               ; ## "load"  auto  ANS block
0013A7r 3                       ; """https://forth-standard.org/standard/block/LOAD
0013A7r 3                       ;
0013A7r 3                       ; Note: LOAD current works because there is only one buffer.
0013A7r 3                       ; If/when multiple buffers are supported, we'll have to deal
0013A7r 3                       ; with the fact that it might re-load the old block into a
0013A7r 3                       ; different buffer.
0013A7r 3                       ; """
0013A7r 3               
0013A7r 3               xt_load:
0013A7r 3  20 rr rr                     jsr underflow_1
0013AAr 3               
0013AAr 3                               ; Save the current value of BLK on the return stack.
0013AAr 3  A0 01                        ldy #blk_offset+1
0013ACr 3  B1 1E                        lda (up),y
0013AEr 3  48                           pha
0013AFr 3  88                           dey
0013B0r 3  B1 1E                        lda (up),y
0013B2r 3  48                           pha
0013B3r 3               
0013B3r 3                               ; Set BLK to the given block/screen number.
0013B3r 3  B5 00                        lda 0,x
0013B5r 3  91 1E                        sta (up),y
0013B7r 3  C8                           iny
0013B8r 3  B5 01                        lda 1,x
0013BAr 3  91 1E                        sta (up),y
0013BCr 3               
0013BCr 3                               ; Load that block into a buffer
0013BCr 3  20 rr rr                     jsr xt_block
0013BFr 3               
0013BFr 3                               ; Put 1024 on the stack for the screen length.
0013BFr 3  CA                           dex
0013C0r 3  CA                           dex
0013C1r 3  A9 04                        lda #4
0013C3r 3  95 01                        sta 1,x
0013C5r 3  74 00                        stz 0,x
0013C7r 3               
0013C7r 3                               ; Jump to a special evluate target. This bypasses the underflow
0013C7r 3                               ; check and skips the zeroing of BLK.
0013C7r 3  20 rr rr                     jsr load_evaluate
0013CAr 3               
0013CAr 3                               ; Restore the value of BLK from before the LOAD command.
0013CAr 3  A0 00                        ldy #blk_offset
0013CCr 3  68                           pla
0013CDr 3  91 1E                        sta (up),y
0013CFr 3  C8                           iny
0013D0r 3  68                           pla
0013D1r 3  91 1E                        sta (up),y
0013D3r 3               
0013D3r 3                               ; If BLK is not zero, read it back into the buffer.
0013D3r 3                               ; A still has MSB
0013D3r 3  88                           dey
0013D4r 3  11 1E                        ora (up),y
0013D6r 3  F0 12                        beq @done
0013D8r 3               
0013D8r 3                               ; The block needs to be read back into the buffer.
0013D8r 3  CA                           dex
0013D9r 3  CA                           dex
0013DAr 3  A0 00                        ldy #blk_offset
0013DCr 3  B1 1E                        lda (up),y
0013DEr 3  95 00                        sta 0,x
0013E0r 3  C8                           iny
0013E1r 3  B1 1E                        lda (up),y
0013E3r 3  95 01                        sta 1,x
0013E5r 3  20 rr rr                     jsr xt_block
0013E8r 3               
0013E8r 3                               ; Drop the buffer address.
0013E8r 3  E8                           inx
0013E9r 3  E8                           inx
0013EAr 3               
0013EAr 3               @done:
0013EAr 3  60           z_load:         rts
0013EBr 3               
0013EBr 3               
0013EBr 3               
0013EBr 3               ; ## LOOP ( -- ) "Finish loop construct"
0013EBr 3               ; ## "loop"  auto  ANS core
0013EBr 3                       ; """https://forth-standard.org/standard/core/LOOP
0013EBr 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
0013EBr 3                       ; the stack and then call +LOOP.
0013EBr 3                       ;
0013EBr 3                       ; In Forth, this is
0013EBr 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
0013EBr 3                       ;       IMMEDIATE ; COMPILE-ONLY
0013EBr 3                       ; """
0013EBr 3               xt_loop:
0013EBr 3                               ; Have the finished word push 1 on the stack
0013EBr 3  A0 rr                        ldy #>xt_one
0013EDr 3  A9 rr                        lda #<xt_one
0013EFr 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
0013F2r 3               
0013F2r 3               
0013F2r 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
0013F2r 3               ; ## "+loop"  auto  ANS core
0013F2r 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
0013F2r 3                       ;
0013F2r 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
0013F2r 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
0013F2r 3                       ;       COMPILE-ONLY
0013F2r 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
0013F2r 3                       ; address for looping as TOS and the address for aborting the loop
0013F2r 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
0013F2r 3                       ; DO and the Control Flow section of the manual for details).
0013F2r 3                       ; """
0013F2r 3               
0013F2r 3               xt_plus_loop:
0013F2r 3                               ; Compile the run-time part. We do this with a short loop
0013F2r 3                               ; and not a call to COMPILE, because it has to be natively
0013F2r 3                               ; coded anyway.
0013F2r 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
0013F4r 3  5A                           phy             ; save counter to adjust CP
0013F5r 3               @1:
0013F5r 3  B9 rr rr                     lda plus_loop_runtime,y
0013F8r 3  91 00                        sta (cp),y
0013FAr 3  88                           dey
0013FBr 3  10 F8                        bpl @1
0013FDr 3               
0013FDr 3                               ; Adjust CP
0013FDr 3  68                           pla
0013FEr 3  18                           clc
0013FFr 3  65 00                        adc cp
001401r 3  85 00                        sta cp
001403r 3  A5 01                        lda cp+1
001405r 3  69 00                        adc #0          ; only need carry
001407r 3  85 01                        sta cp+1
001409r 3               
001409r 3                               ; The address we need to loop back to is TOS. Store it so
001409r 3                               ; the runtime part of +LOOP jumps back up there
001409r 3  20 rr rr                     jsr xt_comma
00140Cr 3               
00140Cr 3                               ; Compile an UNLOOP for when we're all done. This is a series
00140Cr 3                               ; of six PLA, so we just do it here instead jumping around
00140Cr 3                               ; all over the place
00140Cr 3  A9 68                        lda #$68                ; opcode for PLA
00140Er 3  A0 06                        ldy #6
001410r 3               @2:
001410r 3  91 00                        sta (cp),y
001412r 3  88                           dey
001413r 3  10 FB                        bpl @2
001415r 3               
001415r 3                               ; Adjust CP
001415r 3  A9 06                        lda #6
001417r 3  18                           clc
001418r 3  65 00                        adc cp
00141Ar 3  85 00                        sta cp
00141Cr 3  A5 01                        lda cp+1
00141Er 3  69 00                        adc #0                  ; only need carry
001420r 3  85 01                        sta cp+1
001422r 3               
001422r 3                               ; Complete compile of DO/?DO by replacing the six
001422r 3                               ; dummy bytes by PHA instructions. The address where
001422r 3                               ; they are located is on the Data Stack
001422r 3  B5 00                        lda 0,x
001424r 3  85 24                        sta tmp1
001426r 3  B5 01                        lda 1,x
001428r 3  85 25                        sta tmp1+1
00142Ar 3  E8                           inx
00142Br 3  E8                           inx
00142Cr 3               
00142Cr 3                               ; Because of the way that CP works, we don't have to save
00142Cr 3                               ; CP, but CP-1
00142Cr 3  A5 00                        lda cp
00142Er 3  38                           sec
00142Fr 3  E9 01                        sbc #1
001431r 3  85 26                        sta tmp2
001433r 3  A5 01                        lda cp+1
001435r 3  E9 00                        sbc #0
001437r 3  85 27                        sta tmp2+1
001439r 3               
001439r 3                               ; now compile this in the DO/?DO routine
001439r 3  A0 00                        ldy #0
00143Br 3               
00143Br 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
00143Dr 3  91 24                        sta (tmp1),y
00143Fr 3  C8                           iny
001440r 3  A5 27                        lda tmp2+1      ; MSB
001442r 3  91 24                        sta (tmp1),y
001444r 3  C8                           iny
001445r 3  A9 48                        lda #$48        ; Opcode for PHA
001447r 3  91 24                        sta (tmp1),y
001449r 3  C8                           iny
00144Ar 3               
00144Ar 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
00144Cr 3  91 24                        sta (tmp1),y
00144Er 3  C8                           iny
00144Fr 3  A5 26                        lda tmp2        ; LSB
001451r 3  91 24                        sta (tmp1),y
001453r 3  C8                           iny
001454r 3  A9 48                        lda #$48        ; Opcode for PHA
001456r 3  91 24                        sta (tmp1),y
001458r 3               z_loop:
001458r 3  60           z_plus_loop:    rts
001459r 3               
001459r 3               
001459r 3               plus_loop_runtime:
001459r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001459r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001459r 3                       ; loop control so we can test with the Overflow Flag. See
001459r 3                       ; the Control Flow section of the manual for details.
001459r 3                       ; The step value is TOS in the loop. This
001459r 3                       ; must always be native compiled. In some Forths, this is a separate
001459r 3                       ; word called (+LOOP) or (LOOP)
001459r 3                       ; """
001459r 3               
001459r 3  18                           clc
00145Ar 3  68                           pla             ; LSB of index
00145Br 3  75 00                        adc 0,x         ; LSB of step
00145Dr 3  A8                           tay             ; temporary storage of LSB
00145Er 3               
00145Er 3  B8                           clv
00145Fr 3  68                           pla             ; MSB of index
001460r 3  75 01                        adc 1,x         ; MSB of step
001462r 3  48                           pha             ; put MSB of index back on stack
001463r 3               
001463r 3  98                           tya             ; put LSB of index back on stack
001464r 3  48                           pha
001465r 3               
001465r 3  E8                           inx             ; dump step from TOS
001466r 3  E8                           inx
001467r 3               
001467r 3                               ; If V flag is set, we're done looping and continue
001467r 3                               ; after the +LOOP instruction
001467r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001469r 3               
001469r 3               @hack:          ; This is why this routine must be natively compiled: We
001469r 3                               ; compile the opcode for JMP here without an address to
001469r 3                               ; go to, which is added by the next next instruction of
001469r 3                               ; LOOP/+LOOP during compile time
001469r 3  4C                           .byte $4C
00146Ar 3               
00146Ar 3               plus_loop_runtime_end:
00146Ar 3               
00146Ar 3               
00146Ar 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
00146Ar 3               ; ## "lshift"  auto  ANS core
00146Ar 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
00146Ar 3               
00146Ar 3               xt_lshift:
00146Ar 3  20 rr rr                     jsr underflow_2
00146Dr 3               
00146Dr 3                               ; max shift 16 times
00146Dr 3  B5 00                        lda 0,x
00146Fr 3  29 0F                        and #%00001111
001471r 3  F0 08                        beq @done
001473r 3               
001473r 3  A8                           tay
001474r 3               
001474r 3               @loop:
001474r 3  16 02                        asl 2,x
001476r 3  36 03                        rol 3,x
001478r 3  88                           dey
001479r 3  D0 F9                        bne @loop
00147Br 3               
00147Br 3               @done:
00147Br 3  E8                           inx
00147Cr 3  E8                           inx
00147Dr 3               
00147Dr 3  60           z_lshift:       rts
00147Er 3               
00147Er 3               
00147Er 3               
00147Er 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
00147Er 3               ; ## "m*"  auto  ANS core
00147Er 3                       ; """https://forth-standard.org/standard/core/MTimes
00147Er 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
00147Er 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
00147Er 3                       ;
00147Er 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
00147Er 3                       ; with  : D+- O< IF DNEGATE THEN ;
00147Er 3                       ; """
00147Er 3               
00147Er 3               xt_m_star:
00147Er 3  20 rr rr                     jsr underflow_2
001481r 3               
001481r 3                               ; figure out the sign
001481r 3  B5 01                        lda 1,x         ; MSB of n1
001483r 3  55 03                        eor 3,x         ; MSB of n2
001485r 3               
001485r 3                               ; UM* uses all kinds of temporary variables so we don't
001485r 3                               ; risk a conflict but just take the cycle hit and push
001485r 3                               ; this to the stack
001485r 3  48                           pha
001486r 3               
001486r 3                               ; get the absolute value of both numbers so we can feed
001486r 3                               ; them to UM*, which does the real work
001486r 3  20 rr rr                     jsr xt_abs
001489r 3  20 rr rr                     jsr xt_swap
00148Cr 3  20 rr rr                     jsr xt_abs
00148Fr 3               
00148Fr 3  20 rr rr                     jsr xt_um_star          ; ( d )
001492r 3               
001492r 3                               ; handle the sign
001492r 3  68                           pla
001493r 3  10 03                        bpl @done
001495r 3               
001495r 3  20 rr rr                     jsr xt_dnegate
001498r 3               @done:
001498r 3  60           z_m_star:       rts
001499r 3               
001499r 3               
001499r 3               
001499r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001499r 3               ; ## "marker"  auto  ANS core ext
001499r 3                       ; """https://forth-standard.org/standard/core/MARKER
001499r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001499r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001499r 3                       ; Run the named word at a later time to restore all of the wordlists
001499r 3                       ; to their state when the word was created with marker.  Any words
001499r 3                       ; created after the marker (including the marker) will be forgotten.
001499r 3                       ;
001499r 3                       ; To do this, we want to end up with something that jumps to a
001499r 3                       ; run-time component with a link to the original CP and DP values:
001499r 3                       ;
001499r 3                       ;       jsr marker_runtime
001499r 3                       ;       <Original CP MSB>
001499r 3                       ;       <Original CP LSB>
001499r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001499r 3                       ;       <Original DP LSB>
001499r 3                       ;       < USER variables from offset 4 to 39 >
001499r 3                       ;
001499r 3                       ;       The user variables include:
001499r 3                       ;       CURRENT (byte variable)
001499r 3                       ;       <All wordlists> (currently 12) (cell array)
001499r 3                       ;       <#ORDER> (byte variable)
001499r 3                       ;       <All search order> (currently 9) (byte array)
001499r 3                       ;
001499r 3                       ; This code uses tmp1 and tmp2
001499r 3                       ; """
001499r 3               
001499r 3               xt_marker:
001499r 3                               ; Before we do anything, we need to save CP, which
001499r 3                               ; after all is the whole point of this operation. CREATE
001499r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001499r 3                               ; to the stack
001499r 3  20 rr rr                     jsr current_to_dp
00149Cr 3               
00149Cr 3  A5 02                        lda dp
00149Er 3  48                           pha
00149Fr 3  A5 03                        lda dp+1
0014A1r 3  48                           pha
0014A2r 3               
0014A2r 3  A5 00                        lda cp
0014A4r 3  48                           pha
0014A5r 3  A5 01                        lda cp+1
0014A7r 3  48                           pha
0014A8r 3               
0014A8r 3  20 rr rr                     jsr xt_create
0014ABr 3               
0014ABr 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
0014ABr 3                               ; we have to replace by a jump to marker_runtime. We back up
0014ABr 3                               ; two bytes and then overwrite the address
0014ABr 3  A5 00                        lda cp          ; LSB
0014ADr 3  38                           sec
0014AEr 3  E9 02                        sbc #2
0014B0r 3  85 00                        sta cp
0014B2r 3               
0014B2r 3  A5 01                        lda cp+1        ; MSB
0014B4r 3  E9 00                        sbc #0          ; we only care about the borrow
0014B6r 3  85 01                        sta cp+1
0014B8r 3               
0014B8r 3                               ; Add the address of the runtime component
0014B8r 3  A0 rr                        ldy #>marker_runtime
0014BAr 3  A9 rr                        lda #<marker_runtime
0014BCr 3  20 rr rr                     jsr cmpl_word
0014BFr 3               
0014BFr 3                               ; Add original CP as payload
0014BFr 3  7A                           ply                     ; MSB
0014C0r 3  68                           pla                     ; LSB
0014C1r 3  20 rr rr                     jsr cmpl_word
0014C4r 3               
0014C4r 3                               ; Add original DP as payload
0014C4r 3  7A                           ply                     ; MSB
0014C5r 3  68                           pla                     ; LSB
0014C6r 3  20 rr rr                     jsr cmpl_word
0014C9r 3               
0014C9r 3                               ; Add the user variables for the wordlists and search order.
0014C9r 3                               ; We're compiling them in byte order.
0014C9r 3  A0 04                        ldy #4                  ; Start at CURRENT
0014CBr 3               @marker_loop:
0014CBr 3  B1 1E                        lda (up),y
0014CDr 3  20 rr rr                     jsr cmpl_a
0014D0r 3  C8                           iny
0014D1r 3  98                           tya
0014D2r 3  C9 28                        cmp #40                 ; One past the end of the search order.
0014D4r 3  D0 F5                        bne @marker_loop
0014D6r 3               
0014D6r 3  60           z_marker:       rts
0014D7r 3               
0014D7r 3               
0014D7r 3               
0014D7r 3               marker_runtime:
0014D7r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
0014D7r 3                       ; when this marker was defined. We arrive here with the return
0014D7r 3                       ; address on the Return Stack in the usual 65c02 format
0014D7r 3                       ; """
0014D7r 3               
0014D7r 3                               ; Get the address of the string address off the stack and
0014D7r 3                               ; increase by one because of the RTS mechanics
0014D7r 3  68                           pla
0014D8r 3  85 24                        sta tmp1        ; LSB of address
0014DAr 3  68                           pla
0014DBr 3  85 25                        sta tmp1+1      ; MSB of address
0014DDr 3               
0014DDr 3  E6 24                        inc tmp1
0014DFr 3  D0 02                        bne @1
0014E1r 3  E6 25                        inc tmp1+1
0014E3r 3               @1:
0014E3r 3  A0 00                        ldy #0
0014E5r 3               
0014E5r 3                               ; CP was stored first
0014E5r 3  B1 24                        lda (tmp1),y
0014E7r 3  85 00                        sta cp
0014E9r 3  C8                           iny
0014EAr 3  B1 24                        lda (tmp1),y
0014ECr 3  85 01                        sta cp+1
0014EEr 3               
0014EEr 3                               ; Next was DP
0014EEr 3  C8                           iny
0014EFr 3  B1 24                        lda (tmp1),y
0014F1r 3  85 02                        sta dp
0014F3r 3  C8                           iny
0014F4r 3  B1 24                        lda (tmp1),y
0014F6r 3  85 03                        sta dp+1
0014F8r 3               
0014F8r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
0014F8r 3                               ; to start restoring the wordlists and search order.
0014F8r 3  A0 04                        ldy #4
0014FAr 3               
0014FAr 3               @marker_restore_loop:
0014FAr 3                               ; Copy from the dictionary back on top of the wordlists
0014FAr 3                               ; and search order.
0014FAr 3  B1 24                        lda (tmp1), y
0014FCr 3  91 1E                        sta (up), y
0014FEr 3  C8                           iny
0014FFr 3  98                           tya
001500r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001502r 3  D0 F6                        bne @marker_restore_loop
001504r 3               
001504r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001507r 3               
001507r 3                               ; The return instruction takes us back to the original caller
001507r 3  60                           rts
001508r 3               
001508r 3               
001508r 3               
001508r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001508r 3               ; ## "max"  auto  ANS core
001508r 3                       ; """https://forth-standard.org/standard/core/MAX
001508r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001508r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001508r 3                       ; Flag indicates which number is larger. See also
001508r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001508r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001508r 3                       ; """
001508r 3               
001508r 3               xt_max:
001508r 3  20 rr rr                     jsr underflow_2
00150Br 3               
00150Br 3                               ; Compare LSB. We do this first to set the carry flag
00150Br 3  B5 00                        lda 0,x         ; LSB of TOS
00150Dr 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
00150Fr 3               
00150Fr 3  B5 01                        lda 1,x         ; MSB of TOS
001511r 3  F5 03                        sbc 3,x         ; MSB of NOS
001513r 3  50 02                        bvc @no_overflow
001515r 3               
001515r 3                               ; handle overflow, because we use signed numbers
001515r 3  49 80                        eor #$80        ; complement negative flag
001517r 3               
001517r 3               @no_overflow:
001517r 3                               ; if negative, NOS is larger and needs to be kept
001517r 3  30 08                        bmi @keep_nos
001519r 3               
001519r 3                               ; move TOS to NOS
001519r 3  B5 00                        lda 0,x
00151Br 3  95 02                        sta 2,x
00151Dr 3  B5 01                        lda 1,x
00151Fr 3  95 03                        sta 3,x
001521r 3               
001521r 3               @keep_nos:
001521r 3  E8                           inx
001522r 3  E8                           inx
001523r 3               
001523r 3  60           z_max:          rts
001524r 3               
001524r 3               
001524r 3               
001524r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001524r 3               ; ## "min"  auto  ANS core
001524r 3                       ; """https://forth-standard.org/standard/core/MIN
001524r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001524r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001524r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001524r 3                       ; """
001524r 3               
001524r 3               xt_min:
001524r 3  20 rr rr                     jsr underflow_2
001527r 3               
001527r 3                               ; compare LSB. We do this first to set the carry flag
001527r 3  B5 00                        lda 0,x         ; LSB of TOS
001529r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
00152Br 3               
00152Br 3  B5 01                        lda 1,x         ; MSB of TOS
00152Dr 3  F5 03                        sbc 3,x         ; MSB of NOS
00152Fr 3  50 02                        bvc @no_overflow
001531r 3               
001531r 3                               ; handle overflow because we use signed numbers
001531r 3  49 80                        eor #$80
001533r 3               
001533r 3               @no_overflow:
001533r 3                               ; if negative, NOS is larger and needs to be dumped
001533r 3  10 08                        bpl @keep_nos
001535r 3               
001535r 3                               ; move TOS to NOS
001535r 3  B5 00                        lda 0,x
001537r 3  95 02                        sta 2,x
001539r 3  B5 01                        lda 1,x
00153Br 3  95 03                        sta 3,x
00153Dr 3               
00153Dr 3               @keep_nos:
00153Dr 3  E8                           inx
00153Er 3  E8                           inx
00153Fr 3               
00153Fr 3  60           z_min:          rts
001540r 3               
001540r 3               
001540r 3               
001540r 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001540r 3               ; ## "-"  auto  ANS core
001540r 3                       ; """https://forth-standard.org/standard/core/Minus"""
001540r 3               xt_minus:
001540r 3  20 rr rr                     jsr underflow_2
001543r 3               
001543r 3  38                           sec
001544r 3  B5 02                        lda 2,x         ; LSB
001546r 3  F5 00                        sbc 0,x
001548r 3  95 02                        sta 2,x
00154Ar 3               
00154Ar 3  B5 03                        lda 3,x         ; MSB
00154Cr 3  F5 01                        sbc 1,x
00154Er 3  95 03                        sta 3,x
001550r 3               
001550r 3  E8                           inx
001551r 3  E8                           inx
001552r 3               
001552r 3  60           z_minus:        rts
001553r 3               
001553r 3               
001553r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001553r 3               ; ## "-leading"  auto  Tali String
001553r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001553r 3                       ; """
001553r 3               
001553r 3               xt_minus_leading:
001553r 3  20 rr rr                     jsr underflow_2
001556r 3               
001556r 3               @loop:
001556r 3                               ; Quit if we were given an empty string. This also terminates
001556r 3                               ; the main loop
001556r 3  B5 00                        lda 0,x
001558r 3  15 01                        ora 1,x
00155Ar 3  F0 0F                        beq @done
00155Cr 3               
00155Cr 3  A1 02                        lda (2,x)               ; get first character
00155Er 3  20 rr rr                     jsr is_whitespace
001561r 3  90 08                        bcc @done
001563r 3               
001563r 3                               ; It's whitespace, move one down
001563r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001566r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001569r 3               
001569r 3  80 EB                        bra @loop
00156Br 3               @done:
00156Br 3               z_minus_leading:
00156Br 3  60                           rts
00156Cr 3               
00156Cr 3               
00156Cr 3               
00156Cr 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
00156Cr 3               ; ## "-trailing"  auto  ANS string
00156Cr 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
00156Cr 3                       ; Remove trailing spaces
00156Cr 3                       ; """
00156Cr 3               
00156Cr 3               xt_minus_trailing:
00156Cr 3  20 rr rr                     jsr underflow_2
00156Fr 3               
00156Fr 3                               ; if length entry is zero, return a zero and leave the
00156Fr 3                               ; address part untouched
00156Fr 3  B5 00                        lda 0,x         ; LSB of n
001571r 3  15 01                        ora 1,x         ; MSB of n
001573r 3  F0 33                        beq @done
001575r 3               
001575r 3                               ; Compute address of last char in tmp1 as
001575r 3                               ; addr + u1 - 1
001575r 3               
001575r 3                               ; addr + u1
001575r 3  18                           clc
001576r 3  B5 02                        lda 2,x         ; LSB of addr
001578r 3  75 00                        adc 0,x
00157Ar 3  85 24                        sta tmp1
00157Cr 3  B5 03                        lda 3,x         ; MSB of addr
00157Er 3  75 01                        adc 1,x
001580r 3  85 25                        sta tmp1+1
001582r 3               
001582r 3                               ; - 1
001582r 3  A5 24                        lda tmp1
001584r 3  D0 02                        bne @1
001586r 3  C6 25                        dec tmp1+1
001588r 3               @1:
001588r 3  C6 24                        dec tmp1
00158Ar 3               
00158Ar 3               @loop:
00158Ar 3                               ; While spaces are found, move tmp1 backwards and
00158Ar 3                               ; decrease the count on the data stack.
00158Ar 3  B2 24                        lda (tmp1)
00158Cr 3  C9 20                        cmp #AscSP
00158Er 3  D0 18                        bne @done
001590r 3               
001590r 3                               ; Move back one address.
001590r 3  A5 24                        lda tmp1
001592r 3  D0 02                        bne @2
001594r 3  C6 25                        dec tmp1+1
001596r 3               @2:
001596r 3  C6 24                        dec tmp1
001598r 3               
001598r 3                               ; Decrement count by one.
001598r 3  B5 00                        lda 0,x
00159Ar 3  D0 02                        bne @3
00159Cr 3  D6 01                        dec 1,x
00159Er 3               @3:
00159Er 3  D6 00                        dec 0,x
0015A0r 3               
0015A0r 3                               ; Check if there are any characters left.
0015A0r 3  B5 00                        lda 0,x
0015A2r 3  15 01                        ora 1,x
0015A4r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
0015A6r 3               
0015A6r 3  80 E2                        bra @loop
0015A8r 3               
0015A8r 3               @done:
0015A8r 3               z_minus_trailing:
0015A8r 3  60                           rts
0015A9r 3               
0015A9r 3               
0015A9r 3               
0015A9r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
0015A9r 3               ; ## "mod"  auto  ANS core
0015A9r 3                       ; """https://forth-standard.org/standard/core/MOD
0015A9r 3                       ;
0015A9r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
0015A9r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
0015A9r 3                       ; """
0015A9r 3               xt_mod:
0015A9r 3  20 rr rr                     jsr underflow_2
0015ACr 3               
0015ACr 3  20 rr rr                     jsr xt_slash_mod
0015AFr 3               
0015AFr 3  E8                           inx             ; DROP
0015B0r 3  E8                           inx
0015B1r 3               z_mod:
0015B1r 3  60                           rts
0015B2r 3               
0015B2r 3               
0015B2r 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
0015B2r 3               ; ## "move"  auto  ANS core
0015B2r 3                       ; """https://forth-standard.org/standard/core/MOVE
0015B2r 3                       ; Copy u "address units" from addr1 to addr2. Since our address
0015B2r 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
0015B2r 3                       ; is actually the only one of these three words that is in the CORE
0015B2r 3                       ; set.
0015B2r 3                       ;
0015B2r 3                       ; This word must not be natively compiled.
0015B2r 3                       ; """
0015B2r 3               
0015B2r 3               xt_move:
0015B2r 3                               ; We let CMOVE and CMOVE> check if there is underflow or
0015B2r 3                               ; we've been told to copy zero bytes
0015B2r 3               
0015B2r 3                               ; compare MSB first
0015B2r 3  B5 03                        lda 3,x                 ; MSB of addr2
0015B4r 3  D5 05                        cmp 5,x                 ; MSB of addr1
0015B6r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
0015B8r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
0015BAr 3               
0015BAr 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
0015BDr 3               
0015BDr 3               @lsb:
0015BDr 3                               ; MSB were equal, so do the whole thing over with LSB
0015BDr 3  B5 02                        lda 2,x                 ; LSB of addr2
0015BFr 3  D5 04                        cmp 4,x                 ; LSB of addr1
0015C1r 3  F0 08                        beq @equal              ; LSB is equal as well
0015C3r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
0015C5r 3               
0015C5r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
0015C8r 3               
0015C8r 3               @to_move_up:
0015C8r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
0015CBr 3               @equal:
0015CBr 3                               ; drop three entries from Data Stack
0015CBr 3  8A                           txa
0015CCr 3  18                           clc
0015CDr 3  69 06                        adc #6
0015CFr 3  AA                           tax
0015D0r 3               
0015D0r 3  60           z_move:         rts
0015D1r 3               
0015D1r 3               
0015D1r 3               
0015D1r 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
0015D1r 3               ; ## "name>int"  tested  Gforth
0015D1r 3                       ; """See
0015D1r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0015D1r 3                       ; """
0015D1r 3               
0015D1r 3               xt_name_to_int:
0015D1r 3  20 rr rr                     jsr underflow_1
0015D4r 3               
0015D4r 3                               ; The xt starts four bytes down from the nt
0015D4r 3  B5 00                        lda 0,x
0015D6r 3  18                           clc
0015D7r 3  69 04                        adc #4
0015D9r 3  85 28                        sta tmp3
0015DBr 3               
0015DBr 3  B5 01                        lda 1,x
0015DDr 3  90 01                        bcc @done
0015DFr 3  1A                           inc
0015E0r 3               @done:
0015E0r 3  85 29                        sta tmp3+1
0015E2r 3               
0015E2r 3  A0 00                        ldy #0
0015E4r 3  B1 28                        lda (tmp3),y
0015E6r 3  95 00                        sta 0,x
0015E8r 3  C8                           iny
0015E9r 3  B1 28                        lda (tmp3),y
0015EBr 3  95 01                        sta 1,x
0015EDr 3               
0015EDr 3  60           z_name_to_int:  rts
0015EEr 3               
0015EEr 3               
0015EEr 3               
0015EEr 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
0015EEr 3               ; ## "name>string"  tested  Gforth
0015EEr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
0015EEr 3               
0015EEr 3               xt_name_to_string:
0015EEr 3  20 rr rr                     jsr underflow_1
0015F1r 3               
0015F1r 3  CA                           dex
0015F2r 3  CA                           dex
0015F3r 3               
0015F3r 3                               ; the length of the string is the first byte of the
0015F3r 3                               ; header pointed to by nt
0015F3r 3  A1 02                        lda (2,x)
0015F5r 3  95 00                        sta 0,x
0015F7r 3  74 01                        stz 1,x
0015F9r 3               
0015F9r 3                               ; the string itself always starts eight bytes down
0015F9r 3  B5 02                        lda 2,x         ; LSB
0015FBr 3  18                           clc
0015FCr 3  69 08                        adc #8
0015FEr 3  A8                           tay
0015FFr 3  B5 03                        lda 3,x         ; MSB
001601r 3  69 00                        adc #0          ; just need carry
001603r 3  95 03                        sta 3,x
001605r 3  94 02                        sty 2,x
001607r 3               
001607r 3               z_name_to_string:
001607r 3  60                           rts
001608r 3               
001608r 3               
001608r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001608r 3               ; ## "nc-limit"  tested  Tali Forth
001608r 3               
001608r 3               xt_nc_limit:
001608r 3  CA                           dex
001609r 3  CA                           dex
00160Ar 3  A9 1A                        lda #<nc_limit
00160Cr 3  95 00                        sta 0,x
00160Er 3  A9 00                        lda #>nc_limit
001610r 3  95 01                        sta 1,x
001612r 3               
001612r 3  60           z_nc_limit:     rts
001613r 3               
001613r 3               
001613r 3               
001613r 3               ; ## NEGATE ( n -- n ) "Two's complement"
001613r 3               ; ## "negate"  auto  ANS core
001613r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001613r 3               xt_negate:
001613r 3  20 rr rr                     jsr underflow_1
001616r 3               
001616r 3  A9 00                	lda #0
001618r 3  38                           sec
001619r 3  F5 00                        sbc 0,x         ; LSB
00161Br 3  95 00                        sta 0,x
00161Dr 3               
00161Dr 3  A9 00                        lda #0
00161Fr 3  F5 01                        sbc 1,x         ; MSB
001621r 3  95 01                        sta 1,x
001623r 3               
001623r 3  60           z_negate:       rts
001624r 3               
001624r 3               
001624r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001624r 3               ; ## "never-native"  auto  Tali Forth
001624r 3               xt_never_native:
001624r 3  20 rr rr                     jsr current_to_dp
001627r 3  A0 01                        ldy #1          ; offset for status byte
001629r 3  B1 02                        lda (dp),y
00162Br 3  09 08                        ora #NN         ; Make sure NN flag is set
00162Dr 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
00162Fr 3  91 02                        sta (dp),y
001631r 3               z_never_native:
001631r 3  60                           rts
001632r 3               
001632r 3               
001632r 3               ; ## NIP ( b a -- a ) "Delete NOS"
001632r 3               ; ## "nip"  auto  ANS core ext
001632r 3                       ; """https://forth-standard.org/standard/core/NIP"""
001632r 3               xt_nip:
001632r 3  20 rr rr                     jsr underflow_2
001635r 3               
001635r 3  B5 00                        lda 0,x         ; LSB
001637r 3  95 02                        sta 2,x
001639r 3  B5 01                        lda 1,x         ; MSB
00163Br 3  95 03                        sta 3,x
00163Dr 3               
00163Dr 3  E8                           inx
00163Er 3  E8                           inx
00163Fr 3               
00163Fr 3  60           z_nip:          rts
001640r 3               
001640r 3               
001640r 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
001640r 3               ; ## "<>"  auto  ANS core ext
001640r 3                       ; """https://forth-standard.org/standard/core/ne
001640r 3                       ;
001640r 3                       ; This is just a variant of EQUAL, we code it separately
001640r 3                       ; for speed.
001640r 3                       ; """
001640r 3               
001640r 3               xt_not_equals:
001640r 3  20 rr rr                     jsr underflow_2
001643r 3               
001643r 3  A0 00                        ldy #0                  ; default is true
001645r 3               
001645r 3  B5 00                        lda 0,x                 ; LSB
001647r 3  D5 02                        cmp 2,x
001649r 3  D0 0A                        bne @not_equal
00164Br 3               
00164Br 3                               ; LSB is equal
00164Br 3  B5 01                        lda 1,x                 ; MSB
00164Dr 3  D5 03                        cmp 3,x
00164Fr 3  D0 04                        bne @not_equal
001651r 3               
001651r 3  A9 FF                        lda #$FF
001653r 3  80 01                        bra @done
001655r 3               
001655r 3               @not_equal:
001655r 3  88                           dey                     ; drop thru to done
001656r 3               
001656r 3               @done:
001656r 3  98                           tya
001657r 3  E8                           inx
001658r 3  E8                           inx
001659r 3  95 00                        sta 0,x
00165Br 3  95 01                        sta 1,x
00165Dr 3               
00165Dr 3  60           z_not_equals:   rts
00165Er 3               
00165Er 3               
00165Er 3               
00165Er 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
00165Er 3               ; ## "-rot"  auto  Gforth
00165Er 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
00165Er 3               
00165Er 3               xt_not_rote:
00165Er 3  20 rr rr                     jsr underflow_3
001661r 3               
001661r 3  B4 01                        ldy 1,x         ; MSB first
001663r 3  B5 03                        lda 3,x
001665r 3  95 01                        sta 1,x
001667r 3               
001667r 3  B5 05                        lda 5,x
001669r 3  95 03                        sta 3,x
00166Br 3  94 05                        sty 5,x
00166Dr 3               
00166Dr 3  B4 00                        ldy 0,x         ; LSB second
00166Fr 3  B5 02                        lda 2,x
001671r 3  95 00                        sta 0,x
001673r 3               
001673r 3  B5 04                        lda 4,x
001675r 3  95 02                        sta 2,x
001677r 3  94 04                        sty 4,x
001679r 3               
001679r 3  60           z_not_rote:     rts
00167Ar 3               
00167Ar 3               
00167Ar 3               
00167Ar 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
00167Ar 3               ; ## "number"  auto  Tali Forth
00167Ar 3                       ; """Convert a number string to a double or single cell number. This
00167Ar 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
00167Ar 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
00167Ar 3                       ; Based in part on the "Starting Forth" code
00167Ar 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
00167Ar 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
00167Ar 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
00167Ar 3                       ; Another difference to Gforth is that we follow ANS Forth that the
00167Ar 3                       ; dot to signal a double cell number is required to be the last
00167Ar 3                       ; character of the string.
00167Ar 3                       ;
00167Ar 3                       ; Number calls >NUMBER which in turn calls UM*,
00167Ar 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
00167Ar 3                       ; a pain.
00167Ar 3                       ;"""
00167Ar 3               
00167Ar 3               xt_number:
00167Ar 3  20 rr rr                     jsr underflow_2
00167Dr 3               
00167Dr 3                               ; we keep the flags for sign and double in tmpdsp because
00167Dr 3                               ; we've run out of temporary variables
00167Dr 3  64 2A                        stz tmpdsp      ; flag for double
00167Fr 3  64 2B                        stz tmpdsp+1    ; flag for minus
001681r 3               
001681r 3                               ; If the first character is a minus, strip it off and set
001681r 3                               ; the flag
001681r 3  A1 02                        lda (2,x)
001683r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001685r 3  D0 0A                        bne @check_dot
001687r 3               
001687r 3                               ; It's a minus
001687r 3  C6 2B                        dec tmpdsp+1
001689r 3  F6 02                        inc 2,x         ; start one character later
00168Br 3  D0 02                        bne @1
00168Dr 3  F6 03                        inc 3,x
00168Fr 3               @1:
00168Fr 3  D6 00                        dec 0,x         ; decrease string length by one
001691r 3               
001691r 3               @check_dot:
001691r 3                               ; If the last character is a dot, strip it off and set a
001691r 3                               ; flag. We can use tmptos as a temporary variable
001691r 3  B5 02                        lda 2,x         ; LSB of address
001693r 3  18                           clc
001694r 3  75 00                        adc 0,x         ; length of string
001696r 3  85 2C                        sta tmptos
001698r 3  B5 03                        lda 3,x
00169Ar 3  69 00                        adc #0          ; only need carry
00169Cr 3  85 2D                        sta tmptos+1
00169Er 3               
00169Er 3                               ; tmptos now points to the first character after the string,
00169Er 3                               ; but we need the last character
00169Er 3  A5 2C                        lda tmptos
0016A0r 3  D0 02                        bne @2
0016A2r 3  C6 2D                        dec tmptos+1
0016A4r 3               @2:
0016A4r 3  C6 2C                        dec tmptos
0016A6r 3               
0016A6r 3  B2 2C                        lda (tmptos)
0016A8r 3  C9 2E                        cmp #'.'
0016AAr 3  D0 04                        bne @main
0016ACr 3               
0016ACr 3                               ; We have a dot, which means this is a double number. Flag
0016ACr 3                               ; the fact and reduce string length by one
0016ACr 3  C6 2A                        dec tmpdsp
0016AEr 3  D6 00                        dec 0,x
0016B0r 3               
0016B0r 3               @main:
0016B0r 3                               ; Set up stack for subroutine jump to >NUMBER, which means
0016B0r 3                               ; we have to go ( addr u --> ud addr u )
0016B0r 3  CA                           dex
0016B1r 3  CA                           dex
0016B2r 3  CA                           dex
0016B3r 3  CA                           dex
0016B4r 3               
0016B4r 3  B5 04                        lda 4,x         ; LSB of length
0016B6r 3  95 00                        sta 0,x
0016B8r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
0016BAr 3               
0016BAr 3  B5 06                        lda 6,x         ; LSB of address
0016BCr 3  95 02                        sta 2,x
0016BEr 3  B5 07                        lda 7,x         ; MSB of address
0016C0r 3  95 03                        sta 3,x
0016C2r 3               
0016C2r 3  74 04                        stz 4,x         ; clear space for ud
0016C4r 3  74 05                        stz 5,x
0016C6r 3  74 06                        stz 6,x
0016C8r 3  74 07                        stz 7,x
0016CAr 3               
0016CAr 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
0016CDr 3               
0016CDr 3                               ; test length of returned string, which should be zero
0016CDr 3  B5 00                        lda 0,x
0016CFr 3  F0 15                        beq @all_converted
0016D1r 3               
0016D1r 3                               ; Something went wrong, we still have characters left over,
0016D1r 3                               ; so we print an error and abort. If the NUMBER was called
0016D1r 3                               ; by INTERPRET, we've already checked for Forth words, so
0016D1r 3                               ; we're in deep trouble one way or another
0016D1r 3  A9 3E                        lda #$3E        ; ASCII for ">"
0016D3r 3  20 rr rr                     jsr emit_a
0016D6r 3  20 rr rr                     jsr xt_type
0016D9r 3  A9 3C                        lda #$3C        ; ASCII for "<"
0016DBr 3  20 rr rr                     jsr emit_a
0016DEr 3  20 rr rr                     jsr xt_space
0016E1r 3               
0016E1r 3  A9 08                        lda #err_syntax
0016E3r 3  4C rr rr                     jmp error
0016E6r 3               
0016E6r 3               @all_converted:
0016E6r 3                               ; We can drop the string info
0016E6r 3  E8                           inx
0016E7r 3  E8                           inx
0016E8r 3  E8                           inx
0016E9r 3  E8                           inx
0016EAr 3               
0016EAr 3                               ; We have a double-cell number on the Data Stack that might
0016EAr 3                               ; actually have a minus and might actually be single-cell
0016EAr 3  A5 2A                        lda tmpdsp      ; flag for double
0016ECr 3  F0 0D                        beq @single
0016EEr 3               
0016EEr 3                               ; Set status bit 5 to indicate this is a double number
0016EEr 3  A9 20                        lda #%00100000
0016F0r 3  04 20                        tsb status
0016F2r 3               
0016F2r 3                               ; This is a double cell number. If it had a minus, we'll have
0016F2r 3                               ; to negate it
0016F2r 3  A5 2B                        lda tmpdsp+1
0016F4r 3  F0 12                        beq @done       ; no minus, all done
0016F6r 3               
0016F6r 3  20 rr rr                     jsr xt_dnegate
0016F9r 3               
0016F9r 3  80 0D                        bra @done
0016FBr 3               
0016FBr 3               @single:
0016FBr 3                               ; This is a single number, so we just drop the top cell
0016FBr 3  E8                           inx
0016FCr 3  E8                           inx
0016FDr 3               
0016FDr 3                               ; Clear status bit 5 to indicate this is a single number
0016FDr 3  A9 20                        lda #%00100000
0016FFr 3  14 20                        trb status
001701r 3               
001701r 3                               ; If we had a minus, we'll have to negate it
001701r 3  A5 2B                        lda tmpdsp+1
001703r 3  F0 03                        beq @done       ; no minus, all done
001705r 3               
001705r 3  20 rr rr                     jsr xt_negate
001708r 3               @done:
001708r 3  60           z_number:       rts
001709r 3               
001709r 3               
001709r 3               
001709r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001709r 3               ; ## "#"  auto  ANS core
001709r 3                       ; """https://forth-standard.org/standard/core/num
001709r 3                       ; Add one char to the beginning of the pictured output string.
001709r 3                       ;
001709r 3                       ; Based on
001709r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001709r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001709r 3                       ; """
001709r 3               xt_number_sign:
001709r 3  20 rr rr                     jsr underflow_2         ; double number
00170Cr 3               
00170Cr 3  20 rr rr                     jsr xt_base
00170Fr 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
001712r 3               
001712r 3                               ; The following code is the ancient Forth word UD/MOD, which in
001712r 3                               ; various Forths (including Gforth) lives on under the hood,
001712r 3                               ; even though it's not an ANS standard word, it doesn't appear
001712r 3                               ; in the docs, it's only used here, and there are no tests for
001712r 3                               ; it. This is why we got rid of it. We'll be converting this
001712r 3                               ; mess to something more sane in the long run.
001712r 3  20 rr rr                     jsr xt_to_r             ; >r
001715r 3  20 rr rr                     jsr xt_zero             ; 0
001718r 3  20 rr rr                     jsr xt_r_fetch          ; r@
00171Br 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
00171Er 3  20 rr rr                     jsr xt_rot              ; rot
001721r 3  20 rr rr                     jsr xt_rot              ; rot
001724r 3  20 rr rr                     jsr xt_r_from           ; r>
001727r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
00172Ar 3  20 rr rr                     jsr xt_rot              ; rot
00172Dr 3                               ; end of UD/MOD ( rem ud )
00172Dr 3               
00172Dr 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
001730r 3               
001730r 3                               ; Convert the number that is left over to an ASCII character. We
001730r 3                               ; use a string lookup for speed. Use either abc_str_lower for
001730r 3                               ; lower case or abc_str_upper for upper case (prefered)
001730r 3  B5 00                        lda 0,x
001732r 3  A8                           tay
001733r 3  B9 rr rr                     lda s_abc_upper,y
001736r 3  95 00                        sta 0,x
001738r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
00173Ar 3               
00173Ar 3  20 rr rr                     jsr xt_hold
00173Dr 3               
00173Dr 3               z_number_sign:
00173Dr 3  60                           rts
00173Er 3               
00173Er 3               
00173Er 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
00173Er 3               ; ## "#>"  auto  ANS core
00173Er 3                       ; """https://forth-standard.org/standard/core/num-end
00173Er 3                       ; Finish conversion of pictured number string, putting address and
00173Er 3                       ; length on the Data Stack.
00173Er 3                       ;
00173Er 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
00173Er 3                       ; Based on
00173Er 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00173Er 3                       ; """
00173Er 3               xt_number_sign_greater:
00173Er 3               
00173Er 3  20 rr rr                     jsr underflow_2         ; double number
001741r 3               
001741r 3                               ; The start address lives in tohold
001741r 3  A5 34                        lda tohold
001743r 3  95 00                        sta 0,x         ; LSB of tohold
001745r 3  95 02                        sta 2,x
001747r 3  A5 35                        lda tohold+1
001749r 3  95 01                        sta 1,x         ; MSB of addr
00174Br 3  95 03                        sta 3,x         ; ( addr addr )
00174Dr 3               
00174Dr 3                               ; The length of the string is pad - addr
00174Dr 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
001750r 3               
001750r 3  38                           sec
001751r 3  B5 00                        lda 0,x         ; LSB of pad address
001753r 3  F5 02                        sbc 2,x
001755r 3  95 02                        sta 2,x
001757r 3               
001757r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001759r 3  F5 03                        sbc 3,x
00175Br 3  95 03                        sta 3,x         ; ( addr u pad )
00175Dr 3               
00175Dr 3  E8                           inx
00175Er 3  E8                           inx
00175Fr 3               
00175Fr 3               z_number_sign_greater:
00175Fr 3  60                           rts
001760r 3               
001760r 3               
001760r 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
001760r 3               ; ## "#s"  auto  ANS core
001760r 3                       ; """https://forth-standard.org/standard/core/numS
001760r 3                       ; Completely convert number for pictured numerical output.
001760r 3                       ;
001760r 3                       ; Based on
001760r 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
001760r 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
001760r 3                       ; """
001760r 3               
001760r 3               xt_number_sign_s:
001760r 3  20 rr rr                     jsr underflow_2
001763r 3               @loop:
001763r 3                               ; convert a single number ("#")
001763r 3  20 rr rr                     jsr xt_number_sign
001766r 3               
001766r 3                               ; stop when double-celled number in TOS is zero:
001766r 3  B5 00                        lda 0,x
001768r 3  15 01                        ora 1,x
00176Ar 3  15 02                        ora 2,x
00176Cr 3  15 03                        ora 3,x
00176Er 3  D0 F3                        bne @loop
001770r 3               
001770r 3               z_number_sign_s:
001770r 3  60                           rts
001771r 3               
001771r 3               
001771r 3               
001771r 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
001771r 3               ; ## "of"  auto  ANS core ext
001771r 3                       ; """http://forth-standard.org/standard/core/OF"""
001771r 3               
001771r 3               xt_of:
001771r 3                               ; Check if value is equal to this case.
001771r 3                               ; Postpone over (eg. compile a jsr to it)
001771r 3  A0 rr                        ldy #>xt_over
001773r 3  A9 rr                        lda #<xt_over
001775r 3  20 rr rr                     jsr cmpl_subroutine
001778r 3               
001778r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001778r 3  A0 rr                        ldy #>xt_equal
00177Ar 3  A9 rr                        lda #<xt_equal
00177Cr 3  20 rr rr                     jsr cmpl_subroutine
00177Fr 3               
00177Fr 3  20 rr rr                     jsr xt_if
001782r 3               
001782r 3                               ; If it's true, consume the original value.
001782r 3                               ; Postpone DROP (eg. compile a jsr to it)
001782r 3  A0 rr                        ldy #>xt_drop
001784r 3  A9 rr                        lda #<xt_drop
001786r 3  20 rr rr                     jsr cmpl_subroutine
001789r 3               
001789r 3  60           z_of:           rts
00178Ar 3               
00178Ar 3               
00178Ar 3               
00178Ar 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
00178Ar 3               ; ## "1"  auto  Tali Forth
00178Ar 3                       ; """This is also the code for EDITOR-WORDLIST"""
00178Ar 3               xt_editor_wordlist:
00178Ar 3               xt_one:
00178Ar 3  CA                           dex
00178Br 3  CA                           dex
00178Cr 3  A9 01                        lda #1
00178Er 3  95 00                        sta 0,x
001790r 3  74 01                        stz 1,x
001792r 3               
001792r 3               z_editor_wordlist:
001792r 3               z_one:
001792r 3  60                           rts
001793r 3               
001793r 3               
001793r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001793r 3               ; ## "1-"  auto  ANS core
001793r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001793r 3               
001793r 3               xt_one_minus:
001793r 3  20 rr rr                     jsr underflow_1
001796r 3               
001796r 3  B5 00                        lda 0,x
001798r 3  D0 02                        bne @1
00179Ar 3  D6 01                        dec 1,x
00179Cr 3               @1:
00179Cr 3  D6 00                        dec 0,x
00179Er 3               
00179Er 3  60           z_one_minus:    rts
00179Fr 3               
00179Fr 3               
00179Fr 3               
00179Fr 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
00179Fr 3               ; ## "1+"  auto  ANS core
00179Fr 3                       ; """https://forth-standard.org/standard/core/OnePlus
00179Fr 3                       ;
00179Fr 3                       ; Code is shared with CHAR-PLUS
00179Fr 3                       ; """
00179Fr 3               
00179Fr 3               xt_char_plus:
00179Fr 3               xt_one_plus:
00179Fr 3  20 rr rr                     jsr underflow_1
0017A2r 3               
0017A2r 3  F6 00                        inc 0,x
0017A4r 3  D0 02                        bne @done
0017A6r 3  F6 01                        inc 1,x
0017A8r 3               
0017A8r 3               @done:
0017A8r 3               z_char_plus:
0017A8r 3  60           z_one_plus:     rts
0017A9r 3               
0017A9r 3               
0017A9r 3               
0017A9r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
0017A9r 3               ; ## "only"  auto  ANS search ext
0017A9r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
0017A9r 3               
0017A9r 3               xt_only:
0017A9r 3                               ; Put -1 on data stack.
0017A9r 3  CA                           dex
0017AAr 3  CA                           dex
0017ABr 3  A9 FF                        lda #$FF
0017ADr 3  95 00                        sta 0,x
0017AFr 3  95 01                        sta 1,x
0017B1r 3               
0017B1r 3                               ; Invoke set-order to set the minimum search order.
0017B1r 3  20 rr rr                     jsr xt_set_order
0017B4r 3               
0017B4r 3  60           z_only:         rts
0017B5r 3               
0017B5r 3               
0017B5r 3               
0017B5r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
0017B5r 3               ; ## "or"  auto  ANS core
0017B5r 3                       ; """https://forth-standard.org/standard/core/OR"
0017B5r 3               xt_or:
0017B5r 3  20 rr rr                     jsr underflow_2
0017B8r 3               
0017B8r 3  B5 00                        lda 0,x
0017BAr 3  15 02                        ora 2,x
0017BCr 3  95 02                        sta 2,x
0017BEr 3               
0017BEr 3  B5 01                        lda 1,x
0017C0r 3  15 03                        ora 3,x
0017C2r 3  95 03                        sta 3,x
0017C4r 3               
0017C4r 3  E8                           inx
0017C5r 3  E8                           inx
0017C6r 3               
0017C6r 3  60           z_or:           rts
0017C7r 3               
0017C7r 3               
0017C7r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
0017C7r 3               ; ## "order"  auto  ANS core
0017C7r 3                       ; """https://forth-standard.org/standard/search/ORDER
0017C7r 3                       ; Note the search order is displayed from first search to last
0017C7r 3                       ; searched and is therefore exactly the reverse of the order in which
0017C7r 3                       ; Forth stacks are displayed.
0017C7r 3                       ;
0017C7r 3                       ; A Forth implementation of this word is:
0017C7r 3                       ;
0017C7r 3                       ; 	: .wid ( wid -- )
0017C7r 3                       ; 	dup 0=  if ." Forth "  drop    else
0017C7r 3                       ; 	dup 1 = if ." Editor " drop    else
0017C7r 3                       ; 	dup 2 = if ." Assembler " drop else
0017C7r 3                       ; 	dup 3 = if ." Root " drop      else
0017C7r 3                       ; 	           . ( just print the number )
0017C7r 3                       ; 	then then then then ;
0017C7r 3                       ;
0017C7r 3                       ; : ORDER ( -- )
0017C7r 3                       ; 	cr get-order 0 ?do .wid loop
0017C7r 3                       ; 	space space get-current .wid ;
0017C7r 3                       ;
0017C7r 3                       ; This is an interactive program, so speed
0017C7r 3                       ; is not as important as size. We assume we do not have more than 255
0017C7r 3                       ; wordlists.
0017C7r 3                       ; """
0017C7r 3               
0017C7r 3               xt_order:
0017C7r 3  20 rr rr                     jsr xt_cr
0017CAr 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
0017CDr 3               
0017CDr 3                               ; Paranoid: Check if there are no wordlists, a rather
0017CDr 3                               ; pathological case. this would mean ( 0 ) on the stack. In
0017CDr 3                               ; that case, we just drop n and run
0017CDr 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
0017CFr 3  F0 1E                        beq @drop_done
0017D1r 3               
0017D1r 3               @have_wordlists:
0017D1r 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
0017D1r 3                               ; on the stack
0017D1r 3  A8                           tay
0017D2r 3               @loop:
0017D2r 3  E8                           inx
0017D3r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
0017D4r 3  B5 00                        lda 0,x
0017D6r 3               
0017D6r 3  5A                           phy
0017D7r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
0017DAr 3  7A                           ply
0017DBr 3               
0017DBr 3  88                           dey
0017DCr 3  D0 F4                        bne @loop
0017DEr 3               
0017DEr 3                               ; We've printed the wordlists, now we add the current wordlist.
0017DEr 3                               ; This follows the convention of Gforth
0017DEr 3  20 rr rr                     jsr xt_space
0017E1r 3  20 rr rr                     jsr xt_space
0017E4r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
0017E7r 3               
0017E7r 3  B5 00                        lda 0,x
0017E9r 3  20 rr rr                     jsr _print_wid_string
0017ECr 3  20 rr rr                     jsr xt_cr
0017EFr 3               
0017EFr 3               @drop_done:
0017EFr 3  E8                           inx
0017F0r 3  E8                           inx
0017F1r 3               z_order:
0017F1r 3  60                           rts
0017F2r 3               
0017F2r 3               _print_wid_string:
0017F2r 3                       ; """Helper function for ORDER: Given a WID in A, print the
0017F2r 3                       ; corresponding string. If there is no such word list defined, just
0017F2r 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
0017F2r 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
0017F2r 3                       ; theory, we could speed this up by having the WID be the same as the
0017F2r 3                       ; number of the strings. However, ORDER is used rather infrequently and
0017F2r 3                       ; this would make changes to the strings.asm file very dangerous, so we
0017F2r 3                       ; follow the slightly more complicated route with a translation table.
0017F2r 3                       ; """
0017F2r 3                               ; If the WID is larger than 3, we have no string avaliable and
0017F2r 3                               ; just print the number.
0017F2r 3                               ; See http://6502.org/tutorials/compare_instructions.html
0017F2r 3                               ; for details
0017F2r 3  C9 04                        cmp #4
0017F4r 3  90 09                        bcc @output_string      ; less than 4, print a real string
0017F6r 3               
0017F6r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
0017F6r 3                               ; print the number
0017F6r 3  CA                           dex
0017F7r 3  CA                           dex
0017F8r 3  95 00                        sta 0,x
0017FAr 3  74 01                        stz 1,x
0017FCr 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
0017FFr 3               
0017FFr 3               @output_string:
0017FFr 3                               ; Get the string number based on WID 0 to 3
0017FFr 3  A8                           tay
001800r 3  B9 rr rr                     lda @wid_data,y
001803r 3               
001803r 3                               ; Print without a line feed
001803r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
001806r 3               
001806r 3               @wid_data:
001806r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
001806r 3                       ; less than 4.
001806r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
001807r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
001808r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
001809r 3  08                   .byte str_wid_root             ; WID 3: "Root"
00180Ar 3               
00180Ar 3               
00180Ar 3               
00180Ar 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
00180Ar 3               ; ## "output"  tested  Tali Forth
00180Ar 3               xt_output:
00180Ar 3                       ; """Return the address where the jump target for EMIT is stored (but
00180Ar 3                       ; not the vector itself). By default, this will hold the value of
00180Ar 3                       ; kernel_putc routine, but this can be changed by the user, hence this
00180Ar 3                       ; routine.
00180Ar 3                       ; """
00180Ar 3  CA                           dex
00180Br 3  CA                           dex
00180Cr 3  A9 10                        lda #<output
00180Er 3  95 00                        sta 0,x
001810r 3  A9 00                        lda #>output
001812r 3  95 01                        sta 1,x
001814r 3               
001814r 3  60           z_output:       rts
001815r 3               
001815r 3               
001815r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
001815r 3               ; ## "over"  auto  ANS core
001815r 3                       ; """https://forth-standard.org/standard/core/OVER"""
001815r 3               xt_over:
001815r 3  20 rr rr                     jsr underflow_2
001818r 3               
001818r 3  CA                           dex
001819r 3  CA                           dex
00181Ar 3               
00181Ar 3  B5 04                        lda 4,x         ; LSB
00181Cr 3  95 00                        sta 0,x
00181Er 3  B5 05                        lda 5,x         ; MSB
001820r 3  95 01                        sta 1,x
001822r 3               
001822r 3  60           z_over:         rts
001823r 3               
001823r 3               
001823r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
001823r 3               ; ## "pad"  auto  ANS core ext
001823r 3                       ; """https://forth-standard.org/standard/core/PAD
001823r 3                       ; Return address to a temporary area in free memory for user. Must
001823r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
001823r 3                       ; the compile area pointer (CP) and therefore varies in position.
001823r 3                       ; This area is reserved for the user and not used by the system
001823r 3                       ; """
001823r 3               xt_pad:
001823r 3  CA                           dex
001824r 3  CA                           dex
001825r 3               
001825r 3  A5 00                        lda cp
001827r 3  18                           clc
001828r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
00182Ar 3  95 00                        sta 0,x
00182Cr 3               
00182Cr 3  A5 01                        lda cp+1
00182Er 3  69 00                        adc #0          ; only need carry
001830r 3  95 01                        sta 1,x
001832r 3               
001832r 3  60           z_pad:          rts
001833r 3               
001833r 3               
001833r 3               ; ## PAGE ( -- ) "Clear the screen"
001833r 3               ; ## "page"  tested  ANS facility
001833r 3                       ; """https://forth-standard.org/standard/facility/PAGE
001833r 3                       ; Clears a page if supported by ANS terminal codes. This is
001833r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
001833r 3                       ; left of the screen
001833r 3                       ; """
001833r 3               xt_page:
001833r 3  A9 1B                        lda #AscESC
001835r 3  20 rr rr                     jsr emit_a
001838r 3  A9 5B                        lda #$5B        ; ASCII for "["
00183Ar 3  20 rr rr                     jsr emit_a
00183Dr 3  A9 32                        lda #'2'
00183Fr 3  20 rr rr                     jsr emit_a
001842r 3  A9 4A                        lda #'J'
001844r 3  20 rr rr                     jsr emit_a
001847r 3               
001847r 3                               ; move cursor to top left of screen
001847r 3  20 rr rr                     jsr xt_zero
00184Ar 3  20 rr rr                     jsr xt_zero
00184Dr 3  20 rr rr                     jsr xt_at_xy
001850r 3               
001850r 3  60           z_page:         rts
001851r 3               
001851r 3               
001851r 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
001851r 3               ; ## "("  auto  ANS core
001851r 3                       ; """http://forth-standard.org/standard/core/p"""
001851r 3               
001851r 3               xt_paren:
001851r 3                               ; Put a right paren on the stack.
001851r 3  CA                           dex
001852r 3  CA                           dex
001853r 3  A9 29                        lda #41     ; Right parenthesis
001855r 3  95 00                        sta 0,x
001857r 3  74 01                        stz 1,x
001859r 3               
001859r 3                               ; Call parse.
001859r 3  20 rr rr                     jsr xt_parse
00185Cr 3               
00185Cr 3                               ; Throw away the result.
00185Cr 3  E8                           inx
00185Dr 3  E8                           inx
00185Er 3  E8                           inx
00185Fr 3  E8                           inx
001860r 3               
001860r 3  60           z_paren:        rts
001861r 3               
001861r 3               
001861r 3               
001861r 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
001861r 3               ; ## "parse-name"  auto  ANS core ext
001861r 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
001861r 3                       ; Find next word in input string, skipping leading whitespace. This is
001861r 3                       ; a special form of PARSE and drops through to that word. See PARSE
001861r 3                       ; for more detail. We use this word internally for the interpreter
001861r 3                       ; because it is a lot easier to use. Reference implementations at
001861r 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
001861r 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
001861r 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
001861r 3                       ; though the ANS standard talks about skipping "spaces", whitespace
001861r 3                       ; is actually perfectly legal (see for example
001861r 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
001861r 3                       ; Otherwise, PARSE-NAME chokes on tabs.
001861r 3                       ; """
001861r 3               
001861r 3               xt_parse_name:
001861r 3                               ; To enable the compilation of the high-level Forth words
001861r 3                               ; in forth-words.asm and user-words.asm at boot time,
001861r 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
001861r 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
001861r 3                               ; to the current location is in toin (>IN). We need to check,
001861r 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
001861r 3                               ; we can't just use Y as an index.
001861r 3               
001861r 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
001861r 3  A5 0A                        lda ciblen              ; LSB of counter
001863r 3  38                           sec
001864r 3  E5 0C                        sbc toin
001866r 3  85 24                        sta tmp1
001868r 3  A5 0B                        lda ciblen+1            ; MSB
00186Ar 3  E5 0D                        sbc toin+1
00186Cr 3  85 25                        sta tmp1+1
00186Er 3               
00186Er 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
00186Er 3  A5 24                        lda tmp1
001870r 3  05 25                        ora tmp1+1
001872r 3  F0 28                        beq @empty_line
001874r 3               
001874r 3                               ; We walk through the characters starting at CIB+TOIN, so we
001874r 3                               ; save a temp version of that in tmp2
001874r 3  A5 08                        lda cib
001876r 3  18                           clc
001877r 3  65 0C                        adc toin
001879r 3  85 26                        sta tmp2                ; LSB of first character
00187Br 3  A5 09                        lda cib+1
00187Dr 3  65 0D                        adc toin+1
00187Fr 3  85 27                        sta tmp2+1              ; MSB
001881r 3               
001881r 3               @skip_loop:
001881r 3  B2 26                        lda (tmp2)              ; work copy of cib
001883r 3  20 rr rr                     jsr is_whitespace
001886r 3  90 1F                        bcc @char_found
001888r 3               
001888r 3                               ; Char is still whitespace, continue
001888r 3  E6 26                        inc tmp2
00188Ar 3  D0 02                        bne @2
00188Cr 3  E6 27                        inc tmp2+1
00188Er 3               @2:
00188Er 3                               ; Adjust counter
00188Er 3  A5 24                        lda tmp1
001890r 3  D0 02                        bne @3
001892r 3  C6 25                        dec tmp1+1
001894r 3               @3:
001894r 3  C6 24                        dec tmp1
001896r 3               
001896r 3  A5 24                        lda tmp1
001898r 3  05 25                        ora tmp1+1
00189Ar 3  D0 E5                        bne @skip_loop          ; fall through if empty line
00189Cr 3               
00189Cr 3               @empty_line:
00189Cr 3                               ; Neither the ANS Forth nor the Gforth documentation say
00189Cr 3                               ; what to return as an address if a string with only
00189Cr 3                               ; spaces is given. For speed reasons, we just return junk
00189Cr 3                               ; NOS, with the TOS zero as per standard
00189Cr 3  CA                           dex
00189Dr 3  CA                           dex
00189Er 3  CA                           dex
00189Fr 3  CA                           dex
0018A0r 3               
0018A0r 3  74 00                        stz 0,x                 ; TOS is zero
0018A2r 3  74 01                        stz 1,x
0018A4r 3               
0018A4r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
0018A7r 3               
0018A7r 3               @char_found:
0018A7r 3                               ; We arrive here with tmp2 pointing to the first non-space
0018A7r 3                               ; character. This is where the word really starts, so
0018A7r 3                               ; we use it to calculate the new >IN by subtracting
0018A7r 3  A5 26                        lda tmp2
0018A9r 3  38                           sec
0018AAr 3  E5 08                        sbc cib
0018ACr 3  85 0C                        sta toin
0018AEr 3  A5 27                        lda tmp2+1
0018B0r 3  E5 09                        sbc cib+1
0018B2r 3  85 0D                        sta toin+1
0018B4r 3               
0018B4r 3                               ; prepare Data Stack for PARSE by adding space
0018B4r 3                               ; as the delimiter
0018B4r 3  CA                           dex
0018B5r 3  CA                           dex
0018B6r 3               
0018B6r 3  A9 20                        lda #AscSP
0018B8r 3  95 00                        sta 0,x
0018BAr 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
0018BCr 3               
0018BCr 3               
0018BCr 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
0018BCr 3               ; ## "parse"  tested  ANS core ext
0018BCr 3                       ; """https://forth-standard.org/standard/core/PARSE
0018BCr 3                       ; Find word in input string delimited by character given. Do not
0018BCr 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
0018BCr 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
0018BCr 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
0018BCr 3                       ;
0018BCr 3                       ;
0018BCr 3                       ;     cib  cib+toin   cib+ciblen
0018BCr 3                       ;      v      v            v
0018BCr 3                       ;     |###################|
0018BCr 3                       ;
0018BCr 3                       ;     |------>|  toin (>IN)
0018BCr 3                       ;     |------------------->|  ciblen
0018BCr 3                       ;
0018BCr 3                       ; The input string is stored starting at the address in the Current
0018BCr 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
0018BCr 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
0018BCr 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
0018BCr 3                       ; useful string if there are any characters at all. As with
0018BCr 3                       ; PARSE-NAME, we must be able to handle strings with a length of
0018BCr 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
0018BCr 3                       ; """
0018BCr 3               
0018BCr 3               xt_parse:
0018BCr 3  20 rr rr                     jsr underflow_1
0018BFr 3               
0018BFr 3                               ; If the input buffer is empty, we just return
0018BFr 3  A5 0A                        lda ciblen
0018C1r 3  05 0B                        ora ciblen+1
0018C3r 3  F0 0C                        beq @abort_parse
0018C5r 3               
0018C5r 3                               ; If the pointer >IN is larger or equal to the length of
0018C5r 3                               ; the input buffer (CIBLEN), the line is done. Put
0018C5r 3                               ; differently, we only continue if >IN is smaller than
0018C5r 3                               ; CIBLEN
0018C5r 3  A5 0D                        lda toin+1              ; MSB
0018C7r 3  C5 0B                        cmp ciblen+1
0018C9r 3  90 0E                        bcc @go_parse           ; unsigned comparison
0018CBr 3               
0018CBr 3  A5 0C                        lda toin                ; LSB
0018CDr 3  C5 0A                        cmp ciblen
0018CFr 3  90 08                        bcc @go_parse
0018D1r 3               
0018D1r 3               @abort_parse:
0018D1r 3                               ; Sorry, this line is over
0018D1r 3  CA                           dex
0018D2r 3  CA                           dex
0018D3r 3  74 00                        stz 0,x
0018D5r 3  74 01                        stz 1,x
0018D7r 3               
0018D7r 3  80 7A                        bra @done
0018D9r 3               @go_parse:
0018D9r 3                               ; We actually have work to do. Save the delimiter in
0018D9r 3                               ; tmptos.
0018D9r 3  B5 00                        lda 0,x
0018DBr 3  85 2C                        sta tmptos
0018DDr 3               
0018DDr 3                               ; We can now prepare the Data Stack for the return value
0018DDr 3  CA                           dex
0018DEr 3  CA                           dex
0018DFr 3               
0018DFr 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
0018DFr 3                               ; tmp2 is initially the same as tmp1, then the work index
0018DFr 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
0018DFr 3               
0018DFr 3                               ; Calculate the beginning of the string, which is also the
0018DFr 3                               ; address to return
0018DFr 3  A5 08                        lda cib
0018E1r 3  18                           clc
0018E2r 3  65 0C                        adc toin        ; LSB
0018E4r 3  85 24                        sta tmp1
0018E6r 3  85 26                        sta tmp2
0018E8r 3  95 02                        sta 2,x
0018EAr 3               
0018EAr 3  A5 09                        lda cib+1
0018ECr 3  65 0D                        adc toin+1      ; MSB
0018EEr 3  85 25                        sta tmp1+1
0018F0r 3  85 27                        sta tmp2+1
0018F2r 3  95 03                        sta 3,x
0018F4r 3               
0018F4r 3                               ; Calculate the address where the input buffer ends plus 1, so
0018F4r 3                               ; we can compare it with TOIN, which is an index
0018F4r 3  A5 08                        lda cib
0018F6r 3  18                           clc
0018F7r 3  65 0A                        adc ciblen
0018F9r 3  85 28                        sta tmp3
0018FBr 3  A5 09                        lda cib+1
0018FDr 3  65 0B                        adc ciblen+1
0018FFr 3  85 29                        sta tmp3+1
001901r 3               
001901r 3                               ; Initialize the offset we use to adjust EOL or found delimiter
001901r 3  64 2D                        stz tmptos+1
001903r 3               @loop:
001903r 3                               ; If we are at the end of the string, quit
001903r 3  A5 26                        lda tmp2
001905r 3  C5 28                        cmp tmp3
001907r 3  D0 06                        bne @not_empty
001909r 3               
001909r 3  A5 27                        lda tmp2+1
00190Br 3  C5 29                        cmp tmp3+1
00190Dr 3  F0 1D                        beq @eol
00190Fr 3               @not_empty:
00190Fr 3                               ; We have to do this the hard way. In fact, it's really
00190Fr 3                               ; hard since if we are dealing with a SPACE, the standard
00190Fr 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
00190Fr 3                               ; Tali would choke on tabs between words. For details, see
00190Fr 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
00190Fr 3                               ; In theory, we could make this faster by defining a delimiter
00190Fr 3                               ; that is 00 as the sign that we skip all whitespace, thereby
00190Fr 3                               ; avoiding having to test every time. However, somebody,
00190Fr 3                               ; somewhere might want to parse a zero-delimited list. Since
00190Fr 3                               ; any byte value could be chosen for that, we just test for
00190Fr 3                               ; a space every single time for the moment.
00190Fr 3  B2 26                        lda (tmp2)
001911r 3               
001911r 3  A4 2C                        ldy tmptos
001913r 3  C0 20                        cpy #AscSP
001915r 3  D0 07                        bne @not_whitespace
001917r 3               
001917r 3                               ; The delimiter is a space, so we're looking for all
001917r 3                               ; whitespace
001917r 3  20 rr rr                     jsr is_whitespace
00191Ar 3  90 02                        bcc @not_whitespace
00191Cr 3  80 0C                        bra @found_delimiter
00191Er 3               
00191Er 3               @not_whitespace:
00191Er 3                               ; The delimiter is not a space, so we're looking for
00191Er 3                               ; whatever it is
00191Er 3  C5 2C                        cmp tmptos
001920r 3  F0 08                        beq @found_delimiter
001922r 3               
001922r 3                               ; Not a delimiter, next character
001922r 3  E6 26                        inc tmp2
001924r 3  D0 DD                        bne @loop
001926r 3  E6 27                        inc tmp2+1
001928r 3  80 D9                        bra @loop
00192Ar 3               
00192Ar 3               @found_delimiter:
00192Ar 3                               ; Increase the offset: If we've found a delimiter, we want
00192Ar 3                               ; TOIN to point to the character after it, not the delimiter
00192Ar 3                               ; itself
00192Ar 3  E6 2D                        inc tmptos+1
00192Cr 3               @eol:
00192Cr 3                               ; The length of the new string is tmp2-tmp1
00192Cr 3  A5 26                        lda tmp2
00192Er 3  38                           sec
00192Fr 3  E5 24                        sbc tmp1
001931r 3  95 00                        sta 0,x
001933r 3               
001933r 3  A5 27                        lda tmp2+1
001935r 3  E5 25                        sbc tmp1+1
001937r 3  95 01                        sta 1,x
001939r 3               
001939r 3                               ; The new offset is tmp2-cib
001939r 3  A5 26                        lda tmp2
00193Br 3  38                           sec
00193Cr 3  E5 08                        sbc cib
00193Er 3  85 0C                        sta toin
001940r 3  A5 27                        lda tmp2+1
001942r 3  E5 09                        sbc cib+1
001944r 3  85 0D                        sta toin+1
001946r 3               
001946r 3                               ; Add in the delimiter
001946r 3  A5 0C                        lda toin
001948r 3  18                           clc
001949r 3  65 2D                        adc tmptos+1
00194Br 3  85 0C                        sta toin
00194Dr 3  A5 0D                        lda toin+1
00194Fr 3  69 00                        adc #0          ; we only need the carry
001951r 3  85 0D                        sta toin+1
001953r 3               @done:
001953r 3               z_parse_name:
001953r 3  60           z_parse:        rts
001954r 3               
001954r 3               
001954r 3               
001954r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
001954r 3               ; ## "pick"  auto  ANS core ext
001954r 3                       ; """https://forth-standard.org/standard/core/PICK
001954r 3                       ; Take the u-th element out of the stack and put it on TOS,
001954r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
001954r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
001954r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
001954r 3                       ; """
001954r 3               
001954r 3               xt_pick:
001954r 3                               ; Checking for underflow is difficult because it depends on
001954r 3                               ; which element we want to grab. We could probably figure
001954r 3                               ; something out, but it wouldn't work with underflow stripping
001954r 3                               ; Since using PICK is considered poor form anyway, we just
001954r 3                               ; leave it as it is
001954r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
001956r 3  8A                           txa
001957r 3  75 00                        adc 0,x
001959r 3  A8                           tay
00195Ar 3               
00195Ar 3  B9 02 00                     lda 0002,y
00195Dr 3  95 00                        sta 0,x
00195Fr 3  B9 03 00                     lda 0003,y
001962r 3  95 01                        sta 1,x
001964r 3               
001964r 3  60           z_pick:         rts
001965r 3               
001965r 3               
001965r 3               
001965r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
001965r 3               ; ## "+"  auto  ANS core
001965r 3                       ; """https://forth-standard.org/standard/core/Plus"""
001965r 3               xt_plus:
001965r 3  20 rr rr                     jsr underflow_2
001968r 3               
001968r 3  18                           clc
001969r 3  B5 00                        lda 0,x         ; LSB
00196Br 3  75 02                        adc 2,x
00196Dr 3  95 02                        sta 2,x
00196Fr 3               
00196Fr 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
001971r 3  75 03                        adc 3,x
001973r 3  95 03                        sta 3,x
001975r 3               
001975r 3  E8                           inx
001976r 3  E8                           inx
001977r 3               
001977r 3  60           z_plus:         rts
001978r 3               
001978r 3               
001978r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
001978r 3               ; ## "+!"  auto  ANS core
001978r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
001978r 3               xt_plus_store:
001978r 3  20 rr rr                     jsr underflow_2
00197Br 3               
00197Br 3                               ; move address to tmp1 so we can work with it
00197Br 3  B5 00                        lda 0,x
00197Dr 3  85 24                        sta tmp1
00197Fr 3  B5 01                        lda 1,x
001981r 3  85 25                        sta tmp1+1
001983r 3               
001983r 3  A0 00                        ldy #0          ; LSB
001985r 3  B1 24                        lda (tmp1),y
001987r 3  18                           clc
001988r 3  75 02                        adc 2,x
00198Ar 3  91 24                        sta (tmp1),y
00198Cr 3               
00198Cr 3  C8                           iny             ; MSB
00198Dr 3  B1 24                        lda (tmp1),y
00198Fr 3  75 03                        adc 3,x
001991r 3  91 24                        sta (tmp1),y
001993r 3               
001993r 3  E8                           inx
001994r 3  E8                           inx
001995r 3  E8                           inx
001996r 3  E8                           inx
001997r 3               
001997r 3  60           z_plus_store:   rts
001998r 3               
001998r 3               
001998r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
001998r 3               ; ## "postpone"  auto   ANS core
001998r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
001998r 3                       ; Add the compilation behavior of a word to a new word at
001998r 3                       ; compile time. If the word that follows it is immediate, include
001998r 3                       ; it so that it will be compiled when the word being defined is
001998r 3                       ; itself used for a new word. Tricky, but very useful.
001998r 3                       ;
001998r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
001998r 3                       ; on the Data Stack). This means we cannot build words with
001998r 3                       ; "jsr xt_postpone, jsr <word>" directly.
001998r 3                       ; """
001998r 3               
001998r 3               xt_postpone:
001998r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
00199Br 3               
00199Br 3                               ; if there was no word provided, complain and quit
00199Br 3  B5 00                        lda 0,x
00199Dr 3  15 01                        ora 1,x
00199Fr 3  D0 05                        bne @1
0019A1r 3               
0019A1r 3  A9 05                        lda #err_noname
0019A3r 3  4C rr rr                     jmp error
0019A6r 3               @1:
0019A6r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
0019A9r 3               
0019A9r 3                               ; if word not in Dictionary, complain and quit
0019A9r 3  D0 05                        bne @2
0019ABr 3  A9 05                        lda #err_noname
0019ADr 3  4C rr rr                     jmp error
0019B0r 3               
0019B0r 3               @2:
0019B0r 3                               ; keep a copy of nt for later
0019B0r 3  B5 00                        lda 0,x
0019B2r 3  85 24                        sta tmp1
0019B4r 3  B5 01                        lda 1,x
0019B6r 3  85 25                        sta tmp1+1
0019B8r 3               
0019B8r 3                               ; We need the xt instead of the nt
0019B8r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
0019BBr 3               
0019BBr 3                               ; See if this is an immediate word. This is easier
0019BBr 3                               ; with nt than with xt. The status byte of the word
0019BBr 3                               ; is nt+1
0019BBr 3  E6 24                        inc tmp1
0019BDr 3  D0 02                        bne @3
0019BFr 3  E6 25                        inc tmp1+1
0019C1r 3               @3:
0019C1r 3  B2 24                        lda (tmp1)
0019C3r 3  29 04                        and #IM         ; mask all but Intermediate flag
0019C5r 3  F0 05                        beq @not_immediate
0019C7r 3               
0019C7r 3                               ; We're immediate, so instead of executing it right now, we
0019C7r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
0019C7r 3                               ; takes us back to the original caller
0019C7r 3  20 rr rr                     jsr xt_compile_comma
0019CAr 3  80 0A                        bra @done
0019CCr 3               
0019CCr 3               @not_immediate:
0019CCr 3                               ; This is not an immediate word, so we enact "deferred
0019CCr 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
0019CCr 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
0019CCr 3                               ; a subroutine jump to COMPILE,
0019CCr 3  20 rr rr                     jsr xt_literal
0019CFr 3               
0019CFr 3                               ; Last, compile COMPILE,
0019CFr 3  A0 rr                        ldy #>xt_compile_comma
0019D1r 3  A9 rr                        lda #<xt_compile_comma
0019D3r 3  20 rr rr                     jsr cmpl_subroutine
0019D6r 3               @done:
0019D6r 3  60           z_postpone:     rts
0019D7r 3               
0019D7r 3               
0019D7r 3               
0019D7r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
0019D7r 3               ; ## "previous"  auto  ANS search ext
0019D7r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
0019D7r 3               
0019D7r 3               xt_previous:
0019D7r 3  20 rr rr                     jsr xt_get_order
0019DAr 3  20 rr rr                     jsr xt_nip
0019DDr 3  20 rr rr                     jsr xt_one_minus
0019E0r 3  20 rr rr                     jsr xt_set_order
0019E3r 3               
0019E3r 3  60           z_previous:     rts
0019E4r 3               
0019E4r 3               
0019E4r 3               
0019E4r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
0019E4r 3               ; ## "?"  tested  ANS tools
0019E4r 3                       ; """https://forth-standard.org/standard/tools/q
0019E4r 3                       ;
0019E4r 3                       ; Only used interactively. Since humans are so slow, we
0019E4r 3                       ; save size and just go for the subroutine jumps
0019E4r 3                       ; """
0019E4r 3               xt_question:
0019E4r 3                               ; FETCH takes care of underflow check
0019E4r 3  20 rr rr                     jsr xt_fetch
0019E7r 3  20 rr rr                     jsr xt_dot
0019EAr 3               
0019EAr 3  60           z_question:     rts
0019EBr 3               
0019EBr 3               
0019EBr 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
0019EBr 3               ; ## "?dup"  auto  ANS core
0019EBr 3                       ; """https://forth-standard.org/standard/core/qDUP"""
0019EBr 3               
0019EBr 3               xt_question_dup:
0019EBr 3  20 rr rr                     jsr underflow_1
0019EEr 3               
0019EEr 3                               ; Check if TOS is zero
0019EEr 3  B5 00                        lda 0,x
0019F0r 3  15 01                        ora 1,x
0019F2r 3  F0 0A                        beq @done
0019F4r 3               
0019F4r 3                               ; not zero, duplicate
0019F4r 3  CA                           dex
0019F5r 3  CA                           dex
0019F6r 3  B5 02                        lda 2,x
0019F8r 3  95 00                        sta 0,x
0019FAr 3  B5 03                        lda 3,x
0019FCr 3  95 01                        sta 1,x
0019FEr 3               @done:
0019FEr 3  60           z_question_dup: rts
0019FFr 3               
0019FFr 3               
0019FFr 3               
0019FFr 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
0019FFr 3               ; ## "r@"  auto  ANS core
0019FFr 3                       ; """https://forth-standard.org/standard/core/RFetch
0019FFr 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
0019FFr 3                       ; work normally as well
0019FFr 3                       ;
0019FFr 3                       ; An alternative way to write this word
0019FFr 3                       ; would be to access the elements on the stack directly like 2R@
0019FFr 3                       ; does, these versions should be compared at some point.
0019FFr 3                       ; """
0019FFr 3               xt_r_fetch:
0019FFr 3                               ; get the return address
0019FFr 3  7A                           ply             ; LSB
001A00r 3  84 24                        sty tmp1
001A02r 3  7A                           ply             ; MSB
001A03r 3               
001A03r 3                               ; --- CUT FOR NATIVE COMPILE ---
001A03r 3               
001A03r 3                               ; get the actual top of Return Stack
001A03r 3  CA                           dex
001A04r 3  CA                           dex
001A05r 3               
001A05r 3  68                           pla             ; LSB
001A06r 3  95 00                        sta 0,x
001A08r 3  68                           pla             ; MSB
001A09r 3  95 01                        sta 1,x
001A0Br 3               
001A0Br 3                               ; now we have to put that value back
001A0Br 3  48                           pha
001A0Cr 3  B5 00                        lda 0,x
001A0Er 3  48                           pha
001A0Fr 3               
001A0Fr 3                               ; --- CUT FOR NATIVE COMPILE ---
001A0Fr 3               
001A0Fr 3                               ; restore return value
001A0Fr 3  5A                           phy             ; MSB
001A10r 3  A4 24                        ldy tmp1
001A12r 3  5A                           phy             ; LSB
001A13r 3               
001A13r 3  60           z_r_fetch:      rts
001A14r 3               
001A14r 3               
001A14r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
001A14r 3               ; ## "r>"  auto  ANS core
001A14r 3                       ; """https://forth-standard.org/standard/core/Rfrom
001A14r 3                       ; Move Top of Return Stack to Top of Data Stack.
001A14r 3                       ;
001A14r 3                       ; We have to move
001A14r 3                       ; the RTS address out of the way first. This word is handled
001A14r 3                       ; differently for native and and subroutine compilation, see COMPILE,
001A14r 3                       ; This is a compile-only word
001A14r 3                       ; """
001A14r 3               
001A14r 3               xt_r_from:
001A14r 3                               ; Rescue the address of the return jump that is currently
001A14r 3                               ; on top of the Return Stack. If this word is natively
001A14r 3                               ; compiled, this is a total waste of time
001A14r 3  68                           pla             ; LSB
001A15r 3  85 2C                        sta tmptos
001A17r 3  7A                           ply             ; MSB
001A18r 3               
001A18r 3                               ; --- CUT FOR NATIVE CODING ---
001A18r 3               
001A18r 3  CA                           dex
001A19r 3  CA                           dex
001A1Ar 3               
001A1Ar 3                               ; now we can access the actual data
001A1Ar 3               
001A1Ar 3  68                           pla             ; LSB
001A1Br 3  95 00                        sta 0,x
001A1Dr 3  68                           pla             ; MSB
001A1Er 3  95 01                        sta 1,x
001A20r 3               
001A20r 3                               ; --- CUT FOR NATIVE CODING ---
001A20r 3               
001A20r 3                               ; restore the return address
001A20r 3  5A                           phy             ; MSB
001A21r 3  A5 2C                        lda tmptos
001A23r 3  48                           pha             ; LSB
001A24r 3               
001A24r 3  60           z_r_from:       rts
001A25r 3               
001A25r 3               
001A25r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
001A25r 3               ; ## "r>input"  tested  Tali Forth
001A25r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
001A25r 3                       ; and toin from the Return Stack.
001A25r 3                       ;
001A25r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
001A25r 3                       ; """
001A25r 3               
001A25r 3               xt_r_to_input:
001A25r 3               
001A25r 3                               ; We arrive here with the return address on the top of the
001A25r 3                               ; 65c02's stack. We need to move it out of the way first
001A25r 3  68                           pla
001A26r 3  85 24                        sta tmp1
001A28r 3  68                           pla
001A29r 3  85 25                        sta tmp1+1
001A2Br 3               
001A2Br 3                               ; This assumes that insrc is the first of eight bytes and
001A2Br 3                               ; toin+1 the last in the sequence we want to save from the Zero
001A2Br 3                               ; Page. Since we went in reverse order, insrc is now on the top
001A2Br 3                               ; of the Return Stack.
001A2Br 3  A0 00                        ldy #0
001A2Dr 3               @loop:
001A2Dr 3  68                           pla
001A2Er 3  99 06 00                     sta insrc,y
001A31r 3  C8                           iny
001A32r 3  C0 08                        cpy #8
001A34r 3  D0 F7                        bne @loop
001A36r 3               
001A36r 3                               ; Restore address for return jump
001A36r 3  A5 25                        lda tmp1+1
001A38r 3  48                           pha
001A39r 3  A5 24                        lda tmp1
001A3Br 3  48                           pha
001A3Cr 3               
001A3Cr 3  60           z_r_to_input: 	rts
001A3Dr 3               
001A3Dr 3               
001A3Dr 3               
001A3Dr 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
001A3Dr 3               ; ## "recurse"  auto  ANS core
001A3Dr 3                       ; """https://forth-standard.org/standard/core/RECURSE
001A3Dr 3                       ;
001A3Dr 3                       ; This word may not be natively compiled
001A3Dr 3                       ; """
001A3Dr 3               
001A3Dr 3               xt_recurse:
001A3Dr 3                               ; The whole routine amounts to compiling a reference to
001A3Dr 3                               ; the word that is being compiled. First, we save the JSR
001A3Dr 3                               ; instruction
001A3Dr 3  A0 00                        ldy #0
001A3Fr 3               
001A3Fr 3  A9 20                        lda #$20        ; opcode for JSR
001A41r 3  91 00                        sta (cp),y
001A43r 3  C8                           iny
001A44r 3               
001A44r 3                               ; Next, we save the LSB and MSB of the xt of the word
001A44r 3                               ; we are currently working on. We first need to see if
001A44r 3                               ; WORKWORD has the nt (: started the word) or the
001A44r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
001A44r 3  24 20                        bit status
001A46r 3  70 0C                        bvs @nt_in_workword
001A48r 3               
001A48r 3                               ; This is a special :NONAME word. Just copy the xt
001A48r 3                               ; from WORKWORD into the dictionary.
001A48r 3  A5 04                        lda workword
001A4Ar 3  91 00                        sta (cp),y
001A4Cr 3  C8                           iny
001A4Dr 3  A5 05                        lda workword+1
001A4Fr 3  91 00                        sta (cp),y
001A51r 3  C8                           iny
001A52r 3  80 1B                        bra @update_cp
001A54r 3               
001A54r 3               @nt_in_workword:
001A54r 3                               ; This is a regular : word, so the xt is four bytes down
001A54r 3                               ; from the nt which we saved in WORKWORD. We could probably
001A54r 3                               ; use NAME>INT here but this is going to be faster, and
001A54r 3                               ; fast counts with recursion
001A54r 3  A5 04                        lda workword            ; LSB
001A56r 3  18                           clc
001A57r 3  69 04                        adc #4
001A59r 3  85 24                        sta tmp1
001A5Br 3  A5 05                        lda workword+1          ; MSB
001A5Dr 3  69 00                        adc #0
001A5Fr 3  85 25                        sta tmp1+1
001A61r 3               
001A61r 3  B2 24                        lda (tmp1)
001A63r 3  91 00                        sta (cp),y
001A65r 3  5A                           phy
001A66r 3  A0 01                        ldy #1
001A68r 3  B1 24                        lda (tmp1),y
001A6Ar 3  7A                           ply
001A6Br 3  C8                           iny
001A6Cr 3  91 00                        sta (cp),y
001A6Er 3  C8                           iny
001A6Fr 3               
001A6Fr 3               @update_cp:
001A6Fr 3  98                           tya
001A70r 3  18                           clc
001A71r 3  65 00                        adc cp
001A73r 3  85 00                        sta cp
001A75r 3  90 02                        bcc @done
001A77r 3  E6 01                        inc cp+1
001A79r 3               @done:
001A79r 3  60           z_recurse:      rts
001A7Ar 3               
001A7Ar 3               
001A7Ar 3               
001A7Ar 3               ; ## REFILL ( -- f ) "Refill the input buffer"
001A7Ar 3               ; ## "refill"  tested  ANS core ext
001A7Ar 3                       ; """https://forth-standard.org/standard/core/REFILL
001A7Ar 3                       ; Attempt to fill the input buffer from the input source, returning
001A7Ar 3                       ; a true flag if successful. When the input source is the user input
001A7Ar 3                       ; device, attempt to receive input into the terminal input buffer. If
001A7Ar 3                       ; successful, make the result the input buffer, set >IN to zero, and
001A7Ar 3                       ; return true. Receipt of a line containing no characters is considered
001A7Ar 3                       ; successful. If there is no input available from the current input
001A7Ar 3                       ; source, return false. When the input source is a string from EVALUATE,
001A7Ar 3                       ; return false and perform no other action." See
001A7Ar 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
001A7Ar 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
001A7Ar 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
001A7Ar 3                       ; entire block as a 1024 byte string.
001A7Ar 3                       ; """"
001A7Ar 3               
001A7Ar 3               xt_refill:
001A7Ar 3                               ; Get input source from SOURCE-ID. This is an
001A7Ar 3                               ; optimized version of a subroutine jump to SOURCE-ID
001A7Ar 3  A5 06                        lda insrc               ; cheat: We only check LSB
001A7Cr 3  D0 2D                        bne @src_not_kbd
001A7Er 3               
001A7Er 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
001A7Er 3                               ; with ACCEPT, which wants the address of the current input
001A7Er 3                               ; buffer NOS and the max number of characters to accept TOS
001A7Er 3  CA                           dex
001A7Fr 3  CA                           dex
001A80r 3  CA                           dex
001A81r 3  CA                           dex
001A82r 3               
001A82r 3  A5 08                        lda cib                 ; address of CIB is NOS
001A84r 3  95 02                        sta 2,x
001A86r 3  A5 09                        lda cib+1
001A88r 3  95 03                        sta 3,x
001A8Ar 3               
001A8Ar 3  64 0A                        stz ciblen              ; go in with empty buffer
001A8Cr 3  64 0B                        stz ciblen+1
001A8Er 3               
001A8Er 3  A9 FF                        lda #bsize              ; max number of chars is TOS
001A90r 3  95 00                        sta 0,x
001A92r 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
001A94r 3               
001A94r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
001A97r 3               
001A97r 3                               ; ACCEPT returns the number of characters accepted, which
001A97r 3                               ; belong in CIBLEN
001A97r 3  B5 00                        lda 0,x
001A99r 3  85 0A                        sta ciblen
001A9Br 3  B5 01                        lda 1,x
001A9Dr 3  85 0B                        sta ciblen+1            ; though we only accept 255 chars
001A9Fr 3               
001A9Fr 3                               ; make >IN point to beginning of buffer
001A9Fr 3  64 0C                        stz toin
001AA1r 3  64 0D                        stz toin+1
001AA3r 3               
001AA3r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
001AA5r 3  95 00                        sta 0,x
001AA7r 3  95 01                        sta 1,x
001AA9r 3               
001AA9r 3  80 10                        bra @done
001AABr 3               
001AABr 3               @src_not_kbd:
001AABr 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
001AABr 3                               ; memory or a file (remember, no blocks in this version).
001AABr 3                               ; If source is a string, we were given the flag -1 ($FFFF)
001AABr 3  1A                           inc
001AACr 3  D0 08                        bne @src_not_string
001AAEr 3               
001AAEr 3                               ; Simply return FALSE flag as per specification
001AAEr 3  CA                           dex
001AAFr 3  CA                           dex
001AB0r 3  74 00                        stz 0,x
001AB2r 3  74 01                        stz 1,x
001AB4r 3               
001AB4r 3  80 05                        bra z_refill
001AB6r 3               
001AB6r 3               @src_not_string:
001AB6r 3                               ; Since we don't have blocks, this must mean that we are trying
001AB6r 3                               ; to read from a file. However, we don't have files yet, so we
001AB6r 3                               ; report an error and jump to ABORT.
001AB6r 3  A9 01                        lda #err_badsource
001AB8r 3  4C rr rr                     jmp error
001ABBr 3               @done:
001ABBr 3  60           z_refill:       rts
001ABCr 3               
001ABCr 3               
001ABCr 3               
001ABCr 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
001ABCr 3               ; ## "repeat"  auto  ANS core
001ABCr 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
001ABCr 3               
001ABCr 3               xt_repeat:
001ABCr 3                               ; Run again first
001ABCr 3  20 rr rr                     jsr xt_again
001ABFr 3               
001ABFr 3                               ; Stuff HERE in for the branch address
001ABFr 3                               ; to get out of the loop
001ABFr 3  20 rr rr                     jsr xt_here
001AC2r 3  20 rr rr                     jsr xt_swap
001AC5r 3  20 rr rr                     jsr xt_store
001AC8r 3               
001AC8r 3  60           z_repeat:       rts
001AC9r 3               
001AC9r 3               
001AC9r 3               
001AC9r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
001AC9r 3               ; ## "]"  auto  ANS core
001AC9r 3                       ; """https://forth-standard.org/standard/right-bracket
001AC9r 3                       ; This is an immediate word.
001AC9r 3                       ; """
001AC9r 3               xt_right_bracket:
001AC9r 3  A9 FF                        lda #$FF
001ACBr 3  85 16                        sta state
001ACDr 3  85 17                        sta state+1
001ACFr 3               z_right_bracket:
001ACFr 3  60                           rts
001AD0r 3               
001AD0r 3               
001AD0r 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
001AD0r 3               ; ## "root-wordlist"  tested  Tali Editor
001AD0r 3               xt_root_wordlist:
001AD0r 3  CA                           dex             ; The WID for the Root wordlist is 3.
001AD1r 3  CA                           dex
001AD2r 3  A9 03                        lda #3
001AD4r 3  95 00                        sta 0,x
001AD6r 3  74 01                        stz 1,x
001AD8r 3               
001AD8r 3               z_root_wordlist:
001AD8r 3  60                           rts
001AD9r 3               
001AD9r 3               
001AD9r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
001AD9r 3               ; ## "rot"  auto  ANS core
001AD9r 3                       ; """https://forth-standard.org/standard/core/ROT
001AD9r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
001AD9r 3                       ; on top!
001AD9r 3                       ; """
001AD9r 3               
001AD9r 3               xt_rot:
001AD9r 3  20 rr rr                     jsr underflow_3
001ADCr 3               
001ADCr 3  B4 05                        ldy 5,x         ; MSB first
001ADEr 3  B5 03                        lda 3,x
001AE0r 3  95 05                        sta 5,x
001AE2r 3  B5 01                        lda 1,x
001AE4r 3  95 03                        sta 3,x
001AE6r 3  94 01                        sty 1,x
001AE8r 3               
001AE8r 3  B4 04                        ldy 4,x         ; LSB next
001AEAr 3  B5 02                        lda 2,x
001AECr 3  95 04                        sta 4,x
001AEEr 3  B5 00                        lda 0,x
001AF0r 3  95 02                        sta 2,x
001AF2r 3  94 00                        sty 0,x
001AF4r 3               
001AF4r 3  60           z_rot:          rts
001AF5r 3               
001AF5r 3               
001AF5r 3               
001AF5r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
001AF5r 3               ; ## "rshift"  auto  ANS core
001AF5r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
001AF5r 3               xt_rshift:
001AF5r 3  20 rr rr                     jsr underflow_2
001AF8r 3               
001AF8r 3                               ; We shift maximal by 16 bits, mask everything else
001AF8r 3  B5 00                        lda 0,x
001AFAr 3  29 0F                        and #%00001111
001AFCr 3  F0 08                        beq @done               ; if 0 shifts, quit
001AFEr 3               
001AFEr 3  A8                           tay
001AFFr 3               @loop:
001AFFr 3  56 03                        lsr 3,x
001B01r 3  76 02                        ror 2,x
001B03r 3  88                           dey
001B04r 3  D0 F9                        bne @loop
001B06r 3               @done:
001B06r 3  E8                           inx
001B07r 3  E8                           inx
001B08r 3               
001B08r 3  60           z_rshift:       rts
001B09r 3               
001B09r 3               
001B09r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
001B09r 3               ; ## "s\""  auto  ANS core
001B09r 3                       ; """https://forth-standard.org/standard/core/Seq
001B09r 3                       ; Store address and length of string given, returning ( addr u ).
001B09r 3                       ; ANS core claims this is compile-only, but the file set expands it
001B09r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
001B09r 3                       ; are evil. We follow general usage. This is just like S" except
001B09r 3                       ; that it allows for some special escaped characters.
001B09r 3                       ; """
001B09r 3               
001B09r 3               xt_s_backslash_quote:
001B09r 3                               ; tmp2 will be used to determine if we are handling
001B09r 3                               ; escaped characters or not. In this case, we are,
001B09r 3                               ; so set it to $FF (the upper byte will be used to
001B09r 3                               ; determine if we just had a \ and the next character
001B09r 3                               ; needs to be modifed as an escaped character).
001B09r 3  A9 FF                        lda #$FF
001B0Br 3  85 26                        sta tmp2
001B0Dr 3  64 27                        stz tmp2+1
001B0Fr 3               
001B0Fr 3                               ; Now that the flag is set, jump into s_quote to process
001B0Fr 3                               ; the string.
001B0Fr 3  20 rr rr                     jsr s_quote_start
001B12r 3               @done:
001B12r 3               z_s_backslash_quote:
001B12r 3  60                           rts
001B13r 3               
001B13r 3               
001B13r 3               ; This is a helper function for s_backslash_quote to convert a character
001B13r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
001B13r 3               convert_hex_value:
001B13r 3               
001B13r 3  C9 41                cmp #'A'
001B15r 3  90 07                bcc @digit
001B17r 3               
001B17r 3                       ; It's A-F
001B17r 3  29 DF                and #$DF                ; Make it uppercase.
001B19r 3  38                   sec
001B1Ar 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
001B1Cr 3  80 03                bra @done
001B1Er 3               
001B1Er 3               @digit:
001B1Er 3                       ; It's 0-9
001B1Er 3  38                   sec
001B1Fr 3  E9 30                sbc #'0'
001B21r 3               
001B21r 3               @done:
001B21r 3  60                   rts
001B22r 3               
001B22r 3               
001B22r 3               
001B22r 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
001B22r 3               ; ## "search-wordlist" auto ANS search
001B22r 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
001B22r 3               
001B22r 3               xt_search_wordlist:
001B22r 3  20 rr rr                     jsr underflow_3
001B25r 3               
001B25r 3                               ; Set up tmp1 with the wordlist indicated by wid
001B25r 3                               ; on the stack. Start by putting the base address
001B25r 3                               ; of the wordlists in tmp2.
001B25r 3  A5 1E                        lda up
001B27r 3  18                           clc
001B28r 3  69 06                        adc #wordlists_offset
001B2Ar 3  85 26                        sta tmp2
001B2Cr 3  A5 1F                        lda up+1
001B2Er 3  69 00                        adc #0          ; Adding carry
001B30r 3  85 27                        sta tmp2+1
001B32r 3               
001B32r 3                               ; Add the wid (in cells) to the base address.
001B32r 3  B5 00                        lda 0,x
001B34r 3  0A                           asl             ; Convert wid to offset in cells (x2)
001B35r 3  65 26                        adc tmp2
001B37r 3  85 26                        sta tmp2
001B39r 3  90 02                        bcc @1
001B3Br 3  E6 27                        inc tmp2+1      ; Propagate carry if needed.
001B3Dr 3               
001B3Dr 3                               ; tmp2 now holds the address of the dictionary pointer
001B3Dr 3                               ; for the given wordlist.
001B3Dr 3               @1:
001B3Dr 3                               ; Remove the wid from the stack.
001B3Dr 3  E8                           inx
001B3Er 3  E8                           inx
001B3Fr 3               
001B3Fr 3                               ; check for special case of an empty string (length zero)
001B3Fr 3  B5 00                        lda 0,x
001B41r 3  15 01                        ora 1,x
001B43r 3  D0 03                        bne @check_wordlist
001B45r 3  4C rr rr                     jmp @done
001B48r 3               
001B48r 3               @check_wordlist:
001B48r 3                               ; Check for special case of empty wordlist
001B48r 3                               ; (dictionary pointer, in tmp2, is 0)
001B48r 3  A5 26                        lda tmp2
001B4Ar 3  05 27                        ora tmp2+1
001B4Cr 3  D0 03                        bne @have_string
001B4Er 3  4C rr rr                     jmp @done
001B51r 3               
001B51r 3               @have_string:
001B51r 3                               ; set up first loop iteration
001B51r 3  B2 26                        lda (tmp2)              ; nt of first word in Dictionary
001B53r 3  85 24                        sta tmp1
001B55r 3               
001B55r 3  E6 26                        inc tmp2                ; Move to the upper byte
001B57r 3  D0 02                        bne @2
001B59r 3  E6 27                        inc tmp2+1
001B5Br 3               @2:
001B5Br 3  B2 26                        lda (tmp2)
001B5Dr 3  85 25                        sta tmp1+1
001B5Fr 3               
001B5Fr 3                               ; Reuse tmp2 to hold the address of the mystery string.
001B5Fr 3  B5 02                        lda 2,x                 ; Address of mystery string
001B61r 3  85 26                        sta tmp2
001B63r 3  B5 03                        lda 3,x
001B65r 3  85 27                        sta tmp2+1
001B67r 3               
001B67r 3               @loop:
001B67r 3                               ; first quick test: Are strings the same length?
001B67r 3  B2 24                        lda (tmp1)
001B69r 3  D5 00                        cmp 0,x
001B6Br 3  D0 7B                        bne @next_entry
001B6Dr 3               
001B6Dr 3               @compare_string:
001B6Dr 3                               ; are the same length, so we now have to compare each
001B6Dr 3                               ; character
001B6Dr 3               
001B6Dr 3                               ; second quick test: Is the first character the same?
001B6Dr 3  B2 26                        lda (tmp2)      ; first character of mystery string
001B6Fr 3               
001B6Fr 3                               ; Lowercase the incoming charcter.
001B6Fr 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001B71r 3  B0 07                        bcs @compare_first
001B73r 3  C9 41                        cmp #$41        ; ASCII 'A'
001B75r 3  90 03                        bcc @compare_first
001B77r 3               
001B77r 3                               ; An uppercase letter has been located.  Make it
001B77r 3                               ; lowercase.
001B77r 3  18                           clc
001B78r 3  69 20                        adc #$20
001B7Ar 3               
001B7Ar 3               @compare_first:
001B7Ar 3  A0 08                        ldy #8          ; Offset in nt to name
001B7Cr 3  D1 24                        cmp (tmp1),y    ; first character of current word
001B7Er 3  D0 68                        bne @next_entry
001B80r 3               
001B80r 3                               ; string length are the same and the first character is the
001B80r 3                               ; same. If the length of the string is 1, we're already done
001B80r 3  B5 00                        lda 0,x
001B82r 3  3A                           dec
001B83r 3  F0 2C                        beq @success
001B85r 3               
001B85r 3                               ; No such luck: The strings are the same length and the first
001B85r 3                               ; char is the same, but the word is more than one char long.
001B85r 3                               ; So we suck it up and compare every single character. We go
001B85r 3                               ; from back to front, because words like CELLS and CELL+ would
001B85r 3                               ; take longer otherwise. We can also shorten the loop by one
001B85r 3                               ; because we've already compared the first char.
001B85r 3               
001B85r 3                               ; The string of the word we're testing against is 8 bytes down
001B85r 3  A5 24                        lda tmp1
001B87r 3  48                           pha             ; Preserve tmp1 on the return stack.
001B88r 3  18                           clc
001B89r 3  69 08                        adc #8
001B8Br 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001B8Dr 3  A5 25                        lda tmp1+1
001B8Fr 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001B90r 3  69 00                        adc #0          ; we only need the carry
001B92r 3  85 25                        sta tmp1+1
001B94r 3               
001B94r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001B96r 3  88                           dey
001B97r 3               
001B97r 3               @string_loop:
001B97r 3  B1 26                        lda (tmp2),y    ; last char of mystery string
001B99r 3               
001B99r 3                               ; Lowercase the incoming charcter.
001B99r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001B9Br 3  B0 07                        bcs @check_char
001B9Dr 3  C9 41                        cmp #$41        ; ASCII 'A'
001B9Fr 3  90 03                        bcc @check_char
001BA1r 3               
001BA1r 3                               ; An uppercase letter has been located.  Make it
001BA1r 3                               ; lowercase.
001BA1r 3  18                           clc
001BA2r 3  69 20                        adc #$20
001BA4r 3               @check_char:
001BA4r 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
001BA6r 3  D0 3A                        bne @next_entry_tmp1
001BA8r 3               
001BA8r 3  88                           dey
001BA9r 3  D0 EC                        bne @string_loop
001BABr 3               
001BABr 3               @success_tmp1:
001BABr 3  68                           pla             ; Restore tmp1 from the return stack.
001BACr 3  85 25                        sta tmp1+1
001BAEr 3  68                           pla
001BAFr 3  85 24                        sta tmp1
001BB1r 3               
001BB1r 3               @success:
001BB1r 3                               ; The strings match. Drop the count and put correct nt TOS
001BB1r 3  E8                           inx
001BB2r 3  E8                           inx
001BB3r 3  A5 24                        lda tmp1
001BB5r 3  95 00                        sta 0,x
001BB7r 3  A5 25                        lda tmp1+1
001BB9r 3  95 01                        sta 1,x
001BBBr 3               
001BBBr 3                               ; Change the nt into an xt, but save a copy of the nt
001BBBr 3                               ; to look up whether the word is immediate or not.
001BBBr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001BBEr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001BC1r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001BC4r 3               
001BC4r 3  A0 00                        ldy #0                  ; Prepare flag
001BC6r 3               
001BC6r 3                               ; The flags are in the second byte of the header
001BC6r 3  F6 00                        inc 0,x
001BC8r 3  D0 02                        bne @3
001BCAr 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
001BCCr 3               @3:
001BCCr 3  A1 00                        lda (0,x)               ; ( xt char )
001BCEr 3  29 04                        and #IM
001BD0r 3  D0 08                        bne @immediate          ; bit set, we're immediate
001BD2r 3               
001BD2r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001BD4r 3  95 00                        sta 0,x
001BD6r 3  95 01                        sta 1,x
001BD8r 3  80 28                        bra @done_nodrop
001BDAr 3               
001BDAr 3               @immediate:
001BDAr 3  A9 01                        lda #1                  ; We're immediate, return 1
001BDCr 3  95 00                        sta 0,x
001BDEr 3  74 01                        stz 1,x
001BE0r 3               
001BE0r 3  80 20                        bra @done_nodrop
001BE2r 3               
001BE2r 3               @next_entry_tmp1:
001BE2r 3  68                           pla             ; Restore tmp1 from the return stack.
001BE3r 3  85 25                        sta tmp1+1
001BE5r 3  68                           pla
001BE6r 3  85 24                        sta tmp1
001BE8r 3               @next_entry:
001BE8r 3                               ; Not the same, so we get the next word. Next header
001BE8r 3                               ; address is two bytes down
001BE8r 3  A0 02                        ldy #2
001BEAr 3  B1 24                        lda (tmp1),y
001BECr 3  48                           pha
001BEDr 3  C8                           iny
001BEEr 3  B1 24                        lda (tmp1),y
001BF0r 3  85 25                        sta tmp1+1
001BF2r 3  68                           pla
001BF3r 3  85 24                        sta tmp1
001BF5r 3               
001BF5r 3                               ; If we got a zero, we've walked the whole Dictionary and
001BF5r 3                               ; return as a failure, otherwise try again
001BF5r 3  05 25                        ora tmp1+1
001BF7r 3  F0 03                        beq @fail_done
001BF9r 3  4C rr rr                     jmp @loop
001BFCr 3               
001BFCr 3               @fail_done:
001BFCr 3  74 02                        stz 2,x         ; failure flag
001BFEr 3  74 03                        stz 3,x
001C00r 3               @done:
001C00r 3  E8                           inx
001C01r 3  E8                           inx
001C02r 3               @done_nodrop:
001C02r 3               z_search_wordlist:
001C02r 3  60                           rts
001C03r 3               
001C03r 3               
001C03r 3               
001C03r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
001C03r 3               ; ## "see" tested  ANS tools
001C03r 3                       ; """https://forth-standard.org/standard/tools/SEE
001C03r 3                       ; SEE takes the name of a word and prints its name token (nt),
001C03r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
001C03r 3                       ; code and disassembles it.
001C03r 3                       ; """
001C03r 3               
001C03r 3               xt_see:
001C03r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
001C06r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
001C09r 3               
001C09r 3                               ; If we got back a zero we don't know that word and so we quit
001C09r 3                               ; with an error
001C09r 3  B5 00                        lda 0,x
001C0Br 3  15 01                        ora 1,x
001C0Dr 3  D0 05                        bne @1
001C0Fr 3               
001C0Fr 3  A9 05                        lda #err_noname
001C11r 3  4C rr rr                     jmp error
001C14r 3               @1:
001C14r 3  20 rr rr                     jsr xt_cr
001C17r 3               
001C17r 3                               ; We have a legal word, so let's get serious. Save the current
001C17r 3                               ; number base and use hexadecimal instead.
001C17r 3  A5 18                        lda base
001C19r 3  48                           pha
001C1Ar 3  20 rr rr                     jsr xt_hex
001C1Dr 3               
001C1Dr 3  A9 0A                        lda #str_see_nt
001C1Fr 3  20 rr rr                     jsr print_string_no_lf
001C22r 3               
001C22r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001C25r 3  20 rr rr                     jsr xt_u_dot
001C28r 3  20 rr rr                     jsr xt_space            ; ( nt )
001C2Br 3               
001C2Br 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001C2Er 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001C31r 3               
001C31r 3  A9 0B                        lda #str_see_xt
001C33r 3  20 rr rr                     jsr print_string_no_lf
001C36r 3               
001C36r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
001C39r 3  20 rr rr                     jsr xt_u_dot
001C3Cr 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
001C3Fr 3               
001C3Fr 3                               ; We print letters for flags and then later follow it with 1 or
001C3Fr 3                               ; 0 to mark if which flag is set
001C3Fr 3  A9 09                        lda #str_see_flags
001C41r 3  20 rr rr                     jsr print_string_no_lf
001C44r 3               
001C44r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
001C47r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
001C4Ar 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
001C4Dr 3               
001C4Dr 3  B5 00                        lda 0,x
001C4Fr 3               
001C4Fr 3                               ; This is crude, but for the moment it is good enough
001C4Fr 3  A0 06                        ldy #6                  ; Not all bits are used
001C51r 3               @flag_loop:
001C51r 3  48                           pha
001C52r 3  29 01                        and #%00000001
001C54r 3  18                           clc
001C55r 3  69 30                        adc #$30                ; ASCII "0"
001C57r 3  20 rr rr                     jsr emit_a
001C5Ar 3  20 rr rr                     jsr xt_space
001C5Dr 3               
001C5Dr 3  68                           pla
001C5Er 3  6A                           ror                     ; Next flag
001C5Fr 3               
001C5Fr 3  88                           dey
001C60r 3  D0 EF                        bne @flag_loop
001C62r 3               
001C62r 3  20 rr rr                     jsr xt_cr
001C65r 3               
001C65r 3  E8                           inx
001C66r 3  E8                           inx                     ; ( nt xt )
001C67r 3               
001C67r 3                               ; Figure out the size
001C67r 3  A9 0C                        lda #str_see_size
001C69r 3  20 rr rr                     jsr print_string_no_lf
001C6Cr 3               
001C6Cr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001C6Fr 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
001C72r 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
001C75r 3  20 rr rr                     jsr xt_decimal
001C78r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
001C7Br 3  20 rr rr                     jsr xt_hex
001C7Er 3  20 rr rr                     jsr xt_cr
001C81r 3               
001C81r 3                               ; Dump hex and disassemble
001C81r 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
001C84r 3  20 rr rr                     jsr xt_dump
001C87r 3  20 rr rr                     jsr xt_cr
001C8Ar 3  20 rr rr                     jsr xt_disasm
001C8Dr 3               
001C8Dr 3  68                           pla
001C8Er 3  85 18                        sta base
001C90r 3               
001C90r 3  60           z_see:          rts
001C91r 3               
001C91r 3               
001C91r 3               
001C91r 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
001C91r 3               ; ## "set-current" auto ANS search
001C91r 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
001C91r 3               
001C91r 3               xt_set_current:
001C91r 3  20 rr rr                     jsr underflow_1
001C94r 3               
001C94r 3                               ; Save the value from the data stack.
001C94r 3  A0 04                        ldy #current_offset
001C96r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
001C98r 3  91 1E                        sta (up),y      ; so only the LSB is used.
001C9Ar 3               
001C9Ar 3  E8                           inx
001C9Br 3  E8                           inx
001C9Cr 3               
001C9Cr 3  60           z_set_current:  rts
001C9Dr 3               
001C9Dr 3               
001C9Dr 3               
001C9Dr 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
001C9Dr 3               ; ## "set-order" auto ANS search
001C9Dr 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
001C9Dr 3               
001C9Dr 3               xt_set_order:
001C9Dr 3                               ; Test for -1 TOS
001C9Dr 3  A9 FF                        lda #$FF
001C9Fr 3  D5 01                        cmp 1,x
001CA1r 3  D0 12                        bne @start
001CA3r 3  D5 00                        cmp 0,x
001CA5r 3  D0 0E                        bne @start
001CA7r 3               
001CA7r 3                               ; There is a -1 TOS.  Replace it with the default
001CA7r 3                               ; search order, which is just the FORTH-WORDLIST.
001CA7r 3  CA                           dex             ; Make room for the count.
001CA8r 3  CA                           dex
001CA9r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
001CABr 3  A9 03                        lda #3
001CADr 3  95 02                        sta 2,x
001CAFr 3  74 01                        stz 1,x         ; Count is 1.
001CB1r 3  A9 01                        lda #1
001CB3r 3  95 00                        sta 0,x
001CB5r 3               
001CB5r 3                               ; Continue processing with ( forth-wordlist 1 -- )
001CB5r 3               @start:
001CB5r 3                               ; Set #ORDER - the number of wordlists in the search order.
001CB5r 3  A0 1E                        ldy #num_order_offset
001CB7r 3  B5 00                        lda 0,x
001CB9r 3  91 1E                        sta (up),y      ; #ORDER is a byte variable.
001CBBr 3  85 24                        sta tmp1        ; Save a copy for zero check and looping.
001CBDr 3                                               ; Only the low byte is saved in tmp1 as
001CBDr 3                                               ; only 8 wordlists are allowed.
001CBDr 3               
001CBDr 3  E8                           inx             ; Drop the count off the data stack.
001CBEr 3  E8                           inx
001CBFr 3               
001CBFr 3                               ; Check if there are zero wordlists.
001CBFr 3  A5 24                        lda tmp1
001CC1r 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
001CC3r 3               
001CC3r 3                               ; Move the wordlist ids from the data stack to the search order.
001CC3r 3  A0 1F                        ldy #search_order_offset
001CC5r 3               @loop:
001CC5r 3                               ; Move one wordlist id over into the search order.
001CC5r 3  B5 00                        lda 0,x         ; The search order is a byte array
001CC7r 3  91 1E                        sta (up),y      ; so only save the LSB
001CC9r 3  C8                           iny
001CCAr 3               
001CCAr 3                               ; Remove it from the data stack.
001CCAr 3  E8                           inx
001CCBr 3  E8                           inx
001CCCr 3               
001CCCr 3                               ; See if that was the last one to process (first in the list).
001CCCr 3  C6 24                        dec tmp1
001CCEr 3  D0 F5                        bne @loop
001CD0r 3               
001CD0r 3               @done:
001CD0r 3  60           z_set_order:    rts
001CD1r 3               
001CD1r 3               
001CD1r 3               
001CD1r 3               
001CD1r 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
001CD1r 3               ; ## "s""  auto  ANS core
001CD1r 3                       ; """https://forth-standard.org/standard/core/Sq
001CD1r 3                       ; Store address and length of string given, returning ( addr u ).
001CD1r 3                       ; ANS core claims this is compile-only, but the file set expands it
001CD1r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
001CD1r 3                       ; are evil. We follow general usage.
001CD1r 3                       ;
001CD1r 3                       ; Can also be realized as
001CD1r 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
001CD1r 3                       ; but it is used so much we want it in code.
001CD1r 3                       ; """
001CD1r 3               
001CD1r 3               xt_s_quote:
001CD1r 3                               ; tmp2 will be used to determine if we are handling
001CD1r 3                               ; escaped characters or not.  In this case, we are
001CD1r 3                               ; not, so set it to zero.
001CD1r 3  64 26                        stz tmp2
001CD3r 3  64 27                        stz tmp2+1
001CD5r 3               
001CD5r 3               s_quote_start:
001CD5r 3                               ; Make room on the data stack for the address.
001CD5r 3  CA                           dex
001CD6r 3  CA                           dex
001CD7r 3                               ; Make room on the data stack for the count.
001CD7r 3  CA                           dex
001CD8r 3  CA                           dex
001CD9r 3               
001CD9r 3                               ; Put a jmp over the string data with address to be filled
001CD9r 3                               ; in later.
001CD9r 3  A9 4C                        lda #$4C
001CDBr 3  20 rr rr                     jsr cmpl_a
001CDEr 3               
001CDEr 3                               ; Address to be filled in later, just use $4C for the moment
001CDEr 3  20 rr rr                     jsr cmpl_a
001CE1r 3  20 rr rr                     jsr cmpl_a
001CE4r 3               
001CE4r 3                               ; Save the current value of HERE on the data stack for the
001CE4r 3                               ; address of the string.
001CE4r 3  A5 00                        lda cp
001CE6r 3  95 02                        sta 2,x
001CE8r 3  A5 01                        lda cp+1
001CEAr 3  95 03                        sta 3,x
001CECr 3               
001CECr 3               @savechars_loop:
001CECr 3                               ; Start saving the string into the dictionary up to the
001CECr 3                               ; ending double quote. First, check to see if the input
001CECr 3                               ; buffer is empty.
001CECr 3  A5 0D                        lda toin+1              ; MSB
001CEEr 3  C5 0B                        cmp ciblen+1
001CF0r 3  90 2A                        bcc @input_fine         ; unsigned comparison
001CF2r 3               
001CF2r 3  A5 0C                        lda toin                ; LSB
001CF4r 3  C5 0A                        cmp ciblen
001CF6r 3  90 24                        bcc @input_fine
001CF8r 3               
001CF8r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
001CF8r 3                               ; which uses tmp2 and tmp3. Save and restore them.
001CF8r 3  A5 26                        lda tmp2
001CFAr 3  48                           pha
001CFBr 3  A5 27                        lda tmp2+1
001CFDr 3  48                           pha
001CFEr 3  A5 28                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
001D00r 3  48                           pha
001D01r 3               
001D01r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
001D04r 3               
001D04r 3  68                           pla
001D05r 3  85 28                        sta tmp3
001D07r 3  68                           pla
001D08r 3  85 27                        sta tmp2+1
001D0Ar 3  68                           pla
001D0Br 3  85 26                        sta tmp2
001D0Dr 3               
001D0Dr 3                               ; Check result of refill.
001D0Dr 3  B5 00                        lda 0,x
001D0Fr 3  15 01                        ora 1,x
001D11r 3  D0 05                        bne @refill_ok
001D13r 3               
001D13r 3                               ; Something when wrong with refill.
001D13r 3  A9 06                        lda #err_refill
001D15r 3  4C rr rr                     jmp error
001D18r 3               
001D18r 3               @refill_ok:
001D18r 3                               ; Remove the refill flag from the data stack.
001D18r 3  E8                           inx
001D19r 3  E8                           inx
001D1Ar 3               
001D1Ar 3                               ; For refill success, jump back up to the empty check, just in
001D1Ar 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
001D1Ar 3                               ; input)
001D1Ar 3  80 D0                        bra @savechars_loop
001D1Cr 3               
001D1Cr 3               @input_fine:
001D1Cr 3                               ; There should be at least one valid char to use.
001D1Cr 3                               ; Calculate it's address at CIB+TOIN into tmp1
001D1Cr 3  A5 08                        lda cib
001D1Er 3  18                           clc
001D1Fr 3  65 0C                        adc toin        ; LSB
001D21r 3  85 24                        sta tmp1
001D23r 3  A5 09                        lda cib+1
001D25r 3  65 0D                        adc toin+1      ; MSB
001D27r 3  85 25                        sta tmp1+1
001D29r 3               
001D29r 3                               ; Get the character
001D29r 3  B2 24                        lda (tmp1)
001D2Br 3               
001D2Br 3                               ; Check to see if we are handling escaped characters.
001D2Br 3  24 26                        bit tmp2
001D2Dr 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
001D2Fr 3  4C rr rr                     jmp @regular_char
001D32r 3               
001D32r 3               @handle_escapes:
001D32r 3                               ; We are handling escaped characters.  See if we have
001D32r 3                               ; already seen the backslash.
001D32r 3  24 27                        bit tmp2+1
001D34r 3  30 03                        bmi @escaped
001D36r 3  4C rr rr                     jmp @not_escaped
001D39r 3               
001D39r 3               @escaped:
001D39r 3               
001D39r 3                               ; We have seen a backslash (previous character). Check to see if
001D39r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
001D39r 3                               ; be clear in that case )
001D39r 3  70 22                        bvs @check_esc_chars
001D3Br 3               
001D3Br 3                               ; We are in the middle of a \x sequence. Check to see if we
001D3Br 3                               ; are on the first or second digit.
001D3Br 3  A9 01                        lda #1
001D3Dr 3  24 27                        bit tmp2+1
001D3Fr 3  D0 10                        bne @esc_x_second_digit
001D41r 3               
001D41r 3                               ; First digit.
001D41r 3  E6 27                        inc tmp2+1  ; Adjust flag for second digit next time.
001D43r 3  B2 24                        lda (tmp1)  ; Get the char again.
001D45r 3               
001D45r 3                               ; Convert to hex
001D45r 3  20 rr rr                     jsr convert_hex_value
001D48r 3               
001D48r 3                               ; This is the upper nybble, so move it up.
001D48r 3  0A                           asl
001D49r 3  0A                           asl
001D4Ar 3  0A                           asl
001D4Br 3  0A                           asl
001D4Cr 3  85 28                        sta tmp3    ; Save it for later.
001D4Er 3  4C rr rr                     jmp @next_character
001D51r 3               
001D51r 3               @esc_x_second_digit:
001D51r 3               
001D51r 3                               ; We are on the second hex digit of a \x sequence. Clear the
001D51r 3                               ; escaped character flag (because we are handling it right
001D51r 3                               ; here)
001D51r 3  64 27                        stz tmp2+1
001D53r 3  B2 24                        lda (tmp1)
001D55r 3               
001D55r 3                               ; Convert to hex, combine with value in tmp3
001D55r 3  20 rr rr                     jsr convert_hex_value
001D58r 3  05 28                        ora tmp3
001D5Ar 3               
001D5Ar 3  4C rr rr                     jmp @save_character
001D5Dr 3               
001D5Dr 3               @check_esc_chars:
001D5Dr 3                               ; Clear the escaped character flag (because we are
001D5Dr 3                               ; handling it right here)
001D5Dr 3  64 27                        stz tmp2+1
001D5Fr 3               
001D5Fr 3                               ; Process the escaped character
001D5Fr 3               @check_esc_a:
001D5Fr 3  C9 61                        cmp #'a'
001D61r 3  D0 05                        bne @check_esc_b
001D63r 3               
001D63r 3                               ; BEL (ASCII value 7)
001D63r 3  A9 07                        lda #7
001D65r 3  4C rr rr                     jmp @save_character
001D68r 3               
001D68r 3               @check_esc_b:
001D68r 3  C9 62                        cmp #'b'
001D6Ar 3  D0 05                        bne @check_esc_e
001D6Cr 3               
001D6Cr 3                               ; Backspace (ASCII value 8)
001D6Cr 3  A9 08                        lda #8
001D6Er 3  4C rr rr                     jmp @save_character
001D71r 3               
001D71r 3               @check_esc_e:
001D71r 3  C9 65                        cmp #'e'
001D73r 3  D0 04                        bne @check_esc_f
001D75r 3               
001D75r 3                               ; ESC (ASCII value 27)
001D75r 3  A9 1B                        lda #27
001D77r 3  80 75                        bra @save_character
001D79r 3               
001D79r 3               @check_esc_f:
001D79r 3  C9 66                        cmp #'f'
001D7Br 3  D0 04                        bne @check_esc_l
001D7Dr 3               
001D7Dr 3                               ; FF (ASCII value 12)
001D7Dr 3  A9 0C                        lda #12
001D7Fr 3  80 6D                        bra @save_character
001D81r 3               
001D81r 3               @check_esc_l:
001D81r 3  C9 6C                        cmp #'l'
001D83r 3  D0 04                        bne @check_esc_m
001D85r 3               
001D85r 3                               ; LF (ASCII value 10)
001D85r 3  A9 0A                        lda #10
001D87r 3  80 65                        bra @save_character
001D89r 3               
001D89r 3               @check_esc_m:
001D89r 3                               ; This one is not like the others because we save two
001D89r 3                               ; characters
001D89r 3  C9 6D                        cmp #'m'
001D8Br 3  D0 09                        bne @check_esc_n
001D8Dr 3               
001D8Dr 3                               ; CR/LF pair (ASCII values 13, 10)
001D8Dr 3  A9 0D                        lda #13
001D8Fr 3  20 rr rr                     jsr cmpl_a
001D92r 3  A9 0A                        lda #10
001D94r 3  80 58                        bra @save_character
001D96r 3               
001D96r 3               @check_esc_n:
001D96r 3  C9 6E                        cmp #'n'
001D98r 3  D0 04                        bne @check_esc_q
001D9Ar 3               
001D9Ar 3                               ; newline, impl. dependant, using LF (ASCII values 10)
001D9Ar 3  A9 0A                        lda #10
001D9Cr 3  80 50                        bra @save_character
001D9Er 3               
001D9Er 3               @check_esc_q:
001D9Er 3  C9 71                        cmp #'q'
001DA0r 3  D0 04                        bne @check_esc_r
001DA2r 3               
001DA2r 3                               ; Double quote (ASCII value 34)
001DA2r 3  A9 22                        lda #34
001DA4r 3  80 48                        bra @save_character
001DA6r 3               
001DA6r 3               @check_esc_r:
001DA6r 3  C9 72                        cmp #'r'
001DA8r 3  D0 04                        bne @check_esc_t
001DAAr 3               
001DAAr 3                               ; CR (ASCII value 13)
001DAAr 3  A9 0D                        lda #13
001DACr 3  80 40                        bra @save_character
001DAEr 3               
001DAEr 3               @check_esc_t:
001DAEr 3  C9 74                        cmp #'t'
001DB0r 3  D0 04                        bne @check_esc_v
001DB2r 3               
001DB2r 3                               ; Horizontal TAB (ASCII value 9)
001DB2r 3  A9 09                        lda #9
001DB4r 3  80 38                        bra @save_character
001DB6r 3               
001DB6r 3               @check_esc_v:
001DB6r 3  C9 76                        cmp #'v'
001DB8r 3  D0 04                        bne @check_esc_z
001DBAr 3               
001DBAr 3                               ; Vertical TAB (ASCII value 11)
001DBAr 3  A9 0B                        lda #11
001DBCr 3  80 30                        bra @save_character
001DBEr 3               
001DBEr 3               @check_esc_z:
001DBEr 3  C9 7A                        cmp #'z'
001DC0r 3  D0 04                        bne @check_esc_quote
001DC2r 3               
001DC2r 3                               ; NULL (ASCII value 0)
001DC2r 3  A9 00                        lda #0
001DC4r 3  80 28                        bra @save_character
001DC6r 3               
001DC6r 3               @check_esc_quote:
001DC6r 3  C9 22                        cmp #$22
001DC8r 3  D0 04                        bne @check_esc_x
001DCAr 3               
001DCAr 3                               ; Double quote (ASCII value 34)
001DCAr 3  A9 22                        lda #34
001DCCr 3  80 20                        bra @save_character
001DCEr 3               
001DCEr 3               @check_esc_x:
001DCEr 3  C9 78                        cmp #'x'
001DD0r 3  D0 06                        bne @check_esc_backslash
001DD2r 3               
001DD2r 3                               ; This one is difficult. We need to get the next TWO
001DD2r 3                               ; characters (which might require a refill in the middle)
001DD2r 3                               ; and combine them as two hex digits. We do this by
001DD2r 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
001DD2r 3                               ; and using bit 0 to keep track of which digit we are on.
001DD2r 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
001DD4r 3  85 27                        sta tmp2+1
001DD6r 3  80 19                        bra @next_character
001DD8r 3               
001DD8r 3               @check_esc_backslash:
001DD8r 3  C9 5C                        cmp #$5C
001DDAr 3  D0 04                        bne @not_escaped
001DDCr 3               
001DDCr 3                               ; Backslash (ASCII value 92)
001DDCr 3  A9 5C                        lda #92
001DDEr 3  80 0E                        bra @save_character
001DE0r 3               
001DE0r 3               @not_escaped:
001DE0r 3                               ; Check for the backslash to see if we should escape
001DE0r 3                               ; the next char.
001DE0r 3  C9 5C                        cmp #$5C        ; The backslash char
001DE2r 3  D0 06                        bne @regular_char
001DE4r 3               
001DE4r 3                               ; We found a backslash.  Don't save anyhing, but set
001DE4r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
001DE4r 3                               ; try to get the next char here as it may require a
001DE4r 3                               ; refill of the input buffer.
001DE4r 3  A9 FF                        lda #$FF
001DE6r 3  85 27                        sta tmp2+1
001DE8r 3  80 07                        bra @next_character
001DEAr 3               
001DEAr 3               @regular_char:
001DEAr 3                               ; Check if the current character is the end of the string.
001DEAr 3  C9 22                        cmp #$22        ; ASCII for "
001DECr 3  F0 0C                        beq @found_string_end
001DEEr 3               
001DEEr 3               @save_character:
001DEEr 3                               ; If we didn't reach the end of the string, compile this
001DEEr 3                               ; character into the dictionary
001DEEr 3  20 rr rr                     jsr cmpl_a
001DF1r 3               
001DF1r 3               @next_character:
001DF1r 3                               ; Move on to the next character.
001DF1r 3  E6 0C                        inc toin
001DF3r 3  D0 02                        bne @savechars_loop_longjump
001DF5r 3  E6 0D                        inc toin+1
001DF7r 3               
001DF7r 3               @savechars_loop_longjump:
001DF7r 3  4C rr rr                     jmp @savechars_loop
001DFAr 3               
001DFAr 3               @found_string_end:
001DFAr 3                               ; Use up the delimiter.
001DFAr 3  E6 0C                        inc toin
001DFCr 3  D0 02                        bne @1
001DFEr 3  E6 0D                        inc toin+1
001E00r 3               @1:
001E00r 3                               ; Calculate the length of the string, which is the
001E00r 3                               ; difference between cp and the address of the start
001E00r 3                               ; of the string (currently saved on the stack).
001E00r 3  A5 00                        lda cp
001E02r 3  38                           sec
001E03r 3  F5 02                        sbc 2,x
001E05r 3  95 00                        sta 0,x         ; LSB
001E07r 3  A5 01                        lda cp+1
001E09r 3  F5 03                        sbc 3,x
001E0Br 3  95 01                        sta 1,x         ; MSB
001E0Dr 3               
001E0Dr 3                               ; Update the address of the jump-over jmp instruction.
001E0Dr 3                               ; First determine location of jmp instructions address.
001E0Dr 3                               ; It should be 2 bytes before the start of the string.
001E0Dr 3                               ; Compute it into tmp1, which is no longer being used.
001E0Dr 3  B5 02                        lda 2,x
001E0Fr 3  38                           sec
001E10r 3  E9 02                        sbc #2
001E12r 3  85 24                        sta tmp1
001E14r 3  B5 03                        lda 3,x
001E16r 3  E9 00                        sbc #0          ; Propagate borrow
001E18r 3  85 25                        sta tmp1+1
001E1Ar 3               
001E1Ar 3                               ; Update the address of the jump to HERE.
001E1Ar 3  A5 00                        lda cp
001E1Cr 3  92 24                        sta (tmp1)
001E1Er 3  A0 01                        ldy #1
001E20r 3  A5 01                        lda cp+1
001E22r 3  91 24                        sta (tmp1),y
001E24r 3               
001E24r 3                               ; What happens next depends on the state (which is bad, but
001E24r 3                               ; that's the way it works at the moment). If we are
001E24r 3                               ; interpretating, we save the string to a transient buffer
001E24r 3                               ; and return that address (used for file calls, see
001E24r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
001E24r 3                               ; compiling, we just need SLITERAL
001E24r 3  A5 16                        lda state
001E26r 3  05 17                        ora state+1             ; paranoid
001E28r 3  F0 03                        beq @done
001E2Ar 3               
001E2Ar 3                               ; Jump into the middle of the sliteral word, after the
001E2Ar 3                               ; string data has been compiled into the dictionary,
001E2Ar 3                               ; because we've already done that step.
001E2Ar 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
001E2Dr 3               
001E2Dr 3               @done:
001E2Dr 3  60           z_s_quote:      rts
001E2Er 3               
001E2Er 3               
001E2Er 3               
001E2Er 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
001E2Er 3               ; ## "s>d"  auto  ANS core
001E2Er 3                       ; """https://forth-standard.org/standard/core/StoD"""
001E2Er 3               
001E2Er 3               xt_s_to_d:
001E2Er 3  20 rr rr                     jsr underflow_1
001E31r 3               
001E31r 3  CA                           dex
001E32r 3  CA                           dex
001E33r 3  74 00                        stz 0,x
001E35r 3  74 01                        stz 1,x
001E37r 3               
001E37r 3  B5 03                        lda 3,x
001E39r 3  10 04                        bpl @done
001E3Br 3               
001E3Br 3                               ; negative, extend sign
001E3Br 3  D6 00                        dec 0,x
001E3Dr 3  D6 01                        dec 1,x
001E3Fr 3               @done:
001E3Fr 3  60           z_s_to_d:       rts
001E40r 3               
001E40r 3               
001E40r 3               
001E40r 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
001E40r 3               ; ## "save-buffers"  tested  ANS block
001E40r 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
001E40r 3               
001E40r 3               xt_save_buffers:
001E40r 3                               ; Check the buffer status
001E40r 3  A0 2C                        ldy #buffstatus_offset
001E42r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
001E44r 3  C9 03                        cmp #3          ; LSB is needed.
001E46r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
001E48r 3               
001E48r 3                               ; We need to save the block.
001E48r 3  20 rr rr                     jsr xt_blkbuffer
001E4Br 3  20 rr rr                     jsr xt_buffblocknum
001E4Er 3  20 rr rr                     jsr xt_fetch
001E51r 3  20 rr rr                     jsr xt_block_write
001E54r 3               
001E54r 3                               ; Mark the buffer as clean now.
001E54r 3  A9 01                        lda #1
001E56r 3  A0 2C                        ldy #buffstatus_offset
001E58r 3  91 1E                        sta (up),y
001E5Ar 3               
001E5Ar 3               @done:
001E5Ar 3  60           z_save_buffers: rts
001E5Br 3               
001E5Br 3               
001E5Br 3               
001E5Br 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
001E5Br 3               ; ## "scr"  auto  ANS block ext
001E5Br 3                       ; """https://forth-standard.org/standard/block/SCR"""
001E5Br 3               xt_scr:
001E5Br 3                               ; SCR is at UP + scr_offset
001E5Br 3  CA                           dex
001E5Cr 3  CA                           dex
001E5Dr 3  18                           clc
001E5Er 3  A5 1E                        lda up
001E60r 3  69 02                        adc #scr_offset ; Add offset
001E62r 3  95 00                        sta 0,x
001E64r 3  A5 1F                        lda up+1
001E66r 3  69 00                        adc #0          ; Adding carry
001E68r 3  95 01                        sta 1,x
001E6Ar 3               
001E6Ar 3  60           z_scr:          rts
001E6Br 3               
001E6Br 3               
001E6Br 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
001E6Br 3               ; ## "search"   auto  ANS string
001E6Br 3                       ; """https://forth-standard.org/standard/string/SEARCH
001E6Br 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
001E6Br 3                       ; addr1 u1). If a match is found the flag will be true and
001E6Br 3                       ; addr3 will have the address of the start of the match and u3 will have
001E6Br 3                       ; the number of characters remaining from the match point to the end
001E6Br 3                       ; of the original string1. If a match is not found, the flag will be
001E6Br 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
001E6Br 3                       ; """
001E6Br 3               
001E6Br 3               xt_search:
001E6Br 3  20 rr rr                     jsr underflow_4
001E6Er 3               
001E6Er 3                               ; ANS says if the second string is a zero-length string it
001E6Er 3                               ; automatically matches.
001E6Er 3  B5 00                        lda 0,x
001E70r 3  15 01                        ora 1,x
001E72r 3  D0 0B                        bne @start_search
001E74r 3               
001E74r 3                               ; The second string is a zero length string.  Just remove
001E74r 3                               ; the second string and put a true flag.
001E74r 3  E8                           inx             ; Remove u2
001E75r 3  E8                           inx
001E76r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
001E78r 3  95 00                        sta 0,x
001E7Ar 3  95 01                        sta 1,x
001E7Cr 3  4C rr rr                     jmp z_search
001E7Fr 3               
001E7Fr 3               @start_search:
001E7Fr 3                               ; Put an offset (starting at zero) on the stack.
001E7Fr 3  20 rr rr                     jsr xt_zero
001E82r 3               
001E82r 3               @search_loop:
001E82r 3                               ; We stop (not found) when u2 + offset > u1
001E82r 3                               ; Calculate u2+offset into tmp1
001E82r 3  18                           clc
001E83r 3  B5 00                        lda 0,x
001E85r 3  75 02                        adc 2,x
001E87r 3  85 24                        sta tmp1
001E89r 3  B5 01                        lda 1,x
001E8Br 3  75 03                        adc 3,x
001E8Dr 3               
001E8Dr 3               
001E8Dr 3                               ; Compare to u1. Start with the high byte
001E8Dr 3  D5 07                        cmp 7,x
001E8Fr 3  90 12                        bcc @init_comparison ; Obviously less
001E91r 3  D0 06                        bne @not_found
001E93r 3               
001E93r 3                               ; The upper address byte matched - check the lower byte
001E93r 3                               ; Load u1 first so we can use just a carry to check.
001E93r 3  B5 06                        lda 6,x
001E95r 3  C5 24                        cmp tmp1
001E97r 3  B0 0A                        bcs @init_comparison
001E99r 3               
001E99r 3               @not_found:
001E99r 3                               ; The substring isn't in the main string.
001E99r 3                               ; Return just the main string and a false flag.
001E99r 3  E8                           inx             ; Remove offset
001E9Ar 3  E8                           inx
001E9Br 3  E8                           inx             ; Remove u2
001E9Cr 3  E8                           inx
001E9Dr 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
001E9Fr 3  74 01                        stz 1,x
001EA1r 3  80 66                        bra z_search
001EA3r 3               
001EA3r 3               @init_comparison:
001EA3r 3                               ; Use tmp1 to hold address in string 1.
001EA3r 3                               ; Use tmp2 to hold address in string 2.
001EA3r 3                               ; Use tmp3 to hold the number of characters left to check.
001EA3r 3               
001EA3r 3                               ; Compute the starting address in string 1
001EA3r 3                               ; as addr1 + offset
001EA3r 3  18                           clc
001EA4r 3  B5 08                        lda 8,x
001EA6r 3  75 00                        adc 0,x
001EA8r 3  85 24                        sta tmp1
001EAAr 3  B5 09                        lda 9,x
001EACr 3  75 01                        adc 1,x
001EAEr 3  85 25                        sta tmp1+1
001EB0r 3               
001EB0r 3                               ; The starting address in string 2 is just addr2.
001EB0r 3  B5 04                        lda 4,x
001EB2r 3  85 26                        sta tmp2
001EB4r 3  B5 05                        lda 5,x
001EB6r 3  85 27                        sta tmp2+1
001EB8r 3               
001EB8r 3                               ; The number of characters to check is u2.
001EB8r 3  B5 02                        lda 2,x
001EBAr 3  85 28                        sta tmp3
001EBCr 3  B5 03                        lda 3,x
001EBEr 3  85 29                        sta tmp3+1
001EC0r 3               
001EC0r 3               @comparison_loop:
001EC0r 3                               ; Check to see if the current characters match.
001EC0r 3  B2 24                        lda (tmp1)
001EC2r 3  D2 26                        cmp (tmp2)
001EC4r 3  F0 05                        beq @letters_match
001EC6r 3               
001EC6r 3                               ; One of the letters didn't match.
001EC6r 3                               ; Increment the offset and try again.
001EC6r 3  20 rr rr                     jsr xt_one_plus
001EC9r 3  80 B7                        bra @search_loop
001ECBr 3               
001ECBr 3               @letters_match:
001ECBr 3                               ; The letters match.  Advance the pointers until the
001ECBr 3                               ; count reaches zero.
001ECBr 3  E6 24                        inc tmp1
001ECDr 3  D0 02                        bne @1
001ECFr 3  E6 25                        inc tmp1+1
001ED1r 3               @1:
001ED1r 3  E6 26                        inc tmp2
001ED3r 3  D0 02                        bne @2
001ED5r 3  E6 27                        inc tmp2+1
001ED7r 3               @2:
001ED7r 3                               ; Decrement the count of remaining letters to check.
001ED7r 3  A5 28                        lda tmp3
001ED9r 3  D0 02                        bne @3
001EDBr 3  C6 29                        dec tmp3+1
001EDDr 3               @3:
001EDDr 3  C6 28                        dec tmp3
001EDFr 3               
001EDFr 3                               ; Check if we've reached zero.
001EDFr 3  A5 28                        lda tmp3
001EE1r 3  05 29                        ora tmp3+1
001EE3r 3  D0 DB                        bne @comparison_loop ; Check the next letter
001EE5r 3               
001EE5r 3                               ; We've run out of letters and they all match!
001EE5r 3                               ; Return (addr1+offset) (u1-offset) true
001EE5r 3                               ; Add offset to addr1.
001EE5r 3  18                           clc
001EE6r 3  B5 00                        lda 0,x
001EE8r 3  75 08                        adc 8,x
001EEAr 3  95 08                        sta 8,x
001EECr 3  B5 01                        lda 1,x
001EEEr 3  75 09                        adc 9,x
001EF0r 3  95 09                        sta 9,x
001EF2r 3               
001EF2r 3                               ; Subtract offset from u1.
001EF2r 3  38                           sec
001EF3r 3  B5 06                        lda 6,x
001EF5r 3  F5 00                        sbc 0,x
001EF7r 3  95 06                        sta 6,x
001EF9r 3  B5 07                        lda 7,x
001EFBr 3  F5 01                        sbc 1,x
001EFDr 3  95 07                        sta 7,x
001EFFr 3               
001EFFr 3                               ; Replace addr2, u2, and offset with a true flag.
001EFFr 3  E8                           inx             ; drop offset
001F00r 3  E8                           inx
001F01r 3  E8                           inx             ; drop u2
001F02r 3  E8                           inx
001F03r 3  A9 FF                        lda #$FF
001F05r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
001F07r 3  95 01                        sta 1,x
001F09r 3               
001F09r 3  60           z_search:       rts
001F0Ar 3               
001F0Ar 3               
001F0Ar 3               
001F0Ar 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
001F0Ar 3               ; ## ";"  auto  ANS core
001F0Ar 3                       ; """https://forth-standard.org/standard/core/Semi
001F0Ar 3                       ; End the compilation of a new word into the Dictionary.
001F0Ar 3                       ;
001F0Ar 3                       ; When we
001F0Ar 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
001F0Ar 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
001F0Ar 3                       ; A Forth definition would be (see "Starting Forth"):
001F0Ar 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
001F0Ar 3                       ; practice of Gforth, we warn here if a word has been redefined.
001F0Ar 3                       ; """
001F0Ar 3               
001F0Ar 3               xt_semicolon:
001F0Ar 3                               ; Check if this is a : word or a :NONAME word.
001F0Ar 3  24 20                        bit status
001F0Cr 3  70 11                        bvs @colonword
001F0Er 3               
001F0Er 3                               ; This is a :NONAME word - just put an RTS on the end and
001F0Er 3                               ; the address (held in workword) on the stack.
001F0Er 3  A9 60                        lda #$60                ; opcode for RTS
001F10r 3  20 rr rr                     jsr cmpl_a
001F13r 3               
001F13r 3  CA                           dex
001F14r 3  CA                           dex
001F15r 3  A5 04                        lda workword
001F17r 3  95 00                        sta 0,x
001F19r 3  A5 05                        lda workword+1
001F1Br 3  95 01                        sta 1,x
001F1Dr 3  80 45                        bra @semicolon_done
001F1Fr 3               
001F1Fr 3               @colonword:
001F1Fr 3                               ; CP is the byte that will be the address we use in the
001F1Fr 3                               ; header as the end-of-compile address (z_word). This is
001F1Fr 3                               ; six bytes down from the header
001F1Fr 3  A0 06                        ldy #6
001F21r 3  A5 00                        lda cp
001F23r 3  91 04                        sta (workword),y
001F25r 3  C8                           iny
001F26r 3  A5 01                        lda cp+1
001F28r 3  91 04                        sta (workword),y
001F2Ar 3               
001F2Ar 3                               ; Allocate one further byte and save the RTS instruction
001F2Ar 3                               ; there
001F2Ar 3  A9 60                        lda #$60                ; opcode for RTS
001F2Cr 3  20 rr rr                     jsr cmpl_a
001F2Fr 3               
001F2Fr 3                               ; Before we formally add the word to the Dictionary, we
001F2Fr 3                               ; check to see if it is already present, and if yes, we
001F2Fr 3                               ; warn the user.
001F2Fr 3               
001F2Fr 3                               ; See if word already in Dictionary.
001F2Fr 3                               ; (STATUS bit 7 will be high as CREATE already
001F2Fr 3                               ;  checked for us.)
001F2Fr 3  24 20                        bit status
001F31r 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
001F33r 3               
001F33r 3                               ; We start by putting the string of the
001F33r 3                               ; word we're defining on the stack
001F33r 3  CA                           dex
001F34r 3  CA                           dex
001F35r 3  CA                           dex
001F36r 3  CA                           dex
001F37r 3               
001F37r 3                               ; WORKWORD points to the beginning of the head of our new
001F37r 3                               ; word, where the first byte is the length of the string
001F37r 3                               ; We can't use LATESTNT because we haven't added the new
001F37r 3                               ; word to the Dictionary yet
001F37r 3  B2 04                        lda (workword)
001F39r 3  95 00                        sta 0,x
001F3Br 3  74 01                        stz 1,x
001F3Dr 3               
001F3Dr 3                               ; Eight bytes below WORKWORD is the actual beginning of
001F3Dr 3                               ; the string
001F3Dr 3  A5 04                        lda workword
001F3Fr 3  18                           clc
001F40r 3  69 08                        adc #8
001F42r 3  95 02                        sta 2,x
001F44r 3  A5 05                        lda workword+1
001F46r 3  69 00                        adc #0                  ; only want carry
001F48r 3  95 03                        sta 3,x
001F4Ar 3               
001F4Ar 3                               ; This word is already in the Dictionary, so we print a
001F4Ar 3                               ; warning to the user.
001F4Ar 3  A9 02                        lda #str_redefined       ; address of string "redefined"
001F4Cr 3  20 rr rr                     jsr print_string_no_lf
001F4Fr 3               
001F4Fr 3                               ; Now we print the offending word.
001F4Fr 3  20 rr rr                     jsr xt_type
001F52r 3  20 rr rr                     jsr xt_space
001F55r 3               
001F55r 3                               ; Clear bit 7 of status (so future words will print message
001F55r 3                               ; by defaut)
001F55r 3  A9 80                        lda #%10000000
001F57r 3  14 20                        trb status
001F59r 3               
001F59r 3               @new_word:
001F59r 3                               ; Let's get this over with. Save beginning of our word
001F59r 3                               ; as new last word in the Dictionary
001F59r 3  A5 04                        lda workword
001F5Br 3  85 02                        sta dp
001F5Dr 3  A5 05                        lda workword+1
001F5Fr 3  85 03                        sta dp+1
001F61r 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
001F64r 3                                                       ; CURRENT wordlist.
001F64r 3               @semicolon_done:
001F64r 3                               ; Word definition complete. Return compile flag to zero
001F64r 3                               ; to return to interpret mode
001F64r 3  64 16                        stz state
001F66r 3  64 17                        stz state+1
001F68r 3               
001F68r 3  60           z_semicolon:    rts
001F69r 3               
001F69r 3               
001F69r 3               
001F69r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
001F69r 3               ; ## "sign"  auto  ANS core
001F69r 3                       ; """https://forth-standard.org/standard/core/SIGN
001F69r 3                       ;
001F69r 3                       ; Code based on
001F69r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001F69r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
001F69r 3                       ; """
001F69r 3               
001F69r 3               xt_sign:
001F69r 3  20 rr rr                     jsr underflow_1
001F6Cr 3               
001F6Cr 3  B5 01                        lda 1,x         ; check MSB of TOS
001F6Er 3  30 04                        bmi @minus
001F70r 3               
001F70r 3  E8                           inx
001F71r 3  E8                           inx
001F72r 3  80 09                        bra @done
001F74r 3               @minus:
001F74r 3  A9 2D                        lda #$2D        ; ASCII for "-"
001F76r 3  95 00                        sta 0,x         ; overwrite TOS
001F78r 3  74 01                        stz 1,x         ; paranoid
001F7Ar 3               
001F7Ar 3  20 rr rr                     jsr xt_hold
001F7Dr 3               @done:
001F7Dr 3  60           z_sign:         rts
001F7Er 3               
001F7Er 3               
001F7Er 3               
001F7Er 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
001F7Er 3               ; ## "/"  auto  ANS core
001F7Er 3                       ; """https://forth-standard.org/standard/core/Div
001F7Er 3                       ;
001F7Er 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
001F7Er 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
001F7Er 3                       ; This code is currently unoptimized. This code without the SLASH
001F7Er 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
001F7Er 3                       ; """
001F7Er 3               
001F7Er 3               xt_slash:
001F7Er 3                               ; With all the multiplication going on, it would be hard to
001F7Er 3                               ; make sure that one of our temporary variables is not
001F7Er 3                               ; overwritten. We make sure that doesn't happen by taking the
001F7Er 3                               ; hit of pushing the flag to the 65c02's stack
001F7Er 3  A9 00                        lda #0
001F80r 3  48                           pha
001F81r 3  80 03                        bra _common
001F83r 3               
001F83r 3               xt_slash_mod:
001F83r 3                               ; Note that /MOD accesses this code
001F83r 3  A9 FF                        lda #$FF
001F85r 3  48                           pha             ; falls through to _common
001F86r 3               
001F86r 3               _common:
001F86r 3  20 rr rr                     jsr xt_to_r             ; >R
001F89r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
001F8Cr 3  20 rr rr                     jsr xt_r_from           ; R>
001F8Fr 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
001F92r 3               
001F92r 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
001F92r 3                               ; $FF is SLASH MOD
001F92r 3  68                           pla
001F93r 3  D0 05                        bne @done
001F95r 3               
001F95r 3                               ; The following code is for SLASH only
001F95r 3  20 rr rr                     jsr xt_swap
001F98r 3  E8                           inx             ; DROP
001F99r 3  E8                           inx
001F9Ar 3               @done:
001F9Ar 3               z_slash_mod:
001F9Ar 3  60           z_slash:        rts
001F9Br 3               
001F9Br 3               
001F9Br 3               
001F9Br 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
001F9Br 3               ; ## "/mod"  auto  ANS core
001F9Br 3                       ; """https://forth-standard.org/standard/core/DivMOD
001F9Br 3                       ;
001F9Br 3                       ; This is a dummy entry, the actual code is shared with SLASH
001F9Br 3                       ; """
001F9Br 3               
001F9Br 3               
001F9Br 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
001F9Br 3               ; ## "/string"  auto  ANS string
001F9Br 3                       ; """https://forth-standard.org/standard/string/DivSTRING
001F9Br 3                       ;
001F9Br 3                       ; Forth code is
001F9Br 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
001F9Br 3                       ; Put differently, we need to add TOS and 3OS, and subtract
001F9Br 3                       ; TOS from NOS, and then drop TOS
001F9Br 3                       ; """
001F9Br 3               
001F9Br 3               xt_slash_string:
001F9Br 3  20 rr rr                     jsr underflow_3
001F9Er 3               
001F9Er 3  18                           clc             ; 3OS+TOS
001F9Fr 3  B5 00                        lda 0,x
001FA1r 3  75 04                        adc 4,x
001FA3r 3  95 04                        sta 4,x
001FA5r 3               
001FA5r 3  B5 01                        lda 1,x
001FA7r 3  75 05                        adc 5,x
001FA9r 3  95 05                        sta 5,x
001FABr 3               
001FABr 3  38                           sec             ; NOS-TOS
001FACr 3  B5 02                        lda 2,x
001FAEr 3  F5 00                        sbc 0,x
001FB0r 3  95 02                        sta 2,x
001FB2r 3               
001FB2r 3  B5 03                        lda 3,x
001FB4r 3  F5 01                        sbc 1,x
001FB6r 3  95 03                        sta 3,x
001FB8r 3               
001FB8r 3  E8                           inx
001FB9r 3  E8                           inx
001FBAr 3               
001FBAr 3  60           z_slash_string: rts
001FBBr 3               
001FBBr 3               
001FBBr 3               
001FBBr 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
001FBBr 3               ; ## "sliteral" auto  ANS string
001FBBr 3                       ; """https://forth-standard.org/standard/string/SLITERAL
001FBBr 3                       ; Add the runtime for an existing string.
001FBBr 3                       ; """
001FBBr 3               
001FBBr 3               xt_sliteral:
001FBBr 3  20 rr rr                     jsr underflow_2
001FBEr 3               
001FBEr 3                               ; We can't assume that ( addr u ) of the current string is in
001FBEr 3                               ; a stable area (eg. already in the dictionary.) Copy the
001FBEr 3                               ; string data into the dictionary using move.
001FBEr 3               
001FBEr 3                               ; Put a jmp over the string data with address to be filled
001FBEr 3                               ; in later.
001FBEr 3  A9 4C                        lda #$4C
001FC0r 3  20 rr rr                     jsr cmpl_a
001FC3r 3               
001FC3r 3                               ; Address to be filled in later.
001FC3r 3  20 rr rr                     jsr cmpl_a
001FC6r 3  20 rr rr                     jsr cmpl_a
001FC9r 3               
001FC9r 3                               ; Turn the data stack from ( addr u ) into
001FC9r 3                               ; ( here u addr here u ) so move can be called with
001FC9r 3                               ; the remaining items on the stack ready for processing.
001FC9r 3                               ; Reserve three extra words on the stack.
001FC9r 3  8A                           txa
001FCAr 3  38                           sec
001FCBr 3  E9 06                        sbc #6
001FCDr 3  AA                           tax
001FCEr 3               
001FCEr 3                               ; Move addr down from TOS-4 to TOS-2
001FCEr 3  B5 08                        lda 8,x
001FD0r 3  95 04                        sta 4,x
001FD2r 3  B5 09                        lda 9,x
001FD4r 3  95 05                        sta 5,x
001FD6r 3               
001FD6r 3                               ; Copy u from TOS-3 to TOS
001FD6r 3  B5 06                        lda 6,x
001FD8r 3  95 00                        sta 0,x
001FDAr 3  B5 07                        lda 7,x
001FDCr 3  95 01                        sta 1,x
001FDEr 3               
001FDEr 3                               ; Put HERE into TOS-1 and TOS-4
001FDEr 3  A5 00                        lda cp
001FE0r 3  95 08                        sta 8,x
001FE2r 3  95 02                        sta 2,x
001FE4r 3  A5 01                        lda cp+1
001FE6r 3  95 09                        sta 9,x
001FE8r 3  95 03                        sta 3,x
001FEAr 3               
001FEAr 3                               ; Copy the string into the dictionary.
001FEAr 3  20 rr rr                     jsr xt_move
001FEDr 3               
001FEDr 3                               ; Update cp.
001FEDr 3  18                           clc
001FEEr 3  A5 00                        lda cp
001FF0r 3  75 00                        adc 0,x
001FF2r 3  85 00                        sta cp
001FF4r 3  A5 01                        lda cp+1
001FF6r 3  75 01                        adc 1,x
001FF8r 3  85 01                        sta cp+1
001FFAr 3               
001FFAr 3                               ; Update the address of the jump-over jmp instruction.
001FFAr 3                               ; First determine location of jmp instructions address.
001FFAr 3                               ; It should be 2 bytes before the start of the string.
001FFAr 3               
001FFAr 3                               ; Compute it into tmp1, which is no longer being used.
001FFAr 3  B5 02                        lda 2,x
001FFCr 3  38                           sec
001FFDr 3  E9 02                        sbc #2
001FFFr 3  85 24                        sta tmp1
002001r 3  B5 03                        lda 3,x
002003r 3  E9 00                        sbc #0          ; Propagate borrow
002005r 3  85 25                        sta tmp1+1
002007r 3               
002007r 3                               ; Update the address of the jump to HERE.
002007r 3  A5 00                        lda cp
002009r 3  92 24                        sta (tmp1)
00200Br 3  A0 01                        ldy #1
00200Dr 3  A5 01                        lda cp+1
00200Fr 3  91 24                        sta (tmp1),y
002011r 3               
002011r 3                               ; Stack is now ( addr2 u ) where addr2 is the new
002011r 3                               ; location in the dictionary.
002011r 3               
002011r 3               sliteral_const_str:
002011r 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
002011r 3                               ; pushes the new ( addr u ) pair to the Data Stack.
002011r 3                               ; When we're done, the code will look like this:
002011r 3               
002011r 3                               ; xt -->    jmp a
002011r 3                               ;           <string data bytes>
002011r 3                               ;  a -->    jsr sliteral_runtime
002011r 3                               ;           <string address>
002011r 3                               ;           <string length>
002011r 3                               ; rts -->
002011r 3               
002011r 3                               ; This means we'll have to adjust the return address for two
002011r 3                               ; cells, not just one
002011r 3  A0 rr                        ldy #>sliteral_runtime
002013r 3  A9 rr                        lda #<sliteral_runtime
002015r 3  20 rr rr                     jsr cmpl_subroutine
002018r 3               
002018r 3                               ; We want to have the address end up as NOS and the length
002018r 3                               ; as TOS, so we store the address first
002018r 3  B4 03                        ldy 3,x                ; address MSB
00201Ar 3  B5 02                        lda 2,x                ; address LSB
00201Cr 3  20 rr rr                     jsr cmpl_word
00201Fr 3               
00201Fr 3  B4 01                        ldy 1,x                ; length MSB
002021r 3  B5 00                        lda 0,x                ; length LSB
002023r 3  20 rr rr                     jsr cmpl_word
002026r 3               
002026r 3                               ; clean up and leave
002026r 3  E8                           inx
002027r 3  E8                           inx
002028r 3  E8                           inx
002029r 3  E8                           inx
00202Ar 3               
00202Ar 3  60           z_sliteral:     rts
00202Br 3               
00202Br 3               
00202Br 3               sliteral_runtime:
00202Br 3               
00202Br 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
00202Br 3                       ; the Data Stack. We arrive here with the return address as the
00202Br 3                       ; top of Return Stack, which points to the address of the string
00202Br 3                       ; """
00202Br 3  CA                           dex
00202Cr 3  CA                           dex
00202Dr 3  CA                           dex
00202Er 3  CA                           dex
00202Fr 3               
00202Fr 3                               ; Get the address of the string address off the stack and
00202Fr 3                               ; increase by one because of the RTS mechanics
00202Fr 3  68                           pla
002030r 3  85 24                        sta tmp1        ; LSB of address
002032r 3  68                           pla
002033r 3  85 25                        sta tmp1+1      ; MSB of address
002035r 3               
002035r 3                               ; Walk through both and save them
002035r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002037r 3  B1 24                        lda (tmp1),y
002039r 3  95 02                        sta 2,x         ; LSB of address
00203Br 3  C8                           iny
00203Cr 3               
00203Cr 3  B1 24                        lda (tmp1),y
00203Er 3  95 03                        sta 3,x         ; MSB of address
002040r 3  C8                           iny
002041r 3               
002041r 3  B1 24                        lda (tmp1),y
002043r 3  95 00                        sta 0,x         ; LSB of length
002045r 3  C8                           iny
002046r 3               
002046r 3  B1 24                        lda (tmp1),y
002048r 3  95 01                        sta 1,x         ; MSB of length
00204Ar 3               
00204Ar 3                               ; restore return address
00204Ar 3  18                           clc
00204Br 3  A5 24                        lda tmp1
00204Dr 3  69 04                        adc #4
00204Fr 3  A8                           tay             ; LSB
002050r 3  A5 25                        lda tmp1+1
002052r 3  69 00                        adc #0          ; we only need carry
002054r 3  48                           pha             ; MSB
002055r 3  5A                           phy
002056r 3               
002056r 3  60                           rts
002057r 3               
002057r 3               
002057r 3               
002057r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002057r 3               ; ## "sm/rem"  auto  ANS core
002057r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002057r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002057r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002057r 3                       ;
002057r 3                       ; Forth:
002057r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002057r 3                       ; R> ?NEGATE SWAP
002057r 3                       ; """
002057r 3               
002057r 3               xt_sm_slash_rem:
002057r 3  20 rr rr                     jsr underflow_3 ; contains double number
00205Ar 3               
00205Ar 3                               ; push MSB of high cell of d to Data Stack so we can check
00205Ar 3                               ; its sign later
00205Ar 3  B5 03                        lda 3,x
00205Cr 3  48                           pha
00205Dr 3               
00205Dr 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
00205Dr 3                               ; its sign later as well
00205Dr 3  B5 01                        lda 1,x
00205Fr 3  55 03                        eor 3,x
002061r 3  48                           pha
002062r 3               
002062r 3                               ; Prepare division by getting absolute of n1 and d
002062r 3  20 rr rr                     jsr xt_abs
002065r 3  E8                           inx             ; pretend we pushed n1 to R
002066r 3  E8                           inx
002067r 3               
002067r 3  20 rr rr                     jsr xt_dabs
00206Ar 3  CA                           dex
00206Br 3  CA                           dex
00206Cr 3               
00206Cr 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
00206Fr 3               
00206Fr 3                               ; if the XOR compiled above is negative, negate the
00206Fr 3                               ; quotient (n3)
00206Fr 3  68                           pla
002070r 3  10 03                        bpl @1
002072r 3  20 rr rr                     jsr xt_negate
002075r 3               @1:
002075r 3                               ; if d was negative, negate the remainder (n2)
002075r 3  68                           pla
002076r 3  10 07                        bpl @done
002078r 3               
002078r 3  E8                           inx             ; pretend we pushed quotient to R
002079r 3  E8                           inx
00207Ar 3  20 rr rr                     jsr xt_negate
00207Dr 3  CA                           dex
00207Er 3  CA                           dex
00207Fr 3               
00207Fr 3               @done:
00207Fr 3  60           z_sm_slash_rem: rts
002080r 3               
002080r 3               
002080r 3               
002080r 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002080r 3               ; ## "source"  auto  ANS core
002080r 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002080r 3               xt_source:
002080r 3                               ; add address
002080r 3  CA                           dex
002081r 3  CA                           dex
002082r 3  A5 08                        lda cib
002084r 3  95 00                        sta 0,x
002086r 3  A5 09                        lda cib+1
002088r 3  95 01                        sta 1,x
00208Ar 3               
00208Ar 3                               ; add size
00208Ar 3  CA                           dex
00208Br 3  CA                           dex
00208Cr 3  A5 0A                        lda ciblen
00208Er 3  95 00                        sta 0,x
002090r 3  A5 0B                        lda ciblen+1
002092r 3  95 01                        sta 1,x
002094r 3               
002094r 3  60           z_source:       rts
002095r 3               
002095r 3               
002095r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002095r 3               ; ## "source-id"  tested  ANS core ext
002095r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002095r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002095r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002095r 3                       ; string, and a text file gives the fileid.
002095r 3                       ; """
002095r 3               xt_source_id:
002095r 3  CA                           dex
002096r 3  CA                           dex
002097r 3               
002097r 3  A5 06                        lda insrc
002099r 3  95 00                        sta 0,x
00209Br 3  A5 07                        lda insrc+1
00209Dr 3  95 01                        sta 1,x
00209Fr 3               
00209Fr 3  60           z_source_id:    rts
0020A0r 3               
0020A0r 3               
0020A0r 3               ; ## SPACE ( -- ) "Print a single space"
0020A0r 3               ; ## "space"  auto  ANS core
0020A0r 3                       ; """https://forth-standard.org/standard/core/SPACE"""
0020A0r 3               xt_space:
0020A0r 3  A9 20                        lda #AscSP
0020A2r 3  20 rr rr                     jsr emit_a
0020A5r 3               
0020A5r 3  60           z_space:        rts
0020A6r 3               
0020A6r 3               
0020A6r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
0020A6r 3               ; ## "spaces"  auto  ANS core
0020A6r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
0020A6r 3               
0020A6r 3               xt_spaces:
0020A6r 3  20 rr rr                     jsr underflow_1
0020A9r 3               
0020A9r 3                               ; catch any zero in TOS fast
0020A9r 3  B5 00                        lda 0,x
0020ABr 3  15 01                        ora 1,x
0020ADr 3  F0 2A                        beq @done
0020AFr 3               
0020AFr 3                               ; Usually we're only going to print far less than 256 spaces,
0020AFr 3                               ; so we create a quick loop for that. Short loop could be realized
0020AFr 3                               ; as a separate subroutine, but unless we're really pressed for
0020AFr 3                               ; memory at some point, this is faster
0020AFr 3  B4 01                        ldy 1,x
0020B1r 3  D0 0C                        bne @lots_of_spaces
0020B3r 3               
0020B3r 3  B4 00                        ldy 0,x
0020B5r 3               @quick_loop:
0020B5r 3                               ; we reach here knowing that there must be a number that is not
0020B5r 3                               ; zero in the TOS
0020B5r 3  A9 20                        lda #AscSP
0020B7r 3  20 rr rr                     jsr emit_a
0020BAr 3  88                           dey
0020BBr 3  F0 1C                        beq @done
0020BDr 3  80 F6                        bra @quick_loop
0020BFr 3               
0020BFr 3               @lots_of_spaces:
0020BFr 3                               ; We go through the first loop once to get rid of the lower
0020BFr 3                               ; counter byte. This could be zero
0020BFr 3  B4 00                        ldy 0,x
0020C1r 3               
0020C1r 3               @first_slow_loop:
0020C1r 3  F0 08                        beq @slow_outer_loop
0020C3r 3  A9 20                        lda #AscSP
0020C5r 3  20 rr rr                     jsr emit_a
0020C8r 3  88                           dey
0020C9r 3  80 F6                        bra @first_slow_loop
0020CBr 3               
0020CBr 3               @slow_outer_loop:
0020CBr 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
0020CBr 3  A0 00                        ldy #00
0020CDr 3               
0020CDr 3               @slow_inner_loop:
0020CDr 3  A9 20                        lda #AscSP
0020CFr 3  20 rr rr                     jsr emit_a
0020D2r 3  88                           dey
0020D3r 3  D0 F8                        bne @slow_inner_loop
0020D5r 3               
0020D5r 3  D6 01                        dec 1,x
0020D7r 3  D0 F2                        bne @slow_outer_loop
0020D9r 3               
0020D9r 3               @done:
0020D9r 3  E8                           inx             ; drop
0020DAr 3  E8                           inx
0020DBr 3               
0020DBr 3  60           z_spaces:       rts
0020DCr 3               
0020DCr 3               
0020DCr 3               
0020DCr 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
0020DCr 3               ; ## "*"  auto  ANS core
0020DCr 3                       ; """https://forth-standard.org/standard/core/Times
0020DCr 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
0020DCr 3                       ;
0020DCr 3                       ; This is nothing  more than UM* DROP
0020DCr 3                       ; """
0020DCr 3               
0020DCr 3               xt_star:
0020DCr 3  20 rr rr                     jsr underflow_2
0020DFr 3               
0020DFr 3  20 rr rr                     jsr xt_um_star
0020E2r 3  E8                           inx
0020E3r 3  E8                           inx
0020E4r 3               
0020E4r 3  60           z_star:         rts
0020E5r 3               
0020E5r 3               
0020E5r 3               
0020E5r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
0020E5r 3               ; ## "*/"  auto  ANS core
0020E5r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
0020E5r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
0020E5r 3                       ; without a remainder. This is */MOD without the mod.
0020E5r 3                       ;
0020E5r 3                       ; This word
0020E5r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
0020E5r 3                       ; pretty much what we do here
0020E5r 3                       ; """
0020E5r 3               xt_star_slash:
0020E5r 3                               ; We let */MOD check for underflow
0020E5r 3  20 rr rr                     jsr xt_star_slash_mod
0020E8r 3  20 rr rr                     jsr xt_swap
0020EBr 3  E8                           inx
0020ECr 3  E8                           inx
0020EDr 3               z_star_slash:
0020EDr 3  60                           rts
0020EEr 3               
0020EEr 3               
0020EEr 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
0020EEr 3               ; ## "*/mod"  auto  ANS core
0020EEr 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
0020EEr 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
0020EEr 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
0020EEr 3                       ; single-cell quotient n5.
0020EEr 3                       ;
0020EEr 3                       ; In Forth, this is
0020EEr 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
0020EEr 3                       ; """
0020EEr 3               xt_star_slash_mod:
0020EEr 3  20 rr rr                     jsr underflow_3
0020F1r 3               
0020F1r 3  20 rr rr                     jsr xt_to_r
0020F4r 3  20 rr rr                     jsr xt_m_star
0020F7r 3  20 rr rr                     jsr xt_r_from
0020FAr 3  20 rr rr                     jsr xt_sm_slash_rem
0020FDr 3               
0020FDr 3               z_star_slash_mod:
0020FDr 3  60                           rts
0020FEr 3               
0020FEr 3               
0020FEr 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
0020FEr 3               ; ## "state"  auto  ANS core
0020FEr 3                       ; """https://forth-standard.org/standard/core/STATE
0020FEr 3                       ; STATE is true when in compilation state, false otherwise. Note
0020FEr 3                       ; we do not return the state itself, but only the address where
0020FEr 3                       ; it lives. The state should not be changed directly by the user; see
0020FEr 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
0020FEr 3                       ; """
0020FEr 3               xt_state:
0020FEr 3  CA                           dex
0020FFr 3  CA                           dex
002100r 3  A9 16                        lda #<state
002102r 3  95 00                        sta 0,x
002104r 3  A9 00                        lda #>state
002106r 3  95 01                        sta 1,x
002108r 3               
002108r 3  60           z_state:        rts
002109r 3               
002109r 3               
002109r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002109r 3               ; ## "!"  auto  ANS core
002109r 3                       ; """https://forth-standard.org/standard/core/Store"""
002109r 3               xt_store:
002109r 3  20 rr rr                     jsr underflow_2
00210Cr 3               
00210Cr 3  B5 02                        lda 2,x         ; LSB
00210Er 3  81 00                        sta (0,x)
002110r 3               
002110r 3  F6 00                        inc 0,x
002112r 3  D0 02                        bne @1
002114r 3  F6 01                        inc 1,x
002116r 3               @1:
002116r 3  B5 03                        lda 3,x         ; MSB
002118r 3  81 00                        sta (0,x)
00211Ar 3               
00211Ar 3  E8                           inx             ; 2DROP
00211Br 3  E8                           inx
00211Cr 3  E8                           inx
00211Dr 3  E8                           inx
00211Er 3               
00211Er 3  60           z_store:        rts
00211Fr 3               
00211Fr 3               
00211Fr 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
00211Fr 3               ; ## "strip-underflow"  tested  Tali Forth
00211Fr 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
00211Fr 3                       ; checking should be removed during the compilation of new words.
00211Fr 3                       ; Default is false.
00211Fr 3                       ; """
00211Fr 3               xt_strip_underflow:
00211Fr 3  CA                           dex
002120r 3  CA                           dex
002121r 3               
002121r 3  A9 1C                        lda #<uf_strip
002123r 3  95 00                        sta 0,x
002125r 3  A9 00                        lda #>uf_strip
002127r 3  95 01                        sta 1,x
002129r 3               
002129r 3               z_strip_underflow:
002129r 3  60                           rts
00212Ar 3               
00212Ar 3               
00212Ar 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
00212Ar 3               ; ## "swap"  auto  ANS core
00212Ar 3                       ; """https://forth-standard.org/standard/core/SWAP"""
00212Ar 3               xt_swap:
00212Ar 3  20 rr rr                     jsr underflow_2
00212Dr 3               
00212Dr 3  B5 00                        lda 0,x         ; LSB
00212Fr 3  B4 02                        ldy 2,x
002131r 3  95 02                        sta 2,x
002133r 3  94 00                        sty 0,x
002135r 3               
002135r 3  B5 01                        lda 1,x         ; MSB
002137r 3  B4 03                        ldy 3,x
002139r 3  95 03                        sta 3,x
00213Br 3  94 01                        sty 1,x
00213Dr 3               
00213Dr 3  60           z_swap:         rts
00213Er 3               
00213Er 3               
00213Er 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
00213Er 3               ; ## "then"  auto  ANS core
00213Er 3                       ; """http://forth-standard.org/standard/core/THEN"""
00213Er 3               xt_then:
00213Er 3                               ; Get the address to jump to.
00213Er 3  20 rr rr                     jsr xt_here
002141r 3               
002141r 3                               ; Stuff HERE in for the branch address back
002141r 3                               ; at the IF or ELSE (origination address is on stack).
002141r 3  20 rr rr                     jsr xt_swap
002144r 3  20 rr rr                     jsr xt_store
002147r 3               
002147r 3  60           z_then:         rts
002148r 3               
002148r 3               
002148r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002148r 3               ; ## "thru"  tested  ANS block ext
002148r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002148r 3               
002148r 3               xt_thru:
002148r 3  20 rr rr                     jsr underflow_2
00214Br 3               
00214Br 3                               ; We need to loop here, and can't use the data stack
00214Br 3                               ; because the LOADed screens might use it.  We'll
00214Br 3                               ; need to use the same trick that DO loops use, holding
00214Br 3                               ; the limit and current index on the return stack.
00214Br 3               
00214Br 3                               ; Put the ending screen number on the return stack
00214Br 3  B5 01                        lda 1,x
00214Dr 3  48                           pha
00214Er 3  B5 00                        lda 0,x
002150r 3  48                           pha
002151r 3  E8                           inx
002152r 3  E8                           inx
002153r 3               @thru_loop:
002153r 3                               ; Put the starting screen number on the stack,
002153r 3                               ; but keep a copy
002153r 3  B5 01                        lda 1,x
002155r 3  48                           pha
002156r 3  B5 00                        lda 0,x
002158r 3  48                           pha
002159r 3               
002159r 3                               ; Load this screen.
002159r 3  20 rr rr                     jsr xt_load
00215Cr 3               
00215Cr 3                               ; Get the number and limit back off the stack.  Rather than
00215Cr 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
00215Cr 3               
00215Cr 3                               ; Get the screen we just loaded.
00215Cr 3  68                           pla
00215Dr 3  85 24                        sta tmp1
00215Fr 3  68                           pla
002160r 3  85 25                        sta tmp1+1
002162r 3               
002162r 3                               ; Get the ending screen.
002162r 3  68                           pla
002163r 3  85 26                        sta tmp2
002165r 3  68                           pla
002166r 3  85 27                        sta tmp2+1
002168r 3               
002168r 3                               ; See if we just loaded the last screen.
002168r 3                               ; A already has the MSB of the last screen in it.
002168r 3  C5 25                        cmp tmp1+1
00216Ar 3  D0 08                        bne @next_screen
00216Cr 3  A5 26                        lda tmp2        ; Compare the LSB
00216Er 3  C5 24                        cmp tmp1
002170r 3  D0 02                        bne @next_screen
002172r 3  80 18                        bra @done       ; We just did the last screen.
002174r 3               
002174r 3               @next_screen:
002174r 3                               ; Put the ending screen back on the data stack.
002174r 3  A5 27                        lda tmp2+1
002176r 3  48                           pha
002177r 3  A5 26                        lda tmp2
002179r 3  48                           pha
00217Ar 3               
00217Ar 3                               ; Increment the current screen.
00217Ar 3  E6 24                        inc tmp1
00217Cr 3  D0 02                        bne @1
00217Er 3  E6 25                        inc tmp1+1
002180r 3               @1:
002180r 3                               ; Put the current screen on the stack to prepare for
002180r 3                               ; the next loop.
002180r 3  CA                           dex
002181r 3  CA                           dex
002182r 3  A5 24                        lda tmp1
002184r 3  95 00                        sta 0,x
002186r 3  A5 25                        lda tmp1+1
002188r 3  95 01                        sta 1,x
00218Ar 3  80 C7                        bra @thru_loop
00218Cr 3               @done:
00218Cr 3  60           z_thru:         rts
00218Dr 3               
00218Dr 3               
00218Dr 3               
00218Dr 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
00218Dr 3               ; ## "'"  auto  ANS core
00218Dr 3                       ; """https://forth-standard.org/standard/core/Tick"""
00218Dr 3               
00218Dr 3               xt_tick:
00218Dr 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002190r 3               
002190r 3                               ; if we got a zero, there was a problem getting the
002190r 3                               ; name of the word
002190r 3  B5 00                        lda 0,x
002192r 3  15 01                        ora 1,x
002194r 3  D0 05                        bne @1
002196r 3               
002196r 3  A9 05                        lda #err_noname
002198r 3  4C rr rr                     jmp error
00219Br 3               @1:
00219Br 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
00219Er 3               
00219Er 3                               ; If we didn't find the word in the Dictionary, abort
00219Er 3  B5 00                        lda 0,x
0021A0r 3  15 01                        ora 1,x
0021A2r 3  D0 05                        bne @2
0021A4r 3               
0021A4r 3  A9 08                        lda #err_syntax
0021A6r 3  4C rr rr                     jmp error
0021A9r 3               @2:
0021A9r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
0021ACr 3               
0021ACr 3  60           z_tick:         rts
0021ADr 3               
0021ADr 3               
0021ADr 3               
0021ADr 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
0021ADr 3               ; ## "to"  auto  ANS core ext
0021ADr 3                       ; """https://forth-standard.org/standard/core/TO
0021ADr 3                       ; Gives a new value to a, uh, VALUE.
0021ADr 3                       ;
0021ADr 3                       ; One possible Forth
0021ADr 3                       ; implementation is  ' >BODY !  but given the problems we have
0021ADr 3                       ; with >BODY on STC Forths, we do this the hard way. Since
0021ADr 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
0021ADr 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
0021ADr 3                       ;
0021ADr 3                       ; Note that the standard has different behaviors for TO depending
0021ADr 3                       ; on the state (https://forth-standard.org/standard/core/TO).
0021ADr 3                       ; This makes TO state-dependent (which is bad) and also rather
0021ADr 3                       ; complex (see the Gforth implementation for comparison). This
0021ADr 3                       ; word may not be natively compiled and must be immediate. Frankly,
0021ADr 3                       ; it would have made more sense to have two words for this.
0021ADr 3                       ; """
0021ADr 3               
0021ADr 3               xt_to:
0021ADr 3                               ; One way or the other, we need the xt of the word after this
0021ADr 3                               ; one. At this point, we don't know if we are interpreted or
0021ADr 3                               ; compile, so we don't know if there is a value n on the stack,
0021ADr 3                               ; so we can't do an underflow check yet
0021ADr 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
0021B0r 3               
0021B0r 3                               ; The PFA (DFA in this case) is three bytes down,
0021B0r 3                               ; after the jump to DOCONST
0021B0r 3  B5 00                        lda 0,x                 ; LSB
0021B2r 3  18                           clc
0021B3r 3  69 03                        adc #3
0021B5r 3  85 24                        sta tmp1
0021B7r 3  B5 01                        lda 1,x                 ; MSB
0021B9r 3  69 00                        adc #0                  ; we just want the carry
0021BBr 3  85 25                        sta tmp1+1
0021BDr 3               
0021BDr 3  E8                           inx
0021BEr 3  E8                           inx                     ; ( [n] )
0021BFr 3               
0021BFr 3                               ; Now it gets ugly. See which state we are in
0021BFr 3  A5 16                        lda state
0021C1r 3  05 17                        ora state+1
0021C3r 3  F0 34                        beq @interpret
0021C5r 3               
0021C5r 3                               ; Well, we're compiling. We want to end up with simple
0021C5r 3                               ; code that just takes the number that is TOS and saves
0021C5r 3                               ; it in the address of the xt we were just given. So we
0021C5r 3                               ; want to compile this routine:
0021C5r 3                               ;
0021C5r 3                               ;       lda 0,x                 - B5 00
0021C5r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0021C5r 3                               ;       lda 1,x                 - B5 01
0021C5r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0021C5r 3                               ;       inx                     - E8
0021C5r 3                               ;       inx                     - E8
0021C5r 3                               ;
0021C5r 3                               ; which at least is nice and short. Other than that, we pretty
0021C5r 3                               ; much have to do this the hard and long way, because with the
0021C5r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
0021C5r 3                               ; range and store them with a loop. Sigh.
0021C5r 3               
0021C5r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
0021C7r 3  A9 B5                        lda #$B5
0021C9r 3  20 rr rr                     jsr cmpl_word
0021CCr 3               
0021CCr 3  A9 8D                        lda #$8D                ; Code for STA abs
0021CEr 3  20 rr rr                     jsr cmpl_a
0021D1r 3               
0021D1r 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
0021D3r 3  A5 24                        lda tmp1
0021D5r 3  20 rr rr                     jsr cmpl_word
0021D8r 3               
0021D8r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
0021DAr 3  A9 B5                        lda #$B5
0021DCr 3  20 rr rr                     jsr cmpl_word
0021DFr 3               
0021DFr 3  A9 8D                        lda #$8D                ; Code for STA abs
0021E1r 3  20 rr rr                     jsr cmpl_a
0021E4r 3               
0021E4r 3  E6 24                        inc tmp1                ; Calculate MSB
0021E6r 3  D0 02                        bne @1
0021E8r 3  E6 25                        inc tmp1+1
0021EAr 3               @1:
0021EAr 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
0021ECr 3  A5 24                        lda tmp1
0021EEr 3  20 rr rr                     jsr cmpl_word
0021F1r 3               
0021F1r 3  A0 E8                        ldy #$E8                ; Code for INX
0021F3r 3  98                           tya
0021F4r 3  20 rr rr                     jsr cmpl_word
0021F7r 3               
0021F7r 3  80 0F                        bra @done
0021F9r 3               
0021F9r 3               @interpret:
0021F9r 3                               ; We're interpreting, so we arrive here with n
0021F9r 3                               ; on the stack. This is an annoying place to put
0021F9r 3                               ; the underflow check because we can't
0021F9r 3                               ; automatically strip it out
0021F9r 3  20 rr rr                     jsr underflow_1
0021FCr 3               
0021FCr 3                               ; We skip over the jump to DOCONST and store the number
0021FCr 3                               ; in the Program Field Area (PDF, in this case more a
0021FCr 3                               ; Data Field Area
0021FCr 3  B5 00                        lda 0,x
0021FEr 3  92 24                        sta (tmp1)              ; LSB
002200r 3               
002200r 3  A0 01                        ldy #1
002202r 3  B5 01                        lda 1,x                 ; MSB
002204r 3  91 24                        sta (tmp1),y            ; fall through to common
002206r 3               
002206r 3  E8                           inx                     ; DROP
002207r 3  E8                           inx
002208r 3               @done:
002208r 3  60           z_to:           rts
002209r 3               
002209r 3               
002209r 3               
002209r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002209r 3               ; ## ">body"  auto  ANS core
002209r 3                       ; """https://forth-standard.org/standard/core/toBODY
002209r 3                       ; Given a word's execution token (xt), return the address of the
002209r 3                       ; start of that word's parameter field (PFA). This is defined as the
002209r 3                       ; address that HERE would return right after CREATE.
002209r 3                       ;
002209r 3                       ; This is a
002209r 3                       ; difficult word for STC Forths, because most words don't actually
002209r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002209r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002209r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002209r 3                       ; """
002209r 3               
002209r 3               xt_to_body:
002209r 3  20 rr rr                     jsr underflow_1
00220Cr 3               
00220Cr 3                               ; Ideally, xt already points to the CFA. We just need to check
00220Cr 3                               ; the HC flag for special cases
00220Cr 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
00220Fr 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
002212r 3               
002212r 3                               ; The status byte is nt+1
002212r 3  F6 00                        inc 0,x
002214r 3  D0 02                        bne @1
002216r 3  F6 01                        inc 1,x
002218r 3               @1:
002218r 3  A1 00                        lda (0,x)               ; get status byte
00221Ar 3  29 20                        and #HC
00221Cr 3  F0 0D                        beq @no_cfa
00221Er 3               
00221Er 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
00221Er 3                               ; so we add three to xt, which is NOS
00221Er 3  18                           clc
00221Fr 3  B5 02                        lda 2,x         ; LSB
002221r 3  69 03                        adc #3
002223r 3  95 02                        sta 2,x
002225r 3  B5 03                        lda 3,x         ; MSB
002227r 3  69 00                        adc #0          ; we conly care about the carry
002229r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
00222Br 3               @no_cfa:
00222Br 3  E8                           inx             ; get rid of the nt
00222Cr 3  E8                           inx
00222Dr 3               @done:
00222Dr 3  60           z_to_body:      rts
00222Er 3               
00222Er 3               
00222Er 3               
00222Er 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
00222Er 3               ; ## ">in"  auto  ANS core
00222Er 3               xt_to_in:
00222Er 3  CA                           dex
00222Fr 3  CA                           dex
002230r 3               
002230r 3  A9 0C                        lda #<toin
002232r 3  95 00                        sta 0,x
002234r 3  A9 00                        lda #>toin      ; paranoid, should be zero
002236r 3  95 01                        sta 1,x
002238r 3               
002238r 3  60           z_to_in:        rts
002239r 3               
002239r 3               
002239r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002239r 3               ; ## ">number"  auto  ANS core
002239r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002239r 3                       ; Convert a string to a double number. Logic here is based on the
002239r 3                       ; routine by Phil Burk of the same name in pForth, see
002239r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002239r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002239r 3                       ; made sure that we don't have to deal with a sign and we don't have
002239r 3                       ; to deal with a dot as a last character that signalizes double -
002239r 3                       ; this should be a pure number string.
002239r 3                       ;
002239r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002239r 3                       ; cannot access any of those.
002239r 3                       ;
002239r 3                       ; For the math routine, we move the inputs to the scratchpad to
002239r 3                       ; avoid having to fool around with the Data Stack.
002239r 3                       ;
002239r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002239r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002239r 3                       ;     |           |           |           |           |
002239r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002239r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002239r 3                       ;
002239r 3                       ; The math routine works by converting one character to its
002239r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002239r 3                       ; the moment. We then multiply the UD-HI value with the radix
002239r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002239r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002239r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002239r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002239r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002239r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002239r 3                       ; storing the result back in S and S+2, before we start another
002239r 3                       ; round with it as the new UD-LO and UD-HI.
002239r 3                       ; """
002239r 3               
002239r 3               
002239r 3               xt_to_number:
002239r 3  20 rr rr                     jsr underflow_4
00223Cr 3               
00223Cr 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
00223Cr 3                               ; After this step, the original ud-lo and ud-hi will still be on
00223Cr 3                               ; the Data Stack, but will be ignored and later overwritten
00223Cr 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
00223Cr 3  B5 06                        lda 6,x         ; ud-lo LSB
00223Er 3  85 36                        sta scratch
002240r 3  B5 07                        lda 7,x         ; ud-lo MSB
002242r 3  85 37                        sta scratch+1
002244r 3               
002244r 3  B5 04                        lda 4,x         ; ud-hi LSB
002246r 3  85 38                        sta scratch+2
002248r 3  B5 05                        lda 5,x         ; ud-hi MSB
00224Ar 3  85 39                        sta scratch+3
00224Cr 3               
00224Cr 3                               ; Push down one on the Data Stack to use TOS for character
00224Cr 3                               ; conversion ( ud-lo ud-hi addr u x )
00224Cr 3  CA                           dex
00224Dr 3  CA                           dex
00224Er 3               
00224Er 3               @loop:
00224Er 3                               ; Get one character based on address
00224Er 3  A1 04                        lda (4,x)
002250r 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
002252r 3  74 01                        stz 1,x                 ; paranoid
002254r 3               
002254r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002257r 3               
002257r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002257r 3                               ; check the flag. If it is zero, we return what we have and
002257r 3                               ; let the caller (usually NUMBER) complain
002257r 3  B5 00                        lda 0,x
002259r 3  D0 04                        bne @digit_ok
00225Br 3               
00225Br 3  E8                           inx
00225Cr 3  E8                           inx
00225Dr 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
00225Fr 3               
00225Fr 3               @digit_ok:
00225Fr 3                               ; Conversion was successful. We arrive here with
00225Fr 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
00225Fr 3                               ; math routine
00225Fr 3               
00225Fr 3                               ; Save n so we don't have to fool around with the
00225Fr 3                               ; Data Stack
00225Fr 3  B5 02                        lda 2,x
002261r 3  85 3A                        sta scratch+4
002263r 3  B5 03                        lda 3,x
002265r 3  85 3B                        sta scratch+5
002267r 3               
002267r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002267r 3                               ; original one on the Data Stack) with the radix from BASE.
002267r 3                               ; We can clobber TOS and NOS because we saved n
002267r 3  A5 38                        lda scratch+2
002269r 3  95 02                        sta 2,x         ; NOS
00226Br 3  A5 39                        lda scratch+3
00226Dr 3  95 03                        sta 3,x
00226Fr 3               
00226Fr 3  A5 18                        lda base
002271r 3  95 00                        sta 0,x         ; TOS
002273r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002275r 3               
002275r 3                               ; UM* returns a double-celled number
002275r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002278r 3               
002278r 3                               ; Move ud-hi-lo to safety
002278r 3  B5 02                        lda 2,x         ; ud-hi-lo
00227Ar 3  85 3C                        sta scratch+6
00227Cr 3  B5 03                        lda 3,x
00227Er 3  85 3D                        sta scratch+7
002280r 3               
002280r 3                               ; Now we multiply ud-lo, overwriting the stack entries
002280r 3  A5 36                        lda scratch
002282r 3  95 02                        sta 2,x
002284r 3  A5 37                        lda scratch+1
002286r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002288r 3               
002288r 3  A5 18                        lda base
00228Ar 3  95 00                        sta 0,x
00228Cr 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
00228Er 3               
00228Er 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002291r 3               
002291r 3  B5 00                        lda 0,x
002293r 3  85 38                        sta scratch+2
002295r 3  B5 01                        lda 1,x
002297r 3  85 39                        sta scratch+3
002299r 3               
002299r 3  B5 02                        lda 2,x
00229Br 3  85 36                        sta scratch
00229Dr 3  B5 03                        lda 3,x
00229Fr 3  85 37                        sta scratch+1
0022A1r 3               
0022A1r 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
0022A1r 3                               ; both in the scratch pad
0022A1r 3  18                           clc
0022A2r 3  A5 36                        lda scratch     ; ud-lo LSB
0022A4r 3  65 3A                        adc scratch+4   ; n LSB
0022A6r 3  85 36                        sta scratch     ; this is the new ud-lo
0022A8r 3  A5 37                        lda scratch+1   ; ud-lo MSB
0022AAr 3  65 3B                        adc scratch+5   ; n MSB
0022ACr 3  85 37                        sta scratch+1
0022AEr 3               
0022AEr 3  A5 38                        lda scratch+2   ; LSB
0022B0r 3  65 3C                        adc scratch+6
0022B2r 3  85 38                        sta scratch+2   ; this is the new ud-hi
0022B4r 3  A5 39                        lda scratch+3   ; MSB
0022B6r 3  65 3D                        adc scratch+7
0022B8r 3  85 39                        sta scratch+3
0022BAr 3               
0022BAr 3                               ; Clean up: Get rid of one of the two top elements on
0022BAr 3                               ; the Data Stack. We don't really care which one
0022BAr 3  E8                           inx
0022BBr 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
0022BCr 3               
0022BCr 3                               ; One character down. Move address up
0022BCr 3  F6 04                        inc 4,x
0022BEr 3  D0 02                        bne @1
0022C0r 3  F6 05                        inc 5,x
0022C2r 3               @1:
0022C2r 3                               ; Decrease counter
0022C2r 3  D6 02                        dec 2,x
0022C4r 3  D0 88                        bne @loop
0022C6r 3               
0022C6r 3               @done:
0022C6r 3                               ; Counter has reached zero or we have an error. In both
0022C6r 3                               ; cases, we clean up the Data Stack and return. Error gives
0022C6r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
0022C6r 3                               ; ( ud-lo ud-hi addr u ud-lo )
0022C6r 3  E8                           inx
0022C7r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
0022C8r 3               
0022C8r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
0022C8r 3  A5 36                        lda scratch     ; new ud-lo
0022CAr 3  95 06                        sta 6,x
0022CCr 3  A5 37                        lda scratch+1
0022CEr 3  95 07                        sta 7,x
0022D0r 3               
0022D0r 3  A5 38                        lda scratch+2
0022D2r 3  95 04                        sta 4,x
0022D4r 3  A5 39                        lda scratch+3
0022D6r 3  95 05                        sta 5,x
0022D8r 3               
0022D8r 3  60           z_to_number:    rts
0022D9r 3               
0022D9r 3               
0022D9r 3               
0022D9r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
0022D9r 3               ; ## ">order"  tested  Gforth search
0022D9r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
0022D9r 3               
0022D9r 3               xt_to_order:
0022D9r 3                               ; Put the wid on the return stack for now.
0022D9r 3  20 rr rr                     jsr xt_to_r
0022DCr 3               
0022DCr 3                               ; Get the current search order.
0022DCr 3  20 rr rr                     jsr xt_get_order
0022DFr 3               
0022DFr 3                               ; Get back the wid and add it to the list.
0022DFr 3  20 rr rr                     jsr xt_r_from
0022E2r 3  20 rr rr                     jsr xt_swap
0022E5r 3  20 rr rr                     jsr xt_one_plus
0022E8r 3               
0022E8r 3                               ; Set the search order with the new list.
0022E8r 3  20 rr rr                     jsr xt_set_order
0022EBr 3               
0022EBr 3  60           z_to_order:     rts
0022ECr 3               
0022ECr 3               
0022ECr 3               
0022ECr 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
0022ECr 3               ; ## ">r"  auto  ANS core
0022ECr 3                       ; """https://forth-standard.org/standard/core/toR
0022ECr 3                       ; This word is handled differently for native and for
0022ECr 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
0022ECr 3                       ; word.
0022ECr 3                       ; """
0022ECr 3               xt_to_r:
0022ECr 3                               ; Save the return address. If this word is natively
0022ECr 3                               ; coded, this is a complete waste of cycles, but
0022ECr 3                               ; required for subroutine coding
0022ECr 3  68                           pla             ; LSB
0022EDr 3  85 2C                        sta tmptos
0022EFr 3  7A                           ply             ; MSB
0022F0r 3               
0022F0r 3                               ; --- CUT HERE FOR NATIVE CODING ---
0022F0r 3               
0022F0r 3                               ; We check for underflow in the second step, so we can
0022F0r 3                               ; strip off the stack thrashing for native compiling first
0022F0r 3  20 rr rr                     jsr underflow_1
0022F3r 3               
0022F3r 3                               ; now we can do the actual work
0022F3r 3  B5 01                        lda 1,x         ; MSB
0022F5r 3  48                           pha
0022F6r 3  B5 00                        lda 0,x         ; LSB
0022F8r 3  48                           pha
0022F9r 3               
0022F9r 3  E8                           inx
0022FAr 3  E8                           inx
0022FBr 3               
0022FBr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0022FBr 3               
0022FBr 3                               ; restore return address
0022FBr 3  5A                           phy             ; MSB
0022FCr 3  A5 2C                        lda tmptos
0022FEr 3  48                           pha             ; LSB
0022FFr 3               
0022FFr 3  60           z_to_r:         rts
002300r 3               
002300r 3               
002300r 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002300r 3               ; ## "true"  auto  ANS core ext
002300r 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002300r 3               xt_true:
002300r 3  CA                           dex
002301r 3  CA                           dex
002302r 3  A9 FF                        lda #$FF
002304r 3  95 00                        sta 0,x
002306r 3  95 01                        sta 1,x
002308r 3               
002308r 3  60           z_true:         rts
002309r 3               
002309r 3               
002309r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002309r 3               ; ## "tuck"  auto  ANS core ext
002309r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002309r 3               xt_tuck:
002309r 3  20 rr rr                     jsr underflow_2
00230Cr 3               
00230Cr 3  CA                           dex
00230Dr 3  CA                           dex
00230Er 3               
00230Er 3  B4 04                        ldy 4,x         ; LSB
002310r 3  B5 02                        lda 2,x
002312r 3  95 04                        sta 4,x
002314r 3  94 02                        sty 2,x
002316r 3  95 00                        sta 0,x
002318r 3               
002318r 3  B4 05                        ldy 5,x         ; MSB
00231Ar 3  B5 03                        lda 3,x
00231Cr 3  95 05                        sta 5,x
00231Er 3  94 03                        sty 3,x         ; bba
002320r 3  95 01                        sta 1,x         ; baa
002322r 3               
002322r 3  60           z_tuck:         rts
002323r 3               
002323r 3               
002323r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002323r 3               ; ## "2"  auto  Tali Forth
002323r 3                       ;
002323r 3                       ; This code is shared with ASSEMBLER-WORDLIST
002323r 3               xt_assembler_wordlist:
002323r 3               xt_two:
002323r 3  CA                           dex
002324r 3  CA                           dex
002325r 3  A9 02                        lda #2
002327r 3  95 00                        sta 0,x
002329r 3  74 01                        stz 1,x
00232Br 3               
00232Br 3               z_assembler_wordlist:
00232Br 3  60           z_two:          rts
00232Cr 3               
00232Cr 3               
00232Cr 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
00232Cr 3               ; ## "2drop"  auto  ANS core
00232Cr 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
00232Cr 3               xt_two_drop:
00232Cr 3  20 rr rr                     jsr underflow_2
00232Fr 3               
00232Fr 3  E8                           inx
002330r 3  E8                           inx
002331r 3  E8                           inx
002332r 3  E8                           inx
002333r 3               
002333r 3  60           z_two_drop:     rts
002334r 3               
002334r 3               
002334r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002334r 3               ; ## "2dup"  auto  ANS core
002334r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002334r 3               xt_two_dup:
002334r 3  20 rr rr                     jsr underflow_2
002337r 3               
002337r 3  CA                           dex
002338r 3  CA                           dex
002339r 3  CA                           dex
00233Ar 3  CA                           dex
00233Br 3               
00233Br 3  B5 04                        lda 4,x         ; TOS
00233Dr 3  95 00                        sta 0,x
00233Fr 3  B5 05                        lda 5,x
002341r 3  95 01                        sta 1,x
002343r 3               
002343r 3  B5 06                        lda 6,x         ; NOS
002345r 3  95 02                        sta 2,x
002347r 3  B5 07                        lda 7,x
002349r 3  95 03                        sta 3,x
00234Br 3               
00234Br 3  60           z_two_dup:      rts
00234Cr 3               
00234Cr 3               
00234Cr 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
00234Cr 3               ; ## "2@"  auto  ANS core
00234Cr 3                       ; """https://forth-standard.org/standard/core/TwoFetch
00234Cr 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
00234Cr 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
00234Cr 3                       ; """
00234Cr 3               xt_two_fetch:
00234Cr 3  20 rr rr                     jsr underflow_1
00234Fr 3               
00234Fr 3  B5 00                        lda 0,x
002351r 3  85 24                        sta tmp1
002353r 3  B4 01                        ldy 1,x
002355r 3  84 25                        sty tmp1+1
002357r 3               
002357r 3  CA                           dex             ; reuse one stack element
002358r 3  CA                           dex
002359r 3               
002359r 3  B2 24                        lda (tmp1)      ; copy LSB
00235Br 3  95 00                        sta 0,x
00235Dr 3  A0 01                        ldy #1          ; copy next
00235Fr 3  B1 24                        lda (tmp1),y
002361r 3  95 01                        sta 1,x
002363r 3  C8                           iny             ; copy next
002364r 3  B1 24                        lda (tmp1),y
002366r 3  95 02                        sta 2,x
002368r 3  C8                           iny             ; copy next
002369r 3  B1 24                        lda (tmp1),y
00236Br 3  95 03                        sta 3,x
00236Dr 3               
00236Dr 3  60           z_two_fetch:    rts
00236Er 3               
00236Er 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
00236Er 3               ; ## "2over"  auto  ANS core
00236Er 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
00236Er 3               xt_two_over:
00236Er 3  20 rr rr                     jsr underflow_4
002371r 3               
002371r 3  CA                           dex
002372r 3  CA                           dex
002373r 3  CA                           dex
002374r 3  CA                           dex
002375r 3               
002375r 3  B5 08                        lda 8,x
002377r 3  95 00                        sta 0,x
002379r 3               
002379r 3  B5 09                        lda 9,x
00237Br 3  95 01                        sta 1,x
00237Dr 3               
00237Dr 3  B5 0A                        lda 10,x
00237Fr 3  95 02                        sta 2,x
002381r 3               
002381r 3  B5 0B                        lda 11,x
002383r 3  95 03                        sta 3,x
002385r 3               
002385r 3  60           z_two_over:     rts
002386r 3               
002386r 3               
002386r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002386r 3               ; ## "2r@"  auto  ANS core ext
002386r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002386r 3                       ;
002386r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002386r 3                       ; assembler. We use trickery to access the elements on the Return
002386r 3                       ; Stack instead of pulling the return address first and storing
002386r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002386r 3                       ; it as Never Native; at some point, we should compare versions to
002386r 3                       ; see if an Always Native version would be better
002386r 3                       ; """
002386r 3               xt_two_r_fetch:
002386r 3               		; make room on the Data Stack
002386r 3  CA                           dex
002387r 3  CA                           dex
002388r 3  CA                           dex
002389r 3  CA                           dex
00238Ar 3               
00238Ar 3                               ; Get four bytes off of Return Stack. This assumes that
00238Ar 3                               ; we took a subroutine jump here so the first two entries
00238Ar 3                               ; are the return address
00238Ar 3  8A                           txa
00238Br 3  BA                           tsx
00238Cr 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
00238Dr 3  7A                           ply
00238Er 3  AA                           tax
00238Fr 3               
00238Fr 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
00238Fr 3                               ; the return address for this word. This is a whole lot
00238Fr 3                               ; easier on the 65816
00238Fr 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002392r 3  95 00                        sta 0,x
002394r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002397r 3  95 01                        sta 1,x
002399r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
00239Cr 3  95 02                        sta 2,x
00239Er 3  B9 06 01                     lda $0106,y     ; MSB of top entry
0023A1r 3  95 03                        sta 3,x
0023A3r 3               
0023A3r 3  60           z_two_r_fetch:  rts
0023A4r 3               
0023A4r 3               
0023A4r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
0023A4r 3               ; ## "2r>"  auto  ANS core ext
0023A4r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
0023A4r 3                       ; Pull top two entries from Return Stack.
0023A4r 3                       ;
0023A4r 3                       ; Is the same as
0023A4r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
0023A4r 3                       ; the top value on the ReturnStack for a STC Forth is the
0023A4r 3                       ; return address, which we need to get out of the way first.
0023A4r 3                       ; Native compile needs to be handled as a special case.
0023A4r 3                       ; """
0023A4r 3               xt_two_r_from:
0023A4r 3                               ; save the return address
0023A4r 3  68                           pla                     ; LSB
0023A5r 3  85 24                        sta tmp1
0023A7r 3  68                           pla                     ; MSB
0023A8r 3  85 25                        sta tmp1+1
0023AAr 3               
0023AAr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0023AAr 3               
0023AAr 3               		; make room on stack
0023AAr 3  CA                           dex
0023ABr 3  CA                           dex
0023ACr 3  CA                           dex
0023ADr 3  CA                           dex
0023AEr 3               
0023AEr 3                               ; In theory, we should test for underflow on the Return
0023AEr 3                               ; Stack. However, given the traffic there with an STC
0023AEr 3                               ; Forth, that's probably not really useful
0023AEr 3               
0023AEr 3                               ; now we can access the data
0023AEr 3  68                           pla                     ; LSB
0023AFr 3  95 00                        sta 0,x
0023B1r 3  68                           pla                     ; MSB
0023B2r 3  95 01                        sta 1,x
0023B4r 3               
0023B4r 3  68                           pla                     ; LSB
0023B5r 3  95 02                        sta 2,x
0023B7r 3  68                           pla                     ; MSB
0023B8r 3  95 03                        sta 3,x
0023BAr 3               
0023BAr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0023BAr 3               
0023BAr 3                               ; restore return address
0023BAr 3  A5 25                        lda tmp1+1              ; MSB
0023BCr 3  48                           pha
0023BDr 3  A5 24                        lda tmp1                ; LSB
0023BFr 3  48                           pha
0023C0r 3               
0023C0r 3  60           z_two_r_from:   rts
0023C1r 3               
0023C1r 3               
0023C1r 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
0023C1r 3               ; ## "2/"  auto  ANS core
0023C1r 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
0023C1r 3               xt_two_slash:
0023C1r 3  20 rr rr                     jsr underflow_1
0023C4r 3               
0023C4r 3                               ; We can't just LSR the LSB and ROR the MSB because that
0023C4r 3                               ; would do bad things to the sign
0023C4r 3  B5 01                        lda 1,x
0023C6r 3  0A                           asl                     ; save the sign
0023C7r 3  76 01                        ror 1,x
0023C9r 3  76 00                        ror 0,x
0023CBr 3               
0023CBr 3  60           z_two_slash:    rts
0023CCr 3               
0023CCr 3               
0023CCr 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
0023CCr 3               ; ## "2*"  auto  ANS core
0023CCr 3                       ; """https://forth-standard.org/standard/core/TwoTimes
0023CCr 3                       ;
0023CCr 3                       ; Also used for CELLS
0023CCr 3                       ; """
0023CCr 3               xt_two_star:
0023CCr 3               xt_cells:
0023CCr 3  20 rr rr                     jsr underflow_1
0023CFr 3               
0023CFr 3  16 00                        asl 0,x
0023D1r 3  36 01                        rol 1,x
0023D3r 3               z_cells:
0023D3r 3  60           z_two_star:     rts
0023D4r 3               
0023D4r 3               
0023D4r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
0023D4r 3               ; ## "2!"  auto  ANS core
0023D4r 3                       ; """https://forth-standard.org/standard/core/TwoStore
0023D4r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
0023D4r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
0023D4r 3                       ; """
0023D4r 3               xt_two_store:
0023D4r 3  20 rr rr                     jsr underflow_3
0023D7r 3               
0023D7r 3  B5 00                        lda 0,x
0023D9r 3  85 24                        sta tmp1
0023DBr 3  B4 01                        ldy 1,x
0023DDr 3  84 25                        sty tmp1+1
0023DFr 3               
0023DFr 3  E8                           inx
0023E0r 3  E8                           inx
0023E1r 3               
0023E1r 3  B5 00                        lda 0,x         ; copy MSB
0023E3r 3  92 24                        sta (tmp1)
0023E5r 3  B5 01                        lda 1,x         ; copy next
0023E7r 3  A0 01                        ldy #1
0023E9r 3  91 24                        sta (tmp1),y
0023EBr 3  B5 02                        lda 2,x         ; copy next
0023EDr 3  C8                           iny
0023EEr 3  91 24                        sta (tmp1),y
0023F0r 3  B5 03                        lda 3,x         ; copy MSB
0023F2r 3  C8                           iny
0023F3r 3  91 24                        sta (tmp1),y
0023F5r 3               
0023F5r 3  E8                           inx             ; 2DROP
0023F6r 3  E8                           inx
0023F7r 3  E8                           inx
0023F8r 3  E8                           inx
0023F9r 3               
0023F9r 3  60           z_two_store:    rts
0023FAr 3               
0023FAr 3               
0023FAr 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
0023FAr 3               ; ## "2swap"  auto  ANS core
0023FAr 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
0023FAr 3               xt_two_swap:
0023FAr 3  20 rr rr                     jsr underflow_4
0023FDr 3               
0023FDr 3                               ; 0 <-> 4
0023FDr 3  B5 00                        lda 0,x
0023FFr 3  B4 04                        ldy 4,x
002401r 3  95 04                        sta 4,x
002403r 3  94 00                        sty 0,x
002405r 3               
002405r 3                               ; 1 <-> 5
002405r 3  B5 01                        lda 1,x
002407r 3  B4 05                        ldy 5,x
002409r 3  95 05                        sta 5,x
00240Br 3  94 01                        sty 1,x
00240Dr 3               
00240Dr 3                               ; 2 <-> 6
00240Dr 3  B5 02                        lda 2,x
00240Fr 3  B4 06                        ldy 6,x
002411r 3  95 06                        sta 6,x
002413r 3  94 02                        sty 2,x
002415r 3               
002415r 3                               ; 3 <-> 7
002415r 3  B5 03                        lda 3,x
002417r 3  B4 07                        ldy 7,x
002419r 3  95 07                        sta 7,x
00241Br 3  94 03                        sty 3,x
00241Dr 3               
00241Dr 3  60           z_two_swap:     rts
00241Er 3               
00241Er 3               
00241Er 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
00241Er 3               ; ## "2>r"  auto  ANS core ext
00241Er 3                       ; """https://forth-standard.org/standard/core/TwotoR
00241Er 3                       ; Push top two entries to Return Stack.
00241Er 3                       ;
00241Er 3                       ; The same as SWAP >R >R
00241Er 3                       ; except that if we jumped here, the return address will be in the
00241Er 3                       ; way. May not be natively compiled unless we're clever and use
00241Er 3                       ; special routines.
00241Er 3                       ; """
00241Er 3               xt_two_to_r:
00241Er 3                               ; save the return address
00241Er 3  68                           pla             ; LSB
00241Fr 3  85 24                        sta tmp1
002421r 3  68                           pla             ; MSB
002422r 3  85 25                        sta tmp1+1
002424r 3               
002424r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002424r 3               
002424r 3  20 rr rr                     jsr underflow_2
002427r 3               
002427r 3                               ; now we can move the data
002427r 3  B5 03                        lda 3,x         ; MSB
002429r 3  48                           pha
00242Ar 3  B5 02                        lda 2,x         ; LSB
00242Cr 3  48                           pha
00242Dr 3               
00242Dr 3                               ; now we can move the data
00242Dr 3  B5 01                        lda 1,x         ; MSB
00242Fr 3  48                           pha
002430r 3  B5 00                        lda 0,x         ; LSB
002432r 3  48                           pha
002433r 3               
002433r 3  E8                           inx
002434r 3  E8                           inx
002435r 3  E8                           inx
002436r 3  E8                           inx
002437r 3               
002437r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002437r 3               
002437r 3                               ; restore return address
002437r 3  A5 25                        lda tmp1+1      ; MSB
002439r 3  48                           pha
00243Ar 3  A5 24                        lda tmp1        ; LSB
00243Cr 3  48                           pha
00243Dr 3               
00243Dr 3  60           z_two_to_r:     rts
00243Er 3               
00243Er 3               
00243Er 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
00243Er 3               ; ## "2constant"  auto  ANS double
00243Er 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
00243Er 3                       ;
00243Er 3                       ; Based on the Forth code
00243Er 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
00243Er 3                       ; """
00243Er 3               xt_two_constant:
00243Er 3  20 rr rr                     jsr underflow_2
002441r 3               
002441r 3  20 rr rr                     jsr xt_create
002444r 3  20 rr rr                     jsr xt_swap
002447r 3  20 rr rr                     jsr xt_comma
00244Ar 3  20 rr rr                     jsr xt_comma
00244Dr 3               
00244Dr 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002450r 3  20 rr rr                     jsr dodoes
002453r 3               
002453r 3  20 rr rr                     jsr xt_dup
002456r 3  20 rr rr                     jsr xt_fetch
002459r 3  20 rr rr                     jsr xt_swap
00245Cr 3  20 rr rr                     jsr xt_cell_plus
00245Fr 3  20 rr rr                     jsr xt_fetch
002462r 3               
002462r 3  60           z_two_constant: rts
002463r 3               
002463r 3               
002463r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002463r 3               ; ## "2literal"  auto  ANS double
002463r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002463r 3                       ; Based on the Forth code
002463r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002463r 3                       ; """
002463r 3               xt_two_literal:
002463r 3  20 rr rr                     jsr underflow_2 ; double number
002466r 3               
002466r 3  20 rr rr                     jsr xt_swap
002469r 3  20 rr rr                     jsr xt_literal
00246Cr 3  20 rr rr                     jsr xt_literal
00246Fr 3               
00246Fr 3  60           z_two_literal:  rts
002470r 3               
002470r 3               
002470r 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002470r 3               ; ## "2variable"  auto  ANS double
002470r 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002470r 3                       ; The variable is not initialized to zero.
002470r 3                       ;
002470r 3                       ; This can be realized in Forth as either
002470r 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002470r 3                       ; """
002470r 3               xt_two_variable:
002470r 3                               ; We just let CRATE and ALLOT do the heavy lifting
002470r 3  20 rr rr                     jsr xt_create
002473r 3               
002473r 3  CA                           dex
002474r 3  CA                           dex
002475r 3  A9 04                        lda #4
002477r 3  95 00                        sta 0,x
002479r 3  74 01                        stz 1,x
00247Br 3               
00247Br 3  20 rr rr                     jsr xt_allot
00247Er 3               
00247Er 3  60           z_two_variable: rts
00247Fr 3               
00247Fr 3               
00247Fr 3               ; ## TYPE ( addr u -- ) "Print string"
00247Fr 3               ; ## "type"  auto  ANS core
00247Fr 3                       ; """https://forth-standard.org/standard/core/TYPE
00247Fr 3                       ; Works through EMIT to allow OUTPUT revectoring.
00247Fr 3                       ; """
00247Fr 3               
00247Fr 3               xt_type:
00247Fr 3  20 rr rr                     jsr underflow_2
002482r 3               
002482r 3                               ; Save the starting address into tmp1
002482r 3  B5 02                        lda 2,x
002484r 3  85 24                        sta tmp1
002486r 3  B5 03                        lda 3,x
002488r 3  85 25                        sta tmp1+1
00248Ar 3               @loop:
00248Ar 3                               ; done if length is zero
00248Ar 3  B5 00                        lda 0,x
00248Cr 3  15 01                        ora 1,x
00248Er 3  F0 15                        beq @done
002490r 3               
002490r 3                               ; Send the current character
002490r 3  B2 24                        lda (tmp1)
002492r 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002495r 3               
002495r 3                               ; Move the address along (in tmp1)
002495r 3  E6 24                        inc tmp1
002497r 3  D0 02                        bne @1
002499r 3  E6 25                        inc tmp1+1
00249Br 3               @1:
00249Br 3                               ; Reduce the count (on the data stack)
00249Br 3  B5 00                        lda 0,x
00249Dr 3  D0 02                        bne @2
00249Fr 3  D6 01                        dec 1,x
0024A1r 3               @2:
0024A1r 3  D6 00                        dec 0,x
0024A3r 3               
0024A3r 3  80 E5                        bra @loop
0024A5r 3               @done:
0024A5r 3  E8                           inx
0024A6r 3  E8                           inx
0024A7r 3  E8                           inx
0024A8r 3  E8                           inx
0024A9r 3               
0024A9r 3  60           z_type:         rts
0024AAr 3               
0024AAr 3               
0024AAr 3               
0024AAr 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
0024AAr 3               ; ## "u."  tested  ANS core
0024AAr 3                       ; """https://forth-standard.org/standard/core/Ud
0024AAr 3                       ;
0024AAr 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
0024AAr 3                       ; We use the internal assembler function print_u followed
0024AAr 3                       ; by a single space
0024AAr 3                       ; """
0024AAr 3               xt_u_dot:
0024AAr 3  20 rr rr                     jsr underflow_1
0024ADr 3               
0024ADr 3  20 rr rr                     jsr print_u
0024B0r 3  A9 20                        lda #AscSP
0024B2r 3  20 rr rr                     jsr emit_a
0024B5r 3               
0024B5r 3  60           z_u_dot:        rts
0024B6r 3               
0024B6r 3               
0024B6r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
0024B6r 3               ; ## "u.r"  tested  ANS core ext
0024B6r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
0024B6r 3               xt_u_dot_r:
0024B6r 3  20 rr rr                     jsr underflow_2
0024B9r 3               
0024B9r 3  20 rr rr                     jsr xt_to_r
0024BCr 3  20 rr rr                     jsr xt_zero
0024BFr 3  20 rr rr                     jsr xt_less_number_sign
0024C2r 3  20 rr rr                     jsr xt_number_sign_s
0024C5r 3  20 rr rr                     jsr xt_number_sign_greater
0024C8r 3  20 rr rr                     jsr xt_r_from
0024CBr 3  20 rr rr                     jsr xt_over
0024CEr 3  20 rr rr                     jsr xt_minus
0024D1r 3  20 rr rr                     jsr xt_spaces
0024D4r 3  20 rr rr                     jsr xt_type
0024D7r 3               
0024D7r 3  60           z_u_dot_r:      rts
0024D8r 3               
0024D8r 3               
0024D8r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
0024D8r 3               ; ## "u>"  auto  ANS core ext
0024D8r 3                       ; """https://forth-standard.org/standard/core/Umore"""
0024D8r 3               xt_u_greater_than:
0024D8r 3  20 rr rr                     jsr underflow_2
0024DBr 3               
0024DBr 3  B5 00                        lda 0,x
0024DDr 3  D5 02                        cmp 2,x
0024DFr 3  B5 01                        lda 1,x
0024E1r 3  F5 03                        sbc 3,x
0024E3r 3  E8                           inx
0024E4r 3  E8                           inx
0024E5r 3               
0024E5r 3  A9 00                        lda #0
0024E7r 3  69 FF                        adc #$ff
0024E9r 3  95 00                        sta 0,x         ; store flag
0024EBr 3  95 01                        sta 1,x
0024EDr 3               
0024EDr 3  60           z_u_greater_than:    rts
0024EEr 3               
0024EEr 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
0024EEr 3               ; ## "u<"  auto  ANS core
0024EEr 3                       ; """https://forth-standard.org/standard/core/Uless"""
0024EEr 3               xt_u_less_than:
0024EEr 3  20 rr rr                     jsr underflow_2
0024F1r 3               
0024F1r 3  B5 02                        lda 2,x
0024F3r 3  D5 00                        cmp 0,x
0024F5r 3  B5 03                        lda 3,x
0024F7r 3  F5 01                        sbc 1,x
0024F9r 3  E8                           inx
0024FAr 3  E8                           inx
0024FBr 3               
0024FBr 3  A9 00                        lda #0
0024FDr 3  69 FF                        adc #$ff
0024FFr 3  95 00                        sta 0,x         ; store flag
002501r 3  95 01                        sta 1,x
002503r 3               
002503r 3  60           z_u_less_than:    rts
002504r 3               
002504r 3               
002504r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002504r 3               ; ## "ud."  auto  Tali double
002504r 3                       ;
002504r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002504r 3                       ; """
002504r 3               xt_ud_dot:
002504r 3  20 rr rr                     jsr underflow_2 ; double number
002507r 3               
002507r 3  20 rr rr                     jsr xt_less_number_sign
00250Ar 3  20 rr rr                     jsr xt_number_sign_s
00250Dr 3  20 rr rr                     jsr xt_number_sign_greater
002510r 3  20 rr rr                     jsr xt_type
002513r 3  20 rr rr                     jsr xt_space
002516r 3               
002516r 3  60           z_ud_dot:        rts
002517r 3               
002517r 3               
002517r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002517r 3               ; ## "ud.r"  auto  Tali double
002517r 3                       ;
002517r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002517r 3                       ; """
002517r 3               xt_ud_dot_r:
002517r 3  20 rr rr                     jsr underflow_3
00251Ar 3               
00251Ar 3  20 rr rr                     jsr xt_to_r
00251Dr 3  20 rr rr                     jsr xt_less_number_sign
002520r 3  20 rr rr                     jsr xt_number_sign_s
002523r 3  20 rr rr                     jsr xt_number_sign_greater
002526r 3  20 rr rr                     jsr xt_r_from
002529r 3  20 rr rr                     jsr xt_over
00252Cr 3  20 rr rr                     jsr xt_minus
00252Fr 3  20 rr rr                     jsr xt_spaces
002532r 3  20 rr rr                     jsr xt_type
002535r 3               
002535r 3  60           z_ud_dot_r:      rts
002536r 3               
002536r 3               
002536r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002536r 3               ; ## "um/mod"  auto  ANS core
002536r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002536r 3                       ; Divide double cell number by single cell number, returning the
002536r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002536r 3                       ; This is the basic division operation all others use. Based on FIG
002536r 3                       ; Forth code, modified by Garth Wilson, see
002536r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002536r 3                       ;
002536r 3                       ; This uses tmp1, tmp1+1, and tmptos
002536r 3                       ; """
002536r 3               
002536r 3               xt_um_slash_mod:
002536r 3  20 rr rr                     jsr underflow_3
002539r 3               
002539r 3                               ; catch division by zero
002539r 3  B5 00                        lda 0,x
00253Br 3  15 01                        ora 1,x
00253Dr 3  D0 05                        bne @not_zero
00253Fr 3               
00253Fr 3  A9 04                        lda #err_divzero
002541r 3  4C rr rr                     jmp error
002544r 3               
002544r 3               @not_zero:
002544r 3                               ; We loop 17 times
002544r 3  A9 11                        lda #17
002546r 3  85 2C                        sta tmptos
002548r 3               
002548r 3               @loop:
002548r 3                               ; rotate low cell of dividend one bit left (LSB)
002548r 3  36 04                        rol 4,x
00254Ar 3  36 05                        rol 5,x
00254Cr 3               
00254Cr 3                               ; loop control
00254Cr 3  C6 2C                        dec tmptos
00254Er 3  F0 22                        beq @done
002550r 3               
002550r 3                               ; rotate high cell of dividend one bit left (MSB)
002550r 3  36 02                        rol 2,x
002552r 3  36 03                        rol 3,x
002554r 3               
002554r 3  64 24                        stz tmp1        ; store the bit we got from hi cell (MSB)
002556r 3  26 24                        rol tmp1
002558r 3               
002558r 3                               ; subtract dividend hi cell minus divisor
002558r 3  38                           sec
002559r 3  B5 02                        lda 2,x
00255Br 3  F5 00                        sbc 0,x
00255Dr 3  85 25                        sta tmp1+1
00255Fr 3  B5 03                        lda 3,x
002561r 3  F5 01                        sbc 1,x
002563r 3               
002563r 3  A8                           tay
002564r 3  A5 24                        lda tmp1
002566r 3  E9 00                        sbc #0
002568r 3  90 DE                        bcc @loop
00256Ar 3               
00256Ar 3                               ; make result new dividend high cell
00256Ar 3  A5 25                        lda tmp1+1
00256Cr 3  95 02                        sta 2,x
00256Er 3  94 03                        sty 3,x         ; used as temp storage
002570r 3               
002570r 3  80 D6                        bra @loop
002572r 3               @done:
002572r 3  E8                           inx
002573r 3  E8                           inx
002574r 3               
002574r 3  20 rr rr                     jsr xt_swap
002577r 3               
002577r 3  60           z_um_slash_mod: rts
002578r 3               
002578r 3               
002578r 3               
002578r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002578r 3               ; ## "um*"  auto  ANS core
002578r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002578r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002578r 3                       ; Old Forth versions such as FIG Forth call this U*
002578r 3                       ;
002578r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002578r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002578r 3                       ; discussion.
002578r 3                       ;
002578r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002578r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002578r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002578r 3                       ;
002578r 3                       ; Consider switching to a table-supported version based on
002578r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002578r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002578r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002578r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002578r 3                       ; """
002578r 3               
002578r 3               xt_um_star:
002578r 3  20 rr rr                     jsr underflow_2
00257Br 3               
00257Br 3                               ; to eliminate clc inside the loop, the value at
00257Br 3                               ; tmp1 is reduced by 1 in advance
00257Br 3  18                           clc
00257Cr 3  B5 00                        lda 0,x         ; copy TOS to tmp2
00257Er 3  E9 00                        sbc #0
002580r 3  85 26                        sta tmp2
002582r 3               
002582r 3  B5 01                        lda 1,x
002584r 3  E9 00                        sbc #0
002586r 3  90 31                        bcc @zero       ; is TOS zero?
002588r 3  85 27                        sta tmp2+1
00258Ar 3               
00258Ar 3  A9 00                        lda #0
00258Cr 3  85 24                        sta tmp1
00258Er 3  86 28                        stx tmp3        ; tested for exit from outer loop
002590r 3  CA                           dex
002591r 3  CA                           dex
002592r 3               
002592r 3               @outer_loop:
002592r 3  A0 08                        ldy #8          ; counter inner loop
002594r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002596r 3               
002596r 3               @inner_loop:
002596r 3  90 0C                        bcc @no_add
002598r 3  85 25                        sta tmp1+1      ; save time, don't CLC
00259Ar 3  A5 24                        lda tmp1
00259Cr 3  65 26                        adc tmp2
00259Er 3  85 24                        sta tmp1
0025A0r 3  A5 25                        lda tmp1+1
0025A2r 3  65 27                        adc tmp2+1
0025A4r 3               
0025A4r 3               @no_add:
0025A4r 3  6A                           ror
0025A5r 3  66 24                        ror tmp1
0025A7r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
0025A9r 3               
0025A9r 3  88                           dey
0025AAr 3  D0 EA                        bne @inner_loop ; go back for one more shift?
0025ACr 3               
0025ACr 3  E8                           inx
0025ADr 3  E4 28                        cpx tmp3
0025AFr 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
0025B1r 3               
0025B1r 3                               ; all done, store high word of result
0025B1r 3  95 01                        sta 1,x
0025B3r 3  A5 24                        lda tmp1
0025B5r 3  95 00                        sta 0,x
0025B7r 3  80 04                        bra @done
0025B9r 3               
0025B9r 3               @zero:
0025B9r 3  74 02                        stz 2,x
0025BBr 3  74 03                        stz 3,x
0025BDr 3               @done:
0025BDr 3  60           z_um_star:      rts
0025BEr 3               
0025BEr 3               
0025BEr 3               
0025BEr 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
0025BEr 3               ; ## "unloop"  auto  ANS core
0025BEr 3                       ; """https://forth-standard.org/standard/core/UNLOOP
0025BEr 3                       ;
0025BEr 3                       ; Note that 6xPLA uses just as many bytes as a loop would
0025BEr 3                       ; """
0025BEr 3               xt_unloop:
0025BEr 3                               ; Drop fudge number (limit/start from DO/?DO off the
0025BEr 3                               ; return stack
0025BEr 3  68                           pla
0025BFr 3  68                           pla
0025C0r 3  68                           pla
0025C1r 3  68                           pla
0025C2r 3               
0025C2r 3                               ; Now drop the LEAVE address that was below them off
0025C2r 3                               ; the Return Stack as well
0025C2r 3  68                           pla
0025C3r 3  68                           pla
0025C4r 3               
0025C4r 3  60           z_unloop:       rts
0025C5r 3               
0025C5r 3               
0025C5r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
0025C5r 3               ; ## "until"  auto  ANS core
0025C5r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
0025C5r 3               xt_until:
0025C5r 3                               ; Compile a 0BRANCH
0025C5r 3  A0 rr                        ldy #>zero_branch_runtime
0025C7r 3  A9 rr                        lda #<zero_branch_runtime
0025C9r 3  20 rr rr                     jsr cmpl_subroutine
0025CCr 3               
0025CCr 3                               ; The address to loop back to is on the stack.
0025CCr 3                               ; Just compile it as the destination for the
0025CCr 3                               ; 0branch.
0025CCr 3  20 rr rr                     jsr xt_comma
0025CFr 3               
0025CFr 3  60           z_until:        rts
0025D0r 3               
0025D0r 3               
0025D0r 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
0025D0r 3               ; ## "unused"  auto  ANS core ext
0025D0r 3                       ; """https://forth-standard.org/standard/core/UNUSED
0025D0r 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
0025D0r 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
0025D0r 3                       ; defaults to $400
0025D0r 3                       ; """
0025D0r 3               xt_unused:
0025D0r 3  CA                           dex
0025D1r 3  CA                           dex
0025D2r 3               
0025D2r 3  A9 FD                        lda #<cp_end
0025D4r 3  38                           sec
0025D5r 3  E5 00                        sbc cp
0025D7r 3  95 00                        sta 0,x
0025D9r 3               
0025D9r 3  A9 77                        lda #>cp_end
0025DBr 3  E5 01                        sbc cp+1
0025DDr 3  95 01                        sta 1,x
0025DFr 3               
0025DFr 3  60           z_unused:       rts
0025E0r 3               
0025E0r 3               
0025E0r 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
0025E0r 3               ; ## "update"  auto  ANS block
0025E0r 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
0025E0r 3               xt_update:
0025E0r 3                               ; Turn on the dirty bit. We can't use TSB here because it only
0025E0r 3                               ; has Absolute and Direct Pages addressing modes
0025E0r 3  A0 2C                        ldy #buffstatus_offset
0025E2r 3  B1 1E                        lda (up),y
0025E4r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
0025E6r 3  91 1E                        sta (up),y
0025E8r 3               
0025E8r 3  60           z_update:       rts
0025E9r 3               
0025E9r 3               
0025E9r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
0025E9r 3               ; ## "useraddr"  tested  Tali Forth
0025E9r 3               xt_useraddr:
0025E9r 3  CA                           dex
0025EAr 3  CA                           dex
0025EBr 3  A9 1E                        lda #<up
0025EDr 3  95 00                        sta 0,x
0025EFr 3  A9 00                        lda #>up
0025F1r 3  95 01                        sta 1,x
0025F3r 3               
0025F3r 3  60           z_useraddr:     rts
0025F4r 3               
0025F4r 3               
0025F4r 3               ; ## VALUE ( n "name" -- ) "Define a value"
0025F4r 3               ; ## "value"  auto  ANS core
0025F4r 3                       ; """https://forth-standard.org/standard/core/VALUE
0025F4r 3                       ;
0025F4r 3                       ; This is a dummy header for the WORDLIST. The actual code is
0025F4r 3                       ; identical to that of CONSTANT
0025F4r 3                       ; """
0025F4r 3               
0025F4r 3               
0025F4r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
0025F4r 3               ; ## "variable"  auto  ANS core
0025F4r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
0025F4r 3                       ; There are various Forth definitions for this word, such as
0025F4r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
0025F4r 3                       ; second one so the variable is initialized to zero
0025F4r 3                       ; """
0025F4r 3               xt_variable:
0025F4r 3                               ; we let CREATE do the heavy lifting
0025F4r 3  20 rr rr                     jsr xt_create
0025F7r 3               
0025F7r 3                               ; there is no "STZ (CP)" so we have to do this the hard
0025F7r 3                               ; way
0025F7r 3  A9 00                        lda #0
0025F9r 3               
0025F9r 3  92 00                        sta (cp)
0025FBr 3  E6 00                        inc cp
0025FDr 3  D0 02                        bne @1
0025FFr 3  E6 01                        inc cp+1
002601r 3               @1:
002601r 3  92 00                        sta (cp)
002603r 3  E6 00                        inc cp
002605r 3  D0 02                        bne @2
002607r 3  E6 01                        inc cp+1
002609r 3               @2:
002609r 3                               ; Now we need to adjust the length of the complete word by two
002609r 3  20 rr rr                     jsr adjust_z
00260Cr 3               
00260Cr 3  60           z_variable:     rts
00260Dr 3               
00260Dr 3               
00260Dr 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
00260Dr 3               ; ## "while"  auto  ANS core
00260Dr 3                       ; """http://forth-standard.org/standard/core/WHILE"""
00260Dr 3               xt_while:
00260Dr 3                               ; Compile a 0branch
00260Dr 3  A0 rr                        ldy #>zero_branch_runtime
00260Fr 3  A9 rr                        lda #<zero_branch_runtime
002611r 3  20 rr rr                     jsr cmpl_subroutine
002614r 3               
002614r 3                               ; Put the address (here) where the destination
002614r 3                               ; address needs to go so it can be put there later.
002614r 3  20 rr rr                     jsr xt_here
002617r 3               
002617r 3                               ; Fill in the destination address with 0 for now.
002617r 3  20 rr rr                     jsr xt_zero
00261Ar 3  20 rr rr                     jsr xt_comma
00261Dr 3               
00261Dr 3                               ; Swap the two addresses on the stack.
00261Dr 3  20 rr rr                     jsr xt_swap
002620r 3               
002620r 3  60           z_while:        rts
002621r 3               
002621r 3               
002621r 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
002621r 3               ; ## "within"  auto  ANS core ext
002621r 3                       ; """https://forth-standard.org/standard/core/WITHIN
002621r 3                       ;
002621r 3                       ; This an assembler version of the ANS Forth implementation
002621r 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
002621r 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
002621r 3                       ; ROT TUCK > -ROT > INVERT AND
002621r 3                       ; """"
002621r 3               xt_within:
002621r 3  20 rr rr                     jsr underflow_3
002624r 3               
002624r 3  20 rr rr                     jsr xt_over
002627r 3  20 rr rr                     jsr xt_minus
00262Ar 3  20 rr rr                     jsr xt_to_r
00262Dr 3  20 rr rr                     jsr xt_minus
002630r 3  20 rr rr                     jsr xt_r_from
002633r 3  20 rr rr                     jsr xt_u_less_than
002636r 3               
002636r 3  60           z_within:       rts
002637r 3               
002637r 3               
002637r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002637r 3               ; ## "word"  auto  ANS core
002637r 3                       ; """https://forth-standard.org/standard/core/WORD
002637r 3                       ; Obsolete parsing word included for backwards compatibility only.
002637r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002637r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002637r 3                       ; Returns the result as a counted string (requires COUNT to convert
002637r 3                       ; to modern format), and inserts a space after the string. See "Forth
002637r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002637r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002637r 3                       ; for discussions of why you shouldn't be using WORD anymore.
002637r 3                       ;
002637r 3                       ; Forth
002637r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002637r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002637r 3                       ; """
002637r 3               
002637r 3               xt_word:
002637r 3  20 rr rr                     jsr underflow_1
00263Ar 3               
00263Ar 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
00263Ar 3                               ; but unlike PARSE
00263Ar 3  A4 0C                        ldy toin                ; >IN
00263Cr 3               @loop:
00263Cr 3  C4 0A                        cpy ciblen              ; quit if end of input
00263Er 3  F0 09                        beq @found_char
002640r 3  B1 08                        lda (cib),y
002642r 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002644r 3  D0 03                        bne @found_char
002646r 3               
002646r 3  C8                           iny
002647r 3  80 F3                        bra @loop
002649r 3               @found_char:
002649r 3                               ; Save index of where word starts
002649r 3  84 0C                        sty toin
00264Br 3               
00264Br 3                               ; The real work is done by parse
00264Br 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
00264Er 3               
00264Er 3                               ; Convert the modern ( addr u ) string format to obsolete
00264Er 3                               ; ( caddr ) format. We just do this in the Dictionary
00264Er 3  B5 00                        lda 0,x
002650r 3  92 00                        sta (cp)                ; Save length of string
002652r 3  48                           pha                     ; Keep copy of length for later
002653r 3               
002653r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002656r 3  A5 00                        lda cp
002658r 3  18                           clc
002659r 3  69 01                        adc #1
00265Br 3  95 02                        sta 2,x                 ; LSB of CP
00265Dr 3  A5 01                        lda cp+1
00265Fr 3  69 00                        adc #0
002661r 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002663r 3               
002663r 3  20 rr rr                     jsr xt_move
002666r 3               
002666r 3                               ; Return caddr
002666r 3  CA                           dex
002667r 3  CA                           dex
002668r 3  A5 00                        lda cp
00266Ar 3  95 00                        sta 0,x
00266Cr 3  A5 01                        lda cp+1
00266Er 3  95 01                        sta 1,x
002670r 3               
002670r 3                               ; Adjust CP
002670r 3  68                           pla                     ; length of string
002671r 3  18                           clc
002672r 3  65 00                        adc cp
002674r 3  85 00                        sta cp
002676r 3  A5 01                        lda cp+1
002678r 3  69 00                        adc #0                  ; we only need the carry
00267Ar 3  85 01                        sta cp+1
00267Cr 3  60           z_word:         rts
00267Dr 3               
00267Dr 3               
00267Dr 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
00267Dr 3               ; ## "wordlist" auto ANS search
00267Dr 3                       ; """https://forth-standard.org/standard/search/WORDLIST
00267Dr 3                       ; See the tutorial on Wordlists and the Search Order for
00267Dr 3                       ; more information.
00267Dr 3                       ; """
00267Dr 3               
00267Dr 3               xt_wordlist:
00267Dr 3                               ; Get the current number of wordlists
00267Dr 3  A0 05                        ldy #num_wordlists_offset
00267Fr 3  B1 1E                        lda (up),y      ; This is a byte variable, so only
002681r 3                                               ; the LSB needs to be checked.
002681r 3               
002681r 3                               ; See if we are already at the max.
002681r 3  C9 0C                        cmp #max_wordlists
002683r 3  D0 05                        bne @ok
002685r 3               
002685r 3                               ; Print an error message if all wordlists used.
002685r 3  A9 0B                        lda #err_wordlist
002687r 3  4C rr rr                     jmp error
00268Ar 3               
00268Ar 3               @ok:
00268Ar 3  1A                           inc             ; Increment the wordlist#
00268Br 3  91 1E                        sta (up),y      ; Save it into byte variable #wordlists
00268Dr 3  CA                           dex             ; and put it on the stack.
00268Er 3  CA                           dex
00268Fr 3  95 00                        sta 0,x
002691r 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002693r 3               
002693r 3  60           z_wordlist:     rts
002694r 3               
002694r 3               
002694r 3               
002694r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002694r 3               ; ## "words"  tested  ANS tools
002694r 3                       ; """https://forth-standard.org/standard/tools/WORDS
002694r 3                       ; This is pretty much only used at the command line so we can
002694r 3                       ; be slow and try to save space.
002694r 3                       ; """
002694r 3               
002694r 3               xt_words:
002694r 3                               ; we follow Gforth by starting on the next
002694r 3                               ; line
002694r 3  20 rr rr                     jsr xt_cr
002697r 3               
002697r 3                               ; We pretty-format the output by inserting a line break
002697r 3                               ; before the end of the line. We can get away with pushing
002697r 3                               ; the counter to the stack because this is usually an
002697r 3                               ; interactive word and speed is not that important
002697r 3  A9 00                        lda #0
002699r 3  48                           pha
00269Ar 3               
00269Ar 3                               ; Set up for traversing the wordlist search order.
00269Ar 3  CA                           dex                     ; Make room on the stack for
00269Br 3  CA                           dex                     ; a dictionary pointer.
00269Cr 3  64 28                        stz tmp3                ; Start at the beginning of
00269Er 3                                                       ; the search order.
00269Er 3               @wordlist_loop:
00269Er 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
0026A0r 3  A5 28                        lda tmp3
0026A2r 3  D1 1E                        cmp (up),y              ; See if we are done.
0026A4r 3  D0 02                        bne @have_wordlist
0026A6r 3               
0026A6r 3                               ; We ran out of wordlists to search.
0026A6r 3  80 44                        bra @words_done
0026A8r 3               
0026A8r 3               @have_wordlist:
0026A8r 3                               ; start with last word in Dictionary
0026A8r 3                               ; Get the current wordlist id
0026A8r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
0026A9r 3  69 1F                        adc #search_order_offset
0026ABr 3  A8                           tay
0026ACr 3  B1 1E                        lda (up),y              ; Get the index into array WORDLISTS
0026AEr 3               
0026AEr 3                               ; Get the DP for that wordlist.
0026AEr 3  0A                           asl                     ; Turn offset into cells offset.
0026AFr 3  18                           clc
0026B0r 3  69 06                        adc #wordlists_offset
0026B2r 3  A8                           tay
0026B3r 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
0026B5r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
0026B7r 3  C8                           iny
0026B8r 3  B1 1E                        lda (up),y
0026BAr 3  95 01                        sta 1,x
0026BCr 3               
0026BCr 3               @loop:
0026BCr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0026BFr 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
0026C2r 3               
0026C2r 3                               ; Insert line break if we're about to go past the end of the
0026C2r 3                               ; line
0026C2r 3  68                           pla
0026C3r 3  18                           clc
0026C4r 3  75 00                        adc 0,x
0026C6r 3  1A                           inc                     ; don't forget the space between words
0026C7r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
0026C9r 3  90 05                        bcc @1
0026CBr 3               
0026CBr 3  20 rr rr                     jsr xt_cr
0026CEr 3  A9 00                        lda #0
0026D0r 3               @1:
0026D0r 3  48                           pha
0026D1r 3  20 rr rr                     jsr xt_type             ; ( nt )
0026D4r 3               
0026D4r 3  A9 20                        lda #AscSP
0026D6r 3  20 rr rr                     jsr emit_a
0026D9r 3               
0026D9r 3                               ; get next word, which begins two down
0026D9r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0026DCr 3  20 rr rr                     jsr xt_one_plus         ; 1+
0026DFr 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
0026E2r 3               
0026E2r 3                               ; if next address is zero, we're done
0026E2r 3  B5 00                        lda 0,x
0026E4r 3  15 01                        ora 1,x
0026E6r 3  D0 D4                        bne @loop
0026E8r 3               
0026E8r 3                               ; Move on to the next wordlist in the search order.
0026E8r 3  E6 28                        inc tmp3
0026EAr 3  80 B2                        bra @wordlist_loop
0026ECr 3               
0026ECr 3               @words_done:
0026ECr 3  68                           pla                     ; dump counter
0026EDr 3               
0026EDr 3  E8                           inx
0026EEr 3  E8                           inx
0026EFr 3               
0026EFr 3  60           z_words:        rts
0026F0r 3               
0026F0r 3               
0026F0r 3               
0026F0r 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
0026F0r 3               ; ## "wordsize"  auto  Tali Forth
0026F0r 3                       ; """Given an word's name token (nt), return the size of the
0026F0r 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
0026F0r 3                       ; count the final RTS.
0026F0r 3                       ; """
0026F0r 3               xt_wordsize:
0026F0r 3  20 rr rr                     jsr underflow_1
0026F3r 3               
0026F3r 3                               ; We get the start address of the word from its header entry
0026F3r 3                               ; for the start of the actual code (execution token, xt)
0026F3r 3                               ; which is four bytes down, and the pointer to the end of the
0026F3r 3                               ; code (z_word, six bytes down)
0026F3r 3  B5 00                        lda 0,x
0026F5r 3  85 24                        sta tmp1
0026F7r 3  B5 01                        lda 1,x
0026F9r 3  85 25                        sta tmp1+1
0026FBr 3               
0026FBr 3  A0 06                        ldy #6
0026FDr 3  B1 24                        lda (tmp1),y    ; LSB of z
0026FFr 3  88                           dey
002700r 3  88                           dey
002701r 3               
002701r 3  38                           sec
002702r 3  F1 24                        sbc (tmp1),y    ; LSB of xt
002704r 3  95 00                        sta 0,x
002706r 3               
002706r 3  A0 07                        ldy #7
002708r 3  B1 24                        lda (tmp1),y    ; MSB of z
00270Ar 3  88                           dey
00270Br 3  88                           dey
00270Cr 3               
00270Cr 3  F1 24                        sbc (tmp1),y    ; MSB of xt
00270Er 3  95 01                        sta 1,x
002710r 3               
002710r 3  60           z_wordsize:     rts
002711r 3               
002711r 3               
002711r 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
002711r 3               ; ## "xor"  auto  ANS core
002711r 3                       ; """https://forth-standard.org/standard/core/XOR"""
002711r 3               xt_xor:
002711r 3  20 rr rr                     jsr underflow_2
002714r 3               
002714r 3  B5 00                        lda 0,x
002716r 3  55 02                        eor 2,x
002718r 3  95 02                        sta 2,x
00271Ar 3               
00271Ar 3  B5 01                        lda 1,x
00271Cr 3  55 03                        eor 3,x
00271Er 3  95 03                        sta 3,x
002720r 3               
002720r 3  E8                           inx
002721r 3  E8                           inx
002722r 3               
002722r 3  60           z_xor:          rts
002723r 3               
002723r 3               
002723r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002723r 3               ; ## "0"  auto  Tali Forth
002723r 3                       ; """The disassembler assumes that this routine does not use Y. Note
002723r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002723r 3                       ; is 0."""
002723r 3               xt_case:
002723r 3               xt_forth_wordlist:
002723r 3               xt_zero:
002723r 3  CA                           dex             ; push
002724r 3  CA                           dex
002725r 3  74 00                        stz 0,x
002727r 3  74 01                        stz 1,x
002729r 3               z_case:
002729r 3               z_forth_wordlist:
002729r 3               z_zero:
002729r 3  60                           rts
00272Ar 3               
00272Ar 3               
00272Ar 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
00272Ar 3               ; ## "0="  auto  ANS core
00272Ar 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
00272Ar 3               
00272Ar 3               xt_zero_equal:
00272Ar 3  20 rr rr                     jsr underflow_1
00272Dr 3               
00272Dr 3  B5 00                        lda 0,x
00272Fr 3  15 01                        ora 1,x
002731r 3  F0 04                        beq @zero
002733r 3               
002733r 3                               ; not a zero, so we need a FALSE flag (0)
002733r 3  A9 00                        lda #0
002735r 3  80 02                        bra @store
002737r 3               @zero:
002737r 3                               ; We have a zero, so we need a TRUE flag (-1)
002737r 3  A9 FF                        lda #$ff
002739r 3               @store:
002739r 3  95 00                        sta 0,x
00273Br 3  95 01                        sta 1,x
00273Dr 3               
00273Dr 3  60           z_zero_equal:   rts
00273Er 3               
00273Er 3               
00273Er 3               
00273Er 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
00273Er 3               ; ## "0>"  auto  ANS core ext
00273Er 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
00273Er 3               
00273Er 3               xt_zero_greater:
00273Er 3  20 rr rr                     jsr underflow_1
002741r 3               
002741r 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002743r 3               
002743r 3  B5 01                        lda 1,x         ; MSB
002745r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002747r 3  15 00                        ora 0,x
002749r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
00274Br 3               
00274Br 3  88                           dey             ; TOS is postive, make true
00274Cr 3               @done:
00274Cr 3  98                           tya
00274Dr 3  95 00                        sta 0,x
00274Fr 3  95 01                        sta 1,x
002751r 3               
002751r 3  60           z_zero_greater: rts
002752r 3               
002752r 3               
002752r 3               
002752r 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
002752r 3               ; ## "0<"  auto  ANS core
002752r 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
002752r 3               
002752r 3               xt_zero_less:
002752r 3  20 rr rr                     jsr underflow_1
002755r 3               
002755r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002757r 3               
002757r 3  B5 01                        lda 1,x         ; MSB
002759r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
00275Br 3               
00275Br 3  88                           dey             ; TOS is negative, make TRUE
00275Cr 3               @done:
00275Cr 3  98                           tya
00275Dr 3  95 00                        sta 0,x
00275Fr 3  95 01                        sta 1,x
002761r 3               
002761r 3  60           z_zero_less:    rts
002762r 3               
002762r 3               
002762r 3               
002762r 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
002762r 3               ; ## "0<>"  auto  ANS core ext
002762r 3                       ; """https://forth-standard.org/standard/core/Zerone"""
002762r 3               
002762r 3               xt_zero_unequal:
002762r 3  20 rr rr                     jsr underflow_1
002765r 3               
002765r 3  A0 00                        ldy #0          ; default false
002767r 3               
002767r 3  B5 00                        lda 0,x
002769r 3  15 01                        ora 1,x
00276Br 3  F0 01                        beq @got_zero
00276Dr 3               
00276Dr 3  88                           dey
00276Er 3               @got_zero:
00276Er 3  98                           tya
00276Fr 3  95 00                        sta 0,x
002771r 3  95 01                        sta 1,x
002773r 3               
002773r 3  60           z_zero_unequal: rts
002774r 3               
002774r 3               
002774r 3               
002774r 3               ; ==========================================================
002774r 3               ; EDITOR words
002774r 3               
002774r 3               ; This routine is used by both enter-screen and erase-screen
002774r 3               ; to get a buffer for the given screen number and set SCR to
002774r 3               ; the given screen number.  This word is not in the dictionary.
002774r 3               xt_editor_screen_helper:
002774r 3  20 rr rr                     jsr xt_dup
002777r 3  20 rr rr                     jsr xt_scr
00277Ar 3  20 rr rr                     jsr xt_store
00277Dr 3  20 rr rr                     jsr xt_buffer
002780r 3               z_editor_screen_helper:
002780r 3  60                           rts
002781r 3               
002781r 3               
002781r 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
002781r 3               ; ## "enter-screen"  auto  Tali Editor
002781r 3               
002781r 3               xt_editor_enter_screen:
002781r 3                               ; Set the variable SCR and get a buffer for the
002781r 3                               ; given screen number.
002781r 3  20 rr rr                     jsr xt_editor_screen_helper
002784r 3               
002784r 3                               ; Drop the buffer address.
002784r 3  20 rr rr                     jsr xt_drop
002787r 3               
002787r 3                               ; Overwrite the lines one at a time.
002787r 3  64 2E                        stz editor1
002789r 3               @prompt_loop:
002789r 3                               ; Put the current line number on the stack.
002789r 3  CA                           dex
00278Ar 3  CA                           dex
00278Br 3  A5 2E                        lda editor1
00278Dr 3  95 00                        sta 0,x
00278Fr 3  74 01                        stz 1,x
002791r 3               
002791r 3                               ; Use the O word to prompt for overwrite.
002791r 3  20 rr rr                     jsr xt_editor_o
002794r 3               
002794r 3                               ; Move on to the next line.
002794r 3  E6 2E                        inc editor1
002796r 3  A9 10                        lda #16
002798r 3  C5 2E                        cmp editor1
00279Ar 3  D0 ED                        bne @prompt_loop
00279Cr 3               
00279Cr 3               z_editor_enter_screen:
00279Cr 3  60                           rts
00279Dr 3               
00279Dr 3               
00279Dr 3               
00279Dr 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
00279Dr 3               ; ## "erase-screen"  tested  Tali Editor
00279Dr 3               xt_editor_erase_screen:
00279Dr 3                               ; Set the variable SCR and get a buffer for the
00279Dr 3                               ; given screen number.
00279Dr 3  20 rr rr                     jsr xt_editor_screen_helper
0027A0r 3               
0027A0r 3                               ; Put 1024 (chars/screen) on stack.
0027A0r 3  CA                           dex
0027A1r 3  CA                           dex
0027A2r 3  74 00                        stz 0,x
0027A4r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
0027A6r 3  95 01                        sta 1,x
0027A8r 3               
0027A8r 3                               ; Erase the entire block (fill with spaces).
0027A8r 3  20 rr rr                     jsr xt_blank
0027ABr 3               
0027ABr 3                               ; Mark buffer as updated.
0027ABr 3  20 rr rr                     jsr xt_update
0027AEr 3               
0027AEr 3               z_editor_erase_screen:
0027AEr 3  60                           rts
0027AFr 3               
0027AFr 3               
0027AFr 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
0027AFr 3               ; ## "el"  tested  Tali Editor
0027AFr 3               xt_editor_el:
0027AFr 3                               ; Turn the line number into buffer offset.
0027AFr 3                               ; This also loads the block into the buffer if it's
0027AFr 3                               ; not there for some reason.
0027AFr 3  20 rr rr                     jsr xt_editor_line
0027B2r 3               
0027B2r 3                               ; Put 64 (# of chars/line) on the stack.
0027B2r 3  CA                           dex
0027B3r 3  CA                           dex
0027B4r 3  A9 40                        lda #64
0027B6r 3  95 00                        sta 0,x
0027B8r 3  74 01                        stz 1,x
0027BAr 3               
0027BAr 3                               ; Fill with spaces.
0027BAr 3  20 rr rr                     jsr xt_blank
0027BDr 3               
0027BDr 3                               ; Mark buffer as updated.
0027BDr 3  20 rr rr                     jsr xt_update
0027C0r 3               
0027C0r 3  60           z_editor_el:    rts
0027C1r 3               
0027C1r 3               
0027C1r 3               ; ## EDITOR_L ( -- ) "List the current screen"
0027C1r 3               ; ## "l"  tested  Tali Editor
0027C1r 3               
0027C1r 3               xt_editor_l:
0027C1r 3                               ; Load the current screen
0027C1r 3  CA                           dex             ; Put SCR on the stack.
0027C2r 3  CA                           dex
0027C3r 3  A0 02                        ldy #scr_offset
0027C5r 3  B1 1E                        lda (up),y
0027C7r 3  95 00                        sta 0,x
0027C9r 3  C8                           iny
0027CAr 3  B1 1E                        lda (up),y
0027CCr 3  95 01                        sta 1,x
0027CEr 3  20 rr rr                     jsr xt_block    ; Get the current screen.
0027D1r 3               
0027D1r 3  20 rr rr                     jsr xt_cr
0027D4r 3               
0027D4r 3                               ; Print the screen number.
0027D4r 3                               ; We're using sliteral, so we need to set up the
0027D4r 3                               ; appropriate data structure (see sliteral)
0027D4r 3  80 08                        bra @after_screen_msg
0027D6r 3               
0027D6r 3               @screen_msg:
0027D6r 3  53 63 72 65                  .byte "Screen #"
0027DAr 3  65 6E 20 23  
0027DEr 3               
0027DEr 3               @after_screen_msg:
0027DEr 3  20 rr rr                     jsr sliteral_runtime
0027E1r 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
0027E5r 3               
0027E5r 3  20 rr rr                     jsr xt_type
0027E8r 3               
0027E8r 3                               ; Put the screen number and printed size for u.r on the stack.
0027E8r 3  20 rr rr                     jsr xt_scr
0027EBr 3  20 rr rr                     jsr xt_fetch
0027EEr 3  CA                           dex
0027EFr 3  CA                           dex
0027F0r 3  A9 04                        lda #4          ; four spaces
0027F2r 3  95 00                        sta 0,x
0027F4r 3  74 01                        stz 1,x
0027F6r 3  20 rr rr                     jsr xt_u_dot_r
0027F9r 3               
0027F9r 3                               ; The address of the buffer is currently on the stack.
0027F9r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
0027F9r 3                               ; keep track of the line number in tmp3.
0027F9r 3  64 28                        stz tmp3
0027FBr 3               
0027FBr 3               @line_loop:
0027FBr 3  20 rr rr                     jsr xt_cr
0027FEr 3               
0027FEr 3                               ; Print the line number (2-space fixed width)
0027FEr 3  CA                           dex
0027FFr 3  CA                           dex
002800r 3  CA                           dex
002801r 3  CA                           dex
002802r 3  74 03                        stz 3,x
002804r 3  A5 28                        lda tmp3
002806r 3  95 02                        sta 2,x
002808r 3  74 01                        stz 1,x
00280Ar 3  A9 02                        lda #2
00280Cr 3  95 00                        sta 0,x
00280Er 3  20 rr rr                     jsr xt_u_dot_r
002811r 3  20 rr rr                     jsr xt_space
002814r 3               
002814r 3                               ; Print one line using the address on the stack.
002814r 3  20 rr rr                     jsr xt_dup
002817r 3  CA                           dex
002818r 3  CA                           dex
002819r 3  A9 40                        lda #64
00281Br 3  95 00                        sta 0,x
00281Dr 3  74 01                        stz 1,x
00281Fr 3  20 rr rr                     jsr xt_type
002822r 3               
002822r 3                               ; Add 64 to the address on the stack to move to the next line.
002822r 3  18                           clc
002823r 3  A9 40                        lda #64
002825r 3  75 00                        adc 0,x
002827r 3  95 00                        sta 0,x
002829r 3  B5 01                        lda 1,x
00282Br 3  69 00                        adc #0      ; Add carry
00282Dr 3  95 01                        sta 1,x
00282Fr 3               
00282Fr 3                               ; Increment the line number (held in tmp3)
00282Fr 3  E6 28                        inc tmp3
002831r 3               
002831r 3                               ; See if we are done.
002831r 3  A5 28                        lda tmp3
002833r 3  C9 10                        cmp #16
002835r 3  D0 C4                        bne @line_loop
002837r 3               
002837r 3  20 rr rr                     jsr xt_cr
00283Ar 3                               ; Drop the address on the stack.
00283Ar 3  E8                           inx
00283Br 3  E8                           inx
00283Cr 3               
00283Cr 3  60           z_editor_l:            rts
00283Dr 3               
00283Dr 3               
00283Dr 3               
00283Dr 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
00283Dr 3               ; ## "line"  tested  Tali Editor
00283Dr 3               
00283Dr 3               xt_editor_line:
00283Dr 3  20 rr rr                     jsr underflow_1
002840r 3               
002840r 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
002840r 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
002842r 3               @shift_tos_left:
002842r 3  16 00                        asl 0,x         ; Shift TOS to the left
002844r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
002846r 3  88                           dey
002847r 3  D0 F9                        bne @shift_tos_left
002849r 3                               ; Load the current screen into a buffer
002849r 3                               ; and get the buffer address
002849r 3  20 rr rr                     jsr xt_scr
00284Cr 3  20 rr rr                     jsr xt_fetch
00284Fr 3  20 rr rr                     jsr xt_block
002852r 3               
002852r 3                               ; Add the offset to the buffer base address.
002852r 3  20 rr rr                     jsr xt_plus
002855r 3               
002855r 3  60           z_editor_line:  rts
002856r 3               
002856r 3               
002856r 3               
002856r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
002856r 3               ; ## "o"  tested  Tali Editor
002856r 3               xt_editor_o:
002856r 3                               ; Print prompt
002856r 3  20 rr rr                     jsr xt_cr
002859r 3  20 rr rr                     jsr xt_dup
00285Cr 3  20 rr rr                     jsr xt_two
00285Fr 3  20 rr rr                     jsr xt_u_dot_r
002862r 3  20 rr rr                     jsr xt_space
002865r 3  A9 2A                        lda #42         ; ASCII for *
002867r 3  20 rr rr                     jsr emit_a
00286Ar 3  20 rr rr                     jsr xt_space
00286Dr 3               
00286Dr 3                               ; Accept new input (directly into the buffer)
00286Dr 3  20 rr rr                     jsr xt_editor_line
002870r 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
002873r 3  CA                           dex
002874r 3  CA                           dex
002875r 3  A9 40                        lda #64         ; chars/line
002877r 3  95 00                        sta 0,x
002879r 3  74 01                        stz 1,x
00287Br 3  20 rr rr                     jsr xt_accept
00287Er 3               
00287Er 3                               ; Fill the rest with spaces.
00287Er 3                               ; Stack is currently ( line_address numchars_from_accept )
00287Er 3  20 rr rr                     jsr xt_dup
002881r 3  20 rr rr                     jsr xt_not_rote ; -rot
002884r 3  20 rr rr                     jsr xt_plus
002887r 3  CA                           dex
002888r 3  CA                           dex
002889r 3  A9 40                        lda #64         ; chars/line
00288Br 3  95 00                        sta 0,x
00288Dr 3  74 01                        stz 1,x
00288Fr 3  20 rr rr                     jsr xt_rot
002892r 3  20 rr rr                     jsr xt_minus
002895r 3  20 rr rr                     jsr xt_blank
002898r 3               
002898r 3                               ; Mark buffer as updated.
002898r 3  20 rr rr                     jsr xt_update
00289Br 3               
00289Br 3  60           z_editor_o:     rts
00289Cr 3               
00289Cr 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
00289Cr 3               ; ## "lcdput" coded Custom
00289Cr 3               xt_lcdput:
00289Cr 3  20 rr rr                     jsr underflow_1
00289Fr 3               
00289Fr 3  B5 00                        lda 0,x
0028A1r 3               
0028A1r 3  20 rr rr                     jsr lcd_print
0028A4r 3  E8                           inx
0028A5r 3  E8                           inx
0028A6r 3  60           z_lcdput: rts
0028A7r 3               
0028A7r 3               
0028A7r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
0028A7r 3               ; ## "lcdprint"  coded Custom
0028A7r 3               
0028A7r 3               xt_lcdprint:
0028A7r 3  20 rr rr                     jsr underflow_2
0028AAr 3               
0028AAr 3                               ; Save the starting address into tmp1
0028AAr 3  B5 02                        lda 2,x
0028ACr 3  85 24                        sta tmp1
0028AEr 3  B5 03                        lda 3,x
0028B0r 3  85 25                        sta tmp1+1
0028B2r 3               @loop:
0028B2r 3                               ; done if length is zero
0028B2r 3  B5 00                        lda 0,x
0028B4r 3  15 01                        ora 1,x
0028B6r 3  F0 15                        beq @done
0028B8r 3               
0028B8r 3                               ; Send the current character
0028B8r 3  B2 24                        lda (tmp1)
0028BAr 3  20 rr rr                     jsr lcd_print      ; avoids stack foolery
0028BDr 3               
0028BDr 3                               ; Move the address along (in tmp1)
0028BDr 3  E6 24                        inc tmp1
0028BFr 3  D0 02                        bne @1
0028C1r 3  E6 25                        inc tmp1+1
0028C3r 3               @1:
0028C3r 3                               ; Reduce the count (on the data stack)
0028C3r 3  B5 00                        lda 0,x
0028C5r 3  D0 02                        bne @2
0028C7r 3  D6 01                        dec 1,x
0028C9r 3               @2:
0028C9r 3  D6 00                        dec 0,x
0028CBr 3               
0028CBr 3  80 E5                        bra @loop
0028CDr 3               @done:
0028CDr 3  E8                           inx
0028CEr 3  E8                           inx
0028CFr 3  E8                           inx
0028D0r 3  E8                           inx
0028D1r 3               
0028D1r 3  60           z_lcdprint:         rts
0028D2r 3               
0028D2r 3               
0028D2r 3               
0028D2r 3               ; ## CLS ( -- ) "clea VGA screen"
0028D2r 3               ; ## "cls" coded Custom
0028D2r 3               xt_cls:
0028D2r 3  20 rr rr                     jsr vga_clear
0028D5r 3               
0028D5r 3  60           z_cls: rts
0028D6r 3               
0028D6r 3               
0028D6r 3               ; ## SPI_INIT ( -- ) "Init SPI system"
0028D6r 3               ; ## "spi_init" coded Custom
0028D6r 3               xt_spi_init:
0028D6r 3  20 rr rr                     jsr spi_init
0028D9r 3  60           z_spi_init: rts
0028DAr 3               
0028DAr 3               
0028DAr 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
0028DAr 3               ; ## "spi_clk_toggle" coded Custom
0028DAr 3               xt_spi_clk_toggle:
0028DAr 3  20 rr rr                     jsr spi_clk_toggle
0028DDr 3  60           z_spi_clk_toggle: rts
0028DEr 3               
0028DEr 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
0028DEr 3               ; ## "spi_select" coded Custom
0028DEr 3               xt_spi_select:
0028DEr 3  20 rr rr                     jsr underflow_1
0028E1r 3               
0028E1r 3  B5 00                        lda 0,x
0028E3r 3               
0028E3r 3  20 rr rr                     jsr spi_select
0028E6r 3  E8                           inx
0028E7r 3  E8                           inx
0028E8r 3  60           z_spi_select: rts
0028E9r 3               
0028E9r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
0028E9r 3               ; ## "spi_transceive" coded Custom
0028E9r 3               xt_spi_transceive:
0028E9r 3  20 rr rr                     jsr underflow_1
0028ECr 3               
0028ECr 3  B5 00                        lda 0,x
0028EEr 3               
0028EEr 3  20 rr rr                     jsr spi_transceive
0028F1r 3  95 00                        sta 0,x         ; put return value in TOS
0028F3r 3  74 01                        stz 1,X         ;reset value there
0028F5r 3  60           z_spi_transceive: rts
0028F6r 3               
0028F6r 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
0028F6r 3               ; ## "spi_trasceive" coded Custom
0028F6r 3               xt_sd_init:
0028F6r 3  20 rr rr                     jsr underflow_1
0028F9r 3               
0028F9r 3  B5 00                        lda 0,x
0028FBr 3               
0028FBr 3  20 rr rr                     jsr sd_init
0028FEr 3  95 00                        sta 0,x         ; put return value in TOS
002900r 3  74 01                        stz 1,X         ;reset value there
002902r 3  60           z_sd_init: rts
002903r 3               
002903r 3               ; TODO add routine to send a block of data in memory via SPI
002903r 3               ; similar to lcdprint
002903r 3               
002903r 3               ; END
002903r 3               
002903r 3               
002903r 2               .include "assembler.asm"        ; SAN assembler
002903r 3               ; Assembler for Tali Forth 2
002903r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
002903r 3               ; First version: 07. Nov 2014 (as tasm65c02)
002903r 3               ; This version: 03. Jan 2019
002903r 3               
002903r 3               ; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
002903r 3               ; is included with
002903r 3               
002903r 3               ;       assembler-wordlist >order
002903r 3               
002903r 3               ; the opcodes are available as normal Forth words. The format is Simpler
002903r 3               ; Assembler Notation (SAN) which separates the opcode completely from the
002903r 3               ; operand (see https://github.com/scotws/SAN). In this case, the operand is
002903r 3               ; entered before the opcode in the postfix Forth notation (for example, "2000
002903r 3               ; lda.#"). See the assembler documenation in the manual for more detail.
002903r 3               
002903r 3               ; The code here was originally used in A Typist's Assembler for the 65c02
002903r 3               ; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
002903r 3               ; version. Tasm65c02 is in the public domain.
002903r 3               
002903r 3               ; This code makes use of the opcode tables stored as part of the disassembler.
002903r 3               
002903r 3               ; ==========================================================
002903r 3               ; MNEMONICS
002903r 3               
002903r 3               ; The assembler instructions are realized as individual Forth words with
002903r 3               ; entries in the assembler wordlist (see header.asm). We pass the opcode in A.
002903r 3               
002903r 3               ; An alterantive method would have been along the lines of
002903r 3               
002903r 3               ;               jsr asm_common
002903r 3               ;               .byte $EA
002903r 3               
002903r 3               ; where the asm_common then uses the address on the Return Stack to pick up the
002903r 3               ; opcode and the length. Though this uses fewer resources, the current version
002903r 3               ; makes up for this by simplifying the code of asm_common.
002903r 3               
002903r 3               ; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
002903r 3               ; SAN and traditional mnemonics are listed after the opcode load instruction.
002903r 3               ; This list was generated by a Python script in the tools folder, see there for
002903r 3               ; more detail.
002903r 3               
002903r 3               assembler:              ; used to calculate size of assembler code
002903r 3               
002903r 3               xt_asm_adc_h:   ; adc.# \ ADC #nn
002903r 3  A9 69                        lda #$69
002905r 3  4C rr rr                     jmp asm_common
002908r 3               z_asm_adc_h:
002908r 3               
002908r 3               xt_asm_adc_x:   ; adc.x \ ADC nnnn,X
002908r 3  A9 7D                        lda #$7D
00290Ar 3  4C rr rr                     jmp asm_common
00290Dr 3               z_asm_adc_x:
00290Dr 3               
00290Dr 3               xt_asm_adc_y:   ; adc.y \ ADC nnnn,Y
00290Dr 3  A9 79                        lda #$79
00290Fr 3  4C rr rr                     jmp asm_common
002912r 3               z_asm_adc_y:
002912r 3               
002912r 3               xt_asm_adc_z:   ; adc.z \ ADC nn
002912r 3  A9 65                        lda #$65
002914r 3  4C rr rr                     jmp asm_common
002917r 3               z_asm_adc_z:
002917r 3               
002917r 3               xt_asm_adc_zi:  ; adc.zi \ ADC (nn)
002917r 3  A9 72                        lda #$72
002919r 3  4C rr rr                     jmp asm_common
00291Cr 3               z_asm_adc_zi:
00291Cr 3               
00291Cr 3               xt_asm_adc_ziy: ; adc.ziy \ ADC (nn),Y
00291Cr 3  A9 71                        lda #$71
00291Er 3  4C rr rr                     jmp asm_common
002921r 3               z_asm_adc_ziy:
002921r 3               
002921r 3               xt_asm_adc_zx:  ; adc.zx \ ADC nn,X
002921r 3  A9 75                        lda #$75
002923r 3  4C rr rr                     jmp asm_common
002926r 3               z_asm_adc_zx:
002926r 3               
002926r 3               xt_asm_adc_zxi: ; adc.zxi \ ADC (nn,X)
002926r 3  A9 61                        lda #$61
002928r 3  4C rr rr                     jmp asm_common
00292Br 3               z_asm_adc_zxi:
00292Br 3               
00292Br 3               xt_asm_and:     ; and. \ AND nnnn
00292Br 3  A9 2D                        lda #$2D
00292Dr 3  4C rr rr                     jmp asm_common
002930r 3               z_asm_and:
002930r 3               
002930r 3               xt_asm_and_h:   ; and.# \ AND #nn
002930r 3  A9 29                        lda #$29
002932r 3  4C rr rr                     jmp asm_common
002935r 3               z_asm_and_h:
002935r 3               
002935r 3               xt_asm_and_x:   ; and.x \ AND nnnn,X
002935r 3  A9 3D                        lda #$3D
002937r 3  4C rr rr                     jmp asm_common
00293Ar 3               z_asm_and_x:
00293Ar 3               
00293Ar 3               xt_asm_and_y:   ; and.y \ AND nnnn,Y
00293Ar 3  A9 39                        lda #$39
00293Cr 3  4C rr rr                     jmp asm_common
00293Fr 3               z_asm_and_y:
00293Fr 3               
00293Fr 3               xt_asm_and_z:   ; and.z \ AND nn
00293Fr 3  A9 25                        lda #$25
002941r 3  4C rr rr                     jmp asm_common
002944r 3               z_asm_and_z:
002944r 3               
002944r 3               xt_asm_and_zi:  ; and.zi \ AND (nn)
002944r 3  A9 32                        lda #$32
002946r 3  4C rr rr                     jmp asm_common
002949r 3               z_asm_and_zi:
002949r 3               
002949r 3               xt_asm_and_ziy: ; and.ziy \ AND (nn),Y
002949r 3  A9 31                        lda #$31
00294Br 3  4C rr rr                     jmp asm_common
00294Er 3               z_asm_and_ziy:
00294Er 3               
00294Er 3               xt_asm_and_zx:  ; and.zx \ AND nn,X
00294Er 3  A9 35                        lda #$35
002950r 3  4C rr rr                     jmp asm_common
002953r 3               z_asm_and_zx:
002953r 3               
002953r 3               xt_asm_and_zxi: ; and.zxi \ AND (nn,X)
002953r 3  A9 21                        lda #$21
002955r 3  4C rr rr                     jmp asm_common
002958r 3               z_asm_and_zxi:
002958r 3               
002958r 3               xt_asm_asl:     ; asl \ ASL nnnn
002958r 3  A9 0E                        lda #$0E
00295Ar 3  4C rr rr                     jmp asm_common
00295Dr 3               z_asm_asl:
00295Dr 3               
00295Dr 3               xt_asm_asl_a:   ; asl.a \ ASL
00295Dr 3  A9 0A                        lda #$0A
00295Fr 3  4C rr rr                     jmp asm_common
002962r 3               z_asm_asl_a:
002962r 3               
002962r 3               xt_asm_asl_x:   ; asl.x \ ASL nnnn,X
002962r 3  A9 1E                        lda #$1E
002964r 3  4C rr rr                     jmp asm_common
002967r 3               z_asm_asl_x:
002967r 3               
002967r 3               xt_asm_asl_z:   ; asl.z \ ASL nn
002967r 3  A9 06                        lda #$06
002969r 3  4C rr rr                     jmp asm_common
00296Cr 3               z_asm_asl_z:
00296Cr 3               
00296Cr 3               xt_asm_asl_zx:  ; asl.zx \ ASL nn,X
00296Cr 3  A9 16                        lda #$16
00296Er 3  4C rr rr                     jmp asm_common
002971r 3               z_asm_asl_zx:
002971r 3               
002971r 3               xt_asm_bcc:     ; bcc \ BCC
002971r 3  A9 90                        lda #$90
002973r 3  4C rr rr                     jmp asm_common
002976r 3               z_asm_bcc:
002976r 3               
002976r 3               xt_asm_bcs:     ; bcs \ BCS
002976r 3  A9 B0                        lda #$B0
002978r 3  A0 02                        ldy #2
00297Ar 3  4C rr rr                     jmp asm_common
00297Dr 3               z_asm_bcs:
00297Dr 3               
00297Dr 3               xt_asm_beq:     ; beq \ BEQ
00297Dr 3  A9 F0                        lda #$F0
00297Fr 3  4C rr rr                     jmp asm_common
002982r 3               z_asm_beq:
002982r 3               
002982r 3               xt_asm_bit:     ; bit \ BIT nnnn
002982r 3  A9 2C                        lda #$2C
002984r 3  4C rr rr                     jmp asm_common
002987r 3               z_asm_bit:
002987r 3               
002987r 3               xt_asm_bit_h:   ; bit.# \ BIT #nn
002987r 3  A9 89                        lda #$89
002989r 3  4C rr rr                     jmp asm_common
00298Cr 3               z_asm_bit_h:
00298Cr 3               
00298Cr 3               xt_asm_bit_x:   ; bit.x \ BIT nnnn,X
00298Cr 3  A9 3C                        lda #$3C
00298Er 3  4C rr rr                     jmp asm_common
002991r 3               z_asm_bit_x:
002991r 3               
002991r 3               xt_asm_bit_z:   ; bit.z \ BIT nn
002991r 3  A9 24                        lda #$24
002993r 3  4C rr rr                     jmp asm_common
002996r 3               z_asm_bit_z:
002996r 3               
002996r 3               xt_asm_bit_zx:  ; bit.zx \ BIT nn,X
002996r 3  A9 34                        lda #$34
002998r 3  4C rr rr                     jmp asm_common
00299Br 3               z_asm_bit_zx:
00299Br 3               
00299Br 3               xt_asm_bmi:     ; bmi \ BMI
00299Br 3  A9 30                        lda #$30
00299Dr 3  4C rr rr                     jmp asm_common
0029A0r 3               z_asm_bmi:
0029A0r 3               
0029A0r 3               xt_asm_bne:     ; bne \ BNE
0029A0r 3  A9 D0                        lda #$D0
0029A2r 3  4C rr rr                     jmp asm_common
0029A5r 3               z_asm_bne:
0029A5r 3               
0029A5r 3               xt_asm_bpl:     ; bpl \ BPL
0029A5r 3  A9 10                        lda #$10
0029A7r 3  4C rr rr                     jmp asm_common
0029AAr 3               z_asm_bpl:
0029AAr 3               
0029AAr 3               xt_asm_bra:     ; bra \ BRA
0029AAr 3  A9 80                        lda #$80
0029ACr 3  4C rr rr                     jmp asm_common
0029AFr 3               z_asm_bra:
0029AFr 3               
0029AFr 3               xt_asm_brk:     ; brk \ BRK
0029AFr 3  A9 00                        lda #$00
0029B1r 3  4C rr rr                     jmp asm_common
0029B4r 3               z_asm_brk:
0029B4r 3               
0029B4r 3               xt_asm_bvc:     ; bvc \ BVC
0029B4r 3  A9 50                        lda #$50
0029B6r 3  4C rr rr                     jmp asm_common
0029B9r 3               z_asm_bvc:
0029B9r 3               
0029B9r 3               xt_asm_bvs:     ; bvs \ BVS
0029B9r 3  A9 70                        lda #$70
0029BBr 3  4C rr rr                     jmp asm_common
0029BEr 3               z_asm_bvs:
0029BEr 3               
0029BEr 3               xt_asm_clc:     ; clc \ CLC
0029BEr 3  A9 18                        lda #$18
0029C0r 3  4C rr rr                     jmp asm_common
0029C3r 3               z_asm_clc:
0029C3r 3               
0029C3r 3               xt_asm_cld:     ; cld \ CLD
0029C3r 3  A9 D8                        lda #$D8
0029C5r 3  4C rr rr                     jmp asm_common
0029C8r 3               z_asm_cld:
0029C8r 3               
0029C8r 3               xt_asm_cli:     ; cli \ CLI
0029C8r 3  A9 58                        lda #$58
0029CAr 3  4C rr rr                     jmp asm_common
0029CDr 3               z_asm_cli:
0029CDr 3               
0029CDr 3               xt_asm_clv:     ; clv \ CLV
0029CDr 3  A9 B8                        lda #$B8
0029CFr 3  4C rr rr                     jmp asm_common
0029D2r 3               z_asm_clv:
0029D2r 3               
0029D2r 3               xt_asm_cmp:     ; cmp \ CMP nnnn
0029D2r 3  A9 CD                        lda #$CD
0029D4r 3  4C rr rr                     jmp asm_common
0029D7r 3               z_asm_cmp:
0029D7r 3               
0029D7r 3               xt_asm_cmp_h:   ; cmp.# \ CMP #nn
0029D7r 3  A9 C9                        lda #$C9
0029D9r 3  4C rr rr                     jmp asm_common
0029DCr 3               z_asm_cmp_h:
0029DCr 3               
0029DCr 3               xt_asm_cmp_x:   ; cmp.x \ CMP nnnn,X
0029DCr 3  A9 DD                        lda #$DD
0029DEr 3  4C rr rr                     jmp asm_common
0029E1r 3               z_asm_cmp_x:
0029E1r 3               
0029E1r 3               xt_asm_cmp_y:   ; cmp.y \ CMP nnnn,Y
0029E1r 3  A9 D9                        lda #$D9
0029E3r 3  4C rr rr                     jmp asm_common
0029E6r 3               z_asm_cmp_y:
0029E6r 3               
0029E6r 3               xt_asm_cmp_z:   ; cmp.z \ CMP nn
0029E6r 3  A9 C5                        lda #$C5
0029E8r 3  4C rr rr                     jmp asm_common
0029EBr 3               z_asm_cmp_z:
0029EBr 3               
0029EBr 3               xt_asm_cmp_zi:  ; cmp.zi \ CMP (nn)
0029EBr 3  A9 D2                        lda #$D2
0029EDr 3  4C rr rr                     jmp asm_common
0029F0r 3               z_asm_cmp_zi:
0029F0r 3               
0029F0r 3               xt_asm_cmp_ziy: ; cmp.ziy \ CMP (nn),Y
0029F0r 3  A9 D1                        lda #$D1
0029F2r 3  4C rr rr                     jmp asm_common
0029F5r 3               z_asm_cmp_ziy:
0029F5r 3               
0029F5r 3               xt_asm_cmp_zx:  ; cmp.zx \ CMP nn,X
0029F5r 3  A9 D5                        lda #$D5
0029F7r 3  4C rr rr                     jmp asm_common
0029FAr 3               z_asm_cmp_zx:
0029FAr 3               
0029FAr 3               xt_asm_cmp_zxi: ; cmp.zxi \ CMP (nn,X)
0029FAr 3  A9 C1                        lda #$C1
0029FCr 3  4C rr rr                     jmp asm_common
0029FFr 3               z_asm_cmp_zxi:
0029FFr 3               
0029FFr 3               xt_asm_cpx:     ; cpx \ CPX nnnn
0029FFr 3  A9 EC                        lda #$EC
002A01r 3  4C rr rr                     jmp asm_common
002A04r 3               z_asm_cpx:
002A04r 3               
002A04r 3               xt_asm_cpx_h:   ; cpx.# \ CPX #nn
002A04r 3  A9 E0                        lda #$E0
002A06r 3  4C rr rr                     jmp asm_common
002A09r 3               z_asm_cpx_h:
002A09r 3               
002A09r 3               xt_asm_cpx_z:   ; cpx.z \ CPX nn
002A09r 3  A9 E4                        lda #$E4
002A0Br 3  4C rr rr                     jmp asm_common
002A0Er 3               z_asm_cpx_z:
002A0Er 3               
002A0Er 3               xt_asm_cpy:     ; cpy \ CPY
002A0Er 3  A9 CC                        lda #$CC
002A10r 3  A0 03                        ldy #3
002A12r 3  4C rr rr                     jmp asm_common
002A15r 3               z_asm_cpy:
002A15r 3               
002A15r 3               xt_asm_cpy_h:   ; cpy.# \ CPY #nn
002A15r 3  A9 C0                        lda #$C0
002A17r 3  4C rr rr                     jmp asm_common
002A1Ar 3               z_asm_cpy_h:
002A1Ar 3               
002A1Ar 3               xt_asm_cpy_z:   ; cpy.z \ CPY nn
002A1Ar 3  A9 C4                        lda #$C4
002A1Cr 3  4C rr rr                     jmp asm_common
002A1Fr 3               z_asm_cpy_z:
002A1Fr 3               
002A1Fr 3               xt_asm_dec:     ; dec \ DEC nnnn
002A1Fr 3  A9 CE                        lda #$CE
002A21r 3  4C rr rr                     jmp asm_common
002A24r 3               z_asm_dec:
002A24r 3               
002A24r 3               xt_asm_dec_a:   ; dec.a \ DEC
002A24r 3  A9 3A                        lda #$3A
002A26r 3  4C rr rr                     jmp asm_common
002A29r 3               z_asm_dec_a:
002A29r 3               
002A29r 3               xt_asm_dec_x:   ; dec.x \ DEC nnnn,X
002A29r 3  A9 DE                        lda #$DE
002A2Br 3  4C rr rr                     jmp asm_common
002A2Er 3               z_asm_dec_x:
002A2Er 3               
002A2Er 3               xt_asm_dec_z:   ; dec.z \ DEC nn
002A2Er 3  A9 C6                        lda #$C6
002A30r 3  4C rr rr                     jmp asm_common
002A33r 3               z_asm_dec_z:
002A33r 3               
002A33r 3               xt_asm_dec_zx:  ; dec.zx \ DEC nn,X
002A33r 3  A9 D6                        lda #$D6
002A35r 3  4C rr rr                     jmp asm_common
002A38r 3               z_asm_dec_zx:
002A38r 3               
002A38r 3               xt_asm_dex:     ; dex \ DEX
002A38r 3  A9 CA                        lda #$CA
002A3Ar 3  4C rr rr                     jmp asm_common
002A3Dr 3               z_asm_dex:
002A3Dr 3               
002A3Dr 3               xt_asm_dey:     ; dey \ DEY
002A3Dr 3  A9 88                        lda #$88
002A3Fr 3  4C rr rr                     jmp asm_common
002A42r 3               z_asm_dey:
002A42r 3               
002A42r 3               xt_asm_eor:     ; eor \ EOR nnnn
002A42r 3  A9 4D                        lda #$4D
002A44r 3  4C rr rr                     jmp asm_common
002A47r 3               z_asm_eor:
002A47r 3               
002A47r 3               xt_asm_eor_h:   ; eor.# \ EOR #nn
002A47r 3  A9 49                        lda #$49
002A49r 3  4C rr rr                     jmp asm_common
002A4Cr 3               z_asm_eor_h:
002A4Cr 3               
002A4Cr 3               xt_asm_eor_x:   ; eor.x \ EOR nnnn,X
002A4Cr 3  A9 5D                        lda #$5D
002A4Er 3  4C rr rr                     jmp asm_common
002A51r 3               z_asm_eor_x:
002A51r 3               
002A51r 3               xt_asm_eor_y:   ; eor.y \ EOR nnnn,Y
002A51r 3  A9 59                        lda #$59
002A53r 3  4C rr rr                     jmp asm_common
002A56r 3               z_asm_eor_y:
002A56r 3               
002A56r 3               xt_asm_eor_z:   ; eor.z \ EOR nn
002A56r 3  A9 45                        lda #$45
002A58r 3  4C rr rr                     jmp asm_common
002A5Br 3               z_asm_eor_z:
002A5Br 3               
002A5Br 3               xt_asm_eor_zi:  ; eor.zi \ EOR (nn)
002A5Br 3  A9 52                        lda #$52
002A5Dr 3  4C rr rr                     jmp asm_common
002A60r 3               z_asm_eor_zi:
002A60r 3               
002A60r 3               xt_asm_eor_ziy: ; eor.ziy \ EOR (nn),Y
002A60r 3  A9 51                        lda #$51
002A62r 3  4C rr rr                     jmp asm_common
002A65r 3               z_asm_eor_ziy:
002A65r 3               
002A65r 3               xt_asm_eor_zx:  ; eor.zx \ EOR nn,X
002A65r 3  A9 55                        lda #$55
002A67r 3  4C rr rr                     jmp asm_common
002A6Ar 3               z_asm_eor_zx:
002A6Ar 3               
002A6Ar 3               xt_asm_eor_zxi: ; eor.zxi \ EOR (nn,X)
002A6Ar 3  A9 41                        lda #$41
002A6Cr 3  4C rr rr                     jmp asm_common
002A6Fr 3               z_asm_eor_zxi:
002A6Fr 3               
002A6Fr 3               xt_asm_inc:     ; inc \ INC nnnn
002A6Fr 3  A9 EE                        lda #$EE
002A71r 3  4C rr rr                     jmp asm_common
002A74r 3               z_asm_inc:
002A74r 3               
002A74r 3               xt_asm_inc_a:   ; inc.a \ INC
002A74r 3  A9 1A                        lda #$1A
002A76r 3  4C rr rr                     jmp asm_common
002A79r 3               z_asm_inc_a:
002A79r 3               
002A79r 3               xt_asm_inc_x:   ; inc.x \ INC nnnn,X
002A79r 3  A9 FE                        lda #$FE
002A7Br 3  4C rr rr                     jmp asm_common
002A7Er 3               z_asm_inc_x:
002A7Er 3               
002A7Er 3               xt_asm_inc_z:   ; inc.z \ INC nn
002A7Er 3  A9 E6                        lda #$E6
002A80r 3  4C rr rr                     jmp asm_common
002A83r 3               z_asm_inc_z:
002A83r 3               
002A83r 3               xt_asm_inc_zx:  ; inc.zx \ INC nn,X
002A83r 3  A9 F6                        lda #$F6
002A85r 3  4C rr rr                     jmp asm_common
002A88r 3               z_asm_inc_zx:
002A88r 3               
002A88r 3               xt_asm_inx:     ; inx \ INX
002A88r 3  A9 E8                        lda #$E8
002A8Ar 3  4C rr rr                     jmp asm_common
002A8Dr 3               z_asm_inx:
002A8Dr 3               
002A8Dr 3               xt_asm_iny:     ; iny \ INY
002A8Dr 3  A9 C8                        lda #$C8
002A8Fr 3  4C rr rr                     jmp asm_common
002A92r 3               z_asm_iny:
002A92r 3               
002A92r 3               xt_asm_jmp:     ; jmp \ JMP nnnn
002A92r 3  A9 4C                        lda #$4C
002A94r 3  4C rr rr                     jmp asm_common
002A97r 3               z_asm_jmp:
002A97r 3               
002A97r 3               xt_asm_jmp_i:   ; jmp.i \ JMP (nnnn)
002A97r 3  A9 6C                        lda #$6C
002A99r 3  4C rr rr                     jmp asm_common
002A9Cr 3               z_asm_jmp_i:
002A9Cr 3               
002A9Cr 3               xt_asm_jmp_xi:  ; jmp.xi \ JMP (nnnn,X)
002A9Cr 3  A9 7C                        lda #$7C
002A9Er 3  4C rr rr                     jmp asm_common
002AA1r 3               z_asm_jmp_xi:
002AA1r 3               
002AA1r 3               xt_asm_jsr:     ; jsr \ JSR nnnn
002AA1r 3  A9 20                        lda #$20
002AA3r 3  4C rr rr                     jmp asm_common
002AA6r 3               z_asm_jsr:
002AA6r 3               
002AA6r 3               xt_asm_lda:     ; lda \ LDA nnnn
002AA6r 3  A9 AD                        lda #$AD
002AA8r 3  4C rr rr                     jmp asm_common
002AABr 3               z_asm_lda:
002AABr 3               
002AABr 3               xt_asm_lda_h:   ; lda.# \ LDA #nn
002AABr 3  A9 A9                        lda #$A9
002AADr 3  4C rr rr                     jmp asm_common
002AB0r 3               z_asm_lda_h:
002AB0r 3               
002AB0r 3               xt_asm_lda_x:   ; lda.x \ LDA nnnn,X
002AB0r 3  A9 BD                        lda #$BD
002AB2r 3  4C rr rr                     jmp asm_common
002AB5r 3               z_asm_lda_x:
002AB5r 3               
002AB5r 3               xt_asm_lda_y:   ; lda.y \ LDA nnnn,Y
002AB5r 3  A9 B9                        lda #$B9
002AB7r 3  4C rr rr                     jmp asm_common
002ABAr 3               z_asm_lda_y:
002ABAr 3               
002ABAr 3               xt_asm_lda_z:   ; lda.z \ LDA nn
002ABAr 3  A9 A5                        lda #$A5
002ABCr 3  4C rr rr                     jmp asm_common
002ABFr 3               z_asm_lda_z:
002ABFr 3               
002ABFr 3               xt_asm_lda_zi:  ; lda.zi \ LDA (nn)
002ABFr 3  A9 B2                        lda #$B2
002AC1r 3  4C rr rr                     jmp asm_common
002AC4r 3               z_asm_lda_zi:
002AC4r 3               
002AC4r 3               xt_asm_lda_ziy: ; lda.ziy \ LDA (nn),Y
002AC4r 3  A9 B1                        lda #$B1
002AC6r 3  4C rr rr                     jmp asm_common
002AC9r 3               z_asm_lda_ziy:
002AC9r 3               
002AC9r 3               xt_asm_lda_zx:  ; lda.zx \ LDA nn,X
002AC9r 3  A9 B5                        lda #$B5
002ACBr 3  4C rr rr                     jmp asm_common
002ACEr 3               z_asm_lda_zx:
002ACEr 3               
002ACEr 3               xt_asm_lda_zxi: ; lda.zxi \ LDA (nn,X)
002ACEr 3  A9 A1                        lda #$A1
002AD0r 3  4C rr rr                     jmp asm_common
002AD3r 3               z_asm_lda_zxi:
002AD3r 3               
002AD3r 3               xt_asm_ldx:     ; ldx \ LDX nnnn
002AD3r 3  A9 AE                        lda #$AE
002AD5r 3  4C rr rr                     jmp asm_common
002AD8r 3               z_asm_ldx:
002AD8r 3               
002AD8r 3               xt_asm_ldx_h:   ; ldx.# \ LDX #nn
002AD8r 3  A9 A2                        lda #$A2
002ADAr 3  4C rr rr                     jmp asm_common
002ADDr 3               z_asm_ldx_h:
002ADDr 3               
002ADDr 3               xt_asm_ldx_y:   ; ldx.y \ LDX nnnn,Y
002ADDr 3  A9 BE                        lda #$BE
002ADFr 3  4C rr rr                     jmp asm_common
002AE2r 3               z_asm_ldx_y:
002AE2r 3               
002AE2r 3               xt_asm_ldx_z:   ; ldx.z \ LDX nn
002AE2r 3  A9 A6                        lda #$A6
002AE4r 3  4C rr rr                     jmp asm_common
002AE7r 3               z_asm_ldx_z:
002AE7r 3               
002AE7r 3               xt_asm_ldx_zy:  ; ldx.zy \ LDX nn,Y
002AE7r 3  A9 B6                        lda #$B6
002AE9r 3  4C rr rr                     jmp asm_common
002AECr 3               z_asm_ldx_zy:
002AECr 3               
002AECr 3               xt_asm_ldy:     ; ldy \ LDY nnnn
002AECr 3  A9 AC                        lda #$AC
002AEEr 3  4C rr rr                     jmp asm_common
002AF1r 3               z_asm_ldy:
002AF1r 3               
002AF1r 3               xt_asm_ldy_h:   ; ldy.# \ LDY #nn
002AF1r 3  A9 A0                        lda #$A0
002AF3r 3  4C rr rr                     jmp asm_common
002AF6r 3               z_asm_ldy_h:
002AF6r 3               
002AF6r 3               xt_asm_ldy_x:   ; ldy.x \ LDY nnnn,X
002AF6r 3  A9 BC                        lda #$BC
002AF8r 3  4C rr rr                     jmp asm_common
002AFBr 3               z_asm_ldy_x:
002AFBr 3               
002AFBr 3               xt_asm_ldy_z:   ; ldy.z \ LDY nn
002AFBr 3  A9 A4                        lda #$A4
002AFDr 3  4C rr rr                     jmp asm_common
002B00r 3               z_asm_ldy_z:
002B00r 3               
002B00r 3               xt_asm_ldy_zx:  ; ldy.zx \ LDY nn,X
002B00r 3  A9 B4                        lda #$B4
002B02r 3  4C rr rr                     jmp asm_common
002B05r 3               z_asm_ldy_zx:
002B05r 3               
002B05r 3               xt_asm_lsr:     ; lsr \ LSR nnnn
002B05r 3  A9 4E                        lda #$4E
002B07r 3  4C rr rr                     jmp asm_common
002B0Ar 3               z_asm_lsr:
002B0Ar 3               
002B0Ar 3               xt_asm_lsr_a:   ; lsr.a \ LSR
002B0Ar 3  A9 4A                        lda #$4A
002B0Cr 3  4C rr rr                     jmp asm_common
002B0Fr 3               z_asm_lsr_a:
002B0Fr 3               
002B0Fr 3               xt_asm_lsr_x:   ; lsr.x \ LSR nnnn,X
002B0Fr 3  A9 5E                        lda #$5E
002B11r 3  4C rr rr                     jmp asm_common
002B14r 3               z_asm_lsr_x:
002B14r 3               
002B14r 3               xt_asm_lsr_z:   ; lsr.z \ LSR nn
002B14r 3  A9 46                        lda #$46
002B16r 3  4C rr rr                     jmp asm_common
002B19r 3               z_asm_lsr_z:
002B19r 3               
002B19r 3               xt_asm_lsr_zx:  ; lsr.zx \ LSR nn,X
002B19r 3  A9 56                        lda #$56
002B1Br 3  4C rr rr                     jmp asm_common
002B1Er 3               z_asm_lsr_zx:
002B1Er 3               
002B1Er 3               xt_asm_nop:     ; nop \ NOP
002B1Er 3  A9 EA                        lda #$EA
002B20r 3  4C rr rr                     jmp asm_common
002B23r 3               z_asm_nop:
002B23r 3               
002B23r 3               xt_asm_ora:     ; ora \ ORA nnnn
002B23r 3  A9 0D                        lda #$0D
002B25r 3  4C rr rr                     jmp asm_common
002B28r 3               z_asm_ora:
002B28r 3               
002B28r 3               xt_asm_ora_h:   ; ora.# \ ORA #nn
002B28r 3  A9 09                        lda #$09
002B2Ar 3  4C rr rr                     jmp asm_common
002B2Dr 3               z_asm_ora_h:
002B2Dr 3               
002B2Dr 3               xt_asm_ora_x:   ; ora.x \ ORA nnnn,X
002B2Dr 3  A9 1D                        lda #$1D
002B2Fr 3  4C rr rr                     jmp asm_common
002B32r 3               z_asm_ora_x:
002B32r 3               
002B32r 3               xt_asm_ora_y:   ; ora.y \ ORA nnnn,Y
002B32r 3  A9 19                        lda #$19
002B34r 3  4C rr rr                     jmp asm_common
002B37r 3               z_asm_ora_y:
002B37r 3               
002B37r 3               xt_asm_ora_z:   ; ora.z \ ORA nn
002B37r 3  A9 05                        lda #$05
002B39r 3  4C rr rr                     jmp asm_common
002B3Cr 3               z_asm_ora_z:
002B3Cr 3               
002B3Cr 3               xt_asm_ora_zi:  ; ora.zi \ ORA.ZI
002B3Cr 3  A9 12                        lda #$12
002B3Er 3  A0 02                        ldy #2
002B40r 3  4C rr rr                     jmp asm_common
002B43r 3               z_asm_ora_zi:
002B43r 3               
002B43r 3               xt_asm_ora_ziy: ; ora.ziy \ ORA (nn),Y
002B43r 3  A9 11                        lda #$11
002B45r 3  4C rr rr                     jmp asm_common
002B48r 3               z_asm_ora_ziy:
002B48r 3               
002B48r 3               xt_asm_ora_zx:  ; ora.zx \ ORA nn,X
002B48r 3  A9 15                        lda #$15
002B4Ar 3  4C rr rr                     jmp asm_common
002B4Dr 3               z_asm_ora_zx:
002B4Dr 3               
002B4Dr 3               xt_asm_ora_zxi: ; ora.zxi \ ORA (nn,X)
002B4Dr 3  A9 01                        lda #$01
002B4Fr 3  4C rr rr                     jmp asm_common
002B52r 3               z_asm_ora_zxi:
002B52r 3               
002B52r 3               xt_asm_pha:     ; pha \ PHA
002B52r 3  A9 48                        lda #$48
002B54r 3  4C rr rr                     jmp asm_common
002B57r 3               z_asm_pha:
002B57r 3               
002B57r 3               xt_asm_php:     ; php \ PHP
002B57r 3  A9 08                        lda #$08
002B59r 3  4C rr rr                     jmp asm_common
002B5Cr 3               z_asm_php:
002B5Cr 3               
002B5Cr 3               xt_asm_phx:     ; phx \ PHX
002B5Cr 3  A9 DA                        lda #$DA
002B5Er 3  4C rr rr                     jmp asm_common
002B61r 3               z_asm_phx:
002B61r 3               
002B61r 3               xt_asm_phy:     ; phy \ PHY
002B61r 3  A9 5A                        lda #$5A
002B63r 3  4C rr rr                     jmp asm_common
002B66r 3               z_asm_phy:
002B66r 3               
002B66r 3               xt_asm_pla:     ; pla \ PLA
002B66r 3  A9 68                        lda #$68
002B68r 3  4C rr rr                     jmp asm_common
002B6Br 3               z_asm_pla:
002B6Br 3               
002B6Br 3               xt_asm_plp:     ; plp \ PLP
002B6Br 3  A9 28                        lda #$28
002B6Dr 3  4C rr rr                     jmp asm_common
002B70r 3               z_asm_plp:
002B70r 3               
002B70r 3               xt_asm_plx:     ; plx \ PLX
002B70r 3  A9 FA                        lda #$FA
002B72r 3  4C rr rr                     jmp asm_common
002B75r 3               z_asm_plx:
002B75r 3               
002B75r 3               xt_asm_ply:     ; ply \ PLY
002B75r 3  A9 7A                        lda #$7A
002B77r 3  4C rr rr                     jmp asm_common
002B7Ar 3               z_asm_ply:
002B7Ar 3               
002B7Ar 3               xt_asm_rol:     ; rol \ ROL nnnn
002B7Ar 3  A9 2E                        lda #$2E
002B7Cr 3  4C rr rr                     jmp asm_common
002B7Fr 3               z_asm_rol:
002B7Fr 3               
002B7Fr 3               xt_asm_rol_a:   ; rol.a \ ROL
002B7Fr 3  A9 2A                        lda #$2A
002B81r 3  4C rr rr                     jmp asm_common
002B84r 3               z_asm_rol_a:
002B84r 3               
002B84r 3               xt_asm_rol_x:   ; rol.x \ ROL nnnn,X
002B84r 3  A9 3E                        lda #$3E
002B86r 3  4C rr rr                     jmp asm_common
002B89r 3               z_asm_rol_x:
002B89r 3               
002B89r 3               xt_asm_rol_z:   ; rol.z \ ROL nn
002B89r 3  A9 26                        lda #$26
002B8Br 3  4C rr rr                     jmp asm_common
002B8Er 3               z_asm_rol_z:
002B8Er 3               
002B8Er 3               xt_asm_rol_zx:  ; rol.zx \ ROL nn,X
002B8Er 3  A9 36                        lda #$36
002B90r 3  4C rr rr                     jmp asm_common
002B93r 3               z_asm_rol_zx:
002B93r 3               
002B93r 3               xt_asm_ror:     ; ror \ ROR nnnn
002B93r 3  A9 6E                        lda #$6E
002B95r 3  4C rr rr                     jmp asm_common
002B98r 3               z_asm_ror:
002B98r 3               
002B98r 3               xt_asm_ror_a:   ; ror.a \ ROR
002B98r 3  A9 6A                        lda #$6A
002B9Ar 3  4C rr rr                     jmp asm_common
002B9Dr 3               z_asm_ror_a:
002B9Dr 3               
002B9Dr 3               xt_asm_ror_x:   ; ror.x \ ROR nnnn,X
002B9Dr 3  A9 7E                        lda #$7E
002B9Fr 3  4C rr rr                     jmp asm_common
002BA2r 3               z_asm_ror_x:
002BA2r 3               
002BA2r 3               xt_asm_ror_z:   ; ror.z \ ROR nn
002BA2r 3  A9 66                        lda #$66
002BA4r 3  4C rr rr                     jmp asm_common
002BA7r 3               z_asm_ror_z:
002BA7r 3               
002BA7r 3               xt_asm_ror_zx:  ; ror.zx \ ROR nn,X
002BA7r 3  A9 76                        lda #$76
002BA9r 3  4C rr rr                     jmp asm_common
002BACr 3               z_asm_ror_zx:
002BACr 3               
002BACr 3               xt_asm_rti:     ; rti \ RTI
002BACr 3  A9 40                        lda #$40
002BAEr 3  4C rr rr                     jmp asm_common
002BB1r 3               z_asm_rti:
002BB1r 3               
002BB1r 3               xt_asm_rts:     ; rts \ RTS
002BB1r 3  A9 60                        lda #$60
002BB3r 3  4C rr rr                     jmp asm_common
002BB6r 3               z_asm_rts:
002BB6r 3               
002BB6r 3               xt_asm_sbc:     ; sbc \ SBC nnnn
002BB6r 3  A9 ED                        lda #$ED
002BB8r 3  4C rr rr                     jmp asm_common
002BBBr 3               z_asm_sbc:
002BBBr 3               
002BBBr 3               xt_asm_sbc_h:   ; sbc.# \ SBC #nn
002BBBr 3  A9 E9                        lda #$E9
002BBDr 3  4C rr rr                     jmp asm_common
002BC0r 3               z_asm_sbc_h:
002BC0r 3               
002BC0r 3               xt_asm_sbc_x:   ; sbc.x \ SBC nnnn,X
002BC0r 3  A9 FD                        lda #$FD
002BC2r 3  4C rr rr                     jmp asm_common
002BC5r 3               z_asm_sbc_x:
002BC5r 3               
002BC5r 3               xt_asm_sbc_y:   ; sbc.y \ SBC nnnn,Y
002BC5r 3  A9 F9                        lda #$F9
002BC7r 3  4C rr rr                     jmp asm_common
002BCAr 3               z_asm_sbc_y:
002BCAr 3               
002BCAr 3               xt_asm_sbc_z:   ; sbc.z \ SBC nn
002BCAr 3  A9 E5                        lda #$E5
002BCCr 3  4C rr rr                     jmp asm_common
002BCFr 3               z_asm_sbc_z:
002BCFr 3               
002BCFr 3               xt_asm_sbc_zi:  ; sbc.zi \ SBC (nn)
002BCFr 3  A9 F2                        lda #$F2
002BD1r 3  4C rr rr                     jmp asm_common
002BD4r 3               z_asm_sbc_zi:
002BD4r 3               
002BD4r 3               xt_asm_sbc_ziy: ; sbc.ziy \ SBC (nn),Y
002BD4r 3  A9 F1                        lda #$F1
002BD6r 3  4C rr rr                     jmp asm_common
002BD9r 3               z_asm_sbc_ziy:
002BD9r 3               
002BD9r 3               xt_asm_sbc_zx:  ; sbc.zx \ SBC nn,X
002BD9r 3  A9 F5                        lda #$F5
002BDBr 3  4C rr rr                     jmp asm_common
002BDEr 3               z_asm_sbc_zx:
002BDEr 3               
002BDEr 3               xt_asm_sbc_zxi: ; sbc.zxi \ SBC (nn,X)
002BDEr 3  A9 E1                        lda #$E1
002BE0r 3  80 7C                        bra asm_common  ; <-- limit for BRA instead of JMP
002BE2r 3               z_asm_sbc_zxi:
002BE2r 3               
002BE2r 3               xt_asm_sec:     ; sec \ SEC
002BE2r 3  A9 38                        lda #$38
002BE4r 3  80 78                        bra asm_common
002BE6r 3               z_asm_sec:
002BE6r 3               
002BE6r 3               xt_asm_sed:     ; sed \ SED
002BE6r 3  A9 F8                        lda #$F8
002BE8r 3  80 74                        bra asm_common
002BEAr 3               z_asm_sed:
002BEAr 3               
002BEAr 3               xt_asm_sei:     ; sei \ SEI
002BEAr 3  A9 78                        lda #$78
002BECr 3  80 70                        bra asm_common
002BEEr 3               z_asm_sei:
002BEEr 3               
002BEEr 3               xt_asm_sta:     ; sta \ STA nnnn
002BEEr 3  A9 8D                        lda #$8D
002BF0r 3  80 6C                        bra asm_common
002BF2r 3               z_asm_sta:
002BF2r 3               
002BF2r 3               xt_asm_sta_x:   ; sta.x \ STA nnnn,X
002BF2r 3  A9 9D                        lda #$9D
002BF4r 3  80 68                        bra asm_common
002BF6r 3               z_asm_sta_x:
002BF6r 3               
002BF6r 3               xt_asm_sta_y:   ; sta.y \ STA nnnn,Y
002BF6r 3  A9 99                        lda #$99
002BF8r 3  80 64                        bra asm_common
002BFAr 3               z_asm_sta_y:
002BFAr 3               
002BFAr 3               xt_asm_sta_z:   ; sta.z \ STA nn
002BFAr 3  A9 85                        lda #$85
002BFCr 3  80 60                        bra asm_common
002BFEr 3               z_asm_sta_z:
002BFEr 3               
002BFEr 3               xt_asm_sta_zi:  ; sta.zi \ STA (nn)
002BFEr 3  A9 92                        lda #$92
002C00r 3  80 5C                        bra asm_common
002C02r 3               z_asm_sta_zi:
002C02r 3               
002C02r 3               xt_asm_sta_ziy: ; sta.ziy \ STA (nn),Y
002C02r 3  A9 91                        lda #$91
002C04r 3  80 58                        bra asm_common
002C06r 3               z_asm_sta_ziy:
002C06r 3               
002C06r 3               xt_asm_sta_zx:  ; sta.zx \ STA nn,X
002C06r 3  A9 95                        lda #$95
002C08r 3  80 54                        bra asm_common
002C0Ar 3               z_asm_sta_zx:
002C0Ar 3               
002C0Ar 3               xt_asm_sta_zxi: ; sta.zxi \ STA (nn,X)
002C0Ar 3  A9 81                        lda #$81
002C0Cr 3  80 50                        bra asm_common
002C0Er 3               z_asm_sta_zxi:
002C0Er 3               
002C0Er 3               xt_asm_stx:     ; stx \ STX nnnn
002C0Er 3  A9 8E                        lda #$8E
002C10r 3  80 4C                        bra asm_common
002C12r 3               z_asm_stx:
002C12r 3               
002C12r 3               xt_asm_stx_z:   ; stx.z \ STX nn
002C12r 3  A9 86                        lda #$86
002C14r 3  80 48                        bra asm_common
002C16r 3               z_asm_stx_z:
002C16r 3               
002C16r 3               xt_asm_stx_zy:  ; stx.zy \ STX nn,Y
002C16r 3  A9 96                        lda #$96
002C18r 3  80 44                        bra asm_common
002C1Ar 3               z_asm_stx_zy:
002C1Ar 3               
002C1Ar 3               xt_asm_sty:     ; sty \ STY nnnn
002C1Ar 3  A9 8C                        lda #$8C
002C1Cr 3  80 40                        bra asm_common
002C1Er 3               z_asm_sty:
002C1Er 3               
002C1Er 3               xt_asm_sty_z:   ; sty.z \ STY nn
002C1Er 3  A9 84                        lda #$84
002C20r 3  80 3C                        bra asm_common
002C22r 3               z_asm_sty_z:
002C22r 3               
002C22r 3               xt_asm_sty_zx:  ; sty.zx \ STY nn,X
002C22r 3  A9 94                        lda #$94
002C24r 3  80 38                        bra asm_common
002C26r 3               z_asm_sty_zx:
002C26r 3               
002C26r 3               xt_asm_stz:     ; stz \ STZ nnnn
002C26r 3  A9 9C                        lda #$9C
002C28r 3  80 34                        bra asm_common
002C2Ar 3               z_asm_stz:
002C2Ar 3               
002C2Ar 3               xt_asm_stz_x:   ; stz.x \ STZ nnnn,X
002C2Ar 3  A9 9E                        lda #$9E
002C2Cr 3  80 30                        bra asm_common
002C2Er 3               z_asm_stz_x:
002C2Er 3               
002C2Er 3               xt_asm_stz_z:   ; stz.z \ STZ nn
002C2Er 3  A9 64                        lda #$64
002C30r 3  80 2C                        bra asm_common
002C32r 3               z_asm_stz_z:
002C32r 3               
002C32r 3               xt_asm_stz_zx:  ; stz.zx \ STZ nn,X
002C32r 3  A9 74                        lda #$74
002C34r 3  80 28                        bra asm_common
002C36r 3               z_asm_stz_zx:
002C36r 3               
002C36r 3               xt_asm_tax:     ; tax \ TAX
002C36r 3  A9 AA                        lda #$AA
002C38r 3  80 24                        bra asm_common
002C3Ar 3               z_asm_tax:
002C3Ar 3               
002C3Ar 3               xt_asm_tay:     ; tay \ TAY
002C3Ar 3  A9 A8                        lda #$A8
002C3Cr 3  80 20                        bra asm_common
002C3Er 3               z_asm_tay:
002C3Er 3               
002C3Er 3               xt_asm_trb:     ; trb \ TRB nnnn
002C3Er 3  A9 1C                        lda #$1C
002C40r 3  80 1C                        bra asm_common
002C42r 3               z_asm_trb:
002C42r 3               
002C42r 3               xt_asm_trb_z:   ; trb.z \ TRB nn
002C42r 3  A9 14                        lda #$14
002C44r 3  80 18                        bra asm_common
002C46r 3               z_asm_trb_z:
002C46r 3               
002C46r 3               xt_asm_tsb:     ; tsb \ TSB nnnn
002C46r 3  A9 0C                        lda #$0C
002C48r 3  80 14                        bra asm_common
002C4Ar 3               z_asm_tsb:
002C4Ar 3               
002C4Ar 3               xt_asm_tsb_z:   ; tsb.z \ TSB nn
002C4Ar 3  A9 04                        lda #$04
002C4Cr 3  80 10                        bra asm_common
002C4Er 3               z_asm_tsb_z:
002C4Er 3               
002C4Er 3               xt_asm_tsx:     ; tsx \ TSX
002C4Er 3  A9 BA                        lda #$BA
002C50r 3  80 0C                        bra asm_common
002C52r 3               z_asm_tsx:
002C52r 3               
002C52r 3               xt_asm_txa:     ; txa \ TXA
002C52r 3  A9 8A                        lda #$8A
002C54r 3  80 08                        bra asm_common
002C56r 3               z_asm_txa:
002C56r 3               
002C56r 3               xt_asm_txs:     ; txs \ TXS
002C56r 3  A9 9A                        lda #$9A
002C58r 3  80 04                        bra asm_common
002C5Ar 3               z_asm_txs:
002C5Ar 3               
002C5Ar 3               xt_asm_tya:     ; tya \ TYA
002C5Ar 3  A9 98                        lda #$98
002C5Cr 3  80 00                        bra asm_common
002C5Er 3               z_asm_tya:
002C5Er 3               
002C5Er 3               
002C5Er 3               ; ==========================================================
002C5Er 3               ; ASSEMBLER HELPER FUNCTIONS
002C5Er 3               
002C5Er 3               asm_common:
002C5Er 3               
002C5Er 3               
002C5Er 3                       ; """Common routine for all opcodes. We arrive here with the opcode in
002C5Er 3                       ; A. We do not need to check for the correct values because we are
002C5Er 3                       ; coming from the assembler Dictionary and trust our external test
002C5Er 3                       ; suite.
002C5Er 3                       ; """
002C5Er 3                               ; Compile opcode. Note cmpl_a does not use Y
002C5Er 3  A8                           tay
002C5Fr 3  20 rr rr                     jsr cmpl_a
002C62r 3               
002C62r 3                               ; We get the length of the opcode from the table included in
002C62r 3                               ; the disassembler. We use the opcode value as the offset in
002C62r 3                               ; the oc_index_table. We have 256 entries, each two bytes
002C62r 3                               ; long, so we can't just use an index with Y. We use tmp2 for
002C62r 3                               ; this.
002C62r 3  A9 rr                        lda #<oc_index_table
002C64r 3  85 26                        sta tmp2
002C66r 3  A9 rr                        lda #>oc_index_table
002C68r 3  85 27                        sta tmp2+1
002C6Ar 3               
002C6Ar 3  98                           tya             ; retrieve opcode
002C6Br 3  0A                           asl             ; times two for offset
002C6Cr 3  90 02                        bcc @1
002C6Er 3  E6 27                        inc tmp2+1
002C70r 3               @1:
002C70r 3  A8                           tay             ; use Y as the index
002C71r 3               
002C71r 3                               ; Get address of the entry in the opcode table. We put it in
002C71r 3                               ; tmp3 and push a copy of it to the stack to be able to print
002C71r 3                               ; the opcode later
002C71r 3  B1 26                        lda (tmp2),y    ; LSB
002C73r 3  85 28                        sta tmp3
002C75r 3  C8                           iny
002C76r 3  B1 26                        lda (tmp2),y    ; MSB
002C78r 3  85 29                        sta tmp3+1
002C7Ar 3               
002C7Ar 3  B2 28                        lda (tmp3)      ; get "lengths byte"
002C7Cr 3               
002C7Cr 3                               ; The length of the instruction is stored in bits 7 and 6.
002C7Cr 3                               ; Rotate them through the carry flag and mask the rest
002C7Cr 3  2A                           rol
002C7Dr 3  2A                           rol
002C7Er 3  2A                           rol             ; Three times because we go through Carry
002C7Fr 3  29 03                        and #%00000011
002C81r 3  A8                           tay
002C82r 3               
002C82r 3                               ; One byte means no operand, we're done. Use DEY as CPY #1
002C82r 3  88                           dey
002C83r 3  F0 12                        beq @done
002C85r 3               
002C85r 3                               ; We have an operand which must be TOS
002C85r 3  20 rr rr                     jsr underflow_1
002C88r 3               
002C88r 3                               ; We compile the LSB of TOS as the operand we definitely have
002C88r 3                               ; before we even test if this is a two- or three-byte
002C88r 3                               ; instruction. Little endian CPU means we store this byte first
002C88r 3  B5 00                        lda 0,x
002C8Ar 3  20 rr rr                     jsr cmpl_a      ; does not use Y
002C8Dr 3               
002C8Dr 3                               ; If this is a two-byte instruction, we're done. If we landed
002C8Dr 3                               ; here, we've already decremented Y by one, so this is
002C8Dr 3                               ; the equivalent to CPY #2
002C8Dr 3  88                           dey
002C8Er 3  F0 05                        beq @done_drop
002C90r 3               
002C90r 3                               ; This must be a three-byte instruction, get the MSB.
002C90r 3  B5 01                        lda 1,x
002C92r 3  20 rr rr                     jsr cmpl_a      ; Fall through to @done_drop
002C95r 3               
002C95r 3               @done_drop:
002C95r 3  E8                           inx
002C96r 3  E8                           inx             ; Fall through to @done
002C97r 3               @done:
002C97r 3  60                           rts             ; Returns to original caller
002C98r 3               
002C98r 3               
002C98r 3               
002C98r 3               ; ==========================================================
002C98r 3               ; PSEUDO-INSTRUCTIONS AND MACROS
002C98r 3               
002C98r 3               xt_asm_push_a:
002C98r 3                       ; """push-a puts the content of the 65c02 Accumulator on the Forth
002C98r 3                       ; data stack as the TOS. This is a convience routine that encodes the
002C98r 3                       ; instructions  DEX  DEX  STA 0,X  STZ 1,X
002C98r 3                       ; """
002C98r 3               
002C98r 3  A0 00                        ldy #0
002C9Ar 3               @loop:
002C9Ar 3  B9 rr rr                     lda _data,y
002C9Dr 3  C9 FF                        cmp #$FF
002C9Fr 3  F0 06                        beq @done
002CA1r 3               
002CA1r 3  20 rr rr                     jsr cmpl_a      ; does not change Y
002CA4r 3  C8                           iny
002CA5r 3  80 F3                        bra @loop
002CA7r 3               @done:
002CA7r 3               z_asm_push_a:
002CA7r 3  60                           rts
002CA8r 3               _data:
002CA8r 3                       ; We can't use 00 as a terminator because STA 0,X assembles to 95 00
002CA8r 3  CA CA 95 00          .byte $CA, $CA, $95, 00, $74, $01
002CACr 3  74 01        
002CAEr 3  FF                   .byte $FF               ; terminator
002CAFr 3               
002CAFr 3               
002CAFr 3               
002CAFr 3               ; ==========================================================
002CAFr 3               ; DIRECTIVES
002CAFr 3               
002CAFr 3               ; The "<J" directive (back jump) is a dummy instruction (syntactic sugar) to
002CAFr 3               ; make clear that the JMP or JSR instructions are using the address that had
002CAFr 3               ; been placed on the stack by "-->" (the "arrow" directive).
002CAFr 3               xt_asm_back_jump:
002CAFr 3               z_asm_back_jump:
002CAFr 3  60                           rts
002CB0r 3               
002CB0r 3               ; The "<B" directive (back branch) takes an address that was placed on the Data
002CB0r 3               ; Stack by the anonymous label directive "-->" (the "arrow") and the current
002CB0r 3               ; address (via HERE) to calculate a backward branch offset. This is then stored
002CB0r 3               ; by a following branch instruction.
002CB0r 3               xt_asm_back_branch:
002CB0r 3                               ; We arrive here with ( addr-l ) of the label on the stack and
002CB0r 3                               ; then subtract the current address
002CB0r 3  20 rr rr                     jsr xt_here             ; ( addr-l addr-h )
002CB3r 3  20 rr rr                     jsr xt_minus            ; ( offset )
002CB6r 3               
002CB6r 3                               ; We subtract two more because of the branch instruction itself
002CB6r 3  3A                           dec
002CB7r 3  3A                           dec
002CB8r 3               
002CB8r 3               z_asm_back_branch:
002CB8r 3  60                           rts
002CB9r 3               
002CB9r 3               assembler_end:
002CB9r 3               
002CB9r 3               ; END
002CB9r 3               
002CB9r 2               .include "disassembler.asm"     ; SAN disassembler
002CB9r 3               ; Disassembler for Tali Forth 2
002CB9r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
002CB9r 3               ; First version: 28. Apr 2018
002CB9r 3               ; This version: 03. Jan 2019
002CB9r 3               
002CB9r 3               ; This is the default disassembler for Tali Forth 2. Use by passing
002CB9r 3               ; the address and length of the block of memory to be disassembled:
002CB9r 3               ;
002CB9r 3               ;       disasm ( addr x -- )
002CB9r 3               
002CB9r 3               ; The underflow checking is handled by the word's stub in native_words.asm, see
002CB9r 3               ; there for more information.
002CB9r 3               
002CB9r 3               ; The code is disassembled in Simpler Assembler Notation (SAN), because that
002CB9r 3               ; is, uh, simpler. See the documentation and https://github.com/scotws/SAN for
002CB9r 3               ; more information. Because disassemblers are used interactively with slow
002CB9r 3               ; humans, we don't care that much about speed and put the emphasis at being
002CB9r 3               ; small.
002CB9r 3               
002CB9r 3               
002CB9r 3               disassembler:
002CB9r 3  20 rr rr                     jsr xt_cr       ; ( addr u )
002CBCr 3               _byte_loop:
002CBCr 3                               ; Print address at start of the line. Note we use whatever
002CBCr 3                               ; number base the user has
002CBCr 3  20 rr rr                     jsr xt_over     ; ( addr u addr )
002CBFr 3  20 rr rr                     jsr xt_u_dot    ; ( addr u )
002CC2r 3  20 rr rr                     jsr xt_space
002CC5r 3               
002CC5r 3                               ; We use the opcode value as the offset in the oc_index_table.
002CC5r 3                               ; We have 256 entries, each two bytes long, so we can't just
002CC5r 3                               ; use an index with Y. We use tmp2 for this.
002CC5r 3  A9 rr                        lda #<oc_index_table
002CC7r 3  85 26                        sta tmp2
002CC9r 3  A9 rr                        lda #>oc_index_table
002CCBr 3  85 27                        sta tmp2+1
002CCDr 3               
002CCDr 3  A1 02                        lda (2,x)       ; get opcode that addr points to
002CCFr 3               
002CCFr 3  0A                           asl             ; multiply by two for offset
002CD0r 3  90 02                        bcc @1
002CD2r 3  E6 27                        inc tmp2+1      ; we're on second page
002CD4r 3               @1:
002CD4r 3  A8                           tay             ; use Y as the index
002CD5r 3               
002CD5r 3                               ; Get address of the entry in the opcode table. We put it
002CD5r 3                               ; in tmp3 and push a copy of it to the stack to be able to
002CD5r 3                               ; print the opcode later
002CD5r 3  B1 26                        lda (tmp2),y    ; LSB
002CD7r 3  85 28                        sta tmp3
002CD9r 3  48                           pha
002CDAr 3               
002CDAr 3  C8                           iny
002CDBr 3               
002CDBr 3  B1 26                        lda (tmp2),y    ; MSB
002CDDr 3  85 29                        sta tmp3+1
002CDFr 3  48                           pha
002CE0r 3               
002CE0r 3                               ; The first byte is the "lengths byte" which is coded so
002CE0r 3                               ; that bits 7 to 6 are the length of the instruction (1 to
002CE0r 3                               ; 3 bytes) and 2 to 0 are the length of the mnemonic.
002CE0r 3  B2 28                        lda (tmp3)
002CE2r 3  A8                           tay                     ; save copy of lengths byte
002CE3r 3               
002CE3r 3                               ; Since this is Simpler Assembler Notation (SAN) in a Forth
002CE3r 3                               ; system, we want to print any operand before we print the
002CE3r 3                               ; mnemonic ('1000 sta' instead of 'sta 1000'). This allows us
002CE3r 3                               ; to copy and paste directly from the disassembler to the
002CE3r 3                               ; assembler.
002CE3r 3               
002CE3r 3                               ; What happens next depends on the length of the instruction in
002CE3r 3                               ; bytes:
002CE3r 3               
002CE3r 3                               ;   1 byte:  OPC          -->          OPC  bit sequence: %01
002CE3r 3                               ;   2 bytes: OPC LSB      -->    0 LSB OPC  bit sequence: %10
002CE3r 3                               ;   3 bytes: OPC LSB MSB  -->  MSB LSB OPC  bit sequence: %11
002CE3r 3               
002CE3r 3                               ; We can distinguish between the first case, where there is
002CE3r 3                               ; only the mnemonic, and the second and third cases, where we
002CE3r 3                               ; have an operand. We do this by use of the bit sequence in
002CE3r 3                               ; bits 7 and 6.
002CE3r 3  10 38                        bpl _no_operand         ; bit 7 clear, single-byte instruction
002CE5r 3               
002CE5r 3                               ; We have an operand. Prepare the Data Stack
002CE5r 3  20 rr rr                     jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
002CE8r 3               
002CE8r 3                               ; Because of the glory of a little endian CPU, we can start
002CE8r 3                               ; with the next byte regardless if this is a one or two byte
002CE8r 3                               ; operand, because we'll need the LSB one way or the other.
002CE8r 3                               ; We have a copy of the opcode on the stack, so we can now move
002CE8r 3                               ; to the next byte
002CE8r 3  F6 04                        inc 4,x
002CEAr 3  D0 02                        bne @2
002CECr 3  F6 05                        inc 5,x                 ; ( addr+1 u 0 )
002CEEr 3               @2:
002CEEr 3  B5 02                        lda 2,x
002CF0r 3  D0 02                        bne @3
002CF2r 3  D6 03                        dec 3,x
002CF4r 3               @3:
002CF4r 3  D6 02                        dec 2,x                 ; ( addr+1 u-1 0 )
002CF6r 3               
002CF6r 3  A1 04                        lda (4,x)
002CF8r 3  95 00                        sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
002CFAr 3               
002CFAr 3                               ; We still have a copy of the lengths byte in Y, which we use
002CFAr 3                               ; to see if we have a one-byte operand (and are done already)
002CFAr 3                               ; or a two-byte operand
002CFAr 3  98                           tya                     ; retrieve copy of lengths byte
002CFBr 3  2A                           rol                     ; shift bit 6 to bit 7
002CFCr 3  10 12                        bpl _print_operand
002CFEr 3               
002CFEr 3                               ; We have a three-byte instruction, so we need to get the MSB
002CFEr 3                               ; of the operand. Move to the next byte
002CFEr 3  F6 04                        inc 4,x
002D00r 3  D0 02                        bne @4
002D02r 3  F6 05                        inc 5,x                 ; ( addr+2 u-1 LSB )
002D04r 3               @4:
002D04r 3  B5 02                        lda 2,x
002D06r 3  D0 02                        bne @5
002D08r 3  D6 03                        dec 3,x
002D0Ar 3               @5:
002D0Ar 3  D6 02                        dec 2,x                 ; ( addr+2 u-2 LSB )
002D0Cr 3               
002D0Cr 3  A1 04                        lda (4,x)
002D0Er 3  95 01                        sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
002D10r 3               
002D10r 3                               ; fall through to _print_operand
002D10r 3               
002D10r 3               _print_operand:
002D10r 3               
002D10r 3                               ; We arrive here with the lengths byte in Y, the address of the
002D10r 3                               ; opcode table entry for the instruction on the stack ( addr+n
002D10r 3                               ; u-n opr). We want the output to be nicely formatted in
002D10r 3                               ; columns, so we use U.R. The maximal width of the number in
002D10r 3                               ; decimal on an 16-bit addressed machine is five characters
002D10r 3  CA                           dex
002D11r 3  CA                           dex
002D12r 3  A9 05                        lda #5
002D14r 3  95 00                        sta 0,x
002D16r 3  74 01                        stz 1,x                 ; ( addr+n u-n opr 5 )
002D18r 3               
002D18r 3  20 rr rr                     jsr xt_u_dot_r          ; U.R ( addr+n u-n )
002D1Br 3               
002D1Br 3  80 0B                        bra _print_mnemonic
002D1Dr 3               
002D1Dr 3               _no_operand:
002D1Dr 3                               ; We arrive here with the opcode table address on the stack,
002D1Dr 3                               ; the lengths byte in Y and ( addr u ). Since we want to have
002D1Dr 3                               ; a nicely formatted output, we need to indent the mnemonic by
002D1Dr 3                               ; five spaces.
002D1Dr 3  CA                           dex
002D1Er 3  CA                           dex
002D1Fr 3  A9 05                        lda #5
002D21r 3  95 00                        sta 0,x
002D23r 3  74 01                        stz 1,x                 ; ( addr u 5 )
002D25r 3               
002D25r 3  20 rr rr                     jsr xt_spaces           ; ( addr u )
002D28r 3               
002D28r 3                               ; fall through to _print_mnemonic
002D28r 3               
002D28r 3               _print_mnemonic:
002D28r 3                               ; We arrive here with the opcode table address on the stack and
002D28r 3                               ; ( addr u | addr+n u-n ). Time to print the mnemonic.
002D28r 3  20 rr rr                     jsr xt_space
002D2Br 3               
002D2Br 3  CA                           dex
002D2Cr 3  CA                           dex                     ; ( addr u ? )
002D2Dr 3  68                           pla                     ; MSB
002D2Er 3  95 01                        sta 1,x                 ; ( addr u MSB )
002D30r 3  68                           pla                     ; LSB
002D31r 3  95 00                        sta 0,x                 ; ( addr u addr-o )
002D33r 3               
002D33r 3  20 rr rr                     jsr xt_count            ; ( addr u addr-o u-o )
002D36r 3               
002D36r 3                               ; The length of the mnemnonic string is in bits 2 to 0
002D36r 3  74 01                        stz 1,x                 ; paranoid
002D38r 3  B5 00                        lda 0,x
002D3Ar 3  29 07                        and #%00000111          ; ( addr u addr-o u-o )
002D3Cr 3  95 00                        sta 0,x
002D3Er 3               
002D3Er 3  20 rr rr                     jsr xt_type             ; ( addr u )
002D41r 3  20 rr rr                     jsr xt_cr
002D44r 3               
002D44r 3                               ; Housekeeping: Next byte
002D44r 3  F6 02                        inc 2,x
002D46r 3  D0 02                        bne @1
002D48r 3  F6 03                        inc 3,x                 ; ( addr+1 u )
002D4Ar 3               @1:
002D4Ar 3  20 rr rr                     jsr xt_one_minus        ; ( addr+1 u-1 )
002D4Dr 3               
002D4Dr 3  B5 00                        lda 0,x                 ; All done?
002D4Fr 3  15 01                        ora 1,x
002D51r 3  F0 07                        beq @done
002D53r 3               
002D53r 3  B5 01                        lda 1,x                 ; Catch mid-instruction ranges
002D55r 3  30 03                        bmi @done
002D57r 3               
002D57r 3  4C rr rr                     jmp _byte_loop          ; out of range for BRA
002D5Ar 3               @done:
002D5Ar 3                               ; Clean up and leave
002D5Ar 3  4C rr rr                     jmp xt_two_drop         ; JSR/RTS
002D5Dr 3               
002D5Dr 3               
002D5Dr 3               ; =========================================================
002D5Dr 3               oc_index_table:
002D5Dr 3                       ; Lookup table for the instruction data (length of instruction in
002D5Dr 3                       ; bytes, length of mnemonic in bytes, mnemonic string). This is used by
002D5Dr 3                       ; the assembler as well.
002D5Dr 3               
002D5Dr 3                       ; Opcodes 00-0F
002D5Dr 3  rr rr rr rr          .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
002D61r 3  rr rr rr rr  
002D65r 3  rr rr rr rr  
002D6Dr 3  rr rr rr rr          .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
002D71r 3  rr rr rr rr  
002D75r 3  rr rr rr rr  
002D7Dr 3               
002D7Dr 3                       ; Opcodes 10-1F
002D7Dr 3  rr rr rr rr          .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
002D81r 3  rr rr rr rr  
002D85r 3  rr rr rr rr  
002D8Dr 3  rr rr rr rr          .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
002D91r 3  rr rr rr rr  
002D95r 3  rr rr rr rr  
002D9Dr 3               
002D9Dr 3                       ; Opcodes 20-2F
002D9Dr 3  rr rr rr rr          .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
002DA1r 3  rr rr rr rr  
002DA5r 3  rr rr rr rr  
002DADr 3  rr rr rr rr          .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
002DB1r 3  rr rr rr rr  
002DB5r 3  rr rr rr rr  
002DBDr 3               
002DBDr 3                       ; Opcodes 30-3F
002DBDr 3  rr rr rr rr          .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
002DC1r 3  rr rr rr rr  
002DC5r 3  rr rr rr rr  
002DCDr 3  rr rr rr rr          .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
002DD1r 3  rr rr rr rr  
002DD5r 3  rr rr rr rr  
002DDDr 3               
002DDDr 3                       ; Opcodes 40-4F
002DDDr 3  rr rr rr rr          .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
002DE1r 3  rr rr rr rr  
002DE5r 3  rr rr rr rr  
002DEDr 3  rr rr rr rr          .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
002DF1r 3  rr rr rr rr  
002DF5r 3  rr rr rr rr  
002DFDr 3               
002DFDr 3                       ; Opcodes 50-5F
002DFDr 3  rr rr rr rr          .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
002E01r 3  rr rr rr rr  
002E05r 3  rr rr rr rr  
002E0Dr 3  rr rr rr rr          .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
002E11r 3  rr rr rr rr  
002E15r 3  rr rr rr rr  
002E1Dr 3               
002E1Dr 3                       ; Opcodes 60-6F
002E1Dr 3  rr rr rr rr          .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
002E21r 3  rr rr rr rr  
002E25r 3  rr rr rr rr  
002E2Dr 3  rr rr rr rr          .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
002E31r 3  rr rr rr rr  
002E35r 3  rr rr rr rr  
002E3Dr 3               
002E3Dr 3                       ; Opcodes 70-7F
002E3Dr 3  rr rr rr rr          .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
002E41r 3  rr rr rr rr  
002E45r 3  rr rr rr rr  
002E4Dr 3  rr rr rr rr          .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
002E51r 3  rr rr rr rr  
002E55r 3  rr rr rr rr  
002E5Dr 3               
002E5Dr 3                       ; Opcodes 80-8F
002E5Dr 3  rr rr rr rr          .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
002E61r 3  rr rr rr rr  
002E65r 3  rr rr rr rr  
002E6Dr 3  rr rr rr rr          .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
002E71r 3  rr rr rr rr  
002E75r 3  rr rr rr rr  
002E7Dr 3               
002E7Dr 3                       ; Opcodes 90-9F
002E7Dr 3  rr rr rr rr          .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
002E81r 3  rr rr rr rr  
002E85r 3  rr rr rr rr  
002E8Dr 3  rr rr rr rr          .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
002E91r 3  rr rr rr rr  
002E95r 3  rr rr rr rr  
002E9Dr 3               
002E9Dr 3                       ; Opcodes A0-AF
002E9Dr 3  rr rr rr rr          .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
002EA1r 3  rr rr rr rr  
002EA5r 3  rr rr rr rr  
002EADr 3  rr rr rr rr          .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
002EB1r 3  rr rr rr rr  
002EB5r 3  rr rr rr rr  
002EBDr 3               
002EBDr 3                       ; Opcodes B0-BF
002EBDr 3  rr rr rr rr          .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
002EC1r 3  rr rr rr rr  
002EC5r 3  rr rr rr rr  
002ECDr 3  rr rr rr rr          .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
002ED1r 3  rr rr rr rr  
002ED5r 3  rr rr rr rr  
002EDDr 3               
002EDDr 3                       ; Opcodes C0-CF
002EDDr 3  rr rr rr rr          .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
002EE1r 3  rr rr rr rr  
002EE5r 3  rr rr rr rr  
002EEDr 3  rr rr rr rr          .word occ8, occ9, occa, oc__, occc, occd, occe, occf
002EF1r 3  rr rr rr rr  
002EF5r 3  rr rr rr rr  
002EFDr 3               
002EFDr 3                       ; Opcodes D0-DF
002EFDr 3  rr rr rr rr          .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
002F01r 3  rr rr rr rr  
002F05r 3  rr rr rr rr  
002F0Dr 3  rr rr rr rr          .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
002F11r 3  rr rr rr rr  
002F15r 3  rr rr rr rr  
002F1Dr 3               
002F1Dr 3                       ; Opcodes E0-EF
002F1Dr 3  rr rr rr rr          .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
002F21r 3  rr rr rr rr  
002F25r 3  rr rr rr rr  
002F2Dr 3  rr rr rr rr          .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
002F31r 3  rr rr rr rr  
002F35r 3  rr rr rr rr  
002F3Dr 3               
002F3Dr 3                       ; Opcodes F0-FF
002F3Dr 3  rr rr rr rr          .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
002F41r 3  rr rr rr rr  
002F45r 3  rr rr rr rr  
002F4Dr 3  rr rr rr rr          .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
002F51r 3  rr rr rr rr  
002F55r 3  rr rr rr rr  
002F5Dr 3               
002F5Dr 3               
002F5Dr 3               ; =========================================================
002F5Dr 3               oc_table:
002F5Dr 3                       ; Opcode data table for the disassember, which is also used by the
002F5Dr 3                       ; assembler. Each entry starts with a "lengths byte":
002F5Dr 3               
002F5Dr 3                       ;       bit 7-6:  Length of instruction in bytes (1 to 3 for the 65c02)
002F5Dr 3                       ;       bit 5-3:  unused
002F5Dr 3                       ;       bit 2-0:  Length of mnemonic in chars (3 to 7)
002F5Dr 3               
002F5Dr 3                       ; To convert a line in this table to a Forth string of the mnemonic,
002F5Dr 3                       ; use the COUNT word on the address of the lengths byte to get
002F5Dr 3                       ; ( addr u ) and then mask all but the bits 2-0 of the TOS.
002F5Dr 3               
002F5Dr 3                       ; To make debugging easier, we keep the raw numbers for the lengths of
002F5Dr 3                       ; the instruction and mnemonicis and let the assembler do the math
002F5Dr 3                       ; required to shift and add. The actual mnemonic string follows after
002F5Dr 3                       ; and is not zero terminated because we have the length in bits 2 to 0.
002F5Dr 3               
002F5Dr 3  83 62 72 6B  	oc00:	.byte 2*64+3, "brk"              ; enforce the signature byte
002F61r 3  87 6F 72 61  	oc01:	.byte 2*64+7, "ora.zxi"
002F65r 3  2E 7A 78 69  
002F69r 3               ;      (oc02)
002F69r 3               ;      (oc03)
002F69r 3  85 74 73 62          oc04:   .byte 2*64+5, "tsb.z"
002F6Dr 3  2E 7A        
002F6Fr 3  85 6F 72 64  	oc05:	.byte 2*64+5, "ord.z"
002F73r 3  2E 7A        
002F75r 3  85 61 73 6C  	oc06:	.byte 2*64+5, "asl.z"
002F79r 3  2E 7A        
002F7Br 3               ;      (oc07)
002F7Br 3  43 70 68 70  	oc08:	.byte 1*64+3, "php"
002F7Fr 3  85 6F 72 61  	oc09:	.byte 2*64+5, "ora.#"
002F83r 3  2E 23        
002F85r 3  45 61 73 6C  	oc0a:	.byte 1*64+5, "asl.a"
002F89r 3  2E 61        
002F8Br 3               ;      (oc0b)
002F8Br 3  C3 74 73 62  	oc0c:	.byte 3*64+3, "tsb"
002F8Fr 3  C3 6F 72 61  	oc0d:	.byte 3*64+3, "ora"
002F93r 3  C3 61 73 6C  	oc0e:	.byte 3*64+3, "asl"
002F97r 3  C4 62 62 72  	oc0f:	.byte 3*64+4, "bbr0"
002F9Br 3  30           
002F9Cr 3               
002F9Cr 3  83 62 70 6C  	oc10:	.byte 2*64+3, "bpl"
002FA0r 3  87 6F 72 61  	oc11:	.byte 2*64+7, "ora.ziy"
002FA4r 3  2E 7A 69 79  
002FA8r 3  86 6F 72 61  	oc12:	.byte 2*64+6, "ora.zi"
002FACr 3  2E 7A 69     
002FAFr 3               ;      (oc13:)
002FAFr 3  85 74 72 62  	oc14:	.byte 2*64+5, "trb.z"
002FB3r 3  2E 7A        
002FB5r 3  86 6F 72 61  	oc15:	.byte 2*64+6, "ora.zx"
002FB9r 3  2E 7A 78     
002FBCr 3  86 61 73 6C  	oc16:	.byte 2*64+6, "asl.zx"
002FC0r 3  2E 7A 78     
002FC3r 3  86 72 6D 62  	oc17:	.byte 2*64+6, "rmb1.z"
002FC7r 3  31 2E 7A     
002FCAr 3  43 63 6C 63  	oc18:	.byte 1*64+3, "clc"
002FCEr 3  C5 6F 72 61  	oc19:	.byte 3*64+5, "ora.y"
002FD2r 3  2E 79        
002FD4r 3  45 69 6E 63  	oc1a:	.byte 1*64+5, "inc.a"
002FD8r 3  2E 61        
002FDAr 3               ;      (oc1b:)
002FDAr 3  C3 74 72 62  	oc1c:	.byte 3*64+3, "trb"
002FDEr 3  C5 6F 72 61  	oc1d:	.byte 3*64+5, "ora.x"
002FE2r 3  2E 78        
002FE4r 3               ;      (oc1e:)
002FE4r 3  C5 61 73 6C  	oc1f:	.byte 3*64+5, "asl.x"
002FE8r 3  2E 78        
002FEAr 3               
002FEAr 3  C3 6A 73 72  	oc20:	.byte 3*64+3, "jsr"
002FEEr 3  87 61 6E 64  	oc21:	.byte 2*64+7, "and.zxi"
002FF2r 3  2E 7A 78 69  
002FF6r 3               ;      (oc22:)
002FF6r 3               ;      (oc23:)
002FF6r 3  85 62 69 74  	oc24:	.byte 2*64+5, "bit.z"
002FFAr 3  2E 7A        
002FFCr 3  85 61 6E 64  	oc25:	.byte 2*64+5, "and.z"
003000r 3  2E 7A        
003002r 3  85 72 6F 6C  	oc26:	.byte 2*64+5, "rol.z"
003006r 3  2E 7A        
003008r 3  86 72 6D 62  	oc27:	.byte 2*64+6, "rmb2.z"
00300Cr 3  32 2E 7A     
00300Fr 3  43 70 6C 70  	oc28:	.byte 1*64+3, "plp"
003013r 3  85 61 6E 64  	oc29:	.byte 2*64+5, "and.#"
003017r 3  2E 23        
003019r 3  45 72 6F 6C  	oc2a:	.byte 1*64+5, "rol.a"
00301Dr 3  2E 61        
00301Fr 3               ;      (oc2b:)
00301Fr 3  C3 62 69 74  	oc2c:	.byte 3*64+3, "bit"
003023r 3  C4 61 6E 64  	oc2d:	.byte 3*64+4, "and."
003027r 3  2E           
003028r 3  C3 72 6F 6C  	oc2e:	.byte 3*64+3, "rol"
00302Cr 3  C4 62 62 72  	oc2f:	.byte 3*64+4, "bbr2"
003030r 3  32           
003031r 3               
003031r 3  83 62 6D 69  	oc30:	.byte 2*64+3, "bmi"
003035r 3  87 61 6E 64  	oc31:	.byte 2*64+7, "and.ziy"
003039r 3  2E 7A 69 79  
00303Dr 3  86 61 6E 64  	oc32:	.byte 2*64+6, "and.zi"
003041r 3  2E 7A 69     
003044r 3               ;      (oc33:)
003044r 3  87 62 69 74  	oc34:	.byte 2*64+7, "bit.zxi"
003048r 3  2E 7A 78 69  
00304Cr 3  86 61 6E 64  	oc35:	.byte 2*64+6, "and.zx"
003050r 3  2E 7A 78     
003053r 3  86 72 6F 6C  	oc36:	.byte 2*64+6, "rol.zx"
003057r 3  2E 7A 78     
00305Ar 3  86 72 6D 62  	oc37:	.byte 2*64+6, "rmb3.z"
00305Er 3  33 2E 7A     
003061r 3  43 73 65 63  	oc38:	.byte 1*64+3, "sec"
003065r 3  C5 61 6E 64  	oc39:	.byte 3*64+5, "and.y"
003069r 3  2E 79        
00306Br 3  45 64 65 63  	oc3a:	.byte 1*64+5, "dec.a"
00306Fr 3  2E 61        
003071r 3               ;      (oc3b:)
003071r 3  C5 62 69 74  	oc3c:	.byte 3*64+5, "bit.x"
003075r 3  2E 78        
003077r 3  C5 61 6E 64  	oc3d:	.byte 3*64+5, "and.x"
00307Br 3  2E 78        
00307Dr 3  C5 72 6F 6C  	oc3e:	.byte 3*64+5, "rol.x"
003081r 3  2E 78        
003083r 3  C4 62 62 72  	oc3f:	.byte 3*64+4, "bbr3"
003087r 3  33           
003088r 3               
003088r 3  43 72 74 69  	oc40:	.byte 1*64+3, "rti"
00308Cr 3  87 65 6F 72  	oc41:	.byte 2*64+7, "eor.zxi"
003090r 3  2E 7A 78 69  
003094r 3               ;      (oc42:)
003094r 3               ;      (oc43:)
003094r 3               ;      (oc44:)
003094r 3  85 65 6F 72  	oc45:	.byte 2*64+5, "eor.z"
003098r 3  2E 7A        
00309Ar 3  85 6C 73 72  	oc46:	.byte 2*64+5, "lsr.z"
00309Er 3  2E 7A        
0030A0r 3  86 72 62 6D  	oc47:	.byte 2*64+6, "rbm4.z"
0030A4r 3  34 2E 7A     
0030A7r 3  43 70 68 61  	oc48:	.byte 1*64+3, "pha"
0030ABr 3  85 65 6F 72  	oc49:	.byte 2*64+5, "eor.#"
0030AFr 3  2E 23        
0030B1r 3  45 6C 73 72  	oc4a:	.byte 1*64+5, "lsr.a"
0030B5r 3  2E 61        
0030B7r 3               ;      (oc4b:)
0030B7r 3  C3 6A 6D 70  	oc4c:	.byte 3*64+3, "jmp"
0030BBr 3  C3 65 6F 72  	oc4d:	.byte 3*64+3, "eor"
0030BFr 3  C3 6C 73 72  	oc4e:	.byte 3*64+3, "lsr"
0030C3r 3  C4 62 62 72  	oc4f:	.byte 3*64+4, "bbr4"
0030C7r 3  34           
0030C8r 3               
0030C8r 3  83 62 76 63  	oc50:	.byte 2*64+3, "bvc"
0030CCr 3  87 65 6F 72  	oc51:	.byte 2*64+7, "eor.ziy"
0030D0r 3  2E 7A 69 79  
0030D4r 3  86 65 6F 72  	oc52:	.byte 2*64+6, "eor.zi"
0030D8r 3  2E 7A 69     
0030DBr 3               ;      (oc53:)
0030DBr 3               ;      (oc54:)
0030DBr 3  86 65 6F 72  	oc55:	.byte 2*64+6, "eor.zx"
0030DFr 3  2E 7A 78     
0030E2r 3  86 6C 73 72  	oc56:	.byte 2*64+6, "lsr.zx"
0030E6r 3  2E 7A 78     
0030E9r 3  86 72 62 6D  	oc57:	.byte 2*64+6, "rbm5.z"
0030EDr 3  35 2E 7A     
0030F0r 3  43 63 6C 69  	oc58:	.byte 1*64+3, "cli"
0030F4r 3  C5 65 6F 72  	oc59:	.byte 3*64+5, "eor.y"
0030F8r 3  2E 79        
0030FAr 3  43 70 68 79  	oc5a:	.byte 1*64+3, "phy"
0030FEr 3               ;      (oc5b:)
0030FEr 3               ;      (oc5c:)
0030FEr 3  C5 65 6F 72  	oc5d:	.byte 3*64+5, "eor.x"
003102r 3  2E 78        
003104r 3  C5 6C 73 72  	oc5e:	.byte 3*64+5, "lsr.x"
003108r 3  2E 78        
00310Ar 3  C4 62 62 72  	oc5f:	.byte 3*64+4, "bbr5"
00310Er 3  35           
00310Fr 3               
00310Fr 3  43 72 74 73  	oc60:	.byte 1*64+3, "rts"
003113r 3  87 61 64 63  	oc61:	.byte 2*64+7, "adc.zxi"
003117r 3  2E 7A 78 69  
00311Br 3               ;      (oc62:)
00311Br 3               ;      (oc63:)
00311Br 3  85 73 74 7A  	oc64:	.byte 2*64+5, "stz.z"
00311Fr 3  2E 7A        
003121r 3  85 61 64 63  	oc65:	.byte 2*64+5, "adc.z"
003125r 3  2E 7A        
003127r 3  85 72 6F 72  	oc66:	.byte 2*64+5, "ror.z"
00312Br 3  2E 7A        
00312Dr 3  86 72 6D 62  	oc67:	.byte 2*64+6, "rmb6.z"
003131r 3  36 2E 7A     
003134r 3  43 70 6C 61  	oc68:	.byte 1*64+3, "pla"
003138r 3  85 61 64 63  	oc69:	.byte 2*64+5, "adc.#"
00313Cr 3  2E 23        
00313Er 3  45 72 6F 72  	oc6a:	.byte 1*64+5, "ror.a"
003142r 3  2E 61        
003144r 3               ;      (oc6b:)
003144r 3  C5 6A 6D 70  	oc6c:	.byte 3*64+5, "jmp.i"
003148r 3  2E 69        
00314Ar 3  C3 61 64 63  	oc6d:	.byte 3*64+3, "adc"
00314Er 3  C3 72 6F 72  	oc6e:	.byte 3*64+3, "ror"
003152r 3  C4 62 62 72  	oc6f:	.byte 3*64+4, "bbr6"
003156r 3  36           
003157r 3               
003157r 3  83 62 76 73  	oc70:	.byte 2*64+3, "bvs"
00315Br 3  87 61 64 63  	oc71:	.byte 2*64+7, "adc.ziy"
00315Fr 3  2E 7A 69 79  
003163r 3  86 61 64 63  	oc72:	.byte 2*64+6, "adc.zi"
003167r 3  2E 7A 69     
00316Ar 3               ;      (oc73:)
00316Ar 3  86 73 74 7A  	oc74:	.byte 2*64+6, "stz.zx"
00316Er 3  2E 7A 78     
003171r 3  86 61 64 63  	oc75:	.byte 2*64+6, "adc.zx"
003175r 3  2E 7A 78     
003178r 3  86 72 6F 72  	oc76:	.byte 2*64+6, "ror.zx"
00317Cr 3  2E 7A 78     
00317Fr 3  86 72 6D 62  	oc77:	.byte 2*64+6, "rmb7.z"
003183r 3  37 2E 7A     
003186r 3  43 73 65 69  	oc78:	.byte 1*64+3, "sei"
00318Ar 3  C5 61 64 63  	oc79:	.byte 3*64+5, "adc.y"
00318Er 3  2E 79        
003190r 3  43 70 6C 79  	oc7a:	.byte 1*64+3, "ply"
003194r 3               ;      (oc7b:)
003194r 3  C6 6A 6D 70  	oc7c:	.byte 3*64+6, "jmp.xi"
003198r 3  2E 78 69     
00319Br 3  C5 61 64 63  	oc7d:	.byte 3*64+5, "adc.x"
00319Fr 3  2E 78        
0031A1r 3  C5 72 6F 72  	oc7e:	.byte 3*64+5, "ror.x"
0031A5r 3  2E 78        
0031A7r 3  C4 62 62 72  	oc7f:	.byte 3*64+4, "bbr7"
0031ABr 3  37           
0031ACr 3               
0031ACr 3  83 62 72 61  	oc80:	.byte 2*64+3, "bra"
0031B0r 3  87 73 74 61  	oc81:	.byte 2*64+7, "sta.zxi"
0031B4r 3  2E 7A 78 69  
0031B8r 3               ;      (oc82:)
0031B8r 3               ;      (oc83:)
0031B8r 3  85 73 74 79  	oc84:	.byte 2*64+5, "sty.z"
0031BCr 3  2E 7A        
0031BEr 3  85 73 74 61  	oc85:	.byte 2*64+5, "sta.z"
0031C2r 3  2E 7A        
0031C4r 3  85 73 74 78  	oc86:	.byte 2*64+5, "stx.z"
0031C8r 3  2E 7A        
0031CAr 3               ;      (oc87:)
0031CAr 3  43 64 65 79  	oc88:	.byte 1*64+3, "dey"
0031CEr 3  85 62 69 74  	oc89:	.byte 2*64+5, "bit.#"
0031D2r 3  2E 23        
0031D4r 3  43 74 78 61  	oc8a:	.byte 1*64+3, "txa"
0031D8r 3               ;      (oc8b:)
0031D8r 3  C3 73 74 79  	oc8c:	.byte 3*64+3, "sty"
0031DCr 3  C3 73 74 61  	oc8d:	.byte 3*64+3, "sta"
0031E0r 3  C3 73 74 78  	oc8e:	.byte 3*64+3, "stx"
0031E4r 3  C4 62 62 73  	oc8f:	.byte 3*64+4, "bbs0"
0031E8r 3  30           
0031E9r 3               
0031E9r 3  83 62 63 63  	oc90:	.byte 2*64+3, "bcc"
0031EDr 3  87 73 74 61  	oc91:	.byte 2*64+7, "sta.ziy"
0031F1r 3  2E 7A 69 79  
0031F5r 3  86 73 74 61  	oc92:	.byte 2*64+6, "sta.zi"
0031F9r 3  2E 7A 69     
0031FCr 3               ;      (oc93:)
0031FCr 3  86 73 74 79  	oc94:	.byte 2*64+6, "sty.zx"
003200r 3  2E 7A 78     
003203r 3  86 73 74 61  	oc95:	.byte 2*64+6, "sta.zx"
003207r 3  2E 7A 78     
00320Ar 3  86 73 74 78  	oc96:	.byte 2*64+6, "stx.zy"
00320Er 3  2E 7A 79     
003211r 3  86 73 6D 62  	oc97:	.byte 2*64+6, "smb1.z"
003215r 3  31 2E 7A     
003218r 3  43 74 79 61  	oc98:	.byte 1*64+3, "tya"
00321Cr 3  C5 73 74 61  	oc99:	.byte 3*64+5, "sta.y"
003220r 3  2E 79        
003222r 3  43 74 78 73  	oc9a:	.byte 1*64+3, "txs"
003226r 3               ;      (oc9b:)
003226r 3  C3 73 74 7A  	oc9c:	.byte 3*64+3, "stz"
00322Ar 3  C5 73 74 61  	oc9d:	.byte 3*64+5, "sta.x"
00322Er 3  2E 78        
003230r 3  C5 73 74 7A  	oc9e:	.byte 3*64+5, "stz.x"
003234r 3  2E 78        
003236r 3  C4 62 62 73  	oc9f:	.byte 3*64+4, "bbs1"
00323Ar 3  31           
00323Br 3               
00323Br 3  85 6C 64 79  	oca0:	.byte 2*64+5, "ldy.#"
00323Fr 3  2E 23        
003241r 3  87 6C 64 61  	oca1:	.byte 2*64+7, "lda.zxi"
003245r 3  2E 7A 78 69  
003249r 3  85 6C 64 78  	oca2:	.byte 2*64+5, "ldx.#"
00324Dr 3  2E 23        
00324Fr 3               ;      (oca3:)
00324Fr 3  85 6C 64 79  	oca4:	.byte 2*64+5, "ldy.z"
003253r 3  2E 7A        
003255r 3  85 6C 64 61  	oca5:	.byte 2*64+5, "lda.z"
003259r 3  2E 7A        
00325Br 3  85 6C 64 78  	oca6:	.byte 2*64+5, "ldx.z"
00325Fr 3  2E 7A        
003261r 3  86 73 6D 62  	oca7:	.byte 2*64+6, "smb2.z"
003265r 3  32 2E 7A     
003268r 3  43 74 61 79  	oca8:	.byte 1*64+3, "tay"
00326Cr 3  85 6C 64 61  	oca9:	.byte 2*64+5, "lda.#"
003270r 3  2E 23        
003272r 3  43 74 61 78  	ocaa:	.byte 1*64+3, "tax"
003276r 3               ;      (ocab:)
003276r 3  C3 6C 64 79  	ocac:	.byte 3*64+3, "ldy"
00327Ar 3  C3 6C 64 61  	ocad:	.byte 3*64+3, "lda"
00327Er 3  C3 6C 64 78  	ocae:	.byte 3*64+3, "ldx"
003282r 3  C4 62 62 73  	ocaf:	.byte 3*64+4, "bbs2"
003286r 3  32           
003287r 3               
003287r 3  83 62 63 73  	ocb0:	.byte 2*64+3, "bcs"
00328Br 3  87 6C 64 61  	ocb1:	.byte 2*64+7, "lda.ziy"
00328Fr 3  2E 7A 69 79  
003293r 3  86 6C 64 61  	ocb2:	.byte 2*64+6, "lda.zi"
003297r 3  2E 7A 69     
00329Ar 3               ;      (ocb3:)
00329Ar 3  86 6C 64 79  	ocb4:	.byte 2*64+6, "ldy.zx"
00329Er 3  2E 7A 78     
0032A1r 3  86 6C 64 61  	ocb5:	.byte 2*64+6, "lda.zx"
0032A5r 3  2E 7A 78     
0032A8r 3  86 6C 64 78  	ocb6:	.byte 2*64+6, "ldx.zy"
0032ACr 3  2E 7A 79     
0032AFr 3  86 73 6D 62  	ocb7:	.byte 2*64+6, "smb3.z"
0032B3r 3  33 2E 7A     
0032B6r 3  43 63 6C 76  	ocb8:	.byte 1*64+3, "clv"
0032BAr 3  C5 6C 64 61  	ocb9:	.byte 3*64+5, "lda.y"
0032BEr 3  2E 79        
0032C0r 3  43 74 73 78  	ocba:	.byte 1*64+3, "tsx"
0032C4r 3               ;      (ocbb:)
0032C4r 3  C5 6C 64 79  	ocbc:	.byte 3*64+5, "ldy.x"
0032C8r 3  2E 78        
0032CAr 3  C5 6C 64 61  	ocbd:	.byte 3*64+5, "lda.x"
0032CEr 3  2E 78        
0032D0r 3  C5 6C 64 78  	ocbe:	.byte 3*64+5, "ldx.y"
0032D4r 3  2E 79        
0032D6r 3  C4 62 62 73  	ocbf:	.byte 3*64+4, "bbs4"
0032DAr 3  34           
0032DBr 3               
0032DBr 3  85 63 70 79  	occ0:	.byte 2*64+5, "cpy.#"
0032DFr 3  2E 23        
0032E1r 3  87 63 6D 70  	occ1:	.byte 2*64+7, "cmp.zxi"
0032E5r 3  2E 7A 78 69  
0032E9r 3               ;      (occ2:)
0032E9r 3               ;      (occ3:)
0032E9r 3  85 63 70 79  	occ4:	.byte 2*64+5, "cpy.z"
0032EDr 3  2E 7A        
0032EFr 3  85 63 6D 70  	occ5:	.byte 2*64+5, "cmp.z"
0032F3r 3  2E 7A        
0032F5r 3  85 64 65 63  	occ6:	.byte 2*64+5, "dec.z"
0032F9r 3  2E 7A        
0032FBr 3  86 73 6D 62  	occ7:	.byte 2*64+6, "smb4.z"
0032FFr 3  34 2E 7A     
003302r 3  43 69 6E 79  	occ8:	.byte 1*64+3, "iny"
003306r 3  85 63 6D 70  	occ9:	.byte 2*64+5, "cmp.#"
00330Ar 3  2E 23        
00330Cr 3  43 64 65 78  	occa:	.byte 1*64+3, "dex"
003310r 3               ;      (occb:)
003310r 3  C3 63 70 79  	occc:	.byte 3*64+3, "cpy"
003314r 3  C3 63 6D 70  	occd:	.byte 3*64+3, "cmp"
003318r 3  C3 64 65 63  	occe:	.byte 3*64+3, "dec"
00331Cr 3  C4 62 62 73  	occf:	.byte 3*64+4, "bbs4"
003320r 3  34           
003321r 3               
003321r 3  83 62 6E 65  	ocd0:	.byte 2*64+3, "bne"
003325r 3  87 63 6D 70  	ocd1:	.byte 2*64+7, "cmp.ziy"
003329r 3  2E 7A 69 79  
00332Dr 3  86 63 6D 70  	ocd2:	.byte 2*64+6, "cmp.zi"
003331r 3  2E 7A 69     
003334r 3               ;      (ocd3:)
003334r 3               ;      (ocd4:)
003334r 3  86 63 6D 70  	ocd5:	.byte 2*64+6, "cmp.zx"
003338r 3  2E 7A 78     
00333Br 3  86 64 65 63  	ocd6:	.byte 2*64+6, "dec.zx"
00333Fr 3  2E 7A 78     
003342r 3  86 73 6D 62  	ocd7:	.byte 2*64+6, "smb5.z"
003346r 3  35 2E 7A     
003349r 3  43 63 6C 64  	ocd8:	.byte 1*64+3, "cld"
00334Dr 3  C5 63 6D 70  	ocd9:	.byte 3*64+5, "cmp.y"
003351r 3  2E 79        
003353r 3  43 70 68 78  	ocda:	.byte 1*64+3, "phx"
003357r 3               ;      (ocdb:)
003357r 3               ;      (ocdc:)
003357r 3  C5 63 6D 70  	ocdd:	.byte 3*64+5, "cmp.x"
00335Br 3  2E 78        
00335Dr 3  C5 64 65 63  	ocde:	.byte 3*64+5, "dec.x"
003361r 3  2E 78        
003363r 3  C4 62 62 73  	ocdf:	.byte 3*64+4, "bbs5"
003367r 3  35           
003368r 3               
003368r 3  85 63 70 78  	oce0:	.byte 2*64+5, "cpx.#"
00336Cr 3  2E 23        
00336Er 3  87 73 62 63  	oce1:	.byte 2*64+7, "sbc.zxi"
003372r 3  2E 7A 78 69  
003376r 3               ;      (oce2:)
003376r 3               ;      (oce3:)
003376r 3  85 63 70 78  	oce4:	.byte 2*64+5, "cpx.z"
00337Ar 3  2E 7A        
00337Cr 3  85 73 62 63  	oce5:	.byte 2*64+5, "sbc.z"
003380r 3  2E 7A        
003382r 3  85 69 6E 63  	oce6:	.byte 2*64+5, "inc.z"
003386r 3  2E 7A        
003388r 3  86 73 6D 62  	oce7:	.byte 2*64+6, "smb6.z"
00338Cr 3  36 2E 7A     
00338Fr 3  43 69 6E 78  	oce8:	.byte 1*64+3, "inx"
003393r 3  85 73 62 63  	oce9:	.byte 2*64+5, "sbc.#"
003397r 3  2E 23        
003399r 3  43 6E 6F 70  	ocea:	.byte 1*64+3, "nop"
00339Dr 3               ;      (oceb:)
00339Dr 3  C3 63 70 78  	ocec:	.byte 3*64+3, "cpx"
0033A1r 3  C3 73 62 63  	oced:	.byte 3*64+3, "sbc"
0033A5r 3  C3 69 6E 63  	ocee:	.byte 3*64+3, "inc"
0033A9r 3  C4 62 62 73  	ocef:	.byte 3*64+4, "bbs6"
0033ADr 3  36           
0033AEr 3               
0033AEr 3  83 62 65 71  	ocf0:	.byte 2*64+3, "beq"
0033B2r 3  87 73 62 63  	ocf1:	.byte 2*64+7, "sbc.ziy"
0033B6r 3  2E 7A 69 79  
0033BAr 3  86 73 62 63  	ocf2:	.byte 2*64+6, "sbc.zi"
0033BEr 3  2E 7A 69     
0033C1r 3               ;      (ocf3:)
0033C1r 3               ;      (ocf4:)
0033C1r 3  86 73 62 63  	ocf5:	.byte 2*64+6, "sbc.zx"
0033C5r 3  2E 7A 78     
0033C8r 3  86 69 6E 63  	ocf6:	.byte 2*64+6, "inc.zx"
0033CCr 3  2E 7A 78     
0033CFr 3  86 73 6D 62  	ocf7:	.byte 2*64+6, "smb7.z"
0033D3r 3  37 2E 7A     
0033D6r 3  43 73 65 64  	ocf8:	.byte 1*64+3, "sed"
0033DAr 3  C5 73 62 63  	ocf9:	.byte 3*64+5, "sbc.y"
0033DEr 3  2E 79        
0033E0r 3  43 70 6C 78  	ocfa:	.byte 1*64+3, "plx"
0033E4r 3               ;      (ocfb:)
0033E4r 3               ;      (ocfc:)
0033E4r 3  C5 73 62 63  	ocfd:	.byte 3*64+5, "sbc.x"
0033E8r 3  2E 78        
0033EAr 3  C5 69 6E 63  	ocfe:	.byte 3*64+5, "inc.x"
0033EEr 3  2E 78        
0033F0r 3  C4 62 62 73  	ocff:	.byte 3*64+4, "bbs7"
0033F4r 3  37           
0033F5r 3               
0033F5r 3                       ; Common routine for opcodes that are not supported by the 65c02
0033F5r 3  01 3F        	oc__:	.byte 1, "?"
0033F7r 3               
0033F7r 3               ; used to calculate size of assembled disassembler code
0033F7r 3               disassembler_end:
0033F7r 3               
0033F7r 2               .include "ed.asm"               ; Line-based editor ed6502
0033F7r 3               ; ed6502 - Ed-like line-based editor for Tali Forth 2
0033F7r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
0033F7r 3               ; First version: 13. Okt 2018
0033F7r 3               ; This version: 28. Dec 2018
0033F7r 3               
0033F7r 3               ; Ed is a line-orientated editor for Tali Forth 2 based on the classic Unix
0033F7r 3               ; editor of the same name. It is included because a) I like line editors and
0033F7r 3               ; this is my project, so there, and b) as a very simple editor that will work
0033F7r 3               ; even if there is no vt100 terminal support, just with ASCII if needs be. For
0033F7r 3               ; further information on ed, see
0033F7r 3               
0033F7r 3               ;   https://en.wikipedia.org/wiki/Ed_(text_editor)
0033F7r 3               ;   https://www.gnu.org/software/ed/ed.html
0033F7r 3               ;   https://www.gnu.org/software/ed/manual/ed_manual.html
0033F7r 3               ;   https://sanctum.geek.nz/arabesque/actually-using-ed/
0033F7r 3               ;   http://www.psue.uni-hannover.de/wise2017_2018/material/ed.pdf
0033F7r 3               
0033F7r 3               ; We start editor from Forth with
0033F7r 3               ;
0033F7r 3               ;       ed ( -- addr u )
0033F7r 3               ;
0033F7r 3               ; The return values ( addr u ) are the address and length of the text written.
0033F7r 3               ; If no text was written, u is zero and addr is undefined.
0033F7r 3               
0033F7r 3               ; In the working memory, the text is stored as a simple linked list of lines.
0033F7r 3               ; Each node consists of three 16-bit entries:
0033F7r 3               
0033F7r 3               ;       - pointer to next entry (0 for end of list)
0033F7r 3               ;       - pointer to beginning of string ( addr )
0033F7r 3               ;       - length of string ( u )
0033F7r 3               
0033F7r 3               ; The editor only works in interaction with slow humans, so speed is not
0033F7r 3               ; a primary concern. We try to keep the size down instead.
0033F7r 3               
0033F7r 3               ; Where to put variables is a bit of a problem. To convert the numbers, we need
0033F7r 3               ; UM/MOD, which uses the scratchpad, and ACCEPT uses tmp1, tmp2, and tmp3 at
0033F7r 3               ; some point, so we either have to pay very close attention, or we do something
0033F7r 3               ; else. After some experimenting, it seems that the easiest way for this sort
0033F7r 3               ; of hybrid Forth/assembler system is to keep the parameters for the commands
0033F7r 3               ; on the Data Stack in the form of ( para1 para2 ):
0033F7r 3               
0033F7r 3               ;       TOS: parameter 2 (after the comma)
0033F7r 3               ;       NOS: parameter 1 (before the comma)
0033F7r 3               
0033F7r 3               ; The third and fourth entries on the stack are the ( addr-t u-t ) entries the
0033F7r 3               ; text will be/has been written to, or u as 0 if nothing was defined.
0033F7r 3               
0033F7r 3               ; We also need a pointer to the beginning of the text (first node of the list),
0033F7r 3               ; the number of the current line, and a flag to mark if the text has been
0033F7r 3               ; changed. We have six bytes of zero page reserved for any editor to use. Note
0033F7r 3               ; that this means that we can't use two editors at the same time, which won't
0033F7r 3               ; be a problem until we can multitask.
0033F7r 3               
0033F7r 3               ed_head =  editor1  ; pointer to first list element (addr) (2 bytes)
0033F7r 3               ed_cur =   editor2  ; current line number (1 is first line) (2 bytes)
0033F7r 3               ed_flags = editor3  ; Flags used by ed, where
0033F7r 3               ;       bit 7 parameters - 0: none, 1: have at least one parameter
0033F7r 3               ;       bit 6 changed    - 0: text not changed, 1: text was changed
0033F7r 3               ;       bit 0 printing   - 0: no line numbers (p), 1: with line numbers (n)
0033F7r 3               
0033F7r 3               ;  Byte editor3+1 is currently unused
0033F7r 3               
0033F7r 3               
0033F7r 3               ed6502:
0033F7r 3                               ; Start a new empty linked list at HERE. This is also
0033F7r 3                               ; the current line
0033F7r 3  64 2E                        stz ed_head
0033F9r 3  64 2F                        stz ed_head+1
0033FBr 3               
0033FBr 3                               ; The current line is 0, because we start counting at
0033FBr 3                               ; line 1 for the humans
0033FBr 3  64 30                        stz ed_cur
0033FDr 3  64 31                        stz ed_cur+1
0033FFr 3               
0033FFr 3                               ; At the beginning, we have no parameters (bit 7), no line
0033FFr 3                               ; numbers (bit 0), and nothing was changed (bit 6)
0033FFr 3  64 32                        stz ed_flags
003401r 3               
003401r 3                               ; We put zeros as placeholders for the text we've written to
003401r 3                               ; (the "target") on the stack. Because the stack picture is
003401r 3                               ; going to get very confusing very fast, we'll mark them
003401r 3                               ; specially with "-t" suffixes in the stack comments.
003401r 3  20 rr rr                     jsr xt_zero
003404r 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t )
003407r 3               
003407r 3  20 rr rr                     jsr xt_cr
00340Ar 3               
00340Ar 3               _input_loop:
00340Ar 3                               ; Set parameter flag to none (bit 7); default printing is
00340Ar 3                               ; without line numbers (bit 0). We leave the changed flag (bit
00340Ar 3                               ; 6) because we might be coming from a previous add
00340Ar 3  A9 81                        lda #%10000001
00340Cr 3  14 32                        trb ed_flags
00340Er 3               
00340Er 3                               ; We really don't want to have to write a complete
00340Er 3                               ; parser for such a simple editor, so we walk through the
00340Er 3                               ; possibilities the hard way. Get input from the user. This
00340Er 3                               ; routine handles any errors from REFILL
00340Er 3  20 rr rr                     jsr _get_input
003411r 3               
003411r 3                               ; If we were not given an empty line, see what we were given
003411r 3  A5 0A                        lda ciblen
003413r 3  D0 1F                        bne _command_mode
003415r 3               
003415r 3                               ; We were given an empty line. Advance one line, print it, and
003415r 3                               ; make it the new current line
003415r 3  CA                           dex
003416r 3  CA                           dex                     ; ( addr-t u-t ? )
003417r 3               
003417r 3  A5 30                        lda ed_cur
003419r 3  95 00                        sta 0,x
00341Br 3  A5 31                        lda ed_cur+1
00341Dr 3  95 01                        sta 1,x                 ; ( addr-t u-t u )
00341Fr 3               
00341Fr 3                               ; This counts as having a parameter
00341Fr 3  A9 80                        lda #%10000000
003421r 3  04 32                        tsb ed_flags
003423r 3               
003423r 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t u+1 )
003426r 3  20 rr rr                     jsr _is_valid_line
003429r 3  B0 03                        bcs @1
00342Br 3               
00342Br 3                               ; New line number is not legal, abort
00342Br 3  4C rr rr                     jmp _error_1drop
00342Er 3               @1:
00342Er 3                               ; We have a legal line number, but we need two entries on
00342Er 3                               ; the parameter list (four if you count the target
00342Er 3                               ; address) to be able to work with the rest of the program.
00342Er 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t u+1 0 )
003431r 3               
003431r 3  4C rr rr                     jmp _line_number_only_from_external
003434r 3               
003434r 3               _command_mode:
003434r 3               
003434r 3                               ; We were given something other than an empty line. Set the
003434r 3                               ; parameter variables to zero as the default. There is no line
003434r 3                               ; zero, because we're coding for normal, sane humans, not weird
003434r 3                               ; computer people. Some commands like "a" will take a "line 0",
003434r 3                               ; however. We use the ed_flags bit 7 to signal if we are
003434r 3                               ; without parameters.
003434r 3  20 rr rr                     jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
003437r 3  20 rr rr                     jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
00343Ar 3               
00343Ar 3                               ; We start off by taking care of any parameters. These can be
00343Ar 3                               ; '%' for the complete text, '$' for the last line, a line
00343Ar 3                               ; number, or a line number followed by a ',' and then either
00343Ar 3                               ; the '$' for the last line or another number. (The original
00343Ar 3                               ; Unix ed has more options, but we're ignoring them for the
00343Ar 3                               ; moment.) In pseudocode, what we are doing in this stage looks
00343Ar 3                               ; something like this:
00343Ar 3               
00343Ar 3                               ;        case char = '.':
00343Ar 3                               ;              para1 = current line
00343Ar 3                               ;
00343Ar 3                               ;        case char = '$':
00343Ar 3                               ;              para1 = last line
00343Ar 3                               ;
00343Ar 3                               ;        case char = '%' or ',':
00343Ar 3                               ;              para1 = 1
00343Ar 3                               ;              para2 = last line
00343Ar 3                               ;
00343Ar 3                               ;        case char = ';':
00343Ar 3                               ;              para1 = current line
00343Ar 3                               ;              para2 = last line
00343Ar 3                               ;
00343Ar 3                               ;        case number:
00343Ar 3                               ;              para1 = number
00343Ar 3                               ;              get next char
00343Ar 3                               ;
00343Ar 3                               ;              if char = ',':
00343Ar 3                               ;                      get next char
00343Ar 3                               ;
00343Ar 3                               ;                      case char = '$':
00343Ar 3                               ;                              para2 = last line
00343Ar 3                               ;
00343Ar 3                               ;                      case number:
00343Ar 3                               ;                              para2 = number
00343Ar 3                               ;
00343Ar 3                               ;                      else error
00343Ar 3                               ;
00343Ar 3                               ;              else get previous char
00343Ar 3                               ;
00343Ar 3                               ;        else error
00343Ar 3                               ;
00343Ar 3                               ;        get next char
00343Ar 3                               ;        process command char
00343Ar 3               
00343Ar 3                               ; We use the Y register as an offset to the beginning of the
00343Ar 3                               ; character input buffer (cib) because we're never going to
00343Ar 3                               ; have more than 255 characters of input with ed and we don't
00343Ar 3                               ; want to have to duplicate the complete machinery required for
00343Ar 3                               ; >IN. In other words, >IN has no meaning for ed. This means
00343Ar 3                               ; that every jmp to _check_command must have Y in a defined
00343Ar 3                               ; state, which is different from the rest of Tali Forth.
00343Ar 3               
00343Ar 3                               ; Parameter processing could probably be handled more
00343Ar 3                               ; efficiently with a loop construct similar to the way the
00343Ar 3                               ; commands are taken care of below. We'll revisit this once ed
00343Ar 3                               ; is feature complete, because of the evils of premature
00343Ar 3                               ; optimization.
00343Ar 3               
00343Ar 3               _prefix_dot:
00343Ar 3                               ; --- . --- Designate current line for further operations
00343Ar 3  B2 08                        lda (cib)
00343Cr 3  C9 2E                        cmp #$2e                ; ASCII '.'
00343Er 3  D0 3A                        bne _prefix_dollar
003440r 3               
003440r 3  20 rr rr                     jsr _have_text
003443r 3               
003443r 3  A5 30                        lda ed_cur
003445r 3  95 02                        sta 2,x
003447r 3  A5 31                        lda ed_cur+1
003449r 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
00344Br 3               
00344Br 3                               ; We have a parameter
00344Br 3  A9 80                        lda #%10000000
00344Dr 3  04 32                        tsb ed_flags
00344Fr 3               
00344Fr 3                               ; If we were only given a '.', we print the current line and are
00344Fr 3                               ; done
00344Fr 3  A5 0A                        lda ciblen
003451r 3  3A                           dec                     ; sets Z if A was 1
003452r 3  D0 03                        bne @1
003454r 3               
003454r 3                               ; We know that we have some text and the number of the last
003454r 3                               ; line was provided by _last_line, so in theory we don't have
003454r 3                               ; to check if this is a legal line number. However, we keep one
003454r 3                               ; entry point, so the check is repeated further down. Call it
003454r 3                               ; paranoia.
003454r 3  4C rr rr                     jmp _line_number_only_from_external
003457r 3               @1:
003457r 3                               ; We have processed the first parameter, and know that we have
003457r 3                               ; more than just a dot here. We now need to see if the next
003457r 3                               ; character is a comma or a command character. To do this, we
003457r 3                               ; need to modify the stack to ( addr-t u-t para1 0 addr u )
003457r 3  CA                           dex
003458r 3  CA                           dex
003459r 3  CA                           dex
00345Ar 3  CA                           dex
00345Br 3               
00345Br 3  A5 08                        lda cib
00345Dr 3  95 02                        sta 2,x
00345Fr 3  A5 09                        lda cib+1
003461r 3  95 03                        sta 3,x
003463r 3               
003463r 3  A5 0A                        lda ciblen
003465r 3  95 00                        sta 0,x
003467r 3  A5 0B                        lda ciblen+1
003469r 3  95 01                        sta 1,x
00346Br 3               
00346Br 3  20 rr rr                     jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
00346Er 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
003471r 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
003474r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
003477r 3               
003477r 3  4C rr rr                     jmp _check_for_para2
00347Ar 3               
00347Ar 3               _prefix_dollar:
00347Ar 3                               ; --- $ --- Designate last line for further operations
00347Ar 3  B2 08                        lda (cib)
00347Cr 3  C9 24                        cmp #'$'
00347Er 3  D0 1C                        bne _prefix_percent
003480r 3               
003480r 3  20 rr rr                     jsr _have_text
003483r 3               
003483r 3  E8                           inx
003484r 3  E8                           inx                     ; ( addr-t u-t 0 )
003485r 3               
003485r 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t 0 para1 )
003488r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
00348Br 3               
00348Br 3                               ; We have a parameter
00348Br 3  A9 80                        lda #%10000000
00348Dr 3  04 32                        tsb ed_flags
00348Fr 3               
00348Fr 3                               ; If we were only given a '$', we print the last line and are
00348Fr 3                               ; done
00348Fr 3  A5 0A                        lda ciblen
003491r 3  3A                           dec                     ; sets Z if A was 1
003492r 3  D0 03                        bne @1
003494r 3               
003494r 3                               ; We know that we have some text and the number of the last
003494r 3                               ; line was provided by _last_line, so in theory we don't have
003494r 3                               ; to check if this is a legal line number. However, we keep one
003494r 3                               ; entry point for the moment and repeat the check further down
003494r 3                               ; out of paranoia
003494r 3  4C rr rr                     jmp _line_number_only_from_external
003497r 3               @1:
003497r 3                               ; We are one character into the input buffer cib, so we advance
003497r 3                               ; Y as the index accordingly
003497r 3  A0 01                        ldy #01
003499r 3               
003499r 3  4C rr rr                     jmp _check_command
00349Cr 3               
00349Cr 3               _prefix_percent:
00349Cr 3                               ; --- % and , --- Designate whole text for futher operations
00349Cr 3  B2 08                        lda (cib)
00349Er 3  C9 25                        cmp #$25                ; ASCII '%'
0034A0r 3  F0 04                        beq _whole_text
0034A2r 3  C9 2C                        cmp #$2c                ; ASCII ','
0034A4r 3  D0 17                        bne _prefix_semicolon
0034A6r 3               
0034A6r 3               _whole_text:
0034A6r 3                               ; If there is no text yet, print an error
0034A6r 3  20 rr rr                     jsr _have_text
0034A9r 3               
0034A9r 3                               ; We have at least one line of text. The first parameter
0034A9r 3                               ; is therefore line one, the second the last line
0034A9r 3  A9 01                        lda #01
0034ABr 3  95 02                        sta 2,x                 ; LSB of NOS is para 1
0034ADr 3  74 03                        stz 3,x                 ; ( addr-t u-t para1 0 )
0034AFr 3               
0034AFr 3               _semicolon_entry:
0034AFr 3                               ; Get the number (not the address) of the last line and
0034AFr 3                               ; store it as the second parameter
0034AFr 3  E8                           inx
0034B0r 3  E8                           inx                     ; DROP ( addr-t u-t para1 )
0034B1r 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
0034B4r 3               
0034B4r 3                               ; We have a parameter
0034B4r 3  A9 80                        lda #%10000000
0034B6r 3  04 32                        tsb ed_flags
0034B8r 3               
0034B8r 3                               ; We are one character into the input buffer cib, so we advance
0034B8r 3                               ; Y as the index accordingly
0034B8r 3  A0 01                        ldy #01
0034BAr 3               
0034BAr 3  4C rr rr                     jmp _check_command
0034BDr 3               
0034BDr 3               _prefix_semicolon:
0034BDr 3                               ; --- ; --- Designate from current line to end of text
0034BDr 3  B2 08                        lda (cib)
0034BFr 3  C9 3B                        cmp #$3b                ; ASCII ';'
0034C1r 3  D0 0D                        bne _prefix_number
0034C3r 3               
0034C3r 3  20 rr rr                     jsr _have_text
0034C6r 3               
0034C6r 3                               ; The first parameter is the current line
0034C6r 3  A5 30                        lda ed_cur
0034C8r 3  95 02                        sta 2,x
0034CAr 3  A5 31                        lda ed_cur+1
0034CCr 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
0034CEr 3               
0034CEr 3                               ; The second parameter is the last line. We've done this part
0034CEr 3                               ; before for the '%' and ',' parameters, so we reuse that code
0034CEr 3  80 DF                        bra _semicolon_entry
0034D0r 3               
0034D0r 3               _prefix_number:
0034D0r 3                               ; --- <NUM> --- Check if we have been given a number
0034D0r 3               
0034D0r 3                               ; We use the built-in Forth routines for this, which involves
0034D0r 3                               ; calling >NUMBER, which calls UM*, which uses tmp1, tmp2, and
0034D0r 3                               ; tmp3. So we can't use any of those temporary variables. We
0034D0r 3                               ; arrive here with ( addr-t u-t 0 0 ), which doesn't help us at
0034D0r 3                               ; all because the string we are looking at is in ( cib ciblen )
0034D0r 3               
0034D0r 3                               ; Set up >NUMBER using CIB and CIBLEN as the location of the
0034D0r 3                               ; string to check. First, though, add the "accumulator" of
0034D0r 3                               ; >NUMBER as a double number, that is, to single-cell numbers
0034D0r 3  20 rr rr                     jsr xt_zero
0034D3r 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
0034D6r 3               
0034D6r 3  CA                           dex
0034D7r 3  CA                           dex
0034D8r 3  CA                           dex
0034D9r 3  CA                           dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
0034DAr 3               
0034DAr 3  A5 08                        lda cib
0034DCr 3  95 02                        sta 2,x
0034DEr 3  A5 09                        lda cib+1
0034E0r 3  95 03                        sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
0034E2r 3               
0034E2r 3  A5 0A                        lda ciblen
0034E4r 3  95 00                        sta 0,x
0034E6r 3  A5 0B                        lda ciblen+1
0034E8r 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
0034EAr 3               
0034EAr 3  20 rr rr                     jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
0034EDr 3               
0034EDr 3                               ; If we converted all the characters in the string (u2 is
0034EDr 3                               ; zero), then the user just gave us a line number to
0034EDr 3                               ; jump to and nothing else. Otherwise, take another look
0034EDr 3  B5 00                        lda 0,x
0034EFr 3  15 01                        ora 1,x
0034F1r 3  D0 24                        bne _have_unconverted_chars
0034F3r 3               
0034F3r 3                               ; We must have a line number and nothing else. Make this
0034F3r 3                               ; the current line number and print the line. Remember
0034F3r 3                               ; that at this point, the line number still could be a zero
0034F3r 3  E8                           inx
0034F4r 3  E8                           inx
0034F5r 3  E8                           inx
0034F6r 3  E8                           inx                     ; 2DROP ( addr-t u-t 0 0 ud )
0034F7r 3               
0034F7r 3  20 rr rr                     jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
0034FAr 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
0034FDr 3               
0034FDr 3  E8                           inx
0034FEr 3  E8                           inx                     ; ( addr-t u-t u 0 ) drop through
0034FFr 3               
0034FFr 3               _line_number_only_from_external:
0034FFr 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t 0 u )
003502r 3               
003502r 3  20 rr rr                     jsr _is_valid_line
003505r 3  B0 03                        bcs @1
003507r 3               
003507r 3                               ; This is not a valid line number, so we bail
003507r 3  4C rr rr                     jmp _error_2drop
00350Ar 3               @1:
00350Ar 3                               ; Legal line number, so make it the current number
00350Ar 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t u 0 )
00350Dr 3  20 rr rr                     jsr _para1_to_cur
003510r 3               
003510r 3                               ; We have a parameter
003510r 3  A9 80                        lda #%10000000
003512r 3  04 32                        tsb ed_flags
003514r 3               
003514r 3  4C rr rr                     jmp _cmd_p_from_external
003517r 3               
003517r 3               _have_unconverted_chars:
003517r 3                               ; We have some unconverted characters left. If none of the
003517r 3                               ; characters were converted, we probably just got a
003517r 3                               ; command character and need to skip the rest of the prefix
003517r 3                               ; processing. In this case, the number of unconverted
003517r 3                               ; characters is equal to the length of the string.
003517r 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
00351Ar 3               
00351Ar 3  CA                           dex
00351Br 3  CA                           dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
00351Cr 3               
00351Cr 3  A5 0A                        lda ciblen
00351Er 3  95 00                        sta 0,x
003520r 3  A5 0B                        lda ciblen+1
003522r 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
003524r 3               
003524r 3  20 rr rr                     jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
003527r 3               
003527r 3  B5 00                        lda 0,x
003529r 3  15 01                        ora 1,x
00352Br 3  F0 0E                        beq _no_command_yet
00352Dr 3               
00352Dr 3                               ; The length of the input string is equal to the length of the
00352Dr 3                               ; unprocessed string that >NUMBER returned. Put differently,
00352Dr 3                               ; the first character isn't a number. We know that it isn't '$'
00352Dr 3                               ; or '%' either, so we assume that it's a command character.
00352Dr 3               
00352Dr 3                               ; Clear up the stack and process that command character
00352Dr 3  8A                           txa
00352Er 3  18                           clc
00352Fr 3  69 0A                        adc #10
003531r 3  AA                           tax                     ; ( addr-t u-t 0 0 )
003532r 3               
003532r 3                               ; If we weren't given a number, this means we didn't explicitly
003532r 3                               ; get a 0 either. So we don't have a parameter. This is the
003532r 3                               ; default case, but out of paranoia we explicity clear the flag
003532r 3  A9 80                        lda #%10000000
003534r 3  14 32                        trb ed_flags
003536r 3               
003536r 3                               ; We don't have any offset, so we go with Y as zero
003536r 3  A0 00                        ldy #00
003538r 3               
003538r 3  4C rr rr                     jmp _check_command
00353Br 3               
00353Br 3               _no_command_yet:
00353Br 3                               ; There actually seems to be a parameter number present.
00353Br 3                               ; Save the number we converted as the first parameter. We
00353Br 3                               ; arrive here with ( addr-t u-t 0 0 ud addr2 u2 f ) from
00353Br 3                               ; >NUMBER. To avoid too long stack comments, we leave the
00353Br 3                               ; target addresses out in this next code segment.
00353Br 3  E8                           inx
00353Cr 3  E8                           inx                     ; ( ... 0 0 ud addr2 u2 )
00353Dr 3               
00353Dr 3  20 rr rr                     jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
003540r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
003543r 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
003546r 3               
003546r 3  B5 00                        lda 0,x                 ; LSB
003548r 3  95 06                        sta 6,x
00354Ar 3  B5 01                        lda 1,x                 ; MSB
00354Cr 3  95 07                        sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
00354Er 3               
00354Er 3  E8                           inx
00354Fr 3  E8                           inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
003550r 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
003553r 3               
003553r 3                               ; We have a parameter
003553r 3  A9 80                        lda #%10000000
003555r 3  04 32                        tsb ed_flags
003557r 3               
003557r 3               _check_for_para2:
003557r 3                               ; That was the first parameter. If the next character is
003557r 3                               ; a comma, then there is a second parameter (another number
003557r 3                               ; or '$'). Otherwise we expect a command. This is the entry
003557r 3                               ; point if the first character was a dot (eg '.,3p')
003557r 3  A1 02                        lda (2,x)
003559r 3               
003559r 3  C9 2C                        cmp #$2c                ; ASCII code for ',' (comma)
00355Br 3  F0 0D                        beq _got_comma
00355Dr 3               
00355Dr 3                               ; It's not a comma, so it's going to be a command character.
00355Dr 3                               ; We need to figure out how many digits our number has so
00355Dr 3                               ; we can adjust Y as the offset. We don't have to do this with
00355Dr 3                               ; 16 bit because no input string is going to be that long
00355Dr 3  38                           sec
00355Er 3  A5 0A                        lda ciblen
003560r 3  F5 00                        sbc 0,x
003562r 3  A8                           tay
003563r 3               
003563r 3                               ; Remove the leftover stuff from >NUMBER
003563r 3  E8                           inx
003564r 3  E8                           inx
003565r 3  E8                           inx
003566r 3  E8                           inx                     ; 2DROP ( addr-t u-t para1 0 )
003567r 3               
003567r 3  4C rr rr                     jmp _check_command
00356Ar 3               
00356Ar 3               _got_comma:
00356Ar 3                               ; It's a comma, so we have a second parameter. The next
00356Ar 3                               ; character can either be '$' to signal the end of the text
00356Ar 3                               ; or another number. First, though, move to that next char
00356Ar 3  F6 02                        inc 2,x
00356Cr 3  D0 02                        bne @1
00356Er 3  F6 03                        inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
003570r 3               @1:
003570r 3  B5 01                        lda 1,x
003572r 3  F0 02                        beq @2
003574r 3  D6 01                        dec 1,x
003576r 3               @2:
003576r 3  D6 00                        dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
003578r 3               
003578r 3                               ; See if this is an end-of-line '$'
003578r 3  A1 02                        lda (2,x)
00357Ar 3  C9 24                        cmp #$24                ; ASCII for '$'
00357Cr 3  D0 14                        bne _para2_not_dollar
00357Er 3               
00357Er 3                               ; It's a dollar sign, which means para2 is the number of the
00357Er 3                               ; last line of the text. We need to adjust Y as the offset. We
00357Er 3                               ; assume that no command line will be longer than 255
00357Er 3                               ; characters in ed so we can get away with just looking at
00357Er 3                               ; the LSB
00357Er 3  38                           sec
00357Fr 3  A5 0A                        lda ciblen
003581r 3  F5 02                        sbc 2,x
003583r 3  A8                           tay
003584r 3               
003584r 3                               ; However, we need to move Y up by one because we were on the
003584r 3                               ; '$' and not on the character after that
003584r 3  C8                           iny
003585r 3  5A                           phy
003586r 3               
003586r 3                               ; Dump all the stuff from >NUMBER off the stack. This saves
003586r 3                               ; one byte compared to six INX instructions, and a byte saved
003586r 3                               ; is a byte earned.
003586r 3  8A                           txa
003587r 3  18                           clc
003588r 3  69 06                        adc #06
00358Ar 3  AA                           tax                     ; ( addr-t u-t para1 )
00358Br 3               
00358Br 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
00358Er 3               
00358Er 3  7A                           ply
00358Fr 3  4C rr rr                     jmp _check_command
003592r 3               
003592r 3               _para2_not_dollar:
003592r 3                               ; It's not a dollar sign, so it is either another number or an
003592r 3                               ; error. We try for a number first. We arrive here with ( para1
003592r 3                               ; 0 addr2+1 u2-1 ), which u2-1 pointing to the first mystery
003592r 3                               ; character after the comma. Again, we skip the ( addr-t u-t )
003592r 3                               ; at the beginning of the stack comment here.
003592r 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
003595r 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
003598r 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
00359Br 3  20 rr rr                     jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
00359Er 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
0035A1r 3               
0035A1r 3                               ; We'll need a copy of the length of the rest of the string to
0035A1r 3                               ; see if we've actually done any work
0035A1r 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
0035A4r 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
0035A7r 3               
0035A7r 3  20 rr rr                     jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
0035AAr 3               
0035AAr 3                               ; If the original string and the leftover string have the same
0035AAr 3                               ; length, then nothing was converted and we have an error
0035AAr 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
0035ADr 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
0035B0r 3  20 rr rr                     jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
0035B3r 3               
0035B3r 3  B5 00                        lda 0,x
0035B5r 3  15 01                        ora 1,x
0035B7r 3  F0 08                        beq _second_number
0035B9r 3               
0035B9r 3                               ; The strings are the same length, so nothing was converted, so
0035B9r 3                               ; we have an error. We have to get all that stuff off the
0035B9r 3                               ; stack first
0035B9r 3  8A                           txa
0035BAr 3  18                           clc
0035BBr 3  69 0C                        adc #12
0035BDr 3  AA                           tax                     ; back to ( addr-t u-t )
0035BEr 3               
0035BEr 3  4C rr rr                     jmp _error
0035C1r 3               
0035C1r 3               _second_number:
0035C1r 3                               ; We have a second number, so we add it to para2. We arrive here
0035C1r 3                               ; with ( para1 0 ud addr3 u3 f )
0035C1r 3  E8                           inx
0035C2r 3  E8                           inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
0035C3r 3               
0035C3r 3                               ; Calculate the offset for Y
0035C3r 3  38                           sec
0035C4r 3  A5 0A                        lda ciblen
0035C6r 3  F5 00                        sbc 0,x
0035C8r 3  48                           pha
0035C9r 3               
0035C9r 3                               ; Clean up the stack
0035C9r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
0035CCr 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
0035CFr 3  20 rr rr                     jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
0035D2r 3               
0035D2r 3  7A                           ply
0035D3r 3               
0035D3r 3                               ; fall through to _check_command
0035D3r 3               
0035D3r 3               _check_command:
0035D3r 3                               ; At this point, we assume that we have handled any parameters
0035D3r 3                               ; which are now in their place on the stack, which must have
0035D3r 3                               ; the format ( addr-t u-t para1 para2 ). Also, any offset to CIB
0035D3r 3                               ; is going to be in Y. Bit 7 in ed_flags signals if we have
0035D3r 3                               ; a parameter or not.
0035D3r 3               
0035D3r 3                               ; Command character checking works by comparing the char we
0035D3r 3                               ; have at CIB+Y with a list of legal characters. The index in
0035D3r 3                               ; the list is the index of the command's routine in a jump
0035D3r 3                               ; table. The list itself is zero-terminated, which is okay
0035D3r 3                               ; because we've taken care of any legal parameters.
0035D3r 3  B1 08                        lda (cib),y             ; get mystery char from input
0035D5r 3  85 24                        sta tmp1
0035D7r 3               
0035D7r 3                               ; We're going to need X for the jump table, so it has to
0035D7r 3                               ; take a break from being the Data Stack Pointer (DSP). Pushing
0035D7r 3                               ; X to the stack uses less space than storing in the reserved
0035D7r 3                               ; space on the Zero Page
0035D7r 3  DA                           phx
0035D8r 3  A2 00                        ldx #00
0035DAr 3               _cmd_loop:
0035DAr 3  BD rr rr                     lda ed_cmd_list,x
0035DDr 3  F0 07                        beq _illegal_command    ; zero marks end of list
0035DFr 3               
0035DFr 3  C5 24                        cmp tmp1
0035E1r 3  F0 07                        beq _found_cmd
0035E3r 3               
0035E3r 3                               ; No match, next char
0035E3r 3  E8                           inx
0035E4r 3  80 F4                        bra _cmd_loop
0035E6r 3               
0035E6r 3               _illegal_command:
0035E6r 3                               ; Whatever the user gave us, we don't recognize it
0035E6r 3  FA                           plx
0035E7r 3               
0035E7r 3  4C rr rr                     jmp _error_2drop
0035EAr 3               
0035EAr 3               _found_cmd:
0035EAr 3                               ; We have a command match. Because this is the 65c02 and not
0035EAr 3                               ; the 65816, we can only use JMP (addr,x) and not a subroutine
0035EAr 3                               ; jump. That sucks.
0035EAr 3  8A                           txa
0035EBr 3  0A                           asl
0035ECr 3  AA                           tax                     ; X * 2 for table
0035EDr 3               
0035EDr 3                               ; Note we're jumping with the DSP still on the stack, so each
0035EDr 3                               ; command routine has to pull it into X the very first thing
0035EDr 3                               ; with its very own PLX. There doesn't seem to be a sane way to
0035EDr 3                               ; avoid this.
0035EDr 3  7C rr rr                     jmp (ed_cmd_table,x)
0035F0r 3               
0035F0r 3               _next_command:
0035F0r 3                               ; Clean up the stack and return to the input loop. We
0035F0r 3                               ; arrive here with ( addr-t u-t para1 para2 ). The called
0035F0r 3                               ; command routines have taken care of putting the DSP (that's
0035F0r 3                               ; X) back the way it should be
0035F0r 3  E8                           inx
0035F1r 3  E8                           inx
0035F2r 3  E8                           inx
0035F3r 3  E8                           inx                     ; ( addr-t u-t ) Fall through
0035F4r 3               
0035F4r 3               _next_command_empty:
0035F4r 3                               ; The beginning of the input loop takes care of resetting the
0035F4r 3                               ; parameter flag
0035F4r 3  4C rr rr                     jmp _input_loop
0035F7r 3               
0035F7r 3               _all_done:
0035F7r 3                               ; That's enough for ed today. We have to clear out the input
0035F7r 3                               ; buffer or else the Forth main main loop will react to the
0035F7r 3                               ; last input command
0035F7r 3  64 0A                        stz ciblen
0035F9r 3  64 0B                        stz ciblen+1
0035FBr 3               
0035FBr 3                               ; Clean up the stack
0035FBr 3  20 rr rr                     jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
0035FEr 3               
0035FEr 3  60                           rts
0035FFr 3               
0035FFr 3               
0035FFr 3               ; === COMMAND ROUTINES ====
0035FFr 3               
0035FFr 3               ; We enter all command subroutines with ( addr-t u-t para1 para2 ) and the DSP
0035FFr 3               ; still on the Return Stack. This means that the first oder of business is to
0035FFr 3               ; restore the DSP with PLX -- remember this when you add new commands. At this
0035FFr 3               ; point, we don't need the offset in Y anymore so we are free to use it as we
0035FFr 3               ; please.
0035FFr 3               
0035FFr 3               ; There is potential to rewrite many of the command routines with an abstract
0035FFr 3               ; construct in the form of (pseudocode):
0035FFr 3               
0035FFr 3               ;       f = cmd         ; command such as d, p, n, as a function
0035FFr 3               ;       map f range(para1, para2)
0035FFr 3               
0035FFr 3               ; That is, have one routine with a looping structure and pass the actual work
0035FFr 3               ; as a function. However, this is 8-bit assembler and not, say, Haskell, so
0035FFr 3               ; that abstraction will wait for a future round of refracturing when we have
0035FFr 3               ; everything complete and working.
0035FFr 3               
0035FFr 3               ; -------------------------
0035FFr 3               _cmd_a:
0035FFr 3                       ; a -- Add text after current/given line. If no line is given, we use
0035FFr 3                       ; the current line. We accept the number '0' and then start adding at
0035FFr 3                       ; the very beginning. The second parameter is always ignored. This
0035FFr 3                       ; routine is used by i as well.
0035FFr 3  FA                           plx
003600r 3               
003600r 3                               ; We don't care about para2, because a just adds stuff starting
003600r 3                               ; the line we were given
003600r 3  E8                           inx
003601r 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
003602r 3               
003602r 3                               ; If we weren't given a parameter, make the current line the
003602r 3                               ; parameter
003602r 3  24 32                        bit ed_flags
003604r 3  30 08                        bmi _cmd_a_have_para
003606r 3               
003606r 3  A5 30                        lda ed_cur
003608r 3  95 00                        sta 0,x
00360Ar 3  A5 31                        lda ed_cur+1
00360Cr 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
00360Er 3               
00360Er 3               _entry_cmd_i:
00360Er 3                               ; This is where i enters with a parameter that is calculated to
00360Er 3                               ; be one before the current line, or given line, or so that we
00360Er 3                               ; accept 0. We are ( addr-t u-t num )
00360Er 3               
00360Er 3               _cmd_a_have_para:
00360Er 3  20 rr rr                     jsr _num_to_addr        ;  ( addr-t u-t addr1 )
003611r 3  20 rr rr                     jsr xt_cr
003614r 3               
003614r 3               _next_string_loop:
003614r 3                               ; This is where we land when we are continuing in with another
003614r 3                               ; string after the first one. ( addr-t u-t addr1 )
003614r 3  20 rr rr                     jsr _get_input
003617r 3               
003617r 3                               ; If there is only one character and that character is a
003617r 3                               ; dot, we're done with adding text and switch back to command
003617r 3                               ; mode
003617r 3  B2 08                        lda (cib)
003619r 3  C9 2E                        cmp #$2e                ; ASCII for '.'
00361Br 3  D0 16                        bne _add_line
00361Dr 3               
00361Dr 3                               ; So it's a dot, but that the only character in the line?
00361Dr 3                               ; We want the length to be one character exactly
00361Dr 3  A4 0A                        ldy ciblen
00361Fr 3  C0 01                        cpy #01
003621r 3  D0 10                        bne _add_line
003623r 3               
003623r 3  A4 0B                        ldy ciblen+1
003625r 3  D0 0C                        bne _add_line
003627r 3               
003627r 3                               ; Yes, it is a dot, so we're done adding lines.
003627r 3  E8                           inx
003628r 3  E8                           inx
003629r 3               
003629r 3                               ; The string is stored and the new node is full. Time to set the
003629r 3                               ; changed flag
003629r 3  A9 40                        lda #%01000000
00362Br 3  04 32                        tsb ed_flags
00362Dr 3               
00362Dr 3  20 rr rr                     jsr xt_cr
003630r 3  4C rr rr                     jmp _input_loop
003633r 3               
003633r 3               _add_line:
003633r 3                               ; Break the linked list so we can insert another node
003633r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
003636r 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
003639r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
00363Cr 3  20 rr rr                     jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
00363Fr 3  20 rr rr                     jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
003642r 3               
003642r 3                               ; We're going to need that HERE for the next line if more
003642r 3                               ; than one line is added. This is a good time to save it on
003642r 3                               ; the stack
003642r 3  20 rr rr                     jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
003645r 3               
003645r 3                               ; We have now saved the link to the next node at HERE, which is
003645r 3                               ; where the CP was pointing. CP has been advanced by one cell,
003645r 3                               ; but we still have the original as HERE on the stack. That
003645r 3                               ; address now has to go where addr2 was before.
003645r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
003648r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
00364Br 3               
00364Br 3                               ; Thus concludes the mucking about with node links. Now we have
00364Br 3                               ; to create a new header. The CP we access with HERE points to
00364Br 3                               ; the cell after the new node address, which is where we want
00364Br 3                               ; to put ( ) for the new string
00364Br 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t here here2)
00364Er 3               
00364Er 3                               ; Reserve two cells (four bytes on the 65c02) for the ( addr u )
00364Er 3                               ; of the new string
00364Er 3  A5 00                        lda cp
003650r 3  18                           clc
003651r 3  69 04                        adc #04
003653r 3  85 00                        sta cp
003655r 3  90 02                        bcc @1
003657r 3  E6 01                        inc cp+1
003659r 3               @1:
003659r 3                               ; HERE now points to after the new header. Since we're really
003659r 3                               ; going to add something, we can increase the current line
003659r 3                               ; number
003659r 3  E6 30                        inc ed_cur
00365Br 3  D0 02                        bne @2
00365Dr 3  E6 31                        inc ed_cur+1
00365Fr 3               @2:
00365Fr 3                               ; We have the new line sitting in ( cib ciblen ) and need to
00365Fr 3                               ; a) move it somewhere safe and b) get ready for the next
00365Fr 3                               ; line. We arrive here with ( addr-t u-t here here2 ), where here2
00365Fr 3                               ; is where the new string needs to be. The MOVE command we're
00365Fr 3                               ; going to use has the format ( addr1 addr2 u )
00365Fr 3               
00365Fr 3  20 rr rr                     jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
003662r 3  20 rr rr                     jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
003665r 3               
003665r 3  CA                           dex
003666r 3  CA                           dex             ; ( addr-t u-t here here2 here3 here3 ? )
003667r 3  A5 08                        lda cib
003669r 3  95 00                        sta 0,x
00366Br 3  A5 09                        lda cib+1
00366Dr 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
00366Fr 3               
00366Fr 3  20 rr rr                     jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
003672r 3               
003672r 3  CA                           dex
003673r 3  CA                           dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
003674r 3  A5 0A                        lda ciblen
003676r 3  95 00                        sta 0,x
003678r 3  A5 0B                        lda ciblen+1
00367Ar 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
00367Cr 3               
00367Cr 3  20 rr rr                     jsr xt_move     ; ( addr-t u-t here here2 here3 )
00367Fr 3               
00367Fr 3                               ; We need to adjust CP be the length of the string
00367Fr 3  18                           clc
003680r 3  A5 00                        lda cp
003682r 3  65 0A                        adc ciblen
003684r 3  85 00                        sta cp
003686r 3  90 06                        bcc @3
003688r 3  A5 01                        lda cp+1
00368Ar 3  65 0B                        adc ciblen+1
00368Cr 3  85 01                        sta cp+1
00368Er 3               @3:
00368Er 3                               ; The string is now moved safely out of the input buffer to the
00368Er 3                               ; main memory at ( here3 ciblin ). Now we have to fix that
00368Er 3                               ; fact in the header. We start with the address.
00368Er 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
003691r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here here2 )
003694r 3               
003694r 3  20 rr rr                     jsr xt_one_plus         ; 1+
003697r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
00369Ar 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
00369Dr 3               
00369Dr 3  A5 0A                        lda ciblen
00369Fr 3  95 02                        sta 2,x
0036A1r 3  A5 0B                        lda ciblen+1
0036A3r 3  95 03                        sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
0036A5r 3               
0036A5r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
0036A8r 3               
0036A8r 3                               ; Add a line feed for visuals
0036A8r 3  20 rr rr                     jsr xt_cr
0036ABr 3               
0036ABr 3                               ; Remeber that original HERE we've been dragging along all the
0036ABr 3                               ; time? Now we find out why. We return to the loop to pick up
0036ABr 3                               ; the next input
0036ABr 3  4C rr rr                     jmp _next_string_loop
0036AEr 3               
0036AEr 3               ; -------------------------
0036AEr 3               _cmd_d:
0036AEr 3                       ; d -- Delete one or more lines. This might have to be coded as
0036AEr 3                       ; a subroutine because other commands such as 'c' might be easier to
0036AEr 3                       ; implement that way. Note that a lot of this code is very similar to
0036AEr 3                       ; the loop for 'p'. We arrive here with ( addr-t u-t para1 para2 )
0036AEr 3  FA                           plx
0036AFr 3               
0036AFr 3  20 rr rr                     jsr _have_text
0036B2r 3  20 rr rr                     jsr _no_line_zero
0036B5r 3               
0036B5r 3                               ; At least the first line is valid. Most common case is one
0036B5r 3                               ; line, so we check to see if we even have a second parameter.
0036B5r 3  B5 00                        lda 0,x
0036B7r 3  15 01                        ora 1,x
0036B9r 3  D0 08                        bne @1
0036BBr 3               
0036BBr 3                               ; The second parameter is a zero, so delete one line
0036BBr 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 0 para1 )
0036BEr 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
0036C1r 3  80 33                        bra _cmd_d_done
0036C3r 3               @1:
0036C3r 3                               ; We have been given a range. Make sure that the second
0036C3r 3                               ; parameter is legal. We arrive here with ( addr-t u-t para1 para2 )
0036C3r 3  20 rr rr                     jsr _is_valid_line      ; result is in C flag
0036C6r 3  B0 03                        bcs _cmd_d_loop
0036C8r 3               
0036C8r 3                               ; para2 is not valid. Complain and abort
0036C8r 3  4C rr rr                     jmp _error_2drop
0036CBr 3               
0036CBr 3               _cmd_d_loop:
0036CBr 3                               ; Seems to be a legal range. Walk through and delete If para1
0036CBr 3                               ; is larger than para2, we're done. Note that Unix ed throws an
0036CBr 3                               ; error if we start out that way, we might do that in future as
0036CBr 3                               ; well. This is not the same code as for 'p', because we have
0036CBr 3                               ; to delete from the back
0036CBr 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
0036CEr 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
0036D1r 3               
0036D1r 3  B5 00                        lda 0,x
0036D3r 3  15 01                        ora 1,x
0036D5r 3  D0 0D                        bne _cmd_d_done_with_flag
0036D7r 3               
0036D7r 3                               ; Para2 is still larger or the same size as para1, so we
0036D7r 3                               ; continue
0036D7r 3  E8                           inx
0036D8r 3  E8                           inx                     ; Get rid of the flag from >
0036D9r 3               
0036D9r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
0036DCr 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
0036DFr 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
0036E2r 3               
0036E2r 3  80 E7                        bra _cmd_d_loop
0036E4r 3               
0036E4r 3               _cmd_d_done_with_flag:
0036E4r 3  E8                           inx                     ; ( addr-t u-t para1 para2 )
0036E5r 3  E8                           inx
0036E6r 3               
0036E6r 3                               ; The current line is set to the first line minus
0036E6r 3                               ; one. Since we don't accept '0d', this at least
0036E6r 3                               ; hast to be one
0036E6r 3  B5 02                        lda 2,x
0036E8r 3  D0 02                        bne @1
0036EAr 3  D6 03                        dec 3,x
0036ECr 3               @1:
0036ECr 3  D6 02                        dec 2,x
0036EEr 3               
0036EEr 3  B5 02                        lda 2,x
0036F0r 3  85 30                        sta ed_cur
0036F2r 3  B5 03                        lda 3,x
0036F4r 3  85 31                        sta ed_cur+1            ; drop through to _cmd_d_done
0036F6r 3               
0036F6r 3               _cmd_d_done:
0036F6r 3                               ; Text has changed, set flag
0036F6r 3  A9 40                        lda #%01000000
0036F8r 3  04 32                        tsb ed_flags
0036FAr 3               
0036FAr 3  20 rr rr                     jsr xt_cr
0036FDr 3               
0036FDr 3  4C rr rr                     jmp _next_command
003700r 3               
003700r 3               _cmd_d_common:
003700r 3                       ; Internal subroutine to delete a single line when given the line
003700r 3                       ; number TOS. Consumes TOS. What we do is take the link to the next
003700r 3                       ; node and put it in the previous node. The caller is responsible
003700r 3                       ; for setting ed_changed. We arrive here with ( u )
003700r 3               
003700r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t u u )
003703r 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t u addr )
003706r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
003709r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
00370Cr 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
00370Fr 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr1 addr-1 )
003712r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t )
003715r 3               
003715r 3  60                           rts
003716r 3               
003716r 3               ; -------------------------
003716r 3               _cmd_equ:
003716r 3                       ; = --- Print the given line number or the current line number if no
003716r 3                       ; value is given. This is useful if you want to know what the number of
003716r 3                       ; the last line is ("$=")
003716r 3  FA                           plx
003717r 3               
003717r 3                               ; If we don't have a text, we follow Unix ed's example and
003717r 3                               ; print a zero. It would seem to make more sense to throw an
003717r 3                               ; error, but who are we to argue with Unix.
003717r 3  A5 2E                        lda ed_head
003719r 3  05 2F                        ora ed_head+1
00371Br 3  D0 08                        bne _cmd_equ_have_text
00371Dr 3               
00371Dr 3                               ; Fake it: load 0 as para2 and then print. The 0 goes in a new
00371Dr 3                               ; line just like with Unix ed
00371Dr 3  CA                           dex
00371Er 3  CA                           dex
00371Fr 3  74 00                        stz 0,x
003721r 3  74 01                        stz 1,x                 ; ( addr-t u-t para1 para2 0 )
003723r 3  80 21                        bra _cmd_equ_done
003725r 3               
003725r 3               _cmd_equ_have_text:
003725r 3                               ; We have taken care of the case where we don't have a text. If
003725r 3                               ; we have a line zero, it is explicit, and we don't do that
003725r 3  20 rr rr                     jsr _no_line_zero
003728r 3               
003728r 3                               ; If we have no parameters, just print the current line number
003728r 3  24 32                        bit ed_flags
00372Ar 3  30 0C                        bmi _cmd_equ_have_para
00372Cr 3               
00372Cr 3  CA                           dex
00372Dr 3  CA                           dex                     ; ( addr-t u-t para1 para2 ? )
00372Er 3  A5 30                        lda ed_cur
003730r 3  95 00                        sta 0,x
003732r 3  A5 31                        lda ed_cur+1
003734r 3  95 01                        sta 1,x
003736r 3               
003736r 3  80 0E                        bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
003738r 3               
003738r 3               _cmd_equ_have_para:
003738r 3                               ; We have at least one parameter, and we know it is not zero.
003738r 3                               ; We follow the behavior of Unix ed here: If there is one
003738r 3                               ; parameter, we print its line number. If there are two
003738r 3                               ; separated by a comma (etc), we print the second line number
003738r 3                               ; of the range
003738r 3  B5 00                        lda 0,x
00373Ar 3  15 01                        ora 1,x
00373Cr 3  D0 05                        bne _cmd_equ_two_paras
00373Er 3               
00373Er 3                               ; We've got one parameter
00373Er 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1)
003741r 3  80 03                        bra _cmd_equ_done
003743r 3               
003743r 3               _cmd_equ_two_paras:
003743r 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
003746r 3               
003746r 3               _cmd_equ_done:
003746r 3  20 rr rr                     jsr xt_cr               ; number goes on new line
003749r 3  20 rr rr                     jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
00374Cr 3  20 rr rr                     jsr xt_cr
00374Fr 3               
00374Fr 3  4C rr rr                     jmp _next_command
003752r 3               
003752r 3               
003752r 3               ; -------------------------
003752r 3               _cmd_f:
003752r 3                       ; f -- Print the address that a write command ("w") will go to or set
003752r 3                       ; it. If no parameter was passed, we print the address we have on hand,
003752r 3                       ; with a parameter, we set that to the new address. We accept a zero,
003752r 3                       ; though that would be a weird place to write, but we do need a text
003752r 3  FA                           plx
003753r 3               
003753r 3  24 32                        bit ed_flags
003755r 3  30 17                        bmi _cmd_f_have_para
003757r 3               
003757r 3  20 rr rr                     jsr xt_cr
00375Ar 3               
00375Ar 3                               ; No parameters, just a naked "f", so print the address buried
00375Ar 3                               ; at the fourth position of the stack: We arrive here with
00375Ar 3                               ; ( addr-t u-t 0 0 )
00375Ar 3  20 rr rr                     jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
00375Dr 3  20 rr rr                     jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
003760r 3  20 rr rr                     jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
003763r 3  20 rr rr                     jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
003766r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
003769r 3  20 rr rr                     jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
00376Cr 3               
00376Cr 3  80 11                        bra _cmd_f_done
00376Er 3               
00376Er 3               _cmd_f_have_para:
00376Er 3                               ; We do no sanity tests at all. This is Forth, if the user
00376Er 3                               ; wants to blow up the Zero Page and the Stack, sure, go right
00376Er 3                               ; ahead, whatever.
00376Er 3  20 rr rr                     jsr xt_over
003771r 3  20 rr rr                     jsr xt_cr
003774r 3  20 rr rr                     jsr xt_u_dot
003777r 3               
003777r 3  B5 02                        lda 2,x
003779r 3  95 06                        sta 6,x
00377Br 3  B5 03                        lda 3,x
00377Dr 3  95 07                        sta 7,x                 ; fall through to _cmd_f_done
00377Fr 3               
00377Fr 3               _cmd_f_done:
00377Fr 3  20 rr rr                     jsr xt_cr
003782r 3               
003782r 3  4C rr rr                     jmp _next_command
003785r 3               
003785r 3               
003785r 3               ; -------------------------
003785r 3               _cmd_i:
003785r 3                       ; i --- Add text before current line. We allow '0i' and 'i' just like
003785r 3                       ; the Unix ed. Note that this routine just prepares the line numbers so
003785r 3                       ; we can reuse most of the code from a.
003785r 3  FA                           plx
003786r 3               
003786r 3                               ; We don't care about para2, because i just adds stuff before
003786r 3                               ; the line we were given.
003786r 3  E8                           inx
003787r 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
003788r 3               
003788r 3                               ; If we weren't given a parameter, make the current line the
003788r 3                               ; parameter
003788r 3  24 32                        bit ed_flags
00378Ar 3  30 08                        bmi _cmd_i_have_para
00378Cr 3               
00378Cr 3                               ; No parameter, take current line
00378Cr 3  A5 30                        lda ed_cur
00378Er 3  95 00                        sta 0,x
003790r 3  A5 31                        lda ed_cur+1
003792r 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
003794r 3               
003794r 3               _cmd_i_have_para:
003794r 3                               ; If the parameter is zero, we skip the next part and behave
003794r 3                               ; completely like the "a" command
003794r 3  B5 00                        lda 0,x
003796r 3  15 01                        ora 1,x
003798r 3  F0 09                        beq _cmd_i_done
00379Ar 3               
00379Ar 3                               ; We have some other line number, so we start one above it
00379Ar 3  20 rr rr                     jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
00379Dr 3  20 rr rr                     jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
0037A0r 3  20 rr rr                     jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
0037A3r 3               _cmd_i_done:
0037A3r 3  4C rr rr                     jmp _entry_cmd_i
0037A6r 3               
0037A6r 3               
0037A6r 3               ; -------------------------
0037A6r 3               _cmd_n:
0037A6r 3                       ; n -- Print lines with a line number. We just set a flag here and
0037A6r 3                       ; let p do all the heavy work.
0037A6r 3               
0037A6r 3  FA                           plx
0037A7r 3               
0037A7r 3  A9 01                        lda #%00000001
0037A9r 3  04 32                        tsb ed_flags
0037ABr 3               
0037ABr 3  80 05                        bra _cmd_p_entry_for_cmd_n
0037ADr 3               
0037ADr 3               
0037ADr 3               ; -------------------------
0037ADr 3               _cmd_p:
0037ADr 3                       ; p -- Print lines without line numbers. This routine is also used
0037ADr 3                       ; by n, the difference is in a flag. Note that this routine is
0037ADr 3                       ; able to handle line numbers greater than 255 even though it's
0037ADr 3                       ; hard to believe somebody would actually use this editor for anything
0037ADr 3                       ; that long. I'm really sure Leo Tolstoy would not have created "War
0037ADr 3                       ; and Peace" on a 65c02.
0037ADr 3               
0037ADr 3  FA                           plx
0037AEr 3               
0037AEr 3               _cmd_p_from_external:
0037AEr 3                               ; This is coming from p, the variant without line numbers. We
0037AEr 3                               ; set the ed_flags' bit 0 to zero to mark this
0037AEr 3  A9 01                        lda #%00000001
0037B0r 3  14 32                        trb ed_flags
0037B2r 3               
0037B2r 3               _cmd_p_entry_for_cmd_n:
0037B2r 3  20 rr rr                     jsr _have_text
0037B5r 3  20 rr rr                     jsr _no_line_zero
0037B8r 3               
0037B8r 3  20 rr rr                     jsr xt_cr
0037BBr 3               
0037BBr 3                               ; We now know that there is some number in para1. The most
0037BBr 3                               ; common case is that para2 is zero and we're being asked to
0037BBr 3                               ; print a single line
0037BBr 3  B5 00                        lda 0,x
0037BDr 3  15 01                        ora 1,x
0037BFr 3  D0 08                        bne _cmd_p_loop
0037C1r 3               
0037C1r 3                               ; Print a single line and be done with it. We could use
0037C1r 3                               ; DROP here and leave immediately but we want this routine
0037C1r 3                               ; to have a single exit at the bottom.
0037C1r 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
0037C4r 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
0037C7r 3               
0037C7r 3  80 1E                        bra _cmd_p_all_done
0037C9r 3               
0037C9r 3               _cmd_p_loop:
0037C9r 3                               ; We are being asked to print more than one line, which
0037C9r 3                               ; is a bit trickier. If para1 is larger than para2, we're
0037C9r 3                               ; done. Note that Unix ed throws an error if we start out
0037C9r 3                               ; that way, we might do that in future as well
0037C9r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
0037CCr 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
0037CFr 3               
0037CFr 3  B5 00                        lda 0,x
0037D1r 3  15 01                        ora 1,x
0037D3r 3  D0 10                        bne _cmd_p_done
0037D5r 3               
0037D5r 3                               ; Para2 is still larger or the same size as para1, so we
0037D5r 3                               ; continue
0037D5r 3  E8                           inx
0037D6r 3  E8                           inx                     ; Get rid of the flag from >
0037D7r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
0037DAr 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
0037DDr 3               
0037DDr 3  F6 02                        inc 2,x
0037DFr 3  D0 02                        bne @1
0037E1r 3  F6 03                        inc 3,x
0037E3r 3               @1:
0037E3r 3  80 E4                        bra _cmd_p_loop
0037E5r 3               
0037E5r 3               _cmd_p_done:
0037E5r 3                               ; We arrive here with ( addr-t u-t para1 para2 f )
0037E5r 3  E8                           inx
0037E6r 3  E8                           inx                     ; fall through to _cmp_p_all_done
0037E7r 3               _cmd_p_all_done:
0037E7r 3  4C rr rr                     jmp _next_command
0037EAr 3               
0037EAr 3               
0037EAr 3               _cmd_p_common:
0037EAr 3                       ; Internal subroutine to print a single line when given the line number
0037EAr 3                       ; TOS. Consumes TOS. Used by both n and p. We arrive here with
0037EAr 3                       ; ( addr-t u-t para1 ) as the line number
0037EAr 3               
0037EAr 3                               ; See if we're coming from p (no line numbers, ed_flag is zero)
0037EAr 3                               ; or from n (line numbers and a TAB, ed_flag is $FF)
0037EAr 3  A5 32                        lda ed_flags
0037ECr 3  4A                           lsr                     ; bit 0 now in carry
0037EDr 3  90 0B                        bcc _cmd_p_common_no_num
0037EFr 3               
0037EFr 3                               ; Bit 0 is set, this is coming from n. Print the line number
0037EFr 3                               ; followed by a tab
0037EFr 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
0037F2r 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u-t para1 )
0037F5r 3               
0037F5r 3  A9 09                        lda #$09                 ; ASCII for Tab
0037F7r 3  20 rr rr                     jsr emit_a
0037FAr 3               
0037FAr 3               _cmd_p_common_no_num:
0037FAr 3                               ; One way or the other, print the the node's string
0037FAr 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr )
0037FDr 3  20 rr rr                     jsr _print_addr
003800r 3               
003800r 3  60                           rts
003801r 3               
003801r 3               
003801r 3               ; -------------------------
003801r 3               _cmd_q:
003801r 3                       ; q -- Quit if all work as been saved, complain otherwise
003801r 3               
003801r 3  FA                           plx
003802r 3               
003802r 3  24 32                        bit ed_flags            ; bit 6 is change flag
003804r 3  50 03                        bvc @1
003806r 3  4C rr rr                     jmp _error_2drop
003809r 3               @1:
003809r 3  4C rr rr                     jmp _all_done            ; can't fall thru because of PLX
00380Cr 3               
00380Cr 3               
00380Cr 3               ; -------------------------
00380Cr 3               _cmd_qq:
00380Cr 3                       ; Q -- Quit unconditionally, dumping any work that is unsaved
00380Cr 3                       ; without any warning. We can't just jump to all done because
00380Cr 3                       ; of the PLX
00380Cr 3  FA                           plx
00380Dr 3               
00380Dr 3  4C rr rr                     jmp _all_done
003810r 3               
003810r 3               
003810r 3               ; -------------------------
003810r 3               _cmd_w:
003810r 3                       ; w --- Write text to system memory. In contrast to the Unix ed word,
003810r 3                       ; we provide the address before the command, such as "8000w". If no
003810r 3                       ; address is given -- just 'w' -- we write to whatever was fixed with
003810r 3                       ; 'f'. To prevent a common, but potentially common error, we do not
003810r 3                       ; allow writing to the first page ($0000 to $00FF) unless the address
003810r 3                       ; was specificially passed as a parameter. Currently, we can only enter
003810r 3                       ; the address in decimal.
003810r 3  FA                           plx
003811r 3               
003811r 3  20 rr rr                     jsr _have_text
003814r 3               
003814r 3  24 32                        bit ed_flags
003816r 3  30 13                        bmi _cmd_w_have_para
003818r 3               
003818r 3                               ; If we don't have a parameter, we check what is stored on the
003818r 3                               ; stack and use that address -- UNLESS IT IS 0000, which is
003818r 3                               ; what it would be if the user wasn't thinking and just pressed
003818r 3                               ; 'w' at the beginning. We arrive here with ( addr-t u-t 0 0 )
003818r 3  B5 06                        lda 6,x
00381Ar 3  15 07                        ora 7,x
00381Cr 3  D0 03                        bne @1
00381Er 3               
00381Er 3                               ; It's a zero, generate an error to protect the users from
00381Er 3                               ; themselves
00381Er 3  4C rr rr                     jmp _error_2drop
003821r 3               @1:
003821r 3                               ; Not a zero, we assume user knows what they are doing. Get the
003821r 3                               ; address.
003821r 3  B5 06                        lda 6,x
003823r 3  95 02                        sta 2,x
003825r 3  B5 07                        lda 7,x
003827r 3  95 03                        sta 3,x                 ; ( addr-t u-t addr-t ? )
003829r 3               
003829r 3  80 08                        bra _cmd_w_para_ready
00382Br 3               
00382Br 3               _cmd_w_have_para:
00382Br 3                               ; We were given a parameter, which we now make the new
00382Br 3                               ; default parameter. This is different from Unix w, where
00382Br 3                               ; the filename set by f is not changed by w
00382Br 3  B5 02                        lda 2,x
00382Dr 3  95 06                        sta 6,x
00382Fr 3  B5 03                        lda 3,x
003831r 3  95 07                        sta 7,x                 ; drop through to _cmd_w_para_ready
003833r 3               
003833r 3               _cmd_w_para_ready:
003833r 3                               ; We don't care about the second parameter, the first one must
003833r 3                               ; be an address. There is actually no way to test if this is an
003833r 3                               ; address because any number could be a 16-bit address. Anyway,
003833r 3                               ; we overwrite para2 with the address where the pointer to the
003833r 3                               ; first entry in the list is kept.
003833r 3  A9 2E                        lda #<ed_head
003835r 3  95 00                        sta 0,x
003837r 3  A9 00                        lda #>ed_head
003839r 3  95 01                        sta 1,x                 ; ( addr-t u-t addr-t addr-h )
00383Br 3               
00383Br 3                               ; We need to keep a copy of the original target address to
00383Br 3                               ; calculate how many chars (including carriage returns) we
00383Br 3                               ; saved at the end of this routine
00383Br 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
00383Er 3  20 rr rr                     jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
003841r 3               
003841r 3               _cmd_w_loop:
003841r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
003844r 3               
003844r 3                               ; If we're at the end of the list, quit. For the next block of
003844r 3                               ; text, we ignore the ( addr-t u-t ) at the beginning
003844r 3  B5 00                        lda 0,x
003846r 3  15 01                        ora 1,x
003848r 3  F0 55                        beq _cmd_w_eol
00384Ar 3               
00384Ar 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
00384Dr 3  20 rr rr                     jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
003850r 3               
003850r 3                               ; Get the address and length of the string from the header
003850r 3                               ; of this node
003850r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
003853r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
003856r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
003859r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
00385Cr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
00385Fr 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
003862r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
003865r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
003868r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
00386Br 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
00386Er 3  20 rr rr                     jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
003871r 3               
003871r 3                               ; We need a copy of the string length u-s to adjust the pointer
003871r 3                               ; to the store area later
003871r 3  20 rr rr                     jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
003874r 3  20 rr rr                     jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
003877r 3               
003877r 3  20 rr rr                     jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
00387Ar 3               
00387Ar 3                               ; Calculate the position of the next string in the save area.
00387Ar 3                               ; What we don't do is remember the length of the individual
00387Ar 3                               ; strings; instead at the end we will subtract addresses to
00387Ar 3                               ; get the length of the string
00387Ar 3  20 rr rr                     jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
00387Dr 3  20 rr rr                     jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
003880r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
003883r 3  20 rr rr                     jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
003886r 3               
003886r 3                               ; But wait, our strings are terminated by Line Feeds in
003886r 3                               ; memory, so we need to add one
003886r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
003889r 3               
003889r 3  CA                           dex
00388Ar 3  CA                           dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
00388Br 3  A9 0A                        lda #AscLF              ; ASCII for LF
00388Dr 3  95 00                        sta 0,x
00388Fr 3  74 01                        stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
003891r 3               
003891r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
003894r 3  20 rr rr                     jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
003897r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
00389Ar 3               
00389Ar 3                               ; Now we can handle the next line
00389Ar 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
00389Dr 3               
00389Dr 3  80 A2                        bra _cmd_w_loop
00389Fr 3               
00389Fr 3               _cmd_w_eol:
00389Fr 3                               ; We're at the end of the text buffer and arrive here with
00389Fr 3                               ; ( addr-tn addr-n ) ( R: addr-t ) What we do now is calculate
00389Fr 3                               ; the number of characters saved and put that value in the 3OS
00389Fr 3                               ; position
00389Fr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
0038A2r 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
0038A5r 3  20 rr rr                     jsr xt_minus            ; - ( addr-t u-t addr-n u )
0038A8r 3               
0038A8r 3  B5 00                        lda 0,x
0038AAr 3  95 04                        sta 4,x
0038ACr 3  B5 01                        lda 1,x
0038AEr 3  95 05                        sta 5,x                 ; ( addr-t u addr-n u )
0038B0r 3               
0038B0r 3                               ; Unix ed puts the number of characters on a new line, so we
0038B0r 3                               ; do as well
0038B0r 3  20 rr rr                     jsr xt_cr
0038B3r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u addr-n u u )
0038B6r 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u addr-n u )
0038B9r 3  20 rr rr                     jsr xt_cr
0038BCr 3               
0038BCr 3                               ; Reset the changed flag
0038BCr 3  A9 40                        lda #%01000000
0038BEr 3  14 32                        trb ed_flags
0038C0r 3               
0038C0r 3  4C rr rr                     jmp _next_command
0038C3r 3               
0038C3r 3               
0038C3r 3               ; === ERROR HANDLING ===
0038C3r 3               
0038C3r 3               _error_2drop:
0038C3r 3                               ; Lots of times we'll have para1 and para2 on the stack when an
0038C3r 3                               ; error occurs, so we drop stuff here
0038C3r 3  E8                           inx
0038C4r 3  E8                           inx                     ; drop through to _error_1drop
0038C5r 3               _error_1drop:
0038C5r 3  E8                           inx
0038C6r 3  E8                           inx                     ; drop through to _error
0038C7r 3               _error:
0038C7r 3                               ; Error handling with ed is really primitive: We print a question
0038C7r 3                               ; mark and go back to the loop. Any code calling this routine must
0038C7r 3                               ; clean up the stack itself: We expect it to be empty. Note that
0038C7r 3                               ; ed currently does not support reporting the type of error on
0038C7r 3                               ; demand like Unix ed does
0038C7r 3  20 rr rr                     jsr xt_cr
0038CAr 3               
0038CAr 3  A9 3F                        lda #'?'
0038CCr 3  20 rr rr                     jsr emit_a
0038CFr 3               
0038CFr 3  20 rr rr                     jsr xt_cr
0038D2r 3               
0038D2r 3  4C rr rr                     jmp _input_loop
0038D5r 3               
0038D5r 3               
0038D5r 3               ; === HELPER FUNCTIONS ===
0038D5r 3               
0038D5r 3               _get_input:
0038D5r 3                       ; Use REFILL to get input from the user, which is left in
0038D5r 3                       ; ( cib ciblen ) as usual.
0038D5r 3  20 rr rr                     jsr xt_refill           ;  ( addr-t u-t f )
0038D8r 3               
0038D8r 3                               ; If something went wrong while getting the user input, print
0038D8r 3                               ; a question mark and try again. No fancy error messages
0038D8r 3                               ; for ed!
0038D8r 3  B5 00                        lda 0,x
0038DAr 3  15 01                        ora 1,x
0038DCr 3  D0 05                        bne @1
0038DEr 3               
0038DEr 3                               ; Whatever went wrong, we can't handle it here anyway. We
0038DEr 3                               ; clear the return stack, dump the error flag and call
0038DEr 3                               ; a normal error
0038DEr 3  7A                           ply
0038DFr 3  7A                           ply
0038E0r 3               
0038E0r 3  4C rr rr                     jmp _error_1drop
0038E3r 3               @1:
0038E3r 3                               ; Drop the flag
0038E3r 3  E8                           inx
0038E4r 3  E8                           inx
0038E5r 3               
0038E5r 3  60                           rts
0038E6r 3               
0038E6r 3               ; -----------------------------
0038E6r 3               _have_text:
0038E6r 3                       ; See if we have any lines at all. If not, abort with an error. We
0038E6r 3                       ; could in theory set a flag every time we add a text, but this is
0038E6r 3                       ; more robust, if somewhat longer
0038E6r 3  A5 2E                        lda ed_head
0038E8r 3  05 2F                        ora ed_head+1
0038EAr 3  D0 04                        bne @1
0038ECr 3               
0038ECr 3                               ; We don't have any lines. Clean up the return stack and throw
0038ECr 3                               ; an error
0038ECr 3  7A                           ply
0038EDr 3  7A                           ply
0038EEr 3  80 D7                        bra _error
0038F0r 3               @1:
0038F0r 3  60                           rts
0038F1r 3               
0038F1r 3               ; -----------------------------
0038F1r 3               _is_valid_line:
0038F1r 3                       ; See if the line number in TOS is valid. If yes, returns the carry
0038F1r 3                       ; flag set ("true"), otherwise cleared ("false"). Does not change
0038F1r 3                       ; the value of TOS. Line numbers must be 0 < number <= last_line.
0038F1r 3                       ; This routine calls _last_line.
0038F1r 3  38                           sec                             ; default is legal line number
0038F2r 3               
0038F2r 3                               ; First see if we have a zero
0038F2r 3  B5 00                        lda 0,x
0038F4r 3  15 01                        ora 1,x
0038F6r 3  F0 19                        beq _is_valid_line_nope_zero    ; ( n )
0038F8r 3               
0038F8r 3                               ; Not a zero. Now see if we're beyond the last line
0038F8r 3  20 rr rr                     jsr xt_dup                      ; DUP ( n n )
0038FBr 3  20 rr rr                     jsr _last_line                  ; ( n n last )
0038FEr 3  20 rr rr                     jsr xt_swap                     ; SWAP ( n last n )
003901r 3  20 rr rr                     jsr xt_less_than                ; < ( n f )
003904r 3               
003904r 3  B5 00                        lda 0,x                         ; 0 flag is good
003906r 3  15 01                        ora 1,x
003908r 3  D0 05                        bne _is_valid_line_too_small
00390Ar 3               
00390Ar 3                               ; We're good, clean up and leave
00390Ar 3  E8                           inx
00390Br 3  E8                           inx                     ; DROP flag ( n )
00390Cr 3               
00390Cr 3  38                           sec                     ; Who knows what's happened to C by now
00390Dr 3  80 03                        bra _is_valid_line_done ; only one exit from this routine
00390Fr 3               
00390Fr 3               _is_valid_line_too_small:
00390Fr 3  E8                           inx
003910r 3  E8                           inx                     ; drop through to _is_valid_line_zero
003911r 3               
003911r 3               _is_valid_line_nope_zero:
003911r 3  18                           clc                     ; drop through to _is_valid_line_done
003912r 3               
003912r 3               _is_valid_line_done:
003912r 3  60                           rts
003913r 3               
003913r 3               
003913r 3               ; -----------------------------
003913r 3               _last_line:
003913r 3                       ; Calculate the number of the last line (not its address) and return
003913r 3                       ; it TOS. Note this shares code with _num_to_addr. Assumes that user
003913r 3                       ; has made sure there are any lines at all
003913r 3               
003913r 3                               ; Set counter to zero
003913r 3  64 24                        stz tmp1
003915r 3  64 25                        stz tmp1+1
003917r 3               
003917r 3  CA                           dex
003918r 3  CA                           dex                     ; ( ? )
003919r 3  A9 2E                        lda #<ed_head
00391Br 3  95 00                        sta 0,x
00391Dr 3  A9 00                        lda #>ed_head
00391Fr 3  95 01                        sta 1,x                 ; ( addr )
003921r 3               
003921r 3               _last_line_loop:
003921r 3  20 rr rr                     jsr xt_fetch            ; ( addr | 0 )
003924r 3               
003924r 3                               ; If that's over, we're at the end of the list and we're done
003924r 3  B5 00                        lda 0,x
003926r 3  15 01                        ora 1,x
003928r 3  F0 08                        beq _last_line_done
00392Ar 3               
00392Ar 3                               ; Not done. Increase counter and continue
00392Ar 3  E6 24                        inc tmp1
00392Cr 3  D0 02                        bne @1
00392Er 3  E6 25                        inc tmp1+1
003930r 3               @1:
003930r 3  80 EF                        bra _last_line_loop
003932r 3               
003932r 3               _last_line_done:
003932r 3  A5 24                        lda tmp1
003934r 3  95 00                        sta 0,x
003936r 3  A5 25                        lda tmp1+1
003938r 3  95 01                        sta 1,x                 ; ( u )
00393Ar 3               
00393Ar 3  60                           rts
00393Br 3               
00393Br 3               
00393Br 3               ; -----------------------------
00393Br 3               _no_line_zero:
00393Br 3                       ; Make sure we weren't given an explicit zero as the line number with
00393Br 3                       ; commands that don't accept it (that is, pretty much everybody except
00393Br 3                       ; a). If para1 is a zero and we have parameters (bit 7 of ed_flag set),
00393Br 3                       ; throw an error
00393Br 3               
00393Br 3                               ; See if para1 is zero
00393Br 3  B5 02                        lda 2,x
00393Dr 3  15 03                        ora 3,x
00393Fr 3  D0 07                        bne _no_line_zero_done
003941r 3               
003941r 3                               ; It's zero. If bit 7 of ed_flag is set, this is an explicit
003941r 3                               ; parameter
003941r 3  24 32                        bit ed_flags
003943r 3  10 03                        bpl _no_line_zero_done
003945r 3               
003945r 3  4C rr rr                     jmp _error_2drop
003948r 3               
003948r 3               _no_line_zero_done:
003948r 3                               ; All is well, we can continue
003948r 3  60                           rts
003949r 3               
003949r 3               ; -----------------------------
003949r 3               _num_to_addr:
003949r 3                       ; Given a line number as TOS, replace it by the address of the node.
003949r 3                       ; If the line number is zero, we return the address of the header
003949r 3                       ; node. If the line number is beyond the last line, we return a
003949r 3                       ; zero, though we're assuming the user will check for a legal
003949r 3                       ; line number before calling this routine. Assumes we have checked that
003949r 3                       ; we have any text at all.
003949r 3               
003949r 3                               ; One way or another we're going to start with the
003949r 3                               ; address of the pointer to the head of the list
003949r 3  CA                           dex
00394Ar 3  CA                           dex                     ; ( u ? )
00394Br 3  A9 2E                        lda #<ed_head
00394Dr 3  95 00                        sta 0,x
00394Fr 3  A9 00                        lda #>ed_head
003951r 3  95 01                        sta 1,x                 ; ( u addr-h )
003953r 3               
003953r 3                               ; Handle the case where the line number is zero
003953r 3  B5 02                        lda 2,x
003955r 3  15 03                        ora 3,x
003957r 3  D0 05                        bne _num_to_addr_loop
003959r 3               
003959r 3                               ; It's zero, so we're already done
003959r 3  20 rr rr                     jsr xt_nip              ; ( addr-h )
00395Cr 3  80 21                        bra _num_to_addr_done
00395Er 3               
00395Er 3               _num_to_addr_loop:
00395Er 3                               ; Get the first line
00395Er 3  20 rr rr                     jsr xt_fetch            ; @ ( u addr1 )
003961r 3               
003961r 3                               ; If that's zero, we're at the end of the list and it's over
003961r 3  B5 00                        lda 0,x
003963r 3  15 01                        ora 1,x
003965r 3  D0 05                        bne @1
003967r 3               
003967r 3  20 rr rr                     jsr xt_nip              ; NIP ( addr1 )
00396Ar 3  80 13                        bra _num_to_addr_done
00396Cr 3               @1:
00396Cr 3                               ; It's not zero. See if this is the nth element we're looking
00396Cr 3                               ; for
00396Cr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr1 u )
00396Fr 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr1 u-1 )
003972r 3               
003972r 3  B5 00                        lda 0,x
003974r 3  15 01                        ora 1,x
003976r 3  F0 05                        beq _num_to_addr_finished
003978r 3               
003978r 3                               ; Not zero yet, try again
003978r 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-1 addr1 )
00397Br 3               
00397Br 3  80 E1                        bra _num_to_addr_loop
00397Dr 3               
00397Dr 3               _num_to_addr_finished:
00397Dr 3                               ; We arrive here with ( addr u )
00397Dr 3  E8                           inx
00397Er 3  E8                           inx                     ; ( addr )
00397Fr 3               
00397Fr 3               _num_to_addr_done:
00397Fr 3  60                           rts
003980r 3               
003980r 3               
003980r 3               ; -----------------------------
003980r 3               _para1_to_cur:
003980r 3                       ; Switch the current line number to whatever the first parameter
003980r 3                       ; is. We do this a lot so this routine saves a few bytes
003980r 3  B5 02                        lda 2,x
003982r 3  85 30                        sta ed_cur
003984r 3  B5 03                        lda 3,x
003986r 3  85 31                        sta ed_cur+1
003988r 3               
003988r 3  60                           rts
003989r 3               
003989r 3               
003989r 3               ; -----------------------------
003989r 3               _print_addr:
003989r 3                       ; Given the address of a node TOS, print the string it comes with.
003989r 3                       ; Assumes we have made sure that this address exists. It would be
003989r 3                       ; nice to put the CR at the beginning, but that doesn't work with
003989r 3                       ; the n commands, so at the end it goes. Consumes TOS.
003989r 3  20 rr rr                     jsr xt_one_plus
00398Cr 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 )
00398Fr 3               
00398Fr 3  20 rr rr                     jsr xt_dup              ; ( addr+2 addr+2 )
003992r 3               
003992r 3  20 rr rr                     jsr xt_one_plus
003995r 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 addr+4 )
003998r 3               
003998r 3  20 rr rr                     jsr xt_fetch            ; ( addr+2 u-s )
00399Br 3  20 rr rr                     jsr xt_swap             ; ( u-s addr+2 )
00399Er 3  20 rr rr                     jsr xt_fetch            ; ( u-s addr-s )
0039A1r 3               
0039A1r 3  20 rr rr                     jsr xt_swap             ; ( addr-s u-s )
0039A4r 3  20 rr rr                     jsr xt_type
0039A7r 3  20 rr rr                     jsr xt_cr
0039AAr 3               
0039AAr 3  60                           rts
0039ABr 3               
0039ABr 3               
0039ABr 3               ; === COMMAND TABLES ===
0039ABr 3               
0039ABr 3               ; The commands are all one character and kept in a 0-terminated string that is
0039ABr 3               ; walked by a loop. Their index corresponds to the index of their routine's
0039ABr 3               ; address in the jump table. To create a new command, add it's letter at the
0039ABr 3               ; correct position in the command list and the routine's address in the command
0039ABr 3               ; jump table. Oh, and write the routine as well. Capital letters such as 'Q' are
0039ABr 3               ; coded in their routine's address as double letters ('_cmd_qq').
0039ABr 3               
0039ABr 3  61 66 69 64  ed_cmd_list:    .byte "afidpn=wqQ", 0
0039AFr 3  70 6E 3D 77  
0039B3r 3  71 51 00     
0039B6r 3               
0039B6r 3               ed_cmd_table:
0039B6r 3  rr rr rr rr                  .word _cmd_a, _cmd_f, _cmd_i, _cmd_d, _cmd_p, _cmd_n
0039BAr 3  rr rr rr rr  
0039BEr 3  rr rr rr rr  
0039C2r 3  rr rr rr rr                  .word _cmd_equ, _cmd_w, _cmd_q, _cmd_qq
0039C6r 3  rr rr rr rr  
0039CAr 3               
0039CAr 3               
0039CAr 3               ed6502_end:     ; Used to calculate size of editor code
0039CAr 3               
0039CAr 2               
0039CAr 2               ; High-level Forth words, see forth_code/README.md
0039CAr 2               forth_words_start:
0039CAr 2  20 63 72 20  .incbin "forth_words.asc"
0039CEr 2  2E 28 20 57  
0039D2r 2  65 6C 63 6F  
0039EDr 2               forth_words_end:
0039EDr 2               
0039EDr 2               ; User-defined Forth words, see forth_code/README.md
0039EDr 2               user_words_start:
0039EDr 2  20 32 30 20  .incbin "user_words.asc"
0039F1r 2  63 6F 6E 73  
0039F5r 2  74 61 6E 74  
004024r 2               user_words_end:
004024r 2               
004024r 2               .include "headers.asm"          ; Headers of native words
004024r 3               ; Dictionary Headers for Tali Forth 2
004024r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004024r 3               ; First version: 05. Dec 2016 (Liara Forth)
004024r 3               ; This version: 29. Dec 2018
004024r 3               
004024r 3               ; Dictionary headers are kept separately from the code, which allows various
004024r 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
004024r 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
004024r 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
004024r 3               ; header in the Dictionary. There the link to the next word in the Dictionary
004024r 3               ; is always one cell down from the current word's own nt. In the code itself,
004024r 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
004024r 3               
004024r 3               ; This gives us the following header structure:
004024r 3               
004024r 3               ;              8 bit     8 bit
004024r 3               ;               LSB       MSB
004024r 3               ; nt_word ->  +--------+--------+
004024r 3               ;          +0 | Length | Status |
004024r 3               ;             +--------+--------+
004024r 3               ;          +2 | Next Header     | -> nt_next_word
004024r 3               ;             +-----------------+
004024r 3               ;          +4 | Start of Code   | -> xt_word
004024r 3               ;             +-----------------+
004024r 3               ;          +6 | End of Code     | -> z_word
004024r 3               ;             +--------+--------+
004024r 3               ;          +8 | Name   |        |
004024r 3               ;             +--------+--------+
004024r 3               ;             |        |        |
004024r 3               ;             +--------+--------+
004024r 3               ;             |        |  ...   | (name string does not end with a zero)
004024r 3               ;          +n +--------+--------+
004024r 3               
004024r 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
004024r 3               ; which are:
004024r 3               
004024r 3               ;       CO - Compile Only
004024r 3               ;       IM - Immediate Word
004024r 3               ;       NN - Never Native Compile (must always be called by JSR)
004024r 3               ;       AN - Always Native Compile (may not be called by JSR)
004024r 3               ;       UF - Contains underflow check
004024r 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
004024r 3               
004024r 3               ; Note there are currently two bits unused.
004024r 3               
004024r 3               ; By default, all existing words can be natively compiled (compiled inline) or
004024r 3               ; as a subroutine jump target; the system decides which variant to use based on
004024r 3               ; a threshold the user can set. By default, all user-created words are flagged
004024r 3               ; never-native. The user can override this by using the always-native word
004024r 3               ; just after defining their new word.  The NN flag forbids native compiling,
004024r 3               ; the AN flag forces it.
004024r 3               
004024r 3               ; The last word (top word in code) is always BYE. It is marked as the last word
004024r 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
004024r 3               ; more common ones first (further down in code) so they are found earlier.
004024r 3               ; Anything to do with output comes later (further up) because things will
004024r 3               ; always be slow if there is a human involved.
004024r 3               
004024r 3               ; The initial skeleton of this list was automatically generated by a script
004024r 3               ; in the tools folder and then sorted by hand.
004024r 3               
004024r 3               nt_bye:
004024r 3  03                   .byte 3         ; length of word strings
004025r 3  00                   .byte 0         ; status byte
004026r 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
004028r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
00402Ar 3  rr rr                .word z_bye     ; end of code (RTS)
00402Cr 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
00402Fr 3               
00402Fr 3               
00402Fr 3               nt_cold:
00402Fr 3  04 00                .byte 4, 0
004031r 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
004035r 3  rr rr        
004037r 3  63 6F 6C 64          .byte "cold"
00403Br 3               
00403Br 3               nt_lcdput:
00403Br 3  06 10                .byte 6, UF
00403Dr 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
004041r 3  rr rr        
004043r 3  6C 63 64 70          .byte "lcdput"
004047r 3  75 74        
004049r 3               
004049r 3               nt_lcdprint:
004049r 3  08 10                .byte 8, UF
00404Br 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
00404Fr 3  rr rr        
004051r 3  6C 63 64 70          .byte "lcdprint"
004055r 3  72 69 6E 74  
004059r 3               
004059r 3               nt_cls:
004059r 3  03 00                .byte 3, 0
00405Br 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
00405Fr 3  rr rr        
004061r 3  63 6C 73             .byte "cls"
004064r 3               
004064r 3               nt_spi_init:
004064r 3  08 00                .byte 8, 0
004066r 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
00406Ar 3  rr rr        
00406Cr 3  73 70 69 5F          .byte "spi_init"
004070r 3  69 6E 69 74  
004074r 3               
004074r 3               
004074r 3               nt_spi_clk_toggle:
004074r 3  0E 00                .byte 14, 0
004076r 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
00407Ar 3  rr rr        
00407Cr 3  73 70 69 5F          .byte "spi_clk_toggle"
004080r 3  63 6C 6B 5F  
004084r 3  74 6F 67 67  
00408Ar 3               
00408Ar 3               nt_spi_select:
00408Ar 3  0A 00                .byte 10, 0
00408Cr 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
004090r 3  rr rr        
004092r 3  73 70 69 5F          .byte "spi_select"
004096r 3  73 65 6C 65  
00409Ar 3  63 74        
00409Cr 3               
00409Cr 3               nt_spi_transceive:
00409Cr 3  0E 00                .byte 14, 0
00409Er 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
0040A2r 3  rr rr        
0040A4r 3  73 70 69 5F          .byte "spi_transceive"
0040A8r 3  74 72 61 6E  
0040ACr 3  73 63 65 69  
0040B2r 3               
0040B2r 3               nt_sd_init:
0040B2r 3  07 00                .byte 7, 0
0040B4r 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
0040B8r 3  rr rr        
0040BAr 3  73 64 5F 69          .byte "sd_init"
0040BEr 3  6E 69 74     
0040C1r 3               
0040C1r 3               nt_ed:                  ; ed6502
0040C1r 3  02 08                .byte 2, NN
0040C3r 3  rr rr rr rr          .word nt_sd_init, xt_ed, z_ed
0040C7r 3  rr rr        
0040C9r 3  65 64                .byte "ed"
0040CBr 3               
0040CBr 3  03 08        nt_see: .byte 3, NN
0040CDr 3  rr rr rr rr          .word nt_ed, xt_see, z_see
0040D1r 3  rr rr        
0040D3r 3  73 65 65             .byte "see"
0040D6r 3               
0040D6r 3               nt_forth:
0040D6r 3  05 00                .byte 5, 0
0040D8r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
0040DCr 3  rr rr        
0040DEr 3  66 6F 72 74          .byte "forth"
0040E2r 3  68           
0040E3r 3               
0040E3r 3               nt_order:
0040E3r 3  05 00                .byte 5, 0
0040E5r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
0040E9r 3  rr rr        
0040EBr 3  6F 72 64 65          .byte "order"
0040EFr 3  72           
0040F0r 3               
0040F0r 3               nt_to_order:
0040F0r 3  06 00                .byte 6, 0
0040F2r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
0040F6r 3  rr rr        
0040F8r 3  3E 6F 72 64          .byte ">order"
0040FCr 3  65 72        
0040FEr 3               
0040FEr 3               nt_previous:
0040FEr 3  08 00                .byte 8, 0
004100r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
004104r 3  rr rr        
004106r 3  70 72 65 76          .byte "previous"
00410Ar 3  69 6F 75 73  
00410Er 3               
00410Er 3               nt_also:
00410Er 3  04 00                .byte 4, 0
004110r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
004114r 3  rr rr        
004116r 3  61 6C 73 6F          .byte "also"
00411Ar 3               
00411Ar 3               nt_only:
00411Ar 3  04 00                .byte 4, 0
00411Cr 3  rr rr rr rr          .word nt_also, xt_only, z_only
004120r 3  rr rr        
004122r 3  6F 6E 6C 79          .byte "only"
004126r 3               
004126r 3               nt_forth_wordlist:      ; shares code with ZERO
004126r 3  0E 00                .byte 14, 0
004128r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
00412Cr 3  rr rr        
00412Er 3  66 6F 72 74          .byte "forth-wordlist"
004132r 3  68 2D 77 6F  
004136r 3  72 64 6C 69  
00413Cr 3               
00413Cr 3               nt_editor_wordlist:     ; shares code with ONE
00413Cr 3  0F 00                .byte 15, 0
00413Er 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
004142r 3  rr rr        
004144r 3  65 64 69 74          .byte "editor-wordlist"
004148r 3  6F 72 2D 77  
00414Cr 3  6F 72 64 6C  
004153r 3               
004153r 3               nt_assembler_wordlist:  ; shares code with TWO
004153r 3  12 00                .byte 18, 0
004155r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
004159r 3  rr rr        
00415Br 3  61 73 73 65          .byte "assembler-wordlist"
00415Fr 3  6D 62 6C 65  
004163r 3  72 2D 77 6F  
00416Dr 3               
00416Dr 3               nt_root_wordlist:
00416Dr 3  0D 00                .byte 13, 0
00416Fr 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
004173r 3  rr rr        
004175r 3  72 6F 6F 74          .byte "root-wordlist"
004179r 3  2D 77 6F 72  
00417Dr 3  64 6C 69 73  
004182r 3               
004182r 3               nt_get_order:
004182r 3  09 00                .byte 9, 0
004184r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
004188r 3  rr rr        
00418Ar 3  67 65 74 2D          .byte "get-order"
00418Er 3  6F 72 64 65  
004192r 3  72           
004193r 3               
004193r 3               nt_set_order:
004193r 3  09 00                .byte 9, 0
004195r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
004199r 3  rr rr        
00419Br 3  73 65 74 2D          .byte "set-order"
00419Fr 3  6F 72 64 65  
0041A3r 3  72           
0041A4r 3               
0041A4r 3               nt_get_current:
0041A4r 3  0B 00                .byte 11, 0
0041A6r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
0041AAr 3  rr rr        
0041ACr 3  67 65 74 2D          .byte "get-current"
0041B0r 3  63 75 72 72  
0041B4r 3  65 6E 74     
0041B7r 3               
0041B7r 3               nt_set_current:
0041B7r 3  0B 10                .byte 11, UF
0041B9r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
0041BDr 3  rr rr        
0041BFr 3  73 65 74 2D          .byte "set-current"
0041C3r 3  63 75 72 72  
0041C7r 3  65 6E 74     
0041CAr 3               
0041CAr 3               nt_search_wordlist:
0041CAr 3  0F 10                .byte 15, UF
0041CCr 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
0041D0r 3  rr rr        
0041D2r 3  73 65 61 72          .byte "search-wordlist"
0041D6r 3  63 68 2D 77  
0041DAr 3  6F 72 64 6C  
0041E1r 3               
0041E1r 3               nt_wordlist:
0041E1r 3  08 00                .byte 8, 0
0041E3r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
0041E7r 3  rr rr        
0041E9r 3  77 6F 72 64          .byte "wordlist"
0041EDr 3  6C 69 73 74  
0041F1r 3               
0041F1r 3               nt_definitions:
0041F1r 3  0B 00                .byte 11, 0
0041F3r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
0041F7r 3  rr rr        
0041F9r 3  64 65 66 69          .byte "definitions"
0041FDr 3  6E 69 74 69  
004201r 3  6F 6E 73     
004204r 3               
004204r 3               nt_block_ramdrive_init:
004204r 3  13 10                .byte 19, UF
004206r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
00420Ar 3  rr rr        
00420Cr 3  62 6C 6F 63          .byte "block-ramdrive-init"
004210r 3  6B 2D 72 61  
004214r 3  6D 64 72 69  
00421Fr 3               
00421Fr 3               nt_list:
00421Fr 3  04 10                .byte 4, UF
004221r 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
004225r 3  rr rr        
004227r 3  6C 69 73 74          .byte "list"
00422Br 3               
00422Br 3               nt_thru:
00422Br 3  04 10                .byte 4, UF
00422Dr 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
004231r 3  rr rr        
004233r 3  74 68 72 75          .byte "thru"
004237r 3               
004237r 3               nt_load:
004237r 3  04 10                .byte 4, UF
004239r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
00423Dr 3  rr rr        
00423Fr 3  6C 6F 61 64          .byte "load"
004243r 3               
004243r 3               nt_flush:
004243r 3  05 00                .byte 5, 0
004245r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
004249r 3  rr rr        
00424Br 3  66 6C 75 73          .byte "flush"
00424Fr 3  68           
004250r 3               
004250r 3               nt_empty_buffers:
004250r 3  0D 00                .byte 13, 0
004252r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
004256r 3  rr rr        
004258r 3  65 6D 70 74          .byte "empty-buffers"
00425Cr 3  79 2D 62 75  
004260r 3  66 66 65 72  
004265r 3               
004265r 3               nt_buffer:
004265r 3  06 00                .byte 6, 0
004267r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
00426Br 3  rr rr        
00426Dr 3  62 75 66 66          .byte "buffer"
004271r 3  65 72        
004273r 3               
004273r 3               nt_update:
004273r 3  06 00                .byte 6, 0
004275r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
004279r 3  rr rr        
00427Br 3  75 70 64 61          .byte "update"
00427Fr 3  74 65        
004281r 3               
004281r 3               nt_block:
004281r 3  05 00                .byte 5, 0
004283r 3  rr rr rr rr          .word nt_update, xt_block, z_block
004287r 3  rr rr        
004289r 3  62 6C 6F 63          .byte "block"
00428Dr 3  6B           
00428Er 3               
00428Er 3               nt_save_buffers:
00428Er 3  0C 00                .byte 12, 0
004290r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
004294r 3  rr rr        
004296r 3  73 61 76 65          .byte "save-buffers"
00429Ar 3  2D 62 75 66  
00429Er 3  66 65 72 73  
0042A2r 3               
0042A2r 3               nt_block_read_vector:
0042A2r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
0042A4r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
0042A8r 3  rr rr        
0042AAr 3  62 6C 6F 63          .byte "block-read-vector"
0042AEr 3  6B 2D 72 65  
0042B2r 3  61 64 2D 76  
0042BBr 3               
0042BBr 3               nt_block_read:
0042BBr 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
0042BDr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
0042C1r 3  rr rr        
0042C3r 3  62 6C 6F 63          .byte "block-read"
0042C7r 3  6B 2D 72 65  
0042CBr 3  61 64        
0042CDr 3               
0042CDr 3               nt_block_write_vector:
0042CDr 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
0042CFr 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
0042D3r 3  rr rr        
0042D5r 3  62 6C 6F 63          .byte "block-write-vector"
0042D9r 3  6B 2D 77 72  
0042DDr 3  69 74 65 2D  
0042E7r 3               
0042E7r 3               nt_block_write:
0042E7r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
0042E9r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
0042EDr 3  rr rr        
0042EFr 3  62 6C 6F 63          .byte "block-write"
0042F3r 3  6B 2D 77 72  
0042F7r 3  69 74 65     
0042FAr 3               
0042FAr 3               nt_blk:
0042FAr 3  03 00                .byte 3, 0
0042FCr 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
004300r 3  rr rr        
004302r 3  62 6C 6B             .byte "blk"
004305r 3               
004305r 3               nt_scr:
004305r 3  03 00                .byte 3, 0
004307r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
00430Br 3  rr rr        
00430Dr 3  73 63 72             .byte "scr"
004310r 3               
004310r 3               nt_blkbuffer:
004310r 3  09 00                .byte 9, 0
004312r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
004316r 3  rr rr        
004318r 3  62 6C 6B 62          .byte "blkbuffer"
00431Cr 3  75 66 66 65  
004320r 3  72           
004321r 3               
004321r 3               nt_buffblocknum:
004321r 3  0C 00                .byte 12, 0
004323r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
004327r 3  rr rr        
004329r 3  62 75 66 66          .byte "buffblocknum"
00432Dr 3  62 6C 6F 63  
004331r 3  6B 6E 75 6D  
004335r 3               
004335r 3               nt_buffstatus:
004335r 3  0A 00                .byte 10, 0
004337r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
00433Br 3  rr rr        
00433Dr 3  62 75 66 66          .byte "buffstatus"
004341r 3  73 74 61 74  
004345r 3  75 73        
004347r 3               
004347r 3               nt_buffer_colon:
004347r 3  07 00                .byte 7, 0
004349r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
00434Dr 3  rr rr        
00434Fr 3  62 75 66 66          .byte "buffer:"
004353r 3  65 72 3A     
004356r 3               
004356r 3               nt_useraddr:
004356r 3  08 00                .byte 8, 0
004358r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
00435Cr 3  rr rr        
00435Er 3  75 73 65 72          .byte "useraddr"
004362r 3  61 64 64 72  
004366r 3               
004366r 3               nt_action_of:
004366r 3  09 04                .byte 9, IM
004368r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
00436Cr 3  rr rr        
00436Er 3  61 63 74 69          .byte "action-of"
004372r 3  6F 6E 2D 6F  
004376r 3  66           
004377r 3               
004377r 3               nt_is:
004377r 3  02 04                .byte 2, IM
004379r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
00437Dr 3  rr rr        
00437Fr 3  69 73                .byte "is"
004381r 3               
004381r 3               nt_defer_store:
004381r 3  06 00                .byte 6, 0
004383r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
004387r 3  rr rr        
004389r 3  64 65 66 65          .byte "defer!"
00438Dr 3  72 21        
00438Fr 3               
00438Fr 3               nt_defer_fetch:
00438Fr 3  06 00                .byte 6, 0
004391r 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
004395r 3  rr rr        
004397r 3  64 65 66 65          .byte "defer@"
00439Br 3  72 40        
00439Dr 3               
00439Dr 3               nt_endcase:
00439Dr 3  07 0D                .byte 7, IM+CO+NN
00439Fr 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
0043A3r 3  rr rr        
0043A5r 3  65 6E 64 63          .byte "endcase"
0043A9r 3  61 73 65     
0043ACr 3               
0043ACr 3               nt_endof:
0043ACr 3  05 0D                .byte 5, IM+CO+NN
0043AEr 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
0043B2r 3  rr rr        
0043B4r 3  65 6E 64 6F          .byte "endof"
0043B8r 3  66           
0043B9r 3               
0043B9r 3               nt_of:
0043B9r 3  02 0D                .byte 2, IM+CO+NN
0043BBr 3  rr rr rr rr          .word nt_endof, xt_of, z_of
0043BFr 3  rr rr        
0043C1r 3  6F 66                .byte "of"
0043C3r 3               
0043C3r 3               nt_case:
0043C3r 3  04 0D                .byte 4, IM+CO+NN
0043C5r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
0043C9r 3  rr rr        
0043CBr 3  63 61 73 65          .byte "case"
0043CFr 3               
0043CFr 3               nt_while:
0043CFr 3  05 0D                .byte 5, IM+CO+NN
0043D1r 3  rr rr rr rr          .word nt_case, xt_while, z_while
0043D5r 3  rr rr        
0043D7r 3  77 68 69 6C          .byte "while"
0043DBr 3  65           
0043DCr 3               
0043DCr 3               nt_until:
0043DCr 3  05 0D                .byte 5, IM+CO+NN
0043DEr 3  rr rr rr rr          .word nt_while, xt_until, z_until
0043E2r 3  rr rr        
0043E4r 3  75 6E 74 69          .byte "until"
0043E8r 3  6C           
0043E9r 3               
0043E9r 3               nt_repeat:
0043E9r 3  06 0D                .byte 6, IM+CO+NN
0043EBr 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
0043EFr 3  rr rr        
0043F1r 3  72 65 70 65          .byte "repeat"
0043F5r 3  61 74        
0043F7r 3               
0043F7r 3               nt_else:
0043F7r 3  04 0D                .byte 4, IM+CO+NN
0043F9r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
0043FDr 3  rr rr        
0043FFr 3  65 6C 73 65          .byte "else"
004403r 3               
004403r 3               nt_then:
004403r 3  04 0D                .byte 4, IM+CO+NN
004405r 3  rr rr rr rr          .word nt_else, xt_then, z_then
004409r 3  rr rr        
00440Br 3  74 68 65 6E          .byte "then"
00440Fr 3               
00440Fr 3               nt_if:
00440Fr 3  02 0D                .byte 2, IM+CO+NN
004411r 3  rr rr rr rr          .word nt_then, xt_if, z_if
004415r 3  rr rr        
004417r 3  69 66                .byte "if"
004419r 3               
004419r 3               nt_dot_paren:
004419r 3  02 04                .byte 2, IM
00441Br 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
00441Fr 3  rr rr        
004421r 3  2E 28                .byte ".("
004423r 3               
004423r 3               nt_paren:
004423r 3  01 04                .byte 1, IM
004425r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
004429r 3  rr rr        
00442Br 3  28                   .byte "("
00442Cr 3               
00442Cr 3               nt_word:
00442Cr 3  04 10                .byte 4, UF
00442Er 3  rr rr rr rr          .word nt_paren, xt_word, z_word
004432r 3  rr rr        
004434r 3  77 6F 72 64          .byte "word"
004438r 3               
004438r 3               nt_find:
004438r 3  04 10                .byte 4, UF
00443Ar 3  rr rr rr rr          .word nt_word, xt_find, z_find
00443Er 3  rr rr        
004440r 3  66 69 6E 64          .byte "find"
004444r 3               
004444r 3               nt_environment_q:
004444r 3  0C 10                .byte 12, UF
004446r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
00444Ar 3  rr rr        
00444Cr 3  65 6E 76 69          .byte "environment?"
004450r 3  72 6F 6E 6D  
004454r 3  65 6E 74 3F  
004458r 3               
004458r 3               nt_search:
004458r 3  06 18                .byte 6, UF+NN
00445Ar 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
00445Er 3  rr rr        
004460r 3  73 65 61 72          .byte "search"
004464r 3  63 68        
004466r 3               
004466r 3               nt_compare:
004466r 3  07 10                .byte 7, UF
004468r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
00446Cr 3  rr rr        
00446Er 3  63 6F 6D 70          .byte "compare"
004472r 3  61 72 65     
004475r 3               
004475r 3               nt_disasm:
004475r 3  06 10                .byte 6, UF
004477r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
00447Br 3  rr rr        
00447Dr 3  64 69 73 61          .byte "disasm"
004481r 3  73 6D        
004483r 3               
004483r 3               nt_dot_s:
004483r 3  02 00                .byte 2, 0
004485r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
004489r 3  rr rr        
00448Br 3  2E 73                .byte ".s"
00448Dr 3               
00448Dr 3               nt_dump:
00448Dr 3  04 10                .byte 4, UF
00448Fr 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
004493r 3  rr rr        
004495r 3  64 75 6D 70          .byte "dump"
004499r 3               
004499r 3               nt_bell:
004499r 3  04 00                .byte 4, 0
00449Br 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
00449Fr 3  rr rr        
0044A1r 3  62 65 6C 6C          .byte "bell"
0044A5r 3               
0044A5r 3               nt_align:
0044A5r 3  05 00                .byte 5, 0
0044A7r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
0044ABr 3  rr rr        
0044ADr 3  61 6C 69 67          .byte "align"
0044B1r 3  6E           
0044B2r 3               
0044B2r 3               nt_aligned:             ; same code as ALIGN
0044B2r 3  07 00                .byte 7, 0
0044B4r 3  rr rr rr rr          .word nt_align, xt_align, z_align
0044B8r 3  rr rr        
0044BAr 3  61 6C 69 67          .byte "aligned"
0044BEr 3  6E 65 64     
0044C1r 3               
0044C1r 3               nt_wordsize:
0044C1r 3  08 10                .byte 8, UF
0044C3r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
0044C7r 3  rr rr        
0044C9r 3  77 6F 72 64          .byte "wordsize"
0044CDr 3  73 69 7A 65  
0044D1r 3               
0044D1r 3               nt_words:
0044D1r 3  05 00                .byte 5, 0
0044D3r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
0044D7r 3  rr rr        
0044D9r 3  77 6F 72 64          .byte "words"
0044DDr 3  73           
0044DEr 3               
0044DEr 3               nt_marker:
0044DEr 3  06 04                .byte 6, IM
0044E0r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
0044E4r 3  rr rr        
0044E6r 3  6D 61 72 6B          .byte "marker"
0044EAr 3  65 72        
0044ECr 3               
0044ECr 3               nt_at_xy:
0044ECr 3  05 10                .byte 5, UF
0044EEr 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
0044F2r 3  rr rr        
0044F4r 3  61 74 2D 78          .byte "at-xy"
0044F8r 3  79           
0044F9r 3               
0044F9r 3               nt_page:
0044F9r 3  04 00                .byte 4, 0
0044FBr 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
0044FFr 3  rr rr        
004501r 3  70 61 67 65          .byte "page"
004505r 3               
004505r 3               nt_cr:
004505r 3  02 00                .byte 2, 0
004507r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
00450Br 3  rr rr        
00450Dr 3  63 72                .byte "cr"
00450Fr 3               
00450Fr 3               nt_input:
00450Fr 3  05 00                .byte 5, 0
004511r 3  rr rr rr rr          .word nt_cr, xt_input, z_input
004515r 3  rr rr        
004517r 3  69 6E 70 75          .byte "input"
00451Br 3  74           
00451Cr 3               
00451Cr 3               nt_output:
00451Cr 3  06 00                .byte 6, 0
00451Er 3  rr rr rr rr          .word nt_input, xt_output, z_output
004522r 3  rr rr        
004524r 3  6F 75 74 70          .byte "output"
004528r 3  75 74        
00452Ar 3               
00452Ar 3               nt_sign:
00452Ar 3  04 10                .byte 4, UF
00452Cr 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
004530r 3  rr rr        
004532r 3  73 69 67 6E          .byte "sign"
004536r 3               
004536r 3               nt_hold:
004536r 3  04 10                .byte 4, UF
004538r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
00453Cr 3  rr rr        
00453Er 3  68 6F 6C 64          .byte "hold"
004542r 3               
004542r 3               nt_number_sign_greater:
004542r 3  02 10                .byte 2, UF
004544r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
004548r 3  rr rr        
00454Ar 3  23 3E                .byte "#>"
00454Cr 3               
00454Cr 3               nt_number_sign_s:
00454Cr 3  02 10                .byte 2, UF
00454Er 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
004552r 3  rr rr        
004554r 3  23 73                .byte "#s"
004556r 3               
004556r 3               nt_number_sign:
004556r 3  01 10                .byte 1, UF
004558r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
00455Cr 3  rr rr        
00455Er 3  23                   .byte "#"
00455Fr 3               
00455Fr 3               nt_less_number_sign:
00455Fr 3  02 00                .byte 2, 0
004561r 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
004565r 3  rr rr        
004567r 3  3C 23                .byte "<#"
004569r 3               
004569r 3               nt_to_in:
004569r 3  03 00                .byte 3, 0
00456Br 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
00456Fr 3  rr rr        
004571r 3  3E 69 6E             .byte ">in"
004574r 3               
004574r 3               nt_within:
004574r 3  06 10                .byte 6, UF
004576r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
00457Ar 3  rr rr        
00457Cr 3  77 69 74 68          .byte "within"
004580r 3  69 6E        
004582r 3               
004582r 3               nt_hexstore:
004582r 3  08 10                .byte 8, UF
004584r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
004588r 3  rr rr        
00458Ar 3  68 65 78 73          .byte "hexstore"
00458Er 3  74 6F 72 65  
004592r 3               
004592r 3               nt_cleave:
004592r 3  06 10                .byte 6, UF
004594r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
004598r 3  rr rr        
00459Ar 3  63 6C 65 61          .byte "cleave"
00459Er 3  76 65        
0045A0r 3               
0045A0r 3               nt_pad:
0045A0r 3  03 00                .byte 3, 0
0045A2r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
0045A6r 3  rr rr        
0045A8r 3  70 61 64             .byte "pad"
0045ABr 3               
0045ABr 3               nt_cmove:
0045ABr 3  05 10                .byte 5, UF
0045ADr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
0045B1r 3  rr rr        
0045B3r 3  63 6D 6F 76          .byte "cmove"
0045B7r 3  65           
0045B8r 3               
0045B8r 3               nt_cmove_up:
0045B8r 3  06 10                .byte 6, UF
0045BAr 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
0045BEr 3  rr rr        
0045C0r 3  63 6D 6F 76          .byte "cmove>"
0045C4r 3  65 3E        
0045C6r 3               
0045C6r 3               nt_move:
0045C6r 3  04 18                .byte 4, NN+UF
0045C8r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
0045CCr 3  rr rr        
0045CEr 3  6D 6F 76 65          .byte "move"
0045D2r 3               
0045D2r 3               nt_backslash:
0045D2r 3  01 04                .byte 1, IM
0045D4r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
0045D8r 3  rr rr        
0045DAr 3  5C                   .byte $5c
0045DBr 3               
0045DBr 3               nt_star_slash:
0045DBr 3  02 10                .byte 2, UF
0045DDr 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
0045E1r 3  rr rr        
0045E3r 3  2A 2F                .byte "*/"
0045E5r 3               
0045E5r 3               nt_star_slash_mod:
0045E5r 3  05 10                .byte 5, UF
0045E7r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
0045EBr 3  rr rr        
0045EDr 3  2A 2F 6D 6F          .byte "*/mod"
0045F1r 3  64           
0045F2r 3               
0045F2r 3               nt_mod:
0045F2r 3  03 10                .byte 3, UF
0045F4r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
0045F8r 3  rr rr        
0045FAr 3  6D 6F 64             .byte "mod"
0045FDr 3               
0045FDr 3               nt_slash_mod:
0045FDr 3  04 10                .byte 4, UF
0045FFr 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
004603r 3  rr rr        
004605r 3  2F 6D 6F 64          .byte "/mod"
004609r 3               
004609r 3               nt_slash:
004609r 3  01 10                .byte 1, UF
00460Br 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
00460Fr 3  rr rr        
004611r 3  2F                   .byte "/"
004612r 3               
004612r 3               nt_fm_slash_mod:
004612r 3  06 10                .byte 6, UF
004614r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
004618r 3  rr rr        
00461Ar 3  66 6D 2F 6D          .byte "fm/mod"
00461Er 3  6F 64        
004620r 3               
004620r 3               nt_sm_slash_rem:
004620r 3  06 10                .byte 6, UF
004622r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
004626r 3  rr rr        
004628r 3  73 6D 2F 72          .byte "sm/rem"
00462Cr 3  65 6D        
00462Er 3               
00462Er 3               nt_um_slash_mod:
00462Er 3  06 10                .byte 6, UF
004630r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
004634r 3  rr rr        
004636r 3  75 6D 2F 6D          .byte "um/mod"
00463Ar 3  6F 64        
00463Cr 3               
00463Cr 3               nt_star:
00463Cr 3  01 10                .byte 1, UF
00463Er 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
004642r 3  rr rr        
004644r 3  2A                   .byte "*"
004645r 3               
004645r 3               nt_um_star:
004645r 3  03 10                .byte 3, UF
004647r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
00464Br 3  rr rr        
00464Dr 3  75 6D 2A             .byte "um*"
004650r 3               
004650r 3               nt_m_star:
004650r 3  02 10                .byte 2, UF
004652r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
004656r 3  rr rr        
004658r 3  6D 2A                .byte "m*"
00465Ar 3               
00465Ar 3               nt_count:
00465Ar 3  05 10                .byte 5, UF
00465Cr 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
004660r 3  rr rr        
004662r 3  63 6F 75 6E          .byte "count"
004666r 3  74           
004667r 3               
004667r 3               nt_decimal:
004667r 3  07 00                .byte 7, 0
004669r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
00466Dr 3  rr rr        
00466Fr 3  64 65 63 69          .byte "decimal"
004673r 3  6D 61 6C     
004676r 3               
004676r 3               nt_hex:
004676r 3  03 00                .byte 3, 0
004678r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
00467Cr 3  rr rr        
00467Er 3  68 65 78             .byte "hex"
004681r 3               
004681r 3               nt_to_number:
004681r 3  07 10                .byte 7, UF
004683r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
004687r 3  rr rr        
004689r 3  3E 6E 75 6D          .byte ">number"
00468Dr 3  62 65 72     
004690r 3               
004690r 3               nt_number:
004690r 3  06 10                .byte 6, UF
004692r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
004696r 3  rr rr        
004698r 3  6E 75 6D 62          .byte "number"
00469Cr 3  65 72        
00469Er 3               
00469Er 3               nt_digit_question:
00469Er 3  06 10                .byte 6, UF
0046A0r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
0046A4r 3  rr rr        
0046A6r 3  64 69 67 69          .byte "digit?"
0046AAr 3  74 3F        
0046ACr 3               
0046ACr 3               nt_base:
0046ACr 3  04 00                .byte 4, 0
0046AEr 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
0046B2r 3  rr rr        
0046B4r 3  62 61 73 65          .byte "base"
0046B8r 3               
0046B8r 3               nt_evaluate:
0046B8r 3  08 10                .byte 8, UF
0046BAr 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
0046BEr 3  rr rr        
0046C0r 3  65 76 61 6C          .byte "evaluate"
0046C4r 3  75 61 74 65  
0046C8r 3               
0046C8r 3               nt_state:
0046C8r 3  05 00                .byte 5, 0
0046CAr 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
0046CEr 3  rr rr        
0046D0r 3  73 74 61 74          .byte "state"
0046D4r 3  65           
0046D5r 3               
0046D5r 3               nt_again:
0046D5r 3  05 17                .byte 5, AN+CO+IM+UF
0046D7r 3  rr rr rr rr          .word nt_state, xt_again, z_again
0046DBr 3  rr rr        
0046DDr 3  61 67 61 69          .byte "again"
0046E1r 3  6E           
0046E2r 3               
0046E2r 3               nt_begin:
0046E2r 3  05 07                .byte 5, AN+CO+IM
0046E4r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
0046E8r 3  rr rr        
0046EAr 3  62 65 67 69          .byte "begin"
0046EEr 3  6E           
0046EFr 3               
0046EFr 3               nt_quit:
0046EFr 3  04 00                .byte 4, 0
0046F1r 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
0046F5r 3  rr rr        
0046F7r 3  71 75 69 74          .byte "quit"
0046FBr 3               
0046FBr 3               nt_recurse:
0046FBr 3  07 0D                .byte 7, CO+IM+NN
0046FDr 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
004701r 3  rr rr        
004703r 3  72 65 63 75          .byte "recurse"
004707r 3  72 73 65     
00470Ar 3               
00470Ar 3               nt_leave:
00470Ar 3  05 03                .byte 5, AN+CO
00470Cr 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
004710r 3  rr rr        
004712r 3  6C 65 61 76          .byte "leave"
004716r 3  65           
004717r 3               
004717r 3               nt_unloop:
004717r 3  06 03                .byte 6, AN+CO
004719r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
00471Dr 3  rr rr        
00471Fr 3  75 6E 6C 6F          .byte "unloop"
004723r 3  6F 70        
004725r 3               
004725r 3               nt_exit:
004725r 3  04 03                .byte 4, AN+CO
004727r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
00472Br 3  rr rr        
00472Dr 3  65 78 69 74          .byte "exit"
004731r 3               
004731r 3               nt_plus_loop:
004731r 3  05 05                .byte 5, CO+IM
004733r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
004737r 3  rr rr        
004739r 3  2B 6C 6F 6F          .byte "+loop"
00473Dr 3  70           
00473Er 3               
00473Er 3               nt_loop:
00473Er 3  04 05                .byte 4, CO+IM
004740r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
004744r 3  rr rr        
004746r 3  6C 6F 6F 70          .byte "loop"
00474Ar 3               
00474Ar 3               nt_j:
00474Ar 3  01 03                .byte 1, AN+CO
00474Cr 3  rr rr rr rr          .word nt_loop, xt_j, z_j
004750r 3  rr rr        
004752r 3  6A                   .byte "j"
004753r 3               
004753r 3               nt_i:
004753r 3  01 03                .byte 1, AN+CO
004755r 3  rr rr rr rr          .word nt_j, xt_i, z_i
004759r 3  rr rr        
00475Br 3  69                   .byte "i"
00475Cr 3               
00475Cr 3               nt_question_do:
00475Cr 3  03 0D                .byte 3, CO+IM+NN
00475Er 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
004762r 3  rr rr        
004764r 3  3F 64 6F             .byte "?do"
004767r 3               
004767r 3               nt_do:
004767r 3  02 0D                .byte 2, CO+IM+NN
004769r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
00476Dr 3  rr rr        
00476Fr 3  64 6F                .byte "do"
004771r 3               
004771r 3               nt_abort_quote:
004771r 3  06 0D                .byte 6, CO+IM+NN
004773r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
004777r 3  rr rr        
004779r 3  61 62 6F 72          .byte "abort", $22
00477Dr 3  74 22        
00477Fr 3               
00477Fr 3               nt_abort:
00477Fr 3  05 00                .byte 5, 0
004781r 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
004785r 3  rr rr        
004787r 3  61 62 6F 72          .byte "abort"
00478Br 3  74           
00478Cr 3               
00478Cr 3               nt_strip_underflow:
00478Cr 3  0F 00                .byte 15, 0
00478Er 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
004792r 3  rr rr        
004794r 3  73 74 72 69          .byte "strip-underflow"
004798r 3  70 2D 75 6E  
00479Cr 3  64 65 72 66  
0047A3r 3               
0047A3r 3               nt_nc_limit:
0047A3r 3  08 00                .byte 8, 0
0047A5r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
0047A9r 3  rr rr        
0047ABr 3  6E 63 2D 6C          .byte "nc-limit"
0047AFr 3  69 6D 69 74  
0047B3r 3               
0047B3r 3               nt_allow_native:
0047B3r 3  0C 00                .byte 12, 0
0047B5r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
0047B9r 3  rr rr        
0047BBr 3  61 6C 6C 6F          .byte "allow-native"
0047BFr 3  77 2D 6E 61  
0047C3r 3  74 69 76 65  
0047C7r 3               
0047C7r 3               nt_always_native:
0047C7r 3  0D 00                .byte 13, 0
0047C9r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
0047CDr 3  rr rr        
0047CFr 3  61 6C 77 61          .byte "always-native"
0047D3r 3  79 73 2D 6E  
0047D7r 3  61 74 69 76  
0047DCr 3               
0047DCr 3               nt_never_native:
0047DCr 3  0C 00                .byte 12, 0
0047DEr 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
0047E2r 3  rr rr        
0047E4r 3  6E 65 76 65          .byte "never-native"
0047E8r 3  72 2D 6E 61  
0047ECr 3  74 69 76 65  
0047F0r 3               
0047F0r 3               nt_compile_only:
0047F0r 3  0C 00                .byte 12, 0
0047F2r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
0047F6r 3  rr rr        
0047F8r 3  63 6F 6D 70          .byte "compile-only"
0047FCr 3  69 6C 65 2D  
004800r 3  6F 6E 6C 79  
004804r 3               
004804r 3               nt_immediate:
004804r 3  09 00                .byte 9, 0
004806r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
00480Ar 3  rr rr        
00480Cr 3  69 6D 6D 65          .byte "immediate"
004810r 3  64 69 61 74  
004814r 3  65           
004815r 3               
004815r 3               nt_postpone:
004815r 3  08 05                .byte 8, IM+CO
004817r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
00481Br 3  rr rr        
00481Dr 3  70 6F 73 74          .byte "postpone"
004821r 3  70 6F 6E 65  
004825r 3               
004825r 3               nt_s_backslash_quote:
004825r 3  03 04                .byte 3, IM
004827r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
00482Br 3  rr rr        
00482Dr 3  73 5C 22             .byte "s", $5C, $22
004830r 3               
004830r 3               nt_s_quote:
004830r 3  02 0C                .byte 2, IM+NN
004832r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
004836r 3  rr rr        
004838r 3  73 22                .byte "s", $22
00483Ar 3               
00483Ar 3               nt_dot_quote:
00483Ar 3  02 05                .byte 2, CO+IM
00483Cr 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
004840r 3  rr rr        
004842r 3  2E 22                .byte ".", $22
004844r 3               
004844r 3               nt_sliteral:
004844r 3  08 15                .byte 8, CO+IM+UF
004846r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
00484Ar 3  rr rr        
00484Cr 3  73 6C 69 74          .byte "sliteral"
004850r 3  65 72 61 6C  
004854r 3               
004854r 3               nt_literal:
004854r 3  07 15                .byte 7, IM+CO+UF
004856r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
00485Ar 3  rr rr        
00485Cr 3  6C 69 74 65          .byte "literal"
004860r 3  72 61 6C     
004863r 3               
004863r 3               nt_right_bracket:
004863r 3  01 04                .byte 1, IM
004865r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
004869r 3  rr rr        
00486Br 3  5D                   .byte "]"
00486Cr 3               
00486Cr 3               nt_left_bracket:
00486Cr 3  01 05                .byte 1, IM+CO
00486Er 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
004872r 3  rr rr        
004874r 3  5B                   .byte "["
004875r 3               
004875r 3               nt_compile_comma:
004875r 3  08 18                .byte 8, UF+NN
004877r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
00487Br 3  rr rr        
00487Dr 3  63 6F 6D 70          .byte "compile,"
004881r 3  69 6C 65 2C  
004885r 3               
004885r 3               nt_colon_noname:
004885r 3  07 00                .byte 7, 0
004887r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
00488Br 3  rr rr        
00488Dr 3  3A 6E 6F 6E          .byte ":noname"
004891r 3  61 6D 65     
004894r 3               
004894r 3               nt_semicolon:
004894r 3  01 05                .byte 1, CO+IM
004896r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
00489Ar 3  rr rr        
00489Cr 3  3B                   .byte ";"
00489Dr 3               
00489Dr 3               nt_colon:
00489Dr 3  01 00                .byte 1, 0
00489Fr 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
0048A3r 3  rr rr        
0048A5r 3  3A                   .byte ":"
0048A6r 3               
0048A6r 3               nt_source_id:
0048A6r 3  09 00                .byte 9, 0
0048A8r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
0048ACr 3  rr rr        
0048AEr 3  73 6F 75 72          .byte "source-id"
0048B2r 3  63 65 2D 69  
0048B6r 3  64           
0048B7r 3               
0048B7r 3               nt_source:
0048B7r 3  06 00                .byte 6, 0
0048B9r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
0048BDr 3  rr rr        
0048BFr 3  73 6F 75 72          .byte "source"
0048C3r 3  63 65        
0048C5r 3               
0048C5r 3               nt_execute_parsing:
0048C5r 3  0F 10                .byte 15, UF
0048C7r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
0048CBr 3  rr rr        
0048CDr 3  65 78 65 63          .byte "execute-parsing"
0048D1r 3  75 74 65 2D  
0048D5r 3  70 61 72 73  
0048DCr 3               
0048DCr 3               nt_parse:
0048DCr 3  05 10                .byte 5, UF
0048DEr 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
0048E2r 3  rr rr        
0048E4r 3  70 61 72 73          .byte "parse"
0048E8r 3  65           
0048E9r 3               
0048E9r 3               nt_parse_name:
0048E9r 3  0A 08                .byte 10, NN
0048EBr 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
0048EFr 3  rr rr        
0048F1r 3  70 61 72 73          .byte "parse-name"
0048F5r 3  65 2D 6E 61  
0048F9r 3  6D 65        
0048FBr 3               
0048FBr 3               nt_latestnt:
0048FBr 3  08 00                .byte 8, 0
0048FDr 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
004901r 3  rr rr        
004903r 3  6C 61 74 65          .byte "latestnt"
004907r 3  73 74 6E 74  
00490Br 3               
00490Br 3               nt_latestxt:
00490Br 3  08 00                .byte 8, 0
00490Dr 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
004911r 3  rr rr        
004913r 3  6C 61 74 65          .byte "latestxt"
004917r 3  73 74 78 74  
00491Br 3               
00491Br 3               nt_defer:
00491Br 3  05 00                .byte 5, 0
00491Dr 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
004921r 3  rr rr        
004923r 3  64 65 66 65          .byte "defer"
004927r 3  72           
004928r 3               
004928r 3               nt_to_body:
004928r 3  05 10                .byte 5, UF
00492Ar 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
00492Er 3  rr rr        
004930r 3  3E 62 6F 64          .byte ">body"
004934r 3  79           
004935r 3               
004935r 3               nt_name_to_string:
004935r 3  0B 10                .byte 11, UF
004937r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
00493Br 3  rr rr        
00493Dr 3  6E 61 6D 65          .byte "name>string"
004941r 3  3E 73 74 72  
004945r 3  69 6E 67     
004948r 3               
004948r 3               nt_int_to_name:
004948r 3  08 10                .byte 8, UF
00494Ar 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
00494Er 3  rr rr        
004950r 3  69 6E 74 3E          .byte "int>name"
004954r 3  6E 61 6D 65  
004958r 3               
004958r 3               nt_name_to_int:
004958r 3  08 10                .byte 8, UF
00495Ar 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
00495Er 3  rr rr        
004960r 3  6E 61 6D 65          .byte "name>int"
004964r 3  3E 69 6E 74  
004968r 3               
004968r 3               nt_bracket_tick:
004968r 3  03 05                .byte 3, CO+IM
00496Ar 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
00496Er 3  rr rr        
004970r 3  5B 27 5D             .byte "[']"
004973r 3               
004973r 3               nt_tick:
004973r 3  01 00                .byte 1, 0
004975r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
004979r 3  rr rr        
00497Br 3  27                   .byte "'"
00497Cr 3               
00497Cr 3               nt_find_name:
00497Cr 3  09 10                .byte 9, UF
00497Er 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
004982r 3  rr rr        
004984r 3  66 69 6E 64          .byte "find-name"
004988r 3  2D 6E 61 6D  
00498Cr 3  65           
00498Dr 3               
00498Dr 3               nt_fill:
00498Dr 3  04 10                .byte 4, UF
00498Fr 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
004993r 3  rr rr        
004995r 3  66 69 6C 6C          .byte "fill"
004999r 3               
004999r 3               nt_blank:
004999r 3  05 00                .byte 5, 0     ; underflow checked by FILL
00499Br 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
00499Fr 3  rr rr        
0049A1r 3  62 6C 61 6E          .byte "blank"
0049A5r 3  6B           
0049A6r 3               
0049A6r 3               nt_erase:
0049A6r 3  05 00                .byte 5, 0      ; underflow checked by FILL
0049A8r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
0049ACr 3  rr rr        
0049AEr 3  65 72 61 73          .byte "erase"
0049B2r 3  65           
0049B3r 3               
0049B3r 3               nt_d_plus:
0049B3r 3  02 10                .byte 2, UF
0049B5r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
0049B9r 3  rr rr        
0049BBr 3  64 2B                .byte "d+"
0049BDr 3               
0049BDr 3               nt_d_minus:
0049BDr 3  02 10                .byte 2, UF
0049BFr 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
0049C3r 3  rr rr        
0049C5r 3  64 2D                .byte "d-"
0049C7r 3               
0049C7r 3               nt_d_to_s:
0049C7r 3  03 10                .byte 3, UF
0049C9r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
0049CDr 3  rr rr        
0049CFr 3  64 3E 73             .byte "d>s"
0049D2r 3               
0049D2r 3               nt_s_to_d:
0049D2r 3  03 10                .byte 3, UF
0049D4r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
0049D8r 3  rr rr        
0049DAr 3  73 3E 64             .byte "s>d"
0049DDr 3               
0049DDr 3               nt_to:
0049DDr 3  02 0C                .byte 2, NN+IM
0049DFr 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
0049E3r 3  rr rr        
0049E5r 3  74 6F                .byte "to"
0049E7r 3               
0049E7r 3               nt_value:               ; same code as CONSTANT
0049E7r 3  05 10                .byte 5, UF
0049E9r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
0049EDr 3  rr rr        
0049EFr 3  76 61 6C 75          .byte "value"
0049F3r 3  65           
0049F4r 3               
0049F4r 3               nt_constant:
0049F4r 3  08 10                .byte 8, UF
0049F6r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
0049FAr 3  rr rr        
0049FCr 3  63 6F 6E 73          .byte "constant"
004A00r 3  74 61 6E 74  
004A04r 3               
004A04r 3               nt_variable:
004A04r 3  08 00                .byte 8, 0
004A06r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
004A0Ar 3  rr rr        
004A0Cr 3  76 61 72 69          .byte "variable"
004A10r 3  61 62 6C 65  
004A14r 3               
004A14r 3               nt_does:
004A14r 3  05 05                .byte 5, CO+IM
004A16r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
004A1Ar 3  rr rr        
004A1Cr 3  64 6F 65 73          .byte "does>"
004A20r 3  3E           
004A21r 3               
004A21r 3               nt_create:
004A21r 3  06 00                .byte 6, 0
004A23r 3  rr rr rr rr          .word nt_does, xt_create, z_create
004A27r 3  rr rr        
004A29r 3  63 72 65 61          .byte "create"
004A2Dr 3  74 65        
004A2Fr 3               
004A2Fr 3               nt_allot:
004A2Fr 3  05 10                .byte 5, UF
004A31r 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
004A35r 3  rr rr        
004A37r 3  61 6C 6C 6F          .byte "allot"
004A3Br 3  74           
004A3Cr 3               
004A3Cr 3               nt_key:
004A3Cr 3  03 00                .byte 3, 0
004A3Er 3  rr rr rr rr          .word nt_allot, xt_key, z_key
004A42r 3  rr rr        
004A44r 3  6B 65 79             .byte "key"
004A47r 3               
004A47r 3               nt_depth:
004A47r 3  05 00                .byte 5, 0
004A49r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
004A4Dr 3  rr rr        
004A4Fr 3  64 65 70 74          .byte "depth"
004A53r 3  68           
004A54r 3               
004A54r 3               nt_unused:
004A54r 3  06 00                .byte 6, 0
004A56r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
004A5Ar 3  rr rr        
004A5Cr 3  75 6E 75 73          .byte "unused"
004A60r 3  65 64        
004A62r 3               
004A62r 3               nt_r_to_input:
004A62r 3  07 08                .byte 7, NN
004A64r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
004A68r 3  rr rr        
004A6Ar 3  72 3E 69 6E          .byte "r>input"
004A6Er 3  70 75 74     
004A71r 3               
004A71r 3               nt_input_to_r:
004A71r 3  07 08                .byte 7, NN
004A73r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
004A77r 3  rr rr        
004A79r 3  69 6E 70 75          .byte "input>r"
004A7Dr 3  74 3E 72     
004A80r 3               
004A80r 3               nt_accept:
004A80r 3  06 18                .byte 6, UF+NN
004A82r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
004A86r 3  rr rr        
004A88r 3  61 63 63 65          .byte "accept"
004A8Cr 3  70 74        
004A8Er 3               
004A8Er 3               nt_refill:
004A8Er 3  06 00                .byte 6, 0
004A90r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
004A94r 3  rr rr        
004A96r 3  72 65 66 69          .byte "refill"
004A9Ar 3  6C 6C        
004A9Cr 3               
004A9Cr 3               nt_slash_string:
004A9Cr 3  07 10                .byte 7, UF
004A9Er 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
004AA2r 3  rr rr        
004AA4r 3  2F 73 74 72          .byte "/string"
004AA8r 3  69 6E 67     
004AABr 3               
004AABr 3               nt_minus_leading:
004AABr 3  08 10                .byte 8, UF
004AADr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
004AB1r 3  rr rr        
004AB3r 3  2D 6C 65 61          .byte "-leading"
004AB7r 3  64 69 6E 67  
004ABBr 3               
004ABBr 3               nt_minus_trailing:
004ABBr 3  09 10                .byte 9, UF
004ABDr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
004AC1r 3  rr rr        
004AC3r 3  2D 74 72 61          .byte "-trailing"
004AC7r 3  69 6C 69 6E  
004ACBr 3  67           
004ACCr 3               
004ACCr 3               nt_bl:
004ACCr 3  02 00                .byte 2, 0
004ACEr 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
004AD2r 3  rr rr        
004AD4r 3  62 6C                .byte "bl"
004AD6r 3               
004AD6r 3               nt_spaces:
004AD6r 3  06 10                .byte 6, UF
004AD8r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
004ADCr 3  rr rr        
004ADEr 3  73 70 61 63          .byte "spaces"
004AE2r 3  65 73        
004AE4r 3               
004AE4r 3               nt_bounds:
004AE4r 3  06 10                .byte 6, UF
004AE6r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
004AEAr 3  rr rr        
004AECr 3  62 6F 75 6E          .byte "bounds"
004AF0r 3  64 73        
004AF2r 3               
004AF2r 3               nt_c_comma:
004AF2r 3  02 10                .byte 2, UF
004AF4r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
004AF8r 3  rr rr        
004AFAr 3  63 2C                .byte "c,"
004AFCr 3               
004AFCr 3               nt_dnegate:
004AFCr 3  07 10                .byte 7, UF
004AFEr 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
004B02r 3  rr rr        
004B04r 3  64 6E 65 67          .byte "dnegate"
004B08r 3  61 74 65     
004B0Br 3               
004B0Br 3               nt_negate:
004B0Br 3  06 10                .byte 6, UF
004B0Dr 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
004B11r 3  rr rr        
004B13r 3  6E 65 67 61          .byte "negate"
004B17r 3  74 65        
004B19r 3               
004B19r 3               nt_invert:
004B19r 3  06 10                .byte 6, UF
004B1Br 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
004B1Fr 3  rr rr        
004B21r 3  69 6E 76 65          .byte "invert"
004B25r 3  72 74        
004B27r 3               
004B27r 3               nt_two_to_r:
004B27r 3  03 11                .byte 3, CO+UF          ; native is special case
004B29r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
004B2Dr 3  rr rr        
004B2Fr 3  32 3E 72             .byte "2>r"
004B32r 3               
004B32r 3               nt_two_r_from:
004B32r 3  03 01                .byte 3, CO             ; native is special case
004B34r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
004B38r 3  rr rr        
004B3Ar 3  32 72 3E             .byte "2r>"
004B3Dr 3               
004B3Dr 3               nt_two_r_fetch:
004B3Dr 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
004B3Fr 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
004B43r 3  rr rr        
004B45r 3  32 72 40             .byte "2r@"
004B48r 3               
004B48r 3               nt_two_literal:
004B48r 3  08 14                .byte 8, UF+IM
004B4Ar 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
004B4Er 3  rr rr        
004B50r 3  32 6C 69 74          .byte "2literal"
004B54r 3  65 72 61 6C  
004B58r 3               
004B58r 3               nt_two_constant:
004B58r 3  09 10                .byte 9, UF
004B5Ar 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
004B5Er 3  rr rr        
004B60r 3  32 63 6F 6E          .byte "2constant"
004B64r 3  73 74 61 6E  
004B68r 3  74           
004B69r 3               
004B69r 3               nt_two_variable:
004B69r 3  09 00                .byte 9, 0
004B6Br 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
004B6Fr 3  rr rr        
004B71r 3  32 76 61 72          .byte "2variable"
004B75r 3  69 61 62 6C  
004B79r 3  65           
004B7Ar 3               
004B7Ar 3               nt_two_fetch:
004B7Ar 3  02 10                .byte 2, UF
004B7Cr 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
004B80r 3  rr rr        
004B82r 3  32 40                .byte "2@"
004B84r 3               
004B84r 3               nt_two_store:
004B84r 3  02 10                .byte 2, UF
004B86r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
004B8Ar 3  rr rr        
004B8Cr 3  32 21                .byte "2!"
004B8Er 3               
004B8Er 3               nt_two_over:
004B8Er 3  05 10                .byte 5, UF
004B90r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
004B94r 3  rr rr        
004B96r 3  32 6F 76 65          .byte "2over"
004B9Ar 3  72           
004B9Br 3               
004B9Br 3               nt_two_swap:
004B9Br 3  05 10                .byte 5, UF
004B9Dr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
004BA1r 3  rr rr        
004BA3r 3  32 73 77 61          .byte "2swap"
004BA7r 3  70           
004BA8r 3               
004BA8r 3               nt_two_drop:
004BA8r 3  05 10                .byte 5, UF
004BAAr 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
004BAEr 3  rr rr        
004BB0r 3  32 64 72 6F          .byte "2drop"
004BB4r 3  70           
004BB5r 3               
004BB5r 3               nt_max:
004BB5r 3  03 10                .byte 3, UF
004BB7r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
004BBBr 3  rr rr        
004BBDr 3  6D 61 78             .byte "max"
004BC0r 3               
004BC0r 3               nt_min:
004BC0r 3  03 10                .byte 3, UF
004BC2r 3  rr rr rr rr          .word nt_max, xt_min, z_min
004BC6r 3  rr rr        
004BC8r 3  6D 69 6E             .byte "min"
004BCBr 3               
004BCBr 3               nt_zero_less:
004BCBr 3  02 10                .byte 2, UF
004BCDr 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
004BD1r 3  rr rr        
004BD3r 3  30 3C                .byte "0<"
004BD5r 3               
004BD5r 3               nt_zero_greater:
004BD5r 3  02 10                .byte 2, UF
004BD7r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
004BDBr 3  rr rr        
004BDDr 3  30 3E                .byte "0>"
004BDFr 3               
004BDFr 3               nt_zero_unequal:
004BDFr 3  03 10                .byte 3, UF
004BE1r 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
004BE5r 3  rr rr        
004BE7r 3  30 3C 3E             .byte "0<>"
004BEAr 3               
004BEAr 3               nt_zero_equal:
004BEAr 3  02 10                .byte 2, UF
004BECr 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
004BF0r 3  rr rr        
004BF2r 3  30 3D                .byte "0="
004BF4r 3               
004BF4r 3               nt_greater_than:
004BF4r 3  01 10                .byte 1, UF
004BF6r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
004BFAr 3  rr rr        
004BFCr 3  3E                   .byte ">"
004BFDr 3               
004BFDr 3               nt_u_greater_than:
004BFDr 3  02 10                .byte 2, UF
004BFFr 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
004C03r 3  rr rr        
004C05r 3  75 3E                .byte "u>"
004C07r 3               
004C07r 3               nt_u_less_than:
004C07r 3  02 10                .byte 2, UF
004C09r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
004C0Dr 3  rr rr        
004C0Fr 3  75 3C                .byte "u<"
004C11r 3               
004C11r 3               nt_less_than:
004C11r 3  01 10                .byte 1, UF
004C13r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
004C17r 3  rr rr        
004C19r 3  3C                   .byte "<"
004C1Ar 3               
004C1Ar 3               nt_not_equals:
004C1Ar 3  02 10                .byte 2, UF
004C1Cr 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
004C20r 3  rr rr        
004C22r 3  3C 3E                .byte "<>"
004C24r 3               
004C24r 3               nt_equal:
004C24r 3  01 10                .byte 1, UF
004C26r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
004C2Ar 3  rr rr        
004C2Cr 3  3D                   .byte "="
004C2Dr 3               
004C2Dr 3               nt_two_slash:
004C2Dr 3  02 10                .byte 2, UF
004C2Fr 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
004C33r 3  rr rr        
004C35r 3  32 2F                .byte "2/"
004C37r 3               
004C37r 3               nt_two_star:
004C37r 3  02 10                .byte 2, UF
004C39r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
004C3Dr 3  rr rr        
004C3Fr 3  32 2A                .byte "2*"
004C41r 3               
004C41r 3               nt_one_plus:
004C41r 3  02 10                .byte 2, UF
004C43r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
004C47r 3  rr rr        
004C49r 3  31 2B                .byte "1+"
004C4Br 3               
004C4Br 3               nt_one_minus:
004C4Br 3  02 10                .byte 2, UF
004C4Dr 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
004C51r 3  rr rr        
004C53r 3  31 2D                .byte "1-"
004C55r 3               
004C55r 3               nt_here:
004C55r 3  04 00                .byte 4, 0
004C57r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
004C5Br 3  rr rr        
004C5Dr 3  68 65 72 65          .byte "here"
004C61r 3               
004C61r 3               nt_cell_plus:
004C61r 3  05 10                .byte 5, UF
004C63r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
004C67r 3  rr rr        
004C69r 3  63 65 6C 6C          .byte "cell+"
004C6Dr 3  2B           
004C6Er 3               
004C6Er 3               nt_cells:
004C6Er 3  05 00                .byte 5, 0
004C70r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
004C74r 3  rr rr        
004C76r 3  63 65 6C 6C          .byte "cells"
004C7Ar 3  73           
004C7Br 3               
004C7Br 3               nt_chars:
004C7Br 3  05 12                .byte 5, AN+UF   ; deleted during compile
004C7Dr 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
004C81r 3  rr rr        
004C83r 3  63 68 61 72          .byte "chars"
004C87r 3  73           
004C88r 3               
004C88r 3               nt_char_plus:
004C88r 3  05 00                .byte 5, 0
004C8Ar 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
004C8Er 3  rr rr        
004C90r 3  63 68 61 72          .byte "char+"
004C94r 3  2B           
004C95r 3               
004C95r 3               nt_bracket_char:
004C95r 3  06 05                .byte 6, CO+IM
004C97r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
004C9Br 3  rr rr        
004C9Dr 3  5B 63 68 61          .byte "[char]"
004CA1r 3  72 5D        
004CA3r 3               
004CA3r 3               nt_char:
004CA3r 3  04 00                .byte 4, 0
004CA5r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
004CA9r 3  rr rr        
004CABr 3  63 68 61 72          .byte "char"
004CAFr 3               
004CAFr 3               nt_pick:
004CAFr 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
004CB1r 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
004CB5r 3  rr rr        
004CB7r 3  70 69 63 6B          .byte "pick"
004CBBr 3               
004CBBr 3               nt_lshift:
004CBBr 3  06 10                .byte 6, UF
004CBDr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
004CC1r 3  rr rr        
004CC3r 3  6C 73 68 69          .byte "lshift"
004CC7r 3  66 74        
004CC9r 3               
004CC9r 3               nt_rshift:
004CC9r 3  06 10                .byte 6, UF
004CCBr 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
004CCFr 3  rr rr        
004CD1r 3  72 73 68 69          .byte "rshift"
004CD5r 3  66 74        
004CD7r 3               
004CD7r 3               nt_xor:
004CD7r 3  03 10                .byte 3, UF
004CD9r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
004CDDr 3  rr rr        
004CDFr 3  78 6F 72             .byte "xor"
004CE2r 3               
004CE2r 3               nt_or:
004CE2r 3  02 10                .byte 2, UF
004CE4r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
004CE8r 3  rr rr        
004CEAr 3  6F 72                .byte "or"
004CECr 3               
004CECr 3               nt_and:
004CECr 3  03 10                .byte 3, UF
004CEEr 3  rr rr rr rr          .word nt_or, xt_and, z_and
004CF2r 3  rr rr        
004CF4r 3  61 6E 64             .byte "and"
004CF7r 3               
004CF7r 3               nt_dabs:
004CF7r 3  04 10                .byte 4, UF
004CF9r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
004CFDr 3  rr rr        
004CFFr 3  64 61 62 73          .byte "dabs"
004D03r 3               
004D03r 3               nt_abs:
004D03r 3  03 10                .byte 3, UF
004D05r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
004D09r 3  rr rr        
004D0Br 3  61 62 73             .byte "abs"
004D0Er 3               
004D0Er 3               nt_minus:
004D0Er 3  01 10                .byte 1, UF
004D10r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
004D14r 3  rr rr        
004D16r 3  2D                   .byte "-"
004D17r 3               
004D17r 3               nt_plus:
004D17r 3  01 10                .byte 1, UF
004D19r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
004D1Dr 3  rr rr        
004D1Fr 3  2B                   .byte "+"
004D20r 3               
004D20r 3               nt_question_dup:
004D20r 3  04 10                .byte 4, UF
004D22r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
004D26r 3  rr rr        
004D28r 3  3F 64 75 70          .byte "?dup"
004D2Cr 3               
004D2Cr 3               nt_two_dup:
004D2Cr 3  04 10                .byte 4, UF
004D2Er 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
004D32r 3  rr rr        
004D34r 3  32 64 75 70          .byte "2dup"
004D38r 3               
004D38r 3               nt_two:
004D38r 3  01 00                .byte 1, 0
004D3Ar 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
004D3Er 3  rr rr        
004D40r 3  32                   .byte "2"
004D41r 3               
004D41r 3               nt_one:
004D41r 3  01 00                .byte 1, 0
004D43r 3  rr rr rr rr          .word nt_two, xt_one, z_one
004D47r 3  rr rr        
004D49r 3  31                   .byte "1"
004D4Ar 3               
004D4Ar 3               nt_zero:
004D4Ar 3  01 00                .byte 1, 0
004D4Cr 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
004D50r 3  rr rr        
004D52r 3  30                   .byte "0"
004D53r 3               
004D53r 3               nt_space:
004D53r 3  05 00                .byte 5, 0
004D55r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
004D59r 3  rr rr        
004D5Br 3  73 70 61 63          .byte "space"
004D5Fr 3  65           
004D60r 3               
004D60r 3               nt_true:
004D60r 3  04 00                .byte 4, 0
004D62r 3  rr rr rr rr          .word nt_space, xt_true, z_true
004D66r 3  rr rr        
004D68r 3  74 72 75 65          .byte "true"
004D6Cr 3               
004D6Cr 3               nt_false:
004D6Cr 3  05 00                .byte 5, 0
004D6Er 3  rr rr rr rr          .word nt_true, xt_false, z_false
004D72r 3  rr rr        
004D74r 3  66 61 6C 73          .byte "false"
004D78r 3  65           
004D79r 3               
004D79r 3               nt_question:
004D79r 3  01 00                .byte 1, 0
004D7Br 3  rr rr rr rr          .word nt_false, xt_question, z_question
004D7Fr 3  rr rr        
004D81r 3  3F                   .byte "?"
004D82r 3               
004D82r 3               nt_ud_dot_r:
004D82r 3  04 10                .byte 4, UF
004D84r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
004D88r 3  rr rr        
004D8Ar 3  75 64 2E 72          .byte "ud.r"
004D8Er 3               
004D8Er 3               nt_ud_dot:
004D8Er 3  03 10                .byte 3, UF
004D90r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
004D94r 3  rr rr        
004D96r 3  75 64 2E             .byte "ud."
004D99r 3               
004D99r 3               nt_d_dot_r:
004D99r 3  03 10                .byte 3, UF
004D9Br 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
004D9Fr 3  rr rr        
004DA1r 3  64 2E 72             .byte "d.r"
004DA4r 3               
004DA4r 3               nt_d_dot:
004DA4r 3  02 10                .byte 2, UF
004DA6r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
004DAAr 3  rr rr        
004DACr 3  64 2E                .byte "d."
004DAEr 3               
004DAEr 3               nt_dot_r:
004DAEr 3  02 10                .byte 2, UF
004DB0r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
004DB4r 3  rr rr        
004DB6r 3  2E 72                .byte ".r"
004DB8r 3               
004DB8r 3               nt_u_dot_r:
004DB8r 3  03 10                .byte 3, UF
004DBAr 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
004DBEr 3  rr rr        
004DC0r 3  75 2E 72             .byte "u.r"
004DC3r 3               
004DC3r 3               nt_u_dot:
004DC3r 3  02 10                .byte 2, UF
004DC5r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
004DC9r 3  rr rr        
004DCBr 3  75 2E                .byte "u."
004DCDr 3               
004DCDr 3               nt_dot:
004DCDr 3  01 10                .byte 1, UF
004DCFr 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
004DD3r 3  rr rr        
004DD5r 3  2E                   .byte "."
004DD6r 3               
004DD6r 3               nt_type:
004DD6r 3  04 10                .byte 4, UF
004DD8r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
004DDCr 3  rr rr        
004DDEr 3  74 79 70 65          .byte "type"
004DE2r 3               
004DE2r 3               nt_emit:
004DE2r 3  04 18                .byte 4, NN+UF
004DE4r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
004DE8r 3  rr rr        
004DEAr 3  65 6D 69 74          .byte "emit"
004DEEr 3               
004DEEr 3               nt_execute:
004DEEr 3  07 10                .byte 7, UF
004DF0r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
004DF4r 3  rr rr        
004DF6r 3  65 78 65 63          .byte "execute"
004DFAr 3  75 74 65     
004DFDr 3               
004DFDr 3               nt_plus_store:
004DFDr 3  02 10                .byte 2, UF
004DFFr 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
004E03r 3  rr rr        
004E05r 3  2B 21                .byte "+!"
004E07r 3               
004E07r 3               nt_c_store:
004E07r 3  02 10                .byte 2, UF
004E09r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
004E0Dr 3  rr rr        
004E0Fr 3  63 21                .byte "c!"
004E11r 3               
004E11r 3               nt_c_fetch:
004E11r 3  02 10                .byte 2, UF
004E13r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
004E17r 3  rr rr        
004E19r 3  63 40                .byte "c@"
004E1Br 3               
004E1Br 3               nt_comma:
004E1Br 3  01 10                .byte 1, UF
004E1Dr 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
004E21r 3  rr rr        
004E23r 3  2C                   .byte ","
004E24r 3               
004E24r 3               nt_tuck:
004E24r 3  04 10                .byte 4, UF
004E26r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
004E2Ar 3  rr rr        
004E2Cr 3  74 75 63 6B          .byte "tuck"
004E30r 3               
004E30r 3               nt_not_rote:
004E30r 3  04 10                .byte 4, UF
004E32r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
004E36r 3  rr rr        
004E38r 3  2D 72 6F 74          .byte "-rot"
004E3Cr 3               
004E3Cr 3               nt_rot:
004E3Cr 3  03 10                .byte 3, UF
004E3Er 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
004E42r 3  rr rr        
004E44r 3  72 6F 74             .byte "rot"
004E47r 3               
004E47r 3               nt_nip:
004E47r 3  03 10                .byte 3, UF
004E49r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
004E4Dr 3  rr rr        
004E4Fr 3  6E 69 70             .byte "nip"
004E52r 3               
004E52r 3               nt_r_fetch:
004E52r 3  02 01                .byte 2, CO    ; native is special case
004E54r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
004E58r 3  rr rr        
004E5Ar 3  72 40                .byte "r@"
004E5Cr 3               
004E5Cr 3               nt_r_from:
004E5Cr 3  02 01                .byte 2, CO    ; native is special case
004E5Er 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
004E62r 3  rr rr        
004E64r 3  72 3E                .byte "r>"
004E66r 3               
004E66r 3               nt_to_r:
004E66r 3  02 11                .byte 2, CO+UF ; native is special case
004E68r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
004E6Cr 3  rr rr        
004E6Er 3  3E 72                .byte ">r"
004E70r 3               
004E70r 3               nt_over:
004E70r 3  04 10                .byte 4, UF
004E72r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
004E76r 3  rr rr        
004E78r 3  6F 76 65 72          .byte "over"
004E7Cr 3               
004E7Cr 3               nt_fetch:
004E7Cr 3  01 10                .byte 1, UF
004E7Er 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
004E82r 3  rr rr        
004E84r 3  40                   .byte "@"
004E85r 3               
004E85r 3               nt_store:
004E85r 3  01 10                .byte 1, UF
004E87r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
004E8Br 3  rr rr        
004E8Dr 3  21                   .byte "!"
004E8Er 3               
004E8Er 3               nt_swap:
004E8Er 3  04 10                .byte 4, UF
004E90r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
004E94r 3  rr rr        
004E96r 3  73 77 61 70          .byte "swap"
004E9Ar 3               
004E9Ar 3               nt_dup:
004E9Ar 3  03 10                .byte 3, UF
004E9Cr 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
004EA0r 3  rr rr        
004EA2r 3  64 75 70             .byte "dup"
004EA5r 3               
004EA5r 3               ; DROP is always the first native word in the Dictionary
004EA5r 3               dictionary_start:
004EA5r 3               nt_drop:
004EA5r 3  04 10                .byte 4, UF
004EA7r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
004EABr 3  rr rr        
004EADr 3  64 72 6F 70          .byte "drop"
004EB1r 3               
004EB1r 3               ; END of FORTH-WORDLIST
004EB1r 3               
004EB1r 3               
004EB1r 3               ; ROOT-WORDLIST
004EB1r 3                       ; This is a short wordlist that has just the words needed to
004EB1r 3                       ; set the wordlists. These words are also included in the
004EB1r 3                       ; FORTH-WORDLIST as well.
004EB1r 3               
004EB1r 3               nt_root_words:
004EB1r 3  05 00                .byte 5, 0
004EB3r 3  00 00 rr rr          .word 0000, xt_words, z_words
004EB7r 3  rr rr        
004EB9r 3  77 6F 72 64          .byte "words"
004EBDr 3  73           
004EBEr 3               
004EBEr 3               nt_root_forth_wordlist: ; shares code with ZERO
004EBEr 3  0E 00                .byte 14, 0
004EC0r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
004EC4r 3  rr rr        
004EC6r 3  66 6F 72 74          .byte "forth-wordlist"
004ECAr 3  68 2D 77 6F  
004ECEr 3  72 64 6C 69  
004ED4r 3               
004ED4r 3               nt_root_forth:
004ED4r 3  05 00                .byte 5, 0
004ED6r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
004EDAr 3  rr rr        
004EDCr 3  66 6F 72 74          .byte "forth"
004EE0r 3  68           
004EE1r 3               
004EE1r 3               root_dictionary_start:
004EE1r 3               nt_root_set_order:
004EE1r 3  09 00                .byte 9, 0
004EE3r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
004EE7r 3  rr rr        
004EE9r 3  73 65 74 2D          .byte "set-order"
004EEDr 3  6F 72 64 65  
004EF1r 3  72           
004EF2r 3               
004EF2r 3               ; END of ROOT-WORDLIST
004EF2r 3               
004EF2r 3               
004EF2r 3               ; EDITOR-WORDLIST
004EF2r 3               
004EF2r 3               nt_editor_enter_screen:
004EF2r 3  0C 00                .byte 12, 0
004EF4r 3  00 00 rr rr          .word 0000, xt_editor_enter_screen, z_editor_enter_screen
004EF8r 3  rr rr        
004EFAr 3  65 6E 74 65          .byte "enter-screen"
004EFEr 3  72 2D 73 63  
004F02r 3  72 65 65 6E  
004F06r 3               
004F06r 3               nt_editor_erase_screen:
004F06r 3  0C 00                .byte 12, 0
004F08r 3  rr rr rr rr          .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
004F0Cr 3  rr rr        
004F0Er 3  65 72 61 73          .byte "erase-screen"
004F12r 3  65 2D 73 63  
004F16r 3  72 65 65 6E  
004F1Ar 3               
004F1Ar 3               nt_editor_el:
004F1Ar 3  02 00                .byte 2, 0
004F1Cr 3  rr rr rr rr          .word nt_editor_erase_screen, xt_editor_el, z_editor_el
004F20r 3  rr rr        
004F22r 3  65 6C                .byte "el"
004F24r 3               
004F24r 3               nt_editor_l:
004F24r 3  01 00                .byte 1, 0
004F26r 3  rr rr rr rr          .word nt_editor_el, xt_editor_l, z_editor_l
004F2Ar 3  rr rr        
004F2Cr 3  6C                   .byte "l"
004F2Dr 3               
004F2Dr 3               nt_editor_line:
004F2Dr 3  04 10                .byte 4, UF
004F2Fr 3  rr rr rr rr          .word nt_editor_l, xt_editor_line, z_editor_line
004F33r 3  rr rr        
004F35r 3  6C 69 6E 65          .byte "line"
004F39r 3               
004F39r 3               editor_dictionary_start:
004F39r 3               nt_editor_o:
004F39r 3  01 00                .byte 1, 0
004F3Br 3  rr rr rr rr          .word nt_editor_line, xt_editor_o, z_editor_o
004F3Fr 3  rr rr        
004F41r 3  6F                   .byte "o"
004F42r 3               
004F42r 3               ; END of EDITOR-WORDLIST
004F42r 3               
004F42r 3               
004F42r 3               ; ASSEMBLER-WORDLIST
004F42r 3               
004F42r 3               ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
004F42r 3               ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
004F42r 3               ; immediate addressing is replaced by an "h" (for example, the label code for
004F42r 3               ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
004F42r 3               assembler_dictionary_start:
004F42r 3               nt_asm_adc_h:
004F42r 3  05 04        		.byte 5, IM
004F44r 3  rr rr                        .word nt_asm_adc_x
004F46r 3  rr rr rr rr  		.word xt_asm_adc_h, z_asm_adc_h
004F4Ar 3  61 64 63 2E  		.byte "adc.#"
004F4Er 3  23           
004F4Fr 3               
004F4Fr 3               nt_asm_adc_x:
004F4Fr 3  05 04        		.byte 5, IM
004F51r 3  rr rr                        .word nt_asm_adc_y
004F53r 3  rr rr rr rr  		.word xt_asm_adc_x, z_asm_adc_x
004F57r 3  61 64 63 2E  		.byte "adc.x"
004F5Br 3  78           
004F5Cr 3               
004F5Cr 3               nt_asm_adc_y:
004F5Cr 3  05 04        		.byte 5, IM
004F5Er 3  rr rr                        .word nt_asm_adc_z
004F60r 3  rr rr rr rr  		.word xt_asm_adc_y, z_asm_adc_y
004F64r 3  61 64 63 2E  		.byte "adc.y"
004F68r 3  79           
004F69r 3               
004F69r 3               nt_asm_adc_z:
004F69r 3  05 04        		.byte 5, IM
004F6Br 3  rr rr                        .word nt_asm_adc_zi
004F6Dr 3  rr rr rr rr  		.word xt_asm_adc_z, z_asm_adc_z
004F71r 3  61 64 63 2E  		.byte "adc.z"
004F75r 3  7A           
004F76r 3               
004F76r 3               nt_asm_adc_zi:
004F76r 3  06 04        		.byte 6, IM
004F78r 3  rr rr                        .word nt_asm_adc_ziy
004F7Ar 3  rr rr rr rr  		.word xt_asm_adc_zi, z_asm_adc_zi
004F7Er 3  61 64 63 2E  		.byte "adc.zi"
004F82r 3  7A 69        
004F84r 3               
004F84r 3               nt_asm_adc_ziy:
004F84r 3  07 04        		.byte 7, IM
004F86r 3  rr rr                        .word nt_asm_adc_zx
004F88r 3  rr rr rr rr  		.word xt_asm_adc_ziy, z_asm_adc_ziy
004F8Cr 3  61 64 63 2E  		.byte "adc.ziy"
004F90r 3  7A 69 79     
004F93r 3               
004F93r 3               nt_asm_adc_zx:
004F93r 3  06 04        		.byte 6, IM
004F95r 3  rr rr                        .word nt_asm_adc_zxi
004F97r 3  rr rr rr rr  		.word xt_asm_adc_zx, z_asm_adc_zx
004F9Br 3  61 64 63 2E  		.byte "adc.zx"
004F9Fr 3  7A 78        
004FA1r 3               
004FA1r 3               nt_asm_adc_zxi:
004FA1r 3  07 04        		.byte 7, IM
004FA3r 3  rr rr                        .word nt_asm_and
004FA5r 3  rr rr rr rr  		.word xt_asm_adc_zxi, z_asm_adc_zxi
004FA9r 3  61 64 63 2E  		.byte "adc.zxi"
004FADr 3  7A 78 69     
004FB0r 3               
004FB0r 3               nt_asm_and:     ; not "and" because of conflicts with Forth word
004FB0r 3  04 04        		.byte 4, IM
004FB2r 3  rr rr                        .word nt_asm_and_h
004FB4r 3  rr rr rr rr  		.word xt_asm_and, z_asm_and
004FB8r 3  61 6E 64 2E  		.byte "and."
004FBCr 3               
004FBCr 3               nt_asm_and_h:
004FBCr 3  05 04        		.byte 5, IM
004FBEr 3  rr rr                        .word nt_asm_and_x
004FC0r 3  rr rr rr rr  		.word xt_asm_and_h, z_asm_and_h
004FC4r 3  61 6E 64 2E  		.byte "and.#"
004FC8r 3  23           
004FC9r 3               
004FC9r 3               nt_asm_and_x:
004FC9r 3  05 04        		.byte 5, IM
004FCBr 3  rr rr                        .word nt_asm_and_y
004FCDr 3  rr rr rr rr  		.word xt_asm_and_x, z_asm_and_x
004FD1r 3  61 6E 64 2E  		.byte "and.x"
004FD5r 3  78           
004FD6r 3               
004FD6r 3               nt_asm_and_y:
004FD6r 3  05 04        		.byte 5, IM
004FD8r 3  rr rr                        .word nt_asm_and_z
004FDAr 3  rr rr rr rr  		.word xt_asm_and_y, z_asm_and_y
004FDEr 3  61 6E 64 2E  		.byte "and.y"
004FE2r 3  79           
004FE3r 3               
004FE3r 3               nt_asm_and_z:
004FE3r 3  05 04        		.byte 5, IM
004FE5r 3  rr rr                        .word nt_asm_and_zi
004FE7r 3  rr rr rr rr  		.word xt_asm_and_z, z_asm_and_z
004FEBr 3  61 6E 64 2E  		.byte "and.z"
004FEFr 3  7A           
004FF0r 3               
004FF0r 3               nt_asm_and_zi:
004FF0r 3  06 04        		.byte 6, IM
004FF2r 3  rr rr                        .word nt_asm_and_ziy
004FF4r 3  rr rr rr rr  		.word xt_asm_and_zi, z_asm_and_zi
004FF8r 3  61 6E 64 2E  		.byte "and.zi"
004FFCr 3  7A 69        
004FFEr 3               
004FFEr 3               nt_asm_and_ziy:
004FFEr 3  07 04        		.byte 7, IM
005000r 3  rr rr                        .word nt_asm_and_zx
005002r 3  rr rr rr rr  		.word xt_asm_and_ziy, z_asm_and_ziy
005006r 3  61 6E 64 2E  		.byte "and.ziy"
00500Ar 3  7A 69 79     
00500Dr 3               
00500Dr 3               nt_asm_and_zx:
00500Dr 3  06 04        		.byte 6, IM
00500Fr 3  rr rr                        .word nt_asm_and_zxi
005011r 3  rr rr rr rr  		.word xt_asm_and_zx, z_asm_and_zx
005015r 3  61 6E 64 2E  		.byte "and.zx"
005019r 3  7A 78        
00501Br 3               
00501Br 3               nt_asm_and_zxi:
00501Br 3  07 04        		.byte 7, IM
00501Dr 3  rr rr                        .word nt_asm_asl
00501Fr 3  rr rr rr rr  		.word xt_asm_and_zxi, z_asm_and_zxi
005023r 3  61 6E 64 2E  		.byte "and.zxi"
005027r 3  7A 78 69     
00502Ar 3               
00502Ar 3               nt_asm_asl:
00502Ar 3  03 04        		.byte 3, IM
00502Cr 3  rr rr                        .word nt_asm_asl_a
00502Er 3  rr rr rr rr  		.word xt_asm_asl, z_asm_asl
005032r 3  61 73 6C     		.byte "asl"
005035r 3               
005035r 3               nt_asm_asl_a:
005035r 3  05 04        		.byte 5, IM
005037r 3  rr rr                        .word nt_asm_asl_x
005039r 3  rr rr rr rr  		.word xt_asm_asl_a, z_asm_asl_a
00503Dr 3  61 73 6C 2E  		.byte "asl.a"
005041r 3  61           
005042r 3               
005042r 3               nt_asm_asl_x:
005042r 3  05 04        		.byte 5, IM
005044r 3  rr rr                        .word nt_asm_asl_z
005046r 3  rr rr rr rr  		.word xt_asm_asl_x, z_asm_asl_x
00504Ar 3  61 73 6C 2E  		.byte "asl.x"
00504Er 3  78           
00504Fr 3               
00504Fr 3               nt_asm_asl_z:
00504Fr 3  05 04        		.byte 5, IM
005051r 3  rr rr                        .word nt_asm_asl_zx
005053r 3  rr rr rr rr  		.word xt_asm_asl_z, z_asm_asl_z
005057r 3  61 73 6C 2E  		.byte "asl.z"
00505Br 3  7A           
00505Cr 3               
00505Cr 3               nt_asm_asl_zx:
00505Cr 3  06 04        		.byte 6, IM
00505Er 3  rr rr                        .word nt_asm_bcc
005060r 3  rr rr rr rr  		.word xt_asm_asl_zx, z_asm_asl_zx
005064r 3  61 73 6C 2E  		.byte "asl.zx"
005068r 3  7A 78        
00506Ar 3               
00506Ar 3               nt_asm_bcc:
00506Ar 3  03 04        		.byte 3, IM
00506Cr 3  rr rr                        .word nt_asm_bcs
00506Er 3  rr rr rr rr  		.word xt_asm_bcc, z_asm_bcc
005072r 3  62 63 63     		.byte "bcc"
005075r 3               
005075r 3               nt_asm_bcs:
005075r 3  03 04        		.byte 3, IM
005077r 3  rr rr                        .word nt_asm_beq
005079r 3  rr rr rr rr  		.word xt_asm_bcs, z_asm_bcs
00507Dr 3  62 63 73     		.byte "bcs"
005080r 3               
005080r 3               nt_asm_beq:
005080r 3  03 04        		.byte 3, IM
005082r 3  rr rr                        .word nt_asm_bit
005084r 3  rr rr rr rr  		.word xt_asm_beq, z_asm_beq
005088r 3  62 65 71     		.byte "beq"
00508Br 3               
00508Br 3               nt_asm_bit:
00508Br 3  03 04        		.byte 3, IM
00508Dr 3  rr rr                        .word nt_asm_bit_h
00508Fr 3  rr rr rr rr  		.word xt_asm_bit, z_asm_bit
005093r 3  62 69 74     		.byte "bit"
005096r 3               
005096r 3               nt_asm_bit_h:
005096r 3  05 04        		.byte 5, IM
005098r 3  rr rr                        .word nt_asm_bit_x
00509Ar 3  rr rr rr rr  		.word xt_asm_bit_h, z_asm_bit_h
00509Er 3  62 69 74 2E  		.byte "bit.#"
0050A2r 3  23           
0050A3r 3               
0050A3r 3               nt_asm_bit_x:
0050A3r 3  05 04        		.byte 5, IM
0050A5r 3  rr rr                        .word nt_asm_bit_z
0050A7r 3  rr rr rr rr  		.word xt_asm_bit_x, z_asm_bit_x
0050ABr 3  62 69 74 2E  		.byte "bit.x"
0050AFr 3  78           
0050B0r 3               
0050B0r 3               nt_asm_bit_z:
0050B0r 3  05 04        		.byte 5, IM
0050B2r 3  rr rr                        .word nt_asm_bit_zx
0050B4r 3  rr rr rr rr  		.word xt_asm_bit_z, z_asm_bit_z
0050B8r 3  62 69 74 2E  		.byte "bit.z"
0050BCr 3  7A           
0050BDr 3               
0050BDr 3               nt_asm_bit_zx:
0050BDr 3  06 04        		.byte 6, IM
0050BFr 3  rr rr                        .word nt_asm_bmi
0050C1r 3  rr rr rr rr  		.word xt_asm_bit_zx, z_asm_bit_zx
0050C5r 3  62 69 74 2E  		.byte "bit.zx"
0050C9r 3  7A 78        
0050CBr 3               
0050CBr 3               nt_asm_bmi:
0050CBr 3  03 04        		.byte 3, IM
0050CDr 3  rr rr                        .word nt_asm_bne
0050CFr 3  rr rr rr rr  		.word xt_asm_bmi, z_asm_bmi
0050D3r 3  62 6D 69     		.byte "bmi"
0050D6r 3               
0050D6r 3               nt_asm_bne:
0050D6r 3  03 04        		.byte 3, IM
0050D8r 3  rr rr                        .word nt_asm_bpl
0050DAr 3  rr rr rr rr  		.word xt_asm_bne, z_asm_bne
0050DEr 3  62 6E 65     		.byte "bne"
0050E1r 3               
0050E1r 3               nt_asm_bpl:
0050E1r 3  03 04        		.byte 3, IM
0050E3r 3  rr rr                        .word nt_asm_bra
0050E5r 3  rr rr rr rr  		.word xt_asm_bpl, z_asm_bpl
0050E9r 3  62 70 6C     		.byte "bpl"
0050ECr 3               
0050ECr 3               nt_asm_bra:
0050ECr 3  03 04        		.byte 3, IM
0050EEr 3  rr rr                        .word nt_asm_brk
0050F0r 3  rr rr rr rr  		.word xt_asm_bra, z_asm_bra
0050F4r 3  62 72 61     		.byte "bra"
0050F7r 3               
0050F7r 3               nt_asm_brk:
0050F7r 3  03 04        		.byte 3, IM
0050F9r 3  rr rr                        .word nt_asm_bvc
0050FBr 3  rr rr rr rr  		.word xt_asm_brk, z_asm_brk
0050FFr 3  62 72 6B     		.byte "brk"
005102r 3               
005102r 3               nt_asm_bvc:
005102r 3  03 04        		.byte 3, IM
005104r 3  rr rr                        .word nt_asm_bvs
005106r 3  rr rr rr rr  		.word xt_asm_bvc, z_asm_bvc
00510Ar 3  62 76 63     		.byte "bvc"
00510Dr 3               
00510Dr 3               nt_asm_bvs:
00510Dr 3  03 04        		.byte 3, IM
00510Fr 3  rr rr                        .word nt_asm_clc
005111r 3  rr rr rr rr  		.word xt_asm_bvs, z_asm_bvs
005115r 3  62 76 73     		.byte "bvs"
005118r 3               
005118r 3               nt_asm_clc:
005118r 3  03 04        		.byte 3, IM
00511Ar 3  rr rr                        .word nt_asm_cld
00511Cr 3  rr rr rr rr  		.word xt_asm_clc, z_asm_clc
005120r 3  63 6C 63     		.byte "clc"
005123r 3               
005123r 3               nt_asm_cld:
005123r 3  03 04        		.byte 3, IM
005125r 3  rr rr                        .word nt_asm_cli
005127r 3  rr rr rr rr  		.word xt_asm_cld, z_asm_cld
00512Br 3  63 6C 64     		.byte "cld"
00512Er 3               
00512Er 3               nt_asm_cli:
00512Er 3  03 04        		.byte 3, IM
005130r 3  rr rr                        .word nt_asm_clv
005132r 3  rr rr rr rr  		.word xt_asm_cli, z_asm_cli
005136r 3  63 6C 69     		.byte "cli"
005139r 3               
005139r 3               nt_asm_clv:
005139r 3  03 04        		.byte 3, IM
00513Br 3  rr rr                        .word nt_asm_cmp
00513Dr 3  rr rr rr rr  		.word xt_asm_clv, z_asm_clv
005141r 3  63 6C 76     		.byte "clv"
005144r 3               
005144r 3               nt_asm_cmp:
005144r 3  03 04        		.byte 3, IM
005146r 3  rr rr                        .word nt_asm_cmp_h
005148r 3  rr rr rr rr  		.word xt_asm_cmp, z_asm_cmp
00514Cr 3  63 6D 70     		.byte "cmp"
00514Fr 3               
00514Fr 3               nt_asm_cmp_h:
00514Fr 3  05 04        		.byte 5, IM
005151r 3  rr rr                        .word nt_asm_cmp_x
005153r 3  rr rr rr rr  		.word xt_asm_cmp_h, z_asm_cmp_h
005157r 3  63 6D 70 2E  		.byte "cmp.#"
00515Br 3  23           
00515Cr 3               
00515Cr 3               nt_asm_cmp_x:
00515Cr 3  05 04        		.byte 5, IM
00515Er 3  rr rr                        .word nt_asm_cmp_y
005160r 3  rr rr rr rr  		.word xt_asm_cmp_x, z_asm_cmp_x
005164r 3  63 6D 70 2E  		.byte "cmp.x"
005168r 3  78           
005169r 3               
005169r 3               nt_asm_cmp_y:
005169r 3  05 04        		.byte 5, IM
00516Br 3  rr rr                        .word nt_asm_cmp_z
00516Dr 3  rr rr rr rr  		.word xt_asm_cmp_y, z_asm_cmp_y
005171r 3  63 6D 70 2E  		.byte "cmp.y"
005175r 3  79           
005176r 3               
005176r 3               nt_asm_cmp_z:
005176r 3  05 04        		.byte 5, IM
005178r 3  rr rr                        .word nt_asm_cmp_zi
00517Ar 3  rr rr rr rr  		.word xt_asm_cmp_z, z_asm_cmp_z
00517Er 3  63 6D 70 2E  		.byte "cmp.z"
005182r 3  7A           
005183r 3               
005183r 3               nt_asm_cmp_zi:
005183r 3  06 04        		.byte 6, IM
005185r 3  rr rr                        .word nt_asm_cmp_ziy
005187r 3  rr rr rr rr  		.word xt_asm_cmp_zi, z_asm_cmp_zi
00518Br 3  63 6D 70 2E  		.byte "cmp.zi"
00518Fr 3  7A 69        
005191r 3               
005191r 3               nt_asm_cmp_ziy:
005191r 3  07 04        		.byte 7, IM
005193r 3  rr rr                        .word nt_asm_cmp_zx
005195r 3  rr rr rr rr  		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
005199r 3  63 6D 70 2E  		.byte "cmp.ziy"
00519Dr 3  7A 69 79     
0051A0r 3               
0051A0r 3               nt_asm_cmp_zx:
0051A0r 3  06 04        		.byte 6, IM
0051A2r 3  rr rr                        .word nt_asm_cmp_zxi
0051A4r 3  rr rr rr rr  		.word xt_asm_cmp_zx, z_asm_cmp_zx
0051A8r 3  63 6D 70 2E  		.byte "cmp.zx"
0051ACr 3  7A 78        
0051AEr 3               
0051AEr 3               nt_asm_cmp_zxi:
0051AEr 3  07 04        		.byte 7, IM
0051B0r 3  rr rr                        .word nt_asm_cpx
0051B2r 3  rr rr rr rr  		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
0051B6r 3  63 6D 70 2E  		.byte "cmp.zxi"
0051BAr 3  7A 78 69     
0051BDr 3               
0051BDr 3               nt_asm_cpx:
0051BDr 3  03 04        		.byte 3, IM
0051BFr 3  rr rr                        .word nt_asm_cpx_h
0051C1r 3  rr rr rr rr  		.word xt_asm_cpx, z_asm_cpx
0051C5r 3  63 70 78     		.byte "cpx"
0051C8r 3               
0051C8r 3               nt_asm_cpx_h:
0051C8r 3  05 04        		.byte 5, IM
0051CAr 3  rr rr                        .word nt_asm_cpx_z
0051CCr 3  rr rr rr rr  		.word xt_asm_cpx_h, z_asm_cpx_h
0051D0r 3  63 70 78 2E  		.byte "cpx.#"
0051D4r 3  23           
0051D5r 3               
0051D5r 3               nt_asm_cpx_z:
0051D5r 3  05 04        		.byte 5, IM
0051D7r 3  rr rr                        .word nt_asm_cpy
0051D9r 3  rr rr rr rr  		.word xt_asm_cpx_z, z_asm_cpx_z
0051DDr 3  63 70 78 2E  		.byte "cpx.z"
0051E1r 3  7A           
0051E2r 3               
0051E2r 3               nt_asm_cpy:
0051E2r 3  03 04        		.byte 3, IM
0051E4r 3  rr rr                        .word nt_asm_cpy_h
0051E6r 3  rr rr rr rr  		.word xt_asm_cpy, z_asm_cpy
0051EAr 3  63 70 79     		.byte "cpy"
0051EDr 3               
0051EDr 3               nt_asm_cpy_h:
0051EDr 3  05 04        		.byte 5, IM
0051EFr 3  rr rr                        .word nt_asm_cpy_z
0051F1r 3  rr rr rr rr  		.word xt_asm_cpy_h, z_asm_cpy_h
0051F5r 3  63 70 79 2E  		.byte "cpy.#"
0051F9r 3  23           
0051FAr 3               
0051FAr 3               nt_asm_cpy_z:
0051FAr 3  05 04        		.byte 5, IM
0051FCr 3  rr rr                        .word nt_asm_dec
0051FEr 3  rr rr rr rr  		.word xt_asm_cpy_z, z_asm_cpy_z
005202r 3  63 70 79 2E  		.byte "cpy.z"
005206r 3  7A           
005207r 3               
005207r 3               nt_asm_dec:
005207r 3  03 04        		.byte 3, IM
005209r 3  rr rr                        .word nt_asm_dec_a
00520Br 3  rr rr rr rr  		.word xt_asm_dec, z_asm_dec
00520Fr 3  64 65 63     		.byte "dec"
005212r 3               
005212r 3               nt_asm_dec_a:
005212r 3  05 04        		.byte 5, IM
005214r 3  rr rr                        .word nt_asm_dec_x
005216r 3  rr rr rr rr  		.word xt_asm_dec_a, z_asm_dec_a
00521Ar 3  64 65 63 2E  		.byte "dec.a"
00521Er 3  61           
00521Fr 3               
00521Fr 3               nt_asm_dec_x:
00521Fr 3  05 04        		.byte 5, IM
005221r 3  rr rr                        .word nt_asm_dec_z
005223r 3  rr rr rr rr  		.word xt_asm_dec_x, z_asm_dec_x
005227r 3  64 65 63 2E  		.byte "dec.x"
00522Br 3  78           
00522Cr 3               
00522Cr 3               nt_asm_dec_z:
00522Cr 3  05 04        		.byte 5, IM
00522Er 3  rr rr                        .word nt_asm_dec_zx
005230r 3  rr rr rr rr  		.word xt_asm_dec_z, z_asm_dec_z
005234r 3  64 65 63 2E  		.byte "dec.z"
005238r 3  7A           
005239r 3               
005239r 3               nt_asm_dec_zx:
005239r 3  06 04        		.byte 6, IM
00523Br 3  rr rr                        .word nt_asm_dex
00523Dr 3  rr rr rr rr  		.word xt_asm_dec_zx, z_asm_dec_zx
005241r 3  64 65 63 2E  		.byte "dec.zx"
005245r 3  7A 78        
005247r 3               
005247r 3               nt_asm_dex:
005247r 3  03 04        		.byte 3, IM
005249r 3  rr rr                        .word nt_asm_dey
00524Br 3  rr rr rr rr  		.word xt_asm_dex, z_asm_dex
00524Fr 3  64 65 78     		.byte "dex"
005252r 3               
005252r 3               nt_asm_dey:
005252r 3  03 04        		.byte 3, IM
005254r 3  rr rr                        .word nt_asm_eor
005256r 3  rr rr rr rr  		.word xt_asm_dey, z_asm_dey
00525Ar 3  64 65 79     		.byte "dey"
00525Dr 3               
00525Dr 3               nt_asm_eor:
00525Dr 3  03 04        		.byte 3, IM
00525Fr 3  rr rr                        .word nt_asm_eor_h
005261r 3  rr rr rr rr  		.word xt_asm_eor, z_asm_eor
005265r 3  65 6F 72     		.byte "eor"
005268r 3               
005268r 3               nt_asm_eor_h:
005268r 3  05 04        		.byte 5, IM
00526Ar 3  rr rr                        .word nt_asm_eor_x
00526Cr 3  rr rr rr rr  		.word xt_asm_eor_h, z_asm_eor_h
005270r 3  65 6F 72 2E  		.byte "eor.#"
005274r 3  23           
005275r 3               
005275r 3               nt_asm_eor_x:
005275r 3  05 04        		.byte 5, IM
005277r 3  rr rr                        .word nt_asm_eor_y
005279r 3  rr rr rr rr  		.word xt_asm_eor_x, z_asm_eor_x
00527Dr 3  65 6F 72 2E  		.byte "eor.x"
005281r 3  78           
005282r 3               
005282r 3               nt_asm_eor_y:
005282r 3  05 04        		.byte 5, IM
005284r 3  rr rr                        .word nt_asm_eor_z
005286r 3  rr rr rr rr  		.word xt_asm_eor_y, z_asm_eor_y
00528Ar 3  65 6F 72 2E  		.byte "eor.y"
00528Er 3  79           
00528Fr 3               
00528Fr 3               nt_asm_eor_z:
00528Fr 3  05 04        		.byte 5, IM
005291r 3  rr rr                        .word nt_asm_eor_zi
005293r 3  rr rr rr rr  		.word xt_asm_eor_z, z_asm_eor_z
005297r 3  65 6F 72 2E  		.byte "eor.z"
00529Br 3  7A           
00529Cr 3               
00529Cr 3               nt_asm_eor_zi:
00529Cr 3  06 04        		.byte 6, IM
00529Er 3  rr rr                        .word nt_asm_eor_ziy
0052A0r 3  rr rr rr rr  		.word xt_asm_eor_zi, z_asm_eor_zi
0052A4r 3  65 6F 72 2E  		.byte "eor.zi"
0052A8r 3  7A 69        
0052AAr 3               
0052AAr 3               nt_asm_eor_ziy:
0052AAr 3  07 04        		.byte 7, IM
0052ACr 3  rr rr                        .word nt_asm_eor_zx
0052AEr 3  rr rr rr rr  		.word xt_asm_eor_ziy, z_asm_eor_ziy
0052B2r 3  65 6F 72 2E  		.byte "eor.ziy"
0052B6r 3  7A 69 79     
0052B9r 3               
0052B9r 3               nt_asm_eor_zx:
0052B9r 3  06 04        		.byte 6, IM
0052BBr 3  rr rr                        .word nt_asm_eor_zxi
0052BDr 3  rr rr rr rr  		.word xt_asm_eor_zx, z_asm_eor_zx
0052C1r 3  65 6F 72 2E  		.byte "eor.zx"
0052C5r 3  7A 78        
0052C7r 3               
0052C7r 3               nt_asm_eor_zxi:
0052C7r 3  07 04        		.byte 7, IM
0052C9r 3  rr rr                        .word nt_asm_inc
0052CBr 3  rr rr rr rr  		.word xt_asm_eor_zxi, z_asm_eor_zxi
0052CFr 3  65 6F 72 2E  		.byte "eor.zxi"
0052D3r 3  7A 78 69     
0052D6r 3               
0052D6r 3               nt_asm_inc:
0052D6r 3  03 04        		.byte 3, IM
0052D8r 3  rr rr                        .word nt_asm_inc_a
0052DAr 3  rr rr rr rr  		.word xt_asm_inc, z_asm_inc
0052DEr 3  69 6E 63     		.byte "inc"
0052E1r 3               
0052E1r 3               nt_asm_inc_a:
0052E1r 3  05 04        		.byte 5, IM
0052E3r 3  rr rr                        .word nt_asm_inc_x
0052E5r 3  rr rr rr rr  		.word xt_asm_inc_a, z_asm_inc_a
0052E9r 3  69 6E 63 2E  		.byte "inc.a"
0052EDr 3  61           
0052EEr 3               
0052EEr 3               nt_asm_inc_x:
0052EEr 3  05 04        		.byte 5, IM
0052F0r 3  rr rr                        .word nt_asm_inc_z
0052F2r 3  rr rr rr rr  		.word xt_asm_inc_x, z_asm_inc_x
0052F6r 3  69 6E 63 2E  		.byte "inc.x"
0052FAr 3  78           
0052FBr 3               
0052FBr 3               nt_asm_inc_z:
0052FBr 3  05 04        		.byte 5, IM
0052FDr 3  rr rr                        .word nt_asm_inc_zx
0052FFr 3  rr rr rr rr  		.word xt_asm_inc_z, z_asm_inc_z
005303r 3  69 6E 63 2E  		.byte "inc.z"
005307r 3  7A           
005308r 3               
005308r 3               nt_asm_inc_zx:
005308r 3  06 04        		.byte 6, IM
00530Ar 3  rr rr                        .word nt_asm_inx
00530Cr 3  rr rr rr rr  		.word xt_asm_inc_zx, z_asm_inc_zx
005310r 3  69 6E 63 2E  		.byte "inc.zx"
005314r 3  7A 78        
005316r 3               
005316r 3               nt_asm_inx:
005316r 3  03 04        		.byte 3, IM
005318r 3  rr rr                        .word nt_asm_iny
00531Ar 3  rr rr rr rr  		.word xt_asm_inx, z_asm_inx
00531Er 3  69 6E 78     		.byte "inx"
005321r 3               
005321r 3               nt_asm_iny:
005321r 3  03 04        		.byte 3, IM
005323r 3  rr rr                        .word nt_asm_jmp
005325r 3  rr rr rr rr  		.word xt_asm_iny, z_asm_iny
005329r 3  69 6E 79     		.byte "iny"
00532Cr 3               
00532Cr 3               nt_asm_jmp:
00532Cr 3  03 04        		.byte 3, IM
00532Er 3  rr rr                        .word nt_asm_jmp_i
005330r 3  rr rr rr rr  		.word xt_asm_jmp, z_asm_jmp
005334r 3  6A 6D 70     		.byte "jmp"
005337r 3               
005337r 3               nt_asm_jmp_i:
005337r 3  05 04        		.byte 5, IM
005339r 3  rr rr                        .word nt_asm_jmp_xi
00533Br 3  rr rr rr rr  		.word xt_asm_jmp_i, z_asm_jmp_i
00533Fr 3  6A 6D 70 2E  		.byte "jmp.i"
005343r 3  69           
005344r 3               
005344r 3               nt_asm_jmp_xi:
005344r 3  06 04        		.byte 6, IM
005346r 3  rr rr                        .word nt_asm_jsr
005348r 3  rr rr rr rr  		.word xt_asm_jmp_xi, z_asm_jmp_xi
00534Cr 3  6A 6D 70 2E  		.byte "jmp.xi"
005350r 3  78 69        
005352r 3               
005352r 3               nt_asm_jsr:
005352r 3  03 04        		.byte 3, IM
005354r 3  rr rr                        .word nt_asm_lda
005356r 3  rr rr rr rr  		.word xt_asm_jsr, z_asm_jsr
00535Ar 3  6A 73 72     		.byte "jsr"
00535Dr 3               
00535Dr 3               nt_asm_lda:
00535Dr 3  03 04        		.byte 3, IM
00535Fr 3  rr rr                        .word nt_asm_lda_h
005361r 3  rr rr rr rr  		.word xt_asm_lda, z_asm_lda
005365r 3  6C 64 61     		.byte "lda"
005368r 3               
005368r 3               nt_asm_lda_h:
005368r 3  05 04        		.byte 5, IM
00536Ar 3  rr rr                        .word nt_asm_lda_x
00536Cr 3  rr rr rr rr  		.word xt_asm_lda_h, z_asm_lda_h
005370r 3  6C 64 61 2E  		.byte "lda.#"
005374r 3  23           
005375r 3               
005375r 3               nt_asm_lda_x:
005375r 3  05 04        		.byte 5, IM
005377r 3  rr rr                        .word nt_asm_lda_y
005379r 3  rr rr rr rr  		.word xt_asm_lda_x, z_asm_lda_x
00537Dr 3  6C 64 61 2E  		.byte "lda.x"
005381r 3  78           
005382r 3               
005382r 3               nt_asm_lda_y:
005382r 3  05 04        		.byte 5, IM
005384r 3  rr rr                        .word nt_asm_lda_z
005386r 3  rr rr rr rr  		.word xt_asm_lda_y, z_asm_lda_y
00538Ar 3  6C 64 61 2E  		.byte "lda.y"
00538Er 3  79           
00538Fr 3               
00538Fr 3               nt_asm_lda_z:
00538Fr 3  05 04        		.byte 5, IM
005391r 3  rr rr                        .word nt_asm_lda_zi
005393r 3  rr rr rr rr  		.word xt_asm_lda_z, z_asm_lda_z
005397r 3  6C 64 61 2E  		.byte "lda.z"
00539Br 3  7A           
00539Cr 3               
00539Cr 3               nt_asm_lda_zi:
00539Cr 3  06 04        		.byte 6, IM
00539Er 3  rr rr                        .word nt_asm_lda_ziy
0053A0r 3  rr rr rr rr  		.word xt_asm_lda_zi, z_asm_lda_zi
0053A4r 3  6C 64 61 2E  		.byte "lda.zi"
0053A8r 3  7A 69        
0053AAr 3               
0053AAr 3               nt_asm_lda_ziy:
0053AAr 3  07 04        		.byte 7, IM
0053ACr 3  rr rr                        .word nt_asm_lda_zx
0053AEr 3  rr rr rr rr  		.word xt_asm_lda_ziy, z_asm_lda_ziy
0053B2r 3  6C 64 61 2E  		.byte "lda.ziy"
0053B6r 3  7A 69 79     
0053B9r 3               
0053B9r 3               nt_asm_lda_zx:
0053B9r 3  06 04        		.byte 6, IM
0053BBr 3  rr rr                        .word nt_asm_lda_zxi
0053BDr 3  rr rr rr rr  		.word xt_asm_lda_zx, z_asm_lda_zx
0053C1r 3  6C 64 61 2E  		.byte "lda.zx"
0053C5r 3  7A 78        
0053C7r 3               
0053C7r 3               nt_asm_lda_zxi:
0053C7r 3  07 04        		.byte 7, IM
0053C9r 3  rr rr                        .word nt_asm_ldx
0053CBr 3  rr rr rr rr  		.word xt_asm_lda_zxi, z_asm_lda_zxi
0053CFr 3  6C 64 61 2E  		.byte "lda.zxi"
0053D3r 3  7A 78 69     
0053D6r 3               
0053D6r 3               nt_asm_ldx:
0053D6r 3  03 04        		.byte 3, IM
0053D8r 3  rr rr                        .word nt_asm_ldx_h
0053DAr 3  rr rr rr rr  		.word xt_asm_ldx, z_asm_ldx
0053DEr 3  6C 64 78     		.byte "ldx"
0053E1r 3               
0053E1r 3               nt_asm_ldx_h:
0053E1r 3  05 04        		.byte 5, IM
0053E3r 3  rr rr                        .word nt_asm_ldx_y
0053E5r 3  rr rr rr rr  		.word xt_asm_ldx_h, z_asm_ldx_h
0053E9r 3  6C 64 78 2E  		.byte "ldx.#"
0053EDr 3  23           
0053EEr 3               
0053EEr 3               nt_asm_ldx_y:
0053EEr 3  05 04        		.byte 5, IM
0053F0r 3  rr rr                        .word nt_asm_ldx_z
0053F2r 3  rr rr rr rr  		.word xt_asm_ldx_y, z_asm_ldx_y
0053F6r 3  6C 64 78 2E  		.byte "ldx.y"
0053FAr 3  79           
0053FBr 3               
0053FBr 3               nt_asm_ldx_z:
0053FBr 3  05 04        		.byte 5, IM
0053FDr 3  rr rr                        .word nt_asm_ldx_zy
0053FFr 3  rr rr rr rr  		.word xt_asm_ldx_z, z_asm_ldx_z
005403r 3  6C 64 78 2E  		.byte "ldx.z"
005407r 3  7A           
005408r 3               
005408r 3               nt_asm_ldx_zy:
005408r 3  06 04        		.byte 6, IM
00540Ar 3  rr rr                        .word nt_asm_ldy
00540Cr 3  rr rr rr rr  		.word xt_asm_ldx_zy, z_asm_ldx_zy
005410r 3  6C 64 78 2E  		.byte "ldx.zy"
005414r 3  7A 79        
005416r 3               
005416r 3               nt_asm_ldy:
005416r 3  03 04        		.byte 3, IM
005418r 3  rr rr                        .word nt_asm_ldy_h
00541Ar 3  rr rr rr rr  		.word xt_asm_ldy, z_asm_ldy
00541Er 3  6C 64 79     		.byte "ldy"
005421r 3               
005421r 3               nt_asm_ldy_h:
005421r 3  05 04        		.byte 5, IM
005423r 3  rr rr                        .word nt_asm_ldy_x
005425r 3  rr rr rr rr  		.word xt_asm_ldy_h, z_asm_ldy_h
005429r 3  6C 64 79 2E  		.byte "ldy.#"
00542Dr 3  23           
00542Er 3               
00542Er 3               nt_asm_ldy_x:
00542Er 3  05 04        		.byte 5, IM
005430r 3  rr rr                        .word nt_asm_ldy_z
005432r 3  rr rr rr rr  		.word xt_asm_ldy_x, z_asm_ldy_x
005436r 3  6C 64 79 2E  		.byte "ldy.x"
00543Ar 3  78           
00543Br 3               
00543Br 3               nt_asm_ldy_z:
00543Br 3  05 04        		.byte 5, IM
00543Dr 3  rr rr                        .word nt_asm_ldy_zx
00543Fr 3  rr rr rr rr  		.word xt_asm_ldy_z, z_asm_ldy_z
005443r 3  6C 64 79 2E  		.byte "ldy.z"
005447r 3  7A           
005448r 3               
005448r 3               nt_asm_ldy_zx:
005448r 3  06 04        		.byte 6, IM
00544Ar 3  rr rr                        .word nt_asm_lsr
00544Cr 3  rr rr rr rr  		.word xt_asm_ldy_zx, z_asm_ldy_zx
005450r 3  6C 64 79 2E  		.byte "ldy.zx"
005454r 3  7A 78        
005456r 3               
005456r 3               nt_asm_lsr:
005456r 3  03 04        		.byte 3, IM
005458r 3  rr rr                        .word nt_asm_lsr_a
00545Ar 3  rr rr rr rr  		.word xt_asm_lsr, z_asm_lsr
00545Er 3  6C 73 72     		.byte "lsr"
005461r 3               
005461r 3               nt_asm_lsr_a:
005461r 3  05 04        		.byte 5, IM
005463r 3  rr rr                        .word nt_asm_lsr_x
005465r 3  rr rr rr rr  		.word xt_asm_lsr_a, z_asm_lsr_a
005469r 3  6C 73 72 2E  		.byte "lsr.a"
00546Dr 3  61           
00546Er 3               
00546Er 3               nt_asm_lsr_x:
00546Er 3  05 04        		.byte 5, IM
005470r 3  rr rr                        .word nt_asm_lsr_z
005472r 3  rr rr rr rr  		.word xt_asm_lsr_x, z_asm_lsr_x
005476r 3  6C 73 72 2E  		.byte "lsr.x"
00547Ar 3  78           
00547Br 3               
00547Br 3               nt_asm_lsr_z:
00547Br 3  05 04        		.byte 5, IM
00547Dr 3  rr rr                        .word nt_asm_lsr_zx
00547Fr 3  rr rr rr rr  		.word xt_asm_lsr_z, z_asm_lsr_z
005483r 3  6C 73 72 2E  		.byte "lsr.z"
005487r 3  7A           
005488r 3               
005488r 3               nt_asm_lsr_zx:
005488r 3  06 04        		.byte 6, IM
00548Ar 3  rr rr                        .word nt_asm_nop
00548Cr 3  rr rr rr rr  		.word xt_asm_lsr_zx, z_asm_lsr_zx
005490r 3  6C 73 72 2E  		.byte "lsr.zx"
005494r 3  7A 78        
005496r 3               
005496r 3               nt_asm_nop:
005496r 3  03 04        		.byte 3, IM
005498r 3  rr rr                        .word nt_asm_ora
00549Ar 3  rr rr rr rr  		.word xt_asm_nop, z_asm_nop
00549Er 3  6E 6F 70     		.byte "nop"
0054A1r 3               
0054A1r 3               nt_asm_ora:
0054A1r 3  03 04        		.byte 3, IM
0054A3r 3  rr rr                        .word nt_asm_ora_h
0054A5r 3  rr rr rr rr  		.word xt_asm_ora, z_asm_ora
0054A9r 3  6F 72 61     		.byte "ora"
0054ACr 3               
0054ACr 3               nt_asm_ora_h:
0054ACr 3  05 04        		.byte 5, IM
0054AEr 3  rr rr                        .word nt_asm_ora_x
0054B0r 3  rr rr rr rr  		.word xt_asm_ora_h, z_asm_ora_h
0054B4r 3  6F 72 61 2E  		.byte "ora.#"
0054B8r 3  23           
0054B9r 3               
0054B9r 3               nt_asm_ora_x:
0054B9r 3  05 04        		.byte 5, IM
0054BBr 3  rr rr                        .word nt_asm_ora_y
0054BDr 3  rr rr rr rr  		.word xt_asm_ora_x, z_asm_ora_x
0054C1r 3  6F 72 61 2E  		.byte "ora.x"
0054C5r 3  78           
0054C6r 3               
0054C6r 3               nt_asm_ora_y:
0054C6r 3  05 04        		.byte 5, IM
0054C8r 3  rr rr                        .word nt_asm_ora_z
0054CAr 3  rr rr rr rr  		.word xt_asm_ora_y, z_asm_ora_y
0054CEr 3  6F 72 61 2E  		.byte "ora.y"
0054D2r 3  79           
0054D3r 3               
0054D3r 3               nt_asm_ora_z:
0054D3r 3  05 04        		.byte 5, IM
0054D5r 3  rr rr                        .word nt_asm_ora_zi
0054D7r 3  rr rr rr rr  		.word xt_asm_ora_z, z_asm_ora_z
0054DBr 3  6F 72 61 2E  		.byte "ora.z"
0054DFr 3  7A           
0054E0r 3               
0054E0r 3               nt_asm_ora_zi:
0054E0r 3  06 04        		.byte 6, IM
0054E2r 3  rr rr                        .word nt_asm_ora_ziy
0054E4r 3  rr rr rr rr  		.word xt_asm_ora_zi, z_asm_ora_zi
0054E8r 3  6F 72 61 2E  		.byte "ora.zi"
0054ECr 3  7A 69        
0054EEr 3               
0054EEr 3               nt_asm_ora_ziy:
0054EEr 3  07 04        		.byte 7, IM
0054F0r 3  rr rr                        .word nt_asm_ora_zx
0054F2r 3  rr rr rr rr  		.word xt_asm_ora_ziy, z_asm_ora_ziy
0054F6r 3  6F 72 61 2E  		.byte "ora.ziy"
0054FAr 3  7A 69 79     
0054FDr 3               
0054FDr 3               nt_asm_ora_zx:
0054FDr 3  06 04        		.byte 6, IM
0054FFr 3  rr rr                        .word nt_asm_ora_zxi
005501r 3  rr rr rr rr  		.word xt_asm_ora_zx, z_asm_ora_zx
005505r 3  6F 72 61 2E  		.byte "ora.zx"
005509r 3  7A 78        
00550Br 3               
00550Br 3               nt_asm_ora_zxi:
00550Br 3  07 04        		.byte 7, IM
00550Dr 3  rr rr                        .word nt_asm_pha
00550Fr 3  rr rr rr rr  		.word xt_asm_ora_zxi, z_asm_ora_zxi
005513r 3  6F 72 61 2E  		.byte "ora.zxi"
005517r 3  7A 78 69     
00551Ar 3               
00551Ar 3               nt_asm_pha:
00551Ar 3  03 04        		.byte 3, IM
00551Cr 3  rr rr                        .word nt_asm_php
00551Er 3  rr rr rr rr  		.word xt_asm_pha, z_asm_pha
005522r 3  70 68 61     		.byte "pha"
005525r 3               
005525r 3               nt_asm_php:
005525r 3  03 04        		.byte 3, IM
005527r 3  rr rr                        .word nt_asm_phx
005529r 3  rr rr rr rr  		.word xt_asm_php, z_asm_php
00552Dr 3  70 68 70     		.byte "php"
005530r 3               
005530r 3               nt_asm_phx:
005530r 3  03 04        		.byte 3, IM
005532r 3  rr rr                        .word nt_asm_phy
005534r 3  rr rr rr rr  		.word xt_asm_phx, z_asm_phx
005538r 3  70 68 78     		.byte "phx"
00553Br 3               
00553Br 3               nt_asm_phy:
00553Br 3  03 04        		.byte 3, IM
00553Dr 3  rr rr                        .word nt_asm_pla
00553Fr 3  rr rr rr rr  		.word xt_asm_phy, z_asm_phy
005543r 3  70 68 79     		.byte "phy"
005546r 3               
005546r 3               nt_asm_pla:
005546r 3  03 04        		.byte 3, IM
005548r 3  rr rr                        .word nt_asm_plp
00554Ar 3  rr rr rr rr  		.word xt_asm_pla, z_asm_pla
00554Er 3  70 6C 61     		.byte "pla"
005551r 3               
005551r 3               nt_asm_plp:
005551r 3  03 04        		.byte 3, IM
005553r 3  rr rr                        .word nt_asm_plx
005555r 3  rr rr rr rr  		.word xt_asm_plp, z_asm_plp
005559r 3  70 6C 70     		.byte "plp"
00555Cr 3               
00555Cr 3               nt_asm_plx:
00555Cr 3  03 04        		.byte 3, IM
00555Er 3  rr rr                        .word nt_asm_ply
005560r 3  rr rr rr rr  		.word xt_asm_plx, z_asm_plx
005564r 3  70 6C 78     		.byte "plx"
005567r 3               
005567r 3               nt_asm_ply:
005567r 3  03 04        		.byte 3, IM
005569r 3  rr rr                        .word nt_asm_rol
00556Br 3  rr rr rr rr  		.word xt_asm_ply, z_asm_ply
00556Fr 3  70 6C 79     		.byte "ply"
005572r 3               
005572r 3               nt_asm_rol:
005572r 3  03 04        		.byte 3, IM
005574r 3  rr rr                        .word nt_asm_rol_a
005576r 3  rr rr rr rr  		.word xt_asm_rol, z_asm_rol
00557Ar 3  72 6F 6C     		.byte "rol"
00557Dr 3               
00557Dr 3               nt_asm_rol_a:
00557Dr 3  05 04        		.byte 5, IM
00557Fr 3  rr rr                        .word nt_asm_rol_x
005581r 3  rr rr rr rr  		.word xt_asm_rol_a, z_asm_rol_a
005585r 3  72 6F 6C 2E  		.byte "rol.a"
005589r 3  61           
00558Ar 3               
00558Ar 3               nt_asm_rol_x:
00558Ar 3  05 04        		.byte 5, IM
00558Cr 3  rr rr                        .word nt_asm_rol_z
00558Er 3  rr rr rr rr  		.word xt_asm_rol_x, z_asm_rol_x
005592r 3  72 6F 6C 2E  		.byte "rol.x"
005596r 3  78           
005597r 3               
005597r 3               nt_asm_rol_z:
005597r 3  05 04        		.byte 5, IM
005599r 3  rr rr                        .word nt_asm_rol_zx
00559Br 3  rr rr rr rr  		.word xt_asm_rol_z, z_asm_rol_z
00559Fr 3  72 6F 6C 2E  		.byte "rol.z"
0055A3r 3  7A           
0055A4r 3               
0055A4r 3               nt_asm_rol_zx:
0055A4r 3  06 04        		.byte 6, IM
0055A6r 3  rr rr                        .word nt_asm_ror
0055A8r 3  rr rr rr rr  		.word xt_asm_rol_zx, z_asm_rol_zx
0055ACr 3  72 6F 6C 2E  		.byte "rol.zx"
0055B0r 3  7A 78        
0055B2r 3               
0055B2r 3               nt_asm_ror:
0055B2r 3  03 04        		.byte 3, IM
0055B4r 3  rr rr                        .word nt_asm_ror_a
0055B6r 3  rr rr rr rr  		.word xt_asm_ror, z_asm_ror
0055BAr 3  72 6F 72     		.byte "ror"
0055BDr 3               
0055BDr 3               nt_asm_ror_a:
0055BDr 3  05 04        		.byte 5, IM
0055BFr 3  rr rr                        .word nt_asm_ror_x
0055C1r 3  rr rr rr rr  		.word xt_asm_ror_a, z_asm_ror_a
0055C5r 3  72 6F 72 2E  		.byte "ror.a"
0055C9r 3  61           
0055CAr 3               
0055CAr 3               nt_asm_ror_x:
0055CAr 3  05 04        		.byte 5, IM
0055CCr 3  rr rr                        .word nt_asm_ror_z
0055CEr 3  rr rr rr rr  		.word xt_asm_ror_x, z_asm_ror_x
0055D2r 3  72 6F 72 2E  		.byte "ror.x"
0055D6r 3  78           
0055D7r 3               
0055D7r 3               nt_asm_ror_z:
0055D7r 3  05 04        		.byte 5, IM
0055D9r 3  rr rr                        .word nt_asm_ror_zx
0055DBr 3  rr rr rr rr  		.word xt_asm_ror_z, z_asm_ror_z
0055DFr 3  72 6F 72 2E  		.byte "ror.z"
0055E3r 3  7A           
0055E4r 3               
0055E4r 3               nt_asm_ror_zx:
0055E4r 3  06 04        		.byte 6, IM
0055E6r 3  rr rr                        .word nt_asm_rti
0055E8r 3  rr rr rr rr  		.word xt_asm_ror_zx, z_asm_ror_zx
0055ECr 3  72 6F 72 2E  		.byte "ror.zx"
0055F0r 3  7A 78        
0055F2r 3               
0055F2r 3               nt_asm_rti:
0055F2r 3  03 04        		.byte 3, IM
0055F4r 3  rr rr                        .word nt_asm_rts
0055F6r 3  rr rr rr rr  		.word xt_asm_rti, z_asm_rti
0055FAr 3  72 74 69     		.byte "rti"
0055FDr 3               
0055FDr 3               nt_asm_rts:
0055FDr 3  03 04        		.byte 3, IM
0055FFr 3  rr rr                        .word nt_asm_sbc
005601r 3  rr rr rr rr  		.word xt_asm_rts, z_asm_rts
005605r 3  72 74 73     		.byte "rts"
005608r 3               
005608r 3               nt_asm_sbc:
005608r 3  03 04        		.byte 3, IM
00560Ar 3  rr rr                        .word nt_asm_sbc_h
00560Cr 3  rr rr rr rr  		.word xt_asm_sbc, z_asm_sbc
005610r 3  73 62 63     		.byte "sbc"
005613r 3               
005613r 3               nt_asm_sbc_h:
005613r 3  05 04        		.byte 5, IM
005615r 3  rr rr                        .word nt_asm_sbc_x
005617r 3  rr rr rr rr  		.word xt_asm_sbc_h, z_asm_sbc_h
00561Br 3  73 62 63 2E  		.byte "sbc.#"
00561Fr 3  23           
005620r 3               
005620r 3               nt_asm_sbc_x:
005620r 3  05 04        		.byte 5, IM
005622r 3  rr rr                        .word nt_asm_sbc_y
005624r 3  rr rr rr rr  		.word xt_asm_sbc_x, z_asm_sbc_x
005628r 3  73 62 63 2E  		.byte "sbc.x"
00562Cr 3  78           
00562Dr 3               
00562Dr 3               nt_asm_sbc_y:
00562Dr 3  05 04        		.byte 5, IM
00562Fr 3  rr rr                        .word nt_asm_sbc_z
005631r 3  rr rr rr rr  		.word xt_asm_sbc_y, z_asm_sbc_y
005635r 3  73 62 63 2E  		.byte "sbc.y"
005639r 3  79           
00563Ar 3               
00563Ar 3               nt_asm_sbc_z:
00563Ar 3  05 04        		.byte 5, IM
00563Cr 3  rr rr                        .word nt_asm_sbc_zi
00563Er 3  rr rr rr rr  		.word xt_asm_sbc_z, z_asm_sbc_z
005642r 3  73 62 63 2E  		.byte "sbc.z"
005646r 3  7A           
005647r 3               
005647r 3               nt_asm_sbc_zi:
005647r 3  06 04        		.byte 6, IM
005649r 3  rr rr                        .word nt_asm_sbc_ziy
00564Br 3  rr rr rr rr  		.word xt_asm_sbc_zi, z_asm_sbc_zi
00564Fr 3  73 62 63 2E  		.byte "sbc.zi"
005653r 3  7A 69        
005655r 3               
005655r 3               nt_asm_sbc_ziy:
005655r 3  07 04        		.byte 7, IM
005657r 3  rr rr                        .word nt_asm_sbc_zx
005659r 3  rr rr rr rr  		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
00565Dr 3  73 62 63 2E  		.byte "sbc.ziy"
005661r 3  7A 69 79     
005664r 3               
005664r 3               nt_asm_sbc_zx:
005664r 3  06 04        		.byte 6, IM
005666r 3  rr rr                        .word nt_asm_sbc_zxi
005668r 3  rr rr rr rr  		.word xt_asm_sbc_zx, z_asm_sbc_zx
00566Cr 3  73 62 63 2E  		.byte "sbc.zx"
005670r 3  7A 78        
005672r 3               
005672r 3               nt_asm_sbc_zxi:
005672r 3  07 04        		.byte 7, IM
005674r 3  rr rr                        .word nt_asm_sec
005676r 3  rr rr rr rr  		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
00567Ar 3  73 62 63 2E  		.byte "sbc.zxi"
00567Er 3  7A 78 69     
005681r 3               
005681r 3               nt_asm_sec:
005681r 3  03 04        		.byte 3, IM
005683r 3  rr rr                        .word nt_asm_sed
005685r 3  rr rr rr rr  		.word xt_asm_sec, z_asm_sec
005689r 3  73 65 63     		.byte "sec"
00568Cr 3               
00568Cr 3               nt_asm_sed:
00568Cr 3  03 04        		.byte 3, IM
00568Er 3  rr rr                        .word nt_asm_sei
005690r 3  rr rr rr rr  		.word xt_asm_sed, z_asm_sed
005694r 3  73 65 64     		.byte "sed"
005697r 3               
005697r 3               nt_asm_sei:
005697r 3  03 04        		.byte 3, IM
005699r 3  rr rr                        .word nt_asm_sta
00569Br 3  rr rr rr rr  		.word xt_asm_sei, z_asm_sei
00569Fr 3  73 65 69     		.byte "sei"
0056A2r 3               
0056A2r 3               nt_asm_sta:
0056A2r 3  03 04        		.byte 3, IM
0056A4r 3  rr rr                        .word nt_asm_sta_x
0056A6r 3  rr rr rr rr  		.word xt_asm_sta, z_asm_sta
0056AAr 3  73 74 61     		.byte "sta"
0056ADr 3               
0056ADr 3               nt_asm_sta_x:
0056ADr 3  05 04        		.byte 5, IM
0056AFr 3  rr rr                        .word nt_asm_sta_y
0056B1r 3  rr rr rr rr  		.word xt_asm_sta_x, z_asm_sta_x
0056B5r 3  73 74 61 2E  		.byte "sta.x"
0056B9r 3  78           
0056BAr 3               
0056BAr 3               nt_asm_sta_y:
0056BAr 3  05 04        		.byte 5, IM
0056BCr 3  rr rr                        .word nt_asm_sta_z
0056BEr 3  rr rr rr rr  		.word xt_asm_sta_y, z_asm_sta_y
0056C2r 3  73 74 61 2E  		.byte "sta.y"
0056C6r 3  79           
0056C7r 3               
0056C7r 3               nt_asm_sta_z:
0056C7r 3  05 04        		.byte 5, IM
0056C9r 3  rr rr                        .word nt_asm_sta_zi
0056CBr 3  rr rr rr rr  		.word xt_asm_sta_z, z_asm_sta_z
0056CFr 3  73 74 61 2E  		.byte "sta.z"
0056D3r 3  7A           
0056D4r 3               
0056D4r 3               nt_asm_sta_zi:
0056D4r 3  06 04        		.byte 6, IM
0056D6r 3  rr rr                        .word nt_asm_sta_ziy
0056D8r 3  rr rr rr rr  		.word xt_asm_sta_zi, z_asm_sta_zi
0056DCr 3  73 74 61 2E  		.byte "sta.zi"
0056E0r 3  7A 69        
0056E2r 3               
0056E2r 3               nt_asm_sta_ziy:
0056E2r 3  07 04        		.byte 7, IM
0056E4r 3  rr rr                        .word nt_asm_sta_zx
0056E6r 3  rr rr rr rr  		.word xt_asm_sta_ziy, z_asm_sta_ziy
0056EAr 3  73 74 61 2E  		.byte "sta.ziy"
0056EEr 3  7A 69 79     
0056F1r 3               
0056F1r 3               nt_asm_sta_zx:
0056F1r 3  06 04        		.byte 6, IM
0056F3r 3  rr rr                        .word nt_asm_sta_zxi
0056F5r 3  rr rr rr rr  		.word xt_asm_sta_zx, z_asm_sta_zx
0056F9r 3  73 74 61 2E  		.byte "sta.zx"
0056FDr 3  7A 78        
0056FFr 3               
0056FFr 3               nt_asm_sta_zxi:
0056FFr 3  07 04        		.byte 7, IM
005701r 3  rr rr                        .word nt_asm_stx
005703r 3  rr rr rr rr  		.word xt_asm_sta_zxi, z_asm_sta_zxi
005707r 3  73 74 61 2E  		.byte "sta.zxi"
00570Br 3  7A 78 69     
00570Er 3               
00570Er 3               nt_asm_stx:
00570Er 3  03 04        		.byte 3, IM
005710r 3  rr rr                        .word nt_asm_stx_z
005712r 3  rr rr rr rr  		.word xt_asm_stx, z_asm_stx
005716r 3  73 74 78     		.byte "stx"
005719r 3               
005719r 3               nt_asm_stx_z:
005719r 3  05 04        		.byte 5, IM
00571Br 3  rr rr                        .word nt_asm_stx_zy
00571Dr 3  rr rr rr rr  		.word xt_asm_stx_z, z_asm_stx_z
005721r 3  73 74 78 2E  		.byte "stx.z"
005725r 3  7A           
005726r 3               
005726r 3               nt_asm_stx_zy:
005726r 3  06 04        		.byte 6, IM
005728r 3  rr rr                        .word nt_asm_sty
00572Ar 3  rr rr rr rr  		.word xt_asm_stx_zy, z_asm_stx_zy
00572Er 3  73 74 78 2E  		.byte "stx.zy"
005732r 3  7A 79        
005734r 3               
005734r 3               nt_asm_sty:
005734r 3  03 04        		.byte 3, IM
005736r 3  rr rr                        .word nt_asm_sty_z
005738r 3  rr rr rr rr  		.word xt_asm_sty, z_asm_sty
00573Cr 3  73 74 79     		.byte "sty"
00573Fr 3               
00573Fr 3               nt_asm_sty_z:
00573Fr 3  05 04        		.byte 5, IM
005741r 3  rr rr                        .word nt_asm_sty_zx
005743r 3  rr rr rr rr  		.word xt_asm_sty_z, z_asm_sty_z
005747r 3  73 74 79 2E  		.byte "sty.z"
00574Br 3  7A           
00574Cr 3               
00574Cr 3               nt_asm_sty_zx:
00574Cr 3  06 04        		.byte 6, IM
00574Er 3  rr rr                        .word nt_asm_stz
005750r 3  rr rr rr rr  		.word xt_asm_sty_zx, z_asm_sty_zx
005754r 3  73 74 79 2E  		.byte "sty.zx"
005758r 3  7A 78        
00575Ar 3               
00575Ar 3               nt_asm_stz:
00575Ar 3  03 04        		.byte 3, IM
00575Cr 3  rr rr                        .word nt_asm_stz_x
00575Er 3  rr rr rr rr  		.word xt_asm_stz, z_asm_stz
005762r 3  73 74 7A     		.byte "stz"
005765r 3               
005765r 3               nt_asm_stz_x:
005765r 3  05 04        		.byte 5, IM
005767r 3  rr rr                        .word nt_asm_stz_z
005769r 3  rr rr rr rr  		.word xt_asm_stz_x, z_asm_stz_x
00576Dr 3  73 74 7A 2E  		.byte "stz.x"
005771r 3  78           
005772r 3               
005772r 3               nt_asm_stz_z:
005772r 3  05 04        		.byte 5, IM
005774r 3  rr rr                        .word nt_asm_stz_zx
005776r 3  rr rr rr rr  		.word xt_asm_stz_z, z_asm_stz_z
00577Ar 3  73 74 7A 2E  		.byte "stz.z"
00577Er 3  7A           
00577Fr 3               
00577Fr 3               nt_asm_stz_zx:
00577Fr 3  06 04        		.byte 6, IM
005781r 3  rr rr                        .word nt_asm_tax
005783r 3  rr rr rr rr  		.word xt_asm_stz_zx, z_asm_stz_zx
005787r 3  73 74 7A 2E  		.byte "stz.zx"
00578Br 3  7A 78        
00578Dr 3               
00578Dr 3               nt_asm_tax:
00578Dr 3  03 04        		.byte 3, IM
00578Fr 3  rr rr                        .word nt_asm_tay
005791r 3  rr rr rr rr  		.word xt_asm_tax, z_asm_tax
005795r 3  74 61 78     		.byte "tax"
005798r 3               
005798r 3               nt_asm_tay:
005798r 3  03 04        		.byte 3, IM
00579Ar 3  rr rr                        .word nt_asm_trb
00579Cr 3  rr rr rr rr  		.word xt_asm_tay, z_asm_tay
0057A0r 3  74 61 79     		.byte "tay"
0057A3r 3               
0057A3r 3               nt_asm_trb:
0057A3r 3  03 04        		.byte 3, IM
0057A5r 3  rr rr                        .word nt_asm_trb_z
0057A7r 3  rr rr rr rr  		.word xt_asm_trb, z_asm_trb
0057ABr 3  74 72 62     		.byte "trb"
0057AEr 3               
0057AEr 3               nt_asm_trb_z:
0057AEr 3  05 04        		.byte 5, IM
0057B0r 3  rr rr                        .word nt_asm_tsb
0057B2r 3  rr rr rr rr  		.word xt_asm_trb_z, z_asm_trb_z
0057B6r 3  74 72 62 2E  		.byte "trb.z"
0057BAr 3  7A           
0057BBr 3               
0057BBr 3               nt_asm_tsb:
0057BBr 3  03 04        		.byte 3, IM
0057BDr 3  rr rr                        .word nt_asm_tsb_z
0057BFr 3  rr rr rr rr  		.word xt_asm_tsb, z_asm_tsb
0057C3r 3  74 73 62     		.byte "tsb"
0057C6r 3               
0057C6r 3               nt_asm_tsb_z:
0057C6r 3  05 04        		.byte 5, IM
0057C8r 3  rr rr                        .word nt_asm_tsx
0057CAr 3  rr rr rr rr  		.word xt_asm_tsb_z, z_asm_tsb_z
0057CEr 3  74 73 62 2E  		.byte "tsb.z"
0057D2r 3  7A           
0057D3r 3               
0057D3r 3               nt_asm_tsx:
0057D3r 3  03 04        		.byte 3, IM
0057D5r 3  rr rr                        .word nt_asm_txa
0057D7r 3  rr rr rr rr  		.word xt_asm_tsx, z_asm_tsx
0057DBr 3  74 73 78     		.byte "tsx"
0057DEr 3               
0057DEr 3               nt_asm_txa:
0057DEr 3  03 04        		.byte 3, IM
0057E0r 3  rr rr                        .word nt_asm_txs
0057E2r 3  rr rr rr rr  		.word xt_asm_txa, z_asm_txa
0057E6r 3  74 78 61     		.byte "txa"
0057E9r 3               
0057E9r 3               nt_asm_txs:
0057E9r 3  03 04        		.byte 3, IM
0057EBr 3  rr rr                        .word nt_asm_tya
0057EDr 3  rr rr rr rr  		.word xt_asm_txs, z_asm_txs
0057F1r 3  74 78 73     		.byte "txs"
0057F4r 3               
0057F4r 3               nt_asm_tya:
0057F4r 3  03 04        		.byte 3, IM
0057F6r 3  rr rr                        .word nt_asm_arrow
0057F8r 3  rr rr rr rr  		.word xt_asm_tya, z_asm_tya
0057FCr 3  74 79 61     		.byte "tya"
0057FFr 3               
0057FFr 3               ; Assembler pseudo-instructions, directives and macros
0057FFr 3               
0057FFr 3               nt_asm_arrow:   ; uses same code as HERE, but immediate
0057FFr 3  03 04                        .byte 3, IM
005801r 3  rr rr                        .word nt_asm_back_jump
005803r 3  rr rr rr rr                  .word xt_asm_arrow, z_asm_arrow
005807r 3  2D 2D 3E                     .byte "-->"
00580Ar 3               
00580Ar 3               
00580Ar 3               nt_asm_back_jump:  ; syntactic sugar, does nothing
00580Ar 3  02 04                        .byte 2, IM
00580Cr 3  rr rr                        .word nt_asm_back_branch
00580Er 3  rr rr rr rr                  .word xt_asm_back_jump, z_asm_back_jump
005812r 3  3C 6A                        .byte "<j"
005814r 3               
005814r 3               nt_asm_back_branch:
005814r 3  02 04                        .byte 2, IM
005816r 3  rr rr                        .word nt_asm_push_a
005818r 3  rr rr rr rr                  .word xt_asm_back_branch, z_asm_back_branch
00581Cr 3  3C 62                        .byte "<b"
00581Er 3               
00581Er 3               nt_asm_push_a:
00581Er 3  06 04                        .byte 6, IM
005820r 3  00 00                        .word 0000
005822r 3  rr rr rr rr                  .word xt_asm_push_a, z_asm_push_a
005826r 3  70 75 73 68                  .byte "push-a"
00582Ar 3  2D 61        
00582Cr 3               
00582Cr 3               
00582Cr 3               
00582Cr 3               ; END of ASSEMBLER-WORDLIST
00582Cr 3               
00582Cr 3               ; END
00582Cr 3               
00582Cr 2               .include "strings.asm"          ; Strings, including error messages
00582Cr 3               ; List of Strings for Tali Forth 2
00582Cr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00582Cr 3               ; First version: 01. Apr 2016 (for Liara Forth)
00582Cr 3               ; This version: 28. Dec 2018
00582Cr 3               
00582Cr 3               ; This file is included by taliforth.asm
00582Cr 3               
00582Cr 3               ; ## GENERAL STRINGS
00582Cr 3               
00582Cr 3               ; All general strings must be zero-terminated, names start with "s_",
00582Cr 3               ; aliases with "str_"
00582Cr 3               
00582Cr 3               str_ok =              0
00582Cr 3               str_compile =         1
00582Cr 3               str_redefined =       2
00582Cr 3               str_wid_forth =       3
00582Cr 3               str_abc_lower =       4
00582Cr 3               str_abc_upper =       5
00582Cr 3               str_wid_editor =      6
00582Cr 3               str_wid_assembler =   7
00582Cr 3               str_wid_root =        8
00582Cr 3               str_see_flags =       9
00582Cr 3               str_see_nt =         10
00582Cr 3               str_see_xt =         11
00582Cr 3               str_see_size =       12
00582Cr 3               
00582Cr 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
00582Cr 3               ; to tables as error and string numbers.
00582Cr 3               string_table:
00582Cr 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
005830r 3  rr rr rr rr  
005834r 3  rr rr        
005836r 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
00583Ar 3  rr rr rr rr  
00583Er 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
005842r 3  rr rr rr rr  
005846r 3               
005846r 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
00584Ar 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
00584Er 3  70 69 6C 65  
005852r 3  64 00        
005854r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
005858r 3  66 69 6E 65  
00585Cr 3  64 20 00     
00585Fr 3               
00585Fr 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
005863r 3  34 35 36 37  
005867r 3  38 39 61 62  
005883r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
005887r 3  34 35 36 37  
00588Br 3  38 39 41 42  
0058A7r 3               
0058A7r 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
0058ABr 3  6D 62 6C 65  
0058AFr 3  72 20 00     
0058B2r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
0058B6r 3  6F 72 20 00  
0058BAr 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
0058BEr 3  68 20 00     
0058C1r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
0058C5r 3  20 00        
0058C7r 3               
0058C7r 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
0058CBr 3  73 20 28 43  
0058CFr 3  4F 20 41 4E  
0058E3r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
0058E7r 3  00           
0058E8r 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
0058ECr 3  00           
0058EDr 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
0058F1r 3  20 28 64 65  
0058F5r 3  63 69 6D 61  
0058FEr 3               
0058FEr 3               
0058FEr 3               ; ## ERROR STRINGS
0058FEr 3               
0058FEr 3               ; All error strings must be zero-terminated, all names start with "es_",
0058FEr 3               ; aliases with "err_". If the string texts are changed, the test suite must be
0058FEr 3               ; as well
0058FEr 3               
0058FEr 3               err_allot =        0
0058FEr 3               err_badsource =    1
0058FEr 3               err_compileonly =  2
0058FEr 3               err_defer =        3
0058FEr 3               err_divzero =      4
0058FEr 3               err_noname =       5
0058FEr 3               err_refill =       6
0058FEr 3               err_state =        7
0058FEr 3               err_syntax =       8
0058FEr 3               err_underflow =    9
0058FEr 3               err_negallot =     10
0058FEr 3               err_wordlist =     11
0058FEr 3               err_blockwords =   12
0058FEr 3               
0058FEr 3               error_table:
0058FEr 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
005902r 3  rr rr rr rr  
005906r 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
00590Ar 3  rr rr rr rr  
00590Er 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
005912r 3  rr rr rr rr  
005916r 3  rr rr                .word es_blockwords                                    ; 12
005918r 3               
005918r 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
00591Cr 3  54 20 75 73  
005920r 3  69 6E 67 20  
005939r 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
00593Dr 3  67 61 6C 20  
005941r 3  53 4F 55 52  
005959r 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
00595Dr 3  72 70 72 65  
005961r 3  74 69 6E 67  
00597Ar 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
00597Er 3  52 65 64 20  
005982r 3  77 6F 72 64  
005997r 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
00599Br 3  73 69 6F 6E  
00599Fr 3  20 62 79 20  
0059A8r 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
0059ACr 3  69 6E 67 20  
0059B0r 3  66 61 69 6C  
0059B8r 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
0059BCr 3  20 63 6F 75  
0059C0r 3  6C 64 20 6E  
0059E6r 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
0059EAr 3  61 64 79 20  
0059EEr 3  69 6E 20 63  
0059FEr 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
005A02r 3  66 69 6E 65  
005A06r 3  64 20 77 6F  
005A0Dr 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
005A11r 3  6B 20 75 6E  
005A15r 3  64 65 72 66  
005A1Dr 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
005A21r 3  6D 65 6D 6F  
005A25r 3  72 79 20 66  
005A39r 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
005A3Dr 3  6F 72 64 6C  
005A41r 3  69 73 74 73  
005A50r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
005A54r 3  73 65 20 61  
005A58r 3  73 73 69 67  
005A8Fr 3               
005A8Fr 3               ; ## ENVIRONMENT STRINGS
005A8Fr 3               
005A8Fr 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
005A8Fr 3               ; Length byte first, then the string itself that is not rpt. not
005A8Fr 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
005A8Fr 3               ; "envs_".
005A8Fr 3               
005A8Fr 3               ; These return a single-cell number
005A8Fr 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
005A93r 3  55 4E 54 45  
005A97r 3  44 2D 53 54  
005A9Fr 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
005AA3r 3  4C 44        
005AA5r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
005AA9r 3  44           
005AAAr 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
005AAEr 3  52 45 53 53  
005AB2r 3  2D 55 4E 49  
005ABCr 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
005AC0r 3  4F 52 45 44  
005AC4r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
005AC8r 3  2D 43 48 41  
005ACCr 3  52           
005ACDr 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
005AD1r 3  2D 4E        
005AD3r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
005AD7r 3  2D 55        
005AD9r 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
005ADDr 3  55 52 4E 2D  
005AE1r 3  53 54 41 43  
005AECr 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
005AF0r 3  43 4B 2D 43  
005AF4r 3  45 4C 4C 53  
005AF8r 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
005AFCr 3  44 4C 49 53  
005B00r 3  54 53        
005B02r 3               
005B02r 3               ; These return a double-cell number
005B02r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
005B06r 3  2D 44        
005B08r 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
005B0Cr 3  2D 55 44     
005B0Fr 3               
005B0Fr 3               ; END
005B0Fr 3               
005B0Fr 2               
005B0Fr 2               
005B0Fr 2               ; =====================================================================
005B0Fr 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
005B0Fr 2               
005B0Fr 2               ; These three routines compile instructions such as "jsr xt_words" into a word
005B0Fr 2               ; at compile time so they are available at run time. Words that use this
005B0Fr 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
005B0Fr 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
005B0Fr 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
005B0Fr 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
005B0Fr 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
005B0Fr 2               ; Bowie.
005B0Fr 2               
005B0Fr 2               ;               ldy #>addr      ; MSB   ; "Young"
005B0Fr 2               ;               lda #<addr      ; LSB   ; "Americans"
005B0Fr 2               ;               jsr cmpl_subroutine
005B0Fr 2               
005B0Fr 2               ; Also, we keep a routine here to compile a single byte passed through A.
005B0Fr 2               
005B0Fr 2               cmpl_subroutine:
005B0Fr 2                               ; This is the entry point to compile JSR <ADDR>
005B0Fr 2  48                           pha             ; save LSB of address
005B10r 2  A9 20                        lda #$20        ; load opcode for JSR
005B12r 2  80 03                        bra cmpl_common
005B14r 2               cmpl_jump:
005B14r 2                               ; This is the entry point to compile JMP <ADDR>
005B14r 2  48                           pha             ; save LSB of address
005B15r 2  A9 4C                        lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
005B17r 2               cmpl_common:
005B17r 2                               ; At this point, A contains the opcode to be compiled,
005B17r 2                               ; the LSB of the address is on the 65c02 stack, and the MSB of
005B17r 2                               ; the address is in Y
005B17r 2  20 rr rr                     jsr cmpl_a      ; compile opcode
005B1Ar 2  68                           pla             ; retrieve address LSB; fall thru to cmpl_word
005B1Br 2               cmpl_word:
005B1Br 2                               ; This is the entry point to compile a word (little-endian)
005B1Br 2  20 rr rr                     jsr cmpl_a      ; compile LSB of address
005B1Er 2  98                           tya             ; fall thru for MSB
005B1Fr 2               cmpl_a:
005B1Fr 2                               ; This is the entry point to compile a single byte which
005B1Fr 2                               ; is passed in A. The built-in assembler assumes that this
005B1Fr 2                               ; routine does not modify Y.
005B1Fr 2  92 00                        sta (cp)
005B21r 2  E6 00                        inc cp
005B23r 2  D0 02                        bne _done
005B25r 2  E6 01                        inc cp+1
005B27r 2               _done:
005B27r 2  60                           rts
005B28r 2               
005B28r 2               
005B28r 2               
005B28r 2               ; =====================================================================
005B28r 2               ; CODE FIELD ROUTINES
005B28r 2               
005B28r 2               doconst:
005B28r 2                       ; """Execute a CONSTANT: Push the data in the first two bytes of
005B28r 2                       ; the Data Field onto the Data Stack
005B28r 2                       ; """
005B28r 2  CA                           dex             ; make room for constant
005B29r 2  CA                           dex
005B2Ar 2               
005B2Ar 2                               ; The value we need is stored in the two bytes after the
005B2Ar 2                               ; JSR return address, which in turn is what is on top of
005B2Ar 2                               ; the Return Stack
005B2Ar 2  68                           pla             ; LSB of return address
005B2Br 2  85 24                        sta tmp1
005B2Dr 2  68                           pla             ; MSB of return address
005B2Er 2  85 25                        sta tmp1+1
005B30r 2               
005B30r 2                               ; Start LDY with 1 instead of 0 because of how JSR stores
005B30r 2                               ; the return address on the 65c02
005B30r 2  A0 01                        ldy #1
005B32r 2  B1 24                        lda (tmp1),y
005B34r 2  95 00                        sta 0,x
005B36r 2  C8                           iny
005B37r 2  B1 24                        lda (tmp1),y
005B39r 2  95 01                        sta 1,x
005B3Br 2               
005B3Br 2                               ; This takes us back to the original caller, not the
005B3Br 2                               ; DOCONST caller
005B3Br 2  60                           rts
005B3Cr 2               
005B3Cr 2               
005B3Cr 2               dodefer:
005B3Cr 2                       ; """Execute a DEFER statement at runtime: Execute the address we
005B3Cr 2                       ; find after the caller in the Data Field
005B3Cr 2                       ; """
005B3Cr 2                               ; The xt we need is stored in the two bytes after the JSR
005B3Cr 2                               ; return address, which is what is on top of the Return
005B3Cr 2                               ; Stack. So all we have to do is replace our return jump
005B3Cr 2                               ; with what we find there
005B3Cr 2  68                           pla             ; LSB
005B3Dr 2  85 24                        sta tmp1
005B3Fr 2  68                           pla             ; MSB
005B40r 2  85 25                        sta tmp1+1
005B42r 2               
005B42r 2  A0 01                        ldy #1
005B44r 2  B1 24                        lda (tmp1),y
005B46r 2  85 26                        sta tmp2
005B48r 2  C8                           iny
005B49r 2  B1 24                        lda (tmp1),y
005B4Br 2  85 27                        sta tmp2+1
005B4Dr 2               
005B4Dr 2  6C 26 00                     jmp (tmp2)      ; This is actually a jump to the new target
005B50r 2               
005B50r 2               defer_error:
005B50r 2                               ; """Error routine for undefined DEFER: Complain and abort"""
005B50r 2  A9 03                        lda #err_defer
005B52r 2  4C rr rr                     jmp error
005B55r 2               
005B55r 2               dodoes:
005B55r 2                       ; """Execute the runtime portion of DOES>. See DOES> and
005B55r 2                       ; docs/create-does.txt for details and
005B55r 2                       ; http://www.bradrodriguez.com/papers/moving3.htm
005B55r 2                       ; """
005B55r 2                               ; Assumes the address of the CFA of the original defining word
005B55r 2                               ; (say, CONSTANT) is on the top of the Return Stack. Save it
005B55r 2                               ; for a later jump, adding one byte because of the way the
005B55r 2                               ; 6502 works
005B55r 2  7A                           ply             ; LSB
005B56r 2  68                           pla             ; MSB
005B57r 2  C8                           iny
005B58r 2  D0 01                        bne @1
005B5Ar 2  1A                           inc
005B5Br 2               @1:
005B5Br 2  84 26                        sty tmp2
005B5Dr 2  85 27                        sta tmp2+1
005B5Fr 2               
005B5Fr 2                               ; Next on the Return Stack should be the address of the PFA of
005B5Fr 2                               ; the calling defined word (say, the name of whatever constant we
005B5Fr 2                               ; just defined). Move this to the Data Stack, again adding one.
005B5Fr 2  CA                           dex
005B60r 2  CA                           dex
005B61r 2               
005B61r 2  7A                           ply
005B62r 2  68                           pla
005B63r 2  C8                           iny
005B64r 2  D0 01                        bne @2
005B66r 2  1A                           inc
005B67r 2               @2:
005B67r 2  94 00                        sty 0,x         ; LSB
005B69r 2  95 01                        sta 1,x         ; MSB
005B6Br 2               
005B6Br 2                               ; This leaves the return address from the original main routine
005B6Br 2                               ; on top of the Return Stack. We leave that untouched and jump
005B6Br 2                               ; to the special code of the defining word. It's RTS instruction
005B6Br 2                               ; will take us back to the main routine
005B6Br 2  6C 26 00                     jmp (tmp2)
005B6Er 2               
005B6Er 2               
005B6Er 2               dovar:
005B6Er 2                       ; """Execute a variable: Push the address of the first bytes of
005B6Er 2                       ; the Data Field onto the stack. This is called with JSR so we
005B6Er 2                       ; can pick up the address of the calling variable off the 65c02's
005B6Er 2                       ; stack. The final RTS takes us to the original caller of the
005B6Er 2                       ; routine that itself called DOVAR. This is the default
005B6Er 2                       ; routine installed with CREATE.
005B6Er 2                       ; """
005B6Er 2                               ; Pull the return address off the machine's stack, adding
005B6Er 2                               ; one because of the way the 65c02 handles subroutines
005B6Er 2  7A                           ply             ; LSB
005B6Fr 2  68                           pla             ; MSB
005B70r 2  C8                           iny
005B71r 2  D0 01                        bne @1
005B73r 2  1A                           inc
005B74r 2               @1:
005B74r 2  CA                           dex
005B75r 2  CA                           dex
005B76r 2               
005B76r 2  95 01                        sta 1,x
005B78r 2  98                           tya
005B79r 2  95 00                        sta 0,x
005B7Br 2               
005B7Br 2  60                           rts
005B7Cr 2               
005B7Cr 2               ; =====================================================================
005B7Cr 2               ; LOW LEVEL HELPER FUNCTIONS
005B7Cr 2               
005B7Cr 2               byte_to_ascii:
005B7Cr 2                       ; """Convert byte in A to two ASCII hex digits and EMIT them"""
005B7Cr 2               .scope
005B7Cr 2  48                           pha
005B7Dr 2  4A                           lsr             ; convert high nibble first
005B7Er 2  4A                           lsr
005B7Fr 2  4A                           lsr
005B80r 2  4A                           lsr
005B81r 2  20 rr rr                     jsr _nibble_to_ascii
005B84r 2  68                           pla
005B85r 2               
005B85r 2                               ; fall through to _nibble_to_ascii
005B85r 2               
005B85r 2               _nibble_to_ascii:
005B85r 2                       ; """Private helper function for byte_to_ascii: Print lower nibble
005B85r 2                       ; of A and and EMIT it. This does the actual work.
005B85r 2                       ; """
005B85r 2  29 0F                        and #$0F
005B87r 2  09 30                        ora #'0'
005B89r 2  C9 3A                        cmp #$3A        ; '9+1
005B8Br 2  90 02                        bcc @1
005B8Dr 2  69 06                        adc #$06
005B8Fr 2               
005B8Fr 2  4C rr rr     @1:               jmp emit_a
005B92r 2               
005B92r 2  60                           rts
005B93r 2               .endscope
005B93r 2               
005B93r 2               compare_16bit:
005B93r 2                       ; """Compare TOS/NOS and return results in form of the 65c02 flags
005B93r 2                       ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
005B93r 2                       ; also http://www.6502.org/tutorials/compare_beyond.html
005B93r 2                       ; For signed numbers, Z signals equality and N which number is larger:
005B93r 2                       ;       if TOS = NOS: Z=1 and N=0
005B93r 2                       ;       if TOS > NOS: Z=0 and N=0
005B93r 2                       ;       if TOS < NOS: Z=0 and N=1
005B93r 2                       ; For unsigned numbers, Z signals equality and C which number is larger:
005B93r 2                       ;       if TOS = NOS: Z=1 and N=0
005B93r 2                       ;       if TOS > NOS: Z=0 and C=1
005B93r 2                       ;       if TOS < NOS: Z=0 and C=0
005B93r 2                       ; Compared to the book routine, WORD1 (MINUED) is TOS
005B93r 2                       ;                               WORD2 (SUBTRAHEND) is NOS
005B93r 2                       ; """
005B93r 2               .scope
005B93r 2                               ; Compare LSB first to set the carry flag
005B93r 2  B5 00                        lda 0,x                 ; LSB of TOS
005B95r 2  D5 02                        cmp 2,x                 ; LSB of NOS
005B97r 2  F0 0A                        beq _equal
005B99r 2               
005B99r 2                               ; LSBs are not equal, compare MSB
005B99r 2  B5 01                        lda 1,x                 ; MSB of TOS
005B9Br 2  F5 03                        sbc 3,x                 ; MSB of NOS
005B9Dr 2  09 01                        ora #1                  ; Make zero flag 0 because not equal
005B9Fr 2  70 08                        bvs _overflow
005BA1r 2  80 08                        bra _not_equal
005BA3r 2               _equal:
005BA3r 2                               ; Low bytes are equal, so we compare high bytes
005BA3r 2  B5 01                        lda 1,x                 ; MSB of TOS
005BA5r 2  F5 03                        sbc 3,x                 ; MSB of NOS
005BA7r 2  50 04                        bvc _done
005BA9r 2               _overflow:
005BA9r 2                               ; Handle overflow because we use signed numbers
005BA9r 2  49 80                        eor #$80                ; complement negative flag
005BABr 2               _not_equal:
005BABr 2  09 01                        ora #1                  ; if overflow, we can't be eqal
005BADr 2               _done:
005BADr 2  60                           rts
005BAEr 2               .endscope
005BAEr 2               
005BAEr 2               current_to_dp:
005BAEr 2                       ; """Look up the current (compilation) dictionary pointer
005BAEr 2                       ; in the wordlist set and put it into the dp zero-page
005BAEr 2                       ; variable. Uses A and Y.
005BAEr 2                       ; """
005BAEr 2                               ; Determine which wordlist is current
005BAEr 2  A0 04                        ldy #current_offset
005BB0r 2  B1 1E                        lda (up),y      ; current is a byte variable
005BB2r 2  0A                           asl             ; turn it into an offset (in cells)
005BB3r 2               
005BB3r 2                               ; Get the dictionary pointer for that wordlist.
005BB3r 2  18                           clc
005BB4r 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
005BB6r 2  A8                           tay
005BB7r 2  B1 1E                        lda (up),y              ; get the dp for that wordlist.
005BB9r 2  85 02                        sta dp
005BBBr 2  C8                           iny
005BBCr 2  B1 1E                        lda (up),y
005BBEr 2  85 03                        sta dp+1
005BC0r 2               
005BC0r 2  60                           rts
005BC1r 2               
005BC1r 2               
005BC1r 2               dp_to_current:
005BC1r 2                       ; """Look up which wordlist is current and update its pointer
005BC1r 2                       ; with the value in dp. Uses A and Y.
005BC1r 2                       ; """
005BC1r 2                               ; Determine which wordlist is current
005BC1r 2  A0 04                        ldy #current_offset
005BC3r 2  B1 1E                        lda (up),y      ; current is a byte variable
005BC5r 2  0A                           asl             ; turn it into an offset (in cells)
005BC6r 2               
005BC6r 2                               ; Get the dictionary pointer for that wordlist.
005BC6r 2  18                           clc
005BC7r 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
005BC9r 2  A8                           tay
005BCAr 2  A5 02                        lda dp
005BCCr 2  91 1E                        sta (up),y              ; get the dp for that wordlist.
005BCEr 2  C8                           iny
005BCFr 2  A5 03                        lda dp+1
005BD1r 2  91 1E                        sta (up),y
005BD3r 2               
005BD3r 2  60                           rts
005BD4r 2               
005BD4r 2               interpret:
005BD4r 2               .scope
005BD4r 2                       ; """Core routine for the interpreter called by EVALUATE and QUIT.
005BD4r 2                       ; Process one line only. Assumes that the address of name is in
005BD4r 2                       ; cib and the length of the whole input line string is in ciblen
005BD4r 2                       ; """
005BD4r 2                               ; Normally we would use PARSE here with the SPACE character as
005BD4r 2                               ; a parameter (PARSE replaces WORD in modern Forths). However,
005BD4r 2                               ; Gforth's PARSE-NAME makes more sense as it uses spaces as
005BD4r 2                               ; delimiters per default and skips any leading spaces, which
005BD4r 2                               ; PARSE doesn't
005BD4r 2               _loop:
005BD4r 2  20 rr rr                     jsr xt_parse_name       ; ( "string" -- addr u )
005BD7r 2               
005BD7r 2                               ; If PARSE-NAME returns 0 (empty line), no characters were left
005BD7r 2                               ; in the line and we need to go get a new line
005BD7r 2  B5 00                        lda 0,x
005BD9r 2  15 01                        ora 1,x
005BDBr 2  F0 70                        beq _line_done
005BDDr 2               
005BDDr 2                               ; Go to FIND-NAME to see if this is a word we know. We have to
005BDDr 2                               ; make a copy of the address in case it isn't a word we know and
005BDDr 2                               ; we have to go see if it is a number
005BDDr 2  20 rr rr                     jsr xt_two_dup          ; ( addr u -- addr u addr u )
005BE0r 2  20 rr rr                     jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
005BE3r 2               
005BE3r 2                               ; A zero signals that we didn't find a word in the Dictionary
005BE3r 2  B5 00                        lda 0,x
005BE5r 2  15 01                        ora 1,x
005BE7r 2  D0 28                        bne _got_name_token
005BE9r 2               
005BE9r 2                               ; We didn't get any nt we know of, so let's see if this is
005BE9r 2                               ; a number.
005BE9r 2  E8                           inx                     ; ( addr u 0 -- addr u )
005BEAr 2  E8                           inx
005BEBr 2               
005BEBr 2                               ; If the number conversion doesn't work, NUMBER will do the
005BEBr 2                               ; complaining for us
005BEBr 2  20 rr rr                     jsr xt_number           ; ( addr u -- u|d )
005BEEr 2               
005BEEr 2                               ; Otherweise, if we're interpreting, we're done
005BEEr 2  A5 16                        lda state
005BF0r 2  F0 E2                        beq _loop
005BF2r 2               
005BF2r 2                               ; We're compiling, so there is a bit more work.  Check
005BF2r 2                               ; status bit 5 to see if it's a single or double-cell
005BF2r 2                               ; number.
005BF2r 2  A9 20                        lda #$20
005BF4r 2  24 20                        bit status
005BF6r 2  F0 0D                        beq _single_number
005BF8r 2               
005BF8r 2                               ; It's a double cell number.  If we swap the
005BF8r 2                               ; upper and lower half, we can use the literal_runtime twice
005BF8r 2                               ; to compile it into the dictionary.
005BF8r 2  20 rr rr                     jsr xt_swap
005BFBr 2  A0 rr                        ldy #>literal_runtime
005BFDr 2  A9 rr                        lda #<literal_runtime
005BFFr 2  20 rr rr                     jsr cmpl_subroutine
005C02r 2               
005C02r 2                               ; compile our number
005C02r 2  20 rr rr                     jsr xt_comma
005C05r 2               
005C05r 2                               ; Fall into _single_number to process the other half.
005C05r 2               _single_number:
005C05r 2  A0 rr                        ldy #>literal_runtime
005C07r 2  A9 rr                        lda #<literal_runtime
005C09r 2  20 rr rr                     jsr cmpl_subroutine
005C0Cr 2               
005C0Cr 2                               ; compile our number
005C0Cr 2  20 rr rr                     jsr xt_comma
005C0Fr 2               
005C0Fr 2                               ; That was so much fun, let's do it again!
005C0Fr 2  80 C3                        bra _loop
005C11r 2               
005C11r 2               _got_name_token:
005C11r 2                               ; We have a known word's nt TOS. We're going to need its xt
005C11r 2                               ; though, which is four bytes father down.
005C11r 2               
005C11r 2                               ; We arrive here with ( addr u nt ), so we NIP twice
005C11r 2  B5 00                        lda 0,x
005C13r 2  95 04                        sta 4,x
005C15r 2  B5 01                        lda 1,x
005C17r 2  95 05                        sta 5,x
005C19r 2               
005C19r 2  E8                           inx
005C1Ar 2  E8                           inx
005C1Br 2  E8                           inx
005C1Cr 2  E8                           inx                     ; ( nt )
005C1Dr 2               
005C1Dr 2                               ; Save a version of nt for error handling and compilation stuff
005C1Dr 2  B5 00                        lda 0,x
005C1Fr 2  85 22                        sta tmpbranch
005C21r 2  B5 01                        lda 1,x
005C23r 2  85 23                        sta tmpbranch+1
005C25r 2               
005C25r 2  20 rr rr                     jsr xt_name_to_int      ; ( nt - xt )
005C28r 2               
005C28r 2                               ; See if we are in interpret or compile mode, 0 is interpret
005C28r 2  A5 16                        lda state
005C2Ar 2  D0 13                        bne _compile
005C2Cr 2               
005C2Cr 2                               ; We are interpreting, so EXECUTE the xt that is TOS. First,
005C2Cr 2                               ; though, see if this isn't a compile-only word, which would be
005C2Cr 2                               ; illegal. The status byte is the second one of the header.
005C2Cr 2  A0 01                        ldy #1
005C2Er 2  B1 22                        lda (tmpbranch),y
005C30r 2  29 01                        and #CO                 ; mask everything but Compile Only bit
005C32r 2  F0 05                        beq _interpret
005C34r 2               
005C34r 2  A9 02                        lda #err_compileonly
005C36r 2  4C rr rr                     jmp error
005C39r 2               
005C39r 2               _interpret:
005C39r 2                               ; We JSR to EXECUTE instead of calling the xt directly because
005C39r 2                               ; the RTS of the word we're executing will bring us back here,
005C39r 2                               ; skipping EXECUTE completely during RTS. If we were to execute
005C39r 2                               ; xt directly, we have to fool around with the Return Stack
005C39r 2                               ; instead, which is actually slightly slower
005C39r 2  20 rr rr                     jsr xt_execute
005C3Cr 2               
005C3Cr 2                               ; That's quite enough for this word, let's get the next one
005C3Cr 2  4C rr rr                     jmp _loop
005C3Fr 2               
005C3Fr 2               _compile:
005C3Fr 2                               ; We're compiling! However, we need to see if this is an
005C3Fr 2                               ; IMMEDIATE word, which would mean we execute it right now even
005C3Fr 2                               ; during compilation mode. Fortunately, we saved the nt so life
005C3Fr 2                               ; is easier. The flags are in the second byte of the header
005C3Fr 2  A0 01                        ldy #1
005C41r 2  B1 22                        lda (tmpbranch),y
005C43r 2  29 04                        and #IM                 ; Mask all but IM bit
005C45r 2  D0 F2                        bne _interpret          ; IMMEDIATE word, execute right now
005C47r 2               
005C47r 2                               ; Compile the xt into the Dictionary with COMPILE,
005C47r 2  20 rr rr                     jsr xt_compile_comma
005C4Ar 2  4C rr rr                     jmp _loop
005C4Dr 2               
005C4Dr 2               _line_done:
005C4Dr 2                               ; drop stuff from PARSE_NAME
005C4Dr 2  E8                           inx
005C4Er 2  E8                           inx
005C4Fr 2  E8                           inx
005C50r 2  E8                           inx
005C51r 2               
005C51r 2  60                           rts
005C52r 2               .endscope
005C52r 2               
005C52r 2               
005C52r 2               is_printable:
005C52r 2               .scope
005C52r 2                       ; """Given a character in A, check if it is a printable ASCII
005C52r 2                       ; character in the range from $20 to $7E inclusive. Returns the
005C52r 2                       ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
005C52r 2                       ; is printable. Keeps A. See
005C52r 2                       ; http://www.obelisk.me.uk/6502/algorithms.html for a
005C52r 2                       ; discussion of various ways to do this
005C52r 2  C9 20                        cmp #AscSP              ; $20
005C54r 2  90 08                        bcc _done
005C56r 2  C9 7F                        cmp #'~' + 1             ; $7E
005C58r 2  B0 03                        bcs _failed
005C5Ar 2               
005C5Ar 2  38                           sec
005C5Br 2  80 01                        bra _done
005C5Dr 2               _failed:
005C5Dr 2  18                           clc
005C5Er 2               _done:
005C5Er 2  60                           rts
005C5Fr 2               .endscope
005C5Fr 2               
005C5Fr 2               
005C5Fr 2               is_whitespace:
005C5Fr 2               .scope
005C5Fr 2                       ; """Given a character in A, check if it is a whitespace
005C5Fr 2                       ; character, that is, an ASCII value from 0 to 32 (where
005C5Fr 2                       ; 32 is SPACE). Returns the result in the Carry Flag:
005C5Fr 2                       ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
005C5Fr 2                       ; that it is whitespace. See PARSE and PARSE-NAME for
005C5Fr 2                       ; a discussion of the uses. Does not change A or Y.
005C5Fr 2  C9 00                        cmp #00         ; explicit comparison to leave Y untouched
005C61r 2  90 08                        bcc _done
005C63r 2               
005C63r 2  C9 21                        cmp #AscSP+1
005C65r 2  B0 03                        bcs _failed
005C67r 2               
005C67r 2  38                           sec
005C68r 2  80 01                        bra _done
005C6Ar 2               _failed:
005C6Ar 2  18                           clc
005C6Br 2               _done:
005C6Br 2  60                           rts
005C6Cr 2               .endscope
005C6Cr 2               
005C6Cr 2               
005C6Cr 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
005C6Cr 2               ; required for the word. This routine flows into the generic error handling
005C6Cr 2               ; code
005C6Cr 2               underflow_1:
005C6Cr 2                       ; """Make sure we have at least one cell on the Data Stack"""
005C6Cr 2  E0 77                        cpx #dsp0-1
005C6Er 2  10 10                        bpl underflow_error
005C70r 2  60                           rts
005C71r 2               underflow_2:
005C71r 2                       ; """Make sure we have at least two cells on the Data Stack"""
005C71r 2  E0 75                        cpx #dsp0-3
005C73r 2  10 0B                        bpl underflow_error
005C75r 2  60                           rts
005C76r 2               underflow_3:
005C76r 2                       ; """Make sure we have at least three cells on the Data Stack"""
005C76r 2  E0 73                        cpx #dsp0-5
005C78r 2  10 06                        bpl underflow_error
005C7Ar 2  60                           rts
005C7Br 2               underflow_4:
005C7Br 2                       ; """Make sure we have at least four cells on the Data Stack"""
005C7Br 2  E0 71                        cpx #dsp0-7
005C7Dr 2  10 01                        bpl underflow_error
005C7Fr 2  60                           rts
005C80r 2               
005C80r 2               underflow_error:
005C80r 2                               ; Entry for COLD/ABORT/QUIT
005C80r 2  A9 09                        lda #err_underflow      ; fall through to error
005C82r 2               
005C82r 2               error:
005C82r 2                       ; """Given the error number in a, print the associated error string and
005C82r 2                       ; call abort. Uses tmp3.
005C82r 2                       ; """
005C82r 2  0A                           asl
005C83r 2  A8                           tay
005C84r 2  B9 rr rr                     lda error_table,y
005C87r 2  85 28                        sta tmp3                ; LSB
005C89r 2  C8                           iny
005C8Ar 2  B9 rr rr                     lda error_table,y
005C8Dr 2  85 29                        sta tmp3+1              ; MSB
005C8Fr 2               
005C8Fr 2  20 rr rr                     jsr print_common
005C92r 2  20 rr rr                     jsr xt_cr
005C95r 2  4C rr rr                     jmp xt_abort            ; no jsr, as we clobber return stack
005C98r 2               
005C98r 2               
005C98r 2               ; =====================================================================
005C98r 2               ; PRINTING ROUTINES
005C98r 2               
005C98r 2               ; We distinguish two types of print calls, both of which take the string number
005C98r 2               ; (see strings.asm) in A:
005C98r 2               
005C98r 2               ;       print_string       - with a line feed
005C98r 2               ;       print_string_no_lf - without a line feed
005C98r 2               
005C98r 2               ; In addition, print_common provides a lower-level alternative for error
005C98r 2               ; handling and anything else that provides the address of the
005C98r 2               ; zero-terminated string directly in tmp3. All of those routines assume that
005C98r 2               ; printing should be more concerned with size than speed, because anything to
005C98r 2               ; do with humans reading text is going to be slow.
005C98r 2               
005C98r 2               print_string_no_lf:
005C98r 2                       ; """Given the number of a zero-terminated string in A, print it to the
005C98r 2                       ; current output without adding a LF. Uses Y and tmp3 by falling
005C98r 2                       ; through to print_common
005C98r 2                       ; """
005C98r 2                               ; Get the entry from the string table
005C98r 2  0A                           asl
005C99r 2  A8                           tay
005C9Ar 2  B9 rr rr                     lda string_table,y
005C9Dr 2  85 28                        sta tmp3                ; LSB
005C9Fr 2  C8                           iny
005CA0r 2  B9 rr rr                     lda string_table,y
005CA3r 2  85 29                        sta tmp3+1              ; MSB
005CA5r 2               
005CA5r 2                               ; fall through to print_common
005CA5r 2               print_common:
005CA5r 2                       ; """Common print routine used by both the print functions and
005CA5r 2                       ; the error printing routine. Assumes string address is in tmp3. Uses
005CA5r 2                       ; Y.
005CA5r 2                       ; """
005CA5r 2               .scope
005CA5r 2  A0 00                        ldy #0
005CA7r 2               _loop:
005CA7r 2  B1 28                        lda (tmp3),y
005CA9r 2  F0 06                        beq _done               ; strings are zero-terminated
005CABr 2               
005CABr 2  20 rr rr                     jsr emit_a              ; allows vectoring via output
005CAEr 2  C8                           iny
005CAFr 2  80 F6                        bra _loop
005CB1r 2               _done:
005CB1r 2  60                           rts
005CB2r 2               .endscope
005CB2r 2               
005CB2r 2               print_string:
005CB2r 2                       ; """Print a zero-terminated string to the console/screen, adding a LF.
005CB2r 2                       ; We do not check to see if the index is out of range. Uses tmp3.
005CB2r 2                       ; """
005CB2r 2  20 rr rr                     jsr print_string_no_lf
005CB5r 2  4C rr rr                     jmp xt_cr               ; JSR/RTS because never compiled
005CB8r 2               
005CB8r 2               
005CB8r 2               print_u:
005CB8r 2                       ; """basic printing routine used by higher-level constructs,
005CB8r 2                       ; the equivalent of the forth word  0 <# #s #> type  which is
005CB8r 2                       ; basically u. without the space at the end. used for various
005CB8r 2                       ; outputs
005CB8r 2                       ; """
005CB8r 2  20 rr rr                     jsr xt_zero                     ; 0
005CBBr 2  20 rr rr                     jsr xt_less_number_sign         ; <#
005CBEr 2  20 rr rr                     jsr xt_number_sign_s            ; #S
005CC1r 2  20 rr rr                     jsr xt_number_sign_greater      ; #>
005CC4r 2  4C rr rr                     jmp xt_type                     ; JSR/RTS because never compiled
005CC7r 2               
005CC7r 2               ; END
005CC7r 2               
005CC7r 1               
005CC7r 1               ; =====================================================================
005CC7r 1               ; FINALLY
005CC7r 1               
005CC7r 1               ; Of the 32 KiB we use, 24 KiB are reserved for Tali (from $8000 to $DFFF)
005CC7r 1               ; and the last eight (from $E000 to $FFFF) are left for whatever the user
005CC7r 1               ; wants to use them for.
005CC7r 1               
005CC7r 1               
005CC7r 1               ; ******************************************************************
005CC7r 1               ; *  Hardware definitions for Planck 6502 computer                 *
005CC7r 1               ; *  Change these depending on the slot in which                   *
005CC7r 1               ; *  you want to put each card                                     *
005CC7r 1               ; *  As a reminder here are the addresses for each slot:           *
005CC7r 1               ; *                                                                *
005CC7r 1               ; * START ADDRESS    |   END ADDRESS       |     DESCRIPTION       *
005CC7r 1               ; * 0xFF80           |   0xFF8F            | SLOT1 Selected        *
005CC7r 1               ; * 0xFF90           |   0xFF9F            | SLOT2 Selected        *
005CC7r 1               ; * 0xFFA0           |   0xFFAF            | SLOT3 Selected        *
005CC7r 1               ; * 0xFFB0           |   0xFFBF            | SLOT4 Selected        *
005CC7r 1               ; * 0xFFC0           |   0xFFCF            | SLOT5 Selected        *
005CC7r 1               ; ******************************************************************
005CC7r 1               ;
005CC7r 1               ;
005CC7r 1               
005CC7r 1               .segment "KERNEL"
000000r 1               ; clock speed of main oscillator in hertz
000000r 1               ; used by drivers/timer.s to set proper via timing interval
000000r 1               CLOCK_SPEED = 24000000
000000r 1               ; I/O board in slot 0
000000r 1               VIA1_BASE =        $FF80
000000r 1               ; Serial chip at this address
000000r 1               ACIA_BASE =        $FFE0
000000r 1               
000000r 1               ; VIDEO board in slot 3
000000r 1               VIDEO_BASE =       $FFB0
000000r 1               
000000r 1               ; LCD board in slot 2
000000r 1               LCD_BASE =         $FFD0
000000r 1               
000000r 1               ACIA_DATA =    ACIA_BASE
000000r 1               ACIA_STATUS =  ACIA_BASE+1
000000r 1               ACIA_COMMAND = ACIA_BASE+2
000000r 1               ACIA_CTRL =    ACIA_BASE+3
000000r 1               
000000r 1               LCD_ADDR_DISABLED = LCD_BASE
000000r 1               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 1               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 1               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 1               
000000r 1               PORTB =  VIA1_BASE
000000r 1               PORTA =   VIA1_BASE+1
000000r 1               DDRB =  VIA1_BASE+2
000000r 1               DDRA =  VIA1_BASE+3
000000r 1               
000000r 1               T1CL =  VIA1_BASE + 4
000000r 1               T1CH =  VIA1_BASE + 5
000000r 1               T1LL =  VIA1_BASE + 6
000000r 1               T1LH =  VIA1_BASE + 7
000000r 1               ACR =  VIA1_BASE + 11
000000r 1               PCR =  VIA1_BASE + 12
000000r 1               IFR =  VIA1_BASE + 13
000000r 1               IER =  VIA1_BASE + 14
000000r 1               
000000r 1               
000000r 1               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 1               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;//  ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 1               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 1               VIDEO_DATA = VIDEO_BASE + 3
000000r 1               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 1               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 1               VIDEO_HIRES_HCHARS = 100
000000r 1               VIDEO_HIRES_VCHARS = 75
000000r 1               
000000r 1               ; ps2 defines
000000r 1               
000000r 1               DATA = $80   ; Data is in bit 7 of PORTB
000000r 1               ; clock is on CB2
000000r 1               SHIFT = $1
000000r 1               ALT = $2
000000r 1               
000000r 1               KB_STATE_START = $0
000000r 1               KB_STATE_DATA = $1
000000r 1               KB_STATE_PARITY = $2
000000r 1               KB_STATE_STOP = $3
000000r 1               
000000r 1               KB_INIT_STATE_RESET = $0
000000r 1               KB_INIT_STATE_RESET_ACK = $1
000000r 1               KB_INIT_STATE_LEDS = $2
000000r 1               KB_INIT_STATE_LEDS_ACK = $3
000000r 1               KB_INIT_STATE_LEDS_DATA = $4
000000r 1               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 1               
000000r 1               LSHIFT_KEY = $12
000000r 1               RSHIFT_KEY = $59
000000r 1               
000000r 1               TIMER_DELAY = $C4
000000r 1               
000000r 1               ; SPI defines
000000r 1               
000000r 1               SS = $07   ; Slave Select with lowest 3 bits
000000r 1               SCK = $08   ; Clock on bit 3
000000r 1               MISO = $10  ; MISO on bit 4
000000r 1               MOSI = $20  ; MOSI on bit 5
000000r 1               CONF = $40  ; CONF on bit 6
000000r 1               
000000r 1               ; Zero page variables
000000r 1               
000000r 1               stack_p =          dsp0
000000r 1               time =             dsp0+2
000000r 1               last_ps2_time =    dsp0+6
000000r 1               
000000r 1               to_send =          dsp0+10
000000r 1               KB_STATE =         dsp0+11
000000r 1               KB_TEMP =          dsp0+11
000000r 1               
000000r 1               KB_BUF_W_PTR =     dsp0+12
000000r 1               KB_BUF_R_PTR =     dsp0+13
000000r 1               KB_PARITY =        dsp0+14
000000r 1               KB_BIT =           dsp0+15
000000r 1               KB_INIT_STATE =    dsp0+16
000000r 1               KB_INIT_WAIT =     dsp0+17
000000r 1               
000000r 1               ready =            dsp0+18
000000r 1               
000000r 1               ignore_next =      dsp0+19
000000r 1               control_keys =     dsp0+20
000000r 1               
000000r 1               character =        dsp0+21
000000r 1               debug =            dsp0+22
000000r 1               
000000r 1               temp_bits =        dsp0+23
000000r 1               LCD_BUF_W_PTR =    dsp0+24
000000r 1               LCD_BUF_R_PTR =    dsp0+25
000000r 1               line =             dsp0+26
000000r 1               char =             dsp0+27
000000r 1               lcd_absent =       dsp0+28
000000r 1               lcd_pos =          dsp0+29
000000r 1               has_acia =         dsp0+30
000000r 1               spi_tmp =          dsp0+31
000000r 1               spi_tmp2 =         dsp0+32
000000r 1               spi_slave =        dsp0+33
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               .include "../../drivers/delayroutines.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               ; this routine delays by 2304 * y + 23 cycles
000000r 2               delay:
000000r 2  DA             phx       ; 3 cycles
000001r 2  5A             phy       ; 3 cycles
000002r 2               two:
000002r 2  A2 FF          ldx #$ff  ; 2 cycles
000004r 2               one:
000004r 2  EA             nop       ; 2 cycles
000005r 2  EA             nop       ; 2 cycles
000006r 2  CA             dex       ; 2 cycles
000007r 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
000009r 2  88             dey       ; 2 cycles
00000Ar 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
00000Cr 2  7A             ply       ; 4 cycles
00000Dr 2  FA             plx       ; 4 cycles
00000Er 2  60             rts       ; 6 cycles
00000Fr 2               
00000Fr 2               ; delay is in Y register
00000Fr 2               delay_long:
00000Fr 2  48             pha
000010r 2  5A             phy
000011r 2  DA             phx
000012r 2  98             tya
000013r 2  AA             tax
000014r 2               delay_long_loop:
000014r 2  A0 FF          ldy #$ff
000016r 2  20 rr rr       jsr delay
000019r 2  CA             dex
00001Ar 2  D0 F8          bne delay_long_loop
00001Cr 2  FA             plx
00001Dr 2  7A             ply
00001Er 2  68             pla
00001Fr 2  60             rts
000020r 2               
000020r 2               delay_short:        ; delay Y * 19 cycles
000020r 2  5A             phy
000021r 2               delay_short_loop:
000021r 2  EA             nop               ; 2 cycles
000022r 2  EA             nop               ; 2 cycles
000023r 2  EA             nop               ; 2 cycles
000024r 2  EA             nop               ; 2 cycles
000025r 2  EA             nop               ; 2 cycles
000026r 2  EA             nop               ; 2 cycles
000027r 2  EA             nop               ; 2 cycles
000028r 2               
000028r 2               
000028r 2  88             dey               ; 2 cycles
000029r 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
00002Br 2  7A             ply
00002Cr 2  60             rts
00002Dr 2               
00002Dr 1               .include "../../drivers/ps2.s"
00002Dr 2               ; Copyright 2020 Jonathan Foucher
00002Dr 2               
00002Dr 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
00002Dr 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
00002Dr 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
00002Dr 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
00002Dr 2               ; is furnished to do so, subject to the following conditions:
00002Dr 2               
00002Dr 2               ; The above copyright notice and this permission notice shall be included in all copies or
00002Dr 2               ; substantial portions of the Software.
00002Dr 2               
00002Dr 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
00002Dr 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
00002Dr 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
00002Dr 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
00002Dr 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
00002Dr 2               ; DEALINGS IN THE SOFTWARE.
00002Dr 2               
00002Dr 2               
00002Dr 2               ps2_init:
00002Dr 2  78             sei ; prevent interrupts while initializing
00002Er 2               kb_conn_msg:
00002Er 2  A2 00          ldx #0
000030r 2               kb_conn_loop:
000030r 2  BD rr rr       lda kb_conn_msg_text,x
000033r 2  F0 1A          beq kb_conn_msg_end
000035r 2  20 rr rr       jsr kernel_putc
000038r 2  E8             inx
000039r 2  80 F5          bra kb_conn_loop
00003Br 2  44 65 74 65  kb_conn_msg_text: .byte "Detecting keyboard", $0D, $00
00003Fr 2  63 74 69 6E  
000043r 2  67 20 6B 65  
00004Fr 2               kb_conn_msg_end:
00004Fr 2               
00004Fr 2  AD 8E FF       lda IER
000052r 2  09 88          ora #$88      ;enable interrupt on neg transition on CB2
000054r 2  8D 8E FF       sta IER
000057r 2               
000057r 2  A9 00          lda #0
000059r 2  8D 8C FF       sta PCR
00005Cr 2  85 83          sta KB_TEMP
00005Er 2  85 87          sta KB_BIT
000060r 2  85 83          sta KB_STATE
000062r 2  85 82          sta to_send
000064r 2  85 86          sta KB_PARITY
000066r 2  85 84          sta KB_BUF_W_PTR
000068r 2  85 85          sta KB_BUF_R_PTR
00006Ar 2  85 88          sta KB_INIT_STATE
00006Cr 2  85 89          sta KB_INIT_WAIT
00006Er 2  85 8A          sta ready
000070r 2  85 8B          sta ignore_next
000072r 2  85 8D          sta character
000074r 2  20 rr rr       jsr clear_buffer
000077r 2               
000077r 2                 ; jsr kb_reset
000077r 2                 ; jsr kb_leds
000077r 2                 ; jsr kb_leds_data
000077r 2               
000077r 2                 ; jmp done_init
000077r 2               
000077r 2  A9 00          lda #KB_INIT_STATE_RESET
000079r 2  85 88          sta KB_INIT_STATE
00007Br 2  58             cli           ;enable interrupts
00007Cr 2               
00007Cr 2               @wait1:
00007Cr 2  A0 0A          ldy #10
00007Er 2  20 rr rr       jsr delay
000081r 2  E6 89          inc KB_INIT_WAIT
000083r 2  F0 19          beq done_init     ; nothing to show yet
000085r 2  A5 82          lda to_send
000087r 2  D0 F3          bne @wait1       ; do nothing while sending
000089r 2               
000089r 2                 ;jsr lcd_print
000089r 2               
000089r 2  A6 88          ldx KB_INIT_STATE
00008Br 2  E0 00          cpx #KB_INIT_STATE_RESET
00008Dr 2  F0 06          beq @do_reset
00008Fr 2  E0 01          cpx #KB_INIT_STATE_RESET_ACK
000091r 2  F0 0B          beq done_init
000093r 2                 ; beq @self_test_ok  ; Wait for 256 loops with nothing. if still nothing, reset keyboard
000093r 2               
000093r 2  80 09          bra done_init
000095r 2                 ;sta PORTA
000095r 2                 ; wait for keyboard self test (#$AA)
000095r 2               
000095r 2               @do_reset:
000095r 2  20 rr rr       jsr kb_reset
000098r 2  A9 01          lda #KB_INIT_STATE_RESET_ACK  ; next state should be an acknowledgment
00009Ar 2  85 88          sta KB_INIT_STATE
00009Cr 2  80 DE          bra @wait1
00009Er 2               
00009Er 2               
00009Er 2               done_init:
00009Er 2  A9 00          lda #0
0000A0r 2  8D 82 FF       sta DDRB
0000A3r 2  8D 8C FF       sta PCR
0000A6r 2  85 8B          sta ignore_next
0000A8r 2  85 8A          sta ready
0000AAr 2  85 8C          sta control_keys
0000ACr 2  85 82          sta to_send
0000AEr 2  85 8A          sta ready
0000B0r 2  85 8D          sta character
0000B2r 2  85 83          sta KB_TEMP
0000B4r 2  85 88          sta KB_INIT_STATE
0000B6r 2  85 87          sta KB_BIT
0000B8r 2  85 83          sta KB_STATE
0000BAr 2  85 84          sta KB_BUF_W_PTR
0000BCr 2  85 85          sta KB_BUF_R_PTR
0000BEr 2  58             cli ; enable interrupts again
0000BFr 2  60             rts
0000C0r 2               
0000C0r 2               
0000C0r 2               kb_reset:
0000C0r 2  A9 00          lda #0
0000C2r 2  85 89          sta KB_INIT_WAIT
0000C4r 2  A9 F0          lda #$F0
0000C6r 2  8D 81 FF       sta PORTA
0000C9r 2  78             sei                   ;disable interrupts
0000CAr 2  20 rr rr       jsr prepare_send
0000CDr 2  A9 FF          lda #$FF
0000CFr 2  85 82          sta to_send
0000D1r 2  58             cli                   ; enable interrupts
0000D2r 2  60             rts
0000D3r 2               
0000D3r 2               no_kb_msg:
0000D3r 2  A2 00          ldx #0
0000D5r 2               no_kb_loop:
0000D5r 2  BD rr rr       lda no_kb_msg_text,x
0000D8r 2  F0 C4          beq done_init
0000DAr 2  20 rr rr       jsr kernel_putc
0000DDr 2  E8             inx
0000DEr 2  80 F5          bra no_kb_loop
0000E0r 2  4E 6F 20 6B  no_kb_msg_text: .byte "No keyboard connected", $0D, $00
0000E4r 2  65 79 62 6F  
0000E8r 2  61 72 64 20  
0000F7r 2               
0000F7r 2               
0000F7r 2               prepare_send:
0000F7r 2  48             pha
0000F8r 2  5A             phy
0000F9r 2                 ; ready to send, pull clock low for a while
0000F9r 2  A9 C0          lda #$C0
0000FBr 2  8D 8C FF       sta PCR       ;set CB2 low
0000FEr 2                 ;delay
0000FEr 2  A0 80          ldy #$80
000100r 2  20 rr rr       jsr delay
000103r 2                 ; delay end
000103r 2                 ; pull data low now
000103r 2  AD 80 FF       lda PORTB
000106r 2  29 7F          and #($FF^DATA)
000108r 2  8D 80 FF       sta PORTB
00010Br 2  AD 82 FF       lda DDRB
00010Er 2  09 80          ora #DATA   ;data as output to set it low
000110r 2  8D 82 FF       sta DDRB
000113r 2  A0 40          ldy #$40
000115r 2  20 rr rr       jsr delay
000118r 2  A9 01          lda #KB_STATE_DATA    ; no start bit when sending
00011Ar 2  85 83          sta KB_STATE
00011Cr 2                 ; release clock
00011Cr 2  A9 00          lda #0
00011Er 2  85 82          sta to_send
000120r 2  85 86          sta KB_PARITY
000122r 2  8D 8C FF       sta PCR       ;set CB2 to negative edge input
000125r 2               
000125r 2  7A             ply
000126r 2  68             pla
000127r 2  60             rts
000128r 2               
000128r 2               
000128r 2               reset_ps2:          ; routine called during a timer interrupt to check
000128r 2  48             pha
000129r 2                                   ; if the elasped time since the last ps2 interrupt allows us to reset it
000129r 2  A5 7D          lda time+3
00012Br 2  C5 81          cmp last_ps2_time+3
00012Dr 2  90 16          bcc @reset
00012Fr 2  A5 7C          lda time+2
000131r 2  C5 80          cmp last_ps2_time+2
000133r 2  90 10          bcc @reset
000135r 2  A5 7B          lda time+1
000137r 2  C5 7F          cmp last_ps2_time+1
000139r 2  90 0A          bcc @reset
00013Br 2  A5 7A          lda time
00013Dr 2  69 01          adc #$1
00013Fr 2  C5 7E          cmp last_ps2_time
000141r 2  90 02          bcc @reset
000143r 2               @exit2:
000143r 2  68             pla
000144r 2  60             rts
000145r 2               @reset:
000145r 2  A9 00          lda #0
000147r 2  85 83          sta KB_TEMP
000149r 2  85 87          sta KB_BIT
00014Br 2  85 83          sta KB_STATE
00014Dr 2  85 84          sta KB_BUF_W_PTR
00014Fr 2  85 85          sta KB_BUF_R_PTR
000151r 2  F0 F0          beq @exit2
000153r 2               
000153r 2               clear_buffer:
000153r 2  DA             phx
000154r 2  A2 FF          ldx #$ff
000156r 2               @clear_loop:
000156r 2  9E 01 7B       stz KB_BUF, x
000159r 2  CA             dex
00015Ar 2  D0 FA          bne @clear_loop
00015Cr 2  FA             plx
00015Dr 2  60             rts
00015Er 2               
00015Er 2                 .include "ps2_irq.s"
00015Er 3               ; Copyright 2020 Jonathan Foucher
00015Er 3               
00015Er 3               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
00015Er 3               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
00015Er 3               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
00015Er 3               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
00015Er 3               ; is furnished to do so, subject to the following conditions:
00015Er 3               
00015Er 3               ; The above copyright notice and this permission notice shall be included in all copies or
00015Er 3               ; substantial portions of the Software.
00015Er 3               
00015Er 3               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
00015Er 3               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
00015Er 3               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
00015Er 3               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
00015Er 3               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
00015Er 3               ; DEALINGS IN THE SOFTWARE.
00015Er 3               
00015Er 3               
00015Er 3               
00015Er 3               
00015Er 3               ps2_irq:
00015Er 3  48               pha
00015Fr 3  DA               phx
000160r 3  A5 82            lda to_send
000162r 3  D0 21            bne @willsend
000164r 3  A5 83            lda KB_STATE            ; which state ?
000166r 3  C9 00            cmp #KB_STATE_START
000168r 3  F0 0F            beq @start        ; start bit
00016Ar 3               
00016Ar 3  C9 01            cmp #KB_STATE_DATA             ; get data bits
00016Cr 3  F0 1A            beq @data
00016Er 3               
00016Er 3  C9 02            cmp #KB_STATE_PARITY             ; this is the parity bit
000170r 3  F0 31            beq @parity
000172r 3               
000172r 3  C9 03            cmp #KB_STATE_STOP      ; stop bit
000174r 3  F0 33            beq @stop
000176r 3  4C rr rr         jmp @exit
000179r 3               
000179r 3               @start:
000179r 3  A9 01            lda #KB_STATE_DATA
00017Br 3  85 83            sta KB_STATE        ; next state will be to get data
00017Dr 3  A9 00            lda #0
00017Fr 3  85 83            sta KB_TEMP
000181r 3  85 87            sta KB_BIT
000183r 3  80 5B            bra @exit
000185r 3               @willsend:
000185r 3  4C rr rr         jmp @sending
000188r 3               @data:
000188r 3  AD 80 FF         lda PORTB       ; get the bit of data from PORTB bit 7
00018Br 3  29 80            and #$80
00018Dr 3  05 83            ora KB_TEMP     ; OR it with existing temp data
00018Fr 3  85 83            sta KB_TEMP     ; save it
000191r 3  E6 87            inc KB_BIT      ; prepare for next bit
000193r 3  A5 87            lda KB_BIT
000195r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000197r 3  F0 04            beq @next_state_parity
000199r 3  46 83            lsr KB_TEMP     ; if not last bit, shift KB_TEMP right to prepare for next bit
00019Br 3               
00019Br 3  80 43            bra @exit
00019Dr 3               
00019Dr 3               @next_state_parity:
00019Dr 3  A9 02            lda #KB_STATE_PARITY    ;next state is parity
00019Fr 3  85 83            sta KB_STATE
0001A1r 3  80 3D            bra @exit
0001A3r 3               
0001A3r 3               @parity:
0001A3r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
0001A5r 3  85 83            sta KB_STATE
0001A7r 3  80 37            bra @exit
0001A9r 3               
0001A9r 3               @stop:
0001A9r 3  A9 00            lda #KB_STATE_START
0001ABr 3  85 83            sta KB_STATE
0001ADr 3  A5 8B            lda ignore_next
0001AFr 3  D0 42            bne @ignored
0001B1r 3                   ; Save key to character buffer
0001B1r 3  A6 83            ldx KB_TEMP
0001B3r 3  E0 AA            cpx #$AA
0001B5r 3  F0 32            beq @init
0001B7r 3  E0 FA            cpx #$FA
0001B9r 3  F0 2E            beq @init
0001BBr 3  E0 F0            cpx #$F0
0001BDr 3  F0 2E            beq @ignore_next
0001BFr 3  E0 12            cpx #LSHIFT_KEY
0001C1r 3  F0 4A            beq @shift_pressed
0001C3r 3  E0 59            cpx #RSHIFT_KEY
0001C5r 3  F0 46            beq @shift_pressed
0001C7r 3  A5 8C            lda control_keys
0001C9r 3  29 01            and #SHIFT
0001CBr 3  D0 09            bne @shifted
0001CDr 3               @unshifted:
0001CDr 3                   ;stx PORTA
0001CDr 3  BD rr rr         lda ASCIITBL, x
0001D0r 3               
0001D0r 3  C9 1B            cmp #$1B             ; reset if escape pressed
0001D2r 3  F0 12            beq @esc
0001D4r 3  80 03            bra @output
0001D6r 3               @shifted:
0001D6r 3  BD rr rr         lda ASCIITBL+128, x
0001D9r 3               @output:
0001D9r 3  A6 84            ldx KB_BUF_W_PTR
0001DBr 3  9D 01 7B         sta KB_BUF, x
0001DEr 3                   ;sta PORTA
0001DEr 3  E6 84            inc KB_BUF_W_PTR
0001E0r 3               
0001E0r 3               @exit:
0001E0r 3  2C 80 FF         bit PORTB
0001E3r 3  FA               plx
0001E4r 3  68               pla
0001E5r 3  60               rts
0001E6r 3               @esc:
0001E6r 3  4C rr rr         jmp v_reset
0001E9r 3               @init:
0001E9r 3  86 8A            stx ready
0001EBr 3  80 F3            bra @exit
0001EDr 3               
0001EDr 3               @ignore_next:
0001EDr 3  A9 01            lda #1
0001EFr 3  85 8B            sta ignore_next
0001F1r 3  80 ED            bra @exit
0001F3r 3               
0001F3r 3               @ignored:
0001F3r 3  A6 83            ldx KB_TEMP
0001F5r 3  E0 12            cpx #LSHIFT_KEY
0001F7r 3  F0 0A            beq @shift_released
0001F9r 3  E0 59            cpx #RSHIFT_KEY
0001FBr 3  F0 06            beq @shift_released
0001FDr 3  A9 00            lda #0
0001FFr 3  85 8B            sta ignore_next
000201r 3  80 DD            bra @exit
000203r 3               
000203r 3               @shift_released:
000203r 3  A9 00            lda #0
000205r 3  85 8B            sta ignore_next
000207r 3  A9 00            lda #0
000209r 3  85 8C            sta control_keys
00020Br 3  80 D3            bra @exit
00020Dr 3               
00020Dr 3               @shift_pressed:
00020Dr 3  A5 8C            lda control_keys
00020Fr 3  09 01            ora #SHIFT
000211r 3  85 8C            sta control_keys
000213r 3  80 CB            bra @exit
000215r 3               
000215r 3               @sending:
000215r 3                   ; lda #1
000215r 3                   ; sta PORTA
000215r 3                   ; data pin of DDRB should be set as output by prepare_send
000215r 3  A5 83            lda KB_STATE                ; which state ?
000217r 3  C9 01            cmp #KB_STATE_DATA          ; send data bits
000219r 3  F0 0A            beq @sending_data
00021Br 3  C9 02            cmp #KB_STATE_PARITY        ; this is the parity bit
00021Dr 3  F0 2E            beq @sending_parity
00021Fr 3  C9 03            cmp #KB_STATE_STOP          ; stop bit
000221r 3  F0 4E            beq @sending_stop
000223r 3  80 BB            bra @exit
000225r 3               
000225r 3               
000225r 3               @sending_data:
000225r 3                   ; lda #4
000225r 3                   ; sta PORTA
000225r 3  A5 82            lda to_send       ; get the bit of data from memory
000227r 3  29 01            and #$01          ; get only bottom bit
000229r 3  F0 0C            beq @send_zero
00022Br 3               
00022Br 3               @send_one:
00022Br 3  AD 80 FF         lda PORTB
00022Er 3  09 80            ora #$80
000230r 3  8D 80 FF         sta PORTB
000233r 3  E6 86            inc KB_PARITY
000235r 3  80 08            bra @sending_done
000237r 3               @send_zero:
000237r 3  AD 80 FF         lda PORTB
00023Ar 3  29 7F            and #$7F
00023Cr 3  8D 80 FF         sta PORTB
00023Fr 3               @sending_done:
00023Fr 3                   ; lda #2
00023Fr 3                   ; sta PORTA
00023Fr 3  E6 87            inc KB_BIT      ; prepare for next bit
000241r 3  A5 87            lda KB_BIT
000243r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000245r 3  4C rr rr         jmp @next_state_parity
000248r 3  46 82            lsr to_send
00024Ar 3  18               clc
00024Br 3  80 93            bra @exit
00024Dr 3               
00024Dr 3               @sending_parity:
00024Dr 3                   ; lda #5
00024Dr 3                   ; sta PORTA
00024Dr 3  A5 86            lda KB_PARITY
00024Fr 3  29 01            and #$01
000251r 3  F0 0F            beq @odd_parity     ; send zero if odd parity
000253r 3  AD 80 FF         lda PORTB
000256r 3  09 80            ora #$80            ; send one if even
000258r 3  8D 80 FF         sta PORTB
00025Br 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
00025Dr 3  85 83            sta KB_STATE
00025Fr 3  4C rr rr         jmp @exit
000262r 3               @odd_parity:
000262r 3  AD 80 FF         lda PORTB
000265r 3  29 7F            and #$7F
000267r 3  8D 80 FF         sta PORTB
00026Ar 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
00026Cr 3  85 83            sta KB_STATE
00026Er 3  4C rr rr         jmp @exit
000271r 3               
000271r 3               @sending_stop:
000271r 3                   ; lda #6
000271r 3                   ; sta PORTA
000271r 3  A9 00            lda #KB_STATE_START     ; set it back to start in case we are receivin next
000273r 3  85 83            sta KB_STATE
000275r 3  A9 00            lda #0
000277r 3  85 82            sta to_send
000279r 3  85 87            sta KB_BIT
00027Br 3  85 86            sta KB_PARITY
00027Dr 3  AD 82 FF         lda DDRB        ; set PORTB back to input
000280r 3  29 7F            and #$7F
000282r 3  8D 82 FF         sta DDRB
000285r 3  4C rr rr         jmp @exit
000288r 3               
000288r 2               
000288r 2               
000288r 2               
000288r 2               ASCIITBL:
000288r 2  00               .byte $00               ; 00 no key pressed
000289r 2  89               .byte $89               ; 01 F9
00028Ar 2  87               .byte $87               ; 02 relocated F7
00028Br 2  85               .byte $85               ; 03 F5
00028Cr 2  83               .byte $83               ; 04 F3
00028Dr 2  81               .byte $81               ; 05 F1
00028Er 2  82               .byte $82               ; 06 F2
00028Fr 2  8C               .byte $8C               ; 07 F12
000290r 2  00               .byte $00               ; 08
000291r 2  8A               .byte $8A               ; 09 F10
000292r 2  88               .byte $88               ; 0A F8
000293r 2  86               .byte $86               ; 0B F6
000294r 2  84               .byte $84               ; 0C F4
000295r 2  09               .byte $09               ; 0D tab
000296r 2  60               .byte $60               ; 0E `~
000297r 2  8F               .byte $8F               ; 0F relocated Print Screen key
000298r 2  03               .byte $03               ; 10 relocated Pause/Break key
000299r 2  A0               .byte $A0               ; 11 left alt (right alt too)
00029Ar 2  00               .byte $00               ; 12 left shift
00029Br 2  E0               .byte $E0               ; 13 relocated Alt release code
00029Cr 2  00               .byte $00               ; 14 left ctrl (right ctrl too)
00029Dr 2  71               .byte $71               ; 15 qQ
00029Er 2  31               .byte $31               ; 16 1!
00029Fr 2  00               .byte $00               ; 17
0002A0r 2  00               .byte $00               ; 18
0002A1r 2  00               .byte $00               ; 19
0002A2r 2  7A               .byte $7A               ; 1A zZ
0002A3r 2  73               .byte $73               ; 1B sS
0002A4r 2  61               .byte $61               ; 1C aA
0002A5r 2  77               .byte $77               ; 1D wW
0002A6r 2  32               .byte $32               ; 1E 2@
0002A7r 2  A1               .byte $A1               ; 1F Windows 98 menu key (left side)
0002A8r 2  02               .byte $02               ; 20 relocated ctrl-break key
0002A9r 2  63               .byte $63               ; 21 cC
0002AAr 2  78               .byte $78               ; 22 xX
0002ABr 2  64               .byte $64               ; 23 dD
0002ACr 2  65               .byte $65               ; 24 eE
0002ADr 2  34               .byte $34               ; 25 4$
0002AEr 2  33               .byte $33               ; 26 3#
0002AFr 2  A2               .byte $A2               ; 27 Windows 98 menu key (right side)
0002B0r 2  00               .byte $00               ; 28
0002B1r 2  20               .byte $20               ; 29 space
0002B2r 2  76               .byte $76               ; 2A vV
0002B3r 2  66               .byte $66               ; 2B fF
0002B4r 2  74               .byte $74               ; 2C tT
0002B5r 2  72               .byte $72               ; 2D rR
0002B6r 2  35               .byte $35               ; 2E 5%
0002B7r 2  A3               .byte $A3               ; 2F Windows 98 option key (right click, right side)
0002B8r 2  00               .byte $00               ; 30
0002B9r 2  6E               .byte $6E               ; 31 nN
0002BAr 2  62               .byte $62               ; 32 bB
0002BBr 2  68               .byte $68               ; 33 hH
0002BCr 2  67               .byte $67               ; 34 gG
0002BDr 2  79               .byte $79               ; 35 yY
0002BEr 2  36               .byte $36               ; 36 6^
0002BFr 2  00               .byte $00               ; 37
0002C0r 2  00               .byte $00               ; 38
0002C1r 2  00               .byte $00               ; 39
0002C2r 2  6D               .byte $6D               ; 3A mM
0002C3r 2  6A               .byte $6A               ; 3B jJ
0002C4r 2  75               .byte $75               ; 3C uU
0002C5r 2  37               .byte $37               ; 3D 7&
0002C6r 2  38               .byte $38               ; 3E 8*
0002C7r 2  00               .byte $00               ; 3F
0002C8r 2  00               .byte $00               ; 40
0002C9r 2  2C               .byte $2C               ; 41 ,<
0002CAr 2  6B               .byte $6B               ; 42 kK
0002CBr 2  69               .byte $69               ; 43 iI
0002CCr 2  6F               .byte $6F               ; 44 oO
0002CDr 2  30               .byte $30               ; 45 0)
0002CEr 2  39               .byte $39               ; 46 9(
0002CFr 2  00               .byte $00               ; 47
0002D0r 2  00               .byte $00               ; 48
0002D1r 2  2E               .byte $2E               ; 49 .>
0002D2r 2  2F               .byte $2F               ; 4A /?
0002D3r 2  6C               .byte $6C               ; 4B lL
0002D4r 2  3B               .byte $3B               ; 4C ;:
0002D5r 2  70               .byte $70               ; 4D pP
0002D6r 2  2D               .byte $2D               ; 4E -_
0002D7r 2  00               .byte $00               ; 4F
0002D8r 2  00               .byte $00               ; 50
0002D9r 2  00               .byte $00               ; 51
0002DAr 2  27               .byte $27               ; 52 '"
0002DBr 2  00               .byte $00               ; 53
0002DCr 2  5B               .byte $5B               ; 54 [{
0002DDr 2  3D               .byte $3D               ; 55 =+
0002DEr 2  00               .byte $00               ; 56
0002DFr 2  00               .byte $00               ; 57
0002E0r 2  00               .byte $00               ; 58 caps
0002E1r 2  00               .byte $00               ; 59 r shift
0002E2r 2  0D               .byte $0D               ; 5A <Enter>
0002E3r 2  5D               .byte $5D               ; 5B ]}
0002E4r 2  00               .byte $00               ; 5C
0002E5r 2  5C               .byte $5C               ; 5D \|
0002E6r 2  00               .byte $00               ; 5E
0002E7r 2  00               .byte $00               ; 5F
0002E8r 2  00               .byte $00               ; 60
0002E9r 2  00               .byte $00               ; 61
0002EAr 2  00               .byte $00               ; 62
0002EBr 2  00               .byte $00               ; 63
0002ECr 2  00               .byte $00               ; 64
0002EDr 2  00               .byte $00               ; 65
0002EEr 2  08               .byte $08               ; 66 bkspace
0002EFr 2  00               .byte $00               ; 67
0002F0r 2  00               .byte $00               ; 68
0002F1r 2  31               .byte $31               ; 69 kp 1
0002F2r 2  2F               .byte $2f               ; 6A kp / converted from E04A in code
0002F3r 2  34               .byte $34               ; 6B kp 4
0002F4r 2  37               .byte $37               ; 6C kp 7
0002F5r 2  00               .byte $00               ; 6D
0002F6r 2  00               .byte $00               ; 6E
0002F7r 2  00               .byte $00               ; 6F
0002F8r 2  30               .byte $30               ; 70 kp 0
0002F9r 2  2E               .byte $2E               ; 71 kp .
0002FAr 2  32               .byte $32               ; 72 kp 2
0002FBr 2  35               .byte $35               ; 73 kp 5
0002FCr 2  36               .byte $36               ; 74 kp 6
0002FDr 2  38               .byte $38               ; 75 kp 8
0002FEr 2  1B               .byte $1B               ; 76 esc
0002FFr 2  00               .byte $00               ; 77 num lock
000300r 2  8B               .byte $8B               ; 78 F11
000301r 2  2B               .byte $2B               ; 79 kp +
000302r 2  33               .byte $33               ; 7A kp 3
000303r 2  2D               .byte $2D               ; 7B kp -
000304r 2  2A               .byte $2A               ; 7C kp *
000305r 2  39               .byte $39               ; 7D kp 9
000306r 2  8D               .byte $8D               ; 7E scroll lock
000307r 2  00               .byte $00               ; 7F
000308r 2                   ;
000308r 2                   ; Table for shifted scancodes
000308r 2                   ;
000308r 2  00               .byte $00               ; 80
000309r 2  C9               .byte $C9               ; 81 F9
00030Ar 2  C7               .byte $C7               ; 82 relocated F7
00030Br 2  C5               .byte $C5               ; 83 F5 (F7 actual scancode=83)
00030Cr 2  C3               .byte $C3               ; 84 F3
00030Dr 2  C1               .byte $C1               ; 85 F1
00030Er 2  C2               .byte $C2               ; 86 F2
00030Fr 2  CC               .byte $CC               ; 87 F12
000310r 2  00               .byte $00               ; 88
000311r 2  CA               .byte $CA               ; 89 F10
000312r 2  C8               .byte $C8               ; 8A F8
000313r 2  C6               .byte $C6               ; 8B F6
000314r 2  C4               .byte $C4               ; 8C F4
000315r 2  09               .byte $09               ; 8D tab
000316r 2  7E               .byte $7E               ; 8E `~
000317r 2  CF               .byte $CF               ; 8F relocated Print Screen key
000318r 2  03               .byte $03               ; 90 relocated Pause/Break key
000319r 2  A0               .byte $A0               ; 91 left alt (right alt)
00031Ar 2  00               .byte $00               ; 92 left shift
00031Br 2  E0               .byte $E0               ; 93 relocated Alt release code
00031Cr 2  00               .byte $00               ; 94 left ctrl (and right ctrl)
00031Dr 2  51               .byte $51               ; 95 qQ
00031Er 2  21               .byte $21               ; 96 1!
00031Fr 2  00               .byte $00               ; 97
000320r 2  00               .byte $00               ; 98
000321r 2  00               .byte $00               ; 99
000322r 2  5A               .byte $5A               ; 9A zZ
000323r 2  53               .byte $53               ; 9B sS
000324r 2  41               .byte $41               ; 9C aA
000325r 2  57               .byte $57               ; 9D wW
000326r 2  40               .byte $40               ; 9E 2@
000327r 2  E1               .byte $E1               ; 9F Windows 98 menu key (left side)
000328r 2  02               .byte $02               ; A0 relocated ctrl-break key
000329r 2  43               .byte $43               ; A1 cC
00032Ar 2  58               .byte $58               ; A2 xX
00032Br 2  44               .byte $44               ; A3 dD
00032Cr 2  45               .byte $45               ; A4 eE
00032Dr 2  24               .byte $24               ; A5 4$
00032Er 2  23               .byte $23               ; A6 3#
00032Fr 2  E2               .byte $E2               ; A7 Windows 98 menu key (right side)
000330r 2  00               .byte $00               ; A8
000331r 2  20               .byte $20               ; A9 space
000332r 2  56               .byte $56               ; AA vV
000333r 2  46               .byte $46               ; AB fF
000334r 2  54               .byte $54               ; AC tT
000335r 2  52               .byte $52               ; AD rR
000336r 2  25               .byte $25               ; AE 5%
000337r 2  E3               .byte $E3               ; AF Windows 98 option key (right click, right side)
000338r 2  00               .byte $00               ; B0
000339r 2  4E               .byte $4E               ; B1 nN
00033Ar 2  42               .byte $42               ; B2 bB
00033Br 2  48               .byte $48               ; B3 hH
00033Cr 2  47               .byte $47               ; B4 gG
00033Dr 2  59               .byte $59               ; B5 yY
00033Er 2  5E               .byte $5E               ; B6 6^
00033Fr 2  00               .byte $00               ; B7
000340r 2  00               .byte $00               ; B8
000341r 2  00               .byte $00               ; B9
000342r 2  4D               .byte $4D               ; BA mM
000343r 2  4A               .byte $4A               ; BB jJ
000344r 2  55               .byte $55               ; BC uU
000345r 2  26               .byte $26               ; BD 7&
000346r 2  2A               .byte $2A               ; BE 8*
000347r 2  00               .byte $00               ; BF
000348r 2  00               .byte $00               ; C0
000349r 2  3C               .byte $3C               ; C1 ,<
00034Ar 2  4B               .byte $4B               ; C2 kK
00034Br 2  49               .byte $49               ; C3 iI
00034Cr 2  4F               .byte $4F               ; C4 oO
00034Dr 2  29               .byte $29               ; C5 0)
00034Er 2  28               .byte $28               ; C6 9(
00034Fr 2  00               .byte $00               ; C7
000350r 2  00               .byte $00               ; C8
000351r 2  3E               .byte $3E               ; C9 .>
000352r 2  3F               .byte $3F               ; CA /?
000353r 2  4C               .byte $4C               ; CB lL
000354r 2  3A               .byte $3A               ; CC ;:
000355r 2  50               .byte $50               ; CD pP
000356r 2  5F               .byte $5F               ; CE -_
000357r 2  00               .byte $00               ; CF
000358r 2  00               .byte $00               ; D0
000359r 2  00               .byte $00               ; D1
00035Ar 2  22               .byte $22               ; D2 '"
00035Br 2  00               .byte $00               ; D3
00035Cr 2  7B               .byte $7B               ; D4 [{
00035Dr 2  2B               .byte $2B               ; D5 =+
00035Er 2  00               .byte $00               ; D6
00035Fr 2  00               .byte $00               ; D7
000360r 2  00               .byte $00               ; D8 caps
000361r 2  00               .byte $00               ; D9 r shift
000362r 2  0D               .byte $0D               ; DA <Enter>
000363r 2  7D               .byte $7D               ; DB ]}
000364r 2  00               .byte $00               ; DC
000365r 2  7C               .byte $7C               ; DD \|
000366r 2  00               .byte $00               ; DE
000367r 2  00               .byte $00               ; DF
000368r 2  00               .byte $00               ; E0
000369r 2  00               .byte $00               ; E1
00036Ar 2  00               .byte $00               ; E2
00036Br 2  00               .byte $00               ; E3
00036Cr 2  00               .byte $00               ; E4
00036Dr 2  00               .byte $00               ; E5
00036Er 2  08               .byte $08               ; E6 bkspace
00036Fr 2  00               .byte $00               ; E7
000370r 2  00               .byte $00               ; E8
000371r 2  91               .byte $91               ; E9 kp 1
000372r 2  2F               .byte $2f               ; EA kp / converted from E04A in code
000373r 2  94               .byte $94               ; EB kp 4
000374r 2  97               .byte $97               ; EC kp 7
000375r 2  00               .byte $00               ; ED
000376r 2  00               .byte $00               ; EE
000377r 2  00               .byte $00               ; EF
000378r 2  90               .byte $90               ; F0 kp 0
000379r 2  7F               .byte $7F               ; F1 kp .
00037Ar 2  92               .byte $92               ; F2 kp 2
00037Br 2  95               .byte $95               ; F3 kp 5
00037Cr 2  96               .byte $96               ; F4 kp 6
00037Dr 2  98               .byte $98               ; F5 kp 8
00037Er 2  1B               .byte $1B               ; F6 esc
00037Fr 2  00               .byte $00               ; F7 num lock
000380r 2  CB               .byte $CB               ; F8 F11
000381r 2  2B               .byte $2B               ; F9 kp +
000382r 2  93               .byte $93               ; FA kp 3
000383r 2  2D               .byte $2D               ; FB kp -
000384r 2  2A               .byte $2A               ; FC kp *
000385r 2  99               .byte $99               ; FD kp 9
000386r 2  CD               .byte $CD               ; FE scroll lock
000387r 2               
000387r 2               
000387r 2               
000387r 2               
000387r 1               
000387r 1               .include "../../drivers/timer.s"
000387r 2               
000387r 2               
000387r 2               COUNTER = CLOCK_SPEED/400        ; n/s
000387r 2               
000387r 2               
000387r 2               timer_init:
000387r 2  AD 8E FF         lda IER
00038Ar 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
00038Cr 2  8D 8E FF         sta IER
00038Fr 2  A9 40            lda #$40        ; timer one free run mode
000391r 2  8D 8B FF         sta ACR
000394r 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
000396r 2  8D 84 FF         sta T1CL
000399r 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
00039Br 2               
00039Br 2  8D 85 FF         sta T1CH
00039Er 2  A9 00            lda #0              ; reset time variable
0003A0r 2  85 7A            sta time
0003A2r 2  85 7B            sta time+1
0003A4r 2  85 7C            sta time+2
0003A6r 2  85 7D            sta time+3
0003A8r 2  58               cli
0003A9r 2  60               rts
0003AAr 2               
0003AAr 2               
0003AAr 2               timer_irq:
0003AAr 2  E6 7A            inc time
0003ACr 2  F0 04            beq @inc1
0003AEr 2               @exit1:
0003AEr 2                   ; this resets the PS/2 temp variables
0003AEr 2  20 rr rr         jsr reset_ps2
0003B1r 2  60               rts
0003B2r 2               @inc1:
0003B2r 2  E6 7B            inc time+1
0003B4r 2  F0 02            beq @inc2
0003B6r 2  80 F6            bra @exit1
0003B8r 2               @inc2:
0003B8r 2  E6 7C            inc time+2
0003BAr 2  F0 02            beq @inc3
0003BCr 2  80 F0            bra @exit1
0003BEr 2               @inc3:
0003BEr 2  E6 7D            inc time+3
0003C0r 2  80 EC            bra @exit1
0003C2r 2               
0003C2r 1               .include "../../drivers/lcd.s"
0003C2r 2               
0003C2r 2               ; initialize the LCD in 8 bit mode
0003C2r 2               lcd_init:
0003C2r 2  20 rr rr         jsr buf_clr
0003C5r 2  A9 00            lda #0
0003C7r 2  85 94            sta lcd_absent
0003C9r 2  85 90            sta LCD_BUF_W_PTR
0003CBr 2  85 91            sta LCD_BUF_R_PTR
0003CDr 2  85 95            sta lcd_pos
0003CFr 2               
0003CFr 2               
0003CFr 2  A0 FF            ldy #$FF
0003D1r 2  20 rr rr         jsr delay
0003D4r 2               
0003D4r 2  A9 38            LDA #$38            ;function set: 8 bit
0003D6r 2  20 rr rr         jsr lcd_inst
0003D9r 2               
0003D9r 2               
0003D9r 2  A0 FF            ldy #$FF
0003DBr 2  20 rr rr         jsr delay
0003DEr 2               
0003DEr 2  A9 0F            LDA #$0F            ;display on, cursor on, blink on
0003E0r 2  20 rr rr         jsr lcd_inst
0003E3r 2               
0003E3r 2                   ;entry mode set
0003E3r 2  A9 06            LDA #$06
0003E5r 2  20 rr rr         jsr lcd_inst
0003E8r 2               
0003E8r 2                   ;clear display
0003E8r 2  A9 01            LDA #$01
0003EAr 2  20 rr rr         jsr lcd_inst
0003EDr 2               
0003EDr 2  A0 FF            ldy #$ff            ; wait a while
0003EFr 2  20 rr rr         jsr delay
0003F2r 2                   ;set dram address to start of screen
0003F2r 2  A9 80            LDA #$80
0003F4r 2  20 rr rr         jsr lcd_inst
0003F7r 2               
0003F7r 2  A0 FF            ldy #$ff            ; wait a while
0003F9r 2  20 rr rr         jsr delay
0003FCr 2               
0003FCr 2               
0003FCr 2  60               RTS
0003FDr 2               
0003FDr 2               ; Send an instruction in 8 bit mode
0003FDr 2               lcd_inst:
0003FDr 2  5A               phy
0003FEr 2  8D D1 FF         sta LCD_ADDR_ENABLED
000401r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
000403r 2  20 rr rr         jsr delay_short
000406r 2  8D D0 FF         sta LCD_ADDR_DISABLED
000409r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
00040Br 2  20 rr rr         jsr delay_short
00040Er 2  7A               ply
00040Fr 2  60               rts
000410r 2               
000410r 2               lcd_send:
000410r 2  8D D3 FF         sta LCD_DATA_ENABLED
000413r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
000415r 2  20 rr rr         jsr delay_short
000418r 2  8D D2 FF         sta LCD_DATA_DISABLED
00041Br 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
00041Dr 2  20 rr rr         jsr delay_short
000420r 2  60               rts
000421r 2               
000421r 2               ; Sends the character in A to the display
000421r 2               lcd_print:               ; 8 bit data in A
000421r 2  5A               phy
000422r 2  DA               phx
000423r 2  48               pha
000424r 2  C9 0A            cmp #$0A
000426r 2  F0 67            beq @next_line
000428r 2  C9 0D            cmp #$0D
00042Ar 2  F0 63            beq @next_line
00042Cr 2  C9 08            cmp #$08            ;backspace
00042Er 2  F0 1F            beq @backspace
000430r 2               
000430r 2  20 rr rr         jsr lcd_send
000433r 2  A6 95            ldx lcd_pos
000435r 2  9D 82 7A         sta LCD_BUF, x
000438r 2               
000438r 2  E8               inx
000439r 2                   ; Check at which position we are and change line if necessary
000439r 2  86 95            stx lcd_pos
00043Br 2               
00043Br 2  E0 14            cpx #20
00043Dr 2  F0 2A            beq @line_2
00043Fr 2  E0 28            cpx #40
000441r 2  F0 31            beq @line_3
000443r 2  E0 3C            cpx #60
000445r 2  F0 38            beq @line_4
000447r 2  E0 50            cpx #80
000449r 2  F0 3F            beq @clr
00044Br 2               
00044Br 2               @continue:
00044Br 2  68               pla
00044Cr 2  FA               plx
00044Dr 2  7A               ply
00044Er 2  60               rts
00044Fr 2               
00044Fr 2               ; LCD adressing http://web.alfredstate.edu/faculty/weimandn/lcd/lcd_addressing/lcd_addressing_index.html
00044Fr 2               @backspace:
00044Fr 2  A9 10            lda #$10            ; shift cursor left
000451r 2  20 rr rr         jsr lcd_inst
000454r 2  A9 20            lda #$20            ; print a space to erase previous char
000456r 2  20 rr rr         jsr lcd_send
000459r 2               
000459r 2  A9 10            lda #$10            ; shift cursor left
00045Br 2  20 rr rr         jsr lcd_inst
00045Er 2  C6 95            dec lcd_pos
000460r 2  A6 95            ldx lcd_pos         ; save in buffer
000462r 2  A9 20            lda #$20
000464r 2  9D 82 7A         sta LCD_BUF,x
000467r 2  80 E2            bra @continue
000469r 2               @line_2:
000469r 2  A9 14            lda #20
00046Br 2  85 95            sta lcd_pos
00046Dr 2  A9 C0            lda #$C0
00046Fr 2  20 rr rr         jsr lcd_inst
000472r 2  80 D7            bra @continue
000474r 2               
000474r 2               @line_3:
000474r 2  A9 28            lda #40
000476r 2  85 95            sta lcd_pos
000478r 2  A9 94            lda #$94
00047Ar 2  20 rr rr         jsr lcd_inst
00047Dr 2  80 CC            bra @continue
00047Fr 2               
00047Fr 2               @line_4:
00047Fr 2  A9 3C            lda #60
000481r 2  85 95            sta lcd_pos
000483r 2  A9 D4            lda #$D4
000485r 2  20 rr rr         jsr lcd_inst
000488r 2  80 C1            bra @continue
00048Ar 2               @clr:
00048Ar 2                   ; lda #0
00048Ar 2                   ; sta lcd_pos
00048Ar 2                   ; lda #$80
00048Ar 2                   ; jsr lcd_inst
00048Ar 2  20 rr rr         jsr lcd_scroll_up
00048Dr 2  80 BC            bra @continue
00048Fr 2               
00048Fr 2               @next_line:
00048Fr 2  A6 95            ldx lcd_pos            ;get current position
000491r 2  E0 50            cpx #80
000493r 2  F0 F5            beq @clr
000495r 2  E0 3C            cpx #60
000497r 2  F0 E6            beq @line_4
000499r 2  E0 28            cpx #40
00049Br 2  F0 D7            beq @line_3
00049Dr 2  E0 14            cpx #20
00049Fr 2  F0 C8            beq @line_2
0004A1r 2  E8               inx
0004A2r 2  86 95            stx lcd_pos
0004A4r 2  A9 20            lda #$20
0004A6r 2  20 rr rr         jsr lcd_send
0004A9r 2  9D 82 7A         sta LCD_BUF, x
0004ACr 2  80 E1            bra @next_line
0004AEr 2               
0004AEr 2               lcd_scroll_up:
0004AEr 2  48               pha                     ; save registers
0004AFr 2  5A               phy
0004B0r 2  DA               phx
0004B1r 2  A9 80            lda #$80                ; set LCD address to start
0004B3r 2  20 rr rr         jsr lcd_inst
0004B6r 2               
0004B6r 2  A2 14            ldx #20                 ; start getting characters at the start of the second line
0004B8r 2               @scroll_loop:
0004B8r 2  BD 82 7A         lda LCD_BUF, X          ; load from buffer
0004BBr 2  20 rr rr         jsr lcd_send            ; send to display
0004BEr 2  A8               tay                     ; save current character in Y
0004BFr 2  E0 4F            cpx #79                 ; update LCD address if necessary
0004C1r 2  F0 4A            beq @scline_4
0004C3r 2  E0 3B            cpx #59
0004C5r 2  F0 3F            beq @scline_3
0004C7r 2  E0 27            cpx #39
0004C9r 2  F0 34            beq @scline_2
0004CBr 2               @sccontinue:                ; return from updating LCD address
0004CBr 2  8A               txa                     ; copy X to A to be able to subtract from it
0004CCr 2  38               sec                     ; set carry before subtraction
0004CDr 2  E9 14            sbc #20                 ; subtract 20 to get where to put this character
0004CFr 2  AA               tax                     ; put the result in X
0004D0r 2  98               tya                     ; restore character from Y
0004D1r 2  9D 82 7A         sta LCD_BUF, X          ; store char in buffer
0004D4r 2  8A               txa                     ; copy X to A to be able to add to it
0004D5r 2  18               clc
0004D6r 2  69 14            adc #20                 ; add 20 to restore X
0004D8r 2  AA               tax                     ; put the result back in X
0004D9r 2  E8               inx                     ; increment X to prepare to get next char
0004DAr 2  E0 50            cpx #80                 ; if not at end of buffer
0004DCr 2  90 DA            bcc @scroll_loop        ; do next char
0004DEr 2                   ; fill the last line with spaces
0004DEr 2  A9 D4            lda #$D4                ; set address to last line
0004E0r 2  20 rr rr         jsr lcd_inst
0004E3r 2  A9 20            lda #$20
0004E5r 2  A2 3C            ldx #60
0004E7r 2               @last_line_loop:
0004E7r 2  9D 82 7A         sta LCD_BUF, x
0004EAr 2  20 rr rr         jsr lcd_send
0004EDr 2  E8               inx
0004EEr 2  E0 50            cpx #80                 ; if not at end of buffer
0004F0r 2  90 F5            bcc @last_line_loop     ; do next char
0004F2r 2               
0004F2r 2                   ;finally, place the cursor at the start of the last line
0004F2r 2  A9 3C            lda #60
0004F4r 2  85 95            sta lcd_pos
0004F6r 2  A9 D4            lda #$D4
0004F8r 2  20 rr rr         jsr lcd_inst
0004FBr 2  FA               plx                     ; restore everything as it was
0004FCr 2  7A               ply
0004FDr 2  68               pla
0004FEr 2  60               rts
0004FFr 2               
0004FFr 2               @scline_2:
0004FFr 2  A9 C0            lda #$C0
000501r 2  20 rr rr         jsr lcd_inst
000504r 2  80 C5            bra @sccontinue
000506r 2               
000506r 2               @scline_3:
000506r 2  A9 94            lda #$94
000508r 2  20 rr rr         jsr lcd_inst
00050Br 2  80 BE            bra @sccontinue
00050Dr 2               
00050Dr 2               @scline_4:
00050Dr 2  A9 D4            lda #$D4
00050Fr 2  20 rr rr         jsr lcd_inst
000512r 2  80 B7            bra @sccontinue
000514r 2               
000514r 2               lcd_clear:
000514r 2  48               PHA
000515r 2                   ;clear display
000515r 2  A9 01            LDA #$01
000517r 2  20 rr rr         jsr lcd_inst
00051Ar 2                   ;set dram address
00051Ar 2  A9 80            LDA #$80
00051Cr 2  20 rr rr         jsr lcd_inst
00051Fr 2  68               PLA
000520r 2  60               RTS
000521r 2               
000521r 2               
000521r 2               buf_clr:
000521r 2  48               pha
000522r 2  DA               phx
000523r 2  A2 80            ldx #$80
000525r 2  A9 20            lda #$20
000527r 2               buf_clr_loop:
000527r 2  9D 82 7A         sta LCD_BUF,X
00052Ar 2  CA               dex
00052Br 2  D0 FA            bne buf_clr_loop
00052Dr 2  FA               plx
00052Er 2  68               pla
00052Fr 2  60               rts
000530r 2               
000530r 1               .include "../../drivers/vga.s"
000530r 2               video_init:
000530r 2                   ; set colors
000530r 2  A9 05            lda #$05
000532r 2  8D B0 FF         sta VIDEO_CTRL
000535r 2  A9 1E            lda #$1E
000537r 2  8D B1 FF         sta VIDEO_ADDR_LOW
00053Ar 2  A9 FF            lda #$FF
00053Cr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
00053Fr 2  A9 00            lda #$00
000541r 2  8D B3 FF         sta VIDEO_DATA
000544r 2  A9 F0            lda #$F0
000546r 2  8D B3 FF         sta VIDEO_DATA
000549r 2  A9 00            lda #0
00054Br 2  8D B4 FF         sta VIDEO_IEN
00054Er 2  8D B1 FF         sta VIDEO_ADDR_LOW
000551r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
000554r 2  20 rr rr         jsr vga_clear
000557r 2  60               rts
000558r 2               
000558r 2               char_out:
000558r 2  48               pha
000559r 2  DA               phx
00055Ar 2  5A               phy
00055Br 2  C9 0D            cmp #$0D
00055Dr 2  F0 34            beq next_line
00055Fr 2  C9 0A            cmp #$0A
000561r 2  F0 30            beq next_line
000563r 2  C9 08            cmp #$08
000565r 2  F0 0F            beq backspace
000567r 2  8D B3 FF         sta VIDEO_DATA
00056Ar 2  E6 93            inc char
00056Cr 2  A6 93            ldx char
00056Er 2  E0 64            cpx #VIDEO_HIRES_HCHARS
000570r 2  F0 21            beq next_line
000572r 2               
000572r 2               char_out_exit:
000572r 2  7A               ply
000573r 2  FA               plx
000574r 2  68               pla
000575r 2  60               rts
000576r 2               
000576r 2               backspace:
000576r 2  C6 93            dec char
000578r 2  A9 85            lda #$85        ; make increment negative
00057Ar 2  8D B0 FF         sta VIDEO_CTRL
00057Dr 2  A9 20            lda #$20
00057Fr 2  8D B3 FF         sta VIDEO_DATA  ;write a space to go back one
000582r 2  A9 01            lda #$01        ; make increment zero
000584r 2  8D B0 FF         sta VIDEO_CTRL
000587r 2  A9 20            lda #$20
000589r 2  8D B3 FF         sta VIDEO_DATA  ; replace with a space
00058Cr 2  A9 05            lda #$05        ; make increment positive again
00058Er 2  8D B0 FF         sta VIDEO_CTRL
000591r 2  80 DF            bra char_out_exit
000593r 2               
000593r 2               next_line:
000593r 2  E6 92            inc line
000595r 2  64 93            stz char
000597r 2  A6 92            ldx line
000599r 2  E0 4B            cpx #VIDEO_HIRES_VCHARS
00059Br 2  90 05            bcc nl
00059Dr 2  20 rr rr         jsr scroll_up
0005A0r 2  80 D0            bra char_out_exit
0005A2r 2               nl:
0005A2r 2  BD rr rr         lda mult_table_high,x
0005A5r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0005A8r 2  BD rr rr         lda mult_table_low,x
0005ABr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0005AEr 2  80 C2            bra char_out_exit
0005B0r 2               
0005B0r 2               scroll_up:
0005B0r 2  20 rr rr         jsr vga_clear
0005B3r 2  60               rts
0005B4r 2  48               pha
0005B5r 2                   ; lda #1
0005B5r 2                   ; sta VIDEO_VSCROLL
0005B5r 2                   ; lda mult_table_high+60
0005B5r 2                   ; sta VIDEO_ADDR_HIGH
0005B5r 2                   ; lda mult_table_low+60
0005B5r 2                   ; sta VIDEO_ADDR_LOW
0005B5r 2  A9 00            lda #0
0005B7r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0005BAr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0005BDr 2  85 93            sta char
0005BFr 2  85 92            sta line
0005C1r 2  68               pla
0005C2r 2  60               rts
0005C3r 2               
0005C3r 2               vga_clear:
0005C3r 2  48               pha
0005C4r 2  DA               phx
0005C5r 2  5A               phy
0005C6r 2  A9 00            lda #0
0005C8r 2  85 92            sta line
0005CAr 2                   ;lda #$05                ; monochrome chars, increment by one
0005CAr 2                   ;sta VIDEO_CTRL
0005CAr 2               
0005CAr 2  A9 00            lda #$00                ; set start address
0005CCr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0005CFr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0005D2r 2               
0005D2r 2  A9 20            lda #$20
0005D4r 2  A0 64            ldy #VIDEO_HIRES_HCHARS
0005D6r 2               outer:
0005D6r 2  A2 4B            ldx #VIDEO_HIRES_VCHARS
0005D8r 2               inner:
0005D8r 2  8D B3 FF         sta VIDEO_DATA
0005DBr 2               
0005DBr 2  CA               dex
0005DCr 2  D0 FA            bne inner
0005DEr 2  88               dey
0005DFr 2  D0 F5            bne outer
0005E1r 2               
0005E1r 2  A9 00            lda #0
0005E3r 2  85 92            sta line
0005E5r 2  85 93            sta char
0005E7r 2  A9 00            lda #$00
0005E9r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0005ECr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0005EFr 2  7A               ply
0005F0r 2  FA               plx
0005F1r 2  68               pla
0005F2r 2  60               rts
0005F3r 2               
0005F3r 2               
0005F3r 2               
0005F3r 2               ; These are precalculated multiplications for ADDR_LOW and ADDR_HIGH depending on the line number
0005F3r 2               mult_table_high:
0005F3r 2  00               .byte $00
0005F4r 2  02               .byte $02
0005F5r 2  05               .byte $05
0005F6r 2  07               .byte $07
0005F7r 2  0A               .byte $0a
0005F8r 2  0C               .byte $0c
0005F9r 2  0F               .byte $0f
0005FAr 2  11               .byte $11
0005FBr 2  14               .byte $14
0005FCr 2  16               .byte $16
0005FDr 2  19               .byte $19
0005FEr 2  1B               .byte $1b
0005FFr 2  1E               .byte $1e
000600r 2  20               .byte $20
000601r 2  23               .byte $23
000602r 2  25               .byte $25
000603r 2  28               .byte $28
000604r 2  2A               .byte $2a
000605r 2  2D               .byte $2d
000606r 2  2F               .byte $2f
000607r 2  32               .byte $32
000608r 2  34               .byte $34
000609r 2  37               .byte $37
00060Ar 2  39               .byte $39
00060Br 2  3C               .byte $3c
00060Cr 2  3E               .byte $3e
00060Dr 2  41               .byte $41
00060Er 2  43               .byte $43
00060Fr 2  46               .byte $46
000610r 2  48               .byte $48
000611r 2  4B               .byte $4b
000612r 2  4D               .byte $4d
000613r 2  50               .byte $50
000614r 2  52               .byte $52
000615r 2  55               .byte $55
000616r 2  57               .byte $57
000617r 2  5A               .byte $5a
000618r 2  5C               .byte $5c
000619r 2  5F               .byte $5f
00061Ar 2  61               .byte $61
00061Br 2  64               .byte $64
00061Cr 2  66               .byte $66
00061Dr 2  69               .byte $69
00061Er 2  6B               .byte $6b
00061Fr 2  6E               .byte $6e
000620r 2  70               .byte $70
000621r 2  73               .byte $73
000622r 2  75               .byte $75
000623r 2  78               .byte $78
000624r 2  7A               .byte $7a
000625r 2  7D               .byte $7d
000626r 2  7F               .byte $7f
000627r 2  82               .byte $82
000628r 2  84               .byte $84
000629r 2  87               .byte $87
00062Ar 2  89               .byte $89
00062Br 2  8C               .byte $8c
00062Cr 2  8E               .byte $8e
00062Dr 2  91               .byte $91
00062Er 2  93               .byte $93
00062Fr 2  96               .byte $96
000630r 2               
000630r 2               mult_table_low:
000630r 2  00               .byte $00
000631r 2  10               .byte $10
000632r 2  00               .byte $00
000633r 2  10               .byte $10
000634r 2  00               .byte $00
000635r 2  10               .byte $10
000636r 2  00               .byte $00
000637r 2  10               .byte $10
000638r 2  00               .byte $00
000639r 2  10               .byte $10
00063Ar 2  00               .byte $00
00063Br 2  10               .byte $10
00063Cr 2  00               .byte $00
00063Dr 2  10               .byte $10
00063Er 2  00               .byte $00
00063Fr 2  10               .byte $10
000640r 2  00               .byte $00
000641r 2  10               .byte $10
000642r 2  00               .byte $00
000643r 2  10               .byte $10
000644r 2  00               .byte $00
000645r 2  10               .byte $10
000646r 2  00               .byte $00
000647r 2  10               .byte $10
000648r 2  00               .byte $00
000649r 2  10               .byte $10
00064Ar 2  00               .byte $00
00064Br 2  10               .byte $10
00064Cr 2  00               .byte $00
00064Dr 2  10               .byte $10
00064Er 2  00               .byte $00
00064Fr 2  10               .byte $10
000650r 2  00               .byte $00
000651r 2  10               .byte $10
000652r 2  00               .byte $00
000653r 2  10               .byte $10
000654r 2  00               .byte $00
000655r 2  10               .byte $10
000656r 2  00               .byte $00
000657r 2  10               .byte $10
000658r 2  00               .byte $00
000659r 2  10               .byte $10
00065Ar 2  00               .byte $00
00065Br 2  10               .byte $10
00065Cr 2  00               .byte $00
00065Dr 2  10               .byte $10
00065Er 2  00               .byte $00
00065Fr 2  10               .byte $10
000660r 2  00               .byte $00
000661r 2  10               .byte $10
000662r 2  00               .byte $00
000663r 2  10               .byte $10
000664r 2  00               .byte $00
000665r 2  10               .byte $10
000666r 2  00               .byte $00
000667r 2  10               .byte $10
000668r 2  00               .byte $00
000669r 2  10               .byte $10
00066Ar 2  00               .byte $00
00066Br 2  10               .byte $10
00066Cr 2  00               .byte $00
00066Dr 2               
00066Dr 1               .include "../../drivers/spi.s"
00066Dr 2               spi_init:
00066Dr 2  AD 80 FF         lda PORTB               ; load current port B
000670r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
000672r 2  09 40            ora #CONF               ; set CONF high
000674r 2  8D 80 FF         sta PORTB               ; save to PORTB
000677r 2  AD 82 FF         lda DDRB                ; get current direction register
00067Ar 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
00067Cr 2  29 EF            and #($FF^MISO)                 ; set MISO as input
00067Er 2  8D 82 FF         sta DDRB
000681r 2               
000681r 2  60               rts
000682r 2               
000682r 2               spi_select:
000682r 2                   ; selected slave in A
000682r 2  29 07            and #SS                 ; mask slave select bits
000684r 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
000687r 2  85 99            sta spi_slave
000689r 2  5A               phy
00068Ar 2  A0 01            ldy #$1
00068Cr 2  20 rr rr         jsr delay_short         ; slight delay
00068Fr 2  09 40            ora #CONF               ; set CONF high to latch address
000691r 2  8D 80 FF         sta PORTB               ; save to PORTB
000694r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
000695r 2  60               rts
000696r 2               
000696r 2               spi_clk_toggle:
000696r 2  60               rts
000697r 2               
000697r 2               spi_transceive:
000697r 2                   ; send data in A, received data will be in A
000697r 2  5A               phy
000698r 2                   ; save data in RAM
000698r 2  85 97            sta spi_tmp
00069Ar 2                   ; reset X
00069Ar 2  DA               phx
00069Br 2  A2 08            ldx #8
00069Dr 2                   ; reset result
00069Dr 2  64 98            stz spi_tmp2
00069Fr 2               spi_send_loop:
00069Fr 2  06 97            asl spi_tmp
0006A1r 2  90 08            bcc bit_unset
0006A3r 2               bit_set:
0006A3r 2  AD 80 FF         lda PORTB
0006A6r 2  09 60            ora #(MOSI | CONF)
0006A8r 2  4C rr rr         jmp clock_on
0006ABr 2               bit_unset:
0006ABr 2  AD 80 FF         lda PORTB
0006AEr 2  29 DF            and #(($FF^MOSI) | CONF)
0006B0r 2               clock_on:
0006B0r 2                   ; set data bit
0006B0r 2  05 99            ora spi_slave
0006B2r 2  8D 80 FF         sta PORTB
0006B5r 2                   ; delay
0006B5r 2  EA               nop
0006B6r 2  EA               nop
0006B7r 2  EA               nop
0006B8r 2  EA               nop
0006B9r 2  EA               nop
0006BAr 2  EA               nop
0006BBr 2                   ; set clock on
0006BBr 2  09 48            ora #(SCK | CONF)
0006BDr 2  05 99            ora spi_slave
0006BFr 2  8D 80 FF         sta PORTB
0006C2r 2               
0006C2r 2                   ; read bit from slave, maybe add slight delay here ?
0006C2r 2  EA               nop
0006C3r 2  EA               nop
0006C4r 2  EA               nop
0006C5r 2  EA               nop
0006C6r 2  EA               nop
0006C7r 2  EA               nop
0006C8r 2  AD 80 FF         lda PORTB
0006CBr 2  29 10            and #MISO           ; mask miso bit
0006CDr 2  D0 06            bne spi_bit_set      ; bit is set
0006CFr 2                   ; bit is unset
0006CFr 2  18               clc
0006D0r 2  26 98            rol spi_tmp2
0006D2r 2  4C rr rr         jmp clock_off
0006D5r 2               
0006D5r 2               spi_bit_set:
0006D5r 2  38               sec
0006D6r 2  26 98            rol spi_tmp2
0006D8r 2               
0006D8r 2               
0006D8r 2               clock_off:
0006D8r 2  AD 80 FF         lda PORTB
0006DBr 2  29 F7            and #(($FF^SCK) | CONF)
0006DDr 2  EA               nop
0006DEr 2  EA               nop
0006DFr 2  EA               nop
0006E0r 2  EA               nop
0006E1r 2  EA               nop
0006E2r 2  EA               nop
0006E3r 2  05 99            ora spi_slave
0006E5r 2  8D 80 FF         sta PORTB
0006E8r 2               end_loop:
0006E8r 2  CA               dex
0006E9r 2  D0 B4            bne spi_send_loop
0006EBr 2                   ; set data low
0006EBr 2  A0 01            ldy #$1
0006EDr 2  20 rr rr         jsr delay_short
0006F0r 2  AD 80 FF         lda PORTB
0006F3r 2  05 99            ora spi_slave
0006F5r 2  29 DF            and #(($FF^MOSI) | CONF)
0006F7r 2  8D 80 FF         sta PORTB
0006FAr 2  A5 98            lda spi_tmp2
0006FCr 2  FA               plx
0006FDr 2  7A               ply
0006FEr 2  60               rts
0006FFr 2               
0006FFr 1               .include "../../drivers/sd.s"
0006FFr 2               ; SD card driver
0006FFr 2               
0006FFr 2               ; SD card initialization routine
0006FFr 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
0006FFr 2               
0006FFr 2               sd_init:                    ; slave address in A
0006FFr 2  8D 01 7A         sta SD_SLAVE             ; save slave address for later use
000702r 2  DA               phx
000703r 2  20 rr rr         jsr spi_init                ; init SPI system
000706r 2  A9 00            lda #0
000708r 2  20 rr rr         jsr spi_select          ; DEselect slave
00070Br 2  8D FC 79         sta SD_ARG
00070Er 2  8D FD 79         sta SD_ARG+1            ; clear command argument
000711r 2  8D FE 79         sta SD_ARG+2
000714r 2  8D FF 79         sta SD_ARG+3
000717r 2  A9 95            lda #$95
000719r 2  8D 02 7A         sta SD_CRC              ; set CRC for CMD0
00071Cr 2                   ; clear SD buffer
00071Cr 2  A2 FF            ldx #$FF
00071Er 2               clear_sd_buf_loop1:
00071Er 2  9E FD 77         stz SD_BUF, X
000721r 2  CA               dex
000722r 2  D0 FA            bne clear_sd_buf_loop1
000724r 2  A2 FF            ldx #$FF
000726r 2               clear_sd_buf_loop2:
000726r 2  9E FD 78         stz SD_BUF+256, x
000729r 2  CA               dex
00072Ar 2  D0 FA            bne clear_sd_buf_loop2
00072Cr 2               
00072Cr 2                   ; send 10 bytes of $FF With SD card deselected
00072Cr 2  A9 31            lda #$31
00072Er 2  20 rr rr         jsr kernel_putc
000731r 2               
000731r 2  A2 0A            ldx #10
000733r 2               init_loop:
000733r 2  A9 FF            lda #$FF
000735r 2  20 rr rr         jsr spi_transceive
000738r 2  CA               dex
000739r 2  D0 F8            bne init_loop
00073Br 2               
00073Br 2  A9 32            lda #$32
00073Dr 2  20 rr rr         jsr kernel_putc
000740r 2               
000740r 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
000743r 2  C9 01            cmp #$01                ; Check for idle state
000745r 2  D0 6A            bne sd_error
000747r 2  A9 33            lda #$33
000749r 2  20 rr rr         jsr kernel_putc
00074Cr 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
00074Fr 2  C9 01            cmp #$01                ; Check for idle state
000751r 2  D0 5E            bne sd_error
000753r 2                   ; TODO check if long response is $01AA
000753r 2               
000753r 2  A9 34            lda #$34
000755r 2  20 rr rr         jsr kernel_putc
000758r 2                   ; wait for card to be initialized
000758r 2  A2 FF            ldx #$ff    ; Max times to loop
00075Ar 2  9C FC 79         stz SD_ARG
00075Dr 2  9C FD 79         stz SD_ARG+1
000760r 2  9C FE 79         stz SD_ARG+2
000763r 2  9C FF 79         stz SD_ARG+3
000766r 2               sd_init_loop2:
000766r 2  CA               dex
000767r 2  F0 48            beq sd_error
000769r 2  9C FC 79         stz SD_ARG
00076Cr 2  A9 37            lda #55
00076Er 2  20 rr rr         jsr sd_command
000771r 2  A9 40            lda #$40
000773r 2  8D FC 79         sta SD_ARG
000776r 2  A9 29            lda #41
000778r 2  20 rr rr         jsr sd_command
00077Br 2               
00077Br 2  D0 E9            bne sd_init_loop2
00077Dr 2  A9 35            lda #$35
00077Fr 2  20 rr rr         jsr kernel_putc
000782r 2               
000782r 2  A9 3A            lda #58
000784r 2  20 rr rr         jsr sd_command
000787r 2  AD FD 77         lda SD_BUF
00078Ar 2  29 40            and #$40
00078Cr 2  F0 0F            beq force_block_size    ; CCS bit is unset, force block addressing
00078Er 2               sd_init_exit_success:
00078Er 2  A2 00            ldx #0
000790r 2               @1:
000790r 2  BD rr rr         lda sd_init_success_message,x
000793r 2  F0 06            beq sd_init_exit
000795r 2  20 rr rr         jsr kernel_putc
000798r 2  E8               inx
000799r 2  80 F5            bra @1
00079Br 2               sd_init_exit:
00079Br 2  FA               plx
00079Cr 2  60               rts
00079Dr 2               
00079Dr 2               force_block_size:
00079Dr 2  9C FC 79         stz SD_ARG
0007A0r 2  9C FD 79         stz SD_ARG+1
0007A3r 2  A9 02            lda #$2
0007A5r 2  8D FE 79         sta SD_ARG+2
0007A8r 2  9C FF 79         stz SD_ARG+3    ; set block size to $200 (512 bytes)
0007ABr 2  20 rr rr         jsr sd_command
0007AEr 2  4C rr rr         jmp sd_init_exit
0007B1r 2               
0007B1r 2               sd_error:
0007B1r 2                   ; print error message
0007B1r 2  A2 00            ldx #0
0007B3r 2               @1:
0007B3r 2  BD rr rr         lda sd_init_error_message,x
0007B6r 2  F0 E3            beq sd_init_exit
0007B8r 2  20 rr rr         jsr kernel_putc
0007BBr 2  E8               inx
0007BCr 2  80 F5            bra @1
0007BEr 2               
0007BEr 2  4C rr rr         jmp sd_init_exit
0007C1r 2               
0007C1r 2               sd_command:         ; command index is in A
0007C1r 2  29 3F            and #$3F        ; only keep low 6 bits
0007C3r 2  8D 00 7A         sta SD_TMP
0007C6r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
0007C8r 2               
0007C8r 2                   ; Select chip
0007C8r 2  20 rr rr         jsr sd_command_start
0007CBr 2               
0007CBr 2  20 rr rr         jsr spi_transceive  ; send command index
0007CEr 2                   ; command argument is in SD_ARG
0007CEr 2  AD FC 79         lda SD_ARG
0007D1r 2  20 rr rr         jsr spi_transceive
0007D4r 2  AD FD 79         lda SD_ARG+1
0007D7r 2  20 rr rr         jsr spi_transceive
0007DAr 2  AD FE 79         lda SD_ARG+2
0007DDr 2  20 rr rr         jsr spi_transceive
0007E0r 2  AD FF 79         lda SD_ARG+3
0007E3r 2  20 rr rr         jsr spi_transceive
0007E6r 2  AD 02 7A         lda SD_CRC          ; send hardcoded CRC if available
0007E9r 2  20 rr rr         jsr spi_transceive
0007ECr 2               
0007ECr 2                   ; wait for a zero to be received in the top bit of the response
0007ECr 2               sd_response_wait_loop:
0007ECr 2  A9 FF            lda #$FF
0007EEr 2  20 rr rr         jsr spi_transceive
0007F1r 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
0007F3r 2               
0007F3r 2  48               pha
0007F4r 2               
0007F4r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
0007F4r 2               
0007F4r 2                   ; get 32 bits of response for CMD 8 and CMD 58
0007F4r 2  AD 00 7A         lda SD_TMP
0007F7r 2  C9 08            cmp #8
0007F9r 2  F0 09            beq long_response
0007FBr 2  C9 3A            cmp #58
0007FDr 2  F0 05            beq long_response
0007FFr 2               
0007FFr 2               sd_command_exit:
0007FFr 2  20 rr rr         jsr sd_command_end
000802r 2  68               pla
000803r 2                   ; return the response
000803r 2  60               rts
000804r 2               
000804r 2               long_response:
000804r 2  A9 FF            lda #$FF
000806r 2  20 rr rr         jsr spi_transceive
000809r 2  8D FD 77         sta SD_BUF
00080Cr 2  A9 FF            lda #$FF
00080Er 2  20 rr rr         jsr spi_transceive
000811r 2  8D FE 77         sta SD_BUF+1
000814r 2  A9 FF            lda #$FF
000816r 2  20 rr rr         jsr spi_transceive
000819r 2  8D FF 77         sta SD_BUF+2
00081Cr 2  A9 FF            lda #$FF
00081Er 2  20 rr rr         jsr spi_transceive
000821r 2  8D 00 78         sta SD_BUF+3
000824r 2  4C rr rr         jmp sd_command_exit
000827r 2               
000827r 2               ; send SD card CMD0
000827r 2               sd_cmd_0:
000827r 2  A9 95            lda #$95
000829r 2  8D 02 7A         sta SD_CRC
00082Cr 2  9C FC 79         stz SD_ARG
00082Fr 2  9C FD 79         stz SD_ARG+1
000832r 2  9C FE 79         stz SD_ARG+2
000835r 2  9C FF 79         stz SD_ARG+3
000838r 2  A9 00            lda #0
00083Ar 2  20 rr rr         jsr sd_command
00083Dr 2  60               rts
00083Er 2               
00083Er 2               ; send SD card CMD8
00083Er 2               sd_cmd_8:
00083Er 2  A9 87            lda #$87
000840r 2  8D 02 7A         sta SD_CRC
000843r 2  9C FC 79         stz SD_ARG
000846r 2  9C FD 79         stz SD_ARG+1
000849r 2  A9 01            lda #1
00084Br 2  8D FE 79         sta SD_ARG+2
00084Er 2  A9 AA            lda #$AA
000850r 2  8D FF 79         sta SD_ARG+3
000853r 2  A9 48            lda #$48
000855r 2  20 rr rr         jsr sd_command
000858r 2               
000858r 2  60               rts
000859r 2               
000859r 2               sd_command_start:
000859r 2  48               pha                         ; Save A
00085Ar 2  AD 01 7A         lda SD_SLAVE
00085Dr 2  20 rr rr         jsr kernel_putc
000860r 2  20 rr rr         jsr spi_select
000863r 2  68               pla                         ; Restore A
000864r 2  60               rts
000865r 2               
000865r 2               sd_command_end:
000865r 2  48               pha
000866r 2  A9 00            lda #0
000868r 2  20 rr rr         jsr spi_select
00086Br 2  A9 FF            lda #$FF
00086Dr 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
000870r 2  68               pla
000871r 2  60               rts
000872r 2               
000872r 2               sd_init_success_message:
000872r 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
000876r 2  69 6E 69 74  
00087Ar 2  20 4F 4B 0D  
00087Fr 2               
00087Fr 2               sd_init_error_message:
00087Fr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
000883r 2  69 6E 69 74  
000887r 2  20 46 41 49  
00088Fr 2               
00088Fr 1               
00088Fr 1               ; Default kernel file for Tali Forth 2
00088Fr 1               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00088Fr 1               ; First version: 19. Jan 2014
00088Fr 1               ; This version: 18. Feb 2018
00088Fr 1               ;
00088Fr 1               ; This section attempts to isolate the hardware-dependent parts of Tali
00088Fr 1               ; Forth 2 to make it easier for people to port it to their own machines.
00088Fr 1               ; Ideally, you shouldn't have to touch any other files. There are three
00088Fr 1               ; routines and one string that must be present for Tali to run:
00088Fr 1               ;
00088Fr 1               ;       kernel_init - Initialize the low-level hardware
00088Fr 1               ;       kernel_getc - Get single character in A from the keyboard (blocks)
00088Fr 1               ;       kernel_putc - Prints the character in A to the screen
00088Fr 1               ;       s_kernel_id - The zero-terminated string printed at boot
00088Fr 1               ;
00088Fr 1               
00088Fr 1               
00088Fr 1               v_reset:
00088Fr 1               kernel_init:
00088Fr 1                       ; """Initialize the hardware. This is called with a JMP and not
00088Fr 1                       ; a JSR because we don't have anything set up for that yet. With
00088Fr 1                       ; py65mon, of course, this is really easy. -- At the end, we JMP
00088Fr 1                       ; back to the label forth to start the Forth system.
00088Fr 1                       ; """
00088Fr 1               
00088Fr 1  A9 01                lda #1
000891r 1  8D 81 FF             sta PORTA
000894r 1  A9 FF                lda #$FF
000896r 1  8D 83 FF             sta DDRA
000899r 1  8D 82 FF             sta DDRB
00089Cr 1               
00089Cr 1  A0 04                ldy #04
00089Er 1  20 rr rr             jsr delay_long
0008A1r 1               
0008A1r 1  20 rr rr             jsr video_init
0008A4r 1               
0008A4r 1               
0008A4r 1  20 rr rr             jsr ps2_init
0008A7r 1  20 rr rr             jsr timer_init
0008AAr 1  20 rr rr             jsr Init_ACIA
0008ADr 1               
0008ADr 1  20 rr rr             jsr lcd_init
0008B0r 1               
0008B0r 1               v_nmi:
0008B0r 1  58                   cli
0008B1r 1                       ; lda #$55
0008B1r 1                       ; sta PORTA
0008B1r 1                       ; We've successfully set everything up, so print the kernel
0008B1r 1                       ; string
0008B1r 1  A2 00                ldx #0
0008B3r 1               @loop:
0008B3r 1  BD rr rr             lda s_kernel_id,x
0008B6r 1  F0 06                beq @done
0008B8r 1  20 rr rr             jsr kernel_putc
0008BBr 1  E8                   inx
0008BCr 1  80 F5                bra @loop
0008BEr 1               @done:
0008BEr 1  A9 01                lda #1
0008C0r 1  8D 80 FF             sta PORTB
0008C3r 1  4C rr rr             jmp forth
0008C6r 1               
0008C6r 1               
0008C6r 1               
0008C6r 1               ; The Planck computer runs Tali Forth 2 as the OS, to there is nowhere to go back to.
0008C6r 1               ; Just restart TALI.
0008C6r 1               platform_bye:
0008C6r 1  4C rr rr             jmp kernel_init
0008C9r 1               
0008C9r 1               
0008C9r 1                   ;; Init ACIA to 115200 8,N,1
0008C9r 1                   ;; Uses: A (not restored)
0008C9r 1               Init_ACIA:
0008C9r 1  8D E1 FF             sta ACIA_STATUS        ; soft reset (value not important)
0008CCr 1                                               ; set specific modes and functions
0008CCr 1  64 96                stz has_acia
0008CEr 1  A9 0B                lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
0008D0r 1                       ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
0008D0r 1  8D E2 FF             sta ACIA_COMMAND        ; store to the command register
0008D3r 1  AD E2 FF             lda ACIA_COMMAND        ; load command register again
0008D6r 1  C9 0B                cmp #$0B                ; if not the same
0008D8r 1  D0 10                bne acia_absent         ; then it means the ACIA is not connected
0008DAr 1  AD E1 FF             lda ACIA_STATUS         ; Read the ACAI status to
0008DDr 1  29 60                and #$60                ; check if present or absent
0008DFr 1  D0 09                bne acia_absent
0008E1r 1  A9 01                lda #1
0008E3r 1  85 96                sta has_acia           ; remember that ACIA is here
0008E5r 1  A9 10                lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
0008E7r 1                       ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
0008E7r 1  8D E3 FF             sta ACIA_CTRL          ; program the ctl register
0008EAr 1               
0008EAr 1               acia_absent:
0008EAr 1  A0 14                ldy #20
0008ECr 1               aa_loop:
0008ECr 1  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
0008EFr 1  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
0008F2r 1  88                   dey
0008F3r 1  D0 F7                bne aa_loop
0008F5r 1               aa_end:
0008F5r 1  60                   rts
0008F6r 1               
0008F6r 1               
0008F6r 1                       ;; Get_Char - get a character from the serial port into A.
0008F6r 1                       ;; Set the carry flag if char is valid.
0008F6r 1                       ;; Return immediately with carry flag clear if no char available.
0008F6r 1                       ;; Uses: A (return value)
0008F6r 1               Get_Char:
0008F6r 1  A5 96                lda has_acia                    ; if no ACIA
0008F8r 1  F0 0F                beq no_acia_char_available      ; exit now
0008FAr 1  AD E1 FF             lda ACIA_STATUS                 ; Read the ACAI status to
0008FDr 1  29 08                and #$08                        ; Check if there is character in the receiver
0008FFr 1  F0 08                beq no_acia_char_available      ; Exit now if we don't get one.
000901r 1  AD E0 FF             lda ACIA_DATA                   ; Load it into the accumulator
000904r 1  38                   sec                             ; Set Carry to show we got a character
000905r 1  20 rr rr             jsr check_ctrl_c
000908r 1  60                   rts                             ; Return
000909r 1               
000909r 1               no_acia_char_available:                 ; no ACIA char available
000909r 1  DA                   phx                             ; save X
00090Ar 1  A6 85                ldx KB_BUF_R_PTR                ; check the keyboard buffer
00090Cr 1  BD 01 7B             lda KB_BUF, x
00090Fr 1  F0 0B                beq no_ps2_char_available       ; exit if nothing found
000911r 1  9E 01 7B             stz KB_BUF, x                   ; if there was a character, reset this buffer cell
000914r 1  E6 85                inc KB_BUF_R_PTR                ; and increment the read pointer
000916r 1               
000916r 1  38                   sec                             ; mark character present
000917r 1  FA                   plx                             ; restore X
000918r 1  20 rr rr             jsr check_ctrl_c
00091Br 1  60                   rts                             ; return
00091Cr 1               no_ps2_char_available:                  ; no keyboard char
00091Cr 1  E6 85                inc KB_BUF_R_PTR                ; increment read pointer for next time
00091Er 1  FA                   plx                             ; restore X
00091Fr 1               no_char_available:
00091Fr 1  18                   clc                             ; Indicate no char available.
000920r 1  60                   rts                             ; return
000921r 1               
000921r 1               
000921r 1               kernel_getc:
000921r 1                       ; """Get a single character from the keyboard (waits for key).
000921r 1                       ; """
000921r 1                       ;; Get_Char_Wait - same as Get_Char only blocking.
000921r 1                       ;; Uses: A (return value)
000921r 1               Get_Char_Wait:
000921r 1  20 rr rr             jsr Get_Char
000924r 1  90 FB                bcc Get_Char_Wait
000926r 1  60                   rts
000927r 1               
000927r 1               check_ctrl_c:
000927r 1                       ;; Check if we have ctrl-C character, if so jump to nmi
000927r 1  C9 03                cmp #$03
000929r 1  D0 03                bne exit_ctrl_c
00092Br 1               
00092Br 1               
00092Br 1  4C rr rr             jmp xt_abort
00092Er 1               
00092Er 1               exit_ctrl_c:
00092Er 1  38                   sec
00092Fr 1  60                   rts
000930r 1               
000930r 1               kernel_putc:
000930r 1                       ; """Print a single character to the console. """
000930r 1                       ;; Send_Char - send character in A out serial port.
000930r 1                       ;; Uses: A (original value restored)
000930r 1               Send_Char:
000930r 1  20 rr rr             jsr char_out
000933r 1  5A                   phy
000934r 1  A4 96                ldy has_acia
000936r 1  F0 08                beq send_char_exit
000938r 1  8D E0 FF             sta ACIA_DATA
00093Br 1               
00093Br 1                       ; nedd to provide additional delay for ACIA
00093Br 1  A0 20                ldy #$20
00093Dr 1  20 rr rr             jsr delay_short
000940r 1                       ; Delay is provided by writing to the LCD screen
000940r 1                       ;ldy #$32            ;minimal delay; The min delay increased when added diode on SLOW. Why?
000940r 1                       ;jsr delay_short
000940r 1                       ;ldy #$30
000940r 1                       ;jsr delay
000940r 1               
000940r 1                       ;jsr char_out
000940r 1               send_char_exit:
000940r 1                       ;jsr lcd_print
000940r 1  7A                   ply
000941r 1  60                   rts
000942r 1               
000942r 1               
000942r 1               v_irq:                          ; IRQ handler
000942r 1  48                   pha
000943r 1  5A                   phy
000944r 1                       ; check if bit 7 of IFR is set
000944r 1  AD 8D FF             lda IFR
000947r 1  10 2B                bpl v_exit  ; Interrupt not from VIA, exit
000949r 1               
000949r 1  29 08                and #$08        ; ps2 has priority
00094Br 1  D0 09                bne v_ps2
00094Dr 1  AD 8D FF             lda IFR
000950r 1  29 40                and #$40
000952r 1  D0 17                bne v_timer
000954r 1  80 1E                bra v_exit
000956r 1               
000956r 1               
000956r 1               v_ps2:
000956r 1  A5 7A                lda time
000958r 1  85 7E                sta last_ps2_time
00095Ar 1  A5 7B                lda time+1
00095Cr 1  85 7F                sta last_ps2_time+1
00095Er 1  A5 7C                lda time+2
000960r 1  85 80                sta last_ps2_time+2
000962r 1  A5 7D                lda time+3
000964r 1  85 81                sta last_ps2_time+3
000966r 1                       ; this delay is here to ensure we prevent desynchronization
000966r 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
000966r 1                       ; jsr delay_short
000966r 1               
000966r 1               
000966r 1  20 rr rr             jsr ps2_irq
000969r 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
000969r 1                       ; jsr delay_short
000969r 1  80 09                bra v_exit
00096Br 1               v_timer:
00096Br 1  AD 84 FF             lda T1CL
00096Er 1  20 rr rr             jsr timer_irq
000971r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
000974r 1                       ; check if there is a char waiting to be printed to the lcd
000974r 1                       ; lda lcd_char
000974r 1                       ; beq v_exit
000974r 1                       ; jsr lcd_print
000974r 1                       ; stz lcd_char
000974r 1               
000974r 1               v_exit:
000974r 1  7A                   ply
000975r 1  68                   pla
000976r 1  40                   rti
000977r 1               
000977r 1               ; Leave the following string as the last entry in the kernel routine so it
000977r 1               ; is easier to see where the kernel ends in hex dumps. This string is
000977r 1               ; displayed after a successful boot
000977r 1               s_kernel_id:
000977r 1  54 61 6C 69          .byte "Tali Forth 2 for Planck 6502 (27/08/2021)", AscLF, 0
00097Br 1  20 46 6F 72  
00097Fr 1  74 68 20 32  
0009A2r 1               
0009A2r 1               
0009A2r 1               
0009A2r 1               ; Add the interrupt vectors
0009A2r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000006r 1               
000006r 1               ; END
000006r 1               
000006r 1               
