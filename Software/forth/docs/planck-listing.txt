ca65 V2.18 - N/A
Main file   : platform/platform-planck.asm
Current file: platform/platform-planck.asm

000000r 1               .segment "CODE"
000000r 1               
000000r 1               ; I/O facilities are handled in the separate kernel files because of their
000000r 1               ; hardware dependencies. See docs/memorymap.txt for a discussion of Tali's
000000r 1               ; memory layout.
000000r 1               
000000r 1               
000000r 1               ; MEMORY MAP OF RAM
000000r 1               
000000r 1               
000000r 1               ; Drawing is not only very ugly, but also not to scale. See the manual for
000000r 1               ; details on the memory map. Note that some of the values are hard-coded in
000000r 1               ; the testing routines, especially the size of the input history buffer, the
000000r 1               ; offset for PAD, and the total RAM size. If these are changed, the tests will
000000r 1               ; have to be changed as well
000000r 1               
000000r 1               
000000r 1               ;    $0000  +-------------------+  ram_start, zpage, user0
000000r 1               ;           |  User variables  |
000000r 1               ;           +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           +~~~~~~~~~~~~~~~~~~~+  <-- dsp
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Data Stack    |
000000r 1               ;           |  |                |
000000r 1               ;    $0078  +-------------------+  dsp0, stack
000000r 1               ;           |                   |
000000r 1               ;           |   (Reserved for   |
000000r 1               ;           |      kernel)      |
000000r 1               ;           |                   |
000000r 1               ;    $0100  +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Return Stack  |  <-- rsp
000000r 1               ;           |  |                |
000000r 1               ;    $0200  +-------------------+  rsp0, buffer, buffer0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Input Buffer  |
000000r 1               ;           |                   |
000000r 1               ;    $0300  +-------------------+  cp0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Dictionary    |
000000r 1               ;           |       (RAM)       |
000000r 1               ;           |                   |
000000r 1               ;   (...)   ~~~~~~~~~~~~~~~~~~~~~  <-- cp
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;    $7C00  +-------------------+  hist_buff, cp_end
000000r 1               ;           |   Input History   |
000000r 1               ;           |    for ACCEPT     |
000000r 1               ;           |  8x128B buffers   |
000000r 1               ;    $7fff  +-------------------+  ram_end
000000r 1               
000000r 1               
000000r 1               ; HARD PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Some of these are somewhat silly for the 65c02, where for example
000000r 1               ; the location of the Zero Page is fixed by hardware. However, we keep
000000r 1               ; these for easier comparisons with Liara Forth's structure and to
000000r 1               ; help people new to these things.
000000r 1               
000000r 1               ram_start = $0000          ; start of installed 32 KiB of RAM
000000r 1               ram_end =   $8000-1        ; end of installed RAM
000000r 1               zpage =     ram_start      ; begin of Zero Page ($0000-$00ff)
000000r 1               zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
000000r 1               stack0 =    $0100          ; begin of Return Stack ($0100-$01ff)
000000r 1               hist_buff = ram_end-$03ff  ; begin of history buffers
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; SOFT PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Tali currently doesn't have separate user variables for multitasking. To
000000r 1               ; prepare for this, though, we've already named the location of the user
000000r 1               ; variables user0.
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               KB_BUF =    hist_buff - $ff
000000r 1               LCD_BUF =   KB_BUF - $7f
000000r 1               LINE_BUF =  LCD_BUF - $7f
000000r 1               SD_CRC =    LINE_BUF - $1
000000r 1               SD_SLAVE =  SD_CRC - $1
000000r 1               SD_TMP =  SD_SLAVE - $1
000000r 1               SD_ARG =    SD_TMP - $4
000000r 1               SD_BUF =    SD_ARG - $1ff
000000r 1               user0 =     zpage          ; user and system variables
000000r 1               
000000r 1               rsp0 =      $ff            ; initial Return Stack Pointer (65c02 stack)
000000r 1               bsize =     $ff            ; size of input/output buffers
000000r 1               buffer0 =   stack0+$100    ; input buffer ($0200-$027f)
000000r 1               cp0 =       buffer0+bsize  ; Dictionary starts after last buffer
000000r 1               cp_end =    SD_BUF         ; Last RAM byte available for code
000000r 1               padoffset = $ff            ; offset from CP to PAD (holds number strings)
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;PLANCK DEFINITIONS
000000r 1               
000000r 1               ; clock speed of main oscillator in hertz
000000r 1               ; used by drivers/timer.s to set proper via timing interval
000000r 1               CLOCK_SPEED = 24000000
000000r 1               ; I/O board in slot 0
000000r 1               VIA1_BASE =        $FF80
000000r 1               ; Serial chip at this address
000000r 1               ACIA_BASE =        $FFE0
000000r 1               
000000r 1               ; VIDEO board in slot 3
000000r 1               VIDEO_BASE =       $FFB0
000000r 1               
000000r 1               ; LCD board in slot 2
000000r 1               LCD_BASE =         $FFD0
000000r 1               
000000r 1               ACIA_DATA =    ACIA_BASE
000000r 1               ACIA_STATUS =  ACIA_BASE+1
000000r 1               ACIA_COMMAND = ACIA_BASE+2
000000r 1               ACIA_CTRL =    ACIA_BASE+3
000000r 1               
000000r 1               LCD_ADDR_DISABLED = LCD_BASE
000000r 1               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 1               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 1               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 1               
000000r 1               PORTB =  VIA1_BASE
000000r 1               PORTA =   VIA1_BASE+1
000000r 1               DDRB =  VIA1_BASE+2
000000r 1               DDRA =  VIA1_BASE+3
000000r 1               
000000r 1               T1CL =  VIA1_BASE + 4
000000r 1               T1CH =  VIA1_BASE + 5
000000r 1               T1LL =  VIA1_BASE + 6
000000r 1               T1LH =  VIA1_BASE + 7
000000r 1               ACR =  VIA1_BASE + 11
000000r 1               PCR =  VIA1_BASE + 12
000000r 1               IFR =  VIA1_BASE + 13
000000r 1               IER =  VIA1_BASE + 14
000000r 1               
000000r 1               
000000r 1               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 1               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;//  ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 1               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 1               VIDEO_DATA = VIDEO_BASE + 3
000000r 1               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 1               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 1               VIDEO_HIRES_HCHARS = 100
000000r 1               VIDEO_HIRES_VCHARS = 75
000000r 1               
000000r 1               ; ps2 defines
000000r 1               
000000r 1               DATA = $80   ; Data is in bit 7 of PORTB
000000r 1               ; clock is on CB2
000000r 1               SHIFT = $1
000000r 1               ALT = $2
000000r 1               
000000r 1               KB_STATE_START = $0
000000r 1               KB_STATE_DATA = $1
000000r 1               KB_STATE_PARITY = $2
000000r 1               KB_STATE_STOP = $3
000000r 1               
000000r 1               KB_INIT_STATE_RESET = $0
000000r 1               KB_INIT_STATE_RESET_ACK = $1
000000r 1               KB_INIT_STATE_LEDS = $2
000000r 1               KB_INIT_STATE_LEDS_ACK = $3
000000r 1               KB_INIT_STATE_LEDS_DATA = $4
000000r 1               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 1               
000000r 1               LSHIFT_KEY = $12
000000r 1               RSHIFT_KEY = $59
000000r 1               
000000r 1               TIMER_DELAY = $C4
000000r 1               
000000r 1               ; Zero page variables
000000r 1               
000000r 1               stack_p =          dsp0
000000r 1               time =             dsp0+2
000000r 1               last_ps2_time =    dsp0+6
000000r 1               
000000r 1               to_send =          dsp0+10
000000r 1               KB_STATE =         dsp0+11
000000r 1               KB_TEMP =          dsp0+11
000000r 1               
000000r 1               KB_BUF_W_PTR =     dsp0+12
000000r 1               KB_BUF_R_PTR =     dsp0+13
000000r 1               KB_PARITY =        dsp0+14
000000r 1               KB_BIT =           dsp0+15
000000r 1               KB_INIT_STATE =    dsp0+16
000000r 1               KB_INIT_WAIT =     dsp0+17
000000r 1               
000000r 1               ready =            dsp0+18
000000r 1               
000000r 1               ignore_next =      dsp0+19
000000r 1               control_keys =     dsp0+20
000000r 1               
000000r 1               character =        dsp0+21
000000r 1               debug =            dsp0+22
000000r 1               
000000r 1               temp_bits =        dsp0+23
000000r 1               LCD_BUF_W_PTR =    dsp0+24
000000r 1               LCD_BUF_R_PTR =    dsp0+25
000000r 1               line =             dsp0+26
000000r 1               char =             dsp0+27
000000r 1               lcd_absent =       dsp0+28
000000r 1               lcd_pos =          dsp0+29
000000r 1               has_acia =         dsp0+30
000000r 1               spi_tmp =          dsp0+31
000000r 1               spi_tmp2 =         dsp0+32
000000r 1               spi_slave =        dsp0+33
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               .include "../../drivers/spi.s"
000000r 2               ; SPI defines
000000r 2               
000000r 2               SS = $07   ; Slave Select with lowest 3 bits
000000r 2               SCK = $08   ; Clock on bit 3
000000r 2               MISO = $10  ; MISO on bit 4
000000r 2               MOSI = $20  ; MOSI on bit 5
000000r 2               CONF = $40  ; CONF on bit 6
000000r 2               
000000r 2               spi_init:
000000r 2  AD 80 FF         lda PORTB               ; load current port B
000003r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
000005r 2  09 40            ora #CONF               ; set CONF high
000007r 2  8D 80 FF         sta PORTB               ; save to PORTB
00000Ar 2  AD 82 FF         lda DDRB                ; get current direction register
00000Dr 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
00000Fr 2  29 EF            and #($FF^MISO)                 ; set MISO as input
000011r 2  8D 82 FF         sta DDRB
000014r 2  A9 FF            lda #$FF
000016r 2  8D 83 FF         sta DDRA
000019r 2  8D 81 FF         sta PORTA
00001Cr 2               
00001Cr 2  60               rts
00001Dr 2               
00001Dr 2               spi_select:
00001Dr 2                   ; selected slave in A
00001Dr 2  29 07            and #SS                 ; mask slave select bits
00001Fr 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
000022r 2  8D 81 FF         sta PORTA
000025r 2  8D 99 00         sta spi_slave
000028r 2  5A               phy
000029r 2  A0 01            ldy #$1
00002Br 2  20 rr rr         jsr delay_short         ; slight delay
00002Er 2  09 40            ora #CONF               ; set CONF high to latch address
000030r 2  8D 80 FF         sta PORTB               ; save to PORTB
000033r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
000034r 2  60               rts
000035r 2               
000035r 2               spi_clk_toggle:
000035r 2  60               rts
000036r 2               
000036r 2               spi_transceive:
000036r 2                   ; send data in A, received data will be in A
000036r 2  5A               phy
000037r 2                   ; save data in RAM
000037r 2  8D 97 00         sta spi_tmp
00003Ar 2                   ; reset X
00003Ar 2  DA               phx
00003Br 2  A2 08            ldx #8
00003Dr 2                   ; reset result
00003Dr 2  9C 98 00         stz spi_tmp2
000040r 2               spi_send_loop:
000040r 2  0E 97 00         asl spi_tmp
000043r 2  90 08            bcc bit_unset
000045r 2               bit_set:
000045r 2  AD 80 FF         lda PORTB
000048r 2  09 60            ora #(MOSI | CONF)
00004Ar 2  4C rr rr         jmp clock_on
00004Dr 2               bit_unset:
00004Dr 2  AD 80 FF         lda PORTB
000050r 2  29 DF            and #(($FF^MOSI) | CONF)
000052r 2               clock_on:
000052r 2                   ; set data bit
000052r 2  0D 99 00         ora spi_slave
000055r 2  8D 80 FF         sta PORTB
000058r 2               
000058r 2                   ; set clock on
000058r 2  09 48            ora #(SCK | CONF)
00005Ar 2  0D 99 00         ora spi_slave
00005Dr 2  8D 80 FF         sta PORTB
000060r 2               
000060r 2                   ; read bit from slave, maybe add slight delay here ?
000060r 2  AD 80 FF         lda PORTB
000063r 2  29 10            and #MISO           ; mask miso bit
000065r 2  D0 07            bne spi_bit_set      ; bit is set
000067r 2                   ; bit is unset
000067r 2  18               clc
000068r 2  2E 98 00         rol spi_tmp2
00006Br 2  4C rr rr         jmp clock_off
00006Er 2               
00006Er 2               spi_bit_set:
00006Er 2  38               sec
00006Fr 2  2E 98 00         rol spi_tmp2
000072r 2               
000072r 2               
000072r 2               clock_off:
000072r 2  AD 80 FF         lda PORTB
000075r 2  29 F7            and #(($FF^SCK) | CONF)
000077r 2  0D 99 00         ora spi_slave
00007Ar 2  8D 80 FF         sta PORTB
00007Dr 2               end_loop:
00007Dr 2  CA               dex
00007Er 2  D0 C0            bne spi_send_loop
000080r 2                   ; set data low
000080r 2  A0 01            ldy #$1
000082r 2  20 rr rr         jsr delay_short
000085r 2  AD 80 FF         lda PORTB
000088r 2  0D 99 00         ora spi_slave
00008Br 2  29 DF            and #(($FF^MOSI) | CONF)
00008Dr 2  8D 80 FF         sta PORTB
000090r 2  AD 98 00         lda spi_tmp2
000093r 2  FA               plx
000094r 2  7A               ply
000095r 2  60               rts
000096r 2               
000096r 1               .include "../../drivers/delayroutines.s"
000096r 2               ; Copyright 2020 Jonathan Foucher
000096r 2               
000096r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000096r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000096r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000096r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000096r 2               ; is furnished to do so, subject to the following conditions:
000096r 2               
000096r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000096r 2               ; substantial portions of the Software.
000096r 2               
000096r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000096r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000096r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000096r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000096r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000096r 2               ; DEALINGS IN THE SOFTWARE.
000096r 2               
000096r 2               
000096r 2               ; this routine delays by 2304 * y + 23 cycles
000096r 2               delay:
000096r 2  DA             phx       ; 3 cycles
000097r 2  5A             phy       ; 3 cycles
000098r 2               two:
000098r 2  A2 FF          ldx #$ff  ; 2 cycles
00009Ar 2               one:
00009Ar 2  EA             nop       ; 2 cycles
00009Br 2  EA             nop       ; 2 cycles
00009Cr 2  CA             dex       ; 2 cycles
00009Dr 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
00009Fr 2  88             dey       ; 2 cycles
0000A0r 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
0000A2r 2  7A             ply       ; 4 cycles
0000A3r 2  FA             plx       ; 4 cycles
0000A4r 2  60             rts       ; 6 cycles
0000A5r 2               
0000A5r 2               ; delay is in Y register
0000A5r 2               delay_long:
0000A5r 2  48             pha
0000A6r 2  5A             phy
0000A7r 2  DA             phx
0000A8r 2  98             tya
0000A9r 2  AA             tax
0000AAr 2               delay_long_loop:
0000AAr 2  A0 FF          ldy #$ff
0000ACr 2  20 rr rr       jsr delay
0000AFr 2  CA             dex
0000B0r 2  D0 F8          bne delay_long_loop
0000B2r 2  FA             plx
0000B3r 2  7A             ply
0000B4r 2  68             pla
0000B5r 2  60             rts
0000B6r 2               
0000B6r 2               delay_short:        ; delay Y * 19 cycles
0000B6r 2  5A             phy
0000B7r 2               delay_short_loop:
0000B7r 2  EA             nop               ; 2 cycles
0000B8r 2  EA             nop               ; 2 cycles
0000B9r 2  EA             nop               ; 2 cycles
0000BAr 2  EA             nop               ; 2 cycles
0000BBr 2  EA             nop               ; 2 cycles
0000BCr 2  EA             nop               ; 2 cycles
0000BDr 2  EA             nop               ; 2 cycles
0000BEr 2               
0000BEr 2               
0000BEr 2  88             dey               ; 2 cycles
0000BFr 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
0000C1r 2  7A             ply
0000C2r 2  60             rts
0000C3r 2               
0000C3r 1               .include "../../drivers/ps2.s"
0000C3r 2               ; Copyright 2020 Jonathan Foucher
0000C3r 2               
0000C3r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
0000C3r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
0000C3r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
0000C3r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
0000C3r 2               ; is furnished to do so, subject to the following conditions:
0000C3r 2               
0000C3r 2               ; The above copyright notice and this permission notice shall be included in all copies or
0000C3r 2               ; substantial portions of the Software.
0000C3r 2               
0000C3r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
0000C3r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
0000C3r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
0000C3r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
0000C3r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
0000C3r 2               ; DEALINGS IN THE SOFTWARE.
0000C3r 2               
0000C3r 2               
0000C3r 2               ps2_init:
0000C3r 2  78             sei ; prevent interrupts while initializing
0000C4r 2               kb_conn_msg:
0000C4r 2  A2 00          ldx #0
0000C6r 2               kb_conn_loop:
0000C6r 2  BD rr rr       lda kb_conn_msg_text,x
0000C9r 2  F0 1A          beq kb_conn_msg_end
0000CBr 2  20 rr rr       jsr kernel_putc
0000CEr 2  E8             inx
0000CFr 2  80 F5          bra kb_conn_loop
0000D1r 2  44 65 74 65  kb_conn_msg_text: .byte "Detecting keyboard", $0D, $00
0000D5r 2  63 74 69 6E  
0000D9r 2  67 20 6B 65  
0000E5r 2               kb_conn_msg_end:
0000E5r 2               
0000E5r 2  AD 8E FF       lda IER
0000E8r 2  09 88          ora #$88      ;enable interrupt on neg transition on CB2
0000EAr 2  8D 8E FF       sta IER
0000EDr 2               
0000EDr 2  A9 00          lda #0
0000EFr 2  8D 8C FF       sta PCR
0000F2r 2  8D 83 00       sta KB_TEMP
0000F5r 2  8D 87 00       sta KB_BIT
0000F8r 2  8D 83 00       sta KB_STATE
0000FBr 2  8D 82 00       sta to_send
0000FEr 2  8D 86 00       sta KB_PARITY
000101r 2  8D 84 00       sta KB_BUF_W_PTR
000104r 2  8D 85 00       sta KB_BUF_R_PTR
000107r 2  8D 88 00       sta KB_INIT_STATE
00010Ar 2  8D 89 00       sta KB_INIT_WAIT
00010Dr 2  8D 8A 00       sta ready
000110r 2  8D 8B 00       sta ignore_next
000113r 2  8D 8D 00       sta character
000116r 2  20 rr rr       jsr clear_buffer
000119r 2               
000119r 2                 ; jsr kb_reset
000119r 2                 ; jsr kb_leds
000119r 2                 ; jsr kb_leds_data
000119r 2               
000119r 2                 ; jmp done_init
000119r 2               
000119r 2  A9 00          lda #KB_INIT_STATE_RESET
00011Br 2  8D 88 00       sta KB_INIT_STATE
00011Er 2  58             cli           ;enable interrupts
00011Fr 2               
00011Fr 2               @wait1:
00011Fr 2  A0 0A          ldy #10
000121r 2  20 rr rr       jsr delay
000124r 2  EE 89 00       inc KB_INIT_WAIT
000127r 2  F0 1C          beq done_init     ; nothing to show yet
000129r 2  AD 82 00       lda to_send
00012Cr 2  D0 F1          bne @wait1       ; do nothing while sending
00012Er 2               
00012Er 2                 ;jsr lcd_print
00012Er 2               
00012Er 2  AE 88 00       ldx KB_INIT_STATE
000131r 2  E0 00          cpx #KB_INIT_STATE_RESET
000133r 2  F0 06          beq @do_reset
000135r 2  E0 01          cpx #KB_INIT_STATE_RESET_ACK
000137r 2  F0 0C          beq done_init
000139r 2                 ; beq @self_test_ok  ; Wait for 256 loops with nothing. if still nothing, reset keyboard
000139r 2               
000139r 2  80 0A          bra done_init
00013Br 2                 ;sta PORTA
00013Br 2                 ; wait for keyboard self test (#$AA)
00013Br 2               
00013Br 2               @do_reset:
00013Br 2  20 rr rr       jsr kb_reset
00013Er 2  A9 01          lda #KB_INIT_STATE_RESET_ACK  ; next state should be an acknowledgment
000140r 2  8D 88 00       sta KB_INIT_STATE
000143r 2  80 DA          bra @wait1
000145r 2               
000145r 2               
000145r 2               done_init:
000145r 2  A9 00          lda #0
000147r 2  8D 82 FF       sta DDRB
00014Ar 2  8D 8C FF       sta PCR
00014Dr 2  8D 8B 00       sta ignore_next
000150r 2  8D 8A 00       sta ready
000153r 2  8D 8C 00       sta control_keys
000156r 2  8D 82 00       sta to_send
000159r 2  8D 8A 00       sta ready
00015Cr 2  8D 8D 00       sta character
00015Fr 2  8D 83 00       sta KB_TEMP
000162r 2  8D 88 00       sta KB_INIT_STATE
000165r 2  8D 87 00       sta KB_BIT
000168r 2  8D 83 00       sta KB_STATE
00016Br 2  8D 84 00       sta KB_BUF_W_PTR
00016Er 2  8D 85 00       sta KB_BUF_R_PTR
000171r 2  58             cli ; enable interrupts again
000172r 2  60             rts
000173r 2               
000173r 2               
000173r 2               kb_reset:
000173r 2  A9 00          lda #0
000175r 2  8D 89 00       sta KB_INIT_WAIT
000178r 2  A9 F0          lda #$F0
00017Ar 2  8D 81 FF       sta PORTA
00017Dr 2  78             sei                   ;disable interrupts
00017Er 2  20 rr rr       jsr prepare_send
000181r 2  A9 FF          lda #$FF
000183r 2  8D 82 00       sta to_send
000186r 2  58             cli                   ; enable interrupts
000187r 2  60             rts
000188r 2               
000188r 2               no_kb_msg:
000188r 2  A2 00          ldx #0
00018Ar 2               no_kb_loop:
00018Ar 2  BD rr rr       lda no_kb_msg_text,x
00018Dr 2  F0 B6          beq done_init
00018Fr 2  20 rr rr       jsr kernel_putc
000192r 2  E8             inx
000193r 2  80 F5          bra no_kb_loop
000195r 2  4E 6F 20 6B  no_kb_msg_text: .byte "No keyboard connected", $0D, $00
000199r 2  65 79 62 6F  
00019Dr 2  61 72 64 20  
0001ACr 2               
0001ACr 2               
0001ACr 2               prepare_send:
0001ACr 2  48             pha
0001ADr 2  5A             phy
0001AEr 2                 ; ready to send, pull clock low for a while
0001AEr 2  A9 C0          lda #$C0
0001B0r 2  8D 8C FF       sta PCR       ;set CB2 low
0001B3r 2                 ;delay
0001B3r 2  A0 80          ldy #$80
0001B5r 2  20 rr rr       jsr delay
0001B8r 2                 ; delay end
0001B8r 2                 ; pull data low now
0001B8r 2  AD 80 FF       lda PORTB
0001BBr 2  29 7F          and #($FF^DATA)
0001BDr 2  8D 80 FF       sta PORTB
0001C0r 2  AD 82 FF       lda DDRB
0001C3r 2  09 80          ora #DATA   ;data as output to set it low
0001C5r 2  8D 82 FF       sta DDRB
0001C8r 2  A0 40          ldy #$40
0001CAr 2  20 rr rr       jsr delay
0001CDr 2  A9 01          lda #KB_STATE_DATA    ; no start bit when sending
0001CFr 2  8D 83 00       sta KB_STATE
0001D2r 2                 ; release clock
0001D2r 2  A9 00          lda #0
0001D4r 2  8D 82 00       sta to_send
0001D7r 2  8D 86 00       sta KB_PARITY
0001DAr 2  8D 8C FF       sta PCR       ;set CB2 to negative edge input
0001DDr 2               
0001DDr 2  7A             ply
0001DEr 2  68             pla
0001DFr 2  60             rts
0001E0r 2               
0001E0r 2               
0001E0r 2               reset_ps2:          ; routine called during a timer interrupt to check
0001E0r 2  48             pha
0001E1r 2                                   ; if the elasped time since the last ps2 interrupt allows us to reset it
0001E1r 2  AD 7D 00       lda time+3
0001E4r 2  CD 81 00       cmp last_ps2_time+3
0001E7r 2  90 1C          bcc @reset
0001E9r 2  AD 7C 00       lda time+2
0001ECr 2  CD 80 00       cmp last_ps2_time+2
0001EFr 2  90 14          bcc @reset
0001F1r 2  AD 7B 00       lda time+1
0001F4r 2  CD 7F 00       cmp last_ps2_time+1
0001F7r 2  90 0C          bcc @reset
0001F9r 2  AD 7A 00       lda time
0001FCr 2  69 01          adc #$1
0001FEr 2  CD 7E 00       cmp last_ps2_time
000201r 2  90 02          bcc @reset
000203r 2               @exit2:
000203r 2  68             pla
000204r 2  60             rts
000205r 2               @reset:
000205r 2  A9 00          lda #0
000207r 2  8D 83 00       sta KB_TEMP
00020Ar 2  8D 87 00       sta KB_BIT
00020Dr 2  8D 83 00       sta KB_STATE
000210r 2  8D 84 00       sta KB_BUF_W_PTR
000213r 2  8D 85 00       sta KB_BUF_R_PTR
000216r 2  F0 EB          beq @exit2
000218r 2               
000218r 2               clear_buffer:
000218r 2  DA             phx
000219r 2  A2 FF          ldx #$ff
00021Br 2               @clear_loop:
00021Br 2  9E 01 7B       stz KB_BUF, x
00021Er 2  CA             dex
00021Fr 2  D0 FA          bne @clear_loop
000221r 2  FA             plx
000222r 2  60             rts
000223r 2               
000223r 2                 .include "ps2_irq.s"
000223r 3               ; Copyright 2020 Jonathan Foucher
000223r 3               
000223r 3               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000223r 3               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000223r 3               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000223r 3               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000223r 3               ; is furnished to do so, subject to the following conditions:
000223r 3               
000223r 3               ; The above copyright notice and this permission notice shall be included in all copies or
000223r 3               ; substantial portions of the Software.
000223r 3               
000223r 3               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000223r 3               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000223r 3               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000223r 3               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000223r 3               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000223r 3               ; DEALINGS IN THE SOFTWARE.
000223r 3               
000223r 3               
000223r 3               
000223r 3               
000223r 3               ps2_irq:
000223r 3  48               pha
000224r 3  DA               phx
000225r 3  AD 82 00         lda to_send
000228r 3  D0 25            bne @willsend
00022Ar 3  AD 83 00         lda KB_STATE            ; which state ?
00022Dr 3  C9 00            cmp #KB_STATE_START
00022Fr 3  F0 0F            beq @start        ; start bit
000231r 3               
000231r 3  C9 01            cmp #KB_STATE_DATA             ; get data bits
000233r 3  F0 1D            beq @data
000235r 3               
000235r 3  C9 02            cmp #KB_STATE_PARITY             ; this is the parity bit
000237r 3  F0 3A            beq @parity
000239r 3               
000239r 3  C9 03            cmp #KB_STATE_STOP      ; stop bit
00023Br 3  F0 3D            beq @stop
00023Dr 3  4C rr rr         jmp @exit
000240r 3               
000240r 3               @start:
000240r 3  A9 01            lda #KB_STATE_DATA
000242r 3  8D 83 00         sta KB_STATE        ; next state will be to get data
000245r 3  A9 00            lda #0
000247r 3  8D 83 00         sta KB_TEMP
00024Ar 3  8D 87 00         sta KB_BIT
00024Dr 3  80 68            bra @exit
00024Fr 3               @willsend:
00024Fr 3  4C rr rr         jmp @sending
000252r 3               @data:
000252r 3  AD 80 FF         lda PORTB       ; get the bit of data from PORTB bit 7
000255r 3  29 80            and #$80
000257r 3  0D 83 00         ora KB_TEMP     ; OR it with existing temp data
00025Ar 3  8D 83 00         sta KB_TEMP     ; save it
00025Dr 3  EE 87 00         inc KB_BIT      ; prepare for next bit
000260r 3  AD 87 00         lda KB_BIT
000263r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000265r 3  F0 05            beq @next_state_parity
000267r 3  4E 83 00         lsr KB_TEMP     ; if not last bit, shift KB_TEMP right to prepare for next bit
00026Ar 3               
00026Ar 3  80 4B            bra @exit
00026Cr 3               
00026Cr 3               @next_state_parity:
00026Cr 3  A9 02            lda #KB_STATE_PARITY    ;next state is parity
00026Er 3  8D 83 00         sta KB_STATE
000271r 3  80 44            bra @exit
000273r 3               
000273r 3               @parity:
000273r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000275r 3  8D 83 00         sta KB_STATE
000278r 3  80 3D            bra @exit
00027Ar 3               
00027Ar 3               @stop:
00027Ar 3  A9 00            lda #KB_STATE_START
00027Cr 3  8D 83 00         sta KB_STATE
00027Fr 3  AD 8B 00         lda ignore_next
000282r 3  D0 48            bne @ignored
000284r 3                   ; Save key to character buffer
000284r 3  AE 83 00         ldx KB_TEMP
000287r 3  E0 AA            cpx #$AA
000289r 3  F0 35            beq @init
00028Br 3  E0 FA            cpx #$FA
00028Dr 3  F0 31            beq @init
00028Fr 3  E0 F0            cpx #$F0
000291r 3  F0 32            beq @ignore_next
000293r 3  E0 12            cpx #LSHIFT_KEY
000295r 3  F0 53            beq @shift_pressed
000297r 3  E0 59            cpx #RSHIFT_KEY
000299r 3  F0 4F            beq @shift_pressed
00029Br 3  AD 8C 00         lda control_keys
00029Er 3  29 01            and #SHIFT
0002A0r 3  D0 09            bne @shifted
0002A2r 3               @unshifted:
0002A2r 3                   ;stx PORTA
0002A2r 3  BD rr rr         lda ASCIITBL, x
0002A5r 3               
0002A5r 3  C9 1B            cmp #$1B             ; reset if escape pressed
0002A7r 3  F0 14            beq @esc
0002A9r 3  80 03            bra @output
0002ABr 3               @shifted:
0002ABr 3  BD rr rr         lda ASCIITBL+128, x
0002AEr 3               @output:
0002AEr 3  AE 84 00         ldx KB_BUF_W_PTR
0002B1r 3  9D 01 7B         sta KB_BUF, x
0002B4r 3                   ;sta PORTA
0002B4r 3  EE 84 00         inc KB_BUF_W_PTR
0002B7r 3               
0002B7r 3               @exit:
0002B7r 3  2C 80 FF         bit PORTB
0002BAr 3  FA               plx
0002BBr 3  68               pla
0002BCr 3  60               rts
0002BDr 3               @esc:
0002BDr 3  4C rr rr         jmp v_reset
0002C0r 3               @init:
0002C0r 3  8E 8A 00         stx ready
0002C3r 3  80 F2            bra @exit
0002C5r 3               
0002C5r 3               @ignore_next:
0002C5r 3  A9 01            lda #1
0002C7r 3  8D 8B 00         sta ignore_next
0002CAr 3  80 EB            bra @exit
0002CCr 3               
0002CCr 3               @ignored:
0002CCr 3  AE 83 00         ldx KB_TEMP
0002CFr 3  E0 12            cpx #LSHIFT_KEY
0002D1r 3  F0 0B            beq @shift_released
0002D3r 3  E0 59            cpx #RSHIFT_KEY
0002D5r 3  F0 07            beq @shift_released
0002D7r 3  A9 00            lda #0
0002D9r 3  8D 8B 00         sta ignore_next
0002DCr 3  80 D9            bra @exit
0002DEr 3               
0002DEr 3               @shift_released:
0002DEr 3  A9 00            lda #0
0002E0r 3  8D 8B 00         sta ignore_next
0002E3r 3  A9 00            lda #0
0002E5r 3  8D 8C 00         sta control_keys
0002E8r 3  80 CD            bra @exit
0002EAr 3               
0002EAr 3               @shift_pressed:
0002EAr 3  AD 8C 00         lda control_keys
0002EDr 3  09 01            ora #SHIFT
0002EFr 3  8D 8C 00         sta control_keys
0002F2r 3  80 C3            bra @exit
0002F4r 3               
0002F4r 3               @sending:
0002F4r 3                   ; lda #1
0002F4r 3                   ; sta PORTA
0002F4r 3                   ; data pin of DDRB should be set as output by prepare_send
0002F4r 3  AD 83 00         lda KB_STATE                ; which state ?
0002F7r 3  C9 01            cmp #KB_STATE_DATA          ; send data bits
0002F9r 3  F0 0A            beq @sending_data
0002FBr 3  C9 02            cmp #KB_STATE_PARITY        ; this is the parity bit
0002FDr 3  F0 33            beq @sending_parity
0002FFr 3  C9 03            cmp #KB_STATE_STOP          ; stop bit
000301r 3  F0 56            beq @sending_stop
000303r 3  80 B2            bra @exit
000305r 3               
000305r 3               
000305r 3               @sending_data:
000305r 3                   ; lda #4
000305r 3                   ; sta PORTA
000305r 3  AD 82 00         lda to_send       ; get the bit of data from memory
000308r 3  29 01            and #$01          ; get only bottom bit
00030Ar 3  F0 0D            beq @send_zero
00030Cr 3               
00030Cr 3               @send_one:
00030Cr 3  AD 80 FF         lda PORTB
00030Fr 3  09 80            ora #$80
000311r 3  8D 80 FF         sta PORTB
000314r 3  EE 86 00         inc KB_PARITY
000317r 3  80 08            bra @sending_done
000319r 3               @send_zero:
000319r 3  AD 80 FF         lda PORTB
00031Cr 3  29 7F            and #$7F
00031Er 3  8D 80 FF         sta PORTB
000321r 3               @sending_done:
000321r 3                   ; lda #2
000321r 3                   ; sta PORTA
000321r 3  EE 87 00         inc KB_BIT      ; prepare for next bit
000324r 3  AD 87 00         lda KB_BIT
000327r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000329r 3  4C rr rr         jmp @next_state_parity
00032Cr 3  4E 82 00         lsr to_send
00032Fr 3  18               clc
000330r 3  80 85            bra @exit
000332r 3               
000332r 3               @sending_parity:
000332r 3                   ; lda #5
000332r 3                   ; sta PORTA
000332r 3  AD 86 00         lda KB_PARITY
000335r 3  29 01            and #$01
000337r 3  F0 10            beq @odd_parity     ; send zero if odd parity
000339r 3  AD 80 FF         lda PORTB
00033Cr 3  09 80            ora #$80            ; send one if even
00033Er 3  8D 80 FF         sta PORTB
000341r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000343r 3  8D 83 00         sta KB_STATE
000346r 3  4C rr rr         jmp @exit
000349r 3               @odd_parity:
000349r 3  AD 80 FF         lda PORTB
00034Cr 3  29 7F            and #$7F
00034Er 3  8D 80 FF         sta PORTB
000351r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000353r 3  8D 83 00         sta KB_STATE
000356r 3  4C rr rr         jmp @exit
000359r 3               
000359r 3               @sending_stop:
000359r 3                   ; lda #6
000359r 3                   ; sta PORTA
000359r 3  A9 00            lda #KB_STATE_START     ; set it back to start in case we are receivin next
00035Br 3  8D 83 00         sta KB_STATE
00035Er 3  A9 00            lda #0
000360r 3  8D 82 00         sta to_send
000363r 3  8D 87 00         sta KB_BIT
000366r 3  8D 86 00         sta KB_PARITY
000369r 3  AD 82 FF         lda DDRB        ; set PORTB back to input
00036Cr 3  29 7F            and #$7F
00036Er 3  8D 82 FF         sta DDRB
000371r 3  4C rr rr         jmp @exit
000374r 3               
000374r 2               
000374r 2               
000374r 2               
000374r 2               ASCIITBL:
000374r 2  00               .byte $00               ; 00 no key pressed
000375r 2  89               .byte $89               ; 01 F9
000376r 2  87               .byte $87               ; 02 relocated F7
000377r 2  85               .byte $85               ; 03 F5
000378r 2  83               .byte $83               ; 04 F3
000379r 2  81               .byte $81               ; 05 F1
00037Ar 2  82               .byte $82               ; 06 F2
00037Br 2  8C               .byte $8C               ; 07 F12
00037Cr 2  00               .byte $00               ; 08
00037Dr 2  8A               .byte $8A               ; 09 F10
00037Er 2  88               .byte $88               ; 0A F8
00037Fr 2  86               .byte $86               ; 0B F6
000380r 2  84               .byte $84               ; 0C F4
000381r 2  09               .byte $09               ; 0D tab
000382r 2  60               .byte $60               ; 0E `~
000383r 2  8F               .byte $8F               ; 0F relocated Print Screen key
000384r 2  03               .byte $03               ; 10 relocated Pause/Break key
000385r 2  A0               .byte $A0               ; 11 left alt (right alt too)
000386r 2  00               .byte $00               ; 12 left shift
000387r 2  E0               .byte $E0               ; 13 relocated Alt release code
000388r 2  00               .byte $00               ; 14 left ctrl (right ctrl too)
000389r 2  71               .byte $71               ; 15 qQ
00038Ar 2  31               .byte $31               ; 16 1!
00038Br 2  00               .byte $00               ; 17
00038Cr 2  00               .byte $00               ; 18
00038Dr 2  00               .byte $00               ; 19
00038Er 2  7A               .byte $7A               ; 1A zZ
00038Fr 2  73               .byte $73               ; 1B sS
000390r 2  61               .byte $61               ; 1C aA
000391r 2  77               .byte $77               ; 1D wW
000392r 2  32               .byte $32               ; 1E 2@
000393r 2  A1               .byte $A1               ; 1F Windows 98 menu key (left side)
000394r 2  02               .byte $02               ; 20 relocated ctrl-break key
000395r 2  63               .byte $63               ; 21 cC
000396r 2  78               .byte $78               ; 22 xX
000397r 2  64               .byte $64               ; 23 dD
000398r 2  65               .byte $65               ; 24 eE
000399r 2  34               .byte $34               ; 25 4$
00039Ar 2  33               .byte $33               ; 26 3#
00039Br 2  A2               .byte $A2               ; 27 Windows 98 menu key (right side)
00039Cr 2  00               .byte $00               ; 28
00039Dr 2  20               .byte $20               ; 29 space
00039Er 2  76               .byte $76               ; 2A vV
00039Fr 2  66               .byte $66               ; 2B fF
0003A0r 2  74               .byte $74               ; 2C tT
0003A1r 2  72               .byte $72               ; 2D rR
0003A2r 2  35               .byte $35               ; 2E 5%
0003A3r 2  A3               .byte $A3               ; 2F Windows 98 option key (right click, right side)
0003A4r 2  00               .byte $00               ; 30
0003A5r 2  6E               .byte $6E               ; 31 nN
0003A6r 2  62               .byte $62               ; 32 bB
0003A7r 2  68               .byte $68               ; 33 hH
0003A8r 2  67               .byte $67               ; 34 gG
0003A9r 2  79               .byte $79               ; 35 yY
0003AAr 2  36               .byte $36               ; 36 6^
0003ABr 2  00               .byte $00               ; 37
0003ACr 2  00               .byte $00               ; 38
0003ADr 2  00               .byte $00               ; 39
0003AEr 2  6D               .byte $6D               ; 3A mM
0003AFr 2  6A               .byte $6A               ; 3B jJ
0003B0r 2  75               .byte $75               ; 3C uU
0003B1r 2  37               .byte $37               ; 3D 7&
0003B2r 2  38               .byte $38               ; 3E 8*
0003B3r 2  00               .byte $00               ; 3F
0003B4r 2  00               .byte $00               ; 40
0003B5r 2  2C               .byte $2C               ; 41 ,<
0003B6r 2  6B               .byte $6B               ; 42 kK
0003B7r 2  69               .byte $69               ; 43 iI
0003B8r 2  6F               .byte $6F               ; 44 oO
0003B9r 2  30               .byte $30               ; 45 0)
0003BAr 2  39               .byte $39               ; 46 9(
0003BBr 2  00               .byte $00               ; 47
0003BCr 2  00               .byte $00               ; 48
0003BDr 2  2E               .byte $2E               ; 49 .>
0003BEr 2  2F               .byte $2F               ; 4A /?
0003BFr 2  6C               .byte $6C               ; 4B lL
0003C0r 2  3B               .byte $3B               ; 4C ;:
0003C1r 2  70               .byte $70               ; 4D pP
0003C2r 2  2D               .byte $2D               ; 4E -_
0003C3r 2  00               .byte $00               ; 4F
0003C4r 2  00               .byte $00               ; 50
0003C5r 2  00               .byte $00               ; 51
0003C6r 2  27               .byte $27               ; 52 '"
0003C7r 2  00               .byte $00               ; 53
0003C8r 2  5B               .byte $5B               ; 54 [{
0003C9r 2  3D               .byte $3D               ; 55 =+
0003CAr 2  00               .byte $00               ; 56
0003CBr 2  00               .byte $00               ; 57
0003CCr 2  00               .byte $00               ; 58 caps
0003CDr 2  00               .byte $00               ; 59 r shift
0003CEr 2  0D               .byte $0D               ; 5A <Enter>
0003CFr 2  5D               .byte $5D               ; 5B ]}
0003D0r 2  00               .byte $00               ; 5C
0003D1r 2  5C               .byte $5C               ; 5D \|
0003D2r 2  00               .byte $00               ; 5E
0003D3r 2  00               .byte $00               ; 5F
0003D4r 2  00               .byte $00               ; 60
0003D5r 2  00               .byte $00               ; 61
0003D6r 2  00               .byte $00               ; 62
0003D7r 2  00               .byte $00               ; 63
0003D8r 2  00               .byte $00               ; 64
0003D9r 2  00               .byte $00               ; 65
0003DAr 2  08               .byte $08               ; 66 bkspace
0003DBr 2  00               .byte $00               ; 67
0003DCr 2  00               .byte $00               ; 68
0003DDr 2  31               .byte $31               ; 69 kp 1
0003DEr 2  2F               .byte $2f               ; 6A kp / converted from E04A in code
0003DFr 2  34               .byte $34               ; 6B kp 4
0003E0r 2  37               .byte $37               ; 6C kp 7
0003E1r 2  00               .byte $00               ; 6D
0003E2r 2  00               .byte $00               ; 6E
0003E3r 2  00               .byte $00               ; 6F
0003E4r 2  30               .byte $30               ; 70 kp 0
0003E5r 2  2E               .byte $2E               ; 71 kp .
0003E6r 2  32               .byte $32               ; 72 kp 2
0003E7r 2  35               .byte $35               ; 73 kp 5
0003E8r 2  36               .byte $36               ; 74 kp 6
0003E9r 2  38               .byte $38               ; 75 kp 8
0003EAr 2  1B               .byte $1B               ; 76 esc
0003EBr 2  00               .byte $00               ; 77 num lock
0003ECr 2  8B               .byte $8B               ; 78 F11
0003EDr 2  2B               .byte $2B               ; 79 kp +
0003EEr 2  33               .byte $33               ; 7A kp 3
0003EFr 2  2D               .byte $2D               ; 7B kp -
0003F0r 2  2A               .byte $2A               ; 7C kp *
0003F1r 2  39               .byte $39               ; 7D kp 9
0003F2r 2  8D               .byte $8D               ; 7E scroll lock
0003F3r 2  00               .byte $00               ; 7F
0003F4r 2                   ;
0003F4r 2                   ; Table for shifted scancodes
0003F4r 2                   ;
0003F4r 2  00               .byte $00               ; 80
0003F5r 2  C9               .byte $C9               ; 81 F9
0003F6r 2  C7               .byte $C7               ; 82 relocated F7
0003F7r 2  C5               .byte $C5               ; 83 F5 (F7 actual scancode=83)
0003F8r 2  C3               .byte $C3               ; 84 F3
0003F9r 2  C1               .byte $C1               ; 85 F1
0003FAr 2  C2               .byte $C2               ; 86 F2
0003FBr 2  CC               .byte $CC               ; 87 F12
0003FCr 2  00               .byte $00               ; 88
0003FDr 2  CA               .byte $CA               ; 89 F10
0003FEr 2  C8               .byte $C8               ; 8A F8
0003FFr 2  C6               .byte $C6               ; 8B F6
000400r 2  C4               .byte $C4               ; 8C F4
000401r 2  09               .byte $09               ; 8D tab
000402r 2  7E               .byte $7E               ; 8E `~
000403r 2  CF               .byte $CF               ; 8F relocated Print Screen key
000404r 2  03               .byte $03               ; 90 relocated Pause/Break key
000405r 2  A0               .byte $A0               ; 91 left alt (right alt)
000406r 2  00               .byte $00               ; 92 left shift
000407r 2  E0               .byte $E0               ; 93 relocated Alt release code
000408r 2  00               .byte $00               ; 94 left ctrl (and right ctrl)
000409r 2  51               .byte $51               ; 95 qQ
00040Ar 2  21               .byte $21               ; 96 1!
00040Br 2  00               .byte $00               ; 97
00040Cr 2  00               .byte $00               ; 98
00040Dr 2  00               .byte $00               ; 99
00040Er 2  5A               .byte $5A               ; 9A zZ
00040Fr 2  53               .byte $53               ; 9B sS
000410r 2  41               .byte $41               ; 9C aA
000411r 2  57               .byte $57               ; 9D wW
000412r 2  40               .byte $40               ; 9E 2@
000413r 2  E1               .byte $E1               ; 9F Windows 98 menu key (left side)
000414r 2  02               .byte $02               ; A0 relocated ctrl-break key
000415r 2  43               .byte $43               ; A1 cC
000416r 2  58               .byte $58               ; A2 xX
000417r 2  44               .byte $44               ; A3 dD
000418r 2  45               .byte $45               ; A4 eE
000419r 2  24               .byte $24               ; A5 4$
00041Ar 2  23               .byte $23               ; A6 3#
00041Br 2  E2               .byte $E2               ; A7 Windows 98 menu key (right side)
00041Cr 2  00               .byte $00               ; A8
00041Dr 2  20               .byte $20               ; A9 space
00041Er 2  56               .byte $56               ; AA vV
00041Fr 2  46               .byte $46               ; AB fF
000420r 2  54               .byte $54               ; AC tT
000421r 2  52               .byte $52               ; AD rR
000422r 2  25               .byte $25               ; AE 5%
000423r 2  E3               .byte $E3               ; AF Windows 98 option key (right click, right side)
000424r 2  00               .byte $00               ; B0
000425r 2  4E               .byte $4E               ; B1 nN
000426r 2  42               .byte $42               ; B2 bB
000427r 2  48               .byte $48               ; B3 hH
000428r 2  47               .byte $47               ; B4 gG
000429r 2  59               .byte $59               ; B5 yY
00042Ar 2  5E               .byte $5E               ; B6 6^
00042Br 2  00               .byte $00               ; B7
00042Cr 2  00               .byte $00               ; B8
00042Dr 2  00               .byte $00               ; B9
00042Er 2  4D               .byte $4D               ; BA mM
00042Fr 2  4A               .byte $4A               ; BB jJ
000430r 2  55               .byte $55               ; BC uU
000431r 2  26               .byte $26               ; BD 7&
000432r 2  2A               .byte $2A               ; BE 8*
000433r 2  00               .byte $00               ; BF
000434r 2  00               .byte $00               ; C0
000435r 2  3C               .byte $3C               ; C1 ,<
000436r 2  4B               .byte $4B               ; C2 kK
000437r 2  49               .byte $49               ; C3 iI
000438r 2  4F               .byte $4F               ; C4 oO
000439r 2  29               .byte $29               ; C5 0)
00043Ar 2  28               .byte $28               ; C6 9(
00043Br 2  00               .byte $00               ; C7
00043Cr 2  00               .byte $00               ; C8
00043Dr 2  3E               .byte $3E               ; C9 .>
00043Er 2  3F               .byte $3F               ; CA /?
00043Fr 2  4C               .byte $4C               ; CB lL
000440r 2  3A               .byte $3A               ; CC ;:
000441r 2  50               .byte $50               ; CD pP
000442r 2  5F               .byte $5F               ; CE -_
000443r 2  00               .byte $00               ; CF
000444r 2  00               .byte $00               ; D0
000445r 2  00               .byte $00               ; D1
000446r 2  22               .byte $22               ; D2 '"
000447r 2  00               .byte $00               ; D3
000448r 2  7B               .byte $7B               ; D4 [{
000449r 2  2B               .byte $2B               ; D5 =+
00044Ar 2  00               .byte $00               ; D6
00044Br 2  00               .byte $00               ; D7
00044Cr 2  00               .byte $00               ; D8 caps
00044Dr 2  00               .byte $00               ; D9 r shift
00044Er 2  0D               .byte $0D               ; DA <Enter>
00044Fr 2  7D               .byte $7D               ; DB ]}
000450r 2  00               .byte $00               ; DC
000451r 2  7C               .byte $7C               ; DD \|
000452r 2  00               .byte $00               ; DE
000453r 2  00               .byte $00               ; DF
000454r 2  00               .byte $00               ; E0
000455r 2  00               .byte $00               ; E1
000456r 2  00               .byte $00               ; E2
000457r 2  00               .byte $00               ; E3
000458r 2  00               .byte $00               ; E4
000459r 2  00               .byte $00               ; E5
00045Ar 2  08               .byte $08               ; E6 bkspace
00045Br 2  00               .byte $00               ; E7
00045Cr 2  00               .byte $00               ; E8
00045Dr 2  91               .byte $91               ; E9 kp 1
00045Er 2  2F               .byte $2f               ; EA kp / converted from E04A in code
00045Fr 2  94               .byte $94               ; EB kp 4
000460r 2  97               .byte $97               ; EC kp 7
000461r 2  00               .byte $00               ; ED
000462r 2  00               .byte $00               ; EE
000463r 2  00               .byte $00               ; EF
000464r 2  90               .byte $90               ; F0 kp 0
000465r 2  7F               .byte $7F               ; F1 kp .
000466r 2  92               .byte $92               ; F2 kp 2
000467r 2  95               .byte $95               ; F3 kp 5
000468r 2  96               .byte $96               ; F4 kp 6
000469r 2  98               .byte $98               ; F5 kp 8
00046Ar 2  1B               .byte $1B               ; F6 esc
00046Br 2  00               .byte $00               ; F7 num lock
00046Cr 2  CB               .byte $CB               ; F8 F11
00046Dr 2  2B               .byte $2B               ; F9 kp +
00046Er 2  93               .byte $93               ; FA kp 3
00046Fr 2  2D               .byte $2D               ; FB kp -
000470r 2  2A               .byte $2A               ; FC kp *
000471r 2  99               .byte $99               ; FD kp 9
000472r 2  CD               .byte $CD               ; FE scroll lock
000473r 2               
000473r 2               
000473r 2               
000473r 2               
000473r 1               
000473r 1               .include "../../drivers/timer.s"
000473r 2               
000473r 2               
000473r 2               COUNTER = CLOCK_SPEED/400        ; n/s
000473r 2               
000473r 2               
000473r 2               timer_init:
000473r 2  AD 8E FF         lda IER
000476r 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000478r 2  8D 8E FF         sta IER
00047Br 2  A9 40            lda #$40        ; timer one free run mode
00047Dr 2  8D 8B FF         sta ACR
000480r 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
000482r 2  8D 84 FF         sta T1CL
000485r 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
000487r 2               
000487r 2  8D 85 FF         sta T1CH
00048Ar 2  A9 00            lda #0              ; reset time variable
00048Cr 2  8D 7A 00         sta time
00048Fr 2  8D 7B 00         sta time+1
000492r 2  8D 7C 00         sta time+2
000495r 2  8D 7D 00         sta time+3
000498r 2  58               cli
000499r 2  60               rts
00049Ar 2               
00049Ar 2               
00049Ar 2               timer_irq:
00049Ar 2  EE 7A 00         inc time
00049Dr 2  F0 04            beq @inc1
00049Fr 2               @exit1:
00049Fr 2                   ; this resets the PS/2 temp variables
00049Fr 2  20 rr rr         jsr reset_ps2
0004A2r 2  60               rts
0004A3r 2               @inc1:
0004A3r 2  EE 7B 00         inc time+1
0004A6r 2  F0 02            beq @inc2
0004A8r 2  80 F5            bra @exit1
0004AAr 2               @inc2:
0004AAr 2  EE 7C 00         inc time+2
0004ADr 2  F0 02            beq @inc3
0004AFr 2  80 EE            bra @exit1
0004B1r 2               @inc3:
0004B1r 2  EE 7D 00         inc time+3
0004B4r 2  80 E9            bra @exit1
0004B6r 2               
0004B6r 1               .include "../../drivers/lcd.s"
0004B6r 2               
0004B6r 2               ; initialize the LCD in 8 bit mode
0004B6r 2               lcd_init:
0004B6r 2  20 rr rr         jsr buf_clr
0004B9r 2  A9 00            lda #0
0004BBr 2  8D 94 00         sta lcd_absent
0004BEr 2  8D 90 00         sta LCD_BUF_W_PTR
0004C1r 2  8D 91 00         sta LCD_BUF_R_PTR
0004C4r 2  8D 95 00         sta lcd_pos
0004C7r 2               
0004C7r 2               
0004C7r 2  A0 FF            ldy #$FF
0004C9r 2  20 rr rr         jsr delay
0004CCr 2               
0004CCr 2  A9 38            LDA #$38            ;function set: 8 bit
0004CEr 2  20 rr rr         jsr lcd_inst
0004D1r 2               
0004D1r 2               
0004D1r 2  A0 FF            ldy #$FF
0004D3r 2  20 rr rr         jsr delay
0004D6r 2               
0004D6r 2  A9 0F            LDA #$0F            ;display on, cursor on, blink on
0004D8r 2  20 rr rr         jsr lcd_inst
0004DBr 2               
0004DBr 2                   ;entry mode set
0004DBr 2  A9 06            LDA #$06
0004DDr 2  20 rr rr         jsr lcd_inst
0004E0r 2               
0004E0r 2                   ;clear display
0004E0r 2  A9 01            LDA #$01
0004E2r 2  20 rr rr         jsr lcd_inst
0004E5r 2               
0004E5r 2  A0 FF            ldy #$ff            ; wait a while
0004E7r 2  20 rr rr         jsr delay
0004EAr 2                   ;set dram address to start of screen
0004EAr 2  A9 80            LDA #$80
0004ECr 2  20 rr rr         jsr lcd_inst
0004EFr 2               
0004EFr 2  A0 FF            ldy #$ff            ; wait a while
0004F1r 2  20 rr rr         jsr delay
0004F4r 2               
0004F4r 2               
0004F4r 2  60               RTS
0004F5r 2               
0004F5r 2               ; Send an instruction in 8 bit mode
0004F5r 2               lcd_inst:
0004F5r 2  5A               phy
0004F6r 2  8D D1 FF         sta LCD_ADDR_ENABLED
0004F9r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
0004FBr 2  20 rr rr         jsr delay_short
0004FEr 2  8D D0 FF         sta LCD_ADDR_DISABLED
000501r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
000503r 2  20 rr rr         jsr delay_short
000506r 2  7A               ply
000507r 2  60               rts
000508r 2               
000508r 2               lcd_send:
000508r 2  8D D3 FF         sta LCD_DATA_ENABLED
00050Br 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
00050Dr 2  20 rr rr         jsr delay_short
000510r 2  8D D2 FF         sta LCD_DATA_DISABLED
000513r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
000515r 2  20 rr rr         jsr delay_short
000518r 2  60               rts
000519r 2               
000519r 2               ; Sends the character in A to the display
000519r 2               lcd_print:               ; 8 bit data in A
000519r 2  5A               phy
00051Ar 2  DA               phx
00051Br 2  48               pha
00051Cr 2  C9 0A            cmp #$0A
00051Er 2  F0 6E            beq @next_line
000520r 2  C9 0D            cmp #$0D
000522r 2  F0 6A            beq @next_line
000524r 2  C9 08            cmp #$08            ;backspace
000526r 2  F0 21            beq @backspace
000528r 2               
000528r 2  20 rr rr         jsr lcd_send
00052Br 2  AE 95 00         ldx lcd_pos
00052Er 2  9D 82 7A         sta LCD_BUF, x
000531r 2               
000531r 2  E8               inx
000532r 2                   ; Check at which position we are and change line if necessary
000532r 2  8E 95 00         stx lcd_pos
000535r 2               
000535r 2  E0 14            cpx #20
000537r 2  F0 2C            beq @line_2
000539r 2  E0 28            cpx #40
00053Br 2  F0 34            beq @line_3
00053Dr 2  E0 3C            cpx #60
00053Fr 2  F0 3C            beq @line_4
000541r 2  E0 50            cpx #80
000543r 2  F0 44            beq @clr
000545r 2               
000545r 2               @continue:
000545r 2  68               pla
000546r 2  FA               plx
000547r 2  7A               ply
000548r 2  60               rts
000549r 2               
000549r 2               ; LCD adressing http://web.alfredstate.edu/faculty/weimandn/lcd/lcd_addressing/lcd_addressing_index.html
000549r 2               @backspace:
000549r 2  A9 10            lda #$10            ; shift cursor left
00054Br 2  20 rr rr         jsr lcd_inst
00054Er 2  A9 20            lda #$20            ; print a space to erase previous char
000550r 2  20 rr rr         jsr lcd_send
000553r 2               
000553r 2  A9 10            lda #$10            ; shift cursor left
000555r 2  20 rr rr         jsr lcd_inst
000558r 2  CE 95 00         dec lcd_pos
00055Br 2  AE 95 00         ldx lcd_pos         ; save in buffer
00055Er 2  A9 20            lda #$20
000560r 2  9D 82 7A         sta LCD_BUF,x
000563r 2  80 E0            bra @continue
000565r 2               @line_2:
000565r 2  A9 14            lda #20
000567r 2  8D 95 00         sta lcd_pos
00056Ar 2  A9 C0            lda #$C0
00056Cr 2  20 rr rr         jsr lcd_inst
00056Fr 2  80 D4            bra @continue
000571r 2               
000571r 2               @line_3:
000571r 2  A9 28            lda #40
000573r 2  8D 95 00         sta lcd_pos
000576r 2  A9 94            lda #$94
000578r 2  20 rr rr         jsr lcd_inst
00057Br 2  80 C8            bra @continue
00057Dr 2               
00057Dr 2               @line_4:
00057Dr 2  A9 3C            lda #60
00057Fr 2  8D 95 00         sta lcd_pos
000582r 2  A9 D4            lda #$D4
000584r 2  20 rr rr         jsr lcd_inst
000587r 2  80 BC            bra @continue
000589r 2               @clr:
000589r 2                   ; lda #0
000589r 2                   ; sta lcd_pos
000589r 2                   ; lda #$80
000589r 2                   ; jsr lcd_inst
000589r 2  20 rr rr         jsr lcd_scroll_up
00058Cr 2  80 B7            bra @continue
00058Er 2               
00058Er 2               @next_line:
00058Er 2  AE 95 00         ldx lcd_pos            ;get current position
000591r 2  E0 50            cpx #80
000593r 2  F0 F4            beq @clr
000595r 2  E0 3C            cpx #60
000597r 2  F0 E4            beq @line_4
000599r 2  E0 28            cpx #40
00059Br 2  F0 D4            beq @line_3
00059Dr 2  E0 14            cpx #20
00059Fr 2  F0 C4            beq @line_2
0005A1r 2  E8               inx
0005A2r 2  8E 95 00         stx lcd_pos
0005A5r 2  A9 20            lda #$20
0005A7r 2  20 rr rr         jsr lcd_send
0005AAr 2  9D 82 7A         sta LCD_BUF, x
0005ADr 2  80 DF            bra @next_line
0005AFr 2               
0005AFr 2               lcd_scroll_up:
0005AFr 2  48               pha                     ; save registers
0005B0r 2  5A               phy
0005B1r 2  DA               phx
0005B2r 2  A9 80            lda #$80                ; set LCD address to start
0005B4r 2  20 rr rr         jsr lcd_inst
0005B7r 2               
0005B7r 2  A2 14            ldx #20                 ; start getting characters at the start of the second line
0005B9r 2               @scroll_loop:
0005B9r 2  BD 82 7A         lda LCD_BUF, X          ; load from buffer
0005BCr 2  20 rr rr         jsr lcd_send            ; send to display
0005BFr 2  A8               tay                     ; save current character in Y
0005C0r 2  E0 4F            cpx #79                 ; update LCD address if necessary
0005C2r 2  F0 4B            beq @scline_4
0005C4r 2  E0 3B            cpx #59
0005C6r 2  F0 40            beq @scline_3
0005C8r 2  E0 27            cpx #39
0005CAr 2  F0 35            beq @scline_2
0005CCr 2               @sccontinue:                ; return from updating LCD address
0005CCr 2  8A               txa                     ; copy X to A to be able to subtract from it
0005CDr 2  38               sec                     ; set carry before subtraction
0005CEr 2  E9 14            sbc #20                 ; subtract 20 to get where to put this character
0005D0r 2  AA               tax                     ; put the result in X
0005D1r 2  98               tya                     ; restore character from Y
0005D2r 2  9D 82 7A         sta LCD_BUF, X          ; store char in buffer
0005D5r 2  8A               txa                     ; copy X to A to be able to add to it
0005D6r 2  18               clc
0005D7r 2  69 14            adc #20                 ; add 20 to restore X
0005D9r 2  AA               tax                     ; put the result back in X
0005DAr 2  E8               inx                     ; increment X to prepare to get next char
0005DBr 2  E0 50            cpx #80                 ; if not at end of buffer
0005DDr 2  90 DA            bcc @scroll_loop        ; do next char
0005DFr 2                   ; fill the last line with spaces
0005DFr 2  A9 D4            lda #$D4                ; set address to last line
0005E1r 2  20 rr rr         jsr lcd_inst
0005E4r 2  A9 20            lda #$20
0005E6r 2  A2 3C            ldx #60
0005E8r 2               @last_line_loop:
0005E8r 2  9D 82 7A         sta LCD_BUF, x
0005EBr 2  20 rr rr         jsr lcd_send
0005EEr 2  E8               inx
0005EFr 2  E0 50            cpx #80                 ; if not at end of buffer
0005F1r 2  90 F5            bcc @last_line_loop     ; do next char
0005F3r 2               
0005F3r 2                   ;finally, place the cursor at the start of the last line
0005F3r 2  A9 3C            lda #60
0005F5r 2  8D 95 00         sta lcd_pos
0005F8r 2  A9 D4            lda #$D4
0005FAr 2  20 rr rr         jsr lcd_inst
0005FDr 2  FA               plx                     ; restore everything as it was
0005FEr 2  7A               ply
0005FFr 2  68               pla
000600r 2  60               rts
000601r 2               
000601r 2               @scline_2:
000601r 2  A9 C0            lda #$C0
000603r 2  20 rr rr         jsr lcd_inst
000606r 2  80 C4            bra @sccontinue
000608r 2               
000608r 2               @scline_3:
000608r 2  A9 94            lda #$94
00060Ar 2  20 rr rr         jsr lcd_inst
00060Dr 2  80 BD            bra @sccontinue
00060Fr 2               
00060Fr 2               @scline_4:
00060Fr 2  A9 D4            lda #$D4
000611r 2  20 rr rr         jsr lcd_inst
000614r 2  80 B6            bra @sccontinue
000616r 2               
000616r 2               lcd_clear:
000616r 2  48               PHA
000617r 2                   ;clear display
000617r 2  A9 01            LDA #$01
000619r 2  20 rr rr         jsr lcd_inst
00061Cr 2                   ;set dram address
00061Cr 2  A9 80            LDA #$80
00061Er 2  20 rr rr         jsr lcd_inst
000621r 2  68               PLA
000622r 2  60               RTS
000623r 2               
000623r 2               
000623r 2               buf_clr:
000623r 2  48               pha
000624r 2  DA               phx
000625r 2  A2 80            ldx #$80
000627r 2  A9 20            lda #$20
000629r 2               buf_clr_loop:
000629r 2  9D 82 7A         sta LCD_BUF,X
00062Cr 2  CA               dex
00062Dr 2  D0 FA            bne buf_clr_loop
00062Fr 2  FA               plx
000630r 2  68               pla
000631r 2  60               rts
000632r 2               
000632r 1               .include "../../drivers/vga.s"
000632r 2               video_init:
000632r 2                   ; set colors
000632r 2  A9 05            lda #$05
000634r 2  8D B0 FF         sta VIDEO_CTRL
000637r 2  A9 1E            lda #$1E
000639r 2  8D B1 FF         sta VIDEO_ADDR_LOW
00063Cr 2  A9 FF            lda #$FF
00063Er 2  8D B2 FF         sta VIDEO_ADDR_HIGH
000641r 2  A9 00            lda #$00
000643r 2  8D B3 FF         sta VIDEO_DATA
000646r 2  A9 F0            lda #$F0
000648r 2  8D B3 FF         sta VIDEO_DATA
00064Br 2  A9 00            lda #0
00064Dr 2  8D B4 FF         sta VIDEO_IEN
000650r 2  8D B1 FF         sta VIDEO_ADDR_LOW
000653r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
000656r 2  20 rr rr         jsr vga_clear
000659r 2  60               rts
00065Ar 2               
00065Ar 2               char_out:
00065Ar 2  48               pha
00065Br 2  DA               phx
00065Cr 2  5A               phy
00065Dr 2  C9 0D            cmp #$0D
00065Fr 2  F0 37            beq next_line
000661r 2  C9 0A            cmp #$0A
000663r 2  F0 33            beq next_line
000665r 2  C9 08            cmp #$08
000667r 2  F0 11            beq backspace
000669r 2  8D B3 FF         sta VIDEO_DATA
00066Cr 2  EE 93 00         inc char
00066Fr 2  AE 93 00         ldx char
000672r 2  E0 64            cpx #VIDEO_HIRES_HCHARS
000674r 2  F0 22            beq next_line
000676r 2               
000676r 2               char_out_exit:
000676r 2  7A               ply
000677r 2  FA               plx
000678r 2  68               pla
000679r 2  60               rts
00067Ar 2               
00067Ar 2               backspace:
00067Ar 2  CE 93 00         dec char
00067Dr 2  A9 85            lda #$85        ; make increment negative
00067Fr 2  8D B0 FF         sta VIDEO_CTRL
000682r 2  A9 20            lda #$20
000684r 2  8D B3 FF         sta VIDEO_DATA  ;write a space to go back one
000687r 2  A9 01            lda #$01        ; make increment zero
000689r 2  8D B0 FF         sta VIDEO_CTRL
00068Cr 2  A9 20            lda #$20
00068Er 2  8D B3 FF         sta VIDEO_DATA  ; replace with a space
000691r 2  A9 05            lda #$05        ; make increment positive again
000693r 2  8D B0 FF         sta VIDEO_CTRL
000696r 2  80 DE            bra char_out_exit
000698r 2               
000698r 2               next_line:
000698r 2  EE 92 00         inc line
00069Br 2  9C 93 00         stz char
00069Er 2  AE 92 00         ldx line
0006A1r 2  E0 4B            cpx #VIDEO_HIRES_VCHARS
0006A3r 2  90 05            bcc nl
0006A5r 2  20 rr rr         jsr scroll_up
0006A8r 2  80 CC            bra char_out_exit
0006AAr 2               nl:
0006AAr 2  BD rr rr         lda mult_table_high,x
0006ADr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006B0r 2  BD rr rr         lda mult_table_low,x
0006B3r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006B6r 2  80 BE            bra char_out_exit
0006B8r 2               
0006B8r 2               scroll_up:
0006B8r 2  20 rr rr         jsr vga_clear
0006BBr 2  60               rts
0006BCr 2  48               pha
0006BDr 2                   ; lda #1
0006BDr 2                   ; sta VIDEO_VSCROLL
0006BDr 2                   ; lda mult_table_high+60
0006BDr 2                   ; sta VIDEO_ADDR_HIGH
0006BDr 2                   ; lda mult_table_low+60
0006BDr 2                   ; sta VIDEO_ADDR_LOW
0006BDr 2  A9 00            lda #0
0006BFr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006C2r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006C5r 2  8D 93 00         sta char
0006C8r 2  8D 92 00         sta line
0006CBr 2  68               pla
0006CCr 2  60               rts
0006CDr 2               
0006CDr 2               vga_clear:
0006CDr 2  48               pha
0006CEr 2  DA               phx
0006CFr 2  5A               phy
0006D0r 2  A9 00            lda #0
0006D2r 2  8D 92 00         sta line
0006D5r 2                   ;lda #$05                ; monochrome chars, increment by one
0006D5r 2                   ;sta VIDEO_CTRL
0006D5r 2               
0006D5r 2  A9 00            lda #$00                ; set start address
0006D7r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006DAr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006DDr 2               
0006DDr 2  A9 20            lda #$20
0006DFr 2  A0 64            ldy #VIDEO_HIRES_HCHARS
0006E1r 2               outer:
0006E1r 2  A2 4B            ldx #VIDEO_HIRES_VCHARS
0006E3r 2               inner:
0006E3r 2  8D B3 FF         sta VIDEO_DATA
0006E6r 2               
0006E6r 2  CA               dex
0006E7r 2  D0 FA            bne inner
0006E9r 2  88               dey
0006EAr 2  D0 F5            bne outer
0006ECr 2               
0006ECr 2  A9 00            lda #0
0006EEr 2  8D 92 00         sta line
0006F1r 2  8D 93 00         sta char
0006F4r 2  A9 00            lda #$00
0006F6r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006F9r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006FCr 2  7A               ply
0006FDr 2  FA               plx
0006FEr 2  68               pla
0006FFr 2  60               rts
000700r 2               
000700r 2               
000700r 2               
000700r 2               ; These are precalculated multiplications for ADDR_LOW and ADDR_HIGH depending on the line number
000700r 2               mult_table_high:
000700r 2  00               .byte $00
000701r 2  02               .byte $02
000702r 2  05               .byte $05
000703r 2  07               .byte $07
000704r 2  0A               .byte $0a
000705r 2  0C               .byte $0c
000706r 2  0F               .byte $0f
000707r 2  11               .byte $11
000708r 2  14               .byte $14
000709r 2  16               .byte $16
00070Ar 2  19               .byte $19
00070Br 2  1B               .byte $1b
00070Cr 2  1E               .byte $1e
00070Dr 2  20               .byte $20
00070Er 2  23               .byte $23
00070Fr 2  25               .byte $25
000710r 2  28               .byte $28
000711r 2  2A               .byte $2a
000712r 2  2D               .byte $2d
000713r 2  2F               .byte $2f
000714r 2  32               .byte $32
000715r 2  34               .byte $34
000716r 2  37               .byte $37
000717r 2  39               .byte $39
000718r 2  3C               .byte $3c
000719r 2  3E               .byte $3e
00071Ar 2  41               .byte $41
00071Br 2  43               .byte $43
00071Cr 2  46               .byte $46
00071Dr 2  48               .byte $48
00071Er 2  4B               .byte $4b
00071Fr 2  4D               .byte $4d
000720r 2  50               .byte $50
000721r 2  52               .byte $52
000722r 2  55               .byte $55
000723r 2  57               .byte $57
000724r 2  5A               .byte $5a
000725r 2  5C               .byte $5c
000726r 2  5F               .byte $5f
000727r 2  61               .byte $61
000728r 2  64               .byte $64
000729r 2  66               .byte $66
00072Ar 2  69               .byte $69
00072Br 2  6B               .byte $6b
00072Cr 2  6E               .byte $6e
00072Dr 2  70               .byte $70
00072Er 2  73               .byte $73
00072Fr 2  75               .byte $75
000730r 2  78               .byte $78
000731r 2  7A               .byte $7a
000732r 2  7D               .byte $7d
000733r 2  7F               .byte $7f
000734r 2  82               .byte $82
000735r 2  84               .byte $84
000736r 2  87               .byte $87
000737r 2  89               .byte $89
000738r 2  8C               .byte $8c
000739r 2  8E               .byte $8e
00073Ar 2  91               .byte $91
00073Br 2  93               .byte $93
00073Cr 2  96               .byte $96
00073Dr 2               
00073Dr 2               mult_table_low:
00073Dr 2  00               .byte $00
00073Er 2  10               .byte $10
00073Fr 2  00               .byte $00
000740r 2  10               .byte $10
000741r 2  00               .byte $00
000742r 2  10               .byte $10
000743r 2  00               .byte $00
000744r 2  10               .byte $10
000745r 2  00               .byte $00
000746r 2  10               .byte $10
000747r 2  00               .byte $00
000748r 2  10               .byte $10
000749r 2  00               .byte $00
00074Ar 2  10               .byte $10
00074Br 2  00               .byte $00
00074Cr 2  10               .byte $10
00074Dr 2  00               .byte $00
00074Er 2  10               .byte $10
00074Fr 2  00               .byte $00
000750r 2  10               .byte $10
000751r 2  00               .byte $00
000752r 2  10               .byte $10
000753r 2  00               .byte $00
000754r 2  10               .byte $10
000755r 2  00               .byte $00
000756r 2  10               .byte $10
000757r 2  00               .byte $00
000758r 2  10               .byte $10
000759r 2  00               .byte $00
00075Ar 2  10               .byte $10
00075Br 2  00               .byte $00
00075Cr 2  10               .byte $10
00075Dr 2  00               .byte $00
00075Er 2  10               .byte $10
00075Fr 2  00               .byte $00
000760r 2  10               .byte $10
000761r 2  00               .byte $00
000762r 2  10               .byte $10
000763r 2  00               .byte $00
000764r 2  10               .byte $10
000765r 2  00               .byte $00
000766r 2  10               .byte $10
000767r 2  00               .byte $00
000768r 2  10               .byte $10
000769r 2  00               .byte $00
00076Ar 2  10               .byte $10
00076Br 2  00               .byte $00
00076Cr 2  10               .byte $10
00076Dr 2  00               .byte $00
00076Er 2  10               .byte $10
00076Fr 2  00               .byte $00
000770r 2  10               .byte $10
000771r 2  00               .byte $00
000772r 2  10               .byte $10
000773r 2  00               .byte $00
000774r 2  10               .byte $10
000775r 2  00               .byte $00
000776r 2  10               .byte $10
000777r 2  00               .byte $00
000778r 2  10               .byte $10
000779r 2  00               .byte $00
00077Ar 2               
00077Ar 1               
00077Ar 1               .include "../../drivers/sd.s"
00077Ar 2               ; SD card driver
00077Ar 2               
00077Ar 2               ; SD card initialization routine
00077Ar 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
00077Ar 2               
00077Ar 2               sd_init:                    ; slave address in A
00077Ar 2  8D 01 7A         sta SD_SLAVE             ; save slave address for later use
00077Dr 2  DA               phx
00077Er 2  20 rr rr         jsr spi_init                ; init SPI system
000781r 2  A9 00            lda #0
000783r 2  20 rr rr         jsr spi_select          ; DEselect slave
000786r 2  8D FC 79         sta SD_ARG
000789r 2  8D FD 79         sta SD_ARG+1            ; clear command argument
00078Cr 2  8D FE 79         sta SD_ARG+2
00078Fr 2  8D FF 79         sta SD_ARG+3
000792r 2  A9 95            lda #$95
000794r 2  8D 02 7A         sta SD_CRC              ; set CRC for CMD0
000797r 2                   ; clear SD buffer
000797r 2  A2 FF            ldx #$FF
000799r 2               clear_sd_buf_loop1:
000799r 2  9E FD 77         stz SD_BUF, X
00079Cr 2  CA               dex
00079Dr 2  D0 FA            bne clear_sd_buf_loop1
00079Fr 2  A2 FF            ldx #$FF
0007A1r 2               clear_sd_buf_loop2:
0007A1r 2  9E FD 78         stz SD_BUF+256, x
0007A4r 2  CA               dex
0007A5r 2  D0 FA            bne clear_sd_buf_loop2
0007A7r 2               
0007A7r 2                   ; send 10 bytes of $FF With SD card deselected
0007A7r 2  A9 31            lda #$31
0007A9r 2  20 rr rr         jsr kernel_putc
0007ACr 2               
0007ACr 2  A2 0A            ldx #10
0007AEr 2               init_loop:
0007AEr 2  A9 FF            lda #$FF
0007B0r 2  20 rr rr         jsr spi_transceive
0007B3r 2  CA               dex
0007B4r 2  D0 F8            bne init_loop
0007B6r 2               
0007B6r 2  A9 32            lda #$32
0007B8r 2  20 rr rr         jsr kernel_putc
0007BBr 2               
0007BBr 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
0007BEr 2  C9 01            cmp #$01                ; Check for idle state
0007C0r 2  D0 6A            bne sd_error
0007C2r 2  A9 33            lda #$33
0007C4r 2  20 rr rr         jsr kernel_putc
0007C7r 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
0007CAr 2  C9 01            cmp #$01                ; Check for idle state
0007CCr 2  D0 5E            bne sd_error
0007CEr 2                   ; TODO check if long response is $01AA
0007CEr 2               
0007CEr 2  A9 34            lda #$34
0007D0r 2  20 rr rr         jsr kernel_putc
0007D3r 2                   ; wait for card to be initialized
0007D3r 2  A2 FF            ldx #$ff    ; Max times to loop
0007D5r 2  9C FC 79         stz SD_ARG
0007D8r 2  9C FD 79         stz SD_ARG+1
0007DBr 2  9C FE 79         stz SD_ARG+2
0007DEr 2  9C FF 79         stz SD_ARG+3
0007E1r 2               sd_init_loop2:
0007E1r 2  CA               dex
0007E2r 2  F0 48            beq sd_error
0007E4r 2  9C FC 79         stz SD_ARG
0007E7r 2  A9 37            lda #55
0007E9r 2  20 rr rr         jsr sd_command
0007ECr 2  A9 40            lda #$40
0007EEr 2  8D FC 79         sta SD_ARG
0007F1r 2  A9 29            lda #41
0007F3r 2  20 rr rr         jsr sd_command
0007F6r 2               
0007F6r 2  D0 E9            bne sd_init_loop2
0007F8r 2  A9 35            lda #$35
0007FAr 2  20 rr rr         jsr kernel_putc
0007FDr 2               
0007FDr 2  A9 3A            lda #58
0007FFr 2  20 rr rr         jsr sd_command
000802r 2  AD FD 77         lda SD_BUF
000805r 2  29 40            and #$40
000807r 2  F0 0F            beq force_block_size    ; CCS bit is unset, force block addressing
000809r 2               sd_init_exit_success:
000809r 2  A2 00            ldx #0
00080Br 2               @1:
00080Br 2  BD rr rr         lda sd_init_success_message,x
00080Er 2  F0 06            beq sd_init_exit
000810r 2  20 rr rr         jsr kernel_putc
000813r 2  E8               inx
000814r 2  80 F5            bra @1
000816r 2               sd_init_exit:
000816r 2  FA               plx
000817r 2  60               rts
000818r 2               
000818r 2               force_block_size:
000818r 2  9C FC 79         stz SD_ARG
00081Br 2  9C FD 79         stz SD_ARG+1
00081Er 2  A9 02            lda #$2
000820r 2  8D FE 79         sta SD_ARG+2
000823r 2  9C FF 79         stz SD_ARG+3    ; set block size to $200 (512 bytes)
000826r 2  20 rr rr         jsr sd_command
000829r 2  4C rr rr         jmp sd_init_exit
00082Cr 2               
00082Cr 2               sd_error:
00082Cr 2                   ; print error message
00082Cr 2  A2 00            ldx #0
00082Er 2               @1:
00082Er 2  BD rr rr         lda sd_init_error_message,x
000831r 2  F0 E3            beq sd_init_exit
000833r 2  20 rr rr         jsr kernel_putc
000836r 2  E8               inx
000837r 2  80 F5            bra @1
000839r 2               
000839r 2  4C rr rr         jmp sd_init_exit
00083Cr 2               
00083Cr 2               sd_command:         ; command index is in A
00083Cr 2  29 3F            and #$3F        ; only keep low 6 bits
00083Er 2  8D 00 7A         sta SD_TMP
000841r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
000843r 2               
000843r 2                   ; Select chip
000843r 2  20 rr rr         jsr sd_command_start
000846r 2               
000846r 2  20 rr rr         jsr spi_transceive  ; send command index
000849r 2                   ; command argument is in SD_ARG
000849r 2  AD FC 79         lda SD_ARG
00084Cr 2  20 rr rr         jsr spi_transceive
00084Fr 2  AD FD 79         lda SD_ARG+1
000852r 2  20 rr rr         jsr spi_transceive
000855r 2  AD FE 79         lda SD_ARG+2
000858r 2  20 rr rr         jsr spi_transceive
00085Br 2  AD FF 79         lda SD_ARG+3
00085Er 2  20 rr rr         jsr spi_transceive
000861r 2  AD 02 7A         lda SD_CRC          ; send hardcoded CRC if available
000864r 2  20 rr rr         jsr spi_transceive
000867r 2               
000867r 2                   ; wait for a zero to be received in the top bit of the response
000867r 2               sd_response_wait_loop:
000867r 2  A9 FF            lda #$FF
000869r 2  20 rr rr         jsr spi_transceive
00086Cr 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
00086Er 2               
00086Er 2  48               pha
00086Fr 2               
00086Fr 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
00086Fr 2               
00086Fr 2                   ; get 32 bits of response for CMD 8 and CMD 58
00086Fr 2  AD 00 7A         lda SD_TMP
000872r 2  C9 08            cmp #8
000874r 2  F0 09            beq long_response
000876r 2  C9 3A            cmp #58
000878r 2  F0 05            beq long_response
00087Ar 2               
00087Ar 2               sd_command_exit:
00087Ar 2  20 rr rr         jsr sd_command_end
00087Dr 2  68               pla
00087Er 2                   ; return the response
00087Er 2  60               rts
00087Fr 2               
00087Fr 2               long_response:
00087Fr 2  A9 FF            lda #$FF
000881r 2  20 rr rr         jsr spi_transceive
000884r 2  8D FD 77         sta SD_BUF
000887r 2  A9 FF            lda #$FF
000889r 2  20 rr rr         jsr spi_transceive
00088Cr 2  8D FE 77         sta SD_BUF+1
00088Fr 2  A9 FF            lda #$FF
000891r 2  20 rr rr         jsr spi_transceive
000894r 2  8D FF 77         sta SD_BUF+2
000897r 2  A9 FF            lda #$FF
000899r 2  20 rr rr         jsr spi_transceive
00089Cr 2  8D 00 78         sta SD_BUF+3
00089Fr 2  4C rr rr         jmp sd_command_exit
0008A2r 2               
0008A2r 2               ; send SD card CMD0
0008A2r 2               sd_cmd_0:
0008A2r 2  A9 95            lda #$95
0008A4r 2  8D 02 7A         sta SD_CRC
0008A7r 2  9C FC 79         stz SD_ARG
0008AAr 2  9C FD 79         stz SD_ARG+1
0008ADr 2  9C FE 79         stz SD_ARG+2
0008B0r 2  9C FF 79         stz SD_ARG+3
0008B3r 2  A9 00            lda #0
0008B5r 2  20 rr rr         jsr sd_command
0008B8r 2  60               rts
0008B9r 2               
0008B9r 2               ; send SD card CMD8
0008B9r 2               sd_cmd_8:
0008B9r 2  A9 87            lda #$87
0008BBr 2  8D 02 7A         sta SD_CRC
0008BEr 2  9C FC 79         stz SD_ARG
0008C1r 2  9C FD 79         stz SD_ARG+1
0008C4r 2  A9 01            lda #1
0008C6r 2  8D FE 79         sta SD_ARG+2
0008C9r 2  A9 AA            lda #$AA
0008CBr 2  8D FF 79         sta SD_ARG+3
0008CEr 2  A9 48            lda #$48
0008D0r 2  20 rr rr         jsr sd_command
0008D3r 2               
0008D3r 2  60               rts
0008D4r 2               
0008D4r 2               sd_command_start:
0008D4r 2  48               pha                         ; Save A
0008D5r 2  AD 01 7A         lda SD_SLAVE
0008D8r 2  20 rr rr         jsr kernel_putc
0008DBr 2  20 rr rr         jsr spi_select
0008DEr 2  68               pla                         ; Restore A
0008DFr 2  60               rts
0008E0r 2               
0008E0r 2               sd_command_end:
0008E0r 2  48               pha
0008E1r 2  A9 00            lda #0
0008E3r 2  20 rr rr         jsr spi_select
0008E6r 2  A9 FF            lda #$FF
0008E8r 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
0008EBr 2  68               pla
0008ECr 2  60               rts
0008EDr 2               
0008EDr 2               sd_init_success_message:
0008EDr 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
0008F1r 2  69 6E 69 74  
0008F5r 2  20 4F 4B 0D  
0008FAr 2               
0008FAr 2               sd_init_error_message:
0008FAr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
0008FEr 2  69 6E 69 74  
000902r 2  20 46 41 49  
00090Ar 2               
00090Ar 1               .include "../taliforth.asm" ; Top-level definitions, memory map
00090Ar 2               ; Tali Forth 2 for the 65c02
00090Ar 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00090Ar 2               ; First version: 19. Jan 2014 (Tali Forth 1)
00090Ar 2               ; This version: 03. Jan 2018 (Version 1.0)
00090Ar 2               
00090Ar 2               ; This is the main file for Tali Forth 2
00090Ar 2               
00090Ar 2               ; Label used to calculate UNUSED. Silly for Tali Forth, where we assume
00090Ar 2               ; 32 KiB RAM and 32 KiB ROM, but kept here to make the code more useful for
00090Ar 2               ; other hardware configurations
00090Ar 2               code0:
00090Ar 2               
00090Ar 2               .include "definitions.asm"      ; Top-level definitions, memory map
00090Ar 3               ; Definitions for Tali Forth 2
00090Ar 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00090Ar 3               ; First version: 01. Apr 2016 (Liara Forth)
00090Ar 3               ; This version: 29. Jan 2020
00090Ar 3               
00090Ar 3               ; This file is included by taliforth.asm. These are the general
00090Ar 3               ; definitions; platform-specific definitions such as the
00090Ar 3               ; memory map are kept in the platform folder.
00090Ar 3               
00090Ar 3               
00090Ar 3               ; ZERO PAGE ADDRESSES/VARIABLES
00090Ar 3               
00090Ar 3               ; These are kept at the top of Zero Page, with the most important variables at
00090Ar 3               ; the top because the Data Stack grows towards this area from dsp0: If there is
00090Ar 3               ; an overflow, the lower, less important variables will be clobbered first,
00090Ar 3               ; giving the system a chance to recover. In other words, they are part of the
00090Ar 3               ; floodplain.
00090Ar 3               
00090Ar 3               ; The four variables insrc, cib, ciblen, and toin must stay together in this
00090Ar 3               ; sequence for the words INPUT>R and R>INPUT to work correctly.
00090Ar 3               
00090Ar 3               cp =        user0+0   ; Compiler Pointer
00090Ar 3               dp =        user0+2   ; Dictionary Pointer
00090Ar 3               workword =  user0+4   ; nt (not xt!) of word being compiled, except in
00090Ar 3                                          ; a :NONAME declared word (see status)
00090Ar 3               insrc =     user0+6   ; input Source for SOURCE-ID
00090Ar 3               cib =       user0+8   ; address of current input buffer
00090Ar 3               ciblen =    user0+10  ; length of current input buffer
00090Ar 3               toin =      user0+12  ; pointer to CIB (>IN in Forth)
00090Ar 3               ip =        user0+14  ; Instruction Pointer (current xt)
00090Ar 3               output =    user0+16  ; vector for EMIT
00090Ar 3               input =     user0+18  ; vector for KEY
00090Ar 3               havekey =   user0+20  ; vector for KEY?
00090Ar 3               state =     user0+22  ; STATE: -1 compile, 0 interpret
00090Ar 3               base =      user0+24  ; number radix, default decimal
00090Ar 3               nc_limit =   user0+26  ; limit for Native Compile size
00090Ar 3               uf_strip =   user0+28  ; flag to strip underflow detection code
00090Ar 3               up =        user0+30  ; User Pointer (Address of user variables)
00090Ar 3               status =    user0+32  ; internal status information
00090Ar 3                                          ; (used by : :NONAME ; ACCEPT)
00090Ar 3                                          ; Bit 7 = Redefined word message postpone
00090Ar 3                                          ;         When set before calling CREATE, it will
00090Ar 3                                          ;         not print the "redefined xxxx" message if
00090Ar 3                                          ;         the word exists. Instead, this bit will
00090Ar 3                                          ;         be reused and after CREATE has run, it will
00090Ar 3                                          ;         be set if the word was redefined and 0 if
00090Ar 3                                          ;         not. This bit should be 0 when not in use.
00090Ar 3                                          ; Bit 6 = 1 for normal ":" definitions
00090Ar 3                                          ;         WORKWORD contains nt of word being compiled
00090Ar 3                                          ;       = 0 for :NONAME definitions
00090Ar 3                                          ;         WORKWORD contains xt of word being compiled
00090Ar 3                                          ; Bit 5 = 1 for NUMBER returning a double word
00090Ar 3                                          ;       = 0 for NUMBER returning a single word
00090Ar 3                                          ; Bit 3 = 1 makes CTRL-n recall current history
00090Ar 3                                          ;       = 0 CTRL-n recalls previous history
00090Ar 3                                          ; Bit 2 = Current history buffer msb
00090Ar 3                                          ; Bit 1 = Current history buffer (0-7, wraps)
00090Ar 3                                          ; Bit 0 = Current history buffer lsb
00090Ar 3                                          ; status+1 is used by ACCEPT to hold history lengths.
00090Ar 3               tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
00090Ar 3               tmp1 =      user0+36  ; temporary storage
00090Ar 3               tmp2 =      user0+38  ; temporary storage
00090Ar 3               tmp3 =      user0+40  ; temporary storage (especially for print)
00090Ar 3               tmpdsp =    user0+42  ; temporary DSP (X) storage (two bytes)
00090Ar 3               tmptos =    user0+44  ; temporary TOS storage
00090Ar 3               editor1 =   user0+46  ; temporary for editors
00090Ar 3               editor2 =   user0+48  ; temporary for editors
00090Ar 3               editor3 =   user0+50  ; temporary for editors
00090Ar 3               tohold =    user0+52  ; pointer for formatted output
00090Ar 3               scratch =   user0+54  ; 8 byte scratchpad (see UM/MOD)
00090Ar 3               
00090Ar 3               ; Zero Page:
00090Ar 3               ; Bytes used for variables: 62 ($0000-$003D)
00090Ar 3               ; First usable Data Stack location: $003E (decimal 62)
00090Ar 3               ; Bytes avaible for Data Stack: 128-62 = 66 --> 33 16-bit cells
00090Ar 3               
00090Ar 3               dsp0 =      zpage_end-7    ; initial Data Stack Pointer
00090Ar 3               
00090Ar 3               ; User Variables:
00090Ar 3               ; Block variables
00090Ar 3               blk_offset =  0        ; BLK : UP + 0
00090Ar 3               scr_offset =  2        ; SCR : UP + 2
00090Ar 3               
00090Ar 3               ; Wordlists
00090Ar 3               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
00090Ar 3               num_wordlists_offset =  5
00090Ar 3                                          ; #WORDLISTS (byte) : UP + 5
00090Ar 3               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
00090Ar 3                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
00090Ar 3               num_order_offset =  30 ; #ORDER (byte) : UP + 30
00090Ar 3                                          ;          (Number of wordlists in search order)
00090Ar 3               search_order_offset =  31
00090Ar 3                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
00090Ar 3                                          ; Allowing for 9 to keep offsets even.
00090Ar 3               max_wordlists =  12    ; Maximum number of wordlists supported
00090Ar 3                                          ; 4 Tali built-ins + 8 user wordlists
00090Ar 3               
00090Ar 3               ; Buffer variables
00090Ar 3               blkbuffer_offset =     40   ; Address of buffer
00090Ar 3               buffblocknum_offset =  42   ; Block number current in buffer
00090Ar 3               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
00090Ar 3               
00090Ar 3               ; Block I/O vectors
00090Ar 3               blockread_offset =     46   ; Vector to block reading routine
00090Ar 3               blockwrite_offset =    48   ; Vector to block writing routine
00090Ar 3               
00090Ar 3               
00090Ar 3               ; ASCII CHARACTERS
00090Ar 3               AscCC =   $03  ; break (CTRL-c)
00090Ar 3               AscBELL = $07  ; bell sound
00090Ar 3               AscBS =   $08  ; backspace
00090Ar 3               AscLF =   $0a  ; line feed
00090Ar 3               AscCR =   $0d  ; carriage return
00090Ar 3               AscESC =  $1b  ; escape
00090Ar 3               AscSP =   $20  ; space
00090Ar 3               AscDEL =  $7f  ; delete (CTRL-h)
00090Ar 3               AscCP =   $10  ; CTRL-p (used to recall previous input history)
00090Ar 3               AscCN =   $0e  ; CTRL-n (used to recall next input history)
00090Ar 3               
00090Ar 3               ; DICTIONARY FLAGS
00090Ar 3               ; The first three bits are currently unused
00090Ar 3               CO = 1  ; Compile Only
00090Ar 3               AN = 2  ; Always Native Compile
00090Ar 3               IM = 4  ; Immediate Word
00090Ar 3               NN = 8  ; Never Native Compile
00090Ar 3               UF = 16 ; Includes Underflow Check (RESERVED)
00090Ar 3               HC = 32 ; Word has Code Field Area (CFA)
00090Ar 3               
00090Ar 3               
00090Ar 3               ; VARIOUS
00090Ar 3               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
00090Ar 3               
00090Ar 3               ; END
00090Ar 3               
00090Ar 2               
00090Ar 2               ; Insert point for Tali Forth after kernel hardware setup
00090Ar 2               forth:
00090Ar 2               
00090Ar 2               .include "native_words.asm"     ; Native Forth words. Starts with COLD
00090Ar 3               ; Low-level Forth word routines
00090Ar 3               ; Tali Forth 2 for the 65c02
00090Ar 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00090Ar 3               ; First version: 19. Jan 2014
00090Ar 3               ; This version: 03. Jan 2018
00090Ar 3               
00090Ar 3               ; This list is ordered alphabetically by the names of the words, not their
00090Ar 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
00090Ar 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
00090Ar 3               ; status lines that begins with "; ## ", which allows auto-generation of the
00090Ar 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
00090Ar 3               
00090Ar 3               ;       TBA --> fragment --> coded --> tested --> auto
00090Ar 3               
00090Ar 3               ; "Auto" means that the word is automatically tested by the test suite (good),
00090Ar 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
00090Ar 3               ; it hasn't been tested at all (bad). See the test suite for more details.
00090Ar 3               
00090Ar 3               ; ## COLD ( -- ) "Reset the Forth system"
00090Ar 3               ; ## "cold"  tested  Tali Forth
00090Ar 3               ;       """Reset the Forth system. Does not restart the kernel,
00090Ar 3               ;       use the 65c02 reset for that. Flows into ABORT.
00090Ar 3               ;       """
00090Ar 3               xt_cold:
00090Ar 3  D8                           cld
00090Br 3               
00090Br 3                               ; Set the OUTPUT vector to the default kernel_putc
00090Br 3                               ; We do this really early so we can print error messages
00090Br 3                               ; during debugging
00090Br 3  A9 rr                        lda #<kernel_putc
00090Dr 3  85 10                        sta output
00090Fr 3  A9 rr                        lda #>kernel_putc
000911r 3  85 11                        sta output+1
000913r 3               
000913r 3                               ; Load all of the important zero page variables from ROM
000913r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
000915r 3               
000915r 3               @load_zp_loop:
000915r 3                               ; This loop loads them back to front. We can use X here
000915r 3                               ; because Tali hasn't started using the stack yet.
000915r 3  BD rr rr                     lda cold_zp_table,x
000918r 3  95 00                        sta zpage,x
00091Ar 3  CA                           dex
00091Br 3  D0 F8                        bne @load_zp_loop
00091Dr 3               
00091Dr 3                               ; Copy the 0th element.
00091Dr 3  AD rr rr                     lda cold_zp_table
000920r 3  85 00                        sta zpage
000922r 3               
000922r 3                               ; Initialize 65c02 stack (Return Stack)
000922r 3  A2 FF                        ldx #rsp0
000924r 3  9A                           txs
000925r 3               
000925r 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
000925r 3                               ; can load high-level words with EVALUATE
000925r 3  A2 78                        ldx #dsp0
000927r 3               
000927r 3                               ; Initialize the user variables.
000927r 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
000929r 3  A9 00                        lda #0
00092Br 3               
00092Br 3               @load_user_vars_loop:
00092Br 3                               ; Like the zero page variables, these are initialized
00092Br 3                               ; back to front.
00092Br 3  B9 rr rr                     lda cold_user_table,y
00092Er 3  91 1E                        sta (up),y
000930r 3  88                           dey
000931r 3  D0 F8                        bne @load_user_vars_loop
000933r 3               
000933r 3                               ; Copy the 0th element.
000933r 3  AD rr rr                     lda cold_user_table
000936r 3  92 1E                        sta (up)
000938r 3  20 rr rr                     jsr xt_cr
00093Br 3               
00093Br 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
00093Br 3                               ; you do not have any high-level words, this part can be
00093Br 3                               ; commented out.
00093Br 3  CA                           dex
00093Cr 3  CA                           dex
00093Dr 3  CA                           dex
00093Er 3  CA                           dex
00093Fr 3               
00093Fr 3                               ; start address goes NOS
00093Fr 3  A9 rr                        lda #<forth_words_start
000941r 3  95 02                        sta 2,x
000943r 3  A9 rr                        lda #>forth_words_start
000945r 3  95 03                        sta 3,x
000947r 3               
000947r 3                               ; length goes TOS
000947r 3  A9 rr                        lda #<forth_words_end
000949r 3  38                           sec
00094Ar 3  E9 rr                        sbc #<forth_words_start
00094Cr 3  95 00                        sta 0,x
00094Er 3               
00094Er 3  A9 rr                        lda #>forth_words_end
000950r 3  E9 rr                        sbc #>forth_words_start
000952r 3  95 01                        sta 1,x
000954r 3               
000954r 3  20 rr rr                     jsr xt_evaluate
000957r 3               
000957r 3                               ; Now define any user words via EVALUATE. If you do not have
000957r 3                               ; any user-defined words, this part can be commented out as
000957r 3                               ; well.
000957r 3  CA                           dex
000958r 3  CA                           dex
000959r 3  CA                           dex
00095Ar 3  CA                           dex
00095Br 3               
00095Br 3                               ; start address goes NOS
00095Br 3  A9 rr                        lda #<user_words_start
00095Dr 3  95 02                        sta 2,x
00095Fr 3  A9 rr                        lda #>user_words_start
000961r 3  95 03                        sta 3,x
000963r 3               
000963r 3                               ; length goes TOS
000963r 3  A9 rr                        lda #<user_words_end
000965r 3  38                           sec
000966r 3  E9 rr                        sbc #<user_words_start
000968r 3  95 00                        sta 0,x
00096Ar 3               
00096Ar 3  A9 rr                        lda #>user_words_end
00096Cr 3  E9 rr                        sbc #>user_words_start
00096Er 3  95 01                        sta 1,x
000970r 3               
000970r 3  20 rr rr                     jsr xt_evaluate
000973r 3               
000973r 3                               ; Initialize all of the history buffers by putting a zero in
000973r 3                               ; each length byte.
000973r 3  9C 00 7C                     stz hist_buff
000976r 3  9C 80 7C                     stz hist_buff+$80
000979r 3  9C 00 7D                     stz hist_buff+$100
00097Cr 3  9C 80 7D                     stz hist_buff+$180
00097Fr 3  9C 00 7E                     stz hist_buff+$200
000982r 3  9C 80 7E                     stz hist_buff+$280
000985r 3  9C 00 7F                     stz hist_buff+$300
000988r 3  9C 80 7F                     stz hist_buff+$380
00098Br 3               
00098Br 3                               ; fall through to ABORT
00098Br 3               
00098Br 3               
00098Br 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
00098Br 3               ; ## "abort"  tested  ANS core
00098Br 3                       ; """https://forth-standard.org/standard/core/ABORT
00098Br 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
00098Br 3                       ; subroutine if we want to because we are going to reset the 65c02's
00098Br 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
00098Br 3                       ; actually delete the stuff on the Data Stack.
00098Br 3                       ; """
00098Br 3               xt_abort:
00098Br 3  A2 78                        ldx #dsp0
00098Dr 3               
00098Dr 3                               ; fall through to QUIT
00098Dr 3               
00098Dr 3               
00098Dr 3               ; ## QUIT ( -- ) "Reset the input and get new input"
00098Dr 3               ; ## "quit"  tested  ANS core
00098Dr 3                       ; """https://forth-standard.org/standard/core/QUIT
00098Dr 3                       ; Rest the input and start command loop
00098Dr 3                       ; """
00098Dr 3               
00098Dr 3               xt_quit:
00098Dr 3                               ; Clear the Return Stack. This is a little screwed up
00098Dr 3                               ; because the 65c02 can only set the Return Stack via X,
00098Dr 3                               ; which is our Data Stack pointer. The ANS specification
00098Dr 3                               ; demands, however, that ABORT reset the Data Stack pointer
00098Dr 3  8A                           txa             ; Save the DSP that we just defined
00098Er 3  A2 FF                        ldx #rsp0
000990r 3  9A                           txs
000991r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000992r 3               
000992r 3                               ; make sure instruction pointer is empty
000992r 3  64 0E                        stz ip
000994r 3  64 0F                        stz ip+1
000996r 3               
000996r 3                               ; SOURCE-ID is zero (keyboard input)
000996r 3  64 06                        stz insrc
000998r 3  64 07                        stz insrc+1
00099Ar 3               
00099Ar 3                               ; STATE is zero (interpret, not compile)
00099Ar 3  64 16                        stz state
00099Cr 3  64 17                        stz state+1
00099Er 3               @get_line:
00099Er 3  A9 00                        lda #<buffer0   ; input buffer, this is paranoid
0009A0r 3  85 08                        sta cib
0009A2r 3  A9 02                        lda #>buffer0
0009A4r 3  85 09                        sta cib+1
0009A6r 3               
0009A6r 3                               ; Size of current input buffer (CIB) is zero
0009A6r 3  64 0A                        stz ciblen
0009A8r 3  64 0B                        stz ciblen+1
0009AAr 3               
0009AAr 3                               ; Accept a line from the current import source. This is how
0009AAr 3                               ; modern Forths to it.
0009AAr 3  20 rr rr                     jsr xt_refill           ; ( -- f )
0009ADr 3               
0009ADr 3                               ; Test flag: LSB of TOS
0009ADr 3  B5 00                        lda 0,x
0009AFr 3  D0 05                        bne @success
0009B1r 3               
0009B1r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
0009B1r 3                               ; need to print an error message and reset the machine. We
0009B1r 3                               ; don't need to save TOS because we're going to clobber it
0009B1r 3                               ; anyway when we go back to ABORT.
0009B1r 3  A9 06                        lda #err_refill
0009B3r 3  4C rr rr                     jmp error
0009B6r 3               
0009B6r 3               @success:
0009B6r 3                               ; Assume we have successfully accepted a string of input from
0009B6r 3                               ; a source, with address cib and length of input in ciblen. We
0009B6r 3                               ; arrive here still with the TRUE flag from REFILL as TOS
0009B6r 3  E8                           inx                     ; drop
0009B7r 3  E8                           inx
0009B8r 3               
0009B8r 3                               ; Main compile/execute routine
0009B8r 3  20 rr rr                     jsr interpret
0009BBr 3               
0009BBr 3                               ; Test for Data Stack underflow. Tali Forth does not check for
0009BBr 3                               ; overflow because it is so rare
0009BBr 3  E0 78                        cpx #dsp0
0009BDr 3  F0 05                        beq @stack_ok
0009BFr 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
0009C1r 3               
0009C1r 3  4C rr rr                     jmp underflow_error
0009C4r 3               
0009C4r 3               @stack_ok:
0009C4r 3                               ; Display system prompt if all went well. If we're interpreting,
0009C4r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
0009C4r 3                               ; space at beginning of the string.
0009C4r 3  A5 16                        lda state
0009C6r 3  F0 02                        beq @print
0009C8r 3               
0009C8r 3  A9 01                        lda #1                  ; number for "compile" string
0009CAr 3               @print:
0009CAr 3  20 rr rr                     jsr print_string
0009CDr 3               
0009CDr 3                               ; Awesome line, everybody! Now get the next one.
0009CDr 3  80 CF                        bra @get_line
0009CFr 3               
0009CFr 3               z_cold:
0009CFr 3               z_abort:
0009CFr 3               z_quit:         ; no RTS required
0009CFr 3               
0009CFr 3               
0009CFr 3               
0009CFr 3               ; This table holds all of the initial values for the variables in zero page.
0009CFr 3               ; This table is used by COLD.
0009CFr 3               cold_zp_table:
0009CFr 3  FF 07                .word cp0+256+1024      ; cp moved to make room for user vars and
0009D1r 3                                               ; block buffer
0009D1r 3  rr rr                .word dictionary_start  ; dp
0009D3r 3  00 00                .word 0                 ; workword
0009D5r 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
0009D7r 3  00 02                .word buffer0           ; cib
0009D9r 3  00 00                .word 0                 ; ciblen
0009DBr 3  00 00                .word 0                 ; toin
0009DDr 3  00 00                .word 0                 ; ip
0009DFr 3  rr rr                .word kernel_putc       ; output
0009E1r 3  rr rr                .word kernel_getc       ; input
0009E3r 3  00 00                .word 0                 ; havekey
0009E5r 3  00 00                .word 0                 ; state (0 = interpret)
0009E7r 3  0A 00                .word 10                ; base
0009E9r 3  14 00                .word 20                ; nc-limit
0009EBr 3  00 00                .word 0                 ; uf_strip (off by default)
0009EDr 3  FF 02                .word cp0               ; up (user vars put right at beginning of
0009EFr 3                                               ; available RAM)
0009EFr 3  00 00                .word 0                 ; status
0009F1r 3               cold_zp_table_end:
0009F1r 3               
0009F1r 3               ; No further ZP variables are initialized. The variables past this point are
0009F1r 3               ; all temporaries.
0009F1r 3               
0009F1r 3               ; This table holds the inital values for the user variables. This table is
0009F1r 3               ; used by COLD.
0009F1r 3               cold_user_table:
0009F1r 3  00 00                .word 0                         ; BLK
0009F3r 3  00 00                .word 0                         ; SCR
0009F5r 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
0009F6r 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
0009F7r 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
0009F9r 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
0009FBr 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
0009FDr 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
0009FFr 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000A03r 3  00 00 00 00  
000A07r 3  00 00 00 00  
000A0Fr 3  01                   .byte 1                         ; #ORDER
000A10r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
000A14r 3  00 00 00 00  
000A18r 3  00           
000A19r 3  FF 03                .word cp0+256                   ; Address of buffer (right after USER vars)
000A1Br 3  00 00                .word 0                         ; block in buffer
000A1Dr 3  00 00                .word 0                         ; buffer status (not in use)
000A1Fr 3  rr rr                .word xt_block_word_error       ; block-read vector
000A21r 3  rr rr                .word xt_block_word_error       ; block-write vector
000A23r 3               cold_user_table_end:
000A23r 3               
000A23r 3               
000A23r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
000A23r 3               ; ## "abort""  tested  ANS core
000A23r 3                       ; """https://forth-standard.org/standard/core/ABORTq
000A23r 3                       ; Abort and print a string.
000A23r 3                       ; """
000A23r 3               
000A23r 3               xt_abort_quote:
000A23r 3                               ; save the string
000A23r 3  20 rr rr                     jsr xt_s_quote          ; S"
000A26r 3               
000A26r 3                               ; compile run-time part
000A26r 3  A0 rr                        ldy #>abort_quote_runtime
000A28r 3  A9 rr                        lda #<abort_quote_runtime
000A2Ar 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000A2Dr 3               
000A2Dr 3  60           z_abort_quote:  rts
000A2Er 3               
000A2Er 3               
000A2Er 3               abort_quote_runtime:
000A2Er 3                       ; """Runtime aspect of ABORT_QUOTE"""
000A2Er 3               
000A2Er 3                               ; We arrive here with ( f addr u )
000A2Er 3  B5 04                        lda 4,x
000A30r 3  15 05                        ora 5,x
000A32r 3  F0 09                        beq @done       ; if FALSE, we're done
000A34r 3               
000A34r 3                               ; We're true, so print string and ABORT. We follow Gforth
000A34r 3                               ; in going to a new line after the string
000A34r 3  20 rr rr                     jsr xt_type
000A37r 3  20 rr rr                     jsr xt_cr
000A3Ar 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000A3Dr 3               @done:
000A3Dr 3                               ; Drop three entries from the Data Stack
000A3Dr 3  8A                           txa
000A3Er 3  18                           clc
000A3Fr 3  69 06                        adc #6
000A41r 3  AA                           tax
000A42r 3               
000A42r 3  60                           rts
000A43r 3               
000A43r 3               
000A43r 3               
000A43r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
000A43r 3               ; ## "abs"  auto  ANS core
000A43r 3                       ; """https://forth-standard.org/standard/core/ABS
000A43r 3                       ; Return the absolute value of a number.
000A43r 3                       ; """
000A43r 3               
000A43r 3               xt_abs:
000A43r 3  20 rr rr                     jsr underflow_1
000A46r 3               
000A46r 3  B5 01                        lda 1,x
000A48r 3  10 0D                        bpl @done       ; positive number, easy money!
000A4Ar 3               
000A4Ar 3                               ; negative: calculate 0 - n
000A4Ar 3  38                           sec
000A4Br 3  A9 00                        lda #0
000A4Dr 3  F5 00                        sbc 0,x         ; LSB
000A4Fr 3  95 00                        sta 0,x
000A51r 3               
000A51r 3  A9 00                        lda #0          ; MSB
000A53r 3  F5 01                        sbc 1,x
000A55r 3  95 01                        sta 1,x
000A57r 3               
000A57r 3               @done:
000A57r 3  60           z_abs:          rts
000A58r 3               
000A58r 3               
000A58r 3               
000A58r 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
000A58r 3               ; ## "accept"  auto  ANS core
000A58r 3                       ; """https://forth-standard.org/standard/core/ACCEPT
000A58r 3                       ; Receive a string of at most n1 characters, placing them at
000A58r 3                       ; addr. Return the actual number of characters as n2. Characters
000A58r 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
000A58r 3                       ; modern Forths.
000A58r 3                       ; """
000A58r 3               
000A58r 3               xt_accept:
000A58r 3  20 rr rr                     jsr underflow_2
000A5Br 3               
000A5Br 3                               ; Abort if we were asked to receive 0 chars
000A5Br 3  B5 00                        lda 0,x
000A5Dr 3  15 01                        ora 1,x
000A5Fr 3  D0 09                        bne @not_zero
000A61r 3               
000A61r 3  E8                           inx
000A62r 3  E8                           inx
000A63r 3  74 00                        stz 0,x
000A65r 3  74 01                        stz 1,x
000A67r 3               
000A67r 3  4C rr rr                     jmp accept_done
000A6Ar 3               
000A6Ar 3               @not_zero:
000A6Ar 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000A6Cr 3  85 26                        sta tmp2
000A6Er 3  64 27                        stz tmp2+1      ; ... but we only accept max 255 chars
000A70r 3               
000A70r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000A72r 3  85 24                        sta tmp1
000A74r 3  B5 03                        lda 3,x
000A76r 3  85 25                        sta tmp1+1
000A78r 3               
000A78r 3  E8                           inx
000A79r 3  E8                           inx
000A7Ar 3               
000A7Ar 3  A0 00                        ldy #0
000A7Cr 3               
000A7Cr 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
000A7Cr 3                               ; from bit 2 to 3 is OK)
000A7Cr 3  A5 20                        lda status
000A7Er 3  29 F7                        and #$f7
000A80r 3               
000A80r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000A80r 3  1A                           inc
000A81r 3               
000A81r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000A81r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000A81r 3                               ; received and won't be used to calculate the history buffer
000A81r 3                               ; offset.
000A81r 3  09 08                        ora #$08
000A83r 3  85 20                        sta status
000A85r 3               
000A85r 3               accept_loop:
000A85r 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000A85r 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000A85r 3                               ; vt100 terminal clears the screen automatically.
000A85r 3               
000A85r 3                               ; This is the internal version of KEY without all the mucking
000A85r 3                               ; about with the Data Stack while still using the input vector
000A85r 3  20 rr rr                     jsr key_a
000A88r 3               
000A88r 3                               ; We quit on both line feed and carriage return
000A88r 3  C9 0A                        cmp #AscLF
000A8Ar 3  F0 20                        beq @eol
000A8Cr 3  C9 0D                        cmp #AscCR
000A8Er 3  F0 1C                        beq @eol
000A90r 3               
000A90r 3                               ; BACKSPACE and DEL do the same thing for the moment
000A90r 3  C9 08                        cmp #AscBS
000A92r 3  F0 22                        beq @backspace
000A94r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000A96r 3  F0 1E                        beq @backspace
000A98r 3               
000A98r 3                               ; Check for CTRL-p and CTRL-n to recall input history
000A98r 3  C9 10                        cmp #AscCP
000A9Ar 3  F0 36                        beq @ctrl_p
000A9Cr 3  C9 0E                        cmp #AscCN
000A9Er 3  F0 44                        beq @ctrl_n
000AA0r 3               
000AA0r 3                               ; That's enough for now. Save and echo character.
000AA0r 3  91 24                        sta (tmp1),y
000AA2r 3  C8                           iny
000AA3r 3               
000AA3r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000AA3r 3  20 rr rr                     jsr emit_a
000AA6r 3               
000AA6r 3  C4 26                        cpy tmp2        ; reached character limit?
000AA8r 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
000AAAr 3  80 03                        bra @buffer_full
000AACr 3               
000AACr 3               @eol:
000AACr 3  20 rr rr                     jsr xt_space    ; print final space
000AAFr 3               
000AAFr 3               @buffer_full:
000AAFr 3                               ; REFILL updates ciblen and toin, we don't need to do it here
000AAFr 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
000AB1r 3  74 01                        stz 1,x         ; we only accept 256 chars
000AB3r 3               
000AB3r 3  4C rr rr                     jmp accept_done
000AB6r 3               
000AB6r 3               @backspace:
000AB6r 3                               ; Handle backspace and delete kex, which currently do the same
000AB6r 3                               ; thing
000AB6r 3  C0 00                        cpy #0          ; buffer empty?
000AB8r 3  D0 06                        bne @1
000ABAr 3               
000ABAr 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
000ABCr 3  20 rr rr                     jsr emit_a
000ABFr 3  C8                           iny
000AC0r 3               @1:
000AC0r 3  88                           dey
000AC1r 3  A9 08                        lda #AscBS      ; move back one
000AC3r 3  20 rr rr                     jsr emit_a
000AC6r 3  A9 20                        lda #AscSP      ; print a space (rubout)
000AC8r 3  20 rr rr                     jsr emit_a
000ACBr 3  A9 08                        lda #AscBS      ; move back over space
000ACDr 3  20 rr rr                     jsr emit_a
000AD0r 3               
000AD0r 3  80 B3                        bra accept_loop
000AD2r 3               
000AD2r 3               @ctrl_p:
000AD2r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000AD2r 3               
000AD2r 3                               ; Select the previous buffer
000AD2r 3  A5 20                        lda status
000AD4r 3               
000AD4r 3                               ; Check for 0 (need to wrap back to 7)
000AD4r 3  29 07                        and #7
000AD6r 3  D0 08                        bne @ctrl_p_dec
000AD8r 3               
000AD8r 3                               ; We need to wrap back to 7.
000AD8r 3  A5 20                        lda status
000ADAr 3  09 07                        ora #7
000ADCr 3  85 20                        sta status
000ADEr 3  80 11                        bra @recall_history
000AE0r 3               
000AE0r 3               @ctrl_p_dec:
000AE0r 3                               ; It's safe to decrement the buffer index directly.
000AE0r 3  C6 20                        dec status
000AE2r 3  80 0D                        bra @recall_history
000AE4r 3               
000AE4r 3               @ctrl_n:
000AE4r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000AE4r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000AE4r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000AE4r 3                               ; history buffer.
000AE4r 3  A9 08                        lda #$8
000AE6r 3  24 20                        bit status
000AE8r 3  D0 07                        bne @recall_history
000AEAr 3               
000AEAr 3                               ; This isn't the first time CTRL-n has been pressed, select the
000AEAr 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
000AEAr 3  A5 20                        lda status
000AECr 3  29 F7                        and #$f7
000AEEr 3               
000AEEr 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000AEEr 3  1A                           inc
000AEFr 3               
000AEFr 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
000AEFr 3                               ; be cleared below.
000AEFr 3  85 20                        sta status
000AF1r 3               
000AF1r 3                               ; Falls through to @recall_history
000AF1r 3               
000AF1r 3               @recall_history:
000AF1r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000AF1r 3  A9 08                        lda #%00001000
000AF3r 3  14 20                        trb status
000AF5r 3               
000AF5r 3  20 rr rr                     jsr total_recall
000AF8r 3               
000AF8r 3                               ; tmp3 now has the address of the previous history buffer.
000AF8r 3                               ; First byte of buffer is length. Clear the line by sending
000AF8r 3                               ; CR, Y spaces, then CR.
000AF8r 3  A9 0D                        lda #AscCR
000AFAr 3  20 rr rr                     jsr emit_a
000AFDr 3               
000AFDr 3               input_clear:
000AFDr 3  C0 00                        cpy #0
000AFFr 3  F0 08                        beq input_cleared
000B01r 3               
000B01r 3  A9 20                        lda #AscSP
000B03r 3  20 rr rr                     jsr emit_a
000B06r 3  88                           dey
000B07r 3  80 F4                        bra input_clear
000B09r 3               
000B09r 3               input_cleared:
000B09r 3  A9 0D                        lda #AscCR
000B0Br 3  20 rr rr                     jsr emit_a
000B0Er 3               
000B0Er 3                               ; Save the history length byte into histinfo+1
000B0Er 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000B0Er 3  B1 28                        lda (tmp3),y
000B10r 3  85 21                        sta status+1
000B12r 3               
000B12r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000B12r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000B12r 3                               ; buffer)
000B12r 3  E6 28                        inc tmp3
000B14r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
000B16r 3  E6 29                        inc tmp3+1
000B18r 3               @2:
000B18r 3                               ; Copy the history buffer into the input buffer,
000B18r 3                               ; sending the characters to the output as we go.
000B18r 3  A9 0D                        lda #AscCR
000B1Ar 3  20 rr rr                     jsr emit_a
000B1Dr 3               
000B1Dr 3               @history_loop:
000B1Dr 3                               ; See if we have reached the end of the history buffer.
000B1Dr 3  C4 21                        cpy status+1
000B1Fr 3  D0 03                        bne @3
000B21r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
000B24r 3               @3:
000B24r 3                               ; See if we have reached the end of the input buffer.
000B24r 3                               ; (only comparing to lower byte as we currently limit
000B24r 3                               ; to 255 characters max)
000B24r 3  C4 26                        cpy tmp2
000B26r 3  F0 0A                        beq @hist_filled_buffer
000B28r 3               
000B28r 3                               ; Copy a character and echo.
000B28r 3  B1 28                        lda (tmp3),y
000B2Ar 3  91 24                        sta (tmp1),y
000B2Cr 3  20 rr rr                     jsr emit_a
000B2Fr 3               
000B2Fr 3                               ; Move to the next character.
000B2Fr 3  C8                           iny
000B30r 3  80 EB                        bra @history_loop
000B32r 3               
000B32r 3               @hist_filled_buffer:
000B32r 3                               ; We don't want a history recall to EOL our buffer,
000B32r 3                               ; so back up one character and return to editing.
000B32r 3  88                           dey
000B33r 3  4C rr rr                     jmp accept_loop
000B36r 3               accept_done:
000B36r 3               @done:
000B36r 3                               ; Copy the input buffer into the currently
000B36r 3                               ; selected history buffer.
000B36r 3  20 rr rr                     jsr total_recall
000B39r 3  85 21                        sta status+1
000B3Br 3               
000B3Br 3                               ; Also save it in the first buffer byte.
000B3Br 3  A0 00                        ldy #0
000B3Dr 3  91 28                        sta (tmp3),y
000B3Fr 3               
000B3Fr 3                               ; Move path the count to the data bytes
000B3Fr 3  E6 28                        inc tmp3
000B41r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000B43r 3  E6 29                        inc tmp3+1
000B45r 3               @4:
000B45r 3                               ; Copy the characters from the input buffer to the
000B45r 3                               ; history buffer.
000B45r 3               
000B45r 3               @save_history_loop:
000B45r 3  C4 21                        cpy status+1
000B47r 3  F0 07                        beq @save_history_done
000B49r 3               
000B49r 3  B1 24                        lda (tmp1),y
000B4Br 3  91 28                        sta (tmp3),y
000B4Dr 3  C8                           iny
000B4Er 3  80 F5                        bra @save_history_loop
000B50r 3               
000B50r 3               @save_history_done:
000B50r 3               z_accept:
000B50r 3  60                           rts
000B51r 3               
000B51r 3               total_recall:
000B51r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000B51r 3               
000B51r 3                               ; Generate the address of the buffer in tmp3. Start with the
000B51r 3                               ; base address.
000B51r 3  A9 00                        lda #<hist_buff
000B53r 3  85 28                        sta tmp3
000B55r 3  A9 7C                        lda #>hist_buff
000B57r 3  85 29                        sta tmp3+1
000B59r 3               
000B59r 3                               ; This is a bit annoying as some bits go into each byte.
000B59r 3                               ; .....xxx gets put into address like ......xx x.......
000B59r 3  A5 20                        lda status
000B5Br 3  6A                           ror
000B5Cr 3  29 03                        and #3
000B5Er 3  18                           clc
000B5Fr 3  65 29                        adc tmp3+1
000B61r 3  85 29                        sta tmp3+1
000B63r 3               
000B63r 3  A5 20                        lda status
000B65r 3  6A                           ror             ; Rotate through carry into msb.
000B66r 3  6A                           ror
000B67r 3  29 80                        and #$80
000B69r 3  18                           clc
000B6Ar 3  65 28                        adc tmp3
000B6Cr 3  85 28                        sta tmp3
000B6Er 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000B70r 3  E6 29                        inc tmp3+1
000B72r 3               @1:
000B72r 3                               ; Save the current length of the input buffer in
000B72r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000B72r 3  98                           tya
000B73r 3  C9 80                        cmp #$80
000B75r 3  90 02                        bcc @2
000B77r 3  A9 7F                        lda #$7F
000B79r 3               @2:
000B79r 3  60                           rts
000B7Ar 3               
000B7Ar 3               
000B7Ar 3               
000B7Ar 3               
000B7Ar 3               
000B7Ar 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000B7Ar 3               ; ## "action-of"  auto  ANS core ext
000B7Ar 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000B7Ar 3               
000B7Ar 3               xt_action_of:
000B7Ar 3                               ; This is a state aware word with differet behavior
000B7Ar 3                               ; when used while compiling vs interpreting.
000B7Ar 3                               ; Check STATE
000B7Ar 3  A5 16                        lda state
000B7Cr 3  05 17                        ora state+1
000B7Er 3  F0 0C                        beq @interpreting
000B80r 3               
000B80r 3               @compiling:
000B80r 3                               ; Run ['] to compile the xt of the next word
000B80r 3                               ; as a literal.
000B80r 3  20 rr rr                     jsr xt_bracket_tick
000B83r 3               
000B83r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000B83r 3  A0 rr                        ldy #>xt_defer_fetch
000B85r 3  A9 rr                        lda #<xt_defer_fetch
000B87r 3  20 rr rr                     jsr cmpl_subroutine
000B8Ar 3  80 06                        bra @done
000B8Cr 3               
000B8Cr 3               @interpreting:
000B8Cr 3  20 rr rr                     jsr xt_tick
000B8Fr 3  20 rr rr                     jsr xt_defer_fetch
000B92r 3               
000B92r 3               @done:
000B92r 3  60           z_action_of:           rts
000B93r 3               
000B93r 3               
000B93r 3               
000B93r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000B93r 3               ; ## "again"  tested  ANS core ext
000B93r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000B93r 3               
000B93r 3               xt_again:
000B93r 3  20 rr rr                     jsr underflow_1
000B96r 3               
000B96r 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000B96r 3                               ; so we have the range and don't have to calculate the
000B96r 3                               ; offset.
000B96r 3  A0 00                        ldy #0
000B98r 3  A9 4C                        lda #$4C        ; JMP
000B9Ar 3  91 00                        sta (cp),y
000B9Cr 3  C8                           iny
000B9Dr 3               
000B9Dr 3  B5 00                        lda 0,x         ; LSB of address
000B9Fr 3  91 00                        sta (cp),y
000BA1r 3  C8                           iny
000BA2r 3               
000BA2r 3  B5 01                        lda 1,x         ; MSB of address
000BA4r 3  91 00                        sta (cp),y
000BA6r 3  C8                           iny
000BA7r 3               
000BA7r 3                               ; Allot the space we just used
000BA7r 3  98                           tya
000BA8r 3  18                           clc
000BA9r 3  65 00                        adc cp
000BABr 3  85 00                        sta cp
000BADr 3  90 02                        bcc @done
000BAFr 3  E6 01                        inc cp+1
000BB1r 3               @done:
000BB1r 3  E8                           inx
000BB2r 3  E8                           inx
000BB3r 3               
000BB3r 3  60           z_again:        rts
000BB4r 3               
000BB4r 3               
000BB4r 3               
000BB4r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000BB4r 3               ; ## "align"  auto  ANS core
000BB4r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000BB4r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000BB4r 3                       ; routine as well, and also does nothing
000BB4r 3                       ; """
000BB4r 3               
000BB4r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000BB4r 3               ; ## "aligned"  auto  ANS core
000BB4r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000BB4r 3               
000BB4r 3               xt_align:
000BB4r 3               xt_aligned:
000BB4r 3               z_align:
000BB4r 3  60           z_aligned:      rts             ; stripped out during native compile
000BB5r 3               
000BB5r 3               
000BB5r 3               
000BB5r 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000BB5r 3               ; ## "allot"  auto  ANS core
000BB5r 3                       ; """https://forth-standard.org/standard/core/ALLOT
000BB5r 3                       ; Reserve a certain number of bytes (not cells) or release them.
000BB5r 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000BB5r 3                       ; to the beginning of the Dictionary. If n is positive (the most
000BB5r 3                       ; common case), reserve n bytes, but not past the end of the
000BB5r 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000BB5r 3                       ; """
000BB5r 3               
000BB5r 3               xt_allot:
000BB5r 3  20 rr rr                     jsr underflow_1
000BB8r 3               
000BB8r 3                               ; Releasing memory is going to be a very rare operation,
000BB8r 3                               ; so we check for it at the beginning and try to make
000BB8r 3                               ; the most common case as fast as possible
000BB8r 3  B5 01                        lda 1,x
000BBAr 3  30 22                        bmi @release
000BBCr 3               
000BBCr 3                               ; Common case: We are reserving memory, not releasing it
000BBCr 3  18                           clc
000BBDr 3  A5 00                        lda cp
000BBFr 3  75 00                        adc 0,x
000BC1r 3  85 00                        sta cp
000BC3r 3               
000BC3r 3  A5 01                        lda cp+1
000BC5r 3  75 01                        adc 1,x
000BC7r 3  85 01                        sta cp+1
000BC9r 3               
000BC9r 3                               ; Wait, did we just grant more space than we have? This is
000BC9r 3                               ; a check we only do here, not for other situations like cmpl_a
000BC9r 3                               ; where smaller amounts are reserved.
000BC9r 3  A0 FD                        ldy #<cp_end
000BCBr 3  C4 00                        cpy cp
000BCDr 3  A9 77                        lda #>cp_end
000BCFr 3  E5 01                        sbc cp+1
000BD1r 3  B0 48                        bcs @done               ; we're fine.
000BD3r 3               
000BD3r 3                               ; Oops, that was too much, we're beyond the end of
000BD3r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000BD3r 3                               ; an error
000BD3r 3  84 00                        sty cp                  ; still #<cp_end
000BD5r 3  A9 77                        lda #>cp_end
000BD7r 3  85 01                        sta cp+1
000BD9r 3               
000BD9r 3  A9 00                        lda #err_allot
000BDBr 3  4C rr rr                     jmp error
000BDEr 3               
000BDEr 3               @release:
000BDEr 3                  		; The ANS standard doesn't really say what to do if too much
000BDEr 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
000BDEr 3                               ; even an official test. Gforth is little help either. The good
000BDEr 3                               ; news is, this is going to be a rare case. We want to use as
000BDEr 3                               ; few bytes as possible.
000BDEr 3               
000BDEr 3                               ; What we do is let the user free anything up to the beginning
000BDEr 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
000BDEr 3                               ; their own risk. This means that the Dictionary pointer DP
000BDEr 3                               ; might end up pointing to garbage. However, an attempt to
000BDEr 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
000BDEr 3                               ; the DP pointing to the last word in RAM (should be DROP) and
000BDEr 3                               ; an error message.
000BDEr 3               
000BDEr 3                               ; We arrive here with ( n ) which is negative. First step,
000BDEr 3                               ; subtract the number TOS from the CP for a new CP
000BDEr 3  CA                           dex
000BDFr 3  CA                           dex
000BE0r 3  A5 00                        lda cp
000BE2r 3  95 00                        sta 0,x
000BE4r 3  A5 01                        lda cp+1
000BE6r 3  95 01                        sta 1,x
000BE8r 3               
000BE8r 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000BEBr 3               
000BEBr 3                               ; Second step, see if we've gone too far. We compare the new
000BEBr 3                               ; CP on TOS (which, if we've really screwed up, might be
000BEBr 3                               ; negative) with CP0. This is a signed comparison
000BEBr 3  CA                           dex
000BECr 3  CA                           dex                             ; new CP now NOS
000BEDr 3  A9 FF                        lda #<cp0
000BEFr 3  95 00                        sta 0,x
000BF1r 3  A9 02                        lda #>cp0
000BF3r 3  95 01                        sta 1,x                         ; CP0 is TOS
000BF5r 3               
000BF5r 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000BF8r 3               
000BF8r 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000BF8r 3                               ; This means we want Z=1 or N=1
000BF8r 3  F0 17                        beq @nega_done
000BFAr 3  30 15                        bmi @nega_done
000BFCr 3               
000BFCr 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
000BFCr 3                               ; word in ROM (should be DROP), and abort with an error
000BFCr 3  A9 FF                        lda #<cp0
000BFEr 3  85 00                        sta cp
000C00r 3  A9 02                        lda #>cp0
000C02r 3  85 01                        sta cp+1
000C04r 3               
000C04r 3  A9 rr                        lda #<dictionary_start
000C06r 3  85 02                        sta dp
000C08r 3  A9 rr                        lda #>dictionary_start
000C0Ar 3  85 03                        sta dp+1
000C0Cr 3               
000C0Cr 3  A9 0A                        lda #err_negallot
000C0Er 3  4C rr rr                     jmp error
000C11r 3               
000C11r 3               @nega_done:
000C11r 3                               ; Save new CP, which is NOS
000C11r 3  B5 02                        lda 2,x
000C13r 3  85 00                        sta cp
000C15r 3  B5 03                        lda 3,x
000C17r 3  85 01                        sta cp+1
000C19r 3               
000C19r 3  E8                           inx
000C1Ar 3  E8                           inx                     ; drop through to @done
000C1Br 3               @done:
000C1Br 3  E8                           inx
000C1Cr 3  E8                           inx
000C1Dr 3               z_allot:
000C1Dr 3  60                           rts
000C1Er 3               
000C1Er 3               
000C1Er 3               
000C1Er 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000C1Er 3               ; ## "allow-native"  auto  Tali Forth
000C1Er 3               xt_allow_native:
000C1Er 3  20 rr rr                     jsr current_to_dp
000C21r 3  A0 01                        ldy #1          ; offset for status byte
000C23r 3  B1 02                        lda (dp),y
000C25r 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
000C27r 3  91 02                        sta (dp),y
000C29r 3               z_allow_native:
000C29r 3  60                           rts
000C2Ar 3               
000C2Ar 3               
000C2Ar 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000C2Ar 3               ; ## "also"  auto  ANS search ext
000C2Ar 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000C2Ar 3               xt_also:
000C2Ar 3  20 rr rr                     jsr xt_get_order
000C2Dr 3  20 rr rr                     jsr xt_over
000C30r 3  20 rr rr                     jsr xt_swap
000C33r 3  20 rr rr                     jsr xt_one_plus
000C36r 3  20 rr rr                     jsr xt_set_order
000C39r 3               
000C39r 3  60           z_also:         rts
000C3Ar 3               
000C3Ar 3               
000C3Ar 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000C3Ar 3               ; ## "always-native"  auto  Tali Forth
000C3Ar 3               xt_always_native:
000C3Ar 3  20 rr rr                     jsr current_to_dp
000C3Dr 3  A0 01                        ldy #1          ; offset for status byte
000C3Fr 3  B1 02                        lda (dp),y
000C41r 3  09 02                        ora #AN         ; Make sure AN flag is set
000C43r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
000C45r 3  91 02                        sta (dp),y
000C47r 3               z_always_native:
000C47r 3  60                           rts
000C48r 3               
000C48r 3               
000C48r 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
000C48r 3               ; ## "and"  auto  ANS core
000C48r 3                       ; """https://forth-standard.org/standard/core/AND"""
000C48r 3               xt_and:
000C48r 3  20 rr rr                     jsr underflow_2
000C4Br 3               
000C4Br 3  B5 00                        lda 0,x
000C4Dr 3  35 02                        and 2,x
000C4Fr 3  95 02                        sta 2,x
000C51r 3               
000C51r 3  B5 01                        lda 1,x
000C53r 3  35 03                        and 3,x
000C55r 3  95 03                        sta 3,x
000C57r 3               
000C57r 3  E8                           inx
000C58r 3  E8                           inx
000C59r 3               
000C59r 3  60           z_and:          rts
000C5Ar 3               
000C5Ar 3               
000C5Ar 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000C5Ar 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000C5Ar 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000C5Ar 3                       ; assembler words to the search order so they can be used.
000C5Ar 3                       ; See the tutorial on Wordlists and the Search Order for
000C5Ar 3                       ; more information.
000C5Ar 3                       ;
000C5Ar 3                       ; This is a dummy entry, the code is shared with TWO
000C5Ar 3                       ; """
000C5Ar 3               
000C5Ar 3               
000C5Ar 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000C5Ar 3               ; ## "at-xy"  tested  ANS facility
000C5Ar 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000C5Ar 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000C5Ar 3                       ; ANSI code is ESC[<n>;<m>H
000C5Ar 3                       ;
000C5Ar 3                       ; Do not use U. to print the numbers because the
000C5Ar 3                       ; trailing space will not work with xterm
000C5Ar 3                       ; """
000C5Ar 3               xt_at_xy:
000C5Ar 3  20 rr rr                     jsr underflow_2
000C5Dr 3               
000C5Dr 3  A9 1B                        lda #AscESC
000C5Fr 3  20 rr rr                     jsr emit_a
000C62r 3  A9 5B                        lda #$5B        ; ASCII for "["
000C64r 3  20 rr rr                     jsr emit_a
000C67r 3  20 rr rr                     jsr print_u
000C6Ar 3  A9 3B                        lda #$3B        ; ASCII for ";"
000C6Cr 3  20 rr rr                     jsr emit_a
000C6Fr 3  20 rr rr                     jsr print_u
000C72r 3  A9 48                        lda #'H'
000C74r 3  20 rr rr                     jsr emit_a
000C77r 3               
000C77r 3  60           z_at_xy:        rts
000C78r 3               
000C78r 3               
000C78r 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
000C78r 3               ; ## "\"  auto  ANS core ext
000C78r 3                       ; """https://forth-standard.org/standard/core/bs"""
000C78r 3               xt_backslash:
000C78r 3  A5 0A                        lda ciblen
000C7Ar 3  85 0C                        sta toin
000C7Cr 3  A5 0B                        lda ciblen+1
000C7Er 3  85 0D                        sta toin+1
000C80r 3               
000C80r 3  60           z_backslash:    rts
000C81r 3               
000C81r 3               
000C81r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000C81r 3               ; ## "base"  auto  ANS core
000C81r 3                       ; """https://forth-standard.org/standard/core/BASE
000C81r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000C81r 3                       ; ingore the MSB
000C81r 3                       ; """
000C81r 3               xt_base:
000C81r 3  CA                           dex
000C82r 3  CA                           dex
000C83r 3  A9 18                        lda #<base
000C85r 3  95 00                        sta 0,x         ; LSB
000C87r 3  74 01                        stz 1,x         ; MSB is always 0
000C89r 3               
000C89r 3  60           z_base:         rts
000C8Ar 3               
000C8Ar 3               
000C8Ar 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000C8Ar 3               ; ## "begin"  auto  ANS core
000C8Ar 3                       ; """https://forth-standard.org/standard/core/BEGIN
000C8Ar 3                       ;
000C8Ar 3                       ; This is just an immediate version of here which could just
000C8Ar 3                       ; as well be coded in Forth as
000C8Ar 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000C8Ar 3                       ; Since this is a compiling word, we don't care that much about
000C8Ar 3                       ; about speed
000C8Ar 3                       ; """
000C8Ar 3               
000C8Ar 3               xt_begin:
000C8Ar 3  20 rr rr                     jsr xt_here
000C8Dr 3  60           z_begin:        rts
000C8Er 3               
000C8Er 3               
000C8Er 3               
000C8Er 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000C8Er 3               ; ## "bell"  tested  Tali Forth
000C8Er 3               xt_bell:
000C8Er 3  A9 07                        lda #7          ; ASCII value for BELl
000C90r 3  20 rr rr                     jsr emit_a
000C93r 3               
000C93r 3  60           z_bell:         rts
000C94r 3               
000C94r 3               
000C94r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000C94r 3               ; ## "bl"  auto  ANS core
000C94r 3                       ; """https://forth-standard.org/standard/core/BL"""
000C94r 3               
000C94r 3               xt_bl:
000C94r 3  CA                           dex
000C95r 3  CA                           dex
000C96r 3  A9 20                        lda #AscSP
000C98r 3  95 00                        sta 0,x
000C9Ar 3  74 01                        stz 1,x
000C9Cr 3               
000C9Cr 3  60           z_bl:           rts
000C9Dr 3               
000C9Dr 3               
000C9Dr 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000C9Dr 3               ; ## "block"  auto  ANS block
000C9Dr 3                       ; """https://forth-standard.org/standard/block/BLK"""
000C9Dr 3               xt_blk:
000C9Dr 3                               ; BLK is at UP + blk_offset
000C9Dr 3  CA                           dex
000C9Er 3  CA                           dex
000C9Fr 3  18                           clc
000CA0r 3  A5 1E                        lda up
000CA2r 3  69 00                        adc #blk_offset ; Add offset
000CA4r 3  95 00                        sta 0,x
000CA6r 3  A5 1F                        lda up+1
000CA8r 3  69 00                        adc #0          ; Adding carry
000CAAr 3  95 01                        sta 1,x
000CACr 3               
000CACr 3  60           z_blk:          rts
000CADr 3               
000CADr 3               
000CADr 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
000CADr 3               ; ## "blkbuffer"  auto  Tali block
000CADr 3               xt_blkbuffer:
000CADr 3                               ; blkbuffer address is at UP + blkbuffer_offset.
000CADr 3                               ; Unlike some of the other user variables, we actually
000CADr 3                               ; want to push the address stored here, which will
000CADr 3                               ; point to somewhere outside of the user variables.
000CADr 3  CA                           dex
000CAEr 3  CA                           dex
000CAFr 3                               ; Put the address on the stack.
000CAFr 3  A0 28                        ldy #blkbuffer_offset
000CB1r 3  B1 1E                        lda (up),y
000CB3r 3  95 00                        sta 0,x
000CB5r 3  C8                           iny             ; Move along to the next byte
000CB6r 3  B1 1E                        lda (up),y
000CB8r 3  95 01                        sta 1,x
000CBAr 3               
000CBAr 3  60           z_blkbuffer:    rts
000CBBr 3               
000CBBr 3               
000CBBr 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
000CBBr 3               ; ## "block"  auto  ANS block
000CBBr 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
000CBBr 3               
000CBBr 3               xt_block:
000CBBr 3               
000CBBr 3                               ; See if the block requested is the same as the one we
000CBBr 3                               ; currently have in the buffer. Check the LSB.
000CBBr 3  A0 2A                        ldy #buffblocknum_offset
000CBDr 3  B1 1E                        lda (up),y
000CBFr 3  D5 00                        cmp 0,x
000CC1r 3  D0 0F                        bne @not_in_buffer
000CC3r 3               
000CC3r 3                               ; Check the MSB.
000CC3r 3  C8                           iny
000CC4r 3  B1 1E                        lda (up),y
000CC6r 3  D5 01                        cmp 1,x
000CC8r 3  D0 08                        bne @not_in_buffer
000CCAr 3               
000CCAr 3                               ; The block is in the buffer. See if the buffer is in use.
000CCAr 3  A0 2C                        ldy #buffstatus_offset
000CCCr 3  B1 1E                        lda (up),y
000CCEr 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000CD0r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000CD2r 3                                               ; @done will replace the block# with the
000CD2r 3                                               ; buffer address.
000CD2r 3               @not_in_buffer:
000CD2r 3                               ; Check the buffer status
000CD2r 3  A0 2C                        ldy #buffstatus_offset
000CD4r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
000CD6r 3  C9 03                        cmp #3          ; LSB is needed.
000CD8r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000CDAr 3               
000CDAr 3                               ; We need to save the block.
000CDAr 3  20 rr rr                     jsr xt_blkbuffer
000CDDr 3  20 rr rr                     jsr xt_buffblocknum
000CE0r 3  20 rr rr                     jsr xt_fetch
000CE3r 3  20 rr rr                     jsr xt_block_write
000CE6r 3               
000CE6r 3               @buffer_available:
000CE6r 3                               ; Save the block number.
000CE6r 3  A0 2A                        ldy #buffblocknum_offset
000CE8r 3  B5 00                        lda 0,x
000CEAr 3  91 1E                        sta (up),y
000CECr 3  C8                           iny
000CEDr 3  B5 01                        lda 1,x
000CEFr 3  91 1E                        sta (up),y
000CF1r 3               
000CF1r 3                               ; Get the requested block.
000CF1r 3  20 rr rr                     jsr xt_blkbuffer
000CF4r 3  20 rr rr                     jsr xt_swap
000CF7r 3  20 rr rr                     jsr xt_block_read
000CFAr 3               
000CFAr 3                               ; Mark the buffer as clean and in-use.
000CFAr 3  A9 01                        lda #1
000CFCr 3  A0 2C                        ldy #buffstatus_offset
000CFEr 3  91 1E                        sta (up),y
000D00r 3               
000D00r 3                               ; Make room on the stack for the return address.
000D00r 3  CA                           dex
000D01r 3  CA                           dex
000D02r 3               
000D02r 3               @done:
000D02r 3                               ; It's in the buffer. Return the buffer address.
000D02r 3  A0 28                        ldy #blkbuffer_offset
000D04r 3  B1 1E                        lda (up),y
000D06r 3  95 00                        sta 0,x
000D08r 3  C8                           iny
000D09r 3  B1 1E                        lda (up),y
000D0Br 3  95 01                        sta 1,x
000D0Dr 3               
000D0Dr 3  60           z_block:        rts
000D0Er 3               
000D0Er 3               
000D0Er 3               
000D0Er 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000D0Er 3               ; ## "block-ramdrive-init"  auto  Tali block
000D0Er 3                       ; """Create a RAM drive, with the given number of
000D0Er 3                       ; blocks, in the dictionary along with setting up the block words to
000D0Er 3                       ; use it.  The read/write routines do not provide bounds checking.
000D0Er 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000D0Er 3                       ; """
000D0Er 3               
000D0Er 3               xt_block_ramdrive_init:
000D0Er 3  20 rr rr                     jsr underflow_1
000D11r 3               
000D11r 3                               ; Store the string to run here as a string literal.
000D11r 3                               ; See SLITERAL for the format information. This way, we
000D11r 3                               ; don't have the words defined below in the Dictionary until
000D11r 3                               ; we really use them.
000D11r 3  4C rr rr                     jmp @after_ramdrive_code
000D14r 3               
000D14r 3               @ramdrive_code:
000D14r 3  62 61 73 65          .byte "base @ swap decimal"
000D18r 3  20 40 20 73  
000D1Cr 3  77 61 70 20  
000D27r 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000D2Br 3  34 20 2A     
000D2Er 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000D32r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
000D36r 3  66 65 72 3A  
000D3Ar 3  20 72 61 6D  
000D43r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000D43r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
000D47r 3  6C 6F 63 6B  
000D4Br 3  2D 72 65 61  
000D59r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000D5Dr 3  64 72 69 76  
000D61r 3  65 20 73 77  
000D81r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000D85r 3  6C 6F 63 6B  
000D89r 3  2D 77 72 69  
000D98r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000D9Cr 3  64 72 69 76  
000DA0r 3  65 20 73 77  
000DBBr 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000DBFr 3  6C 6F 63 6B  
000DC3r 3  2D 72 65 61  
000DE5r 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
000DE9r 3  6C 6F 63 6B  
000DEDr 3  2D 77 72 69  
000E11r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000E15r 3  64 72 69 76  
000E19r 3  65 20 73 77  
000E2Cr 3               
000E2Cr 3               @after_ramdrive_code:
000E2Cr 3  20 rr rr                     jsr sliteral_runtime
000E2Fr 3               
000E2Fr 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000E33r 3               
000E33r 3                               ; The address and length of the ramdrive code is now on the
000E33r 3                               ; stack. Call EVALUATE to run it.
000E33r 3  20 rr rr                     jsr xt_evaluate
000E36r 3               
000E36r 3               z_block_ramdrive_init:
000E36r 3  60                           rts
000E37r 3               
000E37r 3               
000E37r 3               
000E37r 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
000E37r 3               ; ## "block-read"  auto  Tali block
000E37r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000E37r 3                       ; with their own version to read a block from storage.
000E37r 3                       ; The stack parameters are ( buffer_address block# -- ).
000E37r 3                       ; """
000E37r 3               xt_block_read:
000E37r 3                               ; Execute the BLOCK-READ-VECTOR
000E37r 3  A0 2E                        ldy #blockread_offset
000E39r 3  B1 1E                        lda (up),y
000E3Br 3  85 24                        sta tmp1
000E3Dr 3  C8                           iny
000E3Er 3  B1 1E                        lda (up),y
000E40r 3  85 25                        sta tmp1+1
000E42r 3               
000E42r 3  6C 24 00                     jmp (tmp1)
000E45r 3               
000E45r 3               z_block_read:   ; No RTS needed
000E45r 3               
000E45r 3               
000E45r 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
000E45r 3               ; ## "block-read-vector"  auto  Tali block
000E45r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000E45r 3                       ; with their own version to read a block from storage.
000E45r 3                       ; This word gives the address of the vector so it can be replaced.
000E45r 3                       ; """
000E45r 3               xt_block_read_vector:
000E45r 3                               ; Get the BLOCK-READ-VECTOR address
000E45r 3  CA                           dex
000E46r 3  CA                           dex
000E47r 3  18                           clc
000E48r 3  A5 1E                        lda up
000E4Ar 3  69 2E                        adc #blockread_offset
000E4Cr 3  95 00                        sta 0,x
000E4Er 3  A5 1F                        lda up+1
000E50r 3  69 00                        adc #0          ; Add carry
000E52r 3  95 01                        sta 1,x
000E54r 3               
000E54r 3               z_block_read_vector:
000E54r 3  60                           rts
000E55r 3               
000E55r 3               
000E55r 3               ; This is the default error message the vectored words BLOCK-READ and
000E55r 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
000E55r 3               xt_block_word_error:
000E55r 3  A9 0C                        lda #err_blockwords
000E57r 3  4C rr rr                     jmp error       ; no RTS needed
000E5Ar 3               z_block_word_error:
000E5Ar 3               
000E5Ar 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000E5Ar 3               ; ## "block-write"  auto  Tali block
000E5Ar 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000E5Ar 3                       ; with their own version to write a block to storage.
000E5Ar 3                       ; The stack parameters are ( buffer_address block# -- ).
000E5Ar 3                       ; """
000E5Ar 3               xt_block_write:
000E5Ar 3                               ; Execute the BLOCK-READ-VECTOR
000E5Ar 3  A0 30                        ldy #blockwrite_offset
000E5Cr 3  B1 1E                        lda (up),y
000E5Er 3  85 24                        sta tmp1
000E60r 3  C8                           iny
000E61r 3  B1 1E                        lda (up),y
000E63r 3  85 25                        sta tmp1+1
000E65r 3  6C 24 00                     jmp (tmp1)
000E68r 3               
000E68r 3               z_block_write:  ; No RTS needed
000E68r 3               
000E68r 3               
000E68r 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
000E68r 3               ; ## "block-write-vector"  auto  Tali block
000E68r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000E68r 3                       ; with their own version to write a block to storage.
000E68r 3                       ; This word gives the address of the vector so it can be replaced.
000E68r 3                       ; """
000E68r 3               xt_block_write_vector:
000E68r 3                               ; Get the BLOCK-WRITE-VECTOR address
000E68r 3  CA                           dex
000E69r 3  CA                           dex
000E6Ar 3  18                           clc
000E6Br 3  A5 1E                        lda up
000E6Dr 3  69 30                        adc #blockwrite_offset
000E6Fr 3  95 00                        sta 0,x
000E71r 3  A5 1F                        lda up+1
000E73r 3  69 00                        adc #0          ; Add carry
000E75r 3  95 01                        sta 1,x
000E77r 3               
000E77r 3               z_block_write_vector:
000E77r 3  60                           rts
000E78r 3               
000E78r 3               
000E78r 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
000E78r 3               ; ## "bounds"  auto  Gforth
000E78r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
000E78r 3                       ; Given a string, return the correct Data Stack parameters for
000E78r 3                       ; a DO/LOOP loop over its characters. This is realized as
000E78r 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
000E78r 3                       ; """
000E78r 3               xt_bounds:
000E78r 3  20 rr rr                     jsr underflow_2
000E7Br 3               
000E7Br 3  18                           clc
000E7Cr 3  B5 00                        lda 0,x                 ; LSB u
000E7Er 3  B4 02                        ldy 2,x                 ; LSB addr
000E80r 3  75 02                        adc 2,x
000E82r 3  95 02                        sta 2,x                 ; LSB addr+u
000E84r 3  94 00                        sty 0,x
000E86r 3               
000E86r 3  B5 01                        lda 1,x                 ; MSB u
000E88r 3  B4 03                        ldy 3,x                 ; MSB addr
000E8Ar 3  75 03                        adc 3,x
000E8Cr 3  95 03                        sta 3,x                 ; MSB addr+u
000E8Er 3  94 01                        sty 1,x
000E90r 3               
000E90r 3  60           z_bounds:       rts
000E91r 3               
000E91r 3               
000E91r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000E91r 3               ; ## "[char]"  auto  ANS core
000E91r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000E91r 3                       ; Compile the ASCII value of a character as a literal. This is an
000E91r 3                       ; immediate, compile-only word.
000E91r 3                       ;
000E91r 3                       ; A definition given in
000E91r 3                       ; http://forth-standard.org/standard/implement is
000E91r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000E91r 3                       ; """
000E91r 3               xt_bracket_char:
000E91r 3  20 rr rr                     jsr xt_char
000E94r 3  20 rr rr                     jsr xt_literal
000E97r 3  60           z_bracket_char: rts
000E98r 3               
000E98r 3               
000E98r 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000E98r 3               ; ## "[']"  auto  ANS core
000E98r 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000E98r 3               xt_bracket_tick:
000E98r 3  20 rr rr                     jsr xt_tick
000E9Br 3  20 rr rr                     jsr xt_literal
000E9Er 3  60           z_bracket_tick: rts
000E9Fr 3               
000E9Fr 3               
000E9Fr 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000E9Fr 3               ; ## "buffblocknum"  auto  Tali block
000E9Fr 3               xt_buffblocknum:
000E9Fr 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000E9Fr 3  CA                           dex
000EA0r 3  CA                           dex
000EA1r 3  18                           clc
000EA2r 3  A5 1E                        lda up
000EA4r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000EA6r 3  95 00                        sta 0,x
000EA8r 3  A5 1F                        lda up+1
000EAAr 3  69 00                        adc #0                          ; Adding carry
000EACr 3  95 01                        sta 1,x
000EAEr 3               
000EAEr 3  60           z_buffblocknum: rts
000EAFr 3               
000EAFr 3               
000EAFr 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000EAFr 3               ; ## "buffer"  auto  ANS block
000EAFr 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000EAFr 3               
000EAFr 3               xt_buffer:
000EAFr 3                               ; Check the buffer status
000EAFr 3  A0 2C                        ldy #buffstatus_offset
000EB1r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
000EB3r 3  C9 03                        cmp #3          ; LSB is needed.
000EB5r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000EB7r 3               
000EB7r 3                               ; We need to save the block.
000EB7r 3  20 rr rr                     jsr xt_blkbuffer
000EBAr 3  20 rr rr                     jsr xt_buffblocknum
000EBDr 3  20 rr rr                     jsr xt_fetch
000EC0r 3  20 rr rr                     jsr xt_block_write
000EC3r 3               
000EC3r 3               @buffer_available:
000EC3r 3                               ; Save the block number.
000EC3r 3  A0 2A                        ldy #buffblocknum_offset
000EC5r 3  B5 00                        lda 0,x
000EC7r 3  91 1E                        sta (up),y
000EC9r 3  C8                           iny
000ECAr 3  B5 01                        lda 1,x
000ECCr 3  91 1E                        sta (up),y
000ECEr 3               
000ECEr 3                               ; Mark the buffer as clean and in-use.
000ECEr 3  A9 01                        lda #1
000ED0r 3  A0 2C                        ldy #buffstatus_offset
000ED2r 3  91 1E                        sta (up),y
000ED4r 3               
000ED4r 3               @done:
000ED4r 3                               ; Return the buffer address.
000ED4r 3  A0 28                        ldy #blkbuffer_offset
000ED6r 3  B1 1E                        lda (up),y
000ED8r 3  95 00                        sta 0,x
000EDAr 3  C8                           iny
000EDBr 3  B1 1E                        lda (up),y
000EDDr 3  95 01                        sta 1,x
000EDFr 3               
000EDFr 3  60           z_buffer:       rts
000EE0r 3               
000EE0r 3               
000EE0r 3               
000EE0r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
000EE0r 3               ; ## "buffer:"  auto  ANS core ext
000EE0r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
000EE0r 3                               ; Create a buffer of size u that puts its address on the stack
000EE0r 3                               ; when its name is used.
000EE0r 3                               ; """
000EE0r 3               xt_buffer_colon:
000EE0r 3  20 rr rr                     jsr xt_create
000EE3r 3  20 rr rr                     jsr xt_allot
000EE6r 3  60           z_buffer_colon: rts
000EE7r 3               
000EE7r 3               
000EE7r 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
000EE7r 3               ; ## "buffstatus"  auto  Tali block
000EE7r 3               xt_buffstatus:
000EE7r 3                               ; BUFFSTATUS is at UP + buffstatus_offset
000EE7r 3  CA                           dex
000EE8r 3  CA                           dex
000EE9r 3  18                           clc
000EEAr 3  A5 1E                        lda up
000EECr 3  69 2C                        adc #buffstatus_offset  ; Add offset
000EEEr 3  95 00                        sta 0,x
000EF0r 3  A5 1F                        lda up+1
000EF2r 3  69 00                        adc #0                  ; Adding carry
000EF4r 3  95 01                        sta 1,x
000EF6r 3               
000EF6r 3  60           z_buffstatus:   rts
000EF7r 3               
000EF7r 3               
000EF7r 3               ; ## BYE ( -- ) "Break"
000EF7r 3               ; ## "bye"  tested  ANS tools ext
000EF7r 3                       ; """https://forth-standard.org/standard/tools/BYE"""
000EF7r 3               
000EF7r 3               xt_bye:
000EF7r 3                               ;brk
000EF7r 3  4C rr rr                     jmp platform_bye
000EFAr 3               z_bye:          ;rts             ; never reached
000EFAr 3               
000EFAr 3               
000EFAr 3               
000EFAr 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
000EFAr 3               ; ## "c,"  auto  ANS core
000EFAr 3                       ; """https://forth-standard.org/standard/core/CComma"""
000EFAr 3               
000EFAr 3               xt_c_comma:
000EFAr 3  20 rr rr                     jsr underflow_1
000EFDr 3               
000EFDr 3  B5 00                        lda 0,x
000EFFr 3  20 rr rr                     jsr cmpl_a
000F02r 3               
000F02r 3  E8                           inx
000F03r 3  E8                           inx
000F04r 3               
000F04r 3  60           z_c_comma:      rts
000F05r 3               
000F05r 3               
000F05r 3               
000F05r 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
000F05r 3               ; ## "c@"  auto  ANS core
000F05r 3                       ; """https://forth-standard.org/standard/core/CFetch"""
000F05r 3               xt_c_fetch:
000F05r 3  20 rr rr                     jsr underflow_1
000F08r 3               
000F08r 3  A1 00                        lda (0,x)
000F0Ar 3  95 00                        sta 0,x
000F0Cr 3  74 01                        stz 1,x         ; Ignore LSB
000F0Er 3               
000F0Er 3  60           z_c_fetch:      rts
000F0Fr 3               
000F0Fr 3               
000F0Fr 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000F0Fr 3               ; ## "c!"  auto  ANS core
000F0Fr 3                       ; """https://forth-standard.org/standard/core/CStore"""
000F0Fr 3               xt_c_store:
000F0Fr 3  20 rr rr                     jsr underflow_2
000F12r 3               
000F12r 3  B5 02                        lda 2,x
000F14r 3  81 00                        sta (0,x)
000F16r 3               
000F16r 3  E8                           inx
000F17r 3  E8                           inx
000F18r 3  E8                           inx
000F19r 3  E8                           inx
000F1Ar 3               
000F1Ar 3  60           z_c_store:      rts
000F1Br 3               
000F1Br 3               
000F1Br 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000F1Br 3               ; ## "case"  auto  ANS core ext
000F1Br 3                       ; """http://forth-standard.org/standard/core/CASE
000F1Br 3                       ;
000F1Br 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000F1Br 3                       ; """
000F1Br 3               
000F1Br 3               
000F1Br 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000F1Br 3               ; ## "cell+"  auto  ANS core
000F1Br 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000F1Br 3                       ; Add the number of bytes ("address units") that one cell needs.
000F1Br 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000F1Br 3                       ; """
000F1Br 3               
000F1Br 3               xt_cell_plus:
000F1Br 3  20 rr rr                     jsr underflow_1
000F1Er 3               
000F1Er 3  F6 00                        inc 0,x
000F20r 3  D0 02                        bne @1
000F22r 3  F6 01                        inc 1,x
000F24r 3               @1:
000F24r 3  F6 00                        inc 0,x
000F26r 3  D0 02                        bne @done
000F28r 3  F6 01                        inc 1,x
000F2Ar 3               @done:
000F2Ar 3  60           z_cell_plus:    rts
000F2Br 3               
000F2Br 3               
000F2Br 3               
000F2Br 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000F2Br 3               ; ## "cells"  auto  ANS core
000F2Br 3                       ; """https://forth-standard.org/standard/core/CELLS
000F2Br 3                       ;
000F2Br 3                       ; Dummy entry for the CELLS word, the code is the same as for
000F2Br 3                       ; 2*, which is where the header directs us to
000F2Br 3                       ; """
000F2Br 3               
000F2Br 3               
000F2Br 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000F2Br 3               ; ## "char"  auto  ANS core
000F2Br 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000F2Br 3               
000F2Br 3               xt_char:
000F2Br 3                               ; get character from string, returns ( addr u )
000F2Br 3  20 rr rr                     jsr xt_parse_name
000F2Er 3               
000F2Er 3                               ; if we got back a zero, we have a problem
000F2Er 3  B5 00                        lda 0,x
000F30r 3  15 01                        ora 1,x
000F32r 3  D0 05                        bne @not_empty
000F34r 3               
000F34r 3  A9 05                        lda #err_noname
000F36r 3  4C rr rr                     jmp error
000F39r 3               
000F39r 3               @not_empty:
000F39r 3  E8                           inx             ; drop number of characters, leave addr
000F3Ar 3  E8                           inx
000F3Br 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000F3Dr 3  95 00                        sta 0,x
000F3Fr 3  74 01                        stz 1,x         ; MSB is always zero
000F41r 3               
000F41r 3  60           z_char:         rts
000F42r 3               
000F42r 3               
000F42r 3               
000F42r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000F42r 3               ; ## "char+"  auto  ANS core
000F42r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000F42r 3                       ;
000F42r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000F42r 3                       ; """
000F42r 3               
000F42r 3               
000F42r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000F42r 3               ; ## "chars"  auto  ANS core
000F42r 3                       ; """https://forth-standard.org/standard/core/CHARS
000F42r 3                       ; Return how many address units n chars are. Since this is an 8 bit
000F42r 3                       ; machine, this does absolutely nothing and is included for
000F42r 3                       ; compatibility with other Forth versions
000F42r 3                       ; """
000F42r 3               
000F42r 3               xt_chars:
000F42r 3                               ; Checking for underflow seems a bit stupid because this
000F42r 3                               ; routine does nothing on this machine. However, the user
000F42r 3                               ; should be warned that there is something wrong with the
000F42r 3                               ; code if this occurs.
000F42r 3  20 rr rr                     jsr underflow_1
000F45r 3               
000F45r 3  60           z_chars:        rts
000F46r 3               
000F46r 3               
000F46r 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
000F46r 3               ; ## "cleave"  auto  Tali Forth
000F46r 3               
000F46r 3                       ; """Given a range of memory with words delimited by whitespace,return
000F46r 3                       ; the first word at the top of the stack and the rest of the word
000F46r 3                       ; following it.
000F46r 3                       ;
000F46r 3                       ; Example:
000F46r 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
000F46r 3                       ; s" w1" cleave        -> "" "w1"
000F46r 3                       ;
000F46r 3                       ; Since it will be used in loops a lot, we want it to work in pure
000F46r 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
000F46r 3                       ; strip leading delimiters.
000F46r 3                       ; """
000F46r 3               
000F46r 3               xt_cleave:
000F46r 3  20 rr rr                     jsr underflow_2
000F49r 3               
000F49r 3                               ; We arrive here with ( addr u ). We need to strip any leading
000F49r 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
000F49r 3                               ; remember how many spaces were stripped. This means we can't
000F49r 3                               ; calculate the length of the remainder. Fortunately, Tali
000F49r 3                               ; Forth has just the word we need for this:
000F49r 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000F4Cr 3               
000F4Cr 3                               ; The main part we can turn over to PARSE-NAME, except that we
000F4Cr 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000F4Cr 3                               ; We get around this by cheating: We place ( addr u ) in the
000F4Cr 3                               ; input buffer and then call PARSE-NAME.
000F4Cr 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000F4Fr 3               
000F4Fr 3  B5 00                        lda 0,x         ; u is new ciblen
000F51r 3  85 0A                        sta ciblen
000F53r 3  B5 01                        lda 1,x
000F55r 3  85 0B                        sta ciblen+1
000F57r 3               
000F57r 3  B5 02                        lda 2,x         ; addr is new cib
000F59r 3  85 08                        sta cib
000F5Br 3  B5 03                        lda 3,x
000F5Dr 3  85 09                        sta cib+1
000F5Fr 3               
000F5Fr 3  64 0C                        stz toin        ; >IN pointer is zero
000F61r 3  64 0D                        stz toin+1
000F63r 3               
000F63r 3                               ; PARSE-NAME gives us back the substring of the first word
000F63r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
000F66r 3               
000F66r 3                               ; If we were given an empty string, then we're done. It's the
000F66r 3                               ; resposibility of the user to catch this as a sign to end the
000F66r 3                               ; any loop
000F66r 3  B5 00                        lda 0,x
000F68r 3  15 01                        ora 1,x
000F6Ar 3  F0 23                        beq @done
000F6Cr 3               
000F6Cr 3                               ; Now we have to adjust the original string
000F6Cr 3  B5 04                        lda 4,x         ; LSB of original u
000F6Er 3  38                           sec
000F6Fr 3  F5 00                        sbc 0,x
000F71r 3  95 04                        sta 4,x
000F73r 3               
000F73r 3  B5 05                        lda 5,x         ; MSB of original u
000F75r 3  F5 01                        sbc 1,x
000F77r 3  95 05                        sta 5,x
000F79r 3               
000F79r 3  B5 06                        lda 6,x         ; LSB of original addr
000F7Br 3  18                           clc
000F7Cr 3  75 00                        adc 0,x
000F7Er 3  95 06                        sta 6,x
000F80r 3               
000F80r 3  B5 07                        lda 7,x         ; MSB of original addr
000F82r 3  75 01                        adc 1,x
000F84r 3  95 07                        sta 7,x
000F86r 3               
000F86r 3                               ; There is one small problem: PARSE-NAME will probably have
000F86r 3                               ; left the string with the rest of the words with leading
000F86r 3                               ; delimiters. We use our magic -LEADING again
000F86r 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
000F89r 3  20 rr rr                     jsr xt_minus_leading
000F8Cr 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000F8Fr 3               @done:
000F8Fr 3                               ; Restore input
000F8Fr 3  20 rr rr                     jsr xt_r_to_input
000F92r 3               
000F92r 3  60           z_cleave:       rts
000F93r 3               
000F93r 3               
000F93r 3               
000F93r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000F93r 3               ; ## "cmove"  auto  ANS string
000F93r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000F93r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000F93r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000F93r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000F93r 3                       ; "move left".
000F93r 3                       ;
000F93r 3                       ; There are no official tests for this word.
000F93r 3                       ; """
000F93r 3               
000F93r 3               xt_cmove:
000F93r 3  20 rr rr                     jsr underflow_3
000F96r 3               
000F96r 3                               ; move destination address to where we can work with it
000F96r 3  B5 02                        lda 2,x
000F98r 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
000F9Ar 3  B5 03                        lda 3,x
000F9Cr 3  85 27                        sta tmp2+1
000F9Er 3               
000F9Er 3                               ; move source address to where we can work with it
000F9Er 3  B5 04                        lda 4,x
000FA0r 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
000FA2r 3  B5 05                        lda 5,x
000FA4r 3  85 25                        sta tmp1+1
000FA6r 3               
000FA6r 3  A0 00                        ldy #0
000FA8r 3  B5 01                        lda 1,x         ; number of whole pages to move
000FAAr 3  F0 0F                        beq @dopartial
000FACr 3               
000FACr 3               @page:
000FACr 3  B1 24                        lda (tmp1),y
000FAEr 3  91 26                        sta (tmp2),y
000FB0r 3  C8                           iny
000FB1r 3  D0 F9                        bne @page
000FB3r 3               
000FB3r 3  E6 25                        inc tmp1+1
000FB5r 3  E6 27                        inc tmp2+1
000FB7r 3  D6 01                        dec 1,x
000FB9r 3  D0 F1                        bne @page
000FBBr 3               
000FBBr 3               @dopartial:
000FBBr 3  B5 00                        lda 0,x         ; length of last page
000FBDr 3  F0 09                        beq @done
000FBFr 3               
000FBFr 3               @partial:
000FBFr 3  B1 24                        lda (tmp1),y
000FC1r 3  91 26                        sta (tmp2),y
000FC3r 3  C8                           iny
000FC4r 3               
000FC4r 3  D6 00                        dec 0,x
000FC6r 3  D0 F7                        bne @partial
000FC8r 3               
000FC8r 3               @done:          ; clear the stack
000FC8r 3  8A                           txa
000FC9r 3  18                           clc
000FCAr 3  69 06                        adc #6
000FCCr 3  AA                           tax
000FCDr 3               
000FCDr 3  60           z_cmove:        rts
000FCEr 3               
000FCEr 3               
000FCEr 3               
000FCEr 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
000FCEr 3               ; ## "cmove>"  auto  ANS string
000FCEr 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
000FCEr 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
000FCEr 3                       ; Routines", p. 201, where it is called "move right".
000FCEr 3                       ;
000FCEr 3                       ; There are no official tests for this word.
000FCEr 3                       ; """
000FCEr 3               
000FCEr 3               xt_cmove_up:
000FCEr 3  20 rr rr                     jsr underflow_3
000FD1r 3               
000FD1r 3                               ; Move destination address to where we can work with it
000FD1r 3  B5 02                        lda 2,x
000FD3r 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
000FD5r 3  B5 03                        lda 3,x
000FD7r 3  18                           clc
000FD8r 3  75 01                        adc 1,x
000FDAr 3  85 27                        sta tmp2+1      ; point to last page of destination
000FDCr 3               
000FDCr 3                               ; Move source address to where we can work with it
000FDCr 3  B5 04                        lda 4,x
000FDEr 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
000FE0r 3  B5 05                        lda 5,x
000FE2r 3  18                           clc
000FE3r 3  75 01                        adc 1,x
000FE5r 3  85 25                        sta tmp1+1      ; point to last page of source
000FE7r 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
000FE9r 3               
000FE9r 3                               ; Move the last partial page first
000FE9r 3  B4 00                        ldy 0,x         ; length of last page
000FEBr 3  F0 0E                        beq @nopartial
000FEDr 3               
000FEDr 3               @outerloop:
000FEDr 3  88                           dey
000FEEr 3  F0 07                        beq @finishpage
000FF0r 3               
000FF0r 3               @innerloop:
000FF0r 3  B1 24                        lda (tmp1),y
000FF2r 3  91 26                        sta (tmp2),y
000FF4r 3  88                           dey
000FF5r 3  D0 F9                        bne @innerloop
000FF7r 3               
000FF7r 3               @finishpage:
000FF7r 3  B2 24                        lda (tmp1)      ; handle y = 0 separately
000FF9r 3  92 26                        sta (tmp2)
000FFBr 3               
000FFBr 3               @nopartial:
000FFBr 3  C6 25                        dec tmp1+1      ; back up to previous pages
000FFDr 3  C6 27                        dec tmp2+1
000FFFr 3  D6 01                        dec 1,x
001001r 3  D0 EA                        bne @outerloop
001003r 3               @done:
001003r 3                               ; clear up the stack and leave
001003r 3  8A                           txa
001004r 3  18                           clc
001005r 3  69 06                        adc #6
001007r 3  AA                           tax
001008r 3               
001008r 3  60           z_cmove_up:     rts
001009r 3               
001009r 3               
001009r 3               
001009r 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
001009r 3               ; ## ":"  auto  ANS core
001009r 3                       ; """https://forth-standard.org/standard/core/Colon
001009r 3                       ;
001009r 3                       ; Use the CREATE routine and fill in the rest by hand.
001009r 3                       ; """
001009r 3               
001009r 3               xt_colon:
001009r 3                               ; If we're already in the compile state, complain
001009r 3                               ; and quit
001009r 3  A5 16                        lda state
00100Br 3  05 17                        ora state+1
00100Dr 3  F0 05                        beq @1
00100Fr 3               
00100Fr 3  A9 07                        lda #err_state
001011r 3  4C rr rr                     jmp error
001014r 3               @1:
001014r 3                               ; switch to compile state
001014r 3  C6 16                        dec state
001016r 3  C6 17                        dec state+1
001018r 3               
001018r 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
001018r 3                               ; word
001018r 3  A9 40                        lda #%01000000
00101Ar 3  04 20                        tsb status
00101Cr 3               
00101Cr 3                               ; CREATE is going to change the DP to point to the new word's
00101Cr 3                               ; header. While this is fine for (say) variables, it would mean
00101Cr 3                               ; that FIND-NAME etc would find a half-finished word when
00101Cr 3                               ; looking in the Dictionary. To prevent this, we save the old
00101Cr 3                               ; version of DP and restore it later. The new DP is placed in
00101Cr 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
00101Cr 3  20 rr rr                     jsr current_to_dp
00101Fr 3  A5 03                        lda dp+1            ; CREATE uses a lot of variables
001021r 3  48                           pha
001022r 3  A5 02                        lda dp
001024r 3  48                           pha
001025r 3               
001025r 3                               ; Tell create not to print warning for duplicate name.
001025r 3  A9 80                        lda #%10000000
001027r 3  04 20                        tsb status
001029r 3               
001029r 3  20 rr rr                     jsr xt_create
00102Cr 3               
00102Cr 3                               ; Get the nt (not the xt!) of the new word as described above.
00102Cr 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
00102Cr 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
00102Fr 3  A5 02                        lda dp
001031r 3  85 04                        sta workword
001033r 3  A5 03                        lda dp+1
001035r 3  85 05                        sta workword+1
001037r 3               
001037r 3                               ; Restore original DP
001037r 3  68                           pla
001038r 3  85 02                        sta dp
00103Ar 3  68                           pla
00103Br 3  85 03                        sta dp+1
00103Dr 3  20 rr rr                     jsr dp_to_current
001040r 3               
001040r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
001040r 3                               ; back up three bytes and overwrite that.
001040r 3  A5 00                        lda cp
001042r 3  38                           sec
001043r 3  E9 03                        sbc #3
001045r 3  85 00                        sta cp
001047r 3  B0 02                        bcs @done
001049r 3  C6 01                        dec cp+1
00104Br 3               @done:
00104Br 3  60           z_colon:        rts
00104Cr 3               
00104Cr 3               
00104Cr 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
00104Cr 3               ; ## ":NONAME"  auto  ANS core
00104Cr 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
00104Cr 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
00104Cr 3                       ; """
00104Cr 3               
00104Cr 3               xt_colon_noname:
00104Cr 3                               ; If we're already in the compile state, complain
00104Cr 3                               ; and quit
00104Cr 3  A5 16                        lda state
00104Er 3  05 17                        ora state+1
001050r 3  F0 05                        beq @1
001052r 3               
001052r 3  A9 07                        lda #err_state
001054r 3  4C rr rr                     jmp error
001057r 3               @1:
001057r 3                               ; switch to compile state
001057r 3  C6 16                        dec state
001059r 3  C6 17                        dec state+1
00105Br 3               
00105Br 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
00105Br 3                               ; a :NONAME word.
00105Br 3  A9 40                        lda #%01000000
00105Dr 3  14 20                        trb status
00105Fr 3               
00105Fr 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
00105Fr 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
00105Fr 3                               ; nt and they will modify their behavior.
00105Fr 3  A5 00                        lda cp
001061r 3  85 04                        sta workword
001063r 3  A5 01                        lda cp+1
001065r 3  85 05                        sta workword+1
001067r 3               @done:
001067r 3  60           z_colon_noname:        rts
001068r 3               
001068r 3               
001068r 3               
001068r 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
001068r 3               ; ## ","  auto  ANS core
001068r 3                       ; """https://forth-standard.org/standard/core/Comma
001068r 3                       ; Store TOS at current place in memory.
001068r 3                       ;
001068r 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
001068r 3                       ; """
001068r 3               
001068r 3               xt_comma:
001068r 3  20 rr rr                     jsr underflow_1
00106Br 3               
00106Br 3  B5 00                        lda 0,x
00106Dr 3  92 00                        sta (cp)
00106Fr 3               
00106Fr 3  E6 00                        inc cp
001071r 3  D0 02                        bne @1
001073r 3  E6 01                        inc cp+1
001075r 3               @1:
001075r 3  B5 01                        lda 1,x
001077r 3  92 00                        sta (cp)
001079r 3               
001079r 3  E6 00                        inc cp
00107Br 3  D0 02                        bne @done
00107Dr 3  E6 01                        inc cp+1
00107Fr 3               @done:
00107Fr 3  E8                           inx
001080r 3  E8                           inx
001081r 3               
001081r 3  60           z_comma:        rts
001082r 3               
001082r 3               
001082r 3               
001082r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
001082r 3               ; ## "compare"   auto  ANS string
001082r 3                       ; """https://forth-standard.org/standard/string/COMPARE
001082r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
001082r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
001082r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
001082r 3                       ; that entirely matches the beginning of the other string, but is
001082r 3                       ; shorter, is considered less than the longer string.
001082r 3                       ; """
001082r 3               
001082r 3               xt_compare:
001082r 3  20 rr rr                     jsr underflow_4
001085r 3               
001085r 3                               ; Load the two string addresses into tmp1 and tmp2.
001085r 3  B5 02                        lda 2,x
001087r 3  85 26                        sta tmp2
001089r 3  B5 03                        lda 3,x
00108Br 3  85 27                        sta tmp2+1
00108Dr 3  B5 06                        lda 6,x
00108Fr 3  85 24                        sta tmp1
001091r 3  B5 07                        lda 7,x
001093r 3  85 25                        sta tmp1+1
001095r 3                               ; The counts will be used in-place on the stack.
001095r 3               
001095r 3               @compare_loop:
001095r 3                               ; Check to see if we are out of letters.
001095r 3               
001095r 3                               ; Check string1
001095r 3  B5 04                        lda 4,x
001097r 3  15 05                        ora 5,x
001099r 3  F0 2C                        beq @str1_done
00109Br 3               
00109Br 3                               ; Check string2
00109Br 3  B5 00                        lda 0,x
00109Dr 3  15 01                        ora 1,x
00109Fr 3  F0 3A                        beq @greater    ; Str2 empty first
0010A1r 3               
0010A1r 3               @check_letter:
0010A1r 3                               ; Both strings have at least one letter left.
0010A1r 3                               ; Check the letters against each other.
0010A1r 3  B2 24                        lda (tmp1)
0010A3r 3  D2 26                        cmp (tmp2)
0010A5r 3  90 26                        bcc @less
0010A7r 3  D0 32                        bne @greater
0010A9r 3               @next_letter:
0010A9r 3                               ; Move both tmp pointers and decrement the counts
0010A9r 3                               ; on the stack.
0010A9r 3                               ; Increment tmp1
0010A9r 3  E6 24                        inc tmp1
0010ABr 3  D0 02                        bne @1
0010ADr 3  E6 25                        inc tmp1+1
0010AFr 3               @1:
0010AFr 3                               ; Increment tmp2
0010AFr 3  E6 26                        inc tmp2
0010B1r 3  D0 02                        bne @2
0010B3r 3  E6 27                        inc tmp2+1
0010B5r 3               @2:
0010B5r 3                               ; Decrement count1 on the stack.
0010B5r 3  B5 04                        lda 4,x
0010B7r 3  D0 02                        bne @3
0010B9r 3  D6 05                        dec 5,x
0010BBr 3               @3:
0010BBr 3  D6 04                        dec 4,x
0010BDr 3               
0010BDr 3                               ; Decrement count2 on the stack.
0010BDr 3  B5 00                        lda 0,x
0010BFr 3  D0 02                        bne @4
0010C1r 3  D6 01                        dec 1,x
0010C3r 3               @4:
0010C3r 3  D6 00                        dec 0,x
0010C5r 3               
0010C5r 3                               ; Loop around and check again.
0010C5r 3  80 CE                        bra @compare_loop
0010C7r 3               
0010C7r 3               @str1_done:
0010C7r 3                               ; String 1 is out of letters. Check string 2.
0010C7r 3  B5 00                        lda 0,x
0010C9r 3  15 01                        ora 1,x
0010CBr 3  F0 08                        beq @equal      ; Both out of letters
0010CDr 3               
0010CDr 3                               ; Falls into less (str1 is out but str2 has more)
0010CDr 3               @less:
0010CDr 3                               ; Return -1
0010CDr 3  A9 FF                        lda #$FF
0010CFr 3  95 06                        sta 6,x
0010D1r 3  95 07                        sta 7,x
0010D3r 3  80 0C                        bra @done
0010D5r 3               @equal:
0010D5r 3                               ; Return 0
0010D5r 3  74 06                        stz 6,x
0010D7r 3  74 07                        stz 7,x
0010D9r 3  80 06                        bra @done
0010DBr 3               @greater:
0010DBr 3                               ; Return 1
0010DBr 3  A9 01                        lda #1
0010DDr 3  95 06                        sta 6,x
0010DFr 3  74 07                        stz 7,x
0010E1r 3                               ; Falls into @done
0010E1r 3               @done:
0010E1r 3                               ; Remove all but the result from the stack.
0010E1r 3  8A                           txa
0010E2r 3  18                           clc
0010E3r 3  69 06                        adc #6
0010E5r 3  AA                           tax
0010E6r 3               
0010E6r 3  60           z_compare:      rts
0010E7r 3               
0010E7r 3               
0010E7r 3               
0010E7r 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
0010E7r 3               ; ## "compile,"  auto  ANS core ext
0010E7r 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
0010E7r 3                       ; Compile the given xt in the current word definition. It is an
0010E7r 3                       ; error if we are not in the compile state. Because we are using
0010E7r 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
0010E7r 3                       ; the traditional way. By default, native compiled is allowed, unless
0010E7r 3                       ; there is a NN (Never Native) flag associated. If not, we use the
0010E7r 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
0010E7r 3                       ; is too large to be natively coded: If the size is larger than
0010E7r 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
0010E7r 3                       ; Native) flag is set, the word is always natively compiled.
0010E7r 3                       ; """
0010E7r 3               
0010E7r 3               xt_compile_comma:
0010E7r 3  20 rr rr                     jsr underflow_1
0010EAr 3               
0010EAr 3                               ; See if this is an Always Native (AN) word by checking the
0010EAr 3                               ; AN flag. We need nt for this. First, save a copy of xt to
0010EAr 3                               ; the Return Stack
0010EAr 3  B5 01                        lda 1,x                 ; MSB
0010ECr 3  48                           pha
0010EDr 3  B5 00                        lda 0,x
0010EFr 3  48                           pha                     ; LSB
0010F0r 3               
0010F0r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
0010F3r 3               
0010F3r 3                               ; See if this xt even has an nt.
0010F3r 3  B5 00                        lda 0,x
0010F5r 3  15 01                        ora 1,x
0010F7r 3  D0 03                        bne @check_nt
0010F9r 3               
0010F9r 3                               ; No nt in dictionary. Just compile as a JSR.
0010F9r 3  4C rr rr                     jmp @compile_as_jump
0010FCr 3               
0010FCr 3               @check_nt:
0010FCr 3                               ; put nt away for safe keeping
0010FCr 3  B5 00                        lda 0,x
0010FEr 3  85 2C                        sta tmptos
001100r 3  B5 01                        lda 1,x
001102r 3  85 2D                        sta tmptos+1
001104r 3               
001104r 3                               ; status byte is one further down
001104r 3  F6 00                        inc 0,x
001106r 3  D0 02                        bne @1
001108r 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
00110Ar 3               @1:
00110Ar 3  A1 00                        lda (0,x)
00110Cr 3  85 28                        sta tmp3                ; keep copy of status byte for NN
00110Er 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
001110r 3  F0 0D                        beq @compile_check
001112r 3               
001112r 3                               ; We're natively compiling no matter what. Get length and
001112r 3                               ; compile in code. Get the original nt back
001112r 3  A5 2C                        lda tmptos
001114r 3  95 00                        sta 0,x
001116r 3  A5 2D                        lda tmptos+1
001118r 3  95 01                        sta 1,x
00111Ar 3               
00111Ar 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
00111Dr 3               
00111Dr 3  80 27                        bra @compile_as_code
00111Fr 3               
00111Fr 3               @compile_check:
00111Fr 3                               ; See if Native Compile is even alowed by checking the NN
00111Fr 3                               ; flag
00111Fr 3  A5 28                        lda tmp3
001121r 3  29 08                        and #NN
001123r 3  F0 03                        beq @check_size_limit
001125r 3               
001125r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
001128r 3               
001128r 3               @check_size_limit:
001128r 3                               ; Native compile is a legal option, but we need to see what
001128r 3                               ; limit the user set for size (in nc_limit)
001128r 3  A5 2C                        lda tmptos
00112Ar 3  95 00                        sta 0,x
00112Cr 3  A5 2D                        lda tmptos+1
00112Er 3  95 01                        sta 1,x
001130r 3               
001130r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
001133r 3               
001133r 3                               ; Check the wordsize MSB against the user-defined limit.
001133r 3  B5 01                        lda 1,x
001135r 3  C5 1B                        cmp nc_limit+1
001137r 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
001139r 3  D0 08                        bne @jumpto_compile_as_jump
00113Br 3               
00113Br 3                               ; Check the wordsize LSB against the user-defined limit.
00113Br 3  B5 00                        lda 0,x
00113Dr 3  C5 1A                        cmp nc_limit            ; user-defined limit LSB
00113Fr 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
001141r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
001143r 3               
001143r 3               @jumpto_compile_as_jump:
001143r 3                               ; If the wordsize is greater than the user-defined
001143r 3                               ; limit, it will be compiled as a subroutine jump.
001143r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
001146r 3               
001146r 3               @compile_as_code:
001146r 3                               ; We arrive here with the length of the word's code TOS and
001146r 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
001146r 3                               ; on the data stack
001146r 3  CA                           dex
001147r 3  CA                           dex                     ; ( -- u ? )
001148r 3  CA                           dex
001149r 3  CA                           dex                     ; ( -- u ? ? )
00114Ar 3               
00114Ar 3  B5 04                        lda 4,x
00114Cr 3  95 00                        sta 0,x                 ; LSB of u
00114Er 3  B5 05                        lda 5,x
001150r 3  95 01                        sta 1,x                 ; ( -- u ? u )
001152r 3               
001152r 3  68                           pla
001153r 3  95 04                        sta 4,x                 ; LSB of xt
001155r 3  68                           pla
001156r 3  95 05                        sta 5,x                 ; ( -- xt ? u )
001158r 3               
001158r 3  A5 00                        lda cp                  ; LSB of cp
00115Ar 3  95 02                        sta 2,x
00115Cr 3  A5 01                        lda cp+1
00115Er 3  95 03                        sta 3,x                 ; ( -- xt cp u )
001160r 3               
001160r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
001160r 3               
001160r 3                               ; Native compiling allows us to strip the stack antics off
001160r 3                               ; a number of words that use the Return Stack such as >R, R>,
001160r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
001160r 3                               ; xt with the contents of the table
001160r 3  A0 00                        ldy #0
001162r 3               
001162r 3               @strip_loop:
001162r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
001165r 3  D5 04                        cmp 4,x                 ; LSB of xt
001167r 3  D0 07                        bne @next_entry
001169r 3               
001169r 3                               ; LSB is the same, test MSB
001169r 3  B9 rr rr                     lda @strip_table+1,y
00116Cr 3  D5 05                        cmp 5,x
00116Er 3  F0 0C                        beq @found_entry
001170r 3               
001170r 3                               ; MSB is not equal. Pretend though that we've come from LSB
001170r 3                               ; so we can use the next step for both cases
001170r 3               @next_entry:
001170r 3                               ; Not a word that needs stripping, so check next entry in table
001170r 3                               ; Let's see if we're done with the table (marked by zero entry)
001170r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
001173r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
001176r 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
001178r 3               
001178r 3  C8                           iny
001179r 3  C8                           iny
00117Ar 3  80 E6                        bra @strip_loop
00117Cr 3               @found_entry:
00117Cr 3                               ; This word is one of the ones that needs to have its size
00117Cr 3                               ; adjusted during native compile. We find the values in the
00117Cr 3                               ; next table with the same index, which is Y. However, Y is
00117Cr 3                               ; pointing to the MSB, so we need to go back to the LSB and
00117Cr 3                               ; halve the index before we can use it.
00117Cr 3  98                           tya
00117Dr 3  4A                           lsr
00117Er 3  A8                           tay
00117Fr 3               
00117Fr 3                               ; Get the adjustment out of the size table. We were clever
00117Fr 3                               ; enough to make sure the cut on both ends of the code is
00117Fr 3                               ; is the same size.
00117Fr 3  B9 rr rr                     lda @strip_size,y
001182r 3  85 2C                        sta tmptos              ; save a copy
001184r 3               
001184r 3                               ; Adjust xt: Start later
001184r 3  18                           clc
001185r 3  75 04                        adc 4,x
001187r 3  95 04                        sta 4,x
001189r 3  90 02                        bcc @2
00118Br 3  F6 05                        inc 5,x                 ; we just care about the carry
00118Dr 3               @2:
00118Dr 3               
00118Dr 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
00118Dr 3                               ; bottom of the code, we have to double the value
00118Dr 3  06 2C                        asl tmptos
00118Fr 3               
00118Fr 3  38                           sec
001190r 3  B5 00                        lda 0,x
001192r 3  E5 2C                        sbc tmptos
001194r 3  95 00                        sta 0,x
001196r 3  B0 02                        bcs @3
001198r 3  D6 01                        dec 1,x                 ; we just care about the borrow
00119Ar 3               @3:
00119Ar 3                               ; drop through to underflow check stripping
00119Ar 3               
00119Ar 3               @underflow_strip:
00119Ar 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
00119Ar 3               
00119Ar 3                               ; The user can choose to remove the unterflow testing in those
00119Ar 3                               ; words that have the UF flag. This shortens the word by
00119Ar 3                               ; 3 bytes if there is no underflow.
00119Ar 3               
00119Ar 3                               ; See if the user wants underflow stripping turned on
00119Ar 3  A5 1C                        lda uf_strip
00119Cr 3  05 1D                        ora uf_strip+1
00119Er 3  F0 1C                        beq @specials_done
0011A0r 3               
0011A0r 3                               ; See if this word even contains underflow checking
0011A0r 3  A5 28                        lda tmp3
0011A2r 3  29 10                        and #UF
0011A4r 3  F0 16                        beq @specials_done
0011A6r 3               
0011A6r 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
0011A6r 3                               ; long. Note hat PICK is a special case.
0011A6r 3               
0011A6r 3                               ; Adjust xt: Start later
0011A6r 3  18                           clc
0011A7r 3  B5 04                        lda 4,x
0011A9r 3  69 03                        adc #3
0011ABr 3  95 04                        sta 4,x
0011ADr 3  90 02                        bcc @4
0011AFr 3  F6 05                        inc 5,x                  ; we just care about the carry
0011B1r 3               @4:
0011B1r 3                               ; Adjust u: End earlier
0011B1r 3  38                           sec
0011B2r 3  B5 00                        lda 0,x
0011B4r 3  E9 03                        sbc #3
0011B6r 3  95 00                        sta 0,x
0011B8r 3  B0 02                        bcs @5
0011BAr 3  D6 01                        dec 1,x                  ; we just care about the borrow
0011BCr 3               @5:
0011BCr 3               
0011BCr 3                               ; --- END OF SPECIAL CASES ---
0011BCr 3               @specials_done:
0011BCr 3                               ; Store size of area to be copied for calculation of
0011BCr 3                               ; new CP. We have to do this after all of the special cases
0011BCr 3                               ; because they might change the size
0011BCr 3  B5 01                        lda 1,x                 ; MSB
0011BEr 3  48                           pha
0011BFr 3  B5 00                        lda 0,x                 ; LSB
0011C1r 3  48                           pha
0011C2r 3               
0011C2r 3                               ; Enough of this, let's move those bytes already! We have
0011C2r 3                               ; ( xt cp u ) on the stack at this point
0011C2r 3  20 rr rr                     jsr xt_move
0011C5r 3               
0011C5r 3                               ; Update CP
0011C5r 3  18                           clc
0011C6r 3  68                           pla                     ; LSB
0011C7r 3  65 00                        adc cp
0011C9r 3  85 00                        sta cp
0011CBr 3               
0011CBr 3  68                           pla                     ; MSB
0011CCr 3  65 01                        adc cp+1
0011CEr 3  85 01                        sta cp+1
0011D0r 3               
0011D0r 3  80 2C                        bra @done
0011D2r 3               
0011D2r 3               @strip_table:
0011D2r 3                              ; List of words we strip the Return Stack antics from
0011D2r 3                              ; during native compile, zero terminated. The index here
0011D2r 3                              ; must be the same as for the sizes
0011D2r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
0011D6r 3  rr rr        
0011D8r 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
0011DCr 3  00 00        
0011DEr 3               
0011DEr 3               @strip_size:
0011DEr 3                               ; List of bytes to be stripped from the words that get their
0011DEr 3                               ; Return Stack antics removed during native compile. Index must
0011DEr 3                               ; be the same as for the xts. Zero terminated.
0011DEr 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
0011E2r 3  06 00        
0011E4r 3               
0011E4r 3               @compile_as_jump:
0011E4r 3                               ; Compile xt as a subroutine jump
0011E4r 3  A9 20                        lda #$20
0011E6r 3  92 00                        sta (cp)
0011E8r 3               
0011E8r 3  A0 01                        ldy #1
0011EAr 3  68                           pla             ; LSB
0011EBr 3  91 00                        sta (cp),y
0011EDr 3  C8                           iny
0011EEr 3  68                           pla             ; MSB
0011EFr 3  91 00                        sta (cp),y
0011F1r 3               
0011F1r 3                               ; allot space we just used
0011F1r 3  A9 03                        lda #3
0011F3r 3  18                           clc
0011F4r 3  65 00                        adc cp
0011F6r 3  85 00                        sta cp
0011F8r 3  90 02                        bcc @6
0011FAr 3  E6 01                        inc cp+1
0011FCr 3               @6:
0011FCr 3  E8                           inx             ; drop xt
0011FDr 3  E8                           inx
0011FEr 3               @done:
0011FEr 3               z_compile_comma:
0011FEr 3  60                           rts
0011FFr 3               
0011FFr 3               
0011FFr 3               
0011FFr 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
0011FFr 3               ; ## "compile-only"  tested  Tali Forth
0011FFr 3                       ; """Set the Compile Only flag (CO) of the most recently defined
0011FFr 3                       ; word.
0011FFr 3                       ;
0011FFr 3                       ; The alternative way to do this is to define a word
0011FFr 3                       ; ?COMPILE that makes sure  we're in compile mode
0011FFr 3                       ; """
0011FFr 3               
0011FFr 3               xt_compile_only:
0011FFr 3  20 rr rr                     jsr current_to_dp
001202r 3  A0 01                        ldy #1          ; offset for status byte
001204r 3  B1 02                        lda (dp),y
001206r 3  09 01                        ora #CO        ; make sure bit 7 is set
001208r 3  91 02                        sta (dp),y
00120Ar 3               
00120Ar 3  60           z_compile_only: rts
00120Br 3               
00120Br 3               
00120Br 3               
00120Br 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
00120Br 3               ; ## "constant"  auto  ANS core
00120Br 3                       ; """https://forth-standard.org/standard/core/CONSTANT
00120Br 3                       ;
00120Br 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
00120Br 3                       ; more in assembler and let CREATE do the heavy lifting.
00120Br 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
00120Br 3                       ; a primer on how this works in various Forths. This is the
00120Br 3                       ; same code as VALUE in our case.
00120Br 3                       ; """
00120Br 3               xt_value:
00120Br 3               xt_constant:
00120Br 3  20 rr rr                     jsr underflow_1
00120Er 3               
00120Er 3  20 rr rr                     jsr xt_create
001211r 3               
001211r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
001211r 3                               ; but we want DOCONST for constants. Go back two bytes and
001211r 3                               ; replace the subroutine jump target
001211r 3  38                           sec
001212r 3  A5 00                        lda cp
001214r 3  E9 02                        sbc #2
001216r 3  85 24                        sta tmp1
001218r 3  A5 01                        lda cp+1
00121Ar 3  E9 00                        sbc #0
00121Cr 3  85 25                        sta tmp1+1
00121Er 3               
00121Er 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
001220r 3  92 24                        sta (tmp1)
001222r 3  A0 01                        ldy #1
001224r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
001226r 3  91 24                        sta (tmp1),y
001228r 3               
001228r 3                               ; Now we save the constant number itself in the next cell
001228r 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
00122Br 3               
00122Br 3               adjust_z:
00122Br 3                               ; Now the length of the complete word (z_word) has increased by
00122Br 3                               ; two. We need to update that number or else words such as SEE
00122Br 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
00122Br 3                               ; VALUE and DEFER
00122Br 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
00122Er 3               
00122Er 3                               ; z_word is six bytes further down
00122Er 3  B5 00                        lda 0,x
001230r 3  85 24                        sta tmp1
001232r 3  B5 01                        lda 1,x
001234r 3  85 25                        sta tmp1+1
001236r 3               
001236r 3  A0 06                        ldy #6
001238r 3  B1 24                        lda (tmp1),y
00123Ar 3  18                           clc
00123Br 3  69 02                        adc #2
00123Dr 3  91 24                        sta (tmp1),y
00123Fr 3  C8                           iny
001240r 3  B1 24                        lda (tmp1),y
001242r 3  69 00                        adc #0                  ; only need carry
001244r 3  91 24                        sta (tmp1),y
001246r 3               
001246r 3  E8                           inx
001247r 3  E8                           inx
001248r 3               
001248r 3               z_value:
001248r 3  60           z_constant:     rts
001249r 3               
001249r 3               
001249r 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
001249r 3               ; ## "count"  auto  ANS core
001249r 3                       ; """https://forth-standard.org/standard/core/COUNT
001249r 3                       ; Convert old-style character string to address-length pair. Note
001249r 3                       ; that the length of the string c-addr is stored in character length
001249r 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
001249r 3                       ; though COUNT can also be used to step through a string character by
001249r 3                       ; character.
001249r 3                       ; """
001249r 3               xt_count:
001249r 3  20 rr rr                     jsr underflow_1
00124Cr 3               
00124Cr 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
00124Er 3  A8                           tay
00124Fr 3               
00124Fr 3                               ; move start address up by one
00124Fr 3  F6 00                        inc 0,x         ; LSB
001251r 3  D0 02                        bne @1
001253r 3  F6 01                        inc 1,x         ; MSB
001255r 3               
001255r 3                               ; save number of characters to stack
001255r 3               @1:
001255r 3  98                           tya
001256r 3  CA                           dex
001257r 3  CA                           dex
001258r 3  95 00                        sta 0,x         ; LSB
00125Ar 3  74 01                        stz 1,x         ; MSB, always zero
00125Cr 3               
00125Cr 3  60           z_count:        rts
00125Dr 3               
00125Dr 3               
00125Dr 3               ; ## CR ( -- ) "Print a line feed"
00125Dr 3               ; ## "cr"  auto  ANS core
00125Dr 3                       ; """https://forth-standard.org/standard/core/CR"""
00125Dr 3               xt_cr:
00125Dr 3  A9 0A                        lda #AscLF
00125Fr 3  20 rr rr                     jsr emit_a
001262r 3  60           z_cr:           rts
001263r 3               
001263r 3               
001263r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
001263r 3               ; ## "create"  auto  ANS core
001263r 3                       ; """https://forth-standard.org/standard/core/CREATE
001263r 3                       ;
001263r 3                       ; See the drawing in headers.asm for details on the header
001263r 3                       ; """
001263r 3               
001263r 3               xt_create:
001263r 3                               ; get string
001263r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
001266r 3               
001266r 3                               ; if we were given an empty string, we complain and quit
001266r 3  B5 00                        lda 0,x
001268r 3  15 01                        ora 1,x
00126Ar 3  D0 05                        bne @got_name
00126Cr 3               
00126Cr 3  A9 05                        lda #err_noname
00126Er 3  4C rr rr                     jmp error
001271r 3               
001271r 3               @got_name:
001271r 3                               ; Enforce maximal length of string by overwriting the MSB of
001271r 3                               ; the length. There is a possible error here: If the string
001271r 3                               ; is exactly 255 chars long, then a lot of the following
001271r 3                               ; additions will fail because of wrapping
001271r 3  74 01                        stz 1,x
001273r 3               
001273r 3                               ; Check to see if this name already exists.
001273r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
001276r 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
001279r 3               
001279r 3  B5 00                        lda 0,x
00127Br 3  15 01                        ora 1,x
00127Dr 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
00127Fr 3               
00127Fr 3                               ; This name already exists.  See if we are supposed to print
00127Fr 3                               ; the message for it.
00127Fr 3  E8                           inx                     ; Drop flag (nt) from find-name.
001280r 3  E8                           inx
001281r 3               
001281r 3                               ; Check bit 7
001281r 3  24 20                        bit status
001283r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
001285r 3               
001285r 3                               ; We aren't supposed to print the redefined message ourselves,
001285r 3                               ; but we should indicate that it is redefined (for ; to print
001285r 3                               ; later).
001285r 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
001287r 3  05 20                        ora status
001289r 3  85 20                        sta status
00128Br 3  80 18                        bra @process_name
00128Dr 3               
00128Dr 3               @redefined_name:
00128Dr 3                               ; Print the message that the name is redefined.
00128Dr 3  A9 02                        lda #str_redefined
00128Fr 3  20 rr rr                     jsr print_string_no_lf
001292r 3               
001292r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
001295r 3  20 rr rr                     jsr xt_type
001298r 3  20 rr rr                     jsr xt_space
00129Br 3               
00129Br 3  80 08                        bra @process_name
00129Dr 3               
00129Dr 3               @new_name:
00129Dr 3  E8                           inx                     ; Drop flag (0) from find-name.
00129Er 3  E8                           inx
00129Fr 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
0012A1r 3  25 20                        and status
0012A3r 3  85 20                        sta status
0012A5r 3               
0012A5r 3               @process_name:
0012A5r 3  B5 00                        lda 0,x
0012A7r 3  85 26                        sta tmp2                ; store length of string in tmp2
0012A9r 3               
0012A9r 3                               ; remember the first free byte of memory as the start of
0012A9r 3                               ; the new word
0012A9r 3  A5 00                        lda cp
0012ABr 3  85 24                        sta tmp1
0012ADr 3  A5 01                        lda cp+1
0012AFr 3  85 25                        sta tmp1+1
0012B1r 3               
0012B1r 3                               ; We need 8 bytes plus the length of the string for our new header.
0012B1r 3                               ; This is also the offset for the start of the code field (the
0012B1r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
0012B1r 3                               ; just allot the space afterwards
0012B1r 3  B5 00                        lda 0,x
0012B3r 3  18                           clc
0012B4r 3  69 08                        adc #8
0012B6r 3  85 28                        sta tmp3                ; total header length
0012B8r 3               
0012B8r 3                               ; We need three more bytes for for the hardcoded code field
0012B8r 3                               ; area (CFA), the "payload" of the word which by default will
0012B8r 3                               ; be a subroutine jump to DOVAR
0012B8r 3  18                           clc
0012B9r 3  69 03                        adc #3
0012BBr 3               
0012BBr 3                               ; We overwrite the length of the string returned by PARSE-NAME
0012BBr 3                               ; and then call ALLOT
0012BBr 3  95 00                        sta 0,x
0012BDr 3  74 01                        stz 1,x         ; max header size is 255 chars
0012BFr 3  20 rr rr                     jsr xt_allot    ; ( addr )
0012C2r 3               
0012C2r 3                               ; Get the CURRENT dictionary pointer.
0012C2r 3  20 rr rr                     jsr current_to_dp
0012C5r 3               
0012C5r 3                               ; Now we walk through the header with Y as the index, adding
0012C5r 3                               ; information byte-by-byte
0012C5r 3  A0 00                        ldy #0
0012C7r 3               
0012C7r 3                               ; HEADER BYTE 0: Length of string
0012C7r 3  A5 26                        lda tmp2
0012C9r 3  91 24                        sta (tmp1),y
0012CBr 3               
0012CBr 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
0012CBr 3                               ; to "never native", user will have to decide if they should
0012CBr 3                               ; be inlined
0012CBr 3  A9 08                        lda #NN
0012CDr 3               
0012CDr 3                               ; Also, words defined by CREATE are marked in the header has
0012CDr 3                               ; having a Code Field Area (CFA), which is a bit tricky for
0012CDr 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
0012CDr 3                               ; correctly with DOES> and CREATE. See the discussion at
0012CDr 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
0012CDr 3  09 20                        ora #HC
0012CFr 3  C8                           iny
0012D0r 3  91 24                        sta (tmp1),y
0012D2r 3  C8                           iny
0012D3r 3               
0012D3r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
0012D3r 3                               ; in the Dictionary
0012D3r 3  A5 02                        lda dp
0012D5r 3  91 24                        sta (tmp1),y
0012D7r 3  C8                           iny
0012D8r 3  A5 03                        lda dp+1
0012DAr 3  91 24                        sta (tmp1),y
0012DCr 3  C8                           iny
0012DDr 3               
0012DDr 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
0012DDr 3  A5 25                        lda tmp1+1
0012DFr 3  85 03                        sta dp+1
0012E1r 3  A5 24                        lda tmp1
0012E3r 3  85 02                        sta dp
0012E5r 3               
0012E5r 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
0012E5r 3                               ; This begins after the header so we take the length of the
0012E5r 3                               ; header, which we cleverly saved in tmp3, and use it as an
0012E5r 3                               ; offset to the address of the start of the word. We come here
0012E5r 3                               ; with tmp1 in A
0012E5r 3  18                           clc
0012E6r 3  65 28                        adc tmp3        ; add total header length
0012E8r 3  91 24                        sta (tmp1),y
0012EAr 3  48                           pha             ; we need this in the next step
0012EBr 3  C8                           iny
0012ECr 3               
0012ECr 3  A5 25                        lda tmp1+1
0012EEr 3  69 00                        adc #0          ; only need the carry
0012F0r 3  91 24                        sta (tmp1),y
0012F2r 3  C8                           iny
0012F3r 3               
0012F3r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
0012F3r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
0012F3r 3                               ; bytes down, and then one more byte so that the z_ label points
0012F3r 3                               ; to the (still fictional) RTS instruction for correct compilation
0012F3r 3  68                           pla             ; LSB of "z_" address
0012F4r 3  18                           clc
0012F5r 3  69 03                        adc #3
0012F7r 3  91 24                        sta (tmp1),y
0012F9r 3               
0012F9r 3  88                           dey             ; get the MSB of xt back
0012FAr 3  B1 24                        lda (tmp1),y
0012FCr 3  69 00                        adc #0          ; only need the carry
0012FEr 3  C8                           iny
0012FFr 3  C8                           iny
001300r 3  91 24                        sta (tmp1),y
001302r 3  C8                           iny
001303r 3               
001303r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
001303r 3                               ; length in tmp2. We subtract 8 from the address so we can
001303r 3                               ; use the same loop index, which is already 8 byte ahead at
001303r 3                               ; this point
001303r 3  B5 00                        lda 0,x
001305r 3  38                           sec
001306r 3  E9 08                        sbc #8
001308r 3  85 2C                        sta tmptos
00130Ar 3               
00130Ar 3  B5 01                        lda 1,x
00130Cr 3  E9 00                        sbc #0          ; only need carry
00130Er 3  85 2D                        sta tmptos+1
001310r 3               
001310r 3               @name_loop:
001310r 3  B1 2C                        lda (tmptos),y
001312r 3               
001312r 3                               ; Make sure it goes into the dictionary in lower case.
001312r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001314r 3  B0 07                        bcs @store_name
001316r 3  C9 41                        cmp #$41        ; ASCII 'A'
001318r 3  90 03                        bcc @store_name
00131Ar 3               
00131Ar 3                               ; An uppercase letter has been located. Make it
00131Ar 3                               ; lowercase.
00131Ar 3  18                           clc
00131Br 3  69 20                        adc #$20
00131Dr 3               
00131Dr 3                               ; Fall into @store_name.
00131Dr 3               
00131Dr 3               @store_name:
00131Dr 3  91 24                        sta (tmp1),y
00131Fr 3  C8                           iny
001320r 3  C6 26                        dec tmp2
001322r 3  D0 EC                        bne @name_loop
001324r 3               
001324r 3                               ; After thename string comes the code field, starting at the
001324r 3                               ; current xt of this word, which is initially a jump to the
001324r 3                               ; subroutine to DOVAR. We code this jump by hand
001324r 3  A9 20                        lda #$20        ; opcode of JSR
001326r 3  91 24                        sta (tmp1),y
001328r 3  C8                           iny
001329r 3  A9 rr                        lda #<dovar
00132Br 3  91 24                        sta (tmp1),y
00132Dr 3  C8                           iny
00132Er 3  A9 rr                        lda #>dovar
001330r 3  91 24                        sta (tmp1),y
001332r 3               
001332r 3                               ; Update the CURRENT wordlist with the new DP.
001332r 3                               ; We do this down here because this routine uses Y.
001332r 3  20 rr rr                     jsr dp_to_current
001335r 3               
001335r 3                               ; And we're done. Restore stack
001335r 3  E8                           inx
001336r 3  E8                           inx
001337r 3               
001337r 3  60           z_create:       rts
001338r 3               
001338r 3               
001338r 3               
001338r 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
001338r 3               ; ## "d-"  auto  ANS double
001338r 3                       ; """https://forth-standard.org/standard/double/DMinus"""
001338r 3               
001338r 3               xt_d_minus:
001338r 3  20 rr rr                     jsr underflow_4 ; two double numbers
00133Br 3               
00133Br 3  38                           sec
00133Cr 3               
00133Cr 3  B5 06                        lda 6,x         ; LSB of lower word
00133Er 3  F5 02                        sbc 2,x
001340r 3  95 06                        sta 6,x
001342r 3               
001342r 3  B5 07                        lda 7,x         ; MSB of lower word
001344r 3  F5 03                        sbc 3,x
001346r 3  95 07                        sta 7,x
001348r 3               
001348r 3  B5 04                        lda 4,x         ; LSB of upper word
00134Ar 3  F5 00                        sbc 0,x
00134Cr 3  95 04                        sta 4,x
00134Er 3               
00134Er 3  B5 05                        lda 5,x         ; MSB of upper word
001350r 3  F5 01                        sbc 1,x
001352r 3  95 05                        sta 5,x
001354r 3               
001354r 3  E8                           inx
001355r 3  E8                           inx
001356r 3  E8                           inx
001357r 3  E8                           inx
001358r 3               
001358r 3  60           z_d_minus:      rts
001359r 3               
001359r 3               
001359r 3               
001359r 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
001359r 3               ; ## "d+"  auto  ANS double
001359r 3                       ; """https://forth-standard.org/standard/double/DPlus"""
001359r 3               
001359r 3               xt_d_plus:
001359r 3  20 rr rr                     jsr underflow_4 ; two double numbers
00135Cr 3               
00135Cr 3  18                           clc
00135Dr 3  B5 02                        lda 2,x         ; LSB of lower word
00135Fr 3  75 06                        adc 6,x
001361r 3  95 06                        sta 6,x
001363r 3               
001363r 3  B5 03                        lda 3,x         ; MSB of lower word
001365r 3  75 07                        adc 7,x
001367r 3  95 07                        sta 7,x
001369r 3               
001369r 3  B5 00                        lda 0,x         ; LSB of upper word
00136Br 3  75 04                        adc 4,x
00136Dr 3  95 04                        sta 4,x
00136Fr 3               
00136Fr 3  B5 01                        lda 1,x         ; MSB of upper word
001371r 3  75 05                        adc 5,x
001373r 3  95 05                        sta 5,x
001375r 3               
001375r 3  E8                           inx
001376r 3  E8                           inx
001377r 3  E8                           inx
001378r 3  E8                           inx
001379r 3               
001379r 3  60           z_d_plus:       rts
00137Ar 3               
00137Ar 3               
00137Ar 3               
00137Ar 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
00137Ar 3               ; ## "d>s"  auto  ANS double
00137Ar 3                       ; """https://forth-standard.org/standard/double/DtoS
00137Ar 3                       ; Though this is basically just DROP, we keep it
00137Ar 3                       ; separate so we can test for underflow
00137Ar 3                       ; """
00137Ar 3               
00137Ar 3               xt_d_to_s:
00137Ar 3  20 rr rr                     jsr underflow_2
00137Dr 3               
00137Dr 3  E8                           inx
00137Er 3  E8                           inx
00137Fr 3               
00137Fr 3  60           z_d_to_s:       rts
001380r 3               
001380r 3               
001380r 3               
001380r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
001380r 3               ; ## "dabs"  auto  ANS double
001380r 3                       ; """https://forth-standard.org/standard/double/DABS"""
001380r 3               
001380r 3               xt_dabs:
001380r 3  20 rr rr                     jsr underflow_2 ; double number
001383r 3               
001383r 3  B5 01                        lda 1,x         ; MSB of high cell
001385r 3  10 17                        bpl @done       ; positive, we get off light
001387r 3               
001387r 3                               ; negative, calculate 0 - d
001387r 3  A0 00                        ldy #0
001389r 3  38                           sec
00138Ar 3               
00138Ar 3  98                           tya
00138Br 3  F5 02                        sbc 2,x         ; LSB of low cell
00138Dr 3  95 02                        sta 2,x
00138Fr 3               
00138Fr 3  98                           tya
001390r 3  F5 03                        sbc 3,x         ; MSB of low cell
001392r 3  95 03                        sta 3,x
001394r 3               
001394r 3  98                           tya
001395r 3  F5 00                        sbc 0,x         ; LSB of high cell
001397r 3  95 00                        sta 0,x
001399r 3               
001399r 3  98                           tya
00139Ar 3  F5 01                        sbc 1,x         ; MSB of high cell
00139Cr 3  95 01                        sta 1,x
00139Er 3               @done:
00139Er 3  60           z_dabs:         rts
00139Fr 3               
00139Fr 3               
00139Fr 3               
00139Fr 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
00139Fr 3               ; ## "decimal"  auto  ANS core
00139Fr 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
00139Fr 3               xt_decimal:
00139Fr 3  A9 0A                        lda #10
0013A1r 3  85 18                        sta base
0013A3r 3  64 19                        stz base+1              ; paranoid
0013A5r 3               
0013A5r 3  60           z_decimal:      rts
0013A6r 3               
0013A6r 3               
0013A6r 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
0013A6r 3               ; ## "defer"  auto  ANS core ext
0013A6r 3                       ; """https://forth-standard.org/standard/core/DEFER
0013A6r 3                       ; Reserve an name that can be linked to various xt by IS.
0013A6r 3                       ;
0013A6r 3                       ; The ANS reference implementation is
0013A6r 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
0013A6r 3                       ; But we use this routine as a low-level word so things go faster
0013A6r 3               
0013A6r 3               xt_defer:
0013A6r 3  20 rr rr                     jsr xt_create
0013A9r 3               
0013A9r 3                               ; CREATE by default installs a subroutine jump to DOVAR,
0013A9r 3                               ; but we actually want DODEFER this time. Go back two
0013A9r 3                               ; bytes and repace the subroutine jump target
0013A9r 3  A5 00                        lda cp          ; LSB
0013ABr 3  38                           sec
0013ACr 3  E9 02                        sbc #2
0013AEr 3  85 24                        sta tmp1
0013B0r 3               
0013B0r 3  A5 01                        lda cp+1        ; MSB
0013B2r 3  E9 00                        sbc #0          ; we only care about the borrow
0013B4r 3  85 25                        sta tmp1+1
0013B6r 3               
0013B6r 3                               ; Save the target address
0013B6r 3  A0 00                        ldy #0
0013B8r 3  A9 rr                        lda #<dodefer   ; LSB
0013BAr 3  91 24                        sta (tmp1),y
0013BCr 3  C8                           iny
0013BDr 3  A9 rr                        lda #>dodefer   ; MSB
0013BFr 3  91 24                        sta (tmp1),y
0013C1r 3               
0013C1r 3               
0013C1r 3                               ; DODEFER executes the next address it finds after
0013C1r 3                               ; its call. As default, we include the error
0013C1r 3                               ; "Defer not defined"
0013C1r 3  A9 rr                        lda #<defer_error
0013C3r 3  92 00                        sta (cp)
0013C5r 3  E6 00                        inc cp
0013C7r 3  D0 02                        bne @1
0013C9r 3  E6 01                        inc cp+1
0013CBr 3               @1:
0013CBr 3  A9 rr                        lda #>defer_error
0013CDr 3  92 00                        sta (cp)
0013CFr 3  E6 00                        inc cp
0013D1r 3  D0 02                        bne @2
0013D3r 3  E6 01                        inc cp+1
0013D5r 3               @2:
0013D5r 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
0013D8r 3               
0013D8r 3  60           z_defer:        rts
0013D9r 3               
0013D9r 3               
0013D9r 3               
0013D9r 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
0013D9r 3               ; ## "defer@"  auto  ANS core ext
0013D9r 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
0013D9r 3               
0013D9r 3               xt_defer_fetch:
0013D9r 3                               ; No underflow checking as >BODY does it.
0013D9r 3  20 rr rr                     jsr xt_to_body
0013DCr 3  20 rr rr                     jsr xt_fetch
0013DFr 3  60           z_defer_fetch:  rts
0013E0r 3               
0013E0r 3               
0013E0r 3               
0013E0r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
0013E0r 3               ; ## "defer!"  auto  ANS core ext
0013E0r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
0013E0r 3               
0013E0r 3               xt_defer_store:
0013E0r 3                               ; No underflow checking as >BODY and ! do it.
0013E0r 3  20 rr rr                     jsr xt_to_body
0013E3r 3  20 rr rr                     jsr xt_store
0013E6r 3  60           z_defer_store:  rts
0013E7r 3               
0013E7r 3               
0013E7r 3               
0013E7r 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
0013E7r 3               ; ## "definitions" auto ANS search
0013E7r 3               xt_definitions:
0013E7r 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
0013E9r 3  B1 1E                        lda (up),y                  ; SEARCH_ORDER[0] to
0013EBr 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
0013EDr 3  91 1E                        sta (up),y
0013EFr 3  60           z_definitions:  rts
0013F0r 3               
0013F0r 3               
0013F0r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
0013F0r 3               ; ## "depth"  auto  ANS core
0013F0r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
0013F0r 3               xt_depth:
0013F0r 3  A9 78                        lda #dsp0
0013F2r 3  86 2A                        stx tmpdsp
0013F4r 3  38                           sec
0013F5r 3  E5 2A                        sbc tmpdsp
0013F7r 3               
0013F7r 3                               ; divide by two because each cell is two bytes
0013F7r 3  4A                           lsr
0013F8r 3               
0013F8r 3  CA                           dex
0013F9r 3  CA                           dex
0013FAr 3  95 00                        sta 0,x
0013FCr 3  74 01                        stz 1,x
0013FEr 3               
0013FEr 3  60           z_depth:        rts
0013FFr 3               
0013FFr 3               
0013FFr 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
0013FFr 3               ; ## "digit?"  auto  Tali Forth
0013FFr 3                       ; """Inspired by the pForth instruction DIGIT, see
0013FFr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0013FFr 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
0013FFr 3                       ; pForth, we get the base (radix) ourselves instead of having the
0013FFr 3                       ; user provide it. There is no standard name for this routine, which
0013FFr 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
0013FFr 3                       ; """
0013FFr 3               
0013FFr 3               xt_digit_question:
0013FFr 3  20 rr rr                     jsr underflow_1
001402r 3               
001402r 3                               ; one way or another, we're going to need room for the
001402r 3                               ; flag on the stack
001402r 3  CA                           dex
001403r 3  CA                           dex
001404r 3  74 00                        stz 0,x                 ; default flag is failure
001406r 3  74 01                        stz 1,x
001408r 3  74 03                        stz 3,x                 ; paranoid
00140Ar 3               
00140Ar 3                               ; Check the character, now in the LSB of NOS. First, make
00140Ar 3                               ; sure we're not below the ASCII code for "0"
00140Ar 3  B5 02                        lda 2,x
00140Cr 3  C9 30                        cmp #'0'
00140Er 3  90 23                        bcc @done               ; failure flag already set
001410r 3               
001410r 3                               ; Next, see if we are below "9", because that would make
001410r 3                               ; this a normal number
001410r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
001412r 3  90 12                        bcc @checkbase
001414r 3               
001414r 3                               ; Well, then let's see if this is the gap between "9" and "A"
001414r 3                               ; so we can treat the whole range as a number
001414r 3  C9 41                        cmp #'A'
001416r 3  90 1B                        bcc @done               ; failure flag is already set
001418r 3               
001418r 3                               ; probably a letter, so we make sure it is uppercase
001418r 3  C9 61                        cmp #'a'
00141Ar 3  90 07                        bcc @case_done          ; not lower case, too low
00141Cr 3  C9 7B                        cmp #'z'+1
00141Er 3  B0 03                        bcs @case_done          ; not lower case, too high
001420r 3               
001420r 3  18                           clc                     ; just right
001421r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
001423r 3               
001423r 3               @case_done:
001423r 3                               ; get rid of the gap between "9" and "A" so we can treat
001423r 3                               ; the whole range as one number
001423r 3  38                           sec
001424r 3  E9 07                        sbc #7                  ; fall through to @checkbase
001426r 3               
001426r 3               @checkbase:
001426r 3                               ; we have a number, now see if it falls inside the range
001426r 3                               ; provided by BASE
001426r 3  38                           sec
001427r 3  E9 30                        sbc #'0'                 ; this is also the conversion step
001429r 3  C5 18                        cmp base
00142Br 3  B0 06                        bcs @done               ; already have false flag
00142Dr 3               
00142Dr 3                               ; Found a legal number
00142Dr 3  95 02                        sta 2,x                 ; put number in NOS
00142Fr 3  D6 00                        dec 0,x                 ; set success flag
001431r 3  D6 01                        dec 1,x
001433r 3               
001433r 3               @done:
001433r 3               z_digit_question:
001433r 3  60                           rts
001434r 3               
001434r 3               
001434r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
001434r 3               ; ## "disasm"  tested  Tali Forth
001434r 3                       ; """Convert a segment of memory to assembler output. This
001434r 3                       ; word is vectored so people can add their own disassembler.
001434r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
001434r 3                       ; code, see the section on The Disassembler in the manual and
001434r 3                       ; the file disassembler.asm for more details.
001434r 3                       ; """
001434r 3               xt_disasm:
001434r 3  20 rr rr                     jsr underflow_2
001437r 3               
001437r 3  20 rr rr                     jsr disassembler
00143Ar 3               
00143Ar 3  60           z_disasm:       rts
00143Br 3               
00143Br 3               
00143Br 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
00143Br 3               ; ## "dnegate"  auto  ANS double
00143Br 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
00143Br 3               xt_dnegate:
00143Br 3  20 rr rr                     jsr underflow_2 ; double number
00143Er 3               
00143Er 3  A0 00             		ldy #0
001440r 3  38                           sec
001441r 3               
001441r 3  98                           tya
001442r 3  F5 02                        sbc 2,x         ; LSB of low cell
001444r 3  95 02                        sta 2,x
001446r 3               
001446r 3  98                           tya
001447r 3  F5 03                        sbc 3,x         ; MSB of low cell
001449r 3  95 03                        sta 3,x
00144Br 3               
00144Br 3  98                           tya
00144Cr 3  F5 00                        sbc 0,x         ; LSB of high cell
00144Er 3  95 00                        sta 0,x
001450r 3               
001450r 3  98                           tya
001451r 3  F5 01                        sbc 1,x         ; MSB of high cell
001453r 3  95 01                        sta 1,x
001455r 3               
001455r 3  60           z_dnegate:      rts
001456r 3               
001456r 3               
001456r 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
001456r 3               ; ## "?do"  auto  ANS core ext
001456r 3                       ; """https://forth-standard.org/standard/core/qDO"""
001456r 3               xt_question_do:
001456r 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
001456r 3                               ; to mark which is which
001456r 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
001458r 3  85 24                        sta tmp1
00145Ar 3  80 02                        bra do_common           ; skip flag for DO
00145Cr 3               
00145Cr 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
00145Cr 3               ; ## "do"  auto  ANS core
00145Cr 3                       ; """https://forth-standard.org/standard/core/DO
00145Cr 3                       ;
00145Cr 3                       ; Compile-time part of DO. Could be realized in Forth as
00145Cr 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
00145Cr 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
00145Cr 3                       ; a routine that pushes the end address to the Return Stack at run
00145Cr 3                       ; time. This is based on a suggestion by Garth Wilson, see
00145Cr 3                       ; the Control Flow section of the manual for details.
00145Cr 3                       ;
00145Cr 3                       ; This may not be native compile. Don't check for a stack underflow
00145Cr 3                       ; """
00145Cr 3               
00145Cr 3               xt_do:
00145Cr 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
00145Cr 3  64 24                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
00145Er 3               do_common:
00145Er 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
00145Er 3                               ; compile the address we need to LDA at runtime
00145Er 3  CA                           dex
00145Fr 3  CA                           dex
001460r 3  A5 00                        lda cp
001462r 3  95 00                        sta 0,x                 ; LSB
001464r 3  A5 01                        lda cp+1
001466r 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
001468r 3               
001468r 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
001468r 3                               ; replace by the actual LDA/PHA instructions
001468r 3  A9 05                        lda #5                  ; we don't really care about the value,
00146Ar 3  A8                           tay                     ; so we use 5 to be tricky
00146Br 3               @loop:
00146Br 3  91 00                        sta (cp),y
00146Dr 3  88                           dey
00146Er 3  10 FB                        bpl @loop
001470r 3               
001470r 3                               ; update CP
001470r 3  1A                           inc             ; we used 5 as a dummy value, this is why
001471r 3  18                           clc
001472r 3  65 00                        adc cp
001474r 3  85 00                        sta cp
001476r 3  90 02                        bcc @1
001478r 3  E6 01                        inc cp+1
00147Ar 3               @1:
00147Ar 3                               ; compile the (?DO) portion of ?DO if appropriate
00147Ar 3  A5 24                        lda tmp1
00147Cr 3  F0 17                        beq @compile_do
00147Er 3               
00147Er 3                               ; We came from ?DO, so compile its runtime first. We do
00147Er 3                               ; this with a quick loop because we know it has to be
00147Er 3                               ; Always Native anyway
00147Er 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
001480r 3  5A                           phy             ; save counter to calculate new CP
001481r 3               @2:
001481r 3  B9 rr rr                     lda question_do_runtime,y
001484r 3  91 00                        sta (cp),y
001486r 3  88                           dey
001487r 3  10 F8                        bpl @2
001489r 3               
001489r 3                               ; adjust CP
001489r 3  68                           pla             ; retrieve counter
00148Ar 3  18                           clc
00148Br 3  65 00                        adc cp
00148Dr 3  85 00                        sta cp
00148Fr 3  A5 01                        lda cp+1
001491r 3  69 00                        adc #0          ; only care about carry
001493r 3  85 01                        sta cp+1        ; fall through to @compile_do
001495r 3               
001495r 3               @compile_do:
001495r 3                               ; compile runtime part of DO.
001495r 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
001497r 3  5A                           phy             ; save counter to calculate new CP
001498r 3               @3:
001498r 3  B9 rr rr                     lda do_runtime,y
00149Br 3  91 00                        sta (cp),y
00149Dr 3  88                           dey
00149Er 3  10 F8                        bpl @3
0014A0r 3               
0014A0r 3                               ; adjust CP
0014A0r 3  68                           pla             ; retrieve counter
0014A1r 3  18                           clc
0014A2r 3  65 00                        adc cp
0014A4r 3  85 00                        sta cp
0014A6r 3  A5 01                        lda cp+1
0014A8r 3  69 00                        adc #0          ; only care about carry
0014AAr 3  85 01                        sta cp+1
0014ACr 3               
0014ACr 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
0014ACr 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
0014ACr 3                               ; do with the HERE we're saving for LEAVE
0014ACr 3  CA                           dex
0014ADr 3  CA                           dex
0014AEr 3  A5 00                        lda cp          ; LSB
0014B0r 3  95 00                        sta 0,x
0014B2r 3  A5 01                        lda cp+1        ; MSB
0014B4r 3  95 01                        sta 1,x
0014B6r 3               z_question_do:
0014B6r 3  60           z_do:           rts
0014B7r 3               
0014B7r 3               
0014B7r 3               do_runtime:
0014B7r 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
0014B7r 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
0014B7r 3                       ; the FIG Forth loop (you can see which version you have by running
0014B7r 3                       ; a loop with start and limit as the same value, for instance
0014B7r 3                       ; 0 0 DO -- these will walk through the number space). We use a
0014B7r 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
0014B7r 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
0014B7r 3                       ; for further discussion of this. The source given there for
0014B7r 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
0014B7r 3                       ; in some Forths. Usually, we would define this as a separate word
0014B7r 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
0014B7r 3                       ; However, we can do it faster if we just copy the bytes
0014B7r 3                       ; of this routine with a simple loop in DO.
0014B7r 3                       ; """
0014B7r 3                               ; First step: create fudge factor (FUFA) by subtracting the
0014B7r 3                               ; limit from $8000, the number that will trip the overflow
0014B7r 3                               ; flag
0014B7r 3  38                           sec
0014B8r 3  A9 00                        lda #0
0014BAr 3  F5 02                        sbc 2,x         ; LSB of limit
0014BCr 3  95 02                        sta 2,x         ; save FUFA for later use
0014BEr 3               
0014BEr 3  A9 80                        lda #$80
0014C0r 3  F5 03                        sbc 3,x         ; MSB of limit
0014C2r 3  95 03                        sta 3,x         ; save FUFA for later use
0014C4r 3  48                           pha             ; FUFA replaces limit on R stack
0014C5r 3  B5 02                        lda 2,x         ; LSB of limit
0014C7r 3  48                           pha
0014C8r 3               
0014C8r 3                               ; Second step: index is FUFA plus original index
0014C8r 3  18                           clc
0014C9r 3  B5 00                        lda 0,x         ; LSB of original index
0014CBr 3  75 02                        adc 2,x         ; add LSB of FUFA
0014CDr 3  95 00                        sta 0,x
0014CFr 3  B5 01                        lda 1,x         ; MSB of orginal index
0014D1r 3  75 03                        adc 3,x         ; add MSB of FUFA
0014D3r 3  48                           pha
0014D4r 3  B5 00                        lda 0,x         ; LSB of index
0014D6r 3  48                           pha
0014D7r 3               
0014D7r 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
0014D7r 3                               ; use it later. Clean the Data Stack
0014D7r 3  E8                           inx
0014D8r 3  E8                           inx
0014D9r 3  E8                           inx
0014DAr 3  E8                           inx             ; no RTS because this is copied into code
0014DBr 3               do_runtime_end:
0014DBr 3               
0014DBr 3               question_do_runtime:
0014DBr 3               
0014DBr 3                       ; """This is called (?DO) in some Forths. See the explanation at
0014DBr 3                       ; do_runtime for the background on this design
0014DBr 3                       ; """
0014DBr 3                               ; see if TOS and NOS are equal. Change this to assembler
0014DBr 3                               ; for speed
0014DBr 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
0014DEr 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
0014E1r 3               
0014E1r 3  B5 00                        lda 0,x
0014E3r 3  15 01                        ora 1,x
0014E5r 3  F0 06                        beq @do_do
0014E7r 3               
0014E7r 3                               ; We're equal, so dump everything and jump beyond the loop.
0014E7r 3                               ; But first, dump six entries off of the Data Stack
0014E7r 3  8A                           txa
0014E8r 3  18                           clc
0014E9r 3  69 06                        adc #6
0014EBr 3  AA                           tax
0014ECr 3               
0014ECr 3                               ; Then abort the whole loop
0014ECr 3  60                           rts
0014EDr 3               @do_do:
0014EDr 3  E8                           inx             ; clear flag from EQUAL off stack
0014EEr 3  E8                           inx             ; no RTS because this is copied into code
0014EFr 3               question_do_runtime_end:
0014EFr 3               
0014EFr 3               
0014EFr 3               
0014EFr 3               ; ## DOES ( -- ) "Add payload when defining new words"
0014EFr 3               ; ## "does>"  auto  ANS core
0014EFr 3                       ; """https://forth-standard.org/standard/core/DOES
0014EFr 3                       ; Create the payload for defining new defining words. See
0014EFr 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
0014EFr 3                       ; the Developer Guide in the manual for a discussion of
0014EFr 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
0014EFr 3                       ; """
0014EFr 3               
0014EFr 3               xt_does:
0014EFr 3                               ; compile a subroutine jump to runtime of DOES>
0014EFr 3  A0 rr                        ldy #>does_runtime
0014F1r 3  A9 rr                        lda #<does_runtime
0014F3r 3  20 rr rr                     jsr cmpl_subroutine
0014F6r 3               
0014F6r 3                               ; compile a subroutine jump to DODOES. In traditional
0014F6r 3                               ; terms, this is the Code Field Area (CFA) of the new
0014F6r 3                               ; word
0014F6r 3  A0 rr                        ldy #>dodoes
0014F8r 3  A9 rr                        lda #<dodoes
0014FAr 3  20 rr rr                     jsr cmpl_subroutine
0014FDr 3               
0014FDr 3  60           z_does:         rts
0014FEr 3               
0014FEr 3               
0014FEr 3               does_runtime:
0014FEr 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
0014FEr 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
0014FEr 3                       ; address that contains a subroutine jump to DODOES. We don't
0014FEr 3                       ; jump to DODOES directly because we need to work our magic with
0014FEr 3                       ; the return addresses. This routine is also known as "(DOES)" in
0014FEr 3                       ; other Forths
0014FEr 3                       ; """
0014FEr 3               
0014FEr 3  7A                           ply             ; LSB
0014FFr 3  68                           pla             ; MSB
001500r 3               
001500r 3  C8                           iny
001501r 3  D0 01                        bne @1
001503r 3  1A                           inc
001504r 3               @1:
001504r 3  84 24                        sty tmp1
001506r 3  85 25                        sta tmp1+1
001508r 3               
001508r 3                               ; CREATE has also already modified the DP to point to the new
001508r 3                               ; word. We have no idea which instructions followed the CREATE
001508r 3                               ; command if there is a DOES> so the CP could point anywhere
001508r 3                               ; by now. The address of the word's xt is four bytes down.
001508r 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
00150Br 3  A5 02                        lda dp
00150Dr 3  18                           clc
00150Er 3  69 04                        adc #4
001510r 3  85 26                        sta tmp2
001512r 3  A5 03                        lda dp+1
001514r 3  69 00                        adc #0          ; we only care about the carry
001516r 3  85 27                        sta tmp2+1
001518r 3               
001518r 3                               ; Now we get that address and add one byte to skip over the JSR
001518r 3                               ; opcode
001518r 3  B2 26                        lda (tmp2)
00151Ar 3  18                           clc
00151Br 3  69 01                        adc #1
00151Dr 3  85 28                        sta tmp3
00151Fr 3  A0 01                        ldy #1
001521r 3  B1 26                        lda (tmp2),y
001523r 3  69 00                        adc #0          ; we only care about the carry
001525r 3  85 29                        sta tmp3+1
001527r 3               
001527r 3                               ; Replace the DOVAR address with our own
001527r 3  A5 24                        lda tmp1        ; LSB
001529r 3  92 28                        sta (tmp3)
00152Br 3  A5 25                        lda tmp1+1
00152Dr 3  91 28                        sta (tmp3),y    ; Y is still 1
00152Fr 3               
00152Fr 3                               ; Since we removed the return address that brought us here, we
00152Fr 3                               ; go back to whatever the main routine was. Otherwise, we we
00152Fr 3                               ; smash into the subroutine jump to DODOES.
00152Fr 3  60                           rts
001530r 3               
001530r 3               
001530r 3               
001530r 3               ; ## DOT ( u -- ) "Print TOS"
001530r 3               ; ## "."  auto  ANS core
001530r 3                       ; """https://forth-standard.org/standard/core/d"""
001530r 3               
001530r 3               xt_dot:
001530r 3  20 rr rr                     jsr underflow_1
001533r 3               
001533r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
001536r 3  20 rr rr                     jsr xt_abs                      ; ( n u )
001539r 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
00153Cr 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
00153Fr 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
001542r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
001545r 3  20 rr rr                     jsr xt_sign                     ; ( ud )
001548r 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
00154Br 3  20 rr rr                     jsr xt_type
00154Er 3  20 rr rr                     jsr xt_space
001551r 3               
001551r 3  60           z_dot:          rts
001552r 3               
001552r 3               
001552r 3               
001552r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
001552r 3               ; ## ".("  auto  ANS core
001552r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
001552r 3               
001552r 3               xt_dot_paren:
001552r 3                               ; Put a right paren on the stack.
001552r 3  CA                           dex
001553r 3  CA                           dex
001554r 3  A9 29                        lda #41     ; Right parenthesis
001556r 3  95 00                        sta 0,x
001558r 3  74 01                        stz 1,x
00155Ar 3               
00155Ar 3  20 rr rr                     jsr xt_parse
00155Dr 3  20 rr rr                     jsr xt_type
001560r 3               
001560r 3  60           z_dot_paren:    rts
001561r 3               
001561r 3               
001561r 3               
001561r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
001561r 3               ; ## ".""  auto  ANS core ext
001561r 3                       ; """https://forth-standard.org/standard/core/Dotq
001561r 3                       ; Compile string that is printed during run time. ANS Forth wants
001561r 3                       ; this to be compile-only, even though everybody and their friend
001561r 3                       ; uses it for everything. We follow the book here, and recommend
001561r 3                       ; `.(` for general printing.
001561r 3                       ; """
001561r 3               
001561r 3               xt_dot_quote:
001561r 3                               ; we let S" do the heavy lifting. Since we're in
001561r 3                               ; compile mode, it will save the string and reproduce it
001561r 3                               ; during runtime
001561r 3  20 rr rr                     jsr xt_s_quote
001564r 3               
001564r 3                               ; We then let TYPE do the actual printing
001564r 3  A0 rr                        ldy #>xt_type
001566r 3  A9 rr                        lda #<xt_type
001568r 3  20 rr rr                     jsr cmpl_subroutine
00156Br 3               
00156Br 3  60           z_dot_quote:    rts
00156Cr 3               
00156Cr 3               
00156Cr 3               
00156Cr 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
00156Cr 3               ; ## ".r"  tested  ANS core ext
00156Cr 3                       ; """https://forth-standard.org/standard/core/DotR
00156Cr 3                       ;
00156Cr 3                       ; Based on the Forth code
00156Cr 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
00156Cr 3                       ; """
00156Cr 3               
00156Cr 3               xt_dot_r:
00156Cr 3  20 rr rr                     jsr underflow_2
00156Fr 3               
00156Fr 3  20 rr rr                     jsr xt_to_r
001572r 3  20 rr rr                     jsr xt_dup
001575r 3  20 rr rr                     jsr xt_abs
001578r 3  20 rr rr                     jsr xt_zero
00157Br 3  20 rr rr                     jsr xt_less_number_sign
00157Er 3  20 rr rr                     jsr xt_number_sign_s
001581r 3  20 rr rr                     jsr xt_rot
001584r 3  20 rr rr                     jsr xt_sign
001587r 3  20 rr rr                     jsr xt_number_sign_greater
00158Ar 3  20 rr rr                     jsr xt_r_from
00158Dr 3  20 rr rr                     jsr xt_over
001590r 3  20 rr rr                     jsr xt_minus
001593r 3  20 rr rr                     jsr xt_spaces
001596r 3  20 rr rr                     jsr xt_type
001599r 3               
001599r 3  60           z_dot_r:        rts
00159Ar 3               
00159Ar 3               
00159Ar 3               
00159Ar 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
00159Ar 3               ; ## ".s"  tested  ANS tools
00159Ar 3                       ; """https://forth-standard.org/standard/tools/DotS
00159Ar 3                       ; Print content of Data Stack non-distructively. We follow the format
00159Ar 3                       ; of Gforth and print the number of elements first in brackets,
00159Ar 3                       ; followed by the Data Stack content (if any).
00159Ar 3                       ;
00159Ar 3                       ; Since this is for humans, we don't have to worry about speed.
00159Ar 3                       ; """
00159Ar 3               
00159Ar 3               xt_dot_s:
00159Ar 3  20 rr rr                     jsr xt_depth    ; ( -- u )
00159Dr 3               
00159Dr 3                               ; Print stack depth in brackets
00159Dr 3  A9 3C                        lda #$3c        ; ASCII for "<"
00159Fr 3  20 rr rr                     jsr emit_a
0015A2r 3               
0015A2r 3                               ; We keep a copy of the number of the things on the stack
0015A2r 3                               ; to use as a counter later down. This assumes that there
0015A2r 3                               ; are less than 255 elements on the stack
0015A2r 3  B5 00                        lda 0,x
0015A4r 3  48                           pha
0015A5r 3               
0015A5r 3                               ; print unsigned number without the trailing space
0015A5r 3  CA                           dex             ; DUP
0015A6r 3  CA                           dex
0015A7r 3  95 00                        sta 0,x
0015A9r 3  74 01                        stz 1,x
0015ABr 3               
0015ABr 3  20 rr rr                     jsr print_u
0015AEr 3               
0015AEr 3  A9 3E                        lda #$3e        ; ASCII for ">"
0015B0r 3  20 rr rr                     jsr emit_a
0015B3r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
0015B5r 3  20 rr rr                     jsr emit_a
0015B8r 3               
0015B8r 3  E8                           inx
0015B9r 3  E8                           inx
0015BAr 3               
0015BAr 3                               ; There will be lots of cases where the stack is empty. If that
0015BAr 3                               ; is so, get out of here quickly
0015BAr 3  E0 78                        cpx #dsp0
0015BCr 3  F0 1E                        beq @done
0015BEr 3               
0015BEr 3               @have_stack:
0015BEr 3                               ; We have at least one element on the stack. The depth of the
0015BEr 3                               ; stack is on the stack, we can use it as a counter. We go
0015BEr 3                               ; from bottom to top
0015BEr 3  7A                           ply
0015BFr 3               
0015BFr 3  A9 77                        lda #dsp0-1     ; go up one to avoid garbage
0015C1r 3  85 28                        sta tmp3
0015C3r 3  64 29                        stz tmp3+1      ; must be zero page on the 65c02
0015C5r 3               @loop:
0015C5r 3  CA                           dex
0015C6r 3  CA                           dex
0015C7r 3               
0015C7r 3  B2 28                        lda (tmp3)
0015C9r 3  95 01                        sta 1,x
0015CBr 3  C6 28                        dec tmp3
0015CDr 3               
0015CDr 3  B2 28                        lda (tmp3)
0015CFr 3  95 00                        sta 0,x
0015D1r 3  C6 28                        dec tmp3
0015D3r 3  5A                           phy
0015D4r 3               
0015D4r 3  20 rr rr                     jsr xt_dot
0015D7r 3               
0015D7r 3  7A                           ply
0015D8r 3  88                           dey
0015D9r 3  D0 EA                        bne @loop
0015DBr 3               
0015DBr 3  48                           pha             ; dummy to balance stack
0015DCr 3               @done:
0015DCr 3  68                           pla
0015DDr 3  60           z_dot_s:        rts
0015DEr 3               
0015DEr 3               
0015DEr 3               
0015DEr 3               ; ## D_DOT ( d -- ) "Print double"
0015DEr 3               ; ## "d."  tested  ANS double
0015DEr 3                       ; """http://forth-standard.org/standard/double/Dd"""
0015DEr 3                       ;
0015DEr 3                       ; From the Forth code:
0015DEr 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
0015DEr 3                       ; """
0015DEr 3               
0015DEr 3               xt_d_dot:
0015DEr 3  20 rr rr                     jsr underflow_2
0015E1r 3               
0015E1r 3  20 rr rr                     jsr xt_tuck
0015E4r 3  20 rr rr                     jsr xt_dabs
0015E7r 3  20 rr rr                     jsr xt_less_number_sign
0015EAr 3  20 rr rr                     jsr xt_number_sign_s
0015EDr 3  20 rr rr                     jsr xt_rot
0015F0r 3  20 rr rr                     jsr xt_sign
0015F3r 3  20 rr rr                     jsr xt_number_sign_greater
0015F6r 3  20 rr rr                     jsr xt_type
0015F9r 3  20 rr rr                     jsr xt_space
0015FCr 3               
0015FCr 3  60           z_d_dot:        rts
0015FDr 3               
0015FDr 3               
0015FDr 3               
0015FDr 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
0015FDr 3               ; ## "d.r"  tested  ANS double
0015FDr 3                       ; """http://forth-standard.org/standard/double/DDotR"""
0015FDr 3                       ; Based on the Forth code
0015FDr 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
0015FDr 3                       ; """
0015FDr 3               
0015FDr 3               xt_d_dot_r:
0015FDr 3  20 rr rr                     jsr underflow_3
001600r 3                               ; From the forth code:
001600r 3  20 rr rr                     jsr xt_to_r
001603r 3  20 rr rr                     jsr xt_tuck
001606r 3  20 rr rr                     jsr xt_dabs
001609r 3  20 rr rr                     jsr xt_less_number_sign
00160Cr 3  20 rr rr                     jsr xt_number_sign_s
00160Fr 3  20 rr rr                     jsr xt_rot
001612r 3  20 rr rr                     jsr xt_sign
001615r 3  20 rr rr                     jsr xt_number_sign_greater
001618r 3  20 rr rr                     jsr xt_r_from
00161Br 3  20 rr rr                     jsr xt_over
00161Er 3  20 rr rr                     jsr xt_minus
001621r 3  20 rr rr                     jsr xt_spaces
001624r 3  20 rr rr                     jsr xt_type
001627r 3               
001627r 3  60           z_d_dot_r:      rts
001628r 3               
001628r 3               
001628r 3               
001628r 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
001628r 3               ; ## "drop"  auto  ANS core
001628r 3                       ; """https://forth-standard.org/standard/core/DROP"""
001628r 3               xt_drop:
001628r 3  20 rr rr                     jsr underflow_1
00162Br 3               
00162Br 3  E8                           inx
00162Cr 3  E8                           inx
00162Dr 3               
00162Dr 3  60           z_drop:         rts
00162Er 3               
00162Er 3               
00162Er 3               ; ## DUMP ( addr u -- ) "Display a memory region"
00162Er 3               ; ## "dump"  tested  ANS tools
00162Er 3                       ; """https://forth-standard.org/standard/tools/DUMP
00162Er 3                       ;
00162Er 3                       ; DUMP's exact output is defined as "implementation dependent".
00162Er 3                       ; This is in assembler because it is
00162Er 3                       ; useful for testing and development, so we want to have it work
00162Er 3                       ; as soon as possible. Uses TMP2
00162Er 3                       ; """
00162Er 3               
00162Er 3               xt_dump:
00162Er 3  20 rr rr                     jsr underflow_2
001631r 3               @row:
001631r 3                               ; start counter for 16 numbers per row
001631r 3  A0 10                        ldy #16
001633r 3               
001633r 3                               ; We use TMP2 as the index for the ASCII characters
001633r 3                               ; that we print at the and of the hex block. We
001633r 3                               ; start saving them at HERE (CP)
001633r 3  64 26                        stz tmp2
001635r 3               
001635r 3  20 rr rr                     jsr xt_cr
001638r 3               
001638r 3                               ; print address number
001638r 3  B5 03                        lda 3,x
00163Ar 3  20 rr rr                     jsr byte_to_ascii
00163Dr 3  B5 02                        lda 2,x
00163Fr 3  20 rr rr                     jsr byte_to_ascii
001642r 3               
001642r 3  20 rr rr                     jsr xt_space
001645r 3  20 rr rr                     jsr xt_space
001648r 3               @loop:
001648r 3                               ; if there are zero bytes left to display, we're done
001648r 3  B5 00                        lda 0,x
00164Ar 3  15 01                        ora 1,x
00164Cr 3  F0 39                        beq @all_printed
00164Er 3               
00164Er 3                               ; dump the contents
00164Er 3  A1 02                        lda (2,x)
001650r 3  48                           pha                     ; byte_to_ascii destroys A
001651r 3  20 rr rr                     jsr byte_to_ascii
001654r 3  20 rr rr                     jsr xt_space
001657r 3  68                           pla
001658r 3               
001658r 3                               ; Handle ASCII printing
001658r 3  20 rr rr                     jsr is_printable
00165Br 3  B0 02                        bcs @printable
00165Dr 3  A9 2E                        lda #'.'                 ; Print dot if not printable
00165Fr 3               @printable:
00165Fr 3  5A                           phy                     ; save counter
001660r 3  A4 26                        ldy tmp2
001662r 3  91 00                        sta (cp),y
001664r 3  E6 26                        inc tmp2
001666r 3  7A                           ply
001667r 3               
001667r 3                               ; extra space after eight bytes
001667r 3  C0 09                        cpy #9
001669r 3  D0 03                        bne @next_char
00166Br 3  20 rr rr                     jsr xt_space
00166Er 3               
00166Er 3               @next_char:
00166Er 3  F6 02                        inc 2,x
001670r 3  D0 02                        bne @counter
001672r 3  F6 03                        inc 3,x
001674r 3               
001674r 3               @counter:
001674r 3                               ; loop counter
001674r 3  B5 00                        lda 0,x
001676r 3  D0 02                        bne @1
001678r 3  D6 01                        dec 1,x
00167Ar 3               @1:
00167Ar 3  D6 00                        dec 0,x
00167Cr 3  88                           dey
00167Dr 3  D0 C9                        bne @loop               ; next byte
00167Fr 3               
00167Fr 3                               ; Done with one line, print the ASCII version of these
00167Fr 3                               ; characters
00167Fr 3  20 rr rr                     jsr xt_space
001682r 3  20 rr rr                     jsr print_ascii
001685r 3               
001685r 3  80 AA                        bra @row                ; new row
001687r 3               
001687r 3               @all_printed:
001687r 3                               ; See if there are any ASCII characters in the buffer
001687r 3                               ; left to print
001687r 3  A5 26                        lda tmp2
001689r 3  F0 06                        beq @done
00168Br 3               
00168Br 3                               ; In theory, we could try to make the ASCII part line
00168Br 3                               ; up with the line before it. But that is a hassle (we
00168Br 3                               ; use three bytes for each missed hex entry, and
00168Br 3                               ; then there is the gap after eight entries) and it
00168Br 3                               ; makes it harder to read. We settle for one extra
00168Br 3                               ; space instead for the moment
00168Br 3  20 rr rr                     jsr xt_space
00168Er 3  20 rr rr                     jsr print_ascii
001691r 3               @done:
001691r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
001694r 3  60           z_dump:         rts
001695r 3               
001695r 3               
001695r 3               print_ascii:
001695r 3                               ; Print the ASCII characters that we have saved from
001695r 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
001695r 3                               ; is not compiled (DUMP is probably never compiled anyway)
001695r 3                               ; but we keep it inside the scope of DUMP.
001695r 3  A0 00                        ldy #0
001697r 3               @ascii_loop:
001697r 3  B1 00                        lda (cp),y
001699r 3  20 rr rr                     jsr emit_a
00169Cr 3  C8                           iny
00169Dr 3               
00169Dr 3                               ; extra space after eight chars
00169Dr 3  C0 08                        cpy #8
00169Fr 3  D0 03                        bne @1
0016A1r 3  20 rr rr                     jsr xt_space
0016A4r 3               @1:
0016A4r 3  C6 26                        dec tmp2
0016A6r 3  D0 EF                        bne @ascii_loop
0016A8r 3               
0016A8r 3  60                           rts
0016A9r 3               
0016A9r 3               
0016A9r 3               
0016A9r 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
0016A9r 3               ; ## "dup"  auto  ANS core
0016A9r 3                       ; """https://forth-standard.org/standard/core/DUP"""
0016A9r 3               xt_dup:
0016A9r 3  20 rr rr                     jsr underflow_1
0016ACr 3               
0016ACr 3  CA                           dex
0016ADr 3  CA                           dex
0016AEr 3               
0016AEr 3  B5 02                        lda 2,x         ; LSB
0016B0r 3  95 00                        sta 0,x
0016B2r 3  B5 03                        lda 3,x         ; MSB
0016B4r 3  95 01                        sta 1,x
0016B6r 3               
0016B6r 3  60           z_dup:          rts
0016B7r 3               
0016B7r 3               
0016B7r 3               ; ## ED ( -- u ) "Line-based editor"
0016B7r 3               ; ## "ed"  fragment  Tali Forth
0016B7r 3                       ; """Start the line-based editor ed6502. See separate file
0016B7r 3                       ; ed.asm or the manual for details.
0016B7r 3                       ; """
0016B7r 3               xt_ed:
0016B7r 3  20 rr rr                     jsr ed6502      ; kept in separate file
0016BAr 3               
0016BAr 3  60           z_ed:           rts
0016BBr 3               
0016BBr 3               
0016BBr 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
0016BBr 3               ; ## "editor-wordlist"  tested  Tali Editor
0016BBr 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
0016BBr 3                       ; words to the search order so they can be used.  This will need
0016BBr 3                       ; to be done before any of the words marked "Tali Editor" can be
0016BBr 3                       ; used.  See the tutorial on Wordlists and the Search Order for
0016BBr 3                       ; more information.
0016BBr 3               
0016BBr 3                       ;
0016BBr 3                       ; This is a dummy entry, the code is shared with ONE
0016BBr 3                       ; """
0016BBr 3               
0016BBr 3               
0016BBr 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
0016BBr 3               ; ## "else"  auto  ANS core
0016BBr 3                       ; """http://forth-standard.org/standard/core/ELSE
0016BBr 3                       ;
0016BBr 3                       ; The code is shared with ENDOF
0016BBr 3                       ; """
0016BBr 3               
0016BBr 3               xt_else:
0016BBr 3               xt_endof:
0016BBr 3                               ; Put an unconditional branch.
0016BBr 3  A0 rr                        ldy #>branch_runtime
0016BDr 3  A9 rr                        lda #<branch_runtime
0016BFr 3  20 rr rr                     jsr cmpl_subroutine
0016C2r 3               
0016C2r 3                               ; Put the address of the branch address on the stack.
0016C2r 3  20 rr rr                     jsr xt_here
0016C5r 3               
0016C5r 3                               ; Use zero for the branch address for now.
0016C5r 3                               ; THEN will fill it in later.
0016C5r 3  20 rr rr                     jsr xt_zero
0016C8r 3  20 rr rr                     jsr xt_comma
0016CBr 3               
0016CBr 3                               ; Get the address to jump to (just after the
0016CBr 3                               ; unconditional branch) for the IF to jump to
0016CBr 3                               ; when false.
0016CBr 3  20 rr rr                     jsr xt_here
0016CEr 3  20 rr rr                     jsr xt_rot
0016D1r 3               
0016D1r 3                               ; Update the original if 0branch address.
0016D1r 3  20 rr rr                     jsr xt_store
0016D4r 3               z_else:
0016D4r 3               z_endof:
0016D4r 3  60                           rts
0016D5r 3               
0016D5r 3               
0016D5r 3               
0016D5r 3               branch_runtime:
0016D5r 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
0016D5r 3                       ; formally part of a separate word BRANCH which was later removed.
0016D5r 3                       ; """
0016D5r 3               
0016D5r 3                               ; The address on the Return Stack points to the last byte
0016D5r 3                               ; of the JSR address, one byte below the branch literal
0016D5r 3  68                           pla
0016D6r 3  85 22                        sta tmpbranch
0016D8r 3  68                           pla
0016D9r 3  85 23                        sta tmpbranch+1
0016DBr 3               
0016DBr 3                               ; Keep in mind: the address we just popped points one byte
0016DBr 3                               ; lower than the branch literal we want to grab
0016DBr 3  A0 01                        ldy #1
0016DDr 3  B1 22                        lda (tmpbranch),y  ; LSB
0016DFr 3  85 24                        sta tmp1
0016E1r 3  C8                           iny
0016E2r 3  B1 22                        lda (tmpbranch),y  ; MSB
0016E4r 3  85 25                        sta tmp1+1
0016E6r 3               
0016E6r 3  6C 24 00                     jmp (tmp1)
0016E9r 3               
0016E9r 3               
0016E9r 3               
0016E9r 3               ; ## EMIT ( char -- ) "Print character to current output"
0016E9r 3               ; ## "emit"  auto  ANS core
0016E9r 3                       ; """https://forth-standard.org/standard/core/EMIT
0016E9r 3                       ; Run-time default for EMIT. The user can revector this by changing
0016E9r 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
0016E9r 3                       ; do not check to see if we have been given a valid ASCII character.
0016E9r 3                       ; Don't make this native compile.
0016E9r 3                       ; """
0016E9r 3               
0016E9r 3               xt_emit:
0016E9r 3  20 rr rr                     jsr underflow_1
0016ECr 3               
0016ECr 3  B5 00                        lda 0,x
0016EEr 3  E8                           inx
0016EFr 3  E8                           inx
0016F0r 3               
0016F0r 3               emit_a:
0016F0r 3                       ; We frequently want to print the character in A without fooling
0016F0r 3                       ; around with the Data Stack. This is emit_a's job, which still
0016F0r 3                       ; allows the output to be vectored. Call it with JSR as you
0016F0r 3                       ; would XT_EMIT
0016F0r 3  6C 10 00                     jmp (output)            ; JSR/RTS
0016F3r 3               
0016F3r 3               z_emit:         ; never reached
0016F3r 3               
0016F3r 3               
0016F3r 3               
0016F3r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
0016F3r 3               ; ## "empty-buffers"  tested  ANS block ext
0016F3r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
0016F3r 3               xt_empty_buffers:
0016F3r 3                               ; Set the buffer status to empty.
0016F3r 3  A0 2C                        ldy #buffstatus_offset
0016F5r 3  A9 00                        lda #0
0016F7r 3  91 1E                        sta (up),y      ; Only LSB is used.
0016F9r 3               z_empty_buffers:
0016F9r 3  60                           rts
0016FAr 3               
0016FAr 3               
0016FAr 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
0016FAr 3               ; ## "endcase"  auto  ANS core ext
0016FAr 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
0016FAr 3               
0016FAr 3               xt_endcase:
0016FAr 3                               ; Postpone DROP to remove the item
0016FAr 3                               ; being checked.
0016FAr 3  A0 rr                        ldy #>xt_drop
0016FCr 3  A9 rr                        lda #<xt_drop
0016FEr 3  20 rr rr                     jsr cmpl_subroutine
001701r 3               
001701r 3                               ; There are a number of address (of branches that need their
001701r 3                               ; jump addressed filled in with the address of right here).
001701r 3                               ; Keep calling THEN to deal with them until we reach the
001701r 3                               ; 0 that CASE put on the stack at the beginning.
001701r 3               @endcase_loop:
001701r 3                               ; Check for 0 on the stack.
001701r 3  B5 00                        lda 0,x
001703r 3  15 01                        ora 1,x
001705r 3  F0 05                        beq @done
001707r 3               
001707r 3  20 rr rr                     jsr xt_then
00170Ar 3  80 F5                        bra @endcase_loop
00170Cr 3               @done:
00170Cr 3                               ; Remove the 0 from the stack.
00170Cr 3  E8                           inx
00170Dr 3  E8                           inx
00170Er 3  60           z_endcase:      rts
00170Fr 3               
00170Fr 3               
00170Fr 3               
00170Fr 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
00170Fr 3               ; ## "endof"  auto  ANS core ext
00170Fr 3                       ; """http://forth-standard.org/standard/core/ENDOF
00170Fr 3                       ; This is a dummy entry, the code is shared with ELSE
00170Fr 3                       ; """
00170Fr 3               
00170Fr 3               
00170Fr 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
00170Fr 3               ; ## "environment?"  auto  ANS core
00170Fr 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
00170Fr 3                       ;
00170Fr 3                       ; By ANS definition, we use upper-case strings here, see the
00170Fr 3                       ; string file for details. This can be realized as a high-level
00170Fr 3                       ; Forth word as
00170Fr 3                       ;
00170Fr 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
00170Fr 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
00170Fr 3                       ; HEX
00170Fr 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
00170Fr 3                       ; CASE
00170Fr 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
00170Fr 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
00170Fr 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
00170Fr 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
00170Fr 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
00170Fr 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
00170Fr 3                       ; S" MAX-D"              STRING_OF
00170Fr 3                                                    ; 7FFFFFFF. TRUE ENDOF
00170Fr 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
00170Fr 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
00170Fr 3                       ; S" MAX-UD"             STRING_OF
00170Fr 3                                                    ; FFFFFFFF. TRUE ENDOF
00170Fr 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
00170Fr 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
00170Fr 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
00170Fr 3                       ; ENDCASE ;
00170Fr 3                       ;
00170Fr 3                       ; but that uses lots of memory and increases the start up time. This
00170Fr 3                       ; word is rarely used so we can try to keep it short at the expense
00170Fr 3                       ; of speed.
00170Fr 3                       ; """
00170Fr 3               
00170Fr 3               xt_environment_q:
00170Fr 3  20 rr rr                     jsr underflow_1
001712r 3               
001712r 3                               ; This code is table-driven: We walk through the list of
001712r 3                               ; strings until we find one that matches, and then we take
001712r 3                               ; the equivalent data from the results table. This is made
001712r 3                               ; a bit harder by the fact that some of these return a
001712r 3                               ; double-cell number and some a single-cell one.
001712r 3               
001712r 3                               ; We will walk through the table with variables that return
001712r 3                               ; a single-cell result
001712r 3  A0 00                        ldy #00                 ; counter for table
001714r 3               
001714r 3                               ; We use a flag on the the stack to signal if we have a single-cell
001714r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
001714r 3                               ; double-cell.
001714r 3  5A                           phy
001715r 3               @table_loop:
001715r 3                               ; We arrived here with the address of the string to be checked
001715r 3                               ; on the stack. We make a copy. Index is in Y
001715r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
001718r 3               
001718r 3                               ; We do our work on the TOS to speed things up
001718r 3  CA                           dex
001719r 3  CA                           dex                     ; ( addr u addr u ? )
00171Ar 3               
00171Ar 3                               ; Get address of string to check from table
00171Ar 3  B9 rr rr                     lda env_table_single,y
00171Dr 3  95 00                        sta 0,x
00171Fr 3  C8                           iny
001720r 3  B9 rr rr                     lda env_table_single,y
001723r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
001725r 3  C8                           iny
001726r 3               
001726r 3                               ; See if this is the last entry. The LSB is still in A
001726r 3  15 00                        ora 0,x
001728r 3  F0 4D                        beq @table_done
00172Ar 3               
00172Ar 3                               ; We have a string entry. The address there is stored in
00172Ar 3                               ; old-style address format, that is, the first byte is the
00172Ar 3                               ; length of the string
00172Ar 3  5A                           phy                     ; save Y, which is used by COUNT
00172Br 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
00172Er 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
001731r 3  7A                           ply
001732r 3               
001732r 3                               ; If we found a match (flag is zero -- COMPARE is weird
001732r 3                               ; that way), return the result
001732r 3  B5 00                        lda 0,x
001734r 3  15 01                        ora 1,x
001736r 3  F0 04                        beq @got_result
001738r 3               
001738r 3                               ; Flag is not zero, so not a perfect match, so try next
001738r 3                               ; word
001738r 3  E8                           inx                     ; DROP, now ( addr u )
001739r 3  E8                           inx
00173Ar 3               
00173Ar 3  80 D9                        bra @table_loop
00173Cr 3               
00173Cr 3               @got_result:
00173Cr 3                               ; We arrive here with ( addr u -1 ) and know that we've found
00173Cr 3                               ; a match. The index of the match+2 is in Y.
00173Cr 3  E8                           inx                     ; drop flag, now ( addr u )
00173Dr 3  E8                           inx
00173Er 3  88                           dey                     ; go back to index we had
00173Fr 3  88                           dey
001740r 3               
001740r 3                               ; See if this is a single-cell word.
001740r 3  68                           pla
001741r 3  D0 0D                        bne @double_result
001743r 3               
001743r 3                               ; Single-cell result
001743r 3  B9 rr rr                     lda env_results_single,y
001746r 3  95 02                        sta 2,x
001748r 3  C8                           iny
001749r 3  B9 rr rr                     lda env_results_single,y
00174Cr 3  95 03                        sta 3,x                 ; ( res u )
00174Er 3               
00174Er 3  80 1F                        bra @set_flag
001750r 3               
001750r 3               @double_result:
001750r 3                               ; This is a double-celled result, which means we have to
001750r 3                               ; fool around with the index some more. We also need a
001750r 3                               ; further cell on the stack
001750r 3  CA                           dex                     ; ( addr u ? )
001751r 3  CA                           dex
001752r 3               
001752r 3                               ; We have 11 single-cell words we check, plus the 0000 as
001752r 3                               ; a marker for the end of the table, so we arrive here
001752r 3                               ; with Y as 22 or more. To get the index for the double-
001752r 3                               ; cell words, we move the result
001752r 3  98                           tya
001753r 3  38                           sec
001754r 3  E9 18                        sbc #24
001756r 3               
001756r 3                               ; We have four bytes per entry in the table, but the index
001756r 3                               ; keeps increasing by two, so we only have to multiply by
001756r 3                               ; two (shift left once) to get the right result
001756r 3  0A                           asl
001757r 3  A8                           tay
001758r 3               
001758r 3  B9 rr rr                     lda env_results_double,y
00175Br 3  95 02                        sta 2,x
00175Dr 3  C8                           iny
00175Er 3  B9 rr rr                     lda env_results_double,y
001761r 3  95 03                        sta 3,x                 ; ( res u ? )
001763r 3  C8                           iny
001764r 3               
001764r 3  B9 rr rr                     lda env_results_double,y
001767r 3  95 04                        sta 4,x
001769r 3  C8                           iny
00176Ar 3  B9 rr rr                     lda env_results_double,y
00176Dr 3  95 05                        sta 5,x                 ; ( res res ? )
00176Fr 3               
00176Fr 3                               ; fall through to @set_flag
00176Fr 3               @set_flag:
00176Fr 3  A9 FF                        lda #$ff
001771r 3  95 00                        sta 0,x
001773r 3  95 01                        sta 1,x                 ; ( res f )
001775r 3               
001775r 3  80 14                        bra @done
001777r 3               @table_done:
001777r 3                               ; We're done with a table, because the entry was a zero.
001777r 3                               ; We arrive here with ( addr u addr u 0 )
001777r 3               
001777r 3                               ; We take the flag from stack and increase it by one. If the
001777r 3                               ; flag is zero, we have just completed the single-cell number
001777r 3                               ; strings, so we in increase the flag and try again. Otherwise,
001777r 3                               ; we're done with the double-cell table without having found
001777r 3                               ; a match, and we're done
001777r 3  68                           pla
001778r 3  D0 09                        bne @no_match
00177Ar 3               
00177Ar 3                               ; Flag is zero, increase it to one and start over to check
00177Ar 3                               ; double-cell values
00177Ar 3  1A                           inc
00177Br 3  48                           pha
00177Cr 3               
00177Cr 3  8A                           txa
00177Dr 3  18                           clc
00177Er 3  69 06                        adc #6                  ; skip six bytes
001780r 3  AA                           tax                     ; ( addr u )
001781r 3               
001781r 3  80 92                        bra @table_loop
001783r 3               @no_match:
001783r 3                               ; Bummer, not found. We arrive here with
001783r 3                               ; ( addr u addr u 0 ) and need to return just a zero
001783r 3  8A                           txa
001784r 3  18                           clc
001785r 3  69 0A                        adc #10
001787r 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
001788r 3               
001788r 3  20 rr rr                     jsr xt_false
00178Br 3               @done:
00178Br 3               z_environment_q:
00178Br 3  60                           rts
00178Cr 3               
00178Cr 3               
00178Cr 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
00178Cr 3               ; results and one for the double-celled results. The zero cell at the
00178Cr 3               ; end of each table marks its, uh, end. The strings themselves are defined
00178Cr 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
00178Cr 3               ; have to adapt the result code for double printout, where we subtract 22
00178Cr 3               ; (two bytes each single-cell string and two bytes for the end-of-table
00178Cr 3               ; marker 0000
00178Cr 3               env_table_single:
00178Cr 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
001790r 3  rr rr rr rr  
001794r 3  rr rr        
001796r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
00179Ar 3  rr rr rr rr  
00179Er 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
0017A2r 3  00 00        
0017A4r 3               
0017A4r 3               env_table_double:
0017A4r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
0017A8r 3  00 00        
0017AAr 3               
0017AAr 3               env_results_single:
0017AAr 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
0017ACr 3  FF 00                .word $00FF     ; /HOLD
0017AEr 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
0017B0r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
0017B2r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
0017B4r 3  FF 00                .word $00FF     ; MAX-CHAR
0017B6r 3  FF 7F                .word $7FFF     ; MAX-N
0017B8r 3  FF FF                .word $FFFF     ; MAX-U
0017BAr 3  80 00                .word $0080     ; RETURN-STACK-CELLS
0017BCr 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
0017BEr 3  09 00                .word $0009     ; WORDLISTS
0017C0r 3               
0017C0r 3               env_results_double:
0017C0r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
0017C4r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
0017C8r 3               
0017C8r 3               
0017C8r 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
0017C8r 3               ; ## "="  auto  ANS core
0017C8r 3                       ; """https://forth-standard.org/standard/core/Equal"""
0017C8r 3               
0017C8r 3               xt_equal:
0017C8r 3  20 rr rr                     jsr underflow_2
0017CBr 3               
0017CBr 3  B5 00                        lda 0,x                 ; LSB
0017CDr 3  D5 02                        cmp 2,x
0017CFr 3  D0 0A                        bne @false
0017D1r 3               
0017D1r 3  B5 01                        lda 1,x                 ; MSB
0017D3r 3  D5 03                        cmp 3,x
0017D5r 3  D0 04                        bne @false
0017D7r 3               
0017D7r 3  A9 FF                        lda #$ff
0017D9r 3  80 02                        bra @done
0017DBr 3               
0017DBr 3  A9 00        @false:         lda #0                  ; drop thru to done
0017DDr 3               
0017DDr 3  95 02        @done:          sta 2,x
0017DFr 3  95 03                        sta 3,x
0017E1r 3               
0017E1r 3  E8                           inx
0017E2r 3  E8                           inx
0017E3r 3               
0017E3r 3  60           z_equal:        rts
0017E4r 3               
0017E4r 3               
0017E4r 3               
0017E4r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
0017E4r 3               ; ## "blank"  auto  ANS string
0017E4r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
0017E4r 3               xt_blank:
0017E4r 3                               ; We don't check for underflow here because
0017E4r 3                               ; we deal with that in FILL
0017E4r 3  CA                           dex
0017E5r 3  CA                           dex
0017E6r 3  A9 20                        lda #AscSP
0017E8r 3  95 00                        sta 0,x
0017EAr 3  74 01                        stz 1,x
0017ECr 3               
0017ECr 3  80 06                        bra xt_fill     ; skip over code for ERASE
0017EEr 3               
0017EEr 3               
0017EEr 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
0017EEr 3               ; ## "erase"  auto  ANS core ext
0017EEr 3                       ; """https://forth-standard.org/standard/core/ERASE
0017EEr 3                       ; Note that ERASE works with "address" units
0017EEr 3                       ; (bytes), not cells.
0017EEr 3                       ; """
0017EEr 3               
0017EEr 3               xt_erase:
0017EEr 3                               ; We don't check for underflow here because
0017EEr 3                               ; we deal with that in FILL
0017EEr 3  CA                           dex
0017EFr 3  CA                           dex
0017F0r 3  74 00                        stz 0,x
0017F2r 3  74 01                        stz 1,x
0017F4r 3               
0017F4r 3                               ; fall through to FILL
0017F4r 3               
0017F4r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
0017F4r 3               ; ## "fill"  auto  ANS core
0017F4r 3                       ; """https://forth-standard.org/standard/core/FILL
0017F4r 3                       ; Fill u bytes of memory with char starting at addr. Note that
0017F4r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
0017F4r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
0017F4r 3                       ; happens when we reach the end of the address space
0017F4r 3                       ; """
0017F4r 3               xt_fill:
0017F4r 3  20 rr rr                     jsr underflow_3
0017F7r 3               
0017F7r 3                               ; We use tmp1 to hold the address
0017F7r 3  B5 04                        lda 4,x         ; LSB
0017F9r 3  85 24                        sta tmp1
0017FBr 3  B5 05                        lda 5,x
0017FDr 3  85 25                        sta tmp1+1
0017FFr 3               
0017FFr 3                               ; We use tmp2 to hold the counter
0017FFr 3  B5 02                        lda 2,x
001801r 3  85 26                        sta tmp2
001803r 3  B5 03                        lda 3,x
001805r 3  85 27                        sta tmp2+1
001807r 3               
001807r 3                               ; We use Y to hold the character
001807r 3  B5 00                        lda 0,x
001809r 3  A8                           tay
00180Ar 3               @loop:
00180Ar 3                               ; Unfortunately, we also need to make sure that we don't
00180Ar 3                               ; write further than the end of the RAM. So RAM_END must
00180Ar 3                               ; be larger or equal to the current address
00180Ar 3  A9 7F                        lda #>ram_end           ; MSB
00180Cr 3  C5 25                        cmp tmp1+1
00180Er 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
001810r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
001812r 3               
001812r 3  A9 FF                        lda #<ram_end           ; LSB, because MSBs were equal
001814r 3  C5 24                        cmp tmp1
001816r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
001818r 3               
001818r 3               @check_counter:
001818r 3                               ; See if our counter has reached zero
001818r 3  A5 26                        lda tmp2
00181Ar 3  05 27                        ora tmp2+1
00181Cr 3  F0 13                        beq @done
00181Er 3               
00181Er 3                               ; We're not in ROM and we still have stuff on the counter, so
00181Er 3                               ; let's actually do what we came here to do
00181Er 3  98                           tya
00181Fr 3  92 24                        sta (tmp1)
001821r 3               
001821r 3                               ; Adjust the counter
001821r 3  A5 26                        lda tmp2
001823r 3  D0 02                        bne @1
001825r 3  C6 27                        dec tmp2+1
001827r 3  C6 26        @1:               dec tmp2
001829r 3               
001829r 3                               ; Next address
001829r 3  E6 24                        inc tmp1
00182Br 3  D0 DD                        bne @loop
00182Dr 3  E6 25                        inc tmp1+1
00182Fr 3               
00182Fr 3  80 D9                        bra @loop
001831r 3               
001831r 3               @done:
001831r 3                               ; Drop three cells off the Data Stack. This uses one byte
001831r 3                               ; less than six times INX
001831r 3  8A                           txa
001832r 3  18                           clc
001833r 3  69 06                        adc #6
001835r 3  AA                           tax
001836r 3               z_blank:
001836r 3               z_erase:
001836r 3  60           z_fill:         rts
001837r 3               
001837r 3               
001837r 3               
001837r 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
001837r 3               ; ## "execute"  auto  ANS core
001837r 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
001837r 3               xt_execute:
001837r 3  20 rr rr                     jsr underflow_1
00183Ar 3               
00183Ar 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
00183Dr 3               
00183Dr 3  60           z_execute:      rts
00183Er 3               
00183Er 3               doexecute:
00183Er 3  B5 00                        lda 0,x
001840r 3  85 0E                        sta ip
001842r 3  B5 01                        lda 1,x
001844r 3  85 0F                        sta ip+1
001846r 3               
001846r 3  E8                           inx
001847r 3  E8                           inx
001848r 3               
001848r 3                               ; we don't need a RTS here because we highjack the RTS of
001848r 3                               ; the word we're calling to get back to xt_execute
001848r 3  6C 0E 00                     jmp (ip)
00184Br 3               
00184Br 3               ; end of doexecute
00184Br 3               
00184Br 3               
00184Br 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
00184Br 3               ; ## "execute-parsing"  auto  Gforth
00184Br 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
00184Br 3                       ; Execute the parsing word defined by the execution token (xt) on the
00184Br 3                       ; string as if it were passed on the command line. See the file
00184Br 3                       ; tests/tali.fs for examples.
00184Br 3                       ;
00184Br 3                       ; Note that this word is coded completely
00184Br 3                       ; different in its Gforth version, see the file execute-parsing.fs
00184Br 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
00184Br 3                       ; """
00184Br 3               xt_execute_parsing:
00184Br 3  20 rr rr                     jsr underflow_3
00184Er 3               
00184Er 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
001851r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
001854r 3               
001854r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
001856r 3  85 0A                        sta ciblen
001858r 3  B5 01                        lda 1,x
00185Ar 3  85 0B                        sta ciblen+1
00185Cr 3               
00185Cr 3  B5 02                        lda 2,x                 ; NOS is new cib
00185Er 3  85 08                        sta cib
001860r 3  B5 03                        lda 3,x
001862r 3  85 09                        sta cib+1
001864r 3               
001864r 3  64 0C                        stz toin                ; Set >IN to zero
001866r 3  64 0D                        stz toin+1
001868r 3               
001868r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
00186Br 3  20 rr rr                     jsr xt_execute
00186Er 3               
00186Er 3  20 rr rr                     jsr xt_r_to_input
001871r 3               
001871r 3               z_execute_parsing:
001871r 3  60                           rts
001872r 3               
001872r 3               
001872r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
001872r 3               ; ## "exit"  auto  ANS core
001872r 3                       ; """https://forth-standard.org/standard/core/EXIT
001872r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
001872r 3                       ; we we might have put on the Return Stack off as well. This should
001872r 3                       ; be natively compiled.
001872r 3                       ; """
001872r 3               
001872r 3               xt_exit:
001872r 3  60                           rts             ; keep before z_exit
001873r 3               z_exit:                         ; never reached
001873r 3               
001873r 3               
001873r 3               
001873r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
001873r 3               ; ## "false"  auto  ANS core ext
001873r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
001873r 3               xt_false:
001873r 3  CA                           dex
001874r 3  CA                           dex
001875r 3  74 00                        stz 0,x
001877r 3  74 01                        stz 1,x
001879r 3               
001879r 3  60           z_false:        rts
00187Ar 3               
00187Ar 3               
00187Ar 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
00187Ar 3               ; ## "@"  auto  ANS core
00187Ar 3                       ; """https://forth-standard.org/standard/core/Fetch"""
00187Ar 3               xt_fetch:
00187Ar 3  20 rr rr                     jsr underflow_1
00187Dr 3               
00187Dr 3  A1 00                        lda (0,x)               ; LSB
00187Fr 3  A8                           tay
001880r 3  F6 00                        inc 0,x
001882r 3  D0 02                        bne @1
001884r 3  F6 01                        inc 1,x
001886r 3               @1:
001886r 3  A1 00                        lda (0,x)               ; MSB
001888r 3  95 01                        sta 1,x
00188Ar 3  94 00                        sty 0,x
00188Cr 3               
00188Cr 3  60           z_fetch:        rts
00188Dr 3               
00188Dr 3               
00188Dr 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
00188Dr 3               ; ## "find"  auto  ANS core
00188Dr 3                       ; """https://forth-standard.org/standard/core/FIND
00188Dr 3                       ; Included for backwards compatibility only, because it still
00188Dr 3                       ; can be found in so may examples. It should, however, be replaced
00188Dr 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
00188Dr 3                       ; flag if not found in the Dictionary, or the xt with a flag to
00188Dr 3                       ; indicate if this is immediate or not. FIND is a wrapper around
00188Dr 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
00188Dr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
00188Dr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00188Dr 3                       ; """
00188Dr 3               
00188Dr 3               xt_find:
00188Dr 3  20 rr rr                     jsr underflow_1
001890r 3               
001890r 3                               ; Save address in case conversion fails. We use the
001890r 3                               ; Return Stack instead of temporary variables like TMP1
001890r 3                               ; because this is shorter and anybody still using FIND
001890r 3                               ; can't be worried about speed anyway
001890r 3  B5 01                        lda 1,x                 ; MSB
001892r 3  48                           pha
001893r 3  B5 00                        lda 0,x                 ; LSB
001895r 3  48                           pha
001896r 3               
001896r 3                               ; Convert ancient-type counted string address to
001896r 3                               ; modern format
001896r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
001899r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
00189Cr 3               
00189Cr 3  B5 00                        lda 0,x
00189Er 3  15 01                        ora 1,x
0018A0r 3  D0 0B                        bne @found_word
0018A2r 3               
0018A2r 3                               ; No word found. Return address of the string and a false
0018A2r 3                               ; flag
0018A2r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
0018A5r 3               
0018A5r 3                               ; The address needs to be restored.
0018A5r 3  68                           pla                     ; LSB of address
0018A6r 3  95 02                        sta 2,x
0018A8r 3  68                           pla
0018A9r 3  95 03                        sta 3,x                 ; MSB of address
0018ABr 3               
0018ABr 3  80 27                        bra @done               ; ( addr 0 )
0018ADr 3               
0018ADr 3               @found_word:
0018ADr 3                               ; We don't need the address after all, dump it
0018ADr 3  68                           pla
0018AEr 3  68                           pla
0018AFr 3               
0018AFr 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
0018AFr 3                               ; convert the return values to FIND's format
0018AFr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0018B2r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0018B5r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0018B8r 3               
0018B8r 3  A0 00                        ldy #0                  ; Prepare flag
0018BAr 3               
0018BAr 3                               ; The flags are in the second byte of the header
0018BAr 3  F6 00                        inc 0,x
0018BCr 3  D0 02                        bne @1
0018BEr 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0018C0r 3               @1:
0018C0r 3  A1 00                        lda (0,x)               ; ( xt char )
0018C2r 3  29 04                        and #IM
0018C4r 3  D0 08                        bne @immediate          ; bit set, we're immediate
0018C6r 3               
0018C6r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
0018C8r 3  95 00                        sta 0,x
0018CAr 3  95 01                        sta 1,x
0018CCr 3  80 06                        bra @done
0018CEr 3               
0018CEr 3               @immediate:
0018CEr 3  A9 01                        lda #1                  ; We're immediate, return 1
0018D0r 3  95 00                        sta 0,x
0018D2r 3  74 01                        stz 1,x
0018D4r 3               @done:
0018D4r 3  60           z_find:         rts
0018D5r 3               
0018D5r 3               
0018D5r 3               
0018D5r 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
0018D5r 3               ; ## "find-name"  auto  Gforth
0018D5r 3               
0018D5r 3               xt_find_name:
0018D5r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0018D5r 3                       ; Given a string, find the Name Token (nt) of a word or return
0018D5r 3                       ; zero if the word is not in the dictionary. We use this instead of
0018D5r 3                       ; ancient FIND to look up words in the Dictionary passed by
0018D5r 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
0018D5r 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
0018D5r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0018D5r 3                       ; FIND calls this word
0018D5r 3                       ; """
0018D5r 3  20 rr rr                     jsr underflow_2
0018D8r 3               
0018D8r 3                               ; check for special case of an empty string (length zero)
0018D8r 3  B5 00                        lda 0,x
0018DAr 3  15 01                        ora 1,x
0018DCr 3  D0 03                        bne @nonempty
0018DEr 3               
0018DEr 3  4C rr rr                     jmp @fail_done
0018E1r 3               
0018E1r 3               @nonempty:
0018E1r 3                               ; Set up for traversing the wordlist search order.
0018E1r 3  64 28                        stz tmp3                ; Start at the beginning
0018E3r 3               
0018E3r 3               @wordlist_loop:
0018E3r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
0018E5r 3  A5 28                        lda tmp3
0018E7r 3  D1 1E                        cmp (up),y              ; Check to see if we are done
0018E9r 3  D0 03                        bne @have_string
0018EBr 3               
0018EBr 3                               ; We ran out of wordlists to search.
0018EBr 3  4C rr rr                     jmp @fail_done
0018EEr 3               
0018EEr 3               @have_string:
0018EEr 3                               ; set up first loop iteration
0018EEr 3               
0018EEr 3                               ; Get the current wordlist id
0018EEr 3  18                           clc             ; SEARCH-ORDER is array of bytes.
0018EFr 3  69 1F                        adc #search_order_offset
0018F1r 3  A8                           tay
0018F2r 3  B1 1E                        lda (up),y      ; Get the id byte, which is the offset
0018F4r 3                                               ; into the cell array WORDLISTS
0018F4r 3               
0018F4r 3                               ; Get the DP for that wordlist.
0018F4r 3  0A                           asl                     ; Turn offset into cells offset.
0018F5r 3  18                           clc
0018F6r 3  69 06                        adc #wordlists_offset
0018F8r 3  A8                           tay
0018F9r 3  B1 1E                        lda (up),y
0018FBr 3  85 24                        sta tmp1
0018FDr 3  C8                           iny
0018FEr 3  B1 1E                        lda (up),y
001900r 3  85 25                        sta tmp1+1
001902r 3               
001902r 3  B5 02                        lda 2,x                 ; Address of mystery string
001904r 3  85 26                        sta tmp2
001906r 3  B5 03                        lda 3,x
001908r 3  85 27                        sta tmp2+1
00190Ar 3               
00190Ar 3               @loop:
00190Ar 3                               ; first quick test: Are strings the same length?
00190Ar 3  B2 24                        lda (tmp1)
00190Cr 3  D5 00                        cmp 0,x
00190Er 3  D0 54                        bne @next_entry
001910r 3               
001910r 3               @compare_string:
001910r 3                               ; are the same length, so we now have to compare each
001910r 3                               ; character
001910r 3               
001910r 3                               ; second quick test: Is the first character the same?
001910r 3  B2 26                        lda (tmp2)      ; first character of mystery string
001912r 3               
001912r 3                               ; Lowercase the incoming charcter.
001912r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001914r 3  B0 07                        bcs @compare_first
001916r 3  C9 41                        cmp #$41        ; ASCII 'A'
001918r 3  90 03                        bcc @compare_first
00191Ar 3               
00191Ar 3                               ; An uppercase letter has been located.  Make it
00191Ar 3                               ; lowercase.
00191Ar 3  18                           clc
00191Br 3  69 20                        adc #$20
00191Dr 3               
00191Dr 3               @compare_first:
00191Dr 3  A0 08                        ldy #8          ; Offset in nt to name
00191Fr 3  D1 24                        cmp (tmp1),y    ; first character of current word
001921r 3  D0 41                        bne @next_entry
001923r 3               
001923r 3                               ; String length is the same and the first character is the
001923r 3                               ; same. If the length of the string is 1, we're already done
001923r 3  B5 00                        lda 0,x
001925r 3  3A                           dec
001926r 3  F0 2C                        beq @success
001928r 3               
001928r 3                               ; No such luck: The strings are the same length and the first
001928r 3                               ; char is the same, but the word is more than one char long.
001928r 3                               ; So we suck it up and compare every single character. We go
001928r 3                               ; from back to front, because words like CELLS and CELL+ would
001928r 3                               ; take longer otherwise. We can also shorten the loop by one
001928r 3                               ; because we've already compared the first char.
001928r 3               
001928r 3                               ; The string of the word we're testing against is 8 bytes down
001928r 3  A5 24                        lda tmp1
00192Ar 3  48                           pha             ; Preserve tmp1 on the return stack.
00192Br 3  18                           clc
00192Cr 3  69 08                        adc #8
00192Er 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001930r 3  A5 25                        lda tmp1+1
001932r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001933r 3  69 00                        adc #0          ; we only need the carry
001935r 3  85 25                        sta tmp1+1
001937r 3               
001937r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001939r 3  88                           dey
00193Ar 3               
00193Ar 3               @string_loop:
00193Ar 3  B1 26                        lda (tmp2),y    ; last char of mystery string
00193Cr 3               
00193Cr 3                               ; Lowercase the incoming charcter.
00193Cr 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
00193Er 3  B0 07                        bcs @check_char
001940r 3  C9 41                        cmp #$41        ; ASCII 'A'
001942r 3  90 03                        bcc @check_char
001944r 3               
001944r 3                               ; An uppercase letter has been located.  Make it
001944r 3                               ; lowercase.
001944r 3  18                           clc
001945r 3  69 20                        adc #$20
001947r 3               
001947r 3               @check_char:
001947r 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
001949r 3  D0 13                        bne @next_entry_tmp1
00194Br 3               
00194Br 3  88                           dey
00194Cr 3  D0 EC                        bne @string_loop
00194Er 3               
00194Er 3               @success_tmp1:
00194Er 3  68                           pla             ; Restore tmp1 from the return stack.
00194Fr 3  85 25                        sta tmp1+1
001951r 3  68                           pla
001952r 3  85 24                        sta tmp1
001954r 3               
001954r 3               @success:
001954r 3                               ; The strings match. Put correct nt NOS, because we'll drop
001954r 3                               ; TOS before we leave
001954r 3  A5 24                        lda tmp1
001956r 3  95 02                        sta 2,x
001958r 3  A5 25                        lda tmp1+1
00195Ar 3  95 03                        sta 3,x
00195Cr 3               
00195Cr 3  80 20                        bra @done
00195Er 3               
00195Er 3               @next_entry_tmp1:
00195Er 3  68                           pla             ; Restore tmp1 from the return stack.
00195Fr 3  85 25                        sta tmp1+1
001961r 3  68                           pla
001962r 3  85 24                        sta tmp1
001964r 3               
001964r 3               @next_entry:
001964r 3                               ; Not the same, so we get the next word. Next header
001964r 3                               ; address is two bytes down
001964r 3  A0 02                        ldy #2
001966r 3  B1 24                        lda (tmp1),y
001968r 3  48                           pha
001969r 3  C8                           iny
00196Ar 3  B1 24                        lda (tmp1),y
00196Cr 3  85 25                        sta tmp1+1
00196Er 3  68                           pla
00196Fr 3  85 24                        sta tmp1
001971r 3               
001971r 3                               ; If we got a zero, we've walked the whole Dictionary and
001971r 3                               ; return as a failure, otherwise try again
001971r 3  05 25                        ora tmp1+1
001973r 3  D0 95                        bne @loop
001975r 3               
001975r 3                               ; Move on to the next wordlist in the search order.
001975r 3  E6 28                        inc tmp3
001977r 3  4C rr rr                     jmp @wordlist_loop
00197Ar 3               
00197Ar 3               @fail_done:
00197Ar 3  74 02                        stz 2,x         ; failure flag
00197Cr 3  74 03                        stz 3,x
00197Er 3               @done:
00197Er 3  E8                           inx
00197Fr 3  E8                           inx
001980r 3               
001980r 3  60           z_find_name:    rts
001981r 3               
001981r 3               
001981r 3               
001981r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001981r 3               ; ## "flush"  auto  ANS block
001981r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001981r 3               xt_flush:
001981r 3  20 rr rr                     jsr xt_save_buffers
001984r 3               
001984r 3                               ; Set the buffer status to empty.
001984r 3  A0 2C                        ldy #buffstatus_offset
001986r 3  A9 00                        lda #0
001988r 3  91 1E                        sta (up),y      ; Only LSB is used.
00198Ar 3               z_flush:
00198Ar 3  60                           rts
00198Br 3               
00198Br 3               
00198Br 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
00198Br 3               ; ## "fm/mod"  auto  ANS core
00198Br 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
00198Br 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
00198Br 3                       ;
00198Br 3                       ; There are various ways to realize this. We follow EForth with
00198Br 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
00198Br 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
00198Br 3                       ; See (http://www.forth.org/eforth.html). However you can also
00198Br 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
00198Br 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
00198Br 3                       ; """
00198Br 3               
00198Br 3               xt_fm_slash_mod:
00198Br 3  20 rr rr                     jsr underflow_3
00198Er 3               
00198Er 3                               ; if sign of n1 is negative, negate both n1 and d
00198Er 3  64 26                        stz tmp2        ; default: n is positive
001990r 3  B5 01                        lda 1,x         ; MSB of n1
001992r 3  10 0E                        bpl @check_d
001994r 3               
001994r 3  E6 26                        inc tmp2        ; set flag to negative for n1
001996r 3  20 rr rr                     jsr xt_negate   ; NEGATE
001999r 3  20 rr rr                     jsr xt_to_r     ; >R
00199Cr 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
00199Fr 3  20 rr rr                     jsr xt_r_from   ; R>
0019A2r 3               
0019A2r 3               @check_d:
0019A2r 3                               ; If d is negative, add n1 to high cell of d
0019A2r 3  B5 03                        lda 3,x         ; MSB of high word of d
0019A4r 3  10 0D                        bpl @multiply
0019A6r 3               
0019A6r 3  18                           clc
0019A7r 3  B5 00                        lda 0,x         ; LSB of n1
0019A9r 3  75 02                        adc 2,x         ; LSB of dh
0019ABr 3  95 02                        sta 2,x
0019ADr 3               
0019ADr 3  B5 01                        lda 1,x         ; MSB of n1
0019AFr 3  75 03                        adc 3,x         ; MSB of dh
0019B1r 3  95 03                        sta 3,x
0019B3r 3               
0019B3r 3               @multiply:
0019B3r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
0019B6r 3               
0019B6r 3                               ; if n was negative, negate the result
0019B6r 3  A5 26                        lda tmp2
0019B8r 3  F0 07                        beq @done
0019BAr 3               
0019BAr 3  E8                           inx             ; pretend that we SWAP
0019BBr 3  E8                           inx
0019BCr 3  20 rr rr                     jsr xt_negate
0019BFr 3  CA                           dex
0019C0r 3  CA                           dex
0019C1r 3               @done:
0019C1r 3  60           z_fm_slash_mod: rts
0019C2r 3               
0019C2r 3               
0019C2r 3               
0019C2r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
0019C2r 3               ; ## "forth"  auto  ANS search ext
0019C2r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
0019C2r 3               xt_forth:
0019C2r 3  A0 1F                        ldy #search_order_offset
0019C4r 3  A9 00                        lda #0          ; The WID for Forth is 0.
0019C6r 3               
0019C6r 3  91 1E                        sta (up),y
0019C8r 3               z_forth:
0019C8r 3  60                           rts
0019C9r 3               
0019C9r 3               
0019C9r 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
0019C9r 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
0019C9r 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
0019C9r 3               load_evaluate:
0019C9r 3                               ; Set a flag (using tmp1) to not zero BLK
0019C9r 3  A9 FF                        lda #$FF
0019CBr 3  85 24                        sta tmp1
0019CDr 3  80 11                        bra load_evaluate_start
0019CFr 3               
0019CFr 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
0019CFr 3               ; ## "evaluate"  auto  ANS core
0019CFr 3                       ; """https://forth-standard.org/standard/core/EVALUATE
0019CFr 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
0019CFr 3                       ; After processing the line, revert to old input source. We use this
0019CFr 3                       ; to compile high-level Forth words and user-defined words during
0019CFr 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
0019CFr 3                       ; accept more than 255 characters here, even though it's a pain in
0019CFr 3                       ; the 8-bit.
0019CFr 3                       ; """
0019CFr 3               
0019CFr 3               xt_evaluate:
0019CFr 3  20 rr rr                     jsr underflow_2
0019D2r 3               
0019D2r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
0019D2r 3                               ; and will set the block number.
0019D2r 3  64 24                        stz tmp1
0019D4r 3               
0019D4r 3                               ; If u is zero (which can happen a lot for the user-defined
0019D4r 3                               ; words), just leave again
0019D4r 3  B5 00                        lda 0,x
0019D6r 3  15 01                        ora 1,x
0019D8r 3  D0 06                        bne _eval_got_work
0019DAr 3               
0019DAr 3  E8                           inx
0019DBr 3  E8                           inx
0019DCr 3  E8                           inx
0019DDr 3  E8                           inx
0019DEr 3               
0019DEr 3  80 42                        bra _eval_done
0019E0r 3               
0019E0r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
0019E0r 3               load_evaluate_start:
0019E0r 3               _eval_got_work:
0019E0r 3                               ; Save the current value of BLK on the return stack.
0019E0r 3  A0 01                        ldy #blk_offset+1
0019E2r 3  B1 1E                        lda (up),y
0019E4r 3  48                           pha
0019E5r 3  88                           dey
0019E6r 3  B1 1E                        lda (up),y
0019E8r 3  48                           pha
0019E9r 3               
0019E9r 3                               ; See if we should zero BLK.
0019E9r 3  A5 24                        lda tmp1
0019EBr 3  D0 05                        bne @nozero
0019EDr 3               
0019EDr 3                               ; Set BLK to zero.
0019EDr 3                               ; lda #0        ; A is already zero from loading tmp1
0019EDr 3  91 1E                        sta (up),y
0019EFr 3  C8                           iny
0019F0r 3  91 1E                        sta (up),y
0019F2r 3               
0019F2r 3               @nozero:
0019F2r 3                               ; Save the input state to the Return Stack
0019F2r 3  20 rr rr                     jsr xt_input_to_r
0019F5r 3               
0019F5r 3                               ; set SOURCE-ID to -1
0019F5r 3  A9 FF                        lda #$ff
0019F7r 3  85 06                        sta insrc
0019F9r 3  85 07                        sta insrc+1
0019FBr 3               
0019FBr 3                               ; set >IN to zero
0019FBr 3  64 0C                        stz toin
0019FDr 3  64 0D                        stz toin+1
0019FFr 3               
0019FFr 3                               ; move TOS and NOS to input buffers
0019FFr 3  B5 00                        lda 0,x
001A01r 3  85 0A                        sta ciblen
001A03r 3  B5 01                        lda 1,x
001A05r 3  85 0B                        sta ciblen+1
001A07r 3               
001A07r 3  B5 02                        lda 2,x
001A09r 3  85 08                        sta cib
001A0Br 3  B5 03                        lda 3,x
001A0Dr 3  85 09                        sta cib+1
001A0Fr 3               
001A0Fr 3  E8                           inx             ; A clean stack is a clean mind
001A10r 3  E8                           inx
001A11r 3  E8                           inx
001A12r 3  E8                           inx
001A13r 3               
001A13r 3  20 rr rr                     jsr interpret   ; ( -- )
001A16r 3               
001A16r 3                               ; restore variables
001A16r 3  20 rr rr                     jsr xt_r_to_input
001A19r 3               
001A19r 3                               ; Restore BLK from the return stack.
001A19r 3  A0 00                        ldy #blk_offset
001A1Br 3  68                           pla
001A1Cr 3  91 1E                        sta (up),y
001A1Er 3  C8                           iny
001A1Fr 3  68                           pla
001A20r 3  91 1E                        sta (up),y
001A22r 3               
001A22r 3               _eval_done:
001A22r 3  60           z_evaluate:     rts
001A23r 3               
001A23r 3               
001A23r 3               
001A23r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001A23r 3               ; ## "forth-wordlist"  auto  ANS search
001A23r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001A23r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001A23r 3               
001A23r 3               
001A23r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001A23r 3               ; ## "get-current" auto ANS search
001A23r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001A23r 3               
001A23r 3               xt_get_current:
001A23r 3                               ; This is a little different than some of the variables
001A23r 3                               ; in the user area as we want the value rather than
001A23r 3                               ; the address.
001A23r 3  CA                           dex
001A24r 3  CA                           dex
001A25r 3  A0 04                        ldy #current_offset
001A27r 3  B1 1E                        lda (up),y
001A29r 3  95 00                        sta 0,x         ; CURRENT is a byte variable
001A2Br 3  74 01                        stz 1,x         ; so the MSB is zero.
001A2Dr 3               
001A2Dr 3  60           z_get_current:  rts
001A2Er 3               
001A2Er 3               
001A2Er 3               
001A2Er 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001A2Er 3               ; ## "get-order" auto ANS search
001A2Er 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001A2Er 3               
001A2Er 3               xt_get_order:
001A2Er 3                               ; Get #ORDER - the number of wordlists in the search order.
001A2Er 3  A0 1E                        ldy #num_order_offset
001A30r 3  B1 1E                        lda (up),y
001A32r 3  85 24                        sta tmp1
001A34r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
001A36r 3               
001A36r 3               @loop:
001A36r 3                               ; Count down towards the front of the list.
001A36r 3                               ; By decrementing first, we also turn the length into an offset.
001A36r 3  C6 24                        dec tmp1        ; Count down by bytes.
001A38r 3               
001A38r 3                               ; Get a pointer to the current wordlist, working back to front.
001A38r 3  A9 1F                        lda #search_order_offset
001A3Ar 3  18                           clc
001A3Br 3  65 24                        adc tmp1
001A3Dr 3  A8                           tay
001A3Er 3               
001A3Er 3                               ; Put that wordlist id on the stack.
001A3Er 3  CA                           dex
001A3Fr 3  CA                           dex
001A40r 3  B1 1E                        lda (up),y
001A42r 3  95 00                        sta 0,x         ; Search order array is bytes, so
001A44r 3  74 01                        stz 1,x         ; put a zero in the high byte.
001A46r 3               
001A46r 3                               ; See if that was the last one to process (first in the list).
001A46r 3  A9 00                        lda #0
001A48r 3  C5 24                        cmp tmp1
001A4Ar 3  D0 EA                        bne @loop
001A4Cr 3               
001A4Cr 3               @done:
001A4Cr 3                               ; Put the number of items on the stack.
001A4Cr 3  CA                           dex
001A4Dr 3  CA                           dex
001A4Er 3  A0 1E                        ldy #num_order_offset
001A50r 3  B1 1E                        lda (up),y
001A52r 3  95 00                        sta 0,x
001A54r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
001A56r 3               
001A56r 3  60           z_get_order:    rts
001A57r 3               
001A57r 3               
001A57r 3               
001A57r 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
001A57r 3               ; ## ">"  auto  ANS core
001A57r 3                       ; """https://forth-standard.org/standard/core/more"""
001A57r 3               
001A57r 3               xt_greater_than:
001A57r 3  20 rr rr                     jsr underflow_2
001A5Ar 3               
001A5Ar 3  A0 00                        ldy #0          ; default false
001A5Cr 3  20 rr rr                     jsr compare_16bit
001A5Fr 3               
001A5Fr 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001A5Fr 3  F0 03                        beq @false
001A61r 3  10 01                        bpl @false
001A63r 3               
001A63r 3                               ; true
001A63r 3  88                           dey
001A64r 3               @false:
001A64r 3  98                           tya
001A65r 3               
001A65r 3  E8                           inx
001A66r 3  E8                           inx
001A67r 3  95 00                        sta 0,x
001A69r 3  95 01                        sta 1,x
001A6Br 3               
001A6Br 3  60           z_greater_than: rts
001A6Cr 3               
001A6Cr 3               
001A6Cr 3               
001A6Cr 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
001A6Cr 3               ; ## "here"  auto  ANS core
001A6Cr 3                       ; """https://forth-standard.org/standard/core/HERE
001A6Cr 3                       ; This code is also used by the assembler directive ARROW
001A6Cr 3                       ; ("->") though as immediate"""
001A6Cr 3               xt_here:
001A6Cr 3               xt_asm_arrow:
001A6Cr 3  CA                           dex
001A6Dr 3  CA                           dex
001A6Er 3  A5 00                        lda cp
001A70r 3  95 00                        sta 0,x
001A72r 3  A5 01                        lda cp+1
001A74r 3  95 01                        sta 1,x
001A76r 3               
001A76r 3               z_asm_arrow:
001A76r 3  60           z_here:         rts
001A77r 3               
001A77r 3               
001A77r 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
001A77r 3               ; ## "hex"  auto  ANS core ext
001A77r 3                       ; """https://forth-standard.org/standard/core/HEX"""
001A77r 3               xt_hex:
001A77r 3  A9 10                        lda #16
001A79r 3  85 18                        sta base
001A7Br 3  64 19                        stz base+1              ; paranoid
001A7Dr 3               
001A7Dr 3  60           z_hex:          rts
001A7Er 3               
001A7Er 3               
001A7Er 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001A7Er 3               ; ## "hexstore"  auto  Tali
001A7Er 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001A7Er 3                       ; by spaces, store the numbers at the address addr2, returning the
001A7Er 3                       ; number of elements. Non-number elements are skipped, an zero-length
001A7Er 3                       ; string produces a zero output.
001A7Er 3                       ; """
001A7Er 3               
001A7Er 3               xt_hexstore:
001A7Er 3  20 rr rr                     jsr underflow_3
001A81r 3               
001A81r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
001A84r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
001A87r 3               
001A87r 3               @loop:
001A87r 3                               ; Loop until string is totally consumed
001A87r 3  B5 00                        lda 0,x
001A89r 3  15 01                        ora 1,x
001A8Br 3  F0 36                        beq @done
001A8Dr 3               
001A8Dr 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001A90r 3               
001A90r 3                               ; Prepare the conversion of the number.
001A90r 3  20 rr rr                     jsr xt_two_to_r
001A93r 3  20 rr rr                     jsr xt_zero
001A96r 3  20 rr rr                     jsr xt_zero
001A99r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001A9Cr 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001A9Fr 3               
001A9Fr 3                               ; If u4 is not zero, we have leftover chars and have to do
001A9Fr 3                               ; things differently
001A9Fr 3  B5 00                        lda 0,x
001AA1r 3  15 01                        ora 1,x
001AA3r 3  D0 17                        bne @have_chars_left
001AA5r 3               
001AA5r 3                               ; Normal case, this number is all done
001AA5r 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001AA8r 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001AABr 3               
001AABr 3                               ; Store the new value
001AABr 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
001AAEr 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
001AB1r 3               
001AB1r 3                               ; Increase counter
001AB1r 3  20 rr rr                     jsr xt_r_from           ; R>
001AB4r 3  20 rr rr                     jsr xt_one_plus         ; 1+
001AB7r 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001ABAr 3  80 CB                        bra @loop
001ABCr 3               
001ABCr 3               @have_chars_left:
001ABCr 3                               ; Pathological case: Drop the rest of this number off the stack
001ABCr 3                               ; and continue with the next word. Doesn't print a warning. We
001ABCr 3                               ; need to drop four cells, that is, eight bytes
001ABCr 3  8A                           txa
001ABDr 3  18                           clc
001ABEr 3  69 08                        adc #8
001AC0r 3  AA                           tax
001AC1r 3  80 C4                        bra @loop
001AC3r 3               
001AC3r 3               @done:
001AC3r 3                               ; Clean up return stack and calculate number of chars stored
001AC3r 3  E8                           inx
001AC4r 3  E8                           inx
001AC5r 3  E8                           inx
001AC6r 3  E8                           inx                     ; 2DROP
001AC7r 3               
001AC7r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001ACAr 3  20 rr rr                     jsr xt_swap
001ACDr 3  20 rr rr                     jsr xt_minus            ; ( n )
001AD0r 3               
001AD0r 3  60           z_hexstore:     rts
001AD1r 3               
001AD1r 3               
001AD1r 3               
001AD1r 3               ; ## HOLD ( char -- ) "Insert character at current output"
001AD1r 3               ; ## "hold"  auto  ANS core
001AD1r 3                       ; """https://forth-standard.org/standard/core/HOLD
001AD1r 3                       ; Insert a character at the current position of a pictured numeric
001AD1r 3                       ; output string on
001AD1r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001AD1r 3                       ;
001AD1r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
001AD1r 3                       ; variable tohold instead of HLD.
001AD1r 3                       ; """
001AD1r 3               xt_hold:
001AD1r 3  20 rr rr                     jsr underflow_1
001AD4r 3               
001AD4r 3  A5 34                        lda tohold
001AD6r 3  D0 02                        bne @1
001AD8r 3  C6 35                        dec tohold+1
001ADAr 3               @1:
001ADAr 3  C6 34                        dec tohold
001ADCr 3               
001ADCr 3  B5 00                        lda 0,x
001ADEr 3  92 34                        sta (tohold)
001AE0r 3  E8                           inx
001AE1r 3  E8                           inx
001AE2r 3               
001AE2r 3  60           z_hold:         rts
001AE3r 3               
001AE3r 3               
001AE3r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
001AE3r 3               ; ## "i"  auto  ANS core
001AE3r 3                       ; """https://forth-standard.org/standard/core/I
001AE3r 3                       ; Note that this is not the same as R@ because we use a fudge
001AE3r 3                       ; factor for loop control; see the Control Flow section of the
001AE3r 3                       ; manual for details.
001AE3r 3                       ;
001AE3r 3                       ; We should make this native compile for speed.
001AE3r 3                       ; """
001AE3r 3               
001AE3r 3               xt_i:
001AE3r 3  CA                           dex
001AE4r 3  CA                           dex
001AE5r 3               
001AE5r 3                               ; Get the fudged index off of the top of the stack. It's
001AE5r 3                               ; easier to do math on the stack directly than to pop and
001AE5r 3                               ; push stuff around
001AE5r 3  86 2A                        stx tmpdsp
001AE7r 3  BA                           tsx
001AE8r 3               
001AE8r 3  38                           sec
001AE9r 3  BD 01 01                     lda $0101,x     ; LSB
001AECr 3  FD 03 01                     sbc $0103,x
001AEFr 3  A8                           tay
001AF0r 3               
001AF0r 3  BD 02 01                     lda $0102,x     ; MSB
001AF3r 3  FD 04 01                     sbc $0104,x
001AF6r 3               
001AF6r 3  A6 2A                        ldx tmpdsp
001AF8r 3               
001AF8r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001AFAr 3  94 00                        sty 0,x         ; LSB of de-fudged index
001AFCr 3               
001AFCr 3  60           z_i:            rts
001AFDr 3               
001AFDr 3               
001AFDr 3               
001AFDr 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001AFDr 3               ; ## "if"  auto  ANS core
001AFDr 3                       ; """http://forth-standard.org/standard/core/IF"""
001AFDr 3               
001AFDr 3               xt_if:
001AFDr 3                               ; Compile a 0BRANCH
001AFDr 3  A0 rr                        ldy #>zero_branch_runtime
001AFFr 3  A9 rr                        lda #<zero_branch_runtime
001B01r 3  20 rr rr                     jsr cmpl_subroutine
001B04r 3               
001B04r 3                               ; Put the origination address on the stack for else/then
001B04r 3  20 rr rr                     jsr xt_here
001B07r 3               
001B07r 3                               ; Stuff zero in for the branch address right now.
001B07r 3                               ; THEN or ELSE will fix it later.
001B07r 3  20 rr rr                     jsr xt_zero
001B0Ar 3  20 rr rr                     jsr xt_comma
001B0Dr 3  60           z_if:           rts
001B0Er 3               
001B0Er 3               
001B0Er 3               zero_branch_runtime:
001B0Er 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001B0Er 3                       ; included 0BRANCH as a high-level word that inserted this code at
001B0Er 3                       ; runtime.
001B0Er 3                       ; """
001B0Er 3               
001B0Er 3                               ; We use the return value on the 65c02 stack to determine
001B0Er 3                               ; where we want to return to.
001B0Er 3  68                           pla
001B0Fr 3  85 22                        sta tmpbranch
001B11r 3  68                           pla
001B12r 3  85 23                        sta tmpbranch+1
001B14r 3               
001B14r 3                               ; See if the flag is zero, which is the whole purpose of
001B14r 3                               ; this all
001B14r 3  B5 00                        lda 0,x
001B16r 3  15 01                        ora 1,x
001B18r 3  F0 0F                        beq @zero
001B1Ar 3               
001B1Ar 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001B1Ar 3                               ; the part between IF and THEN
001B1Ar 3  A5 22                        lda tmpbranch   ; LSB
001B1Cr 3  18                           clc
001B1Dr 3  69 02                        adc #2
001B1Fr 3  85 24                        sta tmp1
001B21r 3  A5 23                        lda tmpbranch+1 ; MSB
001B23r 3  69 00                        adc #0          ; For carry
001B25r 3  85 25                        sta tmp1+1
001B27r 3               
001B27r 3  80 13                        bra @done
001B29r 3               
001B29r 3               @zero:
001B29r 3                               ; Flag is FALSE (0) so we take the jump to the address given in
001B29r 3                               ; the next two bytes. However, the address points to the last
001B29r 3                               ; byte of the JSR instruction, not to the next byte afterwards
001B29r 3  A0 01                        ldy #1
001B2Br 3  B1 22                        lda (tmpbranch),y
001B2Dr 3  85 24                        sta tmp1
001B2Fr 3  C8                           iny
001B30r 3  B1 22                        lda (tmpbranch),y
001B32r 3  85 25                        sta tmp1+1
001B34r 3               
001B34r 3                               ; Now we have to subtract one byte from the address
001B34r 3                               ; given because of the way the 6502 calculates RTS
001B34r 3  A5 24                        lda tmp1
001B36r 3  D0 02                        bne @1
001B38r 3  C6 25                        dec tmp1+1
001B3Ar 3               @1:
001B3Ar 3  C6 24                        dec tmp1
001B3Cr 3               
001B3Cr 3               @done:
001B3Cr 3                               ; However we got here, tmp1 has the value we push to jump
001B3Cr 3                               ; to
001B3Cr 3  A5 25                        lda tmp1+1
001B3Er 3  48                           pha             ; MSB first
001B3Fr 3  A5 24                        lda tmp1
001B41r 3  48                           pha
001B42r 3               
001B42r 3                               ; clean up the stack and jump
001B42r 3  E8                           inx
001B43r 3  E8                           inx
001B44r 3               
001B44r 3  60                           rts
001B45r 3               
001B45r 3               
001B45r 3               
001B45r 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
001B45r 3               ; ## "immediate"  auto  ANS core
001B45r 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
001B45r 3                       ; Make sure the most recently defined word is immediate. Will only
001B45r 3                       ; affect the last word in the dictionary. Note that if the word is
001B45r 3                       ; defined in ROM, this will have no affect, but will not produce an
001B45r 3                       ; error message.
001B45r 3                       ; """
001B45r 3               xt_immediate:
001B45r 3  20 rr rr                     jsr current_to_dp
001B48r 3  A0 01                        ldy #1          ; offset for status byte
001B4Ar 3  B1 02                        lda (dp),y
001B4Cr 3  09 04                        ora #IM        ; make sure bit 7 is set
001B4Er 3  91 02                        sta (dp),y
001B50r 3               
001B50r 3  60           z_immediate:    rts
001B51r 3               
001B51r 3               
001B51r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001B51r 3               ; ## "input" tested Tali Forth
001B51r 3               
001B51r 3               xt_input:
001B51r 3  CA                           dex
001B52r 3  CA                           dex
001B53r 3  A9 12                        lda #<input
001B55r 3  95 00                        sta 0,x
001B57r 3  A9 00                        lda #>input
001B59r 3  95 01                        sta 1,x
001B5Br 3               
001B5Br 3  60           z_input:        rts
001B5Cr 3               
001B5Cr 3               
001B5Cr 3               
001B5Cr 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
001B5Cr 3               ; ## "input>r"  tested  Tali Forth
001B5Cr 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
001B5Cr 3                       ; toin to the Return Stack. Used by EVALUTE.
001B5Cr 3                       ;
001B5Cr 3                       ; The naive way of doing
001B5Cr 3                       ; this is to push each two-byte variable to the stack in the form of
001B5Cr 3                       ;
001B5Cr 3                       ;       lda insrc
001B5Cr 3                       ;       pha
001B5Cr 3                       ;       lda insrc+1
001B5Cr 3                       ;       pha
001B5Cr 3                       ;
001B5Cr 3                       ; for a total of 24 byte of instruction in one direction and later
001B5Cr 3                       ; a further 24 bytes to reverse the process. We shorten this at the
001B5Cr 3                       ; cost of some speed by assuming the four variables are grouped
001B5Cr 3                       ; together on the Zero Page and start with insrc (see definitions.asm
001B5Cr 3                       ; for details). The reverse operation is r_to_input. These words must
001B5Cr 3                       ; be flagged as Never Native. Uses tmp1
001B5Cr 3                       ; """
001B5Cr 3               
001B5Cr 3               xt_input_to_r:
001B5Cr 3                               ; We arrive here with the return address on the top of the
001B5Cr 3                               ; 65c02's stack. We need to move it out of the way first
001B5Cr 3  68                           pla
001B5Dr 3  85 24                        sta tmp1
001B5Fr 3  68                           pla
001B60r 3  85 25                        sta tmp1+1
001B62r 3               
001B62r 3                               ; This assumes that insrc is the first of eight bytes and
001B62r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001B62r 3                               ; Page.
001B62r 3  A0 07                        ldy #7
001B64r 3               @loop:
001B64r 3  B9 06 00                     lda insrc,y     ; insrc+7 is toin+1
001B67r 3  48                           pha
001B68r 3  88                           dey
001B69r 3  10 F9                        bpl @loop
001B6Br 3               
001B6Br 3                               ; Restore address for return jump
001B6Br 3  A5 25                        lda tmp1+1
001B6Dr 3  48                           pha
001B6Er 3  A5 24                        lda tmp1
001B70r 3  48                           pha
001B71r 3               
001B71r 3  60           z_input_to_r: 	rts
001B72r 3               
001B72r 3               
001B72r 3               
001B72r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001B72r 3               ; ## "int>name"  auto  Tali Forth
001B72r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001B72r 3                       ; This is called >NAME in Gforth, but we change it to
001B72r 3                       ; INT>NAME to match NAME>INT
001B72r 3                       ; """
001B72r 3               
001B72r 3               xt_int_to_name:
001B72r 3  20 rr rr                     jsr underflow_1
001B75r 3               
001B75r 3                               ; Unfortunately, to find the header, we have to walk through
001B75r 3                               ; all of the wordlists. We are running out of tmp variables.
001B75r 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
001B75r 3                               ; hold the current wordlist on the data stack. This searches
001B75r 3                               ; all of the wordlists in id order.
001B75r 3  CA                           dex
001B76r 3  CA                           dex
001B77r 3  74 00                        stz 0,x
001B79r 3  74 01                        stz 1,x
001B7Br 3               
001B7Br 3               @wordlist_loop:
001B7Br 3                               ; A needs to have the current wordlist id in it at
001B7Br 3                               ; the top of this loop.
001B7Br 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001B7Dr 3               
001B7Dr 3                               ; Get the DP for that wordlist.
001B7Dr 3  0A                           asl                     ; Turn offset into cells offset.
001B7Er 3  18                           clc
001B7Fr 3  69 06                        adc #wordlists_offset
001B81r 3  A8                           tay
001B82r 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
001B84r 3  85 26                        sta tmp2                ; into tmp2
001B86r 3  C8                           iny
001B87r 3  B1 1E                        lda (up),y
001B89r 3  85 27                        sta tmp2+1
001B8Br 3               
001B8Br 3                               ; Check for an empty wordlist (DP will be 0)
001B8Br 3  A5 26                        lda tmp2
001B8Dr 3  05 27                        ora tmp2+1
001B8Fr 3  F0 38                        beq @next_wordlist
001B91r 3               
001B91r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001B93r 3  85 28                        sta tmp3        ; Save target xt in tmp3
001B95r 3  B5 03                        lda 3,x
001B97r 3  85 29                        sta tmp3+1
001B99r 3               
001B99r 3               @loop:
001B99r 3  A0 04                        ldy #4          ; xt is four bytes down
001B9Br 3  B1 26                        lda (tmp2),y    ; LSB of xt of current nt
001B9Dr 3  C5 28                        cmp tmp3
001B9Fr 3  D0 07                        bne @no_match
001BA1r 3               
001BA1r 3                               ; LSB is the same, now check MSB
001BA1r 3  C8                           iny
001BA2r 3  B1 26                        lda (tmp2),y    ; MSB of xt of current nt
001BA4r 3  C5 29                        cmp tmp3+1
001BA6r 3  F0 32                        beq @match
001BA8r 3               
001BA8r 3               @no_match:
001BA8r 3                               ; no match, so we need to get the next word. Next nt is two
001BA8r 3                               ; bytes down
001BA8r 3  18                           clc
001BA9r 3  A5 26                        lda tmp2
001BABr 3  69 02                        adc #2
001BADr 3  85 26                        sta tmp2
001BAFr 3  A5 27                        lda tmp2+1
001BB1r 3  69 00                        adc #0          ; only care about carry
001BB3r 3  85 27                        sta tmp2+1
001BB5r 3               
001BB5r 3  A0 00                        ldy #0
001BB7r 3  B1 26                        lda (tmp2),y
001BB9r 3  48                           pha
001BBAr 3  C8                           iny
001BBBr 3  11 26                        ora (tmp2),y
001BBDr 3  F0 09                        beq @zero
001BBFr 3               
001BBFr 3                               ; Not zero continue
001BBFr 3  B1 26                        lda (tmp2),y
001BC1r 3  85 27                        sta tmp2+1
001BC3r 3  68                           pla
001BC4r 3  85 26                        sta tmp2
001BC6r 3  80 D1                        bra @loop
001BC8r 3               
001BC8r 3               @zero:
001BC8r 3                               ; if next word is zero, the xt has no nt in this wordlist
001BC8r 3  68                           pla             ; Leftover from above loop
001BC9r 3               
001BC9r 3               @next_wordlist:
001BC9r 3                               ; Move on to the next wordlist.
001BC9r 3  B5 00                        lda 0,x
001BCBr 3  1A                           inc
001BCCr 3  95 00                        sta 0,x
001BCEr 3  C9 0C                        cmp #max_wordlists
001BD0r 3  D0 A9                        bne @wordlist_loop
001BD2r 3               
001BD2r 3                               ; We didn't find it in any of the wordlists.
001BD2r 3                               ; Remove the wordlist id from the stack.
001BD2r 3  E8                           inx
001BD3r 3  E8                           inx
001BD4r 3               
001BD4r 3                               ; We return a zero to indicate that we didn't find it.
001BD4r 3  74 00                        stz 0,x
001BD6r 3  74 01                        stz 1,x
001BD8r 3  80 0A                        bra z_int_to_name
001BDAr 3               
001BDAr 3               @match:
001BDAr 3                               ; We found it. Remove wordlist id from stack.
001BDAr 3  E8                           inx
001BDBr 3  E8                           inx
001BDCr 3               
001BDCr 3                               ; It's a match! Replace TOS with nt
001BDCr 3  A5 26                        lda tmp2
001BDEr 3  95 00                        sta 0,x
001BE0r 3  A5 27                        lda tmp2+1
001BE2r 3  95 01                        sta 1,x
001BE4r 3               
001BE4r 3  60           z_int_to_name:  rts
001BE5r 3               
001BE5r 3               
001BE5r 3               
001BE5r 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001BE5r 3               ; ## "invert"  auto  ANS core
001BE5r 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001BE5r 3               xt_invert:
001BE5r 3  20 rr rr                     jsr underflow_1
001BE8r 3               
001BE8r 3  A9 FF                        lda #$FF
001BEAr 3  55 00                        eor 0,x         ; LSB
001BECr 3  95 00                        sta 0,x
001BEEr 3               
001BEEr 3  A9 FF                        lda #$FF
001BF0r 3  55 01                        eor 1,x         ; MSB
001BF2r 3  95 01                        sta 1,x
001BF4r 3               
001BF4r 3  60           z_invert:       rts
001BF5r 3               
001BF5r 3               
001BF5r 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001BF5r 3               ; ## "is"  auto  ANS core ext
001BF5r 3                       ; """http://forth-standard.org/standard/core/IS"""
001BF5r 3               
001BF5r 3               xt_is:
001BF5r 3                               ; This is a state aware word with differet behavior
001BF5r 3                               ; when used while compiling vs interpreting.
001BF5r 3                               ; Check STATE
001BF5r 3  A5 16                        lda state
001BF7r 3  05 17                        ora state+1
001BF9r 3  F0 0C                        beq @interpreting
001BFBr 3               
001BFBr 3               @compiling:
001BFBr 3                               ; Run ['] to compile the xt of the next word as a literal.
001BFBr 3  20 rr rr                     jsr xt_bracket_tick
001BFEr 3               
001BFEr 3                               ; Postpone DEFER! by compiling a JSR to it.
001BFEr 3  A0 rr                        ldy #>xt_defer_store
001C00r 3  A9 rr                        lda #<xt_defer_store
001C02r 3  20 rr rr                     jsr cmpl_subroutine
001C05r 3               
001C05r 3  80 06                        bra @done
001C07r 3               
001C07r 3               @interpreting:
001C07r 3  20 rr rr                     jsr xt_tick
001C0Ar 3  20 rr rr                     jsr xt_defer_store
001C0Dr 3               @done:
001C0Dr 3  60           z_is:           rts
001C0Er 3               
001C0Er 3               
001C0Er 3               
001C0Er 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001C0Er 3               ; ## "j"  auto  ANS core
001C0Er 3                       ; """https://forth-standard.org/standard/core/J
001C0Er 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001C0Er 3                       ; a fudge factor for loop control; see the Control Flow section of
001C0Er 3                       ; the manual for more details.
001C0Er 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001C0Er 3                       ; on the stack above this (three entries), whereas the ideal Forth
001C0Er 3                       ; implementation would just have two.
001C0Er 3                       ;
001C0Er 3                       ; Make this native compiled for speed
001C0Er 3                       ; """
001C0Er 3               
001C0Er 3               xt_j:
001C0Er 3  CA                           dex
001C0Fr 3  CA                           dex
001C10r 3               
001C10r 3                               ; Get the fudged index off from the stack. It's easier to
001C10r 3                               ; do math on the stack directly than to pop and push stuff
001C10r 3                               ; around
001C10r 3  86 2A                        stx tmpdsp
001C12r 3  BA                           tsx
001C13r 3               
001C13r 3  38                           sec
001C14r 3  BD 07 01                     lda $0107,x     ; LSB
001C17r 3  FD 09 01                     sbc $0109,x
001C1Ar 3  A8                           tay
001C1Br 3               
001C1Br 3  BD 08 01                     lda $0108,x     ; MSB
001C1Er 3  FD 0A 01                     sbc $010A,x
001C21r 3               
001C21r 3  A6 2A                        ldx tmpdsp
001C23r 3               
001C23r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001C25r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001C27r 3               
001C27r 3  60           z_j:            rts
001C28r 3               
001C28r 3               
001C28r 3               
001C28r 3               ; ## KEY ( -- char ) "Get one character from the input"
001C28r 3               ; ## "key"  tested  ANS core
001C28r 3               xt_key:
001C28r 3                       ; """https://forth-standard.org/standard/core/KEY
001C28r 3                       ; Get a single character of input from the vectored
001C28r 3                       ; input without echoing.
001C28r 3                       ; """
001C28r 3  20 rr rr                     jsr key_a               ; returns char in A
001C2Br 3               
001C2Br 3  CA                           dex
001C2Cr 3  CA                           dex
001C2Dr 3  95 00                        sta 0,x
001C2Fr 3  74 01                        stz 1,x
001C31r 3               
001C31r 3  60           z_key:          rts
001C32r 3               
001C32r 3               key_a:
001C32r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001C32r 3                       ; 65816, so we have to fake the indirect jump to vector it.
001C32r 3                       ; This is depressingly slow. We use this routine internally
001C32r 3                       ; to avoid manipulating the Data Stack when we just want a
001C32r 3                       ; character
001C32r 3  6C 12 00                     jmp (input)             ; JSR/RTS
001C35r 3               
001C35r 3               
001C35r 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
001C35r 3               ; ## "latestnt"  auto  Tali Forth
001C35r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001C35r 3                       ; The Gforth version of this word is called LATEST
001C35r 3                       ; """
001C35r 3               xt_latestnt:
001C35r 3  CA                           dex
001C36r 3  CA                           dex
001C37r 3               
001C37r 3  20 rr rr                     jsr current_to_dp
001C3Ar 3               
001C3Ar 3  A5 02                        lda dp
001C3Cr 3  95 00                        sta 0,x
001C3Er 3  A5 03                        lda dp+1
001C40r 3  95 01                        sta 1,x
001C42r 3               
001C42r 3  60           z_latestnt:     rts
001C43r 3               
001C43r 3               
001C43r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001C43r 3               ; ## "latestxt"  auto  Gforth
001C43r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001C43r 3               xt_latestxt:
001C43r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
001C46r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
001C49r 3               
001C49r 3  60           z_latestxt:     rts
001C4Ar 3               
001C4Ar 3               
001C4Ar 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
001C4Ar 3               ; ## "leave"  auto  ANS core
001C4Ar 3                       ; """https://forth-standard.org/standard/core/LEAVE
001C4Ar 3                       ; Note that this does not work with anything but a DO/LOOP in
001C4Ar 3                       ; contrast to other versions such as discussed at
001C4Ar 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
001C4Ar 3                       ;
001C4Ar 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
001C4Ar 3                       ; See the Control Flow section in the manual for details of how this works.
001C4Ar 3                       ; This must be native compile and not IMMEDIATE
001C4Ar 3                       ; """
001C4Ar 3               
001C4Ar 3               xt_leave:
001C4Ar 3                               ; We dump the limit/start entries off the Return Stack
001C4Ar 3                               ; (four bytes)
001C4Ar 3  68                           pla
001C4Br 3  68                           pla
001C4Cr 3  68                           pla
001C4Dr 3  68                           pla
001C4Er 3               
001C4Er 3  60                           rts             ; this must be compiled, so keep before z_leave
001C4Fr 3               z_leave:                        ; not reached, not compiled
001C4Fr 3               
001C4Fr 3               
001C4Fr 3               
001C4Fr 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001C4Fr 3               ; ## "["  auto  ANS core
001C4Fr 3                       ; """https://forth-standard.org/standard/core/Bracket
001C4Fr 3                       ; This is an immediate and compile-only word
001C4Fr 3                       ; """
001C4Fr 3               xt_left_bracket:
001C4Fr 3  64 16                        stz state
001C51r 3  64 17                        stz state+1
001C53r 3               
001C53r 3  60           z_left_bracket: rts
001C54r 3               
001C54r 3               
001C54r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
001C54r 3               ; ## "<#"  auto  ANS core
001C54r 3                       ; """https://forth-standard.org/standard/core/num-start
001C54r 3                       ; Start the process to create pictured numeric output.
001C54r 3                       ;
001C54r 3                       ; The new
001C54r 3                       ; string is constructed from back to front, saving the new character
001C54r 3                       ; at the beginning of the output string. Since we use PAD as a
001C54r 3                       ; starting address and work backward (!), the string is constructed
001C54r 3                       ; in the space between the end of the Dictionary (as defined by CP)
001C54r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
001C54r 3                       ; programs don't fool around with the PAD but still use its address.
001C54r 3                       ; Based on pForth
001C54r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001C54r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
001C54r 3                       ; internal variable tohold instead of HLD.
001C54r 3                       ; """
001C54r 3               xt_less_number_sign:
001C54r 3  20 rr rr                     jsr xt_pad      ; ( addr )
001C57r 3               
001C57r 3  B5 00                        lda 0,x
001C59r 3  85 34                        sta tohold
001C5Br 3  B5 01                        lda 1,x
001C5Dr 3  85 35                        sta tohold+1
001C5Fr 3               
001C5Fr 3  E8                           inx
001C60r 3  E8                           inx
001C61r 3               
001C61r 3               z_less_number_sign:
001C61r 3  60                           rts
001C62r 3               
001C62r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001C62r 3               ; ## "<"  auto  ANS core
001C62r 3                       ; """https://forth-standard.org/standard/core/less"""
001C62r 3               
001C62r 3               xt_less_than:
001C62r 3  20 rr rr                     jsr underflow_2
001C65r 3               
001C65r 3  A0 00                        ldy #0          ; default false
001C67r 3  20 rr rr                     jsr compare_16bit
001C6Ar 3               
001C6Ar 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
001C6Ar 3  F0 03                        beq @false
001C6Cr 3  30 01                        bmi @false
001C6Er 3               
001C6Er 3                               ; true
001C6Er 3  88                           dey
001C6Fr 3               @false:
001C6Fr 3  98                           tya
001C70r 3               
001C70r 3  E8                           inx
001C71r 3  E8                           inx
001C72r 3  95 00                        sta 0,x
001C74r 3  95 01                        sta 1,x
001C76r 3               
001C76r 3  60           z_less_than:    rts
001C77r 3               
001C77r 3               
001C77r 3               
001C77r 3               ; ## LIST ( scr# -- ) "List the given screen"
001C77r 3               ; ## "list"  tested  ANS block ext
001C77r 3                       ; """https://forth-standard.org/standard/block/LIST"""
001C77r 3               
001C77r 3               xt_list:
001C77r 3  20 rr rr                     jsr underflow_1
001C7Ar 3               
001C7Ar 3                               ; Save the screen number in SCR
001C7Ar 3  20 rr rr                     jsr xt_scr
001C7Dr 3  20 rr rr                     jsr xt_store
001C80r 3               
001C80r 3                               ; Use L from the editor-wordlist to display the screen.
001C80r 3  20 rr rr                     jsr xt_editor_l
001C83r 3               
001C83r 3  60           z_list:         rts
001C84r 3               
001C84r 3               
001C84r 3               
001C84r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001C84r 3               ; ## "literal"  auto  ANS core
001C84r 3                       ; """https://forth-standard.org/standard/core/LITERAL
001C84r 3                       ; Compile-only word to store TOS so that it is pushed on stack
001C84r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001C84r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001C84r 3                       ;
001C84r 3                       ; Note the cmpl_ routines use TMPTOS
001C84r 3                       ; """
001C84r 3               xt_literal:
001C84r 3  20 rr rr                     jsr underflow_1
001C87r 3               
001C87r 3  A0 rr                        ldy #>literal_runtime
001C89r 3  A9 rr                        lda #<literal_runtime
001C8Br 3  20 rr rr                     jsr cmpl_subroutine
001C8Er 3               
001C8Er 3                               ; Compile the value that is to be pushed on the Stack during
001C8Er 3                               ; runtime
001C8Er 3  20 rr rr                     jsr xt_comma
001C91r 3               
001C91r 3  60           z_literal:      rts
001C92r 3               
001C92r 3               literal_runtime:
001C92r 3               
001C92r 3                               ; During runtime, we push the value following this word back
001C92r 3                               ; on the Data Stack. The subroutine jump that brought us
001C92r 3                               ; here put the address to return to on the Return Stack -
001C92r 3                               ; this points to the data we need to get. This routine is
001C92r 3                               ; also called (LITERAL) in some Forths
001C92r 3  CA                           dex
001C93r 3  CA                           dex
001C94r 3               
001C94r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001C94r 3                               ; so we are actually popping the address-1 of the literal
001C94r 3  68                           pla             ; LSB
001C95r 3  85 24                        sta tmp1
001C97r 3  68                           pla             ; MSB
001C98r 3  85 25                        sta tmp1+1
001C9Ar 3               
001C9Ar 3                               ; Fetch the actual literal value and push it on Data stack
001C9Ar 3  A0 01                        ldy #1
001C9Cr 3  B1 24                        lda (tmp1),y    ; LSB
001C9Er 3  95 00                        sta 0,x
001CA0r 3  C8                           iny
001CA1r 3  B1 24                        lda (tmp1),y    ; MSB
001CA3r 3  95 01                        sta 1,x
001CA5r 3               
001CA5r 3                               ; Adjust return address and push back on the Return Stack
001CA5r 3  98                           tya
001CA6r 3  18                           clc
001CA7r 3  65 24                        adc tmp1
001CA9r 3  A8                           tay
001CAAr 3  A5 25                        lda tmp1+1
001CACr 3  69 00                        adc #0
001CAEr 3  48                           pha
001CAFr 3  5A                           phy
001CB0r 3               
001CB0r 3  60                           rts
001CB1r 3               
001CB1r 3               
001CB1r 3               
001CB1r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
001CB1r 3               ; ## "load"  auto  ANS block
001CB1r 3                       ; """https://forth-standard.org/standard/block/LOAD
001CB1r 3                       ;
001CB1r 3                       ; Note: LOAD current works because there is only one buffer.
001CB1r 3                       ; If/when multiple buffers are supported, we'll have to deal
001CB1r 3                       ; with the fact that it might re-load the old block into a
001CB1r 3                       ; different buffer.
001CB1r 3                       ; """
001CB1r 3               
001CB1r 3               xt_load:
001CB1r 3  20 rr rr                     jsr underflow_1
001CB4r 3               
001CB4r 3                               ; Save the current value of BLK on the return stack.
001CB4r 3  A0 01                        ldy #blk_offset+1
001CB6r 3  B1 1E                        lda (up),y
001CB8r 3  48                           pha
001CB9r 3  88                           dey
001CBAr 3  B1 1E                        lda (up),y
001CBCr 3  48                           pha
001CBDr 3               
001CBDr 3                               ; Set BLK to the given block/screen number.
001CBDr 3  B5 00                        lda 0,x
001CBFr 3  91 1E                        sta (up),y
001CC1r 3  C8                           iny
001CC2r 3  B5 01                        lda 1,x
001CC4r 3  91 1E                        sta (up),y
001CC6r 3               
001CC6r 3                               ; Load that block into a buffer
001CC6r 3  20 rr rr                     jsr xt_block
001CC9r 3               
001CC9r 3                               ; Put 1024 on the stack for the screen length.
001CC9r 3  CA                           dex
001CCAr 3  CA                           dex
001CCBr 3  A9 04                        lda #4
001CCDr 3  95 01                        sta 1,x
001CCFr 3  74 00                        stz 0,x
001CD1r 3               
001CD1r 3                               ; Jump to a special evluate target. This bypasses the underflow
001CD1r 3                               ; check and skips the zeroing of BLK.
001CD1r 3  20 rr rr                     jsr load_evaluate
001CD4r 3               
001CD4r 3                               ; Restore the value of BLK from before the LOAD command.
001CD4r 3  A0 00                        ldy #blk_offset
001CD6r 3  68                           pla
001CD7r 3  91 1E                        sta (up),y
001CD9r 3  C8                           iny
001CDAr 3  68                           pla
001CDBr 3  91 1E                        sta (up),y
001CDDr 3               
001CDDr 3                               ; If BLK is not zero, read it back into the buffer.
001CDDr 3                               ; A still has MSB
001CDDr 3  88                           dey
001CDEr 3  11 1E                        ora (up),y
001CE0r 3  F0 12                        beq @done
001CE2r 3               
001CE2r 3                               ; The block needs to be read back into the buffer.
001CE2r 3  CA                           dex
001CE3r 3  CA                           dex
001CE4r 3  A0 00                        ldy #blk_offset
001CE6r 3  B1 1E                        lda (up),y
001CE8r 3  95 00                        sta 0,x
001CEAr 3  C8                           iny
001CEBr 3  B1 1E                        lda (up),y
001CEDr 3  95 01                        sta 1,x
001CEFr 3  20 rr rr                     jsr xt_block
001CF2r 3               
001CF2r 3                               ; Drop the buffer address.
001CF2r 3  E8                           inx
001CF3r 3  E8                           inx
001CF4r 3               
001CF4r 3               @done:
001CF4r 3  60           z_load:         rts
001CF5r 3               
001CF5r 3               
001CF5r 3               
001CF5r 3               ; ## LOOP ( -- ) "Finish loop construct"
001CF5r 3               ; ## "loop"  auto  ANS core
001CF5r 3                       ; """https://forth-standard.org/standard/core/LOOP
001CF5r 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001CF5r 3                       ; the stack and then call +LOOP.
001CF5r 3                       ;
001CF5r 3                       ; In Forth, this is
001CF5r 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001CF5r 3                       ;       IMMEDIATE ; COMPILE-ONLY
001CF5r 3                       ; """
001CF5r 3               xt_loop:
001CF5r 3                               ; Have the finished word push 1 on the stack
001CF5r 3  A0 rr                        ldy #>xt_one
001CF7r 3  A9 rr                        lda #<xt_one
001CF9r 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
001CFCr 3               
001CFCr 3               
001CFCr 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
001CFCr 3               ; ## "+loop"  auto  ANS core
001CFCr 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
001CFCr 3                       ;
001CFCr 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
001CFCr 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
001CFCr 3                       ;       COMPILE-ONLY
001CFCr 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
001CFCr 3                       ; address for looping as TOS and the address for aborting the loop
001CFCr 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
001CFCr 3                       ; DO and the Control Flow section of the manual for details).
001CFCr 3                       ; """
001CFCr 3               
001CFCr 3               xt_plus_loop:
001CFCr 3                               ; Compile the run-time part. We do this with a short loop
001CFCr 3                               ; and not a call to COMPILE, because it has to be natively
001CFCr 3                               ; coded anyway.
001CFCr 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
001CFEr 3  5A                           phy             ; save counter to adjust CP
001CFFr 3               @1:
001CFFr 3  B9 rr rr                     lda plus_loop_runtime,y
001D02r 3  91 00                        sta (cp),y
001D04r 3  88                           dey
001D05r 3  10 F8                        bpl @1
001D07r 3               
001D07r 3                               ; Adjust CP
001D07r 3  68                           pla
001D08r 3  18                           clc
001D09r 3  65 00                        adc cp
001D0Br 3  85 00                        sta cp
001D0Dr 3  A5 01                        lda cp+1
001D0Fr 3  69 00                        adc #0          ; only need carry
001D11r 3  85 01                        sta cp+1
001D13r 3               
001D13r 3                               ; The address we need to loop back to is TOS. Store it so
001D13r 3                               ; the runtime part of +LOOP jumps back up there
001D13r 3  20 rr rr                     jsr xt_comma
001D16r 3               
001D16r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001D16r 3                               ; of six PLA, so we just do it here instead jumping around
001D16r 3                               ; all over the place
001D16r 3  A9 68                        lda #$68                ; opcode for PLA
001D18r 3  A0 06                        ldy #6
001D1Ar 3               @2:
001D1Ar 3  91 00                        sta (cp),y
001D1Cr 3  88                           dey
001D1Dr 3  10 FB                        bpl @2
001D1Fr 3               
001D1Fr 3                               ; Adjust CP
001D1Fr 3  A9 06                        lda #6
001D21r 3  18                           clc
001D22r 3  65 00                        adc cp
001D24r 3  85 00                        sta cp
001D26r 3  A5 01                        lda cp+1
001D28r 3  69 00                        adc #0                  ; only need carry
001D2Ar 3  85 01                        sta cp+1
001D2Cr 3               
001D2Cr 3                               ; Complete compile of DO/?DO by replacing the six
001D2Cr 3                               ; dummy bytes by PHA instructions. The address where
001D2Cr 3                               ; they are located is on the Data Stack
001D2Cr 3  B5 00                        lda 0,x
001D2Er 3  85 24                        sta tmp1
001D30r 3  B5 01                        lda 1,x
001D32r 3  85 25                        sta tmp1+1
001D34r 3  E8                           inx
001D35r 3  E8                           inx
001D36r 3               
001D36r 3                               ; Because of the way that CP works, we don't have to save
001D36r 3                               ; CP, but CP-1
001D36r 3  A5 00                        lda cp
001D38r 3  38                           sec
001D39r 3  E9 01                        sbc #1
001D3Br 3  85 26                        sta tmp2
001D3Dr 3  A5 01                        lda cp+1
001D3Fr 3  E9 00                        sbc #0
001D41r 3  85 27                        sta tmp2+1
001D43r 3               
001D43r 3                               ; now compile this in the DO/?DO routine
001D43r 3  A0 00                        ldy #0
001D45r 3               
001D45r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001D47r 3  91 24                        sta (tmp1),y
001D49r 3  C8                           iny
001D4Ar 3  A5 27                        lda tmp2+1      ; MSB
001D4Cr 3  91 24                        sta (tmp1),y
001D4Er 3  C8                           iny
001D4Fr 3  A9 48                        lda #$48        ; Opcode for PHA
001D51r 3  91 24                        sta (tmp1),y
001D53r 3  C8                           iny
001D54r 3               
001D54r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001D56r 3  91 24                        sta (tmp1),y
001D58r 3  C8                           iny
001D59r 3  A5 26                        lda tmp2        ; LSB
001D5Br 3  91 24                        sta (tmp1),y
001D5Dr 3  C8                           iny
001D5Er 3  A9 48                        lda #$48        ; Opcode for PHA
001D60r 3  91 24                        sta (tmp1),y
001D62r 3               z_loop:
001D62r 3  60           z_plus_loop:    rts
001D63r 3               
001D63r 3               
001D63r 3               plus_loop_runtime:
001D63r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001D63r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001D63r 3                       ; loop control so we can test with the Overflow Flag. See
001D63r 3                       ; the Control Flow section of the manual for details.
001D63r 3                       ; The step value is TOS in the loop. This
001D63r 3                       ; must always be native compiled. In some Forths, this is a separate
001D63r 3                       ; word called (+LOOP) or (LOOP)
001D63r 3                       ; """
001D63r 3               
001D63r 3  18                           clc
001D64r 3  68                           pla             ; LSB of index
001D65r 3  75 00                        adc 0,x         ; LSB of step
001D67r 3  A8                           tay             ; temporary storage of LSB
001D68r 3               
001D68r 3  B8                           clv
001D69r 3  68                           pla             ; MSB of index
001D6Ar 3  75 01                        adc 1,x         ; MSB of step
001D6Cr 3  48                           pha             ; put MSB of index back on stack
001D6Dr 3               
001D6Dr 3  98                           tya             ; put LSB of index back on stack
001D6Er 3  48                           pha
001D6Fr 3               
001D6Fr 3  E8                           inx             ; dump step from TOS
001D70r 3  E8                           inx
001D71r 3               
001D71r 3                               ; If V flag is set, we're done looping and continue
001D71r 3                               ; after the +LOOP instruction
001D71r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001D73r 3               
001D73r 3               @hack:          ; This is why this routine must be natively compiled: We
001D73r 3                               ; compile the opcode for JMP here without an address to
001D73r 3                               ; go to, which is added by the next next instruction of
001D73r 3                               ; LOOP/+LOOP during compile time
001D73r 3  4C                           .byte $4C
001D74r 3               
001D74r 3               plus_loop_runtime_end:
001D74r 3               
001D74r 3               
001D74r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001D74r 3               ; ## "lshift"  auto  ANS core
001D74r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001D74r 3               
001D74r 3               xt_lshift:
001D74r 3  20 rr rr                     jsr underflow_2
001D77r 3               
001D77r 3                               ; max shift 16 times
001D77r 3  B5 00                        lda 0,x
001D79r 3  29 0F                        and #%00001111
001D7Br 3  F0 08                        beq @done
001D7Dr 3               
001D7Dr 3  A8                           tay
001D7Er 3               
001D7Er 3               @loop:
001D7Er 3  16 02                        asl 2,x
001D80r 3  36 03                        rol 3,x
001D82r 3  88                           dey
001D83r 3  D0 F9                        bne @loop
001D85r 3               
001D85r 3               @done:
001D85r 3  E8                           inx
001D86r 3  E8                           inx
001D87r 3               
001D87r 3  60           z_lshift:       rts
001D88r 3               
001D88r 3               
001D88r 3               
001D88r 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001D88r 3               ; ## "m*"  auto  ANS core
001D88r 3                       ; """https://forth-standard.org/standard/core/MTimes
001D88r 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001D88r 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001D88r 3                       ;
001D88r 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001D88r 3                       ; with  : D+- O< IF DNEGATE THEN ;
001D88r 3                       ; """
001D88r 3               
001D88r 3               xt_m_star:
001D88r 3  20 rr rr                     jsr underflow_2
001D8Br 3               
001D8Br 3                               ; figure out the sign
001D8Br 3  B5 01                        lda 1,x         ; MSB of n1
001D8Dr 3  55 03                        eor 3,x         ; MSB of n2
001D8Fr 3               
001D8Fr 3                               ; UM* uses all kinds of temporary variables so we don't
001D8Fr 3                               ; risk a conflict but just take the cycle hit and push
001D8Fr 3                               ; this to the stack
001D8Fr 3  48                           pha
001D90r 3               
001D90r 3                               ; get the absolute value of both numbers so we can feed
001D90r 3                               ; them to UM*, which does the real work
001D90r 3  20 rr rr                     jsr xt_abs
001D93r 3  20 rr rr                     jsr xt_swap
001D96r 3  20 rr rr                     jsr xt_abs
001D99r 3               
001D99r 3  20 rr rr                     jsr xt_um_star          ; ( d )
001D9Cr 3               
001D9Cr 3                               ; handle the sign
001D9Cr 3  68                           pla
001D9Dr 3  10 03                        bpl @done
001D9Fr 3               
001D9Fr 3  20 rr rr                     jsr xt_dnegate
001DA2r 3               @done:
001DA2r 3  60           z_m_star:       rts
001DA3r 3               
001DA3r 3               
001DA3r 3               
001DA3r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001DA3r 3               ; ## "marker"  auto  ANS core ext
001DA3r 3                       ; """https://forth-standard.org/standard/core/MARKER
001DA3r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001DA3r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001DA3r 3                       ; Run the named word at a later time to restore all of the wordlists
001DA3r 3                       ; to their state when the word was created with marker.  Any words
001DA3r 3                       ; created after the marker (including the marker) will be forgotten.
001DA3r 3                       ;
001DA3r 3                       ; To do this, we want to end up with something that jumps to a
001DA3r 3                       ; run-time component with a link to the original CP and DP values:
001DA3r 3                       ;
001DA3r 3                       ;       jsr marker_runtime
001DA3r 3                       ;       <Original CP MSB>
001DA3r 3                       ;       <Original CP LSB>
001DA3r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001DA3r 3                       ;       <Original DP LSB>
001DA3r 3                       ;       < USER variables from offset 4 to 39 >
001DA3r 3                       ;
001DA3r 3                       ;       The user variables include:
001DA3r 3                       ;       CURRENT (byte variable)
001DA3r 3                       ;       <All wordlists> (currently 12) (cell array)
001DA3r 3                       ;       <#ORDER> (byte variable)
001DA3r 3                       ;       <All search order> (currently 9) (byte array)
001DA3r 3                       ;
001DA3r 3                       ; This code uses tmp1 and tmp2
001DA3r 3                       ; """
001DA3r 3               
001DA3r 3               xt_marker:
001DA3r 3                               ; Before we do anything, we need to save CP, which
001DA3r 3                               ; after all is the whole point of this operation. CREATE
001DA3r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001DA3r 3                               ; to the stack
001DA3r 3  20 rr rr                     jsr current_to_dp
001DA6r 3               
001DA6r 3  A5 02                        lda dp
001DA8r 3  48                           pha
001DA9r 3  A5 03                        lda dp+1
001DABr 3  48                           pha
001DACr 3               
001DACr 3  A5 00                        lda cp
001DAEr 3  48                           pha
001DAFr 3  A5 01                        lda cp+1
001DB1r 3  48                           pha
001DB2r 3               
001DB2r 3  20 rr rr                     jsr xt_create
001DB5r 3               
001DB5r 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001DB5r 3                               ; we have to replace by a jump to marker_runtime. We back up
001DB5r 3                               ; two bytes and then overwrite the address
001DB5r 3  A5 00                        lda cp          ; LSB
001DB7r 3  38                           sec
001DB8r 3  E9 02                        sbc #2
001DBAr 3  85 00                        sta cp
001DBCr 3               
001DBCr 3  A5 01                        lda cp+1        ; MSB
001DBEr 3  E9 00                        sbc #0          ; we only care about the borrow
001DC0r 3  85 01                        sta cp+1
001DC2r 3               
001DC2r 3                               ; Add the address of the runtime component
001DC2r 3  A0 rr                        ldy #>marker_runtime
001DC4r 3  A9 rr                        lda #<marker_runtime
001DC6r 3  20 rr rr                     jsr cmpl_word
001DC9r 3               
001DC9r 3                               ; Add original CP as payload
001DC9r 3  7A                           ply                     ; MSB
001DCAr 3  68                           pla                     ; LSB
001DCBr 3  20 rr rr                     jsr cmpl_word
001DCEr 3               
001DCEr 3                               ; Add original DP as payload
001DCEr 3  7A                           ply                     ; MSB
001DCFr 3  68                           pla                     ; LSB
001DD0r 3  20 rr rr                     jsr cmpl_word
001DD3r 3               
001DD3r 3                               ; Add the user variables for the wordlists and search order.
001DD3r 3                               ; We're compiling them in byte order.
001DD3r 3  A0 04                        ldy #4                  ; Start at CURRENT
001DD5r 3               @marker_loop:
001DD5r 3  B1 1E                        lda (up),y
001DD7r 3  20 rr rr                     jsr cmpl_a
001DDAr 3  C8                           iny
001DDBr 3  98                           tya
001DDCr 3  C9 28                        cmp #40                 ; One past the end of the search order.
001DDEr 3  D0 F5                        bne @marker_loop
001DE0r 3               
001DE0r 3  60           z_marker:       rts
001DE1r 3               
001DE1r 3               
001DE1r 3               
001DE1r 3               marker_runtime:
001DE1r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
001DE1r 3                       ; when this marker was defined. We arrive here with the return
001DE1r 3                       ; address on the Return Stack in the usual 65c02 format
001DE1r 3                       ; """
001DE1r 3               
001DE1r 3                               ; Get the address of the string address off the stack and
001DE1r 3                               ; increase by one because of the RTS mechanics
001DE1r 3  68                           pla
001DE2r 3  85 24                        sta tmp1        ; LSB of address
001DE4r 3  68                           pla
001DE5r 3  85 25                        sta tmp1+1      ; MSB of address
001DE7r 3               
001DE7r 3  E6 24                        inc tmp1
001DE9r 3  D0 02                        bne @1
001DEBr 3  E6 25                        inc tmp1+1
001DEDr 3               @1:
001DEDr 3  A0 00                        ldy #0
001DEFr 3               
001DEFr 3                               ; CP was stored first
001DEFr 3  B1 24                        lda (tmp1),y
001DF1r 3  85 00                        sta cp
001DF3r 3  C8                           iny
001DF4r 3  B1 24                        lda (tmp1),y
001DF6r 3  85 01                        sta cp+1
001DF8r 3               
001DF8r 3                               ; Next was DP
001DF8r 3  C8                           iny
001DF9r 3  B1 24                        lda (tmp1),y
001DFBr 3  85 02                        sta dp
001DFDr 3  C8                           iny
001DFEr 3  B1 24                        lda (tmp1),y
001E00r 3  85 03                        sta dp+1
001E02r 3               
001E02r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001E02r 3                               ; to start restoring the wordlists and search order.
001E02r 3  A0 04                        ldy #4
001E04r 3               
001E04r 3               @marker_restore_loop:
001E04r 3                               ; Copy from the dictionary back on top of the wordlists
001E04r 3                               ; and search order.
001E04r 3  B1 24                        lda (tmp1), y
001E06r 3  91 1E                        sta (up), y
001E08r 3  C8                           iny
001E09r 3  98                           tya
001E0Ar 3  C9 28                        cmp #40                 ; One past the end of the search order.
001E0Cr 3  D0 F6                        bne @marker_restore_loop
001E0Er 3               
001E0Er 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001E11r 3               
001E11r 3                               ; The return instruction takes us back to the original caller
001E11r 3  60                           rts
001E12r 3               
001E12r 3               
001E12r 3               
001E12r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001E12r 3               ; ## "max"  auto  ANS core
001E12r 3                       ; """https://forth-standard.org/standard/core/MAX
001E12r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001E12r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001E12r 3                       ; Flag indicates which number is larger. See also
001E12r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001E12r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001E12r 3                       ; """
001E12r 3               
001E12r 3               xt_max:
001E12r 3  20 rr rr                     jsr underflow_2
001E15r 3               
001E15r 3                               ; Compare LSB. We do this first to set the carry flag
001E15r 3  B5 00                        lda 0,x         ; LSB of TOS
001E17r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001E19r 3               
001E19r 3  B5 01                        lda 1,x         ; MSB of TOS
001E1Br 3  F5 03                        sbc 3,x         ; MSB of NOS
001E1Dr 3  50 02                        bvc @no_overflow
001E1Fr 3               
001E1Fr 3                               ; handle overflow, because we use signed numbers
001E1Fr 3  49 80                        eor #$80        ; complement negative flag
001E21r 3               
001E21r 3               @no_overflow:
001E21r 3                               ; if negative, NOS is larger and needs to be kept
001E21r 3  30 08                        bmi @keep_nos
001E23r 3               
001E23r 3                               ; move TOS to NOS
001E23r 3  B5 00                        lda 0,x
001E25r 3  95 02                        sta 2,x
001E27r 3  B5 01                        lda 1,x
001E29r 3  95 03                        sta 3,x
001E2Br 3               
001E2Br 3               @keep_nos:
001E2Br 3  E8                           inx
001E2Cr 3  E8                           inx
001E2Dr 3               
001E2Dr 3  60           z_max:          rts
001E2Er 3               
001E2Er 3               
001E2Er 3               
001E2Er 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001E2Er 3               ; ## "min"  auto  ANS core
001E2Er 3                       ; """https://forth-standard.org/standard/core/MIN
001E2Er 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001E2Er 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001E2Er 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001E2Er 3                       ; """
001E2Er 3               
001E2Er 3               xt_min:
001E2Er 3  20 rr rr                     jsr underflow_2
001E31r 3               
001E31r 3                               ; compare LSB. We do this first to set the carry flag
001E31r 3  B5 00                        lda 0,x         ; LSB of TOS
001E33r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001E35r 3               
001E35r 3  B5 01                        lda 1,x         ; MSB of TOS
001E37r 3  F5 03                        sbc 3,x         ; MSB of NOS
001E39r 3  50 02                        bvc @no_overflow
001E3Br 3               
001E3Br 3                               ; handle overflow because we use signed numbers
001E3Br 3  49 80                        eor #$80
001E3Dr 3               
001E3Dr 3               @no_overflow:
001E3Dr 3                               ; if negative, NOS is larger and needs to be dumped
001E3Dr 3  10 08                        bpl @keep_nos
001E3Fr 3               
001E3Fr 3                               ; move TOS to NOS
001E3Fr 3  B5 00                        lda 0,x
001E41r 3  95 02                        sta 2,x
001E43r 3  B5 01                        lda 1,x
001E45r 3  95 03                        sta 3,x
001E47r 3               
001E47r 3               @keep_nos:
001E47r 3  E8                           inx
001E48r 3  E8                           inx
001E49r 3               
001E49r 3  60           z_min:          rts
001E4Ar 3               
001E4Ar 3               
001E4Ar 3               
001E4Ar 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001E4Ar 3               ; ## "-"  auto  ANS core
001E4Ar 3                       ; """https://forth-standard.org/standard/core/Minus"""
001E4Ar 3               xt_minus:
001E4Ar 3  20 rr rr                     jsr underflow_2
001E4Dr 3               
001E4Dr 3  38                           sec
001E4Er 3  B5 02                        lda 2,x         ; LSB
001E50r 3  F5 00                        sbc 0,x
001E52r 3  95 02                        sta 2,x
001E54r 3               
001E54r 3  B5 03                        lda 3,x         ; MSB
001E56r 3  F5 01                        sbc 1,x
001E58r 3  95 03                        sta 3,x
001E5Ar 3               
001E5Ar 3  E8                           inx
001E5Br 3  E8                           inx
001E5Cr 3               
001E5Cr 3  60           z_minus:        rts
001E5Dr 3               
001E5Dr 3               
001E5Dr 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001E5Dr 3               ; ## "-leading"  auto  Tali String
001E5Dr 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001E5Dr 3                       ; """
001E5Dr 3               
001E5Dr 3               xt_minus_leading:
001E5Dr 3  20 rr rr                     jsr underflow_2
001E60r 3               
001E60r 3               @loop:
001E60r 3                               ; Quit if we were given an empty string. This also terminates
001E60r 3                               ; the main loop
001E60r 3  B5 00                        lda 0,x
001E62r 3  15 01                        ora 1,x
001E64r 3  F0 0F                        beq @done
001E66r 3               
001E66r 3  A1 02                        lda (2,x)               ; get first character
001E68r 3  20 rr rr                     jsr is_whitespace
001E6Br 3  90 08                        bcc @done
001E6Dr 3               
001E6Dr 3                               ; It's whitespace, move one down
001E6Dr 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001E70r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001E73r 3               
001E73r 3  80 EB                        bra @loop
001E75r 3               @done:
001E75r 3               z_minus_leading:
001E75r 3  60                           rts
001E76r 3               
001E76r 3               
001E76r 3               
001E76r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001E76r 3               ; ## "-trailing"  auto  ANS string
001E76r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001E76r 3                       ; Remove trailing spaces
001E76r 3                       ; """
001E76r 3               
001E76r 3               xt_minus_trailing:
001E76r 3  20 rr rr                     jsr underflow_2
001E79r 3               
001E79r 3                               ; if length entry is zero, return a zero and leave the
001E79r 3                               ; address part untouched
001E79r 3  B5 00                        lda 0,x         ; LSB of n
001E7Br 3  15 01                        ora 1,x         ; MSB of n
001E7Dr 3  F0 33                        beq @done
001E7Fr 3               
001E7Fr 3                               ; Compute address of last char in tmp1 as
001E7Fr 3                               ; addr + u1 - 1
001E7Fr 3               
001E7Fr 3                               ; addr + u1
001E7Fr 3  18                           clc
001E80r 3  B5 02                        lda 2,x         ; LSB of addr
001E82r 3  75 00                        adc 0,x
001E84r 3  85 24                        sta tmp1
001E86r 3  B5 03                        lda 3,x         ; MSB of addr
001E88r 3  75 01                        adc 1,x
001E8Ar 3  85 25                        sta tmp1+1
001E8Cr 3               
001E8Cr 3                               ; - 1
001E8Cr 3  A5 24                        lda tmp1
001E8Er 3  D0 02                        bne @1
001E90r 3  C6 25                        dec tmp1+1
001E92r 3               @1:
001E92r 3  C6 24                        dec tmp1
001E94r 3               
001E94r 3               @loop:
001E94r 3                               ; While spaces are found, move tmp1 backwards and
001E94r 3                               ; decrease the count on the data stack.
001E94r 3  B2 24                        lda (tmp1)
001E96r 3  C9 20                        cmp #AscSP
001E98r 3  D0 18                        bne @done
001E9Ar 3               
001E9Ar 3                               ; Move back one address.
001E9Ar 3  A5 24                        lda tmp1
001E9Cr 3  D0 02                        bne @2
001E9Er 3  C6 25                        dec tmp1+1
001EA0r 3               @2:
001EA0r 3  C6 24                        dec tmp1
001EA2r 3               
001EA2r 3                               ; Decrement count by one.
001EA2r 3  B5 00                        lda 0,x
001EA4r 3  D0 02                        bne @3
001EA6r 3  D6 01                        dec 1,x
001EA8r 3               @3:
001EA8r 3  D6 00                        dec 0,x
001EAAr 3               
001EAAr 3                               ; Check if there are any characters left.
001EAAr 3  B5 00                        lda 0,x
001EACr 3  15 01                        ora 1,x
001EAEr 3  F0 02                        beq @done       ; Count has reached zero - we're done!
001EB0r 3               
001EB0r 3  80 E2                        bra @loop
001EB2r 3               
001EB2r 3               @done:
001EB2r 3               z_minus_trailing:
001EB2r 3  60                           rts
001EB3r 3               
001EB3r 3               
001EB3r 3               
001EB3r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001EB3r 3               ; ## "mod"  auto  ANS core
001EB3r 3                       ; """https://forth-standard.org/standard/core/MOD
001EB3r 3                       ;
001EB3r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001EB3r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001EB3r 3                       ; """
001EB3r 3               xt_mod:
001EB3r 3  20 rr rr                     jsr underflow_2
001EB6r 3               
001EB6r 3  20 rr rr                     jsr xt_slash_mod
001EB9r 3               
001EB9r 3  E8                           inx             ; DROP
001EBAr 3  E8                           inx
001EBBr 3               z_mod:
001EBBr 3  60                           rts
001EBCr 3               
001EBCr 3               
001EBCr 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
001EBCr 3               ; ## "move"  auto  ANS core
001EBCr 3                       ; """https://forth-standard.org/standard/core/MOVE
001EBCr 3                       ; Copy u "address units" from addr1 to addr2. Since our address
001EBCr 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
001EBCr 3                       ; is actually the only one of these three words that is in the CORE
001EBCr 3                       ; set.
001EBCr 3                       ;
001EBCr 3                       ; This word must not be natively compiled.
001EBCr 3                       ; """
001EBCr 3               
001EBCr 3               xt_move:
001EBCr 3                               ; We let CMOVE and CMOVE> check if there is underflow or
001EBCr 3                               ; we've been told to copy zero bytes
001EBCr 3               
001EBCr 3                               ; compare MSB first
001EBCr 3  B5 03                        lda 3,x                 ; MSB of addr2
001EBEr 3  D5 05                        cmp 5,x                 ; MSB of addr1
001EC0r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001EC2r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001EC4r 3               
001EC4r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001EC7r 3               
001EC7r 3               @lsb:
001EC7r 3                               ; MSB were equal, so do the whole thing over with LSB
001EC7r 3  B5 02                        lda 2,x                 ; LSB of addr2
001EC9r 3  D5 04                        cmp 4,x                 ; LSB of addr1
001ECBr 3  F0 08                        beq @equal              ; LSB is equal as well
001ECDr 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
001ECFr 3               
001ECFr 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001ED2r 3               
001ED2r 3               @to_move_up:
001ED2r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
001ED5r 3               @equal:
001ED5r 3                               ; drop three entries from Data Stack
001ED5r 3  8A                           txa
001ED6r 3  18                           clc
001ED7r 3  69 06                        adc #6
001ED9r 3  AA                           tax
001EDAr 3               
001EDAr 3  60           z_move:         rts
001EDBr 3               
001EDBr 3               
001EDBr 3               
001EDBr 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
001EDBr 3               ; ## "name>int"  tested  Gforth
001EDBr 3                       ; """See
001EDBr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001EDBr 3                       ; """
001EDBr 3               
001EDBr 3               xt_name_to_int:
001EDBr 3  20 rr rr                     jsr underflow_1
001EDEr 3               
001EDEr 3                               ; The xt starts four bytes down from the nt
001EDEr 3  B5 00                        lda 0,x
001EE0r 3  18                           clc
001EE1r 3  69 04                        adc #4
001EE3r 3  85 28                        sta tmp3
001EE5r 3               
001EE5r 3  B5 01                        lda 1,x
001EE7r 3  90 01                        bcc @done
001EE9r 3  1A                           inc
001EEAr 3               @done:
001EEAr 3  85 29                        sta tmp3+1
001EECr 3               
001EECr 3  A0 00                        ldy #0
001EEEr 3  B1 28                        lda (tmp3),y
001EF0r 3  95 00                        sta 0,x
001EF2r 3  C8                           iny
001EF3r 3  B1 28                        lda (tmp3),y
001EF5r 3  95 01                        sta 1,x
001EF7r 3               
001EF7r 3  60           z_name_to_int:  rts
001EF8r 3               
001EF8r 3               
001EF8r 3               
001EF8r 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
001EF8r 3               ; ## "name>string"  tested  Gforth
001EF8r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
001EF8r 3               
001EF8r 3               xt_name_to_string:
001EF8r 3  20 rr rr                     jsr underflow_1
001EFBr 3               
001EFBr 3  CA                           dex
001EFCr 3  CA                           dex
001EFDr 3               
001EFDr 3                               ; the length of the string is the first byte of the
001EFDr 3                               ; header pointed to by nt
001EFDr 3  A1 02                        lda (2,x)
001EFFr 3  95 00                        sta 0,x
001F01r 3  74 01                        stz 1,x
001F03r 3               
001F03r 3                               ; the string itself always starts eight bytes down
001F03r 3  B5 02                        lda 2,x         ; LSB
001F05r 3  18                           clc
001F06r 3  69 08                        adc #8
001F08r 3  A8                           tay
001F09r 3  B5 03                        lda 3,x         ; MSB
001F0Br 3  69 00                        adc #0          ; just need carry
001F0Dr 3  95 03                        sta 3,x
001F0Fr 3  94 02                        sty 2,x
001F11r 3               
001F11r 3               z_name_to_string:
001F11r 3  60                           rts
001F12r 3               
001F12r 3               
001F12r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001F12r 3               ; ## "nc-limit"  tested  Tali Forth
001F12r 3               
001F12r 3               xt_nc_limit:
001F12r 3  CA                           dex
001F13r 3  CA                           dex
001F14r 3  A9 1A                        lda #<nc_limit
001F16r 3  95 00                        sta 0,x
001F18r 3  A9 00                        lda #>nc_limit
001F1Ar 3  95 01                        sta 1,x
001F1Cr 3               
001F1Cr 3  60           z_nc_limit:     rts
001F1Dr 3               
001F1Dr 3               
001F1Dr 3               
001F1Dr 3               ; ## NEGATE ( n -- n ) "Two's complement"
001F1Dr 3               ; ## "negate"  auto  ANS core
001F1Dr 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001F1Dr 3               xt_negate:
001F1Dr 3  20 rr rr                     jsr underflow_1
001F20r 3               
001F20r 3  A9 00                	lda #0
001F22r 3  38                           sec
001F23r 3  F5 00                        sbc 0,x         ; LSB
001F25r 3  95 00                        sta 0,x
001F27r 3               
001F27r 3  A9 00                        lda #0
001F29r 3  F5 01                        sbc 1,x         ; MSB
001F2Br 3  95 01                        sta 1,x
001F2Dr 3               
001F2Dr 3  60           z_negate:       rts
001F2Er 3               
001F2Er 3               
001F2Er 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001F2Er 3               ; ## "never-native"  auto  Tali Forth
001F2Er 3               xt_never_native:
001F2Er 3  20 rr rr                     jsr current_to_dp
001F31r 3  A0 01                        ldy #1          ; offset for status byte
001F33r 3  B1 02                        lda (dp),y
001F35r 3  09 08                        ora #NN         ; Make sure NN flag is set
001F37r 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
001F39r 3  91 02                        sta (dp),y
001F3Br 3               z_never_native:
001F3Br 3  60                           rts
001F3Cr 3               
001F3Cr 3               
001F3Cr 3               ; ## NIP ( b a -- a ) "Delete NOS"
001F3Cr 3               ; ## "nip"  auto  ANS core ext
001F3Cr 3                       ; """https://forth-standard.org/standard/core/NIP"""
001F3Cr 3               xt_nip:
001F3Cr 3  20 rr rr                     jsr underflow_2
001F3Fr 3               
001F3Fr 3  B5 00                        lda 0,x         ; LSB
001F41r 3  95 02                        sta 2,x
001F43r 3  B5 01                        lda 1,x         ; MSB
001F45r 3  95 03                        sta 3,x
001F47r 3               
001F47r 3  E8                           inx
001F48r 3  E8                           inx
001F49r 3               
001F49r 3  60           z_nip:          rts
001F4Ar 3               
001F4Ar 3               
001F4Ar 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
001F4Ar 3               ; ## "<>"  auto  ANS core ext
001F4Ar 3                       ; """https://forth-standard.org/standard/core/ne
001F4Ar 3                       ;
001F4Ar 3                       ; This is just a variant of EQUAL, we code it separately
001F4Ar 3                       ; for speed.
001F4Ar 3                       ; """
001F4Ar 3               
001F4Ar 3               xt_not_equals:
001F4Ar 3  20 rr rr                     jsr underflow_2
001F4Dr 3               
001F4Dr 3  A0 00                        ldy #0                  ; default is true
001F4Fr 3               
001F4Fr 3  B5 00                        lda 0,x                 ; LSB
001F51r 3  D5 02                        cmp 2,x
001F53r 3  D0 0A                        bne @not_equal
001F55r 3               
001F55r 3                               ; LSB is equal
001F55r 3  B5 01                        lda 1,x                 ; MSB
001F57r 3  D5 03                        cmp 3,x
001F59r 3  D0 04                        bne @not_equal
001F5Br 3               
001F5Br 3  A9 FF                        lda #$FF
001F5Dr 3  80 01                        bra @done
001F5Fr 3               
001F5Fr 3               @not_equal:
001F5Fr 3  88                           dey                     ; drop thru to done
001F60r 3               
001F60r 3               @done:
001F60r 3  98                           tya
001F61r 3  E8                           inx
001F62r 3  E8                           inx
001F63r 3  95 00                        sta 0,x
001F65r 3  95 01                        sta 1,x
001F67r 3               
001F67r 3  60           z_not_equals:   rts
001F68r 3               
001F68r 3               
001F68r 3               
001F68r 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
001F68r 3               ; ## "-rot"  auto  Gforth
001F68r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
001F68r 3               
001F68r 3               xt_not_rote:
001F68r 3  20 rr rr                     jsr underflow_3
001F6Br 3               
001F6Br 3  B4 01                        ldy 1,x         ; MSB first
001F6Dr 3  B5 03                        lda 3,x
001F6Fr 3  95 01                        sta 1,x
001F71r 3               
001F71r 3  B5 05                        lda 5,x
001F73r 3  95 03                        sta 3,x
001F75r 3  94 05                        sty 5,x
001F77r 3               
001F77r 3  B4 00                        ldy 0,x         ; LSB second
001F79r 3  B5 02                        lda 2,x
001F7Br 3  95 00                        sta 0,x
001F7Dr 3               
001F7Dr 3  B5 04                        lda 4,x
001F7Fr 3  95 02                        sta 2,x
001F81r 3  94 04                        sty 4,x
001F83r 3               
001F83r 3  60           z_not_rote:     rts
001F84r 3               
001F84r 3               
001F84r 3               
001F84r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001F84r 3               ; ## "number"  auto  Tali Forth
001F84r 3                       ; """Convert a number string to a double or single cell number. This
001F84r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001F84r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001F84r 3                       ; Based in part on the "Starting Forth" code
001F84r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001F84r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001F84r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001F84r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001F84r 3                       ; dot to signal a double cell number is required to be the last
001F84r 3                       ; character of the string.
001F84r 3                       ;
001F84r 3                       ; Number calls >NUMBER which in turn calls UM*,
001F84r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001F84r 3                       ; a pain.
001F84r 3                       ;"""
001F84r 3               
001F84r 3               xt_number:
001F84r 3  20 rr rr                     jsr underflow_2
001F87r 3               
001F87r 3                               ; we keep the flags for sign and double in tmpdsp because
001F87r 3                               ; we've run out of temporary variables
001F87r 3  64 2A                        stz tmpdsp      ; flag for double
001F89r 3  64 2B                        stz tmpdsp+1    ; flag for minus
001F8Br 3               
001F8Br 3                               ; If the first character is a minus, strip it off and set
001F8Br 3                               ; the flag
001F8Br 3  A1 02                        lda (2,x)
001F8Dr 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001F8Fr 3  D0 0A                        bne @check_dot
001F91r 3               
001F91r 3                               ; It's a minus
001F91r 3  C6 2B                        dec tmpdsp+1
001F93r 3  F6 02                        inc 2,x         ; start one character later
001F95r 3  D0 02                        bne @1
001F97r 3  F6 03                        inc 3,x
001F99r 3               @1:
001F99r 3  D6 00                        dec 0,x         ; decrease string length by one
001F9Br 3               
001F9Br 3               @check_dot:
001F9Br 3                               ; If the last character is a dot, strip it off and set a
001F9Br 3                               ; flag. We can use tmptos as a temporary variable
001F9Br 3  B5 02                        lda 2,x         ; LSB of address
001F9Dr 3  18                           clc
001F9Er 3  75 00                        adc 0,x         ; length of string
001FA0r 3  85 2C                        sta tmptos
001FA2r 3  B5 03                        lda 3,x
001FA4r 3  69 00                        adc #0          ; only need carry
001FA6r 3  85 2D                        sta tmptos+1
001FA8r 3               
001FA8r 3                               ; tmptos now points to the first character after the string,
001FA8r 3                               ; but we need the last character
001FA8r 3  A5 2C                        lda tmptos
001FAAr 3  D0 02                        bne @2
001FACr 3  C6 2D                        dec tmptos+1
001FAEr 3               @2:
001FAEr 3  C6 2C                        dec tmptos
001FB0r 3               
001FB0r 3  B2 2C                        lda (tmptos)
001FB2r 3  C9 2E                        cmp #'.'
001FB4r 3  D0 04                        bne @main
001FB6r 3               
001FB6r 3                               ; We have a dot, which means this is a double number. Flag
001FB6r 3                               ; the fact and reduce string length by one
001FB6r 3  C6 2A                        dec tmpdsp
001FB8r 3  D6 00                        dec 0,x
001FBAr 3               
001FBAr 3               @main:
001FBAr 3                               ; Set up stack for subroutine jump to >NUMBER, which means
001FBAr 3                               ; we have to go ( addr u --> ud addr u )
001FBAr 3  CA                           dex
001FBBr 3  CA                           dex
001FBCr 3  CA                           dex
001FBDr 3  CA                           dex
001FBEr 3               
001FBEr 3  B5 04                        lda 4,x         ; LSB of length
001FC0r 3  95 00                        sta 0,x
001FC2r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
001FC4r 3               
001FC4r 3  B5 06                        lda 6,x         ; LSB of address
001FC6r 3  95 02                        sta 2,x
001FC8r 3  B5 07                        lda 7,x         ; MSB of address
001FCAr 3  95 03                        sta 3,x
001FCCr 3               
001FCCr 3  74 04                        stz 4,x         ; clear space for ud
001FCEr 3  74 05                        stz 5,x
001FD0r 3  74 06                        stz 6,x
001FD2r 3  74 07                        stz 7,x
001FD4r 3               
001FD4r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
001FD7r 3               
001FD7r 3                               ; test length of returned string, which should be zero
001FD7r 3  B5 00                        lda 0,x
001FD9r 3  F0 15                        beq @all_converted
001FDBr 3               
001FDBr 3                               ; Something went wrong, we still have characters left over,
001FDBr 3                               ; so we print an error and abort. If the NUMBER was called
001FDBr 3                               ; by INTERPRET, we've already checked for Forth words, so
001FDBr 3                               ; we're in deep trouble one way or another
001FDBr 3  A9 3E                        lda #$3E        ; ASCII for ">"
001FDDr 3  20 rr rr                     jsr emit_a
001FE0r 3  20 rr rr                     jsr xt_type
001FE3r 3  A9 3C                        lda #$3C        ; ASCII for "<"
001FE5r 3  20 rr rr                     jsr emit_a
001FE8r 3  20 rr rr                     jsr xt_space
001FEBr 3               
001FEBr 3  A9 08                        lda #err_syntax
001FEDr 3  4C rr rr                     jmp error
001FF0r 3               
001FF0r 3               @all_converted:
001FF0r 3                               ; We can drop the string info
001FF0r 3  E8                           inx
001FF1r 3  E8                           inx
001FF2r 3  E8                           inx
001FF3r 3  E8                           inx
001FF4r 3               
001FF4r 3                               ; We have a double-cell number on the Data Stack that might
001FF4r 3                               ; actually have a minus and might actually be single-cell
001FF4r 3  A5 2A                        lda tmpdsp      ; flag for double
001FF6r 3  F0 0D                        beq @single
001FF8r 3               
001FF8r 3                               ; Set status bit 5 to indicate this is a double number
001FF8r 3  A9 20                        lda #%00100000
001FFAr 3  04 20                        tsb status
001FFCr 3               
001FFCr 3                               ; This is a double cell number. If it had a minus, we'll have
001FFCr 3                               ; to negate it
001FFCr 3  A5 2B                        lda tmpdsp+1
001FFEr 3  F0 12                        beq @done       ; no minus, all done
002000r 3               
002000r 3  20 rr rr                     jsr xt_dnegate
002003r 3               
002003r 3  80 0D                        bra @done
002005r 3               
002005r 3               @single:
002005r 3                               ; This is a single number, so we just drop the top cell
002005r 3  E8                           inx
002006r 3  E8                           inx
002007r 3               
002007r 3                               ; Clear status bit 5 to indicate this is a single number
002007r 3  A9 20                        lda #%00100000
002009r 3  14 20                        trb status
00200Br 3               
00200Br 3                               ; If we had a minus, we'll have to negate it
00200Br 3  A5 2B                        lda tmpdsp+1
00200Dr 3  F0 03                        beq @done       ; no minus, all done
00200Fr 3               
00200Fr 3  20 rr rr                     jsr xt_negate
002012r 3               @done:
002012r 3  60           z_number:       rts
002013r 3               
002013r 3               
002013r 3               
002013r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
002013r 3               ; ## "#"  auto  ANS core
002013r 3                       ; """https://forth-standard.org/standard/core/num
002013r 3                       ; Add one char to the beginning of the pictured output string.
002013r 3                       ;
002013r 3                       ; Based on
002013r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002013r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
002013r 3                       ; """
002013r 3               xt_number_sign:
002013r 3  20 rr rr                     jsr underflow_2         ; double number
002016r 3               
002016r 3  20 rr rr                     jsr xt_base
002019r 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
00201Cr 3               
00201Cr 3                               ; The following code is the ancient Forth word UD/MOD, which in
00201Cr 3                               ; various Forths (including Gforth) lives on under the hood,
00201Cr 3                               ; even though it's not an ANS standard word, it doesn't appear
00201Cr 3                               ; in the docs, it's only used here, and there are no tests for
00201Cr 3                               ; it. This is why we got rid of it. We'll be converting this
00201Cr 3                               ; mess to something more sane in the long run.
00201Cr 3  20 rr rr                     jsr xt_to_r             ; >r
00201Fr 3  20 rr rr                     jsr xt_zero             ; 0
002022r 3  20 rr rr                     jsr xt_r_fetch          ; r@
002025r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
002028r 3  20 rr rr                     jsr xt_rot              ; rot
00202Br 3  20 rr rr                     jsr xt_rot              ; rot
00202Er 3  20 rr rr                     jsr xt_r_from           ; r>
002031r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
002034r 3  20 rr rr                     jsr xt_rot              ; rot
002037r 3                               ; end of UD/MOD ( rem ud )
002037r 3               
002037r 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
00203Ar 3               
00203Ar 3                               ; Convert the number that is left over to an ASCII character. We
00203Ar 3                               ; use a string lookup for speed. Use either abc_str_lower for
00203Ar 3                               ; lower case or abc_str_upper for upper case (prefered)
00203Ar 3  B5 00                        lda 0,x
00203Cr 3  A8                           tay
00203Dr 3  B9 rr rr                     lda s_abc_upper,y
002040r 3  95 00                        sta 0,x
002042r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
002044r 3               
002044r 3  20 rr rr                     jsr xt_hold
002047r 3               
002047r 3               z_number_sign:
002047r 3  60                           rts
002048r 3               
002048r 3               
002048r 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
002048r 3               ; ## "#>"  auto  ANS core
002048r 3                       ; """https://forth-standard.org/standard/core/num-end
002048r 3                       ; Finish conversion of pictured number string, putting address and
002048r 3                       ; length on the Data Stack.
002048r 3                       ;
002048r 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
002048r 3                       ; Based on
002048r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002048r 3                       ; """
002048r 3               xt_number_sign_greater:
002048r 3               
002048r 3  20 rr rr                     jsr underflow_2         ; double number
00204Br 3               
00204Br 3                               ; The start address lives in tohold
00204Br 3  A5 34                        lda tohold
00204Dr 3  95 00                        sta 0,x         ; LSB of tohold
00204Fr 3  95 02                        sta 2,x
002051r 3  A5 35                        lda tohold+1
002053r 3  95 01                        sta 1,x         ; MSB of addr
002055r 3  95 03                        sta 3,x         ; ( addr addr )
002057r 3               
002057r 3                               ; The length of the string is pad - addr
002057r 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
00205Ar 3               
00205Ar 3  38                           sec
00205Br 3  B5 00                        lda 0,x         ; LSB of pad address
00205Dr 3  F5 02                        sbc 2,x
00205Fr 3  95 02                        sta 2,x
002061r 3               
002061r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
002063r 3  F5 03                        sbc 3,x
002065r 3  95 03                        sta 3,x         ; ( addr u pad )
002067r 3               
002067r 3  E8                           inx
002068r 3  E8                           inx
002069r 3               
002069r 3               z_number_sign_greater:
002069r 3  60                           rts
00206Ar 3               
00206Ar 3               
00206Ar 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
00206Ar 3               ; ## "#s"  auto  ANS core
00206Ar 3                       ; """https://forth-standard.org/standard/core/numS
00206Ar 3                       ; Completely convert number for pictured numerical output.
00206Ar 3                       ;
00206Ar 3                       ; Based on
00206Ar 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
00206Ar 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
00206Ar 3                       ; """
00206Ar 3               
00206Ar 3               xt_number_sign_s:
00206Ar 3  20 rr rr                     jsr underflow_2
00206Dr 3               @loop:
00206Dr 3                               ; convert a single number ("#")
00206Dr 3  20 rr rr                     jsr xt_number_sign
002070r 3               
002070r 3                               ; stop when double-celled number in TOS is zero:
002070r 3  B5 00                        lda 0,x
002072r 3  15 01                        ora 1,x
002074r 3  15 02                        ora 2,x
002076r 3  15 03                        ora 3,x
002078r 3  D0 F3                        bne @loop
00207Ar 3               
00207Ar 3               z_number_sign_s:
00207Ar 3  60                           rts
00207Br 3               
00207Br 3               
00207Br 3               
00207Br 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
00207Br 3               ; ## "of"  auto  ANS core ext
00207Br 3                       ; """http://forth-standard.org/standard/core/OF"""
00207Br 3               
00207Br 3               xt_of:
00207Br 3                               ; Check if value is equal to this case.
00207Br 3                               ; Postpone over (eg. compile a jsr to it)
00207Br 3  A0 rr                        ldy #>xt_over
00207Dr 3  A9 rr                        lda #<xt_over
00207Fr 3  20 rr rr                     jsr cmpl_subroutine
002082r 3               
002082r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
002082r 3  A0 rr                        ldy #>xt_equal
002084r 3  A9 rr                        lda #<xt_equal
002086r 3  20 rr rr                     jsr cmpl_subroutine
002089r 3               
002089r 3  20 rr rr                     jsr xt_if
00208Cr 3               
00208Cr 3                               ; If it's true, consume the original value.
00208Cr 3                               ; Postpone DROP (eg. compile a jsr to it)
00208Cr 3  A0 rr                        ldy #>xt_drop
00208Er 3  A9 rr                        lda #<xt_drop
002090r 3  20 rr rr                     jsr cmpl_subroutine
002093r 3               
002093r 3  60           z_of:           rts
002094r 3               
002094r 3               
002094r 3               
002094r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
002094r 3               ; ## "1"  auto  Tali Forth
002094r 3                       ; """This is also the code for EDITOR-WORDLIST"""
002094r 3               xt_editor_wordlist:
002094r 3               xt_one:
002094r 3  CA                           dex
002095r 3  CA                           dex
002096r 3  A9 01                        lda #1
002098r 3  95 00                        sta 0,x
00209Ar 3  74 01                        stz 1,x
00209Cr 3               
00209Cr 3               z_editor_wordlist:
00209Cr 3               z_one:
00209Cr 3  60                           rts
00209Dr 3               
00209Dr 3               
00209Dr 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
00209Dr 3               ; ## "1-"  auto  ANS core
00209Dr 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
00209Dr 3               
00209Dr 3               xt_one_minus:
00209Dr 3  20 rr rr                     jsr underflow_1
0020A0r 3               
0020A0r 3  B5 00                        lda 0,x
0020A2r 3  D0 02                        bne @1
0020A4r 3  D6 01                        dec 1,x
0020A6r 3               @1:
0020A6r 3  D6 00                        dec 0,x
0020A8r 3               
0020A8r 3  60           z_one_minus:    rts
0020A9r 3               
0020A9r 3               
0020A9r 3               
0020A9r 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
0020A9r 3               ; ## "1+"  auto  ANS core
0020A9r 3                       ; """https://forth-standard.org/standard/core/OnePlus
0020A9r 3                       ;
0020A9r 3                       ; Code is shared with CHAR-PLUS
0020A9r 3                       ; """
0020A9r 3               
0020A9r 3               xt_char_plus:
0020A9r 3               xt_one_plus:
0020A9r 3  20 rr rr                     jsr underflow_1
0020ACr 3               
0020ACr 3  F6 00                        inc 0,x
0020AEr 3  D0 02                        bne @done
0020B0r 3  F6 01                        inc 1,x
0020B2r 3               
0020B2r 3               @done:
0020B2r 3               z_char_plus:
0020B2r 3  60           z_one_plus:     rts
0020B3r 3               
0020B3r 3               
0020B3r 3               
0020B3r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
0020B3r 3               ; ## "only"  auto  ANS search ext
0020B3r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
0020B3r 3               
0020B3r 3               xt_only:
0020B3r 3                               ; Put -1 on data stack.
0020B3r 3  CA                           dex
0020B4r 3  CA                           dex
0020B5r 3  A9 FF                        lda #$FF
0020B7r 3  95 00                        sta 0,x
0020B9r 3  95 01                        sta 1,x
0020BBr 3               
0020BBr 3                               ; Invoke set-order to set the minimum search order.
0020BBr 3  20 rr rr                     jsr xt_set_order
0020BEr 3               
0020BEr 3  60           z_only:         rts
0020BFr 3               
0020BFr 3               
0020BFr 3               
0020BFr 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
0020BFr 3               ; ## "or"  auto  ANS core
0020BFr 3                       ; """https://forth-standard.org/standard/core/OR"
0020BFr 3               xt_or:
0020BFr 3  20 rr rr                     jsr underflow_2
0020C2r 3               
0020C2r 3  B5 00                        lda 0,x
0020C4r 3  15 02                        ora 2,x
0020C6r 3  95 02                        sta 2,x
0020C8r 3               
0020C8r 3  B5 01                        lda 1,x
0020CAr 3  15 03                        ora 3,x
0020CCr 3  95 03                        sta 3,x
0020CEr 3               
0020CEr 3  E8                           inx
0020CFr 3  E8                           inx
0020D0r 3               
0020D0r 3  60           z_or:           rts
0020D1r 3               
0020D1r 3               
0020D1r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
0020D1r 3               ; ## "order"  auto  ANS core
0020D1r 3                       ; """https://forth-standard.org/standard/search/ORDER
0020D1r 3                       ; Note the search order is displayed from first search to last
0020D1r 3                       ; searched and is therefore exactly the reverse of the order in which
0020D1r 3                       ; Forth stacks are displayed.
0020D1r 3                       ;
0020D1r 3                       ; A Forth implementation of this word is:
0020D1r 3                       ;
0020D1r 3                       ; 	: .wid ( wid -- )
0020D1r 3                       ; 	dup 0=  if ." Forth "  drop    else
0020D1r 3                       ; 	dup 1 = if ." Editor " drop    else
0020D1r 3                       ; 	dup 2 = if ." Assembler " drop else
0020D1r 3                       ; 	dup 3 = if ." Root " drop      else
0020D1r 3                       ; 	           . ( just print the number )
0020D1r 3                       ; 	then then then then ;
0020D1r 3                       ;
0020D1r 3                       ; : ORDER ( -- )
0020D1r 3                       ; 	cr get-order 0 ?do .wid loop
0020D1r 3                       ; 	space space get-current .wid ;
0020D1r 3                       ;
0020D1r 3                       ; This is an interactive program, so speed
0020D1r 3                       ; is not as important as size. We assume we do not have more than 255
0020D1r 3                       ; wordlists.
0020D1r 3                       ; """
0020D1r 3               
0020D1r 3               xt_order:
0020D1r 3  20 rr rr                     jsr xt_cr
0020D4r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
0020D7r 3               
0020D7r 3                               ; Paranoid: Check if there are no wordlists, a rather
0020D7r 3                               ; pathological case. this would mean ( 0 ) on the stack. In
0020D7r 3                               ; that case, we just drop n and run
0020D7r 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
0020D9r 3  F0 1E                        beq @drop_done
0020DBr 3               
0020DBr 3               @have_wordlists:
0020DBr 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
0020DBr 3                               ; on the stack
0020DBr 3  A8                           tay
0020DCr 3               @loop:
0020DCr 3  E8                           inx
0020DDr 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
0020DEr 3  B5 00                        lda 0,x
0020E0r 3               
0020E0r 3  5A                           phy
0020E1r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
0020E4r 3  7A                           ply
0020E5r 3               
0020E5r 3  88                           dey
0020E6r 3  D0 F4                        bne @loop
0020E8r 3               
0020E8r 3                               ; We've printed the wordlists, now we add the current wordlist.
0020E8r 3                               ; This follows the convention of Gforth
0020E8r 3  20 rr rr                     jsr xt_space
0020EBr 3  20 rr rr                     jsr xt_space
0020EEr 3  20 rr rr                     jsr xt_get_current      ; ( wid )
0020F1r 3               
0020F1r 3  B5 00                        lda 0,x
0020F3r 3  20 rr rr                     jsr _print_wid_string
0020F6r 3  20 rr rr                     jsr xt_cr
0020F9r 3               
0020F9r 3               @drop_done:
0020F9r 3  E8                           inx
0020FAr 3  E8                           inx
0020FBr 3               z_order:
0020FBr 3  60                           rts
0020FCr 3               
0020FCr 3               _print_wid_string:
0020FCr 3                       ; """Helper function for ORDER: Given a WID in A, print the
0020FCr 3                       ; corresponding string. If there is no such word list defined, just
0020FCr 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
0020FCr 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
0020FCr 3                       ; theory, we could speed this up by having the WID be the same as the
0020FCr 3                       ; number of the strings. However, ORDER is used rather infrequently and
0020FCr 3                       ; this would make changes to the strings.asm file very dangerous, so we
0020FCr 3                       ; follow the slightly more complicated route with a translation table.
0020FCr 3                       ; """
0020FCr 3                               ; If the WID is larger than 3, we have no string avaliable and
0020FCr 3                               ; just print the number.
0020FCr 3                               ; See http://6502.org/tutorials/compare_instructions.html
0020FCr 3                               ; for details
0020FCr 3  C9 04                        cmp #4
0020FEr 3  90 09                        bcc @output_string      ; less than 4, print a real string
002100r 3               
002100r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
002100r 3                               ; print the number
002100r 3  CA                           dex
002101r 3  CA                           dex
002102r 3  95 00                        sta 0,x
002104r 3  74 01                        stz 1,x
002106r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
002109r 3               
002109r 3               @output_string:
002109r 3                               ; Get the string number based on WID 0 to 3
002109r 3  A8                           tay
00210Ar 3  B9 rr rr                     lda @wid_data,y
00210Dr 3               
00210Dr 3                               ; Print without a line feed
00210Dr 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
002110r 3               
002110r 3               @wid_data:
002110r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
002110r 3                       ; less than 4.
002110r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
002111r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
002112r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
002113r 3  08                   .byte str_wid_root             ; WID 3: "Root"
002114r 3               
002114r 3               
002114r 3               
002114r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
002114r 3               ; ## "output"  tested  Tali Forth
002114r 3               xt_output:
002114r 3                       ; """Return the address where the jump target for EMIT is stored (but
002114r 3                       ; not the vector itself). By default, this will hold the value of
002114r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
002114r 3                       ; routine.
002114r 3                       ; """
002114r 3  CA                           dex
002115r 3  CA                           dex
002116r 3  A9 10                        lda #<output
002118r 3  95 00                        sta 0,x
00211Ar 3  A9 00                        lda #>output
00211Cr 3  95 01                        sta 1,x
00211Er 3               
00211Er 3  60           z_output:       rts
00211Fr 3               
00211Fr 3               
00211Fr 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
00211Fr 3               ; ## "over"  auto  ANS core
00211Fr 3                       ; """https://forth-standard.org/standard/core/OVER"""
00211Fr 3               xt_over:
00211Fr 3  20 rr rr                     jsr underflow_2
002122r 3               
002122r 3  CA                           dex
002123r 3  CA                           dex
002124r 3               
002124r 3  B5 04                        lda 4,x         ; LSB
002126r 3  95 00                        sta 0,x
002128r 3  B5 05                        lda 5,x         ; MSB
00212Ar 3  95 01                        sta 1,x
00212Cr 3               
00212Cr 3  60           z_over:         rts
00212Dr 3               
00212Dr 3               
00212Dr 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
00212Dr 3               ; ## "pad"  auto  ANS core ext
00212Dr 3                       ; """https://forth-standard.org/standard/core/PAD
00212Dr 3                       ; Return address to a temporary area in free memory for user. Must
00212Dr 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
00212Dr 3                       ; the compile area pointer (CP) and therefore varies in position.
00212Dr 3                       ; This area is reserved for the user and not used by the system
00212Dr 3                       ; """
00212Dr 3               xt_pad:
00212Dr 3  CA                           dex
00212Er 3  CA                           dex
00212Fr 3               
00212Fr 3  A5 00                        lda cp
002131r 3  18                           clc
002132r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
002134r 3  95 00                        sta 0,x
002136r 3               
002136r 3  A5 01                        lda cp+1
002138r 3  69 00                        adc #0          ; only need carry
00213Ar 3  95 01                        sta 1,x
00213Cr 3               
00213Cr 3  60           z_pad:          rts
00213Dr 3               
00213Dr 3               
00213Dr 3               ; ## PAGE ( -- ) "Clear the screen"
00213Dr 3               ; ## "page"  tested  ANS facility
00213Dr 3                       ; """https://forth-standard.org/standard/facility/PAGE
00213Dr 3                       ; Clears a page if supported by ANS terminal codes. This is
00213Dr 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
00213Dr 3                       ; left of the screen
00213Dr 3                       ; """
00213Dr 3               xt_page:
00213Dr 3  A9 1B                        lda #AscESC
00213Fr 3  20 rr rr                     jsr emit_a
002142r 3  A9 5B                        lda #$5B        ; ASCII for "["
002144r 3  20 rr rr                     jsr emit_a
002147r 3  A9 32                        lda #'2'
002149r 3  20 rr rr                     jsr emit_a
00214Cr 3  A9 4A                        lda #'J'
00214Er 3  20 rr rr                     jsr emit_a
002151r 3               
002151r 3                               ; move cursor to top left of screen
002151r 3  20 rr rr                     jsr xt_zero
002154r 3  20 rr rr                     jsr xt_zero
002157r 3  20 rr rr                     jsr xt_at_xy
00215Ar 3               
00215Ar 3  60           z_page:         rts
00215Br 3               
00215Br 3               
00215Br 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
00215Br 3               ; ## "("  auto  ANS core
00215Br 3                       ; """http://forth-standard.org/standard/core/p"""
00215Br 3               
00215Br 3               xt_paren:
00215Br 3                               ; Put a right paren on the stack.
00215Br 3  CA                           dex
00215Cr 3  CA                           dex
00215Dr 3  A9 29                        lda #41     ; Right parenthesis
00215Fr 3  95 00                        sta 0,x
002161r 3  74 01                        stz 1,x
002163r 3               
002163r 3                               ; Call parse.
002163r 3  20 rr rr                     jsr xt_parse
002166r 3               
002166r 3                               ; Throw away the result.
002166r 3  E8                           inx
002167r 3  E8                           inx
002168r 3  E8                           inx
002169r 3  E8                           inx
00216Ar 3               
00216Ar 3  60           z_paren:        rts
00216Br 3               
00216Br 3               
00216Br 3               
00216Br 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
00216Br 3               ; ## "parse-name"  auto  ANS core ext
00216Br 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
00216Br 3                       ; Find next word in input string, skipping leading whitespace. This is
00216Br 3                       ; a special form of PARSE and drops through to that word. See PARSE
00216Br 3                       ; for more detail. We use this word internally for the interpreter
00216Br 3                       ; because it is a lot easier to use. Reference implementations at
00216Br 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
00216Br 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
00216Br 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
00216Br 3                       ; though the ANS standard talks about skipping "spaces", whitespace
00216Br 3                       ; is actually perfectly legal (see for example
00216Br 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
00216Br 3                       ; Otherwise, PARSE-NAME chokes on tabs.
00216Br 3                       ; """
00216Br 3               
00216Br 3               xt_parse_name:
00216Br 3                               ; To enable the compilation of the high-level Forth words
00216Br 3                               ; in forth-words.asm and user-words.asm at boot time,
00216Br 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
00216Br 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
00216Br 3                               ; to the current location is in toin (>IN). We need to check,
00216Br 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
00216Br 3                               ; we can't just use Y as an index.
00216Br 3               
00216Br 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
00216Br 3  A5 0A                        lda ciblen              ; LSB of counter
00216Dr 3  38                           sec
00216Er 3  E5 0C                        sbc toin
002170r 3  85 24                        sta tmp1
002172r 3  A5 0B                        lda ciblen+1            ; MSB
002174r 3  E5 0D                        sbc toin+1
002176r 3  85 25                        sta tmp1+1
002178r 3               
002178r 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
002178r 3  A5 24                        lda tmp1
00217Ar 3  05 25                        ora tmp1+1
00217Cr 3  F0 28                        beq @empty_line
00217Er 3               
00217Er 3                               ; We walk through the characters starting at CIB+TOIN, so we
00217Er 3                               ; save a temp version of that in tmp2
00217Er 3  A5 08                        lda cib
002180r 3  18                           clc
002181r 3  65 0C                        adc toin
002183r 3  85 26                        sta tmp2                ; LSB of first character
002185r 3  A5 09                        lda cib+1
002187r 3  65 0D                        adc toin+1
002189r 3  85 27                        sta tmp2+1              ; MSB
00218Br 3               
00218Br 3               @skip_loop:
00218Br 3  B2 26                        lda (tmp2)              ; work copy of cib
00218Dr 3  20 rr rr                     jsr is_whitespace
002190r 3  90 1F                        bcc @char_found
002192r 3               
002192r 3                               ; Char is still whitespace, continue
002192r 3  E6 26                        inc tmp2
002194r 3  D0 02                        bne @2
002196r 3  E6 27                        inc tmp2+1
002198r 3               @2:
002198r 3                               ; Adjust counter
002198r 3  A5 24                        lda tmp1
00219Ar 3  D0 02                        bne @3
00219Cr 3  C6 25                        dec tmp1+1
00219Er 3               @3:
00219Er 3  C6 24                        dec tmp1
0021A0r 3               
0021A0r 3  A5 24                        lda tmp1
0021A2r 3  05 25                        ora tmp1+1
0021A4r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
0021A6r 3               
0021A6r 3               @empty_line:
0021A6r 3                               ; Neither the ANS Forth nor the Gforth documentation say
0021A6r 3                               ; what to return as an address if a string with only
0021A6r 3                               ; spaces is given. For speed reasons, we just return junk
0021A6r 3                               ; NOS, with the TOS zero as per standard
0021A6r 3  CA                           dex
0021A7r 3  CA                           dex
0021A8r 3  CA                           dex
0021A9r 3  CA                           dex
0021AAr 3               
0021AAr 3  74 00                        stz 0,x                 ; TOS is zero
0021ACr 3  74 01                        stz 1,x
0021AEr 3               
0021AEr 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
0021B1r 3               
0021B1r 3               @char_found:
0021B1r 3                               ; We arrive here with tmp2 pointing to the first non-space
0021B1r 3                               ; character. This is where the word really starts, so
0021B1r 3                               ; we use it to calculate the new >IN by subtracting
0021B1r 3  A5 26                        lda tmp2
0021B3r 3  38                           sec
0021B4r 3  E5 08                        sbc cib
0021B6r 3  85 0C                        sta toin
0021B8r 3  A5 27                        lda tmp2+1
0021BAr 3  E5 09                        sbc cib+1
0021BCr 3  85 0D                        sta toin+1
0021BEr 3               
0021BEr 3                               ; prepare Data Stack for PARSE by adding space
0021BEr 3                               ; as the delimiter
0021BEr 3  CA                           dex
0021BFr 3  CA                           dex
0021C0r 3               
0021C0r 3  A9 20                        lda #AscSP
0021C2r 3  95 00                        sta 0,x
0021C4r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
0021C6r 3               
0021C6r 3               
0021C6r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
0021C6r 3               ; ## "parse"  tested  ANS core ext
0021C6r 3                       ; """https://forth-standard.org/standard/core/PARSE
0021C6r 3                       ; Find word in input string delimited by character given. Do not
0021C6r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
0021C6r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
0021C6r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
0021C6r 3                       ;
0021C6r 3                       ;
0021C6r 3                       ;     cib  cib+toin   cib+ciblen
0021C6r 3                       ;      v      v            v
0021C6r 3                       ;     |###################|
0021C6r 3                       ;
0021C6r 3                       ;     |------>|  toin (>IN)
0021C6r 3                       ;     |------------------->|  ciblen
0021C6r 3                       ;
0021C6r 3                       ; The input string is stored starting at the address in the Current
0021C6r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
0021C6r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
0021C6r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
0021C6r 3                       ; useful string if there are any characters at all. As with
0021C6r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
0021C6r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
0021C6r 3                       ; """
0021C6r 3               
0021C6r 3               xt_parse:
0021C6r 3  20 rr rr                     jsr underflow_1
0021C9r 3               
0021C9r 3                               ; If the input buffer is empty, we just return
0021C9r 3  A5 0A                        lda ciblen
0021CBr 3  05 0B                        ora ciblen+1
0021CDr 3  F0 0C                        beq @abort_parse
0021CFr 3               
0021CFr 3                               ; If the pointer >IN is larger or equal to the length of
0021CFr 3                               ; the input buffer (CIBLEN), the line is done. Put
0021CFr 3                               ; differently, we only continue if >IN is smaller than
0021CFr 3                               ; CIBLEN
0021CFr 3  A5 0D                        lda toin+1              ; MSB
0021D1r 3  C5 0B                        cmp ciblen+1
0021D3r 3  90 0E                        bcc @go_parse           ; unsigned comparison
0021D5r 3               
0021D5r 3  A5 0C                        lda toin                ; LSB
0021D7r 3  C5 0A                        cmp ciblen
0021D9r 3  90 08                        bcc @go_parse
0021DBr 3               
0021DBr 3               @abort_parse:
0021DBr 3                               ; Sorry, this line is over
0021DBr 3  CA                           dex
0021DCr 3  CA                           dex
0021DDr 3  74 00                        stz 0,x
0021DFr 3  74 01                        stz 1,x
0021E1r 3               
0021E1r 3  80 7A                        bra @done
0021E3r 3               @go_parse:
0021E3r 3                               ; We actually have work to do. Save the delimiter in
0021E3r 3                               ; tmptos.
0021E3r 3  B5 00                        lda 0,x
0021E5r 3  85 2C                        sta tmptos
0021E7r 3               
0021E7r 3                               ; We can now prepare the Data Stack for the return value
0021E7r 3  CA                           dex
0021E8r 3  CA                           dex
0021E9r 3               
0021E9r 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
0021E9r 3                               ; tmp2 is initially the same as tmp1, then the work index
0021E9r 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
0021E9r 3               
0021E9r 3                               ; Calculate the beginning of the string, which is also the
0021E9r 3                               ; address to return
0021E9r 3  A5 08                        lda cib
0021EBr 3  18                           clc
0021ECr 3  65 0C                        adc toin        ; LSB
0021EEr 3  85 24                        sta tmp1
0021F0r 3  85 26                        sta tmp2
0021F2r 3  95 02                        sta 2,x
0021F4r 3               
0021F4r 3  A5 09                        lda cib+1
0021F6r 3  65 0D                        adc toin+1      ; MSB
0021F8r 3  85 25                        sta tmp1+1
0021FAr 3  85 27                        sta tmp2+1
0021FCr 3  95 03                        sta 3,x
0021FEr 3               
0021FEr 3                               ; Calculate the address where the input buffer ends plus 1, so
0021FEr 3                               ; we can compare it with TOIN, which is an index
0021FEr 3  A5 08                        lda cib
002200r 3  18                           clc
002201r 3  65 0A                        adc ciblen
002203r 3  85 28                        sta tmp3
002205r 3  A5 09                        lda cib+1
002207r 3  65 0B                        adc ciblen+1
002209r 3  85 29                        sta tmp3+1
00220Br 3               
00220Br 3                               ; Initialize the offset we use to adjust EOL or found delimiter
00220Br 3  64 2D                        stz tmptos+1
00220Dr 3               @loop:
00220Dr 3                               ; If we are at the end of the string, quit
00220Dr 3  A5 26                        lda tmp2
00220Fr 3  C5 28                        cmp tmp3
002211r 3  D0 06                        bne @not_empty
002213r 3               
002213r 3  A5 27                        lda tmp2+1
002215r 3  C5 29                        cmp tmp3+1
002217r 3  F0 1D                        beq @eol
002219r 3               @not_empty:
002219r 3                               ; We have to do this the hard way. In fact, it's really
002219r 3                               ; hard since if we are dealing with a SPACE, the standard
002219r 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
002219r 3                               ; Tali would choke on tabs between words. For details, see
002219r 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
002219r 3                               ; In theory, we could make this faster by defining a delimiter
002219r 3                               ; that is 00 as the sign that we skip all whitespace, thereby
002219r 3                               ; avoiding having to test every time. However, somebody,
002219r 3                               ; somewhere might want to parse a zero-delimited list. Since
002219r 3                               ; any byte value could be chosen for that, we just test for
002219r 3                               ; a space every single time for the moment.
002219r 3  B2 26                        lda (tmp2)
00221Br 3               
00221Br 3  A4 2C                        ldy tmptos
00221Dr 3  C0 20                        cpy #AscSP
00221Fr 3  D0 07                        bne @not_whitespace
002221r 3               
002221r 3                               ; The delimiter is a space, so we're looking for all
002221r 3                               ; whitespace
002221r 3  20 rr rr                     jsr is_whitespace
002224r 3  90 02                        bcc @not_whitespace
002226r 3  80 0C                        bra @found_delimiter
002228r 3               
002228r 3               @not_whitespace:
002228r 3                               ; The delimiter is not a space, so we're looking for
002228r 3                               ; whatever it is
002228r 3  C5 2C                        cmp tmptos
00222Ar 3  F0 08                        beq @found_delimiter
00222Cr 3               
00222Cr 3                               ; Not a delimiter, next character
00222Cr 3  E6 26                        inc tmp2
00222Er 3  D0 DD                        bne @loop
002230r 3  E6 27                        inc tmp2+1
002232r 3  80 D9                        bra @loop
002234r 3               
002234r 3               @found_delimiter:
002234r 3                               ; Increase the offset: If we've found a delimiter, we want
002234r 3                               ; TOIN to point to the character after it, not the delimiter
002234r 3                               ; itself
002234r 3  E6 2D                        inc tmptos+1
002236r 3               @eol:
002236r 3                               ; The length of the new string is tmp2-tmp1
002236r 3  A5 26                        lda tmp2
002238r 3  38                           sec
002239r 3  E5 24                        sbc tmp1
00223Br 3  95 00                        sta 0,x
00223Dr 3               
00223Dr 3  A5 27                        lda tmp2+1
00223Fr 3  E5 25                        sbc tmp1+1
002241r 3  95 01                        sta 1,x
002243r 3               
002243r 3                               ; The new offset is tmp2-cib
002243r 3  A5 26                        lda tmp2
002245r 3  38                           sec
002246r 3  E5 08                        sbc cib
002248r 3  85 0C                        sta toin
00224Ar 3  A5 27                        lda tmp2+1
00224Cr 3  E5 09                        sbc cib+1
00224Er 3  85 0D                        sta toin+1
002250r 3               
002250r 3                               ; Add in the delimiter
002250r 3  A5 0C                        lda toin
002252r 3  18                           clc
002253r 3  65 2D                        adc tmptos+1
002255r 3  85 0C                        sta toin
002257r 3  A5 0D                        lda toin+1
002259r 3  69 00                        adc #0          ; we only need the carry
00225Br 3  85 0D                        sta toin+1
00225Dr 3               @done:
00225Dr 3               z_parse_name:
00225Dr 3  60           z_parse:        rts
00225Er 3               
00225Er 3               
00225Er 3               
00225Er 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
00225Er 3               ; ## "pick"  auto  ANS core ext
00225Er 3                       ; """https://forth-standard.org/standard/core/PICK
00225Er 3                       ; Take the u-th element out of the stack and put it on TOS,
00225Er 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
00225Er 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
00225Er 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
00225Er 3                       ; """
00225Er 3               
00225Er 3               xt_pick:
00225Er 3                               ; Checking for underflow is difficult because it depends on
00225Er 3                               ; which element we want to grab. We could probably figure
00225Er 3                               ; something out, but it wouldn't work with underflow stripping
00225Er 3                               ; Since using PICK is considered poor form anyway, we just
00225Er 3                               ; leave it as it is
00225Er 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
002260r 3  8A                           txa
002261r 3  75 00                        adc 0,x
002263r 3  A8                           tay
002264r 3               
002264r 3  B9 02 00                     lda 0002,y
002267r 3  95 00                        sta 0,x
002269r 3  B9 03 00                     lda 0003,y
00226Cr 3  95 01                        sta 1,x
00226Er 3               
00226Er 3  60           z_pick:         rts
00226Fr 3               
00226Fr 3               
00226Fr 3               
00226Fr 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
00226Fr 3               ; ## "+"  auto  ANS core
00226Fr 3                       ; """https://forth-standard.org/standard/core/Plus"""
00226Fr 3               xt_plus:
00226Fr 3  20 rr rr                     jsr underflow_2
002272r 3               
002272r 3  18                           clc
002273r 3  B5 00                        lda 0,x         ; LSB
002275r 3  75 02                        adc 2,x
002277r 3  95 02                        sta 2,x
002279r 3               
002279r 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
00227Br 3  75 03                        adc 3,x
00227Dr 3  95 03                        sta 3,x
00227Fr 3               
00227Fr 3  E8                           inx
002280r 3  E8                           inx
002281r 3               
002281r 3  60           z_plus:         rts
002282r 3               
002282r 3               
002282r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
002282r 3               ; ## "+!"  auto  ANS core
002282r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
002282r 3               xt_plus_store:
002282r 3  20 rr rr                     jsr underflow_2
002285r 3               
002285r 3                               ; move address to tmp1 so we can work with it
002285r 3  B5 00                        lda 0,x
002287r 3  85 24                        sta tmp1
002289r 3  B5 01                        lda 1,x
00228Br 3  85 25                        sta tmp1+1
00228Dr 3               
00228Dr 3  A0 00                        ldy #0          ; LSB
00228Fr 3  B1 24                        lda (tmp1),y
002291r 3  18                           clc
002292r 3  75 02                        adc 2,x
002294r 3  91 24                        sta (tmp1),y
002296r 3               
002296r 3  C8                           iny             ; MSB
002297r 3  B1 24                        lda (tmp1),y
002299r 3  75 03                        adc 3,x
00229Br 3  91 24                        sta (tmp1),y
00229Dr 3               
00229Dr 3  E8                           inx
00229Er 3  E8                           inx
00229Fr 3  E8                           inx
0022A0r 3  E8                           inx
0022A1r 3               
0022A1r 3  60           z_plus_store:   rts
0022A2r 3               
0022A2r 3               
0022A2r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
0022A2r 3               ; ## "postpone"  auto   ANS core
0022A2r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
0022A2r 3                       ; Add the compilation behavior of a word to a new word at
0022A2r 3                       ; compile time. If the word that follows it is immediate, include
0022A2r 3                       ; it so that it will be compiled when the word being defined is
0022A2r 3                       ; itself used for a new word. Tricky, but very useful.
0022A2r 3                       ;
0022A2r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
0022A2r 3                       ; on the Data Stack). This means we cannot build words with
0022A2r 3                       ; "jsr xt_postpone, jsr <word>" directly.
0022A2r 3                       ; """
0022A2r 3               
0022A2r 3               xt_postpone:
0022A2r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
0022A5r 3               
0022A5r 3                               ; if there was no word provided, complain and quit
0022A5r 3  B5 00                        lda 0,x
0022A7r 3  15 01                        ora 1,x
0022A9r 3  D0 05                        bne @1
0022ABr 3               
0022ABr 3  A9 05                        lda #err_noname
0022ADr 3  4C rr rr                     jmp error
0022B0r 3               @1:
0022B0r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
0022B3r 3               
0022B3r 3                               ; if word not in Dictionary, complain and quit
0022B3r 3  D0 05                        bne @2
0022B5r 3  A9 05                        lda #err_noname
0022B7r 3  4C rr rr                     jmp error
0022BAr 3               
0022BAr 3               @2:
0022BAr 3                               ; keep a copy of nt for later
0022BAr 3  B5 00                        lda 0,x
0022BCr 3  85 24                        sta tmp1
0022BEr 3  B5 01                        lda 1,x
0022C0r 3  85 25                        sta tmp1+1
0022C2r 3               
0022C2r 3                               ; We need the xt instead of the nt
0022C2r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
0022C5r 3               
0022C5r 3                               ; See if this is an immediate word. This is easier
0022C5r 3                               ; with nt than with xt. The status byte of the word
0022C5r 3                               ; is nt+1
0022C5r 3  E6 24                        inc tmp1
0022C7r 3  D0 02                        bne @3
0022C9r 3  E6 25                        inc tmp1+1
0022CBr 3               @3:
0022CBr 3  B2 24                        lda (tmp1)
0022CDr 3  29 04                        and #IM         ; mask all but Intermediate flag
0022CFr 3  F0 05                        beq @not_immediate
0022D1r 3               
0022D1r 3                               ; We're immediate, so instead of executing it right now, we
0022D1r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
0022D1r 3                               ; takes us back to the original caller
0022D1r 3  20 rr rr                     jsr xt_compile_comma
0022D4r 3  80 0A                        bra @done
0022D6r 3               
0022D6r 3               @not_immediate:
0022D6r 3                               ; This is not an immediate word, so we enact "deferred
0022D6r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
0022D6r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
0022D6r 3                               ; a subroutine jump to COMPILE,
0022D6r 3  20 rr rr                     jsr xt_literal
0022D9r 3               
0022D9r 3                               ; Last, compile COMPILE,
0022D9r 3  A0 rr                        ldy #>xt_compile_comma
0022DBr 3  A9 rr                        lda #<xt_compile_comma
0022DDr 3  20 rr rr                     jsr cmpl_subroutine
0022E0r 3               @done:
0022E0r 3  60           z_postpone:     rts
0022E1r 3               
0022E1r 3               
0022E1r 3               
0022E1r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
0022E1r 3               ; ## "previous"  auto  ANS search ext
0022E1r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
0022E1r 3               
0022E1r 3               xt_previous:
0022E1r 3  20 rr rr                     jsr xt_get_order
0022E4r 3  20 rr rr                     jsr xt_nip
0022E7r 3  20 rr rr                     jsr xt_one_minus
0022EAr 3  20 rr rr                     jsr xt_set_order
0022EDr 3               
0022EDr 3  60           z_previous:     rts
0022EEr 3               
0022EEr 3               
0022EEr 3               
0022EEr 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
0022EEr 3               ; ## "?"  tested  ANS tools
0022EEr 3                       ; """https://forth-standard.org/standard/tools/q
0022EEr 3                       ;
0022EEr 3                       ; Only used interactively. Since humans are so slow, we
0022EEr 3                       ; save size and just go for the subroutine jumps
0022EEr 3                       ; """
0022EEr 3               xt_question:
0022EEr 3                               ; FETCH takes care of underflow check
0022EEr 3  20 rr rr                     jsr xt_fetch
0022F1r 3  20 rr rr                     jsr xt_dot
0022F4r 3               
0022F4r 3  60           z_question:     rts
0022F5r 3               
0022F5r 3               
0022F5r 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
0022F5r 3               ; ## "?dup"  auto  ANS core
0022F5r 3                       ; """https://forth-standard.org/standard/core/qDUP"""
0022F5r 3               
0022F5r 3               xt_question_dup:
0022F5r 3  20 rr rr                     jsr underflow_1
0022F8r 3               
0022F8r 3                               ; Check if TOS is zero
0022F8r 3  B5 00                        lda 0,x
0022FAr 3  15 01                        ora 1,x
0022FCr 3  F0 0A                        beq @done
0022FEr 3               
0022FEr 3                               ; not zero, duplicate
0022FEr 3  CA                           dex
0022FFr 3  CA                           dex
002300r 3  B5 02                        lda 2,x
002302r 3  95 00                        sta 0,x
002304r 3  B5 03                        lda 3,x
002306r 3  95 01                        sta 1,x
002308r 3               @done:
002308r 3  60           z_question_dup: rts
002309r 3               
002309r 3               
002309r 3               
002309r 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
002309r 3               ; ## "r@"  auto  ANS core
002309r 3                       ; """https://forth-standard.org/standard/core/RFetch
002309r 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
002309r 3                       ; work normally as well
002309r 3                       ;
002309r 3                       ; An alternative way to write this word
002309r 3                       ; would be to access the elements on the stack directly like 2R@
002309r 3                       ; does, these versions should be compared at some point.
002309r 3                       ; """
002309r 3               xt_r_fetch:
002309r 3                               ; get the return address
002309r 3  7A                           ply             ; LSB
00230Ar 3  84 24                        sty tmp1
00230Cr 3  7A                           ply             ; MSB
00230Dr 3               
00230Dr 3                               ; --- CUT FOR NATIVE COMPILE ---
00230Dr 3               
00230Dr 3                               ; get the actual top of Return Stack
00230Dr 3  CA                           dex
00230Er 3  CA                           dex
00230Fr 3               
00230Fr 3  68                           pla             ; LSB
002310r 3  95 00                        sta 0,x
002312r 3  68                           pla             ; MSB
002313r 3  95 01                        sta 1,x
002315r 3               
002315r 3                               ; now we have to put that value back
002315r 3  48                           pha
002316r 3  B5 00                        lda 0,x
002318r 3  48                           pha
002319r 3               
002319r 3                               ; --- CUT FOR NATIVE COMPILE ---
002319r 3               
002319r 3                               ; restore return value
002319r 3  5A                           phy             ; MSB
00231Ar 3  A4 24                        ldy tmp1
00231Cr 3  5A                           phy             ; LSB
00231Dr 3               
00231Dr 3  60           z_r_fetch:      rts
00231Er 3               
00231Er 3               
00231Er 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
00231Er 3               ; ## "r>"  auto  ANS core
00231Er 3                       ; """https://forth-standard.org/standard/core/Rfrom
00231Er 3                       ; Move Top of Return Stack to Top of Data Stack.
00231Er 3                       ;
00231Er 3                       ; We have to move
00231Er 3                       ; the RTS address out of the way first. This word is handled
00231Er 3                       ; differently for native and and subroutine compilation, see COMPILE,
00231Er 3                       ; This is a compile-only word
00231Er 3                       ; """
00231Er 3               
00231Er 3               xt_r_from:
00231Er 3                               ; Rescue the address of the return jump that is currently
00231Er 3                               ; on top of the Return Stack. If this word is natively
00231Er 3                               ; compiled, this is a total waste of time
00231Er 3  68                           pla             ; LSB
00231Fr 3  85 2C                        sta tmptos
002321r 3  7A                           ply             ; MSB
002322r 3               
002322r 3                               ; --- CUT FOR NATIVE CODING ---
002322r 3               
002322r 3  CA                           dex
002323r 3  CA                           dex
002324r 3               
002324r 3                               ; now we can access the actual data
002324r 3               
002324r 3  68                           pla             ; LSB
002325r 3  95 00                        sta 0,x
002327r 3  68                           pla             ; MSB
002328r 3  95 01                        sta 1,x
00232Ar 3               
00232Ar 3                               ; --- CUT FOR NATIVE CODING ---
00232Ar 3               
00232Ar 3                               ; restore the return address
00232Ar 3  5A                           phy             ; MSB
00232Br 3  A5 2C                        lda tmptos
00232Dr 3  48                           pha             ; LSB
00232Er 3               
00232Er 3  60           z_r_from:       rts
00232Fr 3               
00232Fr 3               
00232Fr 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
00232Fr 3               ; ## "r>input"  tested  Tali Forth
00232Fr 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
00232Fr 3                       ; and toin from the Return Stack.
00232Fr 3                       ;
00232Fr 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
00232Fr 3                       ; """
00232Fr 3               
00232Fr 3               xt_r_to_input:
00232Fr 3               
00232Fr 3                               ; We arrive here with the return address on the top of the
00232Fr 3                               ; 65c02's stack. We need to move it out of the way first
00232Fr 3  68                           pla
002330r 3  85 24                        sta tmp1
002332r 3  68                           pla
002333r 3  85 25                        sta tmp1+1
002335r 3               
002335r 3                               ; This assumes that insrc is the first of eight bytes and
002335r 3                               ; toin+1 the last in the sequence we want to save from the Zero
002335r 3                               ; Page. Since we went in reverse order, insrc is now on the top
002335r 3                               ; of the Return Stack.
002335r 3  A0 00                        ldy #0
002337r 3               @loop:
002337r 3  68                           pla
002338r 3  99 06 00                     sta insrc,y
00233Br 3  C8                           iny
00233Cr 3  C0 08                        cpy #8
00233Er 3  D0 F7                        bne @loop
002340r 3               
002340r 3                               ; Restore address for return jump
002340r 3  A5 25                        lda tmp1+1
002342r 3  48                           pha
002343r 3  A5 24                        lda tmp1
002345r 3  48                           pha
002346r 3               
002346r 3  60           z_r_to_input: 	rts
002347r 3               
002347r 3               
002347r 3               
002347r 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
002347r 3               ; ## "recurse"  auto  ANS core
002347r 3                       ; """https://forth-standard.org/standard/core/RECURSE
002347r 3                       ;
002347r 3                       ; This word may not be natively compiled
002347r 3                       ; """
002347r 3               
002347r 3               xt_recurse:
002347r 3                               ; The whole routine amounts to compiling a reference to
002347r 3                               ; the word that is being compiled. First, we save the JSR
002347r 3                               ; instruction
002347r 3  A0 00                        ldy #0
002349r 3               
002349r 3  A9 20                        lda #$20        ; opcode for JSR
00234Br 3  91 00                        sta (cp),y
00234Dr 3  C8                           iny
00234Er 3               
00234Er 3                               ; Next, we save the LSB and MSB of the xt of the word
00234Er 3                               ; we are currently working on. We first need to see if
00234Er 3                               ; WORKWORD has the nt (: started the word) or the
00234Er 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
00234Er 3  24 20                        bit status
002350r 3  70 0C                        bvs @nt_in_workword
002352r 3               
002352r 3                               ; This is a special :NONAME word. Just copy the xt
002352r 3                               ; from WORKWORD into the dictionary.
002352r 3  A5 04                        lda workword
002354r 3  91 00                        sta (cp),y
002356r 3  C8                           iny
002357r 3  A5 05                        lda workword+1
002359r 3  91 00                        sta (cp),y
00235Br 3  C8                           iny
00235Cr 3  80 1B                        bra @update_cp
00235Er 3               
00235Er 3               @nt_in_workword:
00235Er 3                               ; This is a regular : word, so the xt is four bytes down
00235Er 3                               ; from the nt which we saved in WORKWORD. We could probably
00235Er 3                               ; use NAME>INT here but this is going to be faster, and
00235Er 3                               ; fast counts with recursion
00235Er 3  A5 04                        lda workword            ; LSB
002360r 3  18                           clc
002361r 3  69 04                        adc #4
002363r 3  85 24                        sta tmp1
002365r 3  A5 05                        lda workword+1          ; MSB
002367r 3  69 00                        adc #0
002369r 3  85 25                        sta tmp1+1
00236Br 3               
00236Br 3  B2 24                        lda (tmp1)
00236Dr 3  91 00                        sta (cp),y
00236Fr 3  5A                           phy
002370r 3  A0 01                        ldy #1
002372r 3  B1 24                        lda (tmp1),y
002374r 3  7A                           ply
002375r 3  C8                           iny
002376r 3  91 00                        sta (cp),y
002378r 3  C8                           iny
002379r 3               
002379r 3               @update_cp:
002379r 3  98                           tya
00237Ar 3  18                           clc
00237Br 3  65 00                        adc cp
00237Dr 3  85 00                        sta cp
00237Fr 3  90 02                        bcc @done
002381r 3  E6 01                        inc cp+1
002383r 3               @done:
002383r 3  60           z_recurse:      rts
002384r 3               
002384r 3               
002384r 3               
002384r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
002384r 3               ; ## "refill"  tested  ANS core ext
002384r 3                       ; """https://forth-standard.org/standard/core/REFILL
002384r 3                       ; Attempt to fill the input buffer from the input source, returning
002384r 3                       ; a true flag if successful. When the input source is the user input
002384r 3                       ; device, attempt to receive input into the terminal input buffer. If
002384r 3                       ; successful, make the result the input buffer, set >IN to zero, and
002384r 3                       ; return true. Receipt of a line containing no characters is considered
002384r 3                       ; successful. If there is no input available from the current input
002384r 3                       ; source, return false. When the input source is a string from EVALUATE,
002384r 3                       ; return false and perform no other action." See
002384r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
002384r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
002384r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
002384r 3                       ; entire block as a 1024 byte string.
002384r 3                       ; """"
002384r 3               
002384r 3               xt_refill:
002384r 3                               ; Get input source from SOURCE-ID. This is an
002384r 3                               ; optimized version of a subroutine jump to SOURCE-ID
002384r 3  A5 06                        lda insrc               ; cheat: We only check LSB
002386r 3  D0 2D                        bne @src_not_kbd
002388r 3               
002388r 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
002388r 3                               ; with ACCEPT, which wants the address of the current input
002388r 3                               ; buffer NOS and the max number of characters to accept TOS
002388r 3  CA                           dex
002389r 3  CA                           dex
00238Ar 3  CA                           dex
00238Br 3  CA                           dex
00238Cr 3               
00238Cr 3  A5 08                        lda cib                 ; address of CIB is NOS
00238Er 3  95 02                        sta 2,x
002390r 3  A5 09                        lda cib+1
002392r 3  95 03                        sta 3,x
002394r 3               
002394r 3  64 0A                        stz ciblen              ; go in with empty buffer
002396r 3  64 0B                        stz ciblen+1
002398r 3               
002398r 3  A9 FF                        lda #bsize              ; max number of chars is TOS
00239Ar 3  95 00                        sta 0,x
00239Cr 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
00239Er 3               
00239Er 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
0023A1r 3               
0023A1r 3                               ; ACCEPT returns the number of characters accepted, which
0023A1r 3                               ; belong in CIBLEN
0023A1r 3  B5 00                        lda 0,x
0023A3r 3  85 0A                        sta ciblen
0023A5r 3  B5 01                        lda 1,x
0023A7r 3  85 0B                        sta ciblen+1            ; though we only accept 255 chars
0023A9r 3               
0023A9r 3                               ; make >IN point to beginning of buffer
0023A9r 3  64 0C                        stz toin
0023ABr 3  64 0D                        stz toin+1
0023ADr 3               
0023ADr 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
0023AFr 3  95 00                        sta 0,x
0023B1r 3  95 01                        sta 1,x
0023B3r 3               
0023B3r 3  80 10                        bra @done
0023B5r 3               
0023B5r 3               @src_not_kbd:
0023B5r 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
0023B5r 3                               ; memory or a file (remember, no blocks in this version).
0023B5r 3                               ; If source is a string, we were given the flag -1 ($FFFF)
0023B5r 3  1A                           inc
0023B6r 3  D0 08                        bne @src_not_string
0023B8r 3               
0023B8r 3                               ; Simply return FALSE flag as per specification
0023B8r 3  CA                           dex
0023B9r 3  CA                           dex
0023BAr 3  74 00                        stz 0,x
0023BCr 3  74 01                        stz 1,x
0023BEr 3               
0023BEr 3  80 05                        bra z_refill
0023C0r 3               
0023C0r 3               @src_not_string:
0023C0r 3                               ; Since we don't have blocks, this must mean that we are trying
0023C0r 3                               ; to read from a file. However, we don't have files yet, so we
0023C0r 3                               ; report an error and jump to ABORT.
0023C0r 3  A9 01                        lda #err_badsource
0023C2r 3  4C rr rr                     jmp error
0023C5r 3               @done:
0023C5r 3  60           z_refill:       rts
0023C6r 3               
0023C6r 3               
0023C6r 3               
0023C6r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
0023C6r 3               ; ## "repeat"  auto  ANS core
0023C6r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
0023C6r 3               
0023C6r 3               xt_repeat:
0023C6r 3                               ; Run again first
0023C6r 3  20 rr rr                     jsr xt_again
0023C9r 3               
0023C9r 3                               ; Stuff HERE in for the branch address
0023C9r 3                               ; to get out of the loop
0023C9r 3  20 rr rr                     jsr xt_here
0023CCr 3  20 rr rr                     jsr xt_swap
0023CFr 3  20 rr rr                     jsr xt_store
0023D2r 3               
0023D2r 3  60           z_repeat:       rts
0023D3r 3               
0023D3r 3               
0023D3r 3               
0023D3r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
0023D3r 3               ; ## "]"  auto  ANS core
0023D3r 3                       ; """https://forth-standard.org/standard/right-bracket
0023D3r 3                       ; This is an immediate word.
0023D3r 3                       ; """
0023D3r 3               xt_right_bracket:
0023D3r 3  A9 FF                        lda #$FF
0023D5r 3  85 16                        sta state
0023D7r 3  85 17                        sta state+1
0023D9r 3               z_right_bracket:
0023D9r 3  60                           rts
0023DAr 3               
0023DAr 3               
0023DAr 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
0023DAr 3               ; ## "root-wordlist"  tested  Tali Editor
0023DAr 3               xt_root_wordlist:
0023DAr 3  CA                           dex             ; The WID for the Root wordlist is 3.
0023DBr 3  CA                           dex
0023DCr 3  A9 03                        lda #3
0023DEr 3  95 00                        sta 0,x
0023E0r 3  74 01                        stz 1,x
0023E2r 3               
0023E2r 3               z_root_wordlist:
0023E2r 3  60                           rts
0023E3r 3               
0023E3r 3               
0023E3r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
0023E3r 3               ; ## "rot"  auto  ANS core
0023E3r 3                       ; """https://forth-standard.org/standard/core/ROT
0023E3r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
0023E3r 3                       ; on top!
0023E3r 3                       ; """
0023E3r 3               
0023E3r 3               xt_rot:
0023E3r 3  20 rr rr                     jsr underflow_3
0023E6r 3               
0023E6r 3  B4 05                        ldy 5,x         ; MSB first
0023E8r 3  B5 03                        lda 3,x
0023EAr 3  95 05                        sta 5,x
0023ECr 3  B5 01                        lda 1,x
0023EEr 3  95 03                        sta 3,x
0023F0r 3  94 01                        sty 1,x
0023F2r 3               
0023F2r 3  B4 04                        ldy 4,x         ; LSB next
0023F4r 3  B5 02                        lda 2,x
0023F6r 3  95 04                        sta 4,x
0023F8r 3  B5 00                        lda 0,x
0023FAr 3  95 02                        sta 2,x
0023FCr 3  94 00                        sty 0,x
0023FEr 3               
0023FEr 3  60           z_rot:          rts
0023FFr 3               
0023FFr 3               
0023FFr 3               
0023FFr 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
0023FFr 3               ; ## "rshift"  auto  ANS core
0023FFr 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
0023FFr 3               xt_rshift:
0023FFr 3  20 rr rr                     jsr underflow_2
002402r 3               
002402r 3                               ; We shift maximal by 16 bits, mask everything else
002402r 3  B5 00                        lda 0,x
002404r 3  29 0F                        and #%00001111
002406r 3  F0 08                        beq @done               ; if 0 shifts, quit
002408r 3               
002408r 3  A8                           tay
002409r 3               @loop:
002409r 3  56 03                        lsr 3,x
00240Br 3  76 02                        ror 2,x
00240Dr 3  88                           dey
00240Er 3  D0 F9                        bne @loop
002410r 3               @done:
002410r 3  E8                           inx
002411r 3  E8                           inx
002412r 3               
002412r 3  60           z_rshift:       rts
002413r 3               
002413r 3               
002413r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002413r 3               ; ## "s\""  auto  ANS core
002413r 3                       ; """https://forth-standard.org/standard/core/Seq
002413r 3                       ; Store address and length of string given, returning ( addr u ).
002413r 3                       ; ANS core claims this is compile-only, but the file set expands it
002413r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002413r 3                       ; are evil. We follow general usage. This is just like S" except
002413r 3                       ; that it allows for some special escaped characters.
002413r 3                       ; """
002413r 3               
002413r 3               xt_s_backslash_quote:
002413r 3                               ; tmp2 will be used to determine if we are handling
002413r 3                               ; escaped characters or not. In this case, we are,
002413r 3                               ; so set it to $FF (the upper byte will be used to
002413r 3                               ; determine if we just had a \ and the next character
002413r 3                               ; needs to be modifed as an escaped character).
002413r 3  A9 FF                        lda #$FF
002415r 3  85 26                        sta tmp2
002417r 3  64 27                        stz tmp2+1
002419r 3               
002419r 3                               ; Now that the flag is set, jump into s_quote to process
002419r 3                               ; the string.
002419r 3  20 rr rr                     jsr s_quote_start
00241Cr 3               @done:
00241Cr 3               z_s_backslash_quote:
00241Cr 3  60                           rts
00241Dr 3               
00241Dr 3               
00241Dr 3               ; This is a helper function for s_backslash_quote to convert a character
00241Dr 3               ; from ASCII to the corresponding hex value, eg 'F'->15
00241Dr 3               convert_hex_value:
00241Dr 3               
00241Dr 3  C9 41                cmp #'A'
00241Fr 3  90 07                bcc @digit
002421r 3               
002421r 3                       ; It's A-F
002421r 3  29 DF                and #$DF                ; Make it uppercase.
002423r 3  38                   sec
002424r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
002426r 3  80 03                bra @done
002428r 3               
002428r 3               @digit:
002428r 3                       ; It's 0-9
002428r 3  38                   sec
002429r 3  E9 30                sbc #'0'
00242Br 3               
00242Br 3               @done:
00242Br 3  60                   rts
00242Cr 3               
00242Cr 3               
00242Cr 3               
00242Cr 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
00242Cr 3               ; ## "search-wordlist" auto ANS search
00242Cr 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
00242Cr 3               
00242Cr 3               xt_search_wordlist:
00242Cr 3  20 rr rr                     jsr underflow_3
00242Fr 3               
00242Fr 3                               ; Set up tmp1 with the wordlist indicated by wid
00242Fr 3                               ; on the stack. Start by putting the base address
00242Fr 3                               ; of the wordlists in tmp2.
00242Fr 3  A5 1E                        lda up
002431r 3  18                           clc
002432r 3  69 06                        adc #wordlists_offset
002434r 3  85 26                        sta tmp2
002436r 3  A5 1F                        lda up+1
002438r 3  69 00                        adc #0          ; Adding carry
00243Ar 3  85 27                        sta tmp2+1
00243Cr 3               
00243Cr 3                               ; Add the wid (in cells) to the base address.
00243Cr 3  B5 00                        lda 0,x
00243Er 3  0A                           asl             ; Convert wid to offset in cells (x2)
00243Fr 3  65 26                        adc tmp2
002441r 3  85 26                        sta tmp2
002443r 3  90 02                        bcc @1
002445r 3  E6 27                        inc tmp2+1      ; Propagate carry if needed.
002447r 3               
002447r 3                               ; tmp2 now holds the address of the dictionary pointer
002447r 3                               ; for the given wordlist.
002447r 3               @1:
002447r 3                               ; Remove the wid from the stack.
002447r 3  E8                           inx
002448r 3  E8                           inx
002449r 3               
002449r 3                               ; check for special case of an empty string (length zero)
002449r 3  B5 00                        lda 0,x
00244Br 3  15 01                        ora 1,x
00244Dr 3  D0 03                        bne @check_wordlist
00244Fr 3  4C rr rr                     jmp @done
002452r 3               
002452r 3               @check_wordlist:
002452r 3                               ; Check for special case of empty wordlist
002452r 3                               ; (dictionary pointer, in tmp2, is 0)
002452r 3  A5 26                        lda tmp2
002454r 3  05 27                        ora tmp2+1
002456r 3  D0 03                        bne @have_string
002458r 3  4C rr rr                     jmp @done
00245Br 3               
00245Br 3               @have_string:
00245Br 3                               ; set up first loop iteration
00245Br 3  B2 26                        lda (tmp2)              ; nt of first word in Dictionary
00245Dr 3  85 24                        sta tmp1
00245Fr 3               
00245Fr 3  E6 26                        inc tmp2                ; Move to the upper byte
002461r 3  D0 02                        bne @2
002463r 3  E6 27                        inc tmp2+1
002465r 3               @2:
002465r 3  B2 26                        lda (tmp2)
002467r 3  85 25                        sta tmp1+1
002469r 3               
002469r 3                               ; Reuse tmp2 to hold the address of the mystery string.
002469r 3  B5 02                        lda 2,x                 ; Address of mystery string
00246Br 3  85 26                        sta tmp2
00246Dr 3  B5 03                        lda 3,x
00246Fr 3  85 27                        sta tmp2+1
002471r 3               
002471r 3               @loop:
002471r 3                               ; first quick test: Are strings the same length?
002471r 3  B2 24                        lda (tmp1)
002473r 3  D5 00                        cmp 0,x
002475r 3  D0 7B                        bne @next_entry
002477r 3               
002477r 3               @compare_string:
002477r 3                               ; are the same length, so we now have to compare each
002477r 3                               ; character
002477r 3               
002477r 3                               ; second quick test: Is the first character the same?
002477r 3  B2 26                        lda (tmp2)      ; first character of mystery string
002479r 3               
002479r 3                               ; Lowercase the incoming charcter.
002479r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
00247Br 3  B0 07                        bcs @compare_first
00247Dr 3  C9 41                        cmp #$41        ; ASCII 'A'
00247Fr 3  90 03                        bcc @compare_first
002481r 3               
002481r 3                               ; An uppercase letter has been located.  Make it
002481r 3                               ; lowercase.
002481r 3  18                           clc
002482r 3  69 20                        adc #$20
002484r 3               
002484r 3               @compare_first:
002484r 3  A0 08                        ldy #8          ; Offset in nt to name
002486r 3  D1 24                        cmp (tmp1),y    ; first character of current word
002488r 3  D0 68                        bne @next_entry
00248Ar 3               
00248Ar 3                               ; string length are the same and the first character is the
00248Ar 3                               ; same. If the length of the string is 1, we're already done
00248Ar 3  B5 00                        lda 0,x
00248Cr 3  3A                           dec
00248Dr 3  F0 2C                        beq @success
00248Fr 3               
00248Fr 3                               ; No such luck: The strings are the same length and the first
00248Fr 3                               ; char is the same, but the word is more than one char long.
00248Fr 3                               ; So we suck it up and compare every single character. We go
00248Fr 3                               ; from back to front, because words like CELLS and CELL+ would
00248Fr 3                               ; take longer otherwise. We can also shorten the loop by one
00248Fr 3                               ; because we've already compared the first char.
00248Fr 3               
00248Fr 3                               ; The string of the word we're testing against is 8 bytes down
00248Fr 3  A5 24                        lda tmp1
002491r 3  48                           pha             ; Preserve tmp1 on the return stack.
002492r 3  18                           clc
002493r 3  69 08                        adc #8
002495r 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
002497r 3  A5 25                        lda tmp1+1
002499r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
00249Ar 3  69 00                        adc #0          ; we only need the carry
00249Cr 3  85 25                        sta tmp1+1
00249Er 3               
00249Er 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0024A0r 3  88                           dey
0024A1r 3               
0024A1r 3               @string_loop:
0024A1r 3  B1 26                        lda (tmp2),y    ; last char of mystery string
0024A3r 3               
0024A3r 3                               ; Lowercase the incoming charcter.
0024A3r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0024A5r 3  B0 07                        bcs @check_char
0024A7r 3  C9 41                        cmp #$41        ; ASCII 'A'
0024A9r 3  90 03                        bcc @check_char
0024ABr 3               
0024ABr 3                               ; An uppercase letter has been located.  Make it
0024ABr 3                               ; lowercase.
0024ABr 3  18                           clc
0024ACr 3  69 20                        adc #$20
0024AEr 3               @check_char:
0024AEr 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
0024B0r 3  D0 3A                        bne @next_entry_tmp1
0024B2r 3               
0024B2r 3  88                           dey
0024B3r 3  D0 EC                        bne @string_loop
0024B5r 3               
0024B5r 3               @success_tmp1:
0024B5r 3  68                           pla             ; Restore tmp1 from the return stack.
0024B6r 3  85 25                        sta tmp1+1
0024B8r 3  68                           pla
0024B9r 3  85 24                        sta tmp1
0024BBr 3               
0024BBr 3               @success:
0024BBr 3                               ; The strings match. Drop the count and put correct nt TOS
0024BBr 3  E8                           inx
0024BCr 3  E8                           inx
0024BDr 3  A5 24                        lda tmp1
0024BFr 3  95 00                        sta 0,x
0024C1r 3  A5 25                        lda tmp1+1
0024C3r 3  95 01                        sta 1,x
0024C5r 3               
0024C5r 3                               ; Change the nt into an xt, but save a copy of the nt
0024C5r 3                               ; to look up whether the word is immediate or not.
0024C5r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0024C8r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0024CBr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0024CEr 3               
0024CEr 3  A0 00                        ldy #0                  ; Prepare flag
0024D0r 3               
0024D0r 3                               ; The flags are in the second byte of the header
0024D0r 3  F6 00                        inc 0,x
0024D2r 3  D0 02                        bne @3
0024D4r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0024D6r 3               @3:
0024D6r 3  A1 00                        lda (0,x)               ; ( xt char )
0024D8r 3  29 04                        and #IM
0024DAr 3  D0 08                        bne @immediate          ; bit set, we're immediate
0024DCr 3               
0024DCr 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
0024DEr 3  95 00                        sta 0,x
0024E0r 3  95 01                        sta 1,x
0024E2r 3  80 28                        bra @done_nodrop
0024E4r 3               
0024E4r 3               @immediate:
0024E4r 3  A9 01                        lda #1                  ; We're immediate, return 1
0024E6r 3  95 00                        sta 0,x
0024E8r 3  74 01                        stz 1,x
0024EAr 3               
0024EAr 3  80 20                        bra @done_nodrop
0024ECr 3               
0024ECr 3               @next_entry_tmp1:
0024ECr 3  68                           pla             ; Restore tmp1 from the return stack.
0024EDr 3  85 25                        sta tmp1+1
0024EFr 3  68                           pla
0024F0r 3  85 24                        sta tmp1
0024F2r 3               @next_entry:
0024F2r 3                               ; Not the same, so we get the next word. Next header
0024F2r 3                               ; address is two bytes down
0024F2r 3  A0 02                        ldy #2
0024F4r 3  B1 24                        lda (tmp1),y
0024F6r 3  48                           pha
0024F7r 3  C8                           iny
0024F8r 3  B1 24                        lda (tmp1),y
0024FAr 3  85 25                        sta tmp1+1
0024FCr 3  68                           pla
0024FDr 3  85 24                        sta tmp1
0024FFr 3               
0024FFr 3                               ; If we got a zero, we've walked the whole Dictionary and
0024FFr 3                               ; return as a failure, otherwise try again
0024FFr 3  05 25                        ora tmp1+1
002501r 3  F0 03                        beq @fail_done
002503r 3  4C rr rr                     jmp @loop
002506r 3               
002506r 3               @fail_done:
002506r 3  74 02                        stz 2,x         ; failure flag
002508r 3  74 03                        stz 3,x
00250Ar 3               @done:
00250Ar 3  E8                           inx
00250Br 3  E8                           inx
00250Cr 3               @done_nodrop:
00250Cr 3               z_search_wordlist:
00250Cr 3  60                           rts
00250Dr 3               
00250Dr 3               
00250Dr 3               
00250Dr 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
00250Dr 3               ; ## "see" tested  ANS tools
00250Dr 3                       ; """https://forth-standard.org/standard/tools/SEE
00250Dr 3                       ; SEE takes the name of a word and prints its name token (nt),
00250Dr 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
00250Dr 3                       ; code and disassembles it.
00250Dr 3                       ; """
00250Dr 3               
00250Dr 3               xt_see:
00250Dr 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
002510r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
002513r 3               
002513r 3                               ; If we got back a zero we don't know that word and so we quit
002513r 3                               ; with an error
002513r 3  B5 00                        lda 0,x
002515r 3  15 01                        ora 1,x
002517r 3  D0 05                        bne @1
002519r 3               
002519r 3  A9 05                        lda #err_noname
00251Br 3  4C rr rr                     jmp error
00251Er 3               @1:
00251Er 3  20 rr rr                     jsr xt_cr
002521r 3               
002521r 3                               ; We have a legal word, so let's get serious. Save the current
002521r 3                               ; number base and use hexadecimal instead.
002521r 3  A5 18                        lda base
002523r 3  48                           pha
002524r 3  20 rr rr                     jsr xt_hex
002527r 3               
002527r 3  A9 0A                        lda #str_see_nt
002529r 3  20 rr rr                     jsr print_string_no_lf
00252Cr 3               
00252Cr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00252Fr 3  20 rr rr                     jsr xt_u_dot
002532r 3  20 rr rr                     jsr xt_space            ; ( nt )
002535r 3               
002535r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002538r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
00253Br 3               
00253Br 3  A9 0B                        lda #str_see_xt
00253Dr 3  20 rr rr                     jsr print_string_no_lf
002540r 3               
002540r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
002543r 3  20 rr rr                     jsr xt_u_dot
002546r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
002549r 3               
002549r 3                               ; We print letters for flags and then later follow it with 1 or
002549r 3                               ; 0 to mark if which flag is set
002549r 3  A9 09                        lda #str_see_flags
00254Br 3  20 rr rr                     jsr print_string_no_lf
00254Er 3               
00254Er 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
002551r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
002554r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
002557r 3               
002557r 3  B5 00                        lda 0,x
002559r 3               
002559r 3                               ; This is crude, but for the moment it is good enough
002559r 3  A0 06                        ldy #6                  ; Not all bits are used
00255Br 3               @flag_loop:
00255Br 3  48                           pha
00255Cr 3  29 01                        and #%00000001
00255Er 3  18                           clc
00255Fr 3  69 30                        adc #$30                ; ASCII "0"
002561r 3  20 rr rr                     jsr emit_a
002564r 3  20 rr rr                     jsr xt_space
002567r 3               
002567r 3  68                           pla
002568r 3  6A                           ror                     ; Next flag
002569r 3               
002569r 3  88                           dey
00256Ar 3  D0 EF                        bne @flag_loop
00256Cr 3               
00256Cr 3  20 rr rr                     jsr xt_cr
00256Fr 3               
00256Fr 3  E8                           inx
002570r 3  E8                           inx                     ; ( nt xt )
002571r 3               
002571r 3                               ; Figure out the size
002571r 3  A9 0C                        lda #str_see_size
002573r 3  20 rr rr                     jsr print_string_no_lf
002576r 3               
002576r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
002579r 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
00257Cr 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
00257Fr 3  20 rr rr                     jsr xt_decimal
002582r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
002585r 3  20 rr rr                     jsr xt_hex
002588r 3  20 rr rr                     jsr xt_cr
00258Br 3               
00258Br 3                               ; Dump hex and disassemble
00258Br 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
00258Er 3  20 rr rr                     jsr xt_dump
002591r 3  20 rr rr                     jsr xt_cr
002594r 3  20 rr rr                     jsr xt_disasm
002597r 3               
002597r 3  68                           pla
002598r 3  85 18                        sta base
00259Ar 3               
00259Ar 3  60           z_see:          rts
00259Br 3               
00259Br 3               
00259Br 3               
00259Br 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
00259Br 3               ; ## "set-current" auto ANS search
00259Br 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
00259Br 3               
00259Br 3               xt_set_current:
00259Br 3  20 rr rr                     jsr underflow_1
00259Er 3               
00259Er 3                               ; Save the value from the data stack.
00259Er 3  A0 04                        ldy #current_offset
0025A0r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
0025A2r 3  91 1E                        sta (up),y      ; so only the LSB is used.
0025A4r 3               
0025A4r 3  E8                           inx
0025A5r 3  E8                           inx
0025A6r 3               
0025A6r 3  60           z_set_current:  rts
0025A7r 3               
0025A7r 3               
0025A7r 3               
0025A7r 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
0025A7r 3               ; ## "set-order" auto ANS search
0025A7r 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
0025A7r 3               
0025A7r 3               xt_set_order:
0025A7r 3                               ; Test for -1 TOS
0025A7r 3  A9 FF                        lda #$FF
0025A9r 3  D5 01                        cmp 1,x
0025ABr 3  D0 12                        bne @start
0025ADr 3  D5 00                        cmp 0,x
0025AFr 3  D0 0E                        bne @start
0025B1r 3               
0025B1r 3                               ; There is a -1 TOS.  Replace it with the default
0025B1r 3                               ; search order, which is just the FORTH-WORDLIST.
0025B1r 3  CA                           dex             ; Make room for the count.
0025B2r 3  CA                           dex
0025B3r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
0025B5r 3  A9 03                        lda #3
0025B7r 3  95 02                        sta 2,x
0025B9r 3  74 01                        stz 1,x         ; Count is 1.
0025BBr 3  A9 01                        lda #1
0025BDr 3  95 00                        sta 0,x
0025BFr 3               
0025BFr 3                               ; Continue processing with ( forth-wordlist 1 -- )
0025BFr 3               @start:
0025BFr 3                               ; Set #ORDER - the number of wordlists in the search order.
0025BFr 3  A0 1E                        ldy #num_order_offset
0025C1r 3  B5 00                        lda 0,x
0025C3r 3  91 1E                        sta (up),y      ; #ORDER is a byte variable.
0025C5r 3  85 24                        sta tmp1        ; Save a copy for zero check and looping.
0025C7r 3                                               ; Only the low byte is saved in tmp1 as
0025C7r 3                                               ; only 8 wordlists are allowed.
0025C7r 3               
0025C7r 3  E8                           inx             ; Drop the count off the data stack.
0025C8r 3  E8                           inx
0025C9r 3               
0025C9r 3                               ; Check if there are zero wordlists.
0025C9r 3  A5 24                        lda tmp1
0025CBr 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
0025CDr 3               
0025CDr 3                               ; Move the wordlist ids from the data stack to the search order.
0025CDr 3  A0 1F                        ldy #search_order_offset
0025CFr 3               @loop:
0025CFr 3                               ; Move one wordlist id over into the search order.
0025CFr 3  B5 00                        lda 0,x         ; The search order is a byte array
0025D1r 3  91 1E                        sta (up),y      ; so only save the LSB
0025D3r 3  C8                           iny
0025D4r 3               
0025D4r 3                               ; Remove it from the data stack.
0025D4r 3  E8                           inx
0025D5r 3  E8                           inx
0025D6r 3               
0025D6r 3                               ; See if that was the last one to process (first in the list).
0025D6r 3  C6 24                        dec tmp1
0025D8r 3  D0 F5                        bne @loop
0025DAr 3               
0025DAr 3               @done:
0025DAr 3  60           z_set_order:    rts
0025DBr 3               
0025DBr 3               
0025DBr 3               
0025DBr 3               
0025DBr 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
0025DBr 3               ; ## "s""  auto  ANS core
0025DBr 3                       ; """https://forth-standard.org/standard/core/Sq
0025DBr 3                       ; Store address and length of string given, returning ( addr u ).
0025DBr 3                       ; ANS core claims this is compile-only, but the file set expands it
0025DBr 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
0025DBr 3                       ; are evil. We follow general usage.
0025DBr 3                       ;
0025DBr 3                       ; Can also be realized as
0025DBr 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
0025DBr 3                       ; but it is used so much we want it in code.
0025DBr 3                       ; """
0025DBr 3               
0025DBr 3               xt_s_quote:
0025DBr 3                               ; tmp2 will be used to determine if we are handling
0025DBr 3                               ; escaped characters or not.  In this case, we are
0025DBr 3                               ; not, so set it to zero.
0025DBr 3  64 26                        stz tmp2
0025DDr 3  64 27                        stz tmp2+1
0025DFr 3               
0025DFr 3               s_quote_start:
0025DFr 3                               ; Make room on the data stack for the address.
0025DFr 3  CA                           dex
0025E0r 3  CA                           dex
0025E1r 3                               ; Make room on the data stack for the count.
0025E1r 3  CA                           dex
0025E2r 3  CA                           dex
0025E3r 3               
0025E3r 3                               ; Put a jmp over the string data with address to be filled
0025E3r 3                               ; in later.
0025E3r 3  A9 4C                        lda #$4C
0025E5r 3  20 rr rr                     jsr cmpl_a
0025E8r 3               
0025E8r 3                               ; Address to be filled in later, just use $4C for the moment
0025E8r 3  20 rr rr                     jsr cmpl_a
0025EBr 3  20 rr rr                     jsr cmpl_a
0025EEr 3               
0025EEr 3                               ; Save the current value of HERE on the data stack for the
0025EEr 3                               ; address of the string.
0025EEr 3  A5 00                        lda cp
0025F0r 3  95 02                        sta 2,x
0025F2r 3  A5 01                        lda cp+1
0025F4r 3  95 03                        sta 3,x
0025F6r 3               
0025F6r 3               @savechars_loop:
0025F6r 3                               ; Start saving the string into the dictionary up to the
0025F6r 3                               ; ending double quote. First, check to see if the input
0025F6r 3                               ; buffer is empty.
0025F6r 3  A5 0D                        lda toin+1              ; MSB
0025F8r 3  C5 0B                        cmp ciblen+1
0025FAr 3  90 2A                        bcc @input_fine         ; unsigned comparison
0025FCr 3               
0025FCr 3  A5 0C                        lda toin                ; LSB
0025FEr 3  C5 0A                        cmp ciblen
002600r 3  90 24                        bcc @input_fine
002602r 3               
002602r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
002602r 3                               ; which uses tmp2 and tmp3. Save and restore them.
002602r 3  A5 26                        lda tmp2
002604r 3  48                           pha
002605r 3  A5 27                        lda tmp2+1
002607r 3  48                           pha
002608r 3  A5 28                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
00260Ar 3  48                           pha
00260Br 3               
00260Br 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00260Er 3               
00260Er 3  68                           pla
00260Fr 3  85 28                        sta tmp3
002611r 3  68                           pla
002612r 3  85 27                        sta tmp2+1
002614r 3  68                           pla
002615r 3  85 26                        sta tmp2
002617r 3               
002617r 3                               ; Check result of refill.
002617r 3  B5 00                        lda 0,x
002619r 3  15 01                        ora 1,x
00261Br 3  D0 05                        bne @refill_ok
00261Dr 3               
00261Dr 3                               ; Something when wrong with refill.
00261Dr 3  A9 06                        lda #err_refill
00261Fr 3  4C rr rr                     jmp error
002622r 3               
002622r 3               @refill_ok:
002622r 3                               ; Remove the refill flag from the data stack.
002622r 3  E8                           inx
002623r 3  E8                           inx
002624r 3               
002624r 3                               ; For refill success, jump back up to the empty check, just in
002624r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
002624r 3                               ; input)
002624r 3  80 D0                        bra @savechars_loop
002626r 3               
002626r 3               @input_fine:
002626r 3                               ; There should be at least one valid char to use.
002626r 3                               ; Calculate it's address at CIB+TOIN into tmp1
002626r 3  A5 08                        lda cib
002628r 3  18                           clc
002629r 3  65 0C                        adc toin        ; LSB
00262Br 3  85 24                        sta tmp1
00262Dr 3  A5 09                        lda cib+1
00262Fr 3  65 0D                        adc toin+1      ; MSB
002631r 3  85 25                        sta tmp1+1
002633r 3               
002633r 3                               ; Get the character
002633r 3  B2 24                        lda (tmp1)
002635r 3               
002635r 3                               ; Check to see if we are handling escaped characters.
002635r 3  24 26                        bit tmp2
002637r 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
002639r 3  4C rr rr                     jmp @regular_char
00263Cr 3               
00263Cr 3               @handle_escapes:
00263Cr 3                               ; We are handling escaped characters.  See if we have
00263Cr 3                               ; already seen the backslash.
00263Cr 3  24 27                        bit tmp2+1
00263Er 3  30 03                        bmi @escaped
002640r 3  4C rr rr                     jmp @not_escaped
002643r 3               
002643r 3               @escaped:
002643r 3               
002643r 3                               ; We have seen a backslash (previous character). Check to see if
002643r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
002643r 3                               ; be clear in that case )
002643r 3  70 22                        bvs @check_esc_chars
002645r 3               
002645r 3                               ; We are in the middle of a \x sequence. Check to see if we
002645r 3                               ; are on the first or second digit.
002645r 3  A9 01                        lda #1
002647r 3  24 27                        bit tmp2+1
002649r 3  D0 10                        bne @esc_x_second_digit
00264Br 3               
00264Br 3                               ; First digit.
00264Br 3  E6 27                        inc tmp2+1  ; Adjust flag for second digit next time.
00264Dr 3  B2 24                        lda (tmp1)  ; Get the char again.
00264Fr 3               
00264Fr 3                               ; Convert to hex
00264Fr 3  20 rr rr                     jsr convert_hex_value
002652r 3               
002652r 3                               ; This is the upper nybble, so move it up.
002652r 3  0A                           asl
002653r 3  0A                           asl
002654r 3  0A                           asl
002655r 3  0A                           asl
002656r 3  85 28                        sta tmp3    ; Save it for later.
002658r 3  4C rr rr                     jmp @next_character
00265Br 3               
00265Br 3               @esc_x_second_digit:
00265Br 3               
00265Br 3                               ; We are on the second hex digit of a \x sequence. Clear the
00265Br 3                               ; escaped character flag (because we are handling it right
00265Br 3                               ; here)
00265Br 3  64 27                        stz tmp2+1
00265Dr 3  B2 24                        lda (tmp1)
00265Fr 3               
00265Fr 3                               ; Convert to hex, combine with value in tmp3
00265Fr 3  20 rr rr                     jsr convert_hex_value
002662r 3  05 28                        ora tmp3
002664r 3               
002664r 3  4C rr rr                     jmp @save_character
002667r 3               
002667r 3               @check_esc_chars:
002667r 3                               ; Clear the escaped character flag (because we are
002667r 3                               ; handling it right here)
002667r 3  64 27                        stz tmp2+1
002669r 3               
002669r 3                               ; Process the escaped character
002669r 3               @check_esc_a:
002669r 3  C9 61                        cmp #'a'
00266Br 3  D0 05                        bne @check_esc_b
00266Dr 3               
00266Dr 3                               ; BEL (ASCII value 7)
00266Dr 3  A9 07                        lda #7
00266Fr 3  4C rr rr                     jmp @save_character
002672r 3               
002672r 3               @check_esc_b:
002672r 3  C9 62                        cmp #'b'
002674r 3  D0 05                        bne @check_esc_e
002676r 3               
002676r 3                               ; Backspace (ASCII value 8)
002676r 3  A9 08                        lda #8
002678r 3  4C rr rr                     jmp @save_character
00267Br 3               
00267Br 3               @check_esc_e:
00267Br 3  C9 65                        cmp #'e'
00267Dr 3  D0 04                        bne @check_esc_f
00267Fr 3               
00267Fr 3                               ; ESC (ASCII value 27)
00267Fr 3  A9 1B                        lda #27
002681r 3  80 75                        bra @save_character
002683r 3               
002683r 3               @check_esc_f:
002683r 3  C9 66                        cmp #'f'
002685r 3  D0 04                        bne @check_esc_l
002687r 3               
002687r 3                               ; FF (ASCII value 12)
002687r 3  A9 0C                        lda #12
002689r 3  80 6D                        bra @save_character
00268Br 3               
00268Br 3               @check_esc_l:
00268Br 3  C9 6C                        cmp #'l'
00268Dr 3  D0 04                        bne @check_esc_m
00268Fr 3               
00268Fr 3                               ; LF (ASCII value 10)
00268Fr 3  A9 0A                        lda #10
002691r 3  80 65                        bra @save_character
002693r 3               
002693r 3               @check_esc_m:
002693r 3                               ; This one is not like the others because we save two
002693r 3                               ; characters
002693r 3  C9 6D                        cmp #'m'
002695r 3  D0 09                        bne @check_esc_n
002697r 3               
002697r 3                               ; CR/LF pair (ASCII values 13, 10)
002697r 3  A9 0D                        lda #13
002699r 3  20 rr rr                     jsr cmpl_a
00269Cr 3  A9 0A                        lda #10
00269Er 3  80 58                        bra @save_character
0026A0r 3               
0026A0r 3               @check_esc_n:
0026A0r 3  C9 6E                        cmp #'n'
0026A2r 3  D0 04                        bne @check_esc_q
0026A4r 3               
0026A4r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
0026A4r 3  A9 0A                        lda #10
0026A6r 3  80 50                        bra @save_character
0026A8r 3               
0026A8r 3               @check_esc_q:
0026A8r 3  C9 71                        cmp #'q'
0026AAr 3  D0 04                        bne @check_esc_r
0026ACr 3               
0026ACr 3                               ; Double quote (ASCII value 34)
0026ACr 3  A9 22                        lda #34
0026AEr 3  80 48                        bra @save_character
0026B0r 3               
0026B0r 3               @check_esc_r:
0026B0r 3  C9 72                        cmp #'r'
0026B2r 3  D0 04                        bne @check_esc_t
0026B4r 3               
0026B4r 3                               ; CR (ASCII value 13)
0026B4r 3  A9 0D                        lda #13
0026B6r 3  80 40                        bra @save_character
0026B8r 3               
0026B8r 3               @check_esc_t:
0026B8r 3  C9 74                        cmp #'t'
0026BAr 3  D0 04                        bne @check_esc_v
0026BCr 3               
0026BCr 3                               ; Horizontal TAB (ASCII value 9)
0026BCr 3  A9 09                        lda #9
0026BEr 3  80 38                        bra @save_character
0026C0r 3               
0026C0r 3               @check_esc_v:
0026C0r 3  C9 76                        cmp #'v'
0026C2r 3  D0 04                        bne @check_esc_z
0026C4r 3               
0026C4r 3                               ; Vertical TAB (ASCII value 11)
0026C4r 3  A9 0B                        lda #11
0026C6r 3  80 30                        bra @save_character
0026C8r 3               
0026C8r 3               @check_esc_z:
0026C8r 3  C9 7A                        cmp #'z'
0026CAr 3  D0 04                        bne @check_esc_quote
0026CCr 3               
0026CCr 3                               ; NULL (ASCII value 0)
0026CCr 3  A9 00                        lda #0
0026CEr 3  80 28                        bra @save_character
0026D0r 3               
0026D0r 3               @check_esc_quote:
0026D0r 3  C9 22                        cmp #$22
0026D2r 3  D0 04                        bne @check_esc_x
0026D4r 3               
0026D4r 3                               ; Double quote (ASCII value 34)
0026D4r 3  A9 22                        lda #34
0026D6r 3  80 20                        bra @save_character
0026D8r 3               
0026D8r 3               @check_esc_x:
0026D8r 3  C9 78                        cmp #'x'
0026DAr 3  D0 06                        bne @check_esc_backslash
0026DCr 3               
0026DCr 3                               ; This one is difficult. We need to get the next TWO
0026DCr 3                               ; characters (which might require a refill in the middle)
0026DCr 3                               ; and combine them as two hex digits. We do this by
0026DCr 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
0026DCr 3                               ; and using bit 0 to keep track of which digit we are on.
0026DCr 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
0026DEr 3  85 27                        sta tmp2+1
0026E0r 3  80 19                        bra @next_character
0026E2r 3               
0026E2r 3               @check_esc_backslash:
0026E2r 3  C9 5C                        cmp #$5C
0026E4r 3  D0 04                        bne @not_escaped
0026E6r 3               
0026E6r 3                               ; Backslash (ASCII value 92)
0026E6r 3  A9 5C                        lda #92
0026E8r 3  80 0E                        bra @save_character
0026EAr 3               
0026EAr 3               @not_escaped:
0026EAr 3                               ; Check for the backslash to see if we should escape
0026EAr 3                               ; the next char.
0026EAr 3  C9 5C                        cmp #$5C        ; The backslash char
0026ECr 3  D0 06                        bne @regular_char
0026EEr 3               
0026EEr 3                               ; We found a backslash.  Don't save anyhing, but set
0026EEr 3                               ; a flag (in tmp2+1) to handle the next char. We don't
0026EEr 3                               ; try to get the next char here as it may require a
0026EEr 3                               ; refill of the input buffer.
0026EEr 3  A9 FF                        lda #$FF
0026F0r 3  85 27                        sta tmp2+1
0026F2r 3  80 07                        bra @next_character
0026F4r 3               
0026F4r 3               @regular_char:
0026F4r 3                               ; Check if the current character is the end of the string.
0026F4r 3  C9 22                        cmp #$22        ; ASCII for "
0026F6r 3  F0 0C                        beq @found_string_end
0026F8r 3               
0026F8r 3               @save_character:
0026F8r 3                               ; If we didn't reach the end of the string, compile this
0026F8r 3                               ; character into the dictionary
0026F8r 3  20 rr rr                     jsr cmpl_a
0026FBr 3               
0026FBr 3               @next_character:
0026FBr 3                               ; Move on to the next character.
0026FBr 3  E6 0C                        inc toin
0026FDr 3  D0 02                        bne @savechars_loop_longjump
0026FFr 3  E6 0D                        inc toin+1
002701r 3               
002701r 3               @savechars_loop_longjump:
002701r 3  4C rr rr                     jmp @savechars_loop
002704r 3               
002704r 3               @found_string_end:
002704r 3                               ; Use up the delimiter.
002704r 3  E6 0C                        inc toin
002706r 3  D0 02                        bne @1
002708r 3  E6 0D                        inc toin+1
00270Ar 3               @1:
00270Ar 3                               ; Calculate the length of the string, which is the
00270Ar 3                               ; difference between cp and the address of the start
00270Ar 3                               ; of the string (currently saved on the stack).
00270Ar 3  A5 00                        lda cp
00270Cr 3  38                           sec
00270Dr 3  F5 02                        sbc 2,x
00270Fr 3  95 00                        sta 0,x         ; LSB
002711r 3  A5 01                        lda cp+1
002713r 3  F5 03                        sbc 3,x
002715r 3  95 01                        sta 1,x         ; MSB
002717r 3               
002717r 3                               ; Update the address of the jump-over jmp instruction.
002717r 3                               ; First determine location of jmp instructions address.
002717r 3                               ; It should be 2 bytes before the start of the string.
002717r 3                               ; Compute it into tmp1, which is no longer being used.
002717r 3  B5 02                        lda 2,x
002719r 3  38                           sec
00271Ar 3  E9 02                        sbc #2
00271Cr 3  85 24                        sta tmp1
00271Er 3  B5 03                        lda 3,x
002720r 3  E9 00                        sbc #0          ; Propagate borrow
002722r 3  85 25                        sta tmp1+1
002724r 3               
002724r 3                               ; Update the address of the jump to HERE.
002724r 3  A5 00                        lda cp
002726r 3  92 24                        sta (tmp1)
002728r 3  A0 01                        ldy #1
00272Ar 3  A5 01                        lda cp+1
00272Cr 3  91 24                        sta (tmp1),y
00272Er 3               
00272Er 3                               ; What happens next depends on the state (which is bad, but
00272Er 3                               ; that's the way it works at the moment). If we are
00272Er 3                               ; interpretating, we save the string to a transient buffer
00272Er 3                               ; and return that address (used for file calls, see
00272Er 3                               ; https://forth-standard.org/standard/file/Sq . If we're
00272Er 3                               ; compiling, we just need SLITERAL
00272Er 3  A5 16                        lda state
002730r 3  05 17                        ora state+1             ; paranoid
002732r 3  F0 03                        beq @done
002734r 3               
002734r 3                               ; Jump into the middle of the sliteral word, after the
002734r 3                               ; string data has been compiled into the dictionary,
002734r 3                               ; because we've already done that step.
002734r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
002737r 3               
002737r 3               @done:
002737r 3  60           z_s_quote:      rts
002738r 3               
002738r 3               
002738r 3               
002738r 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
002738r 3               ; ## "s>d"  auto  ANS core
002738r 3                       ; """https://forth-standard.org/standard/core/StoD"""
002738r 3               
002738r 3               xt_s_to_d:
002738r 3  20 rr rr                     jsr underflow_1
00273Br 3               
00273Br 3  CA                           dex
00273Cr 3  CA                           dex
00273Dr 3  74 00                        stz 0,x
00273Fr 3  74 01                        stz 1,x
002741r 3               
002741r 3  B5 03                        lda 3,x
002743r 3  10 04                        bpl @done
002745r 3               
002745r 3                               ; negative, extend sign
002745r 3  D6 00                        dec 0,x
002747r 3  D6 01                        dec 1,x
002749r 3               @done:
002749r 3  60           z_s_to_d:       rts
00274Ar 3               
00274Ar 3               
00274Ar 3               
00274Ar 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
00274Ar 3               ; ## "save-buffers"  tested  ANS block
00274Ar 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
00274Ar 3               
00274Ar 3               xt_save_buffers:
00274Ar 3                               ; Check the buffer status
00274Ar 3  A0 2C                        ldy #buffstatus_offset
00274Cr 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
00274Er 3  C9 03                        cmp #3          ; LSB is needed.
002750r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
002752r 3               
002752r 3                               ; We need to save the block.
002752r 3  20 rr rr                     jsr xt_blkbuffer
002755r 3  20 rr rr                     jsr xt_buffblocknum
002758r 3  20 rr rr                     jsr xt_fetch
00275Br 3  20 rr rr                     jsr xt_block_write
00275Er 3               
00275Er 3                               ; Mark the buffer as clean now.
00275Er 3  A9 01                        lda #1
002760r 3  A0 2C                        ldy #buffstatus_offset
002762r 3  91 1E                        sta (up),y
002764r 3               
002764r 3               @done:
002764r 3  60           z_save_buffers: rts
002765r 3               
002765r 3               
002765r 3               
002765r 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
002765r 3               ; ## "scr"  auto  ANS block ext
002765r 3                       ; """https://forth-standard.org/standard/block/SCR"""
002765r 3               xt_scr:
002765r 3                               ; SCR is at UP + scr_offset
002765r 3  CA                           dex
002766r 3  CA                           dex
002767r 3  18                           clc
002768r 3  A5 1E                        lda up
00276Ar 3  69 02                        adc #scr_offset ; Add offset
00276Cr 3  95 00                        sta 0,x
00276Er 3  A5 1F                        lda up+1
002770r 3  69 00                        adc #0          ; Adding carry
002772r 3  95 01                        sta 1,x
002774r 3               
002774r 3  60           z_scr:          rts
002775r 3               
002775r 3               
002775r 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
002775r 3               ; ## "search"   auto  ANS string
002775r 3                       ; """https://forth-standard.org/standard/string/SEARCH
002775r 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
002775r 3                       ; addr1 u1). If a match is found the flag will be true and
002775r 3                       ; addr3 will have the address of the start of the match and u3 will have
002775r 3                       ; the number of characters remaining from the match point to the end
002775r 3                       ; of the original string1. If a match is not found, the flag will be
002775r 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
002775r 3                       ; """
002775r 3               
002775r 3               xt_search:
002775r 3  20 rr rr                     jsr underflow_4
002778r 3               
002778r 3                               ; ANS says if the second string is a zero-length string it
002778r 3                               ; automatically matches.
002778r 3  B5 00                        lda 0,x
00277Ar 3  15 01                        ora 1,x
00277Cr 3  D0 0B                        bne @start_search
00277Er 3               
00277Er 3                               ; The second string is a zero length string.  Just remove
00277Er 3                               ; the second string and put a true flag.
00277Er 3  E8                           inx             ; Remove u2
00277Fr 3  E8                           inx
002780r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
002782r 3  95 00                        sta 0,x
002784r 3  95 01                        sta 1,x
002786r 3  4C rr rr                     jmp z_search
002789r 3               
002789r 3               @start_search:
002789r 3                               ; Put an offset (starting at zero) on the stack.
002789r 3  20 rr rr                     jsr xt_zero
00278Cr 3               
00278Cr 3               @search_loop:
00278Cr 3                               ; We stop (not found) when u2 + offset > u1
00278Cr 3                               ; Calculate u2+offset into tmp1
00278Cr 3  18                           clc
00278Dr 3  B5 00                        lda 0,x
00278Fr 3  75 02                        adc 2,x
002791r 3  85 24                        sta tmp1
002793r 3  B5 01                        lda 1,x
002795r 3  75 03                        adc 3,x
002797r 3               
002797r 3               
002797r 3                               ; Compare to u1. Start with the high byte
002797r 3  D5 07                        cmp 7,x
002799r 3  90 12                        bcc @init_comparison ; Obviously less
00279Br 3  D0 06                        bne @not_found
00279Dr 3               
00279Dr 3                               ; The upper address byte matched - check the lower byte
00279Dr 3                               ; Load u1 first so we can use just a carry to check.
00279Dr 3  B5 06                        lda 6,x
00279Fr 3  C5 24                        cmp tmp1
0027A1r 3  B0 0A                        bcs @init_comparison
0027A3r 3               
0027A3r 3               @not_found:
0027A3r 3                               ; The substring isn't in the main string.
0027A3r 3                               ; Return just the main string and a false flag.
0027A3r 3  E8                           inx             ; Remove offset
0027A4r 3  E8                           inx
0027A5r 3  E8                           inx             ; Remove u2
0027A6r 3  E8                           inx
0027A7r 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
0027A9r 3  74 01                        stz 1,x
0027ABr 3  80 66                        bra z_search
0027ADr 3               
0027ADr 3               @init_comparison:
0027ADr 3                               ; Use tmp1 to hold address in string 1.
0027ADr 3                               ; Use tmp2 to hold address in string 2.
0027ADr 3                               ; Use tmp3 to hold the number of characters left to check.
0027ADr 3               
0027ADr 3                               ; Compute the starting address in string 1
0027ADr 3                               ; as addr1 + offset
0027ADr 3  18                           clc
0027AEr 3  B5 08                        lda 8,x
0027B0r 3  75 00                        adc 0,x
0027B2r 3  85 24                        sta tmp1
0027B4r 3  B5 09                        lda 9,x
0027B6r 3  75 01                        adc 1,x
0027B8r 3  85 25                        sta tmp1+1
0027BAr 3               
0027BAr 3                               ; The starting address in string 2 is just addr2.
0027BAr 3  B5 04                        lda 4,x
0027BCr 3  85 26                        sta tmp2
0027BEr 3  B5 05                        lda 5,x
0027C0r 3  85 27                        sta tmp2+1
0027C2r 3               
0027C2r 3                               ; The number of characters to check is u2.
0027C2r 3  B5 02                        lda 2,x
0027C4r 3  85 28                        sta tmp3
0027C6r 3  B5 03                        lda 3,x
0027C8r 3  85 29                        sta tmp3+1
0027CAr 3               
0027CAr 3               @comparison_loop:
0027CAr 3                               ; Check to see if the current characters match.
0027CAr 3  B2 24                        lda (tmp1)
0027CCr 3  D2 26                        cmp (tmp2)
0027CEr 3  F0 05                        beq @letters_match
0027D0r 3               
0027D0r 3                               ; One of the letters didn't match.
0027D0r 3                               ; Increment the offset and try again.
0027D0r 3  20 rr rr                     jsr xt_one_plus
0027D3r 3  80 B7                        bra @search_loop
0027D5r 3               
0027D5r 3               @letters_match:
0027D5r 3                               ; The letters match.  Advance the pointers until the
0027D5r 3                               ; count reaches zero.
0027D5r 3  E6 24                        inc tmp1
0027D7r 3  D0 02                        bne @1
0027D9r 3  E6 25                        inc tmp1+1
0027DBr 3               @1:
0027DBr 3  E6 26                        inc tmp2
0027DDr 3  D0 02                        bne @2
0027DFr 3  E6 27                        inc tmp2+1
0027E1r 3               @2:
0027E1r 3                               ; Decrement the count of remaining letters to check.
0027E1r 3  A5 28                        lda tmp3
0027E3r 3  D0 02                        bne @3
0027E5r 3  C6 29                        dec tmp3+1
0027E7r 3               @3:
0027E7r 3  C6 28                        dec tmp3
0027E9r 3               
0027E9r 3                               ; Check if we've reached zero.
0027E9r 3  A5 28                        lda tmp3
0027EBr 3  05 29                        ora tmp3+1
0027EDr 3  D0 DB                        bne @comparison_loop ; Check the next letter
0027EFr 3               
0027EFr 3                               ; We've run out of letters and they all match!
0027EFr 3                               ; Return (addr1+offset) (u1-offset) true
0027EFr 3                               ; Add offset to addr1.
0027EFr 3  18                           clc
0027F0r 3  B5 00                        lda 0,x
0027F2r 3  75 08                        adc 8,x
0027F4r 3  95 08                        sta 8,x
0027F6r 3  B5 01                        lda 1,x
0027F8r 3  75 09                        adc 9,x
0027FAr 3  95 09                        sta 9,x
0027FCr 3               
0027FCr 3                               ; Subtract offset from u1.
0027FCr 3  38                           sec
0027FDr 3  B5 06                        lda 6,x
0027FFr 3  F5 00                        sbc 0,x
002801r 3  95 06                        sta 6,x
002803r 3  B5 07                        lda 7,x
002805r 3  F5 01                        sbc 1,x
002807r 3  95 07                        sta 7,x
002809r 3               
002809r 3                               ; Replace addr2, u2, and offset with a true flag.
002809r 3  E8                           inx             ; drop offset
00280Ar 3  E8                           inx
00280Br 3  E8                           inx             ; drop u2
00280Cr 3  E8                           inx
00280Dr 3  A9 FF                        lda #$FF
00280Fr 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
002811r 3  95 01                        sta 1,x
002813r 3               
002813r 3  60           z_search:       rts
002814r 3               
002814r 3               
002814r 3               
002814r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
002814r 3               ; ## ";"  auto  ANS core
002814r 3                       ; """https://forth-standard.org/standard/core/Semi
002814r 3                       ; End the compilation of a new word into the Dictionary.
002814r 3                       ;
002814r 3                       ; When we
002814r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
002814r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
002814r 3                       ; A Forth definition would be (see "Starting Forth"):
002814r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
002814r 3                       ; practice of Gforth, we warn here if a word has been redefined.
002814r 3                       ; """
002814r 3               
002814r 3               xt_semicolon:
002814r 3                               ; Check if this is a : word or a :NONAME word.
002814r 3  24 20                        bit status
002816r 3  70 11                        bvs @colonword
002818r 3               
002818r 3                               ; This is a :NONAME word - just put an RTS on the end and
002818r 3                               ; the address (held in workword) on the stack.
002818r 3  A9 60                        lda #$60                ; opcode for RTS
00281Ar 3  20 rr rr                     jsr cmpl_a
00281Dr 3               
00281Dr 3  CA                           dex
00281Er 3  CA                           dex
00281Fr 3  A5 04                        lda workword
002821r 3  95 00                        sta 0,x
002823r 3  A5 05                        lda workword+1
002825r 3  95 01                        sta 1,x
002827r 3  80 45                        bra @semicolon_done
002829r 3               
002829r 3               @colonword:
002829r 3                               ; CP is the byte that will be the address we use in the
002829r 3                               ; header as the end-of-compile address (z_word). This is
002829r 3                               ; six bytes down from the header
002829r 3  A0 06                        ldy #6
00282Br 3  A5 00                        lda cp
00282Dr 3  91 04                        sta (workword),y
00282Fr 3  C8                           iny
002830r 3  A5 01                        lda cp+1
002832r 3  91 04                        sta (workword),y
002834r 3               
002834r 3                               ; Allocate one further byte and save the RTS instruction
002834r 3                               ; there
002834r 3  A9 60                        lda #$60                ; opcode for RTS
002836r 3  20 rr rr                     jsr cmpl_a
002839r 3               
002839r 3                               ; Before we formally add the word to the Dictionary, we
002839r 3                               ; check to see if it is already present, and if yes, we
002839r 3                               ; warn the user.
002839r 3               
002839r 3                               ; See if word already in Dictionary.
002839r 3                               ; (STATUS bit 7 will be high as CREATE already
002839r 3                               ;  checked for us.)
002839r 3  24 20                        bit status
00283Br 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
00283Dr 3               
00283Dr 3                               ; We start by putting the string of the
00283Dr 3                               ; word we're defining on the stack
00283Dr 3  CA                           dex
00283Er 3  CA                           dex
00283Fr 3  CA                           dex
002840r 3  CA                           dex
002841r 3               
002841r 3                               ; WORKWORD points to the beginning of the head of our new
002841r 3                               ; word, where the first byte is the length of the string
002841r 3                               ; We can't use LATESTNT because we haven't added the new
002841r 3                               ; word to the Dictionary yet
002841r 3  B2 04                        lda (workword)
002843r 3  95 00                        sta 0,x
002845r 3  74 01                        stz 1,x
002847r 3               
002847r 3                               ; Eight bytes below WORKWORD is the actual beginning of
002847r 3                               ; the string
002847r 3  A5 04                        lda workword
002849r 3  18                           clc
00284Ar 3  69 08                        adc #8
00284Cr 3  95 02                        sta 2,x
00284Er 3  A5 05                        lda workword+1
002850r 3  69 00                        adc #0                  ; only want carry
002852r 3  95 03                        sta 3,x
002854r 3               
002854r 3                               ; This word is already in the Dictionary, so we print a
002854r 3                               ; warning to the user.
002854r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
002856r 3  20 rr rr                     jsr print_string_no_lf
002859r 3               
002859r 3                               ; Now we print the offending word.
002859r 3  20 rr rr                     jsr xt_type
00285Cr 3  20 rr rr                     jsr xt_space
00285Fr 3               
00285Fr 3                               ; Clear bit 7 of status (so future words will print message
00285Fr 3                               ; by defaut)
00285Fr 3  A9 80                        lda #%10000000
002861r 3  14 20                        trb status
002863r 3               
002863r 3               @new_word:
002863r 3                               ; Let's get this over with. Save beginning of our word
002863r 3                               ; as new last word in the Dictionary
002863r 3  A5 04                        lda workword
002865r 3  85 02                        sta dp
002867r 3  A5 05                        lda workword+1
002869r 3  85 03                        sta dp+1
00286Br 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
00286Er 3                                                       ; CURRENT wordlist.
00286Er 3               @semicolon_done:
00286Er 3                               ; Word definition complete. Return compile flag to zero
00286Er 3                               ; to return to interpret mode
00286Er 3  64 16                        stz state
002870r 3  64 17                        stz state+1
002872r 3               
002872r 3  60           z_semicolon:    rts
002873r 3               
002873r 3               
002873r 3               
002873r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
002873r 3               ; ## "sign"  auto  ANS core
002873r 3                       ; """https://forth-standard.org/standard/core/SIGN
002873r 3                       ;
002873r 3                       ; Code based on
002873r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
002873r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
002873r 3                       ; """
002873r 3               
002873r 3               xt_sign:
002873r 3  20 rr rr                     jsr underflow_1
002876r 3               
002876r 3  B5 01                        lda 1,x         ; check MSB of TOS
002878r 3  30 04                        bmi @minus
00287Ar 3               
00287Ar 3  E8                           inx
00287Br 3  E8                           inx
00287Cr 3  80 09                        bra @done
00287Er 3               @minus:
00287Er 3  A9 2D                        lda #$2D        ; ASCII for "-"
002880r 3  95 00                        sta 0,x         ; overwrite TOS
002882r 3  74 01                        stz 1,x         ; paranoid
002884r 3               
002884r 3  20 rr rr                     jsr xt_hold
002887r 3               @done:
002887r 3  60           z_sign:         rts
002888r 3               
002888r 3               
002888r 3               
002888r 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
002888r 3               ; ## "/"  auto  ANS core
002888r 3                       ; """https://forth-standard.org/standard/core/Div
002888r 3                       ;
002888r 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
002888r 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
002888r 3                       ; This code is currently unoptimized. This code without the SLASH
002888r 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
002888r 3                       ; """
002888r 3               
002888r 3               xt_slash:
002888r 3                               ; With all the multiplication going on, it would be hard to
002888r 3                               ; make sure that one of our temporary variables is not
002888r 3                               ; overwritten. We make sure that doesn't happen by taking the
002888r 3                               ; hit of pushing the flag to the 65c02's stack
002888r 3  A9 00                        lda #0
00288Ar 3  48                           pha
00288Br 3  80 03                        bra _common
00288Dr 3               
00288Dr 3               xt_slash_mod:
00288Dr 3                               ; Note that /MOD accesses this code
00288Dr 3  A9 FF                        lda #$FF
00288Fr 3  48                           pha             ; falls through to _common
002890r 3               
002890r 3               _common:
002890r 3  20 rr rr                     jsr xt_to_r             ; >R
002893r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
002896r 3  20 rr rr                     jsr xt_r_from           ; R>
002899r 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
00289Cr 3               
00289Cr 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
00289Cr 3                               ; $FF is SLASH MOD
00289Cr 3  68                           pla
00289Dr 3  D0 05                        bne @done
00289Fr 3               
00289Fr 3                               ; The following code is for SLASH only
00289Fr 3  20 rr rr                     jsr xt_swap
0028A2r 3  E8                           inx             ; DROP
0028A3r 3  E8                           inx
0028A4r 3               @done:
0028A4r 3               z_slash_mod:
0028A4r 3  60           z_slash:        rts
0028A5r 3               
0028A5r 3               
0028A5r 3               
0028A5r 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
0028A5r 3               ; ## "/mod"  auto  ANS core
0028A5r 3                       ; """https://forth-standard.org/standard/core/DivMOD
0028A5r 3                       ;
0028A5r 3                       ; This is a dummy entry, the actual code is shared with SLASH
0028A5r 3                       ; """
0028A5r 3               
0028A5r 3               
0028A5r 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
0028A5r 3               ; ## "/string"  auto  ANS string
0028A5r 3                       ; """https://forth-standard.org/standard/string/DivSTRING
0028A5r 3                       ;
0028A5r 3                       ; Forth code is
0028A5r 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
0028A5r 3                       ; Put differently, we need to add TOS and 3OS, and subtract
0028A5r 3                       ; TOS from NOS, and then drop TOS
0028A5r 3                       ; """
0028A5r 3               
0028A5r 3               xt_slash_string:
0028A5r 3  20 rr rr                     jsr underflow_3
0028A8r 3               
0028A8r 3  18                           clc             ; 3OS+TOS
0028A9r 3  B5 00                        lda 0,x
0028ABr 3  75 04                        adc 4,x
0028ADr 3  95 04                        sta 4,x
0028AFr 3               
0028AFr 3  B5 01                        lda 1,x
0028B1r 3  75 05                        adc 5,x
0028B3r 3  95 05                        sta 5,x
0028B5r 3               
0028B5r 3  38                           sec             ; NOS-TOS
0028B6r 3  B5 02                        lda 2,x
0028B8r 3  F5 00                        sbc 0,x
0028BAr 3  95 02                        sta 2,x
0028BCr 3               
0028BCr 3  B5 03                        lda 3,x
0028BEr 3  F5 01                        sbc 1,x
0028C0r 3  95 03                        sta 3,x
0028C2r 3               
0028C2r 3  E8                           inx
0028C3r 3  E8                           inx
0028C4r 3               
0028C4r 3  60           z_slash_string: rts
0028C5r 3               
0028C5r 3               
0028C5r 3               
0028C5r 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
0028C5r 3               ; ## "sliteral" auto  ANS string
0028C5r 3                       ; """https://forth-standard.org/standard/string/SLITERAL
0028C5r 3                       ; Add the runtime for an existing string.
0028C5r 3                       ; """
0028C5r 3               
0028C5r 3               xt_sliteral:
0028C5r 3  20 rr rr                     jsr underflow_2
0028C8r 3               
0028C8r 3                               ; We can't assume that ( addr u ) of the current string is in
0028C8r 3                               ; a stable area (eg. already in the dictionary.) Copy the
0028C8r 3                               ; string data into the dictionary using move.
0028C8r 3               
0028C8r 3                               ; Put a jmp over the string data with address to be filled
0028C8r 3                               ; in later.
0028C8r 3  A9 4C                        lda #$4C
0028CAr 3  20 rr rr                     jsr cmpl_a
0028CDr 3               
0028CDr 3                               ; Address to be filled in later.
0028CDr 3  20 rr rr                     jsr cmpl_a
0028D0r 3  20 rr rr                     jsr cmpl_a
0028D3r 3               
0028D3r 3                               ; Turn the data stack from ( addr u ) into
0028D3r 3                               ; ( here u addr here u ) so move can be called with
0028D3r 3                               ; the remaining items on the stack ready for processing.
0028D3r 3                               ; Reserve three extra words on the stack.
0028D3r 3  8A                           txa
0028D4r 3  38                           sec
0028D5r 3  E9 06                        sbc #6
0028D7r 3  AA                           tax
0028D8r 3               
0028D8r 3                               ; Move addr down from TOS-4 to TOS-2
0028D8r 3  B5 08                        lda 8,x
0028DAr 3  95 04                        sta 4,x
0028DCr 3  B5 09                        lda 9,x
0028DEr 3  95 05                        sta 5,x
0028E0r 3               
0028E0r 3                               ; Copy u from TOS-3 to TOS
0028E0r 3  B5 06                        lda 6,x
0028E2r 3  95 00                        sta 0,x
0028E4r 3  B5 07                        lda 7,x
0028E6r 3  95 01                        sta 1,x
0028E8r 3               
0028E8r 3                               ; Put HERE into TOS-1 and TOS-4
0028E8r 3  A5 00                        lda cp
0028EAr 3  95 08                        sta 8,x
0028ECr 3  95 02                        sta 2,x
0028EEr 3  A5 01                        lda cp+1
0028F0r 3  95 09                        sta 9,x
0028F2r 3  95 03                        sta 3,x
0028F4r 3               
0028F4r 3                               ; Copy the string into the dictionary.
0028F4r 3  20 rr rr                     jsr xt_move
0028F7r 3               
0028F7r 3                               ; Update cp.
0028F7r 3  18                           clc
0028F8r 3  A5 00                        lda cp
0028FAr 3  75 00                        adc 0,x
0028FCr 3  85 00                        sta cp
0028FEr 3  A5 01                        lda cp+1
002900r 3  75 01                        adc 1,x
002902r 3  85 01                        sta cp+1
002904r 3               
002904r 3                               ; Update the address of the jump-over jmp instruction.
002904r 3                               ; First determine location of jmp instructions address.
002904r 3                               ; It should be 2 bytes before the start of the string.
002904r 3               
002904r 3                               ; Compute it into tmp1, which is no longer being used.
002904r 3  B5 02                        lda 2,x
002906r 3  38                           sec
002907r 3  E9 02                        sbc #2
002909r 3  85 24                        sta tmp1
00290Br 3  B5 03                        lda 3,x
00290Dr 3  E9 00                        sbc #0          ; Propagate borrow
00290Fr 3  85 25                        sta tmp1+1
002911r 3               
002911r 3                               ; Update the address of the jump to HERE.
002911r 3  A5 00                        lda cp
002913r 3  92 24                        sta (tmp1)
002915r 3  A0 01                        ldy #1
002917r 3  A5 01                        lda cp+1
002919r 3  91 24                        sta (tmp1),y
00291Br 3               
00291Br 3                               ; Stack is now ( addr2 u ) where addr2 is the new
00291Br 3                               ; location in the dictionary.
00291Br 3               
00291Br 3               sliteral_const_str:
00291Br 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
00291Br 3                               ; pushes the new ( addr u ) pair to the Data Stack.
00291Br 3                               ; When we're done, the code will look like this:
00291Br 3               
00291Br 3                               ; xt -->    jmp a
00291Br 3                               ;           <string data bytes>
00291Br 3                               ;  a -->    jsr sliteral_runtime
00291Br 3                               ;           <string address>
00291Br 3                               ;           <string length>
00291Br 3                               ; rts -->
00291Br 3               
00291Br 3                               ; This means we'll have to adjust the return address for two
00291Br 3                               ; cells, not just one
00291Br 3  A0 rr                        ldy #>sliteral_runtime
00291Dr 3  A9 rr                        lda #<sliteral_runtime
00291Fr 3  20 rr rr                     jsr cmpl_subroutine
002922r 3               
002922r 3                               ; We want to have the address end up as NOS and the length
002922r 3                               ; as TOS, so we store the address first
002922r 3  B4 03                        ldy 3,x                ; address MSB
002924r 3  B5 02                        lda 2,x                ; address LSB
002926r 3  20 rr rr                     jsr cmpl_word
002929r 3               
002929r 3  B4 01                        ldy 1,x                ; length MSB
00292Br 3  B5 00                        lda 0,x                ; length LSB
00292Dr 3  20 rr rr                     jsr cmpl_word
002930r 3               
002930r 3                               ; clean up and leave
002930r 3  E8                           inx
002931r 3  E8                           inx
002932r 3  E8                           inx
002933r 3  E8                           inx
002934r 3               
002934r 3  60           z_sliteral:     rts
002935r 3               
002935r 3               
002935r 3               sliteral_runtime:
002935r 3               
002935r 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
002935r 3                       ; the Data Stack. We arrive here with the return address as the
002935r 3                       ; top of Return Stack, which points to the address of the string
002935r 3                       ; """
002935r 3  CA                           dex
002936r 3  CA                           dex
002937r 3  CA                           dex
002938r 3  CA                           dex
002939r 3               
002939r 3                               ; Get the address of the string address off the stack and
002939r 3                               ; increase by one because of the RTS mechanics
002939r 3  68                           pla
00293Ar 3  85 24                        sta tmp1        ; LSB of address
00293Cr 3  68                           pla
00293Dr 3  85 25                        sta tmp1+1      ; MSB of address
00293Fr 3               
00293Fr 3                               ; Walk through both and save them
00293Fr 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002941r 3  B1 24                        lda (tmp1),y
002943r 3  95 02                        sta 2,x         ; LSB of address
002945r 3  C8                           iny
002946r 3               
002946r 3  B1 24                        lda (tmp1),y
002948r 3  95 03                        sta 3,x         ; MSB of address
00294Ar 3  C8                           iny
00294Br 3               
00294Br 3  B1 24                        lda (tmp1),y
00294Dr 3  95 00                        sta 0,x         ; LSB of length
00294Fr 3  C8                           iny
002950r 3               
002950r 3  B1 24                        lda (tmp1),y
002952r 3  95 01                        sta 1,x         ; MSB of length
002954r 3               
002954r 3                               ; restore return address
002954r 3  18                           clc
002955r 3  A5 24                        lda tmp1
002957r 3  69 04                        adc #4
002959r 3  A8                           tay             ; LSB
00295Ar 3  A5 25                        lda tmp1+1
00295Cr 3  69 00                        adc #0          ; we only need carry
00295Er 3  48                           pha             ; MSB
00295Fr 3  5A                           phy
002960r 3               
002960r 3  60                           rts
002961r 3               
002961r 3               
002961r 3               
002961r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002961r 3               ; ## "sm/rem"  auto  ANS core
002961r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002961r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002961r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002961r 3                       ;
002961r 3                       ; Forth:
002961r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002961r 3                       ; R> ?NEGATE SWAP
002961r 3                       ; """
002961r 3               
002961r 3               xt_sm_slash_rem:
002961r 3  20 rr rr                     jsr underflow_3 ; contains double number
002964r 3               
002964r 3                               ; push MSB of high cell of d to Data Stack so we can check
002964r 3                               ; its sign later
002964r 3  B5 03                        lda 3,x
002966r 3  48                           pha
002967r 3               
002967r 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
002967r 3                               ; its sign later as well
002967r 3  B5 01                        lda 1,x
002969r 3  55 03                        eor 3,x
00296Br 3  48                           pha
00296Cr 3               
00296Cr 3                               ; Prepare division by getting absolute of n1 and d
00296Cr 3  20 rr rr                     jsr xt_abs
00296Fr 3  E8                           inx             ; pretend we pushed n1 to R
002970r 3  E8                           inx
002971r 3               
002971r 3  20 rr rr                     jsr xt_dabs
002974r 3  CA                           dex
002975r 3  CA                           dex
002976r 3               
002976r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
002979r 3               
002979r 3                               ; if the XOR compiled above is negative, negate the
002979r 3                               ; quotient (n3)
002979r 3  68                           pla
00297Ar 3  10 03                        bpl @1
00297Cr 3  20 rr rr                     jsr xt_negate
00297Fr 3               @1:
00297Fr 3                               ; if d was negative, negate the remainder (n2)
00297Fr 3  68                           pla
002980r 3  10 07                        bpl @done
002982r 3               
002982r 3  E8                           inx             ; pretend we pushed quotient to R
002983r 3  E8                           inx
002984r 3  20 rr rr                     jsr xt_negate
002987r 3  CA                           dex
002988r 3  CA                           dex
002989r 3               
002989r 3               @done:
002989r 3  60           z_sm_slash_rem: rts
00298Ar 3               
00298Ar 3               
00298Ar 3               
00298Ar 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
00298Ar 3               ; ## "source"  auto  ANS core
00298Ar 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
00298Ar 3               xt_source:
00298Ar 3                               ; add address
00298Ar 3  CA                           dex
00298Br 3  CA                           dex
00298Cr 3  A5 08                        lda cib
00298Er 3  95 00                        sta 0,x
002990r 3  A5 09                        lda cib+1
002992r 3  95 01                        sta 1,x
002994r 3               
002994r 3                               ; add size
002994r 3  CA                           dex
002995r 3  CA                           dex
002996r 3  A5 0A                        lda ciblen
002998r 3  95 00                        sta 0,x
00299Ar 3  A5 0B                        lda ciblen+1
00299Cr 3  95 01                        sta 1,x
00299Er 3               
00299Er 3  60           z_source:       rts
00299Fr 3               
00299Fr 3               
00299Fr 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
00299Fr 3               ; ## "source-id"  tested  ANS core ext
00299Fr 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
00299Fr 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
00299Fr 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
00299Fr 3                       ; string, and a text file gives the fileid.
00299Fr 3                       ; """
00299Fr 3               xt_source_id:
00299Fr 3  CA                           dex
0029A0r 3  CA                           dex
0029A1r 3               
0029A1r 3  A5 06                        lda insrc
0029A3r 3  95 00                        sta 0,x
0029A5r 3  A5 07                        lda insrc+1
0029A7r 3  95 01                        sta 1,x
0029A9r 3               
0029A9r 3  60           z_source_id:    rts
0029AAr 3               
0029AAr 3               
0029AAr 3               ; ## SPACE ( -- ) "Print a single space"
0029AAr 3               ; ## "space"  auto  ANS core
0029AAr 3                       ; """https://forth-standard.org/standard/core/SPACE"""
0029AAr 3               xt_space:
0029AAr 3  A9 20                        lda #AscSP
0029ACr 3  20 rr rr                     jsr emit_a
0029AFr 3               
0029AFr 3  60           z_space:        rts
0029B0r 3               
0029B0r 3               
0029B0r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
0029B0r 3               ; ## "spaces"  auto  ANS core
0029B0r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
0029B0r 3               
0029B0r 3               xt_spaces:
0029B0r 3  20 rr rr                     jsr underflow_1
0029B3r 3               
0029B3r 3                               ; catch any zero in TOS fast
0029B3r 3  B5 00                        lda 0,x
0029B5r 3  15 01                        ora 1,x
0029B7r 3  F0 2A                        beq @done
0029B9r 3               
0029B9r 3                               ; Usually we're only going to print far less than 256 spaces,
0029B9r 3                               ; so we create a quick loop for that. Short loop could be realized
0029B9r 3                               ; as a separate subroutine, but unless we're really pressed for
0029B9r 3                               ; memory at some point, this is faster
0029B9r 3  B4 01                        ldy 1,x
0029BBr 3  D0 0C                        bne @lots_of_spaces
0029BDr 3               
0029BDr 3  B4 00                        ldy 0,x
0029BFr 3               @quick_loop:
0029BFr 3                               ; we reach here knowing that there must be a number that is not
0029BFr 3                               ; zero in the TOS
0029BFr 3  A9 20                        lda #AscSP
0029C1r 3  20 rr rr                     jsr emit_a
0029C4r 3  88                           dey
0029C5r 3  F0 1C                        beq @done
0029C7r 3  80 F6                        bra @quick_loop
0029C9r 3               
0029C9r 3               @lots_of_spaces:
0029C9r 3                               ; We go through the first loop once to get rid of the lower
0029C9r 3                               ; counter byte. This could be zero
0029C9r 3  B4 00                        ldy 0,x
0029CBr 3               
0029CBr 3               @first_slow_loop:
0029CBr 3  F0 08                        beq @slow_outer_loop
0029CDr 3  A9 20                        lda #AscSP
0029CFr 3  20 rr rr                     jsr emit_a
0029D2r 3  88                           dey
0029D3r 3  80 F6                        bra @first_slow_loop
0029D5r 3               
0029D5r 3               @slow_outer_loop:
0029D5r 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
0029D5r 3  A0 00                        ldy #00
0029D7r 3               
0029D7r 3               @slow_inner_loop:
0029D7r 3  A9 20                        lda #AscSP
0029D9r 3  20 rr rr                     jsr emit_a
0029DCr 3  88                           dey
0029DDr 3  D0 F8                        bne @slow_inner_loop
0029DFr 3               
0029DFr 3  D6 01                        dec 1,x
0029E1r 3  D0 F2                        bne @slow_outer_loop
0029E3r 3               
0029E3r 3               @done:
0029E3r 3  E8                           inx             ; drop
0029E4r 3  E8                           inx
0029E5r 3               
0029E5r 3  60           z_spaces:       rts
0029E6r 3               
0029E6r 3               
0029E6r 3               
0029E6r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
0029E6r 3               ; ## "*"  auto  ANS core
0029E6r 3                       ; """https://forth-standard.org/standard/core/Times
0029E6r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
0029E6r 3                       ;
0029E6r 3                       ; This is nothing  more than UM* DROP
0029E6r 3                       ; """
0029E6r 3               
0029E6r 3               xt_star:
0029E6r 3  20 rr rr                     jsr underflow_2
0029E9r 3               
0029E9r 3  20 rr rr                     jsr xt_um_star
0029ECr 3  E8                           inx
0029EDr 3  E8                           inx
0029EEr 3               
0029EEr 3  60           z_star:         rts
0029EFr 3               
0029EFr 3               
0029EFr 3               
0029EFr 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
0029EFr 3               ; ## "*/"  auto  ANS core
0029EFr 3                       ; """https://forth-standard.org/standard/core/TimesDiv
0029EFr 3                       ; Multiply n1 by n2 and divide by n3, returning the result
0029EFr 3                       ; without a remainder. This is */MOD without the mod.
0029EFr 3                       ;
0029EFr 3                       ; This word
0029EFr 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
0029EFr 3                       ; pretty much what we do here
0029EFr 3                       ; """
0029EFr 3               xt_star_slash:
0029EFr 3                               ; We let */MOD check for underflow
0029EFr 3  20 rr rr                     jsr xt_star_slash_mod
0029F2r 3  20 rr rr                     jsr xt_swap
0029F5r 3  E8                           inx
0029F6r 3  E8                           inx
0029F7r 3               z_star_slash:
0029F7r 3  60                           rts
0029F8r 3               
0029F8r 3               
0029F8r 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
0029F8r 3               ; ## "*/mod"  auto  ANS core
0029F8r 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
0029F8r 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
0029F8r 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
0029F8r 3                       ; single-cell quotient n5.
0029F8r 3                       ;
0029F8r 3                       ; In Forth, this is
0029F8r 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
0029F8r 3                       ; """
0029F8r 3               xt_star_slash_mod:
0029F8r 3  20 rr rr                     jsr underflow_3
0029FBr 3               
0029FBr 3  20 rr rr                     jsr xt_to_r
0029FEr 3  20 rr rr                     jsr xt_m_star
002A01r 3  20 rr rr                     jsr xt_r_from
002A04r 3  20 rr rr                     jsr xt_sm_slash_rem
002A07r 3               
002A07r 3               z_star_slash_mod:
002A07r 3  60                           rts
002A08r 3               
002A08r 3               
002A08r 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002A08r 3               ; ## "state"  auto  ANS core
002A08r 3                       ; """https://forth-standard.org/standard/core/STATE
002A08r 3                       ; STATE is true when in compilation state, false otherwise. Note
002A08r 3                       ; we do not return the state itself, but only the address where
002A08r 3                       ; it lives. The state should not be changed directly by the user; see
002A08r 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002A08r 3                       ; """
002A08r 3               xt_state:
002A08r 3  CA                           dex
002A09r 3  CA                           dex
002A0Ar 3  A9 16                        lda #<state
002A0Cr 3  95 00                        sta 0,x
002A0Er 3  A9 00                        lda #>state
002A10r 3  95 01                        sta 1,x
002A12r 3               
002A12r 3  60           z_state:        rts
002A13r 3               
002A13r 3               
002A13r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002A13r 3               ; ## "!"  auto  ANS core
002A13r 3                       ; """https://forth-standard.org/standard/core/Store"""
002A13r 3               xt_store:
002A13r 3  20 rr rr                     jsr underflow_2
002A16r 3               
002A16r 3  B5 02                        lda 2,x         ; LSB
002A18r 3  81 00                        sta (0,x)
002A1Ar 3               
002A1Ar 3  F6 00                        inc 0,x
002A1Cr 3  D0 02                        bne @1
002A1Er 3  F6 01                        inc 1,x
002A20r 3               @1:
002A20r 3  B5 03                        lda 3,x         ; MSB
002A22r 3  81 00                        sta (0,x)
002A24r 3               
002A24r 3  E8                           inx             ; 2DROP
002A25r 3  E8                           inx
002A26r 3  E8                           inx
002A27r 3  E8                           inx
002A28r 3               
002A28r 3  60           z_store:        rts
002A29r 3               
002A29r 3               
002A29r 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
002A29r 3               ; ## "strip-underflow"  tested  Tali Forth
002A29r 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
002A29r 3                       ; checking should be removed during the compilation of new words.
002A29r 3                       ; Default is false.
002A29r 3                       ; """
002A29r 3               xt_strip_underflow:
002A29r 3  CA                           dex
002A2Ar 3  CA                           dex
002A2Br 3               
002A2Br 3  A9 1C                        lda #<uf_strip
002A2Dr 3  95 00                        sta 0,x
002A2Fr 3  A9 00                        lda #>uf_strip
002A31r 3  95 01                        sta 1,x
002A33r 3               
002A33r 3               z_strip_underflow:
002A33r 3  60                           rts
002A34r 3               
002A34r 3               
002A34r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
002A34r 3               ; ## "swap"  auto  ANS core
002A34r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
002A34r 3               xt_swap:
002A34r 3  20 rr rr                     jsr underflow_2
002A37r 3               
002A37r 3  B5 00                        lda 0,x         ; LSB
002A39r 3  B4 02                        ldy 2,x
002A3Br 3  95 02                        sta 2,x
002A3Dr 3  94 00                        sty 0,x
002A3Fr 3               
002A3Fr 3  B5 01                        lda 1,x         ; MSB
002A41r 3  B4 03                        ldy 3,x
002A43r 3  95 03                        sta 3,x
002A45r 3  94 01                        sty 1,x
002A47r 3               
002A47r 3  60           z_swap:         rts
002A48r 3               
002A48r 3               
002A48r 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
002A48r 3               ; ## "then"  auto  ANS core
002A48r 3                       ; """http://forth-standard.org/standard/core/THEN"""
002A48r 3               xt_then:
002A48r 3                               ; Get the address to jump to.
002A48r 3  20 rr rr                     jsr xt_here
002A4Br 3               
002A4Br 3                               ; Stuff HERE in for the branch address back
002A4Br 3                               ; at the IF or ELSE (origination address is on stack).
002A4Br 3  20 rr rr                     jsr xt_swap
002A4Er 3  20 rr rr                     jsr xt_store
002A51r 3               
002A51r 3  60           z_then:         rts
002A52r 3               
002A52r 3               
002A52r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002A52r 3               ; ## "thru"  tested  ANS block ext
002A52r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002A52r 3               
002A52r 3               xt_thru:
002A52r 3  20 rr rr                     jsr underflow_2
002A55r 3               
002A55r 3                               ; We need to loop here, and can't use the data stack
002A55r 3                               ; because the LOADed screens might use it.  We'll
002A55r 3                               ; need to use the same trick that DO loops use, holding
002A55r 3                               ; the limit and current index on the return stack.
002A55r 3               
002A55r 3                               ; Put the ending screen number on the return stack
002A55r 3  B5 01                        lda 1,x
002A57r 3  48                           pha
002A58r 3  B5 00                        lda 0,x
002A5Ar 3  48                           pha
002A5Br 3  E8                           inx
002A5Cr 3  E8                           inx
002A5Dr 3               @thru_loop:
002A5Dr 3                               ; Put the starting screen number on the stack,
002A5Dr 3                               ; but keep a copy
002A5Dr 3  B5 01                        lda 1,x
002A5Fr 3  48                           pha
002A60r 3  B5 00                        lda 0,x
002A62r 3  48                           pha
002A63r 3               
002A63r 3                               ; Load this screen.
002A63r 3  20 rr rr                     jsr xt_load
002A66r 3               
002A66r 3                               ; Get the number and limit back off the stack.  Rather than
002A66r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
002A66r 3               
002A66r 3                               ; Get the screen we just loaded.
002A66r 3  68                           pla
002A67r 3  85 24                        sta tmp1
002A69r 3  68                           pla
002A6Ar 3  85 25                        sta tmp1+1
002A6Cr 3               
002A6Cr 3                               ; Get the ending screen.
002A6Cr 3  68                           pla
002A6Dr 3  85 26                        sta tmp2
002A6Fr 3  68                           pla
002A70r 3  85 27                        sta tmp2+1
002A72r 3               
002A72r 3                               ; See if we just loaded the last screen.
002A72r 3                               ; A already has the MSB of the last screen in it.
002A72r 3  C5 25                        cmp tmp1+1
002A74r 3  D0 08                        bne @next_screen
002A76r 3  A5 26                        lda tmp2        ; Compare the LSB
002A78r 3  C5 24                        cmp tmp1
002A7Ar 3  D0 02                        bne @next_screen
002A7Cr 3  80 18                        bra @done       ; We just did the last screen.
002A7Er 3               
002A7Er 3               @next_screen:
002A7Er 3                               ; Put the ending screen back on the data stack.
002A7Er 3  A5 27                        lda tmp2+1
002A80r 3  48                           pha
002A81r 3  A5 26                        lda tmp2
002A83r 3  48                           pha
002A84r 3               
002A84r 3                               ; Increment the current screen.
002A84r 3  E6 24                        inc tmp1
002A86r 3  D0 02                        bne @1
002A88r 3  E6 25                        inc tmp1+1
002A8Ar 3               @1:
002A8Ar 3                               ; Put the current screen on the stack to prepare for
002A8Ar 3                               ; the next loop.
002A8Ar 3  CA                           dex
002A8Br 3  CA                           dex
002A8Cr 3  A5 24                        lda tmp1
002A8Er 3  95 00                        sta 0,x
002A90r 3  A5 25                        lda tmp1+1
002A92r 3  95 01                        sta 1,x
002A94r 3  80 C7                        bra @thru_loop
002A96r 3               @done:
002A96r 3  60           z_thru:         rts
002A97r 3               
002A97r 3               
002A97r 3               
002A97r 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
002A97r 3               ; ## "'"  auto  ANS core
002A97r 3                       ; """https://forth-standard.org/standard/core/Tick"""
002A97r 3               
002A97r 3               xt_tick:
002A97r 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002A9Ar 3               
002A9Ar 3                               ; if we got a zero, there was a problem getting the
002A9Ar 3                               ; name of the word
002A9Ar 3  B5 00                        lda 0,x
002A9Cr 3  15 01                        ora 1,x
002A9Er 3  D0 05                        bne @1
002AA0r 3               
002AA0r 3  A9 05                        lda #err_noname
002AA2r 3  4C rr rr                     jmp error
002AA5r 3               @1:
002AA5r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002AA8r 3               
002AA8r 3                               ; If we didn't find the word in the Dictionary, abort
002AA8r 3  B5 00                        lda 0,x
002AAAr 3  15 01                        ora 1,x
002AACr 3  D0 05                        bne @2
002AAEr 3               
002AAEr 3  A9 08                        lda #err_syntax
002AB0r 3  4C rr rr                     jmp error
002AB3r 3               @2:
002AB3r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
002AB6r 3               
002AB6r 3  60           z_tick:         rts
002AB7r 3               
002AB7r 3               
002AB7r 3               
002AB7r 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
002AB7r 3               ; ## "to"  auto  ANS core ext
002AB7r 3                       ; """https://forth-standard.org/standard/core/TO
002AB7r 3                       ; Gives a new value to a, uh, VALUE.
002AB7r 3                       ;
002AB7r 3                       ; One possible Forth
002AB7r 3                       ; implementation is  ' >BODY !  but given the problems we have
002AB7r 3                       ; with >BODY on STC Forths, we do this the hard way. Since
002AB7r 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
002AB7r 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
002AB7r 3                       ;
002AB7r 3                       ; Note that the standard has different behaviors for TO depending
002AB7r 3                       ; on the state (https://forth-standard.org/standard/core/TO).
002AB7r 3                       ; This makes TO state-dependent (which is bad) and also rather
002AB7r 3                       ; complex (see the Gforth implementation for comparison). This
002AB7r 3                       ; word may not be natively compiled and must be immediate. Frankly,
002AB7r 3                       ; it would have made more sense to have two words for this.
002AB7r 3                       ; """
002AB7r 3               
002AB7r 3               xt_to:
002AB7r 3                               ; One way or the other, we need the xt of the word after this
002AB7r 3                               ; one. At this point, we don't know if we are interpreted or
002AB7r 3                               ; compile, so we don't know if there is a value n on the stack,
002AB7r 3                               ; so we can't do an underflow check yet
002AB7r 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002ABAr 3               
002ABAr 3                               ; The PFA (DFA in this case) is three bytes down,
002ABAr 3                               ; after the jump to DOCONST
002ABAr 3  B5 00                        lda 0,x                 ; LSB
002ABCr 3  18                           clc
002ABDr 3  69 03                        adc #3
002ABFr 3  85 24                        sta tmp1
002AC1r 3  B5 01                        lda 1,x                 ; MSB
002AC3r 3  69 00                        adc #0                  ; we just want the carry
002AC5r 3  85 25                        sta tmp1+1
002AC7r 3               
002AC7r 3  E8                           inx
002AC8r 3  E8                           inx                     ; ( [n] )
002AC9r 3               
002AC9r 3                               ; Now it gets ugly. See which state we are in
002AC9r 3  A5 16                        lda state
002ACBr 3  05 17                        ora state+1
002ACDr 3  F0 34                        beq @interpret
002ACFr 3               
002ACFr 3                               ; Well, we're compiling. We want to end up with simple
002ACFr 3                               ; code that just takes the number that is TOS and saves
002ACFr 3                               ; it in the address of the xt we were just given. So we
002ACFr 3                               ; want to compile this routine:
002ACFr 3                               ;
002ACFr 3                               ;       lda 0,x                 - B5 00
002ACFr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002ACFr 3                               ;       lda 1,x                 - B5 01
002ACFr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002ACFr 3                               ;       inx                     - E8
002ACFr 3                               ;       inx                     - E8
002ACFr 3                               ;
002ACFr 3                               ; which at least is nice and short. Other than that, we pretty
002ACFr 3                               ; much have to do this the hard and long way, because with the
002ACFr 3                               ; LSBs and MSBs, we can't really put the numbers in a data
002ACFr 3                               ; range and store them with a loop. Sigh.
002ACFr 3               
002ACFr 3  A0 00                        ldy #$00                ; Code for LDA 0,X
002AD1r 3  A9 B5                        lda #$B5
002AD3r 3  20 rr rr                     jsr cmpl_word
002AD6r 3               
002AD6r 3  A9 8D                        lda #$8D                ; Code for STA abs
002AD8r 3  20 rr rr                     jsr cmpl_a
002ADBr 3               
002ADBr 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
002ADDr 3  A5 24                        lda tmp1
002ADFr 3  20 rr rr                     jsr cmpl_word
002AE2r 3               
002AE2r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
002AE4r 3  A9 B5                        lda #$B5
002AE6r 3  20 rr rr                     jsr cmpl_word
002AE9r 3               
002AE9r 3  A9 8D                        lda #$8D                ; Code for STA abs
002AEBr 3  20 rr rr                     jsr cmpl_a
002AEEr 3               
002AEEr 3  E6 24                        inc tmp1                ; Calculate MSB
002AF0r 3  D0 02                        bne @1
002AF2r 3  E6 25                        inc tmp1+1
002AF4r 3               @1:
002AF4r 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
002AF6r 3  A5 24                        lda tmp1
002AF8r 3  20 rr rr                     jsr cmpl_word
002AFBr 3               
002AFBr 3  A0 E8                        ldy #$E8                ; Code for INX
002AFDr 3  98                           tya
002AFEr 3  20 rr rr                     jsr cmpl_word
002B01r 3               
002B01r 3  80 0F                        bra @done
002B03r 3               
002B03r 3               @interpret:
002B03r 3                               ; We're interpreting, so we arrive here with n
002B03r 3                               ; on the stack. This is an annoying place to put
002B03r 3                               ; the underflow check because we can't
002B03r 3                               ; automatically strip it out
002B03r 3  20 rr rr                     jsr underflow_1
002B06r 3               
002B06r 3                               ; We skip over the jump to DOCONST and store the number
002B06r 3                               ; in the Program Field Area (PDF, in this case more a
002B06r 3                               ; Data Field Area
002B06r 3  B5 00                        lda 0,x
002B08r 3  92 24                        sta (tmp1)              ; LSB
002B0Ar 3               
002B0Ar 3  A0 01                        ldy #1
002B0Cr 3  B5 01                        lda 1,x                 ; MSB
002B0Er 3  91 24                        sta (tmp1),y            ; fall through to common
002B10r 3               
002B10r 3  E8                           inx                     ; DROP
002B11r 3  E8                           inx
002B12r 3               @done:
002B12r 3  60           z_to:           rts
002B13r 3               
002B13r 3               
002B13r 3               
002B13r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002B13r 3               ; ## ">body"  auto  ANS core
002B13r 3                       ; """https://forth-standard.org/standard/core/toBODY
002B13r 3                       ; Given a word's execution token (xt), return the address of the
002B13r 3                       ; start of that word's parameter field (PFA). This is defined as the
002B13r 3                       ; address that HERE would return right after CREATE.
002B13r 3                       ;
002B13r 3                       ; This is a
002B13r 3                       ; difficult word for STC Forths, because most words don't actually
002B13r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002B13r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002B13r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002B13r 3                       ; """
002B13r 3               
002B13r 3               xt_to_body:
002B13r 3  20 rr rr                     jsr underflow_1
002B16r 3               
002B16r 3                               ; Ideally, xt already points to the CFA. We just need to check
002B16r 3                               ; the HC flag for special cases
002B16r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
002B19r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
002B1Cr 3               
002B1Cr 3                               ; The status byte is nt+1
002B1Cr 3  F6 00                        inc 0,x
002B1Er 3  D0 02                        bne @1
002B20r 3  F6 01                        inc 1,x
002B22r 3               @1:
002B22r 3  A1 00                        lda (0,x)               ; get status byte
002B24r 3  29 20                        and #HC
002B26r 3  F0 0D                        beq @no_cfa
002B28r 3               
002B28r 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
002B28r 3                               ; so we add three to xt, which is NOS
002B28r 3  18                           clc
002B29r 3  B5 02                        lda 2,x         ; LSB
002B2Br 3  69 03                        adc #3
002B2Dr 3  95 02                        sta 2,x
002B2Fr 3  B5 03                        lda 3,x         ; MSB
002B31r 3  69 00                        adc #0          ; we conly care about the carry
002B33r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
002B35r 3               @no_cfa:
002B35r 3  E8                           inx             ; get rid of the nt
002B36r 3  E8                           inx
002B37r 3               @done:
002B37r 3  60           z_to_body:      rts
002B38r 3               
002B38r 3               
002B38r 3               
002B38r 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
002B38r 3               ; ## ">in"  auto  ANS core
002B38r 3               xt_to_in:
002B38r 3  CA                           dex
002B39r 3  CA                           dex
002B3Ar 3               
002B3Ar 3  A9 0C                        lda #<toin
002B3Cr 3  95 00                        sta 0,x
002B3Er 3  A9 00                        lda #>toin      ; paranoid, should be zero
002B40r 3  95 01                        sta 1,x
002B42r 3               
002B42r 3  60           z_to_in:        rts
002B43r 3               
002B43r 3               
002B43r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002B43r 3               ; ## ">number"  auto  ANS core
002B43r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002B43r 3                       ; Convert a string to a double number. Logic here is based on the
002B43r 3                       ; routine by Phil Burk of the same name in pForth, see
002B43r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002B43r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002B43r 3                       ; made sure that we don't have to deal with a sign and we don't have
002B43r 3                       ; to deal with a dot as a last character that signalizes double -
002B43r 3                       ; this should be a pure number string.
002B43r 3                       ;
002B43r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002B43r 3                       ; cannot access any of those.
002B43r 3                       ;
002B43r 3                       ; For the math routine, we move the inputs to the scratchpad to
002B43r 3                       ; avoid having to fool around with the Data Stack.
002B43r 3                       ;
002B43r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002B43r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002B43r 3                       ;     |           |           |           |           |
002B43r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002B43r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002B43r 3                       ;
002B43r 3                       ; The math routine works by converting one character to its
002B43r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002B43r 3                       ; the moment. We then multiply the UD-HI value with the radix
002B43r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002B43r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002B43r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002B43r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002B43r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002B43r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002B43r 3                       ; storing the result back in S and S+2, before we start another
002B43r 3                       ; round with it as the new UD-LO and UD-HI.
002B43r 3                       ; """
002B43r 3               
002B43r 3               
002B43r 3               xt_to_number:
002B43r 3  20 rr rr                     jsr underflow_4
002B46r 3               
002B46r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
002B46r 3                               ; After this step, the original ud-lo and ud-hi will still be on
002B46r 3                               ; the Data Stack, but will be ignored and later overwritten
002B46r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
002B46r 3  B5 06                        lda 6,x         ; ud-lo LSB
002B48r 3  85 36                        sta scratch
002B4Ar 3  B5 07                        lda 7,x         ; ud-lo MSB
002B4Cr 3  85 37                        sta scratch+1
002B4Er 3               
002B4Er 3  B5 04                        lda 4,x         ; ud-hi LSB
002B50r 3  85 38                        sta scratch+2
002B52r 3  B5 05                        lda 5,x         ; ud-hi MSB
002B54r 3  85 39                        sta scratch+3
002B56r 3               
002B56r 3                               ; Push down one on the Data Stack to use TOS for character
002B56r 3                               ; conversion ( ud-lo ud-hi addr u x )
002B56r 3  CA                           dex
002B57r 3  CA                           dex
002B58r 3               
002B58r 3               @loop:
002B58r 3                               ; Get one character based on address
002B58r 3  A1 04                        lda (4,x)
002B5Ar 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
002B5Cr 3  74 01                        stz 1,x                 ; paranoid
002B5Er 3               
002B5Er 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002B61r 3               
002B61r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002B61r 3                               ; check the flag. If it is zero, we return what we have and
002B61r 3                               ; let the caller (usually NUMBER) complain
002B61r 3  B5 00                        lda 0,x
002B63r 3  D0 04                        bne @digit_ok
002B65r 3               
002B65r 3  E8                           inx
002B66r 3  E8                           inx
002B67r 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
002B69r 3               
002B69r 3               @digit_ok:
002B69r 3                               ; Conversion was successful. We arrive here with
002B69r 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
002B69r 3                               ; math routine
002B69r 3               
002B69r 3                               ; Save n so we don't have to fool around with the
002B69r 3                               ; Data Stack
002B69r 3  B5 02                        lda 2,x
002B6Br 3  85 3A                        sta scratch+4
002B6Dr 3  B5 03                        lda 3,x
002B6Fr 3  85 3B                        sta scratch+5
002B71r 3               
002B71r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002B71r 3                               ; original one on the Data Stack) with the radix from BASE.
002B71r 3                               ; We can clobber TOS and NOS because we saved n
002B71r 3  A5 38                        lda scratch+2
002B73r 3  95 02                        sta 2,x         ; NOS
002B75r 3  A5 39                        lda scratch+3
002B77r 3  95 03                        sta 3,x
002B79r 3               
002B79r 3  A5 18                        lda base
002B7Br 3  95 00                        sta 0,x         ; TOS
002B7Dr 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002B7Fr 3               
002B7Fr 3                               ; UM* returns a double-celled number
002B7Fr 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002B82r 3               
002B82r 3                               ; Move ud-hi-lo to safety
002B82r 3  B5 02                        lda 2,x         ; ud-hi-lo
002B84r 3  85 3C                        sta scratch+6
002B86r 3  B5 03                        lda 3,x
002B88r 3  85 3D                        sta scratch+7
002B8Ar 3               
002B8Ar 3                               ; Now we multiply ud-lo, overwriting the stack entries
002B8Ar 3  A5 36                        lda scratch
002B8Cr 3  95 02                        sta 2,x
002B8Er 3  A5 37                        lda scratch+1
002B90r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002B92r 3               
002B92r 3  A5 18                        lda base
002B94r 3  95 00                        sta 0,x
002B96r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002B98r 3               
002B98r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002B9Br 3               
002B9Br 3  B5 00                        lda 0,x
002B9Dr 3  85 38                        sta scratch+2
002B9Fr 3  B5 01                        lda 1,x
002BA1r 3  85 39                        sta scratch+3
002BA3r 3               
002BA3r 3  B5 02                        lda 2,x
002BA5r 3  85 36                        sta scratch
002BA7r 3  B5 03                        lda 3,x
002BA9r 3  85 37                        sta scratch+1
002BABr 3               
002BABr 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002BABr 3                               ; both in the scratch pad
002BABr 3  18                           clc
002BACr 3  A5 36                        lda scratch     ; ud-lo LSB
002BAEr 3  65 3A                        adc scratch+4   ; n LSB
002BB0r 3  85 36                        sta scratch     ; this is the new ud-lo
002BB2r 3  A5 37                        lda scratch+1   ; ud-lo MSB
002BB4r 3  65 3B                        adc scratch+5   ; n MSB
002BB6r 3  85 37                        sta scratch+1
002BB8r 3               
002BB8r 3  A5 38                        lda scratch+2   ; LSB
002BBAr 3  65 3C                        adc scratch+6
002BBCr 3  85 38                        sta scratch+2   ; this is the new ud-hi
002BBEr 3  A5 39                        lda scratch+3   ; MSB
002BC0r 3  65 3D                        adc scratch+7
002BC2r 3  85 39                        sta scratch+3
002BC4r 3               
002BC4r 3                               ; Clean up: Get rid of one of the two top elements on
002BC4r 3                               ; the Data Stack. We don't really care which one
002BC4r 3  E8                           inx
002BC5r 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002BC6r 3               
002BC6r 3                               ; One character down. Move address up
002BC6r 3  F6 04                        inc 4,x
002BC8r 3  D0 02                        bne @1
002BCAr 3  F6 05                        inc 5,x
002BCCr 3               @1:
002BCCr 3                               ; Decrease counter
002BCCr 3  D6 02                        dec 2,x
002BCEr 3  D0 88                        bne @loop
002BD0r 3               
002BD0r 3               @done:
002BD0r 3                               ; Counter has reached zero or we have an error. In both
002BD0r 3                               ; cases, we clean up the Data Stack and return. Error gives
002BD0r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002BD0r 3                               ; ( ud-lo ud-hi addr u ud-lo )
002BD0r 3  E8                           inx
002BD1r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002BD2r 3               
002BD2r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002BD2r 3  A5 36                        lda scratch     ; new ud-lo
002BD4r 3  95 06                        sta 6,x
002BD6r 3  A5 37                        lda scratch+1
002BD8r 3  95 07                        sta 7,x
002BDAr 3               
002BDAr 3  A5 38                        lda scratch+2
002BDCr 3  95 04                        sta 4,x
002BDEr 3  A5 39                        lda scratch+3
002BE0r 3  95 05                        sta 5,x
002BE2r 3               
002BE2r 3  60           z_to_number:    rts
002BE3r 3               
002BE3r 3               
002BE3r 3               
002BE3r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002BE3r 3               ; ## ">order"  tested  Gforth search
002BE3r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002BE3r 3               
002BE3r 3               xt_to_order:
002BE3r 3                               ; Put the wid on the return stack for now.
002BE3r 3  20 rr rr                     jsr xt_to_r
002BE6r 3               
002BE6r 3                               ; Get the current search order.
002BE6r 3  20 rr rr                     jsr xt_get_order
002BE9r 3               
002BE9r 3                               ; Get back the wid and add it to the list.
002BE9r 3  20 rr rr                     jsr xt_r_from
002BECr 3  20 rr rr                     jsr xt_swap
002BEFr 3  20 rr rr                     jsr xt_one_plus
002BF2r 3               
002BF2r 3                               ; Set the search order with the new list.
002BF2r 3  20 rr rr                     jsr xt_set_order
002BF5r 3               
002BF5r 3  60           z_to_order:     rts
002BF6r 3               
002BF6r 3               
002BF6r 3               
002BF6r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002BF6r 3               ; ## ">r"  auto  ANS core
002BF6r 3                       ; """https://forth-standard.org/standard/core/toR
002BF6r 3                       ; This word is handled differently for native and for
002BF6r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002BF6r 3                       ; word.
002BF6r 3                       ; """
002BF6r 3               xt_to_r:
002BF6r 3                               ; Save the return address. If this word is natively
002BF6r 3                               ; coded, this is a complete waste of cycles, but
002BF6r 3                               ; required for subroutine coding
002BF6r 3  68                           pla             ; LSB
002BF7r 3  85 2C                        sta tmptos
002BF9r 3  7A                           ply             ; MSB
002BFAr 3               
002BFAr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002BFAr 3               
002BFAr 3                               ; We check for underflow in the second step, so we can
002BFAr 3                               ; strip off the stack thrashing for native compiling first
002BFAr 3  20 rr rr                     jsr underflow_1
002BFDr 3               
002BFDr 3                               ; now we can do the actual work
002BFDr 3  B5 01                        lda 1,x         ; MSB
002BFFr 3  48                           pha
002C00r 3  B5 00                        lda 0,x         ; LSB
002C02r 3  48                           pha
002C03r 3               
002C03r 3  E8                           inx
002C04r 3  E8                           inx
002C05r 3               
002C05r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002C05r 3               
002C05r 3                               ; restore return address
002C05r 3  5A                           phy             ; MSB
002C06r 3  A5 2C                        lda tmptos
002C08r 3  48                           pha             ; LSB
002C09r 3               
002C09r 3  60           z_to_r:         rts
002C0Ar 3               
002C0Ar 3               
002C0Ar 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002C0Ar 3               ; ## "true"  auto  ANS core ext
002C0Ar 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002C0Ar 3               xt_true:
002C0Ar 3  CA                           dex
002C0Br 3  CA                           dex
002C0Cr 3  A9 FF                        lda #$FF
002C0Er 3  95 00                        sta 0,x
002C10r 3  95 01                        sta 1,x
002C12r 3               
002C12r 3  60           z_true:         rts
002C13r 3               
002C13r 3               
002C13r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002C13r 3               ; ## "tuck"  auto  ANS core ext
002C13r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002C13r 3               xt_tuck:
002C13r 3  20 rr rr                     jsr underflow_2
002C16r 3               
002C16r 3  CA                           dex
002C17r 3  CA                           dex
002C18r 3               
002C18r 3  B4 04                        ldy 4,x         ; LSB
002C1Ar 3  B5 02                        lda 2,x
002C1Cr 3  95 04                        sta 4,x
002C1Er 3  94 02                        sty 2,x
002C20r 3  95 00                        sta 0,x
002C22r 3               
002C22r 3  B4 05                        ldy 5,x         ; MSB
002C24r 3  B5 03                        lda 3,x
002C26r 3  95 05                        sta 5,x
002C28r 3  94 03                        sty 3,x         ; bba
002C2Ar 3  95 01                        sta 1,x         ; baa
002C2Cr 3               
002C2Cr 3  60           z_tuck:         rts
002C2Dr 3               
002C2Dr 3               
002C2Dr 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002C2Dr 3               ; ## "2"  auto  Tali Forth
002C2Dr 3                       ;
002C2Dr 3                       ; This code is shared with ASSEMBLER-WORDLIST
002C2Dr 3               xt_assembler_wordlist:
002C2Dr 3               xt_two:
002C2Dr 3  CA                           dex
002C2Er 3  CA                           dex
002C2Fr 3  A9 02                        lda #2
002C31r 3  95 00                        sta 0,x
002C33r 3  74 01                        stz 1,x
002C35r 3               
002C35r 3               z_assembler_wordlist:
002C35r 3  60           z_two:          rts
002C36r 3               
002C36r 3               
002C36r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
002C36r 3               ; ## "2drop"  auto  ANS core
002C36r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
002C36r 3               xt_two_drop:
002C36r 3  20 rr rr                     jsr underflow_2
002C39r 3               
002C39r 3  E8                           inx
002C3Ar 3  E8                           inx
002C3Br 3  E8                           inx
002C3Cr 3  E8                           inx
002C3Dr 3               
002C3Dr 3  60           z_two_drop:     rts
002C3Er 3               
002C3Er 3               
002C3Er 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002C3Er 3               ; ## "2dup"  auto  ANS core
002C3Er 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002C3Er 3               xt_two_dup:
002C3Er 3  20 rr rr                     jsr underflow_2
002C41r 3               
002C41r 3  CA                           dex
002C42r 3  CA                           dex
002C43r 3  CA                           dex
002C44r 3  CA                           dex
002C45r 3               
002C45r 3  B5 04                        lda 4,x         ; TOS
002C47r 3  95 00                        sta 0,x
002C49r 3  B5 05                        lda 5,x
002C4Br 3  95 01                        sta 1,x
002C4Dr 3               
002C4Dr 3  B5 06                        lda 6,x         ; NOS
002C4Fr 3  95 02                        sta 2,x
002C51r 3  B5 07                        lda 7,x
002C53r 3  95 03                        sta 3,x
002C55r 3               
002C55r 3  60           z_two_dup:      rts
002C56r 3               
002C56r 3               
002C56r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
002C56r 3               ; ## "2@"  auto  ANS core
002C56r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
002C56r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
002C56r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
002C56r 3                       ; """
002C56r 3               xt_two_fetch:
002C56r 3  20 rr rr                     jsr underflow_1
002C59r 3               
002C59r 3  B5 00                        lda 0,x
002C5Br 3  85 24                        sta tmp1
002C5Dr 3  B4 01                        ldy 1,x
002C5Fr 3  84 25                        sty tmp1+1
002C61r 3               
002C61r 3  CA                           dex             ; reuse one stack element
002C62r 3  CA                           dex
002C63r 3               
002C63r 3  B2 24                        lda (tmp1)      ; copy LSB
002C65r 3  95 00                        sta 0,x
002C67r 3  A0 01                        ldy #1          ; copy next
002C69r 3  B1 24                        lda (tmp1),y
002C6Br 3  95 01                        sta 1,x
002C6Dr 3  C8                           iny             ; copy next
002C6Er 3  B1 24                        lda (tmp1),y
002C70r 3  95 02                        sta 2,x
002C72r 3  C8                           iny             ; copy next
002C73r 3  B1 24                        lda (tmp1),y
002C75r 3  95 03                        sta 3,x
002C77r 3               
002C77r 3  60           z_two_fetch:    rts
002C78r 3               
002C78r 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
002C78r 3               ; ## "2over"  auto  ANS core
002C78r 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
002C78r 3               xt_two_over:
002C78r 3  20 rr rr                     jsr underflow_4
002C7Br 3               
002C7Br 3  CA                           dex
002C7Cr 3  CA                           dex
002C7Dr 3  CA                           dex
002C7Er 3  CA                           dex
002C7Fr 3               
002C7Fr 3  B5 08                        lda 8,x
002C81r 3  95 00                        sta 0,x
002C83r 3               
002C83r 3  B5 09                        lda 9,x
002C85r 3  95 01                        sta 1,x
002C87r 3               
002C87r 3  B5 0A                        lda 10,x
002C89r 3  95 02                        sta 2,x
002C8Br 3               
002C8Br 3  B5 0B                        lda 11,x
002C8Dr 3  95 03                        sta 3,x
002C8Fr 3               
002C8Fr 3  60           z_two_over:     rts
002C90r 3               
002C90r 3               
002C90r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002C90r 3               ; ## "2r@"  auto  ANS core ext
002C90r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002C90r 3                       ;
002C90r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002C90r 3                       ; assembler. We use trickery to access the elements on the Return
002C90r 3                       ; Stack instead of pulling the return address first and storing
002C90r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002C90r 3                       ; it as Never Native; at some point, we should compare versions to
002C90r 3                       ; see if an Always Native version would be better
002C90r 3                       ; """
002C90r 3               xt_two_r_fetch:
002C90r 3               		; make room on the Data Stack
002C90r 3  CA                           dex
002C91r 3  CA                           dex
002C92r 3  CA                           dex
002C93r 3  CA                           dex
002C94r 3               
002C94r 3                               ; Get four bytes off of Return Stack. This assumes that
002C94r 3                               ; we took a subroutine jump here so the first two entries
002C94r 3                               ; are the return address
002C94r 3  8A                           txa
002C95r 3  BA                           tsx
002C96r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002C97r 3  7A                           ply
002C98r 3  AA                           tax
002C99r 3               
002C99r 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002C99r 3                               ; the return address for this word. This is a whole lot
002C99r 3                               ; easier on the 65816
002C99r 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002C9Cr 3  95 00                        sta 0,x
002C9Er 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002CA1r 3  95 01                        sta 1,x
002CA3r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002CA6r 3  95 02                        sta 2,x
002CA8r 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002CABr 3  95 03                        sta 3,x
002CADr 3               
002CADr 3  60           z_two_r_fetch:  rts
002CAEr 3               
002CAEr 3               
002CAEr 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
002CAEr 3               ; ## "2r>"  auto  ANS core ext
002CAEr 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
002CAEr 3                       ; Pull top two entries from Return Stack.
002CAEr 3                       ;
002CAEr 3                       ; Is the same as
002CAEr 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
002CAEr 3                       ; the top value on the ReturnStack for a STC Forth is the
002CAEr 3                       ; return address, which we need to get out of the way first.
002CAEr 3                       ; Native compile needs to be handled as a special case.
002CAEr 3                       ; """
002CAEr 3               xt_two_r_from:
002CAEr 3                               ; save the return address
002CAEr 3  68                           pla                     ; LSB
002CAFr 3  85 24                        sta tmp1
002CB1r 3  68                           pla                     ; MSB
002CB2r 3  85 25                        sta tmp1+1
002CB4r 3               
002CB4r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002CB4r 3               
002CB4r 3               		; make room on stack
002CB4r 3  CA                           dex
002CB5r 3  CA                           dex
002CB6r 3  CA                           dex
002CB7r 3  CA                           dex
002CB8r 3               
002CB8r 3                               ; In theory, we should test for underflow on the Return
002CB8r 3                               ; Stack. However, given the traffic there with an STC
002CB8r 3                               ; Forth, that's probably not really useful
002CB8r 3               
002CB8r 3                               ; now we can access the data
002CB8r 3  68                           pla                     ; LSB
002CB9r 3  95 00                        sta 0,x
002CBBr 3  68                           pla                     ; MSB
002CBCr 3  95 01                        sta 1,x
002CBEr 3               
002CBEr 3  68                           pla                     ; LSB
002CBFr 3  95 02                        sta 2,x
002CC1r 3  68                           pla                     ; MSB
002CC2r 3  95 03                        sta 3,x
002CC4r 3               
002CC4r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002CC4r 3               
002CC4r 3                               ; restore return address
002CC4r 3  A5 25                        lda tmp1+1              ; MSB
002CC6r 3  48                           pha
002CC7r 3  A5 24                        lda tmp1                ; LSB
002CC9r 3  48                           pha
002CCAr 3               
002CCAr 3  60           z_two_r_from:   rts
002CCBr 3               
002CCBr 3               
002CCBr 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002CCBr 3               ; ## "2/"  auto  ANS core
002CCBr 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002CCBr 3               xt_two_slash:
002CCBr 3  20 rr rr                     jsr underflow_1
002CCEr 3               
002CCEr 3                               ; We can't just LSR the LSB and ROR the MSB because that
002CCEr 3                               ; would do bad things to the sign
002CCEr 3  B5 01                        lda 1,x
002CD0r 3  0A                           asl                     ; save the sign
002CD1r 3  76 01                        ror 1,x
002CD3r 3  76 00                        ror 0,x
002CD5r 3               
002CD5r 3  60           z_two_slash:    rts
002CD6r 3               
002CD6r 3               
002CD6r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002CD6r 3               ; ## "2*"  auto  ANS core
002CD6r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002CD6r 3                       ;
002CD6r 3                       ; Also used for CELLS
002CD6r 3                       ; """
002CD6r 3               xt_two_star:
002CD6r 3               xt_cells:
002CD6r 3  20 rr rr                     jsr underflow_1
002CD9r 3               
002CD9r 3  16 00                        asl 0,x
002CDBr 3  36 01                        rol 1,x
002CDDr 3               z_cells:
002CDDr 3  60           z_two_star:     rts
002CDEr 3               
002CDEr 3               
002CDEr 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
002CDEr 3               ; ## "2!"  auto  ANS core
002CDEr 3                       ; """https://forth-standard.org/standard/core/TwoStore
002CDEr 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
002CDEr 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
002CDEr 3                       ; """
002CDEr 3               xt_two_store:
002CDEr 3  20 rr rr                     jsr underflow_3
002CE1r 3               
002CE1r 3  B5 00                        lda 0,x
002CE3r 3  85 24                        sta tmp1
002CE5r 3  B4 01                        ldy 1,x
002CE7r 3  84 25                        sty tmp1+1
002CE9r 3               
002CE9r 3  E8                           inx
002CEAr 3  E8                           inx
002CEBr 3               
002CEBr 3  B5 00                        lda 0,x         ; copy MSB
002CEDr 3  92 24                        sta (tmp1)
002CEFr 3  B5 01                        lda 1,x         ; copy next
002CF1r 3  A0 01                        ldy #1
002CF3r 3  91 24                        sta (tmp1),y
002CF5r 3  B5 02                        lda 2,x         ; copy next
002CF7r 3  C8                           iny
002CF8r 3  91 24                        sta (tmp1),y
002CFAr 3  B5 03                        lda 3,x         ; copy MSB
002CFCr 3  C8                           iny
002CFDr 3  91 24                        sta (tmp1),y
002CFFr 3               
002CFFr 3  E8                           inx             ; 2DROP
002D00r 3  E8                           inx
002D01r 3  E8                           inx
002D02r 3  E8                           inx
002D03r 3               
002D03r 3  60           z_two_store:    rts
002D04r 3               
002D04r 3               
002D04r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002D04r 3               ; ## "2swap"  auto  ANS core
002D04r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002D04r 3               xt_two_swap:
002D04r 3  20 rr rr                     jsr underflow_4
002D07r 3               
002D07r 3                               ; 0 <-> 4
002D07r 3  B5 00                        lda 0,x
002D09r 3  B4 04                        ldy 4,x
002D0Br 3  95 04                        sta 4,x
002D0Dr 3  94 00                        sty 0,x
002D0Fr 3               
002D0Fr 3                               ; 1 <-> 5
002D0Fr 3  B5 01                        lda 1,x
002D11r 3  B4 05                        ldy 5,x
002D13r 3  95 05                        sta 5,x
002D15r 3  94 01                        sty 1,x
002D17r 3               
002D17r 3                               ; 2 <-> 6
002D17r 3  B5 02                        lda 2,x
002D19r 3  B4 06                        ldy 6,x
002D1Br 3  95 06                        sta 6,x
002D1Dr 3  94 02                        sty 2,x
002D1Fr 3               
002D1Fr 3                               ; 3 <-> 7
002D1Fr 3  B5 03                        lda 3,x
002D21r 3  B4 07                        ldy 7,x
002D23r 3  95 07                        sta 7,x
002D25r 3  94 03                        sty 3,x
002D27r 3               
002D27r 3  60           z_two_swap:     rts
002D28r 3               
002D28r 3               
002D28r 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
002D28r 3               ; ## "2>r"  auto  ANS core ext
002D28r 3                       ; """https://forth-standard.org/standard/core/TwotoR
002D28r 3                       ; Push top two entries to Return Stack.
002D28r 3                       ;
002D28r 3                       ; The same as SWAP >R >R
002D28r 3                       ; except that if we jumped here, the return address will be in the
002D28r 3                       ; way. May not be natively compiled unless we're clever and use
002D28r 3                       ; special routines.
002D28r 3                       ; """
002D28r 3               xt_two_to_r:
002D28r 3                               ; save the return address
002D28r 3  68                           pla             ; LSB
002D29r 3  85 24                        sta tmp1
002D2Br 3  68                           pla             ; MSB
002D2Cr 3  85 25                        sta tmp1+1
002D2Er 3               
002D2Er 3                               ; --- CUT HERE FOR NATIVE CODING ---
002D2Er 3               
002D2Er 3  20 rr rr                     jsr underflow_2
002D31r 3               
002D31r 3                               ; now we can move the data
002D31r 3  B5 03                        lda 3,x         ; MSB
002D33r 3  48                           pha
002D34r 3  B5 02                        lda 2,x         ; LSB
002D36r 3  48                           pha
002D37r 3               
002D37r 3                               ; now we can move the data
002D37r 3  B5 01                        lda 1,x         ; MSB
002D39r 3  48                           pha
002D3Ar 3  B5 00                        lda 0,x         ; LSB
002D3Cr 3  48                           pha
002D3Dr 3               
002D3Dr 3  E8                           inx
002D3Er 3  E8                           inx
002D3Fr 3  E8                           inx
002D40r 3  E8                           inx
002D41r 3               
002D41r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002D41r 3               
002D41r 3                               ; restore return address
002D41r 3  A5 25                        lda tmp1+1      ; MSB
002D43r 3  48                           pha
002D44r 3  A5 24                        lda tmp1        ; LSB
002D46r 3  48                           pha
002D47r 3               
002D47r 3  60           z_two_to_r:     rts
002D48r 3               
002D48r 3               
002D48r 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
002D48r 3               ; ## "2constant"  auto  ANS double
002D48r 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
002D48r 3                       ;
002D48r 3                       ; Based on the Forth code
002D48r 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
002D48r 3                       ; """
002D48r 3               xt_two_constant:
002D48r 3  20 rr rr                     jsr underflow_2
002D4Br 3               
002D4Br 3  20 rr rr                     jsr xt_create
002D4Er 3  20 rr rr                     jsr xt_swap
002D51r 3  20 rr rr                     jsr xt_comma
002D54r 3  20 rr rr                     jsr xt_comma
002D57r 3               
002D57r 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002D5Ar 3  20 rr rr                     jsr dodoes
002D5Dr 3               
002D5Dr 3  20 rr rr                     jsr xt_dup
002D60r 3  20 rr rr                     jsr xt_fetch
002D63r 3  20 rr rr                     jsr xt_swap
002D66r 3  20 rr rr                     jsr xt_cell_plus
002D69r 3  20 rr rr                     jsr xt_fetch
002D6Cr 3               
002D6Cr 3  60           z_two_constant: rts
002D6Dr 3               
002D6Dr 3               
002D6Dr 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002D6Dr 3               ; ## "2literal"  auto  ANS double
002D6Dr 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002D6Dr 3                       ; Based on the Forth code
002D6Dr 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002D6Dr 3                       ; """
002D6Dr 3               xt_two_literal:
002D6Dr 3  20 rr rr                     jsr underflow_2 ; double number
002D70r 3               
002D70r 3  20 rr rr                     jsr xt_swap
002D73r 3  20 rr rr                     jsr xt_literal
002D76r 3  20 rr rr                     jsr xt_literal
002D79r 3               
002D79r 3  60           z_two_literal:  rts
002D7Ar 3               
002D7Ar 3               
002D7Ar 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002D7Ar 3               ; ## "2variable"  auto  ANS double
002D7Ar 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002D7Ar 3                       ; The variable is not initialized to zero.
002D7Ar 3                       ;
002D7Ar 3                       ; This can be realized in Forth as either
002D7Ar 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002D7Ar 3                       ; """
002D7Ar 3               xt_two_variable:
002D7Ar 3                               ; We just let CRATE and ALLOT do the heavy lifting
002D7Ar 3  20 rr rr                     jsr xt_create
002D7Dr 3               
002D7Dr 3  CA                           dex
002D7Er 3  CA                           dex
002D7Fr 3  A9 04                        lda #4
002D81r 3  95 00                        sta 0,x
002D83r 3  74 01                        stz 1,x
002D85r 3               
002D85r 3  20 rr rr                     jsr xt_allot
002D88r 3               
002D88r 3  60           z_two_variable: rts
002D89r 3               
002D89r 3               
002D89r 3               ; ## TYPE ( addr u -- ) "Print string"
002D89r 3               ; ## "type"  auto  ANS core
002D89r 3                       ; """https://forth-standard.org/standard/core/TYPE
002D89r 3                       ; Works through EMIT to allow OUTPUT revectoring.
002D89r 3                       ; """
002D89r 3               
002D89r 3               xt_type:
002D89r 3  20 rr rr                     jsr underflow_2
002D8Cr 3               
002D8Cr 3                               ; Save the starting address into tmp1
002D8Cr 3  B5 02                        lda 2,x
002D8Er 3  85 24                        sta tmp1
002D90r 3  B5 03                        lda 3,x
002D92r 3  85 25                        sta tmp1+1
002D94r 3               @loop:
002D94r 3                               ; done if length is zero
002D94r 3  B5 00                        lda 0,x
002D96r 3  15 01                        ora 1,x
002D98r 3  F0 15                        beq @done
002D9Ar 3               
002D9Ar 3                               ; Send the current character
002D9Ar 3  B2 24                        lda (tmp1)
002D9Cr 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002D9Fr 3               
002D9Fr 3                               ; Move the address along (in tmp1)
002D9Fr 3  E6 24                        inc tmp1
002DA1r 3  D0 02                        bne @1
002DA3r 3  E6 25                        inc tmp1+1
002DA5r 3               @1:
002DA5r 3                               ; Reduce the count (on the data stack)
002DA5r 3  B5 00                        lda 0,x
002DA7r 3  D0 02                        bne @2
002DA9r 3  D6 01                        dec 1,x
002DABr 3               @2:
002DABr 3  D6 00                        dec 0,x
002DADr 3               
002DADr 3  80 E5                        bra @loop
002DAFr 3               @done:
002DAFr 3  E8                           inx
002DB0r 3  E8                           inx
002DB1r 3  E8                           inx
002DB2r 3  E8                           inx
002DB3r 3               
002DB3r 3  60           z_type:         rts
002DB4r 3               
002DB4r 3               
002DB4r 3               
002DB4r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002DB4r 3               ; ## "u."  tested  ANS core
002DB4r 3                       ; """https://forth-standard.org/standard/core/Ud
002DB4r 3                       ;
002DB4r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002DB4r 3                       ; We use the internal assembler function print_u followed
002DB4r 3                       ; by a single space
002DB4r 3                       ; """
002DB4r 3               xt_u_dot:
002DB4r 3  20 rr rr                     jsr underflow_1
002DB7r 3               
002DB7r 3  20 rr rr                     jsr print_u
002DBAr 3  A9 20                        lda #AscSP
002DBCr 3  20 rr rr                     jsr emit_a
002DBFr 3               
002DBFr 3  60           z_u_dot:        rts
002DC0r 3               
002DC0r 3               
002DC0r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
002DC0r 3               ; ## "u.r"  tested  ANS core ext
002DC0r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
002DC0r 3               xt_u_dot_r:
002DC0r 3  20 rr rr                     jsr underflow_2
002DC3r 3               
002DC3r 3  20 rr rr                     jsr xt_to_r
002DC6r 3  20 rr rr                     jsr xt_zero
002DC9r 3  20 rr rr                     jsr xt_less_number_sign
002DCCr 3  20 rr rr                     jsr xt_number_sign_s
002DCFr 3  20 rr rr                     jsr xt_number_sign_greater
002DD2r 3  20 rr rr                     jsr xt_r_from
002DD5r 3  20 rr rr                     jsr xt_over
002DD8r 3  20 rr rr                     jsr xt_minus
002DDBr 3  20 rr rr                     jsr xt_spaces
002DDEr 3  20 rr rr                     jsr xt_type
002DE1r 3               
002DE1r 3  60           z_u_dot_r:      rts
002DE2r 3               
002DE2r 3               
002DE2r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002DE2r 3               ; ## "u>"  auto  ANS core ext
002DE2r 3                       ; """https://forth-standard.org/standard/core/Umore"""
002DE2r 3               xt_u_greater_than:
002DE2r 3  20 rr rr                     jsr underflow_2
002DE5r 3               
002DE5r 3  B5 00                        lda 0,x
002DE7r 3  D5 02                        cmp 2,x
002DE9r 3  B5 01                        lda 1,x
002DEBr 3  F5 03                        sbc 3,x
002DEDr 3  E8                           inx
002DEEr 3  E8                           inx
002DEFr 3               
002DEFr 3  A9 00                        lda #0
002DF1r 3  69 FF                        adc #$ff
002DF3r 3  95 00                        sta 0,x         ; store flag
002DF5r 3  95 01                        sta 1,x
002DF7r 3               
002DF7r 3  60           z_u_greater_than:    rts
002DF8r 3               
002DF8r 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002DF8r 3               ; ## "u<"  auto  ANS core
002DF8r 3                       ; """https://forth-standard.org/standard/core/Uless"""
002DF8r 3               xt_u_less_than:
002DF8r 3  20 rr rr                     jsr underflow_2
002DFBr 3               
002DFBr 3  B5 02                        lda 2,x
002DFDr 3  D5 00                        cmp 0,x
002DFFr 3  B5 03                        lda 3,x
002E01r 3  F5 01                        sbc 1,x
002E03r 3  E8                           inx
002E04r 3  E8                           inx
002E05r 3               
002E05r 3  A9 00                        lda #0
002E07r 3  69 FF                        adc #$ff
002E09r 3  95 00                        sta 0,x         ; store flag
002E0Br 3  95 01                        sta 1,x
002E0Dr 3               
002E0Dr 3  60           z_u_less_than:    rts
002E0Er 3               
002E0Er 3               
002E0Er 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002E0Er 3               ; ## "ud."  auto  Tali double
002E0Er 3                       ;
002E0Er 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002E0Er 3                       ; """
002E0Er 3               xt_ud_dot:
002E0Er 3  20 rr rr                     jsr underflow_2 ; double number
002E11r 3               
002E11r 3  20 rr rr                     jsr xt_less_number_sign
002E14r 3  20 rr rr                     jsr xt_number_sign_s
002E17r 3  20 rr rr                     jsr xt_number_sign_greater
002E1Ar 3  20 rr rr                     jsr xt_type
002E1Dr 3  20 rr rr                     jsr xt_space
002E20r 3               
002E20r 3  60           z_ud_dot:        rts
002E21r 3               
002E21r 3               
002E21r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002E21r 3               ; ## "ud.r"  auto  Tali double
002E21r 3                       ;
002E21r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002E21r 3                       ; """
002E21r 3               xt_ud_dot_r:
002E21r 3  20 rr rr                     jsr underflow_3
002E24r 3               
002E24r 3  20 rr rr                     jsr xt_to_r
002E27r 3  20 rr rr                     jsr xt_less_number_sign
002E2Ar 3  20 rr rr                     jsr xt_number_sign_s
002E2Dr 3  20 rr rr                     jsr xt_number_sign_greater
002E30r 3  20 rr rr                     jsr xt_r_from
002E33r 3  20 rr rr                     jsr xt_over
002E36r 3  20 rr rr                     jsr xt_minus
002E39r 3  20 rr rr                     jsr xt_spaces
002E3Cr 3  20 rr rr                     jsr xt_type
002E3Fr 3               
002E3Fr 3  60           z_ud_dot_r:      rts
002E40r 3               
002E40r 3               
002E40r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002E40r 3               ; ## "um/mod"  auto  ANS core
002E40r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002E40r 3                       ; Divide double cell number by single cell number, returning the
002E40r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002E40r 3                       ; This is the basic division operation all others use. Based on FIG
002E40r 3                       ; Forth code, modified by Garth Wilson, see
002E40r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002E40r 3                       ;
002E40r 3                       ; This uses tmp1, tmp1+1, and tmptos
002E40r 3                       ; """
002E40r 3               
002E40r 3               xt_um_slash_mod:
002E40r 3  20 rr rr                     jsr underflow_3
002E43r 3               
002E43r 3                               ; catch division by zero
002E43r 3  B5 00                        lda 0,x
002E45r 3  15 01                        ora 1,x
002E47r 3  D0 05                        bne @not_zero
002E49r 3               
002E49r 3  A9 04                        lda #err_divzero
002E4Br 3  4C rr rr                     jmp error
002E4Er 3               
002E4Er 3               @not_zero:
002E4Er 3                               ; We loop 17 times
002E4Er 3  A9 11                        lda #17
002E50r 3  85 2C                        sta tmptos
002E52r 3               
002E52r 3               @loop:
002E52r 3                               ; rotate low cell of dividend one bit left (LSB)
002E52r 3  36 04                        rol 4,x
002E54r 3  36 05                        rol 5,x
002E56r 3               
002E56r 3                               ; loop control
002E56r 3  C6 2C                        dec tmptos
002E58r 3  F0 22                        beq @done
002E5Ar 3               
002E5Ar 3                               ; rotate high cell of dividend one bit left (MSB)
002E5Ar 3  36 02                        rol 2,x
002E5Cr 3  36 03                        rol 3,x
002E5Er 3               
002E5Er 3  64 24                        stz tmp1        ; store the bit we got from hi cell (MSB)
002E60r 3  26 24                        rol tmp1
002E62r 3               
002E62r 3                               ; subtract dividend hi cell minus divisor
002E62r 3  38                           sec
002E63r 3  B5 02                        lda 2,x
002E65r 3  F5 00                        sbc 0,x
002E67r 3  85 25                        sta tmp1+1
002E69r 3  B5 03                        lda 3,x
002E6Br 3  F5 01                        sbc 1,x
002E6Dr 3               
002E6Dr 3  A8                           tay
002E6Er 3  A5 24                        lda tmp1
002E70r 3  E9 00                        sbc #0
002E72r 3  90 DE                        bcc @loop
002E74r 3               
002E74r 3                               ; make result new dividend high cell
002E74r 3  A5 25                        lda tmp1+1
002E76r 3  95 02                        sta 2,x
002E78r 3  94 03                        sty 3,x         ; used as temp storage
002E7Ar 3               
002E7Ar 3  80 D6                        bra @loop
002E7Cr 3               @done:
002E7Cr 3  E8                           inx
002E7Dr 3  E8                           inx
002E7Er 3               
002E7Er 3  20 rr rr                     jsr xt_swap
002E81r 3               
002E81r 3  60           z_um_slash_mod: rts
002E82r 3               
002E82r 3               
002E82r 3               
002E82r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002E82r 3               ; ## "um*"  auto  ANS core
002E82r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002E82r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002E82r 3                       ; Old Forth versions such as FIG Forth call this U*
002E82r 3                       ;
002E82r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002E82r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002E82r 3                       ; discussion.
002E82r 3                       ;
002E82r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002E82r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002E82r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002E82r 3                       ;
002E82r 3                       ; Consider switching to a table-supported version based on
002E82r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002E82r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002E82r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002E82r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002E82r 3                       ; """
002E82r 3               
002E82r 3               xt_um_star:
002E82r 3  20 rr rr                     jsr underflow_2
002E85r 3               
002E85r 3                               ; to eliminate clc inside the loop, the value at
002E85r 3                               ; tmp1 is reduced by 1 in advance
002E85r 3  18                           clc
002E86r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002E88r 3  E9 00                        sbc #0
002E8Ar 3  85 26                        sta tmp2
002E8Cr 3               
002E8Cr 3  B5 01                        lda 1,x
002E8Er 3  E9 00                        sbc #0
002E90r 3  90 31                        bcc @zero       ; is TOS zero?
002E92r 3  85 27                        sta tmp2+1
002E94r 3               
002E94r 3  A9 00                        lda #0
002E96r 3  85 24                        sta tmp1
002E98r 3  86 28                        stx tmp3        ; tested for exit from outer loop
002E9Ar 3  CA                           dex
002E9Br 3  CA                           dex
002E9Cr 3               
002E9Cr 3               @outer_loop:
002E9Cr 3  A0 08                        ldy #8          ; counter inner loop
002E9Er 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002EA0r 3               
002EA0r 3               @inner_loop:
002EA0r 3  90 0C                        bcc @no_add
002EA2r 3  85 25                        sta tmp1+1      ; save time, don't CLC
002EA4r 3  A5 24                        lda tmp1
002EA6r 3  65 26                        adc tmp2
002EA8r 3  85 24                        sta tmp1
002EAAr 3  A5 25                        lda tmp1+1
002EACr 3  65 27                        adc tmp2+1
002EAEr 3               
002EAEr 3               @no_add:
002EAEr 3  6A                           ror
002EAFr 3  66 24                        ror tmp1
002EB1r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002EB3r 3               
002EB3r 3  88                           dey
002EB4r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002EB6r 3               
002EB6r 3  E8                           inx
002EB7r 3  E4 28                        cpx tmp3
002EB9r 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002EBBr 3               
002EBBr 3                               ; all done, store high word of result
002EBBr 3  95 01                        sta 1,x
002EBDr 3  A5 24                        lda tmp1
002EBFr 3  95 00                        sta 0,x
002EC1r 3  80 04                        bra @done
002EC3r 3               
002EC3r 3               @zero:
002EC3r 3  74 02                        stz 2,x
002EC5r 3  74 03                        stz 3,x
002EC7r 3               @done:
002EC7r 3  60           z_um_star:      rts
002EC8r 3               
002EC8r 3               
002EC8r 3               
002EC8r 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002EC8r 3               ; ## "unloop"  auto  ANS core
002EC8r 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002EC8r 3                       ;
002EC8r 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002EC8r 3                       ; """
002EC8r 3               xt_unloop:
002EC8r 3                               ; Drop fudge number (limit/start from DO/?DO off the
002EC8r 3                               ; return stack
002EC8r 3  68                           pla
002EC9r 3  68                           pla
002ECAr 3  68                           pla
002ECBr 3  68                           pla
002ECCr 3               
002ECCr 3                               ; Now drop the LEAVE address that was below them off
002ECCr 3                               ; the Return Stack as well
002ECCr 3  68                           pla
002ECDr 3  68                           pla
002ECEr 3               
002ECEr 3  60           z_unloop:       rts
002ECFr 3               
002ECFr 3               
002ECFr 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
002ECFr 3               ; ## "until"  auto  ANS core
002ECFr 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
002ECFr 3               xt_until:
002ECFr 3                               ; Compile a 0BRANCH
002ECFr 3  A0 rr                        ldy #>zero_branch_runtime
002ED1r 3  A9 rr                        lda #<zero_branch_runtime
002ED3r 3  20 rr rr                     jsr cmpl_subroutine
002ED6r 3               
002ED6r 3                               ; The address to loop back to is on the stack.
002ED6r 3                               ; Just compile it as the destination for the
002ED6r 3                               ; 0branch.
002ED6r 3  20 rr rr                     jsr xt_comma
002ED9r 3               
002ED9r 3  60           z_until:        rts
002EDAr 3               
002EDAr 3               
002EDAr 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
002EDAr 3               ; ## "unused"  auto  ANS core ext
002EDAr 3                       ; """https://forth-standard.org/standard/core/UNUSED
002EDAr 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
002EDAr 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
002EDAr 3                       ; defaults to $400
002EDAr 3                       ; """
002EDAr 3               xt_unused:
002EDAr 3  CA                           dex
002EDBr 3  CA                           dex
002EDCr 3               
002EDCr 3  A9 FD                        lda #<cp_end
002EDEr 3  38                           sec
002EDFr 3  E5 00                        sbc cp
002EE1r 3  95 00                        sta 0,x
002EE3r 3               
002EE3r 3  A9 77                        lda #>cp_end
002EE5r 3  E5 01                        sbc cp+1
002EE7r 3  95 01                        sta 1,x
002EE9r 3               
002EE9r 3  60           z_unused:       rts
002EEAr 3               
002EEAr 3               
002EEAr 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
002EEAr 3               ; ## "update"  auto  ANS block
002EEAr 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
002EEAr 3               xt_update:
002EEAr 3                               ; Turn on the dirty bit. We can't use TSB here because it only
002EEAr 3                               ; has Absolute and Direct Pages addressing modes
002EEAr 3  A0 2C                        ldy #buffstatus_offset
002EECr 3  B1 1E                        lda (up),y
002EEEr 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
002EF0r 3  91 1E                        sta (up),y
002EF2r 3               
002EF2r 3  60           z_update:       rts
002EF3r 3               
002EF3r 3               
002EF3r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
002EF3r 3               ; ## "useraddr"  tested  Tali Forth
002EF3r 3               xt_useraddr:
002EF3r 3  CA                           dex
002EF4r 3  CA                           dex
002EF5r 3  A9 1E                        lda #<up
002EF7r 3  95 00                        sta 0,x
002EF9r 3  A9 00                        lda #>up
002EFBr 3  95 01                        sta 1,x
002EFDr 3               
002EFDr 3  60           z_useraddr:     rts
002EFEr 3               
002EFEr 3               
002EFEr 3               ; ## VALUE ( n "name" -- ) "Define a value"
002EFEr 3               ; ## "value"  auto  ANS core
002EFEr 3                       ; """https://forth-standard.org/standard/core/VALUE
002EFEr 3                       ;
002EFEr 3                       ; This is a dummy header for the WORDLIST. The actual code is
002EFEr 3                       ; identical to that of CONSTANT
002EFEr 3                       ; """
002EFEr 3               
002EFEr 3               
002EFEr 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
002EFEr 3               ; ## "variable"  auto  ANS core
002EFEr 3                       ; """https://forth-standard.org/standard/core/VARIABLE
002EFEr 3                       ; There are various Forth definitions for this word, such as
002EFEr 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
002EFEr 3                       ; second one so the variable is initialized to zero
002EFEr 3                       ; """
002EFEr 3               xt_variable:
002EFEr 3                               ; we let CREATE do the heavy lifting
002EFEr 3  20 rr rr                     jsr xt_create
002F01r 3               
002F01r 3                               ; there is no "STZ (CP)" so we have to do this the hard
002F01r 3                               ; way
002F01r 3  A9 00                        lda #0
002F03r 3               
002F03r 3  92 00                        sta (cp)
002F05r 3  E6 00                        inc cp
002F07r 3  D0 02                        bne @1
002F09r 3  E6 01                        inc cp+1
002F0Br 3               @1:
002F0Br 3  92 00                        sta (cp)
002F0Dr 3  E6 00                        inc cp
002F0Fr 3  D0 02                        bne @2
002F11r 3  E6 01                        inc cp+1
002F13r 3               @2:
002F13r 3                               ; Now we need to adjust the length of the complete word by two
002F13r 3  20 rr rr                     jsr adjust_z
002F16r 3               
002F16r 3  60           z_variable:     rts
002F17r 3               
002F17r 3               
002F17r 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
002F17r 3               ; ## "while"  auto  ANS core
002F17r 3                       ; """http://forth-standard.org/standard/core/WHILE"""
002F17r 3               xt_while:
002F17r 3                               ; Compile a 0branch
002F17r 3  A0 rr                        ldy #>zero_branch_runtime
002F19r 3  A9 rr                        lda #<zero_branch_runtime
002F1Br 3  20 rr rr                     jsr cmpl_subroutine
002F1Er 3               
002F1Er 3                               ; Put the address (here) where the destination
002F1Er 3                               ; address needs to go so it can be put there later.
002F1Er 3  20 rr rr                     jsr xt_here
002F21r 3               
002F21r 3                               ; Fill in the destination address with 0 for now.
002F21r 3  20 rr rr                     jsr xt_zero
002F24r 3  20 rr rr                     jsr xt_comma
002F27r 3               
002F27r 3                               ; Swap the two addresses on the stack.
002F27r 3  20 rr rr                     jsr xt_swap
002F2Ar 3               
002F2Ar 3  60           z_while:        rts
002F2Br 3               
002F2Br 3               
002F2Br 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
002F2Br 3               ; ## "within"  auto  ANS core ext
002F2Br 3                       ; """https://forth-standard.org/standard/core/WITHIN
002F2Br 3                       ;
002F2Br 3                       ; This an assembler version of the ANS Forth implementation
002F2Br 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
002F2Br 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
002F2Br 3                       ; ROT TUCK > -ROT > INVERT AND
002F2Br 3                       ; """"
002F2Br 3               xt_within:
002F2Br 3  20 rr rr                     jsr underflow_3
002F2Er 3               
002F2Er 3  20 rr rr                     jsr xt_over
002F31r 3  20 rr rr                     jsr xt_minus
002F34r 3  20 rr rr                     jsr xt_to_r
002F37r 3  20 rr rr                     jsr xt_minus
002F3Ar 3  20 rr rr                     jsr xt_r_from
002F3Dr 3  20 rr rr                     jsr xt_u_less_than
002F40r 3               
002F40r 3  60           z_within:       rts
002F41r 3               
002F41r 3               
002F41r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002F41r 3               ; ## "word"  auto  ANS core
002F41r 3                       ; """https://forth-standard.org/standard/core/WORD
002F41r 3                       ; Obsolete parsing word included for backwards compatibility only.
002F41r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002F41r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002F41r 3                       ; Returns the result as a counted string (requires COUNT to convert
002F41r 3                       ; to modern format), and inserts a space after the string. See "Forth
002F41r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002F41r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002F41r 3                       ; for discussions of why you shouldn't be using WORD anymore.
002F41r 3                       ;
002F41r 3                       ; Forth
002F41r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002F41r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002F41r 3                       ; """
002F41r 3               
002F41r 3               xt_word:
002F41r 3  20 rr rr                     jsr underflow_1
002F44r 3               
002F44r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
002F44r 3                               ; but unlike PARSE
002F44r 3  A4 0C                        ldy toin                ; >IN
002F46r 3               @loop:
002F46r 3  C4 0A                        cpy ciblen              ; quit if end of input
002F48r 3  F0 09                        beq @found_char
002F4Ar 3  B1 08                        lda (cib),y
002F4Cr 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002F4Er 3  D0 03                        bne @found_char
002F50r 3               
002F50r 3  C8                           iny
002F51r 3  80 F3                        bra @loop
002F53r 3               @found_char:
002F53r 3                               ; Save index of where word starts
002F53r 3  84 0C                        sty toin
002F55r 3               
002F55r 3                               ; The real work is done by parse
002F55r 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
002F58r 3               
002F58r 3                               ; Convert the modern ( addr u ) string format to obsolete
002F58r 3                               ; ( caddr ) format. We just do this in the Dictionary
002F58r 3  B5 00                        lda 0,x
002F5Ar 3  92 00                        sta (cp)                ; Save length of string
002F5Cr 3  48                           pha                     ; Keep copy of length for later
002F5Dr 3               
002F5Dr 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002F60r 3  A5 00                        lda cp
002F62r 3  18                           clc
002F63r 3  69 01                        adc #1
002F65r 3  95 02                        sta 2,x                 ; LSB of CP
002F67r 3  A5 01                        lda cp+1
002F69r 3  69 00                        adc #0
002F6Br 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002F6Dr 3               
002F6Dr 3  20 rr rr                     jsr xt_move
002F70r 3               
002F70r 3                               ; Return caddr
002F70r 3  CA                           dex
002F71r 3  CA                           dex
002F72r 3  A5 00                        lda cp
002F74r 3  95 00                        sta 0,x
002F76r 3  A5 01                        lda cp+1
002F78r 3  95 01                        sta 1,x
002F7Ar 3               
002F7Ar 3                               ; Adjust CP
002F7Ar 3  68                           pla                     ; length of string
002F7Br 3  18                           clc
002F7Cr 3  65 00                        adc cp
002F7Er 3  85 00                        sta cp
002F80r 3  A5 01                        lda cp+1
002F82r 3  69 00                        adc #0                  ; we only need the carry
002F84r 3  85 01                        sta cp+1
002F86r 3  60           z_word:         rts
002F87r 3               
002F87r 3               
002F87r 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
002F87r 3               ; ## "wordlist" auto ANS search
002F87r 3                       ; """https://forth-standard.org/standard/search/WORDLIST
002F87r 3                       ; See the tutorial on Wordlists and the Search Order for
002F87r 3                       ; more information.
002F87r 3                       ; """
002F87r 3               
002F87r 3               xt_wordlist:
002F87r 3                               ; Get the current number of wordlists
002F87r 3  A0 05                        ldy #num_wordlists_offset
002F89r 3  B1 1E                        lda (up),y      ; This is a byte variable, so only
002F8Br 3                                               ; the LSB needs to be checked.
002F8Br 3               
002F8Br 3                               ; See if we are already at the max.
002F8Br 3  C9 0C                        cmp #max_wordlists
002F8Dr 3  D0 05                        bne @ok
002F8Fr 3               
002F8Fr 3                               ; Print an error message if all wordlists used.
002F8Fr 3  A9 0B                        lda #err_wordlist
002F91r 3  4C rr rr                     jmp error
002F94r 3               
002F94r 3               @ok:
002F94r 3  1A                           inc             ; Increment the wordlist#
002F95r 3  91 1E                        sta (up),y      ; Save it into byte variable #wordlists
002F97r 3  CA                           dex             ; and put it on the stack.
002F98r 3  CA                           dex
002F99r 3  95 00                        sta 0,x
002F9Br 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002F9Dr 3               
002F9Dr 3  60           z_wordlist:     rts
002F9Er 3               
002F9Er 3               
002F9Er 3               
002F9Er 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002F9Er 3               ; ## "words"  tested  ANS tools
002F9Er 3                       ; """https://forth-standard.org/standard/tools/WORDS
002F9Er 3                       ; This is pretty much only used at the command line so we can
002F9Er 3                       ; be slow and try to save space.
002F9Er 3                       ; """
002F9Er 3               
002F9Er 3               xt_words:
002F9Er 3                               ; we follow Gforth by starting on the next
002F9Er 3                               ; line
002F9Er 3  20 rr rr                     jsr xt_cr
002FA1r 3               
002FA1r 3                               ; We pretty-format the output by inserting a line break
002FA1r 3                               ; before the end of the line. We can get away with pushing
002FA1r 3                               ; the counter to the stack because this is usually an
002FA1r 3                               ; interactive word and speed is not that important
002FA1r 3  A9 00                        lda #0
002FA3r 3  48                           pha
002FA4r 3               
002FA4r 3                               ; Set up for traversing the wordlist search order.
002FA4r 3  CA                           dex                     ; Make room on the stack for
002FA5r 3  CA                           dex                     ; a dictionary pointer.
002FA6r 3  64 28                        stz tmp3                ; Start at the beginning of
002FA8r 3                                                       ; the search order.
002FA8r 3               @wordlist_loop:
002FA8r 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
002FAAr 3  A5 28                        lda tmp3
002FACr 3  D1 1E                        cmp (up),y              ; See if we are done.
002FAEr 3  D0 02                        bne @have_wordlist
002FB0r 3               
002FB0r 3                               ; We ran out of wordlists to search.
002FB0r 3  80 44                        bra @words_done
002FB2r 3               
002FB2r 3               @have_wordlist:
002FB2r 3                               ; start with last word in Dictionary
002FB2r 3                               ; Get the current wordlist id
002FB2r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
002FB3r 3  69 1F                        adc #search_order_offset
002FB5r 3  A8                           tay
002FB6r 3  B1 1E                        lda (up),y              ; Get the index into array WORDLISTS
002FB8r 3               
002FB8r 3                               ; Get the DP for that wordlist.
002FB8r 3  0A                           asl                     ; Turn offset into cells offset.
002FB9r 3  18                           clc
002FBAr 3  69 06                        adc #wordlists_offset
002FBCr 3  A8                           tay
002FBDr 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
002FBFr 3  95 00                        sta 0,x                 ; on the stack. ( nt )
002FC1r 3  C8                           iny
002FC2r 3  B1 1E                        lda (up),y
002FC4r 3  95 01                        sta 1,x
002FC6r 3               
002FC6r 3               @loop:
002FC6r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002FC9r 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
002FCCr 3               
002FCCr 3                               ; Insert line break if we're about to go past the end of the
002FCCr 3                               ; line
002FCCr 3  68                           pla
002FCDr 3  18                           clc
002FCEr 3  75 00                        adc 0,x
002FD0r 3  1A                           inc                     ; don't forget the space between words
002FD1r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
002FD3r 3  90 05                        bcc @1
002FD5r 3               
002FD5r 3  20 rr rr                     jsr xt_cr
002FD8r 3  A9 00                        lda #0
002FDAr 3               @1:
002FDAr 3  48                           pha
002FDBr 3  20 rr rr                     jsr xt_type             ; ( nt )
002FDEr 3               
002FDEr 3  A9 20                        lda #AscSP
002FE0r 3  20 rr rr                     jsr emit_a
002FE3r 3               
002FE3r 3                               ; get next word, which begins two down
002FE3r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002FE6r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002FE9r 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
002FECr 3               
002FECr 3                               ; if next address is zero, we're done
002FECr 3  B5 00                        lda 0,x
002FEEr 3  15 01                        ora 1,x
002FF0r 3  D0 D4                        bne @loop
002FF2r 3               
002FF2r 3                               ; Move on to the next wordlist in the search order.
002FF2r 3  E6 28                        inc tmp3
002FF4r 3  80 B2                        bra @wordlist_loop
002FF6r 3               
002FF6r 3               @words_done:
002FF6r 3  68                           pla                     ; dump counter
002FF7r 3               
002FF7r 3  E8                           inx
002FF8r 3  E8                           inx
002FF9r 3               
002FF9r 3  60           z_words:        rts
002FFAr 3               
002FFAr 3               
002FFAr 3               
002FFAr 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
002FFAr 3               ; ## "wordsize"  auto  Tali Forth
002FFAr 3                       ; """Given an word's name token (nt), return the size of the
002FFAr 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
002FFAr 3                       ; count the final RTS.
002FFAr 3                       ; """
002FFAr 3               xt_wordsize:
002FFAr 3  20 rr rr                     jsr underflow_1
002FFDr 3               
002FFDr 3                               ; We get the start address of the word from its header entry
002FFDr 3                               ; for the start of the actual code (execution token, xt)
002FFDr 3                               ; which is four bytes down, and the pointer to the end of the
002FFDr 3                               ; code (z_word, six bytes down)
002FFDr 3  B5 00                        lda 0,x
002FFFr 3  85 24                        sta tmp1
003001r 3  B5 01                        lda 1,x
003003r 3  85 25                        sta tmp1+1
003005r 3               
003005r 3  A0 06                        ldy #6
003007r 3  B1 24                        lda (tmp1),y    ; LSB of z
003009r 3  88                           dey
00300Ar 3  88                           dey
00300Br 3               
00300Br 3  38                           sec
00300Cr 3  F1 24                        sbc (tmp1),y    ; LSB of xt
00300Er 3  95 00                        sta 0,x
003010r 3               
003010r 3  A0 07                        ldy #7
003012r 3  B1 24                        lda (tmp1),y    ; MSB of z
003014r 3  88                           dey
003015r 3  88                           dey
003016r 3               
003016r 3  F1 24                        sbc (tmp1),y    ; MSB of xt
003018r 3  95 01                        sta 1,x
00301Ar 3               
00301Ar 3  60           z_wordsize:     rts
00301Br 3               
00301Br 3               
00301Br 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
00301Br 3               ; ## "xor"  auto  ANS core
00301Br 3                       ; """https://forth-standard.org/standard/core/XOR"""
00301Br 3               xt_xor:
00301Br 3  20 rr rr                     jsr underflow_2
00301Er 3               
00301Er 3  B5 00                        lda 0,x
003020r 3  55 02                        eor 2,x
003022r 3  95 02                        sta 2,x
003024r 3               
003024r 3  B5 01                        lda 1,x
003026r 3  55 03                        eor 3,x
003028r 3  95 03                        sta 3,x
00302Ar 3               
00302Ar 3  E8                           inx
00302Br 3  E8                           inx
00302Cr 3               
00302Cr 3  60           z_xor:          rts
00302Dr 3               
00302Dr 3               
00302Dr 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
00302Dr 3               ; ## "0"  auto  Tali Forth
00302Dr 3                       ; """The disassembler assumes that this routine does not use Y. Note
00302Dr 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
00302Dr 3                       ; is 0."""
00302Dr 3               xt_case:
00302Dr 3               xt_forth_wordlist:
00302Dr 3               xt_zero:
00302Dr 3  CA                           dex             ; push
00302Er 3  CA                           dex
00302Fr 3  74 00                        stz 0,x
003031r 3  74 01                        stz 1,x
003033r 3               z_case:
003033r 3               z_forth_wordlist:
003033r 3               z_zero:
003033r 3  60                           rts
003034r 3               
003034r 3               
003034r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
003034r 3               ; ## "0="  auto  ANS core
003034r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
003034r 3               
003034r 3               xt_zero_equal:
003034r 3  20 rr rr                     jsr underflow_1
003037r 3               
003037r 3  B5 00                        lda 0,x
003039r 3  15 01                        ora 1,x
00303Br 3  F0 04                        beq @zero
00303Dr 3               
00303Dr 3                               ; not a zero, so we need a FALSE flag (0)
00303Dr 3  A9 00                        lda #0
00303Fr 3  80 02                        bra @store
003041r 3               @zero:
003041r 3                               ; We have a zero, so we need a TRUE flag (-1)
003041r 3  A9 FF                        lda #$ff
003043r 3               @store:
003043r 3  95 00                        sta 0,x
003045r 3  95 01                        sta 1,x
003047r 3               
003047r 3  60           z_zero_equal:   rts
003048r 3               
003048r 3               
003048r 3               
003048r 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
003048r 3               ; ## "0>"  auto  ANS core ext
003048r 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
003048r 3               
003048r 3               xt_zero_greater:
003048r 3  20 rr rr                     jsr underflow_1
00304Br 3               
00304Br 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
00304Dr 3               
00304Dr 3  B5 01                        lda 1,x         ; MSB
00304Fr 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
003051r 3  15 00                        ora 0,x
003053r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
003055r 3               
003055r 3  88                           dey             ; TOS is postive, make true
003056r 3               @done:
003056r 3  98                           tya
003057r 3  95 00                        sta 0,x
003059r 3  95 01                        sta 1,x
00305Br 3               
00305Br 3  60           z_zero_greater: rts
00305Cr 3               
00305Cr 3               
00305Cr 3               
00305Cr 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
00305Cr 3               ; ## "0<"  auto  ANS core
00305Cr 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
00305Cr 3               
00305Cr 3               xt_zero_less:
00305Cr 3  20 rr rr                     jsr underflow_1
00305Fr 3               
00305Fr 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
003061r 3               
003061r 3  B5 01                        lda 1,x         ; MSB
003063r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
003065r 3               
003065r 3  88                           dey             ; TOS is negative, make TRUE
003066r 3               @done:
003066r 3  98                           tya
003067r 3  95 00                        sta 0,x
003069r 3  95 01                        sta 1,x
00306Br 3               
00306Br 3  60           z_zero_less:    rts
00306Cr 3               
00306Cr 3               
00306Cr 3               
00306Cr 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
00306Cr 3               ; ## "0<>"  auto  ANS core ext
00306Cr 3                       ; """https://forth-standard.org/standard/core/Zerone"""
00306Cr 3               
00306Cr 3               xt_zero_unequal:
00306Cr 3  20 rr rr                     jsr underflow_1
00306Fr 3               
00306Fr 3  A0 00                        ldy #0          ; default false
003071r 3               
003071r 3  B5 00                        lda 0,x
003073r 3  15 01                        ora 1,x
003075r 3  F0 01                        beq @got_zero
003077r 3               
003077r 3  88                           dey
003078r 3               @got_zero:
003078r 3  98                           tya
003079r 3  95 00                        sta 0,x
00307Br 3  95 01                        sta 1,x
00307Dr 3               
00307Dr 3  60           z_zero_unequal: rts
00307Er 3               
00307Er 3               
00307Er 3               
00307Er 3               ; ==========================================================
00307Er 3               ; EDITOR words
00307Er 3               
00307Er 3               ; This routine is used by both enter-screen and erase-screen
00307Er 3               ; to get a buffer for the given screen number and set SCR to
00307Er 3               ; the given screen number.  This word is not in the dictionary.
00307Er 3               xt_editor_screen_helper:
00307Er 3  20 rr rr                     jsr xt_dup
003081r 3  20 rr rr                     jsr xt_scr
003084r 3  20 rr rr                     jsr xt_store
003087r 3  20 rr rr                     jsr xt_buffer
00308Ar 3               z_editor_screen_helper:
00308Ar 3  60                           rts
00308Br 3               
00308Br 3               
00308Br 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
00308Br 3               ; ## "enter-screen"  auto  Tali Editor
00308Br 3               
00308Br 3               xt_editor_enter_screen:
00308Br 3                               ; Set the variable SCR and get a buffer for the
00308Br 3                               ; given screen number.
00308Br 3  20 rr rr                     jsr xt_editor_screen_helper
00308Er 3               
00308Er 3                               ; Drop the buffer address.
00308Er 3  20 rr rr                     jsr xt_drop
003091r 3               
003091r 3                               ; Overwrite the lines one at a time.
003091r 3  64 2E                        stz editor1
003093r 3               @prompt_loop:
003093r 3                               ; Put the current line number on the stack.
003093r 3  CA                           dex
003094r 3  CA                           dex
003095r 3  A5 2E                        lda editor1
003097r 3  95 00                        sta 0,x
003099r 3  74 01                        stz 1,x
00309Br 3               
00309Br 3                               ; Use the O word to prompt for overwrite.
00309Br 3  20 rr rr                     jsr xt_editor_o
00309Er 3               
00309Er 3                               ; Move on to the next line.
00309Er 3  E6 2E                        inc editor1
0030A0r 3  A9 10                        lda #16
0030A2r 3  C5 2E                        cmp editor1
0030A4r 3  D0 ED                        bne @prompt_loop
0030A6r 3               
0030A6r 3               z_editor_enter_screen:
0030A6r 3  60                           rts
0030A7r 3               
0030A7r 3               
0030A7r 3               
0030A7r 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
0030A7r 3               ; ## "erase-screen"  tested  Tali Editor
0030A7r 3               xt_editor_erase_screen:
0030A7r 3                               ; Set the variable SCR and get a buffer for the
0030A7r 3                               ; given screen number.
0030A7r 3  20 rr rr                     jsr xt_editor_screen_helper
0030AAr 3               
0030AAr 3                               ; Put 1024 (chars/screen) on stack.
0030AAr 3  CA                           dex
0030ABr 3  CA                           dex
0030ACr 3  74 00                        stz 0,x
0030AEr 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
0030B0r 3  95 01                        sta 1,x
0030B2r 3               
0030B2r 3                               ; Erase the entire block (fill with spaces).
0030B2r 3  20 rr rr                     jsr xt_blank
0030B5r 3               
0030B5r 3                               ; Mark buffer as updated.
0030B5r 3  20 rr rr                     jsr xt_update
0030B8r 3               
0030B8r 3               z_editor_erase_screen:
0030B8r 3  60                           rts
0030B9r 3               
0030B9r 3               
0030B9r 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
0030B9r 3               ; ## "el"  tested  Tali Editor
0030B9r 3               xt_editor_el:
0030B9r 3                               ; Turn the line number into buffer offset.
0030B9r 3                               ; This also loads the block into the buffer if it's
0030B9r 3                               ; not there for some reason.
0030B9r 3  20 rr rr                     jsr xt_editor_line
0030BCr 3               
0030BCr 3                               ; Put 64 (# of chars/line) on the stack.
0030BCr 3  CA                           dex
0030BDr 3  CA                           dex
0030BEr 3  A9 40                        lda #64
0030C0r 3  95 00                        sta 0,x
0030C2r 3  74 01                        stz 1,x
0030C4r 3               
0030C4r 3                               ; Fill with spaces.
0030C4r 3  20 rr rr                     jsr xt_blank
0030C7r 3               
0030C7r 3                               ; Mark buffer as updated.
0030C7r 3  20 rr rr                     jsr xt_update
0030CAr 3               
0030CAr 3  60           z_editor_el:    rts
0030CBr 3               
0030CBr 3               
0030CBr 3               ; ## EDITOR_L ( -- ) "List the current screen"
0030CBr 3               ; ## "l"  tested  Tali Editor
0030CBr 3               
0030CBr 3               xt_editor_l:
0030CBr 3                               ; Load the current screen
0030CBr 3  CA                           dex             ; Put SCR on the stack.
0030CCr 3  CA                           dex
0030CDr 3  A0 02                        ldy #scr_offset
0030CFr 3  B1 1E                        lda (up),y
0030D1r 3  95 00                        sta 0,x
0030D3r 3  C8                           iny
0030D4r 3  B1 1E                        lda (up),y
0030D6r 3  95 01                        sta 1,x
0030D8r 3  20 rr rr                     jsr xt_block    ; Get the current screen.
0030DBr 3               
0030DBr 3  20 rr rr                     jsr xt_cr
0030DEr 3               
0030DEr 3                               ; Print the screen number.
0030DEr 3                               ; We're using sliteral, so we need to set up the
0030DEr 3                               ; appropriate data structure (see sliteral)
0030DEr 3  80 08                        bra @after_screen_msg
0030E0r 3               
0030E0r 3               @screen_msg:
0030E0r 3  53 63 72 65                  .byte "Screen #"
0030E4r 3  65 6E 20 23  
0030E8r 3               
0030E8r 3               @after_screen_msg:
0030E8r 3  20 rr rr                     jsr sliteral_runtime
0030EBr 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
0030EFr 3               
0030EFr 3  20 rr rr                     jsr xt_type
0030F2r 3               
0030F2r 3                               ; Put the screen number and printed size for u.r on the stack.
0030F2r 3  20 rr rr                     jsr xt_scr
0030F5r 3  20 rr rr                     jsr xt_fetch
0030F8r 3  CA                           dex
0030F9r 3  CA                           dex
0030FAr 3  A9 04                        lda #4          ; four spaces
0030FCr 3  95 00                        sta 0,x
0030FEr 3  74 01                        stz 1,x
003100r 3  20 rr rr                     jsr xt_u_dot_r
003103r 3               
003103r 3                               ; The address of the buffer is currently on the stack.
003103r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
003103r 3                               ; keep track of the line number in tmp3.
003103r 3  64 28                        stz tmp3
003105r 3               
003105r 3               @line_loop:
003105r 3  20 rr rr                     jsr xt_cr
003108r 3               
003108r 3                               ; Print the line number (2-space fixed width)
003108r 3  CA                           dex
003109r 3  CA                           dex
00310Ar 3  CA                           dex
00310Br 3  CA                           dex
00310Cr 3  74 03                        stz 3,x
00310Er 3  A5 28                        lda tmp3
003110r 3  95 02                        sta 2,x
003112r 3  74 01                        stz 1,x
003114r 3  A9 02                        lda #2
003116r 3  95 00                        sta 0,x
003118r 3  20 rr rr                     jsr xt_u_dot_r
00311Br 3  20 rr rr                     jsr xt_space
00311Er 3               
00311Er 3                               ; Print one line using the address on the stack.
00311Er 3  20 rr rr                     jsr xt_dup
003121r 3  CA                           dex
003122r 3  CA                           dex
003123r 3  A9 40                        lda #64
003125r 3  95 00                        sta 0,x
003127r 3  74 01                        stz 1,x
003129r 3  20 rr rr                     jsr xt_type
00312Cr 3               
00312Cr 3                               ; Add 64 to the address on the stack to move to the next line.
00312Cr 3  18                           clc
00312Dr 3  A9 40                        lda #64
00312Fr 3  75 00                        adc 0,x
003131r 3  95 00                        sta 0,x
003133r 3  B5 01                        lda 1,x
003135r 3  69 00                        adc #0      ; Add carry
003137r 3  95 01                        sta 1,x
003139r 3               
003139r 3                               ; Increment the line number (held in tmp3)
003139r 3  E6 28                        inc tmp3
00313Br 3               
00313Br 3                               ; See if we are done.
00313Br 3  A5 28                        lda tmp3
00313Dr 3  C9 10                        cmp #16
00313Fr 3  D0 C4                        bne @line_loop
003141r 3               
003141r 3  20 rr rr                     jsr xt_cr
003144r 3                               ; Drop the address on the stack.
003144r 3  E8                           inx
003145r 3  E8                           inx
003146r 3               
003146r 3  60           z_editor_l:            rts
003147r 3               
003147r 3               
003147r 3               
003147r 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
003147r 3               ; ## "line"  tested  Tali Editor
003147r 3               
003147r 3               xt_editor_line:
003147r 3  20 rr rr                     jsr underflow_1
00314Ar 3               
00314Ar 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
00314Ar 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
00314Cr 3               @shift_tos_left:
00314Cr 3  16 00                        asl 0,x         ; Shift TOS to the left
00314Er 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
003150r 3  88                           dey
003151r 3  D0 F9                        bne @shift_tos_left
003153r 3                               ; Load the current screen into a buffer
003153r 3                               ; and get the buffer address
003153r 3  20 rr rr                     jsr xt_scr
003156r 3  20 rr rr                     jsr xt_fetch
003159r 3  20 rr rr                     jsr xt_block
00315Cr 3               
00315Cr 3                               ; Add the offset to the buffer base address.
00315Cr 3  20 rr rr                     jsr xt_plus
00315Fr 3               
00315Fr 3  60           z_editor_line:  rts
003160r 3               
003160r 3               
003160r 3               
003160r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
003160r 3               ; ## "o"  tested  Tali Editor
003160r 3               xt_editor_o:
003160r 3                               ; Print prompt
003160r 3  20 rr rr                     jsr xt_cr
003163r 3  20 rr rr                     jsr xt_dup
003166r 3  20 rr rr                     jsr xt_two
003169r 3  20 rr rr                     jsr xt_u_dot_r
00316Cr 3  20 rr rr                     jsr xt_space
00316Fr 3  A9 2A                        lda #42         ; ASCII for *
003171r 3  20 rr rr                     jsr emit_a
003174r 3  20 rr rr                     jsr xt_space
003177r 3               
003177r 3                               ; Accept new input (directly into the buffer)
003177r 3  20 rr rr                     jsr xt_editor_line
00317Ar 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
00317Dr 3  CA                           dex
00317Er 3  CA                           dex
00317Fr 3  A9 40                        lda #64         ; chars/line
003181r 3  95 00                        sta 0,x
003183r 3  74 01                        stz 1,x
003185r 3  20 rr rr                     jsr xt_accept
003188r 3               
003188r 3                               ; Fill the rest with spaces.
003188r 3                               ; Stack is currently ( line_address numchars_from_accept )
003188r 3  20 rr rr                     jsr xt_dup
00318Br 3  20 rr rr                     jsr xt_not_rote ; -rot
00318Er 3  20 rr rr                     jsr xt_plus
003191r 3  CA                           dex
003192r 3  CA                           dex
003193r 3  A9 40                        lda #64         ; chars/line
003195r 3  95 00                        sta 0,x
003197r 3  74 01                        stz 1,x
003199r 3  20 rr rr                     jsr xt_rot
00319Cr 3  20 rr rr                     jsr xt_minus
00319Fr 3  20 rr rr                     jsr xt_blank
0031A2r 3               
0031A2r 3                               ; Mark buffer as updated.
0031A2r 3  20 rr rr                     jsr xt_update
0031A5r 3               
0031A5r 3  60           z_editor_o:     rts
0031A6r 3               
0031A6r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
0031A6r 3               ; ## "lcdput" coded Custom
0031A6r 3               xt_lcdput:
0031A6r 3  20 rr rr                     jsr underflow_1
0031A9r 3               
0031A9r 3  B5 00                        lda 0,x
0031ABr 3                       .ifdef lcd_print
0031ABr 3  20 rr rr                     jsr lcd_print
0031AEr 3                       .endif
0031AEr 3  E8                           inx
0031AFr 3  E8                           inx
0031B0r 3  60           z_lcdput: rts
0031B1r 3               
0031B1r 3               
0031B1r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
0031B1r 3               ; ## "lcdprint"  coded Custom
0031B1r 3               
0031B1r 3               xt_lcdprint:
0031B1r 3  20 rr rr                     jsr underflow_2
0031B4r 3               
0031B4r 3                               ; Save the starting address into tmp1
0031B4r 3  B5 02                        lda 2,x
0031B6r 3  85 24                        sta tmp1
0031B8r 3  B5 03                        lda 3,x
0031BAr 3  85 25                        sta tmp1+1
0031BCr 3               @loop:
0031BCr 3                               ; done if length is zero
0031BCr 3  B5 00                        lda 0,x
0031BEr 3  15 01                        ora 1,x
0031C0r 3  F0 15                        beq @done
0031C2r 3               
0031C2r 3                               ; Send the current character
0031C2r 3  B2 24                        lda (tmp1)
0031C4r 3                       .ifdef lcd_print
0031C4r 3  20 rr rr                     jsr lcd_print      ; avoids stack foolery
0031C7r 3                       .endif
0031C7r 3                               ; Move the address along (in tmp1)
0031C7r 3  E6 24                        inc tmp1
0031C9r 3  D0 02                        bne @1
0031CBr 3  E6 25                        inc tmp1+1
0031CDr 3               @1:
0031CDr 3                               ; Reduce the count (on the data stack)
0031CDr 3  B5 00                        lda 0,x
0031CFr 3  D0 02                        bne @2
0031D1r 3  D6 01                        dec 1,x
0031D3r 3               @2:
0031D3r 3  D6 00                        dec 0,x
0031D5r 3               
0031D5r 3  80 E5                        bra @loop
0031D7r 3               @done:
0031D7r 3  E8                           inx
0031D8r 3  E8                           inx
0031D9r 3  E8                           inx
0031DAr 3  E8                           inx
0031DBr 3               
0031DBr 3  60           z_lcdprint:         rts
0031DCr 3               
0031DCr 3               
0031DCr 3               
0031DCr 3               ; ## CLS ( -- ) "clea VGA screen"
0031DCr 3               ; ## "cls" coded Custom
0031DCr 3               xt_cls:
0031DCr 3                       .ifdef vga_clear
0031DCr 3  20 rr rr                     jsr vga_clear
0031DFr 3                       .endif
0031DFr 3               
0031DFr 3  60           z_cls: rts
0031E0r 3               
0031E0r 3               
0031E0r 3               ; ## SPI_INIT ( -- ) "Init SPI system"
0031E0r 3               ; ## "spi_init" coded Custom
0031E0r 3               xt_spi_init:
0031E0r 3                       .ifdef spi_init
0031E0r 3  20 rr rr                     jsr spi_init
0031E3r 3                       .endif
0031E3r 3  60           z_spi_init: rts
0031E4r 3               
0031E4r 3               
0031E4r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
0031E4r 3               ; ## "spi_clk_toggle" coded Custom
0031E4r 3               xt_spi_clk_toggle:
0031E4r 3                       .ifdef spi_clk_toggle
0031E4r 3  20 rr rr                     jsr spi_clk_toggle
0031E7r 3                       .endif
0031E7r 3  60           z_spi_clk_toggle: rts
0031E8r 3               
0031E8r 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
0031E8r 3               ; ## "spi_select" coded Custom
0031E8r 3               xt_spi_select:
0031E8r 3  20 rr rr                     jsr underflow_1
0031EBr 3               
0031EBr 3  B5 00                        lda 0,x
0031EDr 3                       .ifdef spi_select
0031EDr 3  20 rr rr                     jsr spi_select
0031F0r 3                       .endif
0031F0r 3  E8                           inx
0031F1r 3  E8                           inx
0031F2r 3  60           z_spi_select: rts
0031F3r 3               
0031F3r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
0031F3r 3               ; ## "spi_transceive" coded Custom
0031F3r 3               xt_spi_transceive:
0031F3r 3  20 rr rr                     jsr underflow_1
0031F6r 3               
0031F6r 3  B5 00                        lda 0,x
0031F8r 3                       .ifdef spi_transceive
0031F8r 3  20 rr rr                     jsr spi_transceive
0031FBr 3                       .endif
0031FBr 3  95 00                        sta 0,x         ; put return value in TOS
0031FDr 3  74 01                        stz 1,X         ;reset value there
0031FFr 3  60           z_spi_transceive: rts
003200r 3               
003200r 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
003200r 3               ; ## "spi_trasceive" coded Custom
003200r 3               xt_sd_init:
003200r 3  20 rr rr                     jsr underflow_1
003203r 3               
003203r 3  B5 00                        lda 0,x
003205r 3                       .ifdef sd_init
003205r 3  20 rr rr                     jsr sd_init
003208r 3                       .endif
003208r 3  95 00                        sta 0,x         ; put return value in TOS
00320Ar 3  74 01                        stz 1,X         ;reset value there
00320Cr 3  60           z_sd_init: rts
00320Dr 3               
00320Dr 3               ; TODO add routine to send a block of data in memory via SPI
00320Dr 3               ; similar to lcdprint
00320Dr 3               
00320Dr 3               ; END
00320Dr 3               
00320Dr 3               
00320Dr 2               .include "assembler.asm"        ; SAN assembler
00320Dr 3               ; Assembler for Tali Forth 2
00320Dr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00320Dr 3               ; First version: 07. Nov 2014 (as tasm65c02)
00320Dr 3               ; This version: 03. Jan 2019
00320Dr 3               
00320Dr 3               ; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
00320Dr 3               ; is included with
00320Dr 3               
00320Dr 3               ;       assembler-wordlist >order
00320Dr 3               
00320Dr 3               ; the opcodes are available as normal Forth words. The format is Simpler
00320Dr 3               ; Assembler Notation (SAN) which separates the opcode completely from the
00320Dr 3               ; operand (see https://github.com/scotws/SAN). In this case, the operand is
00320Dr 3               ; entered before the opcode in the postfix Forth notation (for example, "2000
00320Dr 3               ; lda.#"). See the assembler documenation in the manual for more detail.
00320Dr 3               
00320Dr 3               ; The code here was originally used in A Typist's Assembler for the 65c02
00320Dr 3               ; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
00320Dr 3               ; version. Tasm65c02 is in the public domain.
00320Dr 3               
00320Dr 3               ; This code makes use of the opcode tables stored as part of the disassembler.
00320Dr 3               
00320Dr 3               ; ==========================================================
00320Dr 3               ; MNEMONICS
00320Dr 3               
00320Dr 3               ; The assembler instructions are realized as individual Forth words with
00320Dr 3               ; entries in the assembler wordlist (see header.asm). We pass the opcode in A.
00320Dr 3               
00320Dr 3               ; An alterantive method would have been along the lines of
00320Dr 3               
00320Dr 3               ;               jsr asm_common
00320Dr 3               ;               .byte $EA
00320Dr 3               
00320Dr 3               ; where the asm_common then uses the address on the Return Stack to pick up the
00320Dr 3               ; opcode and the length. Though this uses fewer resources, the current version
00320Dr 3               ; makes up for this by simplifying the code of asm_common.
00320Dr 3               
00320Dr 3               ; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
00320Dr 3               ; SAN and traditional mnemonics are listed after the opcode load instruction.
00320Dr 3               ; This list was generated by a Python script in the tools folder, see there for
00320Dr 3               ; more detail.
00320Dr 3               
00320Dr 3               assembler:              ; used to calculate size of assembler code
00320Dr 3               
00320Dr 3               xt_asm_adc_h:   ; adc.# \ ADC #nn
00320Dr 3  A9 69                        lda #$69
00320Fr 3  4C rr rr                     jmp asm_common
003212r 3               z_asm_adc_h:
003212r 3               
003212r 3               xt_asm_adc_x:   ; adc.x \ ADC nnnn,X
003212r 3  A9 7D                        lda #$7D
003214r 3  4C rr rr                     jmp asm_common
003217r 3               z_asm_adc_x:
003217r 3               
003217r 3               xt_asm_adc_y:   ; adc.y \ ADC nnnn,Y
003217r 3  A9 79                        lda #$79
003219r 3  4C rr rr                     jmp asm_common
00321Cr 3               z_asm_adc_y:
00321Cr 3               
00321Cr 3               xt_asm_adc_z:   ; adc.z \ ADC nn
00321Cr 3  A9 65                        lda #$65
00321Er 3  4C rr rr                     jmp asm_common
003221r 3               z_asm_adc_z:
003221r 3               
003221r 3               xt_asm_adc_zi:  ; adc.zi \ ADC (nn)
003221r 3  A9 72                        lda #$72
003223r 3  4C rr rr                     jmp asm_common
003226r 3               z_asm_adc_zi:
003226r 3               
003226r 3               xt_asm_adc_ziy: ; adc.ziy \ ADC (nn),Y
003226r 3  A9 71                        lda #$71
003228r 3  4C rr rr                     jmp asm_common
00322Br 3               z_asm_adc_ziy:
00322Br 3               
00322Br 3               xt_asm_adc_zx:  ; adc.zx \ ADC nn,X
00322Br 3  A9 75                        lda #$75
00322Dr 3  4C rr rr                     jmp asm_common
003230r 3               z_asm_adc_zx:
003230r 3               
003230r 3               xt_asm_adc_zxi: ; adc.zxi \ ADC (nn,X)
003230r 3  A9 61                        lda #$61
003232r 3  4C rr rr                     jmp asm_common
003235r 3               z_asm_adc_zxi:
003235r 3               
003235r 3               xt_asm_and:     ; and. \ AND nnnn
003235r 3  A9 2D                        lda #$2D
003237r 3  4C rr rr                     jmp asm_common
00323Ar 3               z_asm_and:
00323Ar 3               
00323Ar 3               xt_asm_and_h:   ; and.# \ AND #nn
00323Ar 3  A9 29                        lda #$29
00323Cr 3  4C rr rr                     jmp asm_common
00323Fr 3               z_asm_and_h:
00323Fr 3               
00323Fr 3               xt_asm_and_x:   ; and.x \ AND nnnn,X
00323Fr 3  A9 3D                        lda #$3D
003241r 3  4C rr rr                     jmp asm_common
003244r 3               z_asm_and_x:
003244r 3               
003244r 3               xt_asm_and_y:   ; and.y \ AND nnnn,Y
003244r 3  A9 39                        lda #$39
003246r 3  4C rr rr                     jmp asm_common
003249r 3               z_asm_and_y:
003249r 3               
003249r 3               xt_asm_and_z:   ; and.z \ AND nn
003249r 3  A9 25                        lda #$25
00324Br 3  4C rr rr                     jmp asm_common
00324Er 3               z_asm_and_z:
00324Er 3               
00324Er 3               xt_asm_and_zi:  ; and.zi \ AND (nn)
00324Er 3  A9 32                        lda #$32
003250r 3  4C rr rr                     jmp asm_common
003253r 3               z_asm_and_zi:
003253r 3               
003253r 3               xt_asm_and_ziy: ; and.ziy \ AND (nn),Y
003253r 3  A9 31                        lda #$31
003255r 3  4C rr rr                     jmp asm_common
003258r 3               z_asm_and_ziy:
003258r 3               
003258r 3               xt_asm_and_zx:  ; and.zx \ AND nn,X
003258r 3  A9 35                        lda #$35
00325Ar 3  4C rr rr                     jmp asm_common
00325Dr 3               z_asm_and_zx:
00325Dr 3               
00325Dr 3               xt_asm_and_zxi: ; and.zxi \ AND (nn,X)
00325Dr 3  A9 21                        lda #$21
00325Fr 3  4C rr rr                     jmp asm_common
003262r 3               z_asm_and_zxi:
003262r 3               
003262r 3               xt_asm_asl:     ; asl \ ASL nnnn
003262r 3  A9 0E                        lda #$0E
003264r 3  4C rr rr                     jmp asm_common
003267r 3               z_asm_asl:
003267r 3               
003267r 3               xt_asm_asl_a:   ; asl.a \ ASL
003267r 3  A9 0A                        lda #$0A
003269r 3  4C rr rr                     jmp asm_common
00326Cr 3               z_asm_asl_a:
00326Cr 3               
00326Cr 3               xt_asm_asl_x:   ; asl.x \ ASL nnnn,X
00326Cr 3  A9 1E                        lda #$1E
00326Er 3  4C rr rr                     jmp asm_common
003271r 3               z_asm_asl_x:
003271r 3               
003271r 3               xt_asm_asl_z:   ; asl.z \ ASL nn
003271r 3  A9 06                        lda #$06
003273r 3  4C rr rr                     jmp asm_common
003276r 3               z_asm_asl_z:
003276r 3               
003276r 3               xt_asm_asl_zx:  ; asl.zx \ ASL nn,X
003276r 3  A9 16                        lda #$16
003278r 3  4C rr rr                     jmp asm_common
00327Br 3               z_asm_asl_zx:
00327Br 3               
00327Br 3               xt_asm_bcc:     ; bcc \ BCC
00327Br 3  A9 90                        lda #$90
00327Dr 3  4C rr rr                     jmp asm_common
003280r 3               z_asm_bcc:
003280r 3               
003280r 3               xt_asm_bcs:     ; bcs \ BCS
003280r 3  A9 B0                        lda #$B0
003282r 3  A0 02                        ldy #2
003284r 3  4C rr rr                     jmp asm_common
003287r 3               z_asm_bcs:
003287r 3               
003287r 3               xt_asm_beq:     ; beq \ BEQ
003287r 3  A9 F0                        lda #$F0
003289r 3  4C rr rr                     jmp asm_common
00328Cr 3               z_asm_beq:
00328Cr 3               
00328Cr 3               xt_asm_bit:     ; bit \ BIT nnnn
00328Cr 3  A9 2C                        lda #$2C
00328Er 3  4C rr rr                     jmp asm_common
003291r 3               z_asm_bit:
003291r 3               
003291r 3               xt_asm_bit_h:   ; bit.# \ BIT #nn
003291r 3  A9 89                        lda #$89
003293r 3  4C rr rr                     jmp asm_common
003296r 3               z_asm_bit_h:
003296r 3               
003296r 3               xt_asm_bit_x:   ; bit.x \ BIT nnnn,X
003296r 3  A9 3C                        lda #$3C
003298r 3  4C rr rr                     jmp asm_common
00329Br 3               z_asm_bit_x:
00329Br 3               
00329Br 3               xt_asm_bit_z:   ; bit.z \ BIT nn
00329Br 3  A9 24                        lda #$24
00329Dr 3  4C rr rr                     jmp asm_common
0032A0r 3               z_asm_bit_z:
0032A0r 3               
0032A0r 3               xt_asm_bit_zx:  ; bit.zx \ BIT nn,X
0032A0r 3  A9 34                        lda #$34
0032A2r 3  4C rr rr                     jmp asm_common
0032A5r 3               z_asm_bit_zx:
0032A5r 3               
0032A5r 3               xt_asm_bmi:     ; bmi \ BMI
0032A5r 3  A9 30                        lda #$30
0032A7r 3  4C rr rr                     jmp asm_common
0032AAr 3               z_asm_bmi:
0032AAr 3               
0032AAr 3               xt_asm_bne:     ; bne \ BNE
0032AAr 3  A9 D0                        lda #$D0
0032ACr 3  4C rr rr                     jmp asm_common
0032AFr 3               z_asm_bne:
0032AFr 3               
0032AFr 3               xt_asm_bpl:     ; bpl \ BPL
0032AFr 3  A9 10                        lda #$10
0032B1r 3  4C rr rr                     jmp asm_common
0032B4r 3               z_asm_bpl:
0032B4r 3               
0032B4r 3               xt_asm_bra:     ; bra \ BRA
0032B4r 3  A9 80                        lda #$80
0032B6r 3  4C rr rr                     jmp asm_common
0032B9r 3               z_asm_bra:
0032B9r 3               
0032B9r 3               xt_asm_brk:     ; brk \ BRK
0032B9r 3  A9 00                        lda #$00
0032BBr 3  4C rr rr                     jmp asm_common
0032BEr 3               z_asm_brk:
0032BEr 3               
0032BEr 3               xt_asm_bvc:     ; bvc \ BVC
0032BEr 3  A9 50                        lda #$50
0032C0r 3  4C rr rr                     jmp asm_common
0032C3r 3               z_asm_bvc:
0032C3r 3               
0032C3r 3               xt_asm_bvs:     ; bvs \ BVS
0032C3r 3  A9 70                        lda #$70
0032C5r 3  4C rr rr                     jmp asm_common
0032C8r 3               z_asm_bvs:
0032C8r 3               
0032C8r 3               xt_asm_clc:     ; clc \ CLC
0032C8r 3  A9 18                        lda #$18
0032CAr 3  4C rr rr                     jmp asm_common
0032CDr 3               z_asm_clc:
0032CDr 3               
0032CDr 3               xt_asm_cld:     ; cld \ CLD
0032CDr 3  A9 D8                        lda #$D8
0032CFr 3  4C rr rr                     jmp asm_common
0032D2r 3               z_asm_cld:
0032D2r 3               
0032D2r 3               xt_asm_cli:     ; cli \ CLI
0032D2r 3  A9 58                        lda #$58
0032D4r 3  4C rr rr                     jmp asm_common
0032D7r 3               z_asm_cli:
0032D7r 3               
0032D7r 3               xt_asm_clv:     ; clv \ CLV
0032D7r 3  A9 B8                        lda #$B8
0032D9r 3  4C rr rr                     jmp asm_common
0032DCr 3               z_asm_clv:
0032DCr 3               
0032DCr 3               xt_asm_cmp:     ; cmp \ CMP nnnn
0032DCr 3  A9 CD                        lda #$CD
0032DEr 3  4C rr rr                     jmp asm_common
0032E1r 3               z_asm_cmp:
0032E1r 3               
0032E1r 3               xt_asm_cmp_h:   ; cmp.# \ CMP #nn
0032E1r 3  A9 C9                        lda #$C9
0032E3r 3  4C rr rr                     jmp asm_common
0032E6r 3               z_asm_cmp_h:
0032E6r 3               
0032E6r 3               xt_asm_cmp_x:   ; cmp.x \ CMP nnnn,X
0032E6r 3  A9 DD                        lda #$DD
0032E8r 3  4C rr rr                     jmp asm_common
0032EBr 3               z_asm_cmp_x:
0032EBr 3               
0032EBr 3               xt_asm_cmp_y:   ; cmp.y \ CMP nnnn,Y
0032EBr 3  A9 D9                        lda #$D9
0032EDr 3  4C rr rr                     jmp asm_common
0032F0r 3               z_asm_cmp_y:
0032F0r 3               
0032F0r 3               xt_asm_cmp_z:   ; cmp.z \ CMP nn
0032F0r 3  A9 C5                        lda #$C5
0032F2r 3  4C rr rr                     jmp asm_common
0032F5r 3               z_asm_cmp_z:
0032F5r 3               
0032F5r 3               xt_asm_cmp_zi:  ; cmp.zi \ CMP (nn)
0032F5r 3  A9 D2                        lda #$D2
0032F7r 3  4C rr rr                     jmp asm_common
0032FAr 3               z_asm_cmp_zi:
0032FAr 3               
0032FAr 3               xt_asm_cmp_ziy: ; cmp.ziy \ CMP (nn),Y
0032FAr 3  A9 D1                        lda #$D1
0032FCr 3  4C rr rr                     jmp asm_common
0032FFr 3               z_asm_cmp_ziy:
0032FFr 3               
0032FFr 3               xt_asm_cmp_zx:  ; cmp.zx \ CMP nn,X
0032FFr 3  A9 D5                        lda #$D5
003301r 3  4C rr rr                     jmp asm_common
003304r 3               z_asm_cmp_zx:
003304r 3               
003304r 3               xt_asm_cmp_zxi: ; cmp.zxi \ CMP (nn,X)
003304r 3  A9 C1                        lda #$C1
003306r 3  4C rr rr                     jmp asm_common
003309r 3               z_asm_cmp_zxi:
003309r 3               
003309r 3               xt_asm_cpx:     ; cpx \ CPX nnnn
003309r 3  A9 EC                        lda #$EC
00330Br 3  4C rr rr                     jmp asm_common
00330Er 3               z_asm_cpx:
00330Er 3               
00330Er 3               xt_asm_cpx_h:   ; cpx.# \ CPX #nn
00330Er 3  A9 E0                        lda #$E0
003310r 3  4C rr rr                     jmp asm_common
003313r 3               z_asm_cpx_h:
003313r 3               
003313r 3               xt_asm_cpx_z:   ; cpx.z \ CPX nn
003313r 3  A9 E4                        lda #$E4
003315r 3  4C rr rr                     jmp asm_common
003318r 3               z_asm_cpx_z:
003318r 3               
003318r 3               xt_asm_cpy:     ; cpy \ CPY
003318r 3  A9 CC                        lda #$CC
00331Ar 3  A0 03                        ldy #3
00331Cr 3  4C rr rr                     jmp asm_common
00331Fr 3               z_asm_cpy:
00331Fr 3               
00331Fr 3               xt_asm_cpy_h:   ; cpy.# \ CPY #nn
00331Fr 3  A9 C0                        lda #$C0
003321r 3  4C rr rr                     jmp asm_common
003324r 3               z_asm_cpy_h:
003324r 3               
003324r 3               xt_asm_cpy_z:   ; cpy.z \ CPY nn
003324r 3  A9 C4                        lda #$C4
003326r 3  4C rr rr                     jmp asm_common
003329r 3               z_asm_cpy_z:
003329r 3               
003329r 3               xt_asm_dec:     ; dec \ DEC nnnn
003329r 3  A9 CE                        lda #$CE
00332Br 3  4C rr rr                     jmp asm_common
00332Er 3               z_asm_dec:
00332Er 3               
00332Er 3               xt_asm_dec_a:   ; dec.a \ DEC
00332Er 3  A9 3A                        lda #$3A
003330r 3  4C rr rr                     jmp asm_common
003333r 3               z_asm_dec_a:
003333r 3               
003333r 3               xt_asm_dec_x:   ; dec.x \ DEC nnnn,X
003333r 3  A9 DE                        lda #$DE
003335r 3  4C rr rr                     jmp asm_common
003338r 3               z_asm_dec_x:
003338r 3               
003338r 3               xt_asm_dec_z:   ; dec.z \ DEC nn
003338r 3  A9 C6                        lda #$C6
00333Ar 3  4C rr rr                     jmp asm_common
00333Dr 3               z_asm_dec_z:
00333Dr 3               
00333Dr 3               xt_asm_dec_zx:  ; dec.zx \ DEC nn,X
00333Dr 3  A9 D6                        lda #$D6
00333Fr 3  4C rr rr                     jmp asm_common
003342r 3               z_asm_dec_zx:
003342r 3               
003342r 3               xt_asm_dex:     ; dex \ DEX
003342r 3  A9 CA                        lda #$CA
003344r 3  4C rr rr                     jmp asm_common
003347r 3               z_asm_dex:
003347r 3               
003347r 3               xt_asm_dey:     ; dey \ DEY
003347r 3  A9 88                        lda #$88
003349r 3  4C rr rr                     jmp asm_common
00334Cr 3               z_asm_dey:
00334Cr 3               
00334Cr 3               xt_asm_eor:     ; eor \ EOR nnnn
00334Cr 3  A9 4D                        lda #$4D
00334Er 3  4C rr rr                     jmp asm_common
003351r 3               z_asm_eor:
003351r 3               
003351r 3               xt_asm_eor_h:   ; eor.# \ EOR #nn
003351r 3  A9 49                        lda #$49
003353r 3  4C rr rr                     jmp asm_common
003356r 3               z_asm_eor_h:
003356r 3               
003356r 3               xt_asm_eor_x:   ; eor.x \ EOR nnnn,X
003356r 3  A9 5D                        lda #$5D
003358r 3  4C rr rr                     jmp asm_common
00335Br 3               z_asm_eor_x:
00335Br 3               
00335Br 3               xt_asm_eor_y:   ; eor.y \ EOR nnnn,Y
00335Br 3  A9 59                        lda #$59
00335Dr 3  4C rr rr                     jmp asm_common
003360r 3               z_asm_eor_y:
003360r 3               
003360r 3               xt_asm_eor_z:   ; eor.z \ EOR nn
003360r 3  A9 45                        lda #$45
003362r 3  4C rr rr                     jmp asm_common
003365r 3               z_asm_eor_z:
003365r 3               
003365r 3               xt_asm_eor_zi:  ; eor.zi \ EOR (nn)
003365r 3  A9 52                        lda #$52
003367r 3  4C rr rr                     jmp asm_common
00336Ar 3               z_asm_eor_zi:
00336Ar 3               
00336Ar 3               xt_asm_eor_ziy: ; eor.ziy \ EOR (nn),Y
00336Ar 3  A9 51                        lda #$51
00336Cr 3  4C rr rr                     jmp asm_common
00336Fr 3               z_asm_eor_ziy:
00336Fr 3               
00336Fr 3               xt_asm_eor_zx:  ; eor.zx \ EOR nn,X
00336Fr 3  A9 55                        lda #$55
003371r 3  4C rr rr                     jmp asm_common
003374r 3               z_asm_eor_zx:
003374r 3               
003374r 3               xt_asm_eor_zxi: ; eor.zxi \ EOR (nn,X)
003374r 3  A9 41                        lda #$41
003376r 3  4C rr rr                     jmp asm_common
003379r 3               z_asm_eor_zxi:
003379r 3               
003379r 3               xt_asm_inc:     ; inc \ INC nnnn
003379r 3  A9 EE                        lda #$EE
00337Br 3  4C rr rr                     jmp asm_common
00337Er 3               z_asm_inc:
00337Er 3               
00337Er 3               xt_asm_inc_a:   ; inc.a \ INC
00337Er 3  A9 1A                        lda #$1A
003380r 3  4C rr rr                     jmp asm_common
003383r 3               z_asm_inc_a:
003383r 3               
003383r 3               xt_asm_inc_x:   ; inc.x \ INC nnnn,X
003383r 3  A9 FE                        lda #$FE
003385r 3  4C rr rr                     jmp asm_common
003388r 3               z_asm_inc_x:
003388r 3               
003388r 3               xt_asm_inc_z:   ; inc.z \ INC nn
003388r 3  A9 E6                        lda #$E6
00338Ar 3  4C rr rr                     jmp asm_common
00338Dr 3               z_asm_inc_z:
00338Dr 3               
00338Dr 3               xt_asm_inc_zx:  ; inc.zx \ INC nn,X
00338Dr 3  A9 F6                        lda #$F6
00338Fr 3  4C rr rr                     jmp asm_common
003392r 3               z_asm_inc_zx:
003392r 3               
003392r 3               xt_asm_inx:     ; inx \ INX
003392r 3  A9 E8                        lda #$E8
003394r 3  4C rr rr                     jmp asm_common
003397r 3               z_asm_inx:
003397r 3               
003397r 3               xt_asm_iny:     ; iny \ INY
003397r 3  A9 C8                        lda #$C8
003399r 3  4C rr rr                     jmp asm_common
00339Cr 3               z_asm_iny:
00339Cr 3               
00339Cr 3               xt_asm_jmp:     ; jmp \ JMP nnnn
00339Cr 3  A9 4C                        lda #$4C
00339Er 3  4C rr rr                     jmp asm_common
0033A1r 3               z_asm_jmp:
0033A1r 3               
0033A1r 3               xt_asm_jmp_i:   ; jmp.i \ JMP (nnnn)
0033A1r 3  A9 6C                        lda #$6C
0033A3r 3  4C rr rr                     jmp asm_common
0033A6r 3               z_asm_jmp_i:
0033A6r 3               
0033A6r 3               xt_asm_jmp_xi:  ; jmp.xi \ JMP (nnnn,X)
0033A6r 3  A9 7C                        lda #$7C
0033A8r 3  4C rr rr                     jmp asm_common
0033ABr 3               z_asm_jmp_xi:
0033ABr 3               
0033ABr 3               xt_asm_jsr:     ; jsr \ JSR nnnn
0033ABr 3  A9 20                        lda #$20
0033ADr 3  4C rr rr                     jmp asm_common
0033B0r 3               z_asm_jsr:
0033B0r 3               
0033B0r 3               xt_asm_lda:     ; lda \ LDA nnnn
0033B0r 3  A9 AD                        lda #$AD
0033B2r 3  4C rr rr                     jmp asm_common
0033B5r 3               z_asm_lda:
0033B5r 3               
0033B5r 3               xt_asm_lda_h:   ; lda.# \ LDA #nn
0033B5r 3  A9 A9                        lda #$A9
0033B7r 3  4C rr rr                     jmp asm_common
0033BAr 3               z_asm_lda_h:
0033BAr 3               
0033BAr 3               xt_asm_lda_x:   ; lda.x \ LDA nnnn,X
0033BAr 3  A9 BD                        lda #$BD
0033BCr 3  4C rr rr                     jmp asm_common
0033BFr 3               z_asm_lda_x:
0033BFr 3               
0033BFr 3               xt_asm_lda_y:   ; lda.y \ LDA nnnn,Y
0033BFr 3  A9 B9                        lda #$B9
0033C1r 3  4C rr rr                     jmp asm_common
0033C4r 3               z_asm_lda_y:
0033C4r 3               
0033C4r 3               xt_asm_lda_z:   ; lda.z \ LDA nn
0033C4r 3  A9 A5                        lda #$A5
0033C6r 3  4C rr rr                     jmp asm_common
0033C9r 3               z_asm_lda_z:
0033C9r 3               
0033C9r 3               xt_asm_lda_zi:  ; lda.zi \ LDA (nn)
0033C9r 3  A9 B2                        lda #$B2
0033CBr 3  4C rr rr                     jmp asm_common
0033CEr 3               z_asm_lda_zi:
0033CEr 3               
0033CEr 3               xt_asm_lda_ziy: ; lda.ziy \ LDA (nn),Y
0033CEr 3  A9 B1                        lda #$B1
0033D0r 3  4C rr rr                     jmp asm_common
0033D3r 3               z_asm_lda_ziy:
0033D3r 3               
0033D3r 3               xt_asm_lda_zx:  ; lda.zx \ LDA nn,X
0033D3r 3  A9 B5                        lda #$B5
0033D5r 3  4C rr rr                     jmp asm_common
0033D8r 3               z_asm_lda_zx:
0033D8r 3               
0033D8r 3               xt_asm_lda_zxi: ; lda.zxi \ LDA (nn,X)
0033D8r 3  A9 A1                        lda #$A1
0033DAr 3  4C rr rr                     jmp asm_common
0033DDr 3               z_asm_lda_zxi:
0033DDr 3               
0033DDr 3               xt_asm_ldx:     ; ldx \ LDX nnnn
0033DDr 3  A9 AE                        lda #$AE
0033DFr 3  4C rr rr                     jmp asm_common
0033E2r 3               z_asm_ldx:
0033E2r 3               
0033E2r 3               xt_asm_ldx_h:   ; ldx.# \ LDX #nn
0033E2r 3  A9 A2                        lda #$A2
0033E4r 3  4C rr rr                     jmp asm_common
0033E7r 3               z_asm_ldx_h:
0033E7r 3               
0033E7r 3               xt_asm_ldx_y:   ; ldx.y \ LDX nnnn,Y
0033E7r 3  A9 BE                        lda #$BE
0033E9r 3  4C rr rr                     jmp asm_common
0033ECr 3               z_asm_ldx_y:
0033ECr 3               
0033ECr 3               xt_asm_ldx_z:   ; ldx.z \ LDX nn
0033ECr 3  A9 A6                        lda #$A6
0033EEr 3  4C rr rr                     jmp asm_common
0033F1r 3               z_asm_ldx_z:
0033F1r 3               
0033F1r 3               xt_asm_ldx_zy:  ; ldx.zy \ LDX nn,Y
0033F1r 3  A9 B6                        lda #$B6
0033F3r 3  4C rr rr                     jmp asm_common
0033F6r 3               z_asm_ldx_zy:
0033F6r 3               
0033F6r 3               xt_asm_ldy:     ; ldy \ LDY nnnn
0033F6r 3  A9 AC                        lda #$AC
0033F8r 3  4C rr rr                     jmp asm_common
0033FBr 3               z_asm_ldy:
0033FBr 3               
0033FBr 3               xt_asm_ldy_h:   ; ldy.# \ LDY #nn
0033FBr 3  A9 A0                        lda #$A0
0033FDr 3  4C rr rr                     jmp asm_common
003400r 3               z_asm_ldy_h:
003400r 3               
003400r 3               xt_asm_ldy_x:   ; ldy.x \ LDY nnnn,X
003400r 3  A9 BC                        lda #$BC
003402r 3  4C rr rr                     jmp asm_common
003405r 3               z_asm_ldy_x:
003405r 3               
003405r 3               xt_asm_ldy_z:   ; ldy.z \ LDY nn
003405r 3  A9 A4                        lda #$A4
003407r 3  4C rr rr                     jmp asm_common
00340Ar 3               z_asm_ldy_z:
00340Ar 3               
00340Ar 3               xt_asm_ldy_zx:  ; ldy.zx \ LDY nn,X
00340Ar 3  A9 B4                        lda #$B4
00340Cr 3  4C rr rr                     jmp asm_common
00340Fr 3               z_asm_ldy_zx:
00340Fr 3               
00340Fr 3               xt_asm_lsr:     ; lsr \ LSR nnnn
00340Fr 3  A9 4E                        lda #$4E
003411r 3  4C rr rr                     jmp asm_common
003414r 3               z_asm_lsr:
003414r 3               
003414r 3               xt_asm_lsr_a:   ; lsr.a \ LSR
003414r 3  A9 4A                        lda #$4A
003416r 3  4C rr rr                     jmp asm_common
003419r 3               z_asm_lsr_a:
003419r 3               
003419r 3               xt_asm_lsr_x:   ; lsr.x \ LSR nnnn,X
003419r 3  A9 5E                        lda #$5E
00341Br 3  4C rr rr                     jmp asm_common
00341Er 3               z_asm_lsr_x:
00341Er 3               
00341Er 3               xt_asm_lsr_z:   ; lsr.z \ LSR nn
00341Er 3  A9 46                        lda #$46
003420r 3  4C rr rr                     jmp asm_common
003423r 3               z_asm_lsr_z:
003423r 3               
003423r 3               xt_asm_lsr_zx:  ; lsr.zx \ LSR nn,X
003423r 3  A9 56                        lda #$56
003425r 3  4C rr rr                     jmp asm_common
003428r 3               z_asm_lsr_zx:
003428r 3               
003428r 3               xt_asm_nop:     ; nop \ NOP
003428r 3  A9 EA                        lda #$EA
00342Ar 3  4C rr rr                     jmp asm_common
00342Dr 3               z_asm_nop:
00342Dr 3               
00342Dr 3               xt_asm_ora:     ; ora \ ORA nnnn
00342Dr 3  A9 0D                        lda #$0D
00342Fr 3  4C rr rr                     jmp asm_common
003432r 3               z_asm_ora:
003432r 3               
003432r 3               xt_asm_ora_h:   ; ora.# \ ORA #nn
003432r 3  A9 09                        lda #$09
003434r 3  4C rr rr                     jmp asm_common
003437r 3               z_asm_ora_h:
003437r 3               
003437r 3               xt_asm_ora_x:   ; ora.x \ ORA nnnn,X
003437r 3  A9 1D                        lda #$1D
003439r 3  4C rr rr                     jmp asm_common
00343Cr 3               z_asm_ora_x:
00343Cr 3               
00343Cr 3               xt_asm_ora_y:   ; ora.y \ ORA nnnn,Y
00343Cr 3  A9 19                        lda #$19
00343Er 3  4C rr rr                     jmp asm_common
003441r 3               z_asm_ora_y:
003441r 3               
003441r 3               xt_asm_ora_z:   ; ora.z \ ORA nn
003441r 3  A9 05                        lda #$05
003443r 3  4C rr rr                     jmp asm_common
003446r 3               z_asm_ora_z:
003446r 3               
003446r 3               xt_asm_ora_zi:  ; ora.zi \ ORA.ZI
003446r 3  A9 12                        lda #$12
003448r 3  A0 02                        ldy #2
00344Ar 3  4C rr rr                     jmp asm_common
00344Dr 3               z_asm_ora_zi:
00344Dr 3               
00344Dr 3               xt_asm_ora_ziy: ; ora.ziy \ ORA (nn),Y
00344Dr 3  A9 11                        lda #$11
00344Fr 3  4C rr rr                     jmp asm_common
003452r 3               z_asm_ora_ziy:
003452r 3               
003452r 3               xt_asm_ora_zx:  ; ora.zx \ ORA nn,X
003452r 3  A9 15                        lda #$15
003454r 3  4C rr rr                     jmp asm_common
003457r 3               z_asm_ora_zx:
003457r 3               
003457r 3               xt_asm_ora_zxi: ; ora.zxi \ ORA (nn,X)
003457r 3  A9 01                        lda #$01
003459r 3  4C rr rr                     jmp asm_common
00345Cr 3               z_asm_ora_zxi:
00345Cr 3               
00345Cr 3               xt_asm_pha:     ; pha \ PHA
00345Cr 3  A9 48                        lda #$48
00345Er 3  4C rr rr                     jmp asm_common
003461r 3               z_asm_pha:
003461r 3               
003461r 3               xt_asm_php:     ; php \ PHP
003461r 3  A9 08                        lda #$08
003463r 3  4C rr rr                     jmp asm_common
003466r 3               z_asm_php:
003466r 3               
003466r 3               xt_asm_phx:     ; phx \ PHX
003466r 3  A9 DA                        lda #$DA
003468r 3  4C rr rr                     jmp asm_common
00346Br 3               z_asm_phx:
00346Br 3               
00346Br 3               xt_asm_phy:     ; phy \ PHY
00346Br 3  A9 5A                        lda #$5A
00346Dr 3  4C rr rr                     jmp asm_common
003470r 3               z_asm_phy:
003470r 3               
003470r 3               xt_asm_pla:     ; pla \ PLA
003470r 3  A9 68                        lda #$68
003472r 3  4C rr rr                     jmp asm_common
003475r 3               z_asm_pla:
003475r 3               
003475r 3               xt_asm_plp:     ; plp \ PLP
003475r 3  A9 28                        lda #$28
003477r 3  4C rr rr                     jmp asm_common
00347Ar 3               z_asm_plp:
00347Ar 3               
00347Ar 3               xt_asm_plx:     ; plx \ PLX
00347Ar 3  A9 FA                        lda #$FA
00347Cr 3  4C rr rr                     jmp asm_common
00347Fr 3               z_asm_plx:
00347Fr 3               
00347Fr 3               xt_asm_ply:     ; ply \ PLY
00347Fr 3  A9 7A                        lda #$7A
003481r 3  4C rr rr                     jmp asm_common
003484r 3               z_asm_ply:
003484r 3               
003484r 3               xt_asm_rol:     ; rol \ ROL nnnn
003484r 3  A9 2E                        lda #$2E
003486r 3  4C rr rr                     jmp asm_common
003489r 3               z_asm_rol:
003489r 3               
003489r 3               xt_asm_rol_a:   ; rol.a \ ROL
003489r 3  A9 2A                        lda #$2A
00348Br 3  4C rr rr                     jmp asm_common
00348Er 3               z_asm_rol_a:
00348Er 3               
00348Er 3               xt_asm_rol_x:   ; rol.x \ ROL nnnn,X
00348Er 3  A9 3E                        lda #$3E
003490r 3  4C rr rr                     jmp asm_common
003493r 3               z_asm_rol_x:
003493r 3               
003493r 3               xt_asm_rol_z:   ; rol.z \ ROL nn
003493r 3  A9 26                        lda #$26
003495r 3  4C rr rr                     jmp asm_common
003498r 3               z_asm_rol_z:
003498r 3               
003498r 3               xt_asm_rol_zx:  ; rol.zx \ ROL nn,X
003498r 3  A9 36                        lda #$36
00349Ar 3  4C rr rr                     jmp asm_common
00349Dr 3               z_asm_rol_zx:
00349Dr 3               
00349Dr 3               xt_asm_ror:     ; ror \ ROR nnnn
00349Dr 3  A9 6E                        lda #$6E
00349Fr 3  4C rr rr                     jmp asm_common
0034A2r 3               z_asm_ror:
0034A2r 3               
0034A2r 3               xt_asm_ror_a:   ; ror.a \ ROR
0034A2r 3  A9 6A                        lda #$6A
0034A4r 3  4C rr rr                     jmp asm_common
0034A7r 3               z_asm_ror_a:
0034A7r 3               
0034A7r 3               xt_asm_ror_x:   ; ror.x \ ROR nnnn,X
0034A7r 3  A9 7E                        lda #$7E
0034A9r 3  4C rr rr                     jmp asm_common
0034ACr 3               z_asm_ror_x:
0034ACr 3               
0034ACr 3               xt_asm_ror_z:   ; ror.z \ ROR nn
0034ACr 3  A9 66                        lda #$66
0034AEr 3  4C rr rr                     jmp asm_common
0034B1r 3               z_asm_ror_z:
0034B1r 3               
0034B1r 3               xt_asm_ror_zx:  ; ror.zx \ ROR nn,X
0034B1r 3  A9 76                        lda #$76
0034B3r 3  4C rr rr                     jmp asm_common
0034B6r 3               z_asm_ror_zx:
0034B6r 3               
0034B6r 3               xt_asm_rti:     ; rti \ RTI
0034B6r 3  A9 40                        lda #$40
0034B8r 3  4C rr rr                     jmp asm_common
0034BBr 3               z_asm_rti:
0034BBr 3               
0034BBr 3               xt_asm_rts:     ; rts \ RTS
0034BBr 3  A9 60                        lda #$60
0034BDr 3  4C rr rr                     jmp asm_common
0034C0r 3               z_asm_rts:
0034C0r 3               
0034C0r 3               xt_asm_sbc:     ; sbc \ SBC nnnn
0034C0r 3  A9 ED                        lda #$ED
0034C2r 3  4C rr rr                     jmp asm_common
0034C5r 3               z_asm_sbc:
0034C5r 3               
0034C5r 3               xt_asm_sbc_h:   ; sbc.# \ SBC #nn
0034C5r 3  A9 E9                        lda #$E9
0034C7r 3  4C rr rr                     jmp asm_common
0034CAr 3               z_asm_sbc_h:
0034CAr 3               
0034CAr 3               xt_asm_sbc_x:   ; sbc.x \ SBC nnnn,X
0034CAr 3  A9 FD                        lda #$FD
0034CCr 3  4C rr rr                     jmp asm_common
0034CFr 3               z_asm_sbc_x:
0034CFr 3               
0034CFr 3               xt_asm_sbc_y:   ; sbc.y \ SBC nnnn,Y
0034CFr 3  A9 F9                        lda #$F9
0034D1r 3  4C rr rr                     jmp asm_common
0034D4r 3               z_asm_sbc_y:
0034D4r 3               
0034D4r 3               xt_asm_sbc_z:   ; sbc.z \ SBC nn
0034D4r 3  A9 E5                        lda #$E5
0034D6r 3  4C rr rr                     jmp asm_common
0034D9r 3               z_asm_sbc_z:
0034D9r 3               
0034D9r 3               xt_asm_sbc_zi:  ; sbc.zi \ SBC (nn)
0034D9r 3  A9 F2                        lda #$F2
0034DBr 3  4C rr rr                     jmp asm_common
0034DEr 3               z_asm_sbc_zi:
0034DEr 3               
0034DEr 3               xt_asm_sbc_ziy: ; sbc.ziy \ SBC (nn),Y
0034DEr 3  A9 F1                        lda #$F1
0034E0r 3  4C rr rr                     jmp asm_common
0034E3r 3               z_asm_sbc_ziy:
0034E3r 3               
0034E3r 3               xt_asm_sbc_zx:  ; sbc.zx \ SBC nn,X
0034E3r 3  A9 F5                        lda #$F5
0034E5r 3  4C rr rr                     jmp asm_common
0034E8r 3               z_asm_sbc_zx:
0034E8r 3               
0034E8r 3               xt_asm_sbc_zxi: ; sbc.zxi \ SBC (nn,X)
0034E8r 3  A9 E1                        lda #$E1
0034EAr 3  80 7C                        bra asm_common  ; <-- limit for BRA instead of JMP
0034ECr 3               z_asm_sbc_zxi:
0034ECr 3               
0034ECr 3               xt_asm_sec:     ; sec \ SEC
0034ECr 3  A9 38                        lda #$38
0034EEr 3  80 78                        bra asm_common
0034F0r 3               z_asm_sec:
0034F0r 3               
0034F0r 3               xt_asm_sed:     ; sed \ SED
0034F0r 3  A9 F8                        lda #$F8
0034F2r 3  80 74                        bra asm_common
0034F4r 3               z_asm_sed:
0034F4r 3               
0034F4r 3               xt_asm_sei:     ; sei \ SEI
0034F4r 3  A9 78                        lda #$78
0034F6r 3  80 70                        bra asm_common
0034F8r 3               z_asm_sei:
0034F8r 3               
0034F8r 3               xt_asm_sta:     ; sta \ STA nnnn
0034F8r 3  A9 8D                        lda #$8D
0034FAr 3  80 6C                        bra asm_common
0034FCr 3               z_asm_sta:
0034FCr 3               
0034FCr 3               xt_asm_sta_x:   ; sta.x \ STA nnnn,X
0034FCr 3  A9 9D                        lda #$9D
0034FEr 3  80 68                        bra asm_common
003500r 3               z_asm_sta_x:
003500r 3               
003500r 3               xt_asm_sta_y:   ; sta.y \ STA nnnn,Y
003500r 3  A9 99                        lda #$99
003502r 3  80 64                        bra asm_common
003504r 3               z_asm_sta_y:
003504r 3               
003504r 3               xt_asm_sta_z:   ; sta.z \ STA nn
003504r 3  A9 85                        lda #$85
003506r 3  80 60                        bra asm_common
003508r 3               z_asm_sta_z:
003508r 3               
003508r 3               xt_asm_sta_zi:  ; sta.zi \ STA (nn)
003508r 3  A9 92                        lda #$92
00350Ar 3  80 5C                        bra asm_common
00350Cr 3               z_asm_sta_zi:
00350Cr 3               
00350Cr 3               xt_asm_sta_ziy: ; sta.ziy \ STA (nn),Y
00350Cr 3  A9 91                        lda #$91
00350Er 3  80 58                        bra asm_common
003510r 3               z_asm_sta_ziy:
003510r 3               
003510r 3               xt_asm_sta_zx:  ; sta.zx \ STA nn,X
003510r 3  A9 95                        lda #$95
003512r 3  80 54                        bra asm_common
003514r 3               z_asm_sta_zx:
003514r 3               
003514r 3               xt_asm_sta_zxi: ; sta.zxi \ STA (nn,X)
003514r 3  A9 81                        lda #$81
003516r 3  80 50                        bra asm_common
003518r 3               z_asm_sta_zxi:
003518r 3               
003518r 3               xt_asm_stx:     ; stx \ STX nnnn
003518r 3  A9 8E                        lda #$8E
00351Ar 3  80 4C                        bra asm_common
00351Cr 3               z_asm_stx:
00351Cr 3               
00351Cr 3               xt_asm_stx_z:   ; stx.z \ STX nn
00351Cr 3  A9 86                        lda #$86
00351Er 3  80 48                        bra asm_common
003520r 3               z_asm_stx_z:
003520r 3               
003520r 3               xt_asm_stx_zy:  ; stx.zy \ STX nn,Y
003520r 3  A9 96                        lda #$96
003522r 3  80 44                        bra asm_common
003524r 3               z_asm_stx_zy:
003524r 3               
003524r 3               xt_asm_sty:     ; sty \ STY nnnn
003524r 3  A9 8C                        lda #$8C
003526r 3  80 40                        bra asm_common
003528r 3               z_asm_sty:
003528r 3               
003528r 3               xt_asm_sty_z:   ; sty.z \ STY nn
003528r 3  A9 84                        lda #$84
00352Ar 3  80 3C                        bra asm_common
00352Cr 3               z_asm_sty_z:
00352Cr 3               
00352Cr 3               xt_asm_sty_zx:  ; sty.zx \ STY nn,X
00352Cr 3  A9 94                        lda #$94
00352Er 3  80 38                        bra asm_common
003530r 3               z_asm_sty_zx:
003530r 3               
003530r 3               xt_asm_stz:     ; stz \ STZ nnnn
003530r 3  A9 9C                        lda #$9C
003532r 3  80 34                        bra asm_common
003534r 3               z_asm_stz:
003534r 3               
003534r 3               xt_asm_stz_x:   ; stz.x \ STZ nnnn,X
003534r 3  A9 9E                        lda #$9E
003536r 3  80 30                        bra asm_common
003538r 3               z_asm_stz_x:
003538r 3               
003538r 3               xt_asm_stz_z:   ; stz.z \ STZ nn
003538r 3  A9 64                        lda #$64
00353Ar 3  80 2C                        bra asm_common
00353Cr 3               z_asm_stz_z:
00353Cr 3               
00353Cr 3               xt_asm_stz_zx:  ; stz.zx \ STZ nn,X
00353Cr 3  A9 74                        lda #$74
00353Er 3  80 28                        bra asm_common
003540r 3               z_asm_stz_zx:
003540r 3               
003540r 3               xt_asm_tax:     ; tax \ TAX
003540r 3  A9 AA                        lda #$AA
003542r 3  80 24                        bra asm_common
003544r 3               z_asm_tax:
003544r 3               
003544r 3               xt_asm_tay:     ; tay \ TAY
003544r 3  A9 A8                        lda #$A8
003546r 3  80 20                        bra asm_common
003548r 3               z_asm_tay:
003548r 3               
003548r 3               xt_asm_trb:     ; trb \ TRB nnnn
003548r 3  A9 1C                        lda #$1C
00354Ar 3  80 1C                        bra asm_common
00354Cr 3               z_asm_trb:
00354Cr 3               
00354Cr 3               xt_asm_trb_z:   ; trb.z \ TRB nn
00354Cr 3  A9 14                        lda #$14
00354Er 3  80 18                        bra asm_common
003550r 3               z_asm_trb_z:
003550r 3               
003550r 3               xt_asm_tsb:     ; tsb \ TSB nnnn
003550r 3  A9 0C                        lda #$0C
003552r 3  80 14                        bra asm_common
003554r 3               z_asm_tsb:
003554r 3               
003554r 3               xt_asm_tsb_z:   ; tsb.z \ TSB nn
003554r 3  A9 04                        lda #$04
003556r 3  80 10                        bra asm_common
003558r 3               z_asm_tsb_z:
003558r 3               
003558r 3               xt_asm_tsx:     ; tsx \ TSX
003558r 3  A9 BA                        lda #$BA
00355Ar 3  80 0C                        bra asm_common
00355Cr 3               z_asm_tsx:
00355Cr 3               
00355Cr 3               xt_asm_txa:     ; txa \ TXA
00355Cr 3  A9 8A                        lda #$8A
00355Er 3  80 08                        bra asm_common
003560r 3               z_asm_txa:
003560r 3               
003560r 3               xt_asm_txs:     ; txs \ TXS
003560r 3  A9 9A                        lda #$9A
003562r 3  80 04                        bra asm_common
003564r 3               z_asm_txs:
003564r 3               
003564r 3               xt_asm_tya:     ; tya \ TYA
003564r 3  A9 98                        lda #$98
003566r 3  80 00                        bra asm_common
003568r 3               z_asm_tya:
003568r 3               
003568r 3               
003568r 3               ; ==========================================================
003568r 3               ; ASSEMBLER HELPER FUNCTIONS
003568r 3               
003568r 3               asm_common:
003568r 3               
003568r 3               
003568r 3                       ; """Common routine for all opcodes. We arrive here with the opcode in
003568r 3                       ; A. We do not need to check for the correct values because we are
003568r 3                       ; coming from the assembler Dictionary and trust our external test
003568r 3                       ; suite.
003568r 3                       ; """
003568r 3                               ; Compile opcode. Note cmpl_a does not use Y
003568r 3  A8                           tay
003569r 3  20 rr rr                     jsr cmpl_a
00356Cr 3               
00356Cr 3                               ; We get the length of the opcode from the table included in
00356Cr 3                               ; the disassembler. We use the opcode value as the offset in
00356Cr 3                               ; the oc_index_table. We have 256 entries, each two bytes
00356Cr 3                               ; long, so we can't just use an index with Y. We use tmp2 for
00356Cr 3                               ; this.
00356Cr 3  A9 rr                        lda #<oc_index_table
00356Er 3  85 26                        sta tmp2
003570r 3  A9 rr                        lda #>oc_index_table
003572r 3  85 27                        sta tmp2+1
003574r 3               
003574r 3  98                           tya             ; retrieve opcode
003575r 3  0A                           asl             ; times two for offset
003576r 3  90 02                        bcc @1
003578r 3  E6 27                        inc tmp2+1
00357Ar 3               @1:
00357Ar 3  A8                           tay             ; use Y as the index
00357Br 3               
00357Br 3                               ; Get address of the entry in the opcode table. We put it in
00357Br 3                               ; tmp3 and push a copy of it to the stack to be able to print
00357Br 3                               ; the opcode later
00357Br 3  B1 26                        lda (tmp2),y    ; LSB
00357Dr 3  85 28                        sta tmp3
00357Fr 3  C8                           iny
003580r 3  B1 26                        lda (tmp2),y    ; MSB
003582r 3  85 29                        sta tmp3+1
003584r 3               
003584r 3  B2 28                        lda (tmp3)      ; get "lengths byte"
003586r 3               
003586r 3                               ; The length of the instruction is stored in bits 7 and 6.
003586r 3                               ; Rotate them through the carry flag and mask the rest
003586r 3  2A                           rol
003587r 3  2A                           rol
003588r 3  2A                           rol             ; Three times because we go through Carry
003589r 3  29 03                        and #%00000011
00358Br 3  A8                           tay
00358Cr 3               
00358Cr 3                               ; One byte means no operand, we're done. Use DEY as CPY #1
00358Cr 3  88                           dey
00358Dr 3  F0 12                        beq @done
00358Fr 3               
00358Fr 3                               ; We have an operand which must be TOS
00358Fr 3  20 rr rr                     jsr underflow_1
003592r 3               
003592r 3                               ; We compile the LSB of TOS as the operand we definitely have
003592r 3                               ; before we even test if this is a two- or three-byte
003592r 3                               ; instruction. Little endian CPU means we store this byte first
003592r 3  B5 00                        lda 0,x
003594r 3  20 rr rr                     jsr cmpl_a      ; does not use Y
003597r 3               
003597r 3                               ; If this is a two-byte instruction, we're done. If we landed
003597r 3                               ; here, we've already decremented Y by one, so this is
003597r 3                               ; the equivalent to CPY #2
003597r 3  88                           dey
003598r 3  F0 05                        beq @done_drop
00359Ar 3               
00359Ar 3                               ; This must be a three-byte instruction, get the MSB.
00359Ar 3  B5 01                        lda 1,x
00359Cr 3  20 rr rr                     jsr cmpl_a      ; Fall through to @done_drop
00359Fr 3               
00359Fr 3               @done_drop:
00359Fr 3  E8                           inx
0035A0r 3  E8                           inx             ; Fall through to @done
0035A1r 3               @done:
0035A1r 3  60                           rts             ; Returns to original caller
0035A2r 3               
0035A2r 3               
0035A2r 3               
0035A2r 3               ; ==========================================================
0035A2r 3               ; PSEUDO-INSTRUCTIONS AND MACROS
0035A2r 3               
0035A2r 3               xt_asm_push_a:
0035A2r 3                       ; """push-a puts the content of the 65c02 Accumulator on the Forth
0035A2r 3                       ; data stack as the TOS. This is a convience routine that encodes the
0035A2r 3                       ; instructions  DEX  DEX  STA 0,X  STZ 1,X
0035A2r 3                       ; """
0035A2r 3               
0035A2r 3  A0 00                        ldy #0
0035A4r 3               @loop:
0035A4r 3  B9 rr rr                     lda _data,y
0035A7r 3  C9 FF                        cmp #$FF
0035A9r 3  F0 06                        beq @done
0035ABr 3               
0035ABr 3  20 rr rr                     jsr cmpl_a      ; does not change Y
0035AEr 3  C8                           iny
0035AFr 3  80 F3                        bra @loop
0035B1r 3               @done:
0035B1r 3               z_asm_push_a:
0035B1r 3  60                           rts
0035B2r 3               _data:
0035B2r 3                       ; We can't use 00 as a terminator because STA 0,X assembles to 95 00
0035B2r 3  CA CA 95 00          .byte $CA, $CA, $95, 00, $74, $01
0035B6r 3  74 01        
0035B8r 3  FF                   .byte $FF               ; terminator
0035B9r 3               
0035B9r 3               
0035B9r 3               
0035B9r 3               ; ==========================================================
0035B9r 3               ; DIRECTIVES
0035B9r 3               
0035B9r 3               ; The "<J" directive (back jump) is a dummy instruction (syntactic sugar) to
0035B9r 3               ; make clear that the JMP or JSR instructions are using the address that had
0035B9r 3               ; been placed on the stack by "-->" (the "arrow" directive).
0035B9r 3               xt_asm_back_jump:
0035B9r 3               z_asm_back_jump:
0035B9r 3  60                           rts
0035BAr 3               
0035BAr 3               ; The "<B" directive (back branch) takes an address that was placed on the Data
0035BAr 3               ; Stack by the anonymous label directive "-->" (the "arrow") and the current
0035BAr 3               ; address (via HERE) to calculate a backward branch offset. This is then stored
0035BAr 3               ; by a following branch instruction.
0035BAr 3               xt_asm_back_branch:
0035BAr 3                               ; We arrive here with ( addr-l ) of the label on the stack and
0035BAr 3                               ; then subtract the current address
0035BAr 3  20 rr rr                     jsr xt_here             ; ( addr-l addr-h )
0035BDr 3  20 rr rr                     jsr xt_minus            ; ( offset )
0035C0r 3               
0035C0r 3                               ; We subtract two more because of the branch instruction itself
0035C0r 3  3A                           dec
0035C1r 3  3A                           dec
0035C2r 3               
0035C2r 3               z_asm_back_branch:
0035C2r 3  60                           rts
0035C3r 3               
0035C3r 3               assembler_end:
0035C3r 3               
0035C3r 3               ; END
0035C3r 3               
0035C3r 2               .include "disassembler.asm"     ; SAN disassembler
0035C3r 3               ; Disassembler for Tali Forth 2
0035C3r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
0035C3r 3               ; First version: 28. Apr 2018
0035C3r 3               ; This version: 03. Jan 2019
0035C3r 3               
0035C3r 3               ; This is the default disassembler for Tali Forth 2. Use by passing
0035C3r 3               ; the address and length of the block of memory to be disassembled:
0035C3r 3               ;
0035C3r 3               ;       disasm ( addr x -- )
0035C3r 3               
0035C3r 3               ; The underflow checking is handled by the word's stub in native_words.asm, see
0035C3r 3               ; there for more information.
0035C3r 3               
0035C3r 3               ; The code is disassembled in Simpler Assembler Notation (SAN), because that
0035C3r 3               ; is, uh, simpler. See the documentation and https://github.com/scotws/SAN for
0035C3r 3               ; more information. Because disassemblers are used interactively with slow
0035C3r 3               ; humans, we don't care that much about speed and put the emphasis at being
0035C3r 3               ; small.
0035C3r 3               
0035C3r 3               
0035C3r 3               disassembler:
0035C3r 3  20 rr rr                     jsr xt_cr       ; ( addr u )
0035C6r 3               _byte_loop:
0035C6r 3                               ; Print address at start of the line. Note we use whatever
0035C6r 3                               ; number base the user has
0035C6r 3  20 rr rr                     jsr xt_over     ; ( addr u addr )
0035C9r 3  20 rr rr                     jsr xt_u_dot    ; ( addr u )
0035CCr 3  20 rr rr                     jsr xt_space
0035CFr 3               
0035CFr 3                               ; We use the opcode value as the offset in the oc_index_table.
0035CFr 3                               ; We have 256 entries, each two bytes long, so we can't just
0035CFr 3                               ; use an index with Y. We use tmp2 for this.
0035CFr 3  A9 rr                        lda #<oc_index_table
0035D1r 3  85 26                        sta tmp2
0035D3r 3  A9 rr                        lda #>oc_index_table
0035D5r 3  85 27                        sta tmp2+1
0035D7r 3               
0035D7r 3  A1 02                        lda (2,x)       ; get opcode that addr points to
0035D9r 3               
0035D9r 3  0A                           asl             ; multiply by two for offset
0035DAr 3  90 02                        bcc @1
0035DCr 3  E6 27                        inc tmp2+1      ; we're on second page
0035DEr 3               @1:
0035DEr 3  A8                           tay             ; use Y as the index
0035DFr 3               
0035DFr 3                               ; Get address of the entry in the opcode table. We put it
0035DFr 3                               ; in tmp3 and push a copy of it to the stack to be able to
0035DFr 3                               ; print the opcode later
0035DFr 3  B1 26                        lda (tmp2),y    ; LSB
0035E1r 3  85 28                        sta tmp3
0035E3r 3  48                           pha
0035E4r 3               
0035E4r 3  C8                           iny
0035E5r 3               
0035E5r 3  B1 26                        lda (tmp2),y    ; MSB
0035E7r 3  85 29                        sta tmp3+1
0035E9r 3  48                           pha
0035EAr 3               
0035EAr 3                               ; The first byte is the "lengths byte" which is coded so
0035EAr 3                               ; that bits 7 to 6 are the length of the instruction (1 to
0035EAr 3                               ; 3 bytes) and 2 to 0 are the length of the mnemonic.
0035EAr 3  B2 28                        lda (tmp3)
0035ECr 3  A8                           tay                     ; save copy of lengths byte
0035EDr 3               
0035EDr 3                               ; Since this is Simpler Assembler Notation (SAN) in a Forth
0035EDr 3                               ; system, we want to print any operand before we print the
0035EDr 3                               ; mnemonic ('1000 sta' instead of 'sta 1000'). This allows us
0035EDr 3                               ; to copy and paste directly from the disassembler to the
0035EDr 3                               ; assembler.
0035EDr 3               
0035EDr 3                               ; What happens next depends on the length of the instruction in
0035EDr 3                               ; bytes:
0035EDr 3               
0035EDr 3                               ;   1 byte:  OPC          -->          OPC  bit sequence: %01
0035EDr 3                               ;   2 bytes: OPC LSB      -->    0 LSB OPC  bit sequence: %10
0035EDr 3                               ;   3 bytes: OPC LSB MSB  -->  MSB LSB OPC  bit sequence: %11
0035EDr 3               
0035EDr 3                               ; We can distinguish between the first case, where there is
0035EDr 3                               ; only the mnemonic, and the second and third cases, where we
0035EDr 3                               ; have an operand. We do this by use of the bit sequence in
0035EDr 3                               ; bits 7 and 6.
0035EDr 3  10 38                        bpl _no_operand         ; bit 7 clear, single-byte instruction
0035EFr 3               
0035EFr 3                               ; We have an operand. Prepare the Data Stack
0035EFr 3  20 rr rr                     jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
0035F2r 3               
0035F2r 3                               ; Because of the glory of a little endian CPU, we can start
0035F2r 3                               ; with the next byte regardless if this is a one or two byte
0035F2r 3                               ; operand, because we'll need the LSB one way or the other.
0035F2r 3                               ; We have a copy of the opcode on the stack, so we can now move
0035F2r 3                               ; to the next byte
0035F2r 3  F6 04                        inc 4,x
0035F4r 3  D0 02                        bne @2
0035F6r 3  F6 05                        inc 5,x                 ; ( addr+1 u 0 )
0035F8r 3               @2:
0035F8r 3  B5 02                        lda 2,x
0035FAr 3  D0 02                        bne @3
0035FCr 3  D6 03                        dec 3,x
0035FEr 3               @3:
0035FEr 3  D6 02                        dec 2,x                 ; ( addr+1 u-1 0 )
003600r 3               
003600r 3  A1 04                        lda (4,x)
003602r 3  95 00                        sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
003604r 3               
003604r 3                               ; We still have a copy of the lengths byte in Y, which we use
003604r 3                               ; to see if we have a one-byte operand (and are done already)
003604r 3                               ; or a two-byte operand
003604r 3  98                           tya                     ; retrieve copy of lengths byte
003605r 3  2A                           rol                     ; shift bit 6 to bit 7
003606r 3  10 12                        bpl _print_operand
003608r 3               
003608r 3                               ; We have a three-byte instruction, so we need to get the MSB
003608r 3                               ; of the operand. Move to the next byte
003608r 3  F6 04                        inc 4,x
00360Ar 3  D0 02                        bne @4
00360Cr 3  F6 05                        inc 5,x                 ; ( addr+2 u-1 LSB )
00360Er 3               @4:
00360Er 3  B5 02                        lda 2,x
003610r 3  D0 02                        bne @5
003612r 3  D6 03                        dec 3,x
003614r 3               @5:
003614r 3  D6 02                        dec 2,x                 ; ( addr+2 u-2 LSB )
003616r 3               
003616r 3  A1 04                        lda (4,x)
003618r 3  95 01                        sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
00361Ar 3               
00361Ar 3                               ; fall through to _print_operand
00361Ar 3               
00361Ar 3               _print_operand:
00361Ar 3               
00361Ar 3                               ; We arrive here with the lengths byte in Y, the address of the
00361Ar 3                               ; opcode table entry for the instruction on the stack ( addr+n
00361Ar 3                               ; u-n opr). We want the output to be nicely formatted in
00361Ar 3                               ; columns, so we use U.R. The maximal width of the number in
00361Ar 3                               ; decimal on an 16-bit addressed machine is five characters
00361Ar 3  CA                           dex
00361Br 3  CA                           dex
00361Cr 3  A9 05                        lda #5
00361Er 3  95 00                        sta 0,x
003620r 3  74 01                        stz 1,x                 ; ( addr+n u-n opr 5 )
003622r 3               
003622r 3  20 rr rr                     jsr xt_u_dot_r          ; U.R ( addr+n u-n )
003625r 3               
003625r 3  80 0B                        bra _print_mnemonic
003627r 3               
003627r 3               _no_operand:
003627r 3                               ; We arrive here with the opcode table address on the stack,
003627r 3                               ; the lengths byte in Y and ( addr u ). Since we want to have
003627r 3                               ; a nicely formatted output, we need to indent the mnemonic by
003627r 3                               ; five spaces.
003627r 3  CA                           dex
003628r 3  CA                           dex
003629r 3  A9 05                        lda #5
00362Br 3  95 00                        sta 0,x
00362Dr 3  74 01                        stz 1,x                 ; ( addr u 5 )
00362Fr 3               
00362Fr 3  20 rr rr                     jsr xt_spaces           ; ( addr u )
003632r 3               
003632r 3                               ; fall through to _print_mnemonic
003632r 3               
003632r 3               _print_mnemonic:
003632r 3                               ; We arrive here with the opcode table address on the stack and
003632r 3                               ; ( addr u | addr+n u-n ). Time to print the mnemonic.
003632r 3  20 rr rr                     jsr xt_space
003635r 3               
003635r 3  CA                           dex
003636r 3  CA                           dex                     ; ( addr u ? )
003637r 3  68                           pla                     ; MSB
003638r 3  95 01                        sta 1,x                 ; ( addr u MSB )
00363Ar 3  68                           pla                     ; LSB
00363Br 3  95 00                        sta 0,x                 ; ( addr u addr-o )
00363Dr 3               
00363Dr 3  20 rr rr                     jsr xt_count            ; ( addr u addr-o u-o )
003640r 3               
003640r 3                               ; The length of the mnemnonic string is in bits 2 to 0
003640r 3  74 01                        stz 1,x                 ; paranoid
003642r 3  B5 00                        lda 0,x
003644r 3  29 07                        and #%00000111          ; ( addr u addr-o u-o )
003646r 3  95 00                        sta 0,x
003648r 3               
003648r 3  20 rr rr                     jsr xt_type             ; ( addr u )
00364Br 3  20 rr rr                     jsr xt_cr
00364Er 3               
00364Er 3                               ; Housekeeping: Next byte
00364Er 3  F6 02                        inc 2,x
003650r 3  D0 02                        bne @1
003652r 3  F6 03                        inc 3,x                 ; ( addr+1 u )
003654r 3               @1:
003654r 3  20 rr rr                     jsr xt_one_minus        ; ( addr+1 u-1 )
003657r 3               
003657r 3  B5 00                        lda 0,x                 ; All done?
003659r 3  15 01                        ora 1,x
00365Br 3  F0 07                        beq @done
00365Dr 3               
00365Dr 3  B5 01                        lda 1,x                 ; Catch mid-instruction ranges
00365Fr 3  30 03                        bmi @done
003661r 3               
003661r 3  4C rr rr                     jmp _byte_loop          ; out of range for BRA
003664r 3               @done:
003664r 3                               ; Clean up and leave
003664r 3  4C rr rr                     jmp xt_two_drop         ; JSR/RTS
003667r 3               
003667r 3               
003667r 3               ; =========================================================
003667r 3               oc_index_table:
003667r 3                       ; Lookup table for the instruction data (length of instruction in
003667r 3                       ; bytes, length of mnemonic in bytes, mnemonic string). This is used by
003667r 3                       ; the assembler as well.
003667r 3               
003667r 3                       ; Opcodes 00-0F
003667r 3  rr rr rr rr          .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
00366Br 3  rr rr rr rr  
00366Fr 3  rr rr rr rr  
003677r 3  rr rr rr rr          .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
00367Br 3  rr rr rr rr  
00367Fr 3  rr rr rr rr  
003687r 3               
003687r 3                       ; Opcodes 10-1F
003687r 3  rr rr rr rr          .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
00368Br 3  rr rr rr rr  
00368Fr 3  rr rr rr rr  
003697r 3  rr rr rr rr          .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
00369Br 3  rr rr rr rr  
00369Fr 3  rr rr rr rr  
0036A7r 3               
0036A7r 3                       ; Opcodes 20-2F
0036A7r 3  rr rr rr rr          .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
0036ABr 3  rr rr rr rr  
0036AFr 3  rr rr rr rr  
0036B7r 3  rr rr rr rr          .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
0036BBr 3  rr rr rr rr  
0036BFr 3  rr rr rr rr  
0036C7r 3               
0036C7r 3                       ; Opcodes 30-3F
0036C7r 3  rr rr rr rr          .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
0036CBr 3  rr rr rr rr  
0036CFr 3  rr rr rr rr  
0036D7r 3  rr rr rr rr          .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
0036DBr 3  rr rr rr rr  
0036DFr 3  rr rr rr rr  
0036E7r 3               
0036E7r 3                       ; Opcodes 40-4F
0036E7r 3  rr rr rr rr          .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
0036EBr 3  rr rr rr rr  
0036EFr 3  rr rr rr rr  
0036F7r 3  rr rr rr rr          .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
0036FBr 3  rr rr rr rr  
0036FFr 3  rr rr rr rr  
003707r 3               
003707r 3                       ; Opcodes 50-5F
003707r 3  rr rr rr rr          .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
00370Br 3  rr rr rr rr  
00370Fr 3  rr rr rr rr  
003717r 3  rr rr rr rr          .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
00371Br 3  rr rr rr rr  
00371Fr 3  rr rr rr rr  
003727r 3               
003727r 3                       ; Opcodes 60-6F
003727r 3  rr rr rr rr          .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
00372Br 3  rr rr rr rr  
00372Fr 3  rr rr rr rr  
003737r 3  rr rr rr rr          .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
00373Br 3  rr rr rr rr  
00373Fr 3  rr rr rr rr  
003747r 3               
003747r 3                       ; Opcodes 70-7F
003747r 3  rr rr rr rr          .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
00374Br 3  rr rr rr rr  
00374Fr 3  rr rr rr rr  
003757r 3  rr rr rr rr          .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
00375Br 3  rr rr rr rr  
00375Fr 3  rr rr rr rr  
003767r 3               
003767r 3                       ; Opcodes 80-8F
003767r 3  rr rr rr rr          .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
00376Br 3  rr rr rr rr  
00376Fr 3  rr rr rr rr  
003777r 3  rr rr rr rr          .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
00377Br 3  rr rr rr rr  
00377Fr 3  rr rr rr rr  
003787r 3               
003787r 3                       ; Opcodes 90-9F
003787r 3  rr rr rr rr          .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
00378Br 3  rr rr rr rr  
00378Fr 3  rr rr rr rr  
003797r 3  rr rr rr rr          .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
00379Br 3  rr rr rr rr  
00379Fr 3  rr rr rr rr  
0037A7r 3               
0037A7r 3                       ; Opcodes A0-AF
0037A7r 3  rr rr rr rr          .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
0037ABr 3  rr rr rr rr  
0037AFr 3  rr rr rr rr  
0037B7r 3  rr rr rr rr          .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
0037BBr 3  rr rr rr rr  
0037BFr 3  rr rr rr rr  
0037C7r 3               
0037C7r 3                       ; Opcodes B0-BF
0037C7r 3  rr rr rr rr          .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
0037CBr 3  rr rr rr rr  
0037CFr 3  rr rr rr rr  
0037D7r 3  rr rr rr rr          .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
0037DBr 3  rr rr rr rr  
0037DFr 3  rr rr rr rr  
0037E7r 3               
0037E7r 3                       ; Opcodes C0-CF
0037E7r 3  rr rr rr rr          .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
0037EBr 3  rr rr rr rr  
0037EFr 3  rr rr rr rr  
0037F7r 3  rr rr rr rr          .word occ8, occ9, occa, oc__, occc, occd, occe, occf
0037FBr 3  rr rr rr rr  
0037FFr 3  rr rr rr rr  
003807r 3               
003807r 3                       ; Opcodes D0-DF
003807r 3  rr rr rr rr          .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
00380Br 3  rr rr rr rr  
00380Fr 3  rr rr rr rr  
003817r 3  rr rr rr rr          .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
00381Br 3  rr rr rr rr  
00381Fr 3  rr rr rr rr  
003827r 3               
003827r 3                       ; Opcodes E0-EF
003827r 3  rr rr rr rr          .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
00382Br 3  rr rr rr rr  
00382Fr 3  rr rr rr rr  
003837r 3  rr rr rr rr          .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
00383Br 3  rr rr rr rr  
00383Fr 3  rr rr rr rr  
003847r 3               
003847r 3                       ; Opcodes F0-FF
003847r 3  rr rr rr rr          .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
00384Br 3  rr rr rr rr  
00384Fr 3  rr rr rr rr  
003857r 3  rr rr rr rr          .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
00385Br 3  rr rr rr rr  
00385Fr 3  rr rr rr rr  
003867r 3               
003867r 3               
003867r 3               ; =========================================================
003867r 3               oc_table:
003867r 3                       ; Opcode data table for the disassember, which is also used by the
003867r 3                       ; assembler. Each entry starts with a "lengths byte":
003867r 3               
003867r 3                       ;       bit 7-6:  Length of instruction in bytes (1 to 3 for the 65c02)
003867r 3                       ;       bit 5-3:  unused
003867r 3                       ;       bit 2-0:  Length of mnemonic in chars (3 to 7)
003867r 3               
003867r 3                       ; To convert a line in this table to a Forth string of the mnemonic,
003867r 3                       ; use the COUNT word on the address of the lengths byte to get
003867r 3                       ; ( addr u ) and then mask all but the bits 2-0 of the TOS.
003867r 3               
003867r 3                       ; To make debugging easier, we keep the raw numbers for the lengths of
003867r 3                       ; the instruction and mnemonicis and let the assembler do the math
003867r 3                       ; required to shift and add. The actual mnemonic string follows after
003867r 3                       ; and is not zero terminated because we have the length in bits 2 to 0.
003867r 3               
003867r 3  83 62 72 6B  	oc00:	.byte 2*64+3, "brk"              ; enforce the signature byte
00386Br 3  87 6F 72 61  	oc01:	.byte 2*64+7, "ora.zxi"
00386Fr 3  2E 7A 78 69  
003873r 3               ;      (oc02)
003873r 3               ;      (oc03)
003873r 3  85 74 73 62          oc04:   .byte 2*64+5, "tsb.z"
003877r 3  2E 7A        
003879r 3  85 6F 72 64  	oc05:	.byte 2*64+5, "ord.z"
00387Dr 3  2E 7A        
00387Fr 3  85 61 73 6C  	oc06:	.byte 2*64+5, "asl.z"
003883r 3  2E 7A        
003885r 3               ;      (oc07)
003885r 3  43 70 68 70  	oc08:	.byte 1*64+3, "php"
003889r 3  85 6F 72 61  	oc09:	.byte 2*64+5, "ora.#"
00388Dr 3  2E 23        
00388Fr 3  45 61 73 6C  	oc0a:	.byte 1*64+5, "asl.a"
003893r 3  2E 61        
003895r 3               ;      (oc0b)
003895r 3  C3 74 73 62  	oc0c:	.byte 3*64+3, "tsb"
003899r 3  C3 6F 72 61  	oc0d:	.byte 3*64+3, "ora"
00389Dr 3  C3 61 73 6C  	oc0e:	.byte 3*64+3, "asl"
0038A1r 3  C4 62 62 72  	oc0f:	.byte 3*64+4, "bbr0"
0038A5r 3  30           
0038A6r 3               
0038A6r 3  83 62 70 6C  	oc10:	.byte 2*64+3, "bpl"
0038AAr 3  87 6F 72 61  	oc11:	.byte 2*64+7, "ora.ziy"
0038AEr 3  2E 7A 69 79  
0038B2r 3  86 6F 72 61  	oc12:	.byte 2*64+6, "ora.zi"
0038B6r 3  2E 7A 69     
0038B9r 3               ;      (oc13:)
0038B9r 3  85 74 72 62  	oc14:	.byte 2*64+5, "trb.z"
0038BDr 3  2E 7A        
0038BFr 3  86 6F 72 61  	oc15:	.byte 2*64+6, "ora.zx"
0038C3r 3  2E 7A 78     
0038C6r 3  86 61 73 6C  	oc16:	.byte 2*64+6, "asl.zx"
0038CAr 3  2E 7A 78     
0038CDr 3  86 72 6D 62  	oc17:	.byte 2*64+6, "rmb1.z"
0038D1r 3  31 2E 7A     
0038D4r 3  43 63 6C 63  	oc18:	.byte 1*64+3, "clc"
0038D8r 3  C5 6F 72 61  	oc19:	.byte 3*64+5, "ora.y"
0038DCr 3  2E 79        
0038DEr 3  45 69 6E 63  	oc1a:	.byte 1*64+5, "inc.a"
0038E2r 3  2E 61        
0038E4r 3               ;      (oc1b:)
0038E4r 3  C3 74 72 62  	oc1c:	.byte 3*64+3, "trb"
0038E8r 3  C5 6F 72 61  	oc1d:	.byte 3*64+5, "ora.x"
0038ECr 3  2E 78        
0038EEr 3               ;      (oc1e:)
0038EEr 3  C5 61 73 6C  	oc1f:	.byte 3*64+5, "asl.x"
0038F2r 3  2E 78        
0038F4r 3               
0038F4r 3  C3 6A 73 72  	oc20:	.byte 3*64+3, "jsr"
0038F8r 3  87 61 6E 64  	oc21:	.byte 2*64+7, "and.zxi"
0038FCr 3  2E 7A 78 69  
003900r 3               ;      (oc22:)
003900r 3               ;      (oc23:)
003900r 3  85 62 69 74  	oc24:	.byte 2*64+5, "bit.z"
003904r 3  2E 7A        
003906r 3  85 61 6E 64  	oc25:	.byte 2*64+5, "and.z"
00390Ar 3  2E 7A        
00390Cr 3  85 72 6F 6C  	oc26:	.byte 2*64+5, "rol.z"
003910r 3  2E 7A        
003912r 3  86 72 6D 62  	oc27:	.byte 2*64+6, "rmb2.z"
003916r 3  32 2E 7A     
003919r 3  43 70 6C 70  	oc28:	.byte 1*64+3, "plp"
00391Dr 3  85 61 6E 64  	oc29:	.byte 2*64+5, "and.#"
003921r 3  2E 23        
003923r 3  45 72 6F 6C  	oc2a:	.byte 1*64+5, "rol.a"
003927r 3  2E 61        
003929r 3               ;      (oc2b:)
003929r 3  C3 62 69 74  	oc2c:	.byte 3*64+3, "bit"
00392Dr 3  C4 61 6E 64  	oc2d:	.byte 3*64+4, "and."
003931r 3  2E           
003932r 3  C3 72 6F 6C  	oc2e:	.byte 3*64+3, "rol"
003936r 3  C4 62 62 72  	oc2f:	.byte 3*64+4, "bbr2"
00393Ar 3  32           
00393Br 3               
00393Br 3  83 62 6D 69  	oc30:	.byte 2*64+3, "bmi"
00393Fr 3  87 61 6E 64  	oc31:	.byte 2*64+7, "and.ziy"
003943r 3  2E 7A 69 79  
003947r 3  86 61 6E 64  	oc32:	.byte 2*64+6, "and.zi"
00394Br 3  2E 7A 69     
00394Er 3               ;      (oc33:)
00394Er 3  87 62 69 74  	oc34:	.byte 2*64+7, "bit.zxi"
003952r 3  2E 7A 78 69  
003956r 3  86 61 6E 64  	oc35:	.byte 2*64+6, "and.zx"
00395Ar 3  2E 7A 78     
00395Dr 3  86 72 6F 6C  	oc36:	.byte 2*64+6, "rol.zx"
003961r 3  2E 7A 78     
003964r 3  86 72 6D 62  	oc37:	.byte 2*64+6, "rmb3.z"
003968r 3  33 2E 7A     
00396Br 3  43 73 65 63  	oc38:	.byte 1*64+3, "sec"
00396Fr 3  C5 61 6E 64  	oc39:	.byte 3*64+5, "and.y"
003973r 3  2E 79        
003975r 3  45 64 65 63  	oc3a:	.byte 1*64+5, "dec.a"
003979r 3  2E 61        
00397Br 3               ;      (oc3b:)
00397Br 3  C5 62 69 74  	oc3c:	.byte 3*64+5, "bit.x"
00397Fr 3  2E 78        
003981r 3  C5 61 6E 64  	oc3d:	.byte 3*64+5, "and.x"
003985r 3  2E 78        
003987r 3  C5 72 6F 6C  	oc3e:	.byte 3*64+5, "rol.x"
00398Br 3  2E 78        
00398Dr 3  C4 62 62 72  	oc3f:	.byte 3*64+4, "bbr3"
003991r 3  33           
003992r 3               
003992r 3  43 72 74 69  	oc40:	.byte 1*64+3, "rti"
003996r 3  87 65 6F 72  	oc41:	.byte 2*64+7, "eor.zxi"
00399Ar 3  2E 7A 78 69  
00399Er 3               ;      (oc42:)
00399Er 3               ;      (oc43:)
00399Er 3               ;      (oc44:)
00399Er 3  85 65 6F 72  	oc45:	.byte 2*64+5, "eor.z"
0039A2r 3  2E 7A        
0039A4r 3  85 6C 73 72  	oc46:	.byte 2*64+5, "lsr.z"
0039A8r 3  2E 7A        
0039AAr 3  86 72 62 6D  	oc47:	.byte 2*64+6, "rbm4.z"
0039AEr 3  34 2E 7A     
0039B1r 3  43 70 68 61  	oc48:	.byte 1*64+3, "pha"
0039B5r 3  85 65 6F 72  	oc49:	.byte 2*64+5, "eor.#"
0039B9r 3  2E 23        
0039BBr 3  45 6C 73 72  	oc4a:	.byte 1*64+5, "lsr.a"
0039BFr 3  2E 61        
0039C1r 3               ;      (oc4b:)
0039C1r 3  C3 6A 6D 70  	oc4c:	.byte 3*64+3, "jmp"
0039C5r 3  C3 65 6F 72  	oc4d:	.byte 3*64+3, "eor"
0039C9r 3  C3 6C 73 72  	oc4e:	.byte 3*64+3, "lsr"
0039CDr 3  C4 62 62 72  	oc4f:	.byte 3*64+4, "bbr4"
0039D1r 3  34           
0039D2r 3               
0039D2r 3  83 62 76 63  	oc50:	.byte 2*64+3, "bvc"
0039D6r 3  87 65 6F 72  	oc51:	.byte 2*64+7, "eor.ziy"
0039DAr 3  2E 7A 69 79  
0039DEr 3  86 65 6F 72  	oc52:	.byte 2*64+6, "eor.zi"
0039E2r 3  2E 7A 69     
0039E5r 3               ;      (oc53:)
0039E5r 3               ;      (oc54:)
0039E5r 3  86 65 6F 72  	oc55:	.byte 2*64+6, "eor.zx"
0039E9r 3  2E 7A 78     
0039ECr 3  86 6C 73 72  	oc56:	.byte 2*64+6, "lsr.zx"
0039F0r 3  2E 7A 78     
0039F3r 3  86 72 62 6D  	oc57:	.byte 2*64+6, "rbm5.z"
0039F7r 3  35 2E 7A     
0039FAr 3  43 63 6C 69  	oc58:	.byte 1*64+3, "cli"
0039FEr 3  C5 65 6F 72  	oc59:	.byte 3*64+5, "eor.y"
003A02r 3  2E 79        
003A04r 3  43 70 68 79  	oc5a:	.byte 1*64+3, "phy"
003A08r 3               ;      (oc5b:)
003A08r 3               ;      (oc5c:)
003A08r 3  C5 65 6F 72  	oc5d:	.byte 3*64+5, "eor.x"
003A0Cr 3  2E 78        
003A0Er 3  C5 6C 73 72  	oc5e:	.byte 3*64+5, "lsr.x"
003A12r 3  2E 78        
003A14r 3  C4 62 62 72  	oc5f:	.byte 3*64+4, "bbr5"
003A18r 3  35           
003A19r 3               
003A19r 3  43 72 74 73  	oc60:	.byte 1*64+3, "rts"
003A1Dr 3  87 61 64 63  	oc61:	.byte 2*64+7, "adc.zxi"
003A21r 3  2E 7A 78 69  
003A25r 3               ;      (oc62:)
003A25r 3               ;      (oc63:)
003A25r 3  85 73 74 7A  	oc64:	.byte 2*64+5, "stz.z"
003A29r 3  2E 7A        
003A2Br 3  85 61 64 63  	oc65:	.byte 2*64+5, "adc.z"
003A2Fr 3  2E 7A        
003A31r 3  85 72 6F 72  	oc66:	.byte 2*64+5, "ror.z"
003A35r 3  2E 7A        
003A37r 3  86 72 6D 62  	oc67:	.byte 2*64+6, "rmb6.z"
003A3Br 3  36 2E 7A     
003A3Er 3  43 70 6C 61  	oc68:	.byte 1*64+3, "pla"
003A42r 3  85 61 64 63  	oc69:	.byte 2*64+5, "adc.#"
003A46r 3  2E 23        
003A48r 3  45 72 6F 72  	oc6a:	.byte 1*64+5, "ror.a"
003A4Cr 3  2E 61        
003A4Er 3               ;      (oc6b:)
003A4Er 3  C5 6A 6D 70  	oc6c:	.byte 3*64+5, "jmp.i"
003A52r 3  2E 69        
003A54r 3  C3 61 64 63  	oc6d:	.byte 3*64+3, "adc"
003A58r 3  C3 72 6F 72  	oc6e:	.byte 3*64+3, "ror"
003A5Cr 3  C4 62 62 72  	oc6f:	.byte 3*64+4, "bbr6"
003A60r 3  36           
003A61r 3               
003A61r 3  83 62 76 73  	oc70:	.byte 2*64+3, "bvs"
003A65r 3  87 61 64 63  	oc71:	.byte 2*64+7, "adc.ziy"
003A69r 3  2E 7A 69 79  
003A6Dr 3  86 61 64 63  	oc72:	.byte 2*64+6, "adc.zi"
003A71r 3  2E 7A 69     
003A74r 3               ;      (oc73:)
003A74r 3  86 73 74 7A  	oc74:	.byte 2*64+6, "stz.zx"
003A78r 3  2E 7A 78     
003A7Br 3  86 61 64 63  	oc75:	.byte 2*64+6, "adc.zx"
003A7Fr 3  2E 7A 78     
003A82r 3  86 72 6F 72  	oc76:	.byte 2*64+6, "ror.zx"
003A86r 3  2E 7A 78     
003A89r 3  86 72 6D 62  	oc77:	.byte 2*64+6, "rmb7.z"
003A8Dr 3  37 2E 7A     
003A90r 3  43 73 65 69  	oc78:	.byte 1*64+3, "sei"
003A94r 3  C5 61 64 63  	oc79:	.byte 3*64+5, "adc.y"
003A98r 3  2E 79        
003A9Ar 3  43 70 6C 79  	oc7a:	.byte 1*64+3, "ply"
003A9Er 3               ;      (oc7b:)
003A9Er 3  C6 6A 6D 70  	oc7c:	.byte 3*64+6, "jmp.xi"
003AA2r 3  2E 78 69     
003AA5r 3  C5 61 64 63  	oc7d:	.byte 3*64+5, "adc.x"
003AA9r 3  2E 78        
003AABr 3  C5 72 6F 72  	oc7e:	.byte 3*64+5, "ror.x"
003AAFr 3  2E 78        
003AB1r 3  C4 62 62 72  	oc7f:	.byte 3*64+4, "bbr7"
003AB5r 3  37           
003AB6r 3               
003AB6r 3  83 62 72 61  	oc80:	.byte 2*64+3, "bra"
003ABAr 3  87 73 74 61  	oc81:	.byte 2*64+7, "sta.zxi"
003ABEr 3  2E 7A 78 69  
003AC2r 3               ;      (oc82:)
003AC2r 3               ;      (oc83:)
003AC2r 3  85 73 74 79  	oc84:	.byte 2*64+5, "sty.z"
003AC6r 3  2E 7A        
003AC8r 3  85 73 74 61  	oc85:	.byte 2*64+5, "sta.z"
003ACCr 3  2E 7A        
003ACEr 3  85 73 74 78  	oc86:	.byte 2*64+5, "stx.z"
003AD2r 3  2E 7A        
003AD4r 3               ;      (oc87:)
003AD4r 3  43 64 65 79  	oc88:	.byte 1*64+3, "dey"
003AD8r 3  85 62 69 74  	oc89:	.byte 2*64+5, "bit.#"
003ADCr 3  2E 23        
003ADEr 3  43 74 78 61  	oc8a:	.byte 1*64+3, "txa"
003AE2r 3               ;      (oc8b:)
003AE2r 3  C3 73 74 79  	oc8c:	.byte 3*64+3, "sty"
003AE6r 3  C3 73 74 61  	oc8d:	.byte 3*64+3, "sta"
003AEAr 3  C3 73 74 78  	oc8e:	.byte 3*64+3, "stx"
003AEEr 3  C4 62 62 73  	oc8f:	.byte 3*64+4, "bbs0"
003AF2r 3  30           
003AF3r 3               
003AF3r 3  83 62 63 63  	oc90:	.byte 2*64+3, "bcc"
003AF7r 3  87 73 74 61  	oc91:	.byte 2*64+7, "sta.ziy"
003AFBr 3  2E 7A 69 79  
003AFFr 3  86 73 74 61  	oc92:	.byte 2*64+6, "sta.zi"
003B03r 3  2E 7A 69     
003B06r 3               ;      (oc93:)
003B06r 3  86 73 74 79  	oc94:	.byte 2*64+6, "sty.zx"
003B0Ar 3  2E 7A 78     
003B0Dr 3  86 73 74 61  	oc95:	.byte 2*64+6, "sta.zx"
003B11r 3  2E 7A 78     
003B14r 3  86 73 74 78  	oc96:	.byte 2*64+6, "stx.zy"
003B18r 3  2E 7A 79     
003B1Br 3  86 73 6D 62  	oc97:	.byte 2*64+6, "smb1.z"
003B1Fr 3  31 2E 7A     
003B22r 3  43 74 79 61  	oc98:	.byte 1*64+3, "tya"
003B26r 3  C5 73 74 61  	oc99:	.byte 3*64+5, "sta.y"
003B2Ar 3  2E 79        
003B2Cr 3  43 74 78 73  	oc9a:	.byte 1*64+3, "txs"
003B30r 3               ;      (oc9b:)
003B30r 3  C3 73 74 7A  	oc9c:	.byte 3*64+3, "stz"
003B34r 3  C5 73 74 61  	oc9d:	.byte 3*64+5, "sta.x"
003B38r 3  2E 78        
003B3Ar 3  C5 73 74 7A  	oc9e:	.byte 3*64+5, "stz.x"
003B3Er 3  2E 78        
003B40r 3  C4 62 62 73  	oc9f:	.byte 3*64+4, "bbs1"
003B44r 3  31           
003B45r 3               
003B45r 3  85 6C 64 79  	oca0:	.byte 2*64+5, "ldy.#"
003B49r 3  2E 23        
003B4Br 3  87 6C 64 61  	oca1:	.byte 2*64+7, "lda.zxi"
003B4Fr 3  2E 7A 78 69  
003B53r 3  85 6C 64 78  	oca2:	.byte 2*64+5, "ldx.#"
003B57r 3  2E 23        
003B59r 3               ;      (oca3:)
003B59r 3  85 6C 64 79  	oca4:	.byte 2*64+5, "ldy.z"
003B5Dr 3  2E 7A        
003B5Fr 3  85 6C 64 61  	oca5:	.byte 2*64+5, "lda.z"
003B63r 3  2E 7A        
003B65r 3  85 6C 64 78  	oca6:	.byte 2*64+5, "ldx.z"
003B69r 3  2E 7A        
003B6Br 3  86 73 6D 62  	oca7:	.byte 2*64+6, "smb2.z"
003B6Fr 3  32 2E 7A     
003B72r 3  43 74 61 79  	oca8:	.byte 1*64+3, "tay"
003B76r 3  85 6C 64 61  	oca9:	.byte 2*64+5, "lda.#"
003B7Ar 3  2E 23        
003B7Cr 3  43 74 61 78  	ocaa:	.byte 1*64+3, "tax"
003B80r 3               ;      (ocab:)
003B80r 3  C3 6C 64 79  	ocac:	.byte 3*64+3, "ldy"
003B84r 3  C3 6C 64 61  	ocad:	.byte 3*64+3, "lda"
003B88r 3  C3 6C 64 78  	ocae:	.byte 3*64+3, "ldx"
003B8Cr 3  C4 62 62 73  	ocaf:	.byte 3*64+4, "bbs2"
003B90r 3  32           
003B91r 3               
003B91r 3  83 62 63 73  	ocb0:	.byte 2*64+3, "bcs"
003B95r 3  87 6C 64 61  	ocb1:	.byte 2*64+7, "lda.ziy"
003B99r 3  2E 7A 69 79  
003B9Dr 3  86 6C 64 61  	ocb2:	.byte 2*64+6, "lda.zi"
003BA1r 3  2E 7A 69     
003BA4r 3               ;      (ocb3:)
003BA4r 3  86 6C 64 79  	ocb4:	.byte 2*64+6, "ldy.zx"
003BA8r 3  2E 7A 78     
003BABr 3  86 6C 64 61  	ocb5:	.byte 2*64+6, "lda.zx"
003BAFr 3  2E 7A 78     
003BB2r 3  86 6C 64 78  	ocb6:	.byte 2*64+6, "ldx.zy"
003BB6r 3  2E 7A 79     
003BB9r 3  86 73 6D 62  	ocb7:	.byte 2*64+6, "smb3.z"
003BBDr 3  33 2E 7A     
003BC0r 3  43 63 6C 76  	ocb8:	.byte 1*64+3, "clv"
003BC4r 3  C5 6C 64 61  	ocb9:	.byte 3*64+5, "lda.y"
003BC8r 3  2E 79        
003BCAr 3  43 74 73 78  	ocba:	.byte 1*64+3, "tsx"
003BCEr 3               ;      (ocbb:)
003BCEr 3  C5 6C 64 79  	ocbc:	.byte 3*64+5, "ldy.x"
003BD2r 3  2E 78        
003BD4r 3  C5 6C 64 61  	ocbd:	.byte 3*64+5, "lda.x"
003BD8r 3  2E 78        
003BDAr 3  C5 6C 64 78  	ocbe:	.byte 3*64+5, "ldx.y"
003BDEr 3  2E 79        
003BE0r 3  C4 62 62 73  	ocbf:	.byte 3*64+4, "bbs4"
003BE4r 3  34           
003BE5r 3               
003BE5r 3  85 63 70 79  	occ0:	.byte 2*64+5, "cpy.#"
003BE9r 3  2E 23        
003BEBr 3  87 63 6D 70  	occ1:	.byte 2*64+7, "cmp.zxi"
003BEFr 3  2E 7A 78 69  
003BF3r 3               ;      (occ2:)
003BF3r 3               ;      (occ3:)
003BF3r 3  85 63 70 79  	occ4:	.byte 2*64+5, "cpy.z"
003BF7r 3  2E 7A        
003BF9r 3  85 63 6D 70  	occ5:	.byte 2*64+5, "cmp.z"
003BFDr 3  2E 7A        
003BFFr 3  85 64 65 63  	occ6:	.byte 2*64+5, "dec.z"
003C03r 3  2E 7A        
003C05r 3  86 73 6D 62  	occ7:	.byte 2*64+6, "smb4.z"
003C09r 3  34 2E 7A     
003C0Cr 3  43 69 6E 79  	occ8:	.byte 1*64+3, "iny"
003C10r 3  85 63 6D 70  	occ9:	.byte 2*64+5, "cmp.#"
003C14r 3  2E 23        
003C16r 3  43 64 65 78  	occa:	.byte 1*64+3, "dex"
003C1Ar 3               ;      (occb:)
003C1Ar 3  C3 63 70 79  	occc:	.byte 3*64+3, "cpy"
003C1Er 3  C3 63 6D 70  	occd:	.byte 3*64+3, "cmp"
003C22r 3  C3 64 65 63  	occe:	.byte 3*64+3, "dec"
003C26r 3  C4 62 62 73  	occf:	.byte 3*64+4, "bbs4"
003C2Ar 3  34           
003C2Br 3               
003C2Br 3  83 62 6E 65  	ocd0:	.byte 2*64+3, "bne"
003C2Fr 3  87 63 6D 70  	ocd1:	.byte 2*64+7, "cmp.ziy"
003C33r 3  2E 7A 69 79  
003C37r 3  86 63 6D 70  	ocd2:	.byte 2*64+6, "cmp.zi"
003C3Br 3  2E 7A 69     
003C3Er 3               ;      (ocd3:)
003C3Er 3               ;      (ocd4:)
003C3Er 3  86 63 6D 70  	ocd5:	.byte 2*64+6, "cmp.zx"
003C42r 3  2E 7A 78     
003C45r 3  86 64 65 63  	ocd6:	.byte 2*64+6, "dec.zx"
003C49r 3  2E 7A 78     
003C4Cr 3  86 73 6D 62  	ocd7:	.byte 2*64+6, "smb5.z"
003C50r 3  35 2E 7A     
003C53r 3  43 63 6C 64  	ocd8:	.byte 1*64+3, "cld"
003C57r 3  C5 63 6D 70  	ocd9:	.byte 3*64+5, "cmp.y"
003C5Br 3  2E 79        
003C5Dr 3  43 70 68 78  	ocda:	.byte 1*64+3, "phx"
003C61r 3               ;      (ocdb:)
003C61r 3               ;      (ocdc:)
003C61r 3  C5 63 6D 70  	ocdd:	.byte 3*64+5, "cmp.x"
003C65r 3  2E 78        
003C67r 3  C5 64 65 63  	ocde:	.byte 3*64+5, "dec.x"
003C6Br 3  2E 78        
003C6Dr 3  C4 62 62 73  	ocdf:	.byte 3*64+4, "bbs5"
003C71r 3  35           
003C72r 3               
003C72r 3  85 63 70 78  	oce0:	.byte 2*64+5, "cpx.#"
003C76r 3  2E 23        
003C78r 3  87 73 62 63  	oce1:	.byte 2*64+7, "sbc.zxi"
003C7Cr 3  2E 7A 78 69  
003C80r 3               ;      (oce2:)
003C80r 3               ;      (oce3:)
003C80r 3  85 63 70 78  	oce4:	.byte 2*64+5, "cpx.z"
003C84r 3  2E 7A        
003C86r 3  85 73 62 63  	oce5:	.byte 2*64+5, "sbc.z"
003C8Ar 3  2E 7A        
003C8Cr 3  85 69 6E 63  	oce6:	.byte 2*64+5, "inc.z"
003C90r 3  2E 7A        
003C92r 3  86 73 6D 62  	oce7:	.byte 2*64+6, "smb6.z"
003C96r 3  36 2E 7A     
003C99r 3  43 69 6E 78  	oce8:	.byte 1*64+3, "inx"
003C9Dr 3  85 73 62 63  	oce9:	.byte 2*64+5, "sbc.#"
003CA1r 3  2E 23        
003CA3r 3  43 6E 6F 70  	ocea:	.byte 1*64+3, "nop"
003CA7r 3               ;      (oceb:)
003CA7r 3  C3 63 70 78  	ocec:	.byte 3*64+3, "cpx"
003CABr 3  C3 73 62 63  	oced:	.byte 3*64+3, "sbc"
003CAFr 3  C3 69 6E 63  	ocee:	.byte 3*64+3, "inc"
003CB3r 3  C4 62 62 73  	ocef:	.byte 3*64+4, "bbs6"
003CB7r 3  36           
003CB8r 3               
003CB8r 3  83 62 65 71  	ocf0:	.byte 2*64+3, "beq"
003CBCr 3  87 73 62 63  	ocf1:	.byte 2*64+7, "sbc.ziy"
003CC0r 3  2E 7A 69 79  
003CC4r 3  86 73 62 63  	ocf2:	.byte 2*64+6, "sbc.zi"
003CC8r 3  2E 7A 69     
003CCBr 3               ;      (ocf3:)
003CCBr 3               ;      (ocf4:)
003CCBr 3  86 73 62 63  	ocf5:	.byte 2*64+6, "sbc.zx"
003CCFr 3  2E 7A 78     
003CD2r 3  86 69 6E 63  	ocf6:	.byte 2*64+6, "inc.zx"
003CD6r 3  2E 7A 78     
003CD9r 3  86 73 6D 62  	ocf7:	.byte 2*64+6, "smb7.z"
003CDDr 3  37 2E 7A     
003CE0r 3  43 73 65 64  	ocf8:	.byte 1*64+3, "sed"
003CE4r 3  C5 73 62 63  	ocf9:	.byte 3*64+5, "sbc.y"
003CE8r 3  2E 79        
003CEAr 3  43 70 6C 78  	ocfa:	.byte 1*64+3, "plx"
003CEEr 3               ;      (ocfb:)
003CEEr 3               ;      (ocfc:)
003CEEr 3  C5 73 62 63  	ocfd:	.byte 3*64+5, "sbc.x"
003CF2r 3  2E 78        
003CF4r 3  C5 69 6E 63  	ocfe:	.byte 3*64+5, "inc.x"
003CF8r 3  2E 78        
003CFAr 3  C4 62 62 73  	ocff:	.byte 3*64+4, "bbs7"
003CFEr 3  37           
003CFFr 3               
003CFFr 3                       ; Common routine for opcodes that are not supported by the 65c02
003CFFr 3  01 3F        	oc__:	.byte 1, "?"
003D01r 3               
003D01r 3               ; used to calculate size of assembled disassembler code
003D01r 3               disassembler_end:
003D01r 3               
003D01r 2               .include "ed.asm"               ; Line-based editor ed6502
003D01r 3               ; ed6502 - Ed-like line-based editor for Tali Forth 2
003D01r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
003D01r 3               ; First version: 13. Okt 2018
003D01r 3               ; This version: 28. Dec 2018
003D01r 3               
003D01r 3               ; Ed is a line-orientated editor for Tali Forth 2 based on the classic Unix
003D01r 3               ; editor of the same name. It is included because a) I like line editors and
003D01r 3               ; this is my project, so there, and b) as a very simple editor that will work
003D01r 3               ; even if there is no vt100 terminal support, just with ASCII if needs be. For
003D01r 3               ; further information on ed, see
003D01r 3               
003D01r 3               ;   https://en.wikipedia.org/wiki/Ed_(text_editor)
003D01r 3               ;   https://www.gnu.org/software/ed/ed.html
003D01r 3               ;   https://www.gnu.org/software/ed/manual/ed_manual.html
003D01r 3               ;   https://sanctum.geek.nz/arabesque/actually-using-ed/
003D01r 3               ;   http://www.psue.uni-hannover.de/wise2017_2018/material/ed.pdf
003D01r 3               
003D01r 3               ; We start editor from Forth with
003D01r 3               ;
003D01r 3               ;       ed ( -- addr u )
003D01r 3               ;
003D01r 3               ; The return values ( addr u ) are the address and length of the text written.
003D01r 3               ; If no text was written, u is zero and addr is undefined.
003D01r 3               
003D01r 3               ; In the working memory, the text is stored as a simple linked list of lines.
003D01r 3               ; Each node consists of three 16-bit entries:
003D01r 3               
003D01r 3               ;       - pointer to next entry (0 for end of list)
003D01r 3               ;       - pointer to beginning of string ( addr )
003D01r 3               ;       - length of string ( u )
003D01r 3               
003D01r 3               ; The editor only works in interaction with slow humans, so speed is not
003D01r 3               ; a primary concern. We try to keep the size down instead.
003D01r 3               
003D01r 3               ; Where to put variables is a bit of a problem. To convert the numbers, we need
003D01r 3               ; UM/MOD, which uses the scratchpad, and ACCEPT uses tmp1, tmp2, and tmp3 at
003D01r 3               ; some point, so we either have to pay very close attention, or we do something
003D01r 3               ; else. After some experimenting, it seems that the easiest way for this sort
003D01r 3               ; of hybrid Forth/assembler system is to keep the parameters for the commands
003D01r 3               ; on the Data Stack in the form of ( para1 para2 ):
003D01r 3               
003D01r 3               ;       TOS: parameter 2 (after the comma)
003D01r 3               ;       NOS: parameter 1 (before the comma)
003D01r 3               
003D01r 3               ; The third and fourth entries on the stack are the ( addr-t u-t ) entries the
003D01r 3               ; text will be/has been written to, or u as 0 if nothing was defined.
003D01r 3               
003D01r 3               ; We also need a pointer to the beginning of the text (first node of the list),
003D01r 3               ; the number of the current line, and a flag to mark if the text has been
003D01r 3               ; changed. We have six bytes of zero page reserved for any editor to use. Note
003D01r 3               ; that this means that we can't use two editors at the same time, which won't
003D01r 3               ; be a problem until we can multitask.
003D01r 3               
003D01r 3               ed_head =  editor1  ; pointer to first list element (addr) (2 bytes)
003D01r 3               ed_cur =   editor2  ; current line number (1 is first line) (2 bytes)
003D01r 3               ed_flags = editor3  ; Flags used by ed, where
003D01r 3               ;       bit 7 parameters - 0: none, 1: have at least one parameter
003D01r 3               ;       bit 6 changed    - 0: text not changed, 1: text was changed
003D01r 3               ;       bit 0 printing   - 0: no line numbers (p), 1: with line numbers (n)
003D01r 3               
003D01r 3               ;  Byte editor3+1 is currently unused
003D01r 3               
003D01r 3               
003D01r 3               ed6502:
003D01r 3                               ; Start a new empty linked list at HERE. This is also
003D01r 3                               ; the current line
003D01r 3  64 2E                        stz ed_head
003D03r 3  64 2F                        stz ed_head+1
003D05r 3               
003D05r 3                               ; The current line is 0, because we start counting at
003D05r 3                               ; line 1 for the humans
003D05r 3  64 30                        stz ed_cur
003D07r 3  64 31                        stz ed_cur+1
003D09r 3               
003D09r 3                               ; At the beginning, we have no parameters (bit 7), no line
003D09r 3                               ; numbers (bit 0), and nothing was changed (bit 6)
003D09r 3  64 32                        stz ed_flags
003D0Br 3               
003D0Br 3                               ; We put zeros as placeholders for the text we've written to
003D0Br 3                               ; (the "target") on the stack. Because the stack picture is
003D0Br 3                               ; going to get very confusing very fast, we'll mark them
003D0Br 3                               ; specially with "-t" suffixes in the stack comments.
003D0Br 3  20 rr rr                     jsr xt_zero
003D0Er 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t )
003D11r 3               
003D11r 3  20 rr rr                     jsr xt_cr
003D14r 3               
003D14r 3               _input_loop:
003D14r 3                               ; Set parameter flag to none (bit 7); default printing is
003D14r 3                               ; without line numbers (bit 0). We leave the changed flag (bit
003D14r 3                               ; 6) because we might be coming from a previous add
003D14r 3  A9 81                        lda #%10000001
003D16r 3  14 32                        trb ed_flags
003D18r 3               
003D18r 3                               ; We really don't want to have to write a complete
003D18r 3                               ; parser for such a simple editor, so we walk through the
003D18r 3                               ; possibilities the hard way. Get input from the user. This
003D18r 3                               ; routine handles any errors from REFILL
003D18r 3  20 rr rr                     jsr _get_input
003D1Br 3               
003D1Br 3                               ; If we were not given an empty line, see what we were given
003D1Br 3  A5 0A                        lda ciblen
003D1Dr 3  D0 1F                        bne _command_mode
003D1Fr 3               
003D1Fr 3                               ; We were given an empty line. Advance one line, print it, and
003D1Fr 3                               ; make it the new current line
003D1Fr 3  CA                           dex
003D20r 3  CA                           dex                     ; ( addr-t u-t ? )
003D21r 3               
003D21r 3  A5 30                        lda ed_cur
003D23r 3  95 00                        sta 0,x
003D25r 3  A5 31                        lda ed_cur+1
003D27r 3  95 01                        sta 1,x                 ; ( addr-t u-t u )
003D29r 3               
003D29r 3                               ; This counts as having a parameter
003D29r 3  A9 80                        lda #%10000000
003D2Br 3  04 32                        tsb ed_flags
003D2Dr 3               
003D2Dr 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t u+1 )
003D30r 3  20 rr rr                     jsr _is_valid_line
003D33r 3  B0 03                        bcs @1
003D35r 3               
003D35r 3                               ; New line number is not legal, abort
003D35r 3  4C rr rr                     jmp _error_1drop
003D38r 3               @1:
003D38r 3                               ; We have a legal line number, but we need two entries on
003D38r 3                               ; the parameter list (four if you count the target
003D38r 3                               ; address) to be able to work with the rest of the program.
003D38r 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t u+1 0 )
003D3Br 3               
003D3Br 3  4C rr rr                     jmp _line_number_only_from_external
003D3Er 3               
003D3Er 3               _command_mode:
003D3Er 3               
003D3Er 3                               ; We were given something other than an empty line. Set the
003D3Er 3                               ; parameter variables to zero as the default. There is no line
003D3Er 3                               ; zero, because we're coding for normal, sane humans, not weird
003D3Er 3                               ; computer people. Some commands like "a" will take a "line 0",
003D3Er 3                               ; however. We use the ed_flags bit 7 to signal if we are
003D3Er 3                               ; without parameters.
003D3Er 3  20 rr rr                     jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
003D41r 3  20 rr rr                     jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
003D44r 3               
003D44r 3                               ; We start off by taking care of any parameters. These can be
003D44r 3                               ; '%' for the complete text, '$' for the last line, a line
003D44r 3                               ; number, or a line number followed by a ',' and then either
003D44r 3                               ; the '$' for the last line or another number. (The original
003D44r 3                               ; Unix ed has more options, but we're ignoring them for the
003D44r 3                               ; moment.) In pseudocode, what we are doing in this stage looks
003D44r 3                               ; something like this:
003D44r 3               
003D44r 3                               ;        case char = '.':
003D44r 3                               ;              para1 = current line
003D44r 3                               ;
003D44r 3                               ;        case char = '$':
003D44r 3                               ;              para1 = last line
003D44r 3                               ;
003D44r 3                               ;        case char = '%' or ',':
003D44r 3                               ;              para1 = 1
003D44r 3                               ;              para2 = last line
003D44r 3                               ;
003D44r 3                               ;        case char = ';':
003D44r 3                               ;              para1 = current line
003D44r 3                               ;              para2 = last line
003D44r 3                               ;
003D44r 3                               ;        case number:
003D44r 3                               ;              para1 = number
003D44r 3                               ;              get next char
003D44r 3                               ;
003D44r 3                               ;              if char = ',':
003D44r 3                               ;                      get next char
003D44r 3                               ;
003D44r 3                               ;                      case char = '$':
003D44r 3                               ;                              para2 = last line
003D44r 3                               ;
003D44r 3                               ;                      case number:
003D44r 3                               ;                              para2 = number
003D44r 3                               ;
003D44r 3                               ;                      else error
003D44r 3                               ;
003D44r 3                               ;              else get previous char
003D44r 3                               ;
003D44r 3                               ;        else error
003D44r 3                               ;
003D44r 3                               ;        get next char
003D44r 3                               ;        process command char
003D44r 3               
003D44r 3                               ; We use the Y register as an offset to the beginning of the
003D44r 3                               ; character input buffer (cib) because we're never going to
003D44r 3                               ; have more than 255 characters of input with ed and we don't
003D44r 3                               ; want to have to duplicate the complete machinery required for
003D44r 3                               ; >IN. In other words, >IN has no meaning for ed. This means
003D44r 3                               ; that every jmp to _check_command must have Y in a defined
003D44r 3                               ; state, which is different from the rest of Tali Forth.
003D44r 3               
003D44r 3                               ; Parameter processing could probably be handled more
003D44r 3                               ; efficiently with a loop construct similar to the way the
003D44r 3                               ; commands are taken care of below. We'll revisit this once ed
003D44r 3                               ; is feature complete, because of the evils of premature
003D44r 3                               ; optimization.
003D44r 3               
003D44r 3               _prefix_dot:
003D44r 3                               ; --- . --- Designate current line for further operations
003D44r 3  B2 08                        lda (cib)
003D46r 3  C9 2E                        cmp #$2e                ; ASCII '.'
003D48r 3  D0 3A                        bne _prefix_dollar
003D4Ar 3               
003D4Ar 3  20 rr rr                     jsr _have_text
003D4Dr 3               
003D4Dr 3  A5 30                        lda ed_cur
003D4Fr 3  95 02                        sta 2,x
003D51r 3  A5 31                        lda ed_cur+1
003D53r 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
003D55r 3               
003D55r 3                               ; We have a parameter
003D55r 3  A9 80                        lda #%10000000
003D57r 3  04 32                        tsb ed_flags
003D59r 3               
003D59r 3                               ; If we were only given a '.', we print the current line and are
003D59r 3                               ; done
003D59r 3  A5 0A                        lda ciblen
003D5Br 3  3A                           dec                     ; sets Z if A was 1
003D5Cr 3  D0 03                        bne @1
003D5Er 3               
003D5Er 3                               ; We know that we have some text and the number of the last
003D5Er 3                               ; line was provided by _last_line, so in theory we don't have
003D5Er 3                               ; to check if this is a legal line number. However, we keep one
003D5Er 3                               ; entry point, so the check is repeated further down. Call it
003D5Er 3                               ; paranoia.
003D5Er 3  4C rr rr                     jmp _line_number_only_from_external
003D61r 3               @1:
003D61r 3                               ; We have processed the first parameter, and know that we have
003D61r 3                               ; more than just a dot here. We now need to see if the next
003D61r 3                               ; character is a comma or a command character. To do this, we
003D61r 3                               ; need to modify the stack to ( addr-t u-t para1 0 addr u )
003D61r 3  CA                           dex
003D62r 3  CA                           dex
003D63r 3  CA                           dex
003D64r 3  CA                           dex
003D65r 3               
003D65r 3  A5 08                        lda cib
003D67r 3  95 02                        sta 2,x
003D69r 3  A5 09                        lda cib+1
003D6Br 3  95 03                        sta 3,x
003D6Dr 3               
003D6Dr 3  A5 0A                        lda ciblen
003D6Fr 3  95 00                        sta 0,x
003D71r 3  A5 0B                        lda ciblen+1
003D73r 3  95 01                        sta 1,x
003D75r 3               
003D75r 3  20 rr rr                     jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
003D78r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
003D7Br 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
003D7Er 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
003D81r 3               
003D81r 3  4C rr rr                     jmp _check_for_para2
003D84r 3               
003D84r 3               _prefix_dollar:
003D84r 3                               ; --- $ --- Designate last line for further operations
003D84r 3  B2 08                        lda (cib)
003D86r 3  C9 24                        cmp #'$'
003D88r 3  D0 1C                        bne _prefix_percent
003D8Ar 3               
003D8Ar 3  20 rr rr                     jsr _have_text
003D8Dr 3               
003D8Dr 3  E8                           inx
003D8Er 3  E8                           inx                     ; ( addr-t u-t 0 )
003D8Fr 3               
003D8Fr 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t 0 para1 )
003D92r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
003D95r 3               
003D95r 3                               ; We have a parameter
003D95r 3  A9 80                        lda #%10000000
003D97r 3  04 32                        tsb ed_flags
003D99r 3               
003D99r 3                               ; If we were only given a '$', we print the last line and are
003D99r 3                               ; done
003D99r 3  A5 0A                        lda ciblen
003D9Br 3  3A                           dec                     ; sets Z if A was 1
003D9Cr 3  D0 03                        bne @1
003D9Er 3               
003D9Er 3                               ; We know that we have some text and the number of the last
003D9Er 3                               ; line was provided by _last_line, so in theory we don't have
003D9Er 3                               ; to check if this is a legal line number. However, we keep one
003D9Er 3                               ; entry point for the moment and repeat the check further down
003D9Er 3                               ; out of paranoia
003D9Er 3  4C rr rr                     jmp _line_number_only_from_external
003DA1r 3               @1:
003DA1r 3                               ; We are one character into the input buffer cib, so we advance
003DA1r 3                               ; Y as the index accordingly
003DA1r 3  A0 01                        ldy #01
003DA3r 3               
003DA3r 3  4C rr rr                     jmp _check_command
003DA6r 3               
003DA6r 3               _prefix_percent:
003DA6r 3                               ; --- % and , --- Designate whole text for futher operations
003DA6r 3  B2 08                        lda (cib)
003DA8r 3  C9 25                        cmp #$25                ; ASCII '%'
003DAAr 3  F0 04                        beq _whole_text
003DACr 3  C9 2C                        cmp #$2c                ; ASCII ','
003DAEr 3  D0 17                        bne _prefix_semicolon
003DB0r 3               
003DB0r 3               _whole_text:
003DB0r 3                               ; If there is no text yet, print an error
003DB0r 3  20 rr rr                     jsr _have_text
003DB3r 3               
003DB3r 3                               ; We have at least one line of text. The first parameter
003DB3r 3                               ; is therefore line one, the second the last line
003DB3r 3  A9 01                        lda #01
003DB5r 3  95 02                        sta 2,x                 ; LSB of NOS is para 1
003DB7r 3  74 03                        stz 3,x                 ; ( addr-t u-t para1 0 )
003DB9r 3               
003DB9r 3               _semicolon_entry:
003DB9r 3                               ; Get the number (not the address) of the last line and
003DB9r 3                               ; store it as the second parameter
003DB9r 3  E8                           inx
003DBAr 3  E8                           inx                     ; DROP ( addr-t u-t para1 )
003DBBr 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
003DBEr 3               
003DBEr 3                               ; We have a parameter
003DBEr 3  A9 80                        lda #%10000000
003DC0r 3  04 32                        tsb ed_flags
003DC2r 3               
003DC2r 3                               ; We are one character into the input buffer cib, so we advance
003DC2r 3                               ; Y as the index accordingly
003DC2r 3  A0 01                        ldy #01
003DC4r 3               
003DC4r 3  4C rr rr                     jmp _check_command
003DC7r 3               
003DC7r 3               _prefix_semicolon:
003DC7r 3                               ; --- ; --- Designate from current line to end of text
003DC7r 3  B2 08                        lda (cib)
003DC9r 3  C9 3B                        cmp #$3b                ; ASCII ';'
003DCBr 3  D0 0D                        bne _prefix_number
003DCDr 3               
003DCDr 3  20 rr rr                     jsr _have_text
003DD0r 3               
003DD0r 3                               ; The first parameter is the current line
003DD0r 3  A5 30                        lda ed_cur
003DD2r 3  95 02                        sta 2,x
003DD4r 3  A5 31                        lda ed_cur+1
003DD6r 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
003DD8r 3               
003DD8r 3                               ; The second parameter is the last line. We've done this part
003DD8r 3                               ; before for the '%' and ',' parameters, so we reuse that code
003DD8r 3  80 DF                        bra _semicolon_entry
003DDAr 3               
003DDAr 3               _prefix_number:
003DDAr 3                               ; --- <NUM> --- Check if we have been given a number
003DDAr 3               
003DDAr 3                               ; We use the built-in Forth routines for this, which involves
003DDAr 3                               ; calling >NUMBER, which calls UM*, which uses tmp1, tmp2, and
003DDAr 3                               ; tmp3. So we can't use any of those temporary variables. We
003DDAr 3                               ; arrive here with ( addr-t u-t 0 0 ), which doesn't help us at
003DDAr 3                               ; all because the string we are looking at is in ( cib ciblen )
003DDAr 3               
003DDAr 3                               ; Set up >NUMBER using CIB and CIBLEN as the location of the
003DDAr 3                               ; string to check. First, though, add the "accumulator" of
003DDAr 3                               ; >NUMBER as a double number, that is, to single-cell numbers
003DDAr 3  20 rr rr                     jsr xt_zero
003DDDr 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
003DE0r 3               
003DE0r 3  CA                           dex
003DE1r 3  CA                           dex
003DE2r 3  CA                           dex
003DE3r 3  CA                           dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
003DE4r 3               
003DE4r 3  A5 08                        lda cib
003DE6r 3  95 02                        sta 2,x
003DE8r 3  A5 09                        lda cib+1
003DEAr 3  95 03                        sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
003DECr 3               
003DECr 3  A5 0A                        lda ciblen
003DEEr 3  95 00                        sta 0,x
003DF0r 3  A5 0B                        lda ciblen+1
003DF2r 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
003DF4r 3               
003DF4r 3  20 rr rr                     jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
003DF7r 3               
003DF7r 3                               ; If we converted all the characters in the string (u2 is
003DF7r 3                               ; zero), then the user just gave us a line number to
003DF7r 3                               ; jump to and nothing else. Otherwise, take another look
003DF7r 3  B5 00                        lda 0,x
003DF9r 3  15 01                        ora 1,x
003DFBr 3  D0 24                        bne _have_unconverted_chars
003DFDr 3               
003DFDr 3                               ; We must have a line number and nothing else. Make this
003DFDr 3                               ; the current line number and print the line. Remember
003DFDr 3                               ; that at this point, the line number still could be a zero
003DFDr 3  E8                           inx
003DFEr 3  E8                           inx
003DFFr 3  E8                           inx
003E00r 3  E8                           inx                     ; 2DROP ( addr-t u-t 0 0 ud )
003E01r 3               
003E01r 3  20 rr rr                     jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
003E04r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
003E07r 3               
003E07r 3  E8                           inx
003E08r 3  E8                           inx                     ; ( addr-t u-t u 0 ) drop through
003E09r 3               
003E09r 3               _line_number_only_from_external:
003E09r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t 0 u )
003E0Cr 3               
003E0Cr 3  20 rr rr                     jsr _is_valid_line
003E0Fr 3  B0 03                        bcs @1
003E11r 3               
003E11r 3                               ; This is not a valid line number, so we bail
003E11r 3  4C rr rr                     jmp _error_2drop
003E14r 3               @1:
003E14r 3                               ; Legal line number, so make it the current number
003E14r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t u 0 )
003E17r 3  20 rr rr                     jsr _para1_to_cur
003E1Ar 3               
003E1Ar 3                               ; We have a parameter
003E1Ar 3  A9 80                        lda #%10000000
003E1Cr 3  04 32                        tsb ed_flags
003E1Er 3               
003E1Er 3  4C rr rr                     jmp _cmd_p_from_external
003E21r 3               
003E21r 3               _have_unconverted_chars:
003E21r 3                               ; We have some unconverted characters left. If none of the
003E21r 3                               ; characters were converted, we probably just got a
003E21r 3                               ; command character and need to skip the rest of the prefix
003E21r 3                               ; processing. In this case, the number of unconverted
003E21r 3                               ; characters is equal to the length of the string.
003E21r 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
003E24r 3               
003E24r 3  CA                           dex
003E25r 3  CA                           dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
003E26r 3               
003E26r 3  A5 0A                        lda ciblen
003E28r 3  95 00                        sta 0,x
003E2Ar 3  A5 0B                        lda ciblen+1
003E2Cr 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
003E2Er 3               
003E2Er 3  20 rr rr                     jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
003E31r 3               
003E31r 3  B5 00                        lda 0,x
003E33r 3  15 01                        ora 1,x
003E35r 3  F0 0E                        beq _no_command_yet
003E37r 3               
003E37r 3                               ; The length of the input string is equal to the length of the
003E37r 3                               ; unprocessed string that >NUMBER returned. Put differently,
003E37r 3                               ; the first character isn't a number. We know that it isn't '$'
003E37r 3                               ; or '%' either, so we assume that it's a command character.
003E37r 3               
003E37r 3                               ; Clear up the stack and process that command character
003E37r 3  8A                           txa
003E38r 3  18                           clc
003E39r 3  69 0A                        adc #10
003E3Br 3  AA                           tax                     ; ( addr-t u-t 0 0 )
003E3Cr 3               
003E3Cr 3                               ; If we weren't given a number, this means we didn't explicitly
003E3Cr 3                               ; get a 0 either. So we don't have a parameter. This is the
003E3Cr 3                               ; default case, but out of paranoia we explicity clear the flag
003E3Cr 3  A9 80                        lda #%10000000
003E3Er 3  14 32                        trb ed_flags
003E40r 3               
003E40r 3                               ; We don't have any offset, so we go with Y as zero
003E40r 3  A0 00                        ldy #00
003E42r 3               
003E42r 3  4C rr rr                     jmp _check_command
003E45r 3               
003E45r 3               _no_command_yet:
003E45r 3                               ; There actually seems to be a parameter number present.
003E45r 3                               ; Save the number we converted as the first parameter. We
003E45r 3                               ; arrive here with ( addr-t u-t 0 0 ud addr2 u2 f ) from
003E45r 3                               ; >NUMBER. To avoid too long stack comments, we leave the
003E45r 3                               ; target addresses out in this next code segment.
003E45r 3  E8                           inx
003E46r 3  E8                           inx                     ; ( ... 0 0 ud addr2 u2 )
003E47r 3               
003E47r 3  20 rr rr                     jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
003E4Ar 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
003E4Dr 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
003E50r 3               
003E50r 3  B5 00                        lda 0,x                 ; LSB
003E52r 3  95 06                        sta 6,x
003E54r 3  B5 01                        lda 1,x                 ; MSB
003E56r 3  95 07                        sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
003E58r 3               
003E58r 3  E8                           inx
003E59r 3  E8                           inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
003E5Ar 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
003E5Dr 3               
003E5Dr 3                               ; We have a parameter
003E5Dr 3  A9 80                        lda #%10000000
003E5Fr 3  04 32                        tsb ed_flags
003E61r 3               
003E61r 3               _check_for_para2:
003E61r 3                               ; That was the first parameter. If the next character is
003E61r 3                               ; a comma, then there is a second parameter (another number
003E61r 3                               ; or '$'). Otherwise we expect a command. This is the entry
003E61r 3                               ; point if the first character was a dot (eg '.,3p')
003E61r 3  A1 02                        lda (2,x)
003E63r 3               
003E63r 3  C9 2C                        cmp #$2c                ; ASCII code for ',' (comma)
003E65r 3  F0 0D                        beq _got_comma
003E67r 3               
003E67r 3                               ; It's not a comma, so it's going to be a command character.
003E67r 3                               ; We need to figure out how many digits our number has so
003E67r 3                               ; we can adjust Y as the offset. We don't have to do this with
003E67r 3                               ; 16 bit because no input string is going to be that long
003E67r 3  38                           sec
003E68r 3  A5 0A                        lda ciblen
003E6Ar 3  F5 00                        sbc 0,x
003E6Cr 3  A8                           tay
003E6Dr 3               
003E6Dr 3                               ; Remove the leftover stuff from >NUMBER
003E6Dr 3  E8                           inx
003E6Er 3  E8                           inx
003E6Fr 3  E8                           inx
003E70r 3  E8                           inx                     ; 2DROP ( addr-t u-t para1 0 )
003E71r 3               
003E71r 3  4C rr rr                     jmp _check_command
003E74r 3               
003E74r 3               _got_comma:
003E74r 3                               ; It's a comma, so we have a second parameter. The next
003E74r 3                               ; character can either be '$' to signal the end of the text
003E74r 3                               ; or another number. First, though, move to that next char
003E74r 3  F6 02                        inc 2,x
003E76r 3  D0 02                        bne @1
003E78r 3  F6 03                        inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
003E7Ar 3               @1:
003E7Ar 3  B5 01                        lda 1,x
003E7Cr 3  F0 02                        beq @2
003E7Er 3  D6 01                        dec 1,x
003E80r 3               @2:
003E80r 3  D6 00                        dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
003E82r 3               
003E82r 3                               ; See if this is an end-of-line '$'
003E82r 3  A1 02                        lda (2,x)
003E84r 3  C9 24                        cmp #$24                ; ASCII for '$'
003E86r 3  D0 14                        bne _para2_not_dollar
003E88r 3               
003E88r 3                               ; It's a dollar sign, which means para2 is the number of the
003E88r 3                               ; last line of the text. We need to adjust Y as the offset. We
003E88r 3                               ; assume that no command line will be longer than 255
003E88r 3                               ; characters in ed so we can get away with just looking at
003E88r 3                               ; the LSB
003E88r 3  38                           sec
003E89r 3  A5 0A                        lda ciblen
003E8Br 3  F5 02                        sbc 2,x
003E8Dr 3  A8                           tay
003E8Er 3               
003E8Er 3                               ; However, we need to move Y up by one because we were on the
003E8Er 3                               ; '$' and not on the character after that
003E8Er 3  C8                           iny
003E8Fr 3  5A                           phy
003E90r 3               
003E90r 3                               ; Dump all the stuff from >NUMBER off the stack. This saves
003E90r 3                               ; one byte compared to six INX instructions, and a byte saved
003E90r 3                               ; is a byte earned.
003E90r 3  8A                           txa
003E91r 3  18                           clc
003E92r 3  69 06                        adc #06
003E94r 3  AA                           tax                     ; ( addr-t u-t para1 )
003E95r 3               
003E95r 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
003E98r 3               
003E98r 3  7A                           ply
003E99r 3  4C rr rr                     jmp _check_command
003E9Cr 3               
003E9Cr 3               _para2_not_dollar:
003E9Cr 3                               ; It's not a dollar sign, so it is either another number or an
003E9Cr 3                               ; error. We try for a number first. We arrive here with ( para1
003E9Cr 3                               ; 0 addr2+1 u2-1 ), which u2-1 pointing to the first mystery
003E9Cr 3                               ; character after the comma. Again, we skip the ( addr-t u-t )
003E9Cr 3                               ; at the beginning of the stack comment here.
003E9Cr 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
003E9Fr 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
003EA2r 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
003EA5r 3  20 rr rr                     jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
003EA8r 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
003EABr 3               
003EABr 3                               ; We'll need a copy of the length of the rest of the string to
003EABr 3                               ; see if we've actually done any work
003EABr 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
003EAEr 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
003EB1r 3               
003EB1r 3  20 rr rr                     jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
003EB4r 3               
003EB4r 3                               ; If the original string and the leftover string have the same
003EB4r 3                               ; length, then nothing was converted and we have an error
003EB4r 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
003EB7r 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
003EBAr 3  20 rr rr                     jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
003EBDr 3               
003EBDr 3  B5 00                        lda 0,x
003EBFr 3  15 01                        ora 1,x
003EC1r 3  F0 08                        beq _second_number
003EC3r 3               
003EC3r 3                               ; The strings are the same length, so nothing was converted, so
003EC3r 3                               ; we have an error. We have to get all that stuff off the
003EC3r 3                               ; stack first
003EC3r 3  8A                           txa
003EC4r 3  18                           clc
003EC5r 3  69 0C                        adc #12
003EC7r 3  AA                           tax                     ; back to ( addr-t u-t )
003EC8r 3               
003EC8r 3  4C rr rr                     jmp _error
003ECBr 3               
003ECBr 3               _second_number:
003ECBr 3                               ; We have a second number, so we add it to para2. We arrive here
003ECBr 3                               ; with ( para1 0 ud addr3 u3 f )
003ECBr 3  E8                           inx
003ECCr 3  E8                           inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
003ECDr 3               
003ECDr 3                               ; Calculate the offset for Y
003ECDr 3  38                           sec
003ECEr 3  A5 0A                        lda ciblen
003ED0r 3  F5 00                        sbc 0,x
003ED2r 3  48                           pha
003ED3r 3               
003ED3r 3                               ; Clean up the stack
003ED3r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
003ED6r 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
003ED9r 3  20 rr rr                     jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
003EDCr 3               
003EDCr 3  7A                           ply
003EDDr 3               
003EDDr 3                               ; fall through to _check_command
003EDDr 3               
003EDDr 3               _check_command:
003EDDr 3                               ; At this point, we assume that we have handled any parameters
003EDDr 3                               ; which are now in their place on the stack, which must have
003EDDr 3                               ; the format ( addr-t u-t para1 para2 ). Also, any offset to CIB
003EDDr 3                               ; is going to be in Y. Bit 7 in ed_flags signals if we have
003EDDr 3                               ; a parameter or not.
003EDDr 3               
003EDDr 3                               ; Command character checking works by comparing the char we
003EDDr 3                               ; have at CIB+Y with a list of legal characters. The index in
003EDDr 3                               ; the list is the index of the command's routine in a jump
003EDDr 3                               ; table. The list itself is zero-terminated, which is okay
003EDDr 3                               ; because we've taken care of any legal parameters.
003EDDr 3  B1 08                        lda (cib),y             ; get mystery char from input
003EDFr 3  85 24                        sta tmp1
003EE1r 3               
003EE1r 3                               ; We're going to need X for the jump table, so it has to
003EE1r 3                               ; take a break from being the Data Stack Pointer (DSP). Pushing
003EE1r 3                               ; X to the stack uses less space than storing in the reserved
003EE1r 3                               ; space on the Zero Page
003EE1r 3  DA                           phx
003EE2r 3  A2 00                        ldx #00
003EE4r 3               _cmd_loop:
003EE4r 3  BD rr rr                     lda ed_cmd_list,x
003EE7r 3  F0 07                        beq _illegal_command    ; zero marks end of list
003EE9r 3               
003EE9r 3  C5 24                        cmp tmp1
003EEBr 3  F0 07                        beq _found_cmd
003EEDr 3               
003EEDr 3                               ; No match, next char
003EEDr 3  E8                           inx
003EEEr 3  80 F4                        bra _cmd_loop
003EF0r 3               
003EF0r 3               _illegal_command:
003EF0r 3                               ; Whatever the user gave us, we don't recognize it
003EF0r 3  FA                           plx
003EF1r 3               
003EF1r 3  4C rr rr                     jmp _error_2drop
003EF4r 3               
003EF4r 3               _found_cmd:
003EF4r 3                               ; We have a command match. Because this is the 65c02 and not
003EF4r 3                               ; the 65816, we can only use JMP (addr,x) and not a subroutine
003EF4r 3                               ; jump. That sucks.
003EF4r 3  8A                           txa
003EF5r 3  0A                           asl
003EF6r 3  AA                           tax                     ; X * 2 for table
003EF7r 3               
003EF7r 3                               ; Note we're jumping with the DSP still on the stack, so each
003EF7r 3                               ; command routine has to pull it into X the very first thing
003EF7r 3                               ; with its very own PLX. There doesn't seem to be a sane way to
003EF7r 3                               ; avoid this.
003EF7r 3  7C rr rr                     jmp (ed_cmd_table,x)
003EFAr 3               
003EFAr 3               _next_command:
003EFAr 3                               ; Clean up the stack and return to the input loop. We
003EFAr 3                               ; arrive here with ( addr-t u-t para1 para2 ). The called
003EFAr 3                               ; command routines have taken care of putting the DSP (that's
003EFAr 3                               ; X) back the way it should be
003EFAr 3  E8                           inx
003EFBr 3  E8                           inx
003EFCr 3  E8                           inx
003EFDr 3  E8                           inx                     ; ( addr-t u-t ) Fall through
003EFEr 3               
003EFEr 3               _next_command_empty:
003EFEr 3                               ; The beginning of the input loop takes care of resetting the
003EFEr 3                               ; parameter flag
003EFEr 3  4C rr rr                     jmp _input_loop
003F01r 3               
003F01r 3               _all_done:
003F01r 3                               ; That's enough for ed today. We have to clear out the input
003F01r 3                               ; buffer or else the Forth main main loop will react to the
003F01r 3                               ; last input command
003F01r 3  64 0A                        stz ciblen
003F03r 3  64 0B                        stz ciblen+1
003F05r 3               
003F05r 3                               ; Clean up the stack
003F05r 3  20 rr rr                     jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
003F08r 3               
003F08r 3  60                           rts
003F09r 3               
003F09r 3               
003F09r 3               ; === COMMAND ROUTINES ====
003F09r 3               
003F09r 3               ; We enter all command subroutines with ( addr-t u-t para1 para2 ) and the DSP
003F09r 3               ; still on the Return Stack. This means that the first oder of business is to
003F09r 3               ; restore the DSP with PLX -- remember this when you add new commands. At this
003F09r 3               ; point, we don't need the offset in Y anymore so we are free to use it as we
003F09r 3               ; please.
003F09r 3               
003F09r 3               ; There is potential to rewrite many of the command routines with an abstract
003F09r 3               ; construct in the form of (pseudocode):
003F09r 3               
003F09r 3               ;       f = cmd         ; command such as d, p, n, as a function
003F09r 3               ;       map f range(para1, para2)
003F09r 3               
003F09r 3               ; That is, have one routine with a looping structure and pass the actual work
003F09r 3               ; as a function. However, this is 8-bit assembler and not, say, Haskell, so
003F09r 3               ; that abstraction will wait for a future round of refracturing when we have
003F09r 3               ; everything complete and working.
003F09r 3               
003F09r 3               ; -------------------------
003F09r 3               _cmd_a:
003F09r 3                       ; a -- Add text after current/given line. If no line is given, we use
003F09r 3                       ; the current line. We accept the number '0' and then start adding at
003F09r 3                       ; the very beginning. The second parameter is always ignored. This
003F09r 3                       ; routine is used by i as well.
003F09r 3  FA                           plx
003F0Ar 3               
003F0Ar 3                               ; We don't care about para2, because a just adds stuff starting
003F0Ar 3                               ; the line we were given
003F0Ar 3  E8                           inx
003F0Br 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
003F0Cr 3               
003F0Cr 3                               ; If we weren't given a parameter, make the current line the
003F0Cr 3                               ; parameter
003F0Cr 3  24 32                        bit ed_flags
003F0Er 3  30 08                        bmi _cmd_a_have_para
003F10r 3               
003F10r 3  A5 30                        lda ed_cur
003F12r 3  95 00                        sta 0,x
003F14r 3  A5 31                        lda ed_cur+1
003F16r 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
003F18r 3               
003F18r 3               _entry_cmd_i:
003F18r 3                               ; This is where i enters with a parameter that is calculated to
003F18r 3                               ; be one before the current line, or given line, or so that we
003F18r 3                               ; accept 0. We are ( addr-t u-t num )
003F18r 3               
003F18r 3               _cmd_a_have_para:
003F18r 3  20 rr rr                     jsr _num_to_addr        ;  ( addr-t u-t addr1 )
003F1Br 3  20 rr rr                     jsr xt_cr
003F1Er 3               
003F1Er 3               _next_string_loop:
003F1Er 3                               ; This is where we land when we are continuing in with another
003F1Er 3                               ; string after the first one. ( addr-t u-t addr1 )
003F1Er 3  20 rr rr                     jsr _get_input
003F21r 3               
003F21r 3                               ; If there is only one character and that character is a
003F21r 3                               ; dot, we're done with adding text and switch back to command
003F21r 3                               ; mode
003F21r 3  B2 08                        lda (cib)
003F23r 3  C9 2E                        cmp #$2e                ; ASCII for '.'
003F25r 3  D0 16                        bne _add_line
003F27r 3               
003F27r 3                               ; So it's a dot, but that the only character in the line?
003F27r 3                               ; We want the length to be one character exactly
003F27r 3  A4 0A                        ldy ciblen
003F29r 3  C0 01                        cpy #01
003F2Br 3  D0 10                        bne _add_line
003F2Dr 3               
003F2Dr 3  A4 0B                        ldy ciblen+1
003F2Fr 3  D0 0C                        bne _add_line
003F31r 3               
003F31r 3                               ; Yes, it is a dot, so we're done adding lines.
003F31r 3  E8                           inx
003F32r 3  E8                           inx
003F33r 3               
003F33r 3                               ; The string is stored and the new node is full. Time to set the
003F33r 3                               ; changed flag
003F33r 3  A9 40                        lda #%01000000
003F35r 3  04 32                        tsb ed_flags
003F37r 3               
003F37r 3  20 rr rr                     jsr xt_cr
003F3Ar 3  4C rr rr                     jmp _input_loop
003F3Dr 3               
003F3Dr 3               _add_line:
003F3Dr 3                               ; Break the linked list so we can insert another node
003F3Dr 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
003F40r 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
003F43r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
003F46r 3  20 rr rr                     jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
003F49r 3  20 rr rr                     jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
003F4Cr 3               
003F4Cr 3                               ; We're going to need that HERE for the next line if more
003F4Cr 3                               ; than one line is added. This is a good time to save it on
003F4Cr 3                               ; the stack
003F4Cr 3  20 rr rr                     jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
003F4Fr 3               
003F4Fr 3                               ; We have now saved the link to the next node at HERE, which is
003F4Fr 3                               ; where the CP was pointing. CP has been advanced by one cell,
003F4Fr 3                               ; but we still have the original as HERE on the stack. That
003F4Fr 3                               ; address now has to go where addr2 was before.
003F4Fr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
003F52r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
003F55r 3               
003F55r 3                               ; Thus concludes the mucking about with node links. Now we have
003F55r 3                               ; to create a new header. The CP we access with HERE points to
003F55r 3                               ; the cell after the new node address, which is where we want
003F55r 3                               ; to put ( ) for the new string
003F55r 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t here here2)
003F58r 3               
003F58r 3                               ; Reserve two cells (four bytes on the 65c02) for the ( addr u )
003F58r 3                               ; of the new string
003F58r 3  A5 00                        lda cp
003F5Ar 3  18                           clc
003F5Br 3  69 04                        adc #04
003F5Dr 3  85 00                        sta cp
003F5Fr 3  90 02                        bcc @1
003F61r 3  E6 01                        inc cp+1
003F63r 3               @1:
003F63r 3                               ; HERE now points to after the new header. Since we're really
003F63r 3                               ; going to add something, we can increase the current line
003F63r 3                               ; number
003F63r 3  E6 30                        inc ed_cur
003F65r 3  D0 02                        bne @2
003F67r 3  E6 31                        inc ed_cur+1
003F69r 3               @2:
003F69r 3                               ; We have the new line sitting in ( cib ciblen ) and need to
003F69r 3                               ; a) move it somewhere safe and b) get ready for the next
003F69r 3                               ; line. We arrive here with ( addr-t u-t here here2 ), where here2
003F69r 3                               ; is where the new string needs to be. The MOVE command we're
003F69r 3                               ; going to use has the format ( addr1 addr2 u )
003F69r 3               
003F69r 3  20 rr rr                     jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
003F6Cr 3  20 rr rr                     jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
003F6Fr 3               
003F6Fr 3  CA                           dex
003F70r 3  CA                           dex             ; ( addr-t u-t here here2 here3 here3 ? )
003F71r 3  A5 08                        lda cib
003F73r 3  95 00                        sta 0,x
003F75r 3  A5 09                        lda cib+1
003F77r 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
003F79r 3               
003F79r 3  20 rr rr                     jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
003F7Cr 3               
003F7Cr 3  CA                           dex
003F7Dr 3  CA                           dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
003F7Er 3  A5 0A                        lda ciblen
003F80r 3  95 00                        sta 0,x
003F82r 3  A5 0B                        lda ciblen+1
003F84r 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
003F86r 3               
003F86r 3  20 rr rr                     jsr xt_move     ; ( addr-t u-t here here2 here3 )
003F89r 3               
003F89r 3                               ; We need to adjust CP be the length of the string
003F89r 3  18                           clc
003F8Ar 3  A5 00                        lda cp
003F8Cr 3  65 0A                        adc ciblen
003F8Er 3  85 00                        sta cp
003F90r 3  90 06                        bcc @3
003F92r 3  A5 01                        lda cp+1
003F94r 3  65 0B                        adc ciblen+1
003F96r 3  85 01                        sta cp+1
003F98r 3               @3:
003F98r 3                               ; The string is now moved safely out of the input buffer to the
003F98r 3                               ; main memory at ( here3 ciblin ). Now we have to fix that
003F98r 3                               ; fact in the header. We start with the address.
003F98r 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
003F9Br 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here here2 )
003F9Er 3               
003F9Er 3  20 rr rr                     jsr xt_one_plus         ; 1+
003FA1r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
003FA4r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
003FA7r 3               
003FA7r 3  A5 0A                        lda ciblen
003FA9r 3  95 02                        sta 2,x
003FABr 3  A5 0B                        lda ciblen+1
003FADr 3  95 03                        sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
003FAFr 3               
003FAFr 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
003FB2r 3               
003FB2r 3                               ; Add a line feed for visuals
003FB2r 3  20 rr rr                     jsr xt_cr
003FB5r 3               
003FB5r 3                               ; Remeber that original HERE we've been dragging along all the
003FB5r 3                               ; time? Now we find out why. We return to the loop to pick up
003FB5r 3                               ; the next input
003FB5r 3  4C rr rr                     jmp _next_string_loop
003FB8r 3               
003FB8r 3               ; -------------------------
003FB8r 3               _cmd_d:
003FB8r 3                       ; d -- Delete one or more lines. This might have to be coded as
003FB8r 3                       ; a subroutine because other commands such as 'c' might be easier to
003FB8r 3                       ; implement that way. Note that a lot of this code is very similar to
003FB8r 3                       ; the loop for 'p'. We arrive here with ( addr-t u-t para1 para2 )
003FB8r 3  FA                           plx
003FB9r 3               
003FB9r 3  20 rr rr                     jsr _have_text
003FBCr 3  20 rr rr                     jsr _no_line_zero
003FBFr 3               
003FBFr 3                               ; At least the first line is valid. Most common case is one
003FBFr 3                               ; line, so we check to see if we even have a second parameter.
003FBFr 3  B5 00                        lda 0,x
003FC1r 3  15 01                        ora 1,x
003FC3r 3  D0 08                        bne @1
003FC5r 3               
003FC5r 3                               ; The second parameter is a zero, so delete one line
003FC5r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 0 para1 )
003FC8r 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
003FCBr 3  80 33                        bra _cmd_d_done
003FCDr 3               @1:
003FCDr 3                               ; We have been given a range. Make sure that the second
003FCDr 3                               ; parameter is legal. We arrive here with ( addr-t u-t para1 para2 )
003FCDr 3  20 rr rr                     jsr _is_valid_line      ; result is in C flag
003FD0r 3  B0 03                        bcs _cmd_d_loop
003FD2r 3               
003FD2r 3                               ; para2 is not valid. Complain and abort
003FD2r 3  4C rr rr                     jmp _error_2drop
003FD5r 3               
003FD5r 3               _cmd_d_loop:
003FD5r 3                               ; Seems to be a legal range. Walk through and delete If para1
003FD5r 3                               ; is larger than para2, we're done. Note that Unix ed throws an
003FD5r 3                               ; error if we start out that way, we might do that in future as
003FD5r 3                               ; well. This is not the same code as for 'p', because we have
003FD5r 3                               ; to delete from the back
003FD5r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
003FD8r 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
003FDBr 3               
003FDBr 3  B5 00                        lda 0,x
003FDDr 3  15 01                        ora 1,x
003FDFr 3  D0 0D                        bne _cmd_d_done_with_flag
003FE1r 3               
003FE1r 3                               ; Para2 is still larger or the same size as para1, so we
003FE1r 3                               ; continue
003FE1r 3  E8                           inx
003FE2r 3  E8                           inx                     ; Get rid of the flag from >
003FE3r 3               
003FE3r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
003FE6r 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
003FE9r 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
003FECr 3               
003FECr 3  80 E7                        bra _cmd_d_loop
003FEEr 3               
003FEEr 3               _cmd_d_done_with_flag:
003FEEr 3  E8                           inx                     ; ( addr-t u-t para1 para2 )
003FEFr 3  E8                           inx
003FF0r 3               
003FF0r 3                               ; The current line is set to the first line minus
003FF0r 3                               ; one. Since we don't accept '0d', this at least
003FF0r 3                               ; hast to be one
003FF0r 3  B5 02                        lda 2,x
003FF2r 3  D0 02                        bne @1
003FF4r 3  D6 03                        dec 3,x
003FF6r 3               @1:
003FF6r 3  D6 02                        dec 2,x
003FF8r 3               
003FF8r 3  B5 02                        lda 2,x
003FFAr 3  85 30                        sta ed_cur
003FFCr 3  B5 03                        lda 3,x
003FFEr 3  85 31                        sta ed_cur+1            ; drop through to _cmd_d_done
004000r 3               
004000r 3               _cmd_d_done:
004000r 3                               ; Text has changed, set flag
004000r 3  A9 40                        lda #%01000000
004002r 3  04 32                        tsb ed_flags
004004r 3               
004004r 3  20 rr rr                     jsr xt_cr
004007r 3               
004007r 3  4C rr rr                     jmp _next_command
00400Ar 3               
00400Ar 3               _cmd_d_common:
00400Ar 3                       ; Internal subroutine to delete a single line when given the line
00400Ar 3                       ; number TOS. Consumes TOS. What we do is take the link to the next
00400Ar 3                       ; node and put it in the previous node. The caller is responsible
00400Ar 3                       ; for setting ed_changed. We arrive here with ( u )
00400Ar 3               
00400Ar 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t u u )
00400Dr 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t u addr )
004010r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
004013r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
004016r 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
004019r 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr1 addr-1 )
00401Cr 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t )
00401Fr 3               
00401Fr 3  60                           rts
004020r 3               
004020r 3               ; -------------------------
004020r 3               _cmd_equ:
004020r 3                       ; = --- Print the given line number or the current line number if no
004020r 3                       ; value is given. This is useful if you want to know what the number of
004020r 3                       ; the last line is ("$=")
004020r 3  FA                           plx
004021r 3               
004021r 3                               ; If we don't have a text, we follow Unix ed's example and
004021r 3                               ; print a zero. It would seem to make more sense to throw an
004021r 3                               ; error, but who are we to argue with Unix.
004021r 3  A5 2E                        lda ed_head
004023r 3  05 2F                        ora ed_head+1
004025r 3  D0 08                        bne _cmd_equ_have_text
004027r 3               
004027r 3                               ; Fake it: load 0 as para2 and then print. The 0 goes in a new
004027r 3                               ; line just like with Unix ed
004027r 3  CA                           dex
004028r 3  CA                           dex
004029r 3  74 00                        stz 0,x
00402Br 3  74 01                        stz 1,x                 ; ( addr-t u-t para1 para2 0 )
00402Dr 3  80 21                        bra _cmd_equ_done
00402Fr 3               
00402Fr 3               _cmd_equ_have_text:
00402Fr 3                               ; We have taken care of the case where we don't have a text. If
00402Fr 3                               ; we have a line zero, it is explicit, and we don't do that
00402Fr 3  20 rr rr                     jsr _no_line_zero
004032r 3               
004032r 3                               ; If we have no parameters, just print the current line number
004032r 3  24 32                        bit ed_flags
004034r 3  30 0C                        bmi _cmd_equ_have_para
004036r 3               
004036r 3  CA                           dex
004037r 3  CA                           dex                     ; ( addr-t u-t para1 para2 ? )
004038r 3  A5 30                        lda ed_cur
00403Ar 3  95 00                        sta 0,x
00403Cr 3  A5 31                        lda ed_cur+1
00403Er 3  95 01                        sta 1,x
004040r 3               
004040r 3  80 0E                        bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
004042r 3               
004042r 3               _cmd_equ_have_para:
004042r 3                               ; We have at least one parameter, and we know it is not zero.
004042r 3                               ; We follow the behavior of Unix ed here: If there is one
004042r 3                               ; parameter, we print its line number. If there are two
004042r 3                               ; separated by a comma (etc), we print the second line number
004042r 3                               ; of the range
004042r 3  B5 00                        lda 0,x
004044r 3  15 01                        ora 1,x
004046r 3  D0 05                        bne _cmd_equ_two_paras
004048r 3               
004048r 3                               ; We've got one parameter
004048r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1)
00404Br 3  80 03                        bra _cmd_equ_done
00404Dr 3               
00404Dr 3               _cmd_equ_two_paras:
00404Dr 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
004050r 3               
004050r 3               _cmd_equ_done:
004050r 3  20 rr rr                     jsr xt_cr               ; number goes on new line
004053r 3  20 rr rr                     jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
004056r 3  20 rr rr                     jsr xt_cr
004059r 3               
004059r 3  4C rr rr                     jmp _next_command
00405Cr 3               
00405Cr 3               
00405Cr 3               ; -------------------------
00405Cr 3               _cmd_f:
00405Cr 3                       ; f -- Print the address that a write command ("w") will go to or set
00405Cr 3                       ; it. If no parameter was passed, we print the address we have on hand,
00405Cr 3                       ; with a parameter, we set that to the new address. We accept a zero,
00405Cr 3                       ; though that would be a weird place to write, but we do need a text
00405Cr 3  FA                           plx
00405Dr 3               
00405Dr 3  24 32                        bit ed_flags
00405Fr 3  30 17                        bmi _cmd_f_have_para
004061r 3               
004061r 3  20 rr rr                     jsr xt_cr
004064r 3               
004064r 3                               ; No parameters, just a naked "f", so print the address buried
004064r 3                               ; at the fourth position of the stack: We arrive here with
004064r 3                               ; ( addr-t u-t 0 0 )
004064r 3  20 rr rr                     jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
004067r 3  20 rr rr                     jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
00406Ar 3  20 rr rr                     jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
00406Dr 3  20 rr rr                     jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
004070r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
004073r 3  20 rr rr                     jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
004076r 3               
004076r 3  80 11                        bra _cmd_f_done
004078r 3               
004078r 3               _cmd_f_have_para:
004078r 3                               ; We do no sanity tests at all. This is Forth, if the user
004078r 3                               ; wants to blow up the Zero Page and the Stack, sure, go right
004078r 3                               ; ahead, whatever.
004078r 3  20 rr rr                     jsr xt_over
00407Br 3  20 rr rr                     jsr xt_cr
00407Er 3  20 rr rr                     jsr xt_u_dot
004081r 3               
004081r 3  B5 02                        lda 2,x
004083r 3  95 06                        sta 6,x
004085r 3  B5 03                        lda 3,x
004087r 3  95 07                        sta 7,x                 ; fall through to _cmd_f_done
004089r 3               
004089r 3               _cmd_f_done:
004089r 3  20 rr rr                     jsr xt_cr
00408Cr 3               
00408Cr 3  4C rr rr                     jmp _next_command
00408Fr 3               
00408Fr 3               
00408Fr 3               ; -------------------------
00408Fr 3               _cmd_i:
00408Fr 3                       ; i --- Add text before current line. We allow '0i' and 'i' just like
00408Fr 3                       ; the Unix ed. Note that this routine just prepares the line numbers so
00408Fr 3                       ; we can reuse most of the code from a.
00408Fr 3  FA                           plx
004090r 3               
004090r 3                               ; We don't care about para2, because i just adds stuff before
004090r 3                               ; the line we were given.
004090r 3  E8                           inx
004091r 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
004092r 3               
004092r 3                               ; If we weren't given a parameter, make the current line the
004092r 3                               ; parameter
004092r 3  24 32                        bit ed_flags
004094r 3  30 08                        bmi _cmd_i_have_para
004096r 3               
004096r 3                               ; No parameter, take current line
004096r 3  A5 30                        lda ed_cur
004098r 3  95 00                        sta 0,x
00409Ar 3  A5 31                        lda ed_cur+1
00409Cr 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
00409Er 3               
00409Er 3               _cmd_i_have_para:
00409Er 3                               ; If the parameter is zero, we skip the next part and behave
00409Er 3                               ; completely like the "a" command
00409Er 3  B5 00                        lda 0,x
0040A0r 3  15 01                        ora 1,x
0040A2r 3  F0 09                        beq _cmd_i_done
0040A4r 3               
0040A4r 3                               ; We have some other line number, so we start one above it
0040A4r 3  20 rr rr                     jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
0040A7r 3  20 rr rr                     jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
0040AAr 3  20 rr rr                     jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
0040ADr 3               _cmd_i_done:
0040ADr 3  4C rr rr                     jmp _entry_cmd_i
0040B0r 3               
0040B0r 3               
0040B0r 3               ; -------------------------
0040B0r 3               _cmd_n:
0040B0r 3                       ; n -- Print lines with a line number. We just set a flag here and
0040B0r 3                       ; let p do all the heavy work.
0040B0r 3               
0040B0r 3  FA                           plx
0040B1r 3               
0040B1r 3  A9 01                        lda #%00000001
0040B3r 3  04 32                        tsb ed_flags
0040B5r 3               
0040B5r 3  80 05                        bra _cmd_p_entry_for_cmd_n
0040B7r 3               
0040B7r 3               
0040B7r 3               ; -------------------------
0040B7r 3               _cmd_p:
0040B7r 3                       ; p -- Print lines without line numbers. This routine is also used
0040B7r 3                       ; by n, the difference is in a flag. Note that this routine is
0040B7r 3                       ; able to handle line numbers greater than 255 even though it's
0040B7r 3                       ; hard to believe somebody would actually use this editor for anything
0040B7r 3                       ; that long. I'm really sure Leo Tolstoy would not have created "War
0040B7r 3                       ; and Peace" on a 65c02.
0040B7r 3               
0040B7r 3  FA                           plx
0040B8r 3               
0040B8r 3               _cmd_p_from_external:
0040B8r 3                               ; This is coming from p, the variant without line numbers. We
0040B8r 3                               ; set the ed_flags' bit 0 to zero to mark this
0040B8r 3  A9 01                        lda #%00000001
0040BAr 3  14 32                        trb ed_flags
0040BCr 3               
0040BCr 3               _cmd_p_entry_for_cmd_n:
0040BCr 3  20 rr rr                     jsr _have_text
0040BFr 3  20 rr rr                     jsr _no_line_zero
0040C2r 3               
0040C2r 3  20 rr rr                     jsr xt_cr
0040C5r 3               
0040C5r 3                               ; We now know that there is some number in para1. The most
0040C5r 3                               ; common case is that para2 is zero and we're being asked to
0040C5r 3                               ; print a single line
0040C5r 3  B5 00                        lda 0,x
0040C7r 3  15 01                        ora 1,x
0040C9r 3  D0 08                        bne _cmd_p_loop
0040CBr 3               
0040CBr 3                               ; Print a single line and be done with it. We could use
0040CBr 3                               ; DROP here and leave immediately but we want this routine
0040CBr 3                               ; to have a single exit at the bottom.
0040CBr 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
0040CEr 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
0040D1r 3               
0040D1r 3  80 1E                        bra _cmd_p_all_done
0040D3r 3               
0040D3r 3               _cmd_p_loop:
0040D3r 3                               ; We are being asked to print more than one line, which
0040D3r 3                               ; is a bit trickier. If para1 is larger than para2, we're
0040D3r 3                               ; done. Note that Unix ed throws an error if we start out
0040D3r 3                               ; that way, we might do that in future as well
0040D3r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
0040D6r 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
0040D9r 3               
0040D9r 3  B5 00                        lda 0,x
0040DBr 3  15 01                        ora 1,x
0040DDr 3  D0 10                        bne _cmd_p_done
0040DFr 3               
0040DFr 3                               ; Para2 is still larger or the same size as para1, so we
0040DFr 3                               ; continue
0040DFr 3  E8                           inx
0040E0r 3  E8                           inx                     ; Get rid of the flag from >
0040E1r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
0040E4r 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
0040E7r 3               
0040E7r 3  F6 02                        inc 2,x
0040E9r 3  D0 02                        bne @1
0040EBr 3  F6 03                        inc 3,x
0040EDr 3               @1:
0040EDr 3  80 E4                        bra _cmd_p_loop
0040EFr 3               
0040EFr 3               _cmd_p_done:
0040EFr 3                               ; We arrive here with ( addr-t u-t para1 para2 f )
0040EFr 3  E8                           inx
0040F0r 3  E8                           inx                     ; fall through to _cmp_p_all_done
0040F1r 3               _cmd_p_all_done:
0040F1r 3  4C rr rr                     jmp _next_command
0040F4r 3               
0040F4r 3               
0040F4r 3               _cmd_p_common:
0040F4r 3                       ; Internal subroutine to print a single line when given the line number
0040F4r 3                       ; TOS. Consumes TOS. Used by both n and p. We arrive here with
0040F4r 3                       ; ( addr-t u-t para1 ) as the line number
0040F4r 3               
0040F4r 3                               ; See if we're coming from p (no line numbers, ed_flag is zero)
0040F4r 3                               ; or from n (line numbers and a TAB, ed_flag is $FF)
0040F4r 3  A5 32                        lda ed_flags
0040F6r 3  4A                           lsr                     ; bit 0 now in carry
0040F7r 3  90 0B                        bcc _cmd_p_common_no_num
0040F9r 3               
0040F9r 3                               ; Bit 0 is set, this is coming from n. Print the line number
0040F9r 3                               ; followed by a tab
0040F9r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
0040FCr 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u-t para1 )
0040FFr 3               
0040FFr 3  A9 09                        lda #$09                 ; ASCII for Tab
004101r 3  20 rr rr                     jsr emit_a
004104r 3               
004104r 3               _cmd_p_common_no_num:
004104r 3                               ; One way or the other, print the the node's string
004104r 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr )
004107r 3  20 rr rr                     jsr _print_addr
00410Ar 3               
00410Ar 3  60                           rts
00410Br 3               
00410Br 3               
00410Br 3               ; -------------------------
00410Br 3               _cmd_q:
00410Br 3                       ; q -- Quit if all work as been saved, complain otherwise
00410Br 3               
00410Br 3  FA                           plx
00410Cr 3               
00410Cr 3  24 32                        bit ed_flags            ; bit 6 is change flag
00410Er 3  50 03                        bvc @1
004110r 3  4C rr rr                     jmp _error_2drop
004113r 3               @1:
004113r 3  4C rr rr                     jmp _all_done            ; can't fall thru because of PLX
004116r 3               
004116r 3               
004116r 3               ; -------------------------
004116r 3               _cmd_qq:
004116r 3                       ; Q -- Quit unconditionally, dumping any work that is unsaved
004116r 3                       ; without any warning. We can't just jump to all done because
004116r 3                       ; of the PLX
004116r 3  FA                           plx
004117r 3               
004117r 3  4C rr rr                     jmp _all_done
00411Ar 3               
00411Ar 3               
00411Ar 3               ; -------------------------
00411Ar 3               _cmd_w:
00411Ar 3                       ; w --- Write text to system memory. In contrast to the Unix ed word,
00411Ar 3                       ; we provide the address before the command, such as "8000w". If no
00411Ar 3                       ; address is given -- just 'w' -- we write to whatever was fixed with
00411Ar 3                       ; 'f'. To prevent a common, but potentially common error, we do not
00411Ar 3                       ; allow writing to the first page ($0000 to $00FF) unless the address
00411Ar 3                       ; was specificially passed as a parameter. Currently, we can only enter
00411Ar 3                       ; the address in decimal.
00411Ar 3  FA                           plx
00411Br 3               
00411Br 3  20 rr rr                     jsr _have_text
00411Er 3               
00411Er 3  24 32                        bit ed_flags
004120r 3  30 13                        bmi _cmd_w_have_para
004122r 3               
004122r 3                               ; If we don't have a parameter, we check what is stored on the
004122r 3                               ; stack and use that address -- UNLESS IT IS 0000, which is
004122r 3                               ; what it would be if the user wasn't thinking and just pressed
004122r 3                               ; 'w' at the beginning. We arrive here with ( addr-t u-t 0 0 )
004122r 3  B5 06                        lda 6,x
004124r 3  15 07                        ora 7,x
004126r 3  D0 03                        bne @1
004128r 3               
004128r 3                               ; It's a zero, generate an error to protect the users from
004128r 3                               ; themselves
004128r 3  4C rr rr                     jmp _error_2drop
00412Br 3               @1:
00412Br 3                               ; Not a zero, we assume user knows what they are doing. Get the
00412Br 3                               ; address.
00412Br 3  B5 06                        lda 6,x
00412Dr 3  95 02                        sta 2,x
00412Fr 3  B5 07                        lda 7,x
004131r 3  95 03                        sta 3,x                 ; ( addr-t u-t addr-t ? )
004133r 3               
004133r 3  80 08                        bra _cmd_w_para_ready
004135r 3               
004135r 3               _cmd_w_have_para:
004135r 3                               ; We were given a parameter, which we now make the new
004135r 3                               ; default parameter. This is different from Unix w, where
004135r 3                               ; the filename set by f is not changed by w
004135r 3  B5 02                        lda 2,x
004137r 3  95 06                        sta 6,x
004139r 3  B5 03                        lda 3,x
00413Br 3  95 07                        sta 7,x                 ; drop through to _cmd_w_para_ready
00413Dr 3               
00413Dr 3               _cmd_w_para_ready:
00413Dr 3                               ; We don't care about the second parameter, the first one must
00413Dr 3                               ; be an address. There is actually no way to test if this is an
00413Dr 3                               ; address because any number could be a 16-bit address. Anyway,
00413Dr 3                               ; we overwrite para2 with the address where the pointer to the
00413Dr 3                               ; first entry in the list is kept.
00413Dr 3  A9 2E                        lda #<ed_head
00413Fr 3  95 00                        sta 0,x
004141r 3  A9 00                        lda #>ed_head
004143r 3  95 01                        sta 1,x                 ; ( addr-t u-t addr-t addr-h )
004145r 3               
004145r 3                               ; We need to keep a copy of the original target address to
004145r 3                               ; calculate how many chars (including carriage returns) we
004145r 3                               ; saved at the end of this routine
004145r 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
004148r 3  20 rr rr                     jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
00414Br 3               
00414Br 3               _cmd_w_loop:
00414Br 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
00414Er 3               
00414Er 3                               ; If we're at the end of the list, quit. For the next block of
00414Er 3                               ; text, we ignore the ( addr-t u-t ) at the beginning
00414Er 3  B5 00                        lda 0,x
004150r 3  15 01                        ora 1,x
004152r 3  F0 55                        beq _cmd_w_eol
004154r 3               
004154r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
004157r 3  20 rr rr                     jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
00415Ar 3               
00415Ar 3                               ; Get the address and length of the string from the header
00415Ar 3                               ; of this node
00415Ar 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
00415Dr 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
004160r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
004163r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
004166r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
004169r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
00416Cr 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
00416Fr 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
004172r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
004175r 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
004178r 3  20 rr rr                     jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
00417Br 3               
00417Br 3                               ; We need a copy of the string length u-s to adjust the pointer
00417Br 3                               ; to the store area later
00417Br 3  20 rr rr                     jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
00417Er 3  20 rr rr                     jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
004181r 3               
004181r 3  20 rr rr                     jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
004184r 3               
004184r 3                               ; Calculate the position of the next string in the save area.
004184r 3                               ; What we don't do is remember the length of the individual
004184r 3                               ; strings; instead at the end we will subtract addresses to
004184r 3                               ; get the length of the string
004184r 3  20 rr rr                     jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
004187r 3  20 rr rr                     jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
00418Ar 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
00418Dr 3  20 rr rr                     jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
004190r 3               
004190r 3                               ; But wait, our strings are terminated by Line Feeds in
004190r 3                               ; memory, so we need to add one
004190r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
004193r 3               
004193r 3  CA                           dex
004194r 3  CA                           dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
004195r 3  A9 0A                        lda #AscLF              ; ASCII for LF
004197r 3  95 00                        sta 0,x
004199r 3  74 01                        stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
00419Br 3               
00419Br 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
00419Er 3  20 rr rr                     jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
0041A1r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
0041A4r 3               
0041A4r 3                               ; Now we can handle the next line
0041A4r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
0041A7r 3               
0041A7r 3  80 A2                        bra _cmd_w_loop
0041A9r 3               
0041A9r 3               _cmd_w_eol:
0041A9r 3                               ; We're at the end of the text buffer and arrive here with
0041A9r 3                               ; ( addr-tn addr-n ) ( R: addr-t ) What we do now is calculate
0041A9r 3                               ; the number of characters saved and put that value in the 3OS
0041A9r 3                               ; position
0041A9r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
0041ACr 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
0041AFr 3  20 rr rr                     jsr xt_minus            ; - ( addr-t u-t addr-n u )
0041B2r 3               
0041B2r 3  B5 00                        lda 0,x
0041B4r 3  95 04                        sta 4,x
0041B6r 3  B5 01                        lda 1,x
0041B8r 3  95 05                        sta 5,x                 ; ( addr-t u addr-n u )
0041BAr 3               
0041BAr 3                               ; Unix ed puts the number of characters on a new line, so we
0041BAr 3                               ; do as well
0041BAr 3  20 rr rr                     jsr xt_cr
0041BDr 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u addr-n u u )
0041C0r 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u addr-n u )
0041C3r 3  20 rr rr                     jsr xt_cr
0041C6r 3               
0041C6r 3                               ; Reset the changed flag
0041C6r 3  A9 40                        lda #%01000000
0041C8r 3  14 32                        trb ed_flags
0041CAr 3               
0041CAr 3  4C rr rr                     jmp _next_command
0041CDr 3               
0041CDr 3               
0041CDr 3               ; === ERROR HANDLING ===
0041CDr 3               
0041CDr 3               _error_2drop:
0041CDr 3                               ; Lots of times we'll have para1 and para2 on the stack when an
0041CDr 3                               ; error occurs, so we drop stuff here
0041CDr 3  E8                           inx
0041CEr 3  E8                           inx                     ; drop through to _error_1drop
0041CFr 3               _error_1drop:
0041CFr 3  E8                           inx
0041D0r 3  E8                           inx                     ; drop through to _error
0041D1r 3               _error:
0041D1r 3                               ; Error handling with ed is really primitive: We print a question
0041D1r 3                               ; mark and go back to the loop. Any code calling this routine must
0041D1r 3                               ; clean up the stack itself: We expect it to be empty. Note that
0041D1r 3                               ; ed currently does not support reporting the type of error on
0041D1r 3                               ; demand like Unix ed does
0041D1r 3  20 rr rr                     jsr xt_cr
0041D4r 3               
0041D4r 3  A9 3F                        lda #'?'
0041D6r 3  20 rr rr                     jsr emit_a
0041D9r 3               
0041D9r 3  20 rr rr                     jsr xt_cr
0041DCr 3               
0041DCr 3  4C rr rr                     jmp _input_loop
0041DFr 3               
0041DFr 3               
0041DFr 3               ; === HELPER FUNCTIONS ===
0041DFr 3               
0041DFr 3               _get_input:
0041DFr 3                       ; Use REFILL to get input from the user, which is left in
0041DFr 3                       ; ( cib ciblen ) as usual.
0041DFr 3  20 rr rr                     jsr xt_refill           ;  ( addr-t u-t f )
0041E2r 3               
0041E2r 3                               ; If something went wrong while getting the user input, print
0041E2r 3                               ; a question mark and try again. No fancy error messages
0041E2r 3                               ; for ed!
0041E2r 3  B5 00                        lda 0,x
0041E4r 3  15 01                        ora 1,x
0041E6r 3  D0 05                        bne @1
0041E8r 3               
0041E8r 3                               ; Whatever went wrong, we can't handle it here anyway. We
0041E8r 3                               ; clear the return stack, dump the error flag and call
0041E8r 3                               ; a normal error
0041E8r 3  7A                           ply
0041E9r 3  7A                           ply
0041EAr 3               
0041EAr 3  4C rr rr                     jmp _error_1drop
0041EDr 3               @1:
0041EDr 3                               ; Drop the flag
0041EDr 3  E8                           inx
0041EEr 3  E8                           inx
0041EFr 3               
0041EFr 3  60                           rts
0041F0r 3               
0041F0r 3               ; -----------------------------
0041F0r 3               _have_text:
0041F0r 3                       ; See if we have any lines at all. If not, abort with an error. We
0041F0r 3                       ; could in theory set a flag every time we add a text, but this is
0041F0r 3                       ; more robust, if somewhat longer
0041F0r 3  A5 2E                        lda ed_head
0041F2r 3  05 2F                        ora ed_head+1
0041F4r 3  D0 04                        bne @1
0041F6r 3               
0041F6r 3                               ; We don't have any lines. Clean up the return stack and throw
0041F6r 3                               ; an error
0041F6r 3  7A                           ply
0041F7r 3  7A                           ply
0041F8r 3  80 D7                        bra _error
0041FAr 3               @1:
0041FAr 3  60                           rts
0041FBr 3               
0041FBr 3               ; -----------------------------
0041FBr 3               _is_valid_line:
0041FBr 3                       ; See if the line number in TOS is valid. If yes, returns the carry
0041FBr 3                       ; flag set ("true"), otherwise cleared ("false"). Does not change
0041FBr 3                       ; the value of TOS. Line numbers must be 0 < number <= last_line.
0041FBr 3                       ; This routine calls _last_line.
0041FBr 3  38                           sec                             ; default is legal line number
0041FCr 3               
0041FCr 3                               ; First see if we have a zero
0041FCr 3  B5 00                        lda 0,x
0041FEr 3  15 01                        ora 1,x
004200r 3  F0 19                        beq _is_valid_line_nope_zero    ; ( n )
004202r 3               
004202r 3                               ; Not a zero. Now see if we're beyond the last line
004202r 3  20 rr rr                     jsr xt_dup                      ; DUP ( n n )
004205r 3  20 rr rr                     jsr _last_line                  ; ( n n last )
004208r 3  20 rr rr                     jsr xt_swap                     ; SWAP ( n last n )
00420Br 3  20 rr rr                     jsr xt_less_than                ; < ( n f )
00420Er 3               
00420Er 3  B5 00                        lda 0,x                         ; 0 flag is good
004210r 3  15 01                        ora 1,x
004212r 3  D0 05                        bne _is_valid_line_too_small
004214r 3               
004214r 3                               ; We're good, clean up and leave
004214r 3  E8                           inx
004215r 3  E8                           inx                     ; DROP flag ( n )
004216r 3               
004216r 3  38                           sec                     ; Who knows what's happened to C by now
004217r 3  80 03                        bra _is_valid_line_done ; only one exit from this routine
004219r 3               
004219r 3               _is_valid_line_too_small:
004219r 3  E8                           inx
00421Ar 3  E8                           inx                     ; drop through to _is_valid_line_zero
00421Br 3               
00421Br 3               _is_valid_line_nope_zero:
00421Br 3  18                           clc                     ; drop through to _is_valid_line_done
00421Cr 3               
00421Cr 3               _is_valid_line_done:
00421Cr 3  60                           rts
00421Dr 3               
00421Dr 3               
00421Dr 3               ; -----------------------------
00421Dr 3               _last_line:
00421Dr 3                       ; Calculate the number of the last line (not its address) and return
00421Dr 3                       ; it TOS. Note this shares code with _num_to_addr. Assumes that user
00421Dr 3                       ; has made sure there are any lines at all
00421Dr 3               
00421Dr 3                               ; Set counter to zero
00421Dr 3  64 24                        stz tmp1
00421Fr 3  64 25                        stz tmp1+1
004221r 3               
004221r 3  CA                           dex
004222r 3  CA                           dex                     ; ( ? )
004223r 3  A9 2E                        lda #<ed_head
004225r 3  95 00                        sta 0,x
004227r 3  A9 00                        lda #>ed_head
004229r 3  95 01                        sta 1,x                 ; ( addr )
00422Br 3               
00422Br 3               _last_line_loop:
00422Br 3  20 rr rr                     jsr xt_fetch            ; ( addr | 0 )
00422Er 3               
00422Er 3                               ; If that's over, we're at the end of the list and we're done
00422Er 3  B5 00                        lda 0,x
004230r 3  15 01                        ora 1,x
004232r 3  F0 08                        beq _last_line_done
004234r 3               
004234r 3                               ; Not done. Increase counter and continue
004234r 3  E6 24                        inc tmp1
004236r 3  D0 02                        bne @1
004238r 3  E6 25                        inc tmp1+1
00423Ar 3               @1:
00423Ar 3  80 EF                        bra _last_line_loop
00423Cr 3               
00423Cr 3               _last_line_done:
00423Cr 3  A5 24                        lda tmp1
00423Er 3  95 00                        sta 0,x
004240r 3  A5 25                        lda tmp1+1
004242r 3  95 01                        sta 1,x                 ; ( u )
004244r 3               
004244r 3  60                           rts
004245r 3               
004245r 3               
004245r 3               ; -----------------------------
004245r 3               _no_line_zero:
004245r 3                       ; Make sure we weren't given an explicit zero as the line number with
004245r 3                       ; commands that don't accept it (that is, pretty much everybody except
004245r 3                       ; a). If para1 is a zero and we have parameters (bit 7 of ed_flag set),
004245r 3                       ; throw an error
004245r 3               
004245r 3                               ; See if para1 is zero
004245r 3  B5 02                        lda 2,x
004247r 3  15 03                        ora 3,x
004249r 3  D0 07                        bne _no_line_zero_done
00424Br 3               
00424Br 3                               ; It's zero. If bit 7 of ed_flag is set, this is an explicit
00424Br 3                               ; parameter
00424Br 3  24 32                        bit ed_flags
00424Dr 3  10 03                        bpl _no_line_zero_done
00424Fr 3               
00424Fr 3  4C rr rr                     jmp _error_2drop
004252r 3               
004252r 3               _no_line_zero_done:
004252r 3                               ; All is well, we can continue
004252r 3  60                           rts
004253r 3               
004253r 3               ; -----------------------------
004253r 3               _num_to_addr:
004253r 3                       ; Given a line number as TOS, replace it by the address of the node.
004253r 3                       ; If the line number is zero, we return the address of the header
004253r 3                       ; node. If the line number is beyond the last line, we return a
004253r 3                       ; zero, though we're assuming the user will check for a legal
004253r 3                       ; line number before calling this routine. Assumes we have checked that
004253r 3                       ; we have any text at all.
004253r 3               
004253r 3                               ; One way or another we're going to start with the
004253r 3                               ; address of the pointer to the head of the list
004253r 3  CA                           dex
004254r 3  CA                           dex                     ; ( u ? )
004255r 3  A9 2E                        lda #<ed_head
004257r 3  95 00                        sta 0,x
004259r 3  A9 00                        lda #>ed_head
00425Br 3  95 01                        sta 1,x                 ; ( u addr-h )
00425Dr 3               
00425Dr 3                               ; Handle the case where the line number is zero
00425Dr 3  B5 02                        lda 2,x
00425Fr 3  15 03                        ora 3,x
004261r 3  D0 05                        bne _num_to_addr_loop
004263r 3               
004263r 3                               ; It's zero, so we're already done
004263r 3  20 rr rr                     jsr xt_nip              ; ( addr-h )
004266r 3  80 21                        bra _num_to_addr_done
004268r 3               
004268r 3               _num_to_addr_loop:
004268r 3                               ; Get the first line
004268r 3  20 rr rr                     jsr xt_fetch            ; @ ( u addr1 )
00426Br 3               
00426Br 3                               ; If that's zero, we're at the end of the list and it's over
00426Br 3  B5 00                        lda 0,x
00426Dr 3  15 01                        ora 1,x
00426Fr 3  D0 05                        bne @1
004271r 3               
004271r 3  20 rr rr                     jsr xt_nip              ; NIP ( addr1 )
004274r 3  80 13                        bra _num_to_addr_done
004276r 3               @1:
004276r 3                               ; It's not zero. See if this is the nth element we're looking
004276r 3                               ; for
004276r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr1 u )
004279r 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr1 u-1 )
00427Cr 3               
00427Cr 3  B5 00                        lda 0,x
00427Er 3  15 01                        ora 1,x
004280r 3  F0 05                        beq _num_to_addr_finished
004282r 3               
004282r 3                               ; Not zero yet, try again
004282r 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-1 addr1 )
004285r 3               
004285r 3  80 E1                        bra _num_to_addr_loop
004287r 3               
004287r 3               _num_to_addr_finished:
004287r 3                               ; We arrive here with ( addr u )
004287r 3  E8                           inx
004288r 3  E8                           inx                     ; ( addr )
004289r 3               
004289r 3               _num_to_addr_done:
004289r 3  60                           rts
00428Ar 3               
00428Ar 3               
00428Ar 3               ; -----------------------------
00428Ar 3               _para1_to_cur:
00428Ar 3                       ; Switch the current line number to whatever the first parameter
00428Ar 3                       ; is. We do this a lot so this routine saves a few bytes
00428Ar 3  B5 02                        lda 2,x
00428Cr 3  85 30                        sta ed_cur
00428Er 3  B5 03                        lda 3,x
004290r 3  85 31                        sta ed_cur+1
004292r 3               
004292r 3  60                           rts
004293r 3               
004293r 3               
004293r 3               ; -----------------------------
004293r 3               _print_addr:
004293r 3                       ; Given the address of a node TOS, print the string it comes with.
004293r 3                       ; Assumes we have made sure that this address exists. It would be
004293r 3                       ; nice to put the CR at the beginning, but that doesn't work with
004293r 3                       ; the n commands, so at the end it goes. Consumes TOS.
004293r 3  20 rr rr                     jsr xt_one_plus
004296r 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 )
004299r 3               
004299r 3  20 rr rr                     jsr xt_dup              ; ( addr+2 addr+2 )
00429Cr 3               
00429Cr 3  20 rr rr                     jsr xt_one_plus
00429Fr 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 addr+4 )
0042A2r 3               
0042A2r 3  20 rr rr                     jsr xt_fetch            ; ( addr+2 u-s )
0042A5r 3  20 rr rr                     jsr xt_swap             ; ( u-s addr+2 )
0042A8r 3  20 rr rr                     jsr xt_fetch            ; ( u-s addr-s )
0042ABr 3               
0042ABr 3  20 rr rr                     jsr xt_swap             ; ( addr-s u-s )
0042AEr 3  20 rr rr                     jsr xt_type
0042B1r 3  20 rr rr                     jsr xt_cr
0042B4r 3               
0042B4r 3  60                           rts
0042B5r 3               
0042B5r 3               
0042B5r 3               ; === COMMAND TABLES ===
0042B5r 3               
0042B5r 3               ; The commands are all one character and kept in a 0-terminated string that is
0042B5r 3               ; walked by a loop. Their index corresponds to the index of their routine's
0042B5r 3               ; address in the jump table. To create a new command, add it's letter at the
0042B5r 3               ; correct position in the command list and the routine's address in the command
0042B5r 3               ; jump table. Oh, and write the routine as well. Capital letters such as 'Q' are
0042B5r 3               ; coded in their routine's address as double letters ('_cmd_qq').
0042B5r 3               
0042B5r 3  61 66 69 64  ed_cmd_list:    .byte "afidpn=wqQ", 0
0042B9r 3  70 6E 3D 77  
0042BDr 3  71 51 00     
0042C0r 3               
0042C0r 3               ed_cmd_table:
0042C0r 3  rr rr rr rr                  .word _cmd_a, _cmd_f, _cmd_i, _cmd_d, _cmd_p, _cmd_n
0042C4r 3  rr rr rr rr  
0042C8r 3  rr rr rr rr  
0042CCr 3  rr rr rr rr                  .word _cmd_equ, _cmd_w, _cmd_q, _cmd_qq
0042D0r 3  rr rr rr rr  
0042D4r 3               
0042D4r 3               
0042D4r 3               ed6502_end:     ; Used to calculate size of editor code
0042D4r 3               
0042D4r 2               
0042D4r 2               ; High-level Forth words, see forth_code/README.md
0042D4r 2               forth_words_start:
0042D4r 2  20 63 72 20  .incbin "forth_words.asc"
0042D8r 2  2E 28 20 52  
0042DCr 2  65 61 64 79  
0042E6r 2               forth_words_end:
0042E6r 2               
0042E6r 2               ; User-defined Forth words, see forth_code/README.md
0042E6r 2               user_words_start:
0042E6r 2  20 32 30 20  .incbin "user_words.asc"
0042EAr 2  63 6F 6E 73  
0042EEr 2  74 61 6E 74  
00491Dr 2               user_words_end:
00491Dr 2               
00491Dr 2               .include "headers.asm"          ; Headers of native words
00491Dr 3               ; Dictionary Headers for Tali Forth 2
00491Dr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00491Dr 3               ; First version: 05. Dec 2016 (Liara Forth)
00491Dr 3               ; This version: 29. Dec 2018
00491Dr 3               
00491Dr 3               ; Dictionary headers are kept separately from the code, which allows various
00491Dr 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
00491Dr 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
00491Dr 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
00491Dr 3               ; header in the Dictionary. There the link to the next word in the Dictionary
00491Dr 3               ; is always one cell down from the current word's own nt. In the code itself,
00491Dr 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
00491Dr 3               
00491Dr 3               ; This gives us the following header structure:
00491Dr 3               
00491Dr 3               ;              8 bit     8 bit
00491Dr 3               ;               LSB       MSB
00491Dr 3               ; nt_word ->  +--------+--------+
00491Dr 3               ;          +0 | Length | Status |
00491Dr 3               ;             +--------+--------+
00491Dr 3               ;          +2 | Next Header     | -> nt_next_word
00491Dr 3               ;             +-----------------+
00491Dr 3               ;          +4 | Start of Code   | -> xt_word
00491Dr 3               ;             +-----------------+
00491Dr 3               ;          +6 | End of Code     | -> z_word
00491Dr 3               ;             +--------+--------+
00491Dr 3               ;          +8 | Name   |        |
00491Dr 3               ;             +--------+--------+
00491Dr 3               ;             |        |        |
00491Dr 3               ;             +--------+--------+
00491Dr 3               ;             |        |  ...   | (name string does not end with a zero)
00491Dr 3               ;          +n +--------+--------+
00491Dr 3               
00491Dr 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
00491Dr 3               ; which are:
00491Dr 3               
00491Dr 3               ;       CO - Compile Only
00491Dr 3               ;       IM - Immediate Word
00491Dr 3               ;       NN - Never Native Compile (must always be called by JSR)
00491Dr 3               ;       AN - Always Native Compile (may not be called by JSR)
00491Dr 3               ;       UF - Contains underflow check
00491Dr 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
00491Dr 3               
00491Dr 3               ; Note there are currently two bits unused.
00491Dr 3               
00491Dr 3               ; By default, all existing words can be natively compiled (compiled inline) or
00491Dr 3               ; as a subroutine jump target; the system decides which variant to use based on
00491Dr 3               ; a threshold the user can set. By default, all user-created words are flagged
00491Dr 3               ; never-native. The user can override this by using the always-native word
00491Dr 3               ; just after defining their new word.  The NN flag forbids native compiling,
00491Dr 3               ; the AN flag forces it.
00491Dr 3               
00491Dr 3               ; The last word (top word in code) is always BYE. It is marked as the last word
00491Dr 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
00491Dr 3               ; more common ones first (further down in code) so they are found earlier.
00491Dr 3               ; Anything to do with output comes later (further up) because things will
00491Dr 3               ; always be slow if there is a human involved.
00491Dr 3               
00491Dr 3               ; The initial skeleton of this list was automatically generated by a script
00491Dr 3               ; in the tools folder and then sorted by hand.
00491Dr 3               
00491Dr 3               nt_bye:
00491Dr 3  03                   .byte 3         ; length of word strings
00491Er 3  00                   .byte 0         ; status byte
00491Fr 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
004921r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
004923r 3  rr rr                .word z_bye     ; end of code (RTS)
004925r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
004928r 3               
004928r 3               
004928r 3               nt_cold:
004928r 3  04 00                .byte 4, 0
00492Ar 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
00492Er 3  rr rr        
004930r 3  63 6F 6C 64          .byte "cold"
004934r 3               
004934r 3               nt_lcdput:
004934r 3  06 10                .byte 6, UF
004936r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
00493Ar 3  rr rr        
00493Cr 3  6C 63 64 70          .byte "lcdput"
004940r 3  75 74        
004942r 3               
004942r 3               nt_lcdprint:
004942r 3  08 10                .byte 8, UF
004944r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
004948r 3  rr rr        
00494Ar 3  6C 63 64 70          .byte "lcdprint"
00494Er 3  72 69 6E 74  
004952r 3               
004952r 3               nt_cls:
004952r 3  03 00                .byte 3, 0
004954r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
004958r 3  rr rr        
00495Ar 3  63 6C 73             .byte "cls"
00495Dr 3               
00495Dr 3               nt_spi_init:
00495Dr 3  08 00                .byte 8, 0
00495Fr 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
004963r 3  rr rr        
004965r 3  73 70 69 5F          .byte "spi_init"
004969r 3  69 6E 69 74  
00496Dr 3               
00496Dr 3               
00496Dr 3               nt_spi_clk_toggle:
00496Dr 3  0E 00                .byte 14, 0
00496Fr 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
004973r 3  rr rr        
004975r 3  73 70 69 5F          .byte "spi_clk_toggle"
004979r 3  63 6C 6B 5F  
00497Dr 3  74 6F 67 67  
004983r 3               
004983r 3               nt_spi_select:
004983r 3  0A 00                .byte 10, 0
004985r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
004989r 3  rr rr        
00498Br 3  73 70 69 5F          .byte "spi_select"
00498Fr 3  73 65 6C 65  
004993r 3  63 74        
004995r 3               
004995r 3               nt_spi_transceive:
004995r 3  0E 00                .byte 14, 0
004997r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
00499Br 3  rr rr        
00499Dr 3  73 70 69 5F          .byte "spi_transceive"
0049A1r 3  74 72 61 6E  
0049A5r 3  73 63 65 69  
0049ABr 3               
0049ABr 3               nt_sd_init:
0049ABr 3  07 00                .byte 7, 0
0049ADr 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
0049B1r 3  rr rr        
0049B3r 3  73 64 5F 69          .byte "sd_init"
0049B7r 3  6E 69 74     
0049BAr 3               
0049BAr 3               nt_ed:                  ; ed6502
0049BAr 3  02 08                .byte 2, NN
0049BCr 3  rr rr rr rr          .word nt_sd_init, xt_ed, z_ed
0049C0r 3  rr rr        
0049C2r 3  65 64                .byte "ed"
0049C4r 3               
0049C4r 3  03 08        nt_see: .byte 3, NN
0049C6r 3  rr rr rr rr          .word nt_ed, xt_see, z_see
0049CAr 3  rr rr        
0049CCr 3  73 65 65             .byte "see"
0049CFr 3               
0049CFr 3               nt_forth:
0049CFr 3  05 00                .byte 5, 0
0049D1r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
0049D5r 3  rr rr        
0049D7r 3  66 6F 72 74          .byte "forth"
0049DBr 3  68           
0049DCr 3               
0049DCr 3               nt_order:
0049DCr 3  05 00                .byte 5, 0
0049DEr 3  rr rr rr rr          .word nt_forth, xt_order, z_order
0049E2r 3  rr rr        
0049E4r 3  6F 72 64 65          .byte "order"
0049E8r 3  72           
0049E9r 3               
0049E9r 3               nt_to_order:
0049E9r 3  06 00                .byte 6, 0
0049EBr 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
0049EFr 3  rr rr        
0049F1r 3  3E 6F 72 64          .byte ">order"
0049F5r 3  65 72        
0049F7r 3               
0049F7r 3               nt_previous:
0049F7r 3  08 00                .byte 8, 0
0049F9r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
0049FDr 3  rr rr        
0049FFr 3  70 72 65 76          .byte "previous"
004A03r 3  69 6F 75 73  
004A07r 3               
004A07r 3               nt_also:
004A07r 3  04 00                .byte 4, 0
004A09r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
004A0Dr 3  rr rr        
004A0Fr 3  61 6C 73 6F          .byte "also"
004A13r 3               
004A13r 3               nt_only:
004A13r 3  04 00                .byte 4, 0
004A15r 3  rr rr rr rr          .word nt_also, xt_only, z_only
004A19r 3  rr rr        
004A1Br 3  6F 6E 6C 79          .byte "only"
004A1Fr 3               
004A1Fr 3               nt_forth_wordlist:      ; shares code with ZERO
004A1Fr 3  0E 00                .byte 14, 0
004A21r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
004A25r 3  rr rr        
004A27r 3  66 6F 72 74          .byte "forth-wordlist"
004A2Br 3  68 2D 77 6F  
004A2Fr 3  72 64 6C 69  
004A35r 3               
004A35r 3               nt_editor_wordlist:     ; shares code with ONE
004A35r 3  0F 00                .byte 15, 0
004A37r 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
004A3Br 3  rr rr        
004A3Dr 3  65 64 69 74          .byte "editor-wordlist"
004A41r 3  6F 72 2D 77  
004A45r 3  6F 72 64 6C  
004A4Cr 3               
004A4Cr 3               nt_assembler_wordlist:  ; shares code with TWO
004A4Cr 3  12 00                .byte 18, 0
004A4Er 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
004A52r 3  rr rr        
004A54r 3  61 73 73 65          .byte "assembler-wordlist"
004A58r 3  6D 62 6C 65  
004A5Cr 3  72 2D 77 6F  
004A66r 3               
004A66r 3               nt_root_wordlist:
004A66r 3  0D 00                .byte 13, 0
004A68r 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
004A6Cr 3  rr rr        
004A6Er 3  72 6F 6F 74          .byte "root-wordlist"
004A72r 3  2D 77 6F 72  
004A76r 3  64 6C 69 73  
004A7Br 3               
004A7Br 3               nt_get_order:
004A7Br 3  09 00                .byte 9, 0
004A7Dr 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
004A81r 3  rr rr        
004A83r 3  67 65 74 2D          .byte "get-order"
004A87r 3  6F 72 64 65  
004A8Br 3  72           
004A8Cr 3               
004A8Cr 3               nt_set_order:
004A8Cr 3  09 00                .byte 9, 0
004A8Er 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
004A92r 3  rr rr        
004A94r 3  73 65 74 2D          .byte "set-order"
004A98r 3  6F 72 64 65  
004A9Cr 3  72           
004A9Dr 3               
004A9Dr 3               nt_get_current:
004A9Dr 3  0B 00                .byte 11, 0
004A9Fr 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
004AA3r 3  rr rr        
004AA5r 3  67 65 74 2D          .byte "get-current"
004AA9r 3  63 75 72 72  
004AADr 3  65 6E 74     
004AB0r 3               
004AB0r 3               nt_set_current:
004AB0r 3  0B 10                .byte 11, UF
004AB2r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
004AB6r 3  rr rr        
004AB8r 3  73 65 74 2D          .byte "set-current"
004ABCr 3  63 75 72 72  
004AC0r 3  65 6E 74     
004AC3r 3               
004AC3r 3               nt_search_wordlist:
004AC3r 3  0F 10                .byte 15, UF
004AC5r 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
004AC9r 3  rr rr        
004ACBr 3  73 65 61 72          .byte "search-wordlist"
004ACFr 3  63 68 2D 77  
004AD3r 3  6F 72 64 6C  
004ADAr 3               
004ADAr 3               nt_wordlist:
004ADAr 3  08 00                .byte 8, 0
004ADCr 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
004AE0r 3  rr rr        
004AE2r 3  77 6F 72 64          .byte "wordlist"
004AE6r 3  6C 69 73 74  
004AEAr 3               
004AEAr 3               nt_definitions:
004AEAr 3  0B 00                .byte 11, 0
004AECr 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
004AF0r 3  rr rr        
004AF2r 3  64 65 66 69          .byte "definitions"
004AF6r 3  6E 69 74 69  
004AFAr 3  6F 6E 73     
004AFDr 3               
004AFDr 3               nt_block_ramdrive_init:
004AFDr 3  13 10                .byte 19, UF
004AFFr 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
004B03r 3  rr rr        
004B05r 3  62 6C 6F 63          .byte "block-ramdrive-init"
004B09r 3  6B 2D 72 61  
004B0Dr 3  6D 64 72 69  
004B18r 3               
004B18r 3               nt_list:
004B18r 3  04 10                .byte 4, UF
004B1Ar 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
004B1Er 3  rr rr        
004B20r 3  6C 69 73 74          .byte "list"
004B24r 3               
004B24r 3               nt_thru:
004B24r 3  04 10                .byte 4, UF
004B26r 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
004B2Ar 3  rr rr        
004B2Cr 3  74 68 72 75          .byte "thru"
004B30r 3               
004B30r 3               nt_load:
004B30r 3  04 10                .byte 4, UF
004B32r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
004B36r 3  rr rr        
004B38r 3  6C 6F 61 64          .byte "load"
004B3Cr 3               
004B3Cr 3               nt_flush:
004B3Cr 3  05 00                .byte 5, 0
004B3Er 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
004B42r 3  rr rr        
004B44r 3  66 6C 75 73          .byte "flush"
004B48r 3  68           
004B49r 3               
004B49r 3               nt_empty_buffers:
004B49r 3  0D 00                .byte 13, 0
004B4Br 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
004B4Fr 3  rr rr        
004B51r 3  65 6D 70 74          .byte "empty-buffers"
004B55r 3  79 2D 62 75  
004B59r 3  66 66 65 72  
004B5Er 3               
004B5Er 3               nt_buffer:
004B5Er 3  06 00                .byte 6, 0
004B60r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
004B64r 3  rr rr        
004B66r 3  62 75 66 66          .byte "buffer"
004B6Ar 3  65 72        
004B6Cr 3               
004B6Cr 3               nt_update:
004B6Cr 3  06 00                .byte 6, 0
004B6Er 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
004B72r 3  rr rr        
004B74r 3  75 70 64 61          .byte "update"
004B78r 3  74 65        
004B7Ar 3               
004B7Ar 3               nt_block:
004B7Ar 3  05 00                .byte 5, 0
004B7Cr 3  rr rr rr rr          .word nt_update, xt_block, z_block
004B80r 3  rr rr        
004B82r 3  62 6C 6F 63          .byte "block"
004B86r 3  6B           
004B87r 3               
004B87r 3               nt_save_buffers:
004B87r 3  0C 00                .byte 12, 0
004B89r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
004B8Dr 3  rr rr        
004B8Fr 3  73 61 76 65          .byte "save-buffers"
004B93r 3  2D 62 75 66  
004B97r 3  66 65 72 73  
004B9Br 3               
004B9Br 3               nt_block_read_vector:
004B9Br 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
004B9Dr 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
004BA1r 3  rr rr        
004BA3r 3  62 6C 6F 63          .byte "block-read-vector"
004BA7r 3  6B 2D 72 65  
004BABr 3  61 64 2D 76  
004BB4r 3               
004BB4r 3               nt_block_read:
004BB4r 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
004BB6r 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
004BBAr 3  rr rr        
004BBCr 3  62 6C 6F 63          .byte "block-read"
004BC0r 3  6B 2D 72 65  
004BC4r 3  61 64        
004BC6r 3               
004BC6r 3               nt_block_write_vector:
004BC6r 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
004BC8r 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
004BCCr 3  rr rr        
004BCEr 3  62 6C 6F 63          .byte "block-write-vector"
004BD2r 3  6B 2D 77 72  
004BD6r 3  69 74 65 2D  
004BE0r 3               
004BE0r 3               nt_block_write:
004BE0r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
004BE2r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
004BE6r 3  rr rr        
004BE8r 3  62 6C 6F 63          .byte "block-write"
004BECr 3  6B 2D 77 72  
004BF0r 3  69 74 65     
004BF3r 3               
004BF3r 3               nt_blk:
004BF3r 3  03 00                .byte 3, 0
004BF5r 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
004BF9r 3  rr rr        
004BFBr 3  62 6C 6B             .byte "blk"
004BFEr 3               
004BFEr 3               nt_scr:
004BFEr 3  03 00                .byte 3, 0
004C00r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
004C04r 3  rr rr        
004C06r 3  73 63 72             .byte "scr"
004C09r 3               
004C09r 3               nt_blkbuffer:
004C09r 3  09 00                .byte 9, 0
004C0Br 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
004C0Fr 3  rr rr        
004C11r 3  62 6C 6B 62          .byte "blkbuffer"
004C15r 3  75 66 66 65  
004C19r 3  72           
004C1Ar 3               
004C1Ar 3               nt_buffblocknum:
004C1Ar 3  0C 00                .byte 12, 0
004C1Cr 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
004C20r 3  rr rr        
004C22r 3  62 75 66 66          .byte "buffblocknum"
004C26r 3  62 6C 6F 63  
004C2Ar 3  6B 6E 75 6D  
004C2Er 3               
004C2Er 3               nt_buffstatus:
004C2Er 3  0A 00                .byte 10, 0
004C30r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
004C34r 3  rr rr        
004C36r 3  62 75 66 66          .byte "buffstatus"
004C3Ar 3  73 74 61 74  
004C3Er 3  75 73        
004C40r 3               
004C40r 3               nt_buffer_colon:
004C40r 3  07 00                .byte 7, 0
004C42r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
004C46r 3  rr rr        
004C48r 3  62 75 66 66          .byte "buffer:"
004C4Cr 3  65 72 3A     
004C4Fr 3               
004C4Fr 3               nt_useraddr:
004C4Fr 3  08 00                .byte 8, 0
004C51r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
004C55r 3  rr rr        
004C57r 3  75 73 65 72          .byte "useraddr"
004C5Br 3  61 64 64 72  
004C5Fr 3               
004C5Fr 3               nt_action_of:
004C5Fr 3  09 04                .byte 9, IM
004C61r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
004C65r 3  rr rr        
004C67r 3  61 63 74 69          .byte "action-of"
004C6Br 3  6F 6E 2D 6F  
004C6Fr 3  66           
004C70r 3               
004C70r 3               nt_is:
004C70r 3  02 04                .byte 2, IM
004C72r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
004C76r 3  rr rr        
004C78r 3  69 73                .byte "is"
004C7Ar 3               
004C7Ar 3               nt_defer_store:
004C7Ar 3  06 00                .byte 6, 0
004C7Cr 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
004C80r 3  rr rr        
004C82r 3  64 65 66 65          .byte "defer!"
004C86r 3  72 21        
004C88r 3               
004C88r 3               nt_defer_fetch:
004C88r 3  06 00                .byte 6, 0
004C8Ar 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
004C8Er 3  rr rr        
004C90r 3  64 65 66 65          .byte "defer@"
004C94r 3  72 40        
004C96r 3               
004C96r 3               nt_endcase:
004C96r 3  07 0D                .byte 7, IM+CO+NN
004C98r 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
004C9Cr 3  rr rr        
004C9Er 3  65 6E 64 63          .byte "endcase"
004CA2r 3  61 73 65     
004CA5r 3               
004CA5r 3               nt_endof:
004CA5r 3  05 0D                .byte 5, IM+CO+NN
004CA7r 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
004CABr 3  rr rr        
004CADr 3  65 6E 64 6F          .byte "endof"
004CB1r 3  66           
004CB2r 3               
004CB2r 3               nt_of:
004CB2r 3  02 0D                .byte 2, IM+CO+NN
004CB4r 3  rr rr rr rr          .word nt_endof, xt_of, z_of
004CB8r 3  rr rr        
004CBAr 3  6F 66                .byte "of"
004CBCr 3               
004CBCr 3               nt_case:
004CBCr 3  04 0D                .byte 4, IM+CO+NN
004CBEr 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
004CC2r 3  rr rr        
004CC4r 3  63 61 73 65          .byte "case"
004CC8r 3               
004CC8r 3               nt_while:
004CC8r 3  05 0D                .byte 5, IM+CO+NN
004CCAr 3  rr rr rr rr          .word nt_case, xt_while, z_while
004CCEr 3  rr rr        
004CD0r 3  77 68 69 6C          .byte "while"
004CD4r 3  65           
004CD5r 3               
004CD5r 3               nt_until:
004CD5r 3  05 0D                .byte 5, IM+CO+NN
004CD7r 3  rr rr rr rr          .word nt_while, xt_until, z_until
004CDBr 3  rr rr        
004CDDr 3  75 6E 74 69          .byte "until"
004CE1r 3  6C           
004CE2r 3               
004CE2r 3               nt_repeat:
004CE2r 3  06 0D                .byte 6, IM+CO+NN
004CE4r 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
004CE8r 3  rr rr        
004CEAr 3  72 65 70 65          .byte "repeat"
004CEEr 3  61 74        
004CF0r 3               
004CF0r 3               nt_else:
004CF0r 3  04 0D                .byte 4, IM+CO+NN
004CF2r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
004CF6r 3  rr rr        
004CF8r 3  65 6C 73 65          .byte "else"
004CFCr 3               
004CFCr 3               nt_then:
004CFCr 3  04 0D                .byte 4, IM+CO+NN
004CFEr 3  rr rr rr rr          .word nt_else, xt_then, z_then
004D02r 3  rr rr        
004D04r 3  74 68 65 6E          .byte "then"
004D08r 3               
004D08r 3               nt_if:
004D08r 3  02 0D                .byte 2, IM+CO+NN
004D0Ar 3  rr rr rr rr          .word nt_then, xt_if, z_if
004D0Er 3  rr rr        
004D10r 3  69 66                .byte "if"
004D12r 3               
004D12r 3               nt_dot_paren:
004D12r 3  02 04                .byte 2, IM
004D14r 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
004D18r 3  rr rr        
004D1Ar 3  2E 28                .byte ".("
004D1Cr 3               
004D1Cr 3               nt_paren:
004D1Cr 3  01 04                .byte 1, IM
004D1Er 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
004D22r 3  rr rr        
004D24r 3  28                   .byte "("
004D25r 3               
004D25r 3               nt_word:
004D25r 3  04 10                .byte 4, UF
004D27r 3  rr rr rr rr          .word nt_paren, xt_word, z_word
004D2Br 3  rr rr        
004D2Dr 3  77 6F 72 64          .byte "word"
004D31r 3               
004D31r 3               nt_find:
004D31r 3  04 10                .byte 4, UF
004D33r 3  rr rr rr rr          .word nt_word, xt_find, z_find
004D37r 3  rr rr        
004D39r 3  66 69 6E 64          .byte "find"
004D3Dr 3               
004D3Dr 3               nt_environment_q:
004D3Dr 3  0C 10                .byte 12, UF
004D3Fr 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
004D43r 3  rr rr        
004D45r 3  65 6E 76 69          .byte "environment?"
004D49r 3  72 6F 6E 6D  
004D4Dr 3  65 6E 74 3F  
004D51r 3               
004D51r 3               nt_search:
004D51r 3  06 18                .byte 6, UF+NN
004D53r 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
004D57r 3  rr rr        
004D59r 3  73 65 61 72          .byte "search"
004D5Dr 3  63 68        
004D5Fr 3               
004D5Fr 3               nt_compare:
004D5Fr 3  07 10                .byte 7, UF
004D61r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
004D65r 3  rr rr        
004D67r 3  63 6F 6D 70          .byte "compare"
004D6Br 3  61 72 65     
004D6Er 3               
004D6Er 3               nt_disasm:
004D6Er 3  06 10                .byte 6, UF
004D70r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
004D74r 3  rr rr        
004D76r 3  64 69 73 61          .byte "disasm"
004D7Ar 3  73 6D        
004D7Cr 3               
004D7Cr 3               nt_dot_s:
004D7Cr 3  02 00                .byte 2, 0
004D7Er 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
004D82r 3  rr rr        
004D84r 3  2E 73                .byte ".s"
004D86r 3               
004D86r 3               nt_dump:
004D86r 3  04 10                .byte 4, UF
004D88r 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
004D8Cr 3  rr rr        
004D8Er 3  64 75 6D 70          .byte "dump"
004D92r 3               
004D92r 3               nt_bell:
004D92r 3  04 00                .byte 4, 0
004D94r 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
004D98r 3  rr rr        
004D9Ar 3  62 65 6C 6C          .byte "bell"
004D9Er 3               
004D9Er 3               nt_align:
004D9Er 3  05 00                .byte 5, 0
004DA0r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
004DA4r 3  rr rr        
004DA6r 3  61 6C 69 67          .byte "align"
004DAAr 3  6E           
004DABr 3               
004DABr 3               nt_aligned:             ; same code as ALIGN
004DABr 3  07 00                .byte 7, 0
004DADr 3  rr rr rr rr          .word nt_align, xt_align, z_align
004DB1r 3  rr rr        
004DB3r 3  61 6C 69 67          .byte "aligned"
004DB7r 3  6E 65 64     
004DBAr 3               
004DBAr 3               nt_wordsize:
004DBAr 3  08 10                .byte 8, UF
004DBCr 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
004DC0r 3  rr rr        
004DC2r 3  77 6F 72 64          .byte "wordsize"
004DC6r 3  73 69 7A 65  
004DCAr 3               
004DCAr 3               nt_words:
004DCAr 3  05 00                .byte 5, 0
004DCCr 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
004DD0r 3  rr rr        
004DD2r 3  77 6F 72 64          .byte "words"
004DD6r 3  73           
004DD7r 3               
004DD7r 3               nt_marker:
004DD7r 3  06 04                .byte 6, IM
004DD9r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
004DDDr 3  rr rr        
004DDFr 3  6D 61 72 6B          .byte "marker"
004DE3r 3  65 72        
004DE5r 3               
004DE5r 3               nt_at_xy:
004DE5r 3  05 10                .byte 5, UF
004DE7r 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
004DEBr 3  rr rr        
004DEDr 3  61 74 2D 78          .byte "at-xy"
004DF1r 3  79           
004DF2r 3               
004DF2r 3               nt_page:
004DF2r 3  04 00                .byte 4, 0
004DF4r 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
004DF8r 3  rr rr        
004DFAr 3  70 61 67 65          .byte "page"
004DFEr 3               
004DFEr 3               nt_cr:
004DFEr 3  02 00                .byte 2, 0
004E00r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
004E04r 3  rr rr        
004E06r 3  63 72                .byte "cr"
004E08r 3               
004E08r 3               nt_input:
004E08r 3  05 00                .byte 5, 0
004E0Ar 3  rr rr rr rr          .word nt_cr, xt_input, z_input
004E0Er 3  rr rr        
004E10r 3  69 6E 70 75          .byte "input"
004E14r 3  74           
004E15r 3               
004E15r 3               nt_output:
004E15r 3  06 00                .byte 6, 0
004E17r 3  rr rr rr rr          .word nt_input, xt_output, z_output
004E1Br 3  rr rr        
004E1Dr 3  6F 75 74 70          .byte "output"
004E21r 3  75 74        
004E23r 3               
004E23r 3               nt_sign:
004E23r 3  04 10                .byte 4, UF
004E25r 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
004E29r 3  rr rr        
004E2Br 3  73 69 67 6E          .byte "sign"
004E2Fr 3               
004E2Fr 3               nt_hold:
004E2Fr 3  04 10                .byte 4, UF
004E31r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
004E35r 3  rr rr        
004E37r 3  68 6F 6C 64          .byte "hold"
004E3Br 3               
004E3Br 3               nt_number_sign_greater:
004E3Br 3  02 10                .byte 2, UF
004E3Dr 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
004E41r 3  rr rr        
004E43r 3  23 3E                .byte "#>"
004E45r 3               
004E45r 3               nt_number_sign_s:
004E45r 3  02 10                .byte 2, UF
004E47r 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
004E4Br 3  rr rr        
004E4Dr 3  23 73                .byte "#s"
004E4Fr 3               
004E4Fr 3               nt_number_sign:
004E4Fr 3  01 10                .byte 1, UF
004E51r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
004E55r 3  rr rr        
004E57r 3  23                   .byte "#"
004E58r 3               
004E58r 3               nt_less_number_sign:
004E58r 3  02 00                .byte 2, 0
004E5Ar 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
004E5Er 3  rr rr        
004E60r 3  3C 23                .byte "<#"
004E62r 3               
004E62r 3               nt_to_in:
004E62r 3  03 00                .byte 3, 0
004E64r 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
004E68r 3  rr rr        
004E6Ar 3  3E 69 6E             .byte ">in"
004E6Dr 3               
004E6Dr 3               nt_within:
004E6Dr 3  06 10                .byte 6, UF
004E6Fr 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
004E73r 3  rr rr        
004E75r 3  77 69 74 68          .byte "within"
004E79r 3  69 6E        
004E7Br 3               
004E7Br 3               nt_hexstore:
004E7Br 3  08 10                .byte 8, UF
004E7Dr 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
004E81r 3  rr rr        
004E83r 3  68 65 78 73          .byte "hexstore"
004E87r 3  74 6F 72 65  
004E8Br 3               
004E8Br 3               nt_cleave:
004E8Br 3  06 10                .byte 6, UF
004E8Dr 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
004E91r 3  rr rr        
004E93r 3  63 6C 65 61          .byte "cleave"
004E97r 3  76 65        
004E99r 3               
004E99r 3               nt_pad:
004E99r 3  03 00                .byte 3, 0
004E9Br 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
004E9Fr 3  rr rr        
004EA1r 3  70 61 64             .byte "pad"
004EA4r 3               
004EA4r 3               nt_cmove:
004EA4r 3  05 10                .byte 5, UF
004EA6r 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
004EAAr 3  rr rr        
004EACr 3  63 6D 6F 76          .byte "cmove"
004EB0r 3  65           
004EB1r 3               
004EB1r 3               nt_cmove_up:
004EB1r 3  06 10                .byte 6, UF
004EB3r 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
004EB7r 3  rr rr        
004EB9r 3  63 6D 6F 76          .byte "cmove>"
004EBDr 3  65 3E        
004EBFr 3               
004EBFr 3               nt_move:
004EBFr 3  04 18                .byte 4, NN+UF
004EC1r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
004EC5r 3  rr rr        
004EC7r 3  6D 6F 76 65          .byte "move"
004ECBr 3               
004ECBr 3               nt_backslash:
004ECBr 3  01 04                .byte 1, IM
004ECDr 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
004ED1r 3  rr rr        
004ED3r 3  5C                   .byte $5c
004ED4r 3               
004ED4r 3               nt_star_slash:
004ED4r 3  02 10                .byte 2, UF
004ED6r 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
004EDAr 3  rr rr        
004EDCr 3  2A 2F                .byte "*/"
004EDEr 3               
004EDEr 3               nt_star_slash_mod:
004EDEr 3  05 10                .byte 5, UF
004EE0r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
004EE4r 3  rr rr        
004EE6r 3  2A 2F 6D 6F          .byte "*/mod"
004EEAr 3  64           
004EEBr 3               
004EEBr 3               nt_mod:
004EEBr 3  03 10                .byte 3, UF
004EEDr 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
004EF1r 3  rr rr        
004EF3r 3  6D 6F 64             .byte "mod"
004EF6r 3               
004EF6r 3               nt_slash_mod:
004EF6r 3  04 10                .byte 4, UF
004EF8r 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
004EFCr 3  rr rr        
004EFEr 3  2F 6D 6F 64          .byte "/mod"
004F02r 3               
004F02r 3               nt_slash:
004F02r 3  01 10                .byte 1, UF
004F04r 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
004F08r 3  rr rr        
004F0Ar 3  2F                   .byte "/"
004F0Br 3               
004F0Br 3               nt_fm_slash_mod:
004F0Br 3  06 10                .byte 6, UF
004F0Dr 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
004F11r 3  rr rr        
004F13r 3  66 6D 2F 6D          .byte "fm/mod"
004F17r 3  6F 64        
004F19r 3               
004F19r 3               nt_sm_slash_rem:
004F19r 3  06 10                .byte 6, UF
004F1Br 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
004F1Fr 3  rr rr        
004F21r 3  73 6D 2F 72          .byte "sm/rem"
004F25r 3  65 6D        
004F27r 3               
004F27r 3               nt_um_slash_mod:
004F27r 3  06 10                .byte 6, UF
004F29r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
004F2Dr 3  rr rr        
004F2Fr 3  75 6D 2F 6D          .byte "um/mod"
004F33r 3  6F 64        
004F35r 3               
004F35r 3               nt_star:
004F35r 3  01 10                .byte 1, UF
004F37r 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
004F3Br 3  rr rr        
004F3Dr 3  2A                   .byte "*"
004F3Er 3               
004F3Er 3               nt_um_star:
004F3Er 3  03 10                .byte 3, UF
004F40r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
004F44r 3  rr rr        
004F46r 3  75 6D 2A             .byte "um*"
004F49r 3               
004F49r 3               nt_m_star:
004F49r 3  02 10                .byte 2, UF
004F4Br 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
004F4Fr 3  rr rr        
004F51r 3  6D 2A                .byte "m*"
004F53r 3               
004F53r 3               nt_count:
004F53r 3  05 10                .byte 5, UF
004F55r 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
004F59r 3  rr rr        
004F5Br 3  63 6F 75 6E          .byte "count"
004F5Fr 3  74           
004F60r 3               
004F60r 3               nt_decimal:
004F60r 3  07 00                .byte 7, 0
004F62r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
004F66r 3  rr rr        
004F68r 3  64 65 63 69          .byte "decimal"
004F6Cr 3  6D 61 6C     
004F6Fr 3               
004F6Fr 3               nt_hex:
004F6Fr 3  03 00                .byte 3, 0
004F71r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
004F75r 3  rr rr        
004F77r 3  68 65 78             .byte "hex"
004F7Ar 3               
004F7Ar 3               nt_to_number:
004F7Ar 3  07 10                .byte 7, UF
004F7Cr 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
004F80r 3  rr rr        
004F82r 3  3E 6E 75 6D          .byte ">number"
004F86r 3  62 65 72     
004F89r 3               
004F89r 3               nt_number:
004F89r 3  06 10                .byte 6, UF
004F8Br 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
004F8Fr 3  rr rr        
004F91r 3  6E 75 6D 62          .byte "number"
004F95r 3  65 72        
004F97r 3               
004F97r 3               nt_digit_question:
004F97r 3  06 10                .byte 6, UF
004F99r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
004F9Dr 3  rr rr        
004F9Fr 3  64 69 67 69          .byte "digit?"
004FA3r 3  74 3F        
004FA5r 3               
004FA5r 3               nt_base:
004FA5r 3  04 00                .byte 4, 0
004FA7r 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
004FABr 3  rr rr        
004FADr 3  62 61 73 65          .byte "base"
004FB1r 3               
004FB1r 3               nt_evaluate:
004FB1r 3  08 10                .byte 8, UF
004FB3r 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
004FB7r 3  rr rr        
004FB9r 3  65 76 61 6C          .byte "evaluate"
004FBDr 3  75 61 74 65  
004FC1r 3               
004FC1r 3               nt_state:
004FC1r 3  05 00                .byte 5, 0
004FC3r 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
004FC7r 3  rr rr        
004FC9r 3  73 74 61 74          .byte "state"
004FCDr 3  65           
004FCEr 3               
004FCEr 3               nt_again:
004FCEr 3  05 17                .byte 5, AN+CO+IM+UF
004FD0r 3  rr rr rr rr          .word nt_state, xt_again, z_again
004FD4r 3  rr rr        
004FD6r 3  61 67 61 69          .byte "again"
004FDAr 3  6E           
004FDBr 3               
004FDBr 3               nt_begin:
004FDBr 3  05 07                .byte 5, AN+CO+IM
004FDDr 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
004FE1r 3  rr rr        
004FE3r 3  62 65 67 69          .byte "begin"
004FE7r 3  6E           
004FE8r 3               
004FE8r 3               nt_quit:
004FE8r 3  04 00                .byte 4, 0
004FEAr 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
004FEEr 3  rr rr        
004FF0r 3  71 75 69 74          .byte "quit"
004FF4r 3               
004FF4r 3               nt_recurse:
004FF4r 3  07 0D                .byte 7, CO+IM+NN
004FF6r 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
004FFAr 3  rr rr        
004FFCr 3  72 65 63 75          .byte "recurse"
005000r 3  72 73 65     
005003r 3               
005003r 3               nt_leave:
005003r 3  05 03                .byte 5, AN+CO
005005r 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
005009r 3  rr rr        
00500Br 3  6C 65 61 76          .byte "leave"
00500Fr 3  65           
005010r 3               
005010r 3               nt_unloop:
005010r 3  06 03                .byte 6, AN+CO
005012r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
005016r 3  rr rr        
005018r 3  75 6E 6C 6F          .byte "unloop"
00501Cr 3  6F 70        
00501Er 3               
00501Er 3               nt_exit:
00501Er 3  04 03                .byte 4, AN+CO
005020r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
005024r 3  rr rr        
005026r 3  65 78 69 74          .byte "exit"
00502Ar 3               
00502Ar 3               nt_plus_loop:
00502Ar 3  05 05                .byte 5, CO+IM
00502Cr 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
005030r 3  rr rr        
005032r 3  2B 6C 6F 6F          .byte "+loop"
005036r 3  70           
005037r 3               
005037r 3               nt_loop:
005037r 3  04 05                .byte 4, CO+IM
005039r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
00503Dr 3  rr rr        
00503Fr 3  6C 6F 6F 70          .byte "loop"
005043r 3               
005043r 3               nt_j:
005043r 3  01 03                .byte 1, AN+CO
005045r 3  rr rr rr rr          .word nt_loop, xt_j, z_j
005049r 3  rr rr        
00504Br 3  6A                   .byte "j"
00504Cr 3               
00504Cr 3               nt_i:
00504Cr 3  01 03                .byte 1, AN+CO
00504Er 3  rr rr rr rr          .word nt_j, xt_i, z_i
005052r 3  rr rr        
005054r 3  69                   .byte "i"
005055r 3               
005055r 3               nt_question_do:
005055r 3  03 0D                .byte 3, CO+IM+NN
005057r 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
00505Br 3  rr rr        
00505Dr 3  3F 64 6F             .byte "?do"
005060r 3               
005060r 3               nt_do:
005060r 3  02 0D                .byte 2, CO+IM+NN
005062r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
005066r 3  rr rr        
005068r 3  64 6F                .byte "do"
00506Ar 3               
00506Ar 3               nt_abort_quote:
00506Ar 3  06 0D                .byte 6, CO+IM+NN
00506Cr 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
005070r 3  rr rr        
005072r 3  61 62 6F 72          .byte "abort", $22
005076r 3  74 22        
005078r 3               
005078r 3               nt_abort:
005078r 3  05 00                .byte 5, 0
00507Ar 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
00507Er 3  rr rr        
005080r 3  61 62 6F 72          .byte "abort"
005084r 3  74           
005085r 3               
005085r 3               nt_strip_underflow:
005085r 3  0F 00                .byte 15, 0
005087r 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
00508Br 3  rr rr        
00508Dr 3  73 74 72 69          .byte "strip-underflow"
005091r 3  70 2D 75 6E  
005095r 3  64 65 72 66  
00509Cr 3               
00509Cr 3               nt_nc_limit:
00509Cr 3  08 00                .byte 8, 0
00509Er 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
0050A2r 3  rr rr        
0050A4r 3  6E 63 2D 6C          .byte "nc-limit"
0050A8r 3  69 6D 69 74  
0050ACr 3               
0050ACr 3               nt_allow_native:
0050ACr 3  0C 00                .byte 12, 0
0050AEr 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
0050B2r 3  rr rr        
0050B4r 3  61 6C 6C 6F          .byte "allow-native"
0050B8r 3  77 2D 6E 61  
0050BCr 3  74 69 76 65  
0050C0r 3               
0050C0r 3               nt_always_native:
0050C0r 3  0D 00                .byte 13, 0
0050C2r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
0050C6r 3  rr rr        
0050C8r 3  61 6C 77 61          .byte "always-native"
0050CCr 3  79 73 2D 6E  
0050D0r 3  61 74 69 76  
0050D5r 3               
0050D5r 3               nt_never_native:
0050D5r 3  0C 00                .byte 12, 0
0050D7r 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
0050DBr 3  rr rr        
0050DDr 3  6E 65 76 65          .byte "never-native"
0050E1r 3  72 2D 6E 61  
0050E5r 3  74 69 76 65  
0050E9r 3               
0050E9r 3               nt_compile_only:
0050E9r 3  0C 00                .byte 12, 0
0050EBr 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
0050EFr 3  rr rr        
0050F1r 3  63 6F 6D 70          .byte "compile-only"
0050F5r 3  69 6C 65 2D  
0050F9r 3  6F 6E 6C 79  
0050FDr 3               
0050FDr 3               nt_immediate:
0050FDr 3  09 00                .byte 9, 0
0050FFr 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
005103r 3  rr rr        
005105r 3  69 6D 6D 65          .byte "immediate"
005109r 3  64 69 61 74  
00510Dr 3  65           
00510Er 3               
00510Er 3               nt_postpone:
00510Er 3  08 05                .byte 8, IM+CO
005110r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
005114r 3  rr rr        
005116r 3  70 6F 73 74          .byte "postpone"
00511Ar 3  70 6F 6E 65  
00511Er 3               
00511Er 3               nt_s_backslash_quote:
00511Er 3  03 04                .byte 3, IM
005120r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
005124r 3  rr rr        
005126r 3  73 5C 22             .byte "s", $5C, $22
005129r 3               
005129r 3               nt_s_quote:
005129r 3  02 0C                .byte 2, IM+NN
00512Br 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
00512Fr 3  rr rr        
005131r 3  73 22                .byte "s", $22
005133r 3               
005133r 3               nt_dot_quote:
005133r 3  02 05                .byte 2, CO+IM
005135r 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
005139r 3  rr rr        
00513Br 3  2E 22                .byte ".", $22
00513Dr 3               
00513Dr 3               nt_sliteral:
00513Dr 3  08 15                .byte 8, CO+IM+UF
00513Fr 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
005143r 3  rr rr        
005145r 3  73 6C 69 74          .byte "sliteral"
005149r 3  65 72 61 6C  
00514Dr 3               
00514Dr 3               nt_literal:
00514Dr 3  07 15                .byte 7, IM+CO+UF
00514Fr 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
005153r 3  rr rr        
005155r 3  6C 69 74 65          .byte "literal"
005159r 3  72 61 6C     
00515Cr 3               
00515Cr 3               nt_right_bracket:
00515Cr 3  01 04                .byte 1, IM
00515Er 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
005162r 3  rr rr        
005164r 3  5D                   .byte "]"
005165r 3               
005165r 3               nt_left_bracket:
005165r 3  01 05                .byte 1, IM+CO
005167r 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
00516Br 3  rr rr        
00516Dr 3  5B                   .byte "["
00516Er 3               
00516Er 3               nt_compile_comma:
00516Er 3  08 18                .byte 8, UF+NN
005170r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
005174r 3  rr rr        
005176r 3  63 6F 6D 70          .byte "compile,"
00517Ar 3  69 6C 65 2C  
00517Er 3               
00517Er 3               nt_colon_noname:
00517Er 3  07 00                .byte 7, 0
005180r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
005184r 3  rr rr        
005186r 3  3A 6E 6F 6E          .byte ":noname"
00518Ar 3  61 6D 65     
00518Dr 3               
00518Dr 3               nt_semicolon:
00518Dr 3  01 05                .byte 1, CO+IM
00518Fr 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
005193r 3  rr rr        
005195r 3  3B                   .byte ";"
005196r 3               
005196r 3               nt_colon:
005196r 3  01 00                .byte 1, 0
005198r 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
00519Cr 3  rr rr        
00519Er 3  3A                   .byte ":"
00519Fr 3               
00519Fr 3               nt_source_id:
00519Fr 3  09 00                .byte 9, 0
0051A1r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
0051A5r 3  rr rr        
0051A7r 3  73 6F 75 72          .byte "source-id"
0051ABr 3  63 65 2D 69  
0051AFr 3  64           
0051B0r 3               
0051B0r 3               nt_source:
0051B0r 3  06 00                .byte 6, 0
0051B2r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
0051B6r 3  rr rr        
0051B8r 3  73 6F 75 72          .byte "source"
0051BCr 3  63 65        
0051BEr 3               
0051BEr 3               nt_execute_parsing:
0051BEr 3  0F 10                .byte 15, UF
0051C0r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
0051C4r 3  rr rr        
0051C6r 3  65 78 65 63          .byte "execute-parsing"
0051CAr 3  75 74 65 2D  
0051CEr 3  70 61 72 73  
0051D5r 3               
0051D5r 3               nt_parse:
0051D5r 3  05 10                .byte 5, UF
0051D7r 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
0051DBr 3  rr rr        
0051DDr 3  70 61 72 73          .byte "parse"
0051E1r 3  65           
0051E2r 3               
0051E2r 3               nt_parse_name:
0051E2r 3  0A 08                .byte 10, NN
0051E4r 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
0051E8r 3  rr rr        
0051EAr 3  70 61 72 73          .byte "parse-name"
0051EEr 3  65 2D 6E 61  
0051F2r 3  6D 65        
0051F4r 3               
0051F4r 3               nt_latestnt:
0051F4r 3  08 00                .byte 8, 0
0051F6r 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
0051FAr 3  rr rr        
0051FCr 3  6C 61 74 65          .byte "latestnt"
005200r 3  73 74 6E 74  
005204r 3               
005204r 3               nt_latestxt:
005204r 3  08 00                .byte 8, 0
005206r 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
00520Ar 3  rr rr        
00520Cr 3  6C 61 74 65          .byte "latestxt"
005210r 3  73 74 78 74  
005214r 3               
005214r 3               nt_defer:
005214r 3  05 00                .byte 5, 0
005216r 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
00521Ar 3  rr rr        
00521Cr 3  64 65 66 65          .byte "defer"
005220r 3  72           
005221r 3               
005221r 3               nt_to_body:
005221r 3  05 10                .byte 5, UF
005223r 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
005227r 3  rr rr        
005229r 3  3E 62 6F 64          .byte ">body"
00522Dr 3  79           
00522Er 3               
00522Er 3               nt_name_to_string:
00522Er 3  0B 10                .byte 11, UF
005230r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
005234r 3  rr rr        
005236r 3  6E 61 6D 65          .byte "name>string"
00523Ar 3  3E 73 74 72  
00523Er 3  69 6E 67     
005241r 3               
005241r 3               nt_int_to_name:
005241r 3  08 10                .byte 8, UF
005243r 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
005247r 3  rr rr        
005249r 3  69 6E 74 3E          .byte "int>name"
00524Dr 3  6E 61 6D 65  
005251r 3               
005251r 3               nt_name_to_int:
005251r 3  08 10                .byte 8, UF
005253r 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
005257r 3  rr rr        
005259r 3  6E 61 6D 65          .byte "name>int"
00525Dr 3  3E 69 6E 74  
005261r 3               
005261r 3               nt_bracket_tick:
005261r 3  03 05                .byte 3, CO+IM
005263r 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
005267r 3  rr rr        
005269r 3  5B 27 5D             .byte "[']"
00526Cr 3               
00526Cr 3               nt_tick:
00526Cr 3  01 00                .byte 1, 0
00526Er 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
005272r 3  rr rr        
005274r 3  27                   .byte "'"
005275r 3               
005275r 3               nt_find_name:
005275r 3  09 10                .byte 9, UF
005277r 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
00527Br 3  rr rr        
00527Dr 3  66 69 6E 64          .byte "find-name"
005281r 3  2D 6E 61 6D  
005285r 3  65           
005286r 3               
005286r 3               nt_fill:
005286r 3  04 10                .byte 4, UF
005288r 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
00528Cr 3  rr rr        
00528Er 3  66 69 6C 6C          .byte "fill"
005292r 3               
005292r 3               nt_blank:
005292r 3  05 00                .byte 5, 0     ; underflow checked by FILL
005294r 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
005298r 3  rr rr        
00529Ar 3  62 6C 61 6E          .byte "blank"
00529Er 3  6B           
00529Fr 3               
00529Fr 3               nt_erase:
00529Fr 3  05 00                .byte 5, 0      ; underflow checked by FILL
0052A1r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
0052A5r 3  rr rr        
0052A7r 3  65 72 61 73          .byte "erase"
0052ABr 3  65           
0052ACr 3               
0052ACr 3               nt_d_plus:
0052ACr 3  02 10                .byte 2, UF
0052AEr 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
0052B2r 3  rr rr        
0052B4r 3  64 2B                .byte "d+"
0052B6r 3               
0052B6r 3               nt_d_minus:
0052B6r 3  02 10                .byte 2, UF
0052B8r 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
0052BCr 3  rr rr        
0052BEr 3  64 2D                .byte "d-"
0052C0r 3               
0052C0r 3               nt_d_to_s:
0052C0r 3  03 10                .byte 3, UF
0052C2r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
0052C6r 3  rr rr        
0052C8r 3  64 3E 73             .byte "d>s"
0052CBr 3               
0052CBr 3               nt_s_to_d:
0052CBr 3  03 10                .byte 3, UF
0052CDr 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
0052D1r 3  rr rr        
0052D3r 3  73 3E 64             .byte "s>d"
0052D6r 3               
0052D6r 3               nt_to:
0052D6r 3  02 0C                .byte 2, NN+IM
0052D8r 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
0052DCr 3  rr rr        
0052DEr 3  74 6F                .byte "to"
0052E0r 3               
0052E0r 3               nt_value:               ; same code as CONSTANT
0052E0r 3  05 10                .byte 5, UF
0052E2r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
0052E6r 3  rr rr        
0052E8r 3  76 61 6C 75          .byte "value"
0052ECr 3  65           
0052EDr 3               
0052EDr 3               nt_constant:
0052EDr 3  08 10                .byte 8, UF
0052EFr 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
0052F3r 3  rr rr        
0052F5r 3  63 6F 6E 73          .byte "constant"
0052F9r 3  74 61 6E 74  
0052FDr 3               
0052FDr 3               nt_variable:
0052FDr 3  08 00                .byte 8, 0
0052FFr 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
005303r 3  rr rr        
005305r 3  76 61 72 69          .byte "variable"
005309r 3  61 62 6C 65  
00530Dr 3               
00530Dr 3               nt_does:
00530Dr 3  05 05                .byte 5, CO+IM
00530Fr 3  rr rr rr rr          .word nt_variable, xt_does, z_does
005313r 3  rr rr        
005315r 3  64 6F 65 73          .byte "does>"
005319r 3  3E           
00531Ar 3               
00531Ar 3               nt_create:
00531Ar 3  06 00                .byte 6, 0
00531Cr 3  rr rr rr rr          .word nt_does, xt_create, z_create
005320r 3  rr rr        
005322r 3  63 72 65 61          .byte "create"
005326r 3  74 65        
005328r 3               
005328r 3               nt_allot:
005328r 3  05 10                .byte 5, UF
00532Ar 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
00532Er 3  rr rr        
005330r 3  61 6C 6C 6F          .byte "allot"
005334r 3  74           
005335r 3               
005335r 3               nt_key:
005335r 3  03 00                .byte 3, 0
005337r 3  rr rr rr rr          .word nt_allot, xt_key, z_key
00533Br 3  rr rr        
00533Dr 3  6B 65 79             .byte "key"
005340r 3               
005340r 3               nt_depth:
005340r 3  05 00                .byte 5, 0
005342r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
005346r 3  rr rr        
005348r 3  64 65 70 74          .byte "depth"
00534Cr 3  68           
00534Dr 3               
00534Dr 3               nt_unused:
00534Dr 3  06 00                .byte 6, 0
00534Fr 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
005353r 3  rr rr        
005355r 3  75 6E 75 73          .byte "unused"
005359r 3  65 64        
00535Br 3               
00535Br 3               nt_r_to_input:
00535Br 3  07 08                .byte 7, NN
00535Dr 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
005361r 3  rr rr        
005363r 3  72 3E 69 6E          .byte "r>input"
005367r 3  70 75 74     
00536Ar 3               
00536Ar 3               nt_input_to_r:
00536Ar 3  07 08                .byte 7, NN
00536Cr 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
005370r 3  rr rr        
005372r 3  69 6E 70 75          .byte "input>r"
005376r 3  74 3E 72     
005379r 3               
005379r 3               nt_accept:
005379r 3  06 18                .byte 6, UF+NN
00537Br 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
00537Fr 3  rr rr        
005381r 3  61 63 63 65          .byte "accept"
005385r 3  70 74        
005387r 3               
005387r 3               nt_refill:
005387r 3  06 00                .byte 6, 0
005389r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
00538Dr 3  rr rr        
00538Fr 3  72 65 66 69          .byte "refill"
005393r 3  6C 6C        
005395r 3               
005395r 3               nt_slash_string:
005395r 3  07 10                .byte 7, UF
005397r 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
00539Br 3  rr rr        
00539Dr 3  2F 73 74 72          .byte "/string"
0053A1r 3  69 6E 67     
0053A4r 3               
0053A4r 3               nt_minus_leading:
0053A4r 3  08 10                .byte 8, UF
0053A6r 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
0053AAr 3  rr rr        
0053ACr 3  2D 6C 65 61          .byte "-leading"
0053B0r 3  64 69 6E 67  
0053B4r 3               
0053B4r 3               nt_minus_trailing:
0053B4r 3  09 10                .byte 9, UF
0053B6r 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
0053BAr 3  rr rr        
0053BCr 3  2D 74 72 61          .byte "-trailing"
0053C0r 3  69 6C 69 6E  
0053C4r 3  67           
0053C5r 3               
0053C5r 3               nt_bl:
0053C5r 3  02 00                .byte 2, 0
0053C7r 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
0053CBr 3  rr rr        
0053CDr 3  62 6C                .byte "bl"
0053CFr 3               
0053CFr 3               nt_spaces:
0053CFr 3  06 10                .byte 6, UF
0053D1r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
0053D5r 3  rr rr        
0053D7r 3  73 70 61 63          .byte "spaces"
0053DBr 3  65 73        
0053DDr 3               
0053DDr 3               nt_bounds:
0053DDr 3  06 10                .byte 6, UF
0053DFr 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
0053E3r 3  rr rr        
0053E5r 3  62 6F 75 6E          .byte "bounds"
0053E9r 3  64 73        
0053EBr 3               
0053EBr 3               nt_c_comma:
0053EBr 3  02 10                .byte 2, UF
0053EDr 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
0053F1r 3  rr rr        
0053F3r 3  63 2C                .byte "c,"
0053F5r 3               
0053F5r 3               nt_dnegate:
0053F5r 3  07 10                .byte 7, UF
0053F7r 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
0053FBr 3  rr rr        
0053FDr 3  64 6E 65 67          .byte "dnegate"
005401r 3  61 74 65     
005404r 3               
005404r 3               nt_negate:
005404r 3  06 10                .byte 6, UF
005406r 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
00540Ar 3  rr rr        
00540Cr 3  6E 65 67 61          .byte "negate"
005410r 3  74 65        
005412r 3               
005412r 3               nt_invert:
005412r 3  06 10                .byte 6, UF
005414r 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
005418r 3  rr rr        
00541Ar 3  69 6E 76 65          .byte "invert"
00541Er 3  72 74        
005420r 3               
005420r 3               nt_two_to_r:
005420r 3  03 11                .byte 3, CO+UF          ; native is special case
005422r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
005426r 3  rr rr        
005428r 3  32 3E 72             .byte "2>r"
00542Br 3               
00542Br 3               nt_two_r_from:
00542Br 3  03 01                .byte 3, CO             ; native is special case
00542Dr 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
005431r 3  rr rr        
005433r 3  32 72 3E             .byte "2r>"
005436r 3               
005436r 3               nt_two_r_fetch:
005436r 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
005438r 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
00543Cr 3  rr rr        
00543Er 3  32 72 40             .byte "2r@"
005441r 3               
005441r 3               nt_two_literal:
005441r 3  08 14                .byte 8, UF+IM
005443r 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
005447r 3  rr rr        
005449r 3  32 6C 69 74          .byte "2literal"
00544Dr 3  65 72 61 6C  
005451r 3               
005451r 3               nt_two_constant:
005451r 3  09 10                .byte 9, UF
005453r 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
005457r 3  rr rr        
005459r 3  32 63 6F 6E          .byte "2constant"
00545Dr 3  73 74 61 6E  
005461r 3  74           
005462r 3               
005462r 3               nt_two_variable:
005462r 3  09 00                .byte 9, 0
005464r 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
005468r 3  rr rr        
00546Ar 3  32 76 61 72          .byte "2variable"
00546Er 3  69 61 62 6C  
005472r 3  65           
005473r 3               
005473r 3               nt_two_fetch:
005473r 3  02 10                .byte 2, UF
005475r 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
005479r 3  rr rr        
00547Br 3  32 40                .byte "2@"
00547Dr 3               
00547Dr 3               nt_two_store:
00547Dr 3  02 10                .byte 2, UF
00547Fr 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
005483r 3  rr rr        
005485r 3  32 21                .byte "2!"
005487r 3               
005487r 3               nt_two_over:
005487r 3  05 10                .byte 5, UF
005489r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
00548Dr 3  rr rr        
00548Fr 3  32 6F 76 65          .byte "2over"
005493r 3  72           
005494r 3               
005494r 3               nt_two_swap:
005494r 3  05 10                .byte 5, UF
005496r 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
00549Ar 3  rr rr        
00549Cr 3  32 73 77 61          .byte "2swap"
0054A0r 3  70           
0054A1r 3               
0054A1r 3               nt_two_drop:
0054A1r 3  05 10                .byte 5, UF
0054A3r 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
0054A7r 3  rr rr        
0054A9r 3  32 64 72 6F          .byte "2drop"
0054ADr 3  70           
0054AEr 3               
0054AEr 3               nt_max:
0054AEr 3  03 10                .byte 3, UF
0054B0r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
0054B4r 3  rr rr        
0054B6r 3  6D 61 78             .byte "max"
0054B9r 3               
0054B9r 3               nt_min:
0054B9r 3  03 10                .byte 3, UF
0054BBr 3  rr rr rr rr          .word nt_max, xt_min, z_min
0054BFr 3  rr rr        
0054C1r 3  6D 69 6E             .byte "min"
0054C4r 3               
0054C4r 3               nt_zero_less:
0054C4r 3  02 10                .byte 2, UF
0054C6r 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
0054CAr 3  rr rr        
0054CCr 3  30 3C                .byte "0<"
0054CEr 3               
0054CEr 3               nt_zero_greater:
0054CEr 3  02 10                .byte 2, UF
0054D0r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
0054D4r 3  rr rr        
0054D6r 3  30 3E                .byte "0>"
0054D8r 3               
0054D8r 3               nt_zero_unequal:
0054D8r 3  03 10                .byte 3, UF
0054DAr 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
0054DEr 3  rr rr        
0054E0r 3  30 3C 3E             .byte "0<>"
0054E3r 3               
0054E3r 3               nt_zero_equal:
0054E3r 3  02 10                .byte 2, UF
0054E5r 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
0054E9r 3  rr rr        
0054EBr 3  30 3D                .byte "0="
0054EDr 3               
0054EDr 3               nt_greater_than:
0054EDr 3  01 10                .byte 1, UF
0054EFr 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
0054F3r 3  rr rr        
0054F5r 3  3E                   .byte ">"
0054F6r 3               
0054F6r 3               nt_u_greater_than:
0054F6r 3  02 10                .byte 2, UF
0054F8r 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
0054FCr 3  rr rr        
0054FEr 3  75 3E                .byte "u>"
005500r 3               
005500r 3               nt_u_less_than:
005500r 3  02 10                .byte 2, UF
005502r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
005506r 3  rr rr        
005508r 3  75 3C                .byte "u<"
00550Ar 3               
00550Ar 3               nt_less_than:
00550Ar 3  01 10                .byte 1, UF
00550Cr 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
005510r 3  rr rr        
005512r 3  3C                   .byte "<"
005513r 3               
005513r 3               nt_not_equals:
005513r 3  02 10                .byte 2, UF
005515r 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
005519r 3  rr rr        
00551Br 3  3C 3E                .byte "<>"
00551Dr 3               
00551Dr 3               nt_equal:
00551Dr 3  01 10                .byte 1, UF
00551Fr 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
005523r 3  rr rr        
005525r 3  3D                   .byte "="
005526r 3               
005526r 3               nt_two_slash:
005526r 3  02 10                .byte 2, UF
005528r 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
00552Cr 3  rr rr        
00552Er 3  32 2F                .byte "2/"
005530r 3               
005530r 3               nt_two_star:
005530r 3  02 10                .byte 2, UF
005532r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
005536r 3  rr rr        
005538r 3  32 2A                .byte "2*"
00553Ar 3               
00553Ar 3               nt_one_plus:
00553Ar 3  02 10                .byte 2, UF
00553Cr 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
005540r 3  rr rr        
005542r 3  31 2B                .byte "1+"
005544r 3               
005544r 3               nt_one_minus:
005544r 3  02 10                .byte 2, UF
005546r 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
00554Ar 3  rr rr        
00554Cr 3  31 2D                .byte "1-"
00554Er 3               
00554Er 3               nt_here:
00554Er 3  04 00                .byte 4, 0
005550r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
005554r 3  rr rr        
005556r 3  68 65 72 65          .byte "here"
00555Ar 3               
00555Ar 3               nt_cell_plus:
00555Ar 3  05 10                .byte 5, UF
00555Cr 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
005560r 3  rr rr        
005562r 3  63 65 6C 6C          .byte "cell+"
005566r 3  2B           
005567r 3               
005567r 3               nt_cells:
005567r 3  05 00                .byte 5, 0
005569r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
00556Dr 3  rr rr        
00556Fr 3  63 65 6C 6C          .byte "cells"
005573r 3  73           
005574r 3               
005574r 3               nt_chars:
005574r 3  05 12                .byte 5, AN+UF   ; deleted during compile
005576r 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
00557Ar 3  rr rr        
00557Cr 3  63 68 61 72          .byte "chars"
005580r 3  73           
005581r 3               
005581r 3               nt_char_plus:
005581r 3  05 00                .byte 5, 0
005583r 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
005587r 3  rr rr        
005589r 3  63 68 61 72          .byte "char+"
00558Dr 3  2B           
00558Er 3               
00558Er 3               nt_bracket_char:
00558Er 3  06 05                .byte 6, CO+IM
005590r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
005594r 3  rr rr        
005596r 3  5B 63 68 61          .byte "[char]"
00559Ar 3  72 5D        
00559Cr 3               
00559Cr 3               nt_char:
00559Cr 3  04 00                .byte 4, 0
00559Er 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
0055A2r 3  rr rr        
0055A4r 3  63 68 61 72          .byte "char"
0055A8r 3               
0055A8r 3               nt_pick:
0055A8r 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
0055AAr 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
0055AEr 3  rr rr        
0055B0r 3  70 69 63 6B          .byte "pick"
0055B4r 3               
0055B4r 3               nt_lshift:
0055B4r 3  06 10                .byte 6, UF
0055B6r 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
0055BAr 3  rr rr        
0055BCr 3  6C 73 68 69          .byte "lshift"
0055C0r 3  66 74        
0055C2r 3               
0055C2r 3               nt_rshift:
0055C2r 3  06 10                .byte 6, UF
0055C4r 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
0055C8r 3  rr rr        
0055CAr 3  72 73 68 69          .byte "rshift"
0055CEr 3  66 74        
0055D0r 3               
0055D0r 3               nt_xor:
0055D0r 3  03 10                .byte 3, UF
0055D2r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
0055D6r 3  rr rr        
0055D8r 3  78 6F 72             .byte "xor"
0055DBr 3               
0055DBr 3               nt_or:
0055DBr 3  02 10                .byte 2, UF
0055DDr 3  rr rr rr rr          .word nt_xor, xt_or, z_or
0055E1r 3  rr rr        
0055E3r 3  6F 72                .byte "or"
0055E5r 3               
0055E5r 3               nt_and:
0055E5r 3  03 10                .byte 3, UF
0055E7r 3  rr rr rr rr          .word nt_or, xt_and, z_and
0055EBr 3  rr rr        
0055EDr 3  61 6E 64             .byte "and"
0055F0r 3               
0055F0r 3               nt_dabs:
0055F0r 3  04 10                .byte 4, UF
0055F2r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
0055F6r 3  rr rr        
0055F8r 3  64 61 62 73          .byte "dabs"
0055FCr 3               
0055FCr 3               nt_abs:
0055FCr 3  03 10                .byte 3, UF
0055FEr 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
005602r 3  rr rr        
005604r 3  61 62 73             .byte "abs"
005607r 3               
005607r 3               nt_minus:
005607r 3  01 10                .byte 1, UF
005609r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
00560Dr 3  rr rr        
00560Fr 3  2D                   .byte "-"
005610r 3               
005610r 3               nt_plus:
005610r 3  01 10                .byte 1, UF
005612r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
005616r 3  rr rr        
005618r 3  2B                   .byte "+"
005619r 3               
005619r 3               nt_question_dup:
005619r 3  04 10                .byte 4, UF
00561Br 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
00561Fr 3  rr rr        
005621r 3  3F 64 75 70          .byte "?dup"
005625r 3               
005625r 3               nt_two_dup:
005625r 3  04 10                .byte 4, UF
005627r 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
00562Br 3  rr rr        
00562Dr 3  32 64 75 70          .byte "2dup"
005631r 3               
005631r 3               nt_two:
005631r 3  01 00                .byte 1, 0
005633r 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
005637r 3  rr rr        
005639r 3  32                   .byte "2"
00563Ar 3               
00563Ar 3               nt_one:
00563Ar 3  01 00                .byte 1, 0
00563Cr 3  rr rr rr rr          .word nt_two, xt_one, z_one
005640r 3  rr rr        
005642r 3  31                   .byte "1"
005643r 3               
005643r 3               nt_zero:
005643r 3  01 00                .byte 1, 0
005645r 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
005649r 3  rr rr        
00564Br 3  30                   .byte "0"
00564Cr 3               
00564Cr 3               nt_space:
00564Cr 3  05 00                .byte 5, 0
00564Er 3  rr rr rr rr          .word nt_zero, xt_space, z_space
005652r 3  rr rr        
005654r 3  73 70 61 63          .byte "space"
005658r 3  65           
005659r 3               
005659r 3               nt_true:
005659r 3  04 00                .byte 4, 0
00565Br 3  rr rr rr rr          .word nt_space, xt_true, z_true
00565Fr 3  rr rr        
005661r 3  74 72 75 65          .byte "true"
005665r 3               
005665r 3               nt_false:
005665r 3  05 00                .byte 5, 0
005667r 3  rr rr rr rr          .word nt_true, xt_false, z_false
00566Br 3  rr rr        
00566Dr 3  66 61 6C 73          .byte "false"
005671r 3  65           
005672r 3               
005672r 3               nt_question:
005672r 3  01 00                .byte 1, 0
005674r 3  rr rr rr rr          .word nt_false, xt_question, z_question
005678r 3  rr rr        
00567Ar 3  3F                   .byte "?"
00567Br 3               
00567Br 3               nt_ud_dot_r:
00567Br 3  04 10                .byte 4, UF
00567Dr 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
005681r 3  rr rr        
005683r 3  75 64 2E 72          .byte "ud.r"
005687r 3               
005687r 3               nt_ud_dot:
005687r 3  03 10                .byte 3, UF
005689r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
00568Dr 3  rr rr        
00568Fr 3  75 64 2E             .byte "ud."
005692r 3               
005692r 3               nt_d_dot_r:
005692r 3  03 10                .byte 3, UF
005694r 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
005698r 3  rr rr        
00569Ar 3  64 2E 72             .byte "d.r"
00569Dr 3               
00569Dr 3               nt_d_dot:
00569Dr 3  02 10                .byte 2, UF
00569Fr 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
0056A3r 3  rr rr        
0056A5r 3  64 2E                .byte "d."
0056A7r 3               
0056A7r 3               nt_dot_r:
0056A7r 3  02 10                .byte 2, UF
0056A9r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
0056ADr 3  rr rr        
0056AFr 3  2E 72                .byte ".r"
0056B1r 3               
0056B1r 3               nt_u_dot_r:
0056B1r 3  03 10                .byte 3, UF
0056B3r 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
0056B7r 3  rr rr        
0056B9r 3  75 2E 72             .byte "u.r"
0056BCr 3               
0056BCr 3               nt_u_dot:
0056BCr 3  02 10                .byte 2, UF
0056BEr 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
0056C2r 3  rr rr        
0056C4r 3  75 2E                .byte "u."
0056C6r 3               
0056C6r 3               nt_dot:
0056C6r 3  01 10                .byte 1, UF
0056C8r 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
0056CCr 3  rr rr        
0056CEr 3  2E                   .byte "."
0056CFr 3               
0056CFr 3               nt_type:
0056CFr 3  04 10                .byte 4, UF
0056D1r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
0056D5r 3  rr rr        
0056D7r 3  74 79 70 65          .byte "type"
0056DBr 3               
0056DBr 3               nt_emit:
0056DBr 3  04 18                .byte 4, NN+UF
0056DDr 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
0056E1r 3  rr rr        
0056E3r 3  65 6D 69 74          .byte "emit"
0056E7r 3               
0056E7r 3               nt_execute:
0056E7r 3  07 10                .byte 7, UF
0056E9r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
0056EDr 3  rr rr        
0056EFr 3  65 78 65 63          .byte "execute"
0056F3r 3  75 74 65     
0056F6r 3               
0056F6r 3               nt_plus_store:
0056F6r 3  02 10                .byte 2, UF
0056F8r 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
0056FCr 3  rr rr        
0056FEr 3  2B 21                .byte "+!"
005700r 3               
005700r 3               nt_c_store:
005700r 3  02 10                .byte 2, UF
005702r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
005706r 3  rr rr        
005708r 3  63 21                .byte "c!"
00570Ar 3               
00570Ar 3               nt_c_fetch:
00570Ar 3  02 10                .byte 2, UF
00570Cr 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
005710r 3  rr rr        
005712r 3  63 40                .byte "c@"
005714r 3               
005714r 3               nt_comma:
005714r 3  01 10                .byte 1, UF
005716r 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
00571Ar 3  rr rr        
00571Cr 3  2C                   .byte ","
00571Dr 3               
00571Dr 3               nt_tuck:
00571Dr 3  04 10                .byte 4, UF
00571Fr 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
005723r 3  rr rr        
005725r 3  74 75 63 6B          .byte "tuck"
005729r 3               
005729r 3               nt_not_rote:
005729r 3  04 10                .byte 4, UF
00572Br 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
00572Fr 3  rr rr        
005731r 3  2D 72 6F 74          .byte "-rot"
005735r 3               
005735r 3               nt_rot:
005735r 3  03 10                .byte 3, UF
005737r 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
00573Br 3  rr rr        
00573Dr 3  72 6F 74             .byte "rot"
005740r 3               
005740r 3               nt_nip:
005740r 3  03 10                .byte 3, UF
005742r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
005746r 3  rr rr        
005748r 3  6E 69 70             .byte "nip"
00574Br 3               
00574Br 3               nt_r_fetch:
00574Br 3  02 01                .byte 2, CO    ; native is special case
00574Dr 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
005751r 3  rr rr        
005753r 3  72 40                .byte "r@"
005755r 3               
005755r 3               nt_r_from:
005755r 3  02 01                .byte 2, CO    ; native is special case
005757r 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
00575Br 3  rr rr        
00575Dr 3  72 3E                .byte "r>"
00575Fr 3               
00575Fr 3               nt_to_r:
00575Fr 3  02 11                .byte 2, CO+UF ; native is special case
005761r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
005765r 3  rr rr        
005767r 3  3E 72                .byte ">r"
005769r 3               
005769r 3               nt_over:
005769r 3  04 10                .byte 4, UF
00576Br 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
00576Fr 3  rr rr        
005771r 3  6F 76 65 72          .byte "over"
005775r 3               
005775r 3               nt_fetch:
005775r 3  01 10                .byte 1, UF
005777r 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
00577Br 3  rr rr        
00577Dr 3  40                   .byte "@"
00577Er 3               
00577Er 3               nt_store:
00577Er 3  01 10                .byte 1, UF
005780r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
005784r 3  rr rr        
005786r 3  21                   .byte "!"
005787r 3               
005787r 3               nt_swap:
005787r 3  04 10                .byte 4, UF
005789r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
00578Dr 3  rr rr        
00578Fr 3  73 77 61 70          .byte "swap"
005793r 3               
005793r 3               nt_dup:
005793r 3  03 10                .byte 3, UF
005795r 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
005799r 3  rr rr        
00579Br 3  64 75 70             .byte "dup"
00579Er 3               
00579Er 3               ; DROP is always the first native word in the Dictionary
00579Er 3               dictionary_start:
00579Er 3               nt_drop:
00579Er 3  04 10                .byte 4, UF
0057A0r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
0057A4r 3  rr rr        
0057A6r 3  64 72 6F 70          .byte "drop"
0057AAr 3               
0057AAr 3               ; END of FORTH-WORDLIST
0057AAr 3               
0057AAr 3               
0057AAr 3               ; ROOT-WORDLIST
0057AAr 3                       ; This is a short wordlist that has just the words needed to
0057AAr 3                       ; set the wordlists. These words are also included in the
0057AAr 3                       ; FORTH-WORDLIST as well.
0057AAr 3               
0057AAr 3               nt_root_words:
0057AAr 3  05 00                .byte 5, 0
0057ACr 3  00 00 rr rr          .word 0000, xt_words, z_words
0057B0r 3  rr rr        
0057B2r 3  77 6F 72 64          .byte "words"
0057B6r 3  73           
0057B7r 3               
0057B7r 3               nt_root_forth_wordlist: ; shares code with ZERO
0057B7r 3  0E 00                .byte 14, 0
0057B9r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
0057BDr 3  rr rr        
0057BFr 3  66 6F 72 74          .byte "forth-wordlist"
0057C3r 3  68 2D 77 6F  
0057C7r 3  72 64 6C 69  
0057CDr 3               
0057CDr 3               nt_root_forth:
0057CDr 3  05 00                .byte 5, 0
0057CFr 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
0057D3r 3  rr rr        
0057D5r 3  66 6F 72 74          .byte "forth"
0057D9r 3  68           
0057DAr 3               
0057DAr 3               root_dictionary_start:
0057DAr 3               nt_root_set_order:
0057DAr 3  09 00                .byte 9, 0
0057DCr 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
0057E0r 3  rr rr        
0057E2r 3  73 65 74 2D          .byte "set-order"
0057E6r 3  6F 72 64 65  
0057EAr 3  72           
0057EBr 3               
0057EBr 3               ; END of ROOT-WORDLIST
0057EBr 3               
0057EBr 3               
0057EBr 3               ; EDITOR-WORDLIST
0057EBr 3               
0057EBr 3               nt_editor_enter_screen:
0057EBr 3  0C 00                .byte 12, 0
0057EDr 3  00 00 rr rr          .word 0000, xt_editor_enter_screen, z_editor_enter_screen
0057F1r 3  rr rr        
0057F3r 3  65 6E 74 65          .byte "enter-screen"
0057F7r 3  72 2D 73 63  
0057FBr 3  72 65 65 6E  
0057FFr 3               
0057FFr 3               nt_editor_erase_screen:
0057FFr 3  0C 00                .byte 12, 0
005801r 3  rr rr rr rr          .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
005805r 3  rr rr        
005807r 3  65 72 61 73          .byte "erase-screen"
00580Br 3  65 2D 73 63  
00580Fr 3  72 65 65 6E  
005813r 3               
005813r 3               nt_editor_el:
005813r 3  02 00                .byte 2, 0
005815r 3  rr rr rr rr          .word nt_editor_erase_screen, xt_editor_el, z_editor_el
005819r 3  rr rr        
00581Br 3  65 6C                .byte "el"
00581Dr 3               
00581Dr 3               nt_editor_l:
00581Dr 3  01 00                .byte 1, 0
00581Fr 3  rr rr rr rr          .word nt_editor_el, xt_editor_l, z_editor_l
005823r 3  rr rr        
005825r 3  6C                   .byte "l"
005826r 3               
005826r 3               nt_editor_line:
005826r 3  04 10                .byte 4, UF
005828r 3  rr rr rr rr          .word nt_editor_l, xt_editor_line, z_editor_line
00582Cr 3  rr rr        
00582Er 3  6C 69 6E 65          .byte "line"
005832r 3               
005832r 3               editor_dictionary_start:
005832r 3               nt_editor_o:
005832r 3  01 00                .byte 1, 0
005834r 3  rr rr rr rr          .word nt_editor_line, xt_editor_o, z_editor_o
005838r 3  rr rr        
00583Ar 3  6F                   .byte "o"
00583Br 3               
00583Br 3               ; END of EDITOR-WORDLIST
00583Br 3               
00583Br 3               
00583Br 3               ; ASSEMBLER-WORDLIST
00583Br 3               
00583Br 3               ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
00583Br 3               ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
00583Br 3               ; immediate addressing is replaced by an "h" (for example, the label code for
00583Br 3               ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
00583Br 3               assembler_dictionary_start:
00583Br 3               nt_asm_adc_h:
00583Br 3  05 04        		.byte 5, IM
00583Dr 3  rr rr                        .word nt_asm_adc_x
00583Fr 3  rr rr rr rr  		.word xt_asm_adc_h, z_asm_adc_h
005843r 3  61 64 63 2E  		.byte "adc.#"
005847r 3  23           
005848r 3               
005848r 3               nt_asm_adc_x:
005848r 3  05 04        		.byte 5, IM
00584Ar 3  rr rr                        .word nt_asm_adc_y
00584Cr 3  rr rr rr rr  		.word xt_asm_adc_x, z_asm_adc_x
005850r 3  61 64 63 2E  		.byte "adc.x"
005854r 3  78           
005855r 3               
005855r 3               nt_asm_adc_y:
005855r 3  05 04        		.byte 5, IM
005857r 3  rr rr                        .word nt_asm_adc_z
005859r 3  rr rr rr rr  		.word xt_asm_adc_y, z_asm_adc_y
00585Dr 3  61 64 63 2E  		.byte "adc.y"
005861r 3  79           
005862r 3               
005862r 3               nt_asm_adc_z:
005862r 3  05 04        		.byte 5, IM
005864r 3  rr rr                        .word nt_asm_adc_zi
005866r 3  rr rr rr rr  		.word xt_asm_adc_z, z_asm_adc_z
00586Ar 3  61 64 63 2E  		.byte "adc.z"
00586Er 3  7A           
00586Fr 3               
00586Fr 3               nt_asm_adc_zi:
00586Fr 3  06 04        		.byte 6, IM
005871r 3  rr rr                        .word nt_asm_adc_ziy
005873r 3  rr rr rr rr  		.word xt_asm_adc_zi, z_asm_adc_zi
005877r 3  61 64 63 2E  		.byte "adc.zi"
00587Br 3  7A 69        
00587Dr 3               
00587Dr 3               nt_asm_adc_ziy:
00587Dr 3  07 04        		.byte 7, IM
00587Fr 3  rr rr                        .word nt_asm_adc_zx
005881r 3  rr rr rr rr  		.word xt_asm_adc_ziy, z_asm_adc_ziy
005885r 3  61 64 63 2E  		.byte "adc.ziy"
005889r 3  7A 69 79     
00588Cr 3               
00588Cr 3               nt_asm_adc_zx:
00588Cr 3  06 04        		.byte 6, IM
00588Er 3  rr rr                        .word nt_asm_adc_zxi
005890r 3  rr rr rr rr  		.word xt_asm_adc_zx, z_asm_adc_zx
005894r 3  61 64 63 2E  		.byte "adc.zx"
005898r 3  7A 78        
00589Ar 3               
00589Ar 3               nt_asm_adc_zxi:
00589Ar 3  07 04        		.byte 7, IM
00589Cr 3  rr rr                        .word nt_asm_and
00589Er 3  rr rr rr rr  		.word xt_asm_adc_zxi, z_asm_adc_zxi
0058A2r 3  61 64 63 2E  		.byte "adc.zxi"
0058A6r 3  7A 78 69     
0058A9r 3               
0058A9r 3               nt_asm_and:     ; not "and" because of conflicts with Forth word
0058A9r 3  04 04        		.byte 4, IM
0058ABr 3  rr rr                        .word nt_asm_and_h
0058ADr 3  rr rr rr rr  		.word xt_asm_and, z_asm_and
0058B1r 3  61 6E 64 2E  		.byte "and."
0058B5r 3               
0058B5r 3               nt_asm_and_h:
0058B5r 3  05 04        		.byte 5, IM
0058B7r 3  rr rr                        .word nt_asm_and_x
0058B9r 3  rr rr rr rr  		.word xt_asm_and_h, z_asm_and_h
0058BDr 3  61 6E 64 2E  		.byte "and.#"
0058C1r 3  23           
0058C2r 3               
0058C2r 3               nt_asm_and_x:
0058C2r 3  05 04        		.byte 5, IM
0058C4r 3  rr rr                        .word nt_asm_and_y
0058C6r 3  rr rr rr rr  		.word xt_asm_and_x, z_asm_and_x
0058CAr 3  61 6E 64 2E  		.byte "and.x"
0058CEr 3  78           
0058CFr 3               
0058CFr 3               nt_asm_and_y:
0058CFr 3  05 04        		.byte 5, IM
0058D1r 3  rr rr                        .word nt_asm_and_z
0058D3r 3  rr rr rr rr  		.word xt_asm_and_y, z_asm_and_y
0058D7r 3  61 6E 64 2E  		.byte "and.y"
0058DBr 3  79           
0058DCr 3               
0058DCr 3               nt_asm_and_z:
0058DCr 3  05 04        		.byte 5, IM
0058DEr 3  rr rr                        .word nt_asm_and_zi
0058E0r 3  rr rr rr rr  		.word xt_asm_and_z, z_asm_and_z
0058E4r 3  61 6E 64 2E  		.byte "and.z"
0058E8r 3  7A           
0058E9r 3               
0058E9r 3               nt_asm_and_zi:
0058E9r 3  06 04        		.byte 6, IM
0058EBr 3  rr rr                        .word nt_asm_and_ziy
0058EDr 3  rr rr rr rr  		.word xt_asm_and_zi, z_asm_and_zi
0058F1r 3  61 6E 64 2E  		.byte "and.zi"
0058F5r 3  7A 69        
0058F7r 3               
0058F7r 3               nt_asm_and_ziy:
0058F7r 3  07 04        		.byte 7, IM
0058F9r 3  rr rr                        .word nt_asm_and_zx
0058FBr 3  rr rr rr rr  		.word xt_asm_and_ziy, z_asm_and_ziy
0058FFr 3  61 6E 64 2E  		.byte "and.ziy"
005903r 3  7A 69 79     
005906r 3               
005906r 3               nt_asm_and_zx:
005906r 3  06 04        		.byte 6, IM
005908r 3  rr rr                        .word nt_asm_and_zxi
00590Ar 3  rr rr rr rr  		.word xt_asm_and_zx, z_asm_and_zx
00590Er 3  61 6E 64 2E  		.byte "and.zx"
005912r 3  7A 78        
005914r 3               
005914r 3               nt_asm_and_zxi:
005914r 3  07 04        		.byte 7, IM
005916r 3  rr rr                        .word nt_asm_asl
005918r 3  rr rr rr rr  		.word xt_asm_and_zxi, z_asm_and_zxi
00591Cr 3  61 6E 64 2E  		.byte "and.zxi"
005920r 3  7A 78 69     
005923r 3               
005923r 3               nt_asm_asl:
005923r 3  03 04        		.byte 3, IM
005925r 3  rr rr                        .word nt_asm_asl_a
005927r 3  rr rr rr rr  		.word xt_asm_asl, z_asm_asl
00592Br 3  61 73 6C     		.byte "asl"
00592Er 3               
00592Er 3               nt_asm_asl_a:
00592Er 3  05 04        		.byte 5, IM
005930r 3  rr rr                        .word nt_asm_asl_x
005932r 3  rr rr rr rr  		.word xt_asm_asl_a, z_asm_asl_a
005936r 3  61 73 6C 2E  		.byte "asl.a"
00593Ar 3  61           
00593Br 3               
00593Br 3               nt_asm_asl_x:
00593Br 3  05 04        		.byte 5, IM
00593Dr 3  rr rr                        .word nt_asm_asl_z
00593Fr 3  rr rr rr rr  		.word xt_asm_asl_x, z_asm_asl_x
005943r 3  61 73 6C 2E  		.byte "asl.x"
005947r 3  78           
005948r 3               
005948r 3               nt_asm_asl_z:
005948r 3  05 04        		.byte 5, IM
00594Ar 3  rr rr                        .word nt_asm_asl_zx
00594Cr 3  rr rr rr rr  		.word xt_asm_asl_z, z_asm_asl_z
005950r 3  61 73 6C 2E  		.byte "asl.z"
005954r 3  7A           
005955r 3               
005955r 3               nt_asm_asl_zx:
005955r 3  06 04        		.byte 6, IM
005957r 3  rr rr                        .word nt_asm_bcc
005959r 3  rr rr rr rr  		.word xt_asm_asl_zx, z_asm_asl_zx
00595Dr 3  61 73 6C 2E  		.byte "asl.zx"
005961r 3  7A 78        
005963r 3               
005963r 3               nt_asm_bcc:
005963r 3  03 04        		.byte 3, IM
005965r 3  rr rr                        .word nt_asm_bcs
005967r 3  rr rr rr rr  		.word xt_asm_bcc, z_asm_bcc
00596Br 3  62 63 63     		.byte "bcc"
00596Er 3               
00596Er 3               nt_asm_bcs:
00596Er 3  03 04        		.byte 3, IM
005970r 3  rr rr                        .word nt_asm_beq
005972r 3  rr rr rr rr  		.word xt_asm_bcs, z_asm_bcs
005976r 3  62 63 73     		.byte "bcs"
005979r 3               
005979r 3               nt_asm_beq:
005979r 3  03 04        		.byte 3, IM
00597Br 3  rr rr                        .word nt_asm_bit
00597Dr 3  rr rr rr rr  		.word xt_asm_beq, z_asm_beq
005981r 3  62 65 71     		.byte "beq"
005984r 3               
005984r 3               nt_asm_bit:
005984r 3  03 04        		.byte 3, IM
005986r 3  rr rr                        .word nt_asm_bit_h
005988r 3  rr rr rr rr  		.word xt_asm_bit, z_asm_bit
00598Cr 3  62 69 74     		.byte "bit"
00598Fr 3               
00598Fr 3               nt_asm_bit_h:
00598Fr 3  05 04        		.byte 5, IM
005991r 3  rr rr                        .word nt_asm_bit_x
005993r 3  rr rr rr rr  		.word xt_asm_bit_h, z_asm_bit_h
005997r 3  62 69 74 2E  		.byte "bit.#"
00599Br 3  23           
00599Cr 3               
00599Cr 3               nt_asm_bit_x:
00599Cr 3  05 04        		.byte 5, IM
00599Er 3  rr rr                        .word nt_asm_bit_z
0059A0r 3  rr rr rr rr  		.word xt_asm_bit_x, z_asm_bit_x
0059A4r 3  62 69 74 2E  		.byte "bit.x"
0059A8r 3  78           
0059A9r 3               
0059A9r 3               nt_asm_bit_z:
0059A9r 3  05 04        		.byte 5, IM
0059ABr 3  rr rr                        .word nt_asm_bit_zx
0059ADr 3  rr rr rr rr  		.word xt_asm_bit_z, z_asm_bit_z
0059B1r 3  62 69 74 2E  		.byte "bit.z"
0059B5r 3  7A           
0059B6r 3               
0059B6r 3               nt_asm_bit_zx:
0059B6r 3  06 04        		.byte 6, IM
0059B8r 3  rr rr                        .word nt_asm_bmi
0059BAr 3  rr rr rr rr  		.word xt_asm_bit_zx, z_asm_bit_zx
0059BEr 3  62 69 74 2E  		.byte "bit.zx"
0059C2r 3  7A 78        
0059C4r 3               
0059C4r 3               nt_asm_bmi:
0059C4r 3  03 04        		.byte 3, IM
0059C6r 3  rr rr                        .word nt_asm_bne
0059C8r 3  rr rr rr rr  		.word xt_asm_bmi, z_asm_bmi
0059CCr 3  62 6D 69     		.byte "bmi"
0059CFr 3               
0059CFr 3               nt_asm_bne:
0059CFr 3  03 04        		.byte 3, IM
0059D1r 3  rr rr                        .word nt_asm_bpl
0059D3r 3  rr rr rr rr  		.word xt_asm_bne, z_asm_bne
0059D7r 3  62 6E 65     		.byte "bne"
0059DAr 3               
0059DAr 3               nt_asm_bpl:
0059DAr 3  03 04        		.byte 3, IM
0059DCr 3  rr rr                        .word nt_asm_bra
0059DEr 3  rr rr rr rr  		.word xt_asm_bpl, z_asm_bpl
0059E2r 3  62 70 6C     		.byte "bpl"
0059E5r 3               
0059E5r 3               nt_asm_bra:
0059E5r 3  03 04        		.byte 3, IM
0059E7r 3  rr rr                        .word nt_asm_brk
0059E9r 3  rr rr rr rr  		.word xt_asm_bra, z_asm_bra
0059EDr 3  62 72 61     		.byte "bra"
0059F0r 3               
0059F0r 3               nt_asm_brk:
0059F0r 3  03 04        		.byte 3, IM
0059F2r 3  rr rr                        .word nt_asm_bvc
0059F4r 3  rr rr rr rr  		.word xt_asm_brk, z_asm_brk
0059F8r 3  62 72 6B     		.byte "brk"
0059FBr 3               
0059FBr 3               nt_asm_bvc:
0059FBr 3  03 04        		.byte 3, IM
0059FDr 3  rr rr                        .word nt_asm_bvs
0059FFr 3  rr rr rr rr  		.word xt_asm_bvc, z_asm_bvc
005A03r 3  62 76 63     		.byte "bvc"
005A06r 3               
005A06r 3               nt_asm_bvs:
005A06r 3  03 04        		.byte 3, IM
005A08r 3  rr rr                        .word nt_asm_clc
005A0Ar 3  rr rr rr rr  		.word xt_asm_bvs, z_asm_bvs
005A0Er 3  62 76 73     		.byte "bvs"
005A11r 3               
005A11r 3               nt_asm_clc:
005A11r 3  03 04        		.byte 3, IM
005A13r 3  rr rr                        .word nt_asm_cld
005A15r 3  rr rr rr rr  		.word xt_asm_clc, z_asm_clc
005A19r 3  63 6C 63     		.byte "clc"
005A1Cr 3               
005A1Cr 3               nt_asm_cld:
005A1Cr 3  03 04        		.byte 3, IM
005A1Er 3  rr rr                        .word nt_asm_cli
005A20r 3  rr rr rr rr  		.word xt_asm_cld, z_asm_cld
005A24r 3  63 6C 64     		.byte "cld"
005A27r 3               
005A27r 3               nt_asm_cli:
005A27r 3  03 04        		.byte 3, IM
005A29r 3  rr rr                        .word nt_asm_clv
005A2Br 3  rr rr rr rr  		.word xt_asm_cli, z_asm_cli
005A2Fr 3  63 6C 69     		.byte "cli"
005A32r 3               
005A32r 3               nt_asm_clv:
005A32r 3  03 04        		.byte 3, IM
005A34r 3  rr rr                        .word nt_asm_cmp
005A36r 3  rr rr rr rr  		.word xt_asm_clv, z_asm_clv
005A3Ar 3  63 6C 76     		.byte "clv"
005A3Dr 3               
005A3Dr 3               nt_asm_cmp:
005A3Dr 3  03 04        		.byte 3, IM
005A3Fr 3  rr rr                        .word nt_asm_cmp_h
005A41r 3  rr rr rr rr  		.word xt_asm_cmp, z_asm_cmp
005A45r 3  63 6D 70     		.byte "cmp"
005A48r 3               
005A48r 3               nt_asm_cmp_h:
005A48r 3  05 04        		.byte 5, IM
005A4Ar 3  rr rr                        .word nt_asm_cmp_x
005A4Cr 3  rr rr rr rr  		.word xt_asm_cmp_h, z_asm_cmp_h
005A50r 3  63 6D 70 2E  		.byte "cmp.#"
005A54r 3  23           
005A55r 3               
005A55r 3               nt_asm_cmp_x:
005A55r 3  05 04        		.byte 5, IM
005A57r 3  rr rr                        .word nt_asm_cmp_y
005A59r 3  rr rr rr rr  		.word xt_asm_cmp_x, z_asm_cmp_x
005A5Dr 3  63 6D 70 2E  		.byte "cmp.x"
005A61r 3  78           
005A62r 3               
005A62r 3               nt_asm_cmp_y:
005A62r 3  05 04        		.byte 5, IM
005A64r 3  rr rr                        .word nt_asm_cmp_z
005A66r 3  rr rr rr rr  		.word xt_asm_cmp_y, z_asm_cmp_y
005A6Ar 3  63 6D 70 2E  		.byte "cmp.y"
005A6Er 3  79           
005A6Fr 3               
005A6Fr 3               nt_asm_cmp_z:
005A6Fr 3  05 04        		.byte 5, IM
005A71r 3  rr rr                        .word nt_asm_cmp_zi
005A73r 3  rr rr rr rr  		.word xt_asm_cmp_z, z_asm_cmp_z
005A77r 3  63 6D 70 2E  		.byte "cmp.z"
005A7Br 3  7A           
005A7Cr 3               
005A7Cr 3               nt_asm_cmp_zi:
005A7Cr 3  06 04        		.byte 6, IM
005A7Er 3  rr rr                        .word nt_asm_cmp_ziy
005A80r 3  rr rr rr rr  		.word xt_asm_cmp_zi, z_asm_cmp_zi
005A84r 3  63 6D 70 2E  		.byte "cmp.zi"
005A88r 3  7A 69        
005A8Ar 3               
005A8Ar 3               nt_asm_cmp_ziy:
005A8Ar 3  07 04        		.byte 7, IM
005A8Cr 3  rr rr                        .word nt_asm_cmp_zx
005A8Er 3  rr rr rr rr  		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
005A92r 3  63 6D 70 2E  		.byte "cmp.ziy"
005A96r 3  7A 69 79     
005A99r 3               
005A99r 3               nt_asm_cmp_zx:
005A99r 3  06 04        		.byte 6, IM
005A9Br 3  rr rr                        .word nt_asm_cmp_zxi
005A9Dr 3  rr rr rr rr  		.word xt_asm_cmp_zx, z_asm_cmp_zx
005AA1r 3  63 6D 70 2E  		.byte "cmp.zx"
005AA5r 3  7A 78        
005AA7r 3               
005AA7r 3               nt_asm_cmp_zxi:
005AA7r 3  07 04        		.byte 7, IM
005AA9r 3  rr rr                        .word nt_asm_cpx
005AABr 3  rr rr rr rr  		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
005AAFr 3  63 6D 70 2E  		.byte "cmp.zxi"
005AB3r 3  7A 78 69     
005AB6r 3               
005AB6r 3               nt_asm_cpx:
005AB6r 3  03 04        		.byte 3, IM
005AB8r 3  rr rr                        .word nt_asm_cpx_h
005ABAr 3  rr rr rr rr  		.word xt_asm_cpx, z_asm_cpx
005ABEr 3  63 70 78     		.byte "cpx"
005AC1r 3               
005AC1r 3               nt_asm_cpx_h:
005AC1r 3  05 04        		.byte 5, IM
005AC3r 3  rr rr                        .word nt_asm_cpx_z
005AC5r 3  rr rr rr rr  		.word xt_asm_cpx_h, z_asm_cpx_h
005AC9r 3  63 70 78 2E  		.byte "cpx.#"
005ACDr 3  23           
005ACEr 3               
005ACEr 3               nt_asm_cpx_z:
005ACEr 3  05 04        		.byte 5, IM
005AD0r 3  rr rr                        .word nt_asm_cpy
005AD2r 3  rr rr rr rr  		.word xt_asm_cpx_z, z_asm_cpx_z
005AD6r 3  63 70 78 2E  		.byte "cpx.z"
005ADAr 3  7A           
005ADBr 3               
005ADBr 3               nt_asm_cpy:
005ADBr 3  03 04        		.byte 3, IM
005ADDr 3  rr rr                        .word nt_asm_cpy_h
005ADFr 3  rr rr rr rr  		.word xt_asm_cpy, z_asm_cpy
005AE3r 3  63 70 79     		.byte "cpy"
005AE6r 3               
005AE6r 3               nt_asm_cpy_h:
005AE6r 3  05 04        		.byte 5, IM
005AE8r 3  rr rr                        .word nt_asm_cpy_z
005AEAr 3  rr rr rr rr  		.word xt_asm_cpy_h, z_asm_cpy_h
005AEEr 3  63 70 79 2E  		.byte "cpy.#"
005AF2r 3  23           
005AF3r 3               
005AF3r 3               nt_asm_cpy_z:
005AF3r 3  05 04        		.byte 5, IM
005AF5r 3  rr rr                        .word nt_asm_dec
005AF7r 3  rr rr rr rr  		.word xt_asm_cpy_z, z_asm_cpy_z
005AFBr 3  63 70 79 2E  		.byte "cpy.z"
005AFFr 3  7A           
005B00r 3               
005B00r 3               nt_asm_dec:
005B00r 3  03 04        		.byte 3, IM
005B02r 3  rr rr                        .word nt_asm_dec_a
005B04r 3  rr rr rr rr  		.word xt_asm_dec, z_asm_dec
005B08r 3  64 65 63     		.byte "dec"
005B0Br 3               
005B0Br 3               nt_asm_dec_a:
005B0Br 3  05 04        		.byte 5, IM
005B0Dr 3  rr rr                        .word nt_asm_dec_x
005B0Fr 3  rr rr rr rr  		.word xt_asm_dec_a, z_asm_dec_a
005B13r 3  64 65 63 2E  		.byte "dec.a"
005B17r 3  61           
005B18r 3               
005B18r 3               nt_asm_dec_x:
005B18r 3  05 04        		.byte 5, IM
005B1Ar 3  rr rr                        .word nt_asm_dec_z
005B1Cr 3  rr rr rr rr  		.word xt_asm_dec_x, z_asm_dec_x
005B20r 3  64 65 63 2E  		.byte "dec.x"
005B24r 3  78           
005B25r 3               
005B25r 3               nt_asm_dec_z:
005B25r 3  05 04        		.byte 5, IM
005B27r 3  rr rr                        .word nt_asm_dec_zx
005B29r 3  rr rr rr rr  		.word xt_asm_dec_z, z_asm_dec_z
005B2Dr 3  64 65 63 2E  		.byte "dec.z"
005B31r 3  7A           
005B32r 3               
005B32r 3               nt_asm_dec_zx:
005B32r 3  06 04        		.byte 6, IM
005B34r 3  rr rr                        .word nt_asm_dex
005B36r 3  rr rr rr rr  		.word xt_asm_dec_zx, z_asm_dec_zx
005B3Ar 3  64 65 63 2E  		.byte "dec.zx"
005B3Er 3  7A 78        
005B40r 3               
005B40r 3               nt_asm_dex:
005B40r 3  03 04        		.byte 3, IM
005B42r 3  rr rr                        .word nt_asm_dey
005B44r 3  rr rr rr rr  		.word xt_asm_dex, z_asm_dex
005B48r 3  64 65 78     		.byte "dex"
005B4Br 3               
005B4Br 3               nt_asm_dey:
005B4Br 3  03 04        		.byte 3, IM
005B4Dr 3  rr rr                        .word nt_asm_eor
005B4Fr 3  rr rr rr rr  		.word xt_asm_dey, z_asm_dey
005B53r 3  64 65 79     		.byte "dey"
005B56r 3               
005B56r 3               nt_asm_eor:
005B56r 3  03 04        		.byte 3, IM
005B58r 3  rr rr                        .word nt_asm_eor_h
005B5Ar 3  rr rr rr rr  		.word xt_asm_eor, z_asm_eor
005B5Er 3  65 6F 72     		.byte "eor"
005B61r 3               
005B61r 3               nt_asm_eor_h:
005B61r 3  05 04        		.byte 5, IM
005B63r 3  rr rr                        .word nt_asm_eor_x
005B65r 3  rr rr rr rr  		.word xt_asm_eor_h, z_asm_eor_h
005B69r 3  65 6F 72 2E  		.byte "eor.#"
005B6Dr 3  23           
005B6Er 3               
005B6Er 3               nt_asm_eor_x:
005B6Er 3  05 04        		.byte 5, IM
005B70r 3  rr rr                        .word nt_asm_eor_y
005B72r 3  rr rr rr rr  		.word xt_asm_eor_x, z_asm_eor_x
005B76r 3  65 6F 72 2E  		.byte "eor.x"
005B7Ar 3  78           
005B7Br 3               
005B7Br 3               nt_asm_eor_y:
005B7Br 3  05 04        		.byte 5, IM
005B7Dr 3  rr rr                        .word nt_asm_eor_z
005B7Fr 3  rr rr rr rr  		.word xt_asm_eor_y, z_asm_eor_y
005B83r 3  65 6F 72 2E  		.byte "eor.y"
005B87r 3  79           
005B88r 3               
005B88r 3               nt_asm_eor_z:
005B88r 3  05 04        		.byte 5, IM
005B8Ar 3  rr rr                        .word nt_asm_eor_zi
005B8Cr 3  rr rr rr rr  		.word xt_asm_eor_z, z_asm_eor_z
005B90r 3  65 6F 72 2E  		.byte "eor.z"
005B94r 3  7A           
005B95r 3               
005B95r 3               nt_asm_eor_zi:
005B95r 3  06 04        		.byte 6, IM
005B97r 3  rr rr                        .word nt_asm_eor_ziy
005B99r 3  rr rr rr rr  		.word xt_asm_eor_zi, z_asm_eor_zi
005B9Dr 3  65 6F 72 2E  		.byte "eor.zi"
005BA1r 3  7A 69        
005BA3r 3               
005BA3r 3               nt_asm_eor_ziy:
005BA3r 3  07 04        		.byte 7, IM
005BA5r 3  rr rr                        .word nt_asm_eor_zx
005BA7r 3  rr rr rr rr  		.word xt_asm_eor_ziy, z_asm_eor_ziy
005BABr 3  65 6F 72 2E  		.byte "eor.ziy"
005BAFr 3  7A 69 79     
005BB2r 3               
005BB2r 3               nt_asm_eor_zx:
005BB2r 3  06 04        		.byte 6, IM
005BB4r 3  rr rr                        .word nt_asm_eor_zxi
005BB6r 3  rr rr rr rr  		.word xt_asm_eor_zx, z_asm_eor_zx
005BBAr 3  65 6F 72 2E  		.byte "eor.zx"
005BBEr 3  7A 78        
005BC0r 3               
005BC0r 3               nt_asm_eor_zxi:
005BC0r 3  07 04        		.byte 7, IM
005BC2r 3  rr rr                        .word nt_asm_inc
005BC4r 3  rr rr rr rr  		.word xt_asm_eor_zxi, z_asm_eor_zxi
005BC8r 3  65 6F 72 2E  		.byte "eor.zxi"
005BCCr 3  7A 78 69     
005BCFr 3               
005BCFr 3               nt_asm_inc:
005BCFr 3  03 04        		.byte 3, IM
005BD1r 3  rr rr                        .word nt_asm_inc_a
005BD3r 3  rr rr rr rr  		.word xt_asm_inc, z_asm_inc
005BD7r 3  69 6E 63     		.byte "inc"
005BDAr 3               
005BDAr 3               nt_asm_inc_a:
005BDAr 3  05 04        		.byte 5, IM
005BDCr 3  rr rr                        .word nt_asm_inc_x
005BDEr 3  rr rr rr rr  		.word xt_asm_inc_a, z_asm_inc_a
005BE2r 3  69 6E 63 2E  		.byte "inc.a"
005BE6r 3  61           
005BE7r 3               
005BE7r 3               nt_asm_inc_x:
005BE7r 3  05 04        		.byte 5, IM
005BE9r 3  rr rr                        .word nt_asm_inc_z
005BEBr 3  rr rr rr rr  		.word xt_asm_inc_x, z_asm_inc_x
005BEFr 3  69 6E 63 2E  		.byte "inc.x"
005BF3r 3  78           
005BF4r 3               
005BF4r 3               nt_asm_inc_z:
005BF4r 3  05 04        		.byte 5, IM
005BF6r 3  rr rr                        .word nt_asm_inc_zx
005BF8r 3  rr rr rr rr  		.word xt_asm_inc_z, z_asm_inc_z
005BFCr 3  69 6E 63 2E  		.byte "inc.z"
005C00r 3  7A           
005C01r 3               
005C01r 3               nt_asm_inc_zx:
005C01r 3  06 04        		.byte 6, IM
005C03r 3  rr rr                        .word nt_asm_inx
005C05r 3  rr rr rr rr  		.word xt_asm_inc_zx, z_asm_inc_zx
005C09r 3  69 6E 63 2E  		.byte "inc.zx"
005C0Dr 3  7A 78        
005C0Fr 3               
005C0Fr 3               nt_asm_inx:
005C0Fr 3  03 04        		.byte 3, IM
005C11r 3  rr rr                        .word nt_asm_iny
005C13r 3  rr rr rr rr  		.word xt_asm_inx, z_asm_inx
005C17r 3  69 6E 78     		.byte "inx"
005C1Ar 3               
005C1Ar 3               nt_asm_iny:
005C1Ar 3  03 04        		.byte 3, IM
005C1Cr 3  rr rr                        .word nt_asm_jmp
005C1Er 3  rr rr rr rr  		.word xt_asm_iny, z_asm_iny
005C22r 3  69 6E 79     		.byte "iny"
005C25r 3               
005C25r 3               nt_asm_jmp:
005C25r 3  03 04        		.byte 3, IM
005C27r 3  rr rr                        .word nt_asm_jmp_i
005C29r 3  rr rr rr rr  		.word xt_asm_jmp, z_asm_jmp
005C2Dr 3  6A 6D 70     		.byte "jmp"
005C30r 3               
005C30r 3               nt_asm_jmp_i:
005C30r 3  05 04        		.byte 5, IM
005C32r 3  rr rr                        .word nt_asm_jmp_xi
005C34r 3  rr rr rr rr  		.word xt_asm_jmp_i, z_asm_jmp_i
005C38r 3  6A 6D 70 2E  		.byte "jmp.i"
005C3Cr 3  69           
005C3Dr 3               
005C3Dr 3               nt_asm_jmp_xi:
005C3Dr 3  06 04        		.byte 6, IM
005C3Fr 3  rr rr                        .word nt_asm_jsr
005C41r 3  rr rr rr rr  		.word xt_asm_jmp_xi, z_asm_jmp_xi
005C45r 3  6A 6D 70 2E  		.byte "jmp.xi"
005C49r 3  78 69        
005C4Br 3               
005C4Br 3               nt_asm_jsr:
005C4Br 3  03 04        		.byte 3, IM
005C4Dr 3  rr rr                        .word nt_asm_lda
005C4Fr 3  rr rr rr rr  		.word xt_asm_jsr, z_asm_jsr
005C53r 3  6A 73 72     		.byte "jsr"
005C56r 3               
005C56r 3               nt_asm_lda:
005C56r 3  03 04        		.byte 3, IM
005C58r 3  rr rr                        .word nt_asm_lda_h
005C5Ar 3  rr rr rr rr  		.word xt_asm_lda, z_asm_lda
005C5Er 3  6C 64 61     		.byte "lda"
005C61r 3               
005C61r 3               nt_asm_lda_h:
005C61r 3  05 04        		.byte 5, IM
005C63r 3  rr rr                        .word nt_asm_lda_x
005C65r 3  rr rr rr rr  		.word xt_asm_lda_h, z_asm_lda_h
005C69r 3  6C 64 61 2E  		.byte "lda.#"
005C6Dr 3  23           
005C6Er 3               
005C6Er 3               nt_asm_lda_x:
005C6Er 3  05 04        		.byte 5, IM
005C70r 3  rr rr                        .word nt_asm_lda_y
005C72r 3  rr rr rr rr  		.word xt_asm_lda_x, z_asm_lda_x
005C76r 3  6C 64 61 2E  		.byte "lda.x"
005C7Ar 3  78           
005C7Br 3               
005C7Br 3               nt_asm_lda_y:
005C7Br 3  05 04        		.byte 5, IM
005C7Dr 3  rr rr                        .word nt_asm_lda_z
005C7Fr 3  rr rr rr rr  		.word xt_asm_lda_y, z_asm_lda_y
005C83r 3  6C 64 61 2E  		.byte "lda.y"
005C87r 3  79           
005C88r 3               
005C88r 3               nt_asm_lda_z:
005C88r 3  05 04        		.byte 5, IM
005C8Ar 3  rr rr                        .word nt_asm_lda_zi
005C8Cr 3  rr rr rr rr  		.word xt_asm_lda_z, z_asm_lda_z
005C90r 3  6C 64 61 2E  		.byte "lda.z"
005C94r 3  7A           
005C95r 3               
005C95r 3               nt_asm_lda_zi:
005C95r 3  06 04        		.byte 6, IM
005C97r 3  rr rr                        .word nt_asm_lda_ziy
005C99r 3  rr rr rr rr  		.word xt_asm_lda_zi, z_asm_lda_zi
005C9Dr 3  6C 64 61 2E  		.byte "lda.zi"
005CA1r 3  7A 69        
005CA3r 3               
005CA3r 3               nt_asm_lda_ziy:
005CA3r 3  07 04        		.byte 7, IM
005CA5r 3  rr rr                        .word nt_asm_lda_zx
005CA7r 3  rr rr rr rr  		.word xt_asm_lda_ziy, z_asm_lda_ziy
005CABr 3  6C 64 61 2E  		.byte "lda.ziy"
005CAFr 3  7A 69 79     
005CB2r 3               
005CB2r 3               nt_asm_lda_zx:
005CB2r 3  06 04        		.byte 6, IM
005CB4r 3  rr rr                        .word nt_asm_lda_zxi
005CB6r 3  rr rr rr rr  		.word xt_asm_lda_zx, z_asm_lda_zx
005CBAr 3  6C 64 61 2E  		.byte "lda.zx"
005CBEr 3  7A 78        
005CC0r 3               
005CC0r 3               nt_asm_lda_zxi:
005CC0r 3  07 04        		.byte 7, IM
005CC2r 3  rr rr                        .word nt_asm_ldx
005CC4r 3  rr rr rr rr  		.word xt_asm_lda_zxi, z_asm_lda_zxi
005CC8r 3  6C 64 61 2E  		.byte "lda.zxi"
005CCCr 3  7A 78 69     
005CCFr 3               
005CCFr 3               nt_asm_ldx:
005CCFr 3  03 04        		.byte 3, IM
005CD1r 3  rr rr                        .word nt_asm_ldx_h
005CD3r 3  rr rr rr rr  		.word xt_asm_ldx, z_asm_ldx
005CD7r 3  6C 64 78     		.byte "ldx"
005CDAr 3               
005CDAr 3               nt_asm_ldx_h:
005CDAr 3  05 04        		.byte 5, IM
005CDCr 3  rr rr                        .word nt_asm_ldx_y
005CDEr 3  rr rr rr rr  		.word xt_asm_ldx_h, z_asm_ldx_h
005CE2r 3  6C 64 78 2E  		.byte "ldx.#"
005CE6r 3  23           
005CE7r 3               
005CE7r 3               nt_asm_ldx_y:
005CE7r 3  05 04        		.byte 5, IM
005CE9r 3  rr rr                        .word nt_asm_ldx_z
005CEBr 3  rr rr rr rr  		.word xt_asm_ldx_y, z_asm_ldx_y
005CEFr 3  6C 64 78 2E  		.byte "ldx.y"
005CF3r 3  79           
005CF4r 3               
005CF4r 3               nt_asm_ldx_z:
005CF4r 3  05 04        		.byte 5, IM
005CF6r 3  rr rr                        .word nt_asm_ldx_zy
005CF8r 3  rr rr rr rr  		.word xt_asm_ldx_z, z_asm_ldx_z
005CFCr 3  6C 64 78 2E  		.byte "ldx.z"
005D00r 3  7A           
005D01r 3               
005D01r 3               nt_asm_ldx_zy:
005D01r 3  06 04        		.byte 6, IM
005D03r 3  rr rr                        .word nt_asm_ldy
005D05r 3  rr rr rr rr  		.word xt_asm_ldx_zy, z_asm_ldx_zy
005D09r 3  6C 64 78 2E  		.byte "ldx.zy"
005D0Dr 3  7A 79        
005D0Fr 3               
005D0Fr 3               nt_asm_ldy:
005D0Fr 3  03 04        		.byte 3, IM
005D11r 3  rr rr                        .word nt_asm_ldy_h
005D13r 3  rr rr rr rr  		.word xt_asm_ldy, z_asm_ldy
005D17r 3  6C 64 79     		.byte "ldy"
005D1Ar 3               
005D1Ar 3               nt_asm_ldy_h:
005D1Ar 3  05 04        		.byte 5, IM
005D1Cr 3  rr rr                        .word nt_asm_ldy_x
005D1Er 3  rr rr rr rr  		.word xt_asm_ldy_h, z_asm_ldy_h
005D22r 3  6C 64 79 2E  		.byte "ldy.#"
005D26r 3  23           
005D27r 3               
005D27r 3               nt_asm_ldy_x:
005D27r 3  05 04        		.byte 5, IM
005D29r 3  rr rr                        .word nt_asm_ldy_z
005D2Br 3  rr rr rr rr  		.word xt_asm_ldy_x, z_asm_ldy_x
005D2Fr 3  6C 64 79 2E  		.byte "ldy.x"
005D33r 3  78           
005D34r 3               
005D34r 3               nt_asm_ldy_z:
005D34r 3  05 04        		.byte 5, IM
005D36r 3  rr rr                        .word nt_asm_ldy_zx
005D38r 3  rr rr rr rr  		.word xt_asm_ldy_z, z_asm_ldy_z
005D3Cr 3  6C 64 79 2E  		.byte "ldy.z"
005D40r 3  7A           
005D41r 3               
005D41r 3               nt_asm_ldy_zx:
005D41r 3  06 04        		.byte 6, IM
005D43r 3  rr rr                        .word nt_asm_lsr
005D45r 3  rr rr rr rr  		.word xt_asm_ldy_zx, z_asm_ldy_zx
005D49r 3  6C 64 79 2E  		.byte "ldy.zx"
005D4Dr 3  7A 78        
005D4Fr 3               
005D4Fr 3               nt_asm_lsr:
005D4Fr 3  03 04        		.byte 3, IM
005D51r 3  rr rr                        .word nt_asm_lsr_a
005D53r 3  rr rr rr rr  		.word xt_asm_lsr, z_asm_lsr
005D57r 3  6C 73 72     		.byte "lsr"
005D5Ar 3               
005D5Ar 3               nt_asm_lsr_a:
005D5Ar 3  05 04        		.byte 5, IM
005D5Cr 3  rr rr                        .word nt_asm_lsr_x
005D5Er 3  rr rr rr rr  		.word xt_asm_lsr_a, z_asm_lsr_a
005D62r 3  6C 73 72 2E  		.byte "lsr.a"
005D66r 3  61           
005D67r 3               
005D67r 3               nt_asm_lsr_x:
005D67r 3  05 04        		.byte 5, IM
005D69r 3  rr rr                        .word nt_asm_lsr_z
005D6Br 3  rr rr rr rr  		.word xt_asm_lsr_x, z_asm_lsr_x
005D6Fr 3  6C 73 72 2E  		.byte "lsr.x"
005D73r 3  78           
005D74r 3               
005D74r 3               nt_asm_lsr_z:
005D74r 3  05 04        		.byte 5, IM
005D76r 3  rr rr                        .word nt_asm_lsr_zx
005D78r 3  rr rr rr rr  		.word xt_asm_lsr_z, z_asm_lsr_z
005D7Cr 3  6C 73 72 2E  		.byte "lsr.z"
005D80r 3  7A           
005D81r 3               
005D81r 3               nt_asm_lsr_zx:
005D81r 3  06 04        		.byte 6, IM
005D83r 3  rr rr                        .word nt_asm_nop
005D85r 3  rr rr rr rr  		.word xt_asm_lsr_zx, z_asm_lsr_zx
005D89r 3  6C 73 72 2E  		.byte "lsr.zx"
005D8Dr 3  7A 78        
005D8Fr 3               
005D8Fr 3               nt_asm_nop:
005D8Fr 3  03 04        		.byte 3, IM
005D91r 3  rr rr                        .word nt_asm_ora
005D93r 3  rr rr rr rr  		.word xt_asm_nop, z_asm_nop
005D97r 3  6E 6F 70     		.byte "nop"
005D9Ar 3               
005D9Ar 3               nt_asm_ora:
005D9Ar 3  03 04        		.byte 3, IM
005D9Cr 3  rr rr                        .word nt_asm_ora_h
005D9Er 3  rr rr rr rr  		.word xt_asm_ora, z_asm_ora
005DA2r 3  6F 72 61     		.byte "ora"
005DA5r 3               
005DA5r 3               nt_asm_ora_h:
005DA5r 3  05 04        		.byte 5, IM
005DA7r 3  rr rr                        .word nt_asm_ora_x
005DA9r 3  rr rr rr rr  		.word xt_asm_ora_h, z_asm_ora_h
005DADr 3  6F 72 61 2E  		.byte "ora.#"
005DB1r 3  23           
005DB2r 3               
005DB2r 3               nt_asm_ora_x:
005DB2r 3  05 04        		.byte 5, IM
005DB4r 3  rr rr                        .word nt_asm_ora_y
005DB6r 3  rr rr rr rr  		.word xt_asm_ora_x, z_asm_ora_x
005DBAr 3  6F 72 61 2E  		.byte "ora.x"
005DBEr 3  78           
005DBFr 3               
005DBFr 3               nt_asm_ora_y:
005DBFr 3  05 04        		.byte 5, IM
005DC1r 3  rr rr                        .word nt_asm_ora_z
005DC3r 3  rr rr rr rr  		.word xt_asm_ora_y, z_asm_ora_y
005DC7r 3  6F 72 61 2E  		.byte "ora.y"
005DCBr 3  79           
005DCCr 3               
005DCCr 3               nt_asm_ora_z:
005DCCr 3  05 04        		.byte 5, IM
005DCEr 3  rr rr                        .word nt_asm_ora_zi
005DD0r 3  rr rr rr rr  		.word xt_asm_ora_z, z_asm_ora_z
005DD4r 3  6F 72 61 2E  		.byte "ora.z"
005DD8r 3  7A           
005DD9r 3               
005DD9r 3               nt_asm_ora_zi:
005DD9r 3  06 04        		.byte 6, IM
005DDBr 3  rr rr                        .word nt_asm_ora_ziy
005DDDr 3  rr rr rr rr  		.word xt_asm_ora_zi, z_asm_ora_zi
005DE1r 3  6F 72 61 2E  		.byte "ora.zi"
005DE5r 3  7A 69        
005DE7r 3               
005DE7r 3               nt_asm_ora_ziy:
005DE7r 3  07 04        		.byte 7, IM
005DE9r 3  rr rr                        .word nt_asm_ora_zx
005DEBr 3  rr rr rr rr  		.word xt_asm_ora_ziy, z_asm_ora_ziy
005DEFr 3  6F 72 61 2E  		.byte "ora.ziy"
005DF3r 3  7A 69 79     
005DF6r 3               
005DF6r 3               nt_asm_ora_zx:
005DF6r 3  06 04        		.byte 6, IM
005DF8r 3  rr rr                        .word nt_asm_ora_zxi
005DFAr 3  rr rr rr rr  		.word xt_asm_ora_zx, z_asm_ora_zx
005DFEr 3  6F 72 61 2E  		.byte "ora.zx"
005E02r 3  7A 78        
005E04r 3               
005E04r 3               nt_asm_ora_zxi:
005E04r 3  07 04        		.byte 7, IM
005E06r 3  rr rr                        .word nt_asm_pha
005E08r 3  rr rr rr rr  		.word xt_asm_ora_zxi, z_asm_ora_zxi
005E0Cr 3  6F 72 61 2E  		.byte "ora.zxi"
005E10r 3  7A 78 69     
005E13r 3               
005E13r 3               nt_asm_pha:
005E13r 3  03 04        		.byte 3, IM
005E15r 3  rr rr                        .word nt_asm_php
005E17r 3  rr rr rr rr  		.word xt_asm_pha, z_asm_pha
005E1Br 3  70 68 61     		.byte "pha"
005E1Er 3               
005E1Er 3               nt_asm_php:
005E1Er 3  03 04        		.byte 3, IM
005E20r 3  rr rr                        .word nt_asm_phx
005E22r 3  rr rr rr rr  		.word xt_asm_php, z_asm_php
005E26r 3  70 68 70     		.byte "php"
005E29r 3               
005E29r 3               nt_asm_phx:
005E29r 3  03 04        		.byte 3, IM
005E2Br 3  rr rr                        .word nt_asm_phy
005E2Dr 3  rr rr rr rr  		.word xt_asm_phx, z_asm_phx
005E31r 3  70 68 78     		.byte "phx"
005E34r 3               
005E34r 3               nt_asm_phy:
005E34r 3  03 04        		.byte 3, IM
005E36r 3  rr rr                        .word nt_asm_pla
005E38r 3  rr rr rr rr  		.word xt_asm_phy, z_asm_phy
005E3Cr 3  70 68 79     		.byte "phy"
005E3Fr 3               
005E3Fr 3               nt_asm_pla:
005E3Fr 3  03 04        		.byte 3, IM
005E41r 3  rr rr                        .word nt_asm_plp
005E43r 3  rr rr rr rr  		.word xt_asm_pla, z_asm_pla
005E47r 3  70 6C 61     		.byte "pla"
005E4Ar 3               
005E4Ar 3               nt_asm_plp:
005E4Ar 3  03 04        		.byte 3, IM
005E4Cr 3  rr rr                        .word nt_asm_plx
005E4Er 3  rr rr rr rr  		.word xt_asm_plp, z_asm_plp
005E52r 3  70 6C 70     		.byte "plp"
005E55r 3               
005E55r 3               nt_asm_plx:
005E55r 3  03 04        		.byte 3, IM
005E57r 3  rr rr                        .word nt_asm_ply
005E59r 3  rr rr rr rr  		.word xt_asm_plx, z_asm_plx
005E5Dr 3  70 6C 78     		.byte "plx"
005E60r 3               
005E60r 3               nt_asm_ply:
005E60r 3  03 04        		.byte 3, IM
005E62r 3  rr rr                        .word nt_asm_rol
005E64r 3  rr rr rr rr  		.word xt_asm_ply, z_asm_ply
005E68r 3  70 6C 79     		.byte "ply"
005E6Br 3               
005E6Br 3               nt_asm_rol:
005E6Br 3  03 04        		.byte 3, IM
005E6Dr 3  rr rr                        .word nt_asm_rol_a
005E6Fr 3  rr rr rr rr  		.word xt_asm_rol, z_asm_rol
005E73r 3  72 6F 6C     		.byte "rol"
005E76r 3               
005E76r 3               nt_asm_rol_a:
005E76r 3  05 04        		.byte 5, IM
005E78r 3  rr rr                        .word nt_asm_rol_x
005E7Ar 3  rr rr rr rr  		.word xt_asm_rol_a, z_asm_rol_a
005E7Er 3  72 6F 6C 2E  		.byte "rol.a"
005E82r 3  61           
005E83r 3               
005E83r 3               nt_asm_rol_x:
005E83r 3  05 04        		.byte 5, IM
005E85r 3  rr rr                        .word nt_asm_rol_z
005E87r 3  rr rr rr rr  		.word xt_asm_rol_x, z_asm_rol_x
005E8Br 3  72 6F 6C 2E  		.byte "rol.x"
005E8Fr 3  78           
005E90r 3               
005E90r 3               nt_asm_rol_z:
005E90r 3  05 04        		.byte 5, IM
005E92r 3  rr rr                        .word nt_asm_rol_zx
005E94r 3  rr rr rr rr  		.word xt_asm_rol_z, z_asm_rol_z
005E98r 3  72 6F 6C 2E  		.byte "rol.z"
005E9Cr 3  7A           
005E9Dr 3               
005E9Dr 3               nt_asm_rol_zx:
005E9Dr 3  06 04        		.byte 6, IM
005E9Fr 3  rr rr                        .word nt_asm_ror
005EA1r 3  rr rr rr rr  		.word xt_asm_rol_zx, z_asm_rol_zx
005EA5r 3  72 6F 6C 2E  		.byte "rol.zx"
005EA9r 3  7A 78        
005EABr 3               
005EABr 3               nt_asm_ror:
005EABr 3  03 04        		.byte 3, IM
005EADr 3  rr rr                        .word nt_asm_ror_a
005EAFr 3  rr rr rr rr  		.word xt_asm_ror, z_asm_ror
005EB3r 3  72 6F 72     		.byte "ror"
005EB6r 3               
005EB6r 3               nt_asm_ror_a:
005EB6r 3  05 04        		.byte 5, IM
005EB8r 3  rr rr                        .word nt_asm_ror_x
005EBAr 3  rr rr rr rr  		.word xt_asm_ror_a, z_asm_ror_a
005EBEr 3  72 6F 72 2E  		.byte "ror.a"
005EC2r 3  61           
005EC3r 3               
005EC3r 3               nt_asm_ror_x:
005EC3r 3  05 04        		.byte 5, IM
005EC5r 3  rr rr                        .word nt_asm_ror_z
005EC7r 3  rr rr rr rr  		.word xt_asm_ror_x, z_asm_ror_x
005ECBr 3  72 6F 72 2E  		.byte "ror.x"
005ECFr 3  78           
005ED0r 3               
005ED0r 3               nt_asm_ror_z:
005ED0r 3  05 04        		.byte 5, IM
005ED2r 3  rr rr                        .word nt_asm_ror_zx
005ED4r 3  rr rr rr rr  		.word xt_asm_ror_z, z_asm_ror_z
005ED8r 3  72 6F 72 2E  		.byte "ror.z"
005EDCr 3  7A           
005EDDr 3               
005EDDr 3               nt_asm_ror_zx:
005EDDr 3  06 04        		.byte 6, IM
005EDFr 3  rr rr                        .word nt_asm_rti
005EE1r 3  rr rr rr rr  		.word xt_asm_ror_zx, z_asm_ror_zx
005EE5r 3  72 6F 72 2E  		.byte "ror.zx"
005EE9r 3  7A 78        
005EEBr 3               
005EEBr 3               nt_asm_rti:
005EEBr 3  03 04        		.byte 3, IM
005EEDr 3  rr rr                        .word nt_asm_rts
005EEFr 3  rr rr rr rr  		.word xt_asm_rti, z_asm_rti
005EF3r 3  72 74 69     		.byte "rti"
005EF6r 3               
005EF6r 3               nt_asm_rts:
005EF6r 3  03 04        		.byte 3, IM
005EF8r 3  rr rr                        .word nt_asm_sbc
005EFAr 3  rr rr rr rr  		.word xt_asm_rts, z_asm_rts
005EFEr 3  72 74 73     		.byte "rts"
005F01r 3               
005F01r 3               nt_asm_sbc:
005F01r 3  03 04        		.byte 3, IM
005F03r 3  rr rr                        .word nt_asm_sbc_h
005F05r 3  rr rr rr rr  		.word xt_asm_sbc, z_asm_sbc
005F09r 3  73 62 63     		.byte "sbc"
005F0Cr 3               
005F0Cr 3               nt_asm_sbc_h:
005F0Cr 3  05 04        		.byte 5, IM
005F0Er 3  rr rr                        .word nt_asm_sbc_x
005F10r 3  rr rr rr rr  		.word xt_asm_sbc_h, z_asm_sbc_h
005F14r 3  73 62 63 2E  		.byte "sbc.#"
005F18r 3  23           
005F19r 3               
005F19r 3               nt_asm_sbc_x:
005F19r 3  05 04        		.byte 5, IM
005F1Br 3  rr rr                        .word nt_asm_sbc_y
005F1Dr 3  rr rr rr rr  		.word xt_asm_sbc_x, z_asm_sbc_x
005F21r 3  73 62 63 2E  		.byte "sbc.x"
005F25r 3  78           
005F26r 3               
005F26r 3               nt_asm_sbc_y:
005F26r 3  05 04        		.byte 5, IM
005F28r 3  rr rr                        .word nt_asm_sbc_z
005F2Ar 3  rr rr rr rr  		.word xt_asm_sbc_y, z_asm_sbc_y
005F2Er 3  73 62 63 2E  		.byte "sbc.y"
005F32r 3  79           
005F33r 3               
005F33r 3               nt_asm_sbc_z:
005F33r 3  05 04        		.byte 5, IM
005F35r 3  rr rr                        .word nt_asm_sbc_zi
005F37r 3  rr rr rr rr  		.word xt_asm_sbc_z, z_asm_sbc_z
005F3Br 3  73 62 63 2E  		.byte "sbc.z"
005F3Fr 3  7A           
005F40r 3               
005F40r 3               nt_asm_sbc_zi:
005F40r 3  06 04        		.byte 6, IM
005F42r 3  rr rr                        .word nt_asm_sbc_ziy
005F44r 3  rr rr rr rr  		.word xt_asm_sbc_zi, z_asm_sbc_zi
005F48r 3  73 62 63 2E  		.byte "sbc.zi"
005F4Cr 3  7A 69        
005F4Er 3               
005F4Er 3               nt_asm_sbc_ziy:
005F4Er 3  07 04        		.byte 7, IM
005F50r 3  rr rr                        .word nt_asm_sbc_zx
005F52r 3  rr rr rr rr  		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
005F56r 3  73 62 63 2E  		.byte "sbc.ziy"
005F5Ar 3  7A 69 79     
005F5Dr 3               
005F5Dr 3               nt_asm_sbc_zx:
005F5Dr 3  06 04        		.byte 6, IM
005F5Fr 3  rr rr                        .word nt_asm_sbc_zxi
005F61r 3  rr rr rr rr  		.word xt_asm_sbc_zx, z_asm_sbc_zx
005F65r 3  73 62 63 2E  		.byte "sbc.zx"
005F69r 3  7A 78        
005F6Br 3               
005F6Br 3               nt_asm_sbc_zxi:
005F6Br 3  07 04        		.byte 7, IM
005F6Dr 3  rr rr                        .word nt_asm_sec
005F6Fr 3  rr rr rr rr  		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
005F73r 3  73 62 63 2E  		.byte "sbc.zxi"
005F77r 3  7A 78 69     
005F7Ar 3               
005F7Ar 3               nt_asm_sec:
005F7Ar 3  03 04        		.byte 3, IM
005F7Cr 3  rr rr                        .word nt_asm_sed
005F7Er 3  rr rr rr rr  		.word xt_asm_sec, z_asm_sec
005F82r 3  73 65 63     		.byte "sec"
005F85r 3               
005F85r 3               nt_asm_sed:
005F85r 3  03 04        		.byte 3, IM
005F87r 3  rr rr                        .word nt_asm_sei
005F89r 3  rr rr rr rr  		.word xt_asm_sed, z_asm_sed
005F8Dr 3  73 65 64     		.byte "sed"
005F90r 3               
005F90r 3               nt_asm_sei:
005F90r 3  03 04        		.byte 3, IM
005F92r 3  rr rr                        .word nt_asm_sta
005F94r 3  rr rr rr rr  		.word xt_asm_sei, z_asm_sei
005F98r 3  73 65 69     		.byte "sei"
005F9Br 3               
005F9Br 3               nt_asm_sta:
005F9Br 3  03 04        		.byte 3, IM
005F9Dr 3  rr rr                        .word nt_asm_sta_x
005F9Fr 3  rr rr rr rr  		.word xt_asm_sta, z_asm_sta
005FA3r 3  73 74 61     		.byte "sta"
005FA6r 3               
005FA6r 3               nt_asm_sta_x:
005FA6r 3  05 04        		.byte 5, IM
005FA8r 3  rr rr                        .word nt_asm_sta_y
005FAAr 3  rr rr rr rr  		.word xt_asm_sta_x, z_asm_sta_x
005FAEr 3  73 74 61 2E  		.byte "sta.x"
005FB2r 3  78           
005FB3r 3               
005FB3r 3               nt_asm_sta_y:
005FB3r 3  05 04        		.byte 5, IM
005FB5r 3  rr rr                        .word nt_asm_sta_z
005FB7r 3  rr rr rr rr  		.word xt_asm_sta_y, z_asm_sta_y
005FBBr 3  73 74 61 2E  		.byte "sta.y"
005FBFr 3  79           
005FC0r 3               
005FC0r 3               nt_asm_sta_z:
005FC0r 3  05 04        		.byte 5, IM
005FC2r 3  rr rr                        .word nt_asm_sta_zi
005FC4r 3  rr rr rr rr  		.word xt_asm_sta_z, z_asm_sta_z
005FC8r 3  73 74 61 2E  		.byte "sta.z"
005FCCr 3  7A           
005FCDr 3               
005FCDr 3               nt_asm_sta_zi:
005FCDr 3  06 04        		.byte 6, IM
005FCFr 3  rr rr                        .word nt_asm_sta_ziy
005FD1r 3  rr rr rr rr  		.word xt_asm_sta_zi, z_asm_sta_zi
005FD5r 3  73 74 61 2E  		.byte "sta.zi"
005FD9r 3  7A 69        
005FDBr 3               
005FDBr 3               nt_asm_sta_ziy:
005FDBr 3  07 04        		.byte 7, IM
005FDDr 3  rr rr                        .word nt_asm_sta_zx
005FDFr 3  rr rr rr rr  		.word xt_asm_sta_ziy, z_asm_sta_ziy
005FE3r 3  73 74 61 2E  		.byte "sta.ziy"
005FE7r 3  7A 69 79     
005FEAr 3               
005FEAr 3               nt_asm_sta_zx:
005FEAr 3  06 04        		.byte 6, IM
005FECr 3  rr rr                        .word nt_asm_sta_zxi
005FEEr 3  rr rr rr rr  		.word xt_asm_sta_zx, z_asm_sta_zx
005FF2r 3  73 74 61 2E  		.byte "sta.zx"
005FF6r 3  7A 78        
005FF8r 3               
005FF8r 3               nt_asm_sta_zxi:
005FF8r 3  07 04        		.byte 7, IM
005FFAr 3  rr rr                        .word nt_asm_stx
005FFCr 3  rr rr rr rr  		.word xt_asm_sta_zxi, z_asm_sta_zxi
006000r 3  73 74 61 2E  		.byte "sta.zxi"
006004r 3  7A 78 69     
006007r 3               
006007r 3               nt_asm_stx:
006007r 3  03 04        		.byte 3, IM
006009r 3  rr rr                        .word nt_asm_stx_z
00600Br 3  rr rr rr rr  		.word xt_asm_stx, z_asm_stx
00600Fr 3  73 74 78     		.byte "stx"
006012r 3               
006012r 3               nt_asm_stx_z:
006012r 3  05 04        		.byte 5, IM
006014r 3  rr rr                        .word nt_asm_stx_zy
006016r 3  rr rr rr rr  		.word xt_asm_stx_z, z_asm_stx_z
00601Ar 3  73 74 78 2E  		.byte "stx.z"
00601Er 3  7A           
00601Fr 3               
00601Fr 3               nt_asm_stx_zy:
00601Fr 3  06 04        		.byte 6, IM
006021r 3  rr rr                        .word nt_asm_sty
006023r 3  rr rr rr rr  		.word xt_asm_stx_zy, z_asm_stx_zy
006027r 3  73 74 78 2E  		.byte "stx.zy"
00602Br 3  7A 79        
00602Dr 3               
00602Dr 3               nt_asm_sty:
00602Dr 3  03 04        		.byte 3, IM
00602Fr 3  rr rr                        .word nt_asm_sty_z
006031r 3  rr rr rr rr  		.word xt_asm_sty, z_asm_sty
006035r 3  73 74 79     		.byte "sty"
006038r 3               
006038r 3               nt_asm_sty_z:
006038r 3  05 04        		.byte 5, IM
00603Ar 3  rr rr                        .word nt_asm_sty_zx
00603Cr 3  rr rr rr rr  		.word xt_asm_sty_z, z_asm_sty_z
006040r 3  73 74 79 2E  		.byte "sty.z"
006044r 3  7A           
006045r 3               
006045r 3               nt_asm_sty_zx:
006045r 3  06 04        		.byte 6, IM
006047r 3  rr rr                        .word nt_asm_stz
006049r 3  rr rr rr rr  		.word xt_asm_sty_zx, z_asm_sty_zx
00604Dr 3  73 74 79 2E  		.byte "sty.zx"
006051r 3  7A 78        
006053r 3               
006053r 3               nt_asm_stz:
006053r 3  03 04        		.byte 3, IM
006055r 3  rr rr                        .word nt_asm_stz_x
006057r 3  rr rr rr rr  		.word xt_asm_stz, z_asm_stz
00605Br 3  73 74 7A     		.byte "stz"
00605Er 3               
00605Er 3               nt_asm_stz_x:
00605Er 3  05 04        		.byte 5, IM
006060r 3  rr rr                        .word nt_asm_stz_z
006062r 3  rr rr rr rr  		.word xt_asm_stz_x, z_asm_stz_x
006066r 3  73 74 7A 2E  		.byte "stz.x"
00606Ar 3  78           
00606Br 3               
00606Br 3               nt_asm_stz_z:
00606Br 3  05 04        		.byte 5, IM
00606Dr 3  rr rr                        .word nt_asm_stz_zx
00606Fr 3  rr rr rr rr  		.word xt_asm_stz_z, z_asm_stz_z
006073r 3  73 74 7A 2E  		.byte "stz.z"
006077r 3  7A           
006078r 3               
006078r 3               nt_asm_stz_zx:
006078r 3  06 04        		.byte 6, IM
00607Ar 3  rr rr                        .word nt_asm_tax
00607Cr 3  rr rr rr rr  		.word xt_asm_stz_zx, z_asm_stz_zx
006080r 3  73 74 7A 2E  		.byte "stz.zx"
006084r 3  7A 78        
006086r 3               
006086r 3               nt_asm_tax:
006086r 3  03 04        		.byte 3, IM
006088r 3  rr rr                        .word nt_asm_tay
00608Ar 3  rr rr rr rr  		.word xt_asm_tax, z_asm_tax
00608Er 3  74 61 78     		.byte "tax"
006091r 3               
006091r 3               nt_asm_tay:
006091r 3  03 04        		.byte 3, IM
006093r 3  rr rr                        .word nt_asm_trb
006095r 3  rr rr rr rr  		.word xt_asm_tay, z_asm_tay
006099r 3  74 61 79     		.byte "tay"
00609Cr 3               
00609Cr 3               nt_asm_trb:
00609Cr 3  03 04        		.byte 3, IM
00609Er 3  rr rr                        .word nt_asm_trb_z
0060A0r 3  rr rr rr rr  		.word xt_asm_trb, z_asm_trb
0060A4r 3  74 72 62     		.byte "trb"
0060A7r 3               
0060A7r 3               nt_asm_trb_z:
0060A7r 3  05 04        		.byte 5, IM
0060A9r 3  rr rr                        .word nt_asm_tsb
0060ABr 3  rr rr rr rr  		.word xt_asm_trb_z, z_asm_trb_z
0060AFr 3  74 72 62 2E  		.byte "trb.z"
0060B3r 3  7A           
0060B4r 3               
0060B4r 3               nt_asm_tsb:
0060B4r 3  03 04        		.byte 3, IM
0060B6r 3  rr rr                        .word nt_asm_tsb_z
0060B8r 3  rr rr rr rr  		.word xt_asm_tsb, z_asm_tsb
0060BCr 3  74 73 62     		.byte "tsb"
0060BFr 3               
0060BFr 3               nt_asm_tsb_z:
0060BFr 3  05 04        		.byte 5, IM
0060C1r 3  rr rr                        .word nt_asm_tsx
0060C3r 3  rr rr rr rr  		.word xt_asm_tsb_z, z_asm_tsb_z
0060C7r 3  74 73 62 2E  		.byte "tsb.z"
0060CBr 3  7A           
0060CCr 3               
0060CCr 3               nt_asm_tsx:
0060CCr 3  03 04        		.byte 3, IM
0060CEr 3  rr rr                        .word nt_asm_txa
0060D0r 3  rr rr rr rr  		.word xt_asm_tsx, z_asm_tsx
0060D4r 3  74 73 78     		.byte "tsx"
0060D7r 3               
0060D7r 3               nt_asm_txa:
0060D7r 3  03 04        		.byte 3, IM
0060D9r 3  rr rr                        .word nt_asm_txs
0060DBr 3  rr rr rr rr  		.word xt_asm_txa, z_asm_txa
0060DFr 3  74 78 61     		.byte "txa"
0060E2r 3               
0060E2r 3               nt_asm_txs:
0060E2r 3  03 04        		.byte 3, IM
0060E4r 3  rr rr                        .word nt_asm_tya
0060E6r 3  rr rr rr rr  		.word xt_asm_txs, z_asm_txs
0060EAr 3  74 78 73     		.byte "txs"
0060EDr 3               
0060EDr 3               nt_asm_tya:
0060EDr 3  03 04        		.byte 3, IM
0060EFr 3  rr rr                        .word nt_asm_arrow
0060F1r 3  rr rr rr rr  		.word xt_asm_tya, z_asm_tya
0060F5r 3  74 79 61     		.byte "tya"
0060F8r 3               
0060F8r 3               ; Assembler pseudo-instructions, directives and macros
0060F8r 3               
0060F8r 3               nt_asm_arrow:   ; uses same code as HERE, but immediate
0060F8r 3  03 04                        .byte 3, IM
0060FAr 3  rr rr                        .word nt_asm_back_jump
0060FCr 3  rr rr rr rr                  .word xt_asm_arrow, z_asm_arrow
006100r 3  2D 2D 3E                     .byte "-->"
006103r 3               
006103r 3               
006103r 3               nt_asm_back_jump:  ; syntactic sugar, does nothing
006103r 3  02 04                        .byte 2, IM
006105r 3  rr rr                        .word nt_asm_back_branch
006107r 3  rr rr rr rr                  .word xt_asm_back_jump, z_asm_back_jump
00610Br 3  3C 6A                        .byte "<j"
00610Dr 3               
00610Dr 3               nt_asm_back_branch:
00610Dr 3  02 04                        .byte 2, IM
00610Fr 3  rr rr                        .word nt_asm_push_a
006111r 3  rr rr rr rr                  .word xt_asm_back_branch, z_asm_back_branch
006115r 3  3C 62                        .byte "<b"
006117r 3               
006117r 3               nt_asm_push_a:
006117r 3  06 04                        .byte 6, IM
006119r 3  00 00                        .word 0000
00611Br 3  rr rr rr rr                  .word xt_asm_push_a, z_asm_push_a
00611Fr 3  70 75 73 68                  .byte "push-a"
006123r 3  2D 61        
006125r 3               
006125r 3               
006125r 3               
006125r 3               ; END of ASSEMBLER-WORDLIST
006125r 3               
006125r 3               ; END
006125r 3               
006125r 2               .include "strings.asm"          ; Strings, including error messages
006125r 3               ; List of Strings for Tali Forth 2
006125r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
006125r 3               ; First version: 01. Apr 2016 (for Liara Forth)
006125r 3               ; This version: 28. Dec 2018
006125r 3               
006125r 3               ; This file is included by taliforth.asm
006125r 3               
006125r 3               ; ## GENERAL STRINGS
006125r 3               
006125r 3               ; All general strings must be zero-terminated, names start with "s_",
006125r 3               ; aliases with "str_"
006125r 3               
006125r 3               str_ok =              0
006125r 3               str_compile =         1
006125r 3               str_redefined =       2
006125r 3               str_wid_forth =       3
006125r 3               str_abc_lower =       4
006125r 3               str_abc_upper =       5
006125r 3               str_wid_editor =      6
006125r 3               str_wid_assembler =   7
006125r 3               str_wid_root =        8
006125r 3               str_see_flags =       9
006125r 3               str_see_nt =         10
006125r 3               str_see_xt =         11
006125r 3               str_see_size =       12
006125r 3               
006125r 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
006125r 3               ; to tables as error and string numbers.
006125r 3               string_table:
006125r 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
006129r 3  rr rr rr rr  
00612Dr 3  rr rr        
00612Fr 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
006133r 3  rr rr rr rr  
006137r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
00613Br 3  rr rr rr rr  
00613Fr 3               
00613Fr 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
006143r 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
006147r 3  70 69 6C 65  
00614Br 3  64 00        
00614Dr 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
006151r 3  66 69 6E 65  
006155r 3  64 20 00     
006158r 3               
006158r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
00615Cr 3  34 35 36 37  
006160r 3  38 39 61 62  
00617Cr 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
006180r 3  34 35 36 37  
006184r 3  38 39 41 42  
0061A0r 3               
0061A0r 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
0061A4r 3  6D 62 6C 65  
0061A8r 3  72 20 00     
0061ABr 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
0061AFr 3  6F 72 20 00  
0061B3r 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
0061B7r 3  68 20 00     
0061BAr 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
0061BEr 3  20 00        
0061C0r 3               
0061C0r 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
0061C4r 3  73 20 28 43  
0061C8r 3  4F 20 41 4E  
0061DCr 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
0061E0r 3  00           
0061E1r 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
0061E5r 3  00           
0061E6r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
0061EAr 3  20 28 64 65  
0061EEr 3  63 69 6D 61  
0061F7r 3               
0061F7r 3               
0061F7r 3               ; ## ERROR STRINGS
0061F7r 3               
0061F7r 3               ; All error strings must be zero-terminated, all names start with "es_",
0061F7r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
0061F7r 3               ; as well
0061F7r 3               
0061F7r 3               err_allot =        0
0061F7r 3               err_badsource =    1
0061F7r 3               err_compileonly =  2
0061F7r 3               err_defer =        3
0061F7r 3               err_divzero =      4
0061F7r 3               err_noname =       5
0061F7r 3               err_refill =       6
0061F7r 3               err_state =        7
0061F7r 3               err_syntax =       8
0061F7r 3               err_underflow =    9
0061F7r 3               err_negallot =     10
0061F7r 3               err_wordlist =     11
0061F7r 3               err_blockwords =   12
0061F7r 3               
0061F7r 3               error_table:
0061F7r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
0061FBr 3  rr rr rr rr  
0061FFr 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
006203r 3  rr rr rr rr  
006207r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
00620Br 3  rr rr rr rr  
00620Fr 3  rr rr                .word es_blockwords                                    ; 12
006211r 3               
006211r 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
006215r 3  54 20 75 73  
006219r 3  69 6E 67 20  
006232r 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
006236r 3  67 61 6C 20  
00623Ar 3  53 4F 55 52  
006252r 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
006256r 3  72 70 72 65  
00625Ar 3  74 69 6E 67  
006273r 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
006277r 3  52 65 64 20  
00627Br 3  77 6F 72 64  
006290r 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
006294r 3  73 69 6F 6E  
006298r 3  20 62 79 20  
0062A1r 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
0062A5r 3  69 6E 67 20  
0062A9r 3  66 61 69 6C  
0062B1r 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
0062B5r 3  20 63 6F 75  
0062B9r 3  6C 64 20 6E  
0062DFr 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
0062E3r 3  61 64 79 20  
0062E7r 3  69 6E 20 63  
0062F7r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
0062FBr 3  66 69 6E 65  
0062FFr 3  64 20 77 6F  
006306r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
00630Ar 3  6B 20 75 6E  
00630Er 3  64 65 72 66  
006316r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
00631Ar 3  6D 65 6D 6F  
00631Er 3  72 79 20 66  
006332r 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
006336r 3  6F 72 64 6C  
00633Ar 3  69 73 74 73  
006349r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
00634Dr 3  73 65 20 61  
006351r 3  73 73 69 67  
006388r 3               
006388r 3               ; ## ENVIRONMENT STRINGS
006388r 3               
006388r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
006388r 3               ; Length byte first, then the string itself that is not rpt. not
006388r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
006388r 3               ; "envs_".
006388r 3               
006388r 3               ; These return a single-cell number
006388r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
00638Cr 3  55 4E 54 45  
006390r 3  44 2D 53 54  
006398r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
00639Cr 3  4C 44        
00639Er 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
0063A2r 3  44           
0063A3r 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
0063A7r 3  52 45 53 53  
0063ABr 3  2D 55 4E 49  
0063B5r 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
0063B9r 3  4F 52 45 44  
0063BDr 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
0063C1r 3  2D 43 48 41  
0063C5r 3  52           
0063C6r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
0063CAr 3  2D 4E        
0063CCr 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
0063D0r 3  2D 55        
0063D2r 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
0063D6r 3  55 52 4E 2D  
0063DAr 3  53 54 41 43  
0063E5r 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
0063E9r 3  43 4B 2D 43  
0063EDr 3  45 4C 4C 53  
0063F1r 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
0063F5r 3  44 4C 49 53  
0063F9r 3  54 53        
0063FBr 3               
0063FBr 3               ; These return a double-cell number
0063FBr 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
0063FFr 3  2D 44        
006401r 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
006405r 3  2D 55 44     
006408r 3               
006408r 3               ; END
006408r 3               
006408r 2               
006408r 2               
006408r 2               ; =====================================================================
006408r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
006408r 2               
006408r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
006408r 2               ; at compile time so they are available at run time. Words that use this
006408r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
006408r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
006408r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
006408r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
006408r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
006408r 2               ; Bowie.
006408r 2               
006408r 2               ;               ldy #>addr      ; MSB   ; "Young"
006408r 2               ;               lda #<addr      ; LSB   ; "Americans"
006408r 2               ;               jsr cmpl_subroutine
006408r 2               
006408r 2               ; Also, we keep a routine here to compile a single byte passed through A.
006408r 2               
006408r 2               cmpl_subroutine:
006408r 2                               ; This is the entry point to compile JSR <ADDR>
006408r 2  48                           pha             ; save LSB of address
006409r 2  A9 20                        lda #$20        ; load opcode for JSR
00640Br 2  80 03                        bra cmpl_common
00640Dr 2               cmpl_jump:
00640Dr 2                               ; This is the entry point to compile JMP <ADDR>
00640Dr 2  48                           pha             ; save LSB of address
00640Er 2  A9 4C                        lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
006410r 2               cmpl_common:
006410r 2                               ; At this point, A contains the opcode to be compiled,
006410r 2                               ; the LSB of the address is on the 65c02 stack, and the MSB of
006410r 2                               ; the address is in Y
006410r 2  20 rr rr                     jsr cmpl_a      ; compile opcode
006413r 2  68                           pla             ; retrieve address LSB; fall thru to cmpl_word
006414r 2               cmpl_word:
006414r 2                               ; This is the entry point to compile a word (little-endian)
006414r 2  20 rr rr                     jsr cmpl_a      ; compile LSB of address
006417r 2  98                           tya             ; fall thru for MSB
006418r 2               cmpl_a:
006418r 2                               ; This is the entry point to compile a single byte which
006418r 2                               ; is passed in A. The built-in assembler assumes that this
006418r 2                               ; routine does not modify Y.
006418r 2  92 00                        sta (cp)
00641Ar 2  E6 00                        inc cp
00641Cr 2  D0 02                        bne _done
00641Er 2  E6 01                        inc cp+1
006420r 2               _done:
006420r 2  60                           rts
006421r 2               
006421r 2               
006421r 2               
006421r 2               ; =====================================================================
006421r 2               ; CODE FIELD ROUTINES
006421r 2               
006421r 2               doconst:
006421r 2                       ; """Execute a CONSTANT: Push the data in the first two bytes of
006421r 2                       ; the Data Field onto the Data Stack
006421r 2                       ; """
006421r 2  CA                           dex             ; make room for constant
006422r 2  CA                           dex
006423r 2               
006423r 2                               ; The value we need is stored in the two bytes after the
006423r 2                               ; JSR return address, which in turn is what is on top of
006423r 2                               ; the Return Stack
006423r 2  68                           pla             ; LSB of return address
006424r 2  85 24                        sta tmp1
006426r 2  68                           pla             ; MSB of return address
006427r 2  85 25                        sta tmp1+1
006429r 2               
006429r 2                               ; Start LDY with 1 instead of 0 because of how JSR stores
006429r 2                               ; the return address on the 65c02
006429r 2  A0 01                        ldy #1
00642Br 2  B1 24                        lda (tmp1),y
00642Dr 2  95 00                        sta 0,x
00642Fr 2  C8                           iny
006430r 2  B1 24                        lda (tmp1),y
006432r 2  95 01                        sta 1,x
006434r 2               
006434r 2                               ; This takes us back to the original caller, not the
006434r 2                               ; DOCONST caller
006434r 2  60                           rts
006435r 2               
006435r 2               
006435r 2               dodefer:
006435r 2                       ; """Execute a DEFER statement at runtime: Execute the address we
006435r 2                       ; find after the caller in the Data Field
006435r 2                       ; """
006435r 2                               ; The xt we need is stored in the two bytes after the JSR
006435r 2                               ; return address, which is what is on top of the Return
006435r 2                               ; Stack. So all we have to do is replace our return jump
006435r 2                               ; with what we find there
006435r 2  68                           pla             ; LSB
006436r 2  85 24                        sta tmp1
006438r 2  68                           pla             ; MSB
006439r 2  85 25                        sta tmp1+1
00643Br 2               
00643Br 2  A0 01                        ldy #1
00643Dr 2  B1 24                        lda (tmp1),y
00643Fr 2  85 26                        sta tmp2
006441r 2  C8                           iny
006442r 2  B1 24                        lda (tmp1),y
006444r 2  85 27                        sta tmp2+1
006446r 2               
006446r 2  6C 26 00                     jmp (tmp2)      ; This is actually a jump to the new target
006449r 2               
006449r 2               defer_error:
006449r 2                               ; """Error routine for undefined DEFER: Complain and abort"""
006449r 2  A9 03                        lda #err_defer
00644Br 2  4C rr rr                     jmp error
00644Er 2               
00644Er 2               dodoes:
00644Er 2                       ; """Execute the runtime portion of DOES>. See DOES> and
00644Er 2                       ; docs/create-does.txt for details and
00644Er 2                       ; http://www.bradrodriguez.com/papers/moving3.htm
00644Er 2                       ; """
00644Er 2                               ; Assumes the address of the CFA of the original defining word
00644Er 2                               ; (say, CONSTANT) is on the top of the Return Stack. Save it
00644Er 2                               ; for a later jump, adding one byte because of the way the
00644Er 2                               ; 6502 works
00644Er 2  7A                           ply             ; LSB
00644Fr 2  68                           pla             ; MSB
006450r 2  C8                           iny
006451r 2  D0 01                        bne @1
006453r 2  1A                           inc
006454r 2               @1:
006454r 2  84 26                        sty tmp2
006456r 2  85 27                        sta tmp2+1
006458r 2               
006458r 2                               ; Next on the Return Stack should be the address of the PFA of
006458r 2                               ; the calling defined word (say, the name of whatever constant we
006458r 2                               ; just defined). Move this to the Data Stack, again adding one.
006458r 2  CA                           dex
006459r 2  CA                           dex
00645Ar 2               
00645Ar 2  7A                           ply
00645Br 2  68                           pla
00645Cr 2  C8                           iny
00645Dr 2  D0 01                        bne @2
00645Fr 2  1A                           inc
006460r 2               @2:
006460r 2  94 00                        sty 0,x         ; LSB
006462r 2  95 01                        sta 1,x         ; MSB
006464r 2               
006464r 2                               ; This leaves the return address from the original main routine
006464r 2                               ; on top of the Return Stack. We leave that untouched and jump
006464r 2                               ; to the special code of the defining word. It's RTS instruction
006464r 2                               ; will take us back to the main routine
006464r 2  6C 26 00                     jmp (tmp2)
006467r 2               
006467r 2               
006467r 2               dovar:
006467r 2                       ; """Execute a variable: Push the address of the first bytes of
006467r 2                       ; the Data Field onto the stack. This is called with JSR so we
006467r 2                       ; can pick up the address of the calling variable off the 65c02's
006467r 2                       ; stack. The final RTS takes us to the original caller of the
006467r 2                       ; routine that itself called DOVAR. This is the default
006467r 2                       ; routine installed with CREATE.
006467r 2                       ; """
006467r 2                               ; Pull the return address off the machine's stack, adding
006467r 2                               ; one because of the way the 65c02 handles subroutines
006467r 2  7A                           ply             ; LSB
006468r 2  68                           pla             ; MSB
006469r 2  C8                           iny
00646Ar 2  D0 01                        bne @1
00646Cr 2  1A                           inc
00646Dr 2               @1:
00646Dr 2  CA                           dex
00646Er 2  CA                           dex
00646Fr 2               
00646Fr 2  95 01                        sta 1,x
006471r 2  98                           tya
006472r 2  95 00                        sta 0,x
006474r 2               
006474r 2  60                           rts
006475r 2               
006475r 2               ; =====================================================================
006475r 2               ; LOW LEVEL HELPER FUNCTIONS
006475r 2               
006475r 2               byte_to_ascii:
006475r 2                       ; """Convert byte in A to two ASCII hex digits and EMIT them"""
006475r 2               .scope
006475r 2  48                           pha
006476r 2  4A                           lsr             ; convert high nibble first
006477r 2  4A                           lsr
006478r 2  4A                           lsr
006479r 2  4A                           lsr
00647Ar 2  20 rr rr                     jsr _nibble_to_ascii
00647Dr 2  68                           pla
00647Er 2               
00647Er 2                               ; fall through to _nibble_to_ascii
00647Er 2               
00647Er 2               _nibble_to_ascii:
00647Er 2                       ; """Private helper function for byte_to_ascii: Print lower nibble
00647Er 2                       ; of A and and EMIT it. This does the actual work.
00647Er 2                       ; """
00647Er 2  29 0F                        and #$0F
006480r 2  09 30                        ora #'0'
006482r 2  C9 3A                        cmp #$3A        ; '9+1
006484r 2  90 02                        bcc @1
006486r 2  69 06                        adc #$06
006488r 2               
006488r 2  4C rr rr     @1:               jmp emit_a
00648Br 2               
00648Br 2  60                           rts
00648Cr 2               .endscope
00648Cr 2               
00648Cr 2               compare_16bit:
00648Cr 2                       ; """Compare TOS/NOS and return results in form of the 65c02 flags
00648Cr 2                       ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
00648Cr 2                       ; also http://www.6502.org/tutorials/compare_beyond.html
00648Cr 2                       ; For signed numbers, Z signals equality and N which number is larger:
00648Cr 2                       ;       if TOS = NOS: Z=1 and N=0
00648Cr 2                       ;       if TOS > NOS: Z=0 and N=0
00648Cr 2                       ;       if TOS < NOS: Z=0 and N=1
00648Cr 2                       ; For unsigned numbers, Z signals equality and C which number is larger:
00648Cr 2                       ;       if TOS = NOS: Z=1 and N=0
00648Cr 2                       ;       if TOS > NOS: Z=0 and C=1
00648Cr 2                       ;       if TOS < NOS: Z=0 and C=0
00648Cr 2                       ; Compared to the book routine, WORD1 (MINUED) is TOS
00648Cr 2                       ;                               WORD2 (SUBTRAHEND) is NOS
00648Cr 2                       ; """
00648Cr 2               .scope
00648Cr 2                               ; Compare LSB first to set the carry flag
00648Cr 2  B5 00                        lda 0,x                 ; LSB of TOS
00648Er 2  D5 02                        cmp 2,x                 ; LSB of NOS
006490r 2  F0 0A                        beq _equal
006492r 2               
006492r 2                               ; LSBs are not equal, compare MSB
006492r 2  B5 01                        lda 1,x                 ; MSB of TOS
006494r 2  F5 03                        sbc 3,x                 ; MSB of NOS
006496r 2  09 01                        ora #1                  ; Make zero flag 0 because not equal
006498r 2  70 08                        bvs _overflow
00649Ar 2  80 08                        bra _not_equal
00649Cr 2               _equal:
00649Cr 2                               ; Low bytes are equal, so we compare high bytes
00649Cr 2  B5 01                        lda 1,x                 ; MSB of TOS
00649Er 2  F5 03                        sbc 3,x                 ; MSB of NOS
0064A0r 2  50 04                        bvc _done
0064A2r 2               _overflow:
0064A2r 2                               ; Handle overflow because we use signed numbers
0064A2r 2  49 80                        eor #$80                ; complement negative flag
0064A4r 2               _not_equal:
0064A4r 2  09 01                        ora #1                  ; if overflow, we can't be eqal
0064A6r 2               _done:
0064A6r 2  60                           rts
0064A7r 2               .endscope
0064A7r 2               
0064A7r 2               current_to_dp:
0064A7r 2                       ; """Look up the current (compilation) dictionary pointer
0064A7r 2                       ; in the wordlist set and put it into the dp zero-page
0064A7r 2                       ; variable. Uses A and Y.
0064A7r 2                       ; """
0064A7r 2                               ; Determine which wordlist is current
0064A7r 2  A0 04                        ldy #current_offset
0064A9r 2  B1 1E                        lda (up),y      ; current is a byte variable
0064ABr 2  0A                           asl             ; turn it into an offset (in cells)
0064ACr 2               
0064ACr 2                               ; Get the dictionary pointer for that wordlist.
0064ACr 2  18                           clc
0064ADr 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
0064AFr 2  A8                           tay
0064B0r 2  B1 1E                        lda (up),y              ; get the dp for that wordlist.
0064B2r 2  85 02                        sta dp
0064B4r 2  C8                           iny
0064B5r 2  B1 1E                        lda (up),y
0064B7r 2  85 03                        sta dp+1
0064B9r 2               
0064B9r 2  60                           rts
0064BAr 2               
0064BAr 2               
0064BAr 2               dp_to_current:
0064BAr 2                       ; """Look up which wordlist is current and update its pointer
0064BAr 2                       ; with the value in dp. Uses A and Y.
0064BAr 2                       ; """
0064BAr 2                               ; Determine which wordlist is current
0064BAr 2  A0 04                        ldy #current_offset
0064BCr 2  B1 1E                        lda (up),y      ; current is a byte variable
0064BEr 2  0A                           asl             ; turn it into an offset (in cells)
0064BFr 2               
0064BFr 2                               ; Get the dictionary pointer for that wordlist.
0064BFr 2  18                           clc
0064C0r 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
0064C2r 2  A8                           tay
0064C3r 2  A5 02                        lda dp
0064C5r 2  91 1E                        sta (up),y              ; get the dp for that wordlist.
0064C7r 2  C8                           iny
0064C8r 2  A5 03                        lda dp+1
0064CAr 2  91 1E                        sta (up),y
0064CCr 2               
0064CCr 2  60                           rts
0064CDr 2               
0064CDr 2               interpret:
0064CDr 2               .scope
0064CDr 2                       ; """Core routine for the interpreter called by EVALUATE and QUIT.
0064CDr 2                       ; Process one line only. Assumes that the address of name is in
0064CDr 2                       ; cib and the length of the whole input line string is in ciblen
0064CDr 2                       ; """
0064CDr 2                               ; Normally we would use PARSE here with the SPACE character as
0064CDr 2                               ; a parameter (PARSE replaces WORD in modern Forths). However,
0064CDr 2                               ; Gforth's PARSE-NAME makes more sense as it uses spaces as
0064CDr 2                               ; delimiters per default and skips any leading spaces, which
0064CDr 2                               ; PARSE doesn't
0064CDr 2               _loop:
0064CDr 2  20 rr rr                     jsr xt_parse_name       ; ( "string" -- addr u )
0064D0r 2               
0064D0r 2                               ; If PARSE-NAME returns 0 (empty line), no characters were left
0064D0r 2                               ; in the line and we need to go get a new line
0064D0r 2  B5 00                        lda 0,x
0064D2r 2  15 01                        ora 1,x
0064D4r 2  F0 70                        beq _line_done
0064D6r 2               
0064D6r 2                               ; Go to FIND-NAME to see if this is a word we know. We have to
0064D6r 2                               ; make a copy of the address in case it isn't a word we know and
0064D6r 2                               ; we have to go see if it is a number
0064D6r 2  20 rr rr                     jsr xt_two_dup          ; ( addr u -- addr u addr u )
0064D9r 2  20 rr rr                     jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
0064DCr 2               
0064DCr 2                               ; A zero signals that we didn't find a word in the Dictionary
0064DCr 2  B5 00                        lda 0,x
0064DEr 2  15 01                        ora 1,x
0064E0r 2  D0 28                        bne _got_name_token
0064E2r 2               
0064E2r 2                               ; We didn't get any nt we know of, so let's see if this is
0064E2r 2                               ; a number.
0064E2r 2  E8                           inx                     ; ( addr u 0 -- addr u )
0064E3r 2  E8                           inx
0064E4r 2               
0064E4r 2                               ; If the number conversion doesn't work, NUMBER will do the
0064E4r 2                               ; complaining for us
0064E4r 2  20 rr rr                     jsr xt_number           ; ( addr u -- u|d )
0064E7r 2               
0064E7r 2                               ; Otherweise, if we're interpreting, we're done
0064E7r 2  A5 16                        lda state
0064E9r 2  F0 E2                        beq _loop
0064EBr 2               
0064EBr 2                               ; We're compiling, so there is a bit more work.  Check
0064EBr 2                               ; status bit 5 to see if it's a single or double-cell
0064EBr 2                               ; number.
0064EBr 2  A9 20                        lda #$20
0064EDr 2  24 20                        bit status
0064EFr 2  F0 0D                        beq _single_number
0064F1r 2               
0064F1r 2                               ; It's a double cell number.  If we swap the
0064F1r 2                               ; upper and lower half, we can use the literal_runtime twice
0064F1r 2                               ; to compile it into the dictionary.
0064F1r 2  20 rr rr                     jsr xt_swap
0064F4r 2  A0 rr                        ldy #>literal_runtime
0064F6r 2  A9 rr                        lda #<literal_runtime
0064F8r 2  20 rr rr                     jsr cmpl_subroutine
0064FBr 2               
0064FBr 2                               ; compile our number
0064FBr 2  20 rr rr                     jsr xt_comma
0064FEr 2               
0064FEr 2                               ; Fall into _single_number to process the other half.
0064FEr 2               _single_number:
0064FEr 2  A0 rr                        ldy #>literal_runtime
006500r 2  A9 rr                        lda #<literal_runtime
006502r 2  20 rr rr                     jsr cmpl_subroutine
006505r 2               
006505r 2                               ; compile our number
006505r 2  20 rr rr                     jsr xt_comma
006508r 2               
006508r 2                               ; That was so much fun, let's do it again!
006508r 2  80 C3                        bra _loop
00650Ar 2               
00650Ar 2               _got_name_token:
00650Ar 2                               ; We have a known word's nt TOS. We're going to need its xt
00650Ar 2                               ; though, which is four bytes father down.
00650Ar 2               
00650Ar 2                               ; We arrive here with ( addr u nt ), so we NIP twice
00650Ar 2  B5 00                        lda 0,x
00650Cr 2  95 04                        sta 4,x
00650Er 2  B5 01                        lda 1,x
006510r 2  95 05                        sta 5,x
006512r 2               
006512r 2  E8                           inx
006513r 2  E8                           inx
006514r 2  E8                           inx
006515r 2  E8                           inx                     ; ( nt )
006516r 2               
006516r 2                               ; Save a version of nt for error handling and compilation stuff
006516r 2  B5 00                        lda 0,x
006518r 2  85 22                        sta tmpbranch
00651Ar 2  B5 01                        lda 1,x
00651Cr 2  85 23                        sta tmpbranch+1
00651Er 2               
00651Er 2  20 rr rr                     jsr xt_name_to_int      ; ( nt - xt )
006521r 2               
006521r 2                               ; See if we are in interpret or compile mode, 0 is interpret
006521r 2  A5 16                        lda state
006523r 2  D0 13                        bne _compile
006525r 2               
006525r 2                               ; We are interpreting, so EXECUTE the xt that is TOS. First,
006525r 2                               ; though, see if this isn't a compile-only word, which would be
006525r 2                               ; illegal. The status byte is the second one of the header.
006525r 2  A0 01                        ldy #1
006527r 2  B1 22                        lda (tmpbranch),y
006529r 2  29 01                        and #CO                 ; mask everything but Compile Only bit
00652Br 2  F0 05                        beq _interpret
00652Dr 2               
00652Dr 2  A9 02                        lda #err_compileonly
00652Fr 2  4C rr rr                     jmp error
006532r 2               
006532r 2               _interpret:
006532r 2                               ; We JSR to EXECUTE instead of calling the xt directly because
006532r 2                               ; the RTS of the word we're executing will bring us back here,
006532r 2                               ; skipping EXECUTE completely during RTS. If we were to execute
006532r 2                               ; xt directly, we have to fool around with the Return Stack
006532r 2                               ; instead, which is actually slightly slower
006532r 2  20 rr rr                     jsr xt_execute
006535r 2               
006535r 2                               ; That's quite enough for this word, let's get the next one
006535r 2  4C rr rr                     jmp _loop
006538r 2               
006538r 2               _compile:
006538r 2                               ; We're compiling! However, we need to see if this is an
006538r 2                               ; IMMEDIATE word, which would mean we execute it right now even
006538r 2                               ; during compilation mode. Fortunately, we saved the nt so life
006538r 2                               ; is easier. The flags are in the second byte of the header
006538r 2  A0 01                        ldy #1
00653Ar 2  B1 22                        lda (tmpbranch),y
00653Cr 2  29 04                        and #IM                 ; Mask all but IM bit
00653Er 2  D0 F2                        bne _interpret          ; IMMEDIATE word, execute right now
006540r 2               
006540r 2                               ; Compile the xt into the Dictionary with COMPILE,
006540r 2  20 rr rr                     jsr xt_compile_comma
006543r 2  4C rr rr                     jmp _loop
006546r 2               
006546r 2               _line_done:
006546r 2                               ; drop stuff from PARSE_NAME
006546r 2  E8                           inx
006547r 2  E8                           inx
006548r 2  E8                           inx
006549r 2  E8                           inx
00654Ar 2               
00654Ar 2  60                           rts
00654Br 2               .endscope
00654Br 2               
00654Br 2               
00654Br 2               is_printable:
00654Br 2               .scope
00654Br 2                       ; """Given a character in A, check if it is a printable ASCII
00654Br 2                       ; character in the range from $20 to $7E inclusive. Returns the
00654Br 2                       ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
00654Br 2                       ; is printable. Keeps A. See
00654Br 2                       ; http://www.obelisk.me.uk/6502/algorithms.html for a
00654Br 2                       ; discussion of various ways to do this
00654Br 2  C9 20                        cmp #AscSP              ; $20
00654Dr 2  90 08                        bcc _done
00654Fr 2  C9 7F                        cmp #'~' + 1             ; $7E
006551r 2  B0 03                        bcs _failed
006553r 2               
006553r 2  38                           sec
006554r 2  80 01                        bra _done
006556r 2               _failed:
006556r 2  18                           clc
006557r 2               _done:
006557r 2  60                           rts
006558r 2               .endscope
006558r 2               
006558r 2               
006558r 2               is_whitespace:
006558r 2               .scope
006558r 2                       ; """Given a character in A, check if it is a whitespace
006558r 2                       ; character, that is, an ASCII value from 0 to 32 (where
006558r 2                       ; 32 is SPACE). Returns the result in the Carry Flag:
006558r 2                       ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
006558r 2                       ; that it is whitespace. See PARSE and PARSE-NAME for
006558r 2                       ; a discussion of the uses. Does not change A or Y.
006558r 2  C9 00                        cmp #00         ; explicit comparison to leave Y untouched
00655Ar 2  90 08                        bcc _done
00655Cr 2               
00655Cr 2  C9 21                        cmp #AscSP+1
00655Er 2  B0 03                        bcs _failed
006560r 2               
006560r 2  38                           sec
006561r 2  80 01                        bra _done
006563r 2               _failed:
006563r 2  18                           clc
006564r 2               _done:
006564r 2  60                           rts
006565r 2               .endscope
006565r 2               
006565r 2               
006565r 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
006565r 2               ; required for the word. This routine flows into the generic error handling
006565r 2               ; code
006565r 2               underflow_1:
006565r 2                       ; """Make sure we have at least one cell on the Data Stack"""
006565r 2  E0 77                        cpx #dsp0-1
006567r 2  10 10                        bpl underflow_error
006569r 2  60                           rts
00656Ar 2               underflow_2:
00656Ar 2                       ; """Make sure we have at least two cells on the Data Stack"""
00656Ar 2  E0 75                        cpx #dsp0-3
00656Cr 2  10 0B                        bpl underflow_error
00656Er 2  60                           rts
00656Fr 2               underflow_3:
00656Fr 2                       ; """Make sure we have at least three cells on the Data Stack"""
00656Fr 2  E0 73                        cpx #dsp0-5
006571r 2  10 06                        bpl underflow_error
006573r 2  60                           rts
006574r 2               underflow_4:
006574r 2                       ; """Make sure we have at least four cells on the Data Stack"""
006574r 2  E0 71                        cpx #dsp0-7
006576r 2  10 01                        bpl underflow_error
006578r 2  60                           rts
006579r 2               
006579r 2               underflow_error:
006579r 2                               ; Entry for COLD/ABORT/QUIT
006579r 2  A9 09                        lda #err_underflow      ; fall through to error
00657Br 2               
00657Br 2               error:
00657Br 2                       ; """Given the error number in a, print the associated error string and
00657Br 2                       ; call abort. Uses tmp3.
00657Br 2                       ; """
00657Br 2  0A                           asl
00657Cr 2  A8                           tay
00657Dr 2  B9 rr rr                     lda error_table,y
006580r 2  85 28                        sta tmp3                ; LSB
006582r 2  C8                           iny
006583r 2  B9 rr rr                     lda error_table,y
006586r 2  85 29                        sta tmp3+1              ; MSB
006588r 2               
006588r 2  20 rr rr                     jsr print_common
00658Br 2  20 rr rr                     jsr xt_cr
00658Er 2  4C rr rr                     jmp xt_abort            ; no jsr, as we clobber return stack
006591r 2               
006591r 2               
006591r 2               ; =====================================================================
006591r 2               ; PRINTING ROUTINES
006591r 2               
006591r 2               ; We distinguish two types of print calls, both of which take the string number
006591r 2               ; (see strings.asm) in A:
006591r 2               
006591r 2               ;       print_string       - with a line feed
006591r 2               ;       print_string_no_lf - without a line feed
006591r 2               
006591r 2               ; In addition, print_common provides a lower-level alternative for error
006591r 2               ; handling and anything else that provides the address of the
006591r 2               ; zero-terminated string directly in tmp3. All of those routines assume that
006591r 2               ; printing should be more concerned with size than speed, because anything to
006591r 2               ; do with humans reading text is going to be slow.
006591r 2               
006591r 2               print_string_no_lf:
006591r 2                       ; """Given the number of a zero-terminated string in A, print it to the
006591r 2                       ; current output without adding a LF. Uses Y and tmp3 by falling
006591r 2                       ; through to print_common
006591r 2                       ; """
006591r 2                               ; Get the entry from the string table
006591r 2  0A                           asl
006592r 2  A8                           tay
006593r 2  B9 rr rr                     lda string_table,y
006596r 2  85 28                        sta tmp3                ; LSB
006598r 2  C8                           iny
006599r 2  B9 rr rr                     lda string_table,y
00659Cr 2  85 29                        sta tmp3+1              ; MSB
00659Er 2               
00659Er 2                               ; fall through to print_common
00659Er 2               print_common:
00659Er 2                       ; """Common print routine used by both the print functions and
00659Er 2                       ; the error printing routine. Assumes string address is in tmp3. Uses
00659Er 2                       ; Y.
00659Er 2                       ; """
00659Er 2               .scope
00659Er 2  A0 00                        ldy #0
0065A0r 2               _loop:
0065A0r 2  B1 28                        lda (tmp3),y
0065A2r 2  F0 06                        beq _done               ; strings are zero-terminated
0065A4r 2               
0065A4r 2  20 rr rr                     jsr emit_a              ; allows vectoring via output
0065A7r 2  C8                           iny
0065A8r 2  80 F6                        bra _loop
0065AAr 2               _done:
0065AAr 2  60                           rts
0065ABr 2               .endscope
0065ABr 2               
0065ABr 2               print_string:
0065ABr 2                       ; """Print a zero-terminated string to the console/screen, adding a LF.
0065ABr 2                       ; We do not check to see if the index is out of range. Uses tmp3.
0065ABr 2                       ; """
0065ABr 2  20 rr rr                     jsr print_string_no_lf
0065AEr 2  4C rr rr                     jmp xt_cr               ; JSR/RTS because never compiled
0065B1r 2               
0065B1r 2               
0065B1r 2               print_u:
0065B1r 2                       ; """basic printing routine used by higher-level constructs,
0065B1r 2                       ; the equivalent of the forth word  0 <# #s #> type  which is
0065B1r 2                       ; basically u. without the space at the end. used for various
0065B1r 2                       ; outputs
0065B1r 2                       ; """
0065B1r 2  20 rr rr                     jsr xt_zero                     ; 0
0065B4r 2  20 rr rr                     jsr xt_less_number_sign         ; <#
0065B7r 2  20 rr rr                     jsr xt_number_sign_s            ; #S
0065BAr 2  20 rr rr                     jsr xt_number_sign_greater      ; #>
0065BDr 2  4C rr rr                     jmp xt_type                     ; JSR/RTS because never compiled
0065C0r 2               
0065C0r 2               ; END
0065C0r 2               
0065C0r 1               
0065C0r 1               ; =====================================================================
0065C0r 1               ; FINALLY
0065C0r 1               
0065C0r 1               ; Of the 32 KiB we use, 24 KiB are reserved for Tali (from $8000 to $DFFF)
0065C0r 1               ; and the last eight (from $E000 to $FFFF) are left for whatever the user
0065C0r 1               ; wants to use them for.
0065C0r 1               
0065C0r 1               
0065C0r 1               ; ******************************************************************
0065C0r 1               ; *  Hardware definitions for Planck 6502 computer                 *
0065C0r 1               ; *  Change these depending on the slot in which                   *
0065C0r 1               ; *  you want to put each card                                     *
0065C0r 1               ; *  As a reminder here are the addresses for each slot:           *
0065C0r 1               ; *                                                                *
0065C0r 1               ; * START ADDRESS    |   END ADDRESS       |     DESCRIPTION       *
0065C0r 1               ; * 0xFF80           |   0xFF8F            | SLOT1 Selected        *
0065C0r 1               ; * 0xFF90           |   0xFF9F            | SLOT2 Selected        *
0065C0r 1               ; * 0xFFA0           |   0xFFAF            | SLOT3 Selected        *
0065C0r 1               ; * 0xFFB0           |   0xFFBF            | SLOT4 Selected        *
0065C0r 1               ; * 0xFFC0           |   0xFFCF            | SLOT5 Selected        *
0065C0r 1               ; ******************************************************************
0065C0r 1               ;
0065C0r 1               ;
0065C0r 1               
0065C0r 1               .segment "KERNEL"
000000r 1               
000000r 1               ; Default kernel file for Tali Forth 2
000000r 1               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 1               ; First version: 19. Jan 2014
000000r 1               ; This version: 18. Feb 2018
000000r 1               ;
000000r 1               ; This section attempts to isolate the hardware-dependent parts of Tali
000000r 1               ; Forth 2 to make it easier for people to port it to their own machines.
000000r 1               ; Ideally, you shouldn't have to touch any other files. There are three
000000r 1               ; routines and one string that must be present for Tali to run:
000000r 1               ;
000000r 1               ;       kernel_init - Initialize the low-level hardware
000000r 1               ;       kernel_getc - Get single character in A from the keyboard (blocks)
000000r 1               ;       kernel_putc - Prints the character in A to the screen
000000r 1               ;       s_kernel_id - The zero-terminated string printed at boot
000000r 1               ;
000000r 1               
000000r 1               
000000r 1               v_reset:
000000r 1               kernel_init:
000000r 1                       ; """Initialize the hardware. This is called with a JMP and not
000000r 1                       ; a JSR because we don't have anything set up for that yet. With
000000r 1                       ; py65mon, of course, this is really easy. -- At the end, we JMP
000000r 1                       ; back to the label forth to start the Forth system.
000000r 1                       ; """
000000r 1               
000000r 1  A9 01                lda #1
000002r 1  8D 81 FF             sta PORTA
000005r 1  A9 FF                lda #$FF
000007r 1  8D 83 FF             sta DDRA
00000Ar 1  8D 82 FF             sta DDRB
00000Dr 1               
00000Dr 1  A0 04                ldy #04
00000Fr 1  20 rr rr             jsr delay_long
000012r 1               
000012r 1  20 rr rr             jsr video_init
000015r 1               
000015r 1               
000015r 1  20 rr rr             jsr ps2_init
000018r 1  20 rr rr             jsr timer_init
00001Br 1  20 rr rr             jsr Init_ACIA
00001Er 1               
00001Er 1  20 rr rr             jsr lcd_init
000021r 1               
000021r 1               v_nmi:
000021r 1  58                   cli
000022r 1                       ; lda #$55
000022r 1                       ; sta PORTA
000022r 1                       ; We've successfully set everything up, so print the kernel
000022r 1                       ; string
000022r 1  A2 00                ldx #0
000024r 1               @loop:
000024r 1  BD rr rr             lda s_kernel_id,x
000027r 1  F0 06                beq @done
000029r 1  20 rr rr             jsr kernel_putc
00002Cr 1  E8                   inx
00002Dr 1  80 F5                bra @loop
00002Fr 1               @done:
00002Fr 1  A9 01                lda #1
000031r 1  8D 80 FF             sta PORTB
000034r 1  4C rr rr             jmp forth
000037r 1               
000037r 1               
000037r 1               
000037r 1               ; The Planck computer runs Tali Forth 2 as the OS, to there is nowhere to go back to.
000037r 1               ; Just restart TALI.
000037r 1               platform_bye:
000037r 1  4C rr rr             jmp kernel_init
00003Ar 1               
00003Ar 1               
00003Ar 1                   ;; Init ACIA to 115200 8,N,1
00003Ar 1                   ;; Uses: A (not restored)
00003Ar 1               Init_ACIA:
00003Ar 1  8D E1 FF             sta ACIA_STATUS        ; soft reset (value not important)
00003Dr 1                                               ; set specific modes and functions
00003Dr 1  64 96                stz has_acia
00003Fr 1  A9 0B                lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000041r 1                       ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
000041r 1  8D E2 FF             sta ACIA_COMMAND        ; store to the command register
000044r 1  AD E2 FF             lda ACIA_COMMAND        ; load command register again
000047r 1  C9 0B                cmp #$0B                ; if not the same
000049r 1  D0 10                bne acia_absent         ; then it means the ACIA is not connected
00004Br 1  AD E1 FF             lda ACIA_STATUS         ; Read the ACAI status to
00004Er 1  29 60                and #$60                ; check if present or absent
000050r 1  D0 09                bne acia_absent
000052r 1  A9 01                lda #1
000054r 1  85 96                sta has_acia           ; remember that ACIA is here
000056r 1  A9 10                lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000058r 1                       ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000058r 1  8D E3 FF             sta ACIA_CTRL          ; program the ctl register
00005Br 1               
00005Br 1               acia_absent:
00005Br 1  A0 14                ldy #20
00005Dr 1               aa_loop:
00005Dr 1  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
000060r 1  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
000063r 1  88                   dey
000064r 1  D0 F7                bne aa_loop
000066r 1               aa_end:
000066r 1  60                   rts
000067r 1               
000067r 1               
000067r 1                       ;; Get_Char - get a character from the serial port into A.
000067r 1                       ;; Set the carry flag if char is valid.
000067r 1                       ;; Return immediately with carry flag clear if no char available.
000067r 1                       ;; Uses: A (return value)
000067r 1               Get_Char:
000067r 1  A5 96                lda has_acia                    ; if no ACIA
000069r 1  F0 0F                beq no_acia_char_available      ; exit now
00006Br 1  AD E1 FF             lda ACIA_STATUS                 ; Read the ACAI status to
00006Er 1  29 08                and #$08                        ; Check if there is character in the receiver
000070r 1  F0 08                beq no_acia_char_available      ; Exit now if we don't get one.
000072r 1  AD E0 FF             lda ACIA_DATA                   ; Load it into the accumulator
000075r 1  38                   sec                             ; Set Carry to show we got a character
000076r 1  20 rr rr             jsr check_ctrl_c
000079r 1  60                   rts                             ; Return
00007Ar 1               
00007Ar 1               no_acia_char_available:                 ; no ACIA char available
00007Ar 1  DA                   phx                             ; save X
00007Br 1  A6 85                ldx KB_BUF_R_PTR                ; check the keyboard buffer
00007Dr 1  BD 01 7B             lda KB_BUF, x
000080r 1  F0 0B                beq no_ps2_char_available       ; exit if nothing found
000082r 1  9E 01 7B             stz KB_BUF, x                   ; if there was a character, reset this buffer cell
000085r 1  E6 85                inc KB_BUF_R_PTR                ; and increment the read pointer
000087r 1               
000087r 1  38                   sec                             ; mark character present
000088r 1  FA                   plx                             ; restore X
000089r 1  20 rr rr             jsr check_ctrl_c
00008Cr 1  60                   rts                             ; return
00008Dr 1               no_ps2_char_available:                  ; no keyboard char
00008Dr 1  E6 85                inc KB_BUF_R_PTR                ; increment read pointer for next time
00008Fr 1  FA                   plx                             ; restore X
000090r 1               no_char_available:
000090r 1  18                   clc                             ; Indicate no char available.
000091r 1  60                   rts                             ; return
000092r 1               
000092r 1               
000092r 1               
000092r 1               
000092r 1               
000092r 1               kernel_getc:
000092r 1                       ; """Get a single character from the keyboard (waits for key).
000092r 1                       ; """
000092r 1                       ;; Get_Char_Wait - same as Get_Char only blocking.
000092r 1                       ;; Uses: A (return value)
000092r 1               Get_Char_Wait:
000092r 1  20 rr rr             jsr Get_Char
000095r 1  90 FB                bcc Get_Char_Wait
000097r 1  60                   rts
000098r 1               
000098r 1               check_ctrl_c:
000098r 1                       ;; Check if we have ctrl-C character, if so jump to nmi
000098r 1  C9 03                cmp #$03
00009Ar 1  D0 03                bne exit_ctrl_c
00009Cr 1               
00009Cr 1               
00009Cr 1  4C rr rr             jmp xt_abort
00009Fr 1               
00009Fr 1               exit_ctrl_c:
00009Fr 1  38                   sec
0000A0r 1  60                   rts
0000A1r 1               
0000A1r 1               kernel_putc:
0000A1r 1                       ; """Print a single character to the console. """
0000A1r 1                       ;; Send_Char - send character in A out serial port.
0000A1r 1                       ;; Uses: A (original value restored)
0000A1r 1               Send_Char:
0000A1r 1  20 rr rr             jsr char_out
0000A4r 1  5A                   phy
0000A5r 1  A4 96                ldy has_acia
0000A7r 1  F0 08                beq send_char_exit
0000A9r 1  8D E0 FF             sta ACIA_DATA
0000ACr 1               
0000ACr 1                       ; nedd to provide additional delay for ACIA
0000ACr 1  A0 20                ldy #$20
0000AEr 1  20 rr rr             jsr delay_short
0000B1r 1                       ; Delay is provided by writing to the LCD screen
0000B1r 1                       ;ldy #$32            ;minimal delay; The min delay increased when added diode on SLOW. Why?
0000B1r 1                       ;jsr delay_short
0000B1r 1                       ;ldy #$30
0000B1r 1                       ;jsr delay
0000B1r 1               
0000B1r 1                       ;jsr char_out
0000B1r 1               send_char_exit:
0000B1r 1                       ;jsr lcd_print
0000B1r 1  7A                   ply
0000B2r 1  60                   rts
0000B3r 1               
0000B3r 1               
0000B3r 1               v_irq:                          ; IRQ handler
0000B3r 1  48                   pha
0000B4r 1  5A                   phy
0000B5r 1                       ; check if bit 7 of IFR is set
0000B5r 1  AD 8D FF             lda IFR
0000B8r 1  10 2B                bpl v_exit  ; Interrupt not from VIA, exit
0000BAr 1               
0000BAr 1  29 08                and #$08        ; ps2 has priority
0000BCr 1  D0 09                bne v_ps2
0000BEr 1  AD 8D FF             lda IFR
0000C1r 1  29 40                and #$40
0000C3r 1  D0 17                bne v_timer
0000C5r 1  80 1E                bra v_exit
0000C7r 1               
0000C7r 1               
0000C7r 1               v_ps2:
0000C7r 1  A5 7A                lda time
0000C9r 1  85 7E                sta last_ps2_time
0000CBr 1  A5 7B                lda time+1
0000CDr 1  85 7F                sta last_ps2_time+1
0000CFr 1  A5 7C                lda time+2
0000D1r 1  85 80                sta last_ps2_time+2
0000D3r 1  A5 7D                lda time+3
0000D5r 1  85 81                sta last_ps2_time+3
0000D7r 1                       ; this delay is here to ensure we prevent desynchronization
0000D7r 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
0000D7r 1                       ; jsr delay_short
0000D7r 1               
0000D7r 1               
0000D7r 1  20 rr rr             jsr ps2_irq
0000DAr 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
0000DAr 1                       ; jsr delay_short
0000DAr 1  80 09                bra v_exit
0000DCr 1               v_timer:
0000DCr 1  AD 84 FF             lda T1CL
0000DFr 1  20 rr rr             jsr timer_irq
0000E2r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
0000E5r 1                       ; check if there is a char waiting to be printed to the lcd
0000E5r 1                       ; lda lcd_char
0000E5r 1                       ; beq v_exit
0000E5r 1                       ; jsr lcd_print
0000E5r 1                       ; stz lcd_char
0000E5r 1               
0000E5r 1               v_exit:
0000E5r 1  7A                   ply
0000E6r 1  68                   pla
0000E7r 1  40                   rti
0000E8r 1               
0000E8r 1               ; Leave the following string as the last entry in the kernel routine so it
0000E8r 1               ; is easier to see where the kernel ends in hex dumps. This string is
0000E8r 1               ; displayed after a successful boot
0000E8r 1               s_kernel_id:
0000E8r 1  54 61 6C 69          .byte "Tali Forth 2.1 for Planck 6502", 0
0000ECr 1  20 46 6F 72  
0000F0r 1  74 68 20 32  
000107r 1               
000107r 1               
000107r 1               
000107r 1               ; Add the interrupt vectors
000107r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000006r 1               
000006r 1               ; END
000006r 1               
000006r 1               
