ca65 V2.18 - N/A
Main file   : platform/platform-planck.asm
Current file: platform/platform-planck.asm

000000r 1               
000000r 1               
000000r 1               ; I/O facilities are handled in the separate kernel files because of their
000000r 1               ; hardware dependencies. See docs/memorymap.txt for a discussion of Tali's
000000r 1               ; memory layout.
000000r 1               
000000r 1               
000000r 1               ; MEMORY MAP OF RAM
000000r 1               
000000r 1               
000000r 1               ; Drawing is not only very ugly, but also not to scale. See the manual for
000000r 1               ; details on the memory map. Note that some of the values are hard-coded in
000000r 1               ; the testing routines, especially the size of the input history buffer, the
000000r 1               ; offset for PAD, and the total RAM size. If these are changed, the tests will
000000r 1               ; have to be changed as well
000000r 1               
000000r 1               
000000r 1               ;    $0000  +-------------------+  ram_start, zpage, user0
000000r 1               ;           |  User variables  |
000000r 1               ;           +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           +~~~~~~~~~~~~~~~~~~~+  <-- dsp
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Data Stack    |
000000r 1               ;           |  |                |
000000r 1               ;    $0078  +-------------------+  dsp0, stack
000000r 1               ;           |                   |
000000r 1               ;           |   (Reserved for   |
000000r 1               ;           |      kernel)      |
000000r 1               ;           |                   |
000000r 1               ;    $0100  +-------------------+
000000r 1               ;           |                   |
000000r 1               ;           |  ^  Return Stack  |  <-- rsp
000000r 1               ;           |  |                |
000000r 1               ;    $0200  +-------------------+  rsp0, buffer, buffer0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Input Buffer  |
000000r 1               ;           |                   |
000000r 1               ;    $0300  +-------------------+  cp0
000000r 1               ;           |  |                |
000000r 1               ;           |  v  Dictionary    |
000000r 1               ;           |       (RAM)       |
000000r 1               ;           |                   |
000000r 1               ;   (...)   ~~~~~~~~~~~~~~~~~~~~~  <-- cp
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;           |                   |
000000r 1               ;    $7C00  +-------------------+  hist_buff, cp_end
000000r 1               ;           |   Input History   |
000000r 1               ;           |    for ACCEPT     |
000000r 1               ;           |  8x128B buffers   |
000000r 1               ;    $7fff  +-------------------+  ram_end
000000r 1               
000000r 1               
000000r 1               ; HARD PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Some of these are somewhat silly for the 65c02, where for example
000000r 1               ; the location of the Zero Page is fixed by hardware. However, we keep
000000r 1               ; these for easier comparisons with Liara Forth's structure and to
000000r 1               ; help people new to these things.
000000r 1               
000000r 1               ram_start = $0000          ; start of installed 32 KiB of RAM
000000r 1               ram_end =   $8000-1        ; end of installed RAM
000000r 1               zpage =     ram_start      ; begin of Zero Page ($0000-$00ff)
000000r 1               zpage_end = $7F            ; end of Zero Page used ($0000-$007f)
000000r 1               stack0 =    $0100          ; begin of Return Stack ($0100-$01ff)
000000r 1               hist_buff = ram_end-$03ff  ; begin of history buffers
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ; SOFT PHYSICAL ADDRESSES
000000r 1               
000000r 1               ; Tali currently doesn't have separate user variables for multitasking. To
000000r 1               ; prepare for this, though, we've already named the location of the user
000000r 1               ; variables user0.
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               KB_BUF =    hist_buff - $ff
000000r 1               LCD_BUF =   KB_BUF - $7f
000000r 1               LINE_BUF =  LCD_BUF - $7f
000000r 1               SD_CRC =    LINE_BUF - $1
000000r 1               SD_SLAVE =  SD_CRC - $1
000000r 1               SD_TMP =  SD_SLAVE - $1
000000r 1               SD_ARG =    SD_TMP - $4
000000r 1               FAT_VARS = SD_ARG - $20
000000r 1               SD_BUF =    FAT_VARS - 16*$200-1   ; reserve space for 16 sectors
000000r 1               
000000r 1               user0 =     zpage          ; user and system variables
000000r 1               
000000r 1               rsp0 =      $ff            ; initial Return Stack Pointer (65c02 stack)
000000r 1               bsize =     $ff            ; size of input/output buffers
000000r 1               buffer0 =   stack0+$100    ; input buffer ($0200-$027f)
000000r 1               cp0 =       buffer0+bsize  ; Dictionary starts after last buffer
000000r 1               cp_end =    SD_BUF         ; Last RAM byte available for code
000000r 1               padoffset = $ff            ; offset from CP to PAD (holds number strings)
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;PLANCK DEFINITIONS
000000r 1               
000000r 1               ; clock speed of main oscillator in hertz
000000r 1               ; used by drivers/timer.s to set proper via timing interval
000000r 1               CLOCK_SPEED = 24000000
000000r 1               ; I/O board in slot 0
000000r 1               VIA1_BASE =        $FF80
000000r 1               ; Serial chip at this address
000000r 1               ACIA_BASE =        $FFE0
000000r 1               
000000r 1               ; VIDEO board in slot 3
000000r 1               VIDEO_BASE =       $FFB0
000000r 1               
000000r 1               ; LCD board in slot 2
000000r 1               LCD_BASE =         $FFD0
000000r 1               
000000r 1               ACIA_DATA =    ACIA_BASE
000000r 1               ACIA_STATUS =  ACIA_BASE+1
000000r 1               ACIA_COMMAND = ACIA_BASE+2
000000r 1               ACIA_CTRL =    ACIA_BASE+3
000000r 1               
000000r 1               LCD_ADDR_DISABLED = LCD_BASE
000000r 1               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 1               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 1               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 1               
000000r 1               PORTB =  VIA1_BASE
000000r 1               PORTA =   VIA1_BASE+1
000000r 1               DDRB =  VIA1_BASE+2
000000r 1               DDRA =  VIA1_BASE+3
000000r 1               
000000r 1               T1CL =  VIA1_BASE + 4
000000r 1               T1CH =  VIA1_BASE + 5
000000r 1               T1LL =  VIA1_BASE + 6
000000r 1               T1LH =  VIA1_BASE + 7
000000r 1               ACR =  VIA1_BASE + 11
000000r 1               PCR =  VIA1_BASE + 12
000000r 1               IFR =  VIA1_BASE + 13
000000r 1               IER =  VIA1_BASE + 14
000000r 1               
000000r 1               
000000r 1               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 1               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;//  ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 1               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 1               VIDEO_DATA = VIDEO_BASE + 3
000000r 1               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 1               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 1               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 1               VIDEO_HIRES_HCHARS = 100
000000r 1               VIDEO_HIRES_VCHARS = 75
000000r 1               
000000r 1               ; ps2 defines
000000r 1               
000000r 1               DATA = $80   ; Data is in bit 7 of PORTB
000000r 1               ; clock is on CB2
000000r 1               SHIFT = $1
000000r 1               ALT = $2
000000r 1               
000000r 1               KB_STATE_START = $0
000000r 1               KB_STATE_DATA = $1
000000r 1               KB_STATE_PARITY = $2
000000r 1               KB_STATE_STOP = $3
000000r 1               
000000r 1               KB_INIT_STATE_RESET = $0
000000r 1               KB_INIT_STATE_RESET_ACK = $1
000000r 1               KB_INIT_STATE_LEDS = $2
000000r 1               KB_INIT_STATE_LEDS_ACK = $3
000000r 1               KB_INIT_STATE_LEDS_DATA = $4
000000r 1               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 1               
000000r 1               LSHIFT_KEY = $12
000000r 1               RSHIFT_KEY = $59
000000r 1               
000000r 1               TIMER_DELAY = $C4
000000r 1               
000000r 1               ; Zero page variables
000000r 1               
000000r 1               stack_p =          dsp0
000000r 1               time =             dsp0+2
000000r 1               last_ps2_time =    dsp0+6
000000r 1               
000000r 1               to_send =          dsp0+10
000000r 1               KB_STATE =         dsp0+11
000000r 1               KB_TEMP =          dsp0+11
000000r 1               
000000r 1               KB_BUF_W_PTR =     dsp0+12
000000r 1               KB_BUF_R_PTR =     dsp0+13
000000r 1               KB_PARITY =        dsp0+14
000000r 1               KB_BIT =           dsp0+15
000000r 1               KB_INIT_STATE =    dsp0+16
000000r 1               KB_INIT_WAIT =     dsp0+17
000000r 1               
000000r 1               ready =            dsp0+18
000000r 1               
000000r 1               ignore_next =      dsp0+19
000000r 1               control_keys =     dsp0+20
000000r 1               
000000r 1               character =        dsp0+21
000000r 1               debug =            dsp0+22
000000r 1               
000000r 1               temp_bits =        dsp0+23
000000r 1               LCD_BUF_W_PTR =    dsp0+24
000000r 1               LCD_BUF_R_PTR =    dsp0+25
000000r 1               line =             dsp0+26
000000r 1               char =             dsp0+27
000000r 1               lcd_absent =       dsp0+28
000000r 1               lcd_pos =          dsp0+29
000000r 1               has_acia =         dsp0+30
000000r 1               spi_tmp =          dsp0+31
000000r 1               spi_tmp2 =         dsp0+32
000000r 1               spi_slave =        dsp0+33
000000r 1               sd_sector =        dsp0+34
000000r 1               sd_buffer_address = dsp0+38
000000r 1               
000000r 1               .segment "CODE"
000000r 1               
000000r 1               .include "../../drivers/spi.s"
000000r 2               ; SPI defines
000000r 2               
000000r 2               SS = $07   ; Slave Select with lowest 3 bits
000000r 2               SCK = $08   ; Clock on bit 3
000000r 2               MISO = $10  ; MISO on bit 4
000000r 2               MOSI = $20  ; MOSI on bit 5
000000r 2               CONF = $40  ; CONF on bit 6
000000r 2               
000000r 2               spi_init:
000000r 2  AD 80 FF         lda PORTB               ; load current port B
000003r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
000005r 2  09 40            ora #CONF               ; set CONF high
000007r 2  8D 80 FF         sta PORTB               ; save to PORTB
00000Ar 2  AD 82 FF         lda DDRB                ; get current direction register
00000Dr 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
00000Fr 2  29 EF            and #($FF^MISO)                 ; set MISO as input
000011r 2  8D 82 FF         sta DDRB
000014r 2  A9 FF            lda #$FF
000016r 2  8D 83 FF         sta DDRA
000019r 2  8D 81 FF         sta PORTA
00001Cr 2               
00001Cr 2  60               rts
00001Dr 2               
00001Dr 2               spi_select:
00001Dr 2                   ; selected slave in A
00001Dr 2  29 07            and #SS                 ; mask slave select bits
00001Fr 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
000022r 2  8D 81 FF         sta PORTA
000025r 2  8D 99 00         sta spi_slave
000028r 2  5A               phy
000029r 2  A0 01            ldy #$1
00002Br 2  20 rr rr         jsr delay_short         ; slight delay
00002Er 2  09 40            ora #CONF               ; set CONF high to latch address
000030r 2  8D 80 FF         sta PORTB               ; save to PORTB
000033r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
000034r 2  60               rts
000035r 2               
000035r 2               spi_clk_toggle:
000035r 2  60               rts
000036r 2               
000036r 2               spi_transceive:
000036r 2                   ; send data in A, received data will be in A
000036r 2  5A               phy
000037r 2                   ; save data in RAM
000037r 2  8D 97 00         sta spi_tmp
00003Ar 2                   ; reset X
00003Ar 2  DA               phx
00003Br 2  A2 08            ldx #8
00003Dr 2                   ; reset result
00003Dr 2  9C 98 00         stz spi_tmp2
000040r 2               spi_send_loop:
000040r 2  0E 97 00         asl spi_tmp
000043r 2  90 08            bcc bit_unset
000045r 2               bit_set:
000045r 2  AD 80 FF         lda PORTB
000048r 2  09 60            ora #(MOSI | CONF)
00004Ar 2  4C rr rr         jmp clock_on
00004Dr 2               bit_unset:
00004Dr 2  AD 80 FF         lda PORTB
000050r 2  29 DF            and #(($FF^MOSI) | CONF)
000052r 2               clock_on:
000052r 2                   ; set data bit
000052r 2  0D 99 00         ora spi_slave
000055r 2  8D 80 FF         sta PORTB
000058r 2               
000058r 2                   ; set clock on
000058r 2  09 48            ora #(SCK | CONF)
00005Ar 2  0D 99 00         ora spi_slave
00005Dr 2  8D 80 FF         sta PORTB
000060r 2               
000060r 2                   ; read bit from slave, maybe add slight delay here ?
000060r 2  AD 80 FF         lda PORTB
000063r 2  29 10            and #MISO           ; mask miso bit
000065r 2  D0 07            bne spi_bit_set      ; bit is set
000067r 2                   ; bit is unset
000067r 2  18               clc
000068r 2  2E 98 00         rol spi_tmp2
00006Br 2  4C rr rr         jmp clock_off
00006Er 2               
00006Er 2               spi_bit_set:
00006Er 2  38               sec
00006Fr 2  2E 98 00         rol spi_tmp2
000072r 2               
000072r 2               
000072r 2               clock_off:
000072r 2  AD 80 FF         lda PORTB
000075r 2  29 F7            and #(($FF^SCK) | CONF)
000077r 2  0D 99 00         ora spi_slave
00007Ar 2  8D 80 FF         sta PORTB
00007Dr 2               end_loop:
00007Dr 2  CA               dex
00007Er 2  D0 C0            bne spi_send_loop
000080r 2                   ; set data low
000080r 2  A0 01            ldy #$1
000082r 2  20 rr rr         jsr delay_short
000085r 2  AD 80 FF         lda PORTB
000088r 2  0D 99 00         ora spi_slave
00008Br 2  29 DF            and #(($FF^MOSI) | CONF)
00008Dr 2  8D 80 FF         sta PORTB
000090r 2  FA               plx
000091r 2  7A               ply
000092r 2  AD 98 00         lda spi_tmp2
000095r 2  60               rts
000096r 2               
000096r 1               .include "../../drivers/delayroutines.s"
000096r 2               ; Copyright 2020 Jonathan Foucher
000096r 2               
000096r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000096r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000096r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000096r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000096r 2               ; is furnished to do so, subject to the following conditions:
000096r 2               
000096r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000096r 2               ; substantial portions of the Software.
000096r 2               
000096r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000096r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000096r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000096r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000096r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000096r 2               ; DEALINGS IN THE SOFTWARE.
000096r 2               
000096r 2               
000096r 2               ; this routine delays by 2304 * y + 23 cycles
000096r 2               delay:
000096r 2  DA             phx       ; 3 cycles
000097r 2  5A             phy       ; 3 cycles
000098r 2               two:
000098r 2  A2 FF          ldx #$ff  ; 2 cycles
00009Ar 2               one:
00009Ar 2  EA             nop       ; 2 cycles
00009Br 2  EA             nop       ; 2 cycles
00009Cr 2  CA             dex       ; 2 cycles
00009Dr 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
00009Fr 2  88             dey       ; 2 cycles
0000A0r 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
0000A2r 2  7A             ply       ; 4 cycles
0000A3r 2  FA             plx       ; 4 cycles
0000A4r 2  60             rts       ; 6 cycles
0000A5r 2               
0000A5r 2               ; delay is in Y register
0000A5r 2               delay_long:
0000A5r 2  48             pha
0000A6r 2  5A             phy
0000A7r 2  DA             phx
0000A8r 2  98             tya
0000A9r 2  AA             tax
0000AAr 2               delay_long_loop:
0000AAr 2  A0 FF          ldy #$ff
0000ACr 2  20 rr rr       jsr delay
0000AFr 2  CA             dex
0000B0r 2  D0 F8          bne delay_long_loop
0000B2r 2  FA             plx
0000B3r 2  7A             ply
0000B4r 2  68             pla
0000B5r 2  60             rts
0000B6r 2               
0000B6r 2               delay_short:        ; delay Y * 19 cycles
0000B6r 2  5A             phy
0000B7r 2               delay_short_loop:
0000B7r 2  EA             nop               ; 2 cycles
0000B8r 2  EA             nop               ; 2 cycles
0000B9r 2  EA             nop               ; 2 cycles
0000BAr 2  EA             nop               ; 2 cycles
0000BBr 2  EA             nop               ; 2 cycles
0000BCr 2  EA             nop               ; 2 cycles
0000BDr 2  EA             nop               ; 2 cycles
0000BEr 2               
0000BEr 2               
0000BEr 2  88             dey               ; 2 cycles
0000BFr 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
0000C1r 2  7A             ply
0000C2r 2  60             rts
0000C3r 2               
0000C3r 1               .include "../../drivers/ps2.s"
0000C3r 2               ; Copyright 2020 Jonathan Foucher
0000C3r 2               
0000C3r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
0000C3r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
0000C3r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
0000C3r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
0000C3r 2               ; is furnished to do so, subject to the following conditions:
0000C3r 2               
0000C3r 2               ; The above copyright notice and this permission notice shall be included in all copies or
0000C3r 2               ; substantial portions of the Software.
0000C3r 2               
0000C3r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
0000C3r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
0000C3r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
0000C3r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
0000C3r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
0000C3r 2               ; DEALINGS IN THE SOFTWARE.
0000C3r 2               
0000C3r 2               
0000C3r 2               ps2_init:
0000C3r 2  78             sei ; prevent interrupts while initializing
0000C4r 2               kb_conn_msg:
0000C4r 2  A2 00          ldx #0
0000C6r 2               kb_conn_loop:
0000C6r 2  BD rr rr       lda kb_conn_msg_text,x
0000C9r 2  F0 1A          beq kb_conn_msg_end
0000CBr 2  20 rr rr       jsr kernel_putc
0000CEr 2  E8             inx
0000CFr 2  80 F5          bra kb_conn_loop
0000D1r 2  44 65 74 65  kb_conn_msg_text: .byte "Detecting keyboard", $0D, $00
0000D5r 2  63 74 69 6E  
0000D9r 2  67 20 6B 65  
0000E5r 2               kb_conn_msg_end:
0000E5r 2               
0000E5r 2  AD 8E FF       lda IER
0000E8r 2  09 88          ora #$88      ;enable interrupt on neg transition on CB2
0000EAr 2  8D 8E FF       sta IER
0000EDr 2               
0000EDr 2  A9 00          lda #0
0000EFr 2  8D 8C FF       sta PCR
0000F2r 2  8D 83 00       sta KB_TEMP
0000F5r 2  8D 87 00       sta KB_BIT
0000F8r 2  8D 83 00       sta KB_STATE
0000FBr 2  8D 82 00       sta to_send
0000FEr 2  8D 86 00       sta KB_PARITY
000101r 2  8D 84 00       sta KB_BUF_W_PTR
000104r 2  8D 85 00       sta KB_BUF_R_PTR
000107r 2  8D 88 00       sta KB_INIT_STATE
00010Ar 2  8D 89 00       sta KB_INIT_WAIT
00010Dr 2  8D 8A 00       sta ready
000110r 2  8D 8B 00       sta ignore_next
000113r 2  8D 8D 00       sta character
000116r 2  20 rr rr       jsr clear_buffer
000119r 2               
000119r 2                 ; jsr kb_reset
000119r 2                 ; jsr kb_leds
000119r 2                 ; jsr kb_leds_data
000119r 2               
000119r 2                 ; jmp done_init
000119r 2               
000119r 2  A9 00          lda #KB_INIT_STATE_RESET
00011Br 2  8D 88 00       sta KB_INIT_STATE
00011Er 2  58             cli           ;enable interrupts
00011Fr 2               
00011Fr 2               @wait1:
00011Fr 2  A0 0A          ldy #10
000121r 2  20 rr rr       jsr delay
000124r 2  EE 89 00       inc KB_INIT_WAIT
000127r 2  F0 1C          beq done_init     ; nothing to show yet
000129r 2  AD 82 00       lda to_send
00012Cr 2  D0 F1          bne @wait1       ; do nothing while sending
00012Er 2               
00012Er 2                 ;jsr lcd_print
00012Er 2               
00012Er 2  AE 88 00       ldx KB_INIT_STATE
000131r 2  E0 00          cpx #KB_INIT_STATE_RESET
000133r 2  F0 06          beq @do_reset
000135r 2  E0 01          cpx #KB_INIT_STATE_RESET_ACK
000137r 2  F0 0C          beq done_init
000139r 2                 ; beq @self_test_ok  ; Wait for 256 loops with nothing. if still nothing, reset keyboard
000139r 2               
000139r 2  80 0A          bra done_init
00013Br 2                 ;sta PORTA
00013Br 2                 ; wait for keyboard self test (#$AA)
00013Br 2               
00013Br 2               @do_reset:
00013Br 2  20 rr rr       jsr kb_reset
00013Er 2  A9 01          lda #KB_INIT_STATE_RESET_ACK  ; next state should be an acknowledgment
000140r 2  8D 88 00       sta KB_INIT_STATE
000143r 2  80 DA          bra @wait1
000145r 2               
000145r 2               
000145r 2               done_init:
000145r 2  A9 00          lda #0
000147r 2  8D 82 FF       sta DDRB
00014Ar 2  8D 8C FF       sta PCR
00014Dr 2  8D 8B 00       sta ignore_next
000150r 2  8D 8A 00       sta ready
000153r 2  8D 8C 00       sta control_keys
000156r 2  8D 82 00       sta to_send
000159r 2  8D 8A 00       sta ready
00015Cr 2  8D 8D 00       sta character
00015Fr 2  8D 83 00       sta KB_TEMP
000162r 2  8D 88 00       sta KB_INIT_STATE
000165r 2  8D 87 00       sta KB_BIT
000168r 2  8D 83 00       sta KB_STATE
00016Br 2  8D 84 00       sta KB_BUF_W_PTR
00016Er 2  8D 85 00       sta KB_BUF_R_PTR
000171r 2  58             cli ; enable interrupts again
000172r 2  60             rts
000173r 2               
000173r 2               
000173r 2               kb_reset:
000173r 2  A9 00          lda #0
000175r 2  8D 89 00       sta KB_INIT_WAIT
000178r 2  A9 F0          lda #$F0
00017Ar 2  8D 81 FF       sta PORTA
00017Dr 2  78             sei                   ;disable interrupts
00017Er 2  20 rr rr       jsr prepare_send
000181r 2  A9 FF          lda #$FF
000183r 2  8D 82 00       sta to_send
000186r 2  58             cli                   ; enable interrupts
000187r 2  60             rts
000188r 2               
000188r 2               no_kb_msg:
000188r 2  A2 00          ldx #0
00018Ar 2               no_kb_loop:
00018Ar 2  BD rr rr       lda no_kb_msg_text,x
00018Dr 2  F0 B6          beq done_init
00018Fr 2  20 rr rr       jsr kernel_putc
000192r 2  E8             inx
000193r 2  80 F5          bra no_kb_loop
000195r 2  4E 6F 20 6B  no_kb_msg_text: .byte "No keyboard connected", $0D, $00
000199r 2  65 79 62 6F  
00019Dr 2  61 72 64 20  
0001ACr 2               
0001ACr 2               
0001ACr 2               prepare_send:
0001ACr 2  48             pha
0001ADr 2  5A             phy
0001AEr 2                 ; ready to send, pull clock low for a while
0001AEr 2  A9 C0          lda #$C0
0001B0r 2  8D 8C FF       sta PCR       ;set CB2 low
0001B3r 2                 ;delay
0001B3r 2  A0 80          ldy #$80
0001B5r 2  20 rr rr       jsr delay
0001B8r 2                 ; delay end
0001B8r 2                 ; pull data low now
0001B8r 2  AD 80 FF       lda PORTB
0001BBr 2  29 7F          and #($FF^DATA)
0001BDr 2  8D 80 FF       sta PORTB
0001C0r 2  AD 82 FF       lda DDRB
0001C3r 2  09 80          ora #DATA   ;data as output to set it low
0001C5r 2  8D 82 FF       sta DDRB
0001C8r 2  A0 40          ldy #$40
0001CAr 2  20 rr rr       jsr delay
0001CDr 2  A9 01          lda #KB_STATE_DATA    ; no start bit when sending
0001CFr 2  8D 83 00       sta KB_STATE
0001D2r 2                 ; release clock
0001D2r 2  A9 00          lda #0
0001D4r 2  8D 82 00       sta to_send
0001D7r 2  8D 86 00       sta KB_PARITY
0001DAr 2  8D 8C FF       sta PCR       ;set CB2 to negative edge input
0001DDr 2               
0001DDr 2  7A             ply
0001DEr 2  68             pla
0001DFr 2  60             rts
0001E0r 2               
0001E0r 2               
0001E0r 2               reset_ps2:          ; routine called during a timer interrupt to check
0001E0r 2  48             pha
0001E1r 2                                   ; if the elasped time since the last ps2 interrupt allows us to reset it
0001E1r 2  AD 7D 00       lda time+3
0001E4r 2  CD 81 00       cmp last_ps2_time+3
0001E7r 2  90 1C          bcc @reset
0001E9r 2  AD 7C 00       lda time+2
0001ECr 2  CD 80 00       cmp last_ps2_time+2
0001EFr 2  90 14          bcc @reset
0001F1r 2  AD 7B 00       lda time+1
0001F4r 2  CD 7F 00       cmp last_ps2_time+1
0001F7r 2  90 0C          bcc @reset
0001F9r 2  AD 7A 00       lda time
0001FCr 2  69 01          adc #$1
0001FEr 2  CD 7E 00       cmp last_ps2_time
000201r 2  90 02          bcc @reset
000203r 2               @exit2:
000203r 2  68             pla
000204r 2  60             rts
000205r 2               @reset:
000205r 2  A9 00          lda #0
000207r 2  8D 83 00       sta KB_TEMP
00020Ar 2  8D 87 00       sta KB_BIT
00020Dr 2  8D 83 00       sta KB_STATE
000210r 2  8D 84 00       sta KB_BUF_W_PTR
000213r 2  8D 85 00       sta KB_BUF_R_PTR
000216r 2  F0 EB          beq @exit2
000218r 2               
000218r 2               clear_buffer:
000218r 2  DA             phx
000219r 2  A2 FF          ldx #$ff
00021Br 2               @clear_loop:
00021Br 2  9E 01 7B       stz KB_BUF, x
00021Er 2  CA             dex
00021Fr 2  D0 FA          bne @clear_loop
000221r 2  FA             plx
000222r 2  60             rts
000223r 2               
000223r 2                 .include "ps2_irq.s"
000223r 3               ; Copyright 2020 Jonathan Foucher
000223r 3               
000223r 3               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000223r 3               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000223r 3               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000223r 3               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000223r 3               ; is furnished to do so, subject to the following conditions:
000223r 3               
000223r 3               ; The above copyright notice and this permission notice shall be included in all copies or
000223r 3               ; substantial portions of the Software.
000223r 3               
000223r 3               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000223r 3               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000223r 3               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000223r 3               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000223r 3               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000223r 3               ; DEALINGS IN THE SOFTWARE.
000223r 3               
000223r 3               
000223r 3               
000223r 3               
000223r 3               ps2_irq:
000223r 3  48               pha
000224r 3  DA               phx
000225r 3  AD 82 00         lda to_send
000228r 3  D0 25            bne @willsend
00022Ar 3  AD 83 00         lda KB_STATE            ; which state ?
00022Dr 3  C9 00            cmp #KB_STATE_START
00022Fr 3  F0 0F            beq @start        ; start bit
000231r 3               
000231r 3  C9 01            cmp #KB_STATE_DATA             ; get data bits
000233r 3  F0 1D            beq @data
000235r 3               
000235r 3  C9 02            cmp #KB_STATE_PARITY             ; this is the parity bit
000237r 3  F0 3A            beq @parity
000239r 3               
000239r 3  C9 03            cmp #KB_STATE_STOP      ; stop bit
00023Br 3  F0 3D            beq @stop
00023Dr 3  4C rr rr         jmp @exit
000240r 3               
000240r 3               @start:
000240r 3  A9 01            lda #KB_STATE_DATA
000242r 3  8D 83 00         sta KB_STATE        ; next state will be to get data
000245r 3  A9 00            lda #0
000247r 3  8D 83 00         sta KB_TEMP
00024Ar 3  8D 87 00         sta KB_BIT
00024Dr 3  80 68            bra @exit
00024Fr 3               @willsend:
00024Fr 3  4C rr rr         jmp @sending
000252r 3               @data:
000252r 3  AD 80 FF         lda PORTB       ; get the bit of data from PORTB bit 7
000255r 3  29 80            and #$80
000257r 3  0D 83 00         ora KB_TEMP     ; OR it with existing temp data
00025Ar 3  8D 83 00         sta KB_TEMP     ; save it
00025Dr 3  EE 87 00         inc KB_BIT      ; prepare for next bit
000260r 3  AD 87 00         lda KB_BIT
000263r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000265r 3  F0 05            beq @next_state_parity
000267r 3  4E 83 00         lsr KB_TEMP     ; if not last bit, shift KB_TEMP right to prepare for next bit
00026Ar 3               
00026Ar 3  80 4B            bra @exit
00026Cr 3               
00026Cr 3               @next_state_parity:
00026Cr 3  A9 02            lda #KB_STATE_PARITY    ;next state is parity
00026Er 3  8D 83 00         sta KB_STATE
000271r 3  80 44            bra @exit
000273r 3               
000273r 3               @parity:
000273r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000275r 3  8D 83 00         sta KB_STATE
000278r 3  80 3D            bra @exit
00027Ar 3               
00027Ar 3               @stop:
00027Ar 3  A9 00            lda #KB_STATE_START
00027Cr 3  8D 83 00         sta KB_STATE
00027Fr 3  AD 8B 00         lda ignore_next
000282r 3  D0 48            bne @ignored
000284r 3                   ; Save key to character buffer
000284r 3  AE 83 00         ldx KB_TEMP
000287r 3  E0 AA            cpx #$AA
000289r 3  F0 35            beq @init
00028Br 3  E0 FA            cpx #$FA
00028Dr 3  F0 31            beq @init
00028Fr 3  E0 F0            cpx #$F0
000291r 3  F0 32            beq @ignore_next
000293r 3  E0 12            cpx #LSHIFT_KEY
000295r 3  F0 53            beq @shift_pressed
000297r 3  E0 59            cpx #RSHIFT_KEY
000299r 3  F0 4F            beq @shift_pressed
00029Br 3  AD 8C 00         lda control_keys
00029Er 3  29 01            and #SHIFT
0002A0r 3  D0 09            bne @shifted
0002A2r 3               @unshifted:
0002A2r 3                   ;stx PORTA
0002A2r 3  BD rr rr         lda ASCIITBL, x
0002A5r 3               
0002A5r 3  C9 1B            cmp #$1B             ; reset if escape pressed
0002A7r 3  F0 14            beq @esc
0002A9r 3  80 03            bra @output
0002ABr 3               @shifted:
0002ABr 3  BD rr rr         lda ASCIITBL+128, x
0002AEr 3               @output:
0002AEr 3  AE 84 00         ldx KB_BUF_W_PTR
0002B1r 3  9D 01 7B         sta KB_BUF, x
0002B4r 3                   ;sta PORTA
0002B4r 3  EE 84 00         inc KB_BUF_W_PTR
0002B7r 3               
0002B7r 3               @exit:
0002B7r 3  2C 80 FF         bit PORTB
0002BAr 3  FA               plx
0002BBr 3  68               pla
0002BCr 3  60               rts
0002BDr 3               @esc:
0002BDr 3  4C rr rr         jmp v_reset
0002C0r 3               @init:
0002C0r 3  8E 8A 00         stx ready
0002C3r 3  80 F2            bra @exit
0002C5r 3               
0002C5r 3               @ignore_next:
0002C5r 3  A9 01            lda #1
0002C7r 3  8D 8B 00         sta ignore_next
0002CAr 3  80 EB            bra @exit
0002CCr 3               
0002CCr 3               @ignored:
0002CCr 3  AE 83 00         ldx KB_TEMP
0002CFr 3  E0 12            cpx #LSHIFT_KEY
0002D1r 3  F0 0B            beq @shift_released
0002D3r 3  E0 59            cpx #RSHIFT_KEY
0002D5r 3  F0 07            beq @shift_released
0002D7r 3  A9 00            lda #0
0002D9r 3  8D 8B 00         sta ignore_next
0002DCr 3  80 D9            bra @exit
0002DEr 3               
0002DEr 3               @shift_released:
0002DEr 3  A9 00            lda #0
0002E0r 3  8D 8B 00         sta ignore_next
0002E3r 3  A9 00            lda #0
0002E5r 3  8D 8C 00         sta control_keys
0002E8r 3  80 CD            bra @exit
0002EAr 3               
0002EAr 3               @shift_pressed:
0002EAr 3  AD 8C 00         lda control_keys
0002EDr 3  09 01            ora #SHIFT
0002EFr 3  8D 8C 00         sta control_keys
0002F2r 3  80 C3            bra @exit
0002F4r 3               
0002F4r 3               @sending:
0002F4r 3                   ; lda #1
0002F4r 3                   ; sta PORTA
0002F4r 3                   ; data pin of DDRB should be set as output by prepare_send
0002F4r 3  AD 83 00         lda KB_STATE                ; which state ?
0002F7r 3  C9 01            cmp #KB_STATE_DATA          ; send data bits
0002F9r 3  F0 0A            beq @sending_data
0002FBr 3  C9 02            cmp #KB_STATE_PARITY        ; this is the parity bit
0002FDr 3  F0 33            beq @sending_parity
0002FFr 3  C9 03            cmp #KB_STATE_STOP          ; stop bit
000301r 3  F0 56            beq @sending_stop
000303r 3  80 B2            bra @exit
000305r 3               
000305r 3               
000305r 3               @sending_data:
000305r 3                   ; lda #4
000305r 3                   ; sta PORTA
000305r 3  AD 82 00         lda to_send       ; get the bit of data from memory
000308r 3  29 01            and #$01          ; get only bottom bit
00030Ar 3  F0 0D            beq @send_zero
00030Cr 3               
00030Cr 3               @send_one:
00030Cr 3  AD 80 FF         lda PORTB
00030Fr 3  09 80            ora #$80
000311r 3  8D 80 FF         sta PORTB
000314r 3  EE 86 00         inc KB_PARITY
000317r 3  80 08            bra @sending_done
000319r 3               @send_zero:
000319r 3  AD 80 FF         lda PORTB
00031Cr 3  29 7F            and #$7F
00031Er 3  8D 80 FF         sta PORTB
000321r 3               @sending_done:
000321r 3                   ; lda #2
000321r 3                   ; sta PORTA
000321r 3  EE 87 00         inc KB_BIT      ; prepare for next bit
000324r 3  AD 87 00         lda KB_BIT
000327r 3  C9 08            cmp #8          ; if this is the last bit, next state is parity
000329r 3  4C rr rr         jmp @next_state_parity
00032Cr 3  4E 82 00         lsr to_send
00032Fr 3  18               clc
000330r 3  80 85            bra @exit
000332r 3               
000332r 3               @sending_parity:
000332r 3                   ; lda #5
000332r 3                   ; sta PORTA
000332r 3  AD 86 00         lda KB_PARITY
000335r 3  29 01            and #$01
000337r 3  F0 10            beq @odd_parity     ; send zero if odd parity
000339r 3  AD 80 FF         lda PORTB
00033Cr 3  09 80            ora #$80            ; send one if even
00033Er 3  8D 80 FF         sta PORTB
000341r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000343r 3  8D 83 00         sta KB_STATE
000346r 3  4C rr rr         jmp @exit
000349r 3               @odd_parity:
000349r 3  AD 80 FF         lda PORTB
00034Cr 3  29 7F            and #$7F
00034Er 3  8D 80 FF         sta PORTB
000351r 3  A9 03            lda #KB_STATE_STOP      ;next state is stop
000353r 3  8D 83 00         sta KB_STATE
000356r 3  4C rr rr         jmp @exit
000359r 3               
000359r 3               @sending_stop:
000359r 3                   ; lda #6
000359r 3                   ; sta PORTA
000359r 3  A9 00            lda #KB_STATE_START     ; set it back to start in case we are receivin next
00035Br 3  8D 83 00         sta KB_STATE
00035Er 3  A9 00            lda #0
000360r 3  8D 82 00         sta to_send
000363r 3  8D 87 00         sta KB_BIT
000366r 3  8D 86 00         sta KB_PARITY
000369r 3  AD 82 FF         lda DDRB        ; set PORTB back to input
00036Cr 3  29 7F            and #$7F
00036Er 3  8D 82 FF         sta DDRB
000371r 3  4C rr rr         jmp @exit
000374r 3               
000374r 2               
000374r 2               
000374r 2               
000374r 2               ASCIITBL:
000374r 2  00               .byte $00               ; 00 no key pressed
000375r 2  89               .byte $89               ; 01 F9
000376r 2  87               .byte $87               ; 02 relocated F7
000377r 2  85               .byte $85               ; 03 F5
000378r 2  83               .byte $83               ; 04 F3
000379r 2  81               .byte $81               ; 05 F1
00037Ar 2  82               .byte $82               ; 06 F2
00037Br 2  8C               .byte $8C               ; 07 F12
00037Cr 2  00               .byte $00               ; 08
00037Dr 2  8A               .byte $8A               ; 09 F10
00037Er 2  88               .byte $88               ; 0A F8
00037Fr 2  86               .byte $86               ; 0B F6
000380r 2  84               .byte $84               ; 0C F4
000381r 2  09               .byte $09               ; 0D tab
000382r 2  60               .byte $60               ; 0E `~
000383r 2  8F               .byte $8F               ; 0F relocated Print Screen key
000384r 2  03               .byte $03               ; 10 relocated Pause/Break key
000385r 2  A0               .byte $A0               ; 11 left alt (right alt too)
000386r 2  00               .byte $00               ; 12 left shift
000387r 2  E0               .byte $E0               ; 13 relocated Alt release code
000388r 2  00               .byte $00               ; 14 left ctrl (right ctrl too)
000389r 2  71               .byte $71               ; 15 qQ
00038Ar 2  31               .byte $31               ; 16 1!
00038Br 2  00               .byte $00               ; 17
00038Cr 2  00               .byte $00               ; 18
00038Dr 2  00               .byte $00               ; 19
00038Er 2  7A               .byte $7A               ; 1A zZ
00038Fr 2  73               .byte $73               ; 1B sS
000390r 2  61               .byte $61               ; 1C aA
000391r 2  77               .byte $77               ; 1D wW
000392r 2  32               .byte $32               ; 1E 2@
000393r 2  A1               .byte $A1               ; 1F Windows 98 menu key (left side)
000394r 2  02               .byte $02               ; 20 relocated ctrl-break key
000395r 2  63               .byte $63               ; 21 cC
000396r 2  78               .byte $78               ; 22 xX
000397r 2  64               .byte $64               ; 23 dD
000398r 2  65               .byte $65               ; 24 eE
000399r 2  34               .byte $34               ; 25 4$
00039Ar 2  33               .byte $33               ; 26 3#
00039Br 2  A2               .byte $A2               ; 27 Windows 98 menu key (right side)
00039Cr 2  00               .byte $00               ; 28
00039Dr 2  20               .byte $20               ; 29 space
00039Er 2  76               .byte $76               ; 2A vV
00039Fr 2  66               .byte $66               ; 2B fF
0003A0r 2  74               .byte $74               ; 2C tT
0003A1r 2  72               .byte $72               ; 2D rR
0003A2r 2  35               .byte $35               ; 2E 5%
0003A3r 2  A3               .byte $A3               ; 2F Windows 98 option key (right click, right side)
0003A4r 2  00               .byte $00               ; 30
0003A5r 2  6E               .byte $6E               ; 31 nN
0003A6r 2  62               .byte $62               ; 32 bB
0003A7r 2  68               .byte $68               ; 33 hH
0003A8r 2  67               .byte $67               ; 34 gG
0003A9r 2  79               .byte $79               ; 35 yY
0003AAr 2  36               .byte $36               ; 36 6^
0003ABr 2  00               .byte $00               ; 37
0003ACr 2  00               .byte $00               ; 38
0003ADr 2  00               .byte $00               ; 39
0003AEr 2  6D               .byte $6D               ; 3A mM
0003AFr 2  6A               .byte $6A               ; 3B jJ
0003B0r 2  75               .byte $75               ; 3C uU
0003B1r 2  37               .byte $37               ; 3D 7&
0003B2r 2  38               .byte $38               ; 3E 8*
0003B3r 2  00               .byte $00               ; 3F
0003B4r 2  00               .byte $00               ; 40
0003B5r 2  2C               .byte $2C               ; 41 ,<
0003B6r 2  6B               .byte $6B               ; 42 kK
0003B7r 2  69               .byte $69               ; 43 iI
0003B8r 2  6F               .byte $6F               ; 44 oO
0003B9r 2  30               .byte $30               ; 45 0)
0003BAr 2  39               .byte $39               ; 46 9(
0003BBr 2  00               .byte $00               ; 47
0003BCr 2  00               .byte $00               ; 48
0003BDr 2  2E               .byte $2E               ; 49 .>
0003BEr 2  2F               .byte $2F               ; 4A /?
0003BFr 2  6C               .byte $6C               ; 4B lL
0003C0r 2  3B               .byte $3B               ; 4C ;:
0003C1r 2  70               .byte $70               ; 4D pP
0003C2r 2  2D               .byte $2D               ; 4E -_
0003C3r 2  00               .byte $00               ; 4F
0003C4r 2  00               .byte $00               ; 50
0003C5r 2  00               .byte $00               ; 51
0003C6r 2  27               .byte $27               ; 52 '"
0003C7r 2  00               .byte $00               ; 53
0003C8r 2  5B               .byte $5B               ; 54 [{
0003C9r 2  3D               .byte $3D               ; 55 =+
0003CAr 2  00               .byte $00               ; 56
0003CBr 2  00               .byte $00               ; 57
0003CCr 2  00               .byte $00               ; 58 caps
0003CDr 2  00               .byte $00               ; 59 r shift
0003CEr 2  0D               .byte $0D               ; 5A <Enter>
0003CFr 2  5D               .byte $5D               ; 5B ]}
0003D0r 2  00               .byte $00               ; 5C
0003D1r 2  5C               .byte $5C               ; 5D \|
0003D2r 2  00               .byte $00               ; 5E
0003D3r 2  00               .byte $00               ; 5F
0003D4r 2  00               .byte $00               ; 60
0003D5r 2  00               .byte $00               ; 61
0003D6r 2  00               .byte $00               ; 62
0003D7r 2  00               .byte $00               ; 63
0003D8r 2  00               .byte $00               ; 64
0003D9r 2  00               .byte $00               ; 65
0003DAr 2  08               .byte $08               ; 66 bkspace
0003DBr 2  00               .byte $00               ; 67
0003DCr 2  00               .byte $00               ; 68
0003DDr 2  31               .byte $31               ; 69 kp 1
0003DEr 2  2F               .byte $2f               ; 6A kp / converted from E04A in code
0003DFr 2  34               .byte $34               ; 6B kp 4
0003E0r 2  37               .byte $37               ; 6C kp 7
0003E1r 2  00               .byte $00               ; 6D
0003E2r 2  00               .byte $00               ; 6E
0003E3r 2  00               .byte $00               ; 6F
0003E4r 2  30               .byte $30               ; 70 kp 0
0003E5r 2  2E               .byte $2E               ; 71 kp .
0003E6r 2  32               .byte $32               ; 72 kp 2
0003E7r 2  35               .byte $35               ; 73 kp 5
0003E8r 2  36               .byte $36               ; 74 kp 6
0003E9r 2  38               .byte $38               ; 75 kp 8
0003EAr 2  1B               .byte $1B               ; 76 esc
0003EBr 2  00               .byte $00               ; 77 num lock
0003ECr 2  8B               .byte $8B               ; 78 F11
0003EDr 2  2B               .byte $2B               ; 79 kp +
0003EEr 2  33               .byte $33               ; 7A kp 3
0003EFr 2  2D               .byte $2D               ; 7B kp -
0003F0r 2  2A               .byte $2A               ; 7C kp *
0003F1r 2  39               .byte $39               ; 7D kp 9
0003F2r 2  8D               .byte $8D               ; 7E scroll lock
0003F3r 2  00               .byte $00               ; 7F
0003F4r 2                   ;
0003F4r 2                   ; Table for shifted scancodes
0003F4r 2                   ;
0003F4r 2  00               .byte $00               ; 80
0003F5r 2  C9               .byte $C9               ; 81 F9
0003F6r 2  C7               .byte $C7               ; 82 relocated F7
0003F7r 2  C5               .byte $C5               ; 83 F5 (F7 actual scancode=83)
0003F8r 2  C3               .byte $C3               ; 84 F3
0003F9r 2  C1               .byte $C1               ; 85 F1
0003FAr 2  C2               .byte $C2               ; 86 F2
0003FBr 2  CC               .byte $CC               ; 87 F12
0003FCr 2  00               .byte $00               ; 88
0003FDr 2  CA               .byte $CA               ; 89 F10
0003FEr 2  C8               .byte $C8               ; 8A F8
0003FFr 2  C6               .byte $C6               ; 8B F6
000400r 2  C4               .byte $C4               ; 8C F4
000401r 2  09               .byte $09               ; 8D tab
000402r 2  7E               .byte $7E               ; 8E `~
000403r 2  CF               .byte $CF               ; 8F relocated Print Screen key
000404r 2  03               .byte $03               ; 90 relocated Pause/Break key
000405r 2  A0               .byte $A0               ; 91 left alt (right alt)
000406r 2  00               .byte $00               ; 92 left shift
000407r 2  E0               .byte $E0               ; 93 relocated Alt release code
000408r 2  00               .byte $00               ; 94 left ctrl (and right ctrl)
000409r 2  51               .byte $51               ; 95 qQ
00040Ar 2  21               .byte $21               ; 96 1!
00040Br 2  00               .byte $00               ; 97
00040Cr 2  00               .byte $00               ; 98
00040Dr 2  00               .byte $00               ; 99
00040Er 2  5A               .byte $5A               ; 9A zZ
00040Fr 2  53               .byte $53               ; 9B sS
000410r 2  41               .byte $41               ; 9C aA
000411r 2  57               .byte $57               ; 9D wW
000412r 2  40               .byte $40               ; 9E 2@
000413r 2  E1               .byte $E1               ; 9F Windows 98 menu key (left side)
000414r 2  02               .byte $02               ; A0 relocated ctrl-break key
000415r 2  43               .byte $43               ; A1 cC
000416r 2  58               .byte $58               ; A2 xX
000417r 2  44               .byte $44               ; A3 dD
000418r 2  45               .byte $45               ; A4 eE
000419r 2  24               .byte $24               ; A5 4$
00041Ar 2  23               .byte $23               ; A6 3#
00041Br 2  E2               .byte $E2               ; A7 Windows 98 menu key (right side)
00041Cr 2  00               .byte $00               ; A8
00041Dr 2  20               .byte $20               ; A9 space
00041Er 2  56               .byte $56               ; AA vV
00041Fr 2  46               .byte $46               ; AB fF
000420r 2  54               .byte $54               ; AC tT
000421r 2  52               .byte $52               ; AD rR
000422r 2  25               .byte $25               ; AE 5%
000423r 2  E3               .byte $E3               ; AF Windows 98 option key (right click, right side)
000424r 2  00               .byte $00               ; B0
000425r 2  4E               .byte $4E               ; B1 nN
000426r 2  42               .byte $42               ; B2 bB
000427r 2  48               .byte $48               ; B3 hH
000428r 2  47               .byte $47               ; B4 gG
000429r 2  59               .byte $59               ; B5 yY
00042Ar 2  5E               .byte $5E               ; B6 6^
00042Br 2  00               .byte $00               ; B7
00042Cr 2  00               .byte $00               ; B8
00042Dr 2  00               .byte $00               ; B9
00042Er 2  4D               .byte $4D               ; BA mM
00042Fr 2  4A               .byte $4A               ; BB jJ
000430r 2  55               .byte $55               ; BC uU
000431r 2  26               .byte $26               ; BD 7&
000432r 2  2A               .byte $2A               ; BE 8*
000433r 2  00               .byte $00               ; BF
000434r 2  00               .byte $00               ; C0
000435r 2  3C               .byte $3C               ; C1 ,<
000436r 2  4B               .byte $4B               ; C2 kK
000437r 2  49               .byte $49               ; C3 iI
000438r 2  4F               .byte $4F               ; C4 oO
000439r 2  29               .byte $29               ; C5 0)
00043Ar 2  28               .byte $28               ; C6 9(
00043Br 2  00               .byte $00               ; C7
00043Cr 2  00               .byte $00               ; C8
00043Dr 2  3E               .byte $3E               ; C9 .>
00043Er 2  3F               .byte $3F               ; CA /?
00043Fr 2  4C               .byte $4C               ; CB lL
000440r 2  3A               .byte $3A               ; CC ;:
000441r 2  50               .byte $50               ; CD pP
000442r 2  5F               .byte $5F               ; CE -_
000443r 2  00               .byte $00               ; CF
000444r 2  00               .byte $00               ; D0
000445r 2  00               .byte $00               ; D1
000446r 2  22               .byte $22               ; D2 '"
000447r 2  00               .byte $00               ; D3
000448r 2  7B               .byte $7B               ; D4 [{
000449r 2  2B               .byte $2B               ; D5 =+
00044Ar 2  00               .byte $00               ; D6
00044Br 2  00               .byte $00               ; D7
00044Cr 2  00               .byte $00               ; D8 caps
00044Dr 2  00               .byte $00               ; D9 r shift
00044Er 2  0D               .byte $0D               ; DA <Enter>
00044Fr 2  7D               .byte $7D               ; DB ]}
000450r 2  00               .byte $00               ; DC
000451r 2  7C               .byte $7C               ; DD \|
000452r 2  00               .byte $00               ; DE
000453r 2  00               .byte $00               ; DF
000454r 2  00               .byte $00               ; E0
000455r 2  00               .byte $00               ; E1
000456r 2  00               .byte $00               ; E2
000457r 2  00               .byte $00               ; E3
000458r 2  00               .byte $00               ; E4
000459r 2  00               .byte $00               ; E5
00045Ar 2  08               .byte $08               ; E6 bkspace
00045Br 2  00               .byte $00               ; E7
00045Cr 2  00               .byte $00               ; E8
00045Dr 2  91               .byte $91               ; E9 kp 1
00045Er 2  2F               .byte $2f               ; EA kp / converted from E04A in code
00045Fr 2  94               .byte $94               ; EB kp 4
000460r 2  97               .byte $97               ; EC kp 7
000461r 2  00               .byte $00               ; ED
000462r 2  00               .byte $00               ; EE
000463r 2  00               .byte $00               ; EF
000464r 2  90               .byte $90               ; F0 kp 0
000465r 2  7F               .byte $7F               ; F1 kp .
000466r 2  92               .byte $92               ; F2 kp 2
000467r 2  95               .byte $95               ; F3 kp 5
000468r 2  96               .byte $96               ; F4 kp 6
000469r 2  98               .byte $98               ; F5 kp 8
00046Ar 2  1B               .byte $1B               ; F6 esc
00046Br 2  00               .byte $00               ; F7 num lock
00046Cr 2  CB               .byte $CB               ; F8 F11
00046Dr 2  2B               .byte $2B               ; F9 kp +
00046Er 2  93               .byte $93               ; FA kp 3
00046Fr 2  2D               .byte $2D               ; FB kp -
000470r 2  2A               .byte $2A               ; FC kp *
000471r 2  99               .byte $99               ; FD kp 9
000472r 2  CD               .byte $CD               ; FE scroll lock
000473r 2               
000473r 2               
000473r 2               
000473r 2               
000473r 1               
000473r 1               .include "../../drivers/timer.s"
000473r 2               
000473r 2               
000473r 2               COUNTER = CLOCK_SPEED/400        ; n/s
000473r 2               
000473r 2               
000473r 2               timer_init:
000473r 2  AD 8E FF         lda IER
000476r 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000478r 2  8D 8E FF         sta IER
00047Br 2  A9 40            lda #$40        ; timer one free run mode
00047Dr 2  8D 8B FF         sta ACR
000480r 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
000482r 2  8D 84 FF         sta T1CL
000485r 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
000487r 2               
000487r 2  8D 85 FF         sta T1CH
00048Ar 2  A9 00            lda #0              ; reset time variable
00048Cr 2  8D 7A 00         sta time
00048Fr 2  8D 7B 00         sta time+1
000492r 2  8D 7C 00         sta time+2
000495r 2  8D 7D 00         sta time+3
000498r 2  58               cli
000499r 2  60               rts
00049Ar 2               
00049Ar 2               
00049Ar 2               timer_irq:
00049Ar 2  EE 7A 00         inc time
00049Dr 2  F0 04            beq @inc1
00049Fr 2               @exit1:
00049Fr 2                   ; this resets the PS/2 temp variables
00049Fr 2  20 rr rr         jsr reset_ps2
0004A2r 2  60               rts
0004A3r 2               @inc1:
0004A3r 2  EE 7B 00         inc time+1
0004A6r 2  F0 02            beq @inc2
0004A8r 2  80 F5            bra @exit1
0004AAr 2               @inc2:
0004AAr 2  EE 7C 00         inc time+2
0004ADr 2  F0 02            beq @inc3
0004AFr 2  80 EE            bra @exit1
0004B1r 2               @inc3:
0004B1r 2  EE 7D 00         inc time+3
0004B4r 2  80 E9            bra @exit1
0004B6r 2               
0004B6r 1               .include "../../drivers/lcd.s"
0004B6r 2               
0004B6r 2               ; initialize the LCD in 8 bit mode
0004B6r 2               lcd_init:
0004B6r 2  20 rr rr         jsr buf_clr
0004B9r 2  A9 00            lda #0
0004BBr 2  8D 94 00         sta lcd_absent
0004BEr 2  8D 90 00         sta LCD_BUF_W_PTR
0004C1r 2  8D 91 00         sta LCD_BUF_R_PTR
0004C4r 2  8D 95 00         sta lcd_pos
0004C7r 2               
0004C7r 2               
0004C7r 2  A0 FF            ldy #$FF
0004C9r 2  20 rr rr         jsr delay
0004CCr 2               
0004CCr 2  A9 38            LDA #$38            ;function set: 8 bit
0004CEr 2  20 rr rr         jsr lcd_inst
0004D1r 2               
0004D1r 2               
0004D1r 2  A0 FF            ldy #$FF
0004D3r 2  20 rr rr         jsr delay
0004D6r 2               
0004D6r 2  A9 0F            LDA #$0F            ;display on, cursor on, blink on
0004D8r 2  20 rr rr         jsr lcd_inst
0004DBr 2               
0004DBr 2                   ;entry mode set
0004DBr 2  A9 06            LDA #$06
0004DDr 2  20 rr rr         jsr lcd_inst
0004E0r 2               
0004E0r 2                   ;clear display
0004E0r 2  A9 01            LDA #$01
0004E2r 2  20 rr rr         jsr lcd_inst
0004E5r 2               
0004E5r 2  A0 FF            ldy #$ff            ; wait a while
0004E7r 2  20 rr rr         jsr delay
0004EAr 2                   ;set dram address to start of screen
0004EAr 2  A9 80            LDA #$80
0004ECr 2  20 rr rr         jsr lcd_inst
0004EFr 2               
0004EFr 2  A0 FF            ldy #$ff            ; wait a while
0004F1r 2  20 rr rr         jsr delay
0004F4r 2               
0004F4r 2               
0004F4r 2  60               RTS
0004F5r 2               
0004F5r 2               ; Send an instruction in 8 bit mode
0004F5r 2               lcd_inst:
0004F5r 2  5A               phy
0004F6r 2  8D D1 FF         sta LCD_ADDR_ENABLED
0004F9r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
0004FBr 2  20 rr rr         jsr delay_short
0004FEr 2  8D D0 FF         sta LCD_ADDR_DISABLED
000501r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
000503r 2  20 rr rr         jsr delay_short
000506r 2  7A               ply
000507r 2  60               rts
000508r 2               
000508r 2               lcd_send:
000508r 2  8D D3 FF         sta LCD_DATA_ENABLED
00050Br 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
00050Dr 2  20 rr rr         jsr delay_short
000510r 2  8D D2 FF         sta LCD_DATA_DISABLED
000513r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
000515r 2  20 rr rr         jsr delay_short
000518r 2  60               rts
000519r 2               
000519r 2               ; Sends the character in A to the display
000519r 2               lcd_print:               ; 8 bit data in A
000519r 2  5A               phy
00051Ar 2  DA               phx
00051Br 2  48               pha
00051Cr 2  C9 0A            cmp #$0A
00051Er 2  F0 6E            beq @next_line
000520r 2  C9 0D            cmp #$0D
000522r 2  F0 6A            beq @next_line
000524r 2  C9 08            cmp #$08            ;backspace
000526r 2  F0 21            beq @backspace
000528r 2               
000528r 2  20 rr rr         jsr lcd_send
00052Br 2  AE 95 00         ldx lcd_pos
00052Er 2  9D 82 7A         sta LCD_BUF, x
000531r 2               
000531r 2  E8               inx
000532r 2                   ; Check at which position we are and change line if necessary
000532r 2  8E 95 00         stx lcd_pos
000535r 2               
000535r 2  E0 14            cpx #20
000537r 2  F0 2C            beq @line_2
000539r 2  E0 28            cpx #40
00053Br 2  F0 34            beq @line_3
00053Dr 2  E0 3C            cpx #60
00053Fr 2  F0 3C            beq @line_4
000541r 2  E0 50            cpx #80
000543r 2  F0 44            beq @clr
000545r 2               
000545r 2               @continue:
000545r 2  68               pla
000546r 2  FA               plx
000547r 2  7A               ply
000548r 2  60               rts
000549r 2               
000549r 2               ; LCD adressing http://web.alfredstate.edu/faculty/weimandn/lcd/lcd_addressing/lcd_addressing_index.html
000549r 2               @backspace:
000549r 2  A9 10            lda #$10            ; shift cursor left
00054Br 2  20 rr rr         jsr lcd_inst
00054Er 2  A9 20            lda #$20            ; print a space to erase previous char
000550r 2  20 rr rr         jsr lcd_send
000553r 2               
000553r 2  A9 10            lda #$10            ; shift cursor left
000555r 2  20 rr rr         jsr lcd_inst
000558r 2  CE 95 00         dec lcd_pos
00055Br 2  AE 95 00         ldx lcd_pos         ; save in buffer
00055Er 2  A9 20            lda #$20
000560r 2  9D 82 7A         sta LCD_BUF,x
000563r 2  80 E0            bra @continue
000565r 2               @line_2:
000565r 2  A9 14            lda #20
000567r 2  8D 95 00         sta lcd_pos
00056Ar 2  A9 C0            lda #$C0
00056Cr 2  20 rr rr         jsr lcd_inst
00056Fr 2  80 D4            bra @continue
000571r 2               
000571r 2               @line_3:
000571r 2  A9 28            lda #40
000573r 2  8D 95 00         sta lcd_pos
000576r 2  A9 94            lda #$94
000578r 2  20 rr rr         jsr lcd_inst
00057Br 2  80 C8            bra @continue
00057Dr 2               
00057Dr 2               @line_4:
00057Dr 2  A9 3C            lda #60
00057Fr 2  8D 95 00         sta lcd_pos
000582r 2  A9 D4            lda #$D4
000584r 2  20 rr rr         jsr lcd_inst
000587r 2  80 BC            bra @continue
000589r 2               @clr:
000589r 2                   ; lda #0
000589r 2                   ; sta lcd_pos
000589r 2                   ; lda #$80
000589r 2                   ; jsr lcd_inst
000589r 2  20 rr rr         jsr lcd_scroll_up
00058Cr 2  80 B7            bra @continue
00058Er 2               
00058Er 2               @next_line:
00058Er 2  AE 95 00         ldx lcd_pos            ;get current position
000591r 2  E0 50            cpx #80
000593r 2  F0 F4            beq @clr
000595r 2  E0 3C            cpx #60
000597r 2  F0 E4            beq @line_4
000599r 2  E0 28            cpx #40
00059Br 2  F0 D4            beq @line_3
00059Dr 2  E0 14            cpx #20
00059Fr 2  F0 C4            beq @line_2
0005A1r 2  E8               inx
0005A2r 2  8E 95 00         stx lcd_pos
0005A5r 2  A9 20            lda #$20
0005A7r 2  20 rr rr         jsr lcd_send
0005AAr 2  9D 82 7A         sta LCD_BUF, x
0005ADr 2  80 DF            bra @next_line
0005AFr 2               
0005AFr 2               lcd_scroll_up:
0005AFr 2  48               pha                     ; save registers
0005B0r 2  5A               phy
0005B1r 2  DA               phx
0005B2r 2  A9 80            lda #$80                ; set LCD address to start
0005B4r 2  20 rr rr         jsr lcd_inst
0005B7r 2               
0005B7r 2  A2 14            ldx #20                 ; start getting characters at the start of the second line
0005B9r 2               @scroll_loop:
0005B9r 2  BD 82 7A         lda LCD_BUF, X          ; load from buffer
0005BCr 2  20 rr rr         jsr lcd_send            ; send to display
0005BFr 2  A8               tay                     ; save current character in Y
0005C0r 2  E0 4F            cpx #79                 ; update LCD address if necessary
0005C2r 2  F0 4B            beq @scline_4
0005C4r 2  E0 3B            cpx #59
0005C6r 2  F0 40            beq @scline_3
0005C8r 2  E0 27            cpx #39
0005CAr 2  F0 35            beq @scline_2
0005CCr 2               @sccontinue:                ; return from updating LCD address
0005CCr 2  8A               txa                     ; copy X to A to be able to subtract from it
0005CDr 2  38               sec                     ; set carry before subtraction
0005CEr 2  E9 14            sbc #20                 ; subtract 20 to get where to put this character
0005D0r 2  AA               tax                     ; put the result in X
0005D1r 2  98               tya                     ; restore character from Y
0005D2r 2  9D 82 7A         sta LCD_BUF, X          ; store char in buffer
0005D5r 2  8A               txa                     ; copy X to A to be able to add to it
0005D6r 2  18               clc
0005D7r 2  69 14            adc #20                 ; add 20 to restore X
0005D9r 2  AA               tax                     ; put the result back in X
0005DAr 2  E8               inx                     ; increment X to prepare to get next char
0005DBr 2  E0 50            cpx #80                 ; if not at end of buffer
0005DDr 2  90 DA            bcc @scroll_loop        ; do next char
0005DFr 2                   ; fill the last line with spaces
0005DFr 2  A9 D4            lda #$D4                ; set address to last line
0005E1r 2  20 rr rr         jsr lcd_inst
0005E4r 2  A9 20            lda #$20
0005E6r 2  A2 3C            ldx #60
0005E8r 2               @last_line_loop:
0005E8r 2  9D 82 7A         sta LCD_BUF, x
0005EBr 2  20 rr rr         jsr lcd_send
0005EEr 2  E8               inx
0005EFr 2  E0 50            cpx #80                 ; if not at end of buffer
0005F1r 2  90 F5            bcc @last_line_loop     ; do next char
0005F3r 2               
0005F3r 2                   ;finally, place the cursor at the start of the last line
0005F3r 2  A9 3C            lda #60
0005F5r 2  8D 95 00         sta lcd_pos
0005F8r 2  A9 D4            lda #$D4
0005FAr 2  20 rr rr         jsr lcd_inst
0005FDr 2  FA               plx                     ; restore everything as it was
0005FEr 2  7A               ply
0005FFr 2  68               pla
000600r 2  60               rts
000601r 2               
000601r 2               @scline_2:
000601r 2  A9 C0            lda #$C0
000603r 2  20 rr rr         jsr lcd_inst
000606r 2  80 C4            bra @sccontinue
000608r 2               
000608r 2               @scline_3:
000608r 2  A9 94            lda #$94
00060Ar 2  20 rr rr         jsr lcd_inst
00060Dr 2  80 BD            bra @sccontinue
00060Fr 2               
00060Fr 2               @scline_4:
00060Fr 2  A9 D4            lda #$D4
000611r 2  20 rr rr         jsr lcd_inst
000614r 2  80 B6            bra @sccontinue
000616r 2               
000616r 2               lcd_clear:
000616r 2  48               PHA
000617r 2                   ;clear display
000617r 2  A9 01            LDA #$01
000619r 2  20 rr rr         jsr lcd_inst
00061Cr 2                   ;set dram address
00061Cr 2  A9 80            LDA #$80
00061Er 2  20 rr rr         jsr lcd_inst
000621r 2  68               PLA
000622r 2  60               RTS
000623r 2               
000623r 2               
000623r 2               buf_clr:
000623r 2  48               pha
000624r 2  DA               phx
000625r 2  A2 80            ldx #$80
000627r 2  A9 20            lda #$20
000629r 2               buf_clr_loop:
000629r 2  9D 82 7A         sta LCD_BUF,X
00062Cr 2  CA               dex
00062Dr 2  D0 FA            bne buf_clr_loop
00062Fr 2  FA               plx
000630r 2  68               pla
000631r 2  60               rts
000632r 2               
000632r 1               .include "../../drivers/vga.s"
000632r 2               video_init:
000632r 2                   ; set colors
000632r 2  A9 05            lda #$05
000634r 2  8D B0 FF         sta VIDEO_CTRL
000637r 2  A9 1E            lda #$1E
000639r 2  8D B1 FF         sta VIDEO_ADDR_LOW
00063Cr 2  A9 FF            lda #$FF
00063Er 2  8D B2 FF         sta VIDEO_ADDR_HIGH
000641r 2  A9 00            lda #$00
000643r 2  8D B3 FF         sta VIDEO_DATA
000646r 2  A9 F0            lda #$F0
000648r 2  8D B3 FF         sta VIDEO_DATA
00064Br 2  A9 00            lda #0
00064Dr 2  8D B4 FF         sta VIDEO_IEN
000650r 2  8D B1 FF         sta VIDEO_ADDR_LOW
000653r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
000656r 2  20 rr rr         jsr vga_clear
000659r 2  60               rts
00065Ar 2               
00065Ar 2               char_out:
00065Ar 2  48               pha
00065Br 2  DA               phx
00065Cr 2  5A               phy
00065Dr 2  C9 0D            cmp #$0D
00065Fr 2  F0 37            beq next_line
000661r 2  C9 0A            cmp #$0A
000663r 2  F0 33            beq next_line
000665r 2  C9 08            cmp #$08
000667r 2  F0 11            beq backspace
000669r 2  8D B3 FF         sta VIDEO_DATA
00066Cr 2  EE 93 00         inc char
00066Fr 2  AE 93 00         ldx char
000672r 2  E0 64            cpx #VIDEO_HIRES_HCHARS
000674r 2  F0 22            beq next_line
000676r 2               
000676r 2               char_out_exit:
000676r 2  7A               ply
000677r 2  FA               plx
000678r 2  68               pla
000679r 2  60               rts
00067Ar 2               
00067Ar 2               backspace:
00067Ar 2  CE 93 00         dec char
00067Dr 2  A9 85            lda #$85        ; make increment negative
00067Fr 2  8D B0 FF         sta VIDEO_CTRL
000682r 2  A9 20            lda #$20
000684r 2  8D B3 FF         sta VIDEO_DATA  ;write a space to go back one
000687r 2  A9 01            lda #$01        ; make increment zero
000689r 2  8D B0 FF         sta VIDEO_CTRL
00068Cr 2  A9 20            lda #$20
00068Er 2  8D B3 FF         sta VIDEO_DATA  ; replace with a space
000691r 2  A9 05            lda #$05        ; make increment positive again
000693r 2  8D B0 FF         sta VIDEO_CTRL
000696r 2  80 DE            bra char_out_exit
000698r 2               
000698r 2               next_line:
000698r 2  EE 92 00         inc line
00069Br 2  9C 93 00         stz char
00069Er 2  AE 92 00         ldx line
0006A1r 2  E0 4B            cpx #VIDEO_HIRES_VCHARS
0006A3r 2  90 05            bcc nl
0006A5r 2  20 rr rr         jsr scroll_up
0006A8r 2  80 CC            bra char_out_exit
0006AAr 2               nl:
0006AAr 2  BD rr rr         lda mult_table_high,x
0006ADr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006B0r 2  BD rr rr         lda mult_table_low,x
0006B3r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006B6r 2  80 BE            bra char_out_exit
0006B8r 2               
0006B8r 2               scroll_up:
0006B8r 2  20 rr rr         jsr vga_clear
0006BBr 2  60               rts
0006BCr 2  48               pha
0006BDr 2                   ; lda #1
0006BDr 2                   ; sta VIDEO_VSCROLL
0006BDr 2                   ; lda mult_table_high+60
0006BDr 2                   ; sta VIDEO_ADDR_HIGH
0006BDr 2                   ; lda mult_table_low+60
0006BDr 2                   ; sta VIDEO_ADDR_LOW
0006BDr 2  A9 00            lda #0
0006BFr 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006C2r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006C5r 2  8D 93 00         sta char
0006C8r 2  8D 92 00         sta line
0006CBr 2  68               pla
0006CCr 2  60               rts
0006CDr 2               
0006CDr 2               vga_clear:
0006CDr 2  48               pha
0006CEr 2  DA               phx
0006CFr 2  5A               phy
0006D0r 2  A9 00            lda #0
0006D2r 2  8D 92 00         sta line
0006D5r 2                   ;lda #$05                ; monochrome chars, increment by one
0006D5r 2                   ;sta VIDEO_CTRL
0006D5r 2               
0006D5r 2  A9 00            lda #$00                ; set start address
0006D7r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006DAr 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006DDr 2               
0006DDr 2  A9 20            lda #$20
0006DFr 2  A0 64            ldy #VIDEO_HIRES_HCHARS
0006E1r 2               outer:
0006E1r 2  A2 4B            ldx #VIDEO_HIRES_VCHARS
0006E3r 2               inner:
0006E3r 2  8D B3 FF         sta VIDEO_DATA
0006E6r 2               
0006E6r 2  CA               dex
0006E7r 2  D0 FA            bne inner
0006E9r 2  88               dey
0006EAr 2  D0 F5            bne outer
0006ECr 2               
0006ECr 2  A9 00            lda #0
0006EEr 2  8D 92 00         sta line
0006F1r 2  8D 93 00         sta char
0006F4r 2  A9 00            lda #$00
0006F6r 2  8D B2 FF         sta VIDEO_ADDR_HIGH
0006F9r 2  8D B1 FF         sta VIDEO_ADDR_LOW
0006FCr 2  7A               ply
0006FDr 2  FA               plx
0006FEr 2  68               pla
0006FFr 2  60               rts
000700r 2               
000700r 2               
000700r 2               
000700r 2               ; These are precalculated multiplications for ADDR_LOW and ADDR_HIGH depending on the line number
000700r 2               mult_table_high:
000700r 2  00               .byte $00
000701r 2  02               .byte $02
000702r 2  05               .byte $05
000703r 2  07               .byte $07
000704r 2  0A               .byte $0a
000705r 2  0C               .byte $0c
000706r 2  0F               .byte $0f
000707r 2  11               .byte $11
000708r 2  14               .byte $14
000709r 2  16               .byte $16
00070Ar 2  19               .byte $19
00070Br 2  1B               .byte $1b
00070Cr 2  1E               .byte $1e
00070Dr 2  20               .byte $20
00070Er 2  23               .byte $23
00070Fr 2  25               .byte $25
000710r 2  28               .byte $28
000711r 2  2A               .byte $2a
000712r 2  2D               .byte $2d
000713r 2  2F               .byte $2f
000714r 2  32               .byte $32
000715r 2  34               .byte $34
000716r 2  37               .byte $37
000717r 2  39               .byte $39
000718r 2  3C               .byte $3c
000719r 2  3E               .byte $3e
00071Ar 2  41               .byte $41
00071Br 2  43               .byte $43
00071Cr 2  46               .byte $46
00071Dr 2  48               .byte $48
00071Er 2  4B               .byte $4b
00071Fr 2  4D               .byte $4d
000720r 2  50               .byte $50
000721r 2  52               .byte $52
000722r 2  55               .byte $55
000723r 2  57               .byte $57
000724r 2  5A               .byte $5a
000725r 2  5C               .byte $5c
000726r 2  5F               .byte $5f
000727r 2  61               .byte $61
000728r 2  64               .byte $64
000729r 2  66               .byte $66
00072Ar 2  69               .byte $69
00072Br 2  6B               .byte $6b
00072Cr 2  6E               .byte $6e
00072Dr 2  70               .byte $70
00072Er 2  73               .byte $73
00072Fr 2  75               .byte $75
000730r 2  78               .byte $78
000731r 2  7A               .byte $7a
000732r 2  7D               .byte $7d
000733r 2  7F               .byte $7f
000734r 2  82               .byte $82
000735r 2  84               .byte $84
000736r 2  87               .byte $87
000737r 2  89               .byte $89
000738r 2  8C               .byte $8c
000739r 2  8E               .byte $8e
00073Ar 2  91               .byte $91
00073Br 2  93               .byte $93
00073Cr 2  96               .byte $96
00073Dr 2               
00073Dr 2               mult_table_low:
00073Dr 2  00               .byte $00
00073Er 2  10               .byte $10
00073Fr 2  00               .byte $00
000740r 2  10               .byte $10
000741r 2  00               .byte $00
000742r 2  10               .byte $10
000743r 2  00               .byte $00
000744r 2  10               .byte $10
000745r 2  00               .byte $00
000746r 2  10               .byte $10
000747r 2  00               .byte $00
000748r 2  10               .byte $10
000749r 2  00               .byte $00
00074Ar 2  10               .byte $10
00074Br 2  00               .byte $00
00074Cr 2  10               .byte $10
00074Dr 2  00               .byte $00
00074Er 2  10               .byte $10
00074Fr 2  00               .byte $00
000750r 2  10               .byte $10
000751r 2  00               .byte $00
000752r 2  10               .byte $10
000753r 2  00               .byte $00
000754r 2  10               .byte $10
000755r 2  00               .byte $00
000756r 2  10               .byte $10
000757r 2  00               .byte $00
000758r 2  10               .byte $10
000759r 2  00               .byte $00
00075Ar 2  10               .byte $10
00075Br 2  00               .byte $00
00075Cr 2  10               .byte $10
00075Dr 2  00               .byte $00
00075Er 2  10               .byte $10
00075Fr 2  00               .byte $00
000760r 2  10               .byte $10
000761r 2  00               .byte $00
000762r 2  10               .byte $10
000763r 2  00               .byte $00
000764r 2  10               .byte $10
000765r 2  00               .byte $00
000766r 2  10               .byte $10
000767r 2  00               .byte $00
000768r 2  10               .byte $10
000769r 2  00               .byte $00
00076Ar 2  10               .byte $10
00076Br 2  00               .byte $00
00076Cr 2  10               .byte $10
00076Dr 2  00               .byte $00
00076Er 2  10               .byte $10
00076Fr 2  00               .byte $00
000770r 2  10               .byte $10
000771r 2  00               .byte $00
000772r 2  10               .byte $10
000773r 2  00               .byte $00
000774r 2  10               .byte $10
000775r 2  00               .byte $00
000776r 2  10               .byte $10
000777r 2  00               .byte $00
000778r 2  10               .byte $10
000779r 2  00               .byte $00
00077Ar 2               
00077Ar 1               
00077Ar 1               .include "../../drivers/sd.s"
00077Ar 2               ; SD card driver
00077Ar 2               
00077Ar 2               ; SD card initialization routine
00077Ar 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
00077Ar 2               
00077Ar 2               sd_init:                    ; slave address in A
00077Ar 2  8D 01 7A         sta SD_SLAVE             ; save slave address for later use
00077Dr 2  DA               phx
00077Er 2  20 rr rr         jsr spi_init                ; init SPI system
000781r 2  A9 00            lda #0
000783r 2  20 rr rr         jsr spi_select          ; DEselect slave
000786r 2  8D FC 79         sta SD_ARG
000789r 2  8D FD 79         sta SD_ARG+1            ; clear command argument
00078Cr 2  8D FE 79         sta SD_ARG+2
00078Fr 2  8D FF 79         sta SD_ARG+3
000792r 2  A9 95            lda #$95
000794r 2  8D 02 7A         sta SD_CRC              ; set CRC for CMD0
000797r 2                   ; clear SD buffer
000797r 2  A2 FF            ldx #$FF
000799r 2               clear_sd_buf_loop1:
000799r 2  9E DB 59         stz SD_BUF, X
00079Cr 2  CA               dex
00079Dr 2  D0 FA            bne clear_sd_buf_loop1
00079Fr 2               
00079Fr 2  CA               dex
0007A0r 2               clear_sd_buf_loop2:
0007A0r 2  9E DB 5A         stz SD_BUF+256, x
0007A3r 2  CA               dex
0007A4r 2  D0 FA            bne clear_sd_buf_loop2
0007A6r 2               
0007A6r 2                   ; send 10 bytes of $FF With SD card deselected
0007A6r 2               
0007A6r 2  A2 0A            ldx #10
0007A8r 2               init_loop:
0007A8r 2  A9 FF            lda #$FF
0007AAr 2  20 rr rr         jsr spi_transceive
0007ADr 2  CA               dex
0007AEr 2  D0 F8            bne init_loop
0007B0r 2               
0007B0r 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
0007B3r 2  C9 01            cmp #$01                ; Check for idle state
0007B5r 2  D0 55            bne sd_error
0007B7r 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
0007BAr 2  C9 01            cmp #$01                ; Check for idle state
0007BCr 2  D0 4E            bne sd_error
0007BEr 2                   ; TODO check if long response is $01AA
0007BEr 2               
0007BEr 2                   ; wait for card to be initialized
0007BEr 2  A2 FF            ldx #$ff    ; Max times to loop
0007C0r 2  9C FC 79         stz SD_ARG
0007C3r 2  9C FD 79         stz SD_ARG+1
0007C6r 2  9C FE 79         stz SD_ARG+2
0007C9r 2  9C FF 79         stz SD_ARG+3
0007CCr 2               sd_init_loop2:
0007CCr 2  CA               dex
0007CDr 2  F0 3D            beq sd_error
0007CFr 2  9C FF 79         stz SD_ARG+3
0007D2r 2  A9 37            lda #55
0007D4r 2  20 rr rr         jsr sd_command
0007D7r 2  A9 40            lda #$40
0007D9r 2  8D FF 79         sta SD_ARG+3
0007DCr 2  A9 29            lda #41
0007DEr 2  20 rr rr         jsr sd_command
0007E1r 2               
0007E1r 2  D0 E9            bne sd_init_loop2
0007E3r 2               
0007E3r 2  A9 3A            lda #58
0007E5r 2  20 rr rr         jsr sd_command
0007E8r 2  AD DB 59         lda SD_BUF
0007EBr 2  29 40            and #$40
0007EDr 2  F0 07            beq force_block_size    ; CCS bit is unset, force block addressing
0007EFr 2               sd_init_exit_success:
0007EFr 2  FA               plx
0007F0r 2  9C 02 7A         stz SD_CRC              ; reset CRC to zero
0007F3r 2  A9 00            lda #0
0007F5r 2               
0007F5r 2  60               rts
0007F6r 2               
0007F6r 2               force_block_size:
0007F6r 2  9C FC 79         stz SD_ARG
0007F9r 2  9C FD 79         stz SD_ARG+1
0007FCr 2  A9 02            lda #$2
0007FEr 2  8D FE 79         sta SD_ARG+2
000801r 2  9C FF 79         stz SD_ARG+3    ; set block size to $200 (512 bytes)
000804r 2  A9 10            lda #$10
000806r 2  20 rr rr         jsr sd_command
000809r 2  4C rr rr         jmp sd_init_exit_success
00080Cr 2               
00080Cr 2               sd_error:
00080Cr 2  FA               plx
00080Dr 2  A9 01            lda #1
00080Fr 2  60               rts
000810r 2               
000810r 2               sd_command:         ; command index is in A
000810r 2  29 3F            and #$3F        ; only keep low 6 bits
000812r 2  8D 00 7A         sta SD_TMP
000815r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
000817r 2               
000817r 2                   ; Select chip
000817r 2  20 rr rr         jsr sd_command_start
00081Ar 2               
00081Ar 2  20 rr rr         jsr spi_transceive  ; send command index
00081Dr 2                   ; command argument is in SD_ARG
00081Dr 2                   ; SPI is big endian, so reverse argument order
00081Dr 2  AD FF 79         lda SD_ARG + 3
000820r 2  20 rr rr         jsr spi_transceive
000823r 2  AD FE 79         lda SD_ARG+2
000826r 2  20 rr rr         jsr spi_transceive
000829r 2  AD FD 79         lda SD_ARG+1
00082Cr 2  20 rr rr         jsr spi_transceive
00082Fr 2  AD FC 79         lda SD_ARG
000832r 2  20 rr rr         jsr spi_transceive
000835r 2  AD 02 7A         lda SD_CRC          ; send hardcoded CRC if available
000838r 2  20 rr rr         jsr spi_transceive
00083Br 2               
00083Br 2                   ; wait for a zero to be received in the top bit of the response
00083Br 2               sd_response_wait_loop:
00083Br 2  A9 FF            lda #$FF
00083Dr 2  20 rr rr         jsr spi_transceive
000840r 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
000842r 2               
000842r 2  48               pha
000843r 2               
000843r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
000843r 2               
000843r 2                   ; get 32 bits of response for CMD 8 and CMD 58
000843r 2  AD 00 7A         lda SD_TMP
000846r 2  C9 08            cmp #8
000848r 2  F0 0D            beq long_response
00084Ar 2  C9 3A            cmp #58
00084Cr 2  F0 09            beq long_response
00084Er 2  C9 11            cmp #$11
000850r 2  F0 03            beq sd_command_exit_no_end
000852r 2               
000852r 2               sd_command_exit:
000852r 2  20 rr rr         jsr sd_command_end
000855r 2               sd_command_exit_no_end:
000855r 2  68               pla
000856r 2                   ; return the response
000856r 2  60               rts
000857r 2               
000857r 2               long_response:
000857r 2  A9 FF            lda #$FF
000859r 2  20 rr rr         jsr spi_transceive
00085Cr 2  8D DB 59         sta SD_BUF
00085Fr 2  A9 FF            lda #$FF
000861r 2  20 rr rr         jsr spi_transceive
000864r 2  8D DC 59         sta SD_BUF+1
000867r 2  A9 FF            lda #$FF
000869r 2  20 rr rr         jsr spi_transceive
00086Cr 2  8D DD 59         sta SD_BUF+2
00086Fr 2  A9 FF            lda #$FF
000871r 2  20 rr rr         jsr spi_transceive
000874r 2  8D DE 59         sta SD_BUF+3
000877r 2  4C rr rr         jmp sd_command_exit
00087Ar 2               
00087Ar 2               ; send SD card CMD0
00087Ar 2               sd_cmd_0:
00087Ar 2  A9 95            lda #$95
00087Cr 2  8D 02 7A         sta SD_CRC
00087Fr 2  9C FC 79         stz SD_ARG
000882r 2  9C FD 79         stz SD_ARG+1
000885r 2  9C FE 79         stz SD_ARG+2
000888r 2  9C FF 79         stz SD_ARG+3
00088Br 2  A9 00            lda #0
00088Dr 2  20 rr rr         jsr sd_command
000890r 2  60               rts
000891r 2               
000891r 2               ; send SD card CMD8
000891r 2               sd_cmd_8:
000891r 2  A9 87            lda #$87
000893r 2  8D 02 7A         sta SD_CRC
000896r 2                   ; store in little endian
000896r 2                   ; will be converted to big endian when sending command
000896r 2  9C FF 79         stz SD_ARG+3
000899r 2  9C FE 79         stz SD_ARG+2
00089Cr 2  A9 01            lda #1
00089Er 2  8D FD 79         sta SD_ARG+1
0008A1r 2  A9 AA            lda #$AA
0008A3r 2  8D FC 79         sta SD_ARG
0008A6r 2  A9 48            lda #$48
0008A8r 2  20 rr rr         jsr sd_command
0008ABr 2               
0008ABr 2  60               rts
0008ACr 2               
0008ACr 2               sd_command_start:
0008ACr 2  48               pha                         ; Save A
0008ADr 2  AD 01 7A         lda SD_SLAVE
0008B0r 2  20 rr rr         jsr spi_select
0008B3r 2  68               pla                         ; Restore A
0008B4r 2  60               rts
0008B5r 2               
0008B5r 2               sd_command_end:
0008B5r 2  48               pha
0008B6r 2  A9 00            lda #0
0008B8r 2  20 rr rr         jsr spi_select
0008BBr 2  A9 FF            lda #$FF
0008BDr 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
0008C0r 2  68               pla
0008C1r 2  60               rts
0008C2r 2               
0008C2r 2               
0008C2r 2               sd_readsector:
0008C2r 2                   ; Read a sector from the SD card.  A sector is 512 bytes.
0008C2r 2                   ;
0008C2r 2                   ; Parameters:
0008C2r 2                   ;    sd_sector   32-bit sector number
0008C2r 2                   ;    sd_buffer_address     address of buffer to receive data
0008C2r 2  DA               phx
0008C3r 2  20 rr rr         jsr sd_command_start
0008C6r 2                   ; Command 17, arg is sector number, crc not checked
0008C6r 2  A9 11            lda #$11                    ; CMD17 - READ_SINGLE_BLOCK
0008C8r 2  20 rr rr         jsr sd_command
0008CBr 2               
0008CBr 2  C9 00            cmp #0              ; Check if command accepted by card
0008CDr 2  D0 2B            bne @fail
0008CFr 2  A2 FF            ldx #$FF
0008D1r 2               @feloop:
0008D1r 2  CA               dex
0008D2r 2  F0 26            beq @fail           ; the card took too long to get ready
0008D4r 2  A9 FF            lda #$FF
0008D6r 2  20 rr rr         jsr spi_transceive
0008D9r 2  C9 FE            cmp #$FE            ; are we about to receive data ?
0008DBr 2  D0 F4            bne @feloop
0008DDr 2               
0008DDr 2                   ; Read page by page
0008DDr 2  20 rr rr         jsr readpage
0008E0r 2  EE 9F 00         inc sd_buffer_address+1
0008E3r 2  20 rr rr         jsr readpage
0008E6r 2  CE 9F 00         dec sd_buffer_address+1
0008E9r 2               
0008E9r 2  A9 FF            lda #$FF
0008EBr 2  20 rr rr         jsr spi_transceive      ; read and discard CRC
0008EEr 2  A9 FF            lda #$FF
0008F0r 2  20 rr rr         jsr spi_transceive
0008F3r 2  20 rr rr         jsr sd_command_end
0008F6r 2  FA               plx
0008F7r 2  A9 00            lda #0
0008F9r 2  60               rts
0008FAr 2               
0008FAr 2               @fail:
0008FAr 2                   ; return 1 means fail
0008FAr 2  20 rr rr         jsr sd_command_end
0008FDr 2  FA               plx
0008FEr 2  A9 01            lda #1
000900r 2  60               rts
000901r 2               
000901r 2               readpage:
000901r 2                   ; Read 256 bytes to the address at zp_sd_address
000901r 2  5A               phy
000902r 2  A0 00            ldy #0
000904r 2               @readloop:
000904r 2  A9 FF            lda #$FF
000906r 2  20 rr rr         jsr spi_transceive
000909r 2  91 9E            sta (sd_buffer_address),y
00090Br 2  C8               iny
00090Cr 2  D0 F6            bne @readloop
00090Er 2  7A               ply
00090Fr 2  60               rts
000910r 2               
000910r 2               sd_init_success_message:
000910r 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
000914r 2  69 6E 69 74  
000918r 2  20 4F 4B 0D  
00091Dr 2               
00091Dr 2               sd_init_error_message:
00091Dr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
000921r 2  69 6E 69 74  
000925r 2  20 46 41 49  
00092Dr 2               
00092Dr 2               sd_read_error_message:
00092Dr 2  0D 53 44 20      .byte $0D,"SD read FAIL", $0D, 7, 0
000931r 2  72 65 61 64  
000935r 2  20 46 41 49  
00093Dr 2               
00093Dr 1               .include "../../drivers/fat32.s"
00093Dr 2               
00093Dr 2               ; PARTITION TYPE
00093Dr 2               ; 00h 	Unknown or Nothing
00093Dr 2               ; 01h 	12-bit FAT
00093Dr 2               ; 04h 	16-bit FAT (Partition Smallerthan 32MB)
00093Dr 2               ; 05h 	Extended MS-DOS Partition
00093Dr 2               ; 06h 	16-bit FAT (Partition Largerthan 32MB)
00093Dr 2               ; 0Bh 	32-bit FAT (Partition Up to2048GB)
00093Dr 2               ; 0Ch 	Same as 0BH, but uses LBA1 13h Extensions
00093Dr 2               ; 0Eh 	Same as 06H, but uses LBA1 13h Extensions
00093Dr 2               ; 0Fh 	Same as 05H, but uses LBA1 13h Extensions
00093Dr 2               FSTYPE_FAT32 = $0B
00093Dr 2               FSTYPE_FAT32_1 = $0C
00093Dr 2               fat32_readbuffer = SD_BUF
00093Dr 2               
00093Dr 2               fat32_fatstart          = FAT_VARS + $00  ; 4 bytes
00093Dr 2               fat32_datastart         = FAT_VARS + $04  ; 4 bytes
00093Dr 2               fat32_rootcluster       = FAT_VARS + $08  ; 4 bytes
00093Dr 2               fat32_sectorspercluster = FAT_VARS + $0c  ; 1 byte
00093Dr 2               fat32_pendingsectors    = FAT_VARS + $0d  ; 1 byte
00093Dr 2               fat32_address           = FAT_VARS + $0e  ; 2 bytes
00093Dr 2               fat32_nextcluster       = FAT_VARS + $10  ; 4 bytes
00093Dr 2               fat32_bytesremaining    = line; FAT_VARS + $14  ; 4 bytes
00093Dr 2               
00093Dr 2               fat32_filenamepointer   = fat32_bytesremaining  ; only used when searching for a file
00093Dr 2               
00093Dr 2               
00093Dr 2               fat32_init:
00093Dr 2                   ; Initialize the module - read the MBR etc, find the partition,
00093Dr 2                   ; and set up the variables ready for navigating the filesystem
00093Dr 2               
00093Dr 2                   ; Read the MBR and extract pertinent information
00093Dr 2  DA               phx
00093Er 2               
00093Er 2                   ; Sector 0
00093Er 2  A9 00            lda #0
000940r 2  8D FC 79         sta SD_ARG
000943r 2  8D FD 79         sta SD_ARG+1
000946r 2  8D FE 79         sta SD_ARG+2
000949r 2  8D FF 79         sta SD_ARG+3
00094Cr 2               
00094Cr 2                   ; Target buffer
00094Cr 2  A9 DB            lda #<fat32_readbuffer
00094Er 2  8D 9E 00         sta sd_buffer_address
000951r 2  A9 59            lda #>fat32_readbuffer
000953r 2  8D 9F 00         sta sd_buffer_address+1
000956r 2               
000956r 2                   ; Do the read
000956r 2  20 rr rr         jsr sd_readsector
000959r 2               
000959r 2                   ; Check some things
000959r 2  AD D9 5B         lda fat32_readbuffer+510 ; Boot sector signature 55
00095Cr 2  C9 55            cmp #$55
00095Er 2  D0 3B            bne @fail
000960r 2  AD DA 5B         lda fat32_readbuffer+511 ; Boot sector signature aa
000963r 2  C9 AA            cmp #$aa
000965r 2  D0 34            bne @fail
000967r 2               
000967r 2                   ; Find a FAT32 partition
000967r 2  A2 00            ldx #0
000969r 2  BD 9D 5B         lda fat32_readbuffer+$1C2, x
00096Cr 2  C9 0B            cmp #FSTYPE_FAT32
00096Er 2  F0 2E            beq @foundpart
000970r 2  C9 0C            cmp #FSTYPE_FAT32_1
000972r 2  F0 2A            beq @foundpart
000974r 2  A2 10            ldx #$10
000976r 2  BD 9D 5B         lda fat32_readbuffer+$1C2, x
000979r 2  C9 0B            cmp #FSTYPE_FAT32
00097Br 2  F0 21            beq @foundpart
00097Dr 2  C9 0C            cmp #FSTYPE_FAT32_1
00097Fr 2  F0 1D            beq @foundpart
000981r 2               
000981r 2  A2 20            ldx #$20
000983r 2  BD 9D 5B         lda fat32_readbuffer+$1C2, x
000986r 2  C9 0B            cmp #FSTYPE_FAT32
000988r 2  F0 14            beq @foundpart
00098Ar 2  C9 0C            cmp #FSTYPE_FAT32_1
00098Cr 2  F0 10            beq @foundpart
00098Er 2               
00098Er 2  A2 30            ldx #$30
000990r 2  BD 9D 5B         lda fat32_readbuffer+$1C2, x
000993r 2  C9 0B            cmp #FSTYPE_FAT32
000995r 2  F0 07            beq @foundpart
000997r 2  C9 0C            cmp #FSTYPE_FAT32_1
000999r 2  F0 03            beq @foundpart
00099Br 2               
00099Br 2               
00099Br 2               @fail:
00099Br 2  4C rr rr         jmp @error
00099Er 2               
00099Er 2               @foundpart:
00099Er 2                   ; Read the FAT32 LBA BEGIN
00099Er 2               
00099Er 2  BD A1 5B         lda fat32_readbuffer + $1C6,x
0009A1r 2  8D FC 79         sta SD_ARG
0009A4r 2  BD A2 5B         lda fat32_readbuffer+$1C7,x
0009A7r 2  8D FD 79         sta SD_ARG+1
0009AAr 2  BD A3 5B         lda fat32_readbuffer+$1C8,x
0009ADr 2  8D FE 79         sta SD_ARG+2
0009B0r 2  BD A4 5B         lda fat32_readbuffer+$1C9,x
0009B3r 2  8D FF 79         sta SD_ARG+3
0009B6r 2               
0009B6r 2  20 rr rr         jsr sd_readsector   ; read FAT32 Volume ID block
0009B9r 2  C9 01            cmp #1              ; readsector returns 1 on failure
0009BBr 2  F0 DE            beq @fail
0009BDr 2               
0009BDr 2                   ; Check some things
0009BDr 2  AD D9 5B         lda fat32_readbuffer+510 ; FAT32 Volume ID sector signature 55
0009C0r 2  C9 55            cmp #$55
0009C2r 2  D0 D7            bne @fail
0009C4r 2  AD DA 5B         lda fat32_readbuffer+511 ; FAT32 Volume ID sector signature aa
0009C7r 2  C9 AA            cmp #$aa
0009C9r 2  D0 D0            bne @fail
0009CBr 2               
0009CBr 2  AD EC 59         lda fat32_readbuffer+$11 ; RootEntCnt should be 0 for FAT32
0009CEr 2  0D ED 59         ora fat32_readbuffer+$12
0009D1r 2  D0 C8            bne @fail
0009D3r 2               
0009D3r 2  AD EE 59         lda fat32_readbuffer+$13 ; TotSec16 should be 0 for FAT32
0009D6r 2  0D EF 59         ora fat32_readbuffer+$14
0009D9r 2  D0 C0            bne @fail
0009DBr 2               
0009DBr 2                   ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
0009DBr 2  AD E6 59         lda fat32_readbuffer+$0B ; low byte should be zero
0009DEr 2  D0 BB            bne @fail
0009E0r 2  AD E7 59         lda fat32_readbuffer+$0C ; high byte is 2 (512), 4, 8, or 16
0009E3r 2  C9 02            cmp #2
0009E5r 2  D0 B4            bne @fail
0009E7r 2               
0009E7r 2                   ; Calculate the starting sector of the FAT
0009E7r 2  18               clc
0009E8r 2  AD FC 79         lda SD_ARG
0009EBr 2  6D E9 59         adc fat32_readbuffer+$0E    ; reserved sectors lo
0009EEr 2  8D DC 79         sta fat32_fatstart
0009F1r 2  8D E0 79         sta fat32_datastart
0009F4r 2  AD FD 79         lda SD_ARG+1
0009F7r 2  6D EA 59         adc fat32_readbuffer+$0F    ; reserved sectors hi
0009FAr 2  8D DD 79         sta fat32_fatstart+1
0009FDr 2  8D E1 79         sta fat32_datastart+1
000A00r 2  AD FE 79         lda SD_ARG+2
000A03r 2  69 00            adc #0
000A05r 2  8D DE 79         sta fat32_fatstart+2
000A08r 2  8D E2 79         sta fat32_datastart+2
000A0Br 2  AD FF 79         lda SD_ARG+3
000A0Er 2  69 00            adc #0
000A10r 2  8D DF 79         sta fat32_fatstart+3
000A13r 2  8D E3 79         sta fat32_datastart+3
000A16r 2               
000A16r 2                   ; Calculate the starting sector of the data area
000A16r 2  AE EB 59         ldx fat32_readbuffer+16   ; number of FATs
000A19r 2               @skipfatsloop:
000A19r 2  18               clc
000A1Ar 2  AD E0 79         lda fat32_datastart
000A1Dr 2  6D FF 59         adc fat32_readbuffer+36 ; fatsize 0
000A20r 2  8D E0 79         sta fat32_datastart
000A23r 2  AD E1 79         lda fat32_datastart+1
000A26r 2  6D 00 5A         adc fat32_readbuffer+37 ; fatsize 1
000A29r 2  8D E1 79         sta fat32_datastart+1
000A2Cr 2  AD E2 79         lda fat32_datastart+2
000A2Fr 2  6D 01 5A         adc fat32_readbuffer+38 ; fatsize 2
000A32r 2  8D E2 79         sta fat32_datastart+2
000A35r 2  AD E3 79         lda fat32_datastart+3
000A38r 2  6D 02 5A         adc fat32_readbuffer+39 ; fatsize 3
000A3Br 2  8D E3 79         sta fat32_datastart+3
000A3Er 2  CA               dex
000A3Fr 2  D0 D8            bne @skipfatsloop
000A41r 2               
000A41r 2                   ; Sectors-per-cluster is a power of two from 1 to 128
000A41r 2  AD E8 59         lda fat32_readbuffer+13
000A44r 2  8D E8 79         sta fat32_sectorspercluster
000A47r 2               
000A47r 2                   ; Remember the root cluster
000A47r 2  AD 07 5A         lda fat32_readbuffer+44
000A4Ar 2  8D E4 79         sta fat32_rootcluster
000A4Dr 2  AD 08 5A         lda fat32_readbuffer+45
000A50r 2  8D E5 79         sta fat32_rootcluster+1
000A53r 2  AD 09 5A         lda fat32_readbuffer+46
000A56r 2  8D E6 79         sta fat32_rootcluster+2
000A59r 2  AD 0A 5A         lda fat32_readbuffer+47
000A5Cr 2  8D E7 79         sta fat32_rootcluster+3
000A5Fr 2               
000A5Fr 2  FA               plx
000A60r 2  A9 00            lda #0
000A62r 2  60               rts
000A63r 2               
000A63r 2               @error:
000A63r 2  FA               plx
000A64r 2  A9 01            lda #1
000A66r 2  60               rts
000A67r 2               
000A67r 2               
000A67r 2               fat32_seekcluster:
000A67r 2                   ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
000A67r 2               
000A67r 2                   ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
000A67r 2  AD EC 79         lda fat32_nextcluster
000A6Ar 2  0A               asl
000A6Br 2  AD ED 79         lda fat32_nextcluster+1
000A6Er 2  2A               rol
000A6Fr 2  8D FC 79         sta SD_ARG
000A72r 2  AD EE 79         lda fat32_nextcluster+2
000A75r 2  2A               rol
000A76r 2  8D FD 79         sta SD_ARG+1
000A79r 2  AD EF 79         lda fat32_nextcluster+3
000A7Cr 2  2A               rol
000A7Dr 2  8D FE 79         sta SD_ARG+2
000A80r 2                   ; note: cluster numbers never have the top bit set, so no carry can occur
000A80r 2                   ; Add FAT starting sector
000A80r 2  AD FC 79         lda SD_ARG
000A83r 2  6D DC 79         adc fat32_fatstart
000A86r 2  8D FC 79         sta SD_ARG
000A89r 2  AD FD 79         lda SD_ARG+1
000A8Cr 2  6D DD 79         adc fat32_fatstart+1
000A8Fr 2  8D FD 79         sta SD_ARG+1
000A92r 2  AD FE 79         lda SD_ARG+2
000A95r 2  6D DE 79         adc fat32_fatstart+2
000A98r 2  8D FE 79         sta SD_ARG+2
000A9Br 2  A9 00            lda #0
000A9Dr 2  6D DF 79         adc fat32_fatstart+3
000AA0r 2  8D FF 79         sta SD_ARG+3
000AA3r 2                   ; Target buffer
000AA3r 2  A9 DB            lda #<fat32_readbuffer
000AA5r 2  8D 9E 00         sta sd_buffer_address
000AA8r 2  A9 59            lda #>fat32_readbuffer
000AAAr 2  8D 9F 00         sta sd_buffer_address+1
000AADr 2                   ; Read the sector from the FAT
000AADr 2  20 rr rr         jsr sd_readsector
000AB0r 2               
000AB0r 2                   ; Before using this FAT data, set currentsector ready to read the cluster itself
000AB0r 2                   ; We need to multiply the cluster number minus two by the number of sectors per
000AB0r 2                   ; cluster, then add the data region start sector
000AB0r 2               
000AB0r 2                   ; Subtract two from cluster number
000AB0r 2  38               sec
000AB1r 2  AD EC 79         lda fat32_nextcluster
000AB4r 2  E9 02            sbc #2
000AB6r 2  8D FC 79         sta SD_ARG
000AB9r 2  AD ED 79         lda fat32_nextcluster+1
000ABCr 2  E9 00            sbc #0
000ABEr 2  8D FD 79         sta SD_ARG+1
000AC1r 2  AD EE 79         lda fat32_nextcluster+2
000AC4r 2  E9 00            sbc #0
000AC6r 2  8D FE 79         sta SD_ARG+2
000AC9r 2  AD EF 79         lda fat32_nextcluster+3
000ACCr 2  E9 00            sbc #0
000ACEr 2  8D FF 79         sta SD_ARG+3
000AD1r 2               
000AD1r 2                   ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
000AD1r 2  AD E8 79         lda fat32_sectorspercluster
000AD4r 2               @spcshiftloop:
000AD4r 2  4A               lsr
000AD5r 2  B0 0F            bcs @spcshiftloopdone
000AD7r 2  0E FC 79         asl SD_ARG
000ADAr 2  2E FD 79         rol SD_ARG+1
000ADDr 2  2E FE 79         rol SD_ARG+2
000AE0r 2  2E FF 79         rol SD_ARG+3
000AE3r 2  4C rr rr         jmp @spcshiftloop
000AE6r 2               @spcshiftloopdone:
000AE6r 2               
000AE6r 2                   ; Add the data region start sector
000AE6r 2  18               clc
000AE7r 2  AD FC 79         lda SD_ARG
000AEAr 2  6D E0 79         adc fat32_datastart
000AEDr 2  8D FC 79         sta SD_ARG
000AF0r 2  AD FD 79         lda SD_ARG+1
000AF3r 2  6D E1 79         adc fat32_datastart+1
000AF6r 2  8D FD 79         sta SD_ARG+1
000AF9r 2  AD FE 79         lda SD_ARG+2
000AFCr 2  6D E2 79         adc fat32_datastart+2
000AFFr 2  8D FE 79         sta SD_ARG+2
000B02r 2  AD FF 79         lda SD_ARG+3
000B05r 2  6D E3 79         adc fat32_datastart+3
000B08r 2  8D FF 79         sta SD_ARG+3
000B0Br 2               
000B0Br 2                   ; That's now ready for later code to read this sector in - tell it how many consecutive
000B0Br 2                   ; sectors it can now read
000B0Br 2  AD E8 79         lda fat32_sectorspercluster
000B0Er 2  8D E9 79         sta fat32_pendingsectors
000B11r 2               
000B11r 2                   ; Now go back to looking up the next cluster in the chain
000B11r 2                   ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
000B11r 2               
000B11r 2                   ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
000B11r 2  AD EC 79         lda fat32_nextcluster
000B14r 2  29 7F            and #$7f
000B16r 2  0A               asl
000B17r 2  0A               asl
000B18r 2  A8               tay ; Y = low byte of offset
000B19r 2                   ; Add the potentially carried bit to the high byte of the address
000B19r 2  AD 9F 00         lda sd_buffer_address+1
000B1Cr 2  69 00            adc #0
000B1Er 2  8D 9F 00         sta sd_buffer_address+1
000B21r 2               
000B21r 2                   ; Copy out the next cluster in the chain for later use
000B21r 2  B1 9E            lda (sd_buffer_address),y
000B23r 2  8D EC 79         sta fat32_nextcluster
000B26r 2  C8               iny
000B27r 2  B1 9E            lda (sd_buffer_address),y
000B29r 2  8D ED 79         sta fat32_nextcluster+1
000B2Cr 2  C8               iny
000B2Dr 2  B1 9E            lda (sd_buffer_address),y
000B2Fr 2  8D EE 79         sta fat32_nextcluster+2
000B32r 2  C8               iny
000B33r 2  B1 9E            lda (sd_buffer_address),y
000B35r 2  29 0F            and #$0f
000B37r 2  8D EF 79         sta fat32_nextcluster+3
000B3Ar 2               
000B3Ar 2                   ; See if it's the end of the chain
000B3Ar 2  09 F0            ora #$f0
000B3Cr 2  2D EE 79         and fat32_nextcluster+2
000B3Fr 2  2D ED 79         and fat32_nextcluster+1
000B42r 2  C9 FF            cmp #$ff
000B44r 2  D0 0A            bne @notendofchain
000B46r 2  AD EC 79         lda fat32_nextcluster
000B49r 2  C9 F8            cmp #$f8
000B4Br 2  90 03            bcc @notendofchain
000B4Dr 2               
000B4Dr 2                   ; It's the end of the chain, set the top bits so that we can tell this later on
000B4Dr 2  8D EF 79         sta fat32_nextcluster+3
000B50r 2               @notendofchain:
000B50r 2  60               rts
000B51r 2               
000B51r 2               
000B51r 2               fat32_readnextsector:
000B51r 2                   ; Reads the next sector from a cluster chain into the buffer at fat32_address.
000B51r 2                   ;
000B51r 2                   ; Advances the current sector ready for the next read and looks up the next cluster
000B51r 2                   ; in the chain when necessary.
000B51r 2                   ;
000B51r 2                   ; On return, carry is clear if data was read, or set if the cluster chain has ended.
000B51r 2               
000B51r 2                   ; Maybe there are pending sectors in the current cluster
000B51r 2  AD E9 79         lda fat32_pendingsectors
000B54r 2  D0 08            bne @readsector
000B56r 2               
000B56r 2                   ; No pending sectors, check for end of cluster chain
000B56r 2  AD EF 79         lda fat32_nextcluster+3
000B59r 2  30 29            bmi @endofchain
000B5Br 2               
000B5Br 2                   ; Prepare to read the next cluster
000B5Br 2  20 rr rr         jsr fat32_seekcluster
000B5Er 2               
000B5Er 2               @readsector:
000B5Er 2  CE E9 79         dec fat32_pendingsectors
000B61r 2               
000B61r 2                   ; Set up target address
000B61r 2  AD EA 79         lda fat32_address
000B64r 2  8D 9E 00         sta sd_buffer_address
000B67r 2  AD EB 79         lda fat32_address+1
000B6Ar 2  8D 9F 00         sta sd_buffer_address+1
000B6Dr 2               
000B6Dr 2                   ; Read the sector
000B6Dr 2  20 rr rr         jsr sd_readsector
000B70r 2               
000B70r 2                   ; Advance to next sector
000B70r 2  EE FC 79         inc SD_ARG
000B73r 2  D0 0D            bne @sectorincrementdone
000B75r 2  EE FD 79         inc SD_ARG+1
000B78r 2  D0 08            bne @sectorincrementdone
000B7Ar 2  EE FE 79         inc SD_ARG+2
000B7Dr 2  D0 03            bne @sectorincrementdone
000B7Fr 2  EE FF 79         inc SD_ARG+3
000B82r 2               @sectorincrementdone:
000B82r 2               
000B82r 2                   ; Success - clear carry and return
000B82r 2  18               clc
000B83r 2  60               rts
000B84r 2               
000B84r 2               @endofchain:
000B84r 2                   ; End of chain - set carry and return
000B84r 2  38               sec
000B85r 2  60               rts
000B86r 2               
000B86r 2               
000B86r 2               fat32_openroot:
000B86r 2                   ; Prepare to read the root directory
000B86r 2               
000B86r 2  AD E4 79         lda fat32_rootcluster
000B89r 2  8D EC 79         sta fat32_nextcluster
000B8Cr 2  AD E5 79         lda fat32_rootcluster+1
000B8Fr 2  8D ED 79         sta fat32_nextcluster+1
000B92r 2  AD E6 79         lda fat32_rootcluster+2
000B95r 2  8D EE 79         sta fat32_nextcluster+2
000B98r 2  AD E7 79         lda fat32_rootcluster+3
000B9Br 2  8D EF 79         sta fat32_nextcluster+3
000B9Er 2               
000B9Er 2  20 rr rr         jsr fat32_seekcluster
000BA1r 2               
000BA1r 2                   ; Set the pointer to a large value so we always read a sector the first time through
000BA1r 2                   ; lda #$ff
000BA1r 2                   ; sta sd_buffer_address+1
000BA1r 2  A9 00            lda #0   ; return success
000BA3r 2  60               rts
000BA4r 2               
000BA4r 2               
000BA4r 2               fat32_opendirent:
000BA4r 2                   ; Prepare to read from a file or directory based on a dirent
000BA4r 2                   ;
000BA4r 2                   ; Point sd_buffer_address at the dirent
000BA4r 2               
000BA4r 2                   ; Remember file size in bytes remaining
000BA4r 2  A0 1C            ldy #28
000BA6r 2  B1 9E            lda (sd_buffer_address),y
000BA8r 2  8D 92 00         sta fat32_bytesremaining
000BABr 2  C8               iny
000BACr 2  B1 9E            lda (sd_buffer_address),y
000BAEr 2  8D 93 00         sta fat32_bytesremaining+1
000BB1r 2  C8               iny
000BB2r 2  B1 9E            lda (sd_buffer_address),y
000BB4r 2  8D 94 00         sta fat32_bytesremaining+2
000BB7r 2  C8               iny
000BB8r 2  B1 9E            lda (sd_buffer_address),y
000BBAr 2  8D 95 00         sta fat32_bytesremaining+3
000BBDr 2               
000BBDr 2                   ; Seek to first cluster
000BBDr 2  A0 1A            ldy #26
000BBFr 2  B1 9E            lda (sd_buffer_address),y
000BC1r 2  8D EC 79         sta fat32_nextcluster
000BC4r 2  C8               iny
000BC5r 2  B1 9E            lda (sd_buffer_address),y
000BC7r 2  8D ED 79         sta fat32_nextcluster+1
000BCAr 2  A0 14            ldy #20
000BCCr 2  B1 9E            lda (sd_buffer_address),y
000BCEr 2  8D EE 79         sta fat32_nextcluster+2
000BD1r 2  C8               iny
000BD2r 2  B1 9E            lda (sd_buffer_address),y
000BD4r 2  8D EF 79         sta fat32_nextcluster+3
000BD7r 2               
000BD7r 2  20 rr rr         jsr fat32_seekcluster
000BDAr 2               
000BDAr 2                   ; Set the pointer to a large value so we always read a sector the first time through
000BDAr 2                   ; lda #$ff
000BDAr 2                   ; sta sd_buffer_address+1
000BDAr 2               
000BDAr 2  60               rts
000BDBr 2               
000BDBr 2               
000BDBr 2               fat32_readdirent:
000BDBr 2                   ; Read a directory entry from the open directory
000BDBr 2                   ;
000BDBr 2                   ; On exit the carry is set if there were no more directory entries.
000BDBr 2                   ;
000BDBr 2                   ; Otherwise, A is set to the file's attribute byte and
000BDBr 2                   ; zp_sd_address points at the returned directory entry.
000BDBr 2                   ; LFNs and empty entries are ignored automatically.
000BDBr 2               
000BDBr 2                   ; Increment pointer by 32 to point to next entry
000BDBr 2  A9 31            lda #'1'
000BDDr 2  20 rr rr         jsr kernel_putc
000BE0r 2  18               clc
000BE1r 2  AD 9E 00         lda sd_buffer_address
000BE4r 2  69 20            adc #32
000BE6r 2  8D 9E 00         sta sd_buffer_address
000BE9r 2  AD 9F 00         lda sd_buffer_address+1
000BECr 2  69 00            adc #0
000BEEr 2  8D 9F 00         sta sd_buffer_address+1
000BF1r 2               
000BF1r 2                   ; If it's not at the end of the buffer, we have data already
000BF1r 2  C9 5B            cmp #>(fat32_readbuffer+$200)
000BF3r 2  90 20            bcc @gotdata
000BF5r 2               
000BF5r 2  A9 32            lda #'2'
000BF7r 2  20 rr rr         jsr kernel_putc
000BFAr 2               
000BFAr 2                   ; Read another sector
000BFAr 2  A9 DB            lda #<fat32_readbuffer
000BFCr 2  8D EA 79         sta fat32_address
000BFFr 2  A9 59            lda #>fat32_readbuffer
000C01r 2  8D EB 79         sta fat32_address+1
000C04r 2  A9 33            lda #'3'
000C06r 2  20 rr rr         jsr kernel_putc
000C09r 2  20 rr rr         jsr fat32_readnextsector
000C0Cr 2  90 07            bcc @gotdata
000C0Er 2               
000C0Er 2               @endofdirectory:
000C0Er 2  A9 34            lda #'4'
000C10r 2  20 rr rr         jsr kernel_putc
000C13r 2  38               sec
000C14r 2  60               rts
000C15r 2               
000C15r 2               @gotdata:
000C15r 2  A0 00            ldy #0
000C17r 2               @printfname:
000C17r 2  B1 9E            lda (sd_buffer_address),y
000C19r 2  20 rr rr         jsr kernel_putc
000C1Cr 2  C8               iny
000C1Dr 2  C0 0B            cpy #11
000C1Fr 2  90 F6            bcc @printfname
000C21r 2               
000C21r 2                   ; Check first character
000C21r 2  A0 00            ldy #0
000C23r 2  B1 9E            lda (sd_buffer_address),y
000C25r 2               
000C25r 2                   ; End of directory => abort
000C25r 2  F0 E7            beq @endofdirectory
000C27r 2               
000C27r 2                   ; Empty entry => start again
000C27r 2  C9 E5            cmp #$e5
000C29r 2  F0 B0            beq fat32_readdirent
000C2Br 2               
000C2Br 2  A9 35            lda #'5'
000C2Dr 2  20 rr rr         jsr kernel_putc
000C30r 2               
000C30r 2                   ; Check attributes
000C30r 2  A0 0B            ldy #11
000C32r 2  B1 9E            lda (sd_buffer_address),y
000C34r 2  29 3F            and #$3f
000C36r 2  C9 0F            cmp #$0f ; LFN => start again
000C38r 2  F0 A1            beq fat32_readdirent
000C3Ar 2               
000C3Ar 2  A9 36            lda #'6'
000C3Cr 2  20 rr rr         jsr kernel_putc
000C3Fr 2                   ; Yield this result
000C3Fr 2  18               clc
000C40r 2  60               rts
000C41r 2               
000C41r 2               
000C41r 2               fat32_finddirent:
000C41r 2                   ; The directory should already be open for iteration.
000C41r 2                   ; Pointer to filename is in fat32_filenamepointer and fat32_filenamepointer + 1
000C41r 2               
000C41r 2                   ; Iterate until name is found or end of directory
000C41r 2  5A               phy
000C42r 2               @direntloop:
000C42r 2  20 rr rr         jsr fat32_readdirent
000C45r 2  A0 0A            ldy #10
000C47r 2  90 03            bcc @comparenameloop
000C49r 2  A9 01            lda #1
000C4Br 2  60               rts ; return not found
000C4Cr 2               
000C4Cr 2               @comparenameloop:
000C4Cr 2  B1 9E            lda (sd_buffer_address),y
000C4Er 2  20 rr rr         jsr kernel_putc
000C51r 2  D1 92            cmp (fat32_filenamepointer),y
000C53r 2  D0 ED            bne @direntloop ; no match
000C55r 2  88               dey
000C56r 2  10 F4            bpl @comparenameloop
000C58r 2               
000C58r 2                   ; Found it
000C58r 2  7A               ply
000C59r 2  A9 00            lda #0
000C5Br 2  60               rts
000C5Cr 2               
000C5Cr 2               
000C5Cr 2               fat32_file_readbyte:
000C5Cr 2                   ; Read a byte from an open file
000C5Cr 2                   ;
000C5Cr 2                   ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
000C5Cr 2               
000C5Cr 2  38               sec
000C5Dr 2               
000C5Dr 2                   ; Is there any data to read at all?
000C5Dr 2  AD 92 00         lda fat32_bytesremaining
000C60r 2  0D 93 00         ora fat32_bytesremaining+1
000C63r 2  0D 94 00         ora fat32_bytesremaining+2
000C66r 2  0D 95 00         ora fat32_bytesremaining+3
000C69r 2  F0 4C            beq @rts
000C6Br 2               
000C6Br 2                   ; Decrement the remaining byte count
000C6Br 2  AD 92 00         lda fat32_bytesremaining
000C6Er 2  E9 01            sbc #1
000C70r 2  8D 92 00         sta fat32_bytesremaining
000C73r 2  AD 93 00         lda fat32_bytesremaining+1
000C76r 2  E9 00            sbc #0
000C78r 2  8D 93 00         sta fat32_bytesremaining+1
000C7Br 2  AD 94 00         lda fat32_bytesremaining+2
000C7Er 2  E9 00            sbc #0
000C80r 2  8D 94 00         sta fat32_bytesremaining+2
000C83r 2  AD 95 00         lda fat32_bytesremaining+3
000C86r 2  E9 00            sbc #0
000C88r 2  8D 95 00         sta fat32_bytesremaining+3
000C8Br 2               
000C8Br 2                   ; Need to read a new sector?
000C8Br 2  AD 9F 00         lda sd_buffer_address+1
000C8Er 2  C9 5B            cmp #>(fat32_readbuffer+$200)
000C90r 2  90 0F            bcc @gotdata
000C92r 2               
000C92r 2                   ; Read another sector
000C92r 2  A9 DB            lda #<fat32_readbuffer
000C94r 2  8D EA 79         sta fat32_address
000C97r 2  A9 59            lda #>fat32_readbuffer
000C99r 2  8D EB 79         sta fat32_address+1
000C9Cr 2               
000C9Cr 2  20 rr rr         jsr fat32_readnextsector
000C9Fr 2  B0 16            bcs @rts                    ; this shouldn't happen
000CA1r 2               
000CA1r 2               @gotdata:
000CA1r 2  A0 00            ldy #0
000CA3r 2  B1 9E            lda (sd_buffer_address),y
000CA5r 2               
000CA5r 2  EE 9E 00         inc sd_buffer_address
000CA8r 2  D0 0D            bne @rts
000CAAr 2  EE 9F 00         inc sd_buffer_address+1
000CADr 2  D0 08            bne @rts
000CAFr 2  EE A0 00         inc sd_buffer_address+2
000CB2r 2  D0 03            bne @rts
000CB4r 2  EE A1 00         inc sd_buffer_address+3
000CB7r 2               
000CB7r 2               @rts:
000CB7r 2  60               rts
000CB8r 2               
000CB8r 2               
000CB8r 2               fat32_file_read:
000CB8r 2                   ; Read a whole file into memory.  It's assumed the file has just been opened
000CB8r 2                   ; and no data has been read yet.
000CB8r 2                   ;
000CB8r 2                   ; Also we read whole sectors, so data in the target region beyond the end of the
000CB8r 2                   ; file may get overwritten, up to the next 512-byte boundary.
000CB8r 2                   ;
000CB8r 2                   ; And we don't properly support 64k+ files, as it's unnecessary complication given
000CB8r 2                   ; the 6502's small address space
000CB8r 2               
000CB8r 2                   ; Round the size up to the next whole sector
000CB8r 2  AD 92 00         lda fat32_bytesremaining
000CBBr 2  C9 01            cmp #1                      ; set carry if bottom 8 bits not zero
000CBDr 2  AD 93 00         lda fat32_bytesremaining+1
000CC0r 2  69 00            adc #0                      ; add carry, if any
000CC2r 2  4A               lsr                         ; divide by 2
000CC3r 2  69 00            adc #0                      ; round up
000CC5r 2               
000CC5r 2                   ; No data?
000CC5r 2  F0 17            beq @done
000CC7r 2               
000CC7r 2                   ; Store sector count - not a byte count any more
000CC7r 2  8D 92 00         sta fat32_bytesremaining
000CCAr 2               
000CCAr 2                   ; Read entire sectors to the user-supplied buffer
000CCAr 2               @wholesectorreadloop:
000CCAr 2                   ; Read a sector to fat32_address
000CCAr 2  20 rr rr         jsr fat32_readnextsector
000CCDr 2               
000CCDr 2                   ; Advance fat32_address by 512 bytes
000CCDr 2  AD EB 79         lda fat32_address+1
000CD0r 2  69 02            adc #2                      ; carry already clear
000CD2r 2  8D EB 79         sta fat32_address+1
000CD5r 2               
000CD5r 2  AE 92 00         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
000CD8r 2  CA               dex
000CD9r 2  8E 92 00         stx fat32_bytesremaining    ; note - actually stores sectors remaining
000CDCr 2               
000CDCr 2  D0 EC            bne @wholesectorreadloop
000CDEr 2               
000CDEr 2               @done:
000CDEr 2  60               rts
000CDFr 2               
000CDFr 2               
000CDFr 1               
000CDFr 1               .include "../taliforth.asm" ; Top-level definitions, memory map
000CDFr 2               ; Tali Forth 2 for the 65c02
000CDFr 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000CDFr 2               ; First version: 19. Jan 2014 (Tali Forth 1)
000CDFr 2               ; This version: 03. Jan 2018 (Version 1.0)
000CDFr 2               
000CDFr 2               ; This is the main file for Tali Forth 2
000CDFr 2               
000CDFr 2               ; Label used to calculate UNUSED. Silly for Tali Forth, where we assume
000CDFr 2               ; 32 KiB RAM and 32 KiB ROM, but kept here to make the code more useful for
000CDFr 2               ; other hardware configurations
000CDFr 2               code0:
000CDFr 2               
000CDFr 2               .include "definitions.asm"      ; Top-level definitions, memory map
000CDFr 3               ; Definitions for Tali Forth 2
000CDFr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000CDFr 3               ; First version: 01. Apr 2016 (Liara Forth)
000CDFr 3               ; This version: 29. Jan 2020
000CDFr 3               
000CDFr 3               ; This file is included by taliforth.asm. These are the general
000CDFr 3               ; definitions; platform-specific definitions such as the
000CDFr 3               ; memory map are kept in the platform folder.
000CDFr 3               
000CDFr 3               
000CDFr 3               ; ZERO PAGE ADDRESSES/VARIABLES
000CDFr 3               
000CDFr 3               ; These are kept at the top of Zero Page, with the most important variables at
000CDFr 3               ; the top because the Data Stack grows towards this area from dsp0: If there is
000CDFr 3               ; an overflow, the lower, less important variables will be clobbered first,
000CDFr 3               ; giving the system a chance to recover. In other words, they are part of the
000CDFr 3               ; floodplain.
000CDFr 3               
000CDFr 3               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000CDFr 3               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000CDFr 3               
000CDFr 3               cp =        user0+0   ; Compiler Pointer
000CDFr 3               dp =        user0+2   ; Dictionary Pointer
000CDFr 3               workword =  user0+4   ; nt (not xt!) of word being compiled, except in
000CDFr 3                                          ; a :NONAME declared word (see status)
000CDFr 3               insrc =     user0+6   ; input Source for SOURCE-ID
000CDFr 3               cib =       user0+8   ; address of current input buffer
000CDFr 3               ciblen =    user0+10  ; length of current input buffer
000CDFr 3               toin =      user0+12  ; pointer to CIB (>IN in Forth)
000CDFr 3               ip =        user0+14  ; Instruction Pointer (current xt)
000CDFr 3               output =    user0+16  ; vector for EMIT
000CDFr 3               input =     user0+18  ; vector for KEY
000CDFr 3               havekey =   user0+20  ; vector for KEY?
000CDFr 3               state =     user0+22  ; STATE: -1 compile, 0 interpret
000CDFr 3               base =      user0+24  ; number radix, default decimal
000CDFr 3               nc_limit =   user0+26  ; limit for Native Compile size
000CDFr 3               uf_strip =   user0+28  ; flag to strip underflow detection code
000CDFr 3               up =        user0+30  ; User Pointer (Address of user variables)
000CDFr 3               status =    user0+32  ; internal status information
000CDFr 3                                          ; (used by : :NONAME ; ACCEPT)
000CDFr 3                                          ; Bit 7 = Redefined word message postpone
000CDFr 3                                          ;         When set before calling CREATE, it will
000CDFr 3                                          ;         not print the "redefined xxxx" message if
000CDFr 3                                          ;         the word exists. Instead, this bit will
000CDFr 3                                          ;         be reused and after CREATE has run, it will
000CDFr 3                                          ;         be set if the word was redefined and 0 if
000CDFr 3                                          ;         not. This bit should be 0 when not in use.
000CDFr 3                                          ; Bit 6 = 1 for normal ":" definitions
000CDFr 3                                          ;         WORKWORD contains nt of word being compiled
000CDFr 3                                          ;       = 0 for :NONAME definitions
000CDFr 3                                          ;         WORKWORD contains xt of word being compiled
000CDFr 3                                          ; Bit 5 = 1 for NUMBER returning a double word
000CDFr 3                                          ;       = 0 for NUMBER returning a single word
000CDFr 3                                          ; Bit 3 = 1 makes CTRL-n recall current history
000CDFr 3                                          ;       = 0 CTRL-n recalls previous history
000CDFr 3                                          ; Bit 2 = Current history buffer msb
000CDFr 3                                          ; Bit 1 = Current history buffer (0-7, wraps)
000CDFr 3                                          ; Bit 0 = Current history buffer lsb
000CDFr 3                                          ; status+1 is used by ACCEPT to hold history lengths.
000CDFr 3               tmpbranch = user0+34  ; temporary storage for 0BRANCH, BRANCH only
000CDFr 3               tmp1 =      user0+36  ; temporary storage
000CDFr 3               tmp2 =      user0+38  ; temporary storage
000CDFr 3               tmp3 =      user0+40  ; temporary storage (especially for print)
000CDFr 3               tmpdsp =    user0+42  ; temporary DSP (X) storage (two bytes)
000CDFr 3               tmptos =    user0+44  ; temporary TOS storage
000CDFr 3               editor1 =   user0+46  ; temporary for editors
000CDFr 3               editor2 =   user0+48  ; temporary for editors
000CDFr 3               editor3 =   user0+50  ; temporary for editors
000CDFr 3               tohold =    user0+52  ; pointer for formatted output
000CDFr 3               scratch =   user0+54  ; 8 byte scratchpad (see UM/MOD)
000CDFr 3               
000CDFr 3               ; Zero Page:
000CDFr 3               ; Bytes used for variables: 62 ($0000-$003D)
000CDFr 3               ; First usable Data Stack location: $003E (decimal 62)
000CDFr 3               ; Bytes avaible for Data Stack: 128-62 = 66 --> 33 16-bit cells
000CDFr 3               
000CDFr 3               dsp0 =      zpage_end-7    ; initial Data Stack Pointer
000CDFr 3               
000CDFr 3               ; User Variables:
000CDFr 3               ; Block variables
000CDFr 3               blk_offset =  0        ; BLK : UP + 0
000CDFr 3               scr_offset =  2        ; SCR : UP + 2
000CDFr 3               
000CDFr 3               ; Wordlists
000CDFr 3               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000CDFr 3               num_wordlists_offset =  5
000CDFr 3                                          ; #WORDLISTS (byte) : UP + 5
000CDFr 3               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000CDFr 3                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000CDFr 3               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000CDFr 3                                          ;          (Number of wordlists in search order)
000CDFr 3               search_order_offset =  31
000CDFr 3                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000CDFr 3                                          ; Allowing for 9 to keep offsets even.
000CDFr 3               max_wordlists =  12    ; Maximum number of wordlists supported
000CDFr 3                                          ; 4 Tali built-ins + 8 user wordlists
000CDFr 3               
000CDFr 3               ; Buffer variables
000CDFr 3               blkbuffer_offset =     40   ; Address of buffer
000CDFr 3               buffblocknum_offset =  42   ; Block number current in buffer
000CDFr 3               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000CDFr 3               
000CDFr 3               ; Block I/O vectors
000CDFr 3               blockread_offset =     46   ; Vector to block reading routine
000CDFr 3               blockwrite_offset =    48   ; Vector to block writing routine
000CDFr 3               
000CDFr 3               
000CDFr 3               ; ASCII CHARACTERS
000CDFr 3               AscCC =   $03  ; break (CTRL-c)
000CDFr 3               AscBELL = $07  ; bell sound
000CDFr 3               AscBS =   $08  ; backspace
000CDFr 3               AscLF =   $0a  ; line feed
000CDFr 3               AscCR =   $0d  ; carriage return
000CDFr 3               AscESC =  $1b  ; escape
000CDFr 3               AscSP =   $20  ; space
000CDFr 3               AscDEL =  $7f  ; delete (CTRL-h)
000CDFr 3               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000CDFr 3               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000CDFr 3               
000CDFr 3               ; DICTIONARY FLAGS
000CDFr 3               ; The first three bits are currently unused
000CDFr 3               CO = 1  ; Compile Only
000CDFr 3               AN = 2  ; Always Native Compile
000CDFr 3               IM = 4  ; Immediate Word
000CDFr 3               NN = 8  ; Never Native Compile
000CDFr 3               UF = 16 ; Includes Underflow Check (RESERVED)
000CDFr 3               HC = 32 ; Word has Code Field Area (CFA)
000CDFr 3               
000CDFr 3               
000CDFr 3               ; VARIOUS
000CDFr 3               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000CDFr 3               
000CDFr 3               ; END
000CDFr 3               
000CDFr 2               
000CDFr 2               ; Insert point for Tali Forth after kernel hardware setup
000CDFr 2               forth:
000CDFr 2               
000CDFr 2               .include "native_words.asm"     ; Native Forth words. Starts with COLD
000CDFr 3               ; Low-level Forth word routines
000CDFr 3               ; Tali Forth 2 for the 65c02
000CDFr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000CDFr 3               ; First version: 19. Jan 2014
000CDFr 3               ; This version: 03. Jan 2018
000CDFr 3               
000CDFr 3               ; This list is ordered alphabetically by the names of the words, not their
000CDFr 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000CDFr 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000CDFr 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000CDFr 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000CDFr 3               
000CDFr 3               ;       TBA --> fragment --> coded --> tested --> auto
000CDFr 3               
000CDFr 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000CDFr 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000CDFr 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000CDFr 3               
000CDFr 3               ; ## COLD ( -- ) "Reset the Forth system"
000CDFr 3               ; ## "cold"  tested  Tali Forth
000CDFr 3               ;       """Reset the Forth system. Does not restart the kernel,
000CDFr 3               ;       use the 65c02 reset for that. Flows into ABORT.
000CDFr 3               ;       """
000CDFr 3               xt_cold:
000CDFr 3  D8                           cld
000CE0r 3               
000CE0r 3                               ; Set the OUTPUT vector to the default kernel_putc
000CE0r 3                               ; We do this really early so we can print error messages
000CE0r 3                               ; during debugging
000CE0r 3  A9 rr                        lda #<kernel_putc
000CE2r 3  85 10                        sta output
000CE4r 3  A9 rr                        lda #>kernel_putc
000CE6r 3  85 11                        sta output+1
000CE8r 3               
000CE8r 3                               ; Load all of the important zero page variables from ROM
000CE8r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
000CEAr 3               
000CEAr 3               @load_zp_loop:
000CEAr 3                               ; This loop loads them back to front. We can use X here
000CEAr 3                               ; because Tali hasn't started using the stack yet.
000CEAr 3  BD rr rr                     lda cold_zp_table,x
000CEDr 3  95 00                        sta zpage,x
000CEFr 3  CA                           dex
000CF0r 3  D0 F8                        bne @load_zp_loop
000CF2r 3               
000CF2r 3                               ; Copy the 0th element.
000CF2r 3  AD rr rr                     lda cold_zp_table
000CF5r 3  85 00                        sta zpage
000CF7r 3               
000CF7r 3                               ; Initialize 65c02 stack (Return Stack)
000CF7r 3  A2 FF                        ldx #rsp0
000CF9r 3  9A                           txs
000CFAr 3               
000CFAr 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
000CFAr 3                               ; can load high-level words with EVALUATE
000CFAr 3  A2 78                        ldx #dsp0
000CFCr 3               
000CFCr 3                               ; Initialize the user variables.
000CFCr 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
000CFEr 3  A9 00                        lda #0
000D00r 3               
000D00r 3               @load_user_vars_loop:
000D00r 3                               ; Like the zero page variables, these are initialized
000D00r 3                               ; back to front.
000D00r 3  B9 rr rr                     lda cold_user_table,y
000D03r 3  91 1E                        sta (up),y
000D05r 3  88                           dey
000D06r 3  D0 F8                        bne @load_user_vars_loop
000D08r 3               
000D08r 3                               ; Copy the 0th element.
000D08r 3  AD rr rr                     lda cold_user_table
000D0Br 3  92 1E                        sta (up)
000D0Dr 3  20 rr rr                     jsr xt_cr
000D10r 3               
000D10r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
000D10r 3                               ; you do not have any high-level words, this part can be
000D10r 3                               ; commented out.
000D10r 3  CA                           dex
000D11r 3  CA                           dex
000D12r 3  CA                           dex
000D13r 3  CA                           dex
000D14r 3               
000D14r 3                               ; start address goes NOS
000D14r 3  A9 rr                        lda #<forth_words_start
000D16r 3  95 02                        sta 2,x
000D18r 3  A9 rr                        lda #>forth_words_start
000D1Ar 3  95 03                        sta 3,x
000D1Cr 3               
000D1Cr 3                               ; length goes TOS
000D1Cr 3  A9 rr                        lda #<forth_words_end
000D1Er 3  38                           sec
000D1Fr 3  E9 rr                        sbc #<forth_words_start
000D21r 3  95 00                        sta 0,x
000D23r 3               
000D23r 3  A9 rr                        lda #>forth_words_end
000D25r 3  E9 rr                        sbc #>forth_words_start
000D27r 3  95 01                        sta 1,x
000D29r 3               
000D29r 3  20 rr rr                     jsr xt_evaluate
000D2Cr 3               
000D2Cr 3                               ; Now define any user words via EVALUATE. If you do not have
000D2Cr 3                               ; any user-defined words, this part can be commented out as
000D2Cr 3                               ; well.
000D2Cr 3  CA                           dex
000D2Dr 3  CA                           dex
000D2Er 3  CA                           dex
000D2Fr 3  CA                           dex
000D30r 3               
000D30r 3                               ; start address goes NOS
000D30r 3  A9 rr                        lda #<user_words_start
000D32r 3  95 02                        sta 2,x
000D34r 3  A9 rr                        lda #>user_words_start
000D36r 3  95 03                        sta 3,x
000D38r 3               
000D38r 3                               ; length goes TOS
000D38r 3  A9 rr                        lda #<user_words_end
000D3Ar 3  38                           sec
000D3Br 3  E9 rr                        sbc #<user_words_start
000D3Dr 3  95 00                        sta 0,x
000D3Fr 3               
000D3Fr 3  A9 rr                        lda #>user_words_end
000D41r 3  E9 rr                        sbc #>user_words_start
000D43r 3  95 01                        sta 1,x
000D45r 3               
000D45r 3  20 rr rr                     jsr xt_evaluate
000D48r 3               
000D48r 3                               ; Initialize all of the history buffers by putting a zero in
000D48r 3                               ; each length byte.
000D48r 3  9C 00 7C                     stz hist_buff
000D4Br 3  9C 80 7C                     stz hist_buff+$80
000D4Er 3  9C 00 7D                     stz hist_buff+$100
000D51r 3  9C 80 7D                     stz hist_buff+$180
000D54r 3  9C 00 7E                     stz hist_buff+$200
000D57r 3  9C 80 7E                     stz hist_buff+$280
000D5Ar 3  9C 00 7F                     stz hist_buff+$300
000D5Dr 3  9C 80 7F                     stz hist_buff+$380
000D60r 3               
000D60r 3                               ; fall through to ABORT
000D60r 3               
000D60r 3               
000D60r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
000D60r 3               ; ## "abort"  tested  ANS core
000D60r 3                       ; """https://forth-standard.org/standard/core/ABORT
000D60r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
000D60r 3                       ; subroutine if we want to because we are going to reset the 65c02's
000D60r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
000D60r 3                       ; actually delete the stuff on the Data Stack.
000D60r 3                       ; """
000D60r 3               xt_abort:
000D60r 3  A2 78                        ldx #dsp0
000D62r 3               
000D62r 3                               ; fall through to QUIT
000D62r 3               
000D62r 3               
000D62r 3               ; ## QUIT ( -- ) "Reset the input and get new input"
000D62r 3               ; ## "quit"  tested  ANS core
000D62r 3                       ; """https://forth-standard.org/standard/core/QUIT
000D62r 3                       ; Rest the input and start command loop
000D62r 3                       ; """
000D62r 3               
000D62r 3               xt_quit:
000D62r 3                               ; Clear the Return Stack. This is a little screwed up
000D62r 3                               ; because the 65c02 can only set the Return Stack via X,
000D62r 3                               ; which is our Data Stack pointer. The ANS specification
000D62r 3                               ; demands, however, that ABORT reset the Data Stack pointer
000D62r 3  8A                           txa             ; Save the DSP that we just defined
000D63r 3  A2 FF                        ldx #rsp0
000D65r 3  9A                           txs
000D66r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000D67r 3               
000D67r 3                               ; make sure instruction pointer is empty
000D67r 3  64 0E                        stz ip
000D69r 3  64 0F                        stz ip+1
000D6Br 3               
000D6Br 3                               ; SOURCE-ID is zero (keyboard input)
000D6Br 3  64 06                        stz insrc
000D6Dr 3  64 07                        stz insrc+1
000D6Fr 3               
000D6Fr 3                               ; STATE is zero (interpret, not compile)
000D6Fr 3  64 16                        stz state
000D71r 3  64 17                        stz state+1
000D73r 3               @get_line:
000D73r 3  A9 00                        lda #<buffer0   ; input buffer, this is paranoid
000D75r 3  85 08                        sta cib
000D77r 3  A9 02                        lda #>buffer0
000D79r 3  85 09                        sta cib+1
000D7Br 3               
000D7Br 3                               ; Size of current input buffer (CIB) is zero
000D7Br 3  64 0A                        stz ciblen
000D7Dr 3  64 0B                        stz ciblen+1
000D7Fr 3               
000D7Fr 3                               ; Accept a line from the current import source. This is how
000D7Fr 3                               ; modern Forths to it.
000D7Fr 3  20 rr rr                     jsr xt_refill           ; ( -- f )
000D82r 3               
000D82r 3                               ; Test flag: LSB of TOS
000D82r 3  B5 00                        lda 0,x
000D84r 3  D0 05                        bne @success
000D86r 3               
000D86r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
000D86r 3                               ; need to print an error message and reset the machine. We
000D86r 3                               ; don't need to save TOS because we're going to clobber it
000D86r 3                               ; anyway when we go back to ABORT.
000D86r 3  A9 06                        lda #err_refill
000D88r 3  4C rr rr                     jmp error
000D8Br 3               
000D8Br 3               @success:
000D8Br 3                               ; Assume we have successfully accepted a string of input from
000D8Br 3                               ; a source, with address cib and length of input in ciblen. We
000D8Br 3                               ; arrive here still with the TRUE flag from REFILL as TOS
000D8Br 3  E8                           inx                     ; drop
000D8Cr 3  E8                           inx
000D8Dr 3               
000D8Dr 3                               ; Main compile/execute routine
000D8Dr 3  20 rr rr                     jsr interpret
000D90r 3               
000D90r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
000D90r 3                               ; overflow because it is so rare
000D90r 3  E0 78                        cpx #dsp0
000D92r 3  F0 05                        beq @stack_ok
000D94r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
000D96r 3               
000D96r 3  4C rr rr                     jmp underflow_error
000D99r 3               
000D99r 3               @stack_ok:
000D99r 3                               ; Display system prompt if all went well. If we're interpreting,
000D99r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
000D99r 3                               ; space at beginning of the string.
000D99r 3  A5 16                        lda state
000D9Br 3  F0 02                        beq @print
000D9Dr 3               
000D9Dr 3  A9 01                        lda #1                  ; number for "compile" string
000D9Fr 3               @print:
000D9Fr 3  20 rr rr                     jsr print_string
000DA2r 3               
000DA2r 3                               ; Awesome line, everybody! Now get the next one.
000DA2r 3  80 CF                        bra @get_line
000DA4r 3               
000DA4r 3               z_cold:
000DA4r 3               z_abort:
000DA4r 3               z_quit:         ; no RTS required
000DA4r 3               
000DA4r 3               
000DA4r 3               
000DA4r 3               ; This table holds all of the initial values for the variables in zero page.
000DA4r 3               ; This table is used by COLD.
000DA4r 3               cold_zp_table:
000DA4r 3  FF 07                .word cp0+256+1024      ; cp moved to make room for user vars and
000DA6r 3                                               ; block buffer
000DA6r 3  rr rr                .word dictionary_start  ; dp
000DA8r 3  00 00                .word 0                 ; workword
000DAAr 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000DACr 3  00 02                .word buffer0           ; cib
000DAEr 3  00 00                .word 0                 ; ciblen
000DB0r 3  00 00                .word 0                 ; toin
000DB2r 3  00 00                .word 0                 ; ip
000DB4r 3  rr rr                .word kernel_putc       ; output
000DB6r 3  rr rr                .word kernel_getc       ; input
000DB8r 3  00 00                .word 0                 ; havekey
000DBAr 3  00 00                .word 0                 ; state (0 = interpret)
000DBCr 3  0A 00                .word 10                ; base
000DBEr 3  14 00                .word 20                ; nc-limit
000DC0r 3  00 00                .word 0                 ; uf_strip (off by default)
000DC2r 3  FF 02                .word cp0               ; up (user vars put right at beginning of
000DC4r 3                                               ; available RAM)
000DC4r 3  00 00                .word 0                 ; status
000DC6r 3               cold_zp_table_end:
000DC6r 3               
000DC6r 3               ; No further ZP variables are initialized. The variables past this point are
000DC6r 3               ; all temporaries.
000DC6r 3               
000DC6r 3               ; This table holds the inital values for the user variables. This table is
000DC6r 3               ; used by COLD.
000DC6r 3               cold_user_table:
000DC6r 3  00 00                .word 0                         ; BLK
000DC8r 3  00 00                .word 0                         ; SCR
000DCAr 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
000DCBr 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000DCCr 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
000DCEr 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
000DD0r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
000DD2r 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
000DD4r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000DD8r 3  00 00 00 00  
000DDCr 3  00 00 00 00  
000DE4r 3  01                   .byte 1                         ; #ORDER
000DE5r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
000DE9r 3  00 00 00 00  
000DEDr 3  00           
000DEEr 3  FF 03                .word cp0+256                   ; Address of buffer (right after USER vars)
000DF0r 3  00 00                .word 0                         ; block in buffer
000DF2r 3  00 00                .word 0                         ; buffer status (not in use)
000DF4r 3  rr rr                .word xt_block_word_error       ; block-read vector
000DF6r 3  rr rr                .word xt_block_word_error       ; block-write vector
000DF8r 3               cold_user_table_end:
000DF8r 3               
000DF8r 3               
000DF8r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
000DF8r 3               ; ## "abort""  tested  ANS core
000DF8r 3                       ; """https://forth-standard.org/standard/core/ABORTq
000DF8r 3                       ; Abort and print a string.
000DF8r 3                       ; """
000DF8r 3               
000DF8r 3               xt_abort_quote:
000DF8r 3                               ; save the string
000DF8r 3  20 rr rr                     jsr xt_s_quote          ; S"
000DFBr 3               
000DFBr 3                               ; compile run-time part
000DFBr 3  A0 rr                        ldy #>abort_quote_runtime
000DFDr 3  A9 rr                        lda #<abort_quote_runtime
000DFFr 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000E02r 3               
000E02r 3  60           z_abort_quote:  rts
000E03r 3               
000E03r 3               
000E03r 3               abort_quote_runtime:
000E03r 3                       ; """Runtime aspect of ABORT_QUOTE"""
000E03r 3               
000E03r 3                               ; We arrive here with ( f addr u )
000E03r 3  B5 04                        lda 4,x
000E05r 3  15 05                        ora 5,x
000E07r 3  F0 09                        beq @done       ; if FALSE, we're done
000E09r 3               
000E09r 3                               ; We're true, so print string and ABORT. We follow Gforth
000E09r 3                               ; in going to a new line after the string
000E09r 3  20 rr rr                     jsr xt_type
000E0Cr 3  20 rr rr                     jsr xt_cr
000E0Fr 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000E12r 3               @done:
000E12r 3                               ; Drop three entries from the Data Stack
000E12r 3  8A                           txa
000E13r 3  18                           clc
000E14r 3  69 06                        adc #6
000E16r 3  AA                           tax
000E17r 3               
000E17r 3  60                           rts
000E18r 3               
000E18r 3               
000E18r 3               
000E18r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
000E18r 3               ; ## "abs"  auto  ANS core
000E18r 3                       ; """https://forth-standard.org/standard/core/ABS
000E18r 3                       ; Return the absolute value of a number.
000E18r 3                       ; """
000E18r 3               
000E18r 3               xt_abs:
000E18r 3  20 rr rr                     jsr underflow_1
000E1Br 3               
000E1Br 3  B5 01                        lda 1,x
000E1Dr 3  10 0D                        bpl @done       ; positive number, easy money!
000E1Fr 3               
000E1Fr 3                               ; negative: calculate 0 - n
000E1Fr 3  38                           sec
000E20r 3  A9 00                        lda #0
000E22r 3  F5 00                        sbc 0,x         ; LSB
000E24r 3  95 00                        sta 0,x
000E26r 3               
000E26r 3  A9 00                        lda #0          ; MSB
000E28r 3  F5 01                        sbc 1,x
000E2Ar 3  95 01                        sta 1,x
000E2Cr 3               
000E2Cr 3               @done:
000E2Cr 3  60           z_abs:          rts
000E2Dr 3               
000E2Dr 3               
000E2Dr 3               
000E2Dr 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
000E2Dr 3               ; ## "accept"  auto  ANS core
000E2Dr 3                       ; """https://forth-standard.org/standard/core/ACCEPT
000E2Dr 3                       ; Receive a string of at most n1 characters, placing them at
000E2Dr 3                       ; addr. Return the actual number of characters as n2. Characters
000E2Dr 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
000E2Dr 3                       ; modern Forths.
000E2Dr 3                       ; """
000E2Dr 3               
000E2Dr 3               xt_accept:
000E2Dr 3  20 rr rr                     jsr underflow_2
000E30r 3               
000E30r 3                               ; Abort if we were asked to receive 0 chars
000E30r 3  B5 00                        lda 0,x
000E32r 3  15 01                        ora 1,x
000E34r 3  D0 09                        bne @not_zero
000E36r 3               
000E36r 3  E8                           inx
000E37r 3  E8                           inx
000E38r 3  74 00                        stz 0,x
000E3Ar 3  74 01                        stz 1,x
000E3Cr 3               
000E3Cr 3  4C rr rr                     jmp accept_done
000E3Fr 3               
000E3Fr 3               @not_zero:
000E3Fr 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000E41r 3  85 26                        sta tmp2
000E43r 3  64 27                        stz tmp2+1      ; ... but we only accept max 255 chars
000E45r 3               
000E45r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000E47r 3  85 24                        sta tmp1
000E49r 3  B5 03                        lda 3,x
000E4Br 3  85 25                        sta tmp1+1
000E4Dr 3               
000E4Dr 3  E8                           inx
000E4Er 3  E8                           inx
000E4Fr 3               
000E4Fr 3  A0 00                        ldy #0
000E51r 3               
000E51r 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
000E51r 3                               ; from bit 2 to 3 is OK)
000E51r 3  A5 20                        lda status
000E53r 3  29 F7                        and #$f7
000E55r 3               
000E55r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000E55r 3  1A                           inc
000E56r 3               
000E56r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000E56r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000E56r 3                               ; received and won't be used to calculate the history buffer
000E56r 3                               ; offset.
000E56r 3  09 08                        ora #$08
000E58r 3  85 20                        sta status
000E5Ar 3               
000E5Ar 3               accept_loop:
000E5Ar 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000E5Ar 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000E5Ar 3                               ; vt100 terminal clears the screen automatically.
000E5Ar 3               
000E5Ar 3                               ; This is the internal version of KEY without all the mucking
000E5Ar 3                               ; about with the Data Stack while still using the input vector
000E5Ar 3  20 rr rr                     jsr key_a
000E5Dr 3               
000E5Dr 3                               ; We quit on both line feed and carriage return
000E5Dr 3  C9 0A                        cmp #AscLF
000E5Fr 3  F0 20                        beq @eol
000E61r 3  C9 0D                        cmp #AscCR
000E63r 3  F0 1C                        beq @eol
000E65r 3               
000E65r 3                               ; BACKSPACE and DEL do the same thing for the moment
000E65r 3  C9 08                        cmp #AscBS
000E67r 3  F0 22                        beq @backspace
000E69r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000E6Br 3  F0 1E                        beq @backspace
000E6Dr 3               
000E6Dr 3                               ; Check for CTRL-p and CTRL-n to recall input history
000E6Dr 3  C9 10                        cmp #AscCP
000E6Fr 3  F0 36                        beq @ctrl_p
000E71r 3  C9 0E                        cmp #AscCN
000E73r 3  F0 44                        beq @ctrl_n
000E75r 3               
000E75r 3                               ; That's enough for now. Save and echo character.
000E75r 3  91 24                        sta (tmp1),y
000E77r 3  C8                           iny
000E78r 3               
000E78r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000E78r 3  20 rr rr                     jsr emit_a
000E7Br 3               
000E7Br 3  C4 26                        cpy tmp2        ; reached character limit?
000E7Dr 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
000E7Fr 3  80 03                        bra @buffer_full
000E81r 3               
000E81r 3               @eol:
000E81r 3  20 rr rr                     jsr xt_space    ; print final space
000E84r 3               
000E84r 3               @buffer_full:
000E84r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
000E84r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
000E86r 3  74 01                        stz 1,x         ; we only accept 256 chars
000E88r 3               
000E88r 3  4C rr rr                     jmp accept_done
000E8Br 3               
000E8Br 3               @backspace:
000E8Br 3                               ; Handle backspace and delete kex, which currently do the same
000E8Br 3                               ; thing
000E8Br 3  C0 00                        cpy #0          ; buffer empty?
000E8Dr 3  D0 06                        bne @1
000E8Fr 3               
000E8Fr 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
000E91r 3  20 rr rr                     jsr emit_a
000E94r 3  C8                           iny
000E95r 3               @1:
000E95r 3  88                           dey
000E96r 3  A9 08                        lda #AscBS      ; move back one
000E98r 3  20 rr rr                     jsr emit_a
000E9Br 3  A9 20                        lda #AscSP      ; print a space (rubout)
000E9Dr 3  20 rr rr                     jsr emit_a
000EA0r 3  A9 08                        lda #AscBS      ; move back over space
000EA2r 3  20 rr rr                     jsr emit_a
000EA5r 3               
000EA5r 3  80 B3                        bra accept_loop
000EA7r 3               
000EA7r 3               @ctrl_p:
000EA7r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000EA7r 3               
000EA7r 3                               ; Select the previous buffer
000EA7r 3  A5 20                        lda status
000EA9r 3               
000EA9r 3                               ; Check for 0 (need to wrap back to 7)
000EA9r 3  29 07                        and #7
000EABr 3  D0 08                        bne @ctrl_p_dec
000EADr 3               
000EADr 3                               ; We need to wrap back to 7.
000EADr 3  A5 20                        lda status
000EAFr 3  09 07                        ora #7
000EB1r 3  85 20                        sta status
000EB3r 3  80 11                        bra @recall_history
000EB5r 3               
000EB5r 3               @ctrl_p_dec:
000EB5r 3                               ; It's safe to decrement the buffer index directly.
000EB5r 3  C6 20                        dec status
000EB7r 3  80 0D                        bra @recall_history
000EB9r 3               
000EB9r 3               @ctrl_n:
000EB9r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000EB9r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000EB9r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000EB9r 3                               ; history buffer.
000EB9r 3  A9 08                        lda #$8
000EBBr 3  24 20                        bit status
000EBDr 3  D0 07                        bne @recall_history
000EBFr 3               
000EBFr 3                               ; This isn't the first time CTRL-n has been pressed, select the
000EBFr 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
000EBFr 3  A5 20                        lda status
000EC1r 3  29 F7                        and #$f7
000EC3r 3               
000EC3r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000EC3r 3  1A                           inc
000EC4r 3               
000EC4r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
000EC4r 3                               ; be cleared below.
000EC4r 3  85 20                        sta status
000EC6r 3               
000EC6r 3                               ; Falls through to @recall_history
000EC6r 3               
000EC6r 3               @recall_history:
000EC6r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000EC6r 3  A9 08                        lda #%00001000
000EC8r 3  14 20                        trb status
000ECAr 3               
000ECAr 3  20 rr rr                     jsr total_recall
000ECDr 3               
000ECDr 3                               ; tmp3 now has the address of the previous history buffer.
000ECDr 3                               ; First byte of buffer is length. Clear the line by sending
000ECDr 3                               ; CR, Y spaces, then CR.
000ECDr 3  A9 0D                        lda #AscCR
000ECFr 3  20 rr rr                     jsr emit_a
000ED2r 3               
000ED2r 3               input_clear:
000ED2r 3  C0 00                        cpy #0
000ED4r 3  F0 08                        beq input_cleared
000ED6r 3               
000ED6r 3  A9 20                        lda #AscSP
000ED8r 3  20 rr rr                     jsr emit_a
000EDBr 3  88                           dey
000EDCr 3  80 F4                        bra input_clear
000EDEr 3               
000EDEr 3               input_cleared:
000EDEr 3  A9 0D                        lda #AscCR
000EE0r 3  20 rr rr                     jsr emit_a
000EE3r 3               
000EE3r 3                               ; Save the history length byte into histinfo+1
000EE3r 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000EE3r 3  B1 28                        lda (tmp3),y
000EE5r 3  85 21                        sta status+1
000EE7r 3               
000EE7r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000EE7r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000EE7r 3                               ; buffer)
000EE7r 3  E6 28                        inc tmp3
000EE9r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
000EEBr 3  E6 29                        inc tmp3+1
000EEDr 3               @2:
000EEDr 3                               ; Copy the history buffer into the input buffer,
000EEDr 3                               ; sending the characters to the output as we go.
000EEDr 3  A9 0D                        lda #AscCR
000EEFr 3  20 rr rr                     jsr emit_a
000EF2r 3               
000EF2r 3               @history_loop:
000EF2r 3                               ; See if we have reached the end of the history buffer.
000EF2r 3  C4 21                        cpy status+1
000EF4r 3  D0 03                        bne @3
000EF6r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
000EF9r 3               @3:
000EF9r 3                               ; See if we have reached the end of the input buffer.
000EF9r 3                               ; (only comparing to lower byte as we currently limit
000EF9r 3                               ; to 255 characters max)
000EF9r 3  C4 26                        cpy tmp2
000EFBr 3  F0 0A                        beq @hist_filled_buffer
000EFDr 3               
000EFDr 3                               ; Copy a character and echo.
000EFDr 3  B1 28                        lda (tmp3),y
000EFFr 3  91 24                        sta (tmp1),y
000F01r 3  20 rr rr                     jsr emit_a
000F04r 3               
000F04r 3                               ; Move to the next character.
000F04r 3  C8                           iny
000F05r 3  80 EB                        bra @history_loop
000F07r 3               
000F07r 3               @hist_filled_buffer:
000F07r 3                               ; We don't want a history recall to EOL our buffer,
000F07r 3                               ; so back up one character and return to editing.
000F07r 3  88                           dey
000F08r 3  4C rr rr                     jmp accept_loop
000F0Br 3               accept_done:
000F0Br 3               @done:
000F0Br 3                               ; Copy the input buffer into the currently
000F0Br 3                               ; selected history buffer.
000F0Br 3  20 rr rr                     jsr total_recall
000F0Er 3  85 21                        sta status+1
000F10r 3               
000F10r 3                               ; Also save it in the first buffer byte.
000F10r 3  A0 00                        ldy #0
000F12r 3  91 28                        sta (tmp3),y
000F14r 3               
000F14r 3                               ; Move path the count to the data bytes
000F14r 3  E6 28                        inc tmp3
000F16r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000F18r 3  E6 29                        inc tmp3+1
000F1Ar 3               @4:
000F1Ar 3                               ; Copy the characters from the input buffer to the
000F1Ar 3                               ; history buffer.
000F1Ar 3               
000F1Ar 3               @save_history_loop:
000F1Ar 3  C4 21                        cpy status+1
000F1Cr 3  F0 07                        beq @save_history_done
000F1Er 3               
000F1Er 3  B1 24                        lda (tmp1),y
000F20r 3  91 28                        sta (tmp3),y
000F22r 3  C8                           iny
000F23r 3  80 F5                        bra @save_history_loop
000F25r 3               
000F25r 3               @save_history_done:
000F25r 3               z_accept:
000F25r 3  60                           rts
000F26r 3               
000F26r 3               total_recall:
000F26r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000F26r 3               
000F26r 3                               ; Generate the address of the buffer in tmp3. Start with the
000F26r 3                               ; base address.
000F26r 3  A9 00                        lda #<hist_buff
000F28r 3  85 28                        sta tmp3
000F2Ar 3  A9 7C                        lda #>hist_buff
000F2Cr 3  85 29                        sta tmp3+1
000F2Er 3               
000F2Er 3                               ; This is a bit annoying as some bits go into each byte.
000F2Er 3                               ; .....xxx gets put into address like ......xx x.......
000F2Er 3  A5 20                        lda status
000F30r 3  6A                           ror
000F31r 3  29 03                        and #3
000F33r 3  18                           clc
000F34r 3  65 29                        adc tmp3+1
000F36r 3  85 29                        sta tmp3+1
000F38r 3               
000F38r 3  A5 20                        lda status
000F3Ar 3  6A                           ror             ; Rotate through carry into msb.
000F3Br 3  6A                           ror
000F3Cr 3  29 80                        and #$80
000F3Er 3  18                           clc
000F3Fr 3  65 28                        adc tmp3
000F41r 3  85 28                        sta tmp3
000F43r 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000F45r 3  E6 29                        inc tmp3+1
000F47r 3               @1:
000F47r 3                               ; Save the current length of the input buffer in
000F47r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000F47r 3  98                           tya
000F48r 3  C9 80                        cmp #$80
000F4Ar 3  90 02                        bcc @2
000F4Cr 3  A9 7F                        lda #$7F
000F4Er 3               @2:
000F4Er 3  60                           rts
000F4Fr 3               
000F4Fr 3               
000F4Fr 3               
000F4Fr 3               
000F4Fr 3               
000F4Fr 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000F4Fr 3               ; ## "action-of"  auto  ANS core ext
000F4Fr 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000F4Fr 3               
000F4Fr 3               xt_action_of:
000F4Fr 3                               ; This is a state aware word with differet behavior
000F4Fr 3                               ; when used while compiling vs interpreting.
000F4Fr 3                               ; Check STATE
000F4Fr 3  A5 16                        lda state
000F51r 3  05 17                        ora state+1
000F53r 3  F0 0C                        beq @interpreting
000F55r 3               
000F55r 3               @compiling:
000F55r 3                               ; Run ['] to compile the xt of the next word
000F55r 3                               ; as a literal.
000F55r 3  20 rr rr                     jsr xt_bracket_tick
000F58r 3               
000F58r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000F58r 3  A0 rr                        ldy #>xt_defer_fetch
000F5Ar 3  A9 rr                        lda #<xt_defer_fetch
000F5Cr 3  20 rr rr                     jsr cmpl_subroutine
000F5Fr 3  80 06                        bra @done
000F61r 3               
000F61r 3               @interpreting:
000F61r 3  20 rr rr                     jsr xt_tick
000F64r 3  20 rr rr                     jsr xt_defer_fetch
000F67r 3               
000F67r 3               @done:
000F67r 3  60           z_action_of:           rts
000F68r 3               
000F68r 3               
000F68r 3               
000F68r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000F68r 3               ; ## "again"  tested  ANS core ext
000F68r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000F68r 3               
000F68r 3               xt_again:
000F68r 3  20 rr rr                     jsr underflow_1
000F6Br 3               
000F6Br 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000F6Br 3                               ; so we have the range and don't have to calculate the
000F6Br 3                               ; offset.
000F6Br 3  A0 00                        ldy #0
000F6Dr 3  A9 4C                        lda #$4C        ; JMP
000F6Fr 3  91 00                        sta (cp),y
000F71r 3  C8                           iny
000F72r 3               
000F72r 3  B5 00                        lda 0,x         ; LSB of address
000F74r 3  91 00                        sta (cp),y
000F76r 3  C8                           iny
000F77r 3               
000F77r 3  B5 01                        lda 1,x         ; MSB of address
000F79r 3  91 00                        sta (cp),y
000F7Br 3  C8                           iny
000F7Cr 3               
000F7Cr 3                               ; Allot the space we just used
000F7Cr 3  98                           tya
000F7Dr 3  18                           clc
000F7Er 3  65 00                        adc cp
000F80r 3  85 00                        sta cp
000F82r 3  90 02                        bcc @done
000F84r 3  E6 01                        inc cp+1
000F86r 3               @done:
000F86r 3  E8                           inx
000F87r 3  E8                           inx
000F88r 3               
000F88r 3  60           z_again:        rts
000F89r 3               
000F89r 3               
000F89r 3               
000F89r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000F89r 3               ; ## "align"  auto  ANS core
000F89r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000F89r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000F89r 3                       ; routine as well, and also does nothing
000F89r 3                       ; """
000F89r 3               
000F89r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000F89r 3               ; ## "aligned"  auto  ANS core
000F89r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000F89r 3               
000F89r 3               xt_align:
000F89r 3               xt_aligned:
000F89r 3               z_align:
000F89r 3  60           z_aligned:      rts             ; stripped out during native compile
000F8Ar 3               
000F8Ar 3               
000F8Ar 3               
000F8Ar 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000F8Ar 3               ; ## "allot"  auto  ANS core
000F8Ar 3                       ; """https://forth-standard.org/standard/core/ALLOT
000F8Ar 3                       ; Reserve a certain number of bytes (not cells) or release them.
000F8Ar 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000F8Ar 3                       ; to the beginning of the Dictionary. If n is positive (the most
000F8Ar 3                       ; common case), reserve n bytes, but not past the end of the
000F8Ar 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000F8Ar 3                       ; """
000F8Ar 3               
000F8Ar 3               xt_allot:
000F8Ar 3  20 rr rr                     jsr underflow_1
000F8Dr 3               
000F8Dr 3                               ; Releasing memory is going to be a very rare operation,
000F8Dr 3                               ; so we check for it at the beginning and try to make
000F8Dr 3                               ; the most common case as fast as possible
000F8Dr 3  B5 01                        lda 1,x
000F8Fr 3  30 22                        bmi @release
000F91r 3               
000F91r 3                               ; Common case: We are reserving memory, not releasing it
000F91r 3  18                           clc
000F92r 3  A5 00                        lda cp
000F94r 3  75 00                        adc 0,x
000F96r 3  85 00                        sta cp
000F98r 3               
000F98r 3  A5 01                        lda cp+1
000F9Ar 3  75 01                        adc 1,x
000F9Cr 3  85 01                        sta cp+1
000F9Er 3               
000F9Er 3                               ; Wait, did we just grant more space than we have? This is
000F9Er 3                               ; a check we only do here, not for other situations like cmpl_a
000F9Er 3                               ; where smaller amounts are reserved.
000F9Er 3  A0 DB                        ldy #<cp_end
000FA0r 3  C4 00                        cpy cp
000FA2r 3  A9 59                        lda #>cp_end
000FA4r 3  E5 01                        sbc cp+1
000FA6r 3  B0 48                        bcs @done               ; we're fine.
000FA8r 3               
000FA8r 3                               ; Oops, that was too much, we're beyond the end of
000FA8r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000FA8r 3                               ; an error
000FA8r 3  84 00                        sty cp                  ; still #<cp_end
000FAAr 3  A9 59                        lda #>cp_end
000FACr 3  85 01                        sta cp+1
000FAEr 3               
000FAEr 3  A9 00                        lda #err_allot
000FB0r 3  4C rr rr                     jmp error
000FB3r 3               
000FB3r 3               @release:
000FB3r 3                  		; The ANS standard doesn't really say what to do if too much
000FB3r 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
000FB3r 3                               ; even an official test. Gforth is little help either. The good
000FB3r 3                               ; news is, this is going to be a rare case. We want to use as
000FB3r 3                               ; few bytes as possible.
000FB3r 3               
000FB3r 3                               ; What we do is let the user free anything up to the beginning
000FB3r 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
000FB3r 3                               ; their own risk. This means that the Dictionary pointer DP
000FB3r 3                               ; might end up pointing to garbage. However, an attempt to
000FB3r 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
000FB3r 3                               ; the DP pointing to the last word in RAM (should be DROP) and
000FB3r 3                               ; an error message.
000FB3r 3               
000FB3r 3                               ; We arrive here with ( n ) which is negative. First step,
000FB3r 3                               ; subtract the number TOS from the CP for a new CP
000FB3r 3  CA                           dex
000FB4r 3  CA                           dex
000FB5r 3  A5 00                        lda cp
000FB7r 3  95 00                        sta 0,x
000FB9r 3  A5 01                        lda cp+1
000FBBr 3  95 01                        sta 1,x
000FBDr 3               
000FBDr 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000FC0r 3               
000FC0r 3                               ; Second step, see if we've gone too far. We compare the new
000FC0r 3                               ; CP on TOS (which, if we've really screwed up, might be
000FC0r 3                               ; negative) with CP0. This is a signed comparison
000FC0r 3  CA                           dex
000FC1r 3  CA                           dex                             ; new CP now NOS
000FC2r 3  A9 FF                        lda #<cp0
000FC4r 3  95 00                        sta 0,x
000FC6r 3  A9 02                        lda #>cp0
000FC8r 3  95 01                        sta 1,x                         ; CP0 is TOS
000FCAr 3               
000FCAr 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000FCDr 3               
000FCDr 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000FCDr 3                               ; This means we want Z=1 or N=1
000FCDr 3  F0 17                        beq @nega_done
000FCFr 3  30 15                        bmi @nega_done
000FD1r 3               
000FD1r 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
000FD1r 3                               ; word in ROM (should be DROP), and abort with an error
000FD1r 3  A9 FF                        lda #<cp0
000FD3r 3  85 00                        sta cp
000FD5r 3  A9 02                        lda #>cp0
000FD7r 3  85 01                        sta cp+1
000FD9r 3               
000FD9r 3  A9 rr                        lda #<dictionary_start
000FDBr 3  85 02                        sta dp
000FDDr 3  A9 rr                        lda #>dictionary_start
000FDFr 3  85 03                        sta dp+1
000FE1r 3               
000FE1r 3  A9 0A                        lda #err_negallot
000FE3r 3  4C rr rr                     jmp error
000FE6r 3               
000FE6r 3               @nega_done:
000FE6r 3                               ; Save new CP, which is NOS
000FE6r 3  B5 02                        lda 2,x
000FE8r 3  85 00                        sta cp
000FEAr 3  B5 03                        lda 3,x
000FECr 3  85 01                        sta cp+1
000FEEr 3               
000FEEr 3  E8                           inx
000FEFr 3  E8                           inx                     ; drop through to @done
000FF0r 3               @done:
000FF0r 3  E8                           inx
000FF1r 3  E8                           inx
000FF2r 3               z_allot:
000FF2r 3  60                           rts
000FF3r 3               
000FF3r 3               
000FF3r 3               
000FF3r 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000FF3r 3               ; ## "allow-native"  auto  Tali Forth
000FF3r 3               xt_allow_native:
000FF3r 3  20 rr rr                     jsr current_to_dp
000FF6r 3  A0 01                        ldy #1          ; offset for status byte
000FF8r 3  B1 02                        lda (dp),y
000FFAr 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
000FFCr 3  91 02                        sta (dp),y
000FFEr 3               z_allow_native:
000FFEr 3  60                           rts
000FFFr 3               
000FFFr 3               
000FFFr 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000FFFr 3               ; ## "also"  auto  ANS search ext
000FFFr 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000FFFr 3               xt_also:
000FFFr 3  20 rr rr                     jsr xt_get_order
001002r 3  20 rr rr                     jsr xt_over
001005r 3  20 rr rr                     jsr xt_swap
001008r 3  20 rr rr                     jsr xt_one_plus
00100Br 3  20 rr rr                     jsr xt_set_order
00100Er 3               
00100Er 3  60           z_also:         rts
00100Fr 3               
00100Fr 3               
00100Fr 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
00100Fr 3               ; ## "always-native"  auto  Tali Forth
00100Fr 3               xt_always_native:
00100Fr 3  20 rr rr                     jsr current_to_dp
001012r 3  A0 01                        ldy #1          ; offset for status byte
001014r 3  B1 02                        lda (dp),y
001016r 3  09 02                        ora #AN         ; Make sure AN flag is set
001018r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
00101Ar 3  91 02                        sta (dp),y
00101Cr 3               z_always_native:
00101Cr 3  60                           rts
00101Dr 3               
00101Dr 3               
00101Dr 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
00101Dr 3               ; ## "and"  auto  ANS core
00101Dr 3                       ; """https://forth-standard.org/standard/core/AND"""
00101Dr 3               xt_and:
00101Dr 3  20 rr rr                     jsr underflow_2
001020r 3               
001020r 3  B5 00                        lda 0,x
001022r 3  35 02                        and 2,x
001024r 3  95 02                        sta 2,x
001026r 3               
001026r 3  B5 01                        lda 1,x
001028r 3  35 03                        and 3,x
00102Ar 3  95 03                        sta 3,x
00102Cr 3               
00102Cr 3  E8                           inx
00102Dr 3  E8                           inx
00102Er 3               
00102Er 3  60           z_and:          rts
00102Fr 3               
00102Fr 3               
00102Fr 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
00102Fr 3               ; ## "assembler-wordlist"  tested  Tali Assembler
00102Fr 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
00102Fr 3                       ; assembler words to the search order so they can be used.
00102Fr 3                       ; See the tutorial on Wordlists and the Search Order for
00102Fr 3                       ; more information.
00102Fr 3                       ;
00102Fr 3                       ; This is a dummy entry, the code is shared with TWO
00102Fr 3                       ; """
00102Fr 3               
00102Fr 3               
00102Fr 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
00102Fr 3               ; ## "at-xy"  tested  ANS facility
00102Fr 3                       ; """https://forth-standard.org/standard/facility/AT-XY
00102Fr 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
00102Fr 3                       ; ANSI code is ESC[<n>;<m>H
00102Fr 3                       ;
00102Fr 3                       ; Do not use U. to print the numbers because the
00102Fr 3                       ; trailing space will not work with xterm
00102Fr 3                       ; """
00102Fr 3               xt_at_xy:
00102Fr 3  20 rr rr                     jsr underflow_2
001032r 3               
001032r 3  A9 1B                        lda #AscESC
001034r 3  20 rr rr                     jsr emit_a
001037r 3  A9 5B                        lda #$5B        ; ASCII for "["
001039r 3  20 rr rr                     jsr emit_a
00103Cr 3  20 rr rr                     jsr print_u
00103Fr 3  A9 3B                        lda #$3B        ; ASCII for ";"
001041r 3  20 rr rr                     jsr emit_a
001044r 3  20 rr rr                     jsr print_u
001047r 3  A9 48                        lda #'H'
001049r 3  20 rr rr                     jsr emit_a
00104Cr 3               
00104Cr 3  60           z_at_xy:        rts
00104Dr 3               
00104Dr 3               
00104Dr 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
00104Dr 3               ; ## "\"  auto  ANS core ext
00104Dr 3                       ; """https://forth-standard.org/standard/core/bs"""
00104Dr 3               xt_backslash:
00104Dr 3  A5 0A                        lda ciblen
00104Fr 3  85 0C                        sta toin
001051r 3  A5 0B                        lda ciblen+1
001053r 3  85 0D                        sta toin+1
001055r 3               
001055r 3  60           z_backslash:    rts
001056r 3               
001056r 3               
001056r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
001056r 3               ; ## "base"  auto  ANS core
001056r 3                       ; """https://forth-standard.org/standard/core/BASE
001056r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
001056r 3                       ; ingore the MSB
001056r 3                       ; """
001056r 3               xt_base:
001056r 3  CA                           dex
001057r 3  CA                           dex
001058r 3  A9 18                        lda #<base
00105Ar 3  95 00                        sta 0,x         ; LSB
00105Cr 3  74 01                        stz 1,x         ; MSB is always 0
00105Er 3               
00105Er 3  60           z_base:         rts
00105Fr 3               
00105Fr 3               
00105Fr 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
00105Fr 3               ; ## "begin"  auto  ANS core
00105Fr 3                       ; """https://forth-standard.org/standard/core/BEGIN
00105Fr 3                       ;
00105Fr 3                       ; This is just an immediate version of here which could just
00105Fr 3                       ; as well be coded in Forth as
00105Fr 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
00105Fr 3                       ; Since this is a compiling word, we don't care that much about
00105Fr 3                       ; about speed
00105Fr 3                       ; """
00105Fr 3               
00105Fr 3               xt_begin:
00105Fr 3  20 rr rr                     jsr xt_here
001062r 3  60           z_begin:        rts
001063r 3               
001063r 3               
001063r 3               
001063r 3               ; ## BELL ( -- ) "Emit ASCII BELL"
001063r 3               ; ## "bell"  tested  Tali Forth
001063r 3               xt_bell:
001063r 3  A9 07                        lda #7          ; ASCII value for BELl
001065r 3  20 rr rr                     jsr emit_a
001068r 3               
001068r 3  60           z_bell:         rts
001069r 3               
001069r 3               
001069r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
001069r 3               ; ## "bl"  auto  ANS core
001069r 3                       ; """https://forth-standard.org/standard/core/BL"""
001069r 3               
001069r 3               xt_bl:
001069r 3  CA                           dex
00106Ar 3  CA                           dex
00106Br 3  A9 20                        lda #AscSP
00106Dr 3  95 00                        sta 0,x
00106Fr 3  74 01                        stz 1,x
001071r 3               
001071r 3  60           z_bl:           rts
001072r 3               
001072r 3               
001072r 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
001072r 3               ; ## "block"  auto  ANS block
001072r 3                       ; """https://forth-standard.org/standard/block/BLK"""
001072r 3               xt_blk:
001072r 3                               ; BLK is at UP + blk_offset
001072r 3  CA                           dex
001073r 3  CA                           dex
001074r 3  18                           clc
001075r 3  A5 1E                        lda up
001077r 3  69 00                        adc #blk_offset ; Add offset
001079r 3  95 00                        sta 0,x
00107Br 3  A5 1F                        lda up+1
00107Dr 3  69 00                        adc #0          ; Adding carry
00107Fr 3  95 01                        sta 1,x
001081r 3               
001081r 3  60           z_blk:          rts
001082r 3               
001082r 3               
001082r 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
001082r 3               ; ## "blkbuffer"  auto  Tali block
001082r 3               xt_blkbuffer:
001082r 3                               ; blkbuffer address is at UP + blkbuffer_offset.
001082r 3                               ; Unlike some of the other user variables, we actually
001082r 3                               ; want to push the address stored here, which will
001082r 3                               ; point to somewhere outside of the user variables.
001082r 3  CA                           dex
001083r 3  CA                           dex
001084r 3                               ; Put the address on the stack.
001084r 3  A0 28                        ldy #blkbuffer_offset
001086r 3  B1 1E                        lda (up),y
001088r 3  95 00                        sta 0,x
00108Ar 3  C8                           iny             ; Move along to the next byte
00108Br 3  B1 1E                        lda (up),y
00108Dr 3  95 01                        sta 1,x
00108Fr 3               
00108Fr 3  60           z_blkbuffer:    rts
001090r 3               
001090r 3               
001090r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
001090r 3               ; ## "block"  auto  ANS block
001090r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
001090r 3               
001090r 3               xt_block:
001090r 3               
001090r 3                               ; See if the block requested is the same as the one we
001090r 3                               ; currently have in the buffer. Check the LSB.
001090r 3  A0 2A                        ldy #buffblocknum_offset
001092r 3  B1 1E                        lda (up),y
001094r 3  D5 00                        cmp 0,x
001096r 3  D0 0F                        bne @not_in_buffer
001098r 3               
001098r 3                               ; Check the MSB.
001098r 3  C8                           iny
001099r 3  B1 1E                        lda (up),y
00109Br 3  D5 01                        cmp 1,x
00109Dr 3  D0 08                        bne @not_in_buffer
00109Fr 3               
00109Fr 3                               ; The block is in the buffer. See if the buffer is in use.
00109Fr 3  A0 2C                        ldy #buffstatus_offset
0010A1r 3  B1 1E                        lda (up),y
0010A3r 3  29 01                        and #1          ; Check the in-use flag (bit 0)
0010A5r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
0010A7r 3                                               ; @done will replace the block# with the
0010A7r 3                                               ; buffer address.
0010A7r 3               @not_in_buffer:
0010A7r 3                               ; Check the buffer status
0010A7r 3  A0 2C                        ldy #buffstatus_offset
0010A9r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
0010ABr 3  C9 03                        cmp #3          ; LSB is needed.
0010ADr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
0010AFr 3               
0010AFr 3                               ; We need to save the block.
0010AFr 3  20 rr rr                     jsr xt_blkbuffer
0010B2r 3  20 rr rr                     jsr xt_buffblocknum
0010B5r 3  20 rr rr                     jsr xt_fetch
0010B8r 3  20 rr rr                     jsr xt_block_write
0010BBr 3               
0010BBr 3               @buffer_available:
0010BBr 3                               ; Save the block number.
0010BBr 3  A0 2A                        ldy #buffblocknum_offset
0010BDr 3  B5 00                        lda 0,x
0010BFr 3  91 1E                        sta (up),y
0010C1r 3  C8                           iny
0010C2r 3  B5 01                        lda 1,x
0010C4r 3  91 1E                        sta (up),y
0010C6r 3               
0010C6r 3                               ; Get the requested block.
0010C6r 3  20 rr rr                     jsr xt_blkbuffer
0010C9r 3  20 rr rr                     jsr xt_swap
0010CCr 3  20 rr rr                     jsr xt_block_read
0010CFr 3               
0010CFr 3                               ; Mark the buffer as clean and in-use.
0010CFr 3  A9 01                        lda #1
0010D1r 3  A0 2C                        ldy #buffstatus_offset
0010D3r 3  91 1E                        sta (up),y
0010D5r 3               
0010D5r 3                               ; Make room on the stack for the return address.
0010D5r 3  CA                           dex
0010D6r 3  CA                           dex
0010D7r 3               
0010D7r 3               @done:
0010D7r 3                               ; It's in the buffer. Return the buffer address.
0010D7r 3  A0 28                        ldy #blkbuffer_offset
0010D9r 3  B1 1E                        lda (up),y
0010DBr 3  95 00                        sta 0,x
0010DDr 3  C8                           iny
0010DEr 3  B1 1E                        lda (up),y
0010E0r 3  95 01                        sta 1,x
0010E2r 3               
0010E2r 3  60           z_block:        rts
0010E3r 3               
0010E3r 3               
0010E3r 3               
0010E3r 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
0010E3r 3               ; ## "block-ramdrive-init"  auto  Tali block
0010E3r 3                       ; """Create a RAM drive, with the given number of
0010E3r 3                       ; blocks, in the dictionary along with setting up the block words to
0010E3r 3                       ; use it.  The read/write routines do not provide bounds checking.
0010E3r 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
0010E3r 3                       ; """
0010E3r 3               
0010E3r 3               xt_block_ramdrive_init:
0010E3r 3  20 rr rr                     jsr underflow_1
0010E6r 3               
0010E6r 3                               ; Store the string to run here as a string literal.
0010E6r 3                               ; See SLITERAL for the format information. This way, we
0010E6r 3                               ; don't have the words defined below in the Dictionary until
0010E6r 3                               ; we really use them.
0010E6r 3  4C rr rr                     jmp @after_ramdrive_code
0010E9r 3               
0010E9r 3               @ramdrive_code:
0010E9r 3  62 61 73 65          .byte "base @ swap decimal"
0010EDr 3  20 40 20 73  
0010F1r 3  77 61 70 20  
0010FCr 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
001100r 3  34 20 2A     
001103r 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
001107r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
00110Br 3  66 65 72 3A  
00110Fr 3  20 72 61 6D  
001118r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
001118r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
00111Cr 3  6C 6F 63 6B  
001120r 3  2D 72 65 61  
00112Er 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
001132r 3  64 72 69 76  
001136r 3  65 20 73 77  
001156r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
00115Ar 3  6C 6F 63 6B  
00115Er 3  2D 77 72 69  
00116Dr 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
001171r 3  64 72 69 76  
001175r 3  65 20 73 77  
001190r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
001194r 3  6C 6F 63 6B  
001198r 3  2D 72 65 61  
0011BAr 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
0011BEr 3  6C 6F 63 6B  
0011C2r 3  2D 77 72 69  
0011E6r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
0011EAr 3  64 72 69 76  
0011EEr 3  65 20 73 77  
001201r 3               
001201r 3               @after_ramdrive_code:
001201r 3  20 rr rr                     jsr sliteral_runtime
001204r 3               
001204r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
001208r 3               
001208r 3                               ; The address and length of the ramdrive code is now on the
001208r 3                               ; stack. Call EVALUATE to run it.
001208r 3  20 rr rr                     jsr xt_evaluate
00120Br 3               
00120Br 3               z_block_ramdrive_init:
00120Br 3  60                           rts
00120Cr 3               
00120Cr 3               
00120Cr 3               
00120Cr 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
00120Cr 3               ; ## "block-read"  auto  Tali block
00120Cr 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00120Cr 3                       ; with their own version to read a block from storage.
00120Cr 3                       ; The stack parameters are ( buffer_address block# -- ).
00120Cr 3                       ; """
00120Cr 3               xt_block_read:
00120Cr 3                               ; Execute the BLOCK-READ-VECTOR
00120Cr 3  A0 2E                        ldy #blockread_offset
00120Er 3  B1 1E                        lda (up),y
001210r 3  85 24                        sta tmp1
001212r 3  C8                           iny
001213r 3  B1 1E                        lda (up),y
001215r 3  85 25                        sta tmp1+1
001217r 3               
001217r 3  6C 24 00                     jmp (tmp1)
00121Ar 3               
00121Ar 3               z_block_read:   ; No RTS needed
00121Ar 3               
00121Ar 3               
00121Ar 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
00121Ar 3               ; ## "block-read-vector"  auto  Tali block
00121Ar 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00121Ar 3                       ; with their own version to read a block from storage.
00121Ar 3                       ; This word gives the address of the vector so it can be replaced.
00121Ar 3                       ; """
00121Ar 3               xt_block_read_vector:
00121Ar 3                               ; Get the BLOCK-READ-VECTOR address
00121Ar 3  CA                           dex
00121Br 3  CA                           dex
00121Cr 3  18                           clc
00121Dr 3  A5 1E                        lda up
00121Fr 3  69 2E                        adc #blockread_offset
001221r 3  95 00                        sta 0,x
001223r 3  A5 1F                        lda up+1
001225r 3  69 00                        adc #0          ; Add carry
001227r 3  95 01                        sta 1,x
001229r 3               
001229r 3               z_block_read_vector:
001229r 3  60                           rts
00122Ar 3               
00122Ar 3               
00122Ar 3               ; This is the default error message the vectored words BLOCK-READ and
00122Ar 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
00122Ar 3               xt_block_word_error:
00122Ar 3  A9 0C                        lda #err_blockwords
00122Cr 3  4C rr rr                     jmp error       ; no RTS needed
00122Fr 3               z_block_word_error:
00122Fr 3               
00122Fr 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
00122Fr 3               ; ## "block-write"  auto  Tali block
00122Fr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
00122Fr 3                       ; with their own version to write a block to storage.
00122Fr 3                       ; The stack parameters are ( buffer_address block# -- ).
00122Fr 3                       ; """
00122Fr 3               xt_block_write:
00122Fr 3                               ; Execute the BLOCK-READ-VECTOR
00122Fr 3  A0 30                        ldy #blockwrite_offset
001231r 3  B1 1E                        lda (up),y
001233r 3  85 24                        sta tmp1
001235r 3  C8                           iny
001236r 3  B1 1E                        lda (up),y
001238r 3  85 25                        sta tmp1+1
00123Ar 3  6C 24 00                     jmp (tmp1)
00123Dr 3               
00123Dr 3               z_block_write:  ; No RTS needed
00123Dr 3               
00123Dr 3               
00123Dr 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
00123Dr 3               ; ## "block-write-vector"  auto  Tali block
00123Dr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
00123Dr 3                       ; with their own version to write a block to storage.
00123Dr 3                       ; This word gives the address of the vector so it can be replaced.
00123Dr 3                       ; """
00123Dr 3               xt_block_write_vector:
00123Dr 3                               ; Get the BLOCK-WRITE-VECTOR address
00123Dr 3  CA                           dex
00123Er 3  CA                           dex
00123Fr 3  18                           clc
001240r 3  A5 1E                        lda up
001242r 3  69 30                        adc #blockwrite_offset
001244r 3  95 00                        sta 0,x
001246r 3  A5 1F                        lda up+1
001248r 3  69 00                        adc #0          ; Add carry
00124Ar 3  95 01                        sta 1,x
00124Cr 3               
00124Cr 3               z_block_write_vector:
00124Cr 3  60                           rts
00124Dr 3               
00124Dr 3               
00124Dr 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
00124Dr 3               ; ## "bounds"  auto  Gforth
00124Dr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
00124Dr 3                       ; Given a string, return the correct Data Stack parameters for
00124Dr 3                       ; a DO/LOOP loop over its characters. This is realized as
00124Dr 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
00124Dr 3                       ; """
00124Dr 3               xt_bounds:
00124Dr 3  20 rr rr                     jsr underflow_2
001250r 3               
001250r 3  18                           clc
001251r 3  B5 00                        lda 0,x                 ; LSB u
001253r 3  B4 02                        ldy 2,x                 ; LSB addr
001255r 3  75 02                        adc 2,x
001257r 3  95 02                        sta 2,x                 ; LSB addr+u
001259r 3  94 00                        sty 0,x
00125Br 3               
00125Br 3  B5 01                        lda 1,x                 ; MSB u
00125Dr 3  B4 03                        ldy 3,x                 ; MSB addr
00125Fr 3  75 03                        adc 3,x
001261r 3  95 03                        sta 3,x                 ; MSB addr+u
001263r 3  94 01                        sty 1,x
001265r 3               
001265r 3  60           z_bounds:       rts
001266r 3               
001266r 3               
001266r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
001266r 3               ; ## "[char]"  auto  ANS core
001266r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
001266r 3                       ; Compile the ASCII value of a character as a literal. This is an
001266r 3                       ; immediate, compile-only word.
001266r 3                       ;
001266r 3                       ; A definition given in
001266r 3                       ; http://forth-standard.org/standard/implement is
001266r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
001266r 3                       ; """
001266r 3               xt_bracket_char:
001266r 3  20 rr rr                     jsr xt_char
001269r 3  20 rr rr                     jsr xt_literal
00126Cr 3  60           z_bracket_char: rts
00126Dr 3               
00126Dr 3               
00126Dr 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
00126Dr 3               ; ## "[']"  auto  ANS core
00126Dr 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
00126Dr 3               xt_bracket_tick:
00126Dr 3  20 rr rr                     jsr xt_tick
001270r 3  20 rr rr                     jsr xt_literal
001273r 3  60           z_bracket_tick: rts
001274r 3               
001274r 3               
001274r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
001274r 3               ; ## "buffblocknum"  auto  Tali block
001274r 3               xt_buffblocknum:
001274r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
001274r 3  CA                           dex
001275r 3  CA                           dex
001276r 3  18                           clc
001277r 3  A5 1E                        lda up
001279r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
00127Br 3  95 00                        sta 0,x
00127Dr 3  A5 1F                        lda up+1
00127Fr 3  69 00                        adc #0                          ; Adding carry
001281r 3  95 01                        sta 1,x
001283r 3               
001283r 3  60           z_buffblocknum: rts
001284r 3               
001284r 3               
001284r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
001284r 3               ; ## "buffer"  auto  ANS block
001284r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
001284r 3               
001284r 3               xt_buffer:
001284r 3                               ; Check the buffer status
001284r 3  A0 2C                        ldy #buffstatus_offset
001286r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
001288r 3  C9 03                        cmp #3          ; LSB is needed.
00128Ar 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
00128Cr 3               
00128Cr 3                               ; We need to save the block.
00128Cr 3  20 rr rr                     jsr xt_blkbuffer
00128Fr 3  20 rr rr                     jsr xt_buffblocknum
001292r 3  20 rr rr                     jsr xt_fetch
001295r 3  20 rr rr                     jsr xt_block_write
001298r 3               
001298r 3               @buffer_available:
001298r 3                               ; Save the block number.
001298r 3  A0 2A                        ldy #buffblocknum_offset
00129Ar 3  B5 00                        lda 0,x
00129Cr 3  91 1E                        sta (up),y
00129Er 3  C8                           iny
00129Fr 3  B5 01                        lda 1,x
0012A1r 3  91 1E                        sta (up),y
0012A3r 3               
0012A3r 3                               ; Mark the buffer as clean and in-use.
0012A3r 3  A9 01                        lda #1
0012A5r 3  A0 2C                        ldy #buffstatus_offset
0012A7r 3  91 1E                        sta (up),y
0012A9r 3               
0012A9r 3               @done:
0012A9r 3                               ; Return the buffer address.
0012A9r 3  A0 28                        ldy #blkbuffer_offset
0012ABr 3  B1 1E                        lda (up),y
0012ADr 3  95 00                        sta 0,x
0012AFr 3  C8                           iny
0012B0r 3  B1 1E                        lda (up),y
0012B2r 3  95 01                        sta 1,x
0012B4r 3               
0012B4r 3  60           z_buffer:       rts
0012B5r 3               
0012B5r 3               
0012B5r 3               
0012B5r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
0012B5r 3               ; ## "buffer:"  auto  ANS core ext
0012B5r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
0012B5r 3                               ; Create a buffer of size u that puts its address on the stack
0012B5r 3                               ; when its name is used.
0012B5r 3                               ; """
0012B5r 3               xt_buffer_colon:
0012B5r 3  20 rr rr                     jsr xt_create
0012B8r 3  20 rr rr                     jsr xt_allot
0012BBr 3  60           z_buffer_colon: rts
0012BCr 3               
0012BCr 3               
0012BCr 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
0012BCr 3               ; ## "buffstatus"  auto  Tali block
0012BCr 3               xt_buffstatus:
0012BCr 3                               ; BUFFSTATUS is at UP + buffstatus_offset
0012BCr 3  CA                           dex
0012BDr 3  CA                           dex
0012BEr 3  18                           clc
0012BFr 3  A5 1E                        lda up
0012C1r 3  69 2C                        adc #buffstatus_offset  ; Add offset
0012C3r 3  95 00                        sta 0,x
0012C5r 3  A5 1F                        lda up+1
0012C7r 3  69 00                        adc #0                  ; Adding carry
0012C9r 3  95 01                        sta 1,x
0012CBr 3               
0012CBr 3  60           z_buffstatus:   rts
0012CCr 3               
0012CCr 3               
0012CCr 3               ; ## BYE ( -- ) "Break"
0012CCr 3               ; ## "bye"  tested  ANS tools ext
0012CCr 3                       ; """https://forth-standard.org/standard/tools/BYE"""
0012CCr 3               
0012CCr 3               xt_bye:
0012CCr 3                               ;brk
0012CCr 3  4C rr rr                     jmp platform_bye
0012CFr 3               z_bye:          ;rts             ; never reached
0012CFr 3               
0012CFr 3               
0012CFr 3               
0012CFr 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
0012CFr 3               ; ## "c,"  auto  ANS core
0012CFr 3                       ; """https://forth-standard.org/standard/core/CComma"""
0012CFr 3               
0012CFr 3               xt_c_comma:
0012CFr 3  20 rr rr                     jsr underflow_1
0012D2r 3               
0012D2r 3  B5 00                        lda 0,x
0012D4r 3  20 rr rr                     jsr cmpl_a
0012D7r 3               
0012D7r 3  E8                           inx
0012D8r 3  E8                           inx
0012D9r 3               
0012D9r 3  60           z_c_comma:      rts
0012DAr 3               
0012DAr 3               
0012DAr 3               
0012DAr 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
0012DAr 3               ; ## "c@"  auto  ANS core
0012DAr 3                       ; """https://forth-standard.org/standard/core/CFetch"""
0012DAr 3               xt_c_fetch:
0012DAr 3  20 rr rr                     jsr underflow_1
0012DDr 3               
0012DDr 3  A1 00                        lda (0,x)
0012DFr 3  95 00                        sta 0,x
0012E1r 3  74 01                        stz 1,x         ; Ignore LSB
0012E3r 3               
0012E3r 3  60           z_c_fetch:      rts
0012E4r 3               
0012E4r 3               
0012E4r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
0012E4r 3               ; ## "c!"  auto  ANS core
0012E4r 3                       ; """https://forth-standard.org/standard/core/CStore"""
0012E4r 3               xt_c_store:
0012E4r 3  20 rr rr                     jsr underflow_2
0012E7r 3               
0012E7r 3  B5 02                        lda 2,x
0012E9r 3  81 00                        sta (0,x)
0012EBr 3               
0012EBr 3  E8                           inx
0012ECr 3  E8                           inx
0012EDr 3  E8                           inx
0012EEr 3  E8                           inx
0012EFr 3               
0012EFr 3  60           z_c_store:      rts
0012F0r 3               
0012F0r 3               
0012F0r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
0012F0r 3               ; ## "case"  auto  ANS core ext
0012F0r 3                       ; """http://forth-standard.org/standard/core/CASE
0012F0r 3                       ;
0012F0r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
0012F0r 3                       ; """
0012F0r 3               
0012F0r 3               
0012F0r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
0012F0r 3               ; ## "cell+"  auto  ANS core
0012F0r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
0012F0r 3                       ; Add the number of bytes ("address units") that one cell needs.
0012F0r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
0012F0r 3                       ; """
0012F0r 3               
0012F0r 3               xt_cell_plus:
0012F0r 3  20 rr rr                     jsr underflow_1
0012F3r 3               
0012F3r 3  F6 00                        inc 0,x
0012F5r 3  D0 02                        bne @1
0012F7r 3  F6 01                        inc 1,x
0012F9r 3               @1:
0012F9r 3  F6 00                        inc 0,x
0012FBr 3  D0 02                        bne @done
0012FDr 3  F6 01                        inc 1,x
0012FFr 3               @done:
0012FFr 3  60           z_cell_plus:    rts
001300r 3               
001300r 3               
001300r 3               
001300r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
001300r 3               ; ## "cells"  auto  ANS core
001300r 3                       ; """https://forth-standard.org/standard/core/CELLS
001300r 3                       ;
001300r 3                       ; Dummy entry for the CELLS word, the code is the same as for
001300r 3                       ; 2*, which is where the header directs us to
001300r 3                       ; """
001300r 3               
001300r 3               
001300r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
001300r 3               ; ## "char"  auto  ANS core
001300r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
001300r 3               
001300r 3               xt_char:
001300r 3                               ; get character from string, returns ( addr u )
001300r 3  20 rr rr                     jsr xt_parse_name
001303r 3               
001303r 3                               ; if we got back a zero, we have a problem
001303r 3  B5 00                        lda 0,x
001305r 3  15 01                        ora 1,x
001307r 3  D0 05                        bne @not_empty
001309r 3               
001309r 3  A9 05                        lda #err_noname
00130Br 3  4C rr rr                     jmp error
00130Er 3               
00130Er 3               @not_empty:
00130Er 3  E8                           inx             ; drop number of characters, leave addr
00130Fr 3  E8                           inx
001310r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
001312r 3  95 00                        sta 0,x
001314r 3  74 01                        stz 1,x         ; MSB is always zero
001316r 3               
001316r 3  60           z_char:         rts
001317r 3               
001317r 3               
001317r 3               
001317r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
001317r 3               ; ## "char+"  auto  ANS core
001317r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
001317r 3                       ;
001317r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
001317r 3                       ; """
001317r 3               
001317r 3               
001317r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
001317r 3               ; ## "chars"  auto  ANS core
001317r 3                       ; """https://forth-standard.org/standard/core/CHARS
001317r 3                       ; Return how many address units n chars are. Since this is an 8 bit
001317r 3                       ; machine, this does absolutely nothing and is included for
001317r 3                       ; compatibility with other Forth versions
001317r 3                       ; """
001317r 3               
001317r 3               xt_chars:
001317r 3                               ; Checking for underflow seems a bit stupid because this
001317r 3                               ; routine does nothing on this machine. However, the user
001317r 3                               ; should be warned that there is something wrong with the
001317r 3                               ; code if this occurs.
001317r 3  20 rr rr                     jsr underflow_1
00131Ar 3               
00131Ar 3  60           z_chars:        rts
00131Br 3               
00131Br 3               
00131Br 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
00131Br 3               ; ## "cleave"  auto  Tali Forth
00131Br 3               
00131Br 3                       ; """Given a range of memory with words delimited by whitespace,return
00131Br 3                       ; the first word at the top of the stack and the rest of the word
00131Br 3                       ; following it.
00131Br 3                       ;
00131Br 3                       ; Example:
00131Br 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
00131Br 3                       ; s" w1" cleave        -> "" "w1"
00131Br 3                       ;
00131Br 3                       ; Since it will be used in loops a lot, we want it to work in pure
00131Br 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
00131Br 3                       ; strip leading delimiters.
00131Br 3                       ; """
00131Br 3               
00131Br 3               xt_cleave:
00131Br 3  20 rr rr                     jsr underflow_2
00131Er 3               
00131Er 3                               ; We arrive here with ( addr u ). We need to strip any leading
00131Er 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
00131Er 3                               ; remember how many spaces were stripped. This means we can't
00131Er 3                               ; calculate the length of the remainder. Fortunately, Tali
00131Er 3                               ; Forth has just the word we need for this:
00131Er 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
001321r 3               
001321r 3                               ; The main part we can turn over to PARSE-NAME, except that we
001321r 3                               ; have a string ( addr u ) and not stuff in the input buffer.
001321r 3                               ; We get around this by cheating: We place ( addr u ) in the
001321r 3                               ; input buffer and then call PARSE-NAME.
001321r 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
001324r 3               
001324r 3  B5 00                        lda 0,x         ; u is new ciblen
001326r 3  85 0A                        sta ciblen
001328r 3  B5 01                        lda 1,x
00132Ar 3  85 0B                        sta ciblen+1
00132Cr 3               
00132Cr 3  B5 02                        lda 2,x         ; addr is new cib
00132Er 3  85 08                        sta cib
001330r 3  B5 03                        lda 3,x
001332r 3  85 09                        sta cib+1
001334r 3               
001334r 3  64 0C                        stz toin        ; >IN pointer is zero
001336r 3  64 0D                        stz toin+1
001338r 3               
001338r 3                               ; PARSE-NAME gives us back the substring of the first word
001338r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
00133Br 3               
00133Br 3                               ; If we were given an empty string, then we're done. It's the
00133Br 3                               ; resposibility of the user to catch this as a sign to end the
00133Br 3                               ; any loop
00133Br 3  B5 00                        lda 0,x
00133Dr 3  15 01                        ora 1,x
00133Fr 3  F0 23                        beq @done
001341r 3               
001341r 3                               ; Now we have to adjust the original string
001341r 3  B5 04                        lda 4,x         ; LSB of original u
001343r 3  38                           sec
001344r 3  F5 00                        sbc 0,x
001346r 3  95 04                        sta 4,x
001348r 3               
001348r 3  B5 05                        lda 5,x         ; MSB of original u
00134Ar 3  F5 01                        sbc 1,x
00134Cr 3  95 05                        sta 5,x
00134Er 3               
00134Er 3  B5 06                        lda 6,x         ; LSB of original addr
001350r 3  18                           clc
001351r 3  75 00                        adc 0,x
001353r 3  95 06                        sta 6,x
001355r 3               
001355r 3  B5 07                        lda 7,x         ; MSB of original addr
001357r 3  75 01                        adc 1,x
001359r 3  95 07                        sta 7,x
00135Br 3               
00135Br 3                               ; There is one small problem: PARSE-NAME will probably have
00135Br 3                               ; left the string with the rest of the words with leading
00135Br 3                               ; delimiters. We use our magic -LEADING again
00135Br 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
00135Er 3  20 rr rr                     jsr xt_minus_leading
001361r 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
001364r 3               @done:
001364r 3                               ; Restore input
001364r 3  20 rr rr                     jsr xt_r_to_input
001367r 3               
001367r 3  60           z_cleave:       rts
001368r 3               
001368r 3               
001368r 3               
001368r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
001368r 3               ; ## "cmove"  auto  ANS string
001368r 3                       ; """https://forth-standard.org/standard/string/CMOVE
001368r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
001368r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
001368r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
001368r 3                       ; "move left".
001368r 3                       ;
001368r 3                       ; There are no official tests for this word.
001368r 3                       ; """
001368r 3               
001368r 3               xt_cmove:
001368r 3  20 rr rr                     jsr underflow_3
00136Br 3               
00136Br 3                               ; move destination address to where we can work with it
00136Br 3  B5 02                        lda 2,x
00136Dr 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
00136Fr 3  B5 03                        lda 3,x
001371r 3  85 27                        sta tmp2+1
001373r 3               
001373r 3                               ; move source address to where we can work with it
001373r 3  B5 04                        lda 4,x
001375r 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
001377r 3  B5 05                        lda 5,x
001379r 3  85 25                        sta tmp1+1
00137Br 3               
00137Br 3  A0 00                        ldy #0
00137Dr 3  B5 01                        lda 1,x         ; number of whole pages to move
00137Fr 3  F0 0F                        beq @dopartial
001381r 3               
001381r 3               @page:
001381r 3  B1 24                        lda (tmp1),y
001383r 3  91 26                        sta (tmp2),y
001385r 3  C8                           iny
001386r 3  D0 F9                        bne @page
001388r 3               
001388r 3  E6 25                        inc tmp1+1
00138Ar 3  E6 27                        inc tmp2+1
00138Cr 3  D6 01                        dec 1,x
00138Er 3  D0 F1                        bne @page
001390r 3               
001390r 3               @dopartial:
001390r 3  B5 00                        lda 0,x         ; length of last page
001392r 3  F0 09                        beq @done
001394r 3               
001394r 3               @partial:
001394r 3  B1 24                        lda (tmp1),y
001396r 3  91 26                        sta (tmp2),y
001398r 3  C8                           iny
001399r 3               
001399r 3  D6 00                        dec 0,x
00139Br 3  D0 F7                        bne @partial
00139Dr 3               
00139Dr 3               @done:          ; clear the stack
00139Dr 3  8A                           txa
00139Er 3  18                           clc
00139Fr 3  69 06                        adc #6
0013A1r 3  AA                           tax
0013A2r 3               
0013A2r 3  60           z_cmove:        rts
0013A3r 3               
0013A3r 3               
0013A3r 3               
0013A3r 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
0013A3r 3               ; ## "cmove>"  auto  ANS string
0013A3r 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
0013A3r 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
0013A3r 3                       ; Routines", p. 201, where it is called "move right".
0013A3r 3                       ;
0013A3r 3                       ; There are no official tests for this word.
0013A3r 3                       ; """
0013A3r 3               
0013A3r 3               xt_cmove_up:
0013A3r 3  20 rr rr                     jsr underflow_3
0013A6r 3               
0013A6r 3                               ; Move destination address to where we can work with it
0013A6r 3  B5 02                        lda 2,x
0013A8r 3  85 26                        sta tmp2        ; use tmp2 because easier to remember
0013AAr 3  B5 03                        lda 3,x
0013ACr 3  18                           clc
0013ADr 3  75 01                        adc 1,x
0013AFr 3  85 27                        sta tmp2+1      ; point to last page of destination
0013B1r 3               
0013B1r 3                               ; Move source address to where we can work with it
0013B1r 3  B5 04                        lda 4,x
0013B3r 3  85 24                        sta tmp1        ; use tmp1 because easier to remember
0013B5r 3  B5 05                        lda 5,x
0013B7r 3  18                           clc
0013B8r 3  75 01                        adc 1,x
0013BAr 3  85 25                        sta tmp1+1      ; point to last page of source
0013BCr 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
0013BEr 3               
0013BEr 3                               ; Move the last partial page first
0013BEr 3  B4 00                        ldy 0,x         ; length of last page
0013C0r 3  F0 0E                        beq @nopartial
0013C2r 3               
0013C2r 3               @outerloop:
0013C2r 3  88                           dey
0013C3r 3  F0 07                        beq @finishpage
0013C5r 3               
0013C5r 3               @innerloop:
0013C5r 3  B1 24                        lda (tmp1),y
0013C7r 3  91 26                        sta (tmp2),y
0013C9r 3  88                           dey
0013CAr 3  D0 F9                        bne @innerloop
0013CCr 3               
0013CCr 3               @finishpage:
0013CCr 3  B2 24                        lda (tmp1)      ; handle y = 0 separately
0013CEr 3  92 26                        sta (tmp2)
0013D0r 3               
0013D0r 3               @nopartial:
0013D0r 3  C6 25                        dec tmp1+1      ; back up to previous pages
0013D2r 3  C6 27                        dec tmp2+1
0013D4r 3  D6 01                        dec 1,x
0013D6r 3  D0 EA                        bne @outerloop
0013D8r 3               @done:
0013D8r 3                               ; clear up the stack and leave
0013D8r 3  8A                           txa
0013D9r 3  18                           clc
0013DAr 3  69 06                        adc #6
0013DCr 3  AA                           tax
0013DDr 3               
0013DDr 3  60           z_cmove_up:     rts
0013DEr 3               
0013DEr 3               
0013DEr 3               
0013DEr 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
0013DEr 3               ; ## ":"  auto  ANS core
0013DEr 3                       ; """https://forth-standard.org/standard/core/Colon
0013DEr 3                       ;
0013DEr 3                       ; Use the CREATE routine and fill in the rest by hand.
0013DEr 3                       ; """
0013DEr 3               
0013DEr 3               xt_colon:
0013DEr 3                               ; If we're already in the compile state, complain
0013DEr 3                               ; and quit
0013DEr 3  A5 16                        lda state
0013E0r 3  05 17                        ora state+1
0013E2r 3  F0 05                        beq @1
0013E4r 3               
0013E4r 3  A9 07                        lda #err_state
0013E6r 3  4C rr rr                     jmp error
0013E9r 3               @1:
0013E9r 3                               ; switch to compile state
0013E9r 3  C6 16                        dec state
0013EBr 3  C6 17                        dec state+1
0013EDr 3               
0013EDr 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
0013EDr 3                               ; word
0013EDr 3  A9 40                        lda #%01000000
0013EFr 3  04 20                        tsb status
0013F1r 3               
0013F1r 3                               ; CREATE is going to change the DP to point to the new word's
0013F1r 3                               ; header. While this is fine for (say) variables, it would mean
0013F1r 3                               ; that FIND-NAME etc would find a half-finished word when
0013F1r 3                               ; looking in the Dictionary. To prevent this, we save the old
0013F1r 3                               ; version of DP and restore it later. The new DP is placed in
0013F1r 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
0013F1r 3  20 rr rr                     jsr current_to_dp
0013F4r 3  A5 03                        lda dp+1            ; CREATE uses a lot of variables
0013F6r 3  48                           pha
0013F7r 3  A5 02                        lda dp
0013F9r 3  48                           pha
0013FAr 3               
0013FAr 3                               ; Tell create not to print warning for duplicate name.
0013FAr 3  A9 80                        lda #%10000000
0013FCr 3  04 20                        tsb status
0013FEr 3               
0013FEr 3  20 rr rr                     jsr xt_create
001401r 3               
001401r 3                               ; Get the nt (not the xt!) of the new word as described above.
001401r 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
001401r 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
001404r 3  A5 02                        lda dp
001406r 3  85 04                        sta workword
001408r 3  A5 03                        lda dp+1
00140Ar 3  85 05                        sta workword+1
00140Cr 3               
00140Cr 3                               ; Restore original DP
00140Cr 3  68                           pla
00140Dr 3  85 02                        sta dp
00140Fr 3  68                           pla
001410r 3  85 03                        sta dp+1
001412r 3  20 rr rr                     jsr dp_to_current
001415r 3               
001415r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
001415r 3                               ; back up three bytes and overwrite that.
001415r 3  A5 00                        lda cp
001417r 3  38                           sec
001418r 3  E9 03                        sbc #3
00141Ar 3  85 00                        sta cp
00141Cr 3  B0 02                        bcs @done
00141Er 3  C6 01                        dec cp+1
001420r 3               @done:
001420r 3  60           z_colon:        rts
001421r 3               
001421r 3               
001421r 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
001421r 3               ; ## ":NONAME"  auto  ANS core
001421r 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
001421r 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
001421r 3                       ; """
001421r 3               
001421r 3               xt_colon_noname:
001421r 3                               ; If we're already in the compile state, complain
001421r 3                               ; and quit
001421r 3  A5 16                        lda state
001423r 3  05 17                        ora state+1
001425r 3  F0 05                        beq @1
001427r 3               
001427r 3  A9 07                        lda #err_state
001429r 3  4C rr rr                     jmp error
00142Cr 3               @1:
00142Cr 3                               ; switch to compile state
00142Cr 3  C6 16                        dec state
00142Er 3  C6 17                        dec state+1
001430r 3               
001430r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
001430r 3                               ; a :NONAME word.
001430r 3  A9 40                        lda #%01000000
001432r 3  14 20                        trb status
001434r 3               
001434r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
001434r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
001434r 3                               ; nt and they will modify their behavior.
001434r 3  A5 00                        lda cp
001436r 3  85 04                        sta workword
001438r 3  A5 01                        lda cp+1
00143Ar 3  85 05                        sta workword+1
00143Cr 3               @done:
00143Cr 3  60           z_colon_noname:        rts
00143Dr 3               
00143Dr 3               
00143Dr 3               
00143Dr 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
00143Dr 3               ; ## ","  auto  ANS core
00143Dr 3                       ; """https://forth-standard.org/standard/core/Comma
00143Dr 3                       ; Store TOS at current place in memory.
00143Dr 3                       ;
00143Dr 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
00143Dr 3                       ; """
00143Dr 3               
00143Dr 3               xt_comma:
00143Dr 3  20 rr rr                     jsr underflow_1
001440r 3               
001440r 3  B5 00                        lda 0,x
001442r 3  92 00                        sta (cp)
001444r 3               
001444r 3  E6 00                        inc cp
001446r 3  D0 02                        bne @1
001448r 3  E6 01                        inc cp+1
00144Ar 3               @1:
00144Ar 3  B5 01                        lda 1,x
00144Cr 3  92 00                        sta (cp)
00144Er 3               
00144Er 3  E6 00                        inc cp
001450r 3  D0 02                        bne @done
001452r 3  E6 01                        inc cp+1
001454r 3               @done:
001454r 3  E8                           inx
001455r 3  E8                           inx
001456r 3               
001456r 3  60           z_comma:        rts
001457r 3               
001457r 3               
001457r 3               
001457r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
001457r 3               ; ## "compare"   auto  ANS string
001457r 3                       ; """https://forth-standard.org/standard/string/COMPARE
001457r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
001457r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
001457r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
001457r 3                       ; that entirely matches the beginning of the other string, but is
001457r 3                       ; shorter, is considered less than the longer string.
001457r 3                       ; """
001457r 3               
001457r 3               xt_compare:
001457r 3  20 rr rr                     jsr underflow_4
00145Ar 3               
00145Ar 3                               ; Load the two string addresses into tmp1 and tmp2.
00145Ar 3  B5 02                        lda 2,x
00145Cr 3  85 26                        sta tmp2
00145Er 3  B5 03                        lda 3,x
001460r 3  85 27                        sta tmp2+1
001462r 3  B5 06                        lda 6,x
001464r 3  85 24                        sta tmp1
001466r 3  B5 07                        lda 7,x
001468r 3  85 25                        sta tmp1+1
00146Ar 3                               ; The counts will be used in-place on the stack.
00146Ar 3               
00146Ar 3               @compare_loop:
00146Ar 3                               ; Check to see if we are out of letters.
00146Ar 3               
00146Ar 3                               ; Check string1
00146Ar 3  B5 04                        lda 4,x
00146Cr 3  15 05                        ora 5,x
00146Er 3  F0 2C                        beq @str1_done
001470r 3               
001470r 3                               ; Check string2
001470r 3  B5 00                        lda 0,x
001472r 3  15 01                        ora 1,x
001474r 3  F0 3A                        beq @greater    ; Str2 empty first
001476r 3               
001476r 3               @check_letter:
001476r 3                               ; Both strings have at least one letter left.
001476r 3                               ; Check the letters against each other.
001476r 3  B2 24                        lda (tmp1)
001478r 3  D2 26                        cmp (tmp2)
00147Ar 3  90 26                        bcc @less
00147Cr 3  D0 32                        bne @greater
00147Er 3               @next_letter:
00147Er 3                               ; Move both tmp pointers and decrement the counts
00147Er 3                               ; on the stack.
00147Er 3                               ; Increment tmp1
00147Er 3  E6 24                        inc tmp1
001480r 3  D0 02                        bne @1
001482r 3  E6 25                        inc tmp1+1
001484r 3               @1:
001484r 3                               ; Increment tmp2
001484r 3  E6 26                        inc tmp2
001486r 3  D0 02                        bne @2
001488r 3  E6 27                        inc tmp2+1
00148Ar 3               @2:
00148Ar 3                               ; Decrement count1 on the stack.
00148Ar 3  B5 04                        lda 4,x
00148Cr 3  D0 02                        bne @3
00148Er 3  D6 05                        dec 5,x
001490r 3               @3:
001490r 3  D6 04                        dec 4,x
001492r 3               
001492r 3                               ; Decrement count2 on the stack.
001492r 3  B5 00                        lda 0,x
001494r 3  D0 02                        bne @4
001496r 3  D6 01                        dec 1,x
001498r 3               @4:
001498r 3  D6 00                        dec 0,x
00149Ar 3               
00149Ar 3                               ; Loop around and check again.
00149Ar 3  80 CE                        bra @compare_loop
00149Cr 3               
00149Cr 3               @str1_done:
00149Cr 3                               ; String 1 is out of letters. Check string 2.
00149Cr 3  B5 00                        lda 0,x
00149Er 3  15 01                        ora 1,x
0014A0r 3  F0 08                        beq @equal      ; Both out of letters
0014A2r 3               
0014A2r 3                               ; Falls into less (str1 is out but str2 has more)
0014A2r 3               @less:
0014A2r 3                               ; Return -1
0014A2r 3  A9 FF                        lda #$FF
0014A4r 3  95 06                        sta 6,x
0014A6r 3  95 07                        sta 7,x
0014A8r 3  80 0C                        bra @done
0014AAr 3               @equal:
0014AAr 3                               ; Return 0
0014AAr 3  74 06                        stz 6,x
0014ACr 3  74 07                        stz 7,x
0014AEr 3  80 06                        bra @done
0014B0r 3               @greater:
0014B0r 3                               ; Return 1
0014B0r 3  A9 01                        lda #1
0014B2r 3  95 06                        sta 6,x
0014B4r 3  74 07                        stz 7,x
0014B6r 3                               ; Falls into @done
0014B6r 3               @done:
0014B6r 3                               ; Remove all but the result from the stack.
0014B6r 3  8A                           txa
0014B7r 3  18                           clc
0014B8r 3  69 06                        adc #6
0014BAr 3  AA                           tax
0014BBr 3               
0014BBr 3  60           z_compare:      rts
0014BCr 3               
0014BCr 3               
0014BCr 3               
0014BCr 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
0014BCr 3               ; ## "compile,"  auto  ANS core ext
0014BCr 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
0014BCr 3                       ; Compile the given xt in the current word definition. It is an
0014BCr 3                       ; error if we are not in the compile state. Because we are using
0014BCr 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
0014BCr 3                       ; the traditional way. By default, native compiled is allowed, unless
0014BCr 3                       ; there is a NN (Never Native) flag associated. If not, we use the
0014BCr 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
0014BCr 3                       ; is too large to be natively coded: If the size is larger than
0014BCr 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
0014BCr 3                       ; Native) flag is set, the word is always natively compiled.
0014BCr 3                       ; """
0014BCr 3               
0014BCr 3               xt_compile_comma:
0014BCr 3  20 rr rr                     jsr underflow_1
0014BFr 3               
0014BFr 3                               ; See if this is an Always Native (AN) word by checking the
0014BFr 3                               ; AN flag. We need nt for this. First, save a copy of xt to
0014BFr 3                               ; the Return Stack
0014BFr 3  B5 01                        lda 1,x                 ; MSB
0014C1r 3  48                           pha
0014C2r 3  B5 00                        lda 0,x
0014C4r 3  48                           pha                     ; LSB
0014C5r 3               
0014C5r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
0014C8r 3               
0014C8r 3                               ; See if this xt even has an nt.
0014C8r 3  B5 00                        lda 0,x
0014CAr 3  15 01                        ora 1,x
0014CCr 3  D0 03                        bne @check_nt
0014CEr 3               
0014CEr 3                               ; No nt in dictionary. Just compile as a JSR.
0014CEr 3  4C rr rr                     jmp @compile_as_jump
0014D1r 3               
0014D1r 3               @check_nt:
0014D1r 3                               ; put nt away for safe keeping
0014D1r 3  B5 00                        lda 0,x
0014D3r 3  85 2C                        sta tmptos
0014D5r 3  B5 01                        lda 1,x
0014D7r 3  85 2D                        sta tmptos+1
0014D9r 3               
0014D9r 3                               ; status byte is one further down
0014D9r 3  F6 00                        inc 0,x
0014DBr 3  D0 02                        bne @1
0014DDr 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
0014DFr 3               @1:
0014DFr 3  A1 00                        lda (0,x)
0014E1r 3  85 28                        sta tmp3                ; keep copy of status byte for NN
0014E3r 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
0014E5r 3  F0 0D                        beq @compile_check
0014E7r 3               
0014E7r 3                               ; We're natively compiling no matter what. Get length and
0014E7r 3                               ; compile in code. Get the original nt back
0014E7r 3  A5 2C                        lda tmptos
0014E9r 3  95 00                        sta 0,x
0014EBr 3  A5 2D                        lda tmptos+1
0014EDr 3  95 01                        sta 1,x
0014EFr 3               
0014EFr 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
0014F2r 3               
0014F2r 3  80 27                        bra @compile_as_code
0014F4r 3               
0014F4r 3               @compile_check:
0014F4r 3                               ; See if Native Compile is even alowed by checking the NN
0014F4r 3                               ; flag
0014F4r 3  A5 28                        lda tmp3
0014F6r 3  29 08                        and #NN
0014F8r 3  F0 03                        beq @check_size_limit
0014FAr 3               
0014FAr 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
0014FDr 3               
0014FDr 3               @check_size_limit:
0014FDr 3                               ; Native compile is a legal option, but we need to see what
0014FDr 3                               ; limit the user set for size (in nc_limit)
0014FDr 3  A5 2C                        lda tmptos
0014FFr 3  95 00                        sta 0,x
001501r 3  A5 2D                        lda tmptos+1
001503r 3  95 01                        sta 1,x
001505r 3               
001505r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
001508r 3               
001508r 3                               ; Check the wordsize MSB against the user-defined limit.
001508r 3  B5 01                        lda 1,x
00150Ar 3  C5 1B                        cmp nc_limit+1
00150Cr 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
00150Er 3  D0 08                        bne @jumpto_compile_as_jump
001510r 3               
001510r 3                               ; Check the wordsize LSB against the user-defined limit.
001510r 3  B5 00                        lda 0,x
001512r 3  C5 1A                        cmp nc_limit            ; user-defined limit LSB
001514r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
001516r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
001518r 3               
001518r 3               @jumpto_compile_as_jump:
001518r 3                               ; If the wordsize is greater than the user-defined
001518r 3                               ; limit, it will be compiled as a subroutine jump.
001518r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00151Br 3               
00151Br 3               @compile_as_code:
00151Br 3                               ; We arrive here with the length of the word's code TOS and
00151Br 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
00151Br 3                               ; on the data stack
00151Br 3  CA                           dex
00151Cr 3  CA                           dex                     ; ( -- u ? )
00151Dr 3  CA                           dex
00151Er 3  CA                           dex                     ; ( -- u ? ? )
00151Fr 3               
00151Fr 3  B5 04                        lda 4,x
001521r 3  95 00                        sta 0,x                 ; LSB of u
001523r 3  B5 05                        lda 5,x
001525r 3  95 01                        sta 1,x                 ; ( -- u ? u )
001527r 3               
001527r 3  68                           pla
001528r 3  95 04                        sta 4,x                 ; LSB of xt
00152Ar 3  68                           pla
00152Br 3  95 05                        sta 5,x                 ; ( -- xt ? u )
00152Dr 3               
00152Dr 3  A5 00                        lda cp                  ; LSB of cp
00152Fr 3  95 02                        sta 2,x
001531r 3  A5 01                        lda cp+1
001533r 3  95 03                        sta 3,x                 ; ( -- xt cp u )
001535r 3               
001535r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
001535r 3               
001535r 3                               ; Native compiling allows us to strip the stack antics off
001535r 3                               ; a number of words that use the Return Stack such as >R, R>,
001535r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
001535r 3                               ; xt with the contents of the table
001535r 3  A0 00                        ldy #0
001537r 3               
001537r 3               @strip_loop:
001537r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
00153Ar 3  D5 04                        cmp 4,x                 ; LSB of xt
00153Cr 3  D0 07                        bne @next_entry
00153Er 3               
00153Er 3                               ; LSB is the same, test MSB
00153Er 3  B9 rr rr                     lda @strip_table+1,y
001541r 3  D5 05                        cmp 5,x
001543r 3  F0 0C                        beq @found_entry
001545r 3               
001545r 3                               ; MSB is not equal. Pretend though that we've come from LSB
001545r 3                               ; so we can use the next step for both cases
001545r 3               @next_entry:
001545r 3                               ; Not a word that needs stripping, so check next entry in table
001545r 3                               ; Let's see if we're done with the table (marked by zero entry)
001545r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
001548r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
00154Br 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
00154Dr 3               
00154Dr 3  C8                           iny
00154Er 3  C8                           iny
00154Fr 3  80 E6                        bra @strip_loop
001551r 3               @found_entry:
001551r 3                               ; This word is one of the ones that needs to have its size
001551r 3                               ; adjusted during native compile. We find the values in the
001551r 3                               ; next table with the same index, which is Y. However, Y is
001551r 3                               ; pointing to the MSB, so we need to go back to the LSB and
001551r 3                               ; halve the index before we can use it.
001551r 3  98                           tya
001552r 3  4A                           lsr
001553r 3  A8                           tay
001554r 3               
001554r 3                               ; Get the adjustment out of the size table. We were clever
001554r 3                               ; enough to make sure the cut on both ends of the code is
001554r 3                               ; is the same size.
001554r 3  B9 rr rr                     lda @strip_size,y
001557r 3  85 2C                        sta tmptos              ; save a copy
001559r 3               
001559r 3                               ; Adjust xt: Start later
001559r 3  18                           clc
00155Ar 3  75 04                        adc 4,x
00155Cr 3  95 04                        sta 4,x
00155Er 3  90 02                        bcc @2
001560r 3  F6 05                        inc 5,x                 ; we just care about the carry
001562r 3               @2:
001562r 3               
001562r 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
001562r 3                               ; bottom of the code, we have to double the value
001562r 3  06 2C                        asl tmptos
001564r 3               
001564r 3  38                           sec
001565r 3  B5 00                        lda 0,x
001567r 3  E5 2C                        sbc tmptos
001569r 3  95 00                        sta 0,x
00156Br 3  B0 02                        bcs @3
00156Dr 3  D6 01                        dec 1,x                 ; we just care about the borrow
00156Fr 3               @3:
00156Fr 3                               ; drop through to underflow check stripping
00156Fr 3               
00156Fr 3               @underflow_strip:
00156Fr 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
00156Fr 3               
00156Fr 3                               ; The user can choose to remove the unterflow testing in those
00156Fr 3                               ; words that have the UF flag. This shortens the word by
00156Fr 3                               ; 3 bytes if there is no underflow.
00156Fr 3               
00156Fr 3                               ; See if the user wants underflow stripping turned on
00156Fr 3  A5 1C                        lda uf_strip
001571r 3  05 1D                        ora uf_strip+1
001573r 3  F0 1C                        beq @specials_done
001575r 3               
001575r 3                               ; See if this word even contains underflow checking
001575r 3  A5 28                        lda tmp3
001577r 3  29 10                        and #UF
001579r 3  F0 16                        beq @specials_done
00157Br 3               
00157Br 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
00157Br 3                               ; long. Note hat PICK is a special case.
00157Br 3               
00157Br 3                               ; Adjust xt: Start later
00157Br 3  18                           clc
00157Cr 3  B5 04                        lda 4,x
00157Er 3  69 03                        adc #3
001580r 3  95 04                        sta 4,x
001582r 3  90 02                        bcc @4
001584r 3  F6 05                        inc 5,x                  ; we just care about the carry
001586r 3               @4:
001586r 3                               ; Adjust u: End earlier
001586r 3  38                           sec
001587r 3  B5 00                        lda 0,x
001589r 3  E9 03                        sbc #3
00158Br 3  95 00                        sta 0,x
00158Dr 3  B0 02                        bcs @5
00158Fr 3  D6 01                        dec 1,x                  ; we just care about the borrow
001591r 3               @5:
001591r 3               
001591r 3                               ; --- END OF SPECIAL CASES ---
001591r 3               @specials_done:
001591r 3                               ; Store size of area to be copied for calculation of
001591r 3                               ; new CP. We have to do this after all of the special cases
001591r 3                               ; because they might change the size
001591r 3  B5 01                        lda 1,x                 ; MSB
001593r 3  48                           pha
001594r 3  B5 00                        lda 0,x                 ; LSB
001596r 3  48                           pha
001597r 3               
001597r 3                               ; Enough of this, let's move those bytes already! We have
001597r 3                               ; ( xt cp u ) on the stack at this point
001597r 3  20 rr rr                     jsr xt_move
00159Ar 3               
00159Ar 3                               ; Update CP
00159Ar 3  18                           clc
00159Br 3  68                           pla                     ; LSB
00159Cr 3  65 00                        adc cp
00159Er 3  85 00                        sta cp
0015A0r 3               
0015A0r 3  68                           pla                     ; MSB
0015A1r 3  65 01                        adc cp+1
0015A3r 3  85 01                        sta cp+1
0015A5r 3               
0015A5r 3  80 2C                        bra @done
0015A7r 3               
0015A7r 3               @strip_table:
0015A7r 3                              ; List of words we strip the Return Stack antics from
0015A7r 3                              ; during native compile, zero terminated. The index here
0015A7r 3                              ; must be the same as for the sizes
0015A7r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
0015ABr 3  rr rr        
0015ADr 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
0015B1r 3  00 00        
0015B3r 3               
0015B3r 3               @strip_size:
0015B3r 3                               ; List of bytes to be stripped from the words that get their
0015B3r 3                               ; Return Stack antics removed during native compile. Index must
0015B3r 3                               ; be the same as for the xts. Zero terminated.
0015B3r 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
0015B7r 3  06 00        
0015B9r 3               
0015B9r 3               @compile_as_jump:
0015B9r 3                               ; Compile xt as a subroutine jump
0015B9r 3  A9 20                        lda #$20
0015BBr 3  92 00                        sta (cp)
0015BDr 3               
0015BDr 3  A0 01                        ldy #1
0015BFr 3  68                           pla             ; LSB
0015C0r 3  91 00                        sta (cp),y
0015C2r 3  C8                           iny
0015C3r 3  68                           pla             ; MSB
0015C4r 3  91 00                        sta (cp),y
0015C6r 3               
0015C6r 3                               ; allot space we just used
0015C6r 3  A9 03                        lda #3
0015C8r 3  18                           clc
0015C9r 3  65 00                        adc cp
0015CBr 3  85 00                        sta cp
0015CDr 3  90 02                        bcc @6
0015CFr 3  E6 01                        inc cp+1
0015D1r 3               @6:
0015D1r 3  E8                           inx             ; drop xt
0015D2r 3  E8                           inx
0015D3r 3               @done:
0015D3r 3               z_compile_comma:
0015D3r 3  60                           rts
0015D4r 3               
0015D4r 3               
0015D4r 3               
0015D4r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
0015D4r 3               ; ## "compile-only"  tested  Tali Forth
0015D4r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
0015D4r 3                       ; word.
0015D4r 3                       ;
0015D4r 3                       ; The alternative way to do this is to define a word
0015D4r 3                       ; ?COMPILE that makes sure  we're in compile mode
0015D4r 3                       ; """
0015D4r 3               
0015D4r 3               xt_compile_only:
0015D4r 3  20 rr rr                     jsr current_to_dp
0015D7r 3  A0 01                        ldy #1          ; offset for status byte
0015D9r 3  B1 02                        lda (dp),y
0015DBr 3  09 01                        ora #CO        ; make sure bit 7 is set
0015DDr 3  91 02                        sta (dp),y
0015DFr 3               
0015DFr 3  60           z_compile_only: rts
0015E0r 3               
0015E0r 3               
0015E0r 3               
0015E0r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
0015E0r 3               ; ## "constant"  auto  ANS core
0015E0r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
0015E0r 3                       ;
0015E0r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
0015E0r 3                       ; more in assembler and let CREATE do the heavy lifting.
0015E0r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
0015E0r 3                       ; a primer on how this works in various Forths. This is the
0015E0r 3                       ; same code as VALUE in our case.
0015E0r 3                       ; """
0015E0r 3               xt_value:
0015E0r 3               xt_constant:
0015E0r 3  20 rr rr                     jsr underflow_1
0015E3r 3               
0015E3r 3  20 rr rr                     jsr xt_create
0015E6r 3               
0015E6r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
0015E6r 3                               ; but we want DOCONST for constants. Go back two bytes and
0015E6r 3                               ; replace the subroutine jump target
0015E6r 3  38                           sec
0015E7r 3  A5 00                        lda cp
0015E9r 3  E9 02                        sbc #2
0015EBr 3  85 24                        sta tmp1
0015EDr 3  A5 01                        lda cp+1
0015EFr 3  E9 00                        sbc #0
0015F1r 3  85 25                        sta tmp1+1
0015F3r 3               
0015F3r 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
0015F5r 3  92 24                        sta (tmp1)
0015F7r 3  A0 01                        ldy #1
0015F9r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
0015FBr 3  91 24                        sta (tmp1),y
0015FDr 3               
0015FDr 3                               ; Now we save the constant number itself in the next cell
0015FDr 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
001600r 3               
001600r 3               adjust_z:
001600r 3                               ; Now the length of the complete word (z_word) has increased by
001600r 3                               ; two. We need to update that number or else words such as SEE
001600r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
001600r 3                               ; VALUE and DEFER
001600r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
001603r 3               
001603r 3                               ; z_word is six bytes further down
001603r 3  B5 00                        lda 0,x
001605r 3  85 24                        sta tmp1
001607r 3  B5 01                        lda 1,x
001609r 3  85 25                        sta tmp1+1
00160Br 3               
00160Br 3  A0 06                        ldy #6
00160Dr 3  B1 24                        lda (tmp1),y
00160Fr 3  18                           clc
001610r 3  69 02                        adc #2
001612r 3  91 24                        sta (tmp1),y
001614r 3  C8                           iny
001615r 3  B1 24                        lda (tmp1),y
001617r 3  69 00                        adc #0                  ; only need carry
001619r 3  91 24                        sta (tmp1),y
00161Br 3               
00161Br 3  E8                           inx
00161Cr 3  E8                           inx
00161Dr 3               
00161Dr 3               z_value:
00161Dr 3  60           z_constant:     rts
00161Er 3               
00161Er 3               
00161Er 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
00161Er 3               ; ## "count"  auto  ANS core
00161Er 3                       ; """https://forth-standard.org/standard/core/COUNT
00161Er 3                       ; Convert old-style character string to address-length pair. Note
00161Er 3                       ; that the length of the string c-addr is stored in character length
00161Er 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
00161Er 3                       ; though COUNT can also be used to step through a string character by
00161Er 3                       ; character.
00161Er 3                       ; """
00161Er 3               xt_count:
00161Er 3  20 rr rr                     jsr underflow_1
001621r 3               
001621r 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
001623r 3  A8                           tay
001624r 3               
001624r 3                               ; move start address up by one
001624r 3  F6 00                        inc 0,x         ; LSB
001626r 3  D0 02                        bne @1
001628r 3  F6 01                        inc 1,x         ; MSB
00162Ar 3               
00162Ar 3                               ; save number of characters to stack
00162Ar 3               @1:
00162Ar 3  98                           tya
00162Br 3  CA                           dex
00162Cr 3  CA                           dex
00162Dr 3  95 00                        sta 0,x         ; LSB
00162Fr 3  74 01                        stz 1,x         ; MSB, always zero
001631r 3               
001631r 3  60           z_count:        rts
001632r 3               
001632r 3               
001632r 3               ; ## CR ( -- ) "Print a line feed"
001632r 3               ; ## "cr"  auto  ANS core
001632r 3                       ; """https://forth-standard.org/standard/core/CR"""
001632r 3               xt_cr:
001632r 3  A9 0A                        lda #AscLF
001634r 3  20 rr rr                     jsr emit_a
001637r 3  60           z_cr:           rts
001638r 3               
001638r 3               
001638r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
001638r 3               ; ## "create"  auto  ANS core
001638r 3                       ; """https://forth-standard.org/standard/core/CREATE
001638r 3                       ;
001638r 3                       ; See the drawing in headers.asm for details on the header
001638r 3                       ; """
001638r 3               
001638r 3               xt_create:
001638r 3                               ; get string
001638r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00163Br 3               
00163Br 3                               ; if we were given an empty string, we complain and quit
00163Br 3  B5 00                        lda 0,x
00163Dr 3  15 01                        ora 1,x
00163Fr 3  D0 05                        bne @got_name
001641r 3               
001641r 3  A9 05                        lda #err_noname
001643r 3  4C rr rr                     jmp error
001646r 3               
001646r 3               @got_name:
001646r 3                               ; Enforce maximal length of string by overwriting the MSB of
001646r 3                               ; the length. There is a possible error here: If the string
001646r 3                               ; is exactly 255 chars long, then a lot of the following
001646r 3                               ; additions will fail because of wrapping
001646r 3  74 01                        stz 1,x
001648r 3               
001648r 3                               ; Check to see if this name already exists.
001648r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
00164Br 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
00164Er 3               
00164Er 3  B5 00                        lda 0,x
001650r 3  15 01                        ora 1,x
001652r 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
001654r 3               
001654r 3                               ; This name already exists.  See if we are supposed to print
001654r 3                               ; the message for it.
001654r 3  E8                           inx                     ; Drop flag (nt) from find-name.
001655r 3  E8                           inx
001656r 3               
001656r 3                               ; Check bit 7
001656r 3  24 20                        bit status
001658r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
00165Ar 3               
00165Ar 3                               ; We aren't supposed to print the redefined message ourselves,
00165Ar 3                               ; but we should indicate that it is redefined (for ; to print
00165Ar 3                               ; later).
00165Ar 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
00165Cr 3  05 20                        ora status
00165Er 3  85 20                        sta status
001660r 3  80 18                        bra @process_name
001662r 3               
001662r 3               @redefined_name:
001662r 3                               ; Print the message that the name is redefined.
001662r 3  A9 02                        lda #str_redefined
001664r 3  20 rr rr                     jsr print_string_no_lf
001667r 3               
001667r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
00166Ar 3  20 rr rr                     jsr xt_type
00166Dr 3  20 rr rr                     jsr xt_space
001670r 3               
001670r 3  80 08                        bra @process_name
001672r 3               
001672r 3               @new_name:
001672r 3  E8                           inx                     ; Drop flag (0) from find-name.
001673r 3  E8                           inx
001674r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
001676r 3  25 20                        and status
001678r 3  85 20                        sta status
00167Ar 3               
00167Ar 3               @process_name:
00167Ar 3  B5 00                        lda 0,x
00167Cr 3  85 26                        sta tmp2                ; store length of string in tmp2
00167Er 3               
00167Er 3                               ; remember the first free byte of memory as the start of
00167Er 3                               ; the new word
00167Er 3  A5 00                        lda cp
001680r 3  85 24                        sta tmp1
001682r 3  A5 01                        lda cp+1
001684r 3  85 25                        sta tmp1+1
001686r 3               
001686r 3                               ; We need 8 bytes plus the length of the string for our new header.
001686r 3                               ; This is also the offset for the start of the code field (the
001686r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
001686r 3                               ; just allot the space afterwards
001686r 3  B5 00                        lda 0,x
001688r 3  18                           clc
001689r 3  69 08                        adc #8
00168Br 3  85 28                        sta tmp3                ; total header length
00168Dr 3               
00168Dr 3                               ; We need three more bytes for for the hardcoded code field
00168Dr 3                               ; area (CFA), the "payload" of the word which by default will
00168Dr 3                               ; be a subroutine jump to DOVAR
00168Dr 3  18                           clc
00168Er 3  69 03                        adc #3
001690r 3               
001690r 3                               ; We overwrite the length of the string returned by PARSE-NAME
001690r 3                               ; and then call ALLOT
001690r 3  95 00                        sta 0,x
001692r 3  74 01                        stz 1,x         ; max header size is 255 chars
001694r 3  20 rr rr                     jsr xt_allot    ; ( addr )
001697r 3               
001697r 3                               ; Get the CURRENT dictionary pointer.
001697r 3  20 rr rr                     jsr current_to_dp
00169Ar 3               
00169Ar 3                               ; Now we walk through the header with Y as the index, adding
00169Ar 3                               ; information byte-by-byte
00169Ar 3  A0 00                        ldy #0
00169Cr 3               
00169Cr 3                               ; HEADER BYTE 0: Length of string
00169Cr 3  A5 26                        lda tmp2
00169Er 3  91 24                        sta (tmp1),y
0016A0r 3               
0016A0r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
0016A0r 3                               ; to "never native", user will have to decide if they should
0016A0r 3                               ; be inlined
0016A0r 3  A9 08                        lda #NN
0016A2r 3               
0016A2r 3                               ; Also, words defined by CREATE are marked in the header has
0016A2r 3                               ; having a Code Field Area (CFA), which is a bit tricky for
0016A2r 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
0016A2r 3                               ; correctly with DOES> and CREATE. See the discussion at
0016A2r 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
0016A2r 3  09 20                        ora #HC
0016A4r 3  C8                           iny
0016A5r 3  91 24                        sta (tmp1),y
0016A7r 3  C8                           iny
0016A8r 3               
0016A8r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
0016A8r 3                               ; in the Dictionary
0016A8r 3  A5 02                        lda dp
0016AAr 3  91 24                        sta (tmp1),y
0016ACr 3  C8                           iny
0016ADr 3  A5 03                        lda dp+1
0016AFr 3  91 24                        sta (tmp1),y
0016B1r 3  C8                           iny
0016B2r 3               
0016B2r 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
0016B2r 3  A5 25                        lda tmp1+1
0016B4r 3  85 03                        sta dp+1
0016B6r 3  A5 24                        lda tmp1
0016B8r 3  85 02                        sta dp
0016BAr 3               
0016BAr 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
0016BAr 3                               ; This begins after the header so we take the length of the
0016BAr 3                               ; header, which we cleverly saved in tmp3, and use it as an
0016BAr 3                               ; offset to the address of the start of the word. We come here
0016BAr 3                               ; with tmp1 in A
0016BAr 3  18                           clc
0016BBr 3  65 28                        adc tmp3        ; add total header length
0016BDr 3  91 24                        sta (tmp1),y
0016BFr 3  48                           pha             ; we need this in the next step
0016C0r 3  C8                           iny
0016C1r 3               
0016C1r 3  A5 25                        lda tmp1+1
0016C3r 3  69 00                        adc #0          ; only need the carry
0016C5r 3  91 24                        sta (tmp1),y
0016C7r 3  C8                           iny
0016C8r 3               
0016C8r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
0016C8r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
0016C8r 3                               ; bytes down, and then one more byte so that the z_ label points
0016C8r 3                               ; to the (still fictional) RTS instruction for correct compilation
0016C8r 3  68                           pla             ; LSB of "z_" address
0016C9r 3  18                           clc
0016CAr 3  69 03                        adc #3
0016CCr 3  91 24                        sta (tmp1),y
0016CEr 3               
0016CEr 3  88                           dey             ; get the MSB of xt back
0016CFr 3  B1 24                        lda (tmp1),y
0016D1r 3  69 00                        adc #0          ; only need the carry
0016D3r 3  C8                           iny
0016D4r 3  C8                           iny
0016D5r 3  91 24                        sta (tmp1),y
0016D7r 3  C8                           iny
0016D8r 3               
0016D8r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
0016D8r 3                               ; length in tmp2. We subtract 8 from the address so we can
0016D8r 3                               ; use the same loop index, which is already 8 byte ahead at
0016D8r 3                               ; this point
0016D8r 3  B5 00                        lda 0,x
0016DAr 3  38                           sec
0016DBr 3  E9 08                        sbc #8
0016DDr 3  85 2C                        sta tmptos
0016DFr 3               
0016DFr 3  B5 01                        lda 1,x
0016E1r 3  E9 00                        sbc #0          ; only need carry
0016E3r 3  85 2D                        sta tmptos+1
0016E5r 3               
0016E5r 3               @name_loop:
0016E5r 3  B1 2C                        lda (tmptos),y
0016E7r 3               
0016E7r 3                               ; Make sure it goes into the dictionary in lower case.
0016E7r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0016E9r 3  B0 07                        bcs @store_name
0016EBr 3  C9 41                        cmp #$41        ; ASCII 'A'
0016EDr 3  90 03                        bcc @store_name
0016EFr 3               
0016EFr 3                               ; An uppercase letter has been located. Make it
0016EFr 3                               ; lowercase.
0016EFr 3  18                           clc
0016F0r 3  69 20                        adc #$20
0016F2r 3               
0016F2r 3                               ; Fall into @store_name.
0016F2r 3               
0016F2r 3               @store_name:
0016F2r 3  91 24                        sta (tmp1),y
0016F4r 3  C8                           iny
0016F5r 3  C6 26                        dec tmp2
0016F7r 3  D0 EC                        bne @name_loop
0016F9r 3               
0016F9r 3                               ; After thename string comes the code field, starting at the
0016F9r 3                               ; current xt of this word, which is initially a jump to the
0016F9r 3                               ; subroutine to DOVAR. We code this jump by hand
0016F9r 3  A9 20                        lda #$20        ; opcode of JSR
0016FBr 3  91 24                        sta (tmp1),y
0016FDr 3  C8                           iny
0016FEr 3  A9 rr                        lda #<dovar
001700r 3  91 24                        sta (tmp1),y
001702r 3  C8                           iny
001703r 3  A9 rr                        lda #>dovar
001705r 3  91 24                        sta (tmp1),y
001707r 3               
001707r 3                               ; Update the CURRENT wordlist with the new DP.
001707r 3                               ; We do this down here because this routine uses Y.
001707r 3  20 rr rr                     jsr dp_to_current
00170Ar 3               
00170Ar 3                               ; And we're done. Restore stack
00170Ar 3  E8                           inx
00170Br 3  E8                           inx
00170Cr 3               
00170Cr 3  60           z_create:       rts
00170Dr 3               
00170Dr 3               
00170Dr 3               
00170Dr 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
00170Dr 3               ; ## "d-"  auto  ANS double
00170Dr 3                       ; """https://forth-standard.org/standard/double/DMinus"""
00170Dr 3               
00170Dr 3               xt_d_minus:
00170Dr 3  20 rr rr                     jsr underflow_4 ; two double numbers
001710r 3               
001710r 3  38                           sec
001711r 3               
001711r 3  B5 06                        lda 6,x         ; LSB of lower word
001713r 3  F5 02                        sbc 2,x
001715r 3  95 06                        sta 6,x
001717r 3               
001717r 3  B5 07                        lda 7,x         ; MSB of lower word
001719r 3  F5 03                        sbc 3,x
00171Br 3  95 07                        sta 7,x
00171Dr 3               
00171Dr 3  B5 04                        lda 4,x         ; LSB of upper word
00171Fr 3  F5 00                        sbc 0,x
001721r 3  95 04                        sta 4,x
001723r 3               
001723r 3  B5 05                        lda 5,x         ; MSB of upper word
001725r 3  F5 01                        sbc 1,x
001727r 3  95 05                        sta 5,x
001729r 3               
001729r 3  E8                           inx
00172Ar 3  E8                           inx
00172Br 3  E8                           inx
00172Cr 3  E8                           inx
00172Dr 3               
00172Dr 3  60           z_d_minus:      rts
00172Er 3               
00172Er 3               
00172Er 3               
00172Er 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
00172Er 3               ; ## "d+"  auto  ANS double
00172Er 3                       ; """https://forth-standard.org/standard/double/DPlus"""
00172Er 3               
00172Er 3               xt_d_plus:
00172Er 3  20 rr rr                     jsr underflow_4 ; two double numbers
001731r 3               
001731r 3  18                           clc
001732r 3  B5 02                        lda 2,x         ; LSB of lower word
001734r 3  75 06                        adc 6,x
001736r 3  95 06                        sta 6,x
001738r 3               
001738r 3  B5 03                        lda 3,x         ; MSB of lower word
00173Ar 3  75 07                        adc 7,x
00173Cr 3  95 07                        sta 7,x
00173Er 3               
00173Er 3  B5 00                        lda 0,x         ; LSB of upper word
001740r 3  75 04                        adc 4,x
001742r 3  95 04                        sta 4,x
001744r 3               
001744r 3  B5 01                        lda 1,x         ; MSB of upper word
001746r 3  75 05                        adc 5,x
001748r 3  95 05                        sta 5,x
00174Ar 3               
00174Ar 3  E8                           inx
00174Br 3  E8                           inx
00174Cr 3  E8                           inx
00174Dr 3  E8                           inx
00174Er 3               
00174Er 3  60           z_d_plus:       rts
00174Fr 3               
00174Fr 3               
00174Fr 3               
00174Fr 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
00174Fr 3               ; ## "d>s"  auto  ANS double
00174Fr 3                       ; """https://forth-standard.org/standard/double/DtoS
00174Fr 3                       ; Though this is basically just DROP, we keep it
00174Fr 3                       ; separate so we can test for underflow
00174Fr 3                       ; """
00174Fr 3               
00174Fr 3               xt_d_to_s:
00174Fr 3  20 rr rr                     jsr underflow_2
001752r 3               
001752r 3  E8                           inx
001753r 3  E8                           inx
001754r 3               
001754r 3  60           z_d_to_s:       rts
001755r 3               
001755r 3               
001755r 3               
001755r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
001755r 3               ; ## "dabs"  auto  ANS double
001755r 3                       ; """https://forth-standard.org/standard/double/DABS"""
001755r 3               
001755r 3               xt_dabs:
001755r 3  20 rr rr                     jsr underflow_2 ; double number
001758r 3               
001758r 3  B5 01                        lda 1,x         ; MSB of high cell
00175Ar 3  10 17                        bpl @done       ; positive, we get off light
00175Cr 3               
00175Cr 3                               ; negative, calculate 0 - d
00175Cr 3  A0 00                        ldy #0
00175Er 3  38                           sec
00175Fr 3               
00175Fr 3  98                           tya
001760r 3  F5 02                        sbc 2,x         ; LSB of low cell
001762r 3  95 02                        sta 2,x
001764r 3               
001764r 3  98                           tya
001765r 3  F5 03                        sbc 3,x         ; MSB of low cell
001767r 3  95 03                        sta 3,x
001769r 3               
001769r 3  98                           tya
00176Ar 3  F5 00                        sbc 0,x         ; LSB of high cell
00176Cr 3  95 00                        sta 0,x
00176Er 3               
00176Er 3  98                           tya
00176Fr 3  F5 01                        sbc 1,x         ; MSB of high cell
001771r 3  95 01                        sta 1,x
001773r 3               @done:
001773r 3  60           z_dabs:         rts
001774r 3               
001774r 3               
001774r 3               
001774r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
001774r 3               ; ## "decimal"  auto  ANS core
001774r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
001774r 3               xt_decimal:
001774r 3  A9 0A                        lda #10
001776r 3  85 18                        sta base
001778r 3  64 19                        stz base+1              ; paranoid
00177Ar 3               
00177Ar 3  60           z_decimal:      rts
00177Br 3               
00177Br 3               
00177Br 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
00177Br 3               ; ## "defer"  auto  ANS core ext
00177Br 3                       ; """https://forth-standard.org/standard/core/DEFER
00177Br 3                       ; Reserve an name that can be linked to various xt by IS.
00177Br 3                       ;
00177Br 3                       ; The ANS reference implementation is
00177Br 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
00177Br 3                       ; But we use this routine as a low-level word so things go faster
00177Br 3               
00177Br 3               xt_defer:
00177Br 3  20 rr rr                     jsr xt_create
00177Er 3               
00177Er 3                               ; CREATE by default installs a subroutine jump to DOVAR,
00177Er 3                               ; but we actually want DODEFER this time. Go back two
00177Er 3                               ; bytes and repace the subroutine jump target
00177Er 3  A5 00                        lda cp          ; LSB
001780r 3  38                           sec
001781r 3  E9 02                        sbc #2
001783r 3  85 24                        sta tmp1
001785r 3               
001785r 3  A5 01                        lda cp+1        ; MSB
001787r 3  E9 00                        sbc #0          ; we only care about the borrow
001789r 3  85 25                        sta tmp1+1
00178Br 3               
00178Br 3                               ; Save the target address
00178Br 3  A0 00                        ldy #0
00178Dr 3  A9 rr                        lda #<dodefer   ; LSB
00178Fr 3  91 24                        sta (tmp1),y
001791r 3  C8                           iny
001792r 3  A9 rr                        lda #>dodefer   ; MSB
001794r 3  91 24                        sta (tmp1),y
001796r 3               
001796r 3               
001796r 3                               ; DODEFER executes the next address it finds after
001796r 3                               ; its call. As default, we include the error
001796r 3                               ; "Defer not defined"
001796r 3  A9 rr                        lda #<defer_error
001798r 3  92 00                        sta (cp)
00179Ar 3  E6 00                        inc cp
00179Cr 3  D0 02                        bne @1
00179Er 3  E6 01                        inc cp+1
0017A0r 3               @1:
0017A0r 3  A9 rr                        lda #>defer_error
0017A2r 3  92 00                        sta (cp)
0017A4r 3  E6 00                        inc cp
0017A6r 3  D0 02                        bne @2
0017A8r 3  E6 01                        inc cp+1
0017AAr 3               @2:
0017AAr 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
0017ADr 3               
0017ADr 3  60           z_defer:        rts
0017AEr 3               
0017AEr 3               
0017AEr 3               
0017AEr 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
0017AEr 3               ; ## "defer@"  auto  ANS core ext
0017AEr 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
0017AEr 3               
0017AEr 3               xt_defer_fetch:
0017AEr 3                               ; No underflow checking as >BODY does it.
0017AEr 3  20 rr rr                     jsr xt_to_body
0017B1r 3  20 rr rr                     jsr xt_fetch
0017B4r 3  60           z_defer_fetch:  rts
0017B5r 3               
0017B5r 3               
0017B5r 3               
0017B5r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
0017B5r 3               ; ## "defer!"  auto  ANS core ext
0017B5r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
0017B5r 3               
0017B5r 3               xt_defer_store:
0017B5r 3                               ; No underflow checking as >BODY and ! do it.
0017B5r 3  20 rr rr                     jsr xt_to_body
0017B8r 3  20 rr rr                     jsr xt_store
0017BBr 3  60           z_defer_store:  rts
0017BCr 3               
0017BCr 3               
0017BCr 3               
0017BCr 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
0017BCr 3               ; ## "definitions" auto ANS search
0017BCr 3               xt_definitions:
0017BCr 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
0017BEr 3  B1 1E                        lda (up),y                  ; SEARCH_ORDER[0] to
0017C0r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
0017C2r 3  91 1E                        sta (up),y
0017C4r 3  60           z_definitions:  rts
0017C5r 3               
0017C5r 3               
0017C5r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
0017C5r 3               ; ## "depth"  auto  ANS core
0017C5r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
0017C5r 3               xt_depth:
0017C5r 3  A9 78                        lda #dsp0
0017C7r 3  86 2A                        stx tmpdsp
0017C9r 3  38                           sec
0017CAr 3  E5 2A                        sbc tmpdsp
0017CCr 3               
0017CCr 3                               ; divide by two because each cell is two bytes
0017CCr 3  4A                           lsr
0017CDr 3               
0017CDr 3  CA                           dex
0017CEr 3  CA                           dex
0017CFr 3  95 00                        sta 0,x
0017D1r 3  74 01                        stz 1,x
0017D3r 3               
0017D3r 3  60           z_depth:        rts
0017D4r 3               
0017D4r 3               
0017D4r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
0017D4r 3               ; ## "digit?"  auto  Tali Forth
0017D4r 3                       ; """Inspired by the pForth instruction DIGIT, see
0017D4r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0017D4r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
0017D4r 3                       ; pForth, we get the base (radix) ourselves instead of having the
0017D4r 3                       ; user provide it. There is no standard name for this routine, which
0017D4r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
0017D4r 3                       ; """
0017D4r 3               
0017D4r 3               xt_digit_question:
0017D4r 3  20 rr rr                     jsr underflow_1
0017D7r 3               
0017D7r 3                               ; one way or another, we're going to need room for the
0017D7r 3                               ; flag on the stack
0017D7r 3  CA                           dex
0017D8r 3  CA                           dex
0017D9r 3  74 00                        stz 0,x                 ; default flag is failure
0017DBr 3  74 01                        stz 1,x
0017DDr 3  74 03                        stz 3,x                 ; paranoid
0017DFr 3               
0017DFr 3                               ; Check the character, now in the LSB of NOS. First, make
0017DFr 3                               ; sure we're not below the ASCII code for "0"
0017DFr 3  B5 02                        lda 2,x
0017E1r 3  C9 30                        cmp #'0'
0017E3r 3  90 23                        bcc @done               ; failure flag already set
0017E5r 3               
0017E5r 3                               ; Next, see if we are below "9", because that would make
0017E5r 3                               ; this a normal number
0017E5r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
0017E7r 3  90 12                        bcc @checkbase
0017E9r 3               
0017E9r 3                               ; Well, then let's see if this is the gap between "9" and "A"
0017E9r 3                               ; so we can treat the whole range as a number
0017E9r 3  C9 41                        cmp #'A'
0017EBr 3  90 1B                        bcc @done               ; failure flag is already set
0017EDr 3               
0017EDr 3                               ; probably a letter, so we make sure it is uppercase
0017EDr 3  C9 61                        cmp #'a'
0017EFr 3  90 07                        bcc @case_done          ; not lower case, too low
0017F1r 3  C9 7B                        cmp #'z'+1
0017F3r 3  B0 03                        bcs @case_done          ; not lower case, too high
0017F5r 3               
0017F5r 3  18                           clc                     ; just right
0017F6r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
0017F8r 3               
0017F8r 3               @case_done:
0017F8r 3                               ; get rid of the gap between "9" and "A" so we can treat
0017F8r 3                               ; the whole range as one number
0017F8r 3  38                           sec
0017F9r 3  E9 07                        sbc #7                  ; fall through to @checkbase
0017FBr 3               
0017FBr 3               @checkbase:
0017FBr 3                               ; we have a number, now see if it falls inside the range
0017FBr 3                               ; provided by BASE
0017FBr 3  38                           sec
0017FCr 3  E9 30                        sbc #'0'                 ; this is also the conversion step
0017FEr 3  C5 18                        cmp base
001800r 3  B0 06                        bcs @done               ; already have false flag
001802r 3               
001802r 3                               ; Found a legal number
001802r 3  95 02                        sta 2,x                 ; put number in NOS
001804r 3  D6 00                        dec 0,x                 ; set success flag
001806r 3  D6 01                        dec 1,x
001808r 3               
001808r 3               @done:
001808r 3               z_digit_question:
001808r 3  60                           rts
001809r 3               
001809r 3               
001809r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
001809r 3               ; ## "disasm"  tested  Tali Forth
001809r 3                       ; """Convert a segment of memory to assembler output. This
001809r 3                       ; word is vectored so people can add their own disassembler.
001809r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
001809r 3                       ; code, see the section on The Disassembler in the manual and
001809r 3                       ; the file disassembler.asm for more details.
001809r 3                       ; """
001809r 3               xt_disasm:
001809r 3  20 rr rr                     jsr underflow_2
00180Cr 3               
00180Cr 3  20 rr rr                     jsr disassembler
00180Fr 3               
00180Fr 3  60           z_disasm:       rts
001810r 3               
001810r 3               
001810r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
001810r 3               ; ## "dnegate"  auto  ANS double
001810r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
001810r 3               xt_dnegate:
001810r 3  20 rr rr                     jsr underflow_2 ; double number
001813r 3               
001813r 3  A0 00             		ldy #0
001815r 3  38                           sec
001816r 3               
001816r 3  98                           tya
001817r 3  F5 02                        sbc 2,x         ; LSB of low cell
001819r 3  95 02                        sta 2,x
00181Br 3               
00181Br 3  98                           tya
00181Cr 3  F5 03                        sbc 3,x         ; MSB of low cell
00181Er 3  95 03                        sta 3,x
001820r 3               
001820r 3  98                           tya
001821r 3  F5 00                        sbc 0,x         ; LSB of high cell
001823r 3  95 00                        sta 0,x
001825r 3               
001825r 3  98                           tya
001826r 3  F5 01                        sbc 1,x         ; MSB of high cell
001828r 3  95 01                        sta 1,x
00182Ar 3               
00182Ar 3  60           z_dnegate:      rts
00182Br 3               
00182Br 3               
00182Br 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
00182Br 3               ; ## "?do"  auto  ANS core ext
00182Br 3                       ; """https://forth-standard.org/standard/core/qDO"""
00182Br 3               xt_question_do:
00182Br 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
00182Br 3                               ; to mark which is which
00182Br 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
00182Dr 3  85 24                        sta tmp1
00182Fr 3  80 02                        bra do_common           ; skip flag for DO
001831r 3               
001831r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
001831r 3               ; ## "do"  auto  ANS core
001831r 3                       ; """https://forth-standard.org/standard/core/DO
001831r 3                       ;
001831r 3                       ; Compile-time part of DO. Could be realized in Forth as
001831r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
001831r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
001831r 3                       ; a routine that pushes the end address to the Return Stack at run
001831r 3                       ; time. This is based on a suggestion by Garth Wilson, see
001831r 3                       ; the Control Flow section of the manual for details.
001831r 3                       ;
001831r 3                       ; This may not be native compile. Don't check for a stack underflow
001831r 3                       ; """
001831r 3               
001831r 3               xt_do:
001831r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
001831r 3  64 24                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
001833r 3               do_common:
001833r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
001833r 3                               ; compile the address we need to LDA at runtime
001833r 3  CA                           dex
001834r 3  CA                           dex
001835r 3  A5 00                        lda cp
001837r 3  95 00                        sta 0,x                 ; LSB
001839r 3  A5 01                        lda cp+1
00183Br 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
00183Dr 3               
00183Dr 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
00183Dr 3                               ; replace by the actual LDA/PHA instructions
00183Dr 3  A9 05                        lda #5                  ; we don't really care about the value,
00183Fr 3  A8                           tay                     ; so we use 5 to be tricky
001840r 3               @loop:
001840r 3  91 00                        sta (cp),y
001842r 3  88                           dey
001843r 3  10 FB                        bpl @loop
001845r 3               
001845r 3                               ; update CP
001845r 3  1A                           inc             ; we used 5 as a dummy value, this is why
001846r 3  18                           clc
001847r 3  65 00                        adc cp
001849r 3  85 00                        sta cp
00184Br 3  90 02                        bcc @1
00184Dr 3  E6 01                        inc cp+1
00184Fr 3               @1:
00184Fr 3                               ; compile the (?DO) portion of ?DO if appropriate
00184Fr 3  A5 24                        lda tmp1
001851r 3  F0 17                        beq @compile_do
001853r 3               
001853r 3                               ; We came from ?DO, so compile its runtime first. We do
001853r 3                               ; this with a quick loop because we know it has to be
001853r 3                               ; Always Native anyway
001853r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
001855r 3  5A                           phy             ; save counter to calculate new CP
001856r 3               @2:
001856r 3  B9 rr rr                     lda question_do_runtime,y
001859r 3  91 00                        sta (cp),y
00185Br 3  88                           dey
00185Cr 3  10 F8                        bpl @2
00185Er 3               
00185Er 3                               ; adjust CP
00185Er 3  68                           pla             ; retrieve counter
00185Fr 3  18                           clc
001860r 3  65 00                        adc cp
001862r 3  85 00                        sta cp
001864r 3  A5 01                        lda cp+1
001866r 3  69 00                        adc #0          ; only care about carry
001868r 3  85 01                        sta cp+1        ; fall through to @compile_do
00186Ar 3               
00186Ar 3               @compile_do:
00186Ar 3                               ; compile runtime part of DO.
00186Ar 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
00186Cr 3  5A                           phy             ; save counter to calculate new CP
00186Dr 3               @3:
00186Dr 3  B9 rr rr                     lda do_runtime,y
001870r 3  91 00                        sta (cp),y
001872r 3  88                           dey
001873r 3  10 F8                        bpl @3
001875r 3               
001875r 3                               ; adjust CP
001875r 3  68                           pla             ; retrieve counter
001876r 3  18                           clc
001877r 3  65 00                        adc cp
001879r 3  85 00                        sta cp
00187Br 3  A5 01                        lda cp+1
00187Dr 3  69 00                        adc #0          ; only care about carry
00187Fr 3  85 01                        sta cp+1
001881r 3               
001881r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
001881r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
001881r 3                               ; do with the HERE we're saving for LEAVE
001881r 3  CA                           dex
001882r 3  CA                           dex
001883r 3  A5 00                        lda cp          ; LSB
001885r 3  95 00                        sta 0,x
001887r 3  A5 01                        lda cp+1        ; MSB
001889r 3  95 01                        sta 1,x
00188Br 3               z_question_do:
00188Br 3  60           z_do:           rts
00188Cr 3               
00188Cr 3               
00188Cr 3               do_runtime:
00188Cr 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
00188Cr 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
00188Cr 3                       ; the FIG Forth loop (you can see which version you have by running
00188Cr 3                       ; a loop with start and limit as the same value, for instance
00188Cr 3                       ; 0 0 DO -- these will walk through the number space). We use a
00188Cr 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
00188Cr 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
00188Cr 3                       ; for further discussion of this. The source given there for
00188Cr 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
00188Cr 3                       ; in some Forths. Usually, we would define this as a separate word
00188Cr 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
00188Cr 3                       ; However, we can do it faster if we just copy the bytes
00188Cr 3                       ; of this routine with a simple loop in DO.
00188Cr 3                       ; """
00188Cr 3                               ; First step: create fudge factor (FUFA) by subtracting the
00188Cr 3                               ; limit from $8000, the number that will trip the overflow
00188Cr 3                               ; flag
00188Cr 3  38                           sec
00188Dr 3  A9 00                        lda #0
00188Fr 3  F5 02                        sbc 2,x         ; LSB of limit
001891r 3  95 02                        sta 2,x         ; save FUFA for later use
001893r 3               
001893r 3  A9 80                        lda #$80
001895r 3  F5 03                        sbc 3,x         ; MSB of limit
001897r 3  95 03                        sta 3,x         ; save FUFA for later use
001899r 3  48                           pha             ; FUFA replaces limit on R stack
00189Ar 3  B5 02                        lda 2,x         ; LSB of limit
00189Cr 3  48                           pha
00189Dr 3               
00189Dr 3                               ; Second step: index is FUFA plus original index
00189Dr 3  18                           clc
00189Er 3  B5 00                        lda 0,x         ; LSB of original index
0018A0r 3  75 02                        adc 2,x         ; add LSB of FUFA
0018A2r 3  95 00                        sta 0,x
0018A4r 3  B5 01                        lda 1,x         ; MSB of orginal index
0018A6r 3  75 03                        adc 3,x         ; add MSB of FUFA
0018A8r 3  48                           pha
0018A9r 3  B5 00                        lda 0,x         ; LSB of index
0018ABr 3  48                           pha
0018ACr 3               
0018ACr 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
0018ACr 3                               ; use it later. Clean the Data Stack
0018ACr 3  E8                           inx
0018ADr 3  E8                           inx
0018AEr 3  E8                           inx
0018AFr 3  E8                           inx             ; no RTS because this is copied into code
0018B0r 3               do_runtime_end:
0018B0r 3               
0018B0r 3               question_do_runtime:
0018B0r 3               
0018B0r 3                       ; """This is called (?DO) in some Forths. See the explanation at
0018B0r 3                       ; do_runtime for the background on this design
0018B0r 3                       ; """
0018B0r 3                               ; see if TOS and NOS are equal. Change this to assembler
0018B0r 3                               ; for speed
0018B0r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
0018B3r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
0018B6r 3               
0018B6r 3  B5 00                        lda 0,x
0018B8r 3  15 01                        ora 1,x
0018BAr 3  F0 06                        beq @do_do
0018BCr 3               
0018BCr 3                               ; We're equal, so dump everything and jump beyond the loop.
0018BCr 3                               ; But first, dump six entries off of the Data Stack
0018BCr 3  8A                           txa
0018BDr 3  18                           clc
0018BEr 3  69 06                        adc #6
0018C0r 3  AA                           tax
0018C1r 3               
0018C1r 3                               ; Then abort the whole loop
0018C1r 3  60                           rts
0018C2r 3               @do_do:
0018C2r 3  E8                           inx             ; clear flag from EQUAL off stack
0018C3r 3  E8                           inx             ; no RTS because this is copied into code
0018C4r 3               question_do_runtime_end:
0018C4r 3               
0018C4r 3               
0018C4r 3               
0018C4r 3               ; ## DOES ( -- ) "Add payload when defining new words"
0018C4r 3               ; ## "does>"  auto  ANS core
0018C4r 3                       ; """https://forth-standard.org/standard/core/DOES
0018C4r 3                       ; Create the payload for defining new defining words. See
0018C4r 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
0018C4r 3                       ; the Developer Guide in the manual for a discussion of
0018C4r 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
0018C4r 3                       ; """
0018C4r 3               
0018C4r 3               xt_does:
0018C4r 3                               ; compile a subroutine jump to runtime of DOES>
0018C4r 3  A0 rr                        ldy #>does_runtime
0018C6r 3  A9 rr                        lda #<does_runtime
0018C8r 3  20 rr rr                     jsr cmpl_subroutine
0018CBr 3               
0018CBr 3                               ; compile a subroutine jump to DODOES. In traditional
0018CBr 3                               ; terms, this is the Code Field Area (CFA) of the new
0018CBr 3                               ; word
0018CBr 3  A0 rr                        ldy #>dodoes
0018CDr 3  A9 rr                        lda #<dodoes
0018CFr 3  20 rr rr                     jsr cmpl_subroutine
0018D2r 3               
0018D2r 3  60           z_does:         rts
0018D3r 3               
0018D3r 3               
0018D3r 3               does_runtime:
0018D3r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
0018D3r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
0018D3r 3                       ; address that contains a subroutine jump to DODOES. We don't
0018D3r 3                       ; jump to DODOES directly because we need to work our magic with
0018D3r 3                       ; the return addresses. This routine is also known as "(DOES)" in
0018D3r 3                       ; other Forths
0018D3r 3                       ; """
0018D3r 3               
0018D3r 3  7A                           ply             ; LSB
0018D4r 3  68                           pla             ; MSB
0018D5r 3               
0018D5r 3  C8                           iny
0018D6r 3  D0 01                        bne @1
0018D8r 3  1A                           inc
0018D9r 3               @1:
0018D9r 3  84 24                        sty tmp1
0018DBr 3  85 25                        sta tmp1+1
0018DDr 3               
0018DDr 3                               ; CREATE has also already modified the DP to point to the new
0018DDr 3                               ; word. We have no idea which instructions followed the CREATE
0018DDr 3                               ; command if there is a DOES> so the CP could point anywhere
0018DDr 3                               ; by now. The address of the word's xt is four bytes down.
0018DDr 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
0018E0r 3  A5 02                        lda dp
0018E2r 3  18                           clc
0018E3r 3  69 04                        adc #4
0018E5r 3  85 26                        sta tmp2
0018E7r 3  A5 03                        lda dp+1
0018E9r 3  69 00                        adc #0          ; we only care about the carry
0018EBr 3  85 27                        sta tmp2+1
0018EDr 3               
0018EDr 3                               ; Now we get that address and add one byte to skip over the JSR
0018EDr 3                               ; opcode
0018EDr 3  B2 26                        lda (tmp2)
0018EFr 3  18                           clc
0018F0r 3  69 01                        adc #1
0018F2r 3  85 28                        sta tmp3
0018F4r 3  A0 01                        ldy #1
0018F6r 3  B1 26                        lda (tmp2),y
0018F8r 3  69 00                        adc #0          ; we only care about the carry
0018FAr 3  85 29                        sta tmp3+1
0018FCr 3               
0018FCr 3                               ; Replace the DOVAR address with our own
0018FCr 3  A5 24                        lda tmp1        ; LSB
0018FEr 3  92 28                        sta (tmp3)
001900r 3  A5 25                        lda tmp1+1
001902r 3  91 28                        sta (tmp3),y    ; Y is still 1
001904r 3               
001904r 3                               ; Since we removed the return address that brought us here, we
001904r 3                               ; go back to whatever the main routine was. Otherwise, we we
001904r 3                               ; smash into the subroutine jump to DODOES.
001904r 3  60                           rts
001905r 3               
001905r 3               
001905r 3               
001905r 3               ; ## DOT ( u -- ) "Print TOS"
001905r 3               ; ## "."  auto  ANS core
001905r 3                       ; """https://forth-standard.org/standard/core/d"""
001905r 3               
001905r 3               xt_dot:
001905r 3  20 rr rr                     jsr underflow_1
001908r 3               
001908r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
00190Br 3  20 rr rr                     jsr xt_abs                      ; ( n u )
00190Er 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
001911r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
001914r 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
001917r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
00191Ar 3  20 rr rr                     jsr xt_sign                     ; ( ud )
00191Dr 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
001920r 3  20 rr rr                     jsr xt_type
001923r 3  20 rr rr                     jsr xt_space
001926r 3               
001926r 3  60           z_dot:          rts
001927r 3               
001927r 3               
001927r 3               
001927r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
001927r 3               ; ## ".("  auto  ANS core
001927r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
001927r 3               
001927r 3               xt_dot_paren:
001927r 3                               ; Put a right paren on the stack.
001927r 3  CA                           dex
001928r 3  CA                           dex
001929r 3  A9 29                        lda #41     ; Right parenthesis
00192Br 3  95 00                        sta 0,x
00192Dr 3  74 01                        stz 1,x
00192Fr 3               
00192Fr 3  20 rr rr                     jsr xt_parse
001932r 3  20 rr rr                     jsr xt_type
001935r 3               
001935r 3  60           z_dot_paren:    rts
001936r 3               
001936r 3               
001936r 3               
001936r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
001936r 3               ; ## ".""  auto  ANS core ext
001936r 3                       ; """https://forth-standard.org/standard/core/Dotq
001936r 3                       ; Compile string that is printed during run time. ANS Forth wants
001936r 3                       ; this to be compile-only, even though everybody and their friend
001936r 3                       ; uses it for everything. We follow the book here, and recommend
001936r 3                       ; `.(` for general printing.
001936r 3                       ; """
001936r 3               
001936r 3               xt_dot_quote:
001936r 3                               ; we let S" do the heavy lifting. Since we're in
001936r 3                               ; compile mode, it will save the string and reproduce it
001936r 3                               ; during runtime
001936r 3  20 rr rr                     jsr xt_s_quote
001939r 3               
001939r 3                               ; We then let TYPE do the actual printing
001939r 3  A0 rr                        ldy #>xt_type
00193Br 3  A9 rr                        lda #<xt_type
00193Dr 3  20 rr rr                     jsr cmpl_subroutine
001940r 3               
001940r 3  60           z_dot_quote:    rts
001941r 3               
001941r 3               
001941r 3               
001941r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
001941r 3               ; ## ".r"  tested  ANS core ext
001941r 3                       ; """https://forth-standard.org/standard/core/DotR
001941r 3                       ;
001941r 3                       ; Based on the Forth code
001941r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
001941r 3                       ; """
001941r 3               
001941r 3               xt_dot_r:
001941r 3  20 rr rr                     jsr underflow_2
001944r 3               
001944r 3  20 rr rr                     jsr xt_to_r
001947r 3  20 rr rr                     jsr xt_dup
00194Ar 3  20 rr rr                     jsr xt_abs
00194Dr 3  20 rr rr                     jsr xt_zero
001950r 3  20 rr rr                     jsr xt_less_number_sign
001953r 3  20 rr rr                     jsr xt_number_sign_s
001956r 3  20 rr rr                     jsr xt_rot
001959r 3  20 rr rr                     jsr xt_sign
00195Cr 3  20 rr rr                     jsr xt_number_sign_greater
00195Fr 3  20 rr rr                     jsr xt_r_from
001962r 3  20 rr rr                     jsr xt_over
001965r 3  20 rr rr                     jsr xt_minus
001968r 3  20 rr rr                     jsr xt_spaces
00196Br 3  20 rr rr                     jsr xt_type
00196Er 3               
00196Er 3  60           z_dot_r:        rts
00196Fr 3               
00196Fr 3               
00196Fr 3               
00196Fr 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
00196Fr 3               ; ## ".s"  tested  ANS tools
00196Fr 3                       ; """https://forth-standard.org/standard/tools/DotS
00196Fr 3                       ; Print content of Data Stack non-distructively. We follow the format
00196Fr 3                       ; of Gforth and print the number of elements first in brackets,
00196Fr 3                       ; followed by the Data Stack content (if any).
00196Fr 3                       ;
00196Fr 3                       ; Since this is for humans, we don't have to worry about speed.
00196Fr 3                       ; """
00196Fr 3               
00196Fr 3               xt_dot_s:
00196Fr 3  20 rr rr                     jsr xt_depth    ; ( -- u )
001972r 3               
001972r 3                               ; Print stack depth in brackets
001972r 3  A9 3C                        lda #$3c        ; ASCII for "<"
001974r 3  20 rr rr                     jsr emit_a
001977r 3               
001977r 3                               ; We keep a copy of the number of the things on the stack
001977r 3                               ; to use as a counter later down. This assumes that there
001977r 3                               ; are less than 255 elements on the stack
001977r 3  B5 00                        lda 0,x
001979r 3  48                           pha
00197Ar 3               
00197Ar 3                               ; print unsigned number without the trailing space
00197Ar 3  CA                           dex             ; DUP
00197Br 3  CA                           dex
00197Cr 3  95 00                        sta 0,x
00197Er 3  74 01                        stz 1,x
001980r 3               
001980r 3  20 rr rr                     jsr print_u
001983r 3               
001983r 3  A9 3E                        lda #$3e        ; ASCII for ">"
001985r 3  20 rr rr                     jsr emit_a
001988r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
00198Ar 3  20 rr rr                     jsr emit_a
00198Dr 3               
00198Dr 3  E8                           inx
00198Er 3  E8                           inx
00198Fr 3               
00198Fr 3                               ; There will be lots of cases where the stack is empty. If that
00198Fr 3                               ; is so, get out of here quickly
00198Fr 3  E0 78                        cpx #dsp0
001991r 3  F0 1E                        beq @done
001993r 3               
001993r 3               @have_stack:
001993r 3                               ; We have at least one element on the stack. The depth of the
001993r 3                               ; stack is on the stack, we can use it as a counter. We go
001993r 3                               ; from bottom to top
001993r 3  7A                           ply
001994r 3               
001994r 3  A9 77                        lda #dsp0-1     ; go up one to avoid garbage
001996r 3  85 28                        sta tmp3
001998r 3  64 29                        stz tmp3+1      ; must be zero page on the 65c02
00199Ar 3               @loop:
00199Ar 3  CA                           dex
00199Br 3  CA                           dex
00199Cr 3               
00199Cr 3  B2 28                        lda (tmp3)
00199Er 3  95 01                        sta 1,x
0019A0r 3  C6 28                        dec tmp3
0019A2r 3               
0019A2r 3  B2 28                        lda (tmp3)
0019A4r 3  95 00                        sta 0,x
0019A6r 3  C6 28                        dec tmp3
0019A8r 3  5A                           phy
0019A9r 3               
0019A9r 3  20 rr rr                     jsr xt_dot
0019ACr 3               
0019ACr 3  7A                           ply
0019ADr 3  88                           dey
0019AEr 3  D0 EA                        bne @loop
0019B0r 3               
0019B0r 3  48                           pha             ; dummy to balance stack
0019B1r 3               @done:
0019B1r 3  68                           pla
0019B2r 3  60           z_dot_s:        rts
0019B3r 3               
0019B3r 3               
0019B3r 3               
0019B3r 3               ; ## D_DOT ( d -- ) "Print double"
0019B3r 3               ; ## "d."  tested  ANS double
0019B3r 3                       ; """http://forth-standard.org/standard/double/Dd"""
0019B3r 3                       ;
0019B3r 3                       ; From the Forth code:
0019B3r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
0019B3r 3                       ; """
0019B3r 3               
0019B3r 3               xt_d_dot:
0019B3r 3  20 rr rr                     jsr underflow_2
0019B6r 3               
0019B6r 3  20 rr rr                     jsr xt_tuck
0019B9r 3  20 rr rr                     jsr xt_dabs
0019BCr 3  20 rr rr                     jsr xt_less_number_sign
0019BFr 3  20 rr rr                     jsr xt_number_sign_s
0019C2r 3  20 rr rr                     jsr xt_rot
0019C5r 3  20 rr rr                     jsr xt_sign
0019C8r 3  20 rr rr                     jsr xt_number_sign_greater
0019CBr 3  20 rr rr                     jsr xt_type
0019CEr 3  20 rr rr                     jsr xt_space
0019D1r 3               
0019D1r 3  60           z_d_dot:        rts
0019D2r 3               
0019D2r 3               
0019D2r 3               
0019D2r 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
0019D2r 3               ; ## "d.r"  tested  ANS double
0019D2r 3                       ; """http://forth-standard.org/standard/double/DDotR"""
0019D2r 3                       ; Based on the Forth code
0019D2r 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
0019D2r 3                       ; """
0019D2r 3               
0019D2r 3               xt_d_dot_r:
0019D2r 3  20 rr rr                     jsr underflow_3
0019D5r 3                               ; From the forth code:
0019D5r 3  20 rr rr                     jsr xt_to_r
0019D8r 3  20 rr rr                     jsr xt_tuck
0019DBr 3  20 rr rr                     jsr xt_dabs
0019DEr 3  20 rr rr                     jsr xt_less_number_sign
0019E1r 3  20 rr rr                     jsr xt_number_sign_s
0019E4r 3  20 rr rr                     jsr xt_rot
0019E7r 3  20 rr rr                     jsr xt_sign
0019EAr 3  20 rr rr                     jsr xt_number_sign_greater
0019EDr 3  20 rr rr                     jsr xt_r_from
0019F0r 3  20 rr rr                     jsr xt_over
0019F3r 3  20 rr rr                     jsr xt_minus
0019F6r 3  20 rr rr                     jsr xt_spaces
0019F9r 3  20 rr rr                     jsr xt_type
0019FCr 3               
0019FCr 3  60           z_d_dot_r:      rts
0019FDr 3               
0019FDr 3               
0019FDr 3               
0019FDr 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
0019FDr 3               ; ## "drop"  auto  ANS core
0019FDr 3                       ; """https://forth-standard.org/standard/core/DROP"""
0019FDr 3               xt_drop:
0019FDr 3  20 rr rr                     jsr underflow_1
001A00r 3               
001A00r 3  E8                           inx
001A01r 3  E8                           inx
001A02r 3               
001A02r 3  60           z_drop:         rts
001A03r 3               
001A03r 3               
001A03r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
001A03r 3               ; ## "dump"  tested  ANS tools
001A03r 3                       ; """https://forth-standard.org/standard/tools/DUMP
001A03r 3                       ;
001A03r 3                       ; DUMP's exact output is defined as "implementation dependent".
001A03r 3                       ; This is in assembler because it is
001A03r 3                       ; useful for testing and development, so we want to have it work
001A03r 3                       ; as soon as possible. Uses TMP2
001A03r 3                       ; """
001A03r 3               
001A03r 3               xt_dump:
001A03r 3  20 rr rr                     jsr underflow_2
001A06r 3               @row:
001A06r 3                               ; start counter for 16 numbers per row
001A06r 3  A0 10                        ldy #16
001A08r 3               
001A08r 3                               ; We use TMP2 as the index for the ASCII characters
001A08r 3                               ; that we print at the and of the hex block. We
001A08r 3                               ; start saving them at HERE (CP)
001A08r 3  64 26                        stz tmp2
001A0Ar 3               
001A0Ar 3  20 rr rr                     jsr xt_cr
001A0Dr 3               
001A0Dr 3                               ; print address number
001A0Dr 3  B5 03                        lda 3,x
001A0Fr 3  20 rr rr                     jsr byte_to_ascii
001A12r 3  B5 02                        lda 2,x
001A14r 3  20 rr rr                     jsr byte_to_ascii
001A17r 3               
001A17r 3  20 rr rr                     jsr xt_space
001A1Ar 3  20 rr rr                     jsr xt_space
001A1Dr 3               @loop:
001A1Dr 3                               ; if there are zero bytes left to display, we're done
001A1Dr 3  B5 00                        lda 0,x
001A1Fr 3  15 01                        ora 1,x
001A21r 3  F0 39                        beq @all_printed
001A23r 3               
001A23r 3                               ; dump the contents
001A23r 3  A1 02                        lda (2,x)
001A25r 3  48                           pha                     ; byte_to_ascii destroys A
001A26r 3  20 rr rr                     jsr byte_to_ascii
001A29r 3  20 rr rr                     jsr xt_space
001A2Cr 3  68                           pla
001A2Dr 3               
001A2Dr 3                               ; Handle ASCII printing
001A2Dr 3  20 rr rr                     jsr is_printable
001A30r 3  B0 02                        bcs @printable
001A32r 3  A9 2E                        lda #'.'                 ; Print dot if not printable
001A34r 3               @printable:
001A34r 3  5A                           phy                     ; save counter
001A35r 3  A4 26                        ldy tmp2
001A37r 3  91 00                        sta (cp),y
001A39r 3  E6 26                        inc tmp2
001A3Br 3  7A                           ply
001A3Cr 3               
001A3Cr 3                               ; extra space after eight bytes
001A3Cr 3  C0 09                        cpy #9
001A3Er 3  D0 03                        bne @next_char
001A40r 3  20 rr rr                     jsr xt_space
001A43r 3               
001A43r 3               @next_char:
001A43r 3  F6 02                        inc 2,x
001A45r 3  D0 02                        bne @counter
001A47r 3  F6 03                        inc 3,x
001A49r 3               
001A49r 3               @counter:
001A49r 3                               ; loop counter
001A49r 3  B5 00                        lda 0,x
001A4Br 3  D0 02                        bne @1
001A4Dr 3  D6 01                        dec 1,x
001A4Fr 3               @1:
001A4Fr 3  D6 00                        dec 0,x
001A51r 3  88                           dey
001A52r 3  D0 C9                        bne @loop               ; next byte
001A54r 3               
001A54r 3                               ; Done with one line, print the ASCII version of these
001A54r 3                               ; characters
001A54r 3  20 rr rr                     jsr xt_space
001A57r 3  20 rr rr                     jsr print_ascii
001A5Ar 3               
001A5Ar 3  80 AA                        bra @row                ; new row
001A5Cr 3               
001A5Cr 3               @all_printed:
001A5Cr 3                               ; See if there are any ASCII characters in the buffer
001A5Cr 3                               ; left to print
001A5Cr 3  A5 26                        lda tmp2
001A5Er 3  F0 06                        beq @done
001A60r 3               
001A60r 3                               ; In theory, we could try to make the ASCII part line
001A60r 3                               ; up with the line before it. But that is a hassle (we
001A60r 3                               ; use three bytes for each missed hex entry, and
001A60r 3                               ; then there is the gap after eight entries) and it
001A60r 3                               ; makes it harder to read. We settle for one extra
001A60r 3                               ; space instead for the moment
001A60r 3  20 rr rr                     jsr xt_space
001A63r 3  20 rr rr                     jsr print_ascii
001A66r 3               @done:
001A66r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
001A69r 3  60           z_dump:         rts
001A6Ar 3               
001A6Ar 3               
001A6Ar 3               print_ascii:
001A6Ar 3                               ; Print the ASCII characters that we have saved from
001A6Ar 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
001A6Ar 3                               ; is not compiled (DUMP is probably never compiled anyway)
001A6Ar 3                               ; but we keep it inside the scope of DUMP.
001A6Ar 3  A0 00                        ldy #0
001A6Cr 3               @ascii_loop:
001A6Cr 3  B1 00                        lda (cp),y
001A6Er 3  20 rr rr                     jsr emit_a
001A71r 3  C8                           iny
001A72r 3               
001A72r 3                               ; extra space after eight chars
001A72r 3  C0 08                        cpy #8
001A74r 3  D0 03                        bne @1
001A76r 3  20 rr rr                     jsr xt_space
001A79r 3               @1:
001A79r 3  C6 26                        dec tmp2
001A7Br 3  D0 EF                        bne @ascii_loop
001A7Dr 3               
001A7Dr 3  60                           rts
001A7Er 3               
001A7Er 3               
001A7Er 3               
001A7Er 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
001A7Er 3               ; ## "dup"  auto  ANS core
001A7Er 3                       ; """https://forth-standard.org/standard/core/DUP"""
001A7Er 3               xt_dup:
001A7Er 3  20 rr rr                     jsr underflow_1
001A81r 3               
001A81r 3  CA                           dex
001A82r 3  CA                           dex
001A83r 3               
001A83r 3  B5 02                        lda 2,x         ; LSB
001A85r 3  95 00                        sta 0,x
001A87r 3  B5 03                        lda 3,x         ; MSB
001A89r 3  95 01                        sta 1,x
001A8Br 3               
001A8Br 3  60           z_dup:          rts
001A8Cr 3               
001A8Cr 3               
001A8Cr 3               ; ## ED ( -- u ) "Line-based editor"
001A8Cr 3               ; ## "ed"  fragment  Tali Forth
001A8Cr 3                       ; """Start the line-based editor ed6502. See separate file
001A8Cr 3                       ; ed.asm or the manual for details.
001A8Cr 3                       ; """
001A8Cr 3               xt_ed:
001A8Cr 3  20 rr rr                     jsr ed6502      ; kept in separate file
001A8Fr 3               
001A8Fr 3  60           z_ed:           rts
001A90r 3               
001A90r 3               
001A90r 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
001A90r 3               ; ## "editor-wordlist"  tested  Tali Editor
001A90r 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
001A90r 3                       ; words to the search order so they can be used.  This will need
001A90r 3                       ; to be done before any of the words marked "Tali Editor" can be
001A90r 3                       ; used.  See the tutorial on Wordlists and the Search Order for
001A90r 3                       ; more information.
001A90r 3               
001A90r 3                       ;
001A90r 3                       ; This is a dummy entry, the code is shared with ONE
001A90r 3                       ; """
001A90r 3               
001A90r 3               
001A90r 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
001A90r 3               ; ## "else"  auto  ANS core
001A90r 3                       ; """http://forth-standard.org/standard/core/ELSE
001A90r 3                       ;
001A90r 3                       ; The code is shared with ENDOF
001A90r 3                       ; """
001A90r 3               
001A90r 3               xt_else:
001A90r 3               xt_endof:
001A90r 3                               ; Put an unconditional branch.
001A90r 3  A0 rr                        ldy #>branch_runtime
001A92r 3  A9 rr                        lda #<branch_runtime
001A94r 3  20 rr rr                     jsr cmpl_subroutine
001A97r 3               
001A97r 3                               ; Put the address of the branch address on the stack.
001A97r 3  20 rr rr                     jsr xt_here
001A9Ar 3               
001A9Ar 3                               ; Use zero for the branch address for now.
001A9Ar 3                               ; THEN will fill it in later.
001A9Ar 3  20 rr rr                     jsr xt_zero
001A9Dr 3  20 rr rr                     jsr xt_comma
001AA0r 3               
001AA0r 3                               ; Get the address to jump to (just after the
001AA0r 3                               ; unconditional branch) for the IF to jump to
001AA0r 3                               ; when false.
001AA0r 3  20 rr rr                     jsr xt_here
001AA3r 3  20 rr rr                     jsr xt_rot
001AA6r 3               
001AA6r 3                               ; Update the original if 0branch address.
001AA6r 3  20 rr rr                     jsr xt_store
001AA9r 3               z_else:
001AA9r 3               z_endof:
001AA9r 3  60                           rts
001AAAr 3               
001AAAr 3               
001AAAr 3               
001AAAr 3               branch_runtime:
001AAAr 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
001AAAr 3                       ; formally part of a separate word BRANCH which was later removed.
001AAAr 3                       ; """
001AAAr 3               
001AAAr 3                               ; The address on the Return Stack points to the last byte
001AAAr 3                               ; of the JSR address, one byte below the branch literal
001AAAr 3  68                           pla
001AABr 3  85 22                        sta tmpbranch
001AADr 3  68                           pla
001AAEr 3  85 23                        sta tmpbranch+1
001AB0r 3               
001AB0r 3                               ; Keep in mind: the address we just popped points one byte
001AB0r 3                               ; lower than the branch literal we want to grab
001AB0r 3  A0 01                        ldy #1
001AB2r 3  B1 22                        lda (tmpbranch),y  ; LSB
001AB4r 3  85 24                        sta tmp1
001AB6r 3  C8                           iny
001AB7r 3  B1 22                        lda (tmpbranch),y  ; MSB
001AB9r 3  85 25                        sta tmp1+1
001ABBr 3               
001ABBr 3  6C 24 00                     jmp (tmp1)
001ABEr 3               
001ABEr 3               
001ABEr 3               
001ABEr 3               ; ## EMIT ( char -- ) "Print character to current output"
001ABEr 3               ; ## "emit"  auto  ANS core
001ABEr 3                       ; """https://forth-standard.org/standard/core/EMIT
001ABEr 3                       ; Run-time default for EMIT. The user can revector this by changing
001ABEr 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
001ABEr 3                       ; do not check to see if we have been given a valid ASCII character.
001ABEr 3                       ; Don't make this native compile.
001ABEr 3                       ; """
001ABEr 3               
001ABEr 3               xt_emit:
001ABEr 3  20 rr rr                     jsr underflow_1
001AC1r 3               
001AC1r 3  B5 00                        lda 0,x
001AC3r 3  E8                           inx
001AC4r 3  E8                           inx
001AC5r 3               
001AC5r 3               emit_a:
001AC5r 3                       ; We frequently want to print the character in A without fooling
001AC5r 3                       ; around with the Data Stack. This is emit_a's job, which still
001AC5r 3                       ; allows the output to be vectored. Call it with JSR as you
001AC5r 3                       ; would XT_EMIT
001AC5r 3  6C 10 00                     jmp (output)            ; JSR/RTS
001AC8r 3               
001AC8r 3               z_emit:         ; never reached
001AC8r 3               
001AC8r 3               
001AC8r 3               
001AC8r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
001AC8r 3               ; ## "empty-buffers"  tested  ANS block ext
001AC8r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
001AC8r 3               xt_empty_buffers:
001AC8r 3                               ; Set the buffer status to empty.
001AC8r 3  A0 2C                        ldy #buffstatus_offset
001ACAr 3  A9 00                        lda #0
001ACCr 3  91 1E                        sta (up),y      ; Only LSB is used.
001ACEr 3               z_empty_buffers:
001ACEr 3  60                           rts
001ACFr 3               
001ACFr 3               
001ACFr 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
001ACFr 3               ; ## "endcase"  auto  ANS core ext
001ACFr 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
001ACFr 3               
001ACFr 3               xt_endcase:
001ACFr 3                               ; Postpone DROP to remove the item
001ACFr 3                               ; being checked.
001ACFr 3  A0 rr                        ldy #>xt_drop
001AD1r 3  A9 rr                        lda #<xt_drop
001AD3r 3  20 rr rr                     jsr cmpl_subroutine
001AD6r 3               
001AD6r 3                               ; There are a number of address (of branches that need their
001AD6r 3                               ; jump addressed filled in with the address of right here).
001AD6r 3                               ; Keep calling THEN to deal with them until we reach the
001AD6r 3                               ; 0 that CASE put on the stack at the beginning.
001AD6r 3               @endcase_loop:
001AD6r 3                               ; Check for 0 on the stack.
001AD6r 3  B5 00                        lda 0,x
001AD8r 3  15 01                        ora 1,x
001ADAr 3  F0 05                        beq @done
001ADCr 3               
001ADCr 3  20 rr rr                     jsr xt_then
001ADFr 3  80 F5                        bra @endcase_loop
001AE1r 3               @done:
001AE1r 3                               ; Remove the 0 from the stack.
001AE1r 3  E8                           inx
001AE2r 3  E8                           inx
001AE3r 3  60           z_endcase:      rts
001AE4r 3               
001AE4r 3               
001AE4r 3               
001AE4r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
001AE4r 3               ; ## "endof"  auto  ANS core ext
001AE4r 3                       ; """http://forth-standard.org/standard/core/ENDOF
001AE4r 3                       ; This is a dummy entry, the code is shared with ELSE
001AE4r 3                       ; """
001AE4r 3               
001AE4r 3               
001AE4r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
001AE4r 3               ; ## "environment?"  auto  ANS core
001AE4r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
001AE4r 3                       ;
001AE4r 3                       ; By ANS definition, we use upper-case strings here, see the
001AE4r 3                       ; string file for details. This can be realized as a high-level
001AE4r 3                       ; Forth word as
001AE4r 3                       ;
001AE4r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
001AE4r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
001AE4r 3                       ; HEX
001AE4r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
001AE4r 3                       ; CASE
001AE4r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
001AE4r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
001AE4r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
001AE4r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
001AE4r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
001AE4r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
001AE4r 3                       ; S" MAX-D"              STRING_OF
001AE4r 3                                                    ; 7FFFFFFF. TRUE ENDOF
001AE4r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
001AE4r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
001AE4r 3                       ; S" MAX-UD"             STRING_OF
001AE4r 3                                                    ; FFFFFFFF. TRUE ENDOF
001AE4r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
001AE4r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
001AE4r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
001AE4r 3                       ; ENDCASE ;
001AE4r 3                       ;
001AE4r 3                       ; but that uses lots of memory and increases the start up time. This
001AE4r 3                       ; word is rarely used so we can try to keep it short at the expense
001AE4r 3                       ; of speed.
001AE4r 3                       ; """
001AE4r 3               
001AE4r 3               xt_environment_q:
001AE4r 3  20 rr rr                     jsr underflow_1
001AE7r 3               
001AE7r 3                               ; This code is table-driven: We walk through the list of
001AE7r 3                               ; strings until we find one that matches, and then we take
001AE7r 3                               ; the equivalent data from the results table. This is made
001AE7r 3                               ; a bit harder by the fact that some of these return a
001AE7r 3                               ; double-cell number and some a single-cell one.
001AE7r 3               
001AE7r 3                               ; We will walk through the table with variables that return
001AE7r 3                               ; a single-cell result
001AE7r 3  A0 00                        ldy #00                 ; counter for table
001AE9r 3               
001AE9r 3                               ; We use a flag on the the stack to signal if we have a single-cell
001AE9r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
001AE9r 3                               ; double-cell.
001AE9r 3  5A                           phy
001AEAr 3               @table_loop:
001AEAr 3                               ; We arrived here with the address of the string to be checked
001AEAr 3                               ; on the stack. We make a copy. Index is in Y
001AEAr 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
001AEDr 3               
001AEDr 3                               ; We do our work on the TOS to speed things up
001AEDr 3  CA                           dex
001AEEr 3  CA                           dex                     ; ( addr u addr u ? )
001AEFr 3               
001AEFr 3                               ; Get address of string to check from table
001AEFr 3  B9 rr rr                     lda env_table_single,y
001AF2r 3  95 00                        sta 0,x
001AF4r 3  C8                           iny
001AF5r 3  B9 rr rr                     lda env_table_single,y
001AF8r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
001AFAr 3  C8                           iny
001AFBr 3               
001AFBr 3                               ; See if this is the last entry. The LSB is still in A
001AFBr 3  15 00                        ora 0,x
001AFDr 3  F0 4D                        beq @table_done
001AFFr 3               
001AFFr 3                               ; We have a string entry. The address there is stored in
001AFFr 3                               ; old-style address format, that is, the first byte is the
001AFFr 3                               ; length of the string
001AFFr 3  5A                           phy                     ; save Y, which is used by COUNT
001B00r 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
001B03r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
001B06r 3  7A                           ply
001B07r 3               
001B07r 3                               ; If we found a match (flag is zero -- COMPARE is weird
001B07r 3                               ; that way), return the result
001B07r 3  B5 00                        lda 0,x
001B09r 3  15 01                        ora 1,x
001B0Br 3  F0 04                        beq @got_result
001B0Dr 3               
001B0Dr 3                               ; Flag is not zero, so not a perfect match, so try next
001B0Dr 3                               ; word
001B0Dr 3  E8                           inx                     ; DROP, now ( addr u )
001B0Er 3  E8                           inx
001B0Fr 3               
001B0Fr 3  80 D9                        bra @table_loop
001B11r 3               
001B11r 3               @got_result:
001B11r 3                               ; We arrive here with ( addr u -1 ) and know that we've found
001B11r 3                               ; a match. The index of the match+2 is in Y.
001B11r 3  E8                           inx                     ; drop flag, now ( addr u )
001B12r 3  E8                           inx
001B13r 3  88                           dey                     ; go back to index we had
001B14r 3  88                           dey
001B15r 3               
001B15r 3                               ; See if this is a single-cell word.
001B15r 3  68                           pla
001B16r 3  D0 0D                        bne @double_result
001B18r 3               
001B18r 3                               ; Single-cell result
001B18r 3  B9 rr rr                     lda env_results_single,y
001B1Br 3  95 02                        sta 2,x
001B1Dr 3  C8                           iny
001B1Er 3  B9 rr rr                     lda env_results_single,y
001B21r 3  95 03                        sta 3,x                 ; ( res u )
001B23r 3               
001B23r 3  80 1F                        bra @set_flag
001B25r 3               
001B25r 3               @double_result:
001B25r 3                               ; This is a double-celled result, which means we have to
001B25r 3                               ; fool around with the index some more. We also need a
001B25r 3                               ; further cell on the stack
001B25r 3  CA                           dex                     ; ( addr u ? )
001B26r 3  CA                           dex
001B27r 3               
001B27r 3                               ; We have 11 single-cell words we check, plus the 0000 as
001B27r 3                               ; a marker for the end of the table, so we arrive here
001B27r 3                               ; with Y as 22 or more. To get the index for the double-
001B27r 3                               ; cell words, we move the result
001B27r 3  98                           tya
001B28r 3  38                           sec
001B29r 3  E9 18                        sbc #24
001B2Br 3               
001B2Br 3                               ; We have four bytes per entry in the table, but the index
001B2Br 3                               ; keeps increasing by two, so we only have to multiply by
001B2Br 3                               ; two (shift left once) to get the right result
001B2Br 3  0A                           asl
001B2Cr 3  A8                           tay
001B2Dr 3               
001B2Dr 3  B9 rr rr                     lda env_results_double,y
001B30r 3  95 02                        sta 2,x
001B32r 3  C8                           iny
001B33r 3  B9 rr rr                     lda env_results_double,y
001B36r 3  95 03                        sta 3,x                 ; ( res u ? )
001B38r 3  C8                           iny
001B39r 3               
001B39r 3  B9 rr rr                     lda env_results_double,y
001B3Cr 3  95 04                        sta 4,x
001B3Er 3  C8                           iny
001B3Fr 3  B9 rr rr                     lda env_results_double,y
001B42r 3  95 05                        sta 5,x                 ; ( res res ? )
001B44r 3               
001B44r 3                               ; fall through to @set_flag
001B44r 3               @set_flag:
001B44r 3  A9 FF                        lda #$ff
001B46r 3  95 00                        sta 0,x
001B48r 3  95 01                        sta 1,x                 ; ( res f )
001B4Ar 3               
001B4Ar 3  80 14                        bra @done
001B4Cr 3               @table_done:
001B4Cr 3                               ; We're done with a table, because the entry was a zero.
001B4Cr 3                               ; We arrive here with ( addr u addr u 0 )
001B4Cr 3               
001B4Cr 3                               ; We take the flag from stack and increase it by one. If the
001B4Cr 3                               ; flag is zero, we have just completed the single-cell number
001B4Cr 3                               ; strings, so we in increase the flag and try again. Otherwise,
001B4Cr 3                               ; we're done with the double-cell table without having found
001B4Cr 3                               ; a match, and we're done
001B4Cr 3  68                           pla
001B4Dr 3  D0 09                        bne @no_match
001B4Fr 3               
001B4Fr 3                               ; Flag is zero, increase it to one and start over to check
001B4Fr 3                               ; double-cell values
001B4Fr 3  1A                           inc
001B50r 3  48                           pha
001B51r 3               
001B51r 3  8A                           txa
001B52r 3  18                           clc
001B53r 3  69 06                        adc #6                  ; skip six bytes
001B55r 3  AA                           tax                     ; ( addr u )
001B56r 3               
001B56r 3  80 92                        bra @table_loop
001B58r 3               @no_match:
001B58r 3                               ; Bummer, not found. We arrive here with
001B58r 3                               ; ( addr u addr u 0 ) and need to return just a zero
001B58r 3  8A                           txa
001B59r 3  18                           clc
001B5Ar 3  69 0A                        adc #10
001B5Cr 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
001B5Dr 3               
001B5Dr 3  20 rr rr                     jsr xt_false
001B60r 3               @done:
001B60r 3               z_environment_q:
001B60r 3  60                           rts
001B61r 3               
001B61r 3               
001B61r 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
001B61r 3               ; results and one for the double-celled results. The zero cell at the
001B61r 3               ; end of each table marks its, uh, end. The strings themselves are defined
001B61r 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
001B61r 3               ; have to adapt the result code for double printout, where we subtract 22
001B61r 3               ; (two bytes each single-cell string and two bytes for the end-of-table
001B61r 3               ; marker 0000
001B61r 3               env_table_single:
001B61r 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
001B65r 3  rr rr rr rr  
001B69r 3  rr rr        
001B6Br 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
001B6Fr 3  rr rr rr rr  
001B73r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
001B77r 3  00 00        
001B79r 3               
001B79r 3               env_table_double:
001B79r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
001B7Dr 3  00 00        
001B7Fr 3               
001B7Fr 3               env_results_single:
001B7Fr 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
001B81r 3  FF 00                .word $00FF     ; /HOLD
001B83r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
001B85r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
001B87r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
001B89r 3  FF 00                .word $00FF     ; MAX-CHAR
001B8Br 3  FF 7F                .word $7FFF     ; MAX-N
001B8Dr 3  FF FF                .word $FFFF     ; MAX-U
001B8Fr 3  80 00                .word $0080     ; RETURN-STACK-CELLS
001B91r 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
001B93r 3  09 00                .word $0009     ; WORDLISTS
001B95r 3               
001B95r 3               env_results_double:
001B95r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
001B99r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
001B9Dr 3               
001B9Dr 3               
001B9Dr 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
001B9Dr 3               ; ## "="  auto  ANS core
001B9Dr 3                       ; """https://forth-standard.org/standard/core/Equal"""
001B9Dr 3               
001B9Dr 3               xt_equal:
001B9Dr 3  20 rr rr                     jsr underflow_2
001BA0r 3               
001BA0r 3  B5 00                        lda 0,x                 ; LSB
001BA2r 3  D5 02                        cmp 2,x
001BA4r 3  D0 0A                        bne @false
001BA6r 3               
001BA6r 3  B5 01                        lda 1,x                 ; MSB
001BA8r 3  D5 03                        cmp 3,x
001BAAr 3  D0 04                        bne @false
001BACr 3               
001BACr 3  A9 FF                        lda #$ff
001BAEr 3  80 02                        bra @done
001BB0r 3               
001BB0r 3  A9 00        @false:         lda #0                  ; drop thru to done
001BB2r 3               
001BB2r 3  95 02        @done:          sta 2,x
001BB4r 3  95 03                        sta 3,x
001BB6r 3               
001BB6r 3  E8                           inx
001BB7r 3  E8                           inx
001BB8r 3               
001BB8r 3  60           z_equal:        rts
001BB9r 3               
001BB9r 3               
001BB9r 3               
001BB9r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
001BB9r 3               ; ## "blank"  auto  ANS string
001BB9r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
001BB9r 3               xt_blank:
001BB9r 3                               ; We don't check for underflow here because
001BB9r 3                               ; we deal with that in FILL
001BB9r 3  CA                           dex
001BBAr 3  CA                           dex
001BBBr 3  A9 20                        lda #AscSP
001BBDr 3  95 00                        sta 0,x
001BBFr 3  74 01                        stz 1,x
001BC1r 3               
001BC1r 3  80 06                        bra xt_fill     ; skip over code for ERASE
001BC3r 3               
001BC3r 3               
001BC3r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
001BC3r 3               ; ## "erase"  auto  ANS core ext
001BC3r 3                       ; """https://forth-standard.org/standard/core/ERASE
001BC3r 3                       ; Note that ERASE works with "address" units
001BC3r 3                       ; (bytes), not cells.
001BC3r 3                       ; """
001BC3r 3               
001BC3r 3               xt_erase:
001BC3r 3                               ; We don't check for underflow here because
001BC3r 3                               ; we deal with that in FILL
001BC3r 3  CA                           dex
001BC4r 3  CA                           dex
001BC5r 3  74 00                        stz 0,x
001BC7r 3  74 01                        stz 1,x
001BC9r 3               
001BC9r 3                               ; fall through to FILL
001BC9r 3               
001BC9r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
001BC9r 3               ; ## "fill"  auto  ANS core
001BC9r 3                       ; """https://forth-standard.org/standard/core/FILL
001BC9r 3                       ; Fill u bytes of memory with char starting at addr. Note that
001BC9r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
001BC9r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
001BC9r 3                       ; happens when we reach the end of the address space
001BC9r 3                       ; """
001BC9r 3               xt_fill:
001BC9r 3  20 rr rr                     jsr underflow_3
001BCCr 3               
001BCCr 3                               ; We use tmp1 to hold the address
001BCCr 3  B5 04                        lda 4,x         ; LSB
001BCEr 3  85 24                        sta tmp1
001BD0r 3  B5 05                        lda 5,x
001BD2r 3  85 25                        sta tmp1+1
001BD4r 3               
001BD4r 3                               ; We use tmp2 to hold the counter
001BD4r 3  B5 02                        lda 2,x
001BD6r 3  85 26                        sta tmp2
001BD8r 3  B5 03                        lda 3,x
001BDAr 3  85 27                        sta tmp2+1
001BDCr 3               
001BDCr 3                               ; We use Y to hold the character
001BDCr 3  B5 00                        lda 0,x
001BDEr 3  A8                           tay
001BDFr 3               @loop:
001BDFr 3                               ; Unfortunately, we also need to make sure that we don't
001BDFr 3                               ; write further than the end of the RAM. So RAM_END must
001BDFr 3                               ; be larger or equal to the current address
001BDFr 3  A9 7F                        lda #>ram_end           ; MSB
001BE1r 3  C5 25                        cmp tmp1+1
001BE3r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
001BE5r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
001BE7r 3               
001BE7r 3  A9 FF                        lda #<ram_end           ; LSB, because MSBs were equal
001BE9r 3  C5 24                        cmp tmp1
001BEBr 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
001BEDr 3               
001BEDr 3               @check_counter:
001BEDr 3                               ; See if our counter has reached zero
001BEDr 3  A5 26                        lda tmp2
001BEFr 3  05 27                        ora tmp2+1
001BF1r 3  F0 13                        beq @done
001BF3r 3               
001BF3r 3                               ; We're not in ROM and we still have stuff on the counter, so
001BF3r 3                               ; let's actually do what we came here to do
001BF3r 3  98                           tya
001BF4r 3  92 24                        sta (tmp1)
001BF6r 3               
001BF6r 3                               ; Adjust the counter
001BF6r 3  A5 26                        lda tmp2
001BF8r 3  D0 02                        bne @1
001BFAr 3  C6 27                        dec tmp2+1
001BFCr 3  C6 26        @1:               dec tmp2
001BFEr 3               
001BFEr 3                               ; Next address
001BFEr 3  E6 24                        inc tmp1
001C00r 3  D0 DD                        bne @loop
001C02r 3  E6 25                        inc tmp1+1
001C04r 3               
001C04r 3  80 D9                        bra @loop
001C06r 3               
001C06r 3               @done:
001C06r 3                               ; Drop three cells off the Data Stack. This uses one byte
001C06r 3                               ; less than six times INX
001C06r 3  8A                           txa
001C07r 3  18                           clc
001C08r 3  69 06                        adc #6
001C0Ar 3  AA                           tax
001C0Br 3               z_blank:
001C0Br 3               z_erase:
001C0Br 3  60           z_fill:         rts
001C0Cr 3               
001C0Cr 3               
001C0Cr 3               
001C0Cr 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
001C0Cr 3               ; ## "execute"  auto  ANS core
001C0Cr 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
001C0Cr 3               xt_execute:
001C0Cr 3  20 rr rr                     jsr underflow_1
001C0Fr 3               
001C0Fr 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
001C12r 3               
001C12r 3  60           z_execute:      rts
001C13r 3               
001C13r 3               doexecute:
001C13r 3  B5 00                        lda 0,x
001C15r 3  85 0E                        sta ip
001C17r 3  B5 01                        lda 1,x
001C19r 3  85 0F                        sta ip+1
001C1Br 3               
001C1Br 3  E8                           inx
001C1Cr 3  E8                           inx
001C1Dr 3               
001C1Dr 3                               ; we don't need a RTS here because we highjack the RTS of
001C1Dr 3                               ; the word we're calling to get back to xt_execute
001C1Dr 3  6C 0E 00                     jmp (ip)
001C20r 3               
001C20r 3               ; end of doexecute
001C20r 3               
001C20r 3               
001C20r 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
001C20r 3               ; ## "execute-parsing"  auto  Gforth
001C20r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
001C20r 3                       ; Execute the parsing word defined by the execution token (xt) on the
001C20r 3                       ; string as if it were passed on the command line. See the file
001C20r 3                       ; tests/tali.fs for examples.
001C20r 3                       ;
001C20r 3                       ; Note that this word is coded completely
001C20r 3                       ; different in its Gforth version, see the file execute-parsing.fs
001C20r 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
001C20r 3                       ; """
001C20r 3               xt_execute_parsing:
001C20r 3  20 rr rr                     jsr underflow_3
001C23r 3               
001C23r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
001C26r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
001C29r 3               
001C29r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
001C2Br 3  85 0A                        sta ciblen
001C2Dr 3  B5 01                        lda 1,x
001C2Fr 3  85 0B                        sta ciblen+1
001C31r 3               
001C31r 3  B5 02                        lda 2,x                 ; NOS is new cib
001C33r 3  85 08                        sta cib
001C35r 3  B5 03                        lda 3,x
001C37r 3  85 09                        sta cib+1
001C39r 3               
001C39r 3  64 0C                        stz toin                ; Set >IN to zero
001C3Br 3  64 0D                        stz toin+1
001C3Dr 3               
001C3Dr 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
001C40r 3  20 rr rr                     jsr xt_execute
001C43r 3               
001C43r 3  20 rr rr                     jsr xt_r_to_input
001C46r 3               
001C46r 3               z_execute_parsing:
001C46r 3  60                           rts
001C47r 3               
001C47r 3               
001C47r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
001C47r 3               ; ## "exit"  auto  ANS core
001C47r 3                       ; """https://forth-standard.org/standard/core/EXIT
001C47r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
001C47r 3                       ; we we might have put on the Return Stack off as well. This should
001C47r 3                       ; be natively compiled.
001C47r 3                       ; """
001C47r 3               
001C47r 3               xt_exit:
001C47r 3  60                           rts             ; keep before z_exit
001C48r 3               z_exit:                         ; never reached
001C48r 3               
001C48r 3               
001C48r 3               
001C48r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
001C48r 3               ; ## "false"  auto  ANS core ext
001C48r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
001C48r 3               xt_false:
001C48r 3  CA                           dex
001C49r 3  CA                           dex
001C4Ar 3  74 00                        stz 0,x
001C4Cr 3  74 01                        stz 1,x
001C4Er 3               
001C4Er 3  60           z_false:        rts
001C4Fr 3               
001C4Fr 3               
001C4Fr 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
001C4Fr 3               ; ## "@"  auto  ANS core
001C4Fr 3                       ; """https://forth-standard.org/standard/core/Fetch"""
001C4Fr 3               xt_fetch:
001C4Fr 3  20 rr rr                     jsr underflow_1
001C52r 3               
001C52r 3  A1 00                        lda (0,x)               ; LSB
001C54r 3  A8                           tay
001C55r 3  F6 00                        inc 0,x
001C57r 3  D0 02                        bne @1
001C59r 3  F6 01                        inc 1,x
001C5Br 3               @1:
001C5Br 3  A1 00                        lda (0,x)               ; MSB
001C5Dr 3  95 01                        sta 1,x
001C5Fr 3  94 00                        sty 0,x
001C61r 3               
001C61r 3  60           z_fetch:        rts
001C62r 3               
001C62r 3               
001C62r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
001C62r 3               ; ## "find"  auto  ANS core
001C62r 3                       ; """https://forth-standard.org/standard/core/FIND
001C62r 3                       ; Included for backwards compatibility only, because it still
001C62r 3                       ; can be found in so may examples. It should, however, be replaced
001C62r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
001C62r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
001C62r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
001C62r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
001C62r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
001C62r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001C62r 3                       ; """
001C62r 3               
001C62r 3               xt_find:
001C62r 3  20 rr rr                     jsr underflow_1
001C65r 3               
001C65r 3                               ; Save address in case conversion fails. We use the
001C65r 3                               ; Return Stack instead of temporary variables like TMP1
001C65r 3                               ; because this is shorter and anybody still using FIND
001C65r 3                               ; can't be worried about speed anyway
001C65r 3  B5 01                        lda 1,x                 ; MSB
001C67r 3  48                           pha
001C68r 3  B5 00                        lda 0,x                 ; LSB
001C6Ar 3  48                           pha
001C6Br 3               
001C6Br 3                               ; Convert ancient-type counted string address to
001C6Br 3                               ; modern format
001C6Br 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
001C6Er 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
001C71r 3               
001C71r 3  B5 00                        lda 0,x
001C73r 3  15 01                        ora 1,x
001C75r 3  D0 0B                        bne @found_word
001C77r 3               
001C77r 3                               ; No word found. Return address of the string and a false
001C77r 3                               ; flag
001C77r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
001C7Ar 3               
001C7Ar 3                               ; The address needs to be restored.
001C7Ar 3  68                           pla                     ; LSB of address
001C7Br 3  95 02                        sta 2,x
001C7Dr 3  68                           pla
001C7Er 3  95 03                        sta 3,x                 ; MSB of address
001C80r 3               
001C80r 3  80 27                        bra @done               ; ( addr 0 )
001C82r 3               
001C82r 3               @found_word:
001C82r 3                               ; We don't need the address after all, dump it
001C82r 3  68                           pla
001C83r 3  68                           pla
001C84r 3               
001C84r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
001C84r 3                               ; convert the return values to FIND's format
001C84r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001C87r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001C8Ar 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001C8Dr 3               
001C8Dr 3  A0 00                        ldy #0                  ; Prepare flag
001C8Fr 3               
001C8Fr 3                               ; The flags are in the second byte of the header
001C8Fr 3  F6 00                        inc 0,x
001C91r 3  D0 02                        bne @1
001C93r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
001C95r 3               @1:
001C95r 3  A1 00                        lda (0,x)               ; ( xt char )
001C97r 3  29 04                        and #IM
001C99r 3  D0 08                        bne @immediate          ; bit set, we're immediate
001C9Br 3               
001C9Br 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001C9Dr 3  95 00                        sta 0,x
001C9Fr 3  95 01                        sta 1,x
001CA1r 3  80 06                        bra @done
001CA3r 3               
001CA3r 3               @immediate:
001CA3r 3  A9 01                        lda #1                  ; We're immediate, return 1
001CA5r 3  95 00                        sta 0,x
001CA7r 3  74 01                        stz 1,x
001CA9r 3               @done:
001CA9r 3  60           z_find:         rts
001CAAr 3               
001CAAr 3               
001CAAr 3               
001CAAr 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
001CAAr 3               ; ## "find-name"  auto  Gforth
001CAAr 3               
001CAAr 3               xt_find_name:
001CAAr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001CAAr 3                       ; Given a string, find the Name Token (nt) of a word or return
001CAAr 3                       ; zero if the word is not in the dictionary. We use this instead of
001CAAr 3                       ; ancient FIND to look up words in the Dictionary passed by
001CAAr 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
001CAAr 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
001CAAr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001CAAr 3                       ; FIND calls this word
001CAAr 3                       ; """
001CAAr 3  20 rr rr                     jsr underflow_2
001CADr 3               
001CADr 3                               ; check for special case of an empty string (length zero)
001CADr 3  B5 00                        lda 0,x
001CAFr 3  15 01                        ora 1,x
001CB1r 3  D0 03                        bne @nonempty
001CB3r 3               
001CB3r 3  4C rr rr                     jmp @fail_done
001CB6r 3               
001CB6r 3               @nonempty:
001CB6r 3                               ; Set up for traversing the wordlist search order.
001CB6r 3  64 28                        stz tmp3                ; Start at the beginning
001CB8r 3               
001CB8r 3               @wordlist_loop:
001CB8r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
001CBAr 3  A5 28                        lda tmp3
001CBCr 3  D1 1E                        cmp (up),y              ; Check to see if we are done
001CBEr 3  D0 03                        bne @have_string
001CC0r 3               
001CC0r 3                               ; We ran out of wordlists to search.
001CC0r 3  4C rr rr                     jmp @fail_done
001CC3r 3               
001CC3r 3               @have_string:
001CC3r 3                               ; set up first loop iteration
001CC3r 3               
001CC3r 3                               ; Get the current wordlist id
001CC3r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
001CC4r 3  69 1F                        adc #search_order_offset
001CC6r 3  A8                           tay
001CC7r 3  B1 1E                        lda (up),y      ; Get the id byte, which is the offset
001CC9r 3                                               ; into the cell array WORDLISTS
001CC9r 3               
001CC9r 3                               ; Get the DP for that wordlist.
001CC9r 3  0A                           asl                     ; Turn offset into cells offset.
001CCAr 3  18                           clc
001CCBr 3  69 06                        adc #wordlists_offset
001CCDr 3  A8                           tay
001CCEr 3  B1 1E                        lda (up),y
001CD0r 3  85 24                        sta tmp1
001CD2r 3  C8                           iny
001CD3r 3  B1 1E                        lda (up),y
001CD5r 3  85 25                        sta tmp1+1
001CD7r 3               
001CD7r 3  B5 02                        lda 2,x                 ; Address of mystery string
001CD9r 3  85 26                        sta tmp2
001CDBr 3  B5 03                        lda 3,x
001CDDr 3  85 27                        sta tmp2+1
001CDFr 3               
001CDFr 3               @loop:
001CDFr 3                               ; first quick test: Are strings the same length?
001CDFr 3  B2 24                        lda (tmp1)
001CE1r 3  D5 00                        cmp 0,x
001CE3r 3  D0 54                        bne @next_entry
001CE5r 3               
001CE5r 3               @compare_string:
001CE5r 3                               ; are the same length, so we now have to compare each
001CE5r 3                               ; character
001CE5r 3               
001CE5r 3                               ; second quick test: Is the first character the same?
001CE5r 3  B2 26                        lda (tmp2)      ; first character of mystery string
001CE7r 3               
001CE7r 3                               ; Lowercase the incoming charcter.
001CE7r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001CE9r 3  B0 07                        bcs @compare_first
001CEBr 3  C9 41                        cmp #$41        ; ASCII 'A'
001CEDr 3  90 03                        bcc @compare_first
001CEFr 3               
001CEFr 3                               ; An uppercase letter has been located.  Make it
001CEFr 3                               ; lowercase.
001CEFr 3  18                           clc
001CF0r 3  69 20                        adc #$20
001CF2r 3               
001CF2r 3               @compare_first:
001CF2r 3  A0 08                        ldy #8          ; Offset in nt to name
001CF4r 3  D1 24                        cmp (tmp1),y    ; first character of current word
001CF6r 3  D0 41                        bne @next_entry
001CF8r 3               
001CF8r 3                               ; String length is the same and the first character is the
001CF8r 3                               ; same. If the length of the string is 1, we're already done
001CF8r 3  B5 00                        lda 0,x
001CFAr 3  3A                           dec
001CFBr 3  F0 2C                        beq @success
001CFDr 3               
001CFDr 3                               ; No such luck: The strings are the same length and the first
001CFDr 3                               ; char is the same, but the word is more than one char long.
001CFDr 3                               ; So we suck it up and compare every single character. We go
001CFDr 3                               ; from back to front, because words like CELLS and CELL+ would
001CFDr 3                               ; take longer otherwise. We can also shorten the loop by one
001CFDr 3                               ; because we've already compared the first char.
001CFDr 3               
001CFDr 3                               ; The string of the word we're testing against is 8 bytes down
001CFDr 3  A5 24                        lda tmp1
001CFFr 3  48                           pha             ; Preserve tmp1 on the return stack.
001D00r 3  18                           clc
001D01r 3  69 08                        adc #8
001D03r 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001D05r 3  A5 25                        lda tmp1+1
001D07r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001D08r 3  69 00                        adc #0          ; we only need the carry
001D0Ar 3  85 25                        sta tmp1+1
001D0Cr 3               
001D0Cr 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001D0Er 3  88                           dey
001D0Fr 3               
001D0Fr 3               @string_loop:
001D0Fr 3  B1 26                        lda (tmp2),y    ; last char of mystery string
001D11r 3               
001D11r 3                               ; Lowercase the incoming charcter.
001D11r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001D13r 3  B0 07                        bcs @check_char
001D15r 3  C9 41                        cmp #$41        ; ASCII 'A'
001D17r 3  90 03                        bcc @check_char
001D19r 3               
001D19r 3                               ; An uppercase letter has been located.  Make it
001D19r 3                               ; lowercase.
001D19r 3  18                           clc
001D1Ar 3  69 20                        adc #$20
001D1Cr 3               
001D1Cr 3               @check_char:
001D1Cr 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
001D1Er 3  D0 13                        bne @next_entry_tmp1
001D20r 3               
001D20r 3  88                           dey
001D21r 3  D0 EC                        bne @string_loop
001D23r 3               
001D23r 3               @success_tmp1:
001D23r 3  68                           pla             ; Restore tmp1 from the return stack.
001D24r 3  85 25                        sta tmp1+1
001D26r 3  68                           pla
001D27r 3  85 24                        sta tmp1
001D29r 3               
001D29r 3               @success:
001D29r 3                               ; The strings match. Put correct nt NOS, because we'll drop
001D29r 3                               ; TOS before we leave
001D29r 3  A5 24                        lda tmp1
001D2Br 3  95 02                        sta 2,x
001D2Dr 3  A5 25                        lda tmp1+1
001D2Fr 3  95 03                        sta 3,x
001D31r 3               
001D31r 3  80 20                        bra @done
001D33r 3               
001D33r 3               @next_entry_tmp1:
001D33r 3  68                           pla             ; Restore tmp1 from the return stack.
001D34r 3  85 25                        sta tmp1+1
001D36r 3  68                           pla
001D37r 3  85 24                        sta tmp1
001D39r 3               
001D39r 3               @next_entry:
001D39r 3                               ; Not the same, so we get the next word. Next header
001D39r 3                               ; address is two bytes down
001D39r 3  A0 02                        ldy #2
001D3Br 3  B1 24                        lda (tmp1),y
001D3Dr 3  48                           pha
001D3Er 3  C8                           iny
001D3Fr 3  B1 24                        lda (tmp1),y
001D41r 3  85 25                        sta tmp1+1
001D43r 3  68                           pla
001D44r 3  85 24                        sta tmp1
001D46r 3               
001D46r 3                               ; If we got a zero, we've walked the whole Dictionary and
001D46r 3                               ; return as a failure, otherwise try again
001D46r 3  05 25                        ora tmp1+1
001D48r 3  D0 95                        bne @loop
001D4Ar 3               
001D4Ar 3                               ; Move on to the next wordlist in the search order.
001D4Ar 3  E6 28                        inc tmp3
001D4Cr 3  4C rr rr                     jmp @wordlist_loop
001D4Fr 3               
001D4Fr 3               @fail_done:
001D4Fr 3  74 02                        stz 2,x         ; failure flag
001D51r 3  74 03                        stz 3,x
001D53r 3               @done:
001D53r 3  E8                           inx
001D54r 3  E8                           inx
001D55r 3               
001D55r 3  60           z_find_name:    rts
001D56r 3               
001D56r 3               
001D56r 3               
001D56r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001D56r 3               ; ## "flush"  auto  ANS block
001D56r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001D56r 3               xt_flush:
001D56r 3  20 rr rr                     jsr xt_save_buffers
001D59r 3               
001D59r 3                               ; Set the buffer status to empty.
001D59r 3  A0 2C                        ldy #buffstatus_offset
001D5Br 3  A9 00                        lda #0
001D5Dr 3  91 1E                        sta (up),y      ; Only LSB is used.
001D5Fr 3               z_flush:
001D5Fr 3  60                           rts
001D60r 3               
001D60r 3               
001D60r 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001D60r 3               ; ## "fm/mod"  auto  ANS core
001D60r 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001D60r 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001D60r 3                       ;
001D60r 3                       ; There are various ways to realize this. We follow EForth with
001D60r 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001D60r 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001D60r 3                       ; See (http://www.forth.org/eforth.html). However you can also
001D60r 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001D60r 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001D60r 3                       ; """
001D60r 3               
001D60r 3               xt_fm_slash_mod:
001D60r 3  20 rr rr                     jsr underflow_3
001D63r 3               
001D63r 3                               ; if sign of n1 is negative, negate both n1 and d
001D63r 3  64 26                        stz tmp2        ; default: n is positive
001D65r 3  B5 01                        lda 1,x         ; MSB of n1
001D67r 3  10 0E                        bpl @check_d
001D69r 3               
001D69r 3  E6 26                        inc tmp2        ; set flag to negative for n1
001D6Br 3  20 rr rr                     jsr xt_negate   ; NEGATE
001D6Er 3  20 rr rr                     jsr xt_to_r     ; >R
001D71r 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001D74r 3  20 rr rr                     jsr xt_r_from   ; R>
001D77r 3               
001D77r 3               @check_d:
001D77r 3                               ; If d is negative, add n1 to high cell of d
001D77r 3  B5 03                        lda 3,x         ; MSB of high word of d
001D79r 3  10 0D                        bpl @multiply
001D7Br 3               
001D7Br 3  18                           clc
001D7Cr 3  B5 00                        lda 0,x         ; LSB of n1
001D7Er 3  75 02                        adc 2,x         ; LSB of dh
001D80r 3  95 02                        sta 2,x
001D82r 3               
001D82r 3  B5 01                        lda 1,x         ; MSB of n1
001D84r 3  75 03                        adc 3,x         ; MSB of dh
001D86r 3  95 03                        sta 3,x
001D88r 3               
001D88r 3               @multiply:
001D88r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
001D8Br 3               
001D8Br 3                               ; if n was negative, negate the result
001D8Br 3  A5 26                        lda tmp2
001D8Dr 3  F0 07                        beq @done
001D8Fr 3               
001D8Fr 3  E8                           inx             ; pretend that we SWAP
001D90r 3  E8                           inx
001D91r 3  20 rr rr                     jsr xt_negate
001D94r 3  CA                           dex
001D95r 3  CA                           dex
001D96r 3               @done:
001D96r 3  60           z_fm_slash_mod: rts
001D97r 3               
001D97r 3               
001D97r 3               
001D97r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
001D97r 3               ; ## "forth"  auto  ANS search ext
001D97r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
001D97r 3               xt_forth:
001D97r 3  A0 1F                        ldy #search_order_offset
001D99r 3  A9 00                        lda #0          ; The WID for Forth is 0.
001D9Br 3               
001D9Br 3  91 1E                        sta (up),y
001D9Dr 3               z_forth:
001D9Dr 3  60                           rts
001D9Er 3               
001D9Er 3               
001D9Er 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
001D9Er 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
001D9Er 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
001D9Er 3               load_evaluate:
001D9Er 3                               ; Set a flag (using tmp1) to not zero BLK
001D9Er 3  A9 FF                        lda #$FF
001DA0r 3  85 24                        sta tmp1
001DA2r 3  80 11                        bra load_evaluate_start
001DA4r 3               
001DA4r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
001DA4r 3               ; ## "evaluate"  auto  ANS core
001DA4r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
001DA4r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
001DA4r 3                       ; After processing the line, revert to old input source. We use this
001DA4r 3                       ; to compile high-level Forth words and user-defined words during
001DA4r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
001DA4r 3                       ; accept more than 255 characters here, even though it's a pain in
001DA4r 3                       ; the 8-bit.
001DA4r 3                       ; """
001DA4r 3               
001DA4r 3               xt_evaluate:
001DA4r 3  20 rr rr                     jsr underflow_2
001DA7r 3               
001DA7r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
001DA7r 3                               ; and will set the block number.
001DA7r 3  64 24                        stz tmp1
001DA9r 3               
001DA9r 3                               ; If u is zero (which can happen a lot for the user-defined
001DA9r 3                               ; words), just leave again
001DA9r 3  B5 00                        lda 0,x
001DABr 3  15 01                        ora 1,x
001DADr 3  D0 06                        bne _eval_got_work
001DAFr 3               
001DAFr 3  E8                           inx
001DB0r 3  E8                           inx
001DB1r 3  E8                           inx
001DB2r 3  E8                           inx
001DB3r 3               
001DB3r 3  80 42                        bra _eval_done
001DB5r 3               
001DB5r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
001DB5r 3               load_evaluate_start:
001DB5r 3               _eval_got_work:
001DB5r 3                               ; Save the current value of BLK on the return stack.
001DB5r 3  A0 01                        ldy #blk_offset+1
001DB7r 3  B1 1E                        lda (up),y
001DB9r 3  48                           pha
001DBAr 3  88                           dey
001DBBr 3  B1 1E                        lda (up),y
001DBDr 3  48                           pha
001DBEr 3               
001DBEr 3                               ; See if we should zero BLK.
001DBEr 3  A5 24                        lda tmp1
001DC0r 3  D0 05                        bne @nozero
001DC2r 3               
001DC2r 3                               ; Set BLK to zero.
001DC2r 3                               ; lda #0        ; A is already zero from loading tmp1
001DC2r 3  91 1E                        sta (up),y
001DC4r 3  C8                           iny
001DC5r 3  91 1E                        sta (up),y
001DC7r 3               
001DC7r 3               @nozero:
001DC7r 3                               ; Save the input state to the Return Stack
001DC7r 3  20 rr rr                     jsr xt_input_to_r
001DCAr 3               
001DCAr 3                               ; set SOURCE-ID to -1
001DCAr 3  A9 FF                        lda #$ff
001DCCr 3  85 06                        sta insrc
001DCEr 3  85 07                        sta insrc+1
001DD0r 3               
001DD0r 3                               ; set >IN to zero
001DD0r 3  64 0C                        stz toin
001DD2r 3  64 0D                        stz toin+1
001DD4r 3               
001DD4r 3                               ; move TOS and NOS to input buffers
001DD4r 3  B5 00                        lda 0,x
001DD6r 3  85 0A                        sta ciblen
001DD8r 3  B5 01                        lda 1,x
001DDAr 3  85 0B                        sta ciblen+1
001DDCr 3               
001DDCr 3  B5 02                        lda 2,x
001DDEr 3  85 08                        sta cib
001DE0r 3  B5 03                        lda 3,x
001DE2r 3  85 09                        sta cib+1
001DE4r 3               
001DE4r 3  E8                           inx             ; A clean stack is a clean mind
001DE5r 3  E8                           inx
001DE6r 3  E8                           inx
001DE7r 3  E8                           inx
001DE8r 3               
001DE8r 3  20 rr rr                     jsr interpret   ; ( -- )
001DEBr 3               
001DEBr 3                               ; restore variables
001DEBr 3  20 rr rr                     jsr xt_r_to_input
001DEEr 3               
001DEEr 3                               ; Restore BLK from the return stack.
001DEEr 3  A0 00                        ldy #blk_offset
001DF0r 3  68                           pla
001DF1r 3  91 1E                        sta (up),y
001DF3r 3  C8                           iny
001DF4r 3  68                           pla
001DF5r 3  91 1E                        sta (up),y
001DF7r 3               
001DF7r 3               _eval_done:
001DF7r 3  60           z_evaluate:     rts
001DF8r 3               
001DF8r 3               
001DF8r 3               
001DF8r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001DF8r 3               ; ## "forth-wordlist"  auto  ANS search
001DF8r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001DF8r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001DF8r 3               
001DF8r 3               
001DF8r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001DF8r 3               ; ## "get-current" auto ANS search
001DF8r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001DF8r 3               
001DF8r 3               xt_get_current:
001DF8r 3                               ; This is a little different than some of the variables
001DF8r 3                               ; in the user area as we want the value rather than
001DF8r 3                               ; the address.
001DF8r 3  CA                           dex
001DF9r 3  CA                           dex
001DFAr 3  A0 04                        ldy #current_offset
001DFCr 3  B1 1E                        lda (up),y
001DFEr 3  95 00                        sta 0,x         ; CURRENT is a byte variable
001E00r 3  74 01                        stz 1,x         ; so the MSB is zero.
001E02r 3               
001E02r 3  60           z_get_current:  rts
001E03r 3               
001E03r 3               
001E03r 3               
001E03r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001E03r 3               ; ## "get-order" auto ANS search
001E03r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001E03r 3               
001E03r 3               xt_get_order:
001E03r 3                               ; Get #ORDER - the number of wordlists in the search order.
001E03r 3  A0 1E                        ldy #num_order_offset
001E05r 3  B1 1E                        lda (up),y
001E07r 3  85 24                        sta tmp1
001E09r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
001E0Br 3               
001E0Br 3               @loop:
001E0Br 3                               ; Count down towards the front of the list.
001E0Br 3                               ; By decrementing first, we also turn the length into an offset.
001E0Br 3  C6 24                        dec tmp1        ; Count down by bytes.
001E0Dr 3               
001E0Dr 3                               ; Get a pointer to the current wordlist, working back to front.
001E0Dr 3  A9 1F                        lda #search_order_offset
001E0Fr 3  18                           clc
001E10r 3  65 24                        adc tmp1
001E12r 3  A8                           tay
001E13r 3               
001E13r 3                               ; Put that wordlist id on the stack.
001E13r 3  CA                           dex
001E14r 3  CA                           dex
001E15r 3  B1 1E                        lda (up),y
001E17r 3  95 00                        sta 0,x         ; Search order array is bytes, so
001E19r 3  74 01                        stz 1,x         ; put a zero in the high byte.
001E1Br 3               
001E1Br 3                               ; See if that was the last one to process (first in the list).
001E1Br 3  A9 00                        lda #0
001E1Dr 3  C5 24                        cmp tmp1
001E1Fr 3  D0 EA                        bne @loop
001E21r 3               
001E21r 3               @done:
001E21r 3                               ; Put the number of items on the stack.
001E21r 3  CA                           dex
001E22r 3  CA                           dex
001E23r 3  A0 1E                        ldy #num_order_offset
001E25r 3  B1 1E                        lda (up),y
001E27r 3  95 00                        sta 0,x
001E29r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
001E2Br 3               
001E2Br 3  60           z_get_order:    rts
001E2Cr 3               
001E2Cr 3               
001E2Cr 3               
001E2Cr 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
001E2Cr 3               ; ## ">"  auto  ANS core
001E2Cr 3                       ; """https://forth-standard.org/standard/core/more"""
001E2Cr 3               
001E2Cr 3               xt_greater_than:
001E2Cr 3  20 rr rr                     jsr underflow_2
001E2Fr 3               
001E2Fr 3  A0 00                        ldy #0          ; default false
001E31r 3  20 rr rr                     jsr compare_16bit
001E34r 3               
001E34r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001E34r 3  F0 03                        beq @false
001E36r 3  10 01                        bpl @false
001E38r 3               
001E38r 3                               ; true
001E38r 3  88                           dey
001E39r 3               @false:
001E39r 3  98                           tya
001E3Ar 3               
001E3Ar 3  E8                           inx
001E3Br 3  E8                           inx
001E3Cr 3  95 00                        sta 0,x
001E3Er 3  95 01                        sta 1,x
001E40r 3               
001E40r 3  60           z_greater_than: rts
001E41r 3               
001E41r 3               
001E41r 3               
001E41r 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
001E41r 3               ; ## "here"  auto  ANS core
001E41r 3                       ; """https://forth-standard.org/standard/core/HERE
001E41r 3                       ; This code is also used by the assembler directive ARROW
001E41r 3                       ; ("->") though as immediate"""
001E41r 3               xt_here:
001E41r 3               xt_asm_arrow:
001E41r 3  CA                           dex
001E42r 3  CA                           dex
001E43r 3  A5 00                        lda cp
001E45r 3  95 00                        sta 0,x
001E47r 3  A5 01                        lda cp+1
001E49r 3  95 01                        sta 1,x
001E4Br 3               
001E4Br 3               z_asm_arrow:
001E4Br 3  60           z_here:         rts
001E4Cr 3               
001E4Cr 3               
001E4Cr 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
001E4Cr 3               ; ## "hex"  auto  ANS core ext
001E4Cr 3                       ; """https://forth-standard.org/standard/core/HEX"""
001E4Cr 3               xt_hex:
001E4Cr 3  A9 10                        lda #16
001E4Er 3  85 18                        sta base
001E50r 3  64 19                        stz base+1              ; paranoid
001E52r 3               
001E52r 3  60           z_hex:          rts
001E53r 3               
001E53r 3               
001E53r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001E53r 3               ; ## "hexstore"  auto  Tali
001E53r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001E53r 3                       ; by spaces, store the numbers at the address addr2, returning the
001E53r 3                       ; number of elements. Non-number elements are skipped, an zero-length
001E53r 3                       ; string produces a zero output.
001E53r 3                       ; """
001E53r 3               
001E53r 3               xt_hexstore:
001E53r 3  20 rr rr                     jsr underflow_3
001E56r 3               
001E56r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
001E59r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
001E5Cr 3               
001E5Cr 3               @loop:
001E5Cr 3                               ; Loop until string is totally consumed
001E5Cr 3  B5 00                        lda 0,x
001E5Er 3  15 01                        ora 1,x
001E60r 3  F0 36                        beq @done
001E62r 3               
001E62r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001E65r 3               
001E65r 3                               ; Prepare the conversion of the number.
001E65r 3  20 rr rr                     jsr xt_two_to_r
001E68r 3  20 rr rr                     jsr xt_zero
001E6Br 3  20 rr rr                     jsr xt_zero
001E6Er 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001E71r 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001E74r 3               
001E74r 3                               ; If u4 is not zero, we have leftover chars and have to do
001E74r 3                               ; things differently
001E74r 3  B5 00                        lda 0,x
001E76r 3  15 01                        ora 1,x
001E78r 3  D0 17                        bne @have_chars_left
001E7Ar 3               
001E7Ar 3                               ; Normal case, this number is all done
001E7Ar 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001E7Dr 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001E80r 3               
001E80r 3                               ; Store the new value
001E80r 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
001E83r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
001E86r 3               
001E86r 3                               ; Increase counter
001E86r 3  20 rr rr                     jsr xt_r_from           ; R>
001E89r 3  20 rr rr                     jsr xt_one_plus         ; 1+
001E8Cr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001E8Fr 3  80 CB                        bra @loop
001E91r 3               
001E91r 3               @have_chars_left:
001E91r 3                               ; Pathological case: Drop the rest of this number off the stack
001E91r 3                               ; and continue with the next word. Doesn't print a warning. We
001E91r 3                               ; need to drop four cells, that is, eight bytes
001E91r 3  8A                           txa
001E92r 3  18                           clc
001E93r 3  69 08                        adc #8
001E95r 3  AA                           tax
001E96r 3  80 C4                        bra @loop
001E98r 3               
001E98r 3               @done:
001E98r 3                               ; Clean up return stack and calculate number of chars stored
001E98r 3  E8                           inx
001E99r 3  E8                           inx
001E9Ar 3  E8                           inx
001E9Br 3  E8                           inx                     ; 2DROP
001E9Cr 3               
001E9Cr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001E9Fr 3  20 rr rr                     jsr xt_swap
001EA2r 3  20 rr rr                     jsr xt_minus            ; ( n )
001EA5r 3               
001EA5r 3  60           z_hexstore:     rts
001EA6r 3               
001EA6r 3               
001EA6r 3               
001EA6r 3               ; ## HOLD ( char -- ) "Insert character at current output"
001EA6r 3               ; ## "hold"  auto  ANS core
001EA6r 3                       ; """https://forth-standard.org/standard/core/HOLD
001EA6r 3                       ; Insert a character at the current position of a pictured numeric
001EA6r 3                       ; output string on
001EA6r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001EA6r 3                       ;
001EA6r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
001EA6r 3                       ; variable tohold instead of HLD.
001EA6r 3                       ; """
001EA6r 3               xt_hold:
001EA6r 3  20 rr rr                     jsr underflow_1
001EA9r 3               
001EA9r 3  A5 34                        lda tohold
001EABr 3  D0 02                        bne @1
001EADr 3  C6 35                        dec tohold+1
001EAFr 3               @1:
001EAFr 3  C6 34                        dec tohold
001EB1r 3               
001EB1r 3  B5 00                        lda 0,x
001EB3r 3  92 34                        sta (tohold)
001EB5r 3  E8                           inx
001EB6r 3  E8                           inx
001EB7r 3               
001EB7r 3  60           z_hold:         rts
001EB8r 3               
001EB8r 3               
001EB8r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
001EB8r 3               ; ## "i"  auto  ANS core
001EB8r 3                       ; """https://forth-standard.org/standard/core/I
001EB8r 3                       ; Note that this is not the same as R@ because we use a fudge
001EB8r 3                       ; factor for loop control; see the Control Flow section of the
001EB8r 3                       ; manual for details.
001EB8r 3                       ;
001EB8r 3                       ; We should make this native compile for speed.
001EB8r 3                       ; """
001EB8r 3               
001EB8r 3               xt_i:
001EB8r 3  CA                           dex
001EB9r 3  CA                           dex
001EBAr 3               
001EBAr 3                               ; Get the fudged index off of the top of the stack. It's
001EBAr 3                               ; easier to do math on the stack directly than to pop and
001EBAr 3                               ; push stuff around
001EBAr 3  86 2A                        stx tmpdsp
001EBCr 3  BA                           tsx
001EBDr 3               
001EBDr 3  38                           sec
001EBEr 3  BD 01 01                     lda $0101,x     ; LSB
001EC1r 3  FD 03 01                     sbc $0103,x
001EC4r 3  A8                           tay
001EC5r 3               
001EC5r 3  BD 02 01                     lda $0102,x     ; MSB
001EC8r 3  FD 04 01                     sbc $0104,x
001ECBr 3               
001ECBr 3  A6 2A                        ldx tmpdsp
001ECDr 3               
001ECDr 3  95 01                        sta 1,x         ; MSB of de-fudged index
001ECFr 3  94 00                        sty 0,x         ; LSB of de-fudged index
001ED1r 3               
001ED1r 3  60           z_i:            rts
001ED2r 3               
001ED2r 3               
001ED2r 3               
001ED2r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001ED2r 3               ; ## "if"  auto  ANS core
001ED2r 3                       ; """http://forth-standard.org/standard/core/IF"""
001ED2r 3               
001ED2r 3               xt_if:
001ED2r 3                               ; Compile a 0BRANCH
001ED2r 3  A0 rr                        ldy #>zero_branch_runtime
001ED4r 3  A9 rr                        lda #<zero_branch_runtime
001ED6r 3  20 rr rr                     jsr cmpl_subroutine
001ED9r 3               
001ED9r 3                               ; Put the origination address on the stack for else/then
001ED9r 3  20 rr rr                     jsr xt_here
001EDCr 3               
001EDCr 3                               ; Stuff zero in for the branch address right now.
001EDCr 3                               ; THEN or ELSE will fix it later.
001EDCr 3  20 rr rr                     jsr xt_zero
001EDFr 3  20 rr rr                     jsr xt_comma
001EE2r 3  60           z_if:           rts
001EE3r 3               
001EE3r 3               
001EE3r 3               zero_branch_runtime:
001EE3r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001EE3r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001EE3r 3                       ; runtime.
001EE3r 3                       ; """
001EE3r 3               
001EE3r 3                               ; We use the return value on the 65c02 stack to determine
001EE3r 3                               ; where we want to return to.
001EE3r 3  68                           pla
001EE4r 3  85 22                        sta tmpbranch
001EE6r 3  68                           pla
001EE7r 3  85 23                        sta tmpbranch+1
001EE9r 3               
001EE9r 3                               ; See if the flag is zero, which is the whole purpose of
001EE9r 3                               ; this all
001EE9r 3  B5 00                        lda 0,x
001EEBr 3  15 01                        ora 1,x
001EEDr 3  F0 0F                        beq @zero
001EEFr 3               
001EEFr 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001EEFr 3                               ; the part between IF and THEN
001EEFr 3  A5 22                        lda tmpbranch   ; LSB
001EF1r 3  18                           clc
001EF2r 3  69 02                        adc #2
001EF4r 3  85 24                        sta tmp1
001EF6r 3  A5 23                        lda tmpbranch+1 ; MSB
001EF8r 3  69 00                        adc #0          ; For carry
001EFAr 3  85 25                        sta tmp1+1
001EFCr 3               
001EFCr 3  80 13                        bra @done
001EFEr 3               
001EFEr 3               @zero:
001EFEr 3                               ; Flag is FALSE (0) so we take the jump to the address given in
001EFEr 3                               ; the next two bytes. However, the address points to the last
001EFEr 3                               ; byte of the JSR instruction, not to the next byte afterwards
001EFEr 3  A0 01                        ldy #1
001F00r 3  B1 22                        lda (tmpbranch),y
001F02r 3  85 24                        sta tmp1
001F04r 3  C8                           iny
001F05r 3  B1 22                        lda (tmpbranch),y
001F07r 3  85 25                        sta tmp1+1
001F09r 3               
001F09r 3                               ; Now we have to subtract one byte from the address
001F09r 3                               ; given because of the way the 6502 calculates RTS
001F09r 3  A5 24                        lda tmp1
001F0Br 3  D0 02                        bne @1
001F0Dr 3  C6 25                        dec tmp1+1
001F0Fr 3               @1:
001F0Fr 3  C6 24                        dec tmp1
001F11r 3               
001F11r 3               @done:
001F11r 3                               ; However we got here, tmp1 has the value we push to jump
001F11r 3                               ; to
001F11r 3  A5 25                        lda tmp1+1
001F13r 3  48                           pha             ; MSB first
001F14r 3  A5 24                        lda tmp1
001F16r 3  48                           pha
001F17r 3               
001F17r 3                               ; clean up the stack and jump
001F17r 3  E8                           inx
001F18r 3  E8                           inx
001F19r 3               
001F19r 3  60                           rts
001F1Ar 3               
001F1Ar 3               
001F1Ar 3               
001F1Ar 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
001F1Ar 3               ; ## "immediate"  auto  ANS core
001F1Ar 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
001F1Ar 3                       ; Make sure the most recently defined word is immediate. Will only
001F1Ar 3                       ; affect the last word in the dictionary. Note that if the word is
001F1Ar 3                       ; defined in ROM, this will have no affect, but will not produce an
001F1Ar 3                       ; error message.
001F1Ar 3                       ; """
001F1Ar 3               xt_immediate:
001F1Ar 3  20 rr rr                     jsr current_to_dp
001F1Dr 3  A0 01                        ldy #1          ; offset for status byte
001F1Fr 3  B1 02                        lda (dp),y
001F21r 3  09 04                        ora #IM        ; make sure bit 7 is set
001F23r 3  91 02                        sta (dp),y
001F25r 3               
001F25r 3  60           z_immediate:    rts
001F26r 3               
001F26r 3               
001F26r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001F26r 3               ; ## "input" tested Tali Forth
001F26r 3               
001F26r 3               xt_input:
001F26r 3  CA                           dex
001F27r 3  CA                           dex
001F28r 3  A9 12                        lda #<input
001F2Ar 3  95 00                        sta 0,x
001F2Cr 3  A9 00                        lda #>input
001F2Er 3  95 01                        sta 1,x
001F30r 3               
001F30r 3  60           z_input:        rts
001F31r 3               
001F31r 3               
001F31r 3               
001F31r 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
001F31r 3               ; ## "input>r"  tested  Tali Forth
001F31r 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
001F31r 3                       ; toin to the Return Stack. Used by EVALUTE.
001F31r 3                       ;
001F31r 3                       ; The naive way of doing
001F31r 3                       ; this is to push each two-byte variable to the stack in the form of
001F31r 3                       ;
001F31r 3                       ;       lda insrc
001F31r 3                       ;       pha
001F31r 3                       ;       lda insrc+1
001F31r 3                       ;       pha
001F31r 3                       ;
001F31r 3                       ; for a total of 24 byte of instruction in one direction and later
001F31r 3                       ; a further 24 bytes to reverse the process. We shorten this at the
001F31r 3                       ; cost of some speed by assuming the four variables are grouped
001F31r 3                       ; together on the Zero Page and start with insrc (see definitions.asm
001F31r 3                       ; for details). The reverse operation is r_to_input. These words must
001F31r 3                       ; be flagged as Never Native. Uses tmp1
001F31r 3                       ; """
001F31r 3               
001F31r 3               xt_input_to_r:
001F31r 3                               ; We arrive here with the return address on the top of the
001F31r 3                               ; 65c02's stack. We need to move it out of the way first
001F31r 3  68                           pla
001F32r 3  85 24                        sta tmp1
001F34r 3  68                           pla
001F35r 3  85 25                        sta tmp1+1
001F37r 3               
001F37r 3                               ; This assumes that insrc is the first of eight bytes and
001F37r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001F37r 3                               ; Page.
001F37r 3  A0 07                        ldy #7
001F39r 3               @loop:
001F39r 3  B9 06 00                     lda insrc,y     ; insrc+7 is toin+1
001F3Cr 3  48                           pha
001F3Dr 3  88                           dey
001F3Er 3  10 F9                        bpl @loop
001F40r 3               
001F40r 3                               ; Restore address for return jump
001F40r 3  A5 25                        lda tmp1+1
001F42r 3  48                           pha
001F43r 3  A5 24                        lda tmp1
001F45r 3  48                           pha
001F46r 3               
001F46r 3  60           z_input_to_r: 	rts
001F47r 3               
001F47r 3               
001F47r 3               
001F47r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001F47r 3               ; ## "int>name"  auto  Tali Forth
001F47r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001F47r 3                       ; This is called >NAME in Gforth, but we change it to
001F47r 3                       ; INT>NAME to match NAME>INT
001F47r 3                       ; """
001F47r 3               
001F47r 3               xt_int_to_name:
001F47r 3  20 rr rr                     jsr underflow_1
001F4Ar 3               
001F4Ar 3                               ; Unfortunately, to find the header, we have to walk through
001F4Ar 3                               ; all of the wordlists. We are running out of tmp variables.
001F4Ar 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
001F4Ar 3                               ; hold the current wordlist on the data stack. This searches
001F4Ar 3                               ; all of the wordlists in id order.
001F4Ar 3  CA                           dex
001F4Br 3  CA                           dex
001F4Cr 3  74 00                        stz 0,x
001F4Er 3  74 01                        stz 1,x
001F50r 3               
001F50r 3               @wordlist_loop:
001F50r 3                               ; A needs to have the current wordlist id in it at
001F50r 3                               ; the top of this loop.
001F50r 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001F52r 3               
001F52r 3                               ; Get the DP for that wordlist.
001F52r 3  0A                           asl                     ; Turn offset into cells offset.
001F53r 3  18                           clc
001F54r 3  69 06                        adc #wordlists_offset
001F56r 3  A8                           tay
001F57r 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
001F59r 3  85 26                        sta tmp2                ; into tmp2
001F5Br 3  C8                           iny
001F5Cr 3  B1 1E                        lda (up),y
001F5Er 3  85 27                        sta tmp2+1
001F60r 3               
001F60r 3                               ; Check for an empty wordlist (DP will be 0)
001F60r 3  A5 26                        lda tmp2
001F62r 3  05 27                        ora tmp2+1
001F64r 3  F0 38                        beq @next_wordlist
001F66r 3               
001F66r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001F68r 3  85 28                        sta tmp3        ; Save target xt in tmp3
001F6Ar 3  B5 03                        lda 3,x
001F6Cr 3  85 29                        sta tmp3+1
001F6Er 3               
001F6Er 3               @loop:
001F6Er 3  A0 04                        ldy #4          ; xt is four bytes down
001F70r 3  B1 26                        lda (tmp2),y    ; LSB of xt of current nt
001F72r 3  C5 28                        cmp tmp3
001F74r 3  D0 07                        bne @no_match
001F76r 3               
001F76r 3                               ; LSB is the same, now check MSB
001F76r 3  C8                           iny
001F77r 3  B1 26                        lda (tmp2),y    ; MSB of xt of current nt
001F79r 3  C5 29                        cmp tmp3+1
001F7Br 3  F0 32                        beq @match
001F7Dr 3               
001F7Dr 3               @no_match:
001F7Dr 3                               ; no match, so we need to get the next word. Next nt is two
001F7Dr 3                               ; bytes down
001F7Dr 3  18                           clc
001F7Er 3  A5 26                        lda tmp2
001F80r 3  69 02                        adc #2
001F82r 3  85 26                        sta tmp2
001F84r 3  A5 27                        lda tmp2+1
001F86r 3  69 00                        adc #0          ; only care about carry
001F88r 3  85 27                        sta tmp2+1
001F8Ar 3               
001F8Ar 3  A0 00                        ldy #0
001F8Cr 3  B1 26                        lda (tmp2),y
001F8Er 3  48                           pha
001F8Fr 3  C8                           iny
001F90r 3  11 26                        ora (tmp2),y
001F92r 3  F0 09                        beq @zero
001F94r 3               
001F94r 3                               ; Not zero continue
001F94r 3  B1 26                        lda (tmp2),y
001F96r 3  85 27                        sta tmp2+1
001F98r 3  68                           pla
001F99r 3  85 26                        sta tmp2
001F9Br 3  80 D1                        bra @loop
001F9Dr 3               
001F9Dr 3               @zero:
001F9Dr 3                               ; if next word is zero, the xt has no nt in this wordlist
001F9Dr 3  68                           pla             ; Leftover from above loop
001F9Er 3               
001F9Er 3               @next_wordlist:
001F9Er 3                               ; Move on to the next wordlist.
001F9Er 3  B5 00                        lda 0,x
001FA0r 3  1A                           inc
001FA1r 3  95 00                        sta 0,x
001FA3r 3  C9 0C                        cmp #max_wordlists
001FA5r 3  D0 A9                        bne @wordlist_loop
001FA7r 3               
001FA7r 3                               ; We didn't find it in any of the wordlists.
001FA7r 3                               ; Remove the wordlist id from the stack.
001FA7r 3  E8                           inx
001FA8r 3  E8                           inx
001FA9r 3               
001FA9r 3                               ; We return a zero to indicate that we didn't find it.
001FA9r 3  74 00                        stz 0,x
001FABr 3  74 01                        stz 1,x
001FADr 3  80 0A                        bra z_int_to_name
001FAFr 3               
001FAFr 3               @match:
001FAFr 3                               ; We found it. Remove wordlist id from stack.
001FAFr 3  E8                           inx
001FB0r 3  E8                           inx
001FB1r 3               
001FB1r 3                               ; It's a match! Replace TOS with nt
001FB1r 3  A5 26                        lda tmp2
001FB3r 3  95 00                        sta 0,x
001FB5r 3  A5 27                        lda tmp2+1
001FB7r 3  95 01                        sta 1,x
001FB9r 3               
001FB9r 3  60           z_int_to_name:  rts
001FBAr 3               
001FBAr 3               
001FBAr 3               
001FBAr 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001FBAr 3               ; ## "invert"  auto  ANS core
001FBAr 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001FBAr 3               xt_invert:
001FBAr 3  20 rr rr                     jsr underflow_1
001FBDr 3               
001FBDr 3  A9 FF                        lda #$FF
001FBFr 3  55 00                        eor 0,x         ; LSB
001FC1r 3  95 00                        sta 0,x
001FC3r 3               
001FC3r 3  A9 FF                        lda #$FF
001FC5r 3  55 01                        eor 1,x         ; MSB
001FC7r 3  95 01                        sta 1,x
001FC9r 3               
001FC9r 3  60           z_invert:       rts
001FCAr 3               
001FCAr 3               
001FCAr 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001FCAr 3               ; ## "is"  auto  ANS core ext
001FCAr 3                       ; """http://forth-standard.org/standard/core/IS"""
001FCAr 3               
001FCAr 3               xt_is:
001FCAr 3                               ; This is a state aware word with differet behavior
001FCAr 3                               ; when used while compiling vs interpreting.
001FCAr 3                               ; Check STATE
001FCAr 3  A5 16                        lda state
001FCCr 3  05 17                        ora state+1
001FCEr 3  F0 0C                        beq @interpreting
001FD0r 3               
001FD0r 3               @compiling:
001FD0r 3                               ; Run ['] to compile the xt of the next word as a literal.
001FD0r 3  20 rr rr                     jsr xt_bracket_tick
001FD3r 3               
001FD3r 3                               ; Postpone DEFER! by compiling a JSR to it.
001FD3r 3  A0 rr                        ldy #>xt_defer_store
001FD5r 3  A9 rr                        lda #<xt_defer_store
001FD7r 3  20 rr rr                     jsr cmpl_subroutine
001FDAr 3               
001FDAr 3  80 06                        bra @done
001FDCr 3               
001FDCr 3               @interpreting:
001FDCr 3  20 rr rr                     jsr xt_tick
001FDFr 3  20 rr rr                     jsr xt_defer_store
001FE2r 3               @done:
001FE2r 3  60           z_is:           rts
001FE3r 3               
001FE3r 3               
001FE3r 3               
001FE3r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001FE3r 3               ; ## "j"  auto  ANS core
001FE3r 3                       ; """https://forth-standard.org/standard/core/J
001FE3r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001FE3r 3                       ; a fudge factor for loop control; see the Control Flow section of
001FE3r 3                       ; the manual for more details.
001FE3r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001FE3r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001FE3r 3                       ; implementation would just have two.
001FE3r 3                       ;
001FE3r 3                       ; Make this native compiled for speed
001FE3r 3                       ; """
001FE3r 3               
001FE3r 3               xt_j:
001FE3r 3  CA                           dex
001FE4r 3  CA                           dex
001FE5r 3               
001FE5r 3                               ; Get the fudged index off from the stack. It's easier to
001FE5r 3                               ; do math on the stack directly than to pop and push stuff
001FE5r 3                               ; around
001FE5r 3  86 2A                        stx tmpdsp
001FE7r 3  BA                           tsx
001FE8r 3               
001FE8r 3  38                           sec
001FE9r 3  BD 07 01                     lda $0107,x     ; LSB
001FECr 3  FD 09 01                     sbc $0109,x
001FEFr 3  A8                           tay
001FF0r 3               
001FF0r 3  BD 08 01                     lda $0108,x     ; MSB
001FF3r 3  FD 0A 01                     sbc $010A,x
001FF6r 3               
001FF6r 3  A6 2A                        ldx tmpdsp
001FF8r 3               
001FF8r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001FFAr 3  94 00                        sty 0,x         ; LSB of de-fudged index
001FFCr 3               
001FFCr 3  60           z_j:            rts
001FFDr 3               
001FFDr 3               
001FFDr 3               
001FFDr 3               ; ## KEY ( -- char ) "Get one character from the input"
001FFDr 3               ; ## "key"  tested  ANS core
001FFDr 3               xt_key:
001FFDr 3                       ; """https://forth-standard.org/standard/core/KEY
001FFDr 3                       ; Get a single character of input from the vectored
001FFDr 3                       ; input without echoing.
001FFDr 3                       ; """
001FFDr 3  20 rr rr                     jsr key_a               ; returns char in A
002000r 3               
002000r 3  CA                           dex
002001r 3  CA                           dex
002002r 3  95 00                        sta 0,x
002004r 3  74 01                        stz 1,x
002006r 3               
002006r 3  60           z_key:          rts
002007r 3               
002007r 3               key_a:
002007r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
002007r 3                       ; 65816, so we have to fake the indirect jump to vector it.
002007r 3                       ; This is depressingly slow. We use this routine internally
002007r 3                       ; to avoid manipulating the Data Stack when we just want a
002007r 3                       ; character
002007r 3  6C 12 00                     jmp (input)             ; JSR/RTS
00200Ar 3               
00200Ar 3               
00200Ar 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
00200Ar 3               ; ## "latestnt"  auto  Tali Forth
00200Ar 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00200Ar 3                       ; The Gforth version of this word is called LATEST
00200Ar 3                       ; """
00200Ar 3               xt_latestnt:
00200Ar 3  CA                           dex
00200Br 3  CA                           dex
00200Cr 3               
00200Cr 3  20 rr rr                     jsr current_to_dp
00200Fr 3               
00200Fr 3  A5 02                        lda dp
002011r 3  95 00                        sta 0,x
002013r 3  A5 03                        lda dp+1
002015r 3  95 01                        sta 1,x
002017r 3               
002017r 3  60           z_latestnt:     rts
002018r 3               
002018r 3               
002018r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
002018r 3               ; ## "latestxt"  auto  Gforth
002018r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
002018r 3               xt_latestxt:
002018r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
00201Br 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
00201Er 3               
00201Er 3  60           z_latestxt:     rts
00201Fr 3               
00201Fr 3               
00201Fr 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
00201Fr 3               ; ## "leave"  auto  ANS core
00201Fr 3                       ; """https://forth-standard.org/standard/core/LEAVE
00201Fr 3                       ; Note that this does not work with anything but a DO/LOOP in
00201Fr 3                       ; contrast to other versions such as discussed at
00201Fr 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
00201Fr 3                       ;
00201Fr 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
00201Fr 3                       ; See the Control Flow section in the manual for details of how this works.
00201Fr 3                       ; This must be native compile and not IMMEDIATE
00201Fr 3                       ; """
00201Fr 3               
00201Fr 3               xt_leave:
00201Fr 3                               ; We dump the limit/start entries off the Return Stack
00201Fr 3                               ; (four bytes)
00201Fr 3  68                           pla
002020r 3  68                           pla
002021r 3  68                           pla
002022r 3  68                           pla
002023r 3               
002023r 3  60                           rts             ; this must be compiled, so keep before z_leave
002024r 3               z_leave:                        ; not reached, not compiled
002024r 3               
002024r 3               
002024r 3               
002024r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
002024r 3               ; ## "["  auto  ANS core
002024r 3                       ; """https://forth-standard.org/standard/core/Bracket
002024r 3                       ; This is an immediate and compile-only word
002024r 3                       ; """
002024r 3               xt_left_bracket:
002024r 3  64 16                        stz state
002026r 3  64 17                        stz state+1
002028r 3               
002028r 3  60           z_left_bracket: rts
002029r 3               
002029r 3               
002029r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
002029r 3               ; ## "<#"  auto  ANS core
002029r 3                       ; """https://forth-standard.org/standard/core/num-start
002029r 3                       ; Start the process to create pictured numeric output.
002029r 3                       ;
002029r 3                       ; The new
002029r 3                       ; string is constructed from back to front, saving the new character
002029r 3                       ; at the beginning of the output string. Since we use PAD as a
002029r 3                       ; starting address and work backward (!), the string is constructed
002029r 3                       ; in the space between the end of the Dictionary (as defined by CP)
002029r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
002029r 3                       ; programs don't fool around with the PAD but still use its address.
002029r 3                       ; Based on pForth
002029r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
002029r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
002029r 3                       ; internal variable tohold instead of HLD.
002029r 3                       ; """
002029r 3               xt_less_number_sign:
002029r 3  20 rr rr                     jsr xt_pad      ; ( addr )
00202Cr 3               
00202Cr 3  B5 00                        lda 0,x
00202Er 3  85 34                        sta tohold
002030r 3  B5 01                        lda 1,x
002032r 3  85 35                        sta tohold+1
002034r 3               
002034r 3  E8                           inx
002035r 3  E8                           inx
002036r 3               
002036r 3               z_less_number_sign:
002036r 3  60                           rts
002037r 3               
002037r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
002037r 3               ; ## "<"  auto  ANS core
002037r 3                       ; """https://forth-standard.org/standard/core/less"""
002037r 3               
002037r 3               xt_less_than:
002037r 3  20 rr rr                     jsr underflow_2
00203Ar 3               
00203Ar 3  A0 00                        ldy #0          ; default false
00203Cr 3  20 rr rr                     jsr compare_16bit
00203Fr 3               
00203Fr 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
00203Fr 3  F0 03                        beq @false
002041r 3  30 01                        bmi @false
002043r 3               
002043r 3                               ; true
002043r 3  88                           dey
002044r 3               @false:
002044r 3  98                           tya
002045r 3               
002045r 3  E8                           inx
002046r 3  E8                           inx
002047r 3  95 00                        sta 0,x
002049r 3  95 01                        sta 1,x
00204Br 3               
00204Br 3  60           z_less_than:    rts
00204Cr 3               
00204Cr 3               
00204Cr 3               
00204Cr 3               ; ## LIST ( scr# -- ) "List the given screen"
00204Cr 3               ; ## "list"  tested  ANS block ext
00204Cr 3                       ; """https://forth-standard.org/standard/block/LIST"""
00204Cr 3               
00204Cr 3               xt_list:
00204Cr 3  20 rr rr                     jsr underflow_1
00204Fr 3               
00204Fr 3                               ; Save the screen number in SCR
00204Fr 3  20 rr rr                     jsr xt_scr
002052r 3  20 rr rr                     jsr xt_store
002055r 3               
002055r 3                               ; Use L from the editor-wordlist to display the screen.
002055r 3  20 rr rr                     jsr xt_editor_l
002058r 3               
002058r 3  60           z_list:         rts
002059r 3               
002059r 3               
002059r 3               
002059r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
002059r 3               ; ## "literal"  auto  ANS core
002059r 3                       ; """https://forth-standard.org/standard/core/LITERAL
002059r 3                       ; Compile-only word to store TOS so that it is pushed on stack
002059r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
002059r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
002059r 3                       ;
002059r 3                       ; Note the cmpl_ routines use TMPTOS
002059r 3                       ; """
002059r 3               xt_literal:
002059r 3  20 rr rr                     jsr underflow_1
00205Cr 3               
00205Cr 3  A0 rr                        ldy #>literal_runtime
00205Er 3  A9 rr                        lda #<literal_runtime
002060r 3  20 rr rr                     jsr cmpl_subroutine
002063r 3               
002063r 3                               ; Compile the value that is to be pushed on the Stack during
002063r 3                               ; runtime
002063r 3  20 rr rr                     jsr xt_comma
002066r 3               
002066r 3  60           z_literal:      rts
002067r 3               
002067r 3               literal_runtime:
002067r 3               
002067r 3                               ; During runtime, we push the value following this word back
002067r 3                               ; on the Data Stack. The subroutine jump that brought us
002067r 3                               ; here put the address to return to on the Return Stack -
002067r 3                               ; this points to the data we need to get. This routine is
002067r 3                               ; also called (LITERAL) in some Forths
002067r 3  CA                           dex
002068r 3  CA                           dex
002069r 3               
002069r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
002069r 3                               ; so we are actually popping the address-1 of the literal
002069r 3  68                           pla             ; LSB
00206Ar 3  85 24                        sta tmp1
00206Cr 3  68                           pla             ; MSB
00206Dr 3  85 25                        sta tmp1+1
00206Fr 3               
00206Fr 3                               ; Fetch the actual literal value and push it on Data stack
00206Fr 3  A0 01                        ldy #1
002071r 3  B1 24                        lda (tmp1),y    ; LSB
002073r 3  95 00                        sta 0,x
002075r 3  C8                           iny
002076r 3  B1 24                        lda (tmp1),y    ; MSB
002078r 3  95 01                        sta 1,x
00207Ar 3               
00207Ar 3                               ; Adjust return address and push back on the Return Stack
00207Ar 3  98                           tya
00207Br 3  18                           clc
00207Cr 3  65 24                        adc tmp1
00207Er 3  A8                           tay
00207Fr 3  A5 25                        lda tmp1+1
002081r 3  69 00                        adc #0
002083r 3  48                           pha
002084r 3  5A                           phy
002085r 3               
002085r 3  60                           rts
002086r 3               
002086r 3               
002086r 3               
002086r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
002086r 3               ; ## "load"  auto  ANS block
002086r 3                       ; """https://forth-standard.org/standard/block/LOAD
002086r 3                       ;
002086r 3                       ; Note: LOAD current works because there is only one buffer.
002086r 3                       ; If/when multiple buffers are supported, we'll have to deal
002086r 3                       ; with the fact that it might re-load the old block into a
002086r 3                       ; different buffer.
002086r 3                       ; """
002086r 3               
002086r 3               xt_load:
002086r 3  20 rr rr                     jsr underflow_1
002089r 3               
002089r 3                               ; Save the current value of BLK on the return stack.
002089r 3  A0 01                        ldy #blk_offset+1
00208Br 3  B1 1E                        lda (up),y
00208Dr 3  48                           pha
00208Er 3  88                           dey
00208Fr 3  B1 1E                        lda (up),y
002091r 3  48                           pha
002092r 3               
002092r 3                               ; Set BLK to the given block/screen number.
002092r 3  B5 00                        lda 0,x
002094r 3  91 1E                        sta (up),y
002096r 3  C8                           iny
002097r 3  B5 01                        lda 1,x
002099r 3  91 1E                        sta (up),y
00209Br 3               
00209Br 3                               ; Load that block into a buffer
00209Br 3  20 rr rr                     jsr xt_block
00209Er 3               
00209Er 3                               ; Put 1024 on the stack for the screen length.
00209Er 3  CA                           dex
00209Fr 3  CA                           dex
0020A0r 3  A9 04                        lda #4
0020A2r 3  95 01                        sta 1,x
0020A4r 3  74 00                        stz 0,x
0020A6r 3               
0020A6r 3                               ; Jump to a special evluate target. This bypasses the underflow
0020A6r 3                               ; check and skips the zeroing of BLK.
0020A6r 3  20 rr rr                     jsr load_evaluate
0020A9r 3               
0020A9r 3                               ; Restore the value of BLK from before the LOAD command.
0020A9r 3  A0 00                        ldy #blk_offset
0020ABr 3  68                           pla
0020ACr 3  91 1E                        sta (up),y
0020AEr 3  C8                           iny
0020AFr 3  68                           pla
0020B0r 3  91 1E                        sta (up),y
0020B2r 3               
0020B2r 3                               ; If BLK is not zero, read it back into the buffer.
0020B2r 3                               ; A still has MSB
0020B2r 3  88                           dey
0020B3r 3  11 1E                        ora (up),y
0020B5r 3  F0 12                        beq @done
0020B7r 3               
0020B7r 3                               ; The block needs to be read back into the buffer.
0020B7r 3  CA                           dex
0020B8r 3  CA                           dex
0020B9r 3  A0 00                        ldy #blk_offset
0020BBr 3  B1 1E                        lda (up),y
0020BDr 3  95 00                        sta 0,x
0020BFr 3  C8                           iny
0020C0r 3  B1 1E                        lda (up),y
0020C2r 3  95 01                        sta 1,x
0020C4r 3  20 rr rr                     jsr xt_block
0020C7r 3               
0020C7r 3                               ; Drop the buffer address.
0020C7r 3  E8                           inx
0020C8r 3  E8                           inx
0020C9r 3               
0020C9r 3               @done:
0020C9r 3  60           z_load:         rts
0020CAr 3               
0020CAr 3               
0020CAr 3               
0020CAr 3               ; ## LOOP ( -- ) "Finish loop construct"
0020CAr 3               ; ## "loop"  auto  ANS core
0020CAr 3                       ; """https://forth-standard.org/standard/core/LOOP
0020CAr 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
0020CAr 3                       ; the stack and then call +LOOP.
0020CAr 3                       ;
0020CAr 3                       ; In Forth, this is
0020CAr 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
0020CAr 3                       ;       IMMEDIATE ; COMPILE-ONLY
0020CAr 3                       ; """
0020CAr 3               xt_loop:
0020CAr 3                               ; Have the finished word push 1 on the stack
0020CAr 3  A0 rr                        ldy #>xt_one
0020CCr 3  A9 rr                        lda #<xt_one
0020CEr 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
0020D1r 3               
0020D1r 3               
0020D1r 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
0020D1r 3               ; ## "+loop"  auto  ANS core
0020D1r 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
0020D1r 3                       ;
0020D1r 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
0020D1r 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
0020D1r 3                       ;       COMPILE-ONLY
0020D1r 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
0020D1r 3                       ; address for looping as TOS and the address for aborting the loop
0020D1r 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
0020D1r 3                       ; DO and the Control Flow section of the manual for details).
0020D1r 3                       ; """
0020D1r 3               
0020D1r 3               xt_plus_loop:
0020D1r 3                               ; Compile the run-time part. We do this with a short loop
0020D1r 3                               ; and not a call to COMPILE, because it has to be natively
0020D1r 3                               ; coded anyway.
0020D1r 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
0020D3r 3  5A                           phy             ; save counter to adjust CP
0020D4r 3               @1:
0020D4r 3  B9 rr rr                     lda plus_loop_runtime,y
0020D7r 3  91 00                        sta (cp),y
0020D9r 3  88                           dey
0020DAr 3  10 F8                        bpl @1
0020DCr 3               
0020DCr 3                               ; Adjust CP
0020DCr 3  68                           pla
0020DDr 3  18                           clc
0020DEr 3  65 00                        adc cp
0020E0r 3  85 00                        sta cp
0020E2r 3  A5 01                        lda cp+1
0020E4r 3  69 00                        adc #0          ; only need carry
0020E6r 3  85 01                        sta cp+1
0020E8r 3               
0020E8r 3                               ; The address we need to loop back to is TOS. Store it so
0020E8r 3                               ; the runtime part of +LOOP jumps back up there
0020E8r 3  20 rr rr                     jsr xt_comma
0020EBr 3               
0020EBr 3                               ; Compile an UNLOOP for when we're all done. This is a series
0020EBr 3                               ; of six PLA, so we just do it here instead jumping around
0020EBr 3                               ; all over the place
0020EBr 3  A9 68                        lda #$68                ; opcode for PLA
0020EDr 3  A0 06                        ldy #6
0020EFr 3               @2:
0020EFr 3  91 00                        sta (cp),y
0020F1r 3  88                           dey
0020F2r 3  10 FB                        bpl @2
0020F4r 3               
0020F4r 3                               ; Adjust CP
0020F4r 3  A9 06                        lda #6
0020F6r 3  18                           clc
0020F7r 3  65 00                        adc cp
0020F9r 3  85 00                        sta cp
0020FBr 3  A5 01                        lda cp+1
0020FDr 3  69 00                        adc #0                  ; only need carry
0020FFr 3  85 01                        sta cp+1
002101r 3               
002101r 3                               ; Complete compile of DO/?DO by replacing the six
002101r 3                               ; dummy bytes by PHA instructions. The address where
002101r 3                               ; they are located is on the Data Stack
002101r 3  B5 00                        lda 0,x
002103r 3  85 24                        sta tmp1
002105r 3  B5 01                        lda 1,x
002107r 3  85 25                        sta tmp1+1
002109r 3  E8                           inx
00210Ar 3  E8                           inx
00210Br 3               
00210Br 3                               ; Because of the way that CP works, we don't have to save
00210Br 3                               ; CP, but CP-1
00210Br 3  A5 00                        lda cp
00210Dr 3  38                           sec
00210Er 3  E9 01                        sbc #1
002110r 3  85 26                        sta tmp2
002112r 3  A5 01                        lda cp+1
002114r 3  E9 00                        sbc #0
002116r 3  85 27                        sta tmp2+1
002118r 3               
002118r 3                               ; now compile this in the DO/?DO routine
002118r 3  A0 00                        ldy #0
00211Ar 3               
00211Ar 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
00211Cr 3  91 24                        sta (tmp1),y
00211Er 3  C8                           iny
00211Fr 3  A5 27                        lda tmp2+1      ; MSB
002121r 3  91 24                        sta (tmp1),y
002123r 3  C8                           iny
002124r 3  A9 48                        lda #$48        ; Opcode for PHA
002126r 3  91 24                        sta (tmp1),y
002128r 3  C8                           iny
002129r 3               
002129r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
00212Br 3  91 24                        sta (tmp1),y
00212Dr 3  C8                           iny
00212Er 3  A5 26                        lda tmp2        ; LSB
002130r 3  91 24                        sta (tmp1),y
002132r 3  C8                           iny
002133r 3  A9 48                        lda #$48        ; Opcode for PHA
002135r 3  91 24                        sta (tmp1),y
002137r 3               z_loop:
002137r 3  60           z_plus_loop:    rts
002138r 3               
002138r 3               
002138r 3               plus_loop_runtime:
002138r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
002138r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
002138r 3                       ; loop control so we can test with the Overflow Flag. See
002138r 3                       ; the Control Flow section of the manual for details.
002138r 3                       ; The step value is TOS in the loop. This
002138r 3                       ; must always be native compiled. In some Forths, this is a separate
002138r 3                       ; word called (+LOOP) or (LOOP)
002138r 3                       ; """
002138r 3               
002138r 3  18                           clc
002139r 3  68                           pla             ; LSB of index
00213Ar 3  75 00                        adc 0,x         ; LSB of step
00213Cr 3  A8                           tay             ; temporary storage of LSB
00213Dr 3               
00213Dr 3  B8                           clv
00213Er 3  68                           pla             ; MSB of index
00213Fr 3  75 01                        adc 1,x         ; MSB of step
002141r 3  48                           pha             ; put MSB of index back on stack
002142r 3               
002142r 3  98                           tya             ; put LSB of index back on stack
002143r 3  48                           pha
002144r 3               
002144r 3  E8                           inx             ; dump step from TOS
002145r 3  E8                           inx
002146r 3               
002146r 3                               ; If V flag is set, we're done looping and continue
002146r 3                               ; after the +LOOP instruction
002146r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
002148r 3               
002148r 3               @hack:          ; This is why this routine must be natively compiled: We
002148r 3                               ; compile the opcode for JMP here without an address to
002148r 3                               ; go to, which is added by the next next instruction of
002148r 3                               ; LOOP/+LOOP during compile time
002148r 3  4C                           .byte $4C
002149r 3               
002149r 3               plus_loop_runtime_end:
002149r 3               
002149r 3               
002149r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
002149r 3               ; ## "lshift"  auto  ANS core
002149r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
002149r 3               
002149r 3               xt_lshift:
002149r 3  20 rr rr                     jsr underflow_2
00214Cr 3               
00214Cr 3                               ; max shift 16 times
00214Cr 3  B5 00                        lda 0,x
00214Er 3  29 0F                        and #%00001111
002150r 3  F0 08                        beq @done
002152r 3               
002152r 3  A8                           tay
002153r 3               
002153r 3               @loop:
002153r 3  16 02                        asl 2,x
002155r 3  36 03                        rol 3,x
002157r 3  88                           dey
002158r 3  D0 F9                        bne @loop
00215Ar 3               
00215Ar 3               @done:
00215Ar 3  E8                           inx
00215Br 3  E8                           inx
00215Cr 3               
00215Cr 3  60           z_lshift:       rts
00215Dr 3               
00215Dr 3               
00215Dr 3               
00215Dr 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
00215Dr 3               ; ## "m*"  auto  ANS core
00215Dr 3                       ; """https://forth-standard.org/standard/core/MTimes
00215Dr 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
00215Dr 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
00215Dr 3                       ;
00215Dr 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
00215Dr 3                       ; with  : D+- O< IF DNEGATE THEN ;
00215Dr 3                       ; """
00215Dr 3               
00215Dr 3               xt_m_star:
00215Dr 3  20 rr rr                     jsr underflow_2
002160r 3               
002160r 3                               ; figure out the sign
002160r 3  B5 01                        lda 1,x         ; MSB of n1
002162r 3  55 03                        eor 3,x         ; MSB of n2
002164r 3               
002164r 3                               ; UM* uses all kinds of temporary variables so we don't
002164r 3                               ; risk a conflict but just take the cycle hit and push
002164r 3                               ; this to the stack
002164r 3  48                           pha
002165r 3               
002165r 3                               ; get the absolute value of both numbers so we can feed
002165r 3                               ; them to UM*, which does the real work
002165r 3  20 rr rr                     jsr xt_abs
002168r 3  20 rr rr                     jsr xt_swap
00216Br 3  20 rr rr                     jsr xt_abs
00216Er 3               
00216Er 3  20 rr rr                     jsr xt_um_star          ; ( d )
002171r 3               
002171r 3                               ; handle the sign
002171r 3  68                           pla
002172r 3  10 03                        bpl @done
002174r 3               
002174r 3  20 rr rr                     jsr xt_dnegate
002177r 3               @done:
002177r 3  60           z_m_star:       rts
002178r 3               
002178r 3               
002178r 3               
002178r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
002178r 3               ; ## "marker"  auto  ANS core ext
002178r 3                       ; """https://forth-standard.org/standard/core/MARKER
002178r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
002178r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
002178r 3                       ; Run the named word at a later time to restore all of the wordlists
002178r 3                       ; to their state when the word was created with marker.  Any words
002178r 3                       ; created after the marker (including the marker) will be forgotten.
002178r 3                       ;
002178r 3                       ; To do this, we want to end up with something that jumps to a
002178r 3                       ; run-time component with a link to the original CP and DP values:
002178r 3                       ;
002178r 3                       ;       jsr marker_runtime
002178r 3                       ;       <Original CP MSB>
002178r 3                       ;       <Original CP LSB>
002178r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
002178r 3                       ;       <Original DP LSB>
002178r 3                       ;       < USER variables from offset 4 to 39 >
002178r 3                       ;
002178r 3                       ;       The user variables include:
002178r 3                       ;       CURRENT (byte variable)
002178r 3                       ;       <All wordlists> (currently 12) (cell array)
002178r 3                       ;       <#ORDER> (byte variable)
002178r 3                       ;       <All search order> (currently 9) (byte array)
002178r 3                       ;
002178r 3                       ; This code uses tmp1 and tmp2
002178r 3                       ; """
002178r 3               
002178r 3               xt_marker:
002178r 3                               ; Before we do anything, we need to save CP, which
002178r 3                               ; after all is the whole point of this operation. CREATE
002178r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
002178r 3                               ; to the stack
002178r 3  20 rr rr                     jsr current_to_dp
00217Br 3               
00217Br 3  A5 02                        lda dp
00217Dr 3  48                           pha
00217Er 3  A5 03                        lda dp+1
002180r 3  48                           pha
002181r 3               
002181r 3  A5 00                        lda cp
002183r 3  48                           pha
002184r 3  A5 01                        lda cp+1
002186r 3  48                           pha
002187r 3               
002187r 3  20 rr rr                     jsr xt_create
00218Ar 3               
00218Ar 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
00218Ar 3                               ; we have to replace by a jump to marker_runtime. We back up
00218Ar 3                               ; two bytes and then overwrite the address
00218Ar 3  A5 00                        lda cp          ; LSB
00218Cr 3  38                           sec
00218Dr 3  E9 02                        sbc #2
00218Fr 3  85 00                        sta cp
002191r 3               
002191r 3  A5 01                        lda cp+1        ; MSB
002193r 3  E9 00                        sbc #0          ; we only care about the borrow
002195r 3  85 01                        sta cp+1
002197r 3               
002197r 3                               ; Add the address of the runtime component
002197r 3  A0 rr                        ldy #>marker_runtime
002199r 3  A9 rr                        lda #<marker_runtime
00219Br 3  20 rr rr                     jsr cmpl_word
00219Er 3               
00219Er 3                               ; Add original CP as payload
00219Er 3  7A                           ply                     ; MSB
00219Fr 3  68                           pla                     ; LSB
0021A0r 3  20 rr rr                     jsr cmpl_word
0021A3r 3               
0021A3r 3                               ; Add original DP as payload
0021A3r 3  7A                           ply                     ; MSB
0021A4r 3  68                           pla                     ; LSB
0021A5r 3  20 rr rr                     jsr cmpl_word
0021A8r 3               
0021A8r 3                               ; Add the user variables for the wordlists and search order.
0021A8r 3                               ; We're compiling them in byte order.
0021A8r 3  A0 04                        ldy #4                  ; Start at CURRENT
0021AAr 3               @marker_loop:
0021AAr 3  B1 1E                        lda (up),y
0021ACr 3  20 rr rr                     jsr cmpl_a
0021AFr 3  C8                           iny
0021B0r 3  98                           tya
0021B1r 3  C9 28                        cmp #40                 ; One past the end of the search order.
0021B3r 3  D0 F5                        bne @marker_loop
0021B5r 3               
0021B5r 3  60           z_marker:       rts
0021B6r 3               
0021B6r 3               
0021B6r 3               
0021B6r 3               marker_runtime:
0021B6r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
0021B6r 3                       ; when this marker was defined. We arrive here with the return
0021B6r 3                       ; address on the Return Stack in the usual 65c02 format
0021B6r 3                       ; """
0021B6r 3               
0021B6r 3                               ; Get the address of the string address off the stack and
0021B6r 3                               ; increase by one because of the RTS mechanics
0021B6r 3  68                           pla
0021B7r 3  85 24                        sta tmp1        ; LSB of address
0021B9r 3  68                           pla
0021BAr 3  85 25                        sta tmp1+1      ; MSB of address
0021BCr 3               
0021BCr 3  E6 24                        inc tmp1
0021BEr 3  D0 02                        bne @1
0021C0r 3  E6 25                        inc tmp1+1
0021C2r 3               @1:
0021C2r 3  A0 00                        ldy #0
0021C4r 3               
0021C4r 3                               ; CP was stored first
0021C4r 3  B1 24                        lda (tmp1),y
0021C6r 3  85 00                        sta cp
0021C8r 3  C8                           iny
0021C9r 3  B1 24                        lda (tmp1),y
0021CBr 3  85 01                        sta cp+1
0021CDr 3               
0021CDr 3                               ; Next was DP
0021CDr 3  C8                           iny
0021CEr 3  B1 24                        lda (tmp1),y
0021D0r 3  85 02                        sta dp
0021D2r 3  C8                           iny
0021D3r 3  B1 24                        lda (tmp1),y
0021D5r 3  85 03                        sta dp+1
0021D7r 3               
0021D7r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
0021D7r 3                               ; to start restoring the wordlists and search order.
0021D7r 3  A0 04                        ldy #4
0021D9r 3               
0021D9r 3               @marker_restore_loop:
0021D9r 3                               ; Copy from the dictionary back on top of the wordlists
0021D9r 3                               ; and search order.
0021D9r 3  B1 24                        lda (tmp1), y
0021DBr 3  91 1E                        sta (up), y
0021DDr 3  C8                           iny
0021DEr 3  98                           tya
0021DFr 3  C9 28                        cmp #40                 ; One past the end of the search order.
0021E1r 3  D0 F6                        bne @marker_restore_loop
0021E3r 3               
0021E3r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
0021E6r 3               
0021E6r 3                               ; The return instruction takes us back to the original caller
0021E6r 3  60                           rts
0021E7r 3               
0021E7r 3               
0021E7r 3               
0021E7r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
0021E7r 3               ; ## "max"  auto  ANS core
0021E7r 3                       ; """https://forth-standard.org/standard/core/MAX
0021E7r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
0021E7r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
0021E7r 3                       ; Flag indicates which number is larger. See also
0021E7r 3                       ; http://6502.org/tutorials/compare_instructions.html and
0021E7r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
0021E7r 3                       ; """
0021E7r 3               
0021E7r 3               xt_max:
0021E7r 3  20 rr rr                     jsr underflow_2
0021EAr 3               
0021EAr 3                               ; Compare LSB. We do this first to set the carry flag
0021EAr 3  B5 00                        lda 0,x         ; LSB of TOS
0021ECr 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
0021EEr 3               
0021EEr 3  B5 01                        lda 1,x         ; MSB of TOS
0021F0r 3  F5 03                        sbc 3,x         ; MSB of NOS
0021F2r 3  50 02                        bvc @no_overflow
0021F4r 3               
0021F4r 3                               ; handle overflow, because we use signed numbers
0021F4r 3  49 80                        eor #$80        ; complement negative flag
0021F6r 3               
0021F6r 3               @no_overflow:
0021F6r 3                               ; if negative, NOS is larger and needs to be kept
0021F6r 3  30 08                        bmi @keep_nos
0021F8r 3               
0021F8r 3                               ; move TOS to NOS
0021F8r 3  B5 00                        lda 0,x
0021FAr 3  95 02                        sta 2,x
0021FCr 3  B5 01                        lda 1,x
0021FEr 3  95 03                        sta 3,x
002200r 3               
002200r 3               @keep_nos:
002200r 3  E8                           inx
002201r 3  E8                           inx
002202r 3               
002202r 3  60           z_max:          rts
002203r 3               
002203r 3               
002203r 3               
002203r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
002203r 3               ; ## "min"  auto  ANS core
002203r 3                       ; """https://forth-standard.org/standard/core/MIN
002203r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
002203r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
002203r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
002203r 3                       ; """
002203r 3               
002203r 3               xt_min:
002203r 3  20 rr rr                     jsr underflow_2
002206r 3               
002206r 3                               ; compare LSB. We do this first to set the carry flag
002206r 3  B5 00                        lda 0,x         ; LSB of TOS
002208r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
00220Ar 3               
00220Ar 3  B5 01                        lda 1,x         ; MSB of TOS
00220Cr 3  F5 03                        sbc 3,x         ; MSB of NOS
00220Er 3  50 02                        bvc @no_overflow
002210r 3               
002210r 3                               ; handle overflow because we use signed numbers
002210r 3  49 80                        eor #$80
002212r 3               
002212r 3               @no_overflow:
002212r 3                               ; if negative, NOS is larger and needs to be dumped
002212r 3  10 08                        bpl @keep_nos
002214r 3               
002214r 3                               ; move TOS to NOS
002214r 3  B5 00                        lda 0,x
002216r 3  95 02                        sta 2,x
002218r 3  B5 01                        lda 1,x
00221Ar 3  95 03                        sta 3,x
00221Cr 3               
00221Cr 3               @keep_nos:
00221Cr 3  E8                           inx
00221Dr 3  E8                           inx
00221Er 3               
00221Er 3  60           z_min:          rts
00221Fr 3               
00221Fr 3               
00221Fr 3               
00221Fr 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
00221Fr 3               ; ## "-"  auto  ANS core
00221Fr 3                       ; """https://forth-standard.org/standard/core/Minus"""
00221Fr 3               xt_minus:
00221Fr 3  20 rr rr                     jsr underflow_2
002222r 3               
002222r 3  38                           sec
002223r 3  B5 02                        lda 2,x         ; LSB
002225r 3  F5 00                        sbc 0,x
002227r 3  95 02                        sta 2,x
002229r 3               
002229r 3  B5 03                        lda 3,x         ; MSB
00222Br 3  F5 01                        sbc 1,x
00222Dr 3  95 03                        sta 3,x
00222Fr 3               
00222Fr 3  E8                           inx
002230r 3  E8                           inx
002231r 3               
002231r 3  60           z_minus:        rts
002232r 3               
002232r 3               
002232r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
002232r 3               ; ## "-leading"  auto  Tali String
002232r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
002232r 3                       ; """
002232r 3               
002232r 3               xt_minus_leading:
002232r 3  20 rr rr                     jsr underflow_2
002235r 3               
002235r 3               @loop:
002235r 3                               ; Quit if we were given an empty string. This also terminates
002235r 3                               ; the main loop
002235r 3  B5 00                        lda 0,x
002237r 3  15 01                        ora 1,x
002239r 3  F0 0F                        beq @done
00223Br 3               
00223Br 3  A1 02                        lda (2,x)               ; get first character
00223Dr 3  20 rr rr                     jsr is_whitespace
002240r 3  90 08                        bcc @done
002242r 3               
002242r 3                               ; It's whitespace, move one down
002242r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
002245r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
002248r 3               
002248r 3  80 EB                        bra @loop
00224Ar 3               @done:
00224Ar 3               z_minus_leading:
00224Ar 3  60                           rts
00224Br 3               
00224Br 3               
00224Br 3               
00224Br 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
00224Br 3               ; ## "-trailing"  auto  ANS string
00224Br 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
00224Br 3                       ; Remove trailing spaces
00224Br 3                       ; """
00224Br 3               
00224Br 3               xt_minus_trailing:
00224Br 3  20 rr rr                     jsr underflow_2
00224Er 3               
00224Er 3                               ; if length entry is zero, return a zero and leave the
00224Er 3                               ; address part untouched
00224Er 3  B5 00                        lda 0,x         ; LSB of n
002250r 3  15 01                        ora 1,x         ; MSB of n
002252r 3  F0 33                        beq @done
002254r 3               
002254r 3                               ; Compute address of last char in tmp1 as
002254r 3                               ; addr + u1 - 1
002254r 3               
002254r 3                               ; addr + u1
002254r 3  18                           clc
002255r 3  B5 02                        lda 2,x         ; LSB of addr
002257r 3  75 00                        adc 0,x
002259r 3  85 24                        sta tmp1
00225Br 3  B5 03                        lda 3,x         ; MSB of addr
00225Dr 3  75 01                        adc 1,x
00225Fr 3  85 25                        sta tmp1+1
002261r 3               
002261r 3                               ; - 1
002261r 3  A5 24                        lda tmp1
002263r 3  D0 02                        bne @1
002265r 3  C6 25                        dec tmp1+1
002267r 3               @1:
002267r 3  C6 24                        dec tmp1
002269r 3               
002269r 3               @loop:
002269r 3                               ; While spaces are found, move tmp1 backwards and
002269r 3                               ; decrease the count on the data stack.
002269r 3  B2 24                        lda (tmp1)
00226Br 3  C9 20                        cmp #AscSP
00226Dr 3  D0 18                        bne @done
00226Fr 3               
00226Fr 3                               ; Move back one address.
00226Fr 3  A5 24                        lda tmp1
002271r 3  D0 02                        bne @2
002273r 3  C6 25                        dec tmp1+1
002275r 3               @2:
002275r 3  C6 24                        dec tmp1
002277r 3               
002277r 3                               ; Decrement count by one.
002277r 3  B5 00                        lda 0,x
002279r 3  D0 02                        bne @3
00227Br 3  D6 01                        dec 1,x
00227Dr 3               @3:
00227Dr 3  D6 00                        dec 0,x
00227Fr 3               
00227Fr 3                               ; Check if there are any characters left.
00227Fr 3  B5 00                        lda 0,x
002281r 3  15 01                        ora 1,x
002283r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
002285r 3               
002285r 3  80 E2                        bra @loop
002287r 3               
002287r 3               @done:
002287r 3               z_minus_trailing:
002287r 3  60                           rts
002288r 3               
002288r 3               
002288r 3               
002288r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
002288r 3               ; ## "mod"  auto  ANS core
002288r 3                       ; """https://forth-standard.org/standard/core/MOD
002288r 3                       ;
002288r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
002288r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
002288r 3                       ; """
002288r 3               xt_mod:
002288r 3  20 rr rr                     jsr underflow_2
00228Br 3               
00228Br 3  20 rr rr                     jsr xt_slash_mod
00228Er 3               
00228Er 3  E8                           inx             ; DROP
00228Fr 3  E8                           inx
002290r 3               z_mod:
002290r 3  60                           rts
002291r 3               
002291r 3               
002291r 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
002291r 3               ; ## "move"  auto  ANS core
002291r 3                       ; """https://forth-standard.org/standard/core/MOVE
002291r 3                       ; Copy u "address units" from addr1 to addr2. Since our address
002291r 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
002291r 3                       ; is actually the only one of these three words that is in the CORE
002291r 3                       ; set.
002291r 3                       ;
002291r 3                       ; This word must not be natively compiled.
002291r 3                       ; """
002291r 3               
002291r 3               xt_move:
002291r 3                               ; We let CMOVE and CMOVE> check if there is underflow or
002291r 3                               ; we've been told to copy zero bytes
002291r 3               
002291r 3                               ; compare MSB first
002291r 3  B5 03                        lda 3,x                 ; MSB of addr2
002293r 3  D5 05                        cmp 5,x                 ; MSB of addr1
002295r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
002297r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
002299r 3               
002299r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
00229Cr 3               
00229Cr 3               @lsb:
00229Cr 3                               ; MSB were equal, so do the whole thing over with LSB
00229Cr 3  B5 02                        lda 2,x                 ; LSB of addr2
00229Er 3  D5 04                        cmp 4,x                 ; LSB of addr1
0022A0r 3  F0 08                        beq @equal              ; LSB is equal as well
0022A2r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
0022A4r 3               
0022A4r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
0022A7r 3               
0022A7r 3               @to_move_up:
0022A7r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
0022AAr 3               @equal:
0022AAr 3                               ; drop three entries from Data Stack
0022AAr 3  8A                           txa
0022ABr 3  18                           clc
0022ACr 3  69 06                        adc #6
0022AEr 3  AA                           tax
0022AFr 3               
0022AFr 3  60           z_move:         rts
0022B0r 3               
0022B0r 3               
0022B0r 3               
0022B0r 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
0022B0r 3               ; ## "name>int"  tested  Gforth
0022B0r 3                       ; """See
0022B0r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0022B0r 3                       ; """
0022B0r 3               
0022B0r 3               xt_name_to_int:
0022B0r 3  20 rr rr                     jsr underflow_1
0022B3r 3               
0022B3r 3                               ; The xt starts four bytes down from the nt
0022B3r 3  B5 00                        lda 0,x
0022B5r 3  18                           clc
0022B6r 3  69 04                        adc #4
0022B8r 3  85 28                        sta tmp3
0022BAr 3               
0022BAr 3  B5 01                        lda 1,x
0022BCr 3  90 01                        bcc @done
0022BEr 3  1A                           inc
0022BFr 3               @done:
0022BFr 3  85 29                        sta tmp3+1
0022C1r 3               
0022C1r 3  A0 00                        ldy #0
0022C3r 3  B1 28                        lda (tmp3),y
0022C5r 3  95 00                        sta 0,x
0022C7r 3  C8                           iny
0022C8r 3  B1 28                        lda (tmp3),y
0022CAr 3  95 01                        sta 1,x
0022CCr 3               
0022CCr 3  60           z_name_to_int:  rts
0022CDr 3               
0022CDr 3               
0022CDr 3               
0022CDr 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
0022CDr 3               ; ## "name>string"  tested  Gforth
0022CDr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
0022CDr 3               
0022CDr 3               xt_name_to_string:
0022CDr 3  20 rr rr                     jsr underflow_1
0022D0r 3               
0022D0r 3  CA                           dex
0022D1r 3  CA                           dex
0022D2r 3               
0022D2r 3                               ; the length of the string is the first byte of the
0022D2r 3                               ; header pointed to by nt
0022D2r 3  A1 02                        lda (2,x)
0022D4r 3  95 00                        sta 0,x
0022D6r 3  74 01                        stz 1,x
0022D8r 3               
0022D8r 3                               ; the string itself always starts eight bytes down
0022D8r 3  B5 02                        lda 2,x         ; LSB
0022DAr 3  18                           clc
0022DBr 3  69 08                        adc #8
0022DDr 3  A8                           tay
0022DEr 3  B5 03                        lda 3,x         ; MSB
0022E0r 3  69 00                        adc #0          ; just need carry
0022E2r 3  95 03                        sta 3,x
0022E4r 3  94 02                        sty 2,x
0022E6r 3               
0022E6r 3               z_name_to_string:
0022E6r 3  60                           rts
0022E7r 3               
0022E7r 3               
0022E7r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
0022E7r 3               ; ## "nc-limit"  tested  Tali Forth
0022E7r 3               
0022E7r 3               xt_nc_limit:
0022E7r 3  CA                           dex
0022E8r 3  CA                           dex
0022E9r 3  A9 1A                        lda #<nc_limit
0022EBr 3  95 00                        sta 0,x
0022EDr 3  A9 00                        lda #>nc_limit
0022EFr 3  95 01                        sta 1,x
0022F1r 3               
0022F1r 3  60           z_nc_limit:     rts
0022F2r 3               
0022F2r 3               
0022F2r 3               
0022F2r 3               ; ## NEGATE ( n -- n ) "Two's complement"
0022F2r 3               ; ## "negate"  auto  ANS core
0022F2r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
0022F2r 3               xt_negate:
0022F2r 3  20 rr rr                     jsr underflow_1
0022F5r 3               
0022F5r 3  A9 00                	lda #0
0022F7r 3  38                           sec
0022F8r 3  F5 00                        sbc 0,x         ; LSB
0022FAr 3  95 00                        sta 0,x
0022FCr 3               
0022FCr 3  A9 00                        lda #0
0022FEr 3  F5 01                        sbc 1,x         ; MSB
002300r 3  95 01                        sta 1,x
002302r 3               
002302r 3  60           z_negate:       rts
002303r 3               
002303r 3               
002303r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
002303r 3               ; ## "never-native"  auto  Tali Forth
002303r 3               xt_never_native:
002303r 3  20 rr rr                     jsr current_to_dp
002306r 3  A0 01                        ldy #1          ; offset for status byte
002308r 3  B1 02                        lda (dp),y
00230Ar 3  09 08                        ora #NN         ; Make sure NN flag is set
00230Cr 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
00230Er 3  91 02                        sta (dp),y
002310r 3               z_never_native:
002310r 3  60                           rts
002311r 3               
002311r 3               
002311r 3               ; ## NIP ( b a -- a ) "Delete NOS"
002311r 3               ; ## "nip"  auto  ANS core ext
002311r 3                       ; """https://forth-standard.org/standard/core/NIP"""
002311r 3               xt_nip:
002311r 3  20 rr rr                     jsr underflow_2
002314r 3               
002314r 3  B5 00                        lda 0,x         ; LSB
002316r 3  95 02                        sta 2,x
002318r 3  B5 01                        lda 1,x         ; MSB
00231Ar 3  95 03                        sta 3,x
00231Cr 3               
00231Cr 3  E8                           inx
00231Dr 3  E8                           inx
00231Er 3               
00231Er 3  60           z_nip:          rts
00231Fr 3               
00231Fr 3               
00231Fr 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
00231Fr 3               ; ## "<>"  auto  ANS core ext
00231Fr 3                       ; """https://forth-standard.org/standard/core/ne
00231Fr 3                       ;
00231Fr 3                       ; This is just a variant of EQUAL, we code it separately
00231Fr 3                       ; for speed.
00231Fr 3                       ; """
00231Fr 3               
00231Fr 3               xt_not_equals:
00231Fr 3  20 rr rr                     jsr underflow_2
002322r 3               
002322r 3  A0 00                        ldy #0                  ; default is true
002324r 3               
002324r 3  B5 00                        lda 0,x                 ; LSB
002326r 3  D5 02                        cmp 2,x
002328r 3  D0 0A                        bne @not_equal
00232Ar 3               
00232Ar 3                               ; LSB is equal
00232Ar 3  B5 01                        lda 1,x                 ; MSB
00232Cr 3  D5 03                        cmp 3,x
00232Er 3  D0 04                        bne @not_equal
002330r 3               
002330r 3  A9 FF                        lda #$FF
002332r 3  80 01                        bra @done
002334r 3               
002334r 3               @not_equal:
002334r 3  88                           dey                     ; drop thru to done
002335r 3               
002335r 3               @done:
002335r 3  98                           tya
002336r 3  E8                           inx
002337r 3  E8                           inx
002338r 3  95 00                        sta 0,x
00233Ar 3  95 01                        sta 1,x
00233Cr 3               
00233Cr 3  60           z_not_equals:   rts
00233Dr 3               
00233Dr 3               
00233Dr 3               
00233Dr 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
00233Dr 3               ; ## "-rot"  auto  Gforth
00233Dr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
00233Dr 3               
00233Dr 3               xt_not_rote:
00233Dr 3  20 rr rr                     jsr underflow_3
002340r 3               
002340r 3  B4 01                        ldy 1,x         ; MSB first
002342r 3  B5 03                        lda 3,x
002344r 3  95 01                        sta 1,x
002346r 3               
002346r 3  B5 05                        lda 5,x
002348r 3  95 03                        sta 3,x
00234Ar 3  94 05                        sty 5,x
00234Cr 3               
00234Cr 3  B4 00                        ldy 0,x         ; LSB second
00234Er 3  B5 02                        lda 2,x
002350r 3  95 00                        sta 0,x
002352r 3               
002352r 3  B5 04                        lda 4,x
002354r 3  95 02                        sta 2,x
002356r 3  94 04                        sty 4,x
002358r 3               
002358r 3  60           z_not_rote:     rts
002359r 3               
002359r 3               
002359r 3               
002359r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
002359r 3               ; ## "number"  auto  Tali Forth
002359r 3                       ; """Convert a number string to a double or single cell number. This
002359r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
002359r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
002359r 3                       ; Based in part on the "Starting Forth" code
002359r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
002359r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
002359r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
002359r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
002359r 3                       ; dot to signal a double cell number is required to be the last
002359r 3                       ; character of the string.
002359r 3                       ;
002359r 3                       ; Number calls >NUMBER which in turn calls UM*,
002359r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
002359r 3                       ; a pain.
002359r 3                       ;"""
002359r 3               
002359r 3               xt_number:
002359r 3  20 rr rr                     jsr underflow_2
00235Cr 3               
00235Cr 3                               ; we keep the flags for sign and double in tmpdsp because
00235Cr 3                               ; we've run out of temporary variables
00235Cr 3  64 2A                        stz tmpdsp      ; flag for double
00235Er 3  64 2B                        stz tmpdsp+1    ; flag for minus
002360r 3               
002360r 3                               ; If the first character is a minus, strip it off and set
002360r 3                               ; the flag
002360r 3  A1 02                        lda (2,x)
002362r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
002364r 3  D0 0A                        bne @check_dot
002366r 3               
002366r 3                               ; It's a minus
002366r 3  C6 2B                        dec tmpdsp+1
002368r 3  F6 02                        inc 2,x         ; start one character later
00236Ar 3  D0 02                        bne @1
00236Cr 3  F6 03                        inc 3,x
00236Er 3               @1:
00236Er 3  D6 00                        dec 0,x         ; decrease string length by one
002370r 3               
002370r 3               @check_dot:
002370r 3                               ; If the last character is a dot, strip it off and set a
002370r 3                               ; flag. We can use tmptos as a temporary variable
002370r 3  B5 02                        lda 2,x         ; LSB of address
002372r 3  18                           clc
002373r 3  75 00                        adc 0,x         ; length of string
002375r 3  85 2C                        sta tmptos
002377r 3  B5 03                        lda 3,x
002379r 3  69 00                        adc #0          ; only need carry
00237Br 3  85 2D                        sta tmptos+1
00237Dr 3               
00237Dr 3                               ; tmptos now points to the first character after the string,
00237Dr 3                               ; but we need the last character
00237Dr 3  A5 2C                        lda tmptos
00237Fr 3  D0 02                        bne @2
002381r 3  C6 2D                        dec tmptos+1
002383r 3               @2:
002383r 3  C6 2C                        dec tmptos
002385r 3               
002385r 3  B2 2C                        lda (tmptos)
002387r 3  C9 2E                        cmp #'.'
002389r 3  D0 04                        bne @main
00238Br 3               
00238Br 3                               ; We have a dot, which means this is a double number. Flag
00238Br 3                               ; the fact and reduce string length by one
00238Br 3  C6 2A                        dec tmpdsp
00238Dr 3  D6 00                        dec 0,x
00238Fr 3               
00238Fr 3               @main:
00238Fr 3                               ; Set up stack for subroutine jump to >NUMBER, which means
00238Fr 3                               ; we have to go ( addr u --> ud addr u )
00238Fr 3  CA                           dex
002390r 3  CA                           dex
002391r 3  CA                           dex
002392r 3  CA                           dex
002393r 3               
002393r 3  B5 04                        lda 4,x         ; LSB of length
002395r 3  95 00                        sta 0,x
002397r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
002399r 3               
002399r 3  B5 06                        lda 6,x         ; LSB of address
00239Br 3  95 02                        sta 2,x
00239Dr 3  B5 07                        lda 7,x         ; MSB of address
00239Fr 3  95 03                        sta 3,x
0023A1r 3               
0023A1r 3  74 04                        stz 4,x         ; clear space for ud
0023A3r 3  74 05                        stz 5,x
0023A5r 3  74 06                        stz 6,x
0023A7r 3  74 07                        stz 7,x
0023A9r 3               
0023A9r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
0023ACr 3               
0023ACr 3                               ; test length of returned string, which should be zero
0023ACr 3  B5 00                        lda 0,x
0023AEr 3  F0 15                        beq @all_converted
0023B0r 3               
0023B0r 3                               ; Something went wrong, we still have characters left over,
0023B0r 3                               ; so we print an error and abort. If the NUMBER was called
0023B0r 3                               ; by INTERPRET, we've already checked for Forth words, so
0023B0r 3                               ; we're in deep trouble one way or another
0023B0r 3  A9 3E                        lda #$3E        ; ASCII for ">"
0023B2r 3  20 rr rr                     jsr emit_a
0023B5r 3  20 rr rr                     jsr xt_type
0023B8r 3  A9 3C                        lda #$3C        ; ASCII for "<"
0023BAr 3  20 rr rr                     jsr emit_a
0023BDr 3  20 rr rr                     jsr xt_space
0023C0r 3               
0023C0r 3  A9 08                        lda #err_syntax
0023C2r 3  4C rr rr                     jmp error
0023C5r 3               
0023C5r 3               @all_converted:
0023C5r 3                               ; We can drop the string info
0023C5r 3  E8                           inx
0023C6r 3  E8                           inx
0023C7r 3  E8                           inx
0023C8r 3  E8                           inx
0023C9r 3               
0023C9r 3                               ; We have a double-cell number on the Data Stack that might
0023C9r 3                               ; actually have a minus and might actually be single-cell
0023C9r 3  A5 2A                        lda tmpdsp      ; flag for double
0023CBr 3  F0 0D                        beq @single
0023CDr 3               
0023CDr 3                               ; Set status bit 5 to indicate this is a double number
0023CDr 3  A9 20                        lda #%00100000
0023CFr 3  04 20                        tsb status
0023D1r 3               
0023D1r 3                               ; This is a double cell number. If it had a minus, we'll have
0023D1r 3                               ; to negate it
0023D1r 3  A5 2B                        lda tmpdsp+1
0023D3r 3  F0 12                        beq @done       ; no minus, all done
0023D5r 3               
0023D5r 3  20 rr rr                     jsr xt_dnegate
0023D8r 3               
0023D8r 3  80 0D                        bra @done
0023DAr 3               
0023DAr 3               @single:
0023DAr 3                               ; This is a single number, so we just drop the top cell
0023DAr 3  E8                           inx
0023DBr 3  E8                           inx
0023DCr 3               
0023DCr 3                               ; Clear status bit 5 to indicate this is a single number
0023DCr 3  A9 20                        lda #%00100000
0023DEr 3  14 20                        trb status
0023E0r 3               
0023E0r 3                               ; If we had a minus, we'll have to negate it
0023E0r 3  A5 2B                        lda tmpdsp+1
0023E2r 3  F0 03                        beq @done       ; no minus, all done
0023E4r 3               
0023E4r 3  20 rr rr                     jsr xt_negate
0023E7r 3               @done:
0023E7r 3  60           z_number:       rts
0023E8r 3               
0023E8r 3               
0023E8r 3               
0023E8r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
0023E8r 3               ; ## "#"  auto  ANS core
0023E8r 3                       ; """https://forth-standard.org/standard/core/num
0023E8r 3                       ; Add one char to the beginning of the pictured output string.
0023E8r 3                       ;
0023E8r 3                       ; Based on
0023E8r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0023E8r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
0023E8r 3                       ; """
0023E8r 3               xt_number_sign:
0023E8r 3  20 rr rr                     jsr underflow_2         ; double number
0023EBr 3               
0023EBr 3  20 rr rr                     jsr xt_base
0023EEr 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
0023F1r 3               
0023F1r 3                               ; The following code is the ancient Forth word UD/MOD, which in
0023F1r 3                               ; various Forths (including Gforth) lives on under the hood,
0023F1r 3                               ; even though it's not an ANS standard word, it doesn't appear
0023F1r 3                               ; in the docs, it's only used here, and there are no tests for
0023F1r 3                               ; it. This is why we got rid of it. We'll be converting this
0023F1r 3                               ; mess to something more sane in the long run.
0023F1r 3  20 rr rr                     jsr xt_to_r             ; >r
0023F4r 3  20 rr rr                     jsr xt_zero             ; 0
0023F7r 3  20 rr rr                     jsr xt_r_fetch          ; r@
0023FAr 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
0023FDr 3  20 rr rr                     jsr xt_rot              ; rot
002400r 3  20 rr rr                     jsr xt_rot              ; rot
002403r 3  20 rr rr                     jsr xt_r_from           ; r>
002406r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
002409r 3  20 rr rr                     jsr xt_rot              ; rot
00240Cr 3                               ; end of UD/MOD ( rem ud )
00240Cr 3               
00240Cr 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
00240Fr 3               
00240Fr 3                               ; Convert the number that is left over to an ASCII character. We
00240Fr 3                               ; use a string lookup for speed. Use either abc_str_lower for
00240Fr 3                               ; lower case or abc_str_upper for upper case (prefered)
00240Fr 3  B5 00                        lda 0,x
002411r 3  A8                           tay
002412r 3  B9 rr rr                     lda s_abc_upper,y
002415r 3  95 00                        sta 0,x
002417r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
002419r 3               
002419r 3  20 rr rr                     jsr xt_hold
00241Cr 3               
00241Cr 3               z_number_sign:
00241Cr 3  60                           rts
00241Dr 3               
00241Dr 3               
00241Dr 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
00241Dr 3               ; ## "#>"  auto  ANS core
00241Dr 3                       ; """https://forth-standard.org/standard/core/num-end
00241Dr 3                       ; Finish conversion of pictured number string, putting address and
00241Dr 3                       ; length on the Data Stack.
00241Dr 3                       ;
00241Dr 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
00241Dr 3                       ; Based on
00241Dr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00241Dr 3                       ; """
00241Dr 3               xt_number_sign_greater:
00241Dr 3               
00241Dr 3  20 rr rr                     jsr underflow_2         ; double number
002420r 3               
002420r 3                               ; The start address lives in tohold
002420r 3  A5 34                        lda tohold
002422r 3  95 00                        sta 0,x         ; LSB of tohold
002424r 3  95 02                        sta 2,x
002426r 3  A5 35                        lda tohold+1
002428r 3  95 01                        sta 1,x         ; MSB of addr
00242Ar 3  95 03                        sta 3,x         ; ( addr addr )
00242Cr 3               
00242Cr 3                               ; The length of the string is pad - addr
00242Cr 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
00242Fr 3               
00242Fr 3  38                           sec
002430r 3  B5 00                        lda 0,x         ; LSB of pad address
002432r 3  F5 02                        sbc 2,x
002434r 3  95 02                        sta 2,x
002436r 3               
002436r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
002438r 3  F5 03                        sbc 3,x
00243Ar 3  95 03                        sta 3,x         ; ( addr u pad )
00243Cr 3               
00243Cr 3  E8                           inx
00243Dr 3  E8                           inx
00243Er 3               
00243Er 3               z_number_sign_greater:
00243Er 3  60                           rts
00243Fr 3               
00243Fr 3               
00243Fr 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
00243Fr 3               ; ## "#s"  auto  ANS core
00243Fr 3                       ; """https://forth-standard.org/standard/core/numS
00243Fr 3                       ; Completely convert number for pictured numerical output.
00243Fr 3                       ;
00243Fr 3                       ; Based on
00243Fr 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
00243Fr 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
00243Fr 3                       ; """
00243Fr 3               
00243Fr 3               xt_number_sign_s:
00243Fr 3  20 rr rr                     jsr underflow_2
002442r 3               @loop:
002442r 3                               ; convert a single number ("#")
002442r 3  20 rr rr                     jsr xt_number_sign
002445r 3               
002445r 3                               ; stop when double-celled number in TOS is zero:
002445r 3  B5 00                        lda 0,x
002447r 3  15 01                        ora 1,x
002449r 3  15 02                        ora 2,x
00244Br 3  15 03                        ora 3,x
00244Dr 3  D0 F3                        bne @loop
00244Fr 3               
00244Fr 3               z_number_sign_s:
00244Fr 3  60                           rts
002450r 3               
002450r 3               
002450r 3               
002450r 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
002450r 3               ; ## "of"  auto  ANS core ext
002450r 3                       ; """http://forth-standard.org/standard/core/OF"""
002450r 3               
002450r 3               xt_of:
002450r 3                               ; Check if value is equal to this case.
002450r 3                               ; Postpone over (eg. compile a jsr to it)
002450r 3  A0 rr                        ldy #>xt_over
002452r 3  A9 rr                        lda #<xt_over
002454r 3  20 rr rr                     jsr cmpl_subroutine
002457r 3               
002457r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
002457r 3  A0 rr                        ldy #>xt_equal
002459r 3  A9 rr                        lda #<xt_equal
00245Br 3  20 rr rr                     jsr cmpl_subroutine
00245Er 3               
00245Er 3  20 rr rr                     jsr xt_if
002461r 3               
002461r 3                               ; If it's true, consume the original value.
002461r 3                               ; Postpone DROP (eg. compile a jsr to it)
002461r 3  A0 rr                        ldy #>xt_drop
002463r 3  A9 rr                        lda #<xt_drop
002465r 3  20 rr rr                     jsr cmpl_subroutine
002468r 3               
002468r 3  60           z_of:           rts
002469r 3               
002469r 3               
002469r 3               
002469r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
002469r 3               ; ## "1"  auto  Tali Forth
002469r 3                       ; """This is also the code for EDITOR-WORDLIST"""
002469r 3               xt_editor_wordlist:
002469r 3               xt_one:
002469r 3  CA                           dex
00246Ar 3  CA                           dex
00246Br 3  A9 01                        lda #1
00246Dr 3  95 00                        sta 0,x
00246Fr 3  74 01                        stz 1,x
002471r 3               
002471r 3               z_editor_wordlist:
002471r 3               z_one:
002471r 3  60                           rts
002472r 3               
002472r 3               
002472r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
002472r 3               ; ## "1-"  auto  ANS core
002472r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
002472r 3               
002472r 3               xt_one_minus:
002472r 3  20 rr rr                     jsr underflow_1
002475r 3               
002475r 3  B5 00                        lda 0,x
002477r 3  D0 02                        bne @1
002479r 3  D6 01                        dec 1,x
00247Br 3               @1:
00247Br 3  D6 00                        dec 0,x
00247Dr 3               
00247Dr 3  60           z_one_minus:    rts
00247Er 3               
00247Er 3               
00247Er 3               
00247Er 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
00247Er 3               ; ## "1+"  auto  ANS core
00247Er 3                       ; """https://forth-standard.org/standard/core/OnePlus
00247Er 3                       ;
00247Er 3                       ; Code is shared with CHAR-PLUS
00247Er 3                       ; """
00247Er 3               
00247Er 3               xt_char_plus:
00247Er 3               xt_one_plus:
00247Er 3  20 rr rr                     jsr underflow_1
002481r 3               
002481r 3  F6 00                        inc 0,x
002483r 3  D0 02                        bne @done
002485r 3  F6 01                        inc 1,x
002487r 3               
002487r 3               @done:
002487r 3               z_char_plus:
002487r 3  60           z_one_plus:     rts
002488r 3               
002488r 3               
002488r 3               
002488r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
002488r 3               ; ## "only"  auto  ANS search ext
002488r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
002488r 3               
002488r 3               xt_only:
002488r 3                               ; Put -1 on data stack.
002488r 3  CA                           dex
002489r 3  CA                           dex
00248Ar 3  A9 FF                        lda #$FF
00248Cr 3  95 00                        sta 0,x
00248Er 3  95 01                        sta 1,x
002490r 3               
002490r 3                               ; Invoke set-order to set the minimum search order.
002490r 3  20 rr rr                     jsr xt_set_order
002493r 3               
002493r 3  60           z_only:         rts
002494r 3               
002494r 3               
002494r 3               
002494r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
002494r 3               ; ## "or"  auto  ANS core
002494r 3                       ; """https://forth-standard.org/standard/core/OR"
002494r 3               xt_or:
002494r 3  20 rr rr                     jsr underflow_2
002497r 3               
002497r 3  B5 00                        lda 0,x
002499r 3  15 02                        ora 2,x
00249Br 3  95 02                        sta 2,x
00249Dr 3               
00249Dr 3  B5 01                        lda 1,x
00249Fr 3  15 03                        ora 3,x
0024A1r 3  95 03                        sta 3,x
0024A3r 3               
0024A3r 3  E8                           inx
0024A4r 3  E8                           inx
0024A5r 3               
0024A5r 3  60           z_or:           rts
0024A6r 3               
0024A6r 3               
0024A6r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
0024A6r 3               ; ## "order"  auto  ANS core
0024A6r 3                       ; """https://forth-standard.org/standard/search/ORDER
0024A6r 3                       ; Note the search order is displayed from first search to last
0024A6r 3                       ; searched and is therefore exactly the reverse of the order in which
0024A6r 3                       ; Forth stacks are displayed.
0024A6r 3                       ;
0024A6r 3                       ; A Forth implementation of this word is:
0024A6r 3                       ;
0024A6r 3                       ; 	: .wid ( wid -- )
0024A6r 3                       ; 	dup 0=  if ." Forth "  drop    else
0024A6r 3                       ; 	dup 1 = if ." Editor " drop    else
0024A6r 3                       ; 	dup 2 = if ." Assembler " drop else
0024A6r 3                       ; 	dup 3 = if ." Root " drop      else
0024A6r 3                       ; 	           . ( just print the number )
0024A6r 3                       ; 	then then then then ;
0024A6r 3                       ;
0024A6r 3                       ; : ORDER ( -- )
0024A6r 3                       ; 	cr get-order 0 ?do .wid loop
0024A6r 3                       ; 	space space get-current .wid ;
0024A6r 3                       ;
0024A6r 3                       ; This is an interactive program, so speed
0024A6r 3                       ; is not as important as size. We assume we do not have more than 255
0024A6r 3                       ; wordlists.
0024A6r 3                       ; """
0024A6r 3               
0024A6r 3               xt_order:
0024A6r 3  20 rr rr                     jsr xt_cr
0024A9r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
0024ACr 3               
0024ACr 3                               ; Paranoid: Check if there are no wordlists, a rather
0024ACr 3                               ; pathological case. this would mean ( 0 ) on the stack. In
0024ACr 3                               ; that case, we just drop n and run
0024ACr 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
0024AEr 3  F0 1E                        beq @drop_done
0024B0r 3               
0024B0r 3               @have_wordlists:
0024B0r 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
0024B0r 3                               ; on the stack
0024B0r 3  A8                           tay
0024B1r 3               @loop:
0024B1r 3  E8                           inx
0024B2r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
0024B3r 3  B5 00                        lda 0,x
0024B5r 3               
0024B5r 3  5A                           phy
0024B6r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
0024B9r 3  7A                           ply
0024BAr 3               
0024BAr 3  88                           dey
0024BBr 3  D0 F4                        bne @loop
0024BDr 3               
0024BDr 3                               ; We've printed the wordlists, now we add the current wordlist.
0024BDr 3                               ; This follows the convention of Gforth
0024BDr 3  20 rr rr                     jsr xt_space
0024C0r 3  20 rr rr                     jsr xt_space
0024C3r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
0024C6r 3               
0024C6r 3  B5 00                        lda 0,x
0024C8r 3  20 rr rr                     jsr _print_wid_string
0024CBr 3  20 rr rr                     jsr xt_cr
0024CEr 3               
0024CEr 3               @drop_done:
0024CEr 3  E8                           inx
0024CFr 3  E8                           inx
0024D0r 3               z_order:
0024D0r 3  60                           rts
0024D1r 3               
0024D1r 3               _print_wid_string:
0024D1r 3                       ; """Helper function for ORDER: Given a WID in A, print the
0024D1r 3                       ; corresponding string. If there is no such word list defined, just
0024D1r 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
0024D1r 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
0024D1r 3                       ; theory, we could speed this up by having the WID be the same as the
0024D1r 3                       ; number of the strings. However, ORDER is used rather infrequently and
0024D1r 3                       ; this would make changes to the strings.asm file very dangerous, so we
0024D1r 3                       ; follow the slightly more complicated route with a translation table.
0024D1r 3                       ; """
0024D1r 3                               ; If the WID is larger than 3, we have no string avaliable and
0024D1r 3                               ; just print the number.
0024D1r 3                               ; See http://6502.org/tutorials/compare_instructions.html
0024D1r 3                               ; for details
0024D1r 3  C9 04                        cmp #4
0024D3r 3  90 09                        bcc @output_string      ; less than 4, print a real string
0024D5r 3               
0024D5r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
0024D5r 3                               ; print the number
0024D5r 3  CA                           dex
0024D6r 3  CA                           dex
0024D7r 3  95 00                        sta 0,x
0024D9r 3  74 01                        stz 1,x
0024DBr 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
0024DEr 3               
0024DEr 3               @output_string:
0024DEr 3                               ; Get the string number based on WID 0 to 3
0024DEr 3  A8                           tay
0024DFr 3  B9 rr rr                     lda @wid_data,y
0024E2r 3               
0024E2r 3                               ; Print without a line feed
0024E2r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
0024E5r 3               
0024E5r 3               @wid_data:
0024E5r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
0024E5r 3                       ; less than 4.
0024E5r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
0024E6r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
0024E7r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
0024E8r 3  08                   .byte str_wid_root             ; WID 3: "Root"
0024E9r 3               
0024E9r 3               
0024E9r 3               
0024E9r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
0024E9r 3               ; ## "output"  tested  Tali Forth
0024E9r 3               xt_output:
0024E9r 3                       ; """Return the address where the jump target for EMIT is stored (but
0024E9r 3                       ; not the vector itself). By default, this will hold the value of
0024E9r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
0024E9r 3                       ; routine.
0024E9r 3                       ; """
0024E9r 3  CA                           dex
0024EAr 3  CA                           dex
0024EBr 3  A9 10                        lda #<output
0024EDr 3  95 00                        sta 0,x
0024EFr 3  A9 00                        lda #>output
0024F1r 3  95 01                        sta 1,x
0024F3r 3               
0024F3r 3  60           z_output:       rts
0024F4r 3               
0024F4r 3               
0024F4r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
0024F4r 3               ; ## "over"  auto  ANS core
0024F4r 3                       ; """https://forth-standard.org/standard/core/OVER"""
0024F4r 3               xt_over:
0024F4r 3  20 rr rr                     jsr underflow_2
0024F7r 3               
0024F7r 3  CA                           dex
0024F8r 3  CA                           dex
0024F9r 3               
0024F9r 3  B5 04                        lda 4,x         ; LSB
0024FBr 3  95 00                        sta 0,x
0024FDr 3  B5 05                        lda 5,x         ; MSB
0024FFr 3  95 01                        sta 1,x
002501r 3               
002501r 3  60           z_over:         rts
002502r 3               
002502r 3               
002502r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
002502r 3               ; ## "pad"  auto  ANS core ext
002502r 3                       ; """https://forth-standard.org/standard/core/PAD
002502r 3                       ; Return address to a temporary area in free memory for user. Must
002502r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
002502r 3                       ; the compile area pointer (CP) and therefore varies in position.
002502r 3                       ; This area is reserved for the user and not used by the system
002502r 3                       ; """
002502r 3               xt_pad:
002502r 3  CA                           dex
002503r 3  CA                           dex
002504r 3               
002504r 3  A5 00                        lda cp
002506r 3  18                           clc
002507r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
002509r 3  95 00                        sta 0,x
00250Br 3               
00250Br 3  A5 01                        lda cp+1
00250Dr 3  69 00                        adc #0          ; only need carry
00250Fr 3  95 01                        sta 1,x
002511r 3               
002511r 3  60           z_pad:          rts
002512r 3               
002512r 3               
002512r 3               ; ## PAGE ( -- ) "Clear the screen"
002512r 3               ; ## "page"  tested  ANS facility
002512r 3                       ; """https://forth-standard.org/standard/facility/PAGE
002512r 3                       ; Clears a page if supported by ANS terminal codes. This is
002512r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
002512r 3                       ; left of the screen
002512r 3                       ; """
002512r 3               xt_page:
002512r 3  A9 1B                        lda #AscESC
002514r 3  20 rr rr                     jsr emit_a
002517r 3  A9 5B                        lda #$5B        ; ASCII for "["
002519r 3  20 rr rr                     jsr emit_a
00251Cr 3  A9 32                        lda #'2'
00251Er 3  20 rr rr                     jsr emit_a
002521r 3  A9 4A                        lda #'J'
002523r 3  20 rr rr                     jsr emit_a
002526r 3               
002526r 3                               ; move cursor to top left of screen
002526r 3  20 rr rr                     jsr xt_zero
002529r 3  20 rr rr                     jsr xt_zero
00252Cr 3  20 rr rr                     jsr xt_at_xy
00252Fr 3               
00252Fr 3  60           z_page:         rts
002530r 3               
002530r 3               
002530r 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
002530r 3               ; ## "("  auto  ANS core
002530r 3                       ; """http://forth-standard.org/standard/core/p"""
002530r 3               
002530r 3               xt_paren:
002530r 3                               ; Put a right paren on the stack.
002530r 3  CA                           dex
002531r 3  CA                           dex
002532r 3  A9 29                        lda #41     ; Right parenthesis
002534r 3  95 00                        sta 0,x
002536r 3  74 01                        stz 1,x
002538r 3               
002538r 3                               ; Call parse.
002538r 3  20 rr rr                     jsr xt_parse
00253Br 3               
00253Br 3                               ; Throw away the result.
00253Br 3  E8                           inx
00253Cr 3  E8                           inx
00253Dr 3  E8                           inx
00253Er 3  E8                           inx
00253Fr 3               
00253Fr 3  60           z_paren:        rts
002540r 3               
002540r 3               
002540r 3               
002540r 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
002540r 3               ; ## "parse-name"  auto  ANS core ext
002540r 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
002540r 3                       ; Find next word in input string, skipping leading whitespace. This is
002540r 3                       ; a special form of PARSE and drops through to that word. See PARSE
002540r 3                       ; for more detail. We use this word internally for the interpreter
002540r 3                       ; because it is a lot easier to use. Reference implementations at
002540r 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
002540r 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
002540r 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
002540r 3                       ; though the ANS standard talks about skipping "spaces", whitespace
002540r 3                       ; is actually perfectly legal (see for example
002540r 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
002540r 3                       ; Otherwise, PARSE-NAME chokes on tabs.
002540r 3                       ; """
002540r 3               
002540r 3               xt_parse_name:
002540r 3                               ; To enable the compilation of the high-level Forth words
002540r 3                               ; in forth-words.asm and user-words.asm at boot time,
002540r 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
002540r 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
002540r 3                               ; to the current location is in toin (>IN). We need to check,
002540r 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
002540r 3                               ; we can't just use Y as an index.
002540r 3               
002540r 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
002540r 3  A5 0A                        lda ciblen              ; LSB of counter
002542r 3  38                           sec
002543r 3  E5 0C                        sbc toin
002545r 3  85 24                        sta tmp1
002547r 3  A5 0B                        lda ciblen+1            ; MSB
002549r 3  E5 0D                        sbc toin+1
00254Br 3  85 25                        sta tmp1+1
00254Dr 3               
00254Dr 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
00254Dr 3  A5 24                        lda tmp1
00254Fr 3  05 25                        ora tmp1+1
002551r 3  F0 28                        beq @empty_line
002553r 3               
002553r 3                               ; We walk through the characters starting at CIB+TOIN, so we
002553r 3                               ; save a temp version of that in tmp2
002553r 3  A5 08                        lda cib
002555r 3  18                           clc
002556r 3  65 0C                        adc toin
002558r 3  85 26                        sta tmp2                ; LSB of first character
00255Ar 3  A5 09                        lda cib+1
00255Cr 3  65 0D                        adc toin+1
00255Er 3  85 27                        sta tmp2+1              ; MSB
002560r 3               
002560r 3               @skip_loop:
002560r 3  B2 26                        lda (tmp2)              ; work copy of cib
002562r 3  20 rr rr                     jsr is_whitespace
002565r 3  90 1F                        bcc @char_found
002567r 3               
002567r 3                               ; Char is still whitespace, continue
002567r 3  E6 26                        inc tmp2
002569r 3  D0 02                        bne @2
00256Br 3  E6 27                        inc tmp2+1
00256Dr 3               @2:
00256Dr 3                               ; Adjust counter
00256Dr 3  A5 24                        lda tmp1
00256Fr 3  D0 02                        bne @3
002571r 3  C6 25                        dec tmp1+1
002573r 3               @3:
002573r 3  C6 24                        dec tmp1
002575r 3               
002575r 3  A5 24                        lda tmp1
002577r 3  05 25                        ora tmp1+1
002579r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
00257Br 3               
00257Br 3               @empty_line:
00257Br 3                               ; Neither the ANS Forth nor the Gforth documentation say
00257Br 3                               ; what to return as an address if a string with only
00257Br 3                               ; spaces is given. For speed reasons, we just return junk
00257Br 3                               ; NOS, with the TOS zero as per standard
00257Br 3  CA                           dex
00257Cr 3  CA                           dex
00257Dr 3  CA                           dex
00257Er 3  CA                           dex
00257Fr 3               
00257Fr 3  74 00                        stz 0,x                 ; TOS is zero
002581r 3  74 01                        stz 1,x
002583r 3               
002583r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
002586r 3               
002586r 3               @char_found:
002586r 3                               ; We arrive here with tmp2 pointing to the first non-space
002586r 3                               ; character. This is where the word really starts, so
002586r 3                               ; we use it to calculate the new >IN by subtracting
002586r 3  A5 26                        lda tmp2
002588r 3  38                           sec
002589r 3  E5 08                        sbc cib
00258Br 3  85 0C                        sta toin
00258Dr 3  A5 27                        lda tmp2+1
00258Fr 3  E5 09                        sbc cib+1
002591r 3  85 0D                        sta toin+1
002593r 3               
002593r 3                               ; prepare Data Stack for PARSE by adding space
002593r 3                               ; as the delimiter
002593r 3  CA                           dex
002594r 3  CA                           dex
002595r 3               
002595r 3  A9 20                        lda #AscSP
002597r 3  95 00                        sta 0,x
002599r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
00259Br 3               
00259Br 3               
00259Br 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
00259Br 3               ; ## "parse"  tested  ANS core ext
00259Br 3                       ; """https://forth-standard.org/standard/core/PARSE
00259Br 3                       ; Find word in input string delimited by character given. Do not
00259Br 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
00259Br 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
00259Br 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
00259Br 3                       ;
00259Br 3                       ;
00259Br 3                       ;     cib  cib+toin   cib+ciblen
00259Br 3                       ;      v      v            v
00259Br 3                       ;     |###################|
00259Br 3                       ;
00259Br 3                       ;     |------>|  toin (>IN)
00259Br 3                       ;     |------------------->|  ciblen
00259Br 3                       ;
00259Br 3                       ; The input string is stored starting at the address in the Current
00259Br 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
00259Br 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
00259Br 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
00259Br 3                       ; useful string if there are any characters at all. As with
00259Br 3                       ; PARSE-NAME, we must be able to handle strings with a length of
00259Br 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
00259Br 3                       ; """
00259Br 3               
00259Br 3               xt_parse:
00259Br 3  20 rr rr                     jsr underflow_1
00259Er 3               
00259Er 3                               ; If the input buffer is empty, we just return
00259Er 3  A5 0A                        lda ciblen
0025A0r 3  05 0B                        ora ciblen+1
0025A2r 3  F0 0C                        beq @abort_parse
0025A4r 3               
0025A4r 3                               ; If the pointer >IN is larger or equal to the length of
0025A4r 3                               ; the input buffer (CIBLEN), the line is done. Put
0025A4r 3                               ; differently, we only continue if >IN is smaller than
0025A4r 3                               ; CIBLEN
0025A4r 3  A5 0D                        lda toin+1              ; MSB
0025A6r 3  C5 0B                        cmp ciblen+1
0025A8r 3  90 0E                        bcc @go_parse           ; unsigned comparison
0025AAr 3               
0025AAr 3  A5 0C                        lda toin                ; LSB
0025ACr 3  C5 0A                        cmp ciblen
0025AEr 3  90 08                        bcc @go_parse
0025B0r 3               
0025B0r 3               @abort_parse:
0025B0r 3                               ; Sorry, this line is over
0025B0r 3  CA                           dex
0025B1r 3  CA                           dex
0025B2r 3  74 00                        stz 0,x
0025B4r 3  74 01                        stz 1,x
0025B6r 3               
0025B6r 3  80 7A                        bra @done
0025B8r 3               @go_parse:
0025B8r 3                               ; We actually have work to do. Save the delimiter in
0025B8r 3                               ; tmptos.
0025B8r 3  B5 00                        lda 0,x
0025BAr 3  85 2C                        sta tmptos
0025BCr 3               
0025BCr 3                               ; We can now prepare the Data Stack for the return value
0025BCr 3  CA                           dex
0025BDr 3  CA                           dex
0025BEr 3               
0025BEr 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
0025BEr 3                               ; tmp2 is initially the same as tmp1, then the work index
0025BEr 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
0025BEr 3               
0025BEr 3                               ; Calculate the beginning of the string, which is also the
0025BEr 3                               ; address to return
0025BEr 3  A5 08                        lda cib
0025C0r 3  18                           clc
0025C1r 3  65 0C                        adc toin        ; LSB
0025C3r 3  85 24                        sta tmp1
0025C5r 3  85 26                        sta tmp2
0025C7r 3  95 02                        sta 2,x
0025C9r 3               
0025C9r 3  A5 09                        lda cib+1
0025CBr 3  65 0D                        adc toin+1      ; MSB
0025CDr 3  85 25                        sta tmp1+1
0025CFr 3  85 27                        sta tmp2+1
0025D1r 3  95 03                        sta 3,x
0025D3r 3               
0025D3r 3                               ; Calculate the address where the input buffer ends plus 1, so
0025D3r 3                               ; we can compare it with TOIN, which is an index
0025D3r 3  A5 08                        lda cib
0025D5r 3  18                           clc
0025D6r 3  65 0A                        adc ciblen
0025D8r 3  85 28                        sta tmp3
0025DAr 3  A5 09                        lda cib+1
0025DCr 3  65 0B                        adc ciblen+1
0025DEr 3  85 29                        sta tmp3+1
0025E0r 3               
0025E0r 3                               ; Initialize the offset we use to adjust EOL or found delimiter
0025E0r 3  64 2D                        stz tmptos+1
0025E2r 3               @loop:
0025E2r 3                               ; If we are at the end of the string, quit
0025E2r 3  A5 26                        lda tmp2
0025E4r 3  C5 28                        cmp tmp3
0025E6r 3  D0 06                        bne @not_empty
0025E8r 3               
0025E8r 3  A5 27                        lda tmp2+1
0025EAr 3  C5 29                        cmp tmp3+1
0025ECr 3  F0 1D                        beq @eol
0025EEr 3               @not_empty:
0025EEr 3                               ; We have to do this the hard way. In fact, it's really
0025EEr 3                               ; hard since if we are dealing with a SPACE, the standard
0025EEr 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
0025EEr 3                               ; Tali would choke on tabs between words. For details, see
0025EEr 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
0025EEr 3                               ; In theory, we could make this faster by defining a delimiter
0025EEr 3                               ; that is 00 as the sign that we skip all whitespace, thereby
0025EEr 3                               ; avoiding having to test every time. However, somebody,
0025EEr 3                               ; somewhere might want to parse a zero-delimited list. Since
0025EEr 3                               ; any byte value could be chosen for that, we just test for
0025EEr 3                               ; a space every single time for the moment.
0025EEr 3  B2 26                        lda (tmp2)
0025F0r 3               
0025F0r 3  A4 2C                        ldy tmptos
0025F2r 3  C0 20                        cpy #AscSP
0025F4r 3  D0 07                        bne @not_whitespace
0025F6r 3               
0025F6r 3                               ; The delimiter is a space, so we're looking for all
0025F6r 3                               ; whitespace
0025F6r 3  20 rr rr                     jsr is_whitespace
0025F9r 3  90 02                        bcc @not_whitespace
0025FBr 3  80 0C                        bra @found_delimiter
0025FDr 3               
0025FDr 3               @not_whitespace:
0025FDr 3                               ; The delimiter is not a space, so we're looking for
0025FDr 3                               ; whatever it is
0025FDr 3  C5 2C                        cmp tmptos
0025FFr 3  F0 08                        beq @found_delimiter
002601r 3               
002601r 3                               ; Not a delimiter, next character
002601r 3  E6 26                        inc tmp2
002603r 3  D0 DD                        bne @loop
002605r 3  E6 27                        inc tmp2+1
002607r 3  80 D9                        bra @loop
002609r 3               
002609r 3               @found_delimiter:
002609r 3                               ; Increase the offset: If we've found a delimiter, we want
002609r 3                               ; TOIN to point to the character after it, not the delimiter
002609r 3                               ; itself
002609r 3  E6 2D                        inc tmptos+1
00260Br 3               @eol:
00260Br 3                               ; The length of the new string is tmp2-tmp1
00260Br 3  A5 26                        lda tmp2
00260Dr 3  38                           sec
00260Er 3  E5 24                        sbc tmp1
002610r 3  95 00                        sta 0,x
002612r 3               
002612r 3  A5 27                        lda tmp2+1
002614r 3  E5 25                        sbc tmp1+1
002616r 3  95 01                        sta 1,x
002618r 3               
002618r 3                               ; The new offset is tmp2-cib
002618r 3  A5 26                        lda tmp2
00261Ar 3  38                           sec
00261Br 3  E5 08                        sbc cib
00261Dr 3  85 0C                        sta toin
00261Fr 3  A5 27                        lda tmp2+1
002621r 3  E5 09                        sbc cib+1
002623r 3  85 0D                        sta toin+1
002625r 3               
002625r 3                               ; Add in the delimiter
002625r 3  A5 0C                        lda toin
002627r 3  18                           clc
002628r 3  65 2D                        adc tmptos+1
00262Ar 3  85 0C                        sta toin
00262Cr 3  A5 0D                        lda toin+1
00262Er 3  69 00                        adc #0          ; we only need the carry
002630r 3  85 0D                        sta toin+1
002632r 3               @done:
002632r 3               z_parse_name:
002632r 3  60           z_parse:        rts
002633r 3               
002633r 3               
002633r 3               
002633r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
002633r 3               ; ## "pick"  auto  ANS core ext
002633r 3                       ; """https://forth-standard.org/standard/core/PICK
002633r 3                       ; Take the u-th element out of the stack and put it on TOS,
002633r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
002633r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
002633r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
002633r 3                       ; """
002633r 3               
002633r 3               xt_pick:
002633r 3                               ; Checking for underflow is difficult because it depends on
002633r 3                               ; which element we want to grab. We could probably figure
002633r 3                               ; something out, but it wouldn't work with underflow stripping
002633r 3                               ; Since using PICK is considered poor form anyway, we just
002633r 3                               ; leave it as it is
002633r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
002635r 3  8A                           txa
002636r 3  75 00                        adc 0,x
002638r 3  A8                           tay
002639r 3               
002639r 3  B9 02 00                     lda 0002,y
00263Cr 3  95 00                        sta 0,x
00263Er 3  B9 03 00                     lda 0003,y
002641r 3  95 01                        sta 1,x
002643r 3               
002643r 3  60           z_pick:         rts
002644r 3               
002644r 3               
002644r 3               
002644r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
002644r 3               ; ## "+"  auto  ANS core
002644r 3                       ; """https://forth-standard.org/standard/core/Plus"""
002644r 3               xt_plus:
002644r 3  20 rr rr                     jsr underflow_2
002647r 3               
002647r 3  18                           clc
002648r 3  B5 00                        lda 0,x         ; LSB
00264Ar 3  75 02                        adc 2,x
00264Cr 3  95 02                        sta 2,x
00264Er 3               
00264Er 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
002650r 3  75 03                        adc 3,x
002652r 3  95 03                        sta 3,x
002654r 3               
002654r 3  E8                           inx
002655r 3  E8                           inx
002656r 3               
002656r 3  60           z_plus:         rts
002657r 3               
002657r 3               
002657r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
002657r 3               ; ## "+!"  auto  ANS core
002657r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
002657r 3               xt_plus_store:
002657r 3  20 rr rr                     jsr underflow_2
00265Ar 3               
00265Ar 3                               ; move address to tmp1 so we can work with it
00265Ar 3  B5 00                        lda 0,x
00265Cr 3  85 24                        sta tmp1
00265Er 3  B5 01                        lda 1,x
002660r 3  85 25                        sta tmp1+1
002662r 3               
002662r 3  A0 00                        ldy #0          ; LSB
002664r 3  B1 24                        lda (tmp1),y
002666r 3  18                           clc
002667r 3  75 02                        adc 2,x
002669r 3  91 24                        sta (tmp1),y
00266Br 3               
00266Br 3  C8                           iny             ; MSB
00266Cr 3  B1 24                        lda (tmp1),y
00266Er 3  75 03                        adc 3,x
002670r 3  91 24                        sta (tmp1),y
002672r 3               
002672r 3  E8                           inx
002673r 3  E8                           inx
002674r 3  E8                           inx
002675r 3  E8                           inx
002676r 3               
002676r 3  60           z_plus_store:   rts
002677r 3               
002677r 3               
002677r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
002677r 3               ; ## "postpone"  auto   ANS core
002677r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
002677r 3                       ; Add the compilation behavior of a word to a new word at
002677r 3                       ; compile time. If the word that follows it is immediate, include
002677r 3                       ; it so that it will be compiled when the word being defined is
002677r 3                       ; itself used for a new word. Tricky, but very useful.
002677r 3                       ;
002677r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
002677r 3                       ; on the Data Stack). This means we cannot build words with
002677r 3                       ; "jsr xt_postpone, jsr <word>" directly.
002677r 3                       ; """
002677r 3               
002677r 3               xt_postpone:
002677r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
00267Ar 3               
00267Ar 3                               ; if there was no word provided, complain and quit
00267Ar 3  B5 00                        lda 0,x
00267Cr 3  15 01                        ora 1,x
00267Er 3  D0 05                        bne @1
002680r 3               
002680r 3  A9 05                        lda #err_noname
002682r 3  4C rr rr                     jmp error
002685r 3               @1:
002685r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
002688r 3               
002688r 3                               ; if word not in Dictionary, complain and quit
002688r 3  D0 05                        bne @2
00268Ar 3  A9 05                        lda #err_noname
00268Cr 3  4C rr rr                     jmp error
00268Fr 3               
00268Fr 3               @2:
00268Fr 3                               ; keep a copy of nt for later
00268Fr 3  B5 00                        lda 0,x
002691r 3  85 24                        sta tmp1
002693r 3  B5 01                        lda 1,x
002695r 3  85 25                        sta tmp1+1
002697r 3               
002697r 3                               ; We need the xt instead of the nt
002697r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
00269Ar 3               
00269Ar 3                               ; See if this is an immediate word. This is easier
00269Ar 3                               ; with nt than with xt. The status byte of the word
00269Ar 3                               ; is nt+1
00269Ar 3  E6 24                        inc tmp1
00269Cr 3  D0 02                        bne @3
00269Er 3  E6 25                        inc tmp1+1
0026A0r 3               @3:
0026A0r 3  B2 24                        lda (tmp1)
0026A2r 3  29 04                        and #IM         ; mask all but Intermediate flag
0026A4r 3  F0 05                        beq @not_immediate
0026A6r 3               
0026A6r 3                               ; We're immediate, so instead of executing it right now, we
0026A6r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
0026A6r 3                               ; takes us back to the original caller
0026A6r 3  20 rr rr                     jsr xt_compile_comma
0026A9r 3  80 0A                        bra @done
0026ABr 3               
0026ABr 3               @not_immediate:
0026ABr 3                               ; This is not an immediate word, so we enact "deferred
0026ABr 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
0026ABr 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
0026ABr 3                               ; a subroutine jump to COMPILE,
0026ABr 3  20 rr rr                     jsr xt_literal
0026AEr 3               
0026AEr 3                               ; Last, compile COMPILE,
0026AEr 3  A0 rr                        ldy #>xt_compile_comma
0026B0r 3  A9 rr                        lda #<xt_compile_comma
0026B2r 3  20 rr rr                     jsr cmpl_subroutine
0026B5r 3               @done:
0026B5r 3  60           z_postpone:     rts
0026B6r 3               
0026B6r 3               
0026B6r 3               
0026B6r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
0026B6r 3               ; ## "previous"  auto  ANS search ext
0026B6r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
0026B6r 3               
0026B6r 3               xt_previous:
0026B6r 3  20 rr rr                     jsr xt_get_order
0026B9r 3  20 rr rr                     jsr xt_nip
0026BCr 3  20 rr rr                     jsr xt_one_minus
0026BFr 3  20 rr rr                     jsr xt_set_order
0026C2r 3               
0026C2r 3  60           z_previous:     rts
0026C3r 3               
0026C3r 3               
0026C3r 3               
0026C3r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
0026C3r 3               ; ## "?"  tested  ANS tools
0026C3r 3                       ; """https://forth-standard.org/standard/tools/q
0026C3r 3                       ;
0026C3r 3                       ; Only used interactively. Since humans are so slow, we
0026C3r 3                       ; save size and just go for the subroutine jumps
0026C3r 3                       ; """
0026C3r 3               xt_question:
0026C3r 3                               ; FETCH takes care of underflow check
0026C3r 3  20 rr rr                     jsr xt_fetch
0026C6r 3  20 rr rr                     jsr xt_dot
0026C9r 3               
0026C9r 3  60           z_question:     rts
0026CAr 3               
0026CAr 3               
0026CAr 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
0026CAr 3               ; ## "?dup"  auto  ANS core
0026CAr 3                       ; """https://forth-standard.org/standard/core/qDUP"""
0026CAr 3               
0026CAr 3               xt_question_dup:
0026CAr 3  20 rr rr                     jsr underflow_1
0026CDr 3               
0026CDr 3                               ; Check if TOS is zero
0026CDr 3  B5 00                        lda 0,x
0026CFr 3  15 01                        ora 1,x
0026D1r 3  F0 0A                        beq @done
0026D3r 3               
0026D3r 3                               ; not zero, duplicate
0026D3r 3  CA                           dex
0026D4r 3  CA                           dex
0026D5r 3  B5 02                        lda 2,x
0026D7r 3  95 00                        sta 0,x
0026D9r 3  B5 03                        lda 3,x
0026DBr 3  95 01                        sta 1,x
0026DDr 3               @done:
0026DDr 3  60           z_question_dup: rts
0026DEr 3               
0026DEr 3               
0026DEr 3               
0026DEr 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
0026DEr 3               ; ## "r@"  auto  ANS core
0026DEr 3                       ; """https://forth-standard.org/standard/core/RFetch
0026DEr 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
0026DEr 3                       ; work normally as well
0026DEr 3                       ;
0026DEr 3                       ; An alternative way to write this word
0026DEr 3                       ; would be to access the elements on the stack directly like 2R@
0026DEr 3                       ; does, these versions should be compared at some point.
0026DEr 3                       ; """
0026DEr 3               xt_r_fetch:
0026DEr 3                               ; get the return address
0026DEr 3  7A                           ply             ; LSB
0026DFr 3  84 24                        sty tmp1
0026E1r 3  7A                           ply             ; MSB
0026E2r 3               
0026E2r 3                               ; --- CUT FOR NATIVE COMPILE ---
0026E2r 3               
0026E2r 3                               ; get the actual top of Return Stack
0026E2r 3  CA                           dex
0026E3r 3  CA                           dex
0026E4r 3               
0026E4r 3  68                           pla             ; LSB
0026E5r 3  95 00                        sta 0,x
0026E7r 3  68                           pla             ; MSB
0026E8r 3  95 01                        sta 1,x
0026EAr 3               
0026EAr 3                               ; now we have to put that value back
0026EAr 3  48                           pha
0026EBr 3  B5 00                        lda 0,x
0026EDr 3  48                           pha
0026EEr 3               
0026EEr 3                               ; --- CUT FOR NATIVE COMPILE ---
0026EEr 3               
0026EEr 3                               ; restore return value
0026EEr 3  5A                           phy             ; MSB
0026EFr 3  A4 24                        ldy tmp1
0026F1r 3  5A                           phy             ; LSB
0026F2r 3               
0026F2r 3  60           z_r_fetch:      rts
0026F3r 3               
0026F3r 3               
0026F3r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
0026F3r 3               ; ## "r>"  auto  ANS core
0026F3r 3                       ; """https://forth-standard.org/standard/core/Rfrom
0026F3r 3                       ; Move Top of Return Stack to Top of Data Stack.
0026F3r 3                       ;
0026F3r 3                       ; We have to move
0026F3r 3                       ; the RTS address out of the way first. This word is handled
0026F3r 3                       ; differently for native and and subroutine compilation, see COMPILE,
0026F3r 3                       ; This is a compile-only word
0026F3r 3                       ; """
0026F3r 3               
0026F3r 3               xt_r_from:
0026F3r 3                               ; Rescue the address of the return jump that is currently
0026F3r 3                               ; on top of the Return Stack. If this word is natively
0026F3r 3                               ; compiled, this is a total waste of time
0026F3r 3  68                           pla             ; LSB
0026F4r 3  85 2C                        sta tmptos
0026F6r 3  7A                           ply             ; MSB
0026F7r 3               
0026F7r 3                               ; --- CUT FOR NATIVE CODING ---
0026F7r 3               
0026F7r 3  CA                           dex
0026F8r 3  CA                           dex
0026F9r 3               
0026F9r 3                               ; now we can access the actual data
0026F9r 3               
0026F9r 3  68                           pla             ; LSB
0026FAr 3  95 00                        sta 0,x
0026FCr 3  68                           pla             ; MSB
0026FDr 3  95 01                        sta 1,x
0026FFr 3               
0026FFr 3                               ; --- CUT FOR NATIVE CODING ---
0026FFr 3               
0026FFr 3                               ; restore the return address
0026FFr 3  5A                           phy             ; MSB
002700r 3  A5 2C                        lda tmptos
002702r 3  48                           pha             ; LSB
002703r 3               
002703r 3  60           z_r_from:       rts
002704r 3               
002704r 3               
002704r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
002704r 3               ; ## "r>input"  tested  Tali Forth
002704r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
002704r 3                       ; and toin from the Return Stack.
002704r 3                       ;
002704r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
002704r 3                       ; """
002704r 3               
002704r 3               xt_r_to_input:
002704r 3               
002704r 3                               ; We arrive here with the return address on the top of the
002704r 3                               ; 65c02's stack. We need to move it out of the way first
002704r 3  68                           pla
002705r 3  85 24                        sta tmp1
002707r 3  68                           pla
002708r 3  85 25                        sta tmp1+1
00270Ar 3               
00270Ar 3                               ; This assumes that insrc is the first of eight bytes and
00270Ar 3                               ; toin+1 the last in the sequence we want to save from the Zero
00270Ar 3                               ; Page. Since we went in reverse order, insrc is now on the top
00270Ar 3                               ; of the Return Stack.
00270Ar 3  A0 00                        ldy #0
00270Cr 3               @loop:
00270Cr 3  68                           pla
00270Dr 3  99 06 00                     sta insrc,y
002710r 3  C8                           iny
002711r 3  C0 08                        cpy #8
002713r 3  D0 F7                        bne @loop
002715r 3               
002715r 3                               ; Restore address for return jump
002715r 3  A5 25                        lda tmp1+1
002717r 3  48                           pha
002718r 3  A5 24                        lda tmp1
00271Ar 3  48                           pha
00271Br 3               
00271Br 3  60           z_r_to_input: 	rts
00271Cr 3               
00271Cr 3               
00271Cr 3               
00271Cr 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
00271Cr 3               ; ## "recurse"  auto  ANS core
00271Cr 3                       ; """https://forth-standard.org/standard/core/RECURSE
00271Cr 3                       ;
00271Cr 3                       ; This word may not be natively compiled
00271Cr 3                       ; """
00271Cr 3               
00271Cr 3               xt_recurse:
00271Cr 3                               ; The whole routine amounts to compiling a reference to
00271Cr 3                               ; the word that is being compiled. First, we save the JSR
00271Cr 3                               ; instruction
00271Cr 3  A0 00                        ldy #0
00271Er 3               
00271Er 3  A9 20                        lda #$20        ; opcode for JSR
002720r 3  91 00                        sta (cp),y
002722r 3  C8                           iny
002723r 3               
002723r 3                               ; Next, we save the LSB and MSB of the xt of the word
002723r 3                               ; we are currently working on. We first need to see if
002723r 3                               ; WORKWORD has the nt (: started the word) or the
002723r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
002723r 3  24 20                        bit status
002725r 3  70 0C                        bvs @nt_in_workword
002727r 3               
002727r 3                               ; This is a special :NONAME word. Just copy the xt
002727r 3                               ; from WORKWORD into the dictionary.
002727r 3  A5 04                        lda workword
002729r 3  91 00                        sta (cp),y
00272Br 3  C8                           iny
00272Cr 3  A5 05                        lda workword+1
00272Er 3  91 00                        sta (cp),y
002730r 3  C8                           iny
002731r 3  80 1B                        bra @update_cp
002733r 3               
002733r 3               @nt_in_workword:
002733r 3                               ; This is a regular : word, so the xt is four bytes down
002733r 3                               ; from the nt which we saved in WORKWORD. We could probably
002733r 3                               ; use NAME>INT here but this is going to be faster, and
002733r 3                               ; fast counts with recursion
002733r 3  A5 04                        lda workword            ; LSB
002735r 3  18                           clc
002736r 3  69 04                        adc #4
002738r 3  85 24                        sta tmp1
00273Ar 3  A5 05                        lda workword+1          ; MSB
00273Cr 3  69 00                        adc #0
00273Er 3  85 25                        sta tmp1+1
002740r 3               
002740r 3  B2 24                        lda (tmp1)
002742r 3  91 00                        sta (cp),y
002744r 3  5A                           phy
002745r 3  A0 01                        ldy #1
002747r 3  B1 24                        lda (tmp1),y
002749r 3  7A                           ply
00274Ar 3  C8                           iny
00274Br 3  91 00                        sta (cp),y
00274Dr 3  C8                           iny
00274Er 3               
00274Er 3               @update_cp:
00274Er 3  98                           tya
00274Fr 3  18                           clc
002750r 3  65 00                        adc cp
002752r 3  85 00                        sta cp
002754r 3  90 02                        bcc @done
002756r 3  E6 01                        inc cp+1
002758r 3               @done:
002758r 3  60           z_recurse:      rts
002759r 3               
002759r 3               
002759r 3               
002759r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
002759r 3               ; ## "refill"  tested  ANS core ext
002759r 3                       ; """https://forth-standard.org/standard/core/REFILL
002759r 3                       ; Attempt to fill the input buffer from the input source, returning
002759r 3                       ; a true flag if successful. When the input source is the user input
002759r 3                       ; device, attempt to receive input into the terminal input buffer. If
002759r 3                       ; successful, make the result the input buffer, set >IN to zero, and
002759r 3                       ; return true. Receipt of a line containing no characters is considered
002759r 3                       ; successful. If there is no input available from the current input
002759r 3                       ; source, return false. When the input source is a string from EVALUATE,
002759r 3                       ; return false and perform no other action." See
002759r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
002759r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
002759r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
002759r 3                       ; entire block as a 1024 byte string.
002759r 3                       ; """"
002759r 3               
002759r 3               xt_refill:
002759r 3                               ; Get input source from SOURCE-ID. This is an
002759r 3                               ; optimized version of a subroutine jump to SOURCE-ID
002759r 3  A5 06                        lda insrc               ; cheat: We only check LSB
00275Br 3  D0 2D                        bne @src_not_kbd
00275Dr 3               
00275Dr 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
00275Dr 3                               ; with ACCEPT, which wants the address of the current input
00275Dr 3                               ; buffer NOS and the max number of characters to accept TOS
00275Dr 3  CA                           dex
00275Er 3  CA                           dex
00275Fr 3  CA                           dex
002760r 3  CA                           dex
002761r 3               
002761r 3  A5 08                        lda cib                 ; address of CIB is NOS
002763r 3  95 02                        sta 2,x
002765r 3  A5 09                        lda cib+1
002767r 3  95 03                        sta 3,x
002769r 3               
002769r 3  64 0A                        stz ciblen              ; go in with empty buffer
00276Br 3  64 0B                        stz ciblen+1
00276Dr 3               
00276Dr 3  A9 FF                        lda #bsize              ; max number of chars is TOS
00276Fr 3  95 00                        sta 0,x
002771r 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
002773r 3               
002773r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
002776r 3               
002776r 3                               ; ACCEPT returns the number of characters accepted, which
002776r 3                               ; belong in CIBLEN
002776r 3  B5 00                        lda 0,x
002778r 3  85 0A                        sta ciblen
00277Ar 3  B5 01                        lda 1,x
00277Cr 3  85 0B                        sta ciblen+1            ; though we only accept 255 chars
00277Er 3               
00277Er 3                               ; make >IN point to beginning of buffer
00277Er 3  64 0C                        stz toin
002780r 3  64 0D                        stz toin+1
002782r 3               
002782r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
002784r 3  95 00                        sta 0,x
002786r 3  95 01                        sta 1,x
002788r 3               
002788r 3  80 10                        bra @done
00278Ar 3               
00278Ar 3               @src_not_kbd:
00278Ar 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
00278Ar 3                               ; memory or a file (remember, no blocks in this version).
00278Ar 3                               ; If source is a string, we were given the flag -1 ($FFFF)
00278Ar 3  1A                           inc
00278Br 3  D0 08                        bne @src_not_string
00278Dr 3               
00278Dr 3                               ; Simply return FALSE flag as per specification
00278Dr 3  CA                           dex
00278Er 3  CA                           dex
00278Fr 3  74 00                        stz 0,x
002791r 3  74 01                        stz 1,x
002793r 3               
002793r 3  80 05                        bra z_refill
002795r 3               
002795r 3               @src_not_string:
002795r 3                               ; Since we don't have blocks, this must mean that we are trying
002795r 3                               ; to read from a file. However, we don't have files yet, so we
002795r 3                               ; report an error and jump to ABORT.
002795r 3  A9 01                        lda #err_badsource
002797r 3  4C rr rr                     jmp error
00279Ar 3               @done:
00279Ar 3  60           z_refill:       rts
00279Br 3               
00279Br 3               
00279Br 3               
00279Br 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
00279Br 3               ; ## "repeat"  auto  ANS core
00279Br 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
00279Br 3               
00279Br 3               xt_repeat:
00279Br 3                               ; Run again first
00279Br 3  20 rr rr                     jsr xt_again
00279Er 3               
00279Er 3                               ; Stuff HERE in for the branch address
00279Er 3                               ; to get out of the loop
00279Er 3  20 rr rr                     jsr xt_here
0027A1r 3  20 rr rr                     jsr xt_swap
0027A4r 3  20 rr rr                     jsr xt_store
0027A7r 3               
0027A7r 3  60           z_repeat:       rts
0027A8r 3               
0027A8r 3               
0027A8r 3               
0027A8r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
0027A8r 3               ; ## "]"  auto  ANS core
0027A8r 3                       ; """https://forth-standard.org/standard/right-bracket
0027A8r 3                       ; This is an immediate word.
0027A8r 3                       ; """
0027A8r 3               xt_right_bracket:
0027A8r 3  A9 FF                        lda #$FF
0027AAr 3  85 16                        sta state
0027ACr 3  85 17                        sta state+1
0027AEr 3               z_right_bracket:
0027AEr 3  60                           rts
0027AFr 3               
0027AFr 3               
0027AFr 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
0027AFr 3               ; ## "root-wordlist"  tested  Tali Editor
0027AFr 3               xt_root_wordlist:
0027AFr 3  CA                           dex             ; The WID for the Root wordlist is 3.
0027B0r 3  CA                           dex
0027B1r 3  A9 03                        lda #3
0027B3r 3  95 00                        sta 0,x
0027B5r 3  74 01                        stz 1,x
0027B7r 3               
0027B7r 3               z_root_wordlist:
0027B7r 3  60                           rts
0027B8r 3               
0027B8r 3               
0027B8r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
0027B8r 3               ; ## "rot"  auto  ANS core
0027B8r 3                       ; """https://forth-standard.org/standard/core/ROT
0027B8r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
0027B8r 3                       ; on top!
0027B8r 3                       ; """
0027B8r 3               
0027B8r 3               xt_rot:
0027B8r 3  20 rr rr                     jsr underflow_3
0027BBr 3               
0027BBr 3  B4 05                        ldy 5,x         ; MSB first
0027BDr 3  B5 03                        lda 3,x
0027BFr 3  95 05                        sta 5,x
0027C1r 3  B5 01                        lda 1,x
0027C3r 3  95 03                        sta 3,x
0027C5r 3  94 01                        sty 1,x
0027C7r 3               
0027C7r 3  B4 04                        ldy 4,x         ; LSB next
0027C9r 3  B5 02                        lda 2,x
0027CBr 3  95 04                        sta 4,x
0027CDr 3  B5 00                        lda 0,x
0027CFr 3  95 02                        sta 2,x
0027D1r 3  94 00                        sty 0,x
0027D3r 3               
0027D3r 3  60           z_rot:          rts
0027D4r 3               
0027D4r 3               
0027D4r 3               
0027D4r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
0027D4r 3               ; ## "rshift"  auto  ANS core
0027D4r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
0027D4r 3               xt_rshift:
0027D4r 3  20 rr rr                     jsr underflow_2
0027D7r 3               
0027D7r 3                               ; We shift maximal by 16 bits, mask everything else
0027D7r 3  B5 00                        lda 0,x
0027D9r 3  29 0F                        and #%00001111
0027DBr 3  F0 08                        beq @done               ; if 0 shifts, quit
0027DDr 3               
0027DDr 3  A8                           tay
0027DEr 3               @loop:
0027DEr 3  56 03                        lsr 3,x
0027E0r 3  76 02                        ror 2,x
0027E2r 3  88                           dey
0027E3r 3  D0 F9                        bne @loop
0027E5r 3               @done:
0027E5r 3  E8                           inx
0027E6r 3  E8                           inx
0027E7r 3               
0027E7r 3  60           z_rshift:       rts
0027E8r 3               
0027E8r 3               
0027E8r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
0027E8r 3               ; ## "s\""  auto  ANS core
0027E8r 3                       ; """https://forth-standard.org/standard/core/Seq
0027E8r 3                       ; Store address and length of string given, returning ( addr u ).
0027E8r 3                       ; ANS core claims this is compile-only, but the file set expands it
0027E8r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
0027E8r 3                       ; are evil. We follow general usage. This is just like S" except
0027E8r 3                       ; that it allows for some special escaped characters.
0027E8r 3                       ; """
0027E8r 3               
0027E8r 3               xt_s_backslash_quote:
0027E8r 3                               ; tmp2 will be used to determine if we are handling
0027E8r 3                               ; escaped characters or not. In this case, we are,
0027E8r 3                               ; so set it to $FF (the upper byte will be used to
0027E8r 3                               ; determine if we just had a \ and the next character
0027E8r 3                               ; needs to be modifed as an escaped character).
0027E8r 3  A9 FF                        lda #$FF
0027EAr 3  85 26                        sta tmp2
0027ECr 3  64 27                        stz tmp2+1
0027EEr 3               
0027EEr 3                               ; Now that the flag is set, jump into s_quote to process
0027EEr 3                               ; the string.
0027EEr 3  20 rr rr                     jsr s_quote_start
0027F1r 3               @done:
0027F1r 3               z_s_backslash_quote:
0027F1r 3  60                           rts
0027F2r 3               
0027F2r 3               
0027F2r 3               ; This is a helper function for s_backslash_quote to convert a character
0027F2r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
0027F2r 3               convert_hex_value:
0027F2r 3               
0027F2r 3  C9 41                cmp #'A'
0027F4r 3  90 07                bcc @digit
0027F6r 3               
0027F6r 3                       ; It's A-F
0027F6r 3  29 DF                and #$DF                ; Make it uppercase.
0027F8r 3  38                   sec
0027F9r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
0027FBr 3  80 03                bra @done
0027FDr 3               
0027FDr 3               @digit:
0027FDr 3                       ; It's 0-9
0027FDr 3  38                   sec
0027FEr 3  E9 30                sbc #'0'
002800r 3               
002800r 3               @done:
002800r 3  60                   rts
002801r 3               
002801r 3               
002801r 3               
002801r 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
002801r 3               ; ## "search-wordlist" auto ANS search
002801r 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
002801r 3               
002801r 3               xt_search_wordlist:
002801r 3  20 rr rr                     jsr underflow_3
002804r 3               
002804r 3                               ; Set up tmp1 with the wordlist indicated by wid
002804r 3                               ; on the stack. Start by putting the base address
002804r 3                               ; of the wordlists in tmp2.
002804r 3  A5 1E                        lda up
002806r 3  18                           clc
002807r 3  69 06                        adc #wordlists_offset
002809r 3  85 26                        sta tmp2
00280Br 3  A5 1F                        lda up+1
00280Dr 3  69 00                        adc #0          ; Adding carry
00280Fr 3  85 27                        sta tmp2+1
002811r 3               
002811r 3                               ; Add the wid (in cells) to the base address.
002811r 3  B5 00                        lda 0,x
002813r 3  0A                           asl             ; Convert wid to offset in cells (x2)
002814r 3  65 26                        adc tmp2
002816r 3  85 26                        sta tmp2
002818r 3  90 02                        bcc @1
00281Ar 3  E6 27                        inc tmp2+1      ; Propagate carry if needed.
00281Cr 3               
00281Cr 3                               ; tmp2 now holds the address of the dictionary pointer
00281Cr 3                               ; for the given wordlist.
00281Cr 3               @1:
00281Cr 3                               ; Remove the wid from the stack.
00281Cr 3  E8                           inx
00281Dr 3  E8                           inx
00281Er 3               
00281Er 3                               ; check for special case of an empty string (length zero)
00281Er 3  B5 00                        lda 0,x
002820r 3  15 01                        ora 1,x
002822r 3  D0 03                        bne @check_wordlist
002824r 3  4C rr rr                     jmp @done
002827r 3               
002827r 3               @check_wordlist:
002827r 3                               ; Check for special case of empty wordlist
002827r 3                               ; (dictionary pointer, in tmp2, is 0)
002827r 3  A5 26                        lda tmp2
002829r 3  05 27                        ora tmp2+1
00282Br 3  D0 03                        bne @have_string
00282Dr 3  4C rr rr                     jmp @done
002830r 3               
002830r 3               @have_string:
002830r 3                               ; set up first loop iteration
002830r 3  B2 26                        lda (tmp2)              ; nt of first word in Dictionary
002832r 3  85 24                        sta tmp1
002834r 3               
002834r 3  E6 26                        inc tmp2                ; Move to the upper byte
002836r 3  D0 02                        bne @2
002838r 3  E6 27                        inc tmp2+1
00283Ar 3               @2:
00283Ar 3  B2 26                        lda (tmp2)
00283Cr 3  85 25                        sta tmp1+1
00283Er 3               
00283Er 3                               ; Reuse tmp2 to hold the address of the mystery string.
00283Er 3  B5 02                        lda 2,x                 ; Address of mystery string
002840r 3  85 26                        sta tmp2
002842r 3  B5 03                        lda 3,x
002844r 3  85 27                        sta tmp2+1
002846r 3               
002846r 3               @loop:
002846r 3                               ; first quick test: Are strings the same length?
002846r 3  B2 24                        lda (tmp1)
002848r 3  D5 00                        cmp 0,x
00284Ar 3  D0 7B                        bne @next_entry
00284Cr 3               
00284Cr 3               @compare_string:
00284Cr 3                               ; are the same length, so we now have to compare each
00284Cr 3                               ; character
00284Cr 3               
00284Cr 3                               ; second quick test: Is the first character the same?
00284Cr 3  B2 26                        lda (tmp2)      ; first character of mystery string
00284Er 3               
00284Er 3                               ; Lowercase the incoming charcter.
00284Er 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
002850r 3  B0 07                        bcs @compare_first
002852r 3  C9 41                        cmp #$41        ; ASCII 'A'
002854r 3  90 03                        bcc @compare_first
002856r 3               
002856r 3                               ; An uppercase letter has been located.  Make it
002856r 3                               ; lowercase.
002856r 3  18                           clc
002857r 3  69 20                        adc #$20
002859r 3               
002859r 3               @compare_first:
002859r 3  A0 08                        ldy #8          ; Offset in nt to name
00285Br 3  D1 24                        cmp (tmp1),y    ; first character of current word
00285Dr 3  D0 68                        bne @next_entry
00285Fr 3               
00285Fr 3                               ; string length are the same and the first character is the
00285Fr 3                               ; same. If the length of the string is 1, we're already done
00285Fr 3  B5 00                        lda 0,x
002861r 3  3A                           dec
002862r 3  F0 2C                        beq @success
002864r 3               
002864r 3                               ; No such luck: The strings are the same length and the first
002864r 3                               ; char is the same, but the word is more than one char long.
002864r 3                               ; So we suck it up and compare every single character. We go
002864r 3                               ; from back to front, because words like CELLS and CELL+ would
002864r 3                               ; take longer otherwise. We can also shorten the loop by one
002864r 3                               ; because we've already compared the first char.
002864r 3               
002864r 3                               ; The string of the word we're testing against is 8 bytes down
002864r 3  A5 24                        lda tmp1
002866r 3  48                           pha             ; Preserve tmp1 on the return stack.
002867r 3  18                           clc
002868r 3  69 08                        adc #8
00286Ar 3  85 24                        sta tmp1        ; Reusing tmp1 temporarily for string check.
00286Cr 3  A5 25                        lda tmp1+1
00286Er 3  48                           pha             ; Preserve tmp1+1 on the return stack.
00286Fr 3  69 00                        adc #0          ; we only need the carry
002871r 3  85 25                        sta tmp1+1
002873r 3               
002873r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
002875r 3  88                           dey
002876r 3               
002876r 3               @string_loop:
002876r 3  B1 26                        lda (tmp2),y    ; last char of mystery string
002878r 3               
002878r 3                               ; Lowercase the incoming charcter.
002878r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
00287Ar 3  B0 07                        bcs @check_char
00287Cr 3  C9 41                        cmp #$41        ; ASCII 'A'
00287Er 3  90 03                        bcc @check_char
002880r 3               
002880r 3                               ; An uppercase letter has been located.  Make it
002880r 3                               ; lowercase.
002880r 3  18                           clc
002881r 3  69 20                        adc #$20
002883r 3               @check_char:
002883r 3  D1 24                        cmp (tmp1),y    ; last char of word we're testing against
002885r 3  D0 3A                        bne @next_entry_tmp1
002887r 3               
002887r 3  88                           dey
002888r 3  D0 EC                        bne @string_loop
00288Ar 3               
00288Ar 3               @success_tmp1:
00288Ar 3  68                           pla             ; Restore tmp1 from the return stack.
00288Br 3  85 25                        sta tmp1+1
00288Dr 3  68                           pla
00288Er 3  85 24                        sta tmp1
002890r 3               
002890r 3               @success:
002890r 3                               ; The strings match. Drop the count and put correct nt TOS
002890r 3  E8                           inx
002891r 3  E8                           inx
002892r 3  A5 24                        lda tmp1
002894r 3  95 00                        sta 0,x
002896r 3  A5 25                        lda tmp1+1
002898r 3  95 01                        sta 1,x
00289Ar 3               
00289Ar 3                               ; Change the nt into an xt, but save a copy of the nt
00289Ar 3                               ; to look up whether the word is immediate or not.
00289Ar 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00289Dr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0028A0r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0028A3r 3               
0028A3r 3  A0 00                        ldy #0                  ; Prepare flag
0028A5r 3               
0028A5r 3                               ; The flags are in the second byte of the header
0028A5r 3  F6 00                        inc 0,x
0028A7r 3  D0 02                        bne @3
0028A9r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0028ABr 3               @3:
0028ABr 3  A1 00                        lda (0,x)               ; ( xt char )
0028ADr 3  29 04                        and #IM
0028AFr 3  D0 08                        bne @immediate          ; bit set, we're immediate
0028B1r 3               
0028B1r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
0028B3r 3  95 00                        sta 0,x
0028B5r 3  95 01                        sta 1,x
0028B7r 3  80 28                        bra @done_nodrop
0028B9r 3               
0028B9r 3               @immediate:
0028B9r 3  A9 01                        lda #1                  ; We're immediate, return 1
0028BBr 3  95 00                        sta 0,x
0028BDr 3  74 01                        stz 1,x
0028BFr 3               
0028BFr 3  80 20                        bra @done_nodrop
0028C1r 3               
0028C1r 3               @next_entry_tmp1:
0028C1r 3  68                           pla             ; Restore tmp1 from the return stack.
0028C2r 3  85 25                        sta tmp1+1
0028C4r 3  68                           pla
0028C5r 3  85 24                        sta tmp1
0028C7r 3               @next_entry:
0028C7r 3                               ; Not the same, so we get the next word. Next header
0028C7r 3                               ; address is two bytes down
0028C7r 3  A0 02                        ldy #2
0028C9r 3  B1 24                        lda (tmp1),y
0028CBr 3  48                           pha
0028CCr 3  C8                           iny
0028CDr 3  B1 24                        lda (tmp1),y
0028CFr 3  85 25                        sta tmp1+1
0028D1r 3  68                           pla
0028D2r 3  85 24                        sta tmp1
0028D4r 3               
0028D4r 3                               ; If we got a zero, we've walked the whole Dictionary and
0028D4r 3                               ; return as a failure, otherwise try again
0028D4r 3  05 25                        ora tmp1+1
0028D6r 3  F0 03                        beq @fail_done
0028D8r 3  4C rr rr                     jmp @loop
0028DBr 3               
0028DBr 3               @fail_done:
0028DBr 3  74 02                        stz 2,x         ; failure flag
0028DDr 3  74 03                        stz 3,x
0028DFr 3               @done:
0028DFr 3  E8                           inx
0028E0r 3  E8                           inx
0028E1r 3               @done_nodrop:
0028E1r 3               z_search_wordlist:
0028E1r 3  60                           rts
0028E2r 3               
0028E2r 3               
0028E2r 3               
0028E2r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
0028E2r 3               ; ## "see" tested  ANS tools
0028E2r 3                       ; """https://forth-standard.org/standard/tools/SEE
0028E2r 3                       ; SEE takes the name of a word and prints its name token (nt),
0028E2r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
0028E2r 3                       ; code and disassembles it.
0028E2r 3                       ; """
0028E2r 3               
0028E2r 3               xt_see:
0028E2r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
0028E5r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
0028E8r 3               
0028E8r 3                               ; If we got back a zero we don't know that word and so we quit
0028E8r 3                               ; with an error
0028E8r 3  B5 00                        lda 0,x
0028EAr 3  15 01                        ora 1,x
0028ECr 3  D0 05                        bne @1
0028EEr 3               
0028EEr 3  A9 05                        lda #err_noname
0028F0r 3  4C rr rr                     jmp error
0028F3r 3               @1:
0028F3r 3  20 rr rr                     jsr xt_cr
0028F6r 3               
0028F6r 3                               ; We have a legal word, so let's get serious. Save the current
0028F6r 3                               ; number base and use hexadecimal instead.
0028F6r 3  A5 18                        lda base
0028F8r 3  48                           pha
0028F9r 3  20 rr rr                     jsr xt_hex
0028FCr 3               
0028FCr 3  A9 0A                        lda #str_see_nt
0028FEr 3  20 rr rr                     jsr print_string_no_lf
002901r 3               
002901r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002904r 3  20 rr rr                     jsr xt_u_dot
002907r 3  20 rr rr                     jsr xt_space            ; ( nt )
00290Ar 3               
00290Ar 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00290Dr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
002910r 3               
002910r 3  A9 0B                        lda #str_see_xt
002912r 3  20 rr rr                     jsr print_string_no_lf
002915r 3               
002915r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
002918r 3  20 rr rr                     jsr xt_u_dot
00291Br 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
00291Er 3               
00291Er 3                               ; We print letters for flags and then later follow it with 1 or
00291Er 3                               ; 0 to mark if which flag is set
00291Er 3  A9 09                        lda #str_see_flags
002920r 3  20 rr rr                     jsr print_string_no_lf
002923r 3               
002923r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
002926r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
002929r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
00292Cr 3               
00292Cr 3  B5 00                        lda 0,x
00292Er 3               
00292Er 3                               ; This is crude, but for the moment it is good enough
00292Er 3  A0 06                        ldy #6                  ; Not all bits are used
002930r 3               @flag_loop:
002930r 3  48                           pha
002931r 3  29 01                        and #%00000001
002933r 3  18                           clc
002934r 3  69 30                        adc #$30                ; ASCII "0"
002936r 3  20 rr rr                     jsr emit_a
002939r 3  20 rr rr                     jsr xt_space
00293Cr 3               
00293Cr 3  68                           pla
00293Dr 3  6A                           ror                     ; Next flag
00293Er 3               
00293Er 3  88                           dey
00293Fr 3  D0 EF                        bne @flag_loop
002941r 3               
002941r 3  20 rr rr                     jsr xt_cr
002944r 3               
002944r 3  E8                           inx
002945r 3  E8                           inx                     ; ( nt xt )
002946r 3               
002946r 3                               ; Figure out the size
002946r 3  A9 0C                        lda #str_see_size
002948r 3  20 rr rr                     jsr print_string_no_lf
00294Br 3               
00294Br 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
00294Er 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
002951r 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
002954r 3  20 rr rr                     jsr xt_decimal
002957r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
00295Ar 3  20 rr rr                     jsr xt_hex
00295Dr 3  20 rr rr                     jsr xt_cr
002960r 3               
002960r 3                               ; Dump hex and disassemble
002960r 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
002963r 3  20 rr rr                     jsr xt_dump
002966r 3  20 rr rr                     jsr xt_cr
002969r 3  20 rr rr                     jsr xt_disasm
00296Cr 3               
00296Cr 3  68                           pla
00296Dr 3  85 18                        sta base
00296Fr 3               
00296Fr 3  60           z_see:          rts
002970r 3               
002970r 3               
002970r 3               
002970r 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
002970r 3               ; ## "set-current" auto ANS search
002970r 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
002970r 3               
002970r 3               xt_set_current:
002970r 3  20 rr rr                     jsr underflow_1
002973r 3               
002973r 3                               ; Save the value from the data stack.
002973r 3  A0 04                        ldy #current_offset
002975r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
002977r 3  91 1E                        sta (up),y      ; so only the LSB is used.
002979r 3               
002979r 3  E8                           inx
00297Ar 3  E8                           inx
00297Br 3               
00297Br 3  60           z_set_current:  rts
00297Cr 3               
00297Cr 3               
00297Cr 3               
00297Cr 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
00297Cr 3               ; ## "set-order" auto ANS search
00297Cr 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
00297Cr 3               
00297Cr 3               xt_set_order:
00297Cr 3                               ; Test for -1 TOS
00297Cr 3  A9 FF                        lda #$FF
00297Er 3  D5 01                        cmp 1,x
002980r 3  D0 12                        bne @start
002982r 3  D5 00                        cmp 0,x
002984r 3  D0 0E                        bne @start
002986r 3               
002986r 3                               ; There is a -1 TOS.  Replace it with the default
002986r 3                               ; search order, which is just the FORTH-WORDLIST.
002986r 3  CA                           dex             ; Make room for the count.
002987r 3  CA                           dex
002988r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
00298Ar 3  A9 03                        lda #3
00298Cr 3  95 02                        sta 2,x
00298Er 3  74 01                        stz 1,x         ; Count is 1.
002990r 3  A9 01                        lda #1
002992r 3  95 00                        sta 0,x
002994r 3               
002994r 3                               ; Continue processing with ( forth-wordlist 1 -- )
002994r 3               @start:
002994r 3                               ; Set #ORDER - the number of wordlists in the search order.
002994r 3  A0 1E                        ldy #num_order_offset
002996r 3  B5 00                        lda 0,x
002998r 3  91 1E                        sta (up),y      ; #ORDER is a byte variable.
00299Ar 3  85 24                        sta tmp1        ; Save a copy for zero check and looping.
00299Cr 3                                               ; Only the low byte is saved in tmp1 as
00299Cr 3                                               ; only 8 wordlists are allowed.
00299Cr 3               
00299Cr 3  E8                           inx             ; Drop the count off the data stack.
00299Dr 3  E8                           inx
00299Er 3               
00299Er 3                               ; Check if there are zero wordlists.
00299Er 3  A5 24                        lda tmp1
0029A0r 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
0029A2r 3               
0029A2r 3                               ; Move the wordlist ids from the data stack to the search order.
0029A2r 3  A0 1F                        ldy #search_order_offset
0029A4r 3               @loop:
0029A4r 3                               ; Move one wordlist id over into the search order.
0029A4r 3  B5 00                        lda 0,x         ; The search order is a byte array
0029A6r 3  91 1E                        sta (up),y      ; so only save the LSB
0029A8r 3  C8                           iny
0029A9r 3               
0029A9r 3                               ; Remove it from the data stack.
0029A9r 3  E8                           inx
0029AAr 3  E8                           inx
0029ABr 3               
0029ABr 3                               ; See if that was the last one to process (first in the list).
0029ABr 3  C6 24                        dec tmp1
0029ADr 3  D0 F5                        bne @loop
0029AFr 3               
0029AFr 3               @done:
0029AFr 3  60           z_set_order:    rts
0029B0r 3               
0029B0r 3               
0029B0r 3               
0029B0r 3               
0029B0r 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
0029B0r 3               ; ## "s""  auto  ANS core
0029B0r 3                       ; """https://forth-standard.org/standard/core/Sq
0029B0r 3                       ; Store address and length of string given, returning ( addr u ).
0029B0r 3                       ; ANS core claims this is compile-only, but the file set expands it
0029B0r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
0029B0r 3                       ; are evil. We follow general usage.
0029B0r 3                       ;
0029B0r 3                       ; Can also be realized as
0029B0r 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
0029B0r 3                       ; but it is used so much we want it in code.
0029B0r 3                       ; """
0029B0r 3               
0029B0r 3               xt_s_quote:
0029B0r 3                               ; tmp2 will be used to determine if we are handling
0029B0r 3                               ; escaped characters or not.  In this case, we are
0029B0r 3                               ; not, so set it to zero.
0029B0r 3  64 26                        stz tmp2
0029B2r 3  64 27                        stz tmp2+1
0029B4r 3               
0029B4r 3               s_quote_start:
0029B4r 3                               ; Make room on the data stack for the address.
0029B4r 3  CA                           dex
0029B5r 3  CA                           dex
0029B6r 3                               ; Make room on the data stack for the count.
0029B6r 3  CA                           dex
0029B7r 3  CA                           dex
0029B8r 3               
0029B8r 3                               ; Put a jmp over the string data with address to be filled
0029B8r 3                               ; in later.
0029B8r 3  A9 4C                        lda #$4C
0029BAr 3  20 rr rr                     jsr cmpl_a
0029BDr 3               
0029BDr 3                               ; Address to be filled in later, just use $4C for the moment
0029BDr 3  20 rr rr                     jsr cmpl_a
0029C0r 3  20 rr rr                     jsr cmpl_a
0029C3r 3               
0029C3r 3                               ; Save the current value of HERE on the data stack for the
0029C3r 3                               ; address of the string.
0029C3r 3  A5 00                        lda cp
0029C5r 3  95 02                        sta 2,x
0029C7r 3  A5 01                        lda cp+1
0029C9r 3  95 03                        sta 3,x
0029CBr 3               
0029CBr 3               @savechars_loop:
0029CBr 3                               ; Start saving the string into the dictionary up to the
0029CBr 3                               ; ending double quote. First, check to see if the input
0029CBr 3                               ; buffer is empty.
0029CBr 3  A5 0D                        lda toin+1              ; MSB
0029CDr 3  C5 0B                        cmp ciblen+1
0029CFr 3  90 2A                        bcc @input_fine         ; unsigned comparison
0029D1r 3               
0029D1r 3  A5 0C                        lda toin                ; LSB
0029D3r 3  C5 0A                        cmp ciblen
0029D5r 3  90 24                        bcc @input_fine
0029D7r 3               
0029D7r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
0029D7r 3                               ; which uses tmp2 and tmp3. Save and restore them.
0029D7r 3  A5 26                        lda tmp2
0029D9r 3  48                           pha
0029DAr 3  A5 27                        lda tmp2+1
0029DCr 3  48                           pha
0029DDr 3  A5 28                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
0029DFr 3  48                           pha
0029E0r 3               
0029E0r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
0029E3r 3               
0029E3r 3  68                           pla
0029E4r 3  85 28                        sta tmp3
0029E6r 3  68                           pla
0029E7r 3  85 27                        sta tmp2+1
0029E9r 3  68                           pla
0029EAr 3  85 26                        sta tmp2
0029ECr 3               
0029ECr 3                               ; Check result of refill.
0029ECr 3  B5 00                        lda 0,x
0029EEr 3  15 01                        ora 1,x
0029F0r 3  D0 05                        bne @refill_ok
0029F2r 3               
0029F2r 3                               ; Something when wrong with refill.
0029F2r 3  A9 06                        lda #err_refill
0029F4r 3  4C rr rr                     jmp error
0029F7r 3               
0029F7r 3               @refill_ok:
0029F7r 3                               ; Remove the refill flag from the data stack.
0029F7r 3  E8                           inx
0029F8r 3  E8                           inx
0029F9r 3               
0029F9r 3                               ; For refill success, jump back up to the empty check, just in
0029F9r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
0029F9r 3                               ; input)
0029F9r 3  80 D0                        bra @savechars_loop
0029FBr 3               
0029FBr 3               @input_fine:
0029FBr 3                               ; There should be at least one valid char to use.
0029FBr 3                               ; Calculate it's address at CIB+TOIN into tmp1
0029FBr 3  A5 08                        lda cib
0029FDr 3  18                           clc
0029FEr 3  65 0C                        adc toin        ; LSB
002A00r 3  85 24                        sta tmp1
002A02r 3  A5 09                        lda cib+1
002A04r 3  65 0D                        adc toin+1      ; MSB
002A06r 3  85 25                        sta tmp1+1
002A08r 3               
002A08r 3                               ; Get the character
002A08r 3  B2 24                        lda (tmp1)
002A0Ar 3               
002A0Ar 3                               ; Check to see if we are handling escaped characters.
002A0Ar 3  24 26                        bit tmp2
002A0Cr 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
002A0Er 3  4C rr rr                     jmp @regular_char
002A11r 3               
002A11r 3               @handle_escapes:
002A11r 3                               ; We are handling escaped characters.  See if we have
002A11r 3                               ; already seen the backslash.
002A11r 3  24 27                        bit tmp2+1
002A13r 3  30 03                        bmi @escaped
002A15r 3  4C rr rr                     jmp @not_escaped
002A18r 3               
002A18r 3               @escaped:
002A18r 3               
002A18r 3                               ; We have seen a backslash (previous character). Check to see if
002A18r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
002A18r 3                               ; be clear in that case )
002A18r 3  70 22                        bvs @check_esc_chars
002A1Ar 3               
002A1Ar 3                               ; We are in the middle of a \x sequence. Check to see if we
002A1Ar 3                               ; are on the first or second digit.
002A1Ar 3  A9 01                        lda #1
002A1Cr 3  24 27                        bit tmp2+1
002A1Er 3  D0 10                        bne @esc_x_second_digit
002A20r 3               
002A20r 3                               ; First digit.
002A20r 3  E6 27                        inc tmp2+1  ; Adjust flag for second digit next time.
002A22r 3  B2 24                        lda (tmp1)  ; Get the char again.
002A24r 3               
002A24r 3                               ; Convert to hex
002A24r 3  20 rr rr                     jsr convert_hex_value
002A27r 3               
002A27r 3                               ; This is the upper nybble, so move it up.
002A27r 3  0A                           asl
002A28r 3  0A                           asl
002A29r 3  0A                           asl
002A2Ar 3  0A                           asl
002A2Br 3  85 28                        sta tmp3    ; Save it for later.
002A2Dr 3  4C rr rr                     jmp @next_character
002A30r 3               
002A30r 3               @esc_x_second_digit:
002A30r 3               
002A30r 3                               ; We are on the second hex digit of a \x sequence. Clear the
002A30r 3                               ; escaped character flag (because we are handling it right
002A30r 3                               ; here)
002A30r 3  64 27                        stz tmp2+1
002A32r 3  B2 24                        lda (tmp1)
002A34r 3               
002A34r 3                               ; Convert to hex, combine with value in tmp3
002A34r 3  20 rr rr                     jsr convert_hex_value
002A37r 3  05 28                        ora tmp3
002A39r 3               
002A39r 3  4C rr rr                     jmp @save_character
002A3Cr 3               
002A3Cr 3               @check_esc_chars:
002A3Cr 3                               ; Clear the escaped character flag (because we are
002A3Cr 3                               ; handling it right here)
002A3Cr 3  64 27                        stz tmp2+1
002A3Er 3               
002A3Er 3                               ; Process the escaped character
002A3Er 3               @check_esc_a:
002A3Er 3  C9 61                        cmp #'a'
002A40r 3  D0 05                        bne @check_esc_b
002A42r 3               
002A42r 3                               ; BEL (ASCII value 7)
002A42r 3  A9 07                        lda #7
002A44r 3  4C rr rr                     jmp @save_character
002A47r 3               
002A47r 3               @check_esc_b:
002A47r 3  C9 62                        cmp #'b'
002A49r 3  D0 05                        bne @check_esc_e
002A4Br 3               
002A4Br 3                               ; Backspace (ASCII value 8)
002A4Br 3  A9 08                        lda #8
002A4Dr 3  4C rr rr                     jmp @save_character
002A50r 3               
002A50r 3               @check_esc_e:
002A50r 3  C9 65                        cmp #'e'
002A52r 3  D0 04                        bne @check_esc_f
002A54r 3               
002A54r 3                               ; ESC (ASCII value 27)
002A54r 3  A9 1B                        lda #27
002A56r 3  80 75                        bra @save_character
002A58r 3               
002A58r 3               @check_esc_f:
002A58r 3  C9 66                        cmp #'f'
002A5Ar 3  D0 04                        bne @check_esc_l
002A5Cr 3               
002A5Cr 3                               ; FF (ASCII value 12)
002A5Cr 3  A9 0C                        lda #12
002A5Er 3  80 6D                        bra @save_character
002A60r 3               
002A60r 3               @check_esc_l:
002A60r 3  C9 6C                        cmp #'l'
002A62r 3  D0 04                        bne @check_esc_m
002A64r 3               
002A64r 3                               ; LF (ASCII value 10)
002A64r 3  A9 0A                        lda #10
002A66r 3  80 65                        bra @save_character
002A68r 3               
002A68r 3               @check_esc_m:
002A68r 3                               ; This one is not like the others because we save two
002A68r 3                               ; characters
002A68r 3  C9 6D                        cmp #'m'
002A6Ar 3  D0 09                        bne @check_esc_n
002A6Cr 3               
002A6Cr 3                               ; CR/LF pair (ASCII values 13, 10)
002A6Cr 3  A9 0D                        lda #13
002A6Er 3  20 rr rr                     jsr cmpl_a
002A71r 3  A9 0A                        lda #10
002A73r 3  80 58                        bra @save_character
002A75r 3               
002A75r 3               @check_esc_n:
002A75r 3  C9 6E                        cmp #'n'
002A77r 3  D0 04                        bne @check_esc_q
002A79r 3               
002A79r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
002A79r 3  A9 0A                        lda #10
002A7Br 3  80 50                        bra @save_character
002A7Dr 3               
002A7Dr 3               @check_esc_q:
002A7Dr 3  C9 71                        cmp #'q'
002A7Fr 3  D0 04                        bne @check_esc_r
002A81r 3               
002A81r 3                               ; Double quote (ASCII value 34)
002A81r 3  A9 22                        lda #34
002A83r 3  80 48                        bra @save_character
002A85r 3               
002A85r 3               @check_esc_r:
002A85r 3  C9 72                        cmp #'r'
002A87r 3  D0 04                        bne @check_esc_t
002A89r 3               
002A89r 3                               ; CR (ASCII value 13)
002A89r 3  A9 0D                        lda #13
002A8Br 3  80 40                        bra @save_character
002A8Dr 3               
002A8Dr 3               @check_esc_t:
002A8Dr 3  C9 74                        cmp #'t'
002A8Fr 3  D0 04                        bne @check_esc_v
002A91r 3               
002A91r 3                               ; Horizontal TAB (ASCII value 9)
002A91r 3  A9 09                        lda #9
002A93r 3  80 38                        bra @save_character
002A95r 3               
002A95r 3               @check_esc_v:
002A95r 3  C9 76                        cmp #'v'
002A97r 3  D0 04                        bne @check_esc_z
002A99r 3               
002A99r 3                               ; Vertical TAB (ASCII value 11)
002A99r 3  A9 0B                        lda #11
002A9Br 3  80 30                        bra @save_character
002A9Dr 3               
002A9Dr 3               @check_esc_z:
002A9Dr 3  C9 7A                        cmp #'z'
002A9Fr 3  D0 04                        bne @check_esc_quote
002AA1r 3               
002AA1r 3                               ; NULL (ASCII value 0)
002AA1r 3  A9 00                        lda #0
002AA3r 3  80 28                        bra @save_character
002AA5r 3               
002AA5r 3               @check_esc_quote:
002AA5r 3  C9 22                        cmp #$22
002AA7r 3  D0 04                        bne @check_esc_x
002AA9r 3               
002AA9r 3                               ; Double quote (ASCII value 34)
002AA9r 3  A9 22                        lda #34
002AABr 3  80 20                        bra @save_character
002AADr 3               
002AADr 3               @check_esc_x:
002AADr 3  C9 78                        cmp #'x'
002AAFr 3  D0 06                        bne @check_esc_backslash
002AB1r 3               
002AB1r 3                               ; This one is difficult. We need to get the next TWO
002AB1r 3                               ; characters (which might require a refill in the middle)
002AB1r 3                               ; and combine them as two hex digits. We do this by
002AB1r 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
002AB1r 3                               ; and using bit 0 to keep track of which digit we are on.
002AB1r 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
002AB3r 3  85 27                        sta tmp2+1
002AB5r 3  80 19                        bra @next_character
002AB7r 3               
002AB7r 3               @check_esc_backslash:
002AB7r 3  C9 5C                        cmp #$5C
002AB9r 3  D0 04                        bne @not_escaped
002ABBr 3               
002ABBr 3                               ; Backslash (ASCII value 92)
002ABBr 3  A9 5C                        lda #92
002ABDr 3  80 0E                        bra @save_character
002ABFr 3               
002ABFr 3               @not_escaped:
002ABFr 3                               ; Check for the backslash to see if we should escape
002ABFr 3                               ; the next char.
002ABFr 3  C9 5C                        cmp #$5C        ; The backslash char
002AC1r 3  D0 06                        bne @regular_char
002AC3r 3               
002AC3r 3                               ; We found a backslash.  Don't save anyhing, but set
002AC3r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
002AC3r 3                               ; try to get the next char here as it may require a
002AC3r 3                               ; refill of the input buffer.
002AC3r 3  A9 FF                        lda #$FF
002AC5r 3  85 27                        sta tmp2+1
002AC7r 3  80 07                        bra @next_character
002AC9r 3               
002AC9r 3               @regular_char:
002AC9r 3                               ; Check if the current character is the end of the string.
002AC9r 3  C9 22                        cmp #$22        ; ASCII for "
002ACBr 3  F0 0C                        beq @found_string_end
002ACDr 3               
002ACDr 3               @save_character:
002ACDr 3                               ; If we didn't reach the end of the string, compile this
002ACDr 3                               ; character into the dictionary
002ACDr 3  20 rr rr                     jsr cmpl_a
002AD0r 3               
002AD0r 3               @next_character:
002AD0r 3                               ; Move on to the next character.
002AD0r 3  E6 0C                        inc toin
002AD2r 3  D0 02                        bne @savechars_loop_longjump
002AD4r 3  E6 0D                        inc toin+1
002AD6r 3               
002AD6r 3               @savechars_loop_longjump:
002AD6r 3  4C rr rr                     jmp @savechars_loop
002AD9r 3               
002AD9r 3               @found_string_end:
002AD9r 3                               ; Use up the delimiter.
002AD9r 3  E6 0C                        inc toin
002ADBr 3  D0 02                        bne @1
002ADDr 3  E6 0D                        inc toin+1
002ADFr 3               @1:
002ADFr 3                               ; Calculate the length of the string, which is the
002ADFr 3                               ; difference between cp and the address of the start
002ADFr 3                               ; of the string (currently saved on the stack).
002ADFr 3  A5 00                        lda cp
002AE1r 3  38                           sec
002AE2r 3  F5 02                        sbc 2,x
002AE4r 3  95 00                        sta 0,x         ; LSB
002AE6r 3  A5 01                        lda cp+1
002AE8r 3  F5 03                        sbc 3,x
002AEAr 3  95 01                        sta 1,x         ; MSB
002AECr 3               
002AECr 3                               ; Update the address of the jump-over jmp instruction.
002AECr 3                               ; First determine location of jmp instructions address.
002AECr 3                               ; It should be 2 bytes before the start of the string.
002AECr 3                               ; Compute it into tmp1, which is no longer being used.
002AECr 3  B5 02                        lda 2,x
002AEEr 3  38                           sec
002AEFr 3  E9 02                        sbc #2
002AF1r 3  85 24                        sta tmp1
002AF3r 3  B5 03                        lda 3,x
002AF5r 3  E9 00                        sbc #0          ; Propagate borrow
002AF7r 3  85 25                        sta tmp1+1
002AF9r 3               
002AF9r 3                               ; Update the address of the jump to HERE.
002AF9r 3  A5 00                        lda cp
002AFBr 3  92 24                        sta (tmp1)
002AFDr 3  A0 01                        ldy #1
002AFFr 3  A5 01                        lda cp+1
002B01r 3  91 24                        sta (tmp1),y
002B03r 3               
002B03r 3                               ; What happens next depends on the state (which is bad, but
002B03r 3                               ; that's the way it works at the moment). If we are
002B03r 3                               ; interpretating, we save the string to a transient buffer
002B03r 3                               ; and return that address (used for file calls, see
002B03r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
002B03r 3                               ; compiling, we just need SLITERAL
002B03r 3  A5 16                        lda state
002B05r 3  05 17                        ora state+1             ; paranoid
002B07r 3  F0 03                        beq @done
002B09r 3               
002B09r 3                               ; Jump into the middle of the sliteral word, after the
002B09r 3                               ; string data has been compiled into the dictionary,
002B09r 3                               ; because we've already done that step.
002B09r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
002B0Cr 3               
002B0Cr 3               @done:
002B0Cr 3  60           z_s_quote:      rts
002B0Dr 3               
002B0Dr 3               
002B0Dr 3               
002B0Dr 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
002B0Dr 3               ; ## "s>d"  auto  ANS core
002B0Dr 3                       ; """https://forth-standard.org/standard/core/StoD"""
002B0Dr 3               
002B0Dr 3               xt_s_to_d:
002B0Dr 3  20 rr rr                     jsr underflow_1
002B10r 3               
002B10r 3  CA                           dex
002B11r 3  CA                           dex
002B12r 3  74 00                        stz 0,x
002B14r 3  74 01                        stz 1,x
002B16r 3               
002B16r 3  B5 03                        lda 3,x
002B18r 3  10 04                        bpl @done
002B1Ar 3               
002B1Ar 3                               ; negative, extend sign
002B1Ar 3  D6 00                        dec 0,x
002B1Cr 3  D6 01                        dec 1,x
002B1Er 3               @done:
002B1Er 3  60           z_s_to_d:       rts
002B1Fr 3               
002B1Fr 3               
002B1Fr 3               
002B1Fr 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
002B1Fr 3               ; ## "save-buffers"  tested  ANS block
002B1Fr 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
002B1Fr 3               
002B1Fr 3               xt_save_buffers:
002B1Fr 3                               ; Check the buffer status
002B1Fr 3  A0 2C                        ldy #buffstatus_offset
002B21r 3  B1 1E                        lda (up),y      ; Only bits 0 and 1 are used, so only
002B23r 3  C9 03                        cmp #3          ; LSB is needed.
002B25r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
002B27r 3               
002B27r 3                               ; We need to save the block.
002B27r 3  20 rr rr                     jsr xt_blkbuffer
002B2Ar 3  20 rr rr                     jsr xt_buffblocknum
002B2Dr 3  20 rr rr                     jsr xt_fetch
002B30r 3  20 rr rr                     jsr xt_block_write
002B33r 3               
002B33r 3                               ; Mark the buffer as clean now.
002B33r 3  A9 01                        lda #1
002B35r 3  A0 2C                        ldy #buffstatus_offset
002B37r 3  91 1E                        sta (up),y
002B39r 3               
002B39r 3               @done:
002B39r 3  60           z_save_buffers: rts
002B3Ar 3               
002B3Ar 3               
002B3Ar 3               
002B3Ar 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
002B3Ar 3               ; ## "scr"  auto  ANS block ext
002B3Ar 3                       ; """https://forth-standard.org/standard/block/SCR"""
002B3Ar 3               xt_scr:
002B3Ar 3                               ; SCR is at UP + scr_offset
002B3Ar 3  CA                           dex
002B3Br 3  CA                           dex
002B3Cr 3  18                           clc
002B3Dr 3  A5 1E                        lda up
002B3Fr 3  69 02                        adc #scr_offset ; Add offset
002B41r 3  95 00                        sta 0,x
002B43r 3  A5 1F                        lda up+1
002B45r 3  69 00                        adc #0          ; Adding carry
002B47r 3  95 01                        sta 1,x
002B49r 3               
002B49r 3  60           z_scr:          rts
002B4Ar 3               
002B4Ar 3               
002B4Ar 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
002B4Ar 3               ; ## "search"   auto  ANS string
002B4Ar 3                       ; """https://forth-standard.org/standard/string/SEARCH
002B4Ar 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
002B4Ar 3                       ; addr1 u1). If a match is found the flag will be true and
002B4Ar 3                       ; addr3 will have the address of the start of the match and u3 will have
002B4Ar 3                       ; the number of characters remaining from the match point to the end
002B4Ar 3                       ; of the original string1. If a match is not found, the flag will be
002B4Ar 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
002B4Ar 3                       ; """
002B4Ar 3               
002B4Ar 3               xt_search:
002B4Ar 3  20 rr rr                     jsr underflow_4
002B4Dr 3               
002B4Dr 3                               ; ANS says if the second string is a zero-length string it
002B4Dr 3                               ; automatically matches.
002B4Dr 3  B5 00                        lda 0,x
002B4Fr 3  15 01                        ora 1,x
002B51r 3  D0 0B                        bne @start_search
002B53r 3               
002B53r 3                               ; The second string is a zero length string.  Just remove
002B53r 3                               ; the second string and put a true flag.
002B53r 3  E8                           inx             ; Remove u2
002B54r 3  E8                           inx
002B55r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
002B57r 3  95 00                        sta 0,x
002B59r 3  95 01                        sta 1,x
002B5Br 3  4C rr rr                     jmp z_search
002B5Er 3               
002B5Er 3               @start_search:
002B5Er 3                               ; Put an offset (starting at zero) on the stack.
002B5Er 3  20 rr rr                     jsr xt_zero
002B61r 3               
002B61r 3               @search_loop:
002B61r 3                               ; We stop (not found) when u2 + offset > u1
002B61r 3                               ; Calculate u2+offset into tmp1
002B61r 3  18                           clc
002B62r 3  B5 00                        lda 0,x
002B64r 3  75 02                        adc 2,x
002B66r 3  85 24                        sta tmp1
002B68r 3  B5 01                        lda 1,x
002B6Ar 3  75 03                        adc 3,x
002B6Cr 3               
002B6Cr 3               
002B6Cr 3                               ; Compare to u1. Start with the high byte
002B6Cr 3  D5 07                        cmp 7,x
002B6Er 3  90 12                        bcc @init_comparison ; Obviously less
002B70r 3  D0 06                        bne @not_found
002B72r 3               
002B72r 3                               ; The upper address byte matched - check the lower byte
002B72r 3                               ; Load u1 first so we can use just a carry to check.
002B72r 3  B5 06                        lda 6,x
002B74r 3  C5 24                        cmp tmp1
002B76r 3  B0 0A                        bcs @init_comparison
002B78r 3               
002B78r 3               @not_found:
002B78r 3                               ; The substring isn't in the main string.
002B78r 3                               ; Return just the main string and a false flag.
002B78r 3  E8                           inx             ; Remove offset
002B79r 3  E8                           inx
002B7Ar 3  E8                           inx             ; Remove u2
002B7Br 3  E8                           inx
002B7Cr 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
002B7Er 3  74 01                        stz 1,x
002B80r 3  80 66                        bra z_search
002B82r 3               
002B82r 3               @init_comparison:
002B82r 3                               ; Use tmp1 to hold address in string 1.
002B82r 3                               ; Use tmp2 to hold address in string 2.
002B82r 3                               ; Use tmp3 to hold the number of characters left to check.
002B82r 3               
002B82r 3                               ; Compute the starting address in string 1
002B82r 3                               ; as addr1 + offset
002B82r 3  18                           clc
002B83r 3  B5 08                        lda 8,x
002B85r 3  75 00                        adc 0,x
002B87r 3  85 24                        sta tmp1
002B89r 3  B5 09                        lda 9,x
002B8Br 3  75 01                        adc 1,x
002B8Dr 3  85 25                        sta tmp1+1
002B8Fr 3               
002B8Fr 3                               ; The starting address in string 2 is just addr2.
002B8Fr 3  B5 04                        lda 4,x
002B91r 3  85 26                        sta tmp2
002B93r 3  B5 05                        lda 5,x
002B95r 3  85 27                        sta tmp2+1
002B97r 3               
002B97r 3                               ; The number of characters to check is u2.
002B97r 3  B5 02                        lda 2,x
002B99r 3  85 28                        sta tmp3
002B9Br 3  B5 03                        lda 3,x
002B9Dr 3  85 29                        sta tmp3+1
002B9Fr 3               
002B9Fr 3               @comparison_loop:
002B9Fr 3                               ; Check to see if the current characters match.
002B9Fr 3  B2 24                        lda (tmp1)
002BA1r 3  D2 26                        cmp (tmp2)
002BA3r 3  F0 05                        beq @letters_match
002BA5r 3               
002BA5r 3                               ; One of the letters didn't match.
002BA5r 3                               ; Increment the offset and try again.
002BA5r 3  20 rr rr                     jsr xt_one_plus
002BA8r 3  80 B7                        bra @search_loop
002BAAr 3               
002BAAr 3               @letters_match:
002BAAr 3                               ; The letters match.  Advance the pointers until the
002BAAr 3                               ; count reaches zero.
002BAAr 3  E6 24                        inc tmp1
002BACr 3  D0 02                        bne @1
002BAEr 3  E6 25                        inc tmp1+1
002BB0r 3               @1:
002BB0r 3  E6 26                        inc tmp2
002BB2r 3  D0 02                        bne @2
002BB4r 3  E6 27                        inc tmp2+1
002BB6r 3               @2:
002BB6r 3                               ; Decrement the count of remaining letters to check.
002BB6r 3  A5 28                        lda tmp3
002BB8r 3  D0 02                        bne @3
002BBAr 3  C6 29                        dec tmp3+1
002BBCr 3               @3:
002BBCr 3  C6 28                        dec tmp3
002BBEr 3               
002BBEr 3                               ; Check if we've reached zero.
002BBEr 3  A5 28                        lda tmp3
002BC0r 3  05 29                        ora tmp3+1
002BC2r 3  D0 DB                        bne @comparison_loop ; Check the next letter
002BC4r 3               
002BC4r 3                               ; We've run out of letters and they all match!
002BC4r 3                               ; Return (addr1+offset) (u1-offset) true
002BC4r 3                               ; Add offset to addr1.
002BC4r 3  18                           clc
002BC5r 3  B5 00                        lda 0,x
002BC7r 3  75 08                        adc 8,x
002BC9r 3  95 08                        sta 8,x
002BCBr 3  B5 01                        lda 1,x
002BCDr 3  75 09                        adc 9,x
002BCFr 3  95 09                        sta 9,x
002BD1r 3               
002BD1r 3                               ; Subtract offset from u1.
002BD1r 3  38                           sec
002BD2r 3  B5 06                        lda 6,x
002BD4r 3  F5 00                        sbc 0,x
002BD6r 3  95 06                        sta 6,x
002BD8r 3  B5 07                        lda 7,x
002BDAr 3  F5 01                        sbc 1,x
002BDCr 3  95 07                        sta 7,x
002BDEr 3               
002BDEr 3                               ; Replace addr2, u2, and offset with a true flag.
002BDEr 3  E8                           inx             ; drop offset
002BDFr 3  E8                           inx
002BE0r 3  E8                           inx             ; drop u2
002BE1r 3  E8                           inx
002BE2r 3  A9 FF                        lda #$FF
002BE4r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
002BE6r 3  95 01                        sta 1,x
002BE8r 3               
002BE8r 3  60           z_search:       rts
002BE9r 3               
002BE9r 3               
002BE9r 3               
002BE9r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
002BE9r 3               ; ## ";"  auto  ANS core
002BE9r 3                       ; """https://forth-standard.org/standard/core/Semi
002BE9r 3                       ; End the compilation of a new word into the Dictionary.
002BE9r 3                       ;
002BE9r 3                       ; When we
002BE9r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
002BE9r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
002BE9r 3                       ; A Forth definition would be (see "Starting Forth"):
002BE9r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
002BE9r 3                       ; practice of Gforth, we warn here if a word has been redefined.
002BE9r 3                       ; """
002BE9r 3               
002BE9r 3               xt_semicolon:
002BE9r 3                               ; Check if this is a : word or a :NONAME word.
002BE9r 3  24 20                        bit status
002BEBr 3  70 11                        bvs @colonword
002BEDr 3               
002BEDr 3                               ; This is a :NONAME word - just put an RTS on the end and
002BEDr 3                               ; the address (held in workword) on the stack.
002BEDr 3  A9 60                        lda #$60                ; opcode for RTS
002BEFr 3  20 rr rr                     jsr cmpl_a
002BF2r 3               
002BF2r 3  CA                           dex
002BF3r 3  CA                           dex
002BF4r 3  A5 04                        lda workword
002BF6r 3  95 00                        sta 0,x
002BF8r 3  A5 05                        lda workword+1
002BFAr 3  95 01                        sta 1,x
002BFCr 3  80 45                        bra @semicolon_done
002BFEr 3               
002BFEr 3               @colonword:
002BFEr 3                               ; CP is the byte that will be the address we use in the
002BFEr 3                               ; header as the end-of-compile address (z_word). This is
002BFEr 3                               ; six bytes down from the header
002BFEr 3  A0 06                        ldy #6
002C00r 3  A5 00                        lda cp
002C02r 3  91 04                        sta (workword),y
002C04r 3  C8                           iny
002C05r 3  A5 01                        lda cp+1
002C07r 3  91 04                        sta (workword),y
002C09r 3               
002C09r 3                               ; Allocate one further byte and save the RTS instruction
002C09r 3                               ; there
002C09r 3  A9 60                        lda #$60                ; opcode for RTS
002C0Br 3  20 rr rr                     jsr cmpl_a
002C0Er 3               
002C0Er 3                               ; Before we formally add the word to the Dictionary, we
002C0Er 3                               ; check to see if it is already present, and if yes, we
002C0Er 3                               ; warn the user.
002C0Er 3               
002C0Er 3                               ; See if word already in Dictionary.
002C0Er 3                               ; (STATUS bit 7 will be high as CREATE already
002C0Er 3                               ;  checked for us.)
002C0Er 3  24 20                        bit status
002C10r 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
002C12r 3               
002C12r 3                               ; We start by putting the string of the
002C12r 3                               ; word we're defining on the stack
002C12r 3  CA                           dex
002C13r 3  CA                           dex
002C14r 3  CA                           dex
002C15r 3  CA                           dex
002C16r 3               
002C16r 3                               ; WORKWORD points to the beginning of the head of our new
002C16r 3                               ; word, where the first byte is the length of the string
002C16r 3                               ; We can't use LATESTNT because we haven't added the new
002C16r 3                               ; word to the Dictionary yet
002C16r 3  B2 04                        lda (workword)
002C18r 3  95 00                        sta 0,x
002C1Ar 3  74 01                        stz 1,x
002C1Cr 3               
002C1Cr 3                               ; Eight bytes below WORKWORD is the actual beginning of
002C1Cr 3                               ; the string
002C1Cr 3  A5 04                        lda workword
002C1Er 3  18                           clc
002C1Fr 3  69 08                        adc #8
002C21r 3  95 02                        sta 2,x
002C23r 3  A5 05                        lda workword+1
002C25r 3  69 00                        adc #0                  ; only want carry
002C27r 3  95 03                        sta 3,x
002C29r 3               
002C29r 3                               ; This word is already in the Dictionary, so we print a
002C29r 3                               ; warning to the user.
002C29r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
002C2Br 3  20 rr rr                     jsr print_string_no_lf
002C2Er 3               
002C2Er 3                               ; Now we print the offending word.
002C2Er 3  20 rr rr                     jsr xt_type
002C31r 3  20 rr rr                     jsr xt_space
002C34r 3               
002C34r 3                               ; Clear bit 7 of status (so future words will print message
002C34r 3                               ; by defaut)
002C34r 3  A9 80                        lda #%10000000
002C36r 3  14 20                        trb status
002C38r 3               
002C38r 3               @new_word:
002C38r 3                               ; Let's get this over with. Save beginning of our word
002C38r 3                               ; as new last word in the Dictionary
002C38r 3  A5 04                        lda workword
002C3Ar 3  85 02                        sta dp
002C3Cr 3  A5 05                        lda workword+1
002C3Er 3  85 03                        sta dp+1
002C40r 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
002C43r 3                                                       ; CURRENT wordlist.
002C43r 3               @semicolon_done:
002C43r 3                               ; Word definition complete. Return compile flag to zero
002C43r 3                               ; to return to interpret mode
002C43r 3  64 16                        stz state
002C45r 3  64 17                        stz state+1
002C47r 3               
002C47r 3  60           z_semicolon:    rts
002C48r 3               
002C48r 3               
002C48r 3               
002C48r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
002C48r 3               ; ## "sign"  auto  ANS core
002C48r 3                       ; """https://forth-standard.org/standard/core/SIGN
002C48r 3                       ;
002C48r 3                       ; Code based on
002C48r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
002C48r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
002C48r 3                       ; """
002C48r 3               
002C48r 3               xt_sign:
002C48r 3  20 rr rr                     jsr underflow_1
002C4Br 3               
002C4Br 3  B5 01                        lda 1,x         ; check MSB of TOS
002C4Dr 3  30 04                        bmi @minus
002C4Fr 3               
002C4Fr 3  E8                           inx
002C50r 3  E8                           inx
002C51r 3  80 09                        bra @done
002C53r 3               @minus:
002C53r 3  A9 2D                        lda #$2D        ; ASCII for "-"
002C55r 3  95 00                        sta 0,x         ; overwrite TOS
002C57r 3  74 01                        stz 1,x         ; paranoid
002C59r 3               
002C59r 3  20 rr rr                     jsr xt_hold
002C5Cr 3               @done:
002C5Cr 3  60           z_sign:         rts
002C5Dr 3               
002C5Dr 3               
002C5Dr 3               
002C5Dr 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
002C5Dr 3               ; ## "/"  auto  ANS core
002C5Dr 3                       ; """https://forth-standard.org/standard/core/Div
002C5Dr 3                       ;
002C5Dr 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
002C5Dr 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
002C5Dr 3                       ; This code is currently unoptimized. This code without the SLASH
002C5Dr 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
002C5Dr 3                       ; """
002C5Dr 3               
002C5Dr 3               xt_slash:
002C5Dr 3                               ; With all the multiplication going on, it would be hard to
002C5Dr 3                               ; make sure that one of our temporary variables is not
002C5Dr 3                               ; overwritten. We make sure that doesn't happen by taking the
002C5Dr 3                               ; hit of pushing the flag to the 65c02's stack
002C5Dr 3  A9 00                        lda #0
002C5Fr 3  48                           pha
002C60r 3  80 03                        bra _common
002C62r 3               
002C62r 3               xt_slash_mod:
002C62r 3                               ; Note that /MOD accesses this code
002C62r 3  A9 FF                        lda #$FF
002C64r 3  48                           pha             ; falls through to _common
002C65r 3               
002C65r 3               _common:
002C65r 3  20 rr rr                     jsr xt_to_r             ; >R
002C68r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
002C6Br 3  20 rr rr                     jsr xt_r_from           ; R>
002C6Er 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
002C71r 3               
002C71r 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
002C71r 3                               ; $FF is SLASH MOD
002C71r 3  68                           pla
002C72r 3  D0 05                        bne @done
002C74r 3               
002C74r 3                               ; The following code is for SLASH only
002C74r 3  20 rr rr                     jsr xt_swap
002C77r 3  E8                           inx             ; DROP
002C78r 3  E8                           inx
002C79r 3               @done:
002C79r 3               z_slash_mod:
002C79r 3  60           z_slash:        rts
002C7Ar 3               
002C7Ar 3               
002C7Ar 3               
002C7Ar 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
002C7Ar 3               ; ## "/mod"  auto  ANS core
002C7Ar 3                       ; """https://forth-standard.org/standard/core/DivMOD
002C7Ar 3                       ;
002C7Ar 3                       ; This is a dummy entry, the actual code is shared with SLASH
002C7Ar 3                       ; """
002C7Ar 3               
002C7Ar 3               
002C7Ar 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
002C7Ar 3               ; ## "/string"  auto  ANS string
002C7Ar 3                       ; """https://forth-standard.org/standard/string/DivSTRING
002C7Ar 3                       ;
002C7Ar 3                       ; Forth code is
002C7Ar 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
002C7Ar 3                       ; Put differently, we need to add TOS and 3OS, and subtract
002C7Ar 3                       ; TOS from NOS, and then drop TOS
002C7Ar 3                       ; """
002C7Ar 3               
002C7Ar 3               xt_slash_string:
002C7Ar 3  20 rr rr                     jsr underflow_3
002C7Dr 3               
002C7Dr 3  18                           clc             ; 3OS+TOS
002C7Er 3  B5 00                        lda 0,x
002C80r 3  75 04                        adc 4,x
002C82r 3  95 04                        sta 4,x
002C84r 3               
002C84r 3  B5 01                        lda 1,x
002C86r 3  75 05                        adc 5,x
002C88r 3  95 05                        sta 5,x
002C8Ar 3               
002C8Ar 3  38                           sec             ; NOS-TOS
002C8Br 3  B5 02                        lda 2,x
002C8Dr 3  F5 00                        sbc 0,x
002C8Fr 3  95 02                        sta 2,x
002C91r 3               
002C91r 3  B5 03                        lda 3,x
002C93r 3  F5 01                        sbc 1,x
002C95r 3  95 03                        sta 3,x
002C97r 3               
002C97r 3  E8                           inx
002C98r 3  E8                           inx
002C99r 3               
002C99r 3  60           z_slash_string: rts
002C9Ar 3               
002C9Ar 3               
002C9Ar 3               
002C9Ar 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
002C9Ar 3               ; ## "sliteral" auto  ANS string
002C9Ar 3                       ; """https://forth-standard.org/standard/string/SLITERAL
002C9Ar 3                       ; Add the runtime for an existing string.
002C9Ar 3                       ; """
002C9Ar 3               
002C9Ar 3               xt_sliteral:
002C9Ar 3  20 rr rr                     jsr underflow_2
002C9Dr 3               
002C9Dr 3                               ; We can't assume that ( addr u ) of the current string is in
002C9Dr 3                               ; a stable area (eg. already in the dictionary.) Copy the
002C9Dr 3                               ; string data into the dictionary using move.
002C9Dr 3               
002C9Dr 3                               ; Put a jmp over the string data with address to be filled
002C9Dr 3                               ; in later.
002C9Dr 3  A9 4C                        lda #$4C
002C9Fr 3  20 rr rr                     jsr cmpl_a
002CA2r 3               
002CA2r 3                               ; Address to be filled in later.
002CA2r 3  20 rr rr                     jsr cmpl_a
002CA5r 3  20 rr rr                     jsr cmpl_a
002CA8r 3               
002CA8r 3                               ; Turn the data stack from ( addr u ) into
002CA8r 3                               ; ( here u addr here u ) so move can be called with
002CA8r 3                               ; the remaining items on the stack ready for processing.
002CA8r 3                               ; Reserve three extra words on the stack.
002CA8r 3  8A                           txa
002CA9r 3  38                           sec
002CAAr 3  E9 06                        sbc #6
002CACr 3  AA                           tax
002CADr 3               
002CADr 3                               ; Move addr down from TOS-4 to TOS-2
002CADr 3  B5 08                        lda 8,x
002CAFr 3  95 04                        sta 4,x
002CB1r 3  B5 09                        lda 9,x
002CB3r 3  95 05                        sta 5,x
002CB5r 3               
002CB5r 3                               ; Copy u from TOS-3 to TOS
002CB5r 3  B5 06                        lda 6,x
002CB7r 3  95 00                        sta 0,x
002CB9r 3  B5 07                        lda 7,x
002CBBr 3  95 01                        sta 1,x
002CBDr 3               
002CBDr 3                               ; Put HERE into TOS-1 and TOS-4
002CBDr 3  A5 00                        lda cp
002CBFr 3  95 08                        sta 8,x
002CC1r 3  95 02                        sta 2,x
002CC3r 3  A5 01                        lda cp+1
002CC5r 3  95 09                        sta 9,x
002CC7r 3  95 03                        sta 3,x
002CC9r 3               
002CC9r 3                               ; Copy the string into the dictionary.
002CC9r 3  20 rr rr                     jsr xt_move
002CCCr 3               
002CCCr 3                               ; Update cp.
002CCCr 3  18                           clc
002CCDr 3  A5 00                        lda cp
002CCFr 3  75 00                        adc 0,x
002CD1r 3  85 00                        sta cp
002CD3r 3  A5 01                        lda cp+1
002CD5r 3  75 01                        adc 1,x
002CD7r 3  85 01                        sta cp+1
002CD9r 3               
002CD9r 3                               ; Update the address of the jump-over jmp instruction.
002CD9r 3                               ; First determine location of jmp instructions address.
002CD9r 3                               ; It should be 2 bytes before the start of the string.
002CD9r 3               
002CD9r 3                               ; Compute it into tmp1, which is no longer being used.
002CD9r 3  B5 02                        lda 2,x
002CDBr 3  38                           sec
002CDCr 3  E9 02                        sbc #2
002CDEr 3  85 24                        sta tmp1
002CE0r 3  B5 03                        lda 3,x
002CE2r 3  E9 00                        sbc #0          ; Propagate borrow
002CE4r 3  85 25                        sta tmp1+1
002CE6r 3               
002CE6r 3                               ; Update the address of the jump to HERE.
002CE6r 3  A5 00                        lda cp
002CE8r 3  92 24                        sta (tmp1)
002CEAr 3  A0 01                        ldy #1
002CECr 3  A5 01                        lda cp+1
002CEEr 3  91 24                        sta (tmp1),y
002CF0r 3               
002CF0r 3                               ; Stack is now ( addr2 u ) where addr2 is the new
002CF0r 3                               ; location in the dictionary.
002CF0r 3               
002CF0r 3               sliteral_const_str:
002CF0r 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
002CF0r 3                               ; pushes the new ( addr u ) pair to the Data Stack.
002CF0r 3                               ; When we're done, the code will look like this:
002CF0r 3               
002CF0r 3                               ; xt -->    jmp a
002CF0r 3                               ;           <string data bytes>
002CF0r 3                               ;  a -->    jsr sliteral_runtime
002CF0r 3                               ;           <string address>
002CF0r 3                               ;           <string length>
002CF0r 3                               ; rts -->
002CF0r 3               
002CF0r 3                               ; This means we'll have to adjust the return address for two
002CF0r 3                               ; cells, not just one
002CF0r 3  A0 rr                        ldy #>sliteral_runtime
002CF2r 3  A9 rr                        lda #<sliteral_runtime
002CF4r 3  20 rr rr                     jsr cmpl_subroutine
002CF7r 3               
002CF7r 3                               ; We want to have the address end up as NOS and the length
002CF7r 3                               ; as TOS, so we store the address first
002CF7r 3  B4 03                        ldy 3,x                ; address MSB
002CF9r 3  B5 02                        lda 2,x                ; address LSB
002CFBr 3  20 rr rr                     jsr cmpl_word
002CFEr 3               
002CFEr 3  B4 01                        ldy 1,x                ; length MSB
002D00r 3  B5 00                        lda 0,x                ; length LSB
002D02r 3  20 rr rr                     jsr cmpl_word
002D05r 3               
002D05r 3                               ; clean up and leave
002D05r 3  E8                           inx
002D06r 3  E8                           inx
002D07r 3  E8                           inx
002D08r 3  E8                           inx
002D09r 3               
002D09r 3  60           z_sliteral:     rts
002D0Ar 3               
002D0Ar 3               
002D0Ar 3               sliteral_runtime:
002D0Ar 3               
002D0Ar 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
002D0Ar 3                       ; the Data Stack. We arrive here with the return address as the
002D0Ar 3                       ; top of Return Stack, which points to the address of the string
002D0Ar 3                       ; """
002D0Ar 3  CA                           dex
002D0Br 3  CA                           dex
002D0Cr 3  CA                           dex
002D0Dr 3  CA                           dex
002D0Er 3               
002D0Er 3                               ; Get the address of the string address off the stack and
002D0Er 3                               ; increase by one because of the RTS mechanics
002D0Er 3  68                           pla
002D0Fr 3  85 24                        sta tmp1        ; LSB of address
002D11r 3  68                           pla
002D12r 3  85 25                        sta tmp1+1      ; MSB of address
002D14r 3               
002D14r 3                               ; Walk through both and save them
002D14r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002D16r 3  B1 24                        lda (tmp1),y
002D18r 3  95 02                        sta 2,x         ; LSB of address
002D1Ar 3  C8                           iny
002D1Br 3               
002D1Br 3  B1 24                        lda (tmp1),y
002D1Dr 3  95 03                        sta 3,x         ; MSB of address
002D1Fr 3  C8                           iny
002D20r 3               
002D20r 3  B1 24                        lda (tmp1),y
002D22r 3  95 00                        sta 0,x         ; LSB of length
002D24r 3  C8                           iny
002D25r 3               
002D25r 3  B1 24                        lda (tmp1),y
002D27r 3  95 01                        sta 1,x         ; MSB of length
002D29r 3               
002D29r 3                               ; restore return address
002D29r 3  18                           clc
002D2Ar 3  A5 24                        lda tmp1
002D2Cr 3  69 04                        adc #4
002D2Er 3  A8                           tay             ; LSB
002D2Fr 3  A5 25                        lda tmp1+1
002D31r 3  69 00                        adc #0          ; we only need carry
002D33r 3  48                           pha             ; MSB
002D34r 3  5A                           phy
002D35r 3               
002D35r 3  60                           rts
002D36r 3               
002D36r 3               
002D36r 3               
002D36r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002D36r 3               ; ## "sm/rem"  auto  ANS core
002D36r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002D36r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002D36r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002D36r 3                       ;
002D36r 3                       ; Forth:
002D36r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002D36r 3                       ; R> ?NEGATE SWAP
002D36r 3                       ; """
002D36r 3               
002D36r 3               xt_sm_slash_rem:
002D36r 3  20 rr rr                     jsr underflow_3 ; contains double number
002D39r 3               
002D39r 3                               ; push MSB of high cell of d to Data Stack so we can check
002D39r 3                               ; its sign later
002D39r 3  B5 03                        lda 3,x
002D3Br 3  48                           pha
002D3Cr 3               
002D3Cr 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
002D3Cr 3                               ; its sign later as well
002D3Cr 3  B5 01                        lda 1,x
002D3Er 3  55 03                        eor 3,x
002D40r 3  48                           pha
002D41r 3               
002D41r 3                               ; Prepare division by getting absolute of n1 and d
002D41r 3  20 rr rr                     jsr xt_abs
002D44r 3  E8                           inx             ; pretend we pushed n1 to R
002D45r 3  E8                           inx
002D46r 3               
002D46r 3  20 rr rr                     jsr xt_dabs
002D49r 3  CA                           dex
002D4Ar 3  CA                           dex
002D4Br 3               
002D4Br 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
002D4Er 3               
002D4Er 3                               ; if the XOR compiled above is negative, negate the
002D4Er 3                               ; quotient (n3)
002D4Er 3  68                           pla
002D4Fr 3  10 03                        bpl @1
002D51r 3  20 rr rr                     jsr xt_negate
002D54r 3               @1:
002D54r 3                               ; if d was negative, negate the remainder (n2)
002D54r 3  68                           pla
002D55r 3  10 07                        bpl @done
002D57r 3               
002D57r 3  E8                           inx             ; pretend we pushed quotient to R
002D58r 3  E8                           inx
002D59r 3  20 rr rr                     jsr xt_negate
002D5Cr 3  CA                           dex
002D5Dr 3  CA                           dex
002D5Er 3               
002D5Er 3               @done:
002D5Er 3  60           z_sm_slash_rem: rts
002D5Fr 3               
002D5Fr 3               
002D5Fr 3               
002D5Fr 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002D5Fr 3               ; ## "source"  auto  ANS core
002D5Fr 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002D5Fr 3               xt_source:
002D5Fr 3                               ; add address
002D5Fr 3  CA                           dex
002D60r 3  CA                           dex
002D61r 3  A5 08                        lda cib
002D63r 3  95 00                        sta 0,x
002D65r 3  A5 09                        lda cib+1
002D67r 3  95 01                        sta 1,x
002D69r 3               
002D69r 3                               ; add size
002D69r 3  CA                           dex
002D6Ar 3  CA                           dex
002D6Br 3  A5 0A                        lda ciblen
002D6Dr 3  95 00                        sta 0,x
002D6Fr 3  A5 0B                        lda ciblen+1
002D71r 3  95 01                        sta 1,x
002D73r 3               
002D73r 3  60           z_source:       rts
002D74r 3               
002D74r 3               
002D74r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002D74r 3               ; ## "source-id"  tested  ANS core ext
002D74r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002D74r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002D74r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002D74r 3                       ; string, and a text file gives the fileid.
002D74r 3                       ; """
002D74r 3               xt_source_id:
002D74r 3  CA                           dex
002D75r 3  CA                           dex
002D76r 3               
002D76r 3  A5 06                        lda insrc
002D78r 3  95 00                        sta 0,x
002D7Ar 3  A5 07                        lda insrc+1
002D7Cr 3  95 01                        sta 1,x
002D7Er 3               
002D7Er 3  60           z_source_id:    rts
002D7Fr 3               
002D7Fr 3               
002D7Fr 3               ; ## SPACE ( -- ) "Print a single space"
002D7Fr 3               ; ## "space"  auto  ANS core
002D7Fr 3                       ; """https://forth-standard.org/standard/core/SPACE"""
002D7Fr 3               xt_space:
002D7Fr 3  A9 20                        lda #AscSP
002D81r 3  20 rr rr                     jsr emit_a
002D84r 3               
002D84r 3  60           z_space:        rts
002D85r 3               
002D85r 3               
002D85r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
002D85r 3               ; ## "spaces"  auto  ANS core
002D85r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
002D85r 3               
002D85r 3               xt_spaces:
002D85r 3  20 rr rr                     jsr underflow_1
002D88r 3               
002D88r 3                               ; catch any zero in TOS fast
002D88r 3  B5 00                        lda 0,x
002D8Ar 3  15 01                        ora 1,x
002D8Cr 3  F0 2A                        beq @done
002D8Er 3               
002D8Er 3                               ; Usually we're only going to print far less than 256 spaces,
002D8Er 3                               ; so we create a quick loop for that. Short loop could be realized
002D8Er 3                               ; as a separate subroutine, but unless we're really pressed for
002D8Er 3                               ; memory at some point, this is faster
002D8Er 3  B4 01                        ldy 1,x
002D90r 3  D0 0C                        bne @lots_of_spaces
002D92r 3               
002D92r 3  B4 00                        ldy 0,x
002D94r 3               @quick_loop:
002D94r 3                               ; we reach here knowing that there must be a number that is not
002D94r 3                               ; zero in the TOS
002D94r 3  A9 20                        lda #AscSP
002D96r 3  20 rr rr                     jsr emit_a
002D99r 3  88                           dey
002D9Ar 3  F0 1C                        beq @done
002D9Cr 3  80 F6                        bra @quick_loop
002D9Er 3               
002D9Er 3               @lots_of_spaces:
002D9Er 3                               ; We go through the first loop once to get rid of the lower
002D9Er 3                               ; counter byte. This could be zero
002D9Er 3  B4 00                        ldy 0,x
002DA0r 3               
002DA0r 3               @first_slow_loop:
002DA0r 3  F0 08                        beq @slow_outer_loop
002DA2r 3  A9 20                        lda #AscSP
002DA4r 3  20 rr rr                     jsr emit_a
002DA7r 3  88                           dey
002DA8r 3  80 F6                        bra @first_slow_loop
002DAAr 3               
002DAAr 3               @slow_outer_loop:
002DAAr 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
002DAAr 3  A0 00                        ldy #00
002DACr 3               
002DACr 3               @slow_inner_loop:
002DACr 3  A9 20                        lda #AscSP
002DAEr 3  20 rr rr                     jsr emit_a
002DB1r 3  88                           dey
002DB2r 3  D0 F8                        bne @slow_inner_loop
002DB4r 3               
002DB4r 3  D6 01                        dec 1,x
002DB6r 3  D0 F2                        bne @slow_outer_loop
002DB8r 3               
002DB8r 3               @done:
002DB8r 3  E8                           inx             ; drop
002DB9r 3  E8                           inx
002DBAr 3               
002DBAr 3  60           z_spaces:       rts
002DBBr 3               
002DBBr 3               
002DBBr 3               
002DBBr 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
002DBBr 3               ; ## "*"  auto  ANS core
002DBBr 3                       ; """https://forth-standard.org/standard/core/Times
002DBBr 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
002DBBr 3                       ;
002DBBr 3                       ; This is nothing  more than UM* DROP
002DBBr 3                       ; """
002DBBr 3               
002DBBr 3               xt_star:
002DBBr 3  20 rr rr                     jsr underflow_2
002DBEr 3               
002DBEr 3  20 rr rr                     jsr xt_um_star
002DC1r 3  E8                           inx
002DC2r 3  E8                           inx
002DC3r 3               
002DC3r 3  60           z_star:         rts
002DC4r 3               
002DC4r 3               
002DC4r 3               
002DC4r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
002DC4r 3               ; ## "*/"  auto  ANS core
002DC4r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
002DC4r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
002DC4r 3                       ; without a remainder. This is */MOD without the mod.
002DC4r 3                       ;
002DC4r 3                       ; This word
002DC4r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
002DC4r 3                       ; pretty much what we do here
002DC4r 3                       ; """
002DC4r 3               xt_star_slash:
002DC4r 3                               ; We let */MOD check for underflow
002DC4r 3  20 rr rr                     jsr xt_star_slash_mod
002DC7r 3  20 rr rr                     jsr xt_swap
002DCAr 3  E8                           inx
002DCBr 3  E8                           inx
002DCCr 3               z_star_slash:
002DCCr 3  60                           rts
002DCDr 3               
002DCDr 3               
002DCDr 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
002DCDr 3               ; ## "*/mod"  auto  ANS core
002DCDr 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
002DCDr 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
002DCDr 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
002DCDr 3                       ; single-cell quotient n5.
002DCDr 3                       ;
002DCDr 3                       ; In Forth, this is
002DCDr 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
002DCDr 3                       ; """
002DCDr 3               xt_star_slash_mod:
002DCDr 3  20 rr rr                     jsr underflow_3
002DD0r 3               
002DD0r 3  20 rr rr                     jsr xt_to_r
002DD3r 3  20 rr rr                     jsr xt_m_star
002DD6r 3  20 rr rr                     jsr xt_r_from
002DD9r 3  20 rr rr                     jsr xt_sm_slash_rem
002DDCr 3               
002DDCr 3               z_star_slash_mod:
002DDCr 3  60                           rts
002DDDr 3               
002DDDr 3               
002DDDr 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002DDDr 3               ; ## "state"  auto  ANS core
002DDDr 3                       ; """https://forth-standard.org/standard/core/STATE
002DDDr 3                       ; STATE is true when in compilation state, false otherwise. Note
002DDDr 3                       ; we do not return the state itself, but only the address where
002DDDr 3                       ; it lives. The state should not be changed directly by the user; see
002DDDr 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002DDDr 3                       ; """
002DDDr 3               xt_state:
002DDDr 3  CA                           dex
002DDEr 3  CA                           dex
002DDFr 3  A9 16                        lda #<state
002DE1r 3  95 00                        sta 0,x
002DE3r 3  A9 00                        lda #>state
002DE5r 3  95 01                        sta 1,x
002DE7r 3               
002DE7r 3  60           z_state:        rts
002DE8r 3               
002DE8r 3               
002DE8r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002DE8r 3               ; ## "!"  auto  ANS core
002DE8r 3                       ; """https://forth-standard.org/standard/core/Store"""
002DE8r 3               xt_store:
002DE8r 3  20 rr rr                     jsr underflow_2
002DEBr 3               
002DEBr 3  B5 02                        lda 2,x         ; LSB
002DEDr 3  81 00                        sta (0,x)
002DEFr 3               
002DEFr 3  F6 00                        inc 0,x
002DF1r 3  D0 02                        bne @1
002DF3r 3  F6 01                        inc 1,x
002DF5r 3               @1:
002DF5r 3  B5 03                        lda 3,x         ; MSB
002DF7r 3  81 00                        sta (0,x)
002DF9r 3               
002DF9r 3  E8                           inx             ; 2DROP
002DFAr 3  E8                           inx
002DFBr 3  E8                           inx
002DFCr 3  E8                           inx
002DFDr 3               
002DFDr 3  60           z_store:        rts
002DFEr 3               
002DFEr 3               
002DFEr 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
002DFEr 3               ; ## "strip-underflow"  tested  Tali Forth
002DFEr 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
002DFEr 3                       ; checking should be removed during the compilation of new words.
002DFEr 3                       ; Default is false.
002DFEr 3                       ; """
002DFEr 3               xt_strip_underflow:
002DFEr 3  CA                           dex
002DFFr 3  CA                           dex
002E00r 3               
002E00r 3  A9 1C                        lda #<uf_strip
002E02r 3  95 00                        sta 0,x
002E04r 3  A9 00                        lda #>uf_strip
002E06r 3  95 01                        sta 1,x
002E08r 3               
002E08r 3               z_strip_underflow:
002E08r 3  60                           rts
002E09r 3               
002E09r 3               
002E09r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
002E09r 3               ; ## "swap"  auto  ANS core
002E09r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
002E09r 3               xt_swap:
002E09r 3  20 rr rr                     jsr underflow_2
002E0Cr 3               
002E0Cr 3  B5 00                        lda 0,x         ; LSB
002E0Er 3  B4 02                        ldy 2,x
002E10r 3  95 02                        sta 2,x
002E12r 3  94 00                        sty 0,x
002E14r 3               
002E14r 3  B5 01                        lda 1,x         ; MSB
002E16r 3  B4 03                        ldy 3,x
002E18r 3  95 03                        sta 3,x
002E1Ar 3  94 01                        sty 1,x
002E1Cr 3               
002E1Cr 3  60           z_swap:         rts
002E1Dr 3               
002E1Dr 3               
002E1Dr 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
002E1Dr 3               ; ## "then"  auto  ANS core
002E1Dr 3                       ; """http://forth-standard.org/standard/core/THEN"""
002E1Dr 3               xt_then:
002E1Dr 3                               ; Get the address to jump to.
002E1Dr 3  20 rr rr                     jsr xt_here
002E20r 3               
002E20r 3                               ; Stuff HERE in for the branch address back
002E20r 3                               ; at the IF or ELSE (origination address is on stack).
002E20r 3  20 rr rr                     jsr xt_swap
002E23r 3  20 rr rr                     jsr xt_store
002E26r 3               
002E26r 3  60           z_then:         rts
002E27r 3               
002E27r 3               
002E27r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002E27r 3               ; ## "thru"  tested  ANS block ext
002E27r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002E27r 3               
002E27r 3               xt_thru:
002E27r 3  20 rr rr                     jsr underflow_2
002E2Ar 3               
002E2Ar 3                               ; We need to loop here, and can't use the data stack
002E2Ar 3                               ; because the LOADed screens might use it.  We'll
002E2Ar 3                               ; need to use the same trick that DO loops use, holding
002E2Ar 3                               ; the limit and current index on the return stack.
002E2Ar 3               
002E2Ar 3                               ; Put the ending screen number on the return stack
002E2Ar 3  B5 01                        lda 1,x
002E2Cr 3  48                           pha
002E2Dr 3  B5 00                        lda 0,x
002E2Fr 3  48                           pha
002E30r 3  E8                           inx
002E31r 3  E8                           inx
002E32r 3               @thru_loop:
002E32r 3                               ; Put the starting screen number on the stack,
002E32r 3                               ; but keep a copy
002E32r 3  B5 01                        lda 1,x
002E34r 3  48                           pha
002E35r 3  B5 00                        lda 0,x
002E37r 3  48                           pha
002E38r 3               
002E38r 3                               ; Load this screen.
002E38r 3  20 rr rr                     jsr xt_load
002E3Br 3               
002E3Br 3                               ; Get the number and limit back off the stack.  Rather than
002E3Br 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
002E3Br 3               
002E3Br 3                               ; Get the screen we just loaded.
002E3Br 3  68                           pla
002E3Cr 3  85 24                        sta tmp1
002E3Er 3  68                           pla
002E3Fr 3  85 25                        sta tmp1+1
002E41r 3               
002E41r 3                               ; Get the ending screen.
002E41r 3  68                           pla
002E42r 3  85 26                        sta tmp2
002E44r 3  68                           pla
002E45r 3  85 27                        sta tmp2+1
002E47r 3               
002E47r 3                               ; See if we just loaded the last screen.
002E47r 3                               ; A already has the MSB of the last screen in it.
002E47r 3  C5 25                        cmp tmp1+1
002E49r 3  D0 08                        bne @next_screen
002E4Br 3  A5 26                        lda tmp2        ; Compare the LSB
002E4Dr 3  C5 24                        cmp tmp1
002E4Fr 3  D0 02                        bne @next_screen
002E51r 3  80 18                        bra @done       ; We just did the last screen.
002E53r 3               
002E53r 3               @next_screen:
002E53r 3                               ; Put the ending screen back on the data stack.
002E53r 3  A5 27                        lda tmp2+1
002E55r 3  48                           pha
002E56r 3  A5 26                        lda tmp2
002E58r 3  48                           pha
002E59r 3               
002E59r 3                               ; Increment the current screen.
002E59r 3  E6 24                        inc tmp1
002E5Br 3  D0 02                        bne @1
002E5Dr 3  E6 25                        inc tmp1+1
002E5Fr 3               @1:
002E5Fr 3                               ; Put the current screen on the stack to prepare for
002E5Fr 3                               ; the next loop.
002E5Fr 3  CA                           dex
002E60r 3  CA                           dex
002E61r 3  A5 24                        lda tmp1
002E63r 3  95 00                        sta 0,x
002E65r 3  A5 25                        lda tmp1+1
002E67r 3  95 01                        sta 1,x
002E69r 3  80 C7                        bra @thru_loop
002E6Br 3               @done:
002E6Br 3  60           z_thru:         rts
002E6Cr 3               
002E6Cr 3               
002E6Cr 3               
002E6Cr 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
002E6Cr 3               ; ## "'"  auto  ANS core
002E6Cr 3                       ; """https://forth-standard.org/standard/core/Tick"""
002E6Cr 3               
002E6Cr 3               xt_tick:
002E6Cr 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002E6Fr 3               
002E6Fr 3                               ; if we got a zero, there was a problem getting the
002E6Fr 3                               ; name of the word
002E6Fr 3  B5 00                        lda 0,x
002E71r 3  15 01                        ora 1,x
002E73r 3  D0 05                        bne @1
002E75r 3               
002E75r 3  A9 05                        lda #err_noname
002E77r 3  4C rr rr                     jmp error
002E7Ar 3               @1:
002E7Ar 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002E7Dr 3               
002E7Dr 3                               ; If we didn't find the word in the Dictionary, abort
002E7Dr 3  B5 00                        lda 0,x
002E7Fr 3  15 01                        ora 1,x
002E81r 3  D0 05                        bne @2
002E83r 3               
002E83r 3  A9 08                        lda #err_syntax
002E85r 3  4C rr rr                     jmp error
002E88r 3               @2:
002E88r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
002E8Br 3               
002E8Br 3  60           z_tick:         rts
002E8Cr 3               
002E8Cr 3               
002E8Cr 3               
002E8Cr 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
002E8Cr 3               ; ## "to"  auto  ANS core ext
002E8Cr 3                       ; """https://forth-standard.org/standard/core/TO
002E8Cr 3                       ; Gives a new value to a, uh, VALUE.
002E8Cr 3                       ;
002E8Cr 3                       ; One possible Forth
002E8Cr 3                       ; implementation is  ' >BODY !  but given the problems we have
002E8Cr 3                       ; with >BODY on STC Forths, we do this the hard way. Since
002E8Cr 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
002E8Cr 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
002E8Cr 3                       ;
002E8Cr 3                       ; Note that the standard has different behaviors for TO depending
002E8Cr 3                       ; on the state (https://forth-standard.org/standard/core/TO).
002E8Cr 3                       ; This makes TO state-dependent (which is bad) and also rather
002E8Cr 3                       ; complex (see the Gforth implementation for comparison). This
002E8Cr 3                       ; word may not be natively compiled and must be immediate. Frankly,
002E8Cr 3                       ; it would have made more sense to have two words for this.
002E8Cr 3                       ; """
002E8Cr 3               
002E8Cr 3               xt_to:
002E8Cr 3                               ; One way or the other, we need the xt of the word after this
002E8Cr 3                               ; one. At this point, we don't know if we are interpreted or
002E8Cr 3                               ; compile, so we don't know if there is a value n on the stack,
002E8Cr 3                               ; so we can't do an underflow check yet
002E8Cr 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002E8Fr 3               
002E8Fr 3                               ; The PFA (DFA in this case) is three bytes down,
002E8Fr 3                               ; after the jump to DOCONST
002E8Fr 3  B5 00                        lda 0,x                 ; LSB
002E91r 3  18                           clc
002E92r 3  69 03                        adc #3
002E94r 3  85 24                        sta tmp1
002E96r 3  B5 01                        lda 1,x                 ; MSB
002E98r 3  69 00                        adc #0                  ; we just want the carry
002E9Ar 3  85 25                        sta tmp1+1
002E9Cr 3               
002E9Cr 3  E8                           inx
002E9Dr 3  E8                           inx                     ; ( [n] )
002E9Er 3               
002E9Er 3                               ; Now it gets ugly. See which state we are in
002E9Er 3  A5 16                        lda state
002EA0r 3  05 17                        ora state+1
002EA2r 3  F0 34                        beq @interpret
002EA4r 3               
002EA4r 3                               ; Well, we're compiling. We want to end up with simple
002EA4r 3                               ; code that just takes the number that is TOS and saves
002EA4r 3                               ; it in the address of the xt we were just given. So we
002EA4r 3                               ; want to compile this routine:
002EA4r 3                               ;
002EA4r 3                               ;       lda 0,x                 - B5 00
002EA4r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002EA4r 3                               ;       lda 1,x                 - B5 01
002EA4r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002EA4r 3                               ;       inx                     - E8
002EA4r 3                               ;       inx                     - E8
002EA4r 3                               ;
002EA4r 3                               ; which at least is nice and short. Other than that, we pretty
002EA4r 3                               ; much have to do this the hard and long way, because with the
002EA4r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
002EA4r 3                               ; range and store them with a loop. Sigh.
002EA4r 3               
002EA4r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
002EA6r 3  A9 B5                        lda #$B5
002EA8r 3  20 rr rr                     jsr cmpl_word
002EABr 3               
002EABr 3  A9 8D                        lda #$8D                ; Code for STA abs
002EADr 3  20 rr rr                     jsr cmpl_a
002EB0r 3               
002EB0r 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
002EB2r 3  A5 24                        lda tmp1
002EB4r 3  20 rr rr                     jsr cmpl_word
002EB7r 3               
002EB7r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
002EB9r 3  A9 B5                        lda #$B5
002EBBr 3  20 rr rr                     jsr cmpl_word
002EBEr 3               
002EBEr 3  A9 8D                        lda #$8D                ; Code for STA abs
002EC0r 3  20 rr rr                     jsr cmpl_a
002EC3r 3               
002EC3r 3  E6 24                        inc tmp1                ; Calculate MSB
002EC5r 3  D0 02                        bne @1
002EC7r 3  E6 25                        inc tmp1+1
002EC9r 3               @1:
002EC9r 3  A4 25                        ldy tmp1+1              ; MSB goes in Y
002ECBr 3  A5 24                        lda tmp1
002ECDr 3  20 rr rr                     jsr cmpl_word
002ED0r 3               
002ED0r 3  A0 E8                        ldy #$E8                ; Code for INX
002ED2r 3  98                           tya
002ED3r 3  20 rr rr                     jsr cmpl_word
002ED6r 3               
002ED6r 3  80 0F                        bra @done
002ED8r 3               
002ED8r 3               @interpret:
002ED8r 3                               ; We're interpreting, so we arrive here with n
002ED8r 3                               ; on the stack. This is an annoying place to put
002ED8r 3                               ; the underflow check because we can't
002ED8r 3                               ; automatically strip it out
002ED8r 3  20 rr rr                     jsr underflow_1
002EDBr 3               
002EDBr 3                               ; We skip over the jump to DOCONST and store the number
002EDBr 3                               ; in the Program Field Area (PDF, in this case more a
002EDBr 3                               ; Data Field Area
002EDBr 3  B5 00                        lda 0,x
002EDDr 3  92 24                        sta (tmp1)              ; LSB
002EDFr 3               
002EDFr 3  A0 01                        ldy #1
002EE1r 3  B5 01                        lda 1,x                 ; MSB
002EE3r 3  91 24                        sta (tmp1),y            ; fall through to common
002EE5r 3               
002EE5r 3  E8                           inx                     ; DROP
002EE6r 3  E8                           inx
002EE7r 3               @done:
002EE7r 3  60           z_to:           rts
002EE8r 3               
002EE8r 3               
002EE8r 3               
002EE8r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002EE8r 3               ; ## ">body"  auto  ANS core
002EE8r 3                       ; """https://forth-standard.org/standard/core/toBODY
002EE8r 3                       ; Given a word's execution token (xt), return the address of the
002EE8r 3                       ; start of that word's parameter field (PFA). This is defined as the
002EE8r 3                       ; address that HERE would return right after CREATE.
002EE8r 3                       ;
002EE8r 3                       ; This is a
002EE8r 3                       ; difficult word for STC Forths, because most words don't actually
002EE8r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002EE8r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002EE8r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002EE8r 3                       ; """
002EE8r 3               
002EE8r 3               xt_to_body:
002EE8r 3  20 rr rr                     jsr underflow_1
002EEBr 3               
002EEBr 3                               ; Ideally, xt already points to the CFA. We just need to check
002EEBr 3                               ; the HC flag for special cases
002EEBr 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
002EEEr 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
002EF1r 3               
002EF1r 3                               ; The status byte is nt+1
002EF1r 3  F6 00                        inc 0,x
002EF3r 3  D0 02                        bne @1
002EF5r 3  F6 01                        inc 1,x
002EF7r 3               @1:
002EF7r 3  A1 00                        lda (0,x)               ; get status byte
002EF9r 3  29 20                        and #HC
002EFBr 3  F0 0D                        beq @no_cfa
002EFDr 3               
002EFDr 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
002EFDr 3                               ; so we add three to xt, which is NOS
002EFDr 3  18                           clc
002EFEr 3  B5 02                        lda 2,x         ; LSB
002F00r 3  69 03                        adc #3
002F02r 3  95 02                        sta 2,x
002F04r 3  B5 03                        lda 3,x         ; MSB
002F06r 3  69 00                        adc #0          ; we conly care about the carry
002F08r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
002F0Ar 3               @no_cfa:
002F0Ar 3  E8                           inx             ; get rid of the nt
002F0Br 3  E8                           inx
002F0Cr 3               @done:
002F0Cr 3  60           z_to_body:      rts
002F0Dr 3               
002F0Dr 3               
002F0Dr 3               
002F0Dr 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
002F0Dr 3               ; ## ">in"  auto  ANS core
002F0Dr 3               xt_to_in:
002F0Dr 3  CA                           dex
002F0Er 3  CA                           dex
002F0Fr 3               
002F0Fr 3  A9 0C                        lda #<toin
002F11r 3  95 00                        sta 0,x
002F13r 3  A9 00                        lda #>toin      ; paranoid, should be zero
002F15r 3  95 01                        sta 1,x
002F17r 3               
002F17r 3  60           z_to_in:        rts
002F18r 3               
002F18r 3               
002F18r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002F18r 3               ; ## ">number"  auto  ANS core
002F18r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002F18r 3                       ; Convert a string to a double number. Logic here is based on the
002F18r 3                       ; routine by Phil Burk of the same name in pForth, see
002F18r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002F18r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002F18r 3                       ; made sure that we don't have to deal with a sign and we don't have
002F18r 3                       ; to deal with a dot as a last character that signalizes double -
002F18r 3                       ; this should be a pure number string.
002F18r 3                       ;
002F18r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002F18r 3                       ; cannot access any of those.
002F18r 3                       ;
002F18r 3                       ; For the math routine, we move the inputs to the scratchpad to
002F18r 3                       ; avoid having to fool around with the Data Stack.
002F18r 3                       ;
002F18r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002F18r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002F18r 3                       ;     |           |           |           |           |
002F18r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002F18r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002F18r 3                       ;
002F18r 3                       ; The math routine works by converting one character to its
002F18r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002F18r 3                       ; the moment. We then multiply the UD-HI value with the radix
002F18r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002F18r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002F18r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002F18r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002F18r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002F18r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002F18r 3                       ; storing the result back in S and S+2, before we start another
002F18r 3                       ; round with it as the new UD-LO and UD-HI.
002F18r 3                       ; """
002F18r 3               
002F18r 3               
002F18r 3               xt_to_number:
002F18r 3  20 rr rr                     jsr underflow_4
002F1Br 3               
002F1Br 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
002F1Br 3                               ; After this step, the original ud-lo and ud-hi will still be on
002F1Br 3                               ; the Data Stack, but will be ignored and later overwritten
002F1Br 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
002F1Br 3  B5 06                        lda 6,x         ; ud-lo LSB
002F1Dr 3  85 36                        sta scratch
002F1Fr 3  B5 07                        lda 7,x         ; ud-lo MSB
002F21r 3  85 37                        sta scratch+1
002F23r 3               
002F23r 3  B5 04                        lda 4,x         ; ud-hi LSB
002F25r 3  85 38                        sta scratch+2
002F27r 3  B5 05                        lda 5,x         ; ud-hi MSB
002F29r 3  85 39                        sta scratch+3
002F2Br 3               
002F2Br 3                               ; Push down one on the Data Stack to use TOS for character
002F2Br 3                               ; conversion ( ud-lo ud-hi addr u x )
002F2Br 3  CA                           dex
002F2Cr 3  CA                           dex
002F2Dr 3               
002F2Dr 3               @loop:
002F2Dr 3                               ; Get one character based on address
002F2Dr 3  A1 04                        lda (4,x)
002F2Fr 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
002F31r 3  74 01                        stz 1,x                 ; paranoid
002F33r 3               
002F33r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002F36r 3               
002F36r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002F36r 3                               ; check the flag. If it is zero, we return what we have and
002F36r 3                               ; let the caller (usually NUMBER) complain
002F36r 3  B5 00                        lda 0,x
002F38r 3  D0 04                        bne @digit_ok
002F3Ar 3               
002F3Ar 3  E8                           inx
002F3Br 3  E8                           inx
002F3Cr 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
002F3Er 3               
002F3Er 3               @digit_ok:
002F3Er 3                               ; Conversion was successful. We arrive here with
002F3Er 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
002F3Er 3                               ; math routine
002F3Er 3               
002F3Er 3                               ; Save n so we don't have to fool around with the
002F3Er 3                               ; Data Stack
002F3Er 3  B5 02                        lda 2,x
002F40r 3  85 3A                        sta scratch+4
002F42r 3  B5 03                        lda 3,x
002F44r 3  85 3B                        sta scratch+5
002F46r 3               
002F46r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002F46r 3                               ; original one on the Data Stack) with the radix from BASE.
002F46r 3                               ; We can clobber TOS and NOS because we saved n
002F46r 3  A5 38                        lda scratch+2
002F48r 3  95 02                        sta 2,x         ; NOS
002F4Ar 3  A5 39                        lda scratch+3
002F4Cr 3  95 03                        sta 3,x
002F4Er 3               
002F4Er 3  A5 18                        lda base
002F50r 3  95 00                        sta 0,x         ; TOS
002F52r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002F54r 3               
002F54r 3                               ; UM* returns a double-celled number
002F54r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002F57r 3               
002F57r 3                               ; Move ud-hi-lo to safety
002F57r 3  B5 02                        lda 2,x         ; ud-hi-lo
002F59r 3  85 3C                        sta scratch+6
002F5Br 3  B5 03                        lda 3,x
002F5Dr 3  85 3D                        sta scratch+7
002F5Fr 3               
002F5Fr 3                               ; Now we multiply ud-lo, overwriting the stack entries
002F5Fr 3  A5 36                        lda scratch
002F61r 3  95 02                        sta 2,x
002F63r 3  A5 37                        lda scratch+1
002F65r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002F67r 3               
002F67r 3  A5 18                        lda base
002F69r 3  95 00                        sta 0,x
002F6Br 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002F6Dr 3               
002F6Dr 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002F70r 3               
002F70r 3  B5 00                        lda 0,x
002F72r 3  85 38                        sta scratch+2
002F74r 3  B5 01                        lda 1,x
002F76r 3  85 39                        sta scratch+3
002F78r 3               
002F78r 3  B5 02                        lda 2,x
002F7Ar 3  85 36                        sta scratch
002F7Cr 3  B5 03                        lda 3,x
002F7Er 3  85 37                        sta scratch+1
002F80r 3               
002F80r 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002F80r 3                               ; both in the scratch pad
002F80r 3  18                           clc
002F81r 3  A5 36                        lda scratch     ; ud-lo LSB
002F83r 3  65 3A                        adc scratch+4   ; n LSB
002F85r 3  85 36                        sta scratch     ; this is the new ud-lo
002F87r 3  A5 37                        lda scratch+1   ; ud-lo MSB
002F89r 3  65 3B                        adc scratch+5   ; n MSB
002F8Br 3  85 37                        sta scratch+1
002F8Dr 3               
002F8Dr 3  A5 38                        lda scratch+2   ; LSB
002F8Fr 3  65 3C                        adc scratch+6
002F91r 3  85 38                        sta scratch+2   ; this is the new ud-hi
002F93r 3  A5 39                        lda scratch+3   ; MSB
002F95r 3  65 3D                        adc scratch+7
002F97r 3  85 39                        sta scratch+3
002F99r 3               
002F99r 3                               ; Clean up: Get rid of one of the two top elements on
002F99r 3                               ; the Data Stack. We don't really care which one
002F99r 3  E8                           inx
002F9Ar 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002F9Br 3               
002F9Br 3                               ; One character down. Move address up
002F9Br 3  F6 04                        inc 4,x
002F9Dr 3  D0 02                        bne @1
002F9Fr 3  F6 05                        inc 5,x
002FA1r 3               @1:
002FA1r 3                               ; Decrease counter
002FA1r 3  D6 02                        dec 2,x
002FA3r 3  D0 88                        bne @loop
002FA5r 3               
002FA5r 3               @done:
002FA5r 3                               ; Counter has reached zero or we have an error. In both
002FA5r 3                               ; cases, we clean up the Data Stack and return. Error gives
002FA5r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002FA5r 3                               ; ( ud-lo ud-hi addr u ud-lo )
002FA5r 3  E8                           inx
002FA6r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002FA7r 3               
002FA7r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002FA7r 3  A5 36                        lda scratch     ; new ud-lo
002FA9r 3  95 06                        sta 6,x
002FABr 3  A5 37                        lda scratch+1
002FADr 3  95 07                        sta 7,x
002FAFr 3               
002FAFr 3  A5 38                        lda scratch+2
002FB1r 3  95 04                        sta 4,x
002FB3r 3  A5 39                        lda scratch+3
002FB5r 3  95 05                        sta 5,x
002FB7r 3               
002FB7r 3  60           z_to_number:    rts
002FB8r 3               
002FB8r 3               
002FB8r 3               
002FB8r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002FB8r 3               ; ## ">order"  tested  Gforth search
002FB8r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002FB8r 3               
002FB8r 3               xt_to_order:
002FB8r 3                               ; Put the wid on the return stack for now.
002FB8r 3  20 rr rr                     jsr xt_to_r
002FBBr 3               
002FBBr 3                               ; Get the current search order.
002FBBr 3  20 rr rr                     jsr xt_get_order
002FBEr 3               
002FBEr 3                               ; Get back the wid and add it to the list.
002FBEr 3  20 rr rr                     jsr xt_r_from
002FC1r 3  20 rr rr                     jsr xt_swap
002FC4r 3  20 rr rr                     jsr xt_one_plus
002FC7r 3               
002FC7r 3                               ; Set the search order with the new list.
002FC7r 3  20 rr rr                     jsr xt_set_order
002FCAr 3               
002FCAr 3  60           z_to_order:     rts
002FCBr 3               
002FCBr 3               
002FCBr 3               
002FCBr 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002FCBr 3               ; ## ">r"  auto  ANS core
002FCBr 3                       ; """https://forth-standard.org/standard/core/toR
002FCBr 3                       ; This word is handled differently for native and for
002FCBr 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002FCBr 3                       ; word.
002FCBr 3                       ; """
002FCBr 3               xt_to_r:
002FCBr 3                               ; Save the return address. If this word is natively
002FCBr 3                               ; coded, this is a complete waste of cycles, but
002FCBr 3                               ; required for subroutine coding
002FCBr 3  68                           pla             ; LSB
002FCCr 3  85 2C                        sta tmptos
002FCEr 3  7A                           ply             ; MSB
002FCFr 3               
002FCFr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002FCFr 3               
002FCFr 3                               ; We check for underflow in the second step, so we can
002FCFr 3                               ; strip off the stack thrashing for native compiling first
002FCFr 3  20 rr rr                     jsr underflow_1
002FD2r 3               
002FD2r 3                               ; now we can do the actual work
002FD2r 3  B5 01                        lda 1,x         ; MSB
002FD4r 3  48                           pha
002FD5r 3  B5 00                        lda 0,x         ; LSB
002FD7r 3  48                           pha
002FD8r 3               
002FD8r 3  E8                           inx
002FD9r 3  E8                           inx
002FDAr 3               
002FDAr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002FDAr 3               
002FDAr 3                               ; restore return address
002FDAr 3  5A                           phy             ; MSB
002FDBr 3  A5 2C                        lda tmptos
002FDDr 3  48                           pha             ; LSB
002FDEr 3               
002FDEr 3  60           z_to_r:         rts
002FDFr 3               
002FDFr 3               
002FDFr 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002FDFr 3               ; ## "true"  auto  ANS core ext
002FDFr 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002FDFr 3               xt_true:
002FDFr 3  CA                           dex
002FE0r 3  CA                           dex
002FE1r 3  A9 FF                        lda #$FF
002FE3r 3  95 00                        sta 0,x
002FE5r 3  95 01                        sta 1,x
002FE7r 3               
002FE7r 3  60           z_true:         rts
002FE8r 3               
002FE8r 3               
002FE8r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002FE8r 3               ; ## "tuck"  auto  ANS core ext
002FE8r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002FE8r 3               xt_tuck:
002FE8r 3  20 rr rr                     jsr underflow_2
002FEBr 3               
002FEBr 3  CA                           dex
002FECr 3  CA                           dex
002FEDr 3               
002FEDr 3  B4 04                        ldy 4,x         ; LSB
002FEFr 3  B5 02                        lda 2,x
002FF1r 3  95 04                        sta 4,x
002FF3r 3  94 02                        sty 2,x
002FF5r 3  95 00                        sta 0,x
002FF7r 3               
002FF7r 3  B4 05                        ldy 5,x         ; MSB
002FF9r 3  B5 03                        lda 3,x
002FFBr 3  95 05                        sta 5,x
002FFDr 3  94 03                        sty 3,x         ; bba
002FFFr 3  95 01                        sta 1,x         ; baa
003001r 3               
003001r 3  60           z_tuck:         rts
003002r 3               
003002r 3               
003002r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
003002r 3               ; ## "2"  auto  Tali Forth
003002r 3                       ;
003002r 3                       ; This code is shared with ASSEMBLER-WORDLIST
003002r 3               xt_assembler_wordlist:
003002r 3               xt_two:
003002r 3  CA                           dex
003003r 3  CA                           dex
003004r 3  A9 02                        lda #2
003006r 3  95 00                        sta 0,x
003008r 3  74 01                        stz 1,x
00300Ar 3               
00300Ar 3               z_assembler_wordlist:
00300Ar 3  60           z_two:          rts
00300Br 3               
00300Br 3               
00300Br 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
00300Br 3               ; ## "2drop"  auto  ANS core
00300Br 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
00300Br 3               xt_two_drop:
00300Br 3  20 rr rr                     jsr underflow_2
00300Er 3               
00300Er 3  E8                           inx
00300Fr 3  E8                           inx
003010r 3  E8                           inx
003011r 3  E8                           inx
003012r 3               
003012r 3  60           z_two_drop:     rts
003013r 3               
003013r 3               
003013r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
003013r 3               ; ## "2dup"  auto  ANS core
003013r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
003013r 3               xt_two_dup:
003013r 3  20 rr rr                     jsr underflow_2
003016r 3               
003016r 3  CA                           dex
003017r 3  CA                           dex
003018r 3  CA                           dex
003019r 3  CA                           dex
00301Ar 3               
00301Ar 3  B5 04                        lda 4,x         ; TOS
00301Cr 3  95 00                        sta 0,x
00301Er 3  B5 05                        lda 5,x
003020r 3  95 01                        sta 1,x
003022r 3               
003022r 3  B5 06                        lda 6,x         ; NOS
003024r 3  95 02                        sta 2,x
003026r 3  B5 07                        lda 7,x
003028r 3  95 03                        sta 3,x
00302Ar 3               
00302Ar 3  60           z_two_dup:      rts
00302Br 3               
00302Br 3               
00302Br 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
00302Br 3               ; ## "2@"  auto  ANS core
00302Br 3                       ; """https://forth-standard.org/standard/core/TwoFetch
00302Br 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
00302Br 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
00302Br 3                       ; """
00302Br 3               xt_two_fetch:
00302Br 3  20 rr rr                     jsr underflow_1
00302Er 3               
00302Er 3  B5 00                        lda 0,x
003030r 3  85 24                        sta tmp1
003032r 3  B4 01                        ldy 1,x
003034r 3  84 25                        sty tmp1+1
003036r 3               
003036r 3  CA                           dex             ; reuse one stack element
003037r 3  CA                           dex
003038r 3               
003038r 3  B2 24                        lda (tmp1)      ; copy LSB
00303Ar 3  95 00                        sta 0,x
00303Cr 3  A0 01                        ldy #1          ; copy next
00303Er 3  B1 24                        lda (tmp1),y
003040r 3  95 01                        sta 1,x
003042r 3  C8                           iny             ; copy next
003043r 3  B1 24                        lda (tmp1),y
003045r 3  95 02                        sta 2,x
003047r 3  C8                           iny             ; copy next
003048r 3  B1 24                        lda (tmp1),y
00304Ar 3  95 03                        sta 3,x
00304Cr 3               
00304Cr 3  60           z_two_fetch:    rts
00304Dr 3               
00304Dr 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
00304Dr 3               ; ## "2over"  auto  ANS core
00304Dr 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
00304Dr 3               xt_two_over:
00304Dr 3  20 rr rr                     jsr underflow_4
003050r 3               
003050r 3  CA                           dex
003051r 3  CA                           dex
003052r 3  CA                           dex
003053r 3  CA                           dex
003054r 3               
003054r 3  B5 08                        lda 8,x
003056r 3  95 00                        sta 0,x
003058r 3               
003058r 3  B5 09                        lda 9,x
00305Ar 3  95 01                        sta 1,x
00305Cr 3               
00305Cr 3  B5 0A                        lda 10,x
00305Er 3  95 02                        sta 2,x
003060r 3               
003060r 3  B5 0B                        lda 11,x
003062r 3  95 03                        sta 3,x
003064r 3               
003064r 3  60           z_two_over:     rts
003065r 3               
003065r 3               
003065r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
003065r 3               ; ## "2r@"  auto  ANS core ext
003065r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
003065r 3                       ;
003065r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
003065r 3                       ; assembler. We use trickery to access the elements on the Return
003065r 3                       ; Stack instead of pulling the return address first and storing
003065r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
003065r 3                       ; it as Never Native; at some point, we should compare versions to
003065r 3                       ; see if an Always Native version would be better
003065r 3                       ; """
003065r 3               xt_two_r_fetch:
003065r 3               		; make room on the Data Stack
003065r 3  CA                           dex
003066r 3  CA                           dex
003067r 3  CA                           dex
003068r 3  CA                           dex
003069r 3               
003069r 3                               ; Get four bytes off of Return Stack. This assumes that
003069r 3                               ; we took a subroutine jump here so the first two entries
003069r 3                               ; are the return address
003069r 3  8A                           txa
00306Ar 3  BA                           tsx
00306Br 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
00306Cr 3  7A                           ply
00306Dr 3  AA                           tax
00306Er 3               
00306Er 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
00306Er 3                               ; the return address for this word. This is a whole lot
00306Er 3                               ; easier on the 65816
00306Er 3  B9 03 01                     lda $0103,y     ; LSB of top entry
003071r 3  95 00                        sta 0,x
003073r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
003076r 3  95 01                        sta 1,x
003078r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
00307Br 3  95 02                        sta 2,x
00307Dr 3  B9 06 01                     lda $0106,y     ; MSB of top entry
003080r 3  95 03                        sta 3,x
003082r 3               
003082r 3  60           z_two_r_fetch:  rts
003083r 3               
003083r 3               
003083r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
003083r 3               ; ## "2r>"  auto  ANS core ext
003083r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
003083r 3                       ; Pull top two entries from Return Stack.
003083r 3                       ;
003083r 3                       ; Is the same as
003083r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
003083r 3                       ; the top value on the ReturnStack for a STC Forth is the
003083r 3                       ; return address, which we need to get out of the way first.
003083r 3                       ; Native compile needs to be handled as a special case.
003083r 3                       ; """
003083r 3               xt_two_r_from:
003083r 3                               ; save the return address
003083r 3  68                           pla                     ; LSB
003084r 3  85 24                        sta tmp1
003086r 3  68                           pla                     ; MSB
003087r 3  85 25                        sta tmp1+1
003089r 3               
003089r 3                               ; --- CUT HERE FOR NATIVE CODING ---
003089r 3               
003089r 3               		; make room on stack
003089r 3  CA                           dex
00308Ar 3  CA                           dex
00308Br 3  CA                           dex
00308Cr 3  CA                           dex
00308Dr 3               
00308Dr 3                               ; In theory, we should test for underflow on the Return
00308Dr 3                               ; Stack. However, given the traffic there with an STC
00308Dr 3                               ; Forth, that's probably not really useful
00308Dr 3               
00308Dr 3                               ; now we can access the data
00308Dr 3  68                           pla                     ; LSB
00308Er 3  95 00                        sta 0,x
003090r 3  68                           pla                     ; MSB
003091r 3  95 01                        sta 1,x
003093r 3               
003093r 3  68                           pla                     ; LSB
003094r 3  95 02                        sta 2,x
003096r 3  68                           pla                     ; MSB
003097r 3  95 03                        sta 3,x
003099r 3               
003099r 3                               ; --- CUT HERE FOR NATIVE CODING ---
003099r 3               
003099r 3                               ; restore return address
003099r 3  A5 25                        lda tmp1+1              ; MSB
00309Br 3  48                           pha
00309Cr 3  A5 24                        lda tmp1                ; LSB
00309Er 3  48                           pha
00309Fr 3               
00309Fr 3  60           z_two_r_from:   rts
0030A0r 3               
0030A0r 3               
0030A0r 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
0030A0r 3               ; ## "2/"  auto  ANS core
0030A0r 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
0030A0r 3               xt_two_slash:
0030A0r 3  20 rr rr                     jsr underflow_1
0030A3r 3               
0030A3r 3                               ; We can't just LSR the LSB and ROR the MSB because that
0030A3r 3                               ; would do bad things to the sign
0030A3r 3  B5 01                        lda 1,x
0030A5r 3  0A                           asl                     ; save the sign
0030A6r 3  76 01                        ror 1,x
0030A8r 3  76 00                        ror 0,x
0030AAr 3               
0030AAr 3  60           z_two_slash:    rts
0030ABr 3               
0030ABr 3               
0030ABr 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
0030ABr 3               ; ## "2*"  auto  ANS core
0030ABr 3                       ; """https://forth-standard.org/standard/core/TwoTimes
0030ABr 3                       ;
0030ABr 3                       ; Also used for CELLS
0030ABr 3                       ; """
0030ABr 3               xt_two_star:
0030ABr 3               xt_cells:
0030ABr 3  20 rr rr                     jsr underflow_1
0030AEr 3               
0030AEr 3  16 00                        asl 0,x
0030B0r 3  36 01                        rol 1,x
0030B2r 3               z_cells:
0030B2r 3  60           z_two_star:     rts
0030B3r 3               
0030B3r 3               
0030B3r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
0030B3r 3               ; ## "2!"  auto  ANS core
0030B3r 3                       ; """https://forth-standard.org/standard/core/TwoStore
0030B3r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
0030B3r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
0030B3r 3                       ; """
0030B3r 3               xt_two_store:
0030B3r 3  20 rr rr                     jsr underflow_3
0030B6r 3               
0030B6r 3  B5 00                        lda 0,x
0030B8r 3  85 24                        sta tmp1
0030BAr 3  B4 01                        ldy 1,x
0030BCr 3  84 25                        sty tmp1+1
0030BEr 3               
0030BEr 3  E8                           inx
0030BFr 3  E8                           inx
0030C0r 3               
0030C0r 3  B5 00                        lda 0,x         ; copy MSB
0030C2r 3  92 24                        sta (tmp1)
0030C4r 3  B5 01                        lda 1,x         ; copy next
0030C6r 3  A0 01                        ldy #1
0030C8r 3  91 24                        sta (tmp1),y
0030CAr 3  B5 02                        lda 2,x         ; copy next
0030CCr 3  C8                           iny
0030CDr 3  91 24                        sta (tmp1),y
0030CFr 3  B5 03                        lda 3,x         ; copy MSB
0030D1r 3  C8                           iny
0030D2r 3  91 24                        sta (tmp1),y
0030D4r 3               
0030D4r 3  E8                           inx             ; 2DROP
0030D5r 3  E8                           inx
0030D6r 3  E8                           inx
0030D7r 3  E8                           inx
0030D8r 3               
0030D8r 3  60           z_two_store:    rts
0030D9r 3               
0030D9r 3               
0030D9r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
0030D9r 3               ; ## "2swap"  auto  ANS core
0030D9r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
0030D9r 3               xt_two_swap:
0030D9r 3  20 rr rr                     jsr underflow_4
0030DCr 3               
0030DCr 3                               ; 0 <-> 4
0030DCr 3  B5 00                        lda 0,x
0030DEr 3  B4 04                        ldy 4,x
0030E0r 3  95 04                        sta 4,x
0030E2r 3  94 00                        sty 0,x
0030E4r 3               
0030E4r 3                               ; 1 <-> 5
0030E4r 3  B5 01                        lda 1,x
0030E6r 3  B4 05                        ldy 5,x
0030E8r 3  95 05                        sta 5,x
0030EAr 3  94 01                        sty 1,x
0030ECr 3               
0030ECr 3                               ; 2 <-> 6
0030ECr 3  B5 02                        lda 2,x
0030EEr 3  B4 06                        ldy 6,x
0030F0r 3  95 06                        sta 6,x
0030F2r 3  94 02                        sty 2,x
0030F4r 3               
0030F4r 3                               ; 3 <-> 7
0030F4r 3  B5 03                        lda 3,x
0030F6r 3  B4 07                        ldy 7,x
0030F8r 3  95 07                        sta 7,x
0030FAr 3  94 03                        sty 3,x
0030FCr 3               
0030FCr 3  60           z_two_swap:     rts
0030FDr 3               
0030FDr 3               
0030FDr 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
0030FDr 3               ; ## "2>r"  auto  ANS core ext
0030FDr 3                       ; """https://forth-standard.org/standard/core/TwotoR
0030FDr 3                       ; Push top two entries to Return Stack.
0030FDr 3                       ;
0030FDr 3                       ; The same as SWAP >R >R
0030FDr 3                       ; except that if we jumped here, the return address will be in the
0030FDr 3                       ; way. May not be natively compiled unless we're clever and use
0030FDr 3                       ; special routines.
0030FDr 3                       ; """
0030FDr 3               xt_two_to_r:
0030FDr 3                               ; save the return address
0030FDr 3  68                           pla             ; LSB
0030FEr 3  85 24                        sta tmp1
003100r 3  68                           pla             ; MSB
003101r 3  85 25                        sta tmp1+1
003103r 3               
003103r 3                               ; --- CUT HERE FOR NATIVE CODING ---
003103r 3               
003103r 3  20 rr rr                     jsr underflow_2
003106r 3               
003106r 3                               ; now we can move the data
003106r 3  B5 03                        lda 3,x         ; MSB
003108r 3  48                           pha
003109r 3  B5 02                        lda 2,x         ; LSB
00310Br 3  48                           pha
00310Cr 3               
00310Cr 3                               ; now we can move the data
00310Cr 3  B5 01                        lda 1,x         ; MSB
00310Er 3  48                           pha
00310Fr 3  B5 00                        lda 0,x         ; LSB
003111r 3  48                           pha
003112r 3               
003112r 3  E8                           inx
003113r 3  E8                           inx
003114r 3  E8                           inx
003115r 3  E8                           inx
003116r 3               
003116r 3                               ; --- CUT HERE FOR NATIVE CODING ---
003116r 3               
003116r 3                               ; restore return address
003116r 3  A5 25                        lda tmp1+1      ; MSB
003118r 3  48                           pha
003119r 3  A5 24                        lda tmp1        ; LSB
00311Br 3  48                           pha
00311Cr 3               
00311Cr 3  60           z_two_to_r:     rts
00311Dr 3               
00311Dr 3               
00311Dr 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
00311Dr 3               ; ## "2constant"  auto  ANS double
00311Dr 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
00311Dr 3                       ;
00311Dr 3                       ; Based on the Forth code
00311Dr 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
00311Dr 3                       ; """
00311Dr 3               xt_two_constant:
00311Dr 3  20 rr rr                     jsr underflow_2
003120r 3               
003120r 3  20 rr rr                     jsr xt_create
003123r 3  20 rr rr                     jsr xt_swap
003126r 3  20 rr rr                     jsr xt_comma
003129r 3  20 rr rr                     jsr xt_comma
00312Cr 3               
00312Cr 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
00312Fr 3  20 rr rr                     jsr dodoes
003132r 3               
003132r 3  20 rr rr                     jsr xt_dup
003135r 3  20 rr rr                     jsr xt_fetch
003138r 3  20 rr rr                     jsr xt_swap
00313Br 3  20 rr rr                     jsr xt_cell_plus
00313Er 3  20 rr rr                     jsr xt_fetch
003141r 3               
003141r 3  60           z_two_constant: rts
003142r 3               
003142r 3               
003142r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
003142r 3               ; ## "2literal"  auto  ANS double
003142r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
003142r 3                       ; Based on the Forth code
003142r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
003142r 3                       ; """
003142r 3               xt_two_literal:
003142r 3  20 rr rr                     jsr underflow_2 ; double number
003145r 3               
003145r 3  20 rr rr                     jsr xt_swap
003148r 3  20 rr rr                     jsr xt_literal
00314Br 3  20 rr rr                     jsr xt_literal
00314Er 3               
00314Er 3  60           z_two_literal:  rts
00314Fr 3               
00314Fr 3               
00314Fr 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
00314Fr 3               ; ## "2variable"  auto  ANS double
00314Fr 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
00314Fr 3                       ; The variable is not initialized to zero.
00314Fr 3                       ;
00314Fr 3                       ; This can be realized in Forth as either
00314Fr 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
00314Fr 3                       ; """
00314Fr 3               xt_two_variable:
00314Fr 3                               ; We just let CRATE and ALLOT do the heavy lifting
00314Fr 3  20 rr rr                     jsr xt_create
003152r 3               
003152r 3  CA                           dex
003153r 3  CA                           dex
003154r 3  A9 04                        lda #4
003156r 3  95 00                        sta 0,x
003158r 3  74 01                        stz 1,x
00315Ar 3               
00315Ar 3  20 rr rr                     jsr xt_allot
00315Dr 3               
00315Dr 3  60           z_two_variable: rts
00315Er 3               
00315Er 3               
00315Er 3               ; ## TYPE ( addr u -- ) "Print string"
00315Er 3               ; ## "type"  auto  ANS core
00315Er 3                       ; """https://forth-standard.org/standard/core/TYPE
00315Er 3                       ; Works through EMIT to allow OUTPUT revectoring.
00315Er 3                       ; """
00315Er 3               
00315Er 3               xt_type:
00315Er 3  20 rr rr                     jsr underflow_2
003161r 3               
003161r 3                               ; Save the starting address into tmp1
003161r 3  B5 02                        lda 2,x
003163r 3  85 24                        sta tmp1
003165r 3  B5 03                        lda 3,x
003167r 3  85 25                        sta tmp1+1
003169r 3               @loop:
003169r 3                               ; done if length is zero
003169r 3  B5 00                        lda 0,x
00316Br 3  15 01                        ora 1,x
00316Dr 3  F0 15                        beq @done
00316Fr 3               
00316Fr 3                               ; Send the current character
00316Fr 3  B2 24                        lda (tmp1)
003171r 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
003174r 3               
003174r 3                               ; Move the address along (in tmp1)
003174r 3  E6 24                        inc tmp1
003176r 3  D0 02                        bne @1
003178r 3  E6 25                        inc tmp1+1
00317Ar 3               @1:
00317Ar 3                               ; Reduce the count (on the data stack)
00317Ar 3  B5 00                        lda 0,x
00317Cr 3  D0 02                        bne @2
00317Er 3  D6 01                        dec 1,x
003180r 3               @2:
003180r 3  D6 00                        dec 0,x
003182r 3               
003182r 3  80 E5                        bra @loop
003184r 3               @done:
003184r 3  E8                           inx
003185r 3  E8                           inx
003186r 3  E8                           inx
003187r 3  E8                           inx
003188r 3               
003188r 3  60           z_type:         rts
003189r 3               
003189r 3               
003189r 3               
003189r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
003189r 3               ; ## "u."  tested  ANS core
003189r 3                       ; """https://forth-standard.org/standard/core/Ud
003189r 3                       ;
003189r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
003189r 3                       ; We use the internal assembler function print_u followed
003189r 3                       ; by a single space
003189r 3                       ; """
003189r 3               xt_u_dot:
003189r 3  20 rr rr                     jsr underflow_1
00318Cr 3               
00318Cr 3  20 rr rr                     jsr print_u
00318Fr 3  A9 20                        lda #AscSP
003191r 3  20 rr rr                     jsr emit_a
003194r 3               
003194r 3  60           z_u_dot:        rts
003195r 3               
003195r 3               
003195r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
003195r 3               ; ## "u.r"  tested  ANS core ext
003195r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
003195r 3               xt_u_dot_r:
003195r 3  20 rr rr                     jsr underflow_2
003198r 3               
003198r 3  20 rr rr                     jsr xt_to_r
00319Br 3  20 rr rr                     jsr xt_zero
00319Er 3  20 rr rr                     jsr xt_less_number_sign
0031A1r 3  20 rr rr                     jsr xt_number_sign_s
0031A4r 3  20 rr rr                     jsr xt_number_sign_greater
0031A7r 3  20 rr rr                     jsr xt_r_from
0031AAr 3  20 rr rr                     jsr xt_over
0031ADr 3  20 rr rr                     jsr xt_minus
0031B0r 3  20 rr rr                     jsr xt_spaces
0031B3r 3  20 rr rr                     jsr xt_type
0031B6r 3               
0031B6r 3  60           z_u_dot_r:      rts
0031B7r 3               
0031B7r 3               
0031B7r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
0031B7r 3               ; ## "u>"  auto  ANS core ext
0031B7r 3                       ; """https://forth-standard.org/standard/core/Umore"""
0031B7r 3               xt_u_greater_than:
0031B7r 3  20 rr rr                     jsr underflow_2
0031BAr 3               
0031BAr 3  B5 00                        lda 0,x
0031BCr 3  D5 02                        cmp 2,x
0031BEr 3  B5 01                        lda 1,x
0031C0r 3  F5 03                        sbc 3,x
0031C2r 3  E8                           inx
0031C3r 3  E8                           inx
0031C4r 3               
0031C4r 3  A9 00                        lda #0
0031C6r 3  69 FF                        adc #$ff
0031C8r 3  95 00                        sta 0,x         ; store flag
0031CAr 3  95 01                        sta 1,x
0031CCr 3               
0031CCr 3  60           z_u_greater_than:    rts
0031CDr 3               
0031CDr 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
0031CDr 3               ; ## "u<"  auto  ANS core
0031CDr 3                       ; """https://forth-standard.org/standard/core/Uless"""
0031CDr 3               xt_u_less_than:
0031CDr 3  20 rr rr                     jsr underflow_2
0031D0r 3               
0031D0r 3  B5 02                        lda 2,x
0031D2r 3  D5 00                        cmp 0,x
0031D4r 3  B5 03                        lda 3,x
0031D6r 3  F5 01                        sbc 1,x
0031D8r 3  E8                           inx
0031D9r 3  E8                           inx
0031DAr 3               
0031DAr 3  A9 00                        lda #0
0031DCr 3  69 FF                        adc #$ff
0031DEr 3  95 00                        sta 0,x         ; store flag
0031E0r 3  95 01                        sta 1,x
0031E2r 3               
0031E2r 3  60           z_u_less_than:    rts
0031E3r 3               
0031E3r 3               
0031E3r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
0031E3r 3               ; ## "ud."  auto  Tali double
0031E3r 3                       ;
0031E3r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
0031E3r 3                       ; """
0031E3r 3               xt_ud_dot:
0031E3r 3  20 rr rr                     jsr underflow_2 ; double number
0031E6r 3               
0031E6r 3  20 rr rr                     jsr xt_less_number_sign
0031E9r 3  20 rr rr                     jsr xt_number_sign_s
0031ECr 3  20 rr rr                     jsr xt_number_sign_greater
0031EFr 3  20 rr rr                     jsr xt_type
0031F2r 3  20 rr rr                     jsr xt_space
0031F5r 3               
0031F5r 3  60           z_ud_dot:        rts
0031F6r 3               
0031F6r 3               
0031F6r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
0031F6r 3               ; ## "ud.r"  auto  Tali double
0031F6r 3                       ;
0031F6r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
0031F6r 3                       ; """
0031F6r 3               xt_ud_dot_r:
0031F6r 3  20 rr rr                     jsr underflow_3
0031F9r 3               
0031F9r 3  20 rr rr                     jsr xt_to_r
0031FCr 3  20 rr rr                     jsr xt_less_number_sign
0031FFr 3  20 rr rr                     jsr xt_number_sign_s
003202r 3  20 rr rr                     jsr xt_number_sign_greater
003205r 3  20 rr rr                     jsr xt_r_from
003208r 3  20 rr rr                     jsr xt_over
00320Br 3  20 rr rr                     jsr xt_minus
00320Er 3  20 rr rr                     jsr xt_spaces
003211r 3  20 rr rr                     jsr xt_type
003214r 3               
003214r 3  60           z_ud_dot_r:      rts
003215r 3               
003215r 3               
003215r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
003215r 3               ; ## "um/mod"  auto  ANS core
003215r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
003215r 3                       ; Divide double cell number by single cell number, returning the
003215r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
003215r 3                       ; This is the basic division operation all others use. Based on FIG
003215r 3                       ; Forth code, modified by Garth Wilson, see
003215r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
003215r 3                       ;
003215r 3                       ; This uses tmp1, tmp1+1, and tmptos
003215r 3                       ; """
003215r 3               
003215r 3               xt_um_slash_mod:
003215r 3  20 rr rr                     jsr underflow_3
003218r 3               
003218r 3                               ; catch division by zero
003218r 3  B5 00                        lda 0,x
00321Ar 3  15 01                        ora 1,x
00321Cr 3  D0 05                        bne @not_zero
00321Er 3               
00321Er 3  A9 04                        lda #err_divzero
003220r 3  4C rr rr                     jmp error
003223r 3               
003223r 3               @not_zero:
003223r 3                               ; We loop 17 times
003223r 3  A9 11                        lda #17
003225r 3  85 2C                        sta tmptos
003227r 3               
003227r 3               @loop:
003227r 3                               ; rotate low cell of dividend one bit left (LSB)
003227r 3  36 04                        rol 4,x
003229r 3  36 05                        rol 5,x
00322Br 3               
00322Br 3                               ; loop control
00322Br 3  C6 2C                        dec tmptos
00322Dr 3  F0 22                        beq @done
00322Fr 3               
00322Fr 3                               ; rotate high cell of dividend one bit left (MSB)
00322Fr 3  36 02                        rol 2,x
003231r 3  36 03                        rol 3,x
003233r 3               
003233r 3  64 24                        stz tmp1        ; store the bit we got from hi cell (MSB)
003235r 3  26 24                        rol tmp1
003237r 3               
003237r 3                               ; subtract dividend hi cell minus divisor
003237r 3  38                           sec
003238r 3  B5 02                        lda 2,x
00323Ar 3  F5 00                        sbc 0,x
00323Cr 3  85 25                        sta tmp1+1
00323Er 3  B5 03                        lda 3,x
003240r 3  F5 01                        sbc 1,x
003242r 3               
003242r 3  A8                           tay
003243r 3  A5 24                        lda tmp1
003245r 3  E9 00                        sbc #0
003247r 3  90 DE                        bcc @loop
003249r 3               
003249r 3                               ; make result new dividend high cell
003249r 3  A5 25                        lda tmp1+1
00324Br 3  95 02                        sta 2,x
00324Dr 3  94 03                        sty 3,x         ; used as temp storage
00324Fr 3               
00324Fr 3  80 D6                        bra @loop
003251r 3               @done:
003251r 3  E8                           inx
003252r 3  E8                           inx
003253r 3               
003253r 3  20 rr rr                     jsr xt_swap
003256r 3               
003256r 3  60           z_um_slash_mod: rts
003257r 3               
003257r 3               
003257r 3               
003257r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
003257r 3               ; ## "um*"  auto  ANS core
003257r 3                       ; """https://forth-standard.org/standard/core/UMTimes
003257r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
003257r 3                       ; Old Forth versions such as FIG Forth call this U*
003257r 3                       ;
003257r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
003257r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
003257r 3                       ; discussion.
003257r 3                       ;
003257r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
003257r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
003257r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
003257r 3                       ;
003257r 3                       ; Consider switching to a table-supported version based on
003257r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
003257r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
003257r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
003257r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
003257r 3                       ; """
003257r 3               
003257r 3               xt_um_star:
003257r 3  20 rr rr                     jsr underflow_2
00325Ar 3               
00325Ar 3                               ; to eliminate clc inside the loop, the value at
00325Ar 3                               ; tmp1 is reduced by 1 in advance
00325Ar 3  18                           clc
00325Br 3  B5 00                        lda 0,x         ; copy TOS to tmp2
00325Dr 3  E9 00                        sbc #0
00325Fr 3  85 26                        sta tmp2
003261r 3               
003261r 3  B5 01                        lda 1,x
003263r 3  E9 00                        sbc #0
003265r 3  90 31                        bcc @zero       ; is TOS zero?
003267r 3  85 27                        sta tmp2+1
003269r 3               
003269r 3  A9 00                        lda #0
00326Br 3  85 24                        sta tmp1
00326Dr 3  86 28                        stx tmp3        ; tested for exit from outer loop
00326Fr 3  CA                           dex
003270r 3  CA                           dex
003271r 3               
003271r 3               @outer_loop:
003271r 3  A0 08                        ldy #8          ; counter inner loop
003273r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
003275r 3               
003275r 3               @inner_loop:
003275r 3  90 0C                        bcc @no_add
003277r 3  85 25                        sta tmp1+1      ; save time, don't CLC
003279r 3  A5 24                        lda tmp1
00327Br 3  65 26                        adc tmp2
00327Dr 3  85 24                        sta tmp1
00327Fr 3  A5 25                        lda tmp1+1
003281r 3  65 27                        adc tmp2+1
003283r 3               
003283r 3               @no_add:
003283r 3  6A                           ror
003284r 3  66 24                        ror tmp1
003286r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
003288r 3               
003288r 3  88                           dey
003289r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
00328Br 3               
00328Br 3  E8                           inx
00328Cr 3  E4 28                        cpx tmp3
00328Er 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
003290r 3               
003290r 3                               ; all done, store high word of result
003290r 3  95 01                        sta 1,x
003292r 3  A5 24                        lda tmp1
003294r 3  95 00                        sta 0,x
003296r 3  80 04                        bra @done
003298r 3               
003298r 3               @zero:
003298r 3  74 02                        stz 2,x
00329Ar 3  74 03                        stz 3,x
00329Cr 3               @done:
00329Cr 3  60           z_um_star:      rts
00329Dr 3               
00329Dr 3               
00329Dr 3               
00329Dr 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
00329Dr 3               ; ## "unloop"  auto  ANS core
00329Dr 3                       ; """https://forth-standard.org/standard/core/UNLOOP
00329Dr 3                       ;
00329Dr 3                       ; Note that 6xPLA uses just as many bytes as a loop would
00329Dr 3                       ; """
00329Dr 3               xt_unloop:
00329Dr 3                               ; Drop fudge number (limit/start from DO/?DO off the
00329Dr 3                               ; return stack
00329Dr 3  68                           pla
00329Er 3  68                           pla
00329Fr 3  68                           pla
0032A0r 3  68                           pla
0032A1r 3               
0032A1r 3                               ; Now drop the LEAVE address that was below them off
0032A1r 3                               ; the Return Stack as well
0032A1r 3  68                           pla
0032A2r 3  68                           pla
0032A3r 3               
0032A3r 3  60           z_unloop:       rts
0032A4r 3               
0032A4r 3               
0032A4r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
0032A4r 3               ; ## "until"  auto  ANS core
0032A4r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
0032A4r 3               xt_until:
0032A4r 3                               ; Compile a 0BRANCH
0032A4r 3  A0 rr                        ldy #>zero_branch_runtime
0032A6r 3  A9 rr                        lda #<zero_branch_runtime
0032A8r 3  20 rr rr                     jsr cmpl_subroutine
0032ABr 3               
0032ABr 3                               ; The address to loop back to is on the stack.
0032ABr 3                               ; Just compile it as the destination for the
0032ABr 3                               ; 0branch.
0032ABr 3  20 rr rr                     jsr xt_comma
0032AEr 3               
0032AEr 3  60           z_until:        rts
0032AFr 3               
0032AFr 3               
0032AFr 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
0032AFr 3               ; ## "unused"  auto  ANS core ext
0032AFr 3                       ; """https://forth-standard.org/standard/core/UNUSED
0032AFr 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
0032AFr 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
0032AFr 3                       ; defaults to $400
0032AFr 3                       ; """
0032AFr 3               xt_unused:
0032AFr 3  CA                           dex
0032B0r 3  CA                           dex
0032B1r 3               
0032B1r 3  A9 DB                        lda #<cp_end
0032B3r 3  38                           sec
0032B4r 3  E5 00                        sbc cp
0032B6r 3  95 00                        sta 0,x
0032B8r 3               
0032B8r 3  A9 59                        lda #>cp_end
0032BAr 3  E5 01                        sbc cp+1
0032BCr 3  95 01                        sta 1,x
0032BEr 3               
0032BEr 3  60           z_unused:       rts
0032BFr 3               
0032BFr 3               
0032BFr 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
0032BFr 3               ; ## "update"  auto  ANS block
0032BFr 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
0032BFr 3               xt_update:
0032BFr 3                               ; Turn on the dirty bit. We can't use TSB here because it only
0032BFr 3                               ; has Absolute and Direct Pages addressing modes
0032BFr 3  A0 2C                        ldy #buffstatus_offset
0032C1r 3  B1 1E                        lda (up),y
0032C3r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
0032C5r 3  91 1E                        sta (up),y
0032C7r 3               
0032C7r 3  60           z_update:       rts
0032C8r 3               
0032C8r 3               
0032C8r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
0032C8r 3               ; ## "useraddr"  tested  Tali Forth
0032C8r 3               xt_useraddr:
0032C8r 3  CA                           dex
0032C9r 3  CA                           dex
0032CAr 3  A9 1E                        lda #<up
0032CCr 3  95 00                        sta 0,x
0032CEr 3  A9 00                        lda #>up
0032D0r 3  95 01                        sta 1,x
0032D2r 3               
0032D2r 3  60           z_useraddr:     rts
0032D3r 3               
0032D3r 3               
0032D3r 3               ; ## VALUE ( n "name" -- ) "Define a value"
0032D3r 3               ; ## "value"  auto  ANS core
0032D3r 3                       ; """https://forth-standard.org/standard/core/VALUE
0032D3r 3                       ;
0032D3r 3                       ; This is a dummy header for the WORDLIST. The actual code is
0032D3r 3                       ; identical to that of CONSTANT
0032D3r 3                       ; """
0032D3r 3               
0032D3r 3               
0032D3r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
0032D3r 3               ; ## "variable"  auto  ANS core
0032D3r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
0032D3r 3                       ; There are various Forth definitions for this word, such as
0032D3r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
0032D3r 3                       ; second one so the variable is initialized to zero
0032D3r 3                       ; """
0032D3r 3               xt_variable:
0032D3r 3                               ; we let CREATE do the heavy lifting
0032D3r 3  20 rr rr                     jsr xt_create
0032D6r 3               
0032D6r 3                               ; there is no "STZ (CP)" so we have to do this the hard
0032D6r 3                               ; way
0032D6r 3  A9 00                        lda #0
0032D8r 3               
0032D8r 3  92 00                        sta (cp)
0032DAr 3  E6 00                        inc cp
0032DCr 3  D0 02                        bne @1
0032DEr 3  E6 01                        inc cp+1
0032E0r 3               @1:
0032E0r 3  92 00                        sta (cp)
0032E2r 3  E6 00                        inc cp
0032E4r 3  D0 02                        bne @2
0032E6r 3  E6 01                        inc cp+1
0032E8r 3               @2:
0032E8r 3                               ; Now we need to adjust the length of the complete word by two
0032E8r 3  20 rr rr                     jsr adjust_z
0032EBr 3               
0032EBr 3  60           z_variable:     rts
0032ECr 3               
0032ECr 3               
0032ECr 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
0032ECr 3               ; ## "while"  auto  ANS core
0032ECr 3                       ; """http://forth-standard.org/standard/core/WHILE"""
0032ECr 3               xt_while:
0032ECr 3                               ; Compile a 0branch
0032ECr 3  A0 rr                        ldy #>zero_branch_runtime
0032EEr 3  A9 rr                        lda #<zero_branch_runtime
0032F0r 3  20 rr rr                     jsr cmpl_subroutine
0032F3r 3               
0032F3r 3                               ; Put the address (here) where the destination
0032F3r 3                               ; address needs to go so it can be put there later.
0032F3r 3  20 rr rr                     jsr xt_here
0032F6r 3               
0032F6r 3                               ; Fill in the destination address with 0 for now.
0032F6r 3  20 rr rr                     jsr xt_zero
0032F9r 3  20 rr rr                     jsr xt_comma
0032FCr 3               
0032FCr 3                               ; Swap the two addresses on the stack.
0032FCr 3  20 rr rr                     jsr xt_swap
0032FFr 3               
0032FFr 3  60           z_while:        rts
003300r 3               
003300r 3               
003300r 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
003300r 3               ; ## "within"  auto  ANS core ext
003300r 3                       ; """https://forth-standard.org/standard/core/WITHIN
003300r 3                       ;
003300r 3                       ; This an assembler version of the ANS Forth implementation
003300r 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
003300r 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
003300r 3                       ; ROT TUCK > -ROT > INVERT AND
003300r 3                       ; """"
003300r 3               xt_within:
003300r 3  20 rr rr                     jsr underflow_3
003303r 3               
003303r 3  20 rr rr                     jsr xt_over
003306r 3  20 rr rr                     jsr xt_minus
003309r 3  20 rr rr                     jsr xt_to_r
00330Cr 3  20 rr rr                     jsr xt_minus
00330Fr 3  20 rr rr                     jsr xt_r_from
003312r 3  20 rr rr                     jsr xt_u_less_than
003315r 3               
003315r 3  60           z_within:       rts
003316r 3               
003316r 3               
003316r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
003316r 3               ; ## "word"  auto  ANS core
003316r 3                       ; """https://forth-standard.org/standard/core/WORD
003316r 3                       ; Obsolete parsing word included for backwards compatibility only.
003316r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
003316r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
003316r 3                       ; Returns the result as a counted string (requires COUNT to convert
003316r 3                       ; to modern format), and inserts a space after the string. See "Forth
003316r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
003316r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
003316r 3                       ; for discussions of why you shouldn't be using WORD anymore.
003316r 3                       ;
003316r 3                       ; Forth
003316r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
003316r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
003316r 3                       ; """
003316r 3               
003316r 3               xt_word:
003316r 3  20 rr rr                     jsr underflow_1
003319r 3               
003319r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
003319r 3                               ; but unlike PARSE
003319r 3  A4 0C                        ldy toin                ; >IN
00331Br 3               @loop:
00331Br 3  C4 0A                        cpy ciblen              ; quit if end of input
00331Dr 3  F0 09                        beq @found_char
00331Fr 3  B1 08                        lda (cib),y
003321r 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
003323r 3  D0 03                        bne @found_char
003325r 3               
003325r 3  C8                           iny
003326r 3  80 F3                        bra @loop
003328r 3               @found_char:
003328r 3                               ; Save index of where word starts
003328r 3  84 0C                        sty toin
00332Ar 3               
00332Ar 3                               ; The real work is done by parse
00332Ar 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
00332Dr 3               
00332Dr 3                               ; Convert the modern ( addr u ) string format to obsolete
00332Dr 3                               ; ( caddr ) format. We just do this in the Dictionary
00332Dr 3  B5 00                        lda 0,x
00332Fr 3  92 00                        sta (cp)                ; Save length of string
003331r 3  48                           pha                     ; Keep copy of length for later
003332r 3               
003332r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
003335r 3  A5 00                        lda cp
003337r 3  18                           clc
003338r 3  69 01                        adc #1
00333Ar 3  95 02                        sta 2,x                 ; LSB of CP
00333Cr 3  A5 01                        lda cp+1
00333Er 3  69 00                        adc #0
003340r 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
003342r 3               
003342r 3  20 rr rr                     jsr xt_move
003345r 3               
003345r 3                               ; Return caddr
003345r 3  CA                           dex
003346r 3  CA                           dex
003347r 3  A5 00                        lda cp
003349r 3  95 00                        sta 0,x
00334Br 3  A5 01                        lda cp+1
00334Dr 3  95 01                        sta 1,x
00334Fr 3               
00334Fr 3                               ; Adjust CP
00334Fr 3  68                           pla                     ; length of string
003350r 3  18                           clc
003351r 3  65 00                        adc cp
003353r 3  85 00                        sta cp
003355r 3  A5 01                        lda cp+1
003357r 3  69 00                        adc #0                  ; we only need the carry
003359r 3  85 01                        sta cp+1
00335Br 3  60           z_word:         rts
00335Cr 3               
00335Cr 3               
00335Cr 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
00335Cr 3               ; ## "wordlist" auto ANS search
00335Cr 3                       ; """https://forth-standard.org/standard/search/WORDLIST
00335Cr 3                       ; See the tutorial on Wordlists and the Search Order for
00335Cr 3                       ; more information.
00335Cr 3                       ; """
00335Cr 3               
00335Cr 3               xt_wordlist:
00335Cr 3                               ; Get the current number of wordlists
00335Cr 3  A0 05                        ldy #num_wordlists_offset
00335Er 3  B1 1E                        lda (up),y      ; This is a byte variable, so only
003360r 3                                               ; the LSB needs to be checked.
003360r 3               
003360r 3                               ; See if we are already at the max.
003360r 3  C9 0C                        cmp #max_wordlists
003362r 3  D0 05                        bne @ok
003364r 3               
003364r 3                               ; Print an error message if all wordlists used.
003364r 3  A9 0B                        lda #err_wordlist
003366r 3  4C rr rr                     jmp error
003369r 3               
003369r 3               @ok:
003369r 3  1A                           inc             ; Increment the wordlist#
00336Ar 3  91 1E                        sta (up),y      ; Save it into byte variable #wordlists
00336Cr 3  CA                           dex             ; and put it on the stack.
00336Dr 3  CA                           dex
00336Er 3  95 00                        sta 0,x
003370r 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
003372r 3               
003372r 3  60           z_wordlist:     rts
003373r 3               
003373r 3               
003373r 3               
003373r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
003373r 3               ; ## "words"  tested  ANS tools
003373r 3                       ; """https://forth-standard.org/standard/tools/WORDS
003373r 3                       ; This is pretty much only used at the command line so we can
003373r 3                       ; be slow and try to save space.
003373r 3                       ; """
003373r 3               
003373r 3               xt_words:
003373r 3                               ; we follow Gforth by starting on the next
003373r 3                               ; line
003373r 3  20 rr rr                     jsr xt_cr
003376r 3               
003376r 3                               ; We pretty-format the output by inserting a line break
003376r 3                               ; before the end of the line. We can get away with pushing
003376r 3                               ; the counter to the stack because this is usually an
003376r 3                               ; interactive word and speed is not that important
003376r 3  A9 00                        lda #0
003378r 3  48                           pha
003379r 3               
003379r 3                               ; Set up for traversing the wordlist search order.
003379r 3  CA                           dex                     ; Make room on the stack for
00337Ar 3  CA                           dex                     ; a dictionary pointer.
00337Br 3  64 28                        stz tmp3                ; Start at the beginning of
00337Dr 3                                                       ; the search order.
00337Dr 3               @wordlist_loop:
00337Dr 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
00337Fr 3  A5 28                        lda tmp3
003381r 3  D1 1E                        cmp (up),y              ; See if we are done.
003383r 3  D0 02                        bne @have_wordlist
003385r 3               
003385r 3                               ; We ran out of wordlists to search.
003385r 3  80 44                        bra @words_done
003387r 3               
003387r 3               @have_wordlist:
003387r 3                               ; start with last word in Dictionary
003387r 3                               ; Get the current wordlist id
003387r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
003388r 3  69 1F                        adc #search_order_offset
00338Ar 3  A8                           tay
00338Br 3  B1 1E                        lda (up),y              ; Get the index into array WORDLISTS
00338Dr 3               
00338Dr 3                               ; Get the DP for that wordlist.
00338Dr 3  0A                           asl                     ; Turn offset into cells offset.
00338Er 3  18                           clc
00338Fr 3  69 06                        adc #wordlists_offset
003391r 3  A8                           tay
003392r 3  B1 1E                        lda (up),y              ; Save the DP for this wordlist
003394r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
003396r 3  C8                           iny
003397r 3  B1 1E                        lda (up),y
003399r 3  95 01                        sta 1,x
00339Br 3               
00339Br 3               @loop:
00339Br 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00339Er 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
0033A1r 3               
0033A1r 3                               ; Insert line break if we're about to go past the end of the
0033A1r 3                               ; line
0033A1r 3  68                           pla
0033A2r 3  18                           clc
0033A3r 3  75 00                        adc 0,x
0033A5r 3  1A                           inc                     ; don't forget the space between words
0033A6r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
0033A8r 3  90 05                        bcc @1
0033AAr 3               
0033AAr 3  20 rr rr                     jsr xt_cr
0033ADr 3  A9 00                        lda #0
0033AFr 3               @1:
0033AFr 3  48                           pha
0033B0r 3  20 rr rr                     jsr xt_type             ; ( nt )
0033B3r 3               
0033B3r 3  A9 20                        lda #AscSP
0033B5r 3  20 rr rr                     jsr emit_a
0033B8r 3               
0033B8r 3                               ; get next word, which begins two down
0033B8r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0033BBr 3  20 rr rr                     jsr xt_one_plus         ; 1+
0033BEr 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
0033C1r 3               
0033C1r 3                               ; if next address is zero, we're done
0033C1r 3  B5 00                        lda 0,x
0033C3r 3  15 01                        ora 1,x
0033C5r 3  D0 D4                        bne @loop
0033C7r 3               
0033C7r 3                               ; Move on to the next wordlist in the search order.
0033C7r 3  E6 28                        inc tmp3
0033C9r 3  80 B2                        bra @wordlist_loop
0033CBr 3               
0033CBr 3               @words_done:
0033CBr 3  68                           pla                     ; dump counter
0033CCr 3               
0033CCr 3  E8                           inx
0033CDr 3  E8                           inx
0033CEr 3               
0033CEr 3  60           z_words:        rts
0033CFr 3               
0033CFr 3               
0033CFr 3               
0033CFr 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
0033CFr 3               ; ## "wordsize"  auto  Tali Forth
0033CFr 3                       ; """Given an word's name token (nt), return the size of the
0033CFr 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
0033CFr 3                       ; count the final RTS.
0033CFr 3                       ; """
0033CFr 3               xt_wordsize:
0033CFr 3  20 rr rr                     jsr underflow_1
0033D2r 3               
0033D2r 3                               ; We get the start address of the word from its header entry
0033D2r 3                               ; for the start of the actual code (execution token, xt)
0033D2r 3                               ; which is four bytes down, and the pointer to the end of the
0033D2r 3                               ; code (z_word, six bytes down)
0033D2r 3  B5 00                        lda 0,x
0033D4r 3  85 24                        sta tmp1
0033D6r 3  B5 01                        lda 1,x
0033D8r 3  85 25                        sta tmp1+1
0033DAr 3               
0033DAr 3  A0 06                        ldy #6
0033DCr 3  B1 24                        lda (tmp1),y    ; LSB of z
0033DEr 3  88                           dey
0033DFr 3  88                           dey
0033E0r 3               
0033E0r 3  38                           sec
0033E1r 3  F1 24                        sbc (tmp1),y    ; LSB of xt
0033E3r 3  95 00                        sta 0,x
0033E5r 3               
0033E5r 3  A0 07                        ldy #7
0033E7r 3  B1 24                        lda (tmp1),y    ; MSB of z
0033E9r 3  88                           dey
0033EAr 3  88                           dey
0033EBr 3               
0033EBr 3  F1 24                        sbc (tmp1),y    ; MSB of xt
0033EDr 3  95 01                        sta 1,x
0033EFr 3               
0033EFr 3  60           z_wordsize:     rts
0033F0r 3               
0033F0r 3               
0033F0r 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
0033F0r 3               ; ## "xor"  auto  ANS core
0033F0r 3                       ; """https://forth-standard.org/standard/core/XOR"""
0033F0r 3               xt_xor:
0033F0r 3  20 rr rr                     jsr underflow_2
0033F3r 3               
0033F3r 3  B5 00                        lda 0,x
0033F5r 3  55 02                        eor 2,x
0033F7r 3  95 02                        sta 2,x
0033F9r 3               
0033F9r 3  B5 01                        lda 1,x
0033FBr 3  55 03                        eor 3,x
0033FDr 3  95 03                        sta 3,x
0033FFr 3               
0033FFr 3  E8                           inx
003400r 3  E8                           inx
003401r 3               
003401r 3  60           z_xor:          rts
003402r 3               
003402r 3               
003402r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
003402r 3               ; ## "0"  auto  Tali Forth
003402r 3                       ; """The disassembler assumes that this routine does not use Y. Note
003402r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
003402r 3                       ; is 0."""
003402r 3               xt_case:
003402r 3               xt_forth_wordlist:
003402r 3               xt_zero:
003402r 3  CA                           dex             ; push
003403r 3  CA                           dex
003404r 3  74 00                        stz 0,x
003406r 3  74 01                        stz 1,x
003408r 3               z_case:
003408r 3               z_forth_wordlist:
003408r 3               z_zero:
003408r 3  60                           rts
003409r 3               
003409r 3               
003409r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
003409r 3               ; ## "0="  auto  ANS core
003409r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
003409r 3               
003409r 3               xt_zero_equal:
003409r 3  20 rr rr                     jsr underflow_1
00340Cr 3               
00340Cr 3  B5 00                        lda 0,x
00340Er 3  15 01                        ora 1,x
003410r 3  F0 04                        beq @zero
003412r 3               
003412r 3                               ; not a zero, so we need a FALSE flag (0)
003412r 3  A9 00                        lda #0
003414r 3  80 02                        bra @store
003416r 3               @zero:
003416r 3                               ; We have a zero, so we need a TRUE flag (-1)
003416r 3  A9 FF                        lda #$ff
003418r 3               @store:
003418r 3  95 00                        sta 0,x
00341Ar 3  95 01                        sta 1,x
00341Cr 3               
00341Cr 3  60           z_zero_equal:   rts
00341Dr 3               
00341Dr 3               
00341Dr 3               
00341Dr 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
00341Dr 3               ; ## "0>"  auto  ANS core ext
00341Dr 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
00341Dr 3               
00341Dr 3               xt_zero_greater:
00341Dr 3  20 rr rr                     jsr underflow_1
003420r 3               
003420r 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
003422r 3               
003422r 3  B5 01                        lda 1,x         ; MSB
003424r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
003426r 3  15 00                        ora 0,x
003428r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
00342Ar 3               
00342Ar 3  88                           dey             ; TOS is postive, make true
00342Br 3               @done:
00342Br 3  98                           tya
00342Cr 3  95 00                        sta 0,x
00342Er 3  95 01                        sta 1,x
003430r 3               
003430r 3  60           z_zero_greater: rts
003431r 3               
003431r 3               
003431r 3               
003431r 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
003431r 3               ; ## "0<"  auto  ANS core
003431r 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
003431r 3               
003431r 3               xt_zero_less:
003431r 3  20 rr rr                     jsr underflow_1
003434r 3               
003434r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
003436r 3               
003436r 3  B5 01                        lda 1,x         ; MSB
003438r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
00343Ar 3               
00343Ar 3  88                           dey             ; TOS is negative, make TRUE
00343Br 3               @done:
00343Br 3  98                           tya
00343Cr 3  95 00                        sta 0,x
00343Er 3  95 01                        sta 1,x
003440r 3               
003440r 3  60           z_zero_less:    rts
003441r 3               
003441r 3               
003441r 3               
003441r 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
003441r 3               ; ## "0<>"  auto  ANS core ext
003441r 3                       ; """https://forth-standard.org/standard/core/Zerone"""
003441r 3               
003441r 3               xt_zero_unequal:
003441r 3  20 rr rr                     jsr underflow_1
003444r 3               
003444r 3  A0 00                        ldy #0          ; default false
003446r 3               
003446r 3  B5 00                        lda 0,x
003448r 3  15 01                        ora 1,x
00344Ar 3  F0 01                        beq @got_zero
00344Cr 3               
00344Cr 3  88                           dey
00344Dr 3               @got_zero:
00344Dr 3  98                           tya
00344Er 3  95 00                        sta 0,x
003450r 3  95 01                        sta 1,x
003452r 3               
003452r 3  60           z_zero_unequal: rts
003453r 3               
003453r 3               
003453r 3               
003453r 3               ; ==========================================================
003453r 3               ; EDITOR words
003453r 3               
003453r 3               ; This routine is used by both enter-screen and erase-screen
003453r 3               ; to get a buffer for the given screen number and set SCR to
003453r 3               ; the given screen number.  This word is not in the dictionary.
003453r 3               xt_editor_screen_helper:
003453r 3  20 rr rr                     jsr xt_dup
003456r 3  20 rr rr                     jsr xt_scr
003459r 3  20 rr rr                     jsr xt_store
00345Cr 3  20 rr rr                     jsr xt_buffer
00345Fr 3               z_editor_screen_helper:
00345Fr 3  60                           rts
003460r 3               
003460r 3               
003460r 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
003460r 3               ; ## "enter-screen"  auto  Tali Editor
003460r 3               
003460r 3               xt_editor_enter_screen:
003460r 3                               ; Set the variable SCR and get a buffer for the
003460r 3                               ; given screen number.
003460r 3  20 rr rr                     jsr xt_editor_screen_helper
003463r 3               
003463r 3                               ; Drop the buffer address.
003463r 3  20 rr rr                     jsr xt_drop
003466r 3               
003466r 3                               ; Overwrite the lines one at a time.
003466r 3  64 2E                        stz editor1
003468r 3               @prompt_loop:
003468r 3                               ; Put the current line number on the stack.
003468r 3  CA                           dex
003469r 3  CA                           dex
00346Ar 3  A5 2E                        lda editor1
00346Cr 3  95 00                        sta 0,x
00346Er 3  74 01                        stz 1,x
003470r 3               
003470r 3                               ; Use the O word to prompt for overwrite.
003470r 3  20 rr rr                     jsr xt_editor_o
003473r 3               
003473r 3                               ; Move on to the next line.
003473r 3  E6 2E                        inc editor1
003475r 3  A9 10                        lda #16
003477r 3  C5 2E                        cmp editor1
003479r 3  D0 ED                        bne @prompt_loop
00347Br 3               
00347Br 3               z_editor_enter_screen:
00347Br 3  60                           rts
00347Cr 3               
00347Cr 3               
00347Cr 3               
00347Cr 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
00347Cr 3               ; ## "erase-screen"  tested  Tali Editor
00347Cr 3               xt_editor_erase_screen:
00347Cr 3                               ; Set the variable SCR and get a buffer for the
00347Cr 3                               ; given screen number.
00347Cr 3  20 rr rr                     jsr xt_editor_screen_helper
00347Fr 3               
00347Fr 3                               ; Put 1024 (chars/screen) on stack.
00347Fr 3  CA                           dex
003480r 3  CA                           dex
003481r 3  74 00                        stz 0,x
003483r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
003485r 3  95 01                        sta 1,x
003487r 3               
003487r 3                               ; Erase the entire block (fill with spaces).
003487r 3  20 rr rr                     jsr xt_blank
00348Ar 3               
00348Ar 3                               ; Mark buffer as updated.
00348Ar 3  20 rr rr                     jsr xt_update
00348Dr 3               
00348Dr 3               z_editor_erase_screen:
00348Dr 3  60                           rts
00348Er 3               
00348Er 3               
00348Er 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
00348Er 3               ; ## "el"  tested  Tali Editor
00348Er 3               xt_editor_el:
00348Er 3                               ; Turn the line number into buffer offset.
00348Er 3                               ; This also loads the block into the buffer if it's
00348Er 3                               ; not there for some reason.
00348Er 3  20 rr rr                     jsr xt_editor_line
003491r 3               
003491r 3                               ; Put 64 (# of chars/line) on the stack.
003491r 3  CA                           dex
003492r 3  CA                           dex
003493r 3  A9 40                        lda #64
003495r 3  95 00                        sta 0,x
003497r 3  74 01                        stz 1,x
003499r 3               
003499r 3                               ; Fill with spaces.
003499r 3  20 rr rr                     jsr xt_blank
00349Cr 3               
00349Cr 3                               ; Mark buffer as updated.
00349Cr 3  20 rr rr                     jsr xt_update
00349Fr 3               
00349Fr 3  60           z_editor_el:    rts
0034A0r 3               
0034A0r 3               
0034A0r 3               ; ## EDITOR_L ( -- ) "List the current screen"
0034A0r 3               ; ## "l"  tested  Tali Editor
0034A0r 3               
0034A0r 3               xt_editor_l:
0034A0r 3                               ; Load the current screen
0034A0r 3  CA                           dex             ; Put SCR on the stack.
0034A1r 3  CA                           dex
0034A2r 3  A0 02                        ldy #scr_offset
0034A4r 3  B1 1E                        lda (up),y
0034A6r 3  95 00                        sta 0,x
0034A8r 3  C8                           iny
0034A9r 3  B1 1E                        lda (up),y
0034ABr 3  95 01                        sta 1,x
0034ADr 3  20 rr rr                     jsr xt_block    ; Get the current screen.
0034B0r 3               
0034B0r 3  20 rr rr                     jsr xt_cr
0034B3r 3               
0034B3r 3                               ; Print the screen number.
0034B3r 3                               ; We're using sliteral, so we need to set up the
0034B3r 3                               ; appropriate data structure (see sliteral)
0034B3r 3  80 08                        bra @after_screen_msg
0034B5r 3               
0034B5r 3               @screen_msg:
0034B5r 3  53 63 72 65                  .byte "Screen #"
0034B9r 3  65 6E 20 23  
0034BDr 3               
0034BDr 3               @after_screen_msg:
0034BDr 3  20 rr rr                     jsr sliteral_runtime
0034C0r 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
0034C4r 3               
0034C4r 3  20 rr rr                     jsr xt_type
0034C7r 3               
0034C7r 3                               ; Put the screen number and printed size for u.r on the stack.
0034C7r 3  20 rr rr                     jsr xt_scr
0034CAr 3  20 rr rr                     jsr xt_fetch
0034CDr 3  CA                           dex
0034CEr 3  CA                           dex
0034CFr 3  A9 04                        lda #4          ; four spaces
0034D1r 3  95 00                        sta 0,x
0034D3r 3  74 01                        stz 1,x
0034D5r 3  20 rr rr                     jsr xt_u_dot_r
0034D8r 3               
0034D8r 3                               ; The address of the buffer is currently on the stack.
0034D8r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
0034D8r 3                               ; keep track of the line number in tmp3.
0034D8r 3  64 28                        stz tmp3
0034DAr 3               
0034DAr 3               @line_loop:
0034DAr 3  20 rr rr                     jsr xt_cr
0034DDr 3               
0034DDr 3                               ; Print the line number (2-space fixed width)
0034DDr 3  CA                           dex
0034DEr 3  CA                           dex
0034DFr 3  CA                           dex
0034E0r 3  CA                           dex
0034E1r 3  74 03                        stz 3,x
0034E3r 3  A5 28                        lda tmp3
0034E5r 3  95 02                        sta 2,x
0034E7r 3  74 01                        stz 1,x
0034E9r 3  A9 02                        lda #2
0034EBr 3  95 00                        sta 0,x
0034EDr 3  20 rr rr                     jsr xt_u_dot_r
0034F0r 3  20 rr rr                     jsr xt_space
0034F3r 3               
0034F3r 3                               ; Print one line using the address on the stack.
0034F3r 3  20 rr rr                     jsr xt_dup
0034F6r 3  CA                           dex
0034F7r 3  CA                           dex
0034F8r 3  A9 40                        lda #64
0034FAr 3  95 00                        sta 0,x
0034FCr 3  74 01                        stz 1,x
0034FEr 3  20 rr rr                     jsr xt_type
003501r 3               
003501r 3                               ; Add 64 to the address on the stack to move to the next line.
003501r 3  18                           clc
003502r 3  A9 40                        lda #64
003504r 3  75 00                        adc 0,x
003506r 3  95 00                        sta 0,x
003508r 3  B5 01                        lda 1,x
00350Ar 3  69 00                        adc #0      ; Add carry
00350Cr 3  95 01                        sta 1,x
00350Er 3               
00350Er 3                               ; Increment the line number (held in tmp3)
00350Er 3  E6 28                        inc tmp3
003510r 3               
003510r 3                               ; See if we are done.
003510r 3  A5 28                        lda tmp3
003512r 3  C9 10                        cmp #16
003514r 3  D0 C4                        bne @line_loop
003516r 3               
003516r 3  20 rr rr                     jsr xt_cr
003519r 3                               ; Drop the address on the stack.
003519r 3  E8                           inx
00351Ar 3  E8                           inx
00351Br 3               
00351Br 3  60           z_editor_l:            rts
00351Cr 3               
00351Cr 3               
00351Cr 3               
00351Cr 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
00351Cr 3               ; ## "line"  tested  Tali Editor
00351Cr 3               
00351Cr 3               xt_editor_line:
00351Cr 3  20 rr rr                     jsr underflow_1
00351Fr 3               
00351Fr 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
00351Fr 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
003521r 3               @shift_tos_left:
003521r 3  16 00                        asl 0,x         ; Shift TOS to the left
003523r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
003525r 3  88                           dey
003526r 3  D0 F9                        bne @shift_tos_left
003528r 3                               ; Load the current screen into a buffer
003528r 3                               ; and get the buffer address
003528r 3  20 rr rr                     jsr xt_scr
00352Br 3  20 rr rr                     jsr xt_fetch
00352Er 3  20 rr rr                     jsr xt_block
003531r 3               
003531r 3                               ; Add the offset to the buffer base address.
003531r 3  20 rr rr                     jsr xt_plus
003534r 3               
003534r 3  60           z_editor_line:  rts
003535r 3               
003535r 3               
003535r 3               
003535r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
003535r 3               ; ## "o"  tested  Tali Editor
003535r 3               xt_editor_o:
003535r 3                               ; Print prompt
003535r 3  20 rr rr                     jsr xt_cr
003538r 3  20 rr rr                     jsr xt_dup
00353Br 3  20 rr rr                     jsr xt_two
00353Er 3  20 rr rr                     jsr xt_u_dot_r
003541r 3  20 rr rr                     jsr xt_space
003544r 3  A9 2A                        lda #42         ; ASCII for *
003546r 3  20 rr rr                     jsr emit_a
003549r 3  20 rr rr                     jsr xt_space
00354Cr 3               
00354Cr 3                               ; Accept new input (directly into the buffer)
00354Cr 3  20 rr rr                     jsr xt_editor_line
00354Fr 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
003552r 3  CA                           dex
003553r 3  CA                           dex
003554r 3  A9 40                        lda #64         ; chars/line
003556r 3  95 00                        sta 0,x
003558r 3  74 01                        stz 1,x
00355Ar 3  20 rr rr                     jsr xt_accept
00355Dr 3               
00355Dr 3                               ; Fill the rest with spaces.
00355Dr 3                               ; Stack is currently ( line_address numchars_from_accept )
00355Dr 3  20 rr rr                     jsr xt_dup
003560r 3  20 rr rr                     jsr xt_not_rote ; -rot
003563r 3  20 rr rr                     jsr xt_plus
003566r 3  CA                           dex
003567r 3  CA                           dex
003568r 3  A9 40                        lda #64         ; chars/line
00356Ar 3  95 00                        sta 0,x
00356Cr 3  74 01                        stz 1,x
00356Er 3  20 rr rr                     jsr xt_rot
003571r 3  20 rr rr                     jsr xt_minus
003574r 3  20 rr rr                     jsr xt_blank
003577r 3               
003577r 3                               ; Mark buffer as updated.
003577r 3  20 rr rr                     jsr xt_update
00357Ar 3               
00357Ar 3  60           z_editor_o:     rts
00357Br 3               
00357Br 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
00357Br 3               ; ## "lcdput" coded Custom
00357Br 3               xt_lcdput:
00357Br 3  20 rr rr                     jsr underflow_1
00357Er 3               
00357Er 3  B5 00                        lda 0,x
003580r 3                       .ifdef lcd_print
003580r 3  20 rr rr                     jsr lcd_print
003583r 3                       .endif
003583r 3  E8                           inx
003584r 3  E8                           inx
003585r 3  60           z_lcdput: rts
003586r 3               
003586r 3               
003586r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
003586r 3               ; ## "lcdprint"  coded Custom
003586r 3               
003586r 3               xt_lcdprint:
003586r 3  20 rr rr                     jsr underflow_2
003589r 3               
003589r 3                               ; Save the starting address into tmp1
003589r 3  B5 02                        lda 2,x
00358Br 3  85 24                        sta tmp1
00358Dr 3  B5 03                        lda 3,x
00358Fr 3  85 25                        sta tmp1+1
003591r 3               @loop:
003591r 3                               ; done if length is zero
003591r 3  B5 00                        lda 0,x
003593r 3  15 01                        ora 1,x
003595r 3  F0 15                        beq @done
003597r 3               
003597r 3                               ; Send the current character
003597r 3  B2 24                        lda (tmp1)
003599r 3                       .ifdef lcd_print
003599r 3  20 rr rr                     jsr lcd_print      ; avoids stack foolery
00359Cr 3                       .endif
00359Cr 3                               ; Move the address along (in tmp1)
00359Cr 3  E6 24                        inc tmp1
00359Er 3  D0 02                        bne @1
0035A0r 3  E6 25                        inc tmp1+1
0035A2r 3               @1:
0035A2r 3                               ; Reduce the count (on the data stack)
0035A2r 3  B5 00                        lda 0,x
0035A4r 3  D0 02                        bne @2
0035A6r 3  D6 01                        dec 1,x
0035A8r 3               @2:
0035A8r 3  D6 00                        dec 0,x
0035AAr 3               
0035AAr 3  80 E5                        bra @loop
0035ACr 3               @done:
0035ACr 3  E8                           inx
0035ADr 3  E8                           inx
0035AEr 3  E8                           inx
0035AFr 3  E8                           inx
0035B0r 3               
0035B0r 3  60           z_lcdprint:         rts
0035B1r 3               
0035B1r 3               
0035B1r 3               
0035B1r 3               ; ## CLS ( -- ) "clea VGA screen"
0035B1r 3               ; ## "cls" coded Custom
0035B1r 3               xt_cls:
0035B1r 3                       .ifdef vga_clear
0035B1r 3  20 rr rr                     jsr vga_clear
0035B4r 3                       .endif
0035B4r 3               
0035B4r 3  60           z_cls: rts
0035B5r 3               
0035B5r 3               
0035B5r 3               ; ## SPI_INIT ( -- ) "Init SPI system"
0035B5r 3               ; ## "spi_init" coded Custom
0035B5r 3               xt_spi_init:
0035B5r 3                       .ifdef spi_init
0035B5r 3  20 rr rr                     jsr spi_init
0035B8r 3                       .endif
0035B8r 3  60           z_spi_init: rts
0035B9r 3               
0035B9r 3               
0035B9r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
0035B9r 3               ; ## "spi_clk_toggle" coded Custom
0035B9r 3               xt_spi_clk_toggle:
0035B9r 3                       .ifdef spi_clk_toggle
0035B9r 3  20 rr rr                     jsr spi_clk_toggle
0035BCr 3                       .endif
0035BCr 3  60           z_spi_clk_toggle: rts
0035BDr 3               
0035BDr 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
0035BDr 3               ; ## "spi_select" coded Custom
0035BDr 3               xt_spi_select:
0035BDr 3  20 rr rr                     jsr underflow_1
0035C0r 3               
0035C0r 3  B5 00                        lda 0,x
0035C2r 3                       .ifdef spi_select
0035C2r 3  20 rr rr                     jsr spi_select
0035C5r 3                       .endif
0035C5r 3  E8                           inx
0035C6r 3  E8                           inx
0035C7r 3  60           z_spi_select: rts
0035C8r 3               
0035C8r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
0035C8r 3               ; ## "spi_transceive" coded Custom
0035C8r 3               xt_spi_transceive:
0035C8r 3  20 rr rr                     jsr underflow_1
0035CBr 3               
0035CBr 3  B5 00                        lda 0,x
0035CDr 3                       .ifdef spi_transceive
0035CDr 3  20 rr rr                     jsr spi_transceive
0035D0r 3                       .endif
0035D0r 3  95 00                        sta 0,x         ; put return value in TOS
0035D2r 3  74 01                        stz 1,X         ;reset value there
0035D4r 3  60           z_spi_transceive: rts
0035D5r 3               
0035D5r 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
0035D5r 3               ; ## "spi_transceive" coded Custom
0035D5r 3               xt_sd_init:
0035D5r 3  20 rr rr                     jsr underflow_1
0035D8r 3               
0035D8r 3  B5 00                        lda 0,x
0035DAr 3                       .ifdef sd_init
0035DAr 3  20 rr rr                     jsr sd_init
0035DDr 3                       .endif
0035DDr 3  95 00                        sta 0,x         ; put return value in TOS
0035DFr 3  74 01                        stz 1,X         ;reset value there
0035E1r 3  60           z_sd_init: rts
0035E2r 3               
0035E2r 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
0035E2r 3               ; ## "sd_readsector" coded Custom
0035E2r 3               xt_sd_readsector:
0035E2r 3  20 rr rr                     jsr underflow_3
0035E5r 3                       .ifdef sd_readsector
0035E5r 3                               ; get and save storage address
0035E5r 3  B5 00                        lda 0,x
0035E7r 3  85 9E                        sta sd_buffer_address
0035E9r 3  B5 01                        lda 1, x
0035EBr 3  85 9F                        sta sd_buffer_address + 1
0035EDr 3                               ; get and save sector number (32 bit number, double)
0035EDr 3  B5 02                        lda 2, X
0035EFr 3  8D FF 79                     sta SD_ARG + 3
0035F2r 3  B5 03                        lda 3, X
0035F4r 3  8D FE 79                     sta SD_ARG + 2
0035F7r 3  B5 04                        lda 4, X
0035F9r 3  8D FD 79                     sta SD_ARG + 1
0035FCr 3  B5 05                        lda 5, X
0035FEr 3  8D FC 79                     sta SD_ARG
003601r 3  A9 01                        lda #1
003603r 3  8D 02 7A                     sta SD_CRC
003606r 3               
003606r 3  20 rr rr                     jsr sd_readsector
003609r 3                       .endif
003609r 3  95 00                        sta 0,x         ; put return value in TOS
00360Br 3  74 01                        stz 1,X         ;reset value there
00360Dr 3               
00360Dr 3  E8                           inx
00360Er 3  E8                           inx
00360Fr 3  E8                           inx
003610r 3  E8                           inx
003611r 3               
003611r 3  60           z_sd_readsector: rts
003612r 3               
003612r 3               
003612r 3               ; ## FAT32_INIT ( u -- u ) "initialize FAT32 file system on passed spi drive address"
003612r 3               ; ## "fat32_init" coded Custom
003612r 3               xt_fat32_init:
003612r 3  20 rr rr                     jsr underflow_1
003615r 3               
003615r 3  B5 00                        lda 0,x
003617r 3                       .ifdef sd_init
003617r 3  20 rr rr                     jsr sd_init
00361Ar 3  D0 08                        bne @error
00361Cr 3                       .endif
00361Cr 3                       .ifdef fat32_init
00361Cr 3  20 rr rr                     jsr fat32_init
00361Fr 3                       .endif
00361Fr 3                       .ifdef fat32_openroot
00361Fr 3  20 rr rr                     jsr fat32_openroot
003622r 3  F0 02                        beq @end
003624r 3                       .endif
003624r 3               @error:
003624r 3  A9 01                        lda #1
003626r 3               @end:
003626r 3  95 00                        sta 0,x         ; put return value in TOS
003628r 3  74 01                        stz 1,X         ;reset value there
00362Ar 3  60           z_fat32_init: rts
00362Br 3               
00362Br 3               
00362Br 3               ; ## FAT32_FIND ( addr u -- u ) "Open file from initialized fat32 FS"
00362Br 3               ; ## "fat32_find" coded Custom
00362Br 3               xt_fat32_find:
00362Br 3  20 rr rr                     jsr underflow_2
00362Er 3  5A                           phy
00362Fr 3  B4 00                        ldy 0,x ; length of string
003631r 3  A9 00                        lda #0
003633r 3               @reset_loop:
003633r 3  91 92                        sta (fat32_filenamepointer),y
003635r 3  C8                           iny
003636r 3  C0 0B                        cpy #11
003638r 3  90 F9                        bcc @reset_loop
00363Ar 3  E8                           inx     ; get address
00363Br 3  E8                           inx
00363Cr 3  B5 00                        lda 0,x
00363Er 3  85 92                        sta fat32_filenamepointer
003640r 3  B5 01                        lda 1,x
003642r 3  85 93                        sta fat32_filenamepointer+1
003644r 3               
003644r 3  7A                           ply
003645r 3               
003645r 3  20 rr rr                     jsr fat32_finddirent    ; open root file system
003648r 3  F0 02                        beq @end
00364Ar 3               
00364Ar 3               @error:
00364Ar 3  A9 01                        lda #1
00364Cr 3               @end:
00364Cr 3  95 00                        sta 0,x         ; put return value in TOS
00364Er 3  74 01                        stz 1,X         ;reset value there
003650r 3  60           z_fat32_find: rts
003651r 3               
003651r 3               ; TODO add routine to send a block of data in memory via SPI
003651r 3               ; similar to lcdprint
003651r 3               
003651r 3               ; END
003651r 3               
003651r 3               
003651r 2               .include "assembler.asm"        ; SAN assembler
003651r 3               ; Assembler for Tali Forth 2
003651r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
003651r 3               ; First version: 07. Nov 2014 (as tasm65c02)
003651r 3               ; This version: 03. Jan 2019
003651r 3               
003651r 3               ; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
003651r 3               ; is included with
003651r 3               
003651r 3               ;       assembler-wordlist >order
003651r 3               
003651r 3               ; the opcodes are available as normal Forth words. The format is Simpler
003651r 3               ; Assembler Notation (SAN) which separates the opcode completely from the
003651r 3               ; operand (see https://github.com/scotws/SAN). In this case, the operand is
003651r 3               ; entered before the opcode in the postfix Forth notation (for example, "2000
003651r 3               ; lda.#"). See the assembler documenation in the manual for more detail.
003651r 3               
003651r 3               ; The code here was originally used in A Typist's Assembler for the 65c02
003651r 3               ; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
003651r 3               ; version. Tasm65c02 is in the public domain.
003651r 3               
003651r 3               ; This code makes use of the opcode tables stored as part of the disassembler.
003651r 3               
003651r 3               ; ==========================================================
003651r 3               ; MNEMONICS
003651r 3               
003651r 3               ; The assembler instructions are realized as individual Forth words with
003651r 3               ; entries in the assembler wordlist (see header.asm). We pass the opcode in A.
003651r 3               
003651r 3               ; An alterantive method would have been along the lines of
003651r 3               
003651r 3               ;               jsr asm_common
003651r 3               ;               .byte $EA
003651r 3               
003651r 3               ; where the asm_common then uses the address on the Return Stack to pick up the
003651r 3               ; opcode and the length. Though this uses fewer resources, the current version
003651r 3               ; makes up for this by simplifying the code of asm_common.
003651r 3               
003651r 3               ; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
003651r 3               ; SAN and traditional mnemonics are listed after the opcode load instruction.
003651r 3               ; This list was generated by a Python script in the tools folder, see there for
003651r 3               ; more detail.
003651r 3               
003651r 3               assembler:              ; used to calculate size of assembler code
003651r 3               
003651r 3               xt_asm_adc_h:   ; adc.# \ ADC #nn
003651r 3  A9 69                        lda #$69
003653r 3  4C rr rr                     jmp asm_common
003656r 3               z_asm_adc_h:
003656r 3               
003656r 3               xt_asm_adc_x:   ; adc.x \ ADC nnnn,X
003656r 3  A9 7D                        lda #$7D
003658r 3  4C rr rr                     jmp asm_common
00365Br 3               z_asm_adc_x:
00365Br 3               
00365Br 3               xt_asm_adc_y:   ; adc.y \ ADC nnnn,Y
00365Br 3  A9 79                        lda #$79
00365Dr 3  4C rr rr                     jmp asm_common
003660r 3               z_asm_adc_y:
003660r 3               
003660r 3               xt_asm_adc_z:   ; adc.z \ ADC nn
003660r 3  A9 65                        lda #$65
003662r 3  4C rr rr                     jmp asm_common
003665r 3               z_asm_adc_z:
003665r 3               
003665r 3               xt_asm_adc_zi:  ; adc.zi \ ADC (nn)
003665r 3  A9 72                        lda #$72
003667r 3  4C rr rr                     jmp asm_common
00366Ar 3               z_asm_adc_zi:
00366Ar 3               
00366Ar 3               xt_asm_adc_ziy: ; adc.ziy \ ADC (nn),Y
00366Ar 3  A9 71                        lda #$71
00366Cr 3  4C rr rr                     jmp asm_common
00366Fr 3               z_asm_adc_ziy:
00366Fr 3               
00366Fr 3               xt_asm_adc_zx:  ; adc.zx \ ADC nn,X
00366Fr 3  A9 75                        lda #$75
003671r 3  4C rr rr                     jmp asm_common
003674r 3               z_asm_adc_zx:
003674r 3               
003674r 3               xt_asm_adc_zxi: ; adc.zxi \ ADC (nn,X)
003674r 3  A9 61                        lda #$61
003676r 3  4C rr rr                     jmp asm_common
003679r 3               z_asm_adc_zxi:
003679r 3               
003679r 3               xt_asm_and:     ; and. \ AND nnnn
003679r 3  A9 2D                        lda #$2D
00367Br 3  4C rr rr                     jmp asm_common
00367Er 3               z_asm_and:
00367Er 3               
00367Er 3               xt_asm_and_h:   ; and.# \ AND #nn
00367Er 3  A9 29                        lda #$29
003680r 3  4C rr rr                     jmp asm_common
003683r 3               z_asm_and_h:
003683r 3               
003683r 3               xt_asm_and_x:   ; and.x \ AND nnnn,X
003683r 3  A9 3D                        lda #$3D
003685r 3  4C rr rr                     jmp asm_common
003688r 3               z_asm_and_x:
003688r 3               
003688r 3               xt_asm_and_y:   ; and.y \ AND nnnn,Y
003688r 3  A9 39                        lda #$39
00368Ar 3  4C rr rr                     jmp asm_common
00368Dr 3               z_asm_and_y:
00368Dr 3               
00368Dr 3               xt_asm_and_z:   ; and.z \ AND nn
00368Dr 3  A9 25                        lda #$25
00368Fr 3  4C rr rr                     jmp asm_common
003692r 3               z_asm_and_z:
003692r 3               
003692r 3               xt_asm_and_zi:  ; and.zi \ AND (nn)
003692r 3  A9 32                        lda #$32
003694r 3  4C rr rr                     jmp asm_common
003697r 3               z_asm_and_zi:
003697r 3               
003697r 3               xt_asm_and_ziy: ; and.ziy \ AND (nn),Y
003697r 3  A9 31                        lda #$31
003699r 3  4C rr rr                     jmp asm_common
00369Cr 3               z_asm_and_ziy:
00369Cr 3               
00369Cr 3               xt_asm_and_zx:  ; and.zx \ AND nn,X
00369Cr 3  A9 35                        lda #$35
00369Er 3  4C rr rr                     jmp asm_common
0036A1r 3               z_asm_and_zx:
0036A1r 3               
0036A1r 3               xt_asm_and_zxi: ; and.zxi \ AND (nn,X)
0036A1r 3  A9 21                        lda #$21
0036A3r 3  4C rr rr                     jmp asm_common
0036A6r 3               z_asm_and_zxi:
0036A6r 3               
0036A6r 3               xt_asm_asl:     ; asl \ ASL nnnn
0036A6r 3  A9 0E                        lda #$0E
0036A8r 3  4C rr rr                     jmp asm_common
0036ABr 3               z_asm_asl:
0036ABr 3               
0036ABr 3               xt_asm_asl_a:   ; asl.a \ ASL
0036ABr 3  A9 0A                        lda #$0A
0036ADr 3  4C rr rr                     jmp asm_common
0036B0r 3               z_asm_asl_a:
0036B0r 3               
0036B0r 3               xt_asm_asl_x:   ; asl.x \ ASL nnnn,X
0036B0r 3  A9 1E                        lda #$1E
0036B2r 3  4C rr rr                     jmp asm_common
0036B5r 3               z_asm_asl_x:
0036B5r 3               
0036B5r 3               xt_asm_asl_z:   ; asl.z \ ASL nn
0036B5r 3  A9 06                        lda #$06
0036B7r 3  4C rr rr                     jmp asm_common
0036BAr 3               z_asm_asl_z:
0036BAr 3               
0036BAr 3               xt_asm_asl_zx:  ; asl.zx \ ASL nn,X
0036BAr 3  A9 16                        lda #$16
0036BCr 3  4C rr rr                     jmp asm_common
0036BFr 3               z_asm_asl_zx:
0036BFr 3               
0036BFr 3               xt_asm_bcc:     ; bcc \ BCC
0036BFr 3  A9 90                        lda #$90
0036C1r 3  4C rr rr                     jmp asm_common
0036C4r 3               z_asm_bcc:
0036C4r 3               
0036C4r 3               xt_asm_bcs:     ; bcs \ BCS
0036C4r 3  A9 B0                        lda #$B0
0036C6r 3  A0 02                        ldy #2
0036C8r 3  4C rr rr                     jmp asm_common
0036CBr 3               z_asm_bcs:
0036CBr 3               
0036CBr 3               xt_asm_beq:     ; beq \ BEQ
0036CBr 3  A9 F0                        lda #$F0
0036CDr 3  4C rr rr                     jmp asm_common
0036D0r 3               z_asm_beq:
0036D0r 3               
0036D0r 3               xt_asm_bit:     ; bit \ BIT nnnn
0036D0r 3  A9 2C                        lda #$2C
0036D2r 3  4C rr rr                     jmp asm_common
0036D5r 3               z_asm_bit:
0036D5r 3               
0036D5r 3               xt_asm_bit_h:   ; bit.# \ BIT #nn
0036D5r 3  A9 89                        lda #$89
0036D7r 3  4C rr rr                     jmp asm_common
0036DAr 3               z_asm_bit_h:
0036DAr 3               
0036DAr 3               xt_asm_bit_x:   ; bit.x \ BIT nnnn,X
0036DAr 3  A9 3C                        lda #$3C
0036DCr 3  4C rr rr                     jmp asm_common
0036DFr 3               z_asm_bit_x:
0036DFr 3               
0036DFr 3               xt_asm_bit_z:   ; bit.z \ BIT nn
0036DFr 3  A9 24                        lda #$24
0036E1r 3  4C rr rr                     jmp asm_common
0036E4r 3               z_asm_bit_z:
0036E4r 3               
0036E4r 3               xt_asm_bit_zx:  ; bit.zx \ BIT nn,X
0036E4r 3  A9 34                        lda #$34
0036E6r 3  4C rr rr                     jmp asm_common
0036E9r 3               z_asm_bit_zx:
0036E9r 3               
0036E9r 3               xt_asm_bmi:     ; bmi \ BMI
0036E9r 3  A9 30                        lda #$30
0036EBr 3  4C rr rr                     jmp asm_common
0036EEr 3               z_asm_bmi:
0036EEr 3               
0036EEr 3               xt_asm_bne:     ; bne \ BNE
0036EEr 3  A9 D0                        lda #$D0
0036F0r 3  4C rr rr                     jmp asm_common
0036F3r 3               z_asm_bne:
0036F3r 3               
0036F3r 3               xt_asm_bpl:     ; bpl \ BPL
0036F3r 3  A9 10                        lda #$10
0036F5r 3  4C rr rr                     jmp asm_common
0036F8r 3               z_asm_bpl:
0036F8r 3               
0036F8r 3               xt_asm_bra:     ; bra \ BRA
0036F8r 3  A9 80                        lda #$80
0036FAr 3  4C rr rr                     jmp asm_common
0036FDr 3               z_asm_bra:
0036FDr 3               
0036FDr 3               xt_asm_brk:     ; brk \ BRK
0036FDr 3  A9 00                        lda #$00
0036FFr 3  4C rr rr                     jmp asm_common
003702r 3               z_asm_brk:
003702r 3               
003702r 3               xt_asm_bvc:     ; bvc \ BVC
003702r 3  A9 50                        lda #$50
003704r 3  4C rr rr                     jmp asm_common
003707r 3               z_asm_bvc:
003707r 3               
003707r 3               xt_asm_bvs:     ; bvs \ BVS
003707r 3  A9 70                        lda #$70
003709r 3  4C rr rr                     jmp asm_common
00370Cr 3               z_asm_bvs:
00370Cr 3               
00370Cr 3               xt_asm_clc:     ; clc \ CLC
00370Cr 3  A9 18                        lda #$18
00370Er 3  4C rr rr                     jmp asm_common
003711r 3               z_asm_clc:
003711r 3               
003711r 3               xt_asm_cld:     ; cld \ CLD
003711r 3  A9 D8                        lda #$D8
003713r 3  4C rr rr                     jmp asm_common
003716r 3               z_asm_cld:
003716r 3               
003716r 3               xt_asm_cli:     ; cli \ CLI
003716r 3  A9 58                        lda #$58
003718r 3  4C rr rr                     jmp asm_common
00371Br 3               z_asm_cli:
00371Br 3               
00371Br 3               xt_asm_clv:     ; clv \ CLV
00371Br 3  A9 B8                        lda #$B8
00371Dr 3  4C rr rr                     jmp asm_common
003720r 3               z_asm_clv:
003720r 3               
003720r 3               xt_asm_cmp:     ; cmp \ CMP nnnn
003720r 3  A9 CD                        lda #$CD
003722r 3  4C rr rr                     jmp asm_common
003725r 3               z_asm_cmp:
003725r 3               
003725r 3               xt_asm_cmp_h:   ; cmp.# \ CMP #nn
003725r 3  A9 C9                        lda #$C9
003727r 3  4C rr rr                     jmp asm_common
00372Ar 3               z_asm_cmp_h:
00372Ar 3               
00372Ar 3               xt_asm_cmp_x:   ; cmp.x \ CMP nnnn,X
00372Ar 3  A9 DD                        lda #$DD
00372Cr 3  4C rr rr                     jmp asm_common
00372Fr 3               z_asm_cmp_x:
00372Fr 3               
00372Fr 3               xt_asm_cmp_y:   ; cmp.y \ CMP nnnn,Y
00372Fr 3  A9 D9                        lda #$D9
003731r 3  4C rr rr                     jmp asm_common
003734r 3               z_asm_cmp_y:
003734r 3               
003734r 3               xt_asm_cmp_z:   ; cmp.z \ CMP nn
003734r 3  A9 C5                        lda #$C5
003736r 3  4C rr rr                     jmp asm_common
003739r 3               z_asm_cmp_z:
003739r 3               
003739r 3               xt_asm_cmp_zi:  ; cmp.zi \ CMP (nn)
003739r 3  A9 D2                        lda #$D2
00373Br 3  4C rr rr                     jmp asm_common
00373Er 3               z_asm_cmp_zi:
00373Er 3               
00373Er 3               xt_asm_cmp_ziy: ; cmp.ziy \ CMP (nn),Y
00373Er 3  A9 D1                        lda #$D1
003740r 3  4C rr rr                     jmp asm_common
003743r 3               z_asm_cmp_ziy:
003743r 3               
003743r 3               xt_asm_cmp_zx:  ; cmp.zx \ CMP nn,X
003743r 3  A9 D5                        lda #$D5
003745r 3  4C rr rr                     jmp asm_common
003748r 3               z_asm_cmp_zx:
003748r 3               
003748r 3               xt_asm_cmp_zxi: ; cmp.zxi \ CMP (nn,X)
003748r 3  A9 C1                        lda #$C1
00374Ar 3  4C rr rr                     jmp asm_common
00374Dr 3               z_asm_cmp_zxi:
00374Dr 3               
00374Dr 3               xt_asm_cpx:     ; cpx \ CPX nnnn
00374Dr 3  A9 EC                        lda #$EC
00374Fr 3  4C rr rr                     jmp asm_common
003752r 3               z_asm_cpx:
003752r 3               
003752r 3               xt_asm_cpx_h:   ; cpx.# \ CPX #nn
003752r 3  A9 E0                        lda #$E0
003754r 3  4C rr rr                     jmp asm_common
003757r 3               z_asm_cpx_h:
003757r 3               
003757r 3               xt_asm_cpx_z:   ; cpx.z \ CPX nn
003757r 3  A9 E4                        lda #$E4
003759r 3  4C rr rr                     jmp asm_common
00375Cr 3               z_asm_cpx_z:
00375Cr 3               
00375Cr 3               xt_asm_cpy:     ; cpy \ CPY
00375Cr 3  A9 CC                        lda #$CC
00375Er 3  A0 03                        ldy #3
003760r 3  4C rr rr                     jmp asm_common
003763r 3               z_asm_cpy:
003763r 3               
003763r 3               xt_asm_cpy_h:   ; cpy.# \ CPY #nn
003763r 3  A9 C0                        lda #$C0
003765r 3  4C rr rr                     jmp asm_common
003768r 3               z_asm_cpy_h:
003768r 3               
003768r 3               xt_asm_cpy_z:   ; cpy.z \ CPY nn
003768r 3  A9 C4                        lda #$C4
00376Ar 3  4C rr rr                     jmp asm_common
00376Dr 3               z_asm_cpy_z:
00376Dr 3               
00376Dr 3               xt_asm_dec:     ; dec \ DEC nnnn
00376Dr 3  A9 CE                        lda #$CE
00376Fr 3  4C rr rr                     jmp asm_common
003772r 3               z_asm_dec:
003772r 3               
003772r 3               xt_asm_dec_a:   ; dec.a \ DEC
003772r 3  A9 3A                        lda #$3A
003774r 3  4C rr rr                     jmp asm_common
003777r 3               z_asm_dec_a:
003777r 3               
003777r 3               xt_asm_dec_x:   ; dec.x \ DEC nnnn,X
003777r 3  A9 DE                        lda #$DE
003779r 3  4C rr rr                     jmp asm_common
00377Cr 3               z_asm_dec_x:
00377Cr 3               
00377Cr 3               xt_asm_dec_z:   ; dec.z \ DEC nn
00377Cr 3  A9 C6                        lda #$C6
00377Er 3  4C rr rr                     jmp asm_common
003781r 3               z_asm_dec_z:
003781r 3               
003781r 3               xt_asm_dec_zx:  ; dec.zx \ DEC nn,X
003781r 3  A9 D6                        lda #$D6
003783r 3  4C rr rr                     jmp asm_common
003786r 3               z_asm_dec_zx:
003786r 3               
003786r 3               xt_asm_dex:     ; dex \ DEX
003786r 3  A9 CA                        lda #$CA
003788r 3  4C rr rr                     jmp asm_common
00378Br 3               z_asm_dex:
00378Br 3               
00378Br 3               xt_asm_dey:     ; dey \ DEY
00378Br 3  A9 88                        lda #$88
00378Dr 3  4C rr rr                     jmp asm_common
003790r 3               z_asm_dey:
003790r 3               
003790r 3               xt_asm_eor:     ; eor \ EOR nnnn
003790r 3  A9 4D                        lda #$4D
003792r 3  4C rr rr                     jmp asm_common
003795r 3               z_asm_eor:
003795r 3               
003795r 3               xt_asm_eor_h:   ; eor.# \ EOR #nn
003795r 3  A9 49                        lda #$49
003797r 3  4C rr rr                     jmp asm_common
00379Ar 3               z_asm_eor_h:
00379Ar 3               
00379Ar 3               xt_asm_eor_x:   ; eor.x \ EOR nnnn,X
00379Ar 3  A9 5D                        lda #$5D
00379Cr 3  4C rr rr                     jmp asm_common
00379Fr 3               z_asm_eor_x:
00379Fr 3               
00379Fr 3               xt_asm_eor_y:   ; eor.y \ EOR nnnn,Y
00379Fr 3  A9 59                        lda #$59
0037A1r 3  4C rr rr                     jmp asm_common
0037A4r 3               z_asm_eor_y:
0037A4r 3               
0037A4r 3               xt_asm_eor_z:   ; eor.z \ EOR nn
0037A4r 3  A9 45                        lda #$45
0037A6r 3  4C rr rr                     jmp asm_common
0037A9r 3               z_asm_eor_z:
0037A9r 3               
0037A9r 3               xt_asm_eor_zi:  ; eor.zi \ EOR (nn)
0037A9r 3  A9 52                        lda #$52
0037ABr 3  4C rr rr                     jmp asm_common
0037AEr 3               z_asm_eor_zi:
0037AEr 3               
0037AEr 3               xt_asm_eor_ziy: ; eor.ziy \ EOR (nn),Y
0037AEr 3  A9 51                        lda #$51
0037B0r 3  4C rr rr                     jmp asm_common
0037B3r 3               z_asm_eor_ziy:
0037B3r 3               
0037B3r 3               xt_asm_eor_zx:  ; eor.zx \ EOR nn,X
0037B3r 3  A9 55                        lda #$55
0037B5r 3  4C rr rr                     jmp asm_common
0037B8r 3               z_asm_eor_zx:
0037B8r 3               
0037B8r 3               xt_asm_eor_zxi: ; eor.zxi \ EOR (nn,X)
0037B8r 3  A9 41                        lda #$41
0037BAr 3  4C rr rr                     jmp asm_common
0037BDr 3               z_asm_eor_zxi:
0037BDr 3               
0037BDr 3               xt_asm_inc:     ; inc \ INC nnnn
0037BDr 3  A9 EE                        lda #$EE
0037BFr 3  4C rr rr                     jmp asm_common
0037C2r 3               z_asm_inc:
0037C2r 3               
0037C2r 3               xt_asm_inc_a:   ; inc.a \ INC
0037C2r 3  A9 1A                        lda #$1A
0037C4r 3  4C rr rr                     jmp asm_common
0037C7r 3               z_asm_inc_a:
0037C7r 3               
0037C7r 3               xt_asm_inc_x:   ; inc.x \ INC nnnn,X
0037C7r 3  A9 FE                        lda #$FE
0037C9r 3  4C rr rr                     jmp asm_common
0037CCr 3               z_asm_inc_x:
0037CCr 3               
0037CCr 3               xt_asm_inc_z:   ; inc.z \ INC nn
0037CCr 3  A9 E6                        lda #$E6
0037CEr 3  4C rr rr                     jmp asm_common
0037D1r 3               z_asm_inc_z:
0037D1r 3               
0037D1r 3               xt_asm_inc_zx:  ; inc.zx \ INC nn,X
0037D1r 3  A9 F6                        lda #$F6
0037D3r 3  4C rr rr                     jmp asm_common
0037D6r 3               z_asm_inc_zx:
0037D6r 3               
0037D6r 3               xt_asm_inx:     ; inx \ INX
0037D6r 3  A9 E8                        lda #$E8
0037D8r 3  4C rr rr                     jmp asm_common
0037DBr 3               z_asm_inx:
0037DBr 3               
0037DBr 3               xt_asm_iny:     ; iny \ INY
0037DBr 3  A9 C8                        lda #$C8
0037DDr 3  4C rr rr                     jmp asm_common
0037E0r 3               z_asm_iny:
0037E0r 3               
0037E0r 3               xt_asm_jmp:     ; jmp \ JMP nnnn
0037E0r 3  A9 4C                        lda #$4C
0037E2r 3  4C rr rr                     jmp asm_common
0037E5r 3               z_asm_jmp:
0037E5r 3               
0037E5r 3               xt_asm_jmp_i:   ; jmp.i \ JMP (nnnn)
0037E5r 3  A9 6C                        lda #$6C
0037E7r 3  4C rr rr                     jmp asm_common
0037EAr 3               z_asm_jmp_i:
0037EAr 3               
0037EAr 3               xt_asm_jmp_xi:  ; jmp.xi \ JMP (nnnn,X)
0037EAr 3  A9 7C                        lda #$7C
0037ECr 3  4C rr rr                     jmp asm_common
0037EFr 3               z_asm_jmp_xi:
0037EFr 3               
0037EFr 3               xt_asm_jsr:     ; jsr \ JSR nnnn
0037EFr 3  A9 20                        lda #$20
0037F1r 3  4C rr rr                     jmp asm_common
0037F4r 3               z_asm_jsr:
0037F4r 3               
0037F4r 3               xt_asm_lda:     ; lda \ LDA nnnn
0037F4r 3  A9 AD                        lda #$AD
0037F6r 3  4C rr rr                     jmp asm_common
0037F9r 3               z_asm_lda:
0037F9r 3               
0037F9r 3               xt_asm_lda_h:   ; lda.# \ LDA #nn
0037F9r 3  A9 A9                        lda #$A9
0037FBr 3  4C rr rr                     jmp asm_common
0037FEr 3               z_asm_lda_h:
0037FEr 3               
0037FEr 3               xt_asm_lda_x:   ; lda.x \ LDA nnnn,X
0037FEr 3  A9 BD                        lda #$BD
003800r 3  4C rr rr                     jmp asm_common
003803r 3               z_asm_lda_x:
003803r 3               
003803r 3               xt_asm_lda_y:   ; lda.y \ LDA nnnn,Y
003803r 3  A9 B9                        lda #$B9
003805r 3  4C rr rr                     jmp asm_common
003808r 3               z_asm_lda_y:
003808r 3               
003808r 3               xt_asm_lda_z:   ; lda.z \ LDA nn
003808r 3  A9 A5                        lda #$A5
00380Ar 3  4C rr rr                     jmp asm_common
00380Dr 3               z_asm_lda_z:
00380Dr 3               
00380Dr 3               xt_asm_lda_zi:  ; lda.zi \ LDA (nn)
00380Dr 3  A9 B2                        lda #$B2
00380Fr 3  4C rr rr                     jmp asm_common
003812r 3               z_asm_lda_zi:
003812r 3               
003812r 3               xt_asm_lda_ziy: ; lda.ziy \ LDA (nn),Y
003812r 3  A9 B1                        lda #$B1
003814r 3  4C rr rr                     jmp asm_common
003817r 3               z_asm_lda_ziy:
003817r 3               
003817r 3               xt_asm_lda_zx:  ; lda.zx \ LDA nn,X
003817r 3  A9 B5                        lda #$B5
003819r 3  4C rr rr                     jmp asm_common
00381Cr 3               z_asm_lda_zx:
00381Cr 3               
00381Cr 3               xt_asm_lda_zxi: ; lda.zxi \ LDA (nn,X)
00381Cr 3  A9 A1                        lda #$A1
00381Er 3  4C rr rr                     jmp asm_common
003821r 3               z_asm_lda_zxi:
003821r 3               
003821r 3               xt_asm_ldx:     ; ldx \ LDX nnnn
003821r 3  A9 AE                        lda #$AE
003823r 3  4C rr rr                     jmp asm_common
003826r 3               z_asm_ldx:
003826r 3               
003826r 3               xt_asm_ldx_h:   ; ldx.# \ LDX #nn
003826r 3  A9 A2                        lda #$A2
003828r 3  4C rr rr                     jmp asm_common
00382Br 3               z_asm_ldx_h:
00382Br 3               
00382Br 3               xt_asm_ldx_y:   ; ldx.y \ LDX nnnn,Y
00382Br 3  A9 BE                        lda #$BE
00382Dr 3  4C rr rr                     jmp asm_common
003830r 3               z_asm_ldx_y:
003830r 3               
003830r 3               xt_asm_ldx_z:   ; ldx.z \ LDX nn
003830r 3  A9 A6                        lda #$A6
003832r 3  4C rr rr                     jmp asm_common
003835r 3               z_asm_ldx_z:
003835r 3               
003835r 3               xt_asm_ldx_zy:  ; ldx.zy \ LDX nn,Y
003835r 3  A9 B6                        lda #$B6
003837r 3  4C rr rr                     jmp asm_common
00383Ar 3               z_asm_ldx_zy:
00383Ar 3               
00383Ar 3               xt_asm_ldy:     ; ldy \ LDY nnnn
00383Ar 3  A9 AC                        lda #$AC
00383Cr 3  4C rr rr                     jmp asm_common
00383Fr 3               z_asm_ldy:
00383Fr 3               
00383Fr 3               xt_asm_ldy_h:   ; ldy.# \ LDY #nn
00383Fr 3  A9 A0                        lda #$A0
003841r 3  4C rr rr                     jmp asm_common
003844r 3               z_asm_ldy_h:
003844r 3               
003844r 3               xt_asm_ldy_x:   ; ldy.x \ LDY nnnn,X
003844r 3  A9 BC                        lda #$BC
003846r 3  4C rr rr                     jmp asm_common
003849r 3               z_asm_ldy_x:
003849r 3               
003849r 3               xt_asm_ldy_z:   ; ldy.z \ LDY nn
003849r 3  A9 A4                        lda #$A4
00384Br 3  4C rr rr                     jmp asm_common
00384Er 3               z_asm_ldy_z:
00384Er 3               
00384Er 3               xt_asm_ldy_zx:  ; ldy.zx \ LDY nn,X
00384Er 3  A9 B4                        lda #$B4
003850r 3  4C rr rr                     jmp asm_common
003853r 3               z_asm_ldy_zx:
003853r 3               
003853r 3               xt_asm_lsr:     ; lsr \ LSR nnnn
003853r 3  A9 4E                        lda #$4E
003855r 3  4C rr rr                     jmp asm_common
003858r 3               z_asm_lsr:
003858r 3               
003858r 3               xt_asm_lsr_a:   ; lsr.a \ LSR
003858r 3  A9 4A                        lda #$4A
00385Ar 3  4C rr rr                     jmp asm_common
00385Dr 3               z_asm_lsr_a:
00385Dr 3               
00385Dr 3               xt_asm_lsr_x:   ; lsr.x \ LSR nnnn,X
00385Dr 3  A9 5E                        lda #$5E
00385Fr 3  4C rr rr                     jmp asm_common
003862r 3               z_asm_lsr_x:
003862r 3               
003862r 3               xt_asm_lsr_z:   ; lsr.z \ LSR nn
003862r 3  A9 46                        lda #$46
003864r 3  4C rr rr                     jmp asm_common
003867r 3               z_asm_lsr_z:
003867r 3               
003867r 3               xt_asm_lsr_zx:  ; lsr.zx \ LSR nn,X
003867r 3  A9 56                        lda #$56
003869r 3  4C rr rr                     jmp asm_common
00386Cr 3               z_asm_lsr_zx:
00386Cr 3               
00386Cr 3               xt_asm_nop:     ; nop \ NOP
00386Cr 3  A9 EA                        lda #$EA
00386Er 3  4C rr rr                     jmp asm_common
003871r 3               z_asm_nop:
003871r 3               
003871r 3               xt_asm_ora:     ; ora \ ORA nnnn
003871r 3  A9 0D                        lda #$0D
003873r 3  4C rr rr                     jmp asm_common
003876r 3               z_asm_ora:
003876r 3               
003876r 3               xt_asm_ora_h:   ; ora.# \ ORA #nn
003876r 3  A9 09                        lda #$09
003878r 3  4C rr rr                     jmp asm_common
00387Br 3               z_asm_ora_h:
00387Br 3               
00387Br 3               xt_asm_ora_x:   ; ora.x \ ORA nnnn,X
00387Br 3  A9 1D                        lda #$1D
00387Dr 3  4C rr rr                     jmp asm_common
003880r 3               z_asm_ora_x:
003880r 3               
003880r 3               xt_asm_ora_y:   ; ora.y \ ORA nnnn,Y
003880r 3  A9 19                        lda #$19
003882r 3  4C rr rr                     jmp asm_common
003885r 3               z_asm_ora_y:
003885r 3               
003885r 3               xt_asm_ora_z:   ; ora.z \ ORA nn
003885r 3  A9 05                        lda #$05
003887r 3  4C rr rr                     jmp asm_common
00388Ar 3               z_asm_ora_z:
00388Ar 3               
00388Ar 3               xt_asm_ora_zi:  ; ora.zi \ ORA.ZI
00388Ar 3  A9 12                        lda #$12
00388Cr 3  A0 02                        ldy #2
00388Er 3  4C rr rr                     jmp asm_common
003891r 3               z_asm_ora_zi:
003891r 3               
003891r 3               xt_asm_ora_ziy: ; ora.ziy \ ORA (nn),Y
003891r 3  A9 11                        lda #$11
003893r 3  4C rr rr                     jmp asm_common
003896r 3               z_asm_ora_ziy:
003896r 3               
003896r 3               xt_asm_ora_zx:  ; ora.zx \ ORA nn,X
003896r 3  A9 15                        lda #$15
003898r 3  4C rr rr                     jmp asm_common
00389Br 3               z_asm_ora_zx:
00389Br 3               
00389Br 3               xt_asm_ora_zxi: ; ora.zxi \ ORA (nn,X)
00389Br 3  A9 01                        lda #$01
00389Dr 3  4C rr rr                     jmp asm_common
0038A0r 3               z_asm_ora_zxi:
0038A0r 3               
0038A0r 3               xt_asm_pha:     ; pha \ PHA
0038A0r 3  A9 48                        lda #$48
0038A2r 3  4C rr rr                     jmp asm_common
0038A5r 3               z_asm_pha:
0038A5r 3               
0038A5r 3               xt_asm_php:     ; php \ PHP
0038A5r 3  A9 08                        lda #$08
0038A7r 3  4C rr rr                     jmp asm_common
0038AAr 3               z_asm_php:
0038AAr 3               
0038AAr 3               xt_asm_phx:     ; phx \ PHX
0038AAr 3  A9 DA                        lda #$DA
0038ACr 3  4C rr rr                     jmp asm_common
0038AFr 3               z_asm_phx:
0038AFr 3               
0038AFr 3               xt_asm_phy:     ; phy \ PHY
0038AFr 3  A9 5A                        lda #$5A
0038B1r 3  4C rr rr                     jmp asm_common
0038B4r 3               z_asm_phy:
0038B4r 3               
0038B4r 3               xt_asm_pla:     ; pla \ PLA
0038B4r 3  A9 68                        lda #$68
0038B6r 3  4C rr rr                     jmp asm_common
0038B9r 3               z_asm_pla:
0038B9r 3               
0038B9r 3               xt_asm_plp:     ; plp \ PLP
0038B9r 3  A9 28                        lda #$28
0038BBr 3  4C rr rr                     jmp asm_common
0038BEr 3               z_asm_plp:
0038BEr 3               
0038BEr 3               xt_asm_plx:     ; plx \ PLX
0038BEr 3  A9 FA                        lda #$FA
0038C0r 3  4C rr rr                     jmp asm_common
0038C3r 3               z_asm_plx:
0038C3r 3               
0038C3r 3               xt_asm_ply:     ; ply \ PLY
0038C3r 3  A9 7A                        lda #$7A
0038C5r 3  4C rr rr                     jmp asm_common
0038C8r 3               z_asm_ply:
0038C8r 3               
0038C8r 3               xt_asm_rol:     ; rol \ ROL nnnn
0038C8r 3  A9 2E                        lda #$2E
0038CAr 3  4C rr rr                     jmp asm_common
0038CDr 3               z_asm_rol:
0038CDr 3               
0038CDr 3               xt_asm_rol_a:   ; rol.a \ ROL
0038CDr 3  A9 2A                        lda #$2A
0038CFr 3  4C rr rr                     jmp asm_common
0038D2r 3               z_asm_rol_a:
0038D2r 3               
0038D2r 3               xt_asm_rol_x:   ; rol.x \ ROL nnnn,X
0038D2r 3  A9 3E                        lda #$3E
0038D4r 3  4C rr rr                     jmp asm_common
0038D7r 3               z_asm_rol_x:
0038D7r 3               
0038D7r 3               xt_asm_rol_z:   ; rol.z \ ROL nn
0038D7r 3  A9 26                        lda #$26
0038D9r 3  4C rr rr                     jmp asm_common
0038DCr 3               z_asm_rol_z:
0038DCr 3               
0038DCr 3               xt_asm_rol_zx:  ; rol.zx \ ROL nn,X
0038DCr 3  A9 36                        lda #$36
0038DEr 3  4C rr rr                     jmp asm_common
0038E1r 3               z_asm_rol_zx:
0038E1r 3               
0038E1r 3               xt_asm_ror:     ; ror \ ROR nnnn
0038E1r 3  A9 6E                        lda #$6E
0038E3r 3  4C rr rr                     jmp asm_common
0038E6r 3               z_asm_ror:
0038E6r 3               
0038E6r 3               xt_asm_ror_a:   ; ror.a \ ROR
0038E6r 3  A9 6A                        lda #$6A
0038E8r 3  4C rr rr                     jmp asm_common
0038EBr 3               z_asm_ror_a:
0038EBr 3               
0038EBr 3               xt_asm_ror_x:   ; ror.x \ ROR nnnn,X
0038EBr 3  A9 7E                        lda #$7E
0038EDr 3  4C rr rr                     jmp asm_common
0038F0r 3               z_asm_ror_x:
0038F0r 3               
0038F0r 3               xt_asm_ror_z:   ; ror.z \ ROR nn
0038F0r 3  A9 66                        lda #$66
0038F2r 3  4C rr rr                     jmp asm_common
0038F5r 3               z_asm_ror_z:
0038F5r 3               
0038F5r 3               xt_asm_ror_zx:  ; ror.zx \ ROR nn,X
0038F5r 3  A9 76                        lda #$76
0038F7r 3  4C rr rr                     jmp asm_common
0038FAr 3               z_asm_ror_zx:
0038FAr 3               
0038FAr 3               xt_asm_rti:     ; rti \ RTI
0038FAr 3  A9 40                        lda #$40
0038FCr 3  4C rr rr                     jmp asm_common
0038FFr 3               z_asm_rti:
0038FFr 3               
0038FFr 3               xt_asm_rts:     ; rts \ RTS
0038FFr 3  A9 60                        lda #$60
003901r 3  4C rr rr                     jmp asm_common
003904r 3               z_asm_rts:
003904r 3               
003904r 3               xt_asm_sbc:     ; sbc \ SBC nnnn
003904r 3  A9 ED                        lda #$ED
003906r 3  4C rr rr                     jmp asm_common
003909r 3               z_asm_sbc:
003909r 3               
003909r 3               xt_asm_sbc_h:   ; sbc.# \ SBC #nn
003909r 3  A9 E9                        lda #$E9
00390Br 3  4C rr rr                     jmp asm_common
00390Er 3               z_asm_sbc_h:
00390Er 3               
00390Er 3               xt_asm_sbc_x:   ; sbc.x \ SBC nnnn,X
00390Er 3  A9 FD                        lda #$FD
003910r 3  4C rr rr                     jmp asm_common
003913r 3               z_asm_sbc_x:
003913r 3               
003913r 3               xt_asm_sbc_y:   ; sbc.y \ SBC nnnn,Y
003913r 3  A9 F9                        lda #$F9
003915r 3  4C rr rr                     jmp asm_common
003918r 3               z_asm_sbc_y:
003918r 3               
003918r 3               xt_asm_sbc_z:   ; sbc.z \ SBC nn
003918r 3  A9 E5                        lda #$E5
00391Ar 3  4C rr rr                     jmp asm_common
00391Dr 3               z_asm_sbc_z:
00391Dr 3               
00391Dr 3               xt_asm_sbc_zi:  ; sbc.zi \ SBC (nn)
00391Dr 3  A9 F2                        lda #$F2
00391Fr 3  4C rr rr                     jmp asm_common
003922r 3               z_asm_sbc_zi:
003922r 3               
003922r 3               xt_asm_sbc_ziy: ; sbc.ziy \ SBC (nn),Y
003922r 3  A9 F1                        lda #$F1
003924r 3  4C rr rr                     jmp asm_common
003927r 3               z_asm_sbc_ziy:
003927r 3               
003927r 3               xt_asm_sbc_zx:  ; sbc.zx \ SBC nn,X
003927r 3  A9 F5                        lda #$F5
003929r 3  4C rr rr                     jmp asm_common
00392Cr 3               z_asm_sbc_zx:
00392Cr 3               
00392Cr 3               xt_asm_sbc_zxi: ; sbc.zxi \ SBC (nn,X)
00392Cr 3  A9 E1                        lda #$E1
00392Er 3  80 7C                        bra asm_common  ; <-- limit for BRA instead of JMP
003930r 3               z_asm_sbc_zxi:
003930r 3               
003930r 3               xt_asm_sec:     ; sec \ SEC
003930r 3  A9 38                        lda #$38
003932r 3  80 78                        bra asm_common
003934r 3               z_asm_sec:
003934r 3               
003934r 3               xt_asm_sed:     ; sed \ SED
003934r 3  A9 F8                        lda #$F8
003936r 3  80 74                        bra asm_common
003938r 3               z_asm_sed:
003938r 3               
003938r 3               xt_asm_sei:     ; sei \ SEI
003938r 3  A9 78                        lda #$78
00393Ar 3  80 70                        bra asm_common
00393Cr 3               z_asm_sei:
00393Cr 3               
00393Cr 3               xt_asm_sta:     ; sta \ STA nnnn
00393Cr 3  A9 8D                        lda #$8D
00393Er 3  80 6C                        bra asm_common
003940r 3               z_asm_sta:
003940r 3               
003940r 3               xt_asm_sta_x:   ; sta.x \ STA nnnn,X
003940r 3  A9 9D                        lda #$9D
003942r 3  80 68                        bra asm_common
003944r 3               z_asm_sta_x:
003944r 3               
003944r 3               xt_asm_sta_y:   ; sta.y \ STA nnnn,Y
003944r 3  A9 99                        lda #$99
003946r 3  80 64                        bra asm_common
003948r 3               z_asm_sta_y:
003948r 3               
003948r 3               xt_asm_sta_z:   ; sta.z \ STA nn
003948r 3  A9 85                        lda #$85
00394Ar 3  80 60                        bra asm_common
00394Cr 3               z_asm_sta_z:
00394Cr 3               
00394Cr 3               xt_asm_sta_zi:  ; sta.zi \ STA (nn)
00394Cr 3  A9 92                        lda #$92
00394Er 3  80 5C                        bra asm_common
003950r 3               z_asm_sta_zi:
003950r 3               
003950r 3               xt_asm_sta_ziy: ; sta.ziy \ STA (nn),Y
003950r 3  A9 91                        lda #$91
003952r 3  80 58                        bra asm_common
003954r 3               z_asm_sta_ziy:
003954r 3               
003954r 3               xt_asm_sta_zx:  ; sta.zx \ STA nn,X
003954r 3  A9 95                        lda #$95
003956r 3  80 54                        bra asm_common
003958r 3               z_asm_sta_zx:
003958r 3               
003958r 3               xt_asm_sta_zxi: ; sta.zxi \ STA (nn,X)
003958r 3  A9 81                        lda #$81
00395Ar 3  80 50                        bra asm_common
00395Cr 3               z_asm_sta_zxi:
00395Cr 3               
00395Cr 3               xt_asm_stx:     ; stx \ STX nnnn
00395Cr 3  A9 8E                        lda #$8E
00395Er 3  80 4C                        bra asm_common
003960r 3               z_asm_stx:
003960r 3               
003960r 3               xt_asm_stx_z:   ; stx.z \ STX nn
003960r 3  A9 86                        lda #$86
003962r 3  80 48                        bra asm_common
003964r 3               z_asm_stx_z:
003964r 3               
003964r 3               xt_asm_stx_zy:  ; stx.zy \ STX nn,Y
003964r 3  A9 96                        lda #$96
003966r 3  80 44                        bra asm_common
003968r 3               z_asm_stx_zy:
003968r 3               
003968r 3               xt_asm_sty:     ; sty \ STY nnnn
003968r 3  A9 8C                        lda #$8C
00396Ar 3  80 40                        bra asm_common
00396Cr 3               z_asm_sty:
00396Cr 3               
00396Cr 3               xt_asm_sty_z:   ; sty.z \ STY nn
00396Cr 3  A9 84                        lda #$84
00396Er 3  80 3C                        bra asm_common
003970r 3               z_asm_sty_z:
003970r 3               
003970r 3               xt_asm_sty_zx:  ; sty.zx \ STY nn,X
003970r 3  A9 94                        lda #$94
003972r 3  80 38                        bra asm_common
003974r 3               z_asm_sty_zx:
003974r 3               
003974r 3               xt_asm_stz:     ; stz \ STZ nnnn
003974r 3  A9 9C                        lda #$9C
003976r 3  80 34                        bra asm_common
003978r 3               z_asm_stz:
003978r 3               
003978r 3               xt_asm_stz_x:   ; stz.x \ STZ nnnn,X
003978r 3  A9 9E                        lda #$9E
00397Ar 3  80 30                        bra asm_common
00397Cr 3               z_asm_stz_x:
00397Cr 3               
00397Cr 3               xt_asm_stz_z:   ; stz.z \ STZ nn
00397Cr 3  A9 64                        lda #$64
00397Er 3  80 2C                        bra asm_common
003980r 3               z_asm_stz_z:
003980r 3               
003980r 3               xt_asm_stz_zx:  ; stz.zx \ STZ nn,X
003980r 3  A9 74                        lda #$74
003982r 3  80 28                        bra asm_common
003984r 3               z_asm_stz_zx:
003984r 3               
003984r 3               xt_asm_tax:     ; tax \ TAX
003984r 3  A9 AA                        lda #$AA
003986r 3  80 24                        bra asm_common
003988r 3               z_asm_tax:
003988r 3               
003988r 3               xt_asm_tay:     ; tay \ TAY
003988r 3  A9 A8                        lda #$A8
00398Ar 3  80 20                        bra asm_common
00398Cr 3               z_asm_tay:
00398Cr 3               
00398Cr 3               xt_asm_trb:     ; trb \ TRB nnnn
00398Cr 3  A9 1C                        lda #$1C
00398Er 3  80 1C                        bra asm_common
003990r 3               z_asm_trb:
003990r 3               
003990r 3               xt_asm_trb_z:   ; trb.z \ TRB nn
003990r 3  A9 14                        lda #$14
003992r 3  80 18                        bra asm_common
003994r 3               z_asm_trb_z:
003994r 3               
003994r 3               xt_asm_tsb:     ; tsb \ TSB nnnn
003994r 3  A9 0C                        lda #$0C
003996r 3  80 14                        bra asm_common
003998r 3               z_asm_tsb:
003998r 3               
003998r 3               xt_asm_tsb_z:   ; tsb.z \ TSB nn
003998r 3  A9 04                        lda #$04
00399Ar 3  80 10                        bra asm_common
00399Cr 3               z_asm_tsb_z:
00399Cr 3               
00399Cr 3               xt_asm_tsx:     ; tsx \ TSX
00399Cr 3  A9 BA                        lda #$BA
00399Er 3  80 0C                        bra asm_common
0039A0r 3               z_asm_tsx:
0039A0r 3               
0039A0r 3               xt_asm_txa:     ; txa \ TXA
0039A0r 3  A9 8A                        lda #$8A
0039A2r 3  80 08                        bra asm_common
0039A4r 3               z_asm_txa:
0039A4r 3               
0039A4r 3               xt_asm_txs:     ; txs \ TXS
0039A4r 3  A9 9A                        lda #$9A
0039A6r 3  80 04                        bra asm_common
0039A8r 3               z_asm_txs:
0039A8r 3               
0039A8r 3               xt_asm_tya:     ; tya \ TYA
0039A8r 3  A9 98                        lda #$98
0039AAr 3  80 00                        bra asm_common
0039ACr 3               z_asm_tya:
0039ACr 3               
0039ACr 3               
0039ACr 3               ; ==========================================================
0039ACr 3               ; ASSEMBLER HELPER FUNCTIONS
0039ACr 3               
0039ACr 3               asm_common:
0039ACr 3               
0039ACr 3               
0039ACr 3                       ; """Common routine for all opcodes. We arrive here with the opcode in
0039ACr 3                       ; A. We do not need to check for the correct values because we are
0039ACr 3                       ; coming from the assembler Dictionary and trust our external test
0039ACr 3                       ; suite.
0039ACr 3                       ; """
0039ACr 3                               ; Compile opcode. Note cmpl_a does not use Y
0039ACr 3  A8                           tay
0039ADr 3  20 rr rr                     jsr cmpl_a
0039B0r 3               
0039B0r 3                               ; We get the length of the opcode from the table included in
0039B0r 3                               ; the disassembler. We use the opcode value as the offset in
0039B0r 3                               ; the oc_index_table. We have 256 entries, each two bytes
0039B0r 3                               ; long, so we can't just use an index with Y. We use tmp2 for
0039B0r 3                               ; this.
0039B0r 3  A9 rr                        lda #<oc_index_table
0039B2r 3  85 26                        sta tmp2
0039B4r 3  A9 rr                        lda #>oc_index_table
0039B6r 3  85 27                        sta tmp2+1
0039B8r 3               
0039B8r 3  98                           tya             ; retrieve opcode
0039B9r 3  0A                           asl             ; times two for offset
0039BAr 3  90 02                        bcc @1
0039BCr 3  E6 27                        inc tmp2+1
0039BEr 3               @1:
0039BEr 3  A8                           tay             ; use Y as the index
0039BFr 3               
0039BFr 3                               ; Get address of the entry in the opcode table. We put it in
0039BFr 3                               ; tmp3 and push a copy of it to the stack to be able to print
0039BFr 3                               ; the opcode later
0039BFr 3  B1 26                        lda (tmp2),y    ; LSB
0039C1r 3  85 28                        sta tmp3
0039C3r 3  C8                           iny
0039C4r 3  B1 26                        lda (tmp2),y    ; MSB
0039C6r 3  85 29                        sta tmp3+1
0039C8r 3               
0039C8r 3  B2 28                        lda (tmp3)      ; get "lengths byte"
0039CAr 3               
0039CAr 3                               ; The length of the instruction is stored in bits 7 and 6.
0039CAr 3                               ; Rotate them through the carry flag and mask the rest
0039CAr 3  2A                           rol
0039CBr 3  2A                           rol
0039CCr 3  2A                           rol             ; Three times because we go through Carry
0039CDr 3  29 03                        and #%00000011
0039CFr 3  A8                           tay
0039D0r 3               
0039D0r 3                               ; One byte means no operand, we're done. Use DEY as CPY #1
0039D0r 3  88                           dey
0039D1r 3  F0 12                        beq @done
0039D3r 3               
0039D3r 3                               ; We have an operand which must be TOS
0039D3r 3  20 rr rr                     jsr underflow_1
0039D6r 3               
0039D6r 3                               ; We compile the LSB of TOS as the operand we definitely have
0039D6r 3                               ; before we even test if this is a two- or three-byte
0039D6r 3                               ; instruction. Little endian CPU means we store this byte first
0039D6r 3  B5 00                        lda 0,x
0039D8r 3  20 rr rr                     jsr cmpl_a      ; does not use Y
0039DBr 3               
0039DBr 3                               ; If this is a two-byte instruction, we're done. If we landed
0039DBr 3                               ; here, we've already decremented Y by one, so this is
0039DBr 3                               ; the equivalent to CPY #2
0039DBr 3  88                           dey
0039DCr 3  F0 05                        beq @done_drop
0039DEr 3               
0039DEr 3                               ; This must be a three-byte instruction, get the MSB.
0039DEr 3  B5 01                        lda 1,x
0039E0r 3  20 rr rr                     jsr cmpl_a      ; Fall through to @done_drop
0039E3r 3               
0039E3r 3               @done_drop:
0039E3r 3  E8                           inx
0039E4r 3  E8                           inx             ; Fall through to @done
0039E5r 3               @done:
0039E5r 3  60                           rts             ; Returns to original caller
0039E6r 3               
0039E6r 3               
0039E6r 3               
0039E6r 3               ; ==========================================================
0039E6r 3               ; PSEUDO-INSTRUCTIONS AND MACROS
0039E6r 3               
0039E6r 3               xt_asm_push_a:
0039E6r 3                       ; """push-a puts the content of the 65c02 Accumulator on the Forth
0039E6r 3                       ; data stack as the TOS. This is a convience routine that encodes the
0039E6r 3                       ; instructions  DEX  DEX  STA 0,X  STZ 1,X
0039E6r 3                       ; """
0039E6r 3               
0039E6r 3  A0 00                        ldy #0
0039E8r 3               @loop:
0039E8r 3  B9 rr rr                     lda _data,y
0039EBr 3  C9 FF                        cmp #$FF
0039EDr 3  F0 06                        beq @done
0039EFr 3               
0039EFr 3  20 rr rr                     jsr cmpl_a      ; does not change Y
0039F2r 3  C8                           iny
0039F3r 3  80 F3                        bra @loop
0039F5r 3               @done:
0039F5r 3               z_asm_push_a:
0039F5r 3  60                           rts
0039F6r 3               _data:
0039F6r 3                       ; We can't use 00 as a terminator because STA 0,X assembles to 95 00
0039F6r 3  CA CA 95 00          .byte $CA, $CA, $95, 00, $74, $01
0039FAr 3  74 01        
0039FCr 3  FF                   .byte $FF               ; terminator
0039FDr 3               
0039FDr 3               
0039FDr 3               
0039FDr 3               ; ==========================================================
0039FDr 3               ; DIRECTIVES
0039FDr 3               
0039FDr 3               ; The "<J" directive (back jump) is a dummy instruction (syntactic sugar) to
0039FDr 3               ; make clear that the JMP or JSR instructions are using the address that had
0039FDr 3               ; been placed on the stack by "-->" (the "arrow" directive).
0039FDr 3               xt_asm_back_jump:
0039FDr 3               z_asm_back_jump:
0039FDr 3  60                           rts
0039FEr 3               
0039FEr 3               ; The "<B" directive (back branch) takes an address that was placed on the Data
0039FEr 3               ; Stack by the anonymous label directive "-->" (the "arrow") and the current
0039FEr 3               ; address (via HERE) to calculate a backward branch offset. This is then stored
0039FEr 3               ; by a following branch instruction.
0039FEr 3               xt_asm_back_branch:
0039FEr 3                               ; We arrive here with ( addr-l ) of the label on the stack and
0039FEr 3                               ; then subtract the current address
0039FEr 3  20 rr rr                     jsr xt_here             ; ( addr-l addr-h )
003A01r 3  20 rr rr                     jsr xt_minus            ; ( offset )
003A04r 3               
003A04r 3                               ; We subtract two more because of the branch instruction itself
003A04r 3  3A                           dec
003A05r 3  3A                           dec
003A06r 3               
003A06r 3               z_asm_back_branch:
003A06r 3  60                           rts
003A07r 3               
003A07r 3               assembler_end:
003A07r 3               
003A07r 3               ; END
003A07r 3               
003A07r 2               .include "disassembler.asm"     ; SAN disassembler
003A07r 3               ; Disassembler for Tali Forth 2
003A07r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
003A07r 3               ; First version: 28. Apr 2018
003A07r 3               ; This version: 03. Jan 2019
003A07r 3               
003A07r 3               ; This is the default disassembler for Tali Forth 2. Use by passing
003A07r 3               ; the address and length of the block of memory to be disassembled:
003A07r 3               ;
003A07r 3               ;       disasm ( addr x -- )
003A07r 3               
003A07r 3               ; The underflow checking is handled by the word's stub in native_words.asm, see
003A07r 3               ; there for more information.
003A07r 3               
003A07r 3               ; The code is disassembled in Simpler Assembler Notation (SAN), because that
003A07r 3               ; is, uh, simpler. See the documentation and https://github.com/scotws/SAN for
003A07r 3               ; more information. Because disassemblers are used interactively with slow
003A07r 3               ; humans, we don't care that much about speed and put the emphasis at being
003A07r 3               ; small.
003A07r 3               
003A07r 3               
003A07r 3               disassembler:
003A07r 3  20 rr rr                     jsr xt_cr       ; ( addr u )
003A0Ar 3               _byte_loop:
003A0Ar 3                               ; Print address at start of the line. Note we use whatever
003A0Ar 3                               ; number base the user has
003A0Ar 3  20 rr rr                     jsr xt_over     ; ( addr u addr )
003A0Dr 3  20 rr rr                     jsr xt_u_dot    ; ( addr u )
003A10r 3  20 rr rr                     jsr xt_space
003A13r 3               
003A13r 3                               ; We use the opcode value as the offset in the oc_index_table.
003A13r 3                               ; We have 256 entries, each two bytes long, so we can't just
003A13r 3                               ; use an index with Y. We use tmp2 for this.
003A13r 3  A9 rr                        lda #<oc_index_table
003A15r 3  85 26                        sta tmp2
003A17r 3  A9 rr                        lda #>oc_index_table
003A19r 3  85 27                        sta tmp2+1
003A1Br 3               
003A1Br 3  A1 02                        lda (2,x)       ; get opcode that addr points to
003A1Dr 3               
003A1Dr 3  0A                           asl             ; multiply by two for offset
003A1Er 3  90 02                        bcc @1
003A20r 3  E6 27                        inc tmp2+1      ; we're on second page
003A22r 3               @1:
003A22r 3  A8                           tay             ; use Y as the index
003A23r 3               
003A23r 3                               ; Get address of the entry in the opcode table. We put it
003A23r 3                               ; in tmp3 and push a copy of it to the stack to be able to
003A23r 3                               ; print the opcode later
003A23r 3  B1 26                        lda (tmp2),y    ; LSB
003A25r 3  85 28                        sta tmp3
003A27r 3  48                           pha
003A28r 3               
003A28r 3  C8                           iny
003A29r 3               
003A29r 3  B1 26                        lda (tmp2),y    ; MSB
003A2Br 3  85 29                        sta tmp3+1
003A2Dr 3  48                           pha
003A2Er 3               
003A2Er 3                               ; The first byte is the "lengths byte" which is coded so
003A2Er 3                               ; that bits 7 to 6 are the length of the instruction (1 to
003A2Er 3                               ; 3 bytes) and 2 to 0 are the length of the mnemonic.
003A2Er 3  B2 28                        lda (tmp3)
003A30r 3  A8                           tay                     ; save copy of lengths byte
003A31r 3               
003A31r 3                               ; Since this is Simpler Assembler Notation (SAN) in a Forth
003A31r 3                               ; system, we want to print any operand before we print the
003A31r 3                               ; mnemonic ('1000 sta' instead of 'sta 1000'). This allows us
003A31r 3                               ; to copy and paste directly from the disassembler to the
003A31r 3                               ; assembler.
003A31r 3               
003A31r 3                               ; What happens next depends on the length of the instruction in
003A31r 3                               ; bytes:
003A31r 3               
003A31r 3                               ;   1 byte:  OPC          -->          OPC  bit sequence: %01
003A31r 3                               ;   2 bytes: OPC LSB      -->    0 LSB OPC  bit sequence: %10
003A31r 3                               ;   3 bytes: OPC LSB MSB  -->  MSB LSB OPC  bit sequence: %11
003A31r 3               
003A31r 3                               ; We can distinguish between the first case, where there is
003A31r 3                               ; only the mnemonic, and the second and third cases, where we
003A31r 3                               ; have an operand. We do this by use of the bit sequence in
003A31r 3                               ; bits 7 and 6.
003A31r 3  10 38                        bpl _no_operand         ; bit 7 clear, single-byte instruction
003A33r 3               
003A33r 3                               ; We have an operand. Prepare the Data Stack
003A33r 3  20 rr rr                     jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
003A36r 3               
003A36r 3                               ; Because of the glory of a little endian CPU, we can start
003A36r 3                               ; with the next byte regardless if this is a one or two byte
003A36r 3                               ; operand, because we'll need the LSB one way or the other.
003A36r 3                               ; We have a copy of the opcode on the stack, so we can now move
003A36r 3                               ; to the next byte
003A36r 3  F6 04                        inc 4,x
003A38r 3  D0 02                        bne @2
003A3Ar 3  F6 05                        inc 5,x                 ; ( addr+1 u 0 )
003A3Cr 3               @2:
003A3Cr 3  B5 02                        lda 2,x
003A3Er 3  D0 02                        bne @3
003A40r 3  D6 03                        dec 3,x
003A42r 3               @3:
003A42r 3  D6 02                        dec 2,x                 ; ( addr+1 u-1 0 )
003A44r 3               
003A44r 3  A1 04                        lda (4,x)
003A46r 3  95 00                        sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
003A48r 3               
003A48r 3                               ; We still have a copy of the lengths byte in Y, which we use
003A48r 3                               ; to see if we have a one-byte operand (and are done already)
003A48r 3                               ; or a two-byte operand
003A48r 3  98                           tya                     ; retrieve copy of lengths byte
003A49r 3  2A                           rol                     ; shift bit 6 to bit 7
003A4Ar 3  10 12                        bpl _print_operand
003A4Cr 3               
003A4Cr 3                               ; We have a three-byte instruction, so we need to get the MSB
003A4Cr 3                               ; of the operand. Move to the next byte
003A4Cr 3  F6 04                        inc 4,x
003A4Er 3  D0 02                        bne @4
003A50r 3  F6 05                        inc 5,x                 ; ( addr+2 u-1 LSB )
003A52r 3               @4:
003A52r 3  B5 02                        lda 2,x
003A54r 3  D0 02                        bne @5
003A56r 3  D6 03                        dec 3,x
003A58r 3               @5:
003A58r 3  D6 02                        dec 2,x                 ; ( addr+2 u-2 LSB )
003A5Ar 3               
003A5Ar 3  A1 04                        lda (4,x)
003A5Cr 3  95 01                        sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
003A5Er 3               
003A5Er 3                               ; fall through to _print_operand
003A5Er 3               
003A5Er 3               _print_operand:
003A5Er 3               
003A5Er 3                               ; We arrive here with the lengths byte in Y, the address of the
003A5Er 3                               ; opcode table entry for the instruction on the stack ( addr+n
003A5Er 3                               ; u-n opr). We want the output to be nicely formatted in
003A5Er 3                               ; columns, so we use U.R. The maximal width of the number in
003A5Er 3                               ; decimal on an 16-bit addressed machine is five characters
003A5Er 3  CA                           dex
003A5Fr 3  CA                           dex
003A60r 3  A9 05                        lda #5
003A62r 3  95 00                        sta 0,x
003A64r 3  74 01                        stz 1,x                 ; ( addr+n u-n opr 5 )
003A66r 3               
003A66r 3  20 rr rr                     jsr xt_u_dot_r          ; U.R ( addr+n u-n )
003A69r 3               
003A69r 3  80 0B                        bra _print_mnemonic
003A6Br 3               
003A6Br 3               _no_operand:
003A6Br 3                               ; We arrive here with the opcode table address on the stack,
003A6Br 3                               ; the lengths byte in Y and ( addr u ). Since we want to have
003A6Br 3                               ; a nicely formatted output, we need to indent the mnemonic by
003A6Br 3                               ; five spaces.
003A6Br 3  CA                           dex
003A6Cr 3  CA                           dex
003A6Dr 3  A9 05                        lda #5
003A6Fr 3  95 00                        sta 0,x
003A71r 3  74 01                        stz 1,x                 ; ( addr u 5 )
003A73r 3               
003A73r 3  20 rr rr                     jsr xt_spaces           ; ( addr u )
003A76r 3               
003A76r 3                               ; fall through to _print_mnemonic
003A76r 3               
003A76r 3               _print_mnemonic:
003A76r 3                               ; We arrive here with the opcode table address on the stack and
003A76r 3                               ; ( addr u | addr+n u-n ). Time to print the mnemonic.
003A76r 3  20 rr rr                     jsr xt_space
003A79r 3               
003A79r 3  CA                           dex
003A7Ar 3  CA                           dex                     ; ( addr u ? )
003A7Br 3  68                           pla                     ; MSB
003A7Cr 3  95 01                        sta 1,x                 ; ( addr u MSB )
003A7Er 3  68                           pla                     ; LSB
003A7Fr 3  95 00                        sta 0,x                 ; ( addr u addr-o )
003A81r 3               
003A81r 3  20 rr rr                     jsr xt_count            ; ( addr u addr-o u-o )
003A84r 3               
003A84r 3                               ; The length of the mnemnonic string is in bits 2 to 0
003A84r 3  74 01                        stz 1,x                 ; paranoid
003A86r 3  B5 00                        lda 0,x
003A88r 3  29 07                        and #%00000111          ; ( addr u addr-o u-o )
003A8Ar 3  95 00                        sta 0,x
003A8Cr 3               
003A8Cr 3  20 rr rr                     jsr xt_type             ; ( addr u )
003A8Fr 3  20 rr rr                     jsr xt_cr
003A92r 3               
003A92r 3                               ; Housekeeping: Next byte
003A92r 3  F6 02                        inc 2,x
003A94r 3  D0 02                        bne @1
003A96r 3  F6 03                        inc 3,x                 ; ( addr+1 u )
003A98r 3               @1:
003A98r 3  20 rr rr                     jsr xt_one_minus        ; ( addr+1 u-1 )
003A9Br 3               
003A9Br 3  B5 00                        lda 0,x                 ; All done?
003A9Dr 3  15 01                        ora 1,x
003A9Fr 3  F0 07                        beq @done
003AA1r 3               
003AA1r 3  B5 01                        lda 1,x                 ; Catch mid-instruction ranges
003AA3r 3  30 03                        bmi @done
003AA5r 3               
003AA5r 3  4C rr rr                     jmp _byte_loop          ; out of range for BRA
003AA8r 3               @done:
003AA8r 3                               ; Clean up and leave
003AA8r 3  4C rr rr                     jmp xt_two_drop         ; JSR/RTS
003AABr 3               
003AABr 3               
003AABr 3               ; =========================================================
003AABr 3               oc_index_table:
003AABr 3                       ; Lookup table for the instruction data (length of instruction in
003AABr 3                       ; bytes, length of mnemonic in bytes, mnemonic string). This is used by
003AABr 3                       ; the assembler as well.
003AABr 3               
003AABr 3                       ; Opcodes 00-0F
003AABr 3  rr rr rr rr          .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
003AAFr 3  rr rr rr rr  
003AB3r 3  rr rr rr rr  
003ABBr 3  rr rr rr rr          .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
003ABFr 3  rr rr rr rr  
003AC3r 3  rr rr rr rr  
003ACBr 3               
003ACBr 3                       ; Opcodes 10-1F
003ACBr 3  rr rr rr rr          .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
003ACFr 3  rr rr rr rr  
003AD3r 3  rr rr rr rr  
003ADBr 3  rr rr rr rr          .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
003ADFr 3  rr rr rr rr  
003AE3r 3  rr rr rr rr  
003AEBr 3               
003AEBr 3                       ; Opcodes 20-2F
003AEBr 3  rr rr rr rr          .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
003AEFr 3  rr rr rr rr  
003AF3r 3  rr rr rr rr  
003AFBr 3  rr rr rr rr          .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
003AFFr 3  rr rr rr rr  
003B03r 3  rr rr rr rr  
003B0Br 3               
003B0Br 3                       ; Opcodes 30-3F
003B0Br 3  rr rr rr rr          .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
003B0Fr 3  rr rr rr rr  
003B13r 3  rr rr rr rr  
003B1Br 3  rr rr rr rr          .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
003B1Fr 3  rr rr rr rr  
003B23r 3  rr rr rr rr  
003B2Br 3               
003B2Br 3                       ; Opcodes 40-4F
003B2Br 3  rr rr rr rr          .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
003B2Fr 3  rr rr rr rr  
003B33r 3  rr rr rr rr  
003B3Br 3  rr rr rr rr          .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
003B3Fr 3  rr rr rr rr  
003B43r 3  rr rr rr rr  
003B4Br 3               
003B4Br 3                       ; Opcodes 50-5F
003B4Br 3  rr rr rr rr          .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
003B4Fr 3  rr rr rr rr  
003B53r 3  rr rr rr rr  
003B5Br 3  rr rr rr rr          .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
003B5Fr 3  rr rr rr rr  
003B63r 3  rr rr rr rr  
003B6Br 3               
003B6Br 3                       ; Opcodes 60-6F
003B6Br 3  rr rr rr rr          .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
003B6Fr 3  rr rr rr rr  
003B73r 3  rr rr rr rr  
003B7Br 3  rr rr rr rr          .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
003B7Fr 3  rr rr rr rr  
003B83r 3  rr rr rr rr  
003B8Br 3               
003B8Br 3                       ; Opcodes 70-7F
003B8Br 3  rr rr rr rr          .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
003B8Fr 3  rr rr rr rr  
003B93r 3  rr rr rr rr  
003B9Br 3  rr rr rr rr          .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
003B9Fr 3  rr rr rr rr  
003BA3r 3  rr rr rr rr  
003BABr 3               
003BABr 3                       ; Opcodes 80-8F
003BABr 3  rr rr rr rr          .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
003BAFr 3  rr rr rr rr  
003BB3r 3  rr rr rr rr  
003BBBr 3  rr rr rr rr          .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
003BBFr 3  rr rr rr rr  
003BC3r 3  rr rr rr rr  
003BCBr 3               
003BCBr 3                       ; Opcodes 90-9F
003BCBr 3  rr rr rr rr          .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
003BCFr 3  rr rr rr rr  
003BD3r 3  rr rr rr rr  
003BDBr 3  rr rr rr rr          .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
003BDFr 3  rr rr rr rr  
003BE3r 3  rr rr rr rr  
003BEBr 3               
003BEBr 3                       ; Opcodes A0-AF
003BEBr 3  rr rr rr rr          .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
003BEFr 3  rr rr rr rr  
003BF3r 3  rr rr rr rr  
003BFBr 3  rr rr rr rr          .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
003BFFr 3  rr rr rr rr  
003C03r 3  rr rr rr rr  
003C0Br 3               
003C0Br 3                       ; Opcodes B0-BF
003C0Br 3  rr rr rr rr          .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
003C0Fr 3  rr rr rr rr  
003C13r 3  rr rr rr rr  
003C1Br 3  rr rr rr rr          .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
003C1Fr 3  rr rr rr rr  
003C23r 3  rr rr rr rr  
003C2Br 3               
003C2Br 3                       ; Opcodes C0-CF
003C2Br 3  rr rr rr rr          .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
003C2Fr 3  rr rr rr rr  
003C33r 3  rr rr rr rr  
003C3Br 3  rr rr rr rr          .word occ8, occ9, occa, oc__, occc, occd, occe, occf
003C3Fr 3  rr rr rr rr  
003C43r 3  rr rr rr rr  
003C4Br 3               
003C4Br 3                       ; Opcodes D0-DF
003C4Br 3  rr rr rr rr          .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
003C4Fr 3  rr rr rr rr  
003C53r 3  rr rr rr rr  
003C5Br 3  rr rr rr rr          .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
003C5Fr 3  rr rr rr rr  
003C63r 3  rr rr rr rr  
003C6Br 3               
003C6Br 3                       ; Opcodes E0-EF
003C6Br 3  rr rr rr rr          .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
003C6Fr 3  rr rr rr rr  
003C73r 3  rr rr rr rr  
003C7Br 3  rr rr rr rr          .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
003C7Fr 3  rr rr rr rr  
003C83r 3  rr rr rr rr  
003C8Br 3               
003C8Br 3                       ; Opcodes F0-FF
003C8Br 3  rr rr rr rr          .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
003C8Fr 3  rr rr rr rr  
003C93r 3  rr rr rr rr  
003C9Br 3  rr rr rr rr          .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
003C9Fr 3  rr rr rr rr  
003CA3r 3  rr rr rr rr  
003CABr 3               
003CABr 3               
003CABr 3               ; =========================================================
003CABr 3               oc_table:
003CABr 3                       ; Opcode data table for the disassember, which is also used by the
003CABr 3                       ; assembler. Each entry starts with a "lengths byte":
003CABr 3               
003CABr 3                       ;       bit 7-6:  Length of instruction in bytes (1 to 3 for the 65c02)
003CABr 3                       ;       bit 5-3:  unused
003CABr 3                       ;       bit 2-0:  Length of mnemonic in chars (3 to 7)
003CABr 3               
003CABr 3                       ; To convert a line in this table to a Forth string of the mnemonic,
003CABr 3                       ; use the COUNT word on the address of the lengths byte to get
003CABr 3                       ; ( addr u ) and then mask all but the bits 2-0 of the TOS.
003CABr 3               
003CABr 3                       ; To make debugging easier, we keep the raw numbers for the lengths of
003CABr 3                       ; the instruction and mnemonicis and let the assembler do the math
003CABr 3                       ; required to shift and add. The actual mnemonic string follows after
003CABr 3                       ; and is not zero terminated because we have the length in bits 2 to 0.
003CABr 3               
003CABr 3  83 62 72 6B  	oc00:	.byte 2*64+3, "brk"              ; enforce the signature byte
003CAFr 3  87 6F 72 61  	oc01:	.byte 2*64+7, "ora.zxi"
003CB3r 3  2E 7A 78 69  
003CB7r 3               ;      (oc02)
003CB7r 3               ;      (oc03)
003CB7r 3  85 74 73 62          oc04:   .byte 2*64+5, "tsb.z"
003CBBr 3  2E 7A        
003CBDr 3  85 6F 72 64  	oc05:	.byte 2*64+5, "ord.z"
003CC1r 3  2E 7A        
003CC3r 3  85 61 73 6C  	oc06:	.byte 2*64+5, "asl.z"
003CC7r 3  2E 7A        
003CC9r 3               ;      (oc07)
003CC9r 3  43 70 68 70  	oc08:	.byte 1*64+3, "php"
003CCDr 3  85 6F 72 61  	oc09:	.byte 2*64+5, "ora.#"
003CD1r 3  2E 23        
003CD3r 3  45 61 73 6C  	oc0a:	.byte 1*64+5, "asl.a"
003CD7r 3  2E 61        
003CD9r 3               ;      (oc0b)
003CD9r 3  C3 74 73 62  	oc0c:	.byte 3*64+3, "tsb"
003CDDr 3  C3 6F 72 61  	oc0d:	.byte 3*64+3, "ora"
003CE1r 3  C3 61 73 6C  	oc0e:	.byte 3*64+3, "asl"
003CE5r 3  C4 62 62 72  	oc0f:	.byte 3*64+4, "bbr0"
003CE9r 3  30           
003CEAr 3               
003CEAr 3  83 62 70 6C  	oc10:	.byte 2*64+3, "bpl"
003CEEr 3  87 6F 72 61  	oc11:	.byte 2*64+7, "ora.ziy"
003CF2r 3  2E 7A 69 79  
003CF6r 3  86 6F 72 61  	oc12:	.byte 2*64+6, "ora.zi"
003CFAr 3  2E 7A 69     
003CFDr 3               ;      (oc13:)
003CFDr 3  85 74 72 62  	oc14:	.byte 2*64+5, "trb.z"
003D01r 3  2E 7A        
003D03r 3  86 6F 72 61  	oc15:	.byte 2*64+6, "ora.zx"
003D07r 3  2E 7A 78     
003D0Ar 3  86 61 73 6C  	oc16:	.byte 2*64+6, "asl.zx"
003D0Er 3  2E 7A 78     
003D11r 3  86 72 6D 62  	oc17:	.byte 2*64+6, "rmb1.z"
003D15r 3  31 2E 7A     
003D18r 3  43 63 6C 63  	oc18:	.byte 1*64+3, "clc"
003D1Cr 3  C5 6F 72 61  	oc19:	.byte 3*64+5, "ora.y"
003D20r 3  2E 79        
003D22r 3  45 69 6E 63  	oc1a:	.byte 1*64+5, "inc.a"
003D26r 3  2E 61        
003D28r 3               ;      (oc1b:)
003D28r 3  C3 74 72 62  	oc1c:	.byte 3*64+3, "trb"
003D2Cr 3  C5 6F 72 61  	oc1d:	.byte 3*64+5, "ora.x"
003D30r 3  2E 78        
003D32r 3               ;      (oc1e:)
003D32r 3  C5 61 73 6C  	oc1f:	.byte 3*64+5, "asl.x"
003D36r 3  2E 78        
003D38r 3               
003D38r 3  C3 6A 73 72  	oc20:	.byte 3*64+3, "jsr"
003D3Cr 3  87 61 6E 64  	oc21:	.byte 2*64+7, "and.zxi"
003D40r 3  2E 7A 78 69  
003D44r 3               ;      (oc22:)
003D44r 3               ;      (oc23:)
003D44r 3  85 62 69 74  	oc24:	.byte 2*64+5, "bit.z"
003D48r 3  2E 7A        
003D4Ar 3  85 61 6E 64  	oc25:	.byte 2*64+5, "and.z"
003D4Er 3  2E 7A        
003D50r 3  85 72 6F 6C  	oc26:	.byte 2*64+5, "rol.z"
003D54r 3  2E 7A        
003D56r 3  86 72 6D 62  	oc27:	.byte 2*64+6, "rmb2.z"
003D5Ar 3  32 2E 7A     
003D5Dr 3  43 70 6C 70  	oc28:	.byte 1*64+3, "plp"
003D61r 3  85 61 6E 64  	oc29:	.byte 2*64+5, "and.#"
003D65r 3  2E 23        
003D67r 3  45 72 6F 6C  	oc2a:	.byte 1*64+5, "rol.a"
003D6Br 3  2E 61        
003D6Dr 3               ;      (oc2b:)
003D6Dr 3  C3 62 69 74  	oc2c:	.byte 3*64+3, "bit"
003D71r 3  C4 61 6E 64  	oc2d:	.byte 3*64+4, "and."
003D75r 3  2E           
003D76r 3  C3 72 6F 6C  	oc2e:	.byte 3*64+3, "rol"
003D7Ar 3  C4 62 62 72  	oc2f:	.byte 3*64+4, "bbr2"
003D7Er 3  32           
003D7Fr 3               
003D7Fr 3  83 62 6D 69  	oc30:	.byte 2*64+3, "bmi"
003D83r 3  87 61 6E 64  	oc31:	.byte 2*64+7, "and.ziy"
003D87r 3  2E 7A 69 79  
003D8Br 3  86 61 6E 64  	oc32:	.byte 2*64+6, "and.zi"
003D8Fr 3  2E 7A 69     
003D92r 3               ;      (oc33:)
003D92r 3  87 62 69 74  	oc34:	.byte 2*64+7, "bit.zxi"
003D96r 3  2E 7A 78 69  
003D9Ar 3  86 61 6E 64  	oc35:	.byte 2*64+6, "and.zx"
003D9Er 3  2E 7A 78     
003DA1r 3  86 72 6F 6C  	oc36:	.byte 2*64+6, "rol.zx"
003DA5r 3  2E 7A 78     
003DA8r 3  86 72 6D 62  	oc37:	.byte 2*64+6, "rmb3.z"
003DACr 3  33 2E 7A     
003DAFr 3  43 73 65 63  	oc38:	.byte 1*64+3, "sec"
003DB3r 3  C5 61 6E 64  	oc39:	.byte 3*64+5, "and.y"
003DB7r 3  2E 79        
003DB9r 3  45 64 65 63  	oc3a:	.byte 1*64+5, "dec.a"
003DBDr 3  2E 61        
003DBFr 3               ;      (oc3b:)
003DBFr 3  C5 62 69 74  	oc3c:	.byte 3*64+5, "bit.x"
003DC3r 3  2E 78        
003DC5r 3  C5 61 6E 64  	oc3d:	.byte 3*64+5, "and.x"
003DC9r 3  2E 78        
003DCBr 3  C5 72 6F 6C  	oc3e:	.byte 3*64+5, "rol.x"
003DCFr 3  2E 78        
003DD1r 3  C4 62 62 72  	oc3f:	.byte 3*64+4, "bbr3"
003DD5r 3  33           
003DD6r 3               
003DD6r 3  43 72 74 69  	oc40:	.byte 1*64+3, "rti"
003DDAr 3  87 65 6F 72  	oc41:	.byte 2*64+7, "eor.zxi"
003DDEr 3  2E 7A 78 69  
003DE2r 3               ;      (oc42:)
003DE2r 3               ;      (oc43:)
003DE2r 3               ;      (oc44:)
003DE2r 3  85 65 6F 72  	oc45:	.byte 2*64+5, "eor.z"
003DE6r 3  2E 7A        
003DE8r 3  85 6C 73 72  	oc46:	.byte 2*64+5, "lsr.z"
003DECr 3  2E 7A        
003DEEr 3  86 72 62 6D  	oc47:	.byte 2*64+6, "rbm4.z"
003DF2r 3  34 2E 7A     
003DF5r 3  43 70 68 61  	oc48:	.byte 1*64+3, "pha"
003DF9r 3  85 65 6F 72  	oc49:	.byte 2*64+5, "eor.#"
003DFDr 3  2E 23        
003DFFr 3  45 6C 73 72  	oc4a:	.byte 1*64+5, "lsr.a"
003E03r 3  2E 61        
003E05r 3               ;      (oc4b:)
003E05r 3  C3 6A 6D 70  	oc4c:	.byte 3*64+3, "jmp"
003E09r 3  C3 65 6F 72  	oc4d:	.byte 3*64+3, "eor"
003E0Dr 3  C3 6C 73 72  	oc4e:	.byte 3*64+3, "lsr"
003E11r 3  C4 62 62 72  	oc4f:	.byte 3*64+4, "bbr4"
003E15r 3  34           
003E16r 3               
003E16r 3  83 62 76 63  	oc50:	.byte 2*64+3, "bvc"
003E1Ar 3  87 65 6F 72  	oc51:	.byte 2*64+7, "eor.ziy"
003E1Er 3  2E 7A 69 79  
003E22r 3  86 65 6F 72  	oc52:	.byte 2*64+6, "eor.zi"
003E26r 3  2E 7A 69     
003E29r 3               ;      (oc53:)
003E29r 3               ;      (oc54:)
003E29r 3  86 65 6F 72  	oc55:	.byte 2*64+6, "eor.zx"
003E2Dr 3  2E 7A 78     
003E30r 3  86 6C 73 72  	oc56:	.byte 2*64+6, "lsr.zx"
003E34r 3  2E 7A 78     
003E37r 3  86 72 62 6D  	oc57:	.byte 2*64+6, "rbm5.z"
003E3Br 3  35 2E 7A     
003E3Er 3  43 63 6C 69  	oc58:	.byte 1*64+3, "cli"
003E42r 3  C5 65 6F 72  	oc59:	.byte 3*64+5, "eor.y"
003E46r 3  2E 79        
003E48r 3  43 70 68 79  	oc5a:	.byte 1*64+3, "phy"
003E4Cr 3               ;      (oc5b:)
003E4Cr 3               ;      (oc5c:)
003E4Cr 3  C5 65 6F 72  	oc5d:	.byte 3*64+5, "eor.x"
003E50r 3  2E 78        
003E52r 3  C5 6C 73 72  	oc5e:	.byte 3*64+5, "lsr.x"
003E56r 3  2E 78        
003E58r 3  C4 62 62 72  	oc5f:	.byte 3*64+4, "bbr5"
003E5Cr 3  35           
003E5Dr 3               
003E5Dr 3  43 72 74 73  	oc60:	.byte 1*64+3, "rts"
003E61r 3  87 61 64 63  	oc61:	.byte 2*64+7, "adc.zxi"
003E65r 3  2E 7A 78 69  
003E69r 3               ;      (oc62:)
003E69r 3               ;      (oc63:)
003E69r 3  85 73 74 7A  	oc64:	.byte 2*64+5, "stz.z"
003E6Dr 3  2E 7A        
003E6Fr 3  85 61 64 63  	oc65:	.byte 2*64+5, "adc.z"
003E73r 3  2E 7A        
003E75r 3  85 72 6F 72  	oc66:	.byte 2*64+5, "ror.z"
003E79r 3  2E 7A        
003E7Br 3  86 72 6D 62  	oc67:	.byte 2*64+6, "rmb6.z"
003E7Fr 3  36 2E 7A     
003E82r 3  43 70 6C 61  	oc68:	.byte 1*64+3, "pla"
003E86r 3  85 61 64 63  	oc69:	.byte 2*64+5, "adc.#"
003E8Ar 3  2E 23        
003E8Cr 3  45 72 6F 72  	oc6a:	.byte 1*64+5, "ror.a"
003E90r 3  2E 61        
003E92r 3               ;      (oc6b:)
003E92r 3  C5 6A 6D 70  	oc6c:	.byte 3*64+5, "jmp.i"
003E96r 3  2E 69        
003E98r 3  C3 61 64 63  	oc6d:	.byte 3*64+3, "adc"
003E9Cr 3  C3 72 6F 72  	oc6e:	.byte 3*64+3, "ror"
003EA0r 3  C4 62 62 72  	oc6f:	.byte 3*64+4, "bbr6"
003EA4r 3  36           
003EA5r 3               
003EA5r 3  83 62 76 73  	oc70:	.byte 2*64+3, "bvs"
003EA9r 3  87 61 64 63  	oc71:	.byte 2*64+7, "adc.ziy"
003EADr 3  2E 7A 69 79  
003EB1r 3  86 61 64 63  	oc72:	.byte 2*64+6, "adc.zi"
003EB5r 3  2E 7A 69     
003EB8r 3               ;      (oc73:)
003EB8r 3  86 73 74 7A  	oc74:	.byte 2*64+6, "stz.zx"
003EBCr 3  2E 7A 78     
003EBFr 3  86 61 64 63  	oc75:	.byte 2*64+6, "adc.zx"
003EC3r 3  2E 7A 78     
003EC6r 3  86 72 6F 72  	oc76:	.byte 2*64+6, "ror.zx"
003ECAr 3  2E 7A 78     
003ECDr 3  86 72 6D 62  	oc77:	.byte 2*64+6, "rmb7.z"
003ED1r 3  37 2E 7A     
003ED4r 3  43 73 65 69  	oc78:	.byte 1*64+3, "sei"
003ED8r 3  C5 61 64 63  	oc79:	.byte 3*64+5, "adc.y"
003EDCr 3  2E 79        
003EDEr 3  43 70 6C 79  	oc7a:	.byte 1*64+3, "ply"
003EE2r 3               ;      (oc7b:)
003EE2r 3  C6 6A 6D 70  	oc7c:	.byte 3*64+6, "jmp.xi"
003EE6r 3  2E 78 69     
003EE9r 3  C5 61 64 63  	oc7d:	.byte 3*64+5, "adc.x"
003EEDr 3  2E 78        
003EEFr 3  C5 72 6F 72  	oc7e:	.byte 3*64+5, "ror.x"
003EF3r 3  2E 78        
003EF5r 3  C4 62 62 72  	oc7f:	.byte 3*64+4, "bbr7"
003EF9r 3  37           
003EFAr 3               
003EFAr 3  83 62 72 61  	oc80:	.byte 2*64+3, "bra"
003EFEr 3  87 73 74 61  	oc81:	.byte 2*64+7, "sta.zxi"
003F02r 3  2E 7A 78 69  
003F06r 3               ;      (oc82:)
003F06r 3               ;      (oc83:)
003F06r 3  85 73 74 79  	oc84:	.byte 2*64+5, "sty.z"
003F0Ar 3  2E 7A        
003F0Cr 3  85 73 74 61  	oc85:	.byte 2*64+5, "sta.z"
003F10r 3  2E 7A        
003F12r 3  85 73 74 78  	oc86:	.byte 2*64+5, "stx.z"
003F16r 3  2E 7A        
003F18r 3               ;      (oc87:)
003F18r 3  43 64 65 79  	oc88:	.byte 1*64+3, "dey"
003F1Cr 3  85 62 69 74  	oc89:	.byte 2*64+5, "bit.#"
003F20r 3  2E 23        
003F22r 3  43 74 78 61  	oc8a:	.byte 1*64+3, "txa"
003F26r 3               ;      (oc8b:)
003F26r 3  C3 73 74 79  	oc8c:	.byte 3*64+3, "sty"
003F2Ar 3  C3 73 74 61  	oc8d:	.byte 3*64+3, "sta"
003F2Er 3  C3 73 74 78  	oc8e:	.byte 3*64+3, "stx"
003F32r 3  C4 62 62 73  	oc8f:	.byte 3*64+4, "bbs0"
003F36r 3  30           
003F37r 3               
003F37r 3  83 62 63 63  	oc90:	.byte 2*64+3, "bcc"
003F3Br 3  87 73 74 61  	oc91:	.byte 2*64+7, "sta.ziy"
003F3Fr 3  2E 7A 69 79  
003F43r 3  86 73 74 61  	oc92:	.byte 2*64+6, "sta.zi"
003F47r 3  2E 7A 69     
003F4Ar 3               ;      (oc93:)
003F4Ar 3  86 73 74 79  	oc94:	.byte 2*64+6, "sty.zx"
003F4Er 3  2E 7A 78     
003F51r 3  86 73 74 61  	oc95:	.byte 2*64+6, "sta.zx"
003F55r 3  2E 7A 78     
003F58r 3  86 73 74 78  	oc96:	.byte 2*64+6, "stx.zy"
003F5Cr 3  2E 7A 79     
003F5Fr 3  86 73 6D 62  	oc97:	.byte 2*64+6, "smb1.z"
003F63r 3  31 2E 7A     
003F66r 3  43 74 79 61  	oc98:	.byte 1*64+3, "tya"
003F6Ar 3  C5 73 74 61  	oc99:	.byte 3*64+5, "sta.y"
003F6Er 3  2E 79        
003F70r 3  43 74 78 73  	oc9a:	.byte 1*64+3, "txs"
003F74r 3               ;      (oc9b:)
003F74r 3  C3 73 74 7A  	oc9c:	.byte 3*64+3, "stz"
003F78r 3  C5 73 74 61  	oc9d:	.byte 3*64+5, "sta.x"
003F7Cr 3  2E 78        
003F7Er 3  C5 73 74 7A  	oc9e:	.byte 3*64+5, "stz.x"
003F82r 3  2E 78        
003F84r 3  C4 62 62 73  	oc9f:	.byte 3*64+4, "bbs1"
003F88r 3  31           
003F89r 3               
003F89r 3  85 6C 64 79  	oca0:	.byte 2*64+5, "ldy.#"
003F8Dr 3  2E 23        
003F8Fr 3  87 6C 64 61  	oca1:	.byte 2*64+7, "lda.zxi"
003F93r 3  2E 7A 78 69  
003F97r 3  85 6C 64 78  	oca2:	.byte 2*64+5, "ldx.#"
003F9Br 3  2E 23        
003F9Dr 3               ;      (oca3:)
003F9Dr 3  85 6C 64 79  	oca4:	.byte 2*64+5, "ldy.z"
003FA1r 3  2E 7A        
003FA3r 3  85 6C 64 61  	oca5:	.byte 2*64+5, "lda.z"
003FA7r 3  2E 7A        
003FA9r 3  85 6C 64 78  	oca6:	.byte 2*64+5, "ldx.z"
003FADr 3  2E 7A        
003FAFr 3  86 73 6D 62  	oca7:	.byte 2*64+6, "smb2.z"
003FB3r 3  32 2E 7A     
003FB6r 3  43 74 61 79  	oca8:	.byte 1*64+3, "tay"
003FBAr 3  85 6C 64 61  	oca9:	.byte 2*64+5, "lda.#"
003FBEr 3  2E 23        
003FC0r 3  43 74 61 78  	ocaa:	.byte 1*64+3, "tax"
003FC4r 3               ;      (ocab:)
003FC4r 3  C3 6C 64 79  	ocac:	.byte 3*64+3, "ldy"
003FC8r 3  C3 6C 64 61  	ocad:	.byte 3*64+3, "lda"
003FCCr 3  C3 6C 64 78  	ocae:	.byte 3*64+3, "ldx"
003FD0r 3  C4 62 62 73  	ocaf:	.byte 3*64+4, "bbs2"
003FD4r 3  32           
003FD5r 3               
003FD5r 3  83 62 63 73  	ocb0:	.byte 2*64+3, "bcs"
003FD9r 3  87 6C 64 61  	ocb1:	.byte 2*64+7, "lda.ziy"
003FDDr 3  2E 7A 69 79  
003FE1r 3  86 6C 64 61  	ocb2:	.byte 2*64+6, "lda.zi"
003FE5r 3  2E 7A 69     
003FE8r 3               ;      (ocb3:)
003FE8r 3  86 6C 64 79  	ocb4:	.byte 2*64+6, "ldy.zx"
003FECr 3  2E 7A 78     
003FEFr 3  86 6C 64 61  	ocb5:	.byte 2*64+6, "lda.zx"
003FF3r 3  2E 7A 78     
003FF6r 3  86 6C 64 78  	ocb6:	.byte 2*64+6, "ldx.zy"
003FFAr 3  2E 7A 79     
003FFDr 3  86 73 6D 62  	ocb7:	.byte 2*64+6, "smb3.z"
004001r 3  33 2E 7A     
004004r 3  43 63 6C 76  	ocb8:	.byte 1*64+3, "clv"
004008r 3  C5 6C 64 61  	ocb9:	.byte 3*64+5, "lda.y"
00400Cr 3  2E 79        
00400Er 3  43 74 73 78  	ocba:	.byte 1*64+3, "tsx"
004012r 3               ;      (ocbb:)
004012r 3  C5 6C 64 79  	ocbc:	.byte 3*64+5, "ldy.x"
004016r 3  2E 78        
004018r 3  C5 6C 64 61  	ocbd:	.byte 3*64+5, "lda.x"
00401Cr 3  2E 78        
00401Er 3  C5 6C 64 78  	ocbe:	.byte 3*64+5, "ldx.y"
004022r 3  2E 79        
004024r 3  C4 62 62 73  	ocbf:	.byte 3*64+4, "bbs4"
004028r 3  34           
004029r 3               
004029r 3  85 63 70 79  	occ0:	.byte 2*64+5, "cpy.#"
00402Dr 3  2E 23        
00402Fr 3  87 63 6D 70  	occ1:	.byte 2*64+7, "cmp.zxi"
004033r 3  2E 7A 78 69  
004037r 3               ;      (occ2:)
004037r 3               ;      (occ3:)
004037r 3  85 63 70 79  	occ4:	.byte 2*64+5, "cpy.z"
00403Br 3  2E 7A        
00403Dr 3  85 63 6D 70  	occ5:	.byte 2*64+5, "cmp.z"
004041r 3  2E 7A        
004043r 3  85 64 65 63  	occ6:	.byte 2*64+5, "dec.z"
004047r 3  2E 7A        
004049r 3  86 73 6D 62  	occ7:	.byte 2*64+6, "smb4.z"
00404Dr 3  34 2E 7A     
004050r 3  43 69 6E 79  	occ8:	.byte 1*64+3, "iny"
004054r 3  85 63 6D 70  	occ9:	.byte 2*64+5, "cmp.#"
004058r 3  2E 23        
00405Ar 3  43 64 65 78  	occa:	.byte 1*64+3, "dex"
00405Er 3               ;      (occb:)
00405Er 3  C3 63 70 79  	occc:	.byte 3*64+3, "cpy"
004062r 3  C3 63 6D 70  	occd:	.byte 3*64+3, "cmp"
004066r 3  C3 64 65 63  	occe:	.byte 3*64+3, "dec"
00406Ar 3  C4 62 62 73  	occf:	.byte 3*64+4, "bbs4"
00406Er 3  34           
00406Fr 3               
00406Fr 3  83 62 6E 65  	ocd0:	.byte 2*64+3, "bne"
004073r 3  87 63 6D 70  	ocd1:	.byte 2*64+7, "cmp.ziy"
004077r 3  2E 7A 69 79  
00407Br 3  86 63 6D 70  	ocd2:	.byte 2*64+6, "cmp.zi"
00407Fr 3  2E 7A 69     
004082r 3               ;      (ocd3:)
004082r 3               ;      (ocd4:)
004082r 3  86 63 6D 70  	ocd5:	.byte 2*64+6, "cmp.zx"
004086r 3  2E 7A 78     
004089r 3  86 64 65 63  	ocd6:	.byte 2*64+6, "dec.zx"
00408Dr 3  2E 7A 78     
004090r 3  86 73 6D 62  	ocd7:	.byte 2*64+6, "smb5.z"
004094r 3  35 2E 7A     
004097r 3  43 63 6C 64  	ocd8:	.byte 1*64+3, "cld"
00409Br 3  C5 63 6D 70  	ocd9:	.byte 3*64+5, "cmp.y"
00409Fr 3  2E 79        
0040A1r 3  43 70 68 78  	ocda:	.byte 1*64+3, "phx"
0040A5r 3               ;      (ocdb:)
0040A5r 3               ;      (ocdc:)
0040A5r 3  C5 63 6D 70  	ocdd:	.byte 3*64+5, "cmp.x"
0040A9r 3  2E 78        
0040ABr 3  C5 64 65 63  	ocde:	.byte 3*64+5, "dec.x"
0040AFr 3  2E 78        
0040B1r 3  C4 62 62 73  	ocdf:	.byte 3*64+4, "bbs5"
0040B5r 3  35           
0040B6r 3               
0040B6r 3  85 63 70 78  	oce0:	.byte 2*64+5, "cpx.#"
0040BAr 3  2E 23        
0040BCr 3  87 73 62 63  	oce1:	.byte 2*64+7, "sbc.zxi"
0040C0r 3  2E 7A 78 69  
0040C4r 3               ;      (oce2:)
0040C4r 3               ;      (oce3:)
0040C4r 3  85 63 70 78  	oce4:	.byte 2*64+5, "cpx.z"
0040C8r 3  2E 7A        
0040CAr 3  85 73 62 63  	oce5:	.byte 2*64+5, "sbc.z"
0040CEr 3  2E 7A        
0040D0r 3  85 69 6E 63  	oce6:	.byte 2*64+5, "inc.z"
0040D4r 3  2E 7A        
0040D6r 3  86 73 6D 62  	oce7:	.byte 2*64+6, "smb6.z"
0040DAr 3  36 2E 7A     
0040DDr 3  43 69 6E 78  	oce8:	.byte 1*64+3, "inx"
0040E1r 3  85 73 62 63  	oce9:	.byte 2*64+5, "sbc.#"
0040E5r 3  2E 23        
0040E7r 3  43 6E 6F 70  	ocea:	.byte 1*64+3, "nop"
0040EBr 3               ;      (oceb:)
0040EBr 3  C3 63 70 78  	ocec:	.byte 3*64+3, "cpx"
0040EFr 3  C3 73 62 63  	oced:	.byte 3*64+3, "sbc"
0040F3r 3  C3 69 6E 63  	ocee:	.byte 3*64+3, "inc"
0040F7r 3  C4 62 62 73  	ocef:	.byte 3*64+4, "bbs6"
0040FBr 3  36           
0040FCr 3               
0040FCr 3  83 62 65 71  	ocf0:	.byte 2*64+3, "beq"
004100r 3  87 73 62 63  	ocf1:	.byte 2*64+7, "sbc.ziy"
004104r 3  2E 7A 69 79  
004108r 3  86 73 62 63  	ocf2:	.byte 2*64+6, "sbc.zi"
00410Cr 3  2E 7A 69     
00410Fr 3               ;      (ocf3:)
00410Fr 3               ;      (ocf4:)
00410Fr 3  86 73 62 63  	ocf5:	.byte 2*64+6, "sbc.zx"
004113r 3  2E 7A 78     
004116r 3  86 69 6E 63  	ocf6:	.byte 2*64+6, "inc.zx"
00411Ar 3  2E 7A 78     
00411Dr 3  86 73 6D 62  	ocf7:	.byte 2*64+6, "smb7.z"
004121r 3  37 2E 7A     
004124r 3  43 73 65 64  	ocf8:	.byte 1*64+3, "sed"
004128r 3  C5 73 62 63  	ocf9:	.byte 3*64+5, "sbc.y"
00412Cr 3  2E 79        
00412Er 3  43 70 6C 78  	ocfa:	.byte 1*64+3, "plx"
004132r 3               ;      (ocfb:)
004132r 3               ;      (ocfc:)
004132r 3  C5 73 62 63  	ocfd:	.byte 3*64+5, "sbc.x"
004136r 3  2E 78        
004138r 3  C5 69 6E 63  	ocfe:	.byte 3*64+5, "inc.x"
00413Cr 3  2E 78        
00413Er 3  C4 62 62 73  	ocff:	.byte 3*64+4, "bbs7"
004142r 3  37           
004143r 3               
004143r 3                       ; Common routine for opcodes that are not supported by the 65c02
004143r 3  01 3F        	oc__:	.byte 1, "?"
004145r 3               
004145r 3               ; used to calculate size of assembled disassembler code
004145r 3               disassembler_end:
004145r 3               
004145r 2               .include "ed.asm"               ; Line-based editor ed6502
004145r 3               ; ed6502 - Ed-like line-based editor for Tali Forth 2
004145r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004145r 3               ; First version: 13. Okt 2018
004145r 3               ; This version: 28. Dec 2018
004145r 3               
004145r 3               ; Ed is a line-orientated editor for Tali Forth 2 based on the classic Unix
004145r 3               ; editor of the same name. It is included because a) I like line editors and
004145r 3               ; this is my project, so there, and b) as a very simple editor that will work
004145r 3               ; even if there is no vt100 terminal support, just with ASCII if needs be. For
004145r 3               ; further information on ed, see
004145r 3               
004145r 3               ;   https://en.wikipedia.org/wiki/Ed_(text_editor)
004145r 3               ;   https://www.gnu.org/software/ed/ed.html
004145r 3               ;   https://www.gnu.org/software/ed/manual/ed_manual.html
004145r 3               ;   https://sanctum.geek.nz/arabesque/actually-using-ed/
004145r 3               ;   http://www.psue.uni-hannover.de/wise2017_2018/material/ed.pdf
004145r 3               
004145r 3               ; We start editor from Forth with
004145r 3               ;
004145r 3               ;       ed ( -- addr u )
004145r 3               ;
004145r 3               ; The return values ( addr u ) are the address and length of the text written.
004145r 3               ; If no text was written, u is zero and addr is undefined.
004145r 3               
004145r 3               ; In the working memory, the text is stored as a simple linked list of lines.
004145r 3               ; Each node consists of three 16-bit entries:
004145r 3               
004145r 3               ;       - pointer to next entry (0 for end of list)
004145r 3               ;       - pointer to beginning of string ( addr )
004145r 3               ;       - length of string ( u )
004145r 3               
004145r 3               ; The editor only works in interaction with slow humans, so speed is not
004145r 3               ; a primary concern. We try to keep the size down instead.
004145r 3               
004145r 3               ; Where to put variables is a bit of a problem. To convert the numbers, we need
004145r 3               ; UM/MOD, which uses the scratchpad, and ACCEPT uses tmp1, tmp2, and tmp3 at
004145r 3               ; some point, so we either have to pay very close attention, or we do something
004145r 3               ; else. After some experimenting, it seems that the easiest way for this sort
004145r 3               ; of hybrid Forth/assembler system is to keep the parameters for the commands
004145r 3               ; on the Data Stack in the form of ( para1 para2 ):
004145r 3               
004145r 3               ;       TOS: parameter 2 (after the comma)
004145r 3               ;       NOS: parameter 1 (before the comma)
004145r 3               
004145r 3               ; The third and fourth entries on the stack are the ( addr-t u-t ) entries the
004145r 3               ; text will be/has been written to, or u as 0 if nothing was defined.
004145r 3               
004145r 3               ; We also need a pointer to the beginning of the text (first node of the list),
004145r 3               ; the number of the current line, and a flag to mark if the text has been
004145r 3               ; changed. We have six bytes of zero page reserved for any editor to use. Note
004145r 3               ; that this means that we can't use two editors at the same time, which won't
004145r 3               ; be a problem until we can multitask.
004145r 3               
004145r 3               ed_head =  editor1  ; pointer to first list element (addr) (2 bytes)
004145r 3               ed_cur =   editor2  ; current line number (1 is first line) (2 bytes)
004145r 3               ed_flags = editor3  ; Flags used by ed, where
004145r 3               ;       bit 7 parameters - 0: none, 1: have at least one parameter
004145r 3               ;       bit 6 changed    - 0: text not changed, 1: text was changed
004145r 3               ;       bit 0 printing   - 0: no line numbers (p), 1: with line numbers (n)
004145r 3               
004145r 3               ;  Byte editor3+1 is currently unused
004145r 3               
004145r 3               
004145r 3               ed6502:
004145r 3                               ; Start a new empty linked list at HERE. This is also
004145r 3                               ; the current line
004145r 3  64 2E                        stz ed_head
004147r 3  64 2F                        stz ed_head+1
004149r 3               
004149r 3                               ; The current line is 0, because we start counting at
004149r 3                               ; line 1 for the humans
004149r 3  64 30                        stz ed_cur
00414Br 3  64 31                        stz ed_cur+1
00414Dr 3               
00414Dr 3                               ; At the beginning, we have no parameters (bit 7), no line
00414Dr 3                               ; numbers (bit 0), and nothing was changed (bit 6)
00414Dr 3  64 32                        stz ed_flags
00414Fr 3               
00414Fr 3                               ; We put zeros as placeholders for the text we've written to
00414Fr 3                               ; (the "target") on the stack. Because the stack picture is
00414Fr 3                               ; going to get very confusing very fast, we'll mark them
00414Fr 3                               ; specially with "-t" suffixes in the stack comments.
00414Fr 3  20 rr rr                     jsr xt_zero
004152r 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t )
004155r 3               
004155r 3  20 rr rr                     jsr xt_cr
004158r 3               
004158r 3               _input_loop:
004158r 3                               ; Set parameter flag to none (bit 7); default printing is
004158r 3                               ; without line numbers (bit 0). We leave the changed flag (bit
004158r 3                               ; 6) because we might be coming from a previous add
004158r 3  A9 81                        lda #%10000001
00415Ar 3  14 32                        trb ed_flags
00415Cr 3               
00415Cr 3                               ; We really don't want to have to write a complete
00415Cr 3                               ; parser for such a simple editor, so we walk through the
00415Cr 3                               ; possibilities the hard way. Get input from the user. This
00415Cr 3                               ; routine handles any errors from REFILL
00415Cr 3  20 rr rr                     jsr _get_input
00415Fr 3               
00415Fr 3                               ; If we were not given an empty line, see what we were given
00415Fr 3  A5 0A                        lda ciblen
004161r 3  D0 1F                        bne _command_mode
004163r 3               
004163r 3                               ; We were given an empty line. Advance one line, print it, and
004163r 3                               ; make it the new current line
004163r 3  CA                           dex
004164r 3  CA                           dex                     ; ( addr-t u-t ? )
004165r 3               
004165r 3  A5 30                        lda ed_cur
004167r 3  95 00                        sta 0,x
004169r 3  A5 31                        lda ed_cur+1
00416Br 3  95 01                        sta 1,x                 ; ( addr-t u-t u )
00416Dr 3               
00416Dr 3                               ; This counts as having a parameter
00416Dr 3  A9 80                        lda #%10000000
00416Fr 3  04 32                        tsb ed_flags
004171r 3               
004171r 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t u+1 )
004174r 3  20 rr rr                     jsr _is_valid_line
004177r 3  B0 03                        bcs @1
004179r 3               
004179r 3                               ; New line number is not legal, abort
004179r 3  4C rr rr                     jmp _error_1drop
00417Cr 3               @1:
00417Cr 3                               ; We have a legal line number, but we need two entries on
00417Cr 3                               ; the parameter list (four if you count the target
00417Cr 3                               ; address) to be able to work with the rest of the program.
00417Cr 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t u+1 0 )
00417Fr 3               
00417Fr 3  4C rr rr                     jmp _line_number_only_from_external
004182r 3               
004182r 3               _command_mode:
004182r 3               
004182r 3                               ; We were given something other than an empty line. Set the
004182r 3                               ; parameter variables to zero as the default. There is no line
004182r 3                               ; zero, because we're coding for normal, sane humans, not weird
004182r 3                               ; computer people. Some commands like "a" will take a "line 0",
004182r 3                               ; however. We use the ed_flags bit 7 to signal if we are
004182r 3                               ; without parameters.
004182r 3  20 rr rr                     jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
004185r 3  20 rr rr                     jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
004188r 3               
004188r 3                               ; We start off by taking care of any parameters. These can be
004188r 3                               ; '%' for the complete text, '$' for the last line, a line
004188r 3                               ; number, or a line number followed by a ',' and then either
004188r 3                               ; the '$' for the last line or another number. (The original
004188r 3                               ; Unix ed has more options, but we're ignoring them for the
004188r 3                               ; moment.) In pseudocode, what we are doing in this stage looks
004188r 3                               ; something like this:
004188r 3               
004188r 3                               ;        case char = '.':
004188r 3                               ;              para1 = current line
004188r 3                               ;
004188r 3                               ;        case char = '$':
004188r 3                               ;              para1 = last line
004188r 3                               ;
004188r 3                               ;        case char = '%' or ',':
004188r 3                               ;              para1 = 1
004188r 3                               ;              para2 = last line
004188r 3                               ;
004188r 3                               ;        case char = ';':
004188r 3                               ;              para1 = current line
004188r 3                               ;              para2 = last line
004188r 3                               ;
004188r 3                               ;        case number:
004188r 3                               ;              para1 = number
004188r 3                               ;              get next char
004188r 3                               ;
004188r 3                               ;              if char = ',':
004188r 3                               ;                      get next char
004188r 3                               ;
004188r 3                               ;                      case char = '$':
004188r 3                               ;                              para2 = last line
004188r 3                               ;
004188r 3                               ;                      case number:
004188r 3                               ;                              para2 = number
004188r 3                               ;
004188r 3                               ;                      else error
004188r 3                               ;
004188r 3                               ;              else get previous char
004188r 3                               ;
004188r 3                               ;        else error
004188r 3                               ;
004188r 3                               ;        get next char
004188r 3                               ;        process command char
004188r 3               
004188r 3                               ; We use the Y register as an offset to the beginning of the
004188r 3                               ; character input buffer (cib) because we're never going to
004188r 3                               ; have more than 255 characters of input with ed and we don't
004188r 3                               ; want to have to duplicate the complete machinery required for
004188r 3                               ; >IN. In other words, >IN has no meaning for ed. This means
004188r 3                               ; that every jmp to _check_command must have Y in a defined
004188r 3                               ; state, which is different from the rest of Tali Forth.
004188r 3               
004188r 3                               ; Parameter processing could probably be handled more
004188r 3                               ; efficiently with a loop construct similar to the way the
004188r 3                               ; commands are taken care of below. We'll revisit this once ed
004188r 3                               ; is feature complete, because of the evils of premature
004188r 3                               ; optimization.
004188r 3               
004188r 3               _prefix_dot:
004188r 3                               ; --- . --- Designate current line for further operations
004188r 3  B2 08                        lda (cib)
00418Ar 3  C9 2E                        cmp #$2e                ; ASCII '.'
00418Cr 3  D0 3A                        bne _prefix_dollar
00418Er 3               
00418Er 3  20 rr rr                     jsr _have_text
004191r 3               
004191r 3  A5 30                        lda ed_cur
004193r 3  95 02                        sta 2,x
004195r 3  A5 31                        lda ed_cur+1
004197r 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
004199r 3               
004199r 3                               ; We have a parameter
004199r 3  A9 80                        lda #%10000000
00419Br 3  04 32                        tsb ed_flags
00419Dr 3               
00419Dr 3                               ; If we were only given a '.', we print the current line and are
00419Dr 3                               ; done
00419Dr 3  A5 0A                        lda ciblen
00419Fr 3  3A                           dec                     ; sets Z if A was 1
0041A0r 3  D0 03                        bne @1
0041A2r 3               
0041A2r 3                               ; We know that we have some text and the number of the last
0041A2r 3                               ; line was provided by _last_line, so in theory we don't have
0041A2r 3                               ; to check if this is a legal line number. However, we keep one
0041A2r 3                               ; entry point, so the check is repeated further down. Call it
0041A2r 3                               ; paranoia.
0041A2r 3  4C rr rr                     jmp _line_number_only_from_external
0041A5r 3               @1:
0041A5r 3                               ; We have processed the first parameter, and know that we have
0041A5r 3                               ; more than just a dot here. We now need to see if the next
0041A5r 3                               ; character is a comma or a command character. To do this, we
0041A5r 3                               ; need to modify the stack to ( addr-t u-t para1 0 addr u )
0041A5r 3  CA                           dex
0041A6r 3  CA                           dex
0041A7r 3  CA                           dex
0041A8r 3  CA                           dex
0041A9r 3               
0041A9r 3  A5 08                        lda cib
0041ABr 3  95 02                        sta 2,x
0041ADr 3  A5 09                        lda cib+1
0041AFr 3  95 03                        sta 3,x
0041B1r 3               
0041B1r 3  A5 0A                        lda ciblen
0041B3r 3  95 00                        sta 0,x
0041B5r 3  A5 0B                        lda ciblen+1
0041B7r 3  95 01                        sta 1,x
0041B9r 3               
0041B9r 3  20 rr rr                     jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
0041BCr 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
0041BFr 3  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
0041C2r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
0041C5r 3               
0041C5r 3  4C rr rr                     jmp _check_for_para2
0041C8r 3               
0041C8r 3               _prefix_dollar:
0041C8r 3                               ; --- $ --- Designate last line for further operations
0041C8r 3  B2 08                        lda (cib)
0041CAr 3  C9 24                        cmp #'$'
0041CCr 3  D0 1C                        bne _prefix_percent
0041CEr 3               
0041CEr 3  20 rr rr                     jsr _have_text
0041D1r 3               
0041D1r 3  E8                           inx
0041D2r 3  E8                           inx                     ; ( addr-t u-t 0 )
0041D3r 3               
0041D3r 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t 0 para1 )
0041D6r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
0041D9r 3               
0041D9r 3                               ; We have a parameter
0041D9r 3  A9 80                        lda #%10000000
0041DBr 3  04 32                        tsb ed_flags
0041DDr 3               
0041DDr 3                               ; If we were only given a '$', we print the last line and are
0041DDr 3                               ; done
0041DDr 3  A5 0A                        lda ciblen
0041DFr 3  3A                           dec                     ; sets Z if A was 1
0041E0r 3  D0 03                        bne @1
0041E2r 3               
0041E2r 3                               ; We know that we have some text and the number of the last
0041E2r 3                               ; line was provided by _last_line, so in theory we don't have
0041E2r 3                               ; to check if this is a legal line number. However, we keep one
0041E2r 3                               ; entry point for the moment and repeat the check further down
0041E2r 3                               ; out of paranoia
0041E2r 3  4C rr rr                     jmp _line_number_only_from_external
0041E5r 3               @1:
0041E5r 3                               ; We are one character into the input buffer cib, so we advance
0041E5r 3                               ; Y as the index accordingly
0041E5r 3  A0 01                        ldy #01
0041E7r 3               
0041E7r 3  4C rr rr                     jmp _check_command
0041EAr 3               
0041EAr 3               _prefix_percent:
0041EAr 3                               ; --- % and , --- Designate whole text for futher operations
0041EAr 3  B2 08                        lda (cib)
0041ECr 3  C9 25                        cmp #$25                ; ASCII '%'
0041EEr 3  F0 04                        beq _whole_text
0041F0r 3  C9 2C                        cmp #$2c                ; ASCII ','
0041F2r 3  D0 17                        bne _prefix_semicolon
0041F4r 3               
0041F4r 3               _whole_text:
0041F4r 3                               ; If there is no text yet, print an error
0041F4r 3  20 rr rr                     jsr _have_text
0041F7r 3               
0041F7r 3                               ; We have at least one line of text. The first parameter
0041F7r 3                               ; is therefore line one, the second the last line
0041F7r 3  A9 01                        lda #01
0041F9r 3  95 02                        sta 2,x                 ; LSB of NOS is para 1
0041FBr 3  74 03                        stz 3,x                 ; ( addr-t u-t para1 0 )
0041FDr 3               
0041FDr 3               _semicolon_entry:
0041FDr 3                               ; Get the number (not the address) of the last line and
0041FDr 3                               ; store it as the second parameter
0041FDr 3  E8                           inx
0041FEr 3  E8                           inx                     ; DROP ( addr-t u-t para1 )
0041FFr 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
004202r 3               
004202r 3                               ; We have a parameter
004202r 3  A9 80                        lda #%10000000
004204r 3  04 32                        tsb ed_flags
004206r 3               
004206r 3                               ; We are one character into the input buffer cib, so we advance
004206r 3                               ; Y as the index accordingly
004206r 3  A0 01                        ldy #01
004208r 3               
004208r 3  4C rr rr                     jmp _check_command
00420Br 3               
00420Br 3               _prefix_semicolon:
00420Br 3                               ; --- ; --- Designate from current line to end of text
00420Br 3  B2 08                        lda (cib)
00420Dr 3  C9 3B                        cmp #$3b                ; ASCII ';'
00420Fr 3  D0 0D                        bne _prefix_number
004211r 3               
004211r 3  20 rr rr                     jsr _have_text
004214r 3               
004214r 3                               ; The first parameter is the current line
004214r 3  A5 30                        lda ed_cur
004216r 3  95 02                        sta 2,x
004218r 3  A5 31                        lda ed_cur+1
00421Ar 3  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
00421Cr 3               
00421Cr 3                               ; The second parameter is the last line. We've done this part
00421Cr 3                               ; before for the '%' and ',' parameters, so we reuse that code
00421Cr 3  80 DF                        bra _semicolon_entry
00421Er 3               
00421Er 3               _prefix_number:
00421Er 3                               ; --- <NUM> --- Check if we have been given a number
00421Er 3               
00421Er 3                               ; We use the built-in Forth routines for this, which involves
00421Er 3                               ; calling >NUMBER, which calls UM*, which uses tmp1, tmp2, and
00421Er 3                               ; tmp3. So we can't use any of those temporary variables. We
00421Er 3                               ; arrive here with ( addr-t u-t 0 0 ), which doesn't help us at
00421Er 3                               ; all because the string we are looking at is in ( cib ciblen )
00421Er 3               
00421Er 3                               ; Set up >NUMBER using CIB and CIBLEN as the location of the
00421Er 3                               ; string to check. First, though, add the "accumulator" of
00421Er 3                               ; >NUMBER as a double number, that is, to single-cell numbers
00421Er 3  20 rr rr                     jsr xt_zero
004221r 3  20 rr rr                     jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
004224r 3               
004224r 3  CA                           dex
004225r 3  CA                           dex
004226r 3  CA                           dex
004227r 3  CA                           dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
004228r 3               
004228r 3  A5 08                        lda cib
00422Ar 3  95 02                        sta 2,x
00422Cr 3  A5 09                        lda cib+1
00422Er 3  95 03                        sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
004230r 3               
004230r 3  A5 0A                        lda ciblen
004232r 3  95 00                        sta 0,x
004234r 3  A5 0B                        lda ciblen+1
004236r 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
004238r 3               
004238r 3  20 rr rr                     jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
00423Br 3               
00423Br 3                               ; If we converted all the characters in the string (u2 is
00423Br 3                               ; zero), then the user just gave us a line number to
00423Br 3                               ; jump to and nothing else. Otherwise, take another look
00423Br 3  B5 00                        lda 0,x
00423Dr 3  15 01                        ora 1,x
00423Fr 3  D0 24                        bne _have_unconverted_chars
004241r 3               
004241r 3                               ; We must have a line number and nothing else. Make this
004241r 3                               ; the current line number and print the line. Remember
004241r 3                               ; that at this point, the line number still could be a zero
004241r 3  E8                           inx
004242r 3  E8                           inx
004243r 3  E8                           inx
004244r 3  E8                           inx                     ; 2DROP ( addr-t u-t 0 0 ud )
004245r 3               
004245r 3  20 rr rr                     jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
004248r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
00424Br 3               
00424Br 3  E8                           inx
00424Cr 3  E8                           inx                     ; ( addr-t u-t u 0 ) drop through
00424Dr 3               
00424Dr 3               _line_number_only_from_external:
00424Dr 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t 0 u )
004250r 3               
004250r 3  20 rr rr                     jsr _is_valid_line
004253r 3  B0 03                        bcs @1
004255r 3               
004255r 3                               ; This is not a valid line number, so we bail
004255r 3  4C rr rr                     jmp _error_2drop
004258r 3               @1:
004258r 3                               ; Legal line number, so make it the current number
004258r 3  20 rr rr                     jsr xt_swap             ; ( addr-t u-t u 0 )
00425Br 3  20 rr rr                     jsr _para1_to_cur
00425Er 3               
00425Er 3                               ; We have a parameter
00425Er 3  A9 80                        lda #%10000000
004260r 3  04 32                        tsb ed_flags
004262r 3               
004262r 3  4C rr rr                     jmp _cmd_p_from_external
004265r 3               
004265r 3               _have_unconverted_chars:
004265r 3                               ; We have some unconverted characters left. If none of the
004265r 3                               ; characters were converted, we probably just got a
004265r 3                               ; command character and need to skip the rest of the prefix
004265r 3                               ; processing. In this case, the number of unconverted
004265r 3                               ; characters is equal to the length of the string.
004265r 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
004268r 3               
004268r 3  CA                           dex
004269r 3  CA                           dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
00426Ar 3               
00426Ar 3  A5 0A                        lda ciblen
00426Cr 3  95 00                        sta 0,x
00426Er 3  A5 0B                        lda ciblen+1
004270r 3  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
004272r 3               
004272r 3  20 rr rr                     jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
004275r 3               
004275r 3  B5 00                        lda 0,x
004277r 3  15 01                        ora 1,x
004279r 3  F0 0E                        beq _no_command_yet
00427Br 3               
00427Br 3                               ; The length of the input string is equal to the length of the
00427Br 3                               ; unprocessed string that >NUMBER returned. Put differently,
00427Br 3                               ; the first character isn't a number. We know that it isn't '$'
00427Br 3                               ; or '%' either, so we assume that it's a command character.
00427Br 3               
00427Br 3                               ; Clear up the stack and process that command character
00427Br 3  8A                           txa
00427Cr 3  18                           clc
00427Dr 3  69 0A                        adc #10
00427Fr 3  AA                           tax                     ; ( addr-t u-t 0 0 )
004280r 3               
004280r 3                               ; If we weren't given a number, this means we didn't explicitly
004280r 3                               ; get a 0 either. So we don't have a parameter. This is the
004280r 3                               ; default case, but out of paranoia we explicity clear the flag
004280r 3  A9 80                        lda #%10000000
004282r 3  14 32                        trb ed_flags
004284r 3               
004284r 3                               ; We don't have any offset, so we go with Y as zero
004284r 3  A0 00                        ldy #00
004286r 3               
004286r 3  4C rr rr                     jmp _check_command
004289r 3               
004289r 3               _no_command_yet:
004289r 3                               ; There actually seems to be a parameter number present.
004289r 3                               ; Save the number we converted as the first parameter. We
004289r 3                               ; arrive here with ( addr-t u-t 0 0 ud addr2 u2 f ) from
004289r 3                               ; >NUMBER. To avoid too long stack comments, we leave the
004289r 3                               ; target addresses out in this next code segment.
004289r 3  E8                           inx
00428Ar 3  E8                           inx                     ; ( ... 0 0 ud addr2 u2 )
00428Br 3               
00428Br 3  20 rr rr                     jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
00428Er 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
004291r 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
004294r 3               
004294r 3  B5 00                        lda 0,x                 ; LSB
004296r 3  95 06                        sta 6,x
004298r 3  B5 01                        lda 1,x                 ; MSB
00429Ar 3  95 07                        sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
00429Cr 3               
00429Cr 3  E8                           inx
00429Dr 3  E8                           inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
00429Er 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
0042A1r 3               
0042A1r 3                               ; We have a parameter
0042A1r 3  A9 80                        lda #%10000000
0042A3r 3  04 32                        tsb ed_flags
0042A5r 3               
0042A5r 3               _check_for_para2:
0042A5r 3                               ; That was the first parameter. If the next character is
0042A5r 3                               ; a comma, then there is a second parameter (another number
0042A5r 3                               ; or '$'). Otherwise we expect a command. This is the entry
0042A5r 3                               ; point if the first character was a dot (eg '.,3p')
0042A5r 3  A1 02                        lda (2,x)
0042A7r 3               
0042A7r 3  C9 2C                        cmp #$2c                ; ASCII code for ',' (comma)
0042A9r 3  F0 0D                        beq _got_comma
0042ABr 3               
0042ABr 3                               ; It's not a comma, so it's going to be a command character.
0042ABr 3                               ; We need to figure out how many digits our number has so
0042ABr 3                               ; we can adjust Y as the offset. We don't have to do this with
0042ABr 3                               ; 16 bit because no input string is going to be that long
0042ABr 3  38                           sec
0042ACr 3  A5 0A                        lda ciblen
0042AEr 3  F5 00                        sbc 0,x
0042B0r 3  A8                           tay
0042B1r 3               
0042B1r 3                               ; Remove the leftover stuff from >NUMBER
0042B1r 3  E8                           inx
0042B2r 3  E8                           inx
0042B3r 3  E8                           inx
0042B4r 3  E8                           inx                     ; 2DROP ( addr-t u-t para1 0 )
0042B5r 3               
0042B5r 3  4C rr rr                     jmp _check_command
0042B8r 3               
0042B8r 3               _got_comma:
0042B8r 3                               ; It's a comma, so we have a second parameter. The next
0042B8r 3                               ; character can either be '$' to signal the end of the text
0042B8r 3                               ; or another number. First, though, move to that next char
0042B8r 3  F6 02                        inc 2,x
0042BAr 3  D0 02                        bne @1
0042BCr 3  F6 03                        inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
0042BEr 3               @1:
0042BEr 3  B5 01                        lda 1,x
0042C0r 3  F0 02                        beq @2
0042C2r 3  D6 01                        dec 1,x
0042C4r 3               @2:
0042C4r 3  D6 00                        dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
0042C6r 3               
0042C6r 3                               ; See if this is an end-of-line '$'
0042C6r 3  A1 02                        lda (2,x)
0042C8r 3  C9 24                        cmp #$24                ; ASCII for '$'
0042CAr 3  D0 14                        bne _para2_not_dollar
0042CCr 3               
0042CCr 3                               ; It's a dollar sign, which means para2 is the number of the
0042CCr 3                               ; last line of the text. We need to adjust Y as the offset. We
0042CCr 3                               ; assume that no command line will be longer than 255
0042CCr 3                               ; characters in ed so we can get away with just looking at
0042CCr 3                               ; the LSB
0042CCr 3  38                           sec
0042CDr 3  A5 0A                        lda ciblen
0042CFr 3  F5 02                        sbc 2,x
0042D1r 3  A8                           tay
0042D2r 3               
0042D2r 3                               ; However, we need to move Y up by one because we were on the
0042D2r 3                               ; '$' and not on the character after that
0042D2r 3  C8                           iny
0042D3r 3  5A                           phy
0042D4r 3               
0042D4r 3                               ; Dump all the stuff from >NUMBER off the stack. This saves
0042D4r 3                               ; one byte compared to six INX instructions, and a byte saved
0042D4r 3                               ; is a byte earned.
0042D4r 3  8A                           txa
0042D5r 3  18                           clc
0042D6r 3  69 06                        adc #06
0042D8r 3  AA                           tax                     ; ( addr-t u-t para1 )
0042D9r 3               
0042D9r 3  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
0042DCr 3               
0042DCr 3  7A                           ply
0042DDr 3  4C rr rr                     jmp _check_command
0042E0r 3               
0042E0r 3               _para2_not_dollar:
0042E0r 3                               ; It's not a dollar sign, so it is either another number or an
0042E0r 3                               ; error. We try for a number first. We arrive here with ( para1
0042E0r 3                               ; 0 addr2+1 u2-1 ), which u2-1 pointing to the first mystery
0042E0r 3                               ; character after the comma. Again, we skip the ( addr-t u-t )
0042E0r 3                               ; at the beginning of the stack comment here.
0042E0r 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
0042E3r 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
0042E6r 3  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
0042E9r 3  20 rr rr                     jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
0042ECr 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
0042EFr 3               
0042EFr 3                               ; We'll need a copy of the length of the rest of the string to
0042EFr 3                               ; see if we've actually done any work
0042EFr 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
0042F2r 3  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
0042F5r 3               
0042F5r 3  20 rr rr                     jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
0042F8r 3               
0042F8r 3                               ; If the original string and the leftover string have the same
0042F8r 3                               ; length, then nothing was converted and we have an error
0042F8r 3  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
0042FBr 3  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
0042FEr 3  20 rr rr                     jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
004301r 3               
004301r 3  B5 00                        lda 0,x
004303r 3  15 01                        ora 1,x
004305r 3  F0 08                        beq _second_number
004307r 3               
004307r 3                               ; The strings are the same length, so nothing was converted, so
004307r 3                               ; we have an error. We have to get all that stuff off the
004307r 3                               ; stack first
004307r 3  8A                           txa
004308r 3  18                           clc
004309r 3  69 0C                        adc #12
00430Br 3  AA                           tax                     ; back to ( addr-t u-t )
00430Cr 3               
00430Cr 3  4C rr rr                     jmp _error
00430Fr 3               
00430Fr 3               _second_number:
00430Fr 3                               ; We have a second number, so we add it to para2. We arrive here
00430Fr 3                               ; with ( para1 0 ud addr3 u3 f )
00430Fr 3  E8                           inx
004310r 3  E8                           inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
004311r 3               
004311r 3                               ; Calculate the offset for Y
004311r 3  38                           sec
004312r 3  A5 0A                        lda ciblen
004314r 3  F5 00                        sbc 0,x
004316r 3  48                           pha
004317r 3               
004317r 3                               ; Clean up the stack
004317r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
00431Ar 3  20 rr rr                     jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
00431Dr 3  20 rr rr                     jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
004320r 3               
004320r 3  7A                           ply
004321r 3               
004321r 3                               ; fall through to _check_command
004321r 3               
004321r 3               _check_command:
004321r 3                               ; At this point, we assume that we have handled any parameters
004321r 3                               ; which are now in their place on the stack, which must have
004321r 3                               ; the format ( addr-t u-t para1 para2 ). Also, any offset to CIB
004321r 3                               ; is going to be in Y. Bit 7 in ed_flags signals if we have
004321r 3                               ; a parameter or not.
004321r 3               
004321r 3                               ; Command character checking works by comparing the char we
004321r 3                               ; have at CIB+Y with a list of legal characters. The index in
004321r 3                               ; the list is the index of the command's routine in a jump
004321r 3                               ; table. The list itself is zero-terminated, which is okay
004321r 3                               ; because we've taken care of any legal parameters.
004321r 3  B1 08                        lda (cib),y             ; get mystery char from input
004323r 3  85 24                        sta tmp1
004325r 3               
004325r 3                               ; We're going to need X for the jump table, so it has to
004325r 3                               ; take a break from being the Data Stack Pointer (DSP). Pushing
004325r 3                               ; X to the stack uses less space than storing in the reserved
004325r 3                               ; space on the Zero Page
004325r 3  DA                           phx
004326r 3  A2 00                        ldx #00
004328r 3               _cmd_loop:
004328r 3  BD rr rr                     lda ed_cmd_list,x
00432Br 3  F0 07                        beq _illegal_command    ; zero marks end of list
00432Dr 3               
00432Dr 3  C5 24                        cmp tmp1
00432Fr 3  F0 07                        beq _found_cmd
004331r 3               
004331r 3                               ; No match, next char
004331r 3  E8                           inx
004332r 3  80 F4                        bra _cmd_loop
004334r 3               
004334r 3               _illegal_command:
004334r 3                               ; Whatever the user gave us, we don't recognize it
004334r 3  FA                           plx
004335r 3               
004335r 3  4C rr rr                     jmp _error_2drop
004338r 3               
004338r 3               _found_cmd:
004338r 3                               ; We have a command match. Because this is the 65c02 and not
004338r 3                               ; the 65816, we can only use JMP (addr,x) and not a subroutine
004338r 3                               ; jump. That sucks.
004338r 3  8A                           txa
004339r 3  0A                           asl
00433Ar 3  AA                           tax                     ; X * 2 for table
00433Br 3               
00433Br 3                               ; Note we're jumping with the DSP still on the stack, so each
00433Br 3                               ; command routine has to pull it into X the very first thing
00433Br 3                               ; with its very own PLX. There doesn't seem to be a sane way to
00433Br 3                               ; avoid this.
00433Br 3  7C rr rr                     jmp (ed_cmd_table,x)
00433Er 3               
00433Er 3               _next_command:
00433Er 3                               ; Clean up the stack and return to the input loop. We
00433Er 3                               ; arrive here with ( addr-t u-t para1 para2 ). The called
00433Er 3                               ; command routines have taken care of putting the DSP (that's
00433Er 3                               ; X) back the way it should be
00433Er 3  E8                           inx
00433Fr 3  E8                           inx
004340r 3  E8                           inx
004341r 3  E8                           inx                     ; ( addr-t u-t ) Fall through
004342r 3               
004342r 3               _next_command_empty:
004342r 3                               ; The beginning of the input loop takes care of resetting the
004342r 3                               ; parameter flag
004342r 3  4C rr rr                     jmp _input_loop
004345r 3               
004345r 3               _all_done:
004345r 3                               ; That's enough for ed today. We have to clear out the input
004345r 3                               ; buffer or else the Forth main main loop will react to the
004345r 3                               ; last input command
004345r 3  64 0A                        stz ciblen
004347r 3  64 0B                        stz ciblen+1
004349r 3               
004349r 3                               ; Clean up the stack
004349r 3  20 rr rr                     jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
00434Cr 3               
00434Cr 3  60                           rts
00434Dr 3               
00434Dr 3               
00434Dr 3               ; === COMMAND ROUTINES ====
00434Dr 3               
00434Dr 3               ; We enter all command subroutines with ( addr-t u-t para1 para2 ) and the DSP
00434Dr 3               ; still on the Return Stack. This means that the first oder of business is to
00434Dr 3               ; restore the DSP with PLX -- remember this when you add new commands. At this
00434Dr 3               ; point, we don't need the offset in Y anymore so we are free to use it as we
00434Dr 3               ; please.
00434Dr 3               
00434Dr 3               ; There is potential to rewrite many of the command routines with an abstract
00434Dr 3               ; construct in the form of (pseudocode):
00434Dr 3               
00434Dr 3               ;       f = cmd         ; command such as d, p, n, as a function
00434Dr 3               ;       map f range(para1, para2)
00434Dr 3               
00434Dr 3               ; That is, have one routine with a looping structure and pass the actual work
00434Dr 3               ; as a function. However, this is 8-bit assembler and not, say, Haskell, so
00434Dr 3               ; that abstraction will wait for a future round of refracturing when we have
00434Dr 3               ; everything complete and working.
00434Dr 3               
00434Dr 3               ; -------------------------
00434Dr 3               _cmd_a:
00434Dr 3                       ; a -- Add text after current/given line. If no line is given, we use
00434Dr 3                       ; the current line. We accept the number '0' and then start adding at
00434Dr 3                       ; the very beginning. The second parameter is always ignored. This
00434Dr 3                       ; routine is used by i as well.
00434Dr 3  FA                           plx
00434Er 3               
00434Er 3                               ; We don't care about para2, because a just adds stuff starting
00434Er 3                               ; the line we were given
00434Er 3  E8                           inx
00434Fr 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
004350r 3               
004350r 3                               ; If we weren't given a parameter, make the current line the
004350r 3                               ; parameter
004350r 3  24 32                        bit ed_flags
004352r 3  30 08                        bmi _cmd_a_have_para
004354r 3               
004354r 3  A5 30                        lda ed_cur
004356r 3  95 00                        sta 0,x
004358r 3  A5 31                        lda ed_cur+1
00435Ar 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
00435Cr 3               
00435Cr 3               _entry_cmd_i:
00435Cr 3                               ; This is where i enters with a parameter that is calculated to
00435Cr 3                               ; be one before the current line, or given line, or so that we
00435Cr 3                               ; accept 0. We are ( addr-t u-t num )
00435Cr 3               
00435Cr 3               _cmd_a_have_para:
00435Cr 3  20 rr rr                     jsr _num_to_addr        ;  ( addr-t u-t addr1 )
00435Fr 3  20 rr rr                     jsr xt_cr
004362r 3               
004362r 3               _next_string_loop:
004362r 3                               ; This is where we land when we are continuing in with another
004362r 3                               ; string after the first one. ( addr-t u-t addr1 )
004362r 3  20 rr rr                     jsr _get_input
004365r 3               
004365r 3                               ; If there is only one character and that character is a
004365r 3                               ; dot, we're done with adding text and switch back to command
004365r 3                               ; mode
004365r 3  B2 08                        lda (cib)
004367r 3  C9 2E                        cmp #$2e                ; ASCII for '.'
004369r 3  D0 16                        bne _add_line
00436Br 3               
00436Br 3                               ; So it's a dot, but that the only character in the line?
00436Br 3                               ; We want the length to be one character exactly
00436Br 3  A4 0A                        ldy ciblen
00436Dr 3  C0 01                        cpy #01
00436Fr 3  D0 10                        bne _add_line
004371r 3               
004371r 3  A4 0B                        ldy ciblen+1
004373r 3  D0 0C                        bne _add_line
004375r 3               
004375r 3                               ; Yes, it is a dot, so we're done adding lines.
004375r 3  E8                           inx
004376r 3  E8                           inx
004377r 3               
004377r 3                               ; The string is stored and the new node is full. Time to set the
004377r 3                               ; changed flag
004377r 3  A9 40                        lda #%01000000
004379r 3  04 32                        tsb ed_flags
00437Br 3               
00437Br 3  20 rr rr                     jsr xt_cr
00437Er 3  4C rr rr                     jmp _input_loop
004381r 3               
004381r 3               _add_line:
004381r 3                               ; Break the linked list so we can insert another node
004381r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
004384r 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
004387r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
00438Ar 3  20 rr rr                     jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
00438Dr 3  20 rr rr                     jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
004390r 3               
004390r 3                               ; We're going to need that HERE for the next line if more
004390r 3                               ; than one line is added. This is a good time to save it on
004390r 3                               ; the stack
004390r 3  20 rr rr                     jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
004393r 3               
004393r 3                               ; We have now saved the link to the next node at HERE, which is
004393r 3                               ; where the CP was pointing. CP has been advanced by one cell,
004393r 3                               ; but we still have the original as HERE on the stack. That
004393r 3                               ; address now has to go where addr2 was before.
004393r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
004396r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
004399r 3               
004399r 3                               ; Thus concludes the mucking about with node links. Now we have
004399r 3                               ; to create a new header. The CP we access with HERE points to
004399r 3                               ; the cell after the new node address, which is where we want
004399r 3                               ; to put ( ) for the new string
004399r 3  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t here here2)
00439Cr 3               
00439Cr 3                               ; Reserve two cells (four bytes on the 65c02) for the ( addr u )
00439Cr 3                               ; of the new string
00439Cr 3  A5 00                        lda cp
00439Er 3  18                           clc
00439Fr 3  69 04                        adc #04
0043A1r 3  85 00                        sta cp
0043A3r 3  90 02                        bcc @1
0043A5r 3  E6 01                        inc cp+1
0043A7r 3               @1:
0043A7r 3                               ; HERE now points to after the new header. Since we're really
0043A7r 3                               ; going to add something, we can increase the current line
0043A7r 3                               ; number
0043A7r 3  E6 30                        inc ed_cur
0043A9r 3  D0 02                        bne @2
0043ABr 3  E6 31                        inc ed_cur+1
0043ADr 3               @2:
0043ADr 3                               ; We have the new line sitting in ( cib ciblen ) and need to
0043ADr 3                               ; a) move it somewhere safe and b) get ready for the next
0043ADr 3                               ; line. We arrive here with ( addr-t u-t here here2 ), where here2
0043ADr 3                               ; is where the new string needs to be. The MOVE command we're
0043ADr 3                               ; going to use has the format ( addr1 addr2 u )
0043ADr 3               
0043ADr 3  20 rr rr                     jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
0043B0r 3  20 rr rr                     jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
0043B3r 3               
0043B3r 3  CA                           dex
0043B4r 3  CA                           dex             ; ( addr-t u-t here here2 here3 here3 ? )
0043B5r 3  A5 08                        lda cib
0043B7r 3  95 00                        sta 0,x
0043B9r 3  A5 09                        lda cib+1
0043BBr 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
0043BDr 3               
0043BDr 3  20 rr rr                     jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
0043C0r 3               
0043C0r 3  CA                           dex
0043C1r 3  CA                           dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
0043C2r 3  A5 0A                        lda ciblen
0043C4r 3  95 00                        sta 0,x
0043C6r 3  A5 0B                        lda ciblen+1
0043C8r 3  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
0043CAr 3               
0043CAr 3  20 rr rr                     jsr xt_move     ; ( addr-t u-t here here2 here3 )
0043CDr 3               
0043CDr 3                               ; We need to adjust CP be the length of the string
0043CDr 3  18                           clc
0043CEr 3  A5 00                        lda cp
0043D0r 3  65 0A                        adc ciblen
0043D2r 3  85 00                        sta cp
0043D4r 3  90 06                        bcc @3
0043D6r 3  A5 01                        lda cp+1
0043D8r 3  65 0B                        adc ciblen+1
0043DAr 3  85 01                        sta cp+1
0043DCr 3               @3:
0043DCr 3                               ; The string is now moved safely out of the input buffer to the
0043DCr 3                               ; main memory at ( here3 ciblin ). Now we have to fix that
0043DCr 3                               ; fact in the header. We start with the address.
0043DCr 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
0043DFr 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here here2 )
0043E2r 3               
0043E2r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0043E5r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
0043E8r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
0043EBr 3               
0043EBr 3  A5 0A                        lda ciblen
0043EDr 3  95 02                        sta 2,x
0043EFr 3  A5 0B                        lda ciblen+1
0043F1r 3  95 03                        sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
0043F3r 3               
0043F3r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
0043F6r 3               
0043F6r 3                               ; Add a line feed for visuals
0043F6r 3  20 rr rr                     jsr xt_cr
0043F9r 3               
0043F9r 3                               ; Remeber that original HERE we've been dragging along all the
0043F9r 3                               ; time? Now we find out why. We return to the loop to pick up
0043F9r 3                               ; the next input
0043F9r 3  4C rr rr                     jmp _next_string_loop
0043FCr 3               
0043FCr 3               ; -------------------------
0043FCr 3               _cmd_d:
0043FCr 3                       ; d -- Delete one or more lines. This might have to be coded as
0043FCr 3                       ; a subroutine because other commands such as 'c' might be easier to
0043FCr 3                       ; implement that way. Note that a lot of this code is very similar to
0043FCr 3                       ; the loop for 'p'. We arrive here with ( addr-t u-t para1 para2 )
0043FCr 3  FA                           plx
0043FDr 3               
0043FDr 3  20 rr rr                     jsr _have_text
004400r 3  20 rr rr                     jsr _no_line_zero
004403r 3               
004403r 3                               ; At least the first line is valid. Most common case is one
004403r 3                               ; line, so we check to see if we even have a second parameter.
004403r 3  B5 00                        lda 0,x
004405r 3  15 01                        ora 1,x
004407r 3  D0 08                        bne @1
004409r 3               
004409r 3                               ; The second parameter is a zero, so delete one line
004409r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 0 para1 )
00440Cr 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
00440Fr 3  80 33                        bra _cmd_d_done
004411r 3               @1:
004411r 3                               ; We have been given a range. Make sure that the second
004411r 3                               ; parameter is legal. We arrive here with ( addr-t u-t para1 para2 )
004411r 3  20 rr rr                     jsr _is_valid_line      ; result is in C flag
004414r 3  B0 03                        bcs _cmd_d_loop
004416r 3               
004416r 3                               ; para2 is not valid. Complain and abort
004416r 3  4C rr rr                     jmp _error_2drop
004419r 3               
004419r 3               _cmd_d_loop:
004419r 3                               ; Seems to be a legal range. Walk through and delete If para1
004419r 3                               ; is larger than para2, we're done. Note that Unix ed throws an
004419r 3                               ; error if we start out that way, we might do that in future as
004419r 3                               ; well. This is not the same code as for 'p', because we have
004419r 3                               ; to delete from the back
004419r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
00441Cr 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
00441Fr 3               
00441Fr 3  B5 00                        lda 0,x
004421r 3  15 01                        ora 1,x
004423r 3  D0 0D                        bne _cmd_d_done_with_flag
004425r 3               
004425r 3                               ; Para2 is still larger or the same size as para1, so we
004425r 3                               ; continue
004425r 3  E8                           inx
004426r 3  E8                           inx                     ; Get rid of the flag from >
004427r 3               
004427r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
00442Ar 3  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
00442Dr 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
004430r 3               
004430r 3  80 E7                        bra _cmd_d_loop
004432r 3               
004432r 3               _cmd_d_done_with_flag:
004432r 3  E8                           inx                     ; ( addr-t u-t para1 para2 )
004433r 3  E8                           inx
004434r 3               
004434r 3                               ; The current line is set to the first line minus
004434r 3                               ; one. Since we don't accept '0d', this at least
004434r 3                               ; hast to be one
004434r 3  B5 02                        lda 2,x
004436r 3  D0 02                        bne @1
004438r 3  D6 03                        dec 3,x
00443Ar 3               @1:
00443Ar 3  D6 02                        dec 2,x
00443Cr 3               
00443Cr 3  B5 02                        lda 2,x
00443Er 3  85 30                        sta ed_cur
004440r 3  B5 03                        lda 3,x
004442r 3  85 31                        sta ed_cur+1            ; drop through to _cmd_d_done
004444r 3               
004444r 3               _cmd_d_done:
004444r 3                               ; Text has changed, set flag
004444r 3  A9 40                        lda #%01000000
004446r 3  04 32                        tsb ed_flags
004448r 3               
004448r 3  20 rr rr                     jsr xt_cr
00444Br 3               
00444Br 3  4C rr rr                     jmp _next_command
00444Er 3               
00444Er 3               _cmd_d_common:
00444Er 3                       ; Internal subroutine to delete a single line when given the line
00444Er 3                       ; number TOS. Consumes TOS. What we do is take the link to the next
00444Er 3                       ; node and put it in the previous node. The caller is responsible
00444Er 3                       ; for setting ed_changed. We arrive here with ( u )
00444Er 3               
00444Er 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t u u )
004451r 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t u addr )
004454r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
004457r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
00445Ar 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
00445Dr 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr1 addr-1 )
004460r 3  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t )
004463r 3               
004463r 3  60                           rts
004464r 3               
004464r 3               ; -------------------------
004464r 3               _cmd_equ:
004464r 3                       ; = --- Print the given line number or the current line number if no
004464r 3                       ; value is given. This is useful if you want to know what the number of
004464r 3                       ; the last line is ("$=")
004464r 3  FA                           plx
004465r 3               
004465r 3                               ; If we don't have a text, we follow Unix ed's example and
004465r 3                               ; print a zero. It would seem to make more sense to throw an
004465r 3                               ; error, but who are we to argue with Unix.
004465r 3  A5 2E                        lda ed_head
004467r 3  05 2F                        ora ed_head+1
004469r 3  D0 08                        bne _cmd_equ_have_text
00446Br 3               
00446Br 3                               ; Fake it: load 0 as para2 and then print. The 0 goes in a new
00446Br 3                               ; line just like with Unix ed
00446Br 3  CA                           dex
00446Cr 3  CA                           dex
00446Dr 3  74 00                        stz 0,x
00446Fr 3  74 01                        stz 1,x                 ; ( addr-t u-t para1 para2 0 )
004471r 3  80 21                        bra _cmd_equ_done
004473r 3               
004473r 3               _cmd_equ_have_text:
004473r 3                               ; We have taken care of the case where we don't have a text. If
004473r 3                               ; we have a line zero, it is explicit, and we don't do that
004473r 3  20 rr rr                     jsr _no_line_zero
004476r 3               
004476r 3                               ; If we have no parameters, just print the current line number
004476r 3  24 32                        bit ed_flags
004478r 3  30 0C                        bmi _cmd_equ_have_para
00447Ar 3               
00447Ar 3  CA                           dex
00447Br 3  CA                           dex                     ; ( addr-t u-t para1 para2 ? )
00447Cr 3  A5 30                        lda ed_cur
00447Er 3  95 00                        sta 0,x
004480r 3  A5 31                        lda ed_cur+1
004482r 3  95 01                        sta 1,x
004484r 3               
004484r 3  80 0E                        bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
004486r 3               
004486r 3               _cmd_equ_have_para:
004486r 3                               ; We have at least one parameter, and we know it is not zero.
004486r 3                               ; We follow the behavior of Unix ed here: If there is one
004486r 3                               ; parameter, we print its line number. If there are two
004486r 3                               ; separated by a comma (etc), we print the second line number
004486r 3                               ; of the range
004486r 3  B5 00                        lda 0,x
004488r 3  15 01                        ora 1,x
00448Ar 3  D0 05                        bne _cmd_equ_two_paras
00448Cr 3               
00448Cr 3                               ; We've got one parameter
00448Cr 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1)
00448Fr 3  80 03                        bra _cmd_equ_done
004491r 3               
004491r 3               _cmd_equ_two_paras:
004491r 3  20 rr rr                     jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
004494r 3               
004494r 3               _cmd_equ_done:
004494r 3  20 rr rr                     jsr xt_cr               ; number goes on new line
004497r 3  20 rr rr                     jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
00449Ar 3  20 rr rr                     jsr xt_cr
00449Dr 3               
00449Dr 3  4C rr rr                     jmp _next_command
0044A0r 3               
0044A0r 3               
0044A0r 3               ; -------------------------
0044A0r 3               _cmd_f:
0044A0r 3                       ; f -- Print the address that a write command ("w") will go to or set
0044A0r 3                       ; it. If no parameter was passed, we print the address we have on hand,
0044A0r 3                       ; with a parameter, we set that to the new address. We accept a zero,
0044A0r 3                       ; though that would be a weird place to write, but we do need a text
0044A0r 3  FA                           plx
0044A1r 3               
0044A1r 3  24 32                        bit ed_flags
0044A3r 3  30 17                        bmi _cmd_f_have_para
0044A5r 3               
0044A5r 3  20 rr rr                     jsr xt_cr
0044A8r 3               
0044A8r 3                               ; No parameters, just a naked "f", so print the address buried
0044A8r 3                               ; at the fourth position of the stack: We arrive here with
0044A8r 3                               ; ( addr-t u-t 0 0 )
0044A8r 3  20 rr rr                     jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
0044ABr 3  20 rr rr                     jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
0044AEr 3  20 rr rr                     jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
0044B1r 3  20 rr rr                     jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
0044B4r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
0044B7r 3  20 rr rr                     jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
0044BAr 3               
0044BAr 3  80 11                        bra _cmd_f_done
0044BCr 3               
0044BCr 3               _cmd_f_have_para:
0044BCr 3                               ; We do no sanity tests at all. This is Forth, if the user
0044BCr 3                               ; wants to blow up the Zero Page and the Stack, sure, go right
0044BCr 3                               ; ahead, whatever.
0044BCr 3  20 rr rr                     jsr xt_over
0044BFr 3  20 rr rr                     jsr xt_cr
0044C2r 3  20 rr rr                     jsr xt_u_dot
0044C5r 3               
0044C5r 3  B5 02                        lda 2,x
0044C7r 3  95 06                        sta 6,x
0044C9r 3  B5 03                        lda 3,x
0044CBr 3  95 07                        sta 7,x                 ; fall through to _cmd_f_done
0044CDr 3               
0044CDr 3               _cmd_f_done:
0044CDr 3  20 rr rr                     jsr xt_cr
0044D0r 3               
0044D0r 3  4C rr rr                     jmp _next_command
0044D3r 3               
0044D3r 3               
0044D3r 3               ; -------------------------
0044D3r 3               _cmd_i:
0044D3r 3                       ; i --- Add text before current line. We allow '0i' and 'i' just like
0044D3r 3                       ; the Unix ed. Note that this routine just prepares the line numbers so
0044D3r 3                       ; we can reuse most of the code from a.
0044D3r 3  FA                           plx
0044D4r 3               
0044D4r 3                               ; We don't care about para2, because i just adds stuff before
0044D4r 3                               ; the line we were given.
0044D4r 3  E8                           inx
0044D5r 3  E8                           inx                     ;  DROP ( addr-t u-t para1 )
0044D6r 3               
0044D6r 3                               ; If we weren't given a parameter, make the current line the
0044D6r 3                               ; parameter
0044D6r 3  24 32                        bit ed_flags
0044D8r 3  30 08                        bmi _cmd_i_have_para
0044DAr 3               
0044DAr 3                               ; No parameter, take current line
0044DAr 3  A5 30                        lda ed_cur
0044DCr 3  95 00                        sta 0,x
0044DEr 3  A5 31                        lda ed_cur+1
0044E0r 3  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
0044E2r 3               
0044E2r 3               _cmd_i_have_para:
0044E2r 3                               ; If the parameter is zero, we skip the next part and behave
0044E2r 3                               ; completely like the "a" command
0044E2r 3  B5 00                        lda 0,x
0044E4r 3  15 01                        ora 1,x
0044E6r 3  F0 09                        beq _cmd_i_done
0044E8r 3               
0044E8r 3                               ; We have some other line number, so we start one above it
0044E8r 3  20 rr rr                     jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
0044EBr 3  20 rr rr                     jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
0044EEr 3  20 rr rr                     jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
0044F1r 3               _cmd_i_done:
0044F1r 3  4C rr rr                     jmp _entry_cmd_i
0044F4r 3               
0044F4r 3               
0044F4r 3               ; -------------------------
0044F4r 3               _cmd_n:
0044F4r 3                       ; n -- Print lines with a line number. We just set a flag here and
0044F4r 3                       ; let p do all the heavy work.
0044F4r 3               
0044F4r 3  FA                           plx
0044F5r 3               
0044F5r 3  A9 01                        lda #%00000001
0044F7r 3  04 32                        tsb ed_flags
0044F9r 3               
0044F9r 3  80 05                        bra _cmd_p_entry_for_cmd_n
0044FBr 3               
0044FBr 3               
0044FBr 3               ; -------------------------
0044FBr 3               _cmd_p:
0044FBr 3                       ; p -- Print lines without line numbers. This routine is also used
0044FBr 3                       ; by n, the difference is in a flag. Note that this routine is
0044FBr 3                       ; able to handle line numbers greater than 255 even though it's
0044FBr 3                       ; hard to believe somebody would actually use this editor for anything
0044FBr 3                       ; that long. I'm really sure Leo Tolstoy would not have created "War
0044FBr 3                       ; and Peace" on a 65c02.
0044FBr 3               
0044FBr 3  FA                           plx
0044FCr 3               
0044FCr 3               _cmd_p_from_external:
0044FCr 3                               ; This is coming from p, the variant without line numbers. We
0044FCr 3                               ; set the ed_flags' bit 0 to zero to mark this
0044FCr 3  A9 01                        lda #%00000001
0044FEr 3  14 32                        trb ed_flags
004500r 3               
004500r 3               _cmd_p_entry_for_cmd_n:
004500r 3  20 rr rr                     jsr _have_text
004503r 3  20 rr rr                     jsr _no_line_zero
004506r 3               
004506r 3  20 rr rr                     jsr xt_cr
004509r 3               
004509r 3                               ; We now know that there is some number in para1. The most
004509r 3                               ; common case is that para2 is zero and we're being asked to
004509r 3                               ; print a single line
004509r 3  B5 00                        lda 0,x
00450Br 3  15 01                        ora 1,x
00450Dr 3  D0 08                        bne _cmd_p_loop
00450Fr 3               
00450Fr 3                               ; Print a single line and be done with it. We could use
00450Fr 3                               ; DROP here and leave immediately but we want this routine
00450Fr 3                               ; to have a single exit at the bottom.
00450Fr 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
004512r 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
004515r 3               
004515r 3  80 1E                        bra _cmd_p_all_done
004517r 3               
004517r 3               _cmd_p_loop:
004517r 3                               ; We are being asked to print more than one line, which
004517r 3                               ; is a bit trickier. If para1 is larger than para2, we're
004517r 3                               ; done. Note that Unix ed throws an error if we start out
004517r 3                               ; that way, we might do that in future as well
004517r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
00451Ar 3  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
00451Dr 3               
00451Dr 3  B5 00                        lda 0,x
00451Fr 3  15 01                        ora 1,x
004521r 3  D0 10                        bne _cmd_p_done
004523r 3               
004523r 3                               ; Para2 is still larger or the same size as para1, so we
004523r 3                               ; continue
004523r 3  E8                           inx
004524r 3  E8                           inx                     ; Get rid of the flag from >
004525r 3  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
004528r 3  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
00452Br 3               
00452Br 3  F6 02                        inc 2,x
00452Dr 3  D0 02                        bne @1
00452Fr 3  F6 03                        inc 3,x
004531r 3               @1:
004531r 3  80 E4                        bra _cmd_p_loop
004533r 3               
004533r 3               _cmd_p_done:
004533r 3                               ; We arrive here with ( addr-t u-t para1 para2 f )
004533r 3  E8                           inx
004534r 3  E8                           inx                     ; fall through to _cmp_p_all_done
004535r 3               _cmd_p_all_done:
004535r 3  4C rr rr                     jmp _next_command
004538r 3               
004538r 3               
004538r 3               _cmd_p_common:
004538r 3                       ; Internal subroutine to print a single line when given the line number
004538r 3                       ; TOS. Consumes TOS. Used by both n and p. We arrive here with
004538r 3                       ; ( addr-t u-t para1 ) as the line number
004538r 3               
004538r 3                               ; See if we're coming from p (no line numbers, ed_flag is zero)
004538r 3                               ; or from n (line numbers and a TAB, ed_flag is $FF)
004538r 3  A5 32                        lda ed_flags
00453Ar 3  4A                           lsr                     ; bit 0 now in carry
00453Br 3  90 0B                        bcc _cmd_p_common_no_num
00453Dr 3               
00453Dr 3                               ; Bit 0 is set, this is coming from n. Print the line number
00453Dr 3                               ; followed by a tab
00453Dr 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
004540r 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u-t para1 )
004543r 3               
004543r 3  A9 09                        lda #$09                 ; ASCII for Tab
004545r 3  20 rr rr                     jsr emit_a
004548r 3               
004548r 3               _cmd_p_common_no_num:
004548r 3                               ; One way or the other, print the the node's string
004548r 3  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr )
00454Br 3  20 rr rr                     jsr _print_addr
00454Er 3               
00454Er 3  60                           rts
00454Fr 3               
00454Fr 3               
00454Fr 3               ; -------------------------
00454Fr 3               _cmd_q:
00454Fr 3                       ; q -- Quit if all work as been saved, complain otherwise
00454Fr 3               
00454Fr 3  FA                           plx
004550r 3               
004550r 3  24 32                        bit ed_flags            ; bit 6 is change flag
004552r 3  50 03                        bvc @1
004554r 3  4C rr rr                     jmp _error_2drop
004557r 3               @1:
004557r 3  4C rr rr                     jmp _all_done            ; can't fall thru because of PLX
00455Ar 3               
00455Ar 3               
00455Ar 3               ; -------------------------
00455Ar 3               _cmd_qq:
00455Ar 3                       ; Q -- Quit unconditionally, dumping any work that is unsaved
00455Ar 3                       ; without any warning. We can't just jump to all done because
00455Ar 3                       ; of the PLX
00455Ar 3  FA                           plx
00455Br 3               
00455Br 3  4C rr rr                     jmp _all_done
00455Er 3               
00455Er 3               
00455Er 3               ; -------------------------
00455Er 3               _cmd_w:
00455Er 3                       ; w --- Write text to system memory. In contrast to the Unix ed word,
00455Er 3                       ; we provide the address before the command, such as "8000w". If no
00455Er 3                       ; address is given -- just 'w' -- we write to whatever was fixed with
00455Er 3                       ; 'f'. To prevent a common, but potentially common error, we do not
00455Er 3                       ; allow writing to the first page ($0000 to $00FF) unless the address
00455Er 3                       ; was specificially passed as a parameter. Currently, we can only enter
00455Er 3                       ; the address in decimal.
00455Er 3  FA                           plx
00455Fr 3               
00455Fr 3  20 rr rr                     jsr _have_text
004562r 3               
004562r 3  24 32                        bit ed_flags
004564r 3  30 13                        bmi _cmd_w_have_para
004566r 3               
004566r 3                               ; If we don't have a parameter, we check what is stored on the
004566r 3                               ; stack and use that address -- UNLESS IT IS 0000, which is
004566r 3                               ; what it would be if the user wasn't thinking and just pressed
004566r 3                               ; 'w' at the beginning. We arrive here with ( addr-t u-t 0 0 )
004566r 3  B5 06                        lda 6,x
004568r 3  15 07                        ora 7,x
00456Ar 3  D0 03                        bne @1
00456Cr 3               
00456Cr 3                               ; It's a zero, generate an error to protect the users from
00456Cr 3                               ; themselves
00456Cr 3  4C rr rr                     jmp _error_2drop
00456Fr 3               @1:
00456Fr 3                               ; Not a zero, we assume user knows what they are doing. Get the
00456Fr 3                               ; address.
00456Fr 3  B5 06                        lda 6,x
004571r 3  95 02                        sta 2,x
004573r 3  B5 07                        lda 7,x
004575r 3  95 03                        sta 3,x                 ; ( addr-t u-t addr-t ? )
004577r 3               
004577r 3  80 08                        bra _cmd_w_para_ready
004579r 3               
004579r 3               _cmd_w_have_para:
004579r 3                               ; We were given a parameter, which we now make the new
004579r 3                               ; default parameter. This is different from Unix w, where
004579r 3                               ; the filename set by f is not changed by w
004579r 3  B5 02                        lda 2,x
00457Br 3  95 06                        sta 6,x
00457Dr 3  B5 03                        lda 3,x
00457Fr 3  95 07                        sta 7,x                 ; drop through to _cmd_w_para_ready
004581r 3               
004581r 3               _cmd_w_para_ready:
004581r 3                               ; We don't care about the second parameter, the first one must
004581r 3                               ; be an address. There is actually no way to test if this is an
004581r 3                               ; address because any number could be a 16-bit address. Anyway,
004581r 3                               ; we overwrite para2 with the address where the pointer to the
004581r 3                               ; first entry in the list is kept.
004581r 3  A9 2E                        lda #<ed_head
004583r 3  95 00                        sta 0,x
004585r 3  A9 00                        lda #>ed_head
004587r 3  95 01                        sta 1,x                 ; ( addr-t u-t addr-t addr-h )
004589r 3               
004589r 3                               ; We need to keep a copy of the original target address to
004589r 3                               ; calculate how many chars (including carriage returns) we
004589r 3                               ; saved at the end of this routine
004589r 3  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
00458Cr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
00458Fr 3               
00458Fr 3               _cmd_w_loop:
00458Fr 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
004592r 3               
004592r 3                               ; If we're at the end of the list, quit. For the next block of
004592r 3                               ; text, we ignore the ( addr-t u-t ) at the beginning
004592r 3  B5 00                        lda 0,x
004594r 3  15 01                        ora 1,x
004596r 3  F0 55                        beq _cmd_w_eol
004598r 3               
004598r 3  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
00459Br 3  20 rr rr                     jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
00459Er 3               
00459Er 3                               ; Get the address and length of the string from the header
00459Er 3                               ; of this node
00459Er 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
0045A1r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
0045A4r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
0045A7r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
0045AAr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
0045ADr 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
0045B0r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
0045B3r 3  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
0045B6r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
0045B9r 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
0045BCr 3  20 rr rr                     jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
0045BFr 3               
0045BFr 3                               ; We need a copy of the string length u-s to adjust the pointer
0045BFr 3                               ; to the store area later
0045BFr 3  20 rr rr                     jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
0045C2r 3  20 rr rr                     jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
0045C5r 3               
0045C5r 3  20 rr rr                     jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
0045C8r 3               
0045C8r 3                               ; Calculate the position of the next string in the save area.
0045C8r 3                               ; What we don't do is remember the length of the individual
0045C8r 3                               ; strings; instead at the end we will subtract addresses to
0045C8r 3                               ; get the length of the string
0045C8r 3  20 rr rr                     jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
0045CBr 3  20 rr rr                     jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
0045CEr 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
0045D1r 3  20 rr rr                     jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
0045D4r 3               
0045D4r 3                               ; But wait, our strings are terminated by Line Feeds in
0045D4r 3                               ; memory, so we need to add one
0045D4r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
0045D7r 3               
0045D7r 3  CA                           dex
0045D8r 3  CA                           dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
0045D9r 3  A9 0A                        lda #AscLF              ; ASCII for LF
0045DBr 3  95 00                        sta 0,x
0045DDr 3  74 01                        stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
0045DFr 3               
0045DFr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
0045E2r 3  20 rr rr                     jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
0045E5r 3  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
0045E8r 3               
0045E8r 3                               ; Now we can handle the next line
0045E8r 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
0045EBr 3               
0045EBr 3  80 A2                        bra _cmd_w_loop
0045EDr 3               
0045EDr 3               _cmd_w_eol:
0045EDr 3                               ; We're at the end of the text buffer and arrive here with
0045EDr 3                               ; ( addr-tn addr-n ) ( R: addr-t ) What we do now is calculate
0045EDr 3                               ; the number of characters saved and put that value in the 3OS
0045EDr 3                               ; position
0045EDr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
0045F0r 3  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
0045F3r 3  20 rr rr                     jsr xt_minus            ; - ( addr-t u-t addr-n u )
0045F6r 3               
0045F6r 3  B5 00                        lda 0,x
0045F8r 3  95 04                        sta 4,x
0045FAr 3  B5 01                        lda 1,x
0045FCr 3  95 05                        sta 5,x                 ; ( addr-t u addr-n u )
0045FEr 3               
0045FEr 3                               ; Unix ed puts the number of characters on a new line, so we
0045FEr 3                               ; do as well
0045FEr 3  20 rr rr                     jsr xt_cr
004601r 3  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u addr-n u u )
004604r 3  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u addr-n u )
004607r 3  20 rr rr                     jsr xt_cr
00460Ar 3               
00460Ar 3                               ; Reset the changed flag
00460Ar 3  A9 40                        lda #%01000000
00460Cr 3  14 32                        trb ed_flags
00460Er 3               
00460Er 3  4C rr rr                     jmp _next_command
004611r 3               
004611r 3               
004611r 3               ; === ERROR HANDLING ===
004611r 3               
004611r 3               _error_2drop:
004611r 3                               ; Lots of times we'll have para1 and para2 on the stack when an
004611r 3                               ; error occurs, so we drop stuff here
004611r 3  E8                           inx
004612r 3  E8                           inx                     ; drop through to _error_1drop
004613r 3               _error_1drop:
004613r 3  E8                           inx
004614r 3  E8                           inx                     ; drop through to _error
004615r 3               _error:
004615r 3                               ; Error handling with ed is really primitive: We print a question
004615r 3                               ; mark and go back to the loop. Any code calling this routine must
004615r 3                               ; clean up the stack itself: We expect it to be empty. Note that
004615r 3                               ; ed currently does not support reporting the type of error on
004615r 3                               ; demand like Unix ed does
004615r 3  20 rr rr                     jsr xt_cr
004618r 3               
004618r 3  A9 3F                        lda #'?'
00461Ar 3  20 rr rr                     jsr emit_a
00461Dr 3               
00461Dr 3  20 rr rr                     jsr xt_cr
004620r 3               
004620r 3  4C rr rr                     jmp _input_loop
004623r 3               
004623r 3               
004623r 3               ; === HELPER FUNCTIONS ===
004623r 3               
004623r 3               _get_input:
004623r 3                       ; Use REFILL to get input from the user, which is left in
004623r 3                       ; ( cib ciblen ) as usual.
004623r 3  20 rr rr                     jsr xt_refill           ;  ( addr-t u-t f )
004626r 3               
004626r 3                               ; If something went wrong while getting the user input, print
004626r 3                               ; a question mark and try again. No fancy error messages
004626r 3                               ; for ed!
004626r 3  B5 00                        lda 0,x
004628r 3  15 01                        ora 1,x
00462Ar 3  D0 05                        bne @1
00462Cr 3               
00462Cr 3                               ; Whatever went wrong, we can't handle it here anyway. We
00462Cr 3                               ; clear the return stack, dump the error flag and call
00462Cr 3                               ; a normal error
00462Cr 3  7A                           ply
00462Dr 3  7A                           ply
00462Er 3               
00462Er 3  4C rr rr                     jmp _error_1drop
004631r 3               @1:
004631r 3                               ; Drop the flag
004631r 3  E8                           inx
004632r 3  E8                           inx
004633r 3               
004633r 3  60                           rts
004634r 3               
004634r 3               ; -----------------------------
004634r 3               _have_text:
004634r 3                       ; See if we have any lines at all. If not, abort with an error. We
004634r 3                       ; could in theory set a flag every time we add a text, but this is
004634r 3                       ; more robust, if somewhat longer
004634r 3  A5 2E                        lda ed_head
004636r 3  05 2F                        ora ed_head+1
004638r 3  D0 04                        bne @1
00463Ar 3               
00463Ar 3                               ; We don't have any lines. Clean up the return stack and throw
00463Ar 3                               ; an error
00463Ar 3  7A                           ply
00463Br 3  7A                           ply
00463Cr 3  80 D7                        bra _error
00463Er 3               @1:
00463Er 3  60                           rts
00463Fr 3               
00463Fr 3               ; -----------------------------
00463Fr 3               _is_valid_line:
00463Fr 3                       ; See if the line number in TOS is valid. If yes, returns the carry
00463Fr 3                       ; flag set ("true"), otherwise cleared ("false"). Does not change
00463Fr 3                       ; the value of TOS. Line numbers must be 0 < number <= last_line.
00463Fr 3                       ; This routine calls _last_line.
00463Fr 3  38                           sec                             ; default is legal line number
004640r 3               
004640r 3                               ; First see if we have a zero
004640r 3  B5 00                        lda 0,x
004642r 3  15 01                        ora 1,x
004644r 3  F0 19                        beq _is_valid_line_nope_zero    ; ( n )
004646r 3               
004646r 3                               ; Not a zero. Now see if we're beyond the last line
004646r 3  20 rr rr                     jsr xt_dup                      ; DUP ( n n )
004649r 3  20 rr rr                     jsr _last_line                  ; ( n n last )
00464Cr 3  20 rr rr                     jsr xt_swap                     ; SWAP ( n last n )
00464Fr 3  20 rr rr                     jsr xt_less_than                ; < ( n f )
004652r 3               
004652r 3  B5 00                        lda 0,x                         ; 0 flag is good
004654r 3  15 01                        ora 1,x
004656r 3  D0 05                        bne _is_valid_line_too_small
004658r 3               
004658r 3                               ; We're good, clean up and leave
004658r 3  E8                           inx
004659r 3  E8                           inx                     ; DROP flag ( n )
00465Ar 3               
00465Ar 3  38                           sec                     ; Who knows what's happened to C by now
00465Br 3  80 03                        bra _is_valid_line_done ; only one exit from this routine
00465Dr 3               
00465Dr 3               _is_valid_line_too_small:
00465Dr 3  E8                           inx
00465Er 3  E8                           inx                     ; drop through to _is_valid_line_zero
00465Fr 3               
00465Fr 3               _is_valid_line_nope_zero:
00465Fr 3  18                           clc                     ; drop through to _is_valid_line_done
004660r 3               
004660r 3               _is_valid_line_done:
004660r 3  60                           rts
004661r 3               
004661r 3               
004661r 3               ; -----------------------------
004661r 3               _last_line:
004661r 3                       ; Calculate the number of the last line (not its address) and return
004661r 3                       ; it TOS. Note this shares code with _num_to_addr. Assumes that user
004661r 3                       ; has made sure there are any lines at all
004661r 3               
004661r 3                               ; Set counter to zero
004661r 3  64 24                        stz tmp1
004663r 3  64 25                        stz tmp1+1
004665r 3               
004665r 3  CA                           dex
004666r 3  CA                           dex                     ; ( ? )
004667r 3  A9 2E                        lda #<ed_head
004669r 3  95 00                        sta 0,x
00466Br 3  A9 00                        lda #>ed_head
00466Dr 3  95 01                        sta 1,x                 ; ( addr )
00466Fr 3               
00466Fr 3               _last_line_loop:
00466Fr 3  20 rr rr                     jsr xt_fetch            ; ( addr | 0 )
004672r 3               
004672r 3                               ; If that's over, we're at the end of the list and we're done
004672r 3  B5 00                        lda 0,x
004674r 3  15 01                        ora 1,x
004676r 3  F0 08                        beq _last_line_done
004678r 3               
004678r 3                               ; Not done. Increase counter and continue
004678r 3  E6 24                        inc tmp1
00467Ar 3  D0 02                        bne @1
00467Cr 3  E6 25                        inc tmp1+1
00467Er 3               @1:
00467Er 3  80 EF                        bra _last_line_loop
004680r 3               
004680r 3               _last_line_done:
004680r 3  A5 24                        lda tmp1
004682r 3  95 00                        sta 0,x
004684r 3  A5 25                        lda tmp1+1
004686r 3  95 01                        sta 1,x                 ; ( u )
004688r 3               
004688r 3  60                           rts
004689r 3               
004689r 3               
004689r 3               ; -----------------------------
004689r 3               _no_line_zero:
004689r 3                       ; Make sure we weren't given an explicit zero as the line number with
004689r 3                       ; commands that don't accept it (that is, pretty much everybody except
004689r 3                       ; a). If para1 is a zero and we have parameters (bit 7 of ed_flag set),
004689r 3                       ; throw an error
004689r 3               
004689r 3                               ; See if para1 is zero
004689r 3  B5 02                        lda 2,x
00468Br 3  15 03                        ora 3,x
00468Dr 3  D0 07                        bne _no_line_zero_done
00468Fr 3               
00468Fr 3                               ; It's zero. If bit 7 of ed_flag is set, this is an explicit
00468Fr 3                               ; parameter
00468Fr 3  24 32                        bit ed_flags
004691r 3  10 03                        bpl _no_line_zero_done
004693r 3               
004693r 3  4C rr rr                     jmp _error_2drop
004696r 3               
004696r 3               _no_line_zero_done:
004696r 3                               ; All is well, we can continue
004696r 3  60                           rts
004697r 3               
004697r 3               ; -----------------------------
004697r 3               _num_to_addr:
004697r 3                       ; Given a line number as TOS, replace it by the address of the node.
004697r 3                       ; If the line number is zero, we return the address of the header
004697r 3                       ; node. If the line number is beyond the last line, we return a
004697r 3                       ; zero, though we're assuming the user will check for a legal
004697r 3                       ; line number before calling this routine. Assumes we have checked that
004697r 3                       ; we have any text at all.
004697r 3               
004697r 3                               ; One way or another we're going to start with the
004697r 3                               ; address of the pointer to the head of the list
004697r 3  CA                           dex
004698r 3  CA                           dex                     ; ( u ? )
004699r 3  A9 2E                        lda #<ed_head
00469Br 3  95 00                        sta 0,x
00469Dr 3  A9 00                        lda #>ed_head
00469Fr 3  95 01                        sta 1,x                 ; ( u addr-h )
0046A1r 3               
0046A1r 3                               ; Handle the case where the line number is zero
0046A1r 3  B5 02                        lda 2,x
0046A3r 3  15 03                        ora 3,x
0046A5r 3  D0 05                        bne _num_to_addr_loop
0046A7r 3               
0046A7r 3                               ; It's zero, so we're already done
0046A7r 3  20 rr rr                     jsr xt_nip              ; ( addr-h )
0046AAr 3  80 21                        bra _num_to_addr_done
0046ACr 3               
0046ACr 3               _num_to_addr_loop:
0046ACr 3                               ; Get the first line
0046ACr 3  20 rr rr                     jsr xt_fetch            ; @ ( u addr1 )
0046AFr 3               
0046AFr 3                               ; If that's zero, we're at the end of the list and it's over
0046AFr 3  B5 00                        lda 0,x
0046B1r 3  15 01                        ora 1,x
0046B3r 3  D0 05                        bne @1
0046B5r 3               
0046B5r 3  20 rr rr                     jsr xt_nip              ; NIP ( addr1 )
0046B8r 3  80 13                        bra _num_to_addr_done
0046BAr 3               @1:
0046BAr 3                               ; It's not zero. See if this is the nth element we're looking
0046BAr 3                               ; for
0046BAr 3  20 rr rr                     jsr xt_swap             ; SWAP ( addr1 u )
0046BDr 3  20 rr rr                     jsr xt_one_minus        ; 1- ( addr1 u-1 )
0046C0r 3               
0046C0r 3  B5 00                        lda 0,x
0046C2r 3  15 01                        ora 1,x
0046C4r 3  F0 05                        beq _num_to_addr_finished
0046C6r 3               
0046C6r 3                               ; Not zero yet, try again
0046C6r 3  20 rr rr                     jsr xt_swap             ; SWAP ( u-1 addr1 )
0046C9r 3               
0046C9r 3  80 E1                        bra _num_to_addr_loop
0046CBr 3               
0046CBr 3               _num_to_addr_finished:
0046CBr 3                               ; We arrive here with ( addr u )
0046CBr 3  E8                           inx
0046CCr 3  E8                           inx                     ; ( addr )
0046CDr 3               
0046CDr 3               _num_to_addr_done:
0046CDr 3  60                           rts
0046CEr 3               
0046CEr 3               
0046CEr 3               ; -----------------------------
0046CEr 3               _para1_to_cur:
0046CEr 3                       ; Switch the current line number to whatever the first parameter
0046CEr 3                       ; is. We do this a lot so this routine saves a few bytes
0046CEr 3  B5 02                        lda 2,x
0046D0r 3  85 30                        sta ed_cur
0046D2r 3  B5 03                        lda 3,x
0046D4r 3  85 31                        sta ed_cur+1
0046D6r 3               
0046D6r 3  60                           rts
0046D7r 3               
0046D7r 3               
0046D7r 3               ; -----------------------------
0046D7r 3               _print_addr:
0046D7r 3                       ; Given the address of a node TOS, print the string it comes with.
0046D7r 3                       ; Assumes we have made sure that this address exists. It would be
0046D7r 3                       ; nice to put the CR at the beginning, but that doesn't work with
0046D7r 3                       ; the n commands, so at the end it goes. Consumes TOS.
0046D7r 3  20 rr rr                     jsr xt_one_plus
0046DAr 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 )
0046DDr 3               
0046DDr 3  20 rr rr                     jsr xt_dup              ; ( addr+2 addr+2 )
0046E0r 3               
0046E0r 3  20 rr rr                     jsr xt_one_plus
0046E3r 3  20 rr rr                     jsr xt_one_plus         ; ( addr+2 addr+4 )
0046E6r 3               
0046E6r 3  20 rr rr                     jsr xt_fetch            ; ( addr+2 u-s )
0046E9r 3  20 rr rr                     jsr xt_swap             ; ( u-s addr+2 )
0046ECr 3  20 rr rr                     jsr xt_fetch            ; ( u-s addr-s )
0046EFr 3               
0046EFr 3  20 rr rr                     jsr xt_swap             ; ( addr-s u-s )
0046F2r 3  20 rr rr                     jsr xt_type
0046F5r 3  20 rr rr                     jsr xt_cr
0046F8r 3               
0046F8r 3  60                           rts
0046F9r 3               
0046F9r 3               
0046F9r 3               ; === COMMAND TABLES ===
0046F9r 3               
0046F9r 3               ; The commands are all one character and kept in a 0-terminated string that is
0046F9r 3               ; walked by a loop. Their index corresponds to the index of their routine's
0046F9r 3               ; address in the jump table. To create a new command, add it's letter at the
0046F9r 3               ; correct position in the command list and the routine's address in the command
0046F9r 3               ; jump table. Oh, and write the routine as well. Capital letters such as 'Q' are
0046F9r 3               ; coded in their routine's address as double letters ('_cmd_qq').
0046F9r 3               
0046F9r 3  61 66 69 64  ed_cmd_list:    .byte "afidpn=wqQ", 0
0046FDr 3  70 6E 3D 77  
004701r 3  71 51 00     
004704r 3               
004704r 3               ed_cmd_table:
004704r 3  rr rr rr rr                  .word _cmd_a, _cmd_f, _cmd_i, _cmd_d, _cmd_p, _cmd_n
004708r 3  rr rr rr rr  
00470Cr 3  rr rr rr rr  
004710r 3  rr rr rr rr                  .word _cmd_equ, _cmd_w, _cmd_q, _cmd_qq
004714r 3  rr rr rr rr  
004718r 3               
004718r 3               
004718r 3               ed6502_end:     ; Used to calculate size of editor code
004718r 3               
004718r 2               
004718r 2               ; High-level Forth words, see forth_code/README.md
004718r 2               forth_words_start:
004718r 2  20 63 72 20  .incbin "forth_words.asc"
00471Cr 2  2E 28 20 52  
004720r 2  65 61 64 79  
00472Ar 2               forth_words_end:
00472Ar 2               
00472Ar 2               ; User-defined Forth words, see forth_code/README.md
00472Ar 2               user_words_start:
00472Ar 2  20 32 30 20  .incbin "user_words.asc"
00472Er 2  63 6F 6E 73  
004732r 2  74 61 6E 74  
004DCFr 2               user_words_end:
004DCFr 2               
004DCFr 2               .include "headers.asm"          ; Headers of native words
004DCFr 3               ; Dictionary Headers for Tali Forth 2
004DCFr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004DCFr 3               ; First version: 05. Dec 2016 (Liara Forth)
004DCFr 3               ; This version: 29. Dec 2018
004DCFr 3               
004DCFr 3               ; Dictionary headers are kept separately from the code, which allows various
004DCFr 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
004DCFr 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
004DCFr 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
004DCFr 3               ; header in the Dictionary. There the link to the next word in the Dictionary
004DCFr 3               ; is always one cell down from the current word's own nt. In the code itself,
004DCFr 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
004DCFr 3               
004DCFr 3               ; This gives us the following header structure:
004DCFr 3               
004DCFr 3               ;              8 bit     8 bit
004DCFr 3               ;               LSB       MSB
004DCFr 3               ; nt_word ->  +--------+--------+
004DCFr 3               ;          +0 | Length | Status |
004DCFr 3               ;             +--------+--------+
004DCFr 3               ;          +2 | Next Header     | -> nt_next_word
004DCFr 3               ;             +-----------------+
004DCFr 3               ;          +4 | Start of Code   | -> xt_word
004DCFr 3               ;             +-----------------+
004DCFr 3               ;          +6 | End of Code     | -> z_word
004DCFr 3               ;             +--------+--------+
004DCFr 3               ;          +8 | Name   |        |
004DCFr 3               ;             +--------+--------+
004DCFr 3               ;             |        |        |
004DCFr 3               ;             +--------+--------+
004DCFr 3               ;             |        |  ...   | (name string does not end with a zero)
004DCFr 3               ;          +n +--------+--------+
004DCFr 3               
004DCFr 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
004DCFr 3               ; which are:
004DCFr 3               
004DCFr 3               ;       CO - Compile Only
004DCFr 3               ;       IM - Immediate Word
004DCFr 3               ;       NN - Never Native Compile (must always be called by JSR)
004DCFr 3               ;       AN - Always Native Compile (may not be called by JSR)
004DCFr 3               ;       UF - Contains underflow check
004DCFr 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
004DCFr 3               
004DCFr 3               ; Note there are currently two bits unused.
004DCFr 3               
004DCFr 3               ; By default, all existing words can be natively compiled (compiled inline) or
004DCFr 3               ; as a subroutine jump target; the system decides which variant to use based on
004DCFr 3               ; a threshold the user can set. By default, all user-created words are flagged
004DCFr 3               ; never-native. The user can override this by using the always-native word
004DCFr 3               ; just after defining their new word.  The NN flag forbids native compiling,
004DCFr 3               ; the AN flag forces it.
004DCFr 3               
004DCFr 3               ; The last word (top word in code) is always BYE. It is marked as the last word
004DCFr 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
004DCFr 3               ; more common ones first (further down in code) so they are found earlier.
004DCFr 3               ; Anything to do with output comes later (further up) because things will
004DCFr 3               ; always be slow if there is a human involved.
004DCFr 3               
004DCFr 3               ; The initial skeleton of this list was automatically generated by a script
004DCFr 3               ; in the tools folder and then sorted by hand.
004DCFr 3               
004DCFr 3               nt_bye:
004DCFr 3  03                   .byte 3         ; length of word strings
004DD0r 3  00                   .byte 0         ; status byte
004DD1r 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
004DD3r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
004DD5r 3  rr rr                .word z_bye     ; end of code (RTS)
004DD7r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
004DDAr 3               
004DDAr 3               
004DDAr 3               nt_cold:
004DDAr 3  04 00                .byte 4, 0
004DDCr 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
004DE0r 3  rr rr        
004DE2r 3  63 6F 6C 64          .byte "cold"
004DE6r 3               
004DE6r 3               nt_lcdput:
004DE6r 3  06 10                .byte 6, UF
004DE8r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
004DECr 3  rr rr        
004DEEr 3  6C 63 64 70          .byte "lcdput"
004DF2r 3  75 74        
004DF4r 3               
004DF4r 3               nt_lcdprint:
004DF4r 3  08 10                .byte 8, UF
004DF6r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
004DFAr 3  rr rr        
004DFCr 3  6C 63 64 70          .byte "lcdprint"
004E00r 3  72 69 6E 74  
004E04r 3               
004E04r 3               nt_cls:
004E04r 3  03 00                .byte 3, 0
004E06r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
004E0Ar 3  rr rr        
004E0Cr 3  63 6C 73             .byte "cls"
004E0Fr 3               
004E0Fr 3               nt_spi_init:
004E0Fr 3  08 00                .byte 8, 0
004E11r 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
004E15r 3  rr rr        
004E17r 3  73 70 69 5F          .byte "spi_init"
004E1Br 3  69 6E 69 74  
004E1Fr 3               
004E1Fr 3               
004E1Fr 3               nt_spi_clk_toggle:
004E1Fr 3  0E 00                .byte 14, 0
004E21r 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
004E25r 3  rr rr        
004E27r 3  73 70 69 5F          .byte "spi_clk_toggle"
004E2Br 3  63 6C 6B 5F  
004E2Fr 3  74 6F 67 67  
004E35r 3               
004E35r 3               nt_spi_select:
004E35r 3  0A 00                .byte 10, 0
004E37r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
004E3Br 3  rr rr        
004E3Dr 3  73 70 69 5F          .byte "spi_select"
004E41r 3  73 65 6C 65  
004E45r 3  63 74        
004E47r 3               
004E47r 3               nt_spi_transceive:
004E47r 3  0E 00                .byte 14, 0
004E49r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
004E4Dr 3  rr rr        
004E4Fr 3  73 70 69 5F          .byte "spi_transceive"
004E53r 3  74 72 61 6E  
004E57r 3  73 63 65 69  
004E5Dr 3               
004E5Dr 3               nt_sd_init:
004E5Dr 3  07 00                .byte 7, 0
004E5Fr 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
004E63r 3  rr rr        
004E65r 3  73 64 5F 69          .byte "sd_init"
004E69r 3  6E 69 74     
004E6Cr 3               
004E6Cr 3               
004E6Cr 3               nt_sd_readsector:
004E6Cr 3  0D 00                .byte 13, 0
004E6Er 3  rr rr rr rr          .word nt_sd_init, xt_sd_readsector, z_sd_readsector
004E72r 3  rr rr        
004E74r 3  73 64 5F 72          .byte "sd_readsector"
004E78r 3  65 61 64 73  
004E7Cr 3  65 63 74 6F  
004E81r 3               
004E81r 3               
004E81r 3               nt_fat32_init:
004E81r 3  0A 00                .byte 10, 0
004E83r 3  rr rr rr rr          .word nt_sd_readsector, xt_fat32_init, z_fat32_init
004E87r 3  rr rr        
004E89r 3  66 61 74 33          .byte "fat32_init"
004E8Dr 3  32 5F 69 6E  
004E91r 3  69 74        
004E93r 3               
004E93r 3               nt_fat32_find:
004E93r 3  0A 00                .byte 10, 0
004E95r 3  rr rr rr rr          .word nt_fat32_init, xt_fat32_find, z_fat32_find
004E99r 3  rr rr        
004E9Br 3  66 61 74 33          .byte "fat32_find"
004E9Fr 3  32 5F 66 69  
004EA3r 3  6E 64        
004EA5r 3               
004EA5r 3               nt_ed:                  ; ed6502
004EA5r 3  02 08                .byte 2, NN
004EA7r 3  rr rr rr rr          .word nt_fat32_find, xt_ed, z_ed
004EABr 3  rr rr        
004EADr 3  65 64                .byte "ed"
004EAFr 3               
004EAFr 3  03 08        nt_see: .byte 3, NN
004EB1r 3  rr rr rr rr          .word nt_ed, xt_see, z_see
004EB5r 3  rr rr        
004EB7r 3  73 65 65             .byte "see"
004EBAr 3               
004EBAr 3               nt_forth:
004EBAr 3  05 00                .byte 5, 0
004EBCr 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
004EC0r 3  rr rr        
004EC2r 3  66 6F 72 74          .byte "forth"
004EC6r 3  68           
004EC7r 3               
004EC7r 3               nt_order:
004EC7r 3  05 00                .byte 5, 0
004EC9r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
004ECDr 3  rr rr        
004ECFr 3  6F 72 64 65          .byte "order"
004ED3r 3  72           
004ED4r 3               
004ED4r 3               nt_to_order:
004ED4r 3  06 00                .byte 6, 0
004ED6r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
004EDAr 3  rr rr        
004EDCr 3  3E 6F 72 64          .byte ">order"
004EE0r 3  65 72        
004EE2r 3               
004EE2r 3               nt_previous:
004EE2r 3  08 00                .byte 8, 0
004EE4r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
004EE8r 3  rr rr        
004EEAr 3  70 72 65 76          .byte "previous"
004EEEr 3  69 6F 75 73  
004EF2r 3               
004EF2r 3               nt_also:
004EF2r 3  04 00                .byte 4, 0
004EF4r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
004EF8r 3  rr rr        
004EFAr 3  61 6C 73 6F          .byte "also"
004EFEr 3               
004EFEr 3               nt_only:
004EFEr 3  04 00                .byte 4, 0
004F00r 3  rr rr rr rr          .word nt_also, xt_only, z_only
004F04r 3  rr rr        
004F06r 3  6F 6E 6C 79          .byte "only"
004F0Ar 3               
004F0Ar 3               nt_forth_wordlist:      ; shares code with ZERO
004F0Ar 3  0E 00                .byte 14, 0
004F0Cr 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
004F10r 3  rr rr        
004F12r 3  66 6F 72 74          .byte "forth-wordlist"
004F16r 3  68 2D 77 6F  
004F1Ar 3  72 64 6C 69  
004F20r 3               
004F20r 3               nt_editor_wordlist:     ; shares code with ONE
004F20r 3  0F 00                .byte 15, 0
004F22r 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
004F26r 3  rr rr        
004F28r 3  65 64 69 74          .byte "editor-wordlist"
004F2Cr 3  6F 72 2D 77  
004F30r 3  6F 72 64 6C  
004F37r 3               
004F37r 3               nt_assembler_wordlist:  ; shares code with TWO
004F37r 3  12 00                .byte 18, 0
004F39r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
004F3Dr 3  rr rr        
004F3Fr 3  61 73 73 65          .byte "assembler-wordlist"
004F43r 3  6D 62 6C 65  
004F47r 3  72 2D 77 6F  
004F51r 3               
004F51r 3               nt_root_wordlist:
004F51r 3  0D 00                .byte 13, 0
004F53r 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
004F57r 3  rr rr        
004F59r 3  72 6F 6F 74          .byte "root-wordlist"
004F5Dr 3  2D 77 6F 72  
004F61r 3  64 6C 69 73  
004F66r 3               
004F66r 3               nt_get_order:
004F66r 3  09 00                .byte 9, 0
004F68r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
004F6Cr 3  rr rr        
004F6Er 3  67 65 74 2D          .byte "get-order"
004F72r 3  6F 72 64 65  
004F76r 3  72           
004F77r 3               
004F77r 3               nt_set_order:
004F77r 3  09 00                .byte 9, 0
004F79r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
004F7Dr 3  rr rr        
004F7Fr 3  73 65 74 2D          .byte "set-order"
004F83r 3  6F 72 64 65  
004F87r 3  72           
004F88r 3               
004F88r 3               nt_get_current:
004F88r 3  0B 00                .byte 11, 0
004F8Ar 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
004F8Er 3  rr rr        
004F90r 3  67 65 74 2D          .byte "get-current"
004F94r 3  63 75 72 72  
004F98r 3  65 6E 74     
004F9Br 3               
004F9Br 3               nt_set_current:
004F9Br 3  0B 10                .byte 11, UF
004F9Dr 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
004FA1r 3  rr rr        
004FA3r 3  73 65 74 2D          .byte "set-current"
004FA7r 3  63 75 72 72  
004FABr 3  65 6E 74     
004FAEr 3               
004FAEr 3               nt_search_wordlist:
004FAEr 3  0F 10                .byte 15, UF
004FB0r 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
004FB4r 3  rr rr        
004FB6r 3  73 65 61 72          .byte "search-wordlist"
004FBAr 3  63 68 2D 77  
004FBEr 3  6F 72 64 6C  
004FC5r 3               
004FC5r 3               nt_wordlist:
004FC5r 3  08 00                .byte 8, 0
004FC7r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
004FCBr 3  rr rr        
004FCDr 3  77 6F 72 64          .byte "wordlist"
004FD1r 3  6C 69 73 74  
004FD5r 3               
004FD5r 3               nt_definitions:
004FD5r 3  0B 00                .byte 11, 0
004FD7r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
004FDBr 3  rr rr        
004FDDr 3  64 65 66 69          .byte "definitions"
004FE1r 3  6E 69 74 69  
004FE5r 3  6F 6E 73     
004FE8r 3               
004FE8r 3               nt_block_ramdrive_init:
004FE8r 3  13 10                .byte 19, UF
004FEAr 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
004FEEr 3  rr rr        
004FF0r 3  62 6C 6F 63          .byte "block-ramdrive-init"
004FF4r 3  6B 2D 72 61  
004FF8r 3  6D 64 72 69  
005003r 3               
005003r 3               nt_list:
005003r 3  04 10                .byte 4, UF
005005r 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
005009r 3  rr rr        
00500Br 3  6C 69 73 74          .byte "list"
00500Fr 3               
00500Fr 3               nt_thru:
00500Fr 3  04 10                .byte 4, UF
005011r 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
005015r 3  rr rr        
005017r 3  74 68 72 75          .byte "thru"
00501Br 3               
00501Br 3               nt_load:
00501Br 3  04 10                .byte 4, UF
00501Dr 3  rr rr rr rr          .word nt_thru, xt_load, z_load
005021r 3  rr rr        
005023r 3  6C 6F 61 64          .byte "load"
005027r 3               
005027r 3               nt_flush:
005027r 3  05 00                .byte 5, 0
005029r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
00502Dr 3  rr rr        
00502Fr 3  66 6C 75 73          .byte "flush"
005033r 3  68           
005034r 3               
005034r 3               nt_empty_buffers:
005034r 3  0D 00                .byte 13, 0
005036r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
00503Ar 3  rr rr        
00503Cr 3  65 6D 70 74          .byte "empty-buffers"
005040r 3  79 2D 62 75  
005044r 3  66 66 65 72  
005049r 3               
005049r 3               nt_buffer:
005049r 3  06 00                .byte 6, 0
00504Br 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
00504Fr 3  rr rr        
005051r 3  62 75 66 66          .byte "buffer"
005055r 3  65 72        
005057r 3               
005057r 3               nt_update:
005057r 3  06 00                .byte 6, 0
005059r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
00505Dr 3  rr rr        
00505Fr 3  75 70 64 61          .byte "update"
005063r 3  74 65        
005065r 3               
005065r 3               nt_block:
005065r 3  05 00                .byte 5, 0
005067r 3  rr rr rr rr          .word nt_update, xt_block, z_block
00506Br 3  rr rr        
00506Dr 3  62 6C 6F 63          .byte "block"
005071r 3  6B           
005072r 3               
005072r 3               nt_save_buffers:
005072r 3  0C 00                .byte 12, 0
005074r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
005078r 3  rr rr        
00507Ar 3  73 61 76 65          .byte "save-buffers"
00507Er 3  2D 62 75 66  
005082r 3  66 65 72 73  
005086r 3               
005086r 3               nt_block_read_vector:
005086r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
005088r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
00508Cr 3  rr rr        
00508Er 3  62 6C 6F 63          .byte "block-read-vector"
005092r 3  6B 2D 72 65  
005096r 3  61 64 2D 76  
00509Fr 3               
00509Fr 3               nt_block_read:
00509Fr 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
0050A1r 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
0050A5r 3  rr rr        
0050A7r 3  62 6C 6F 63          .byte "block-read"
0050ABr 3  6B 2D 72 65  
0050AFr 3  61 64        
0050B1r 3               
0050B1r 3               nt_block_write_vector:
0050B1r 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
0050B3r 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
0050B7r 3  rr rr        
0050B9r 3  62 6C 6F 63          .byte "block-write-vector"
0050BDr 3  6B 2D 77 72  
0050C1r 3  69 74 65 2D  
0050CBr 3               
0050CBr 3               nt_block_write:
0050CBr 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
0050CDr 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
0050D1r 3  rr rr        
0050D3r 3  62 6C 6F 63          .byte "block-write"
0050D7r 3  6B 2D 77 72  
0050DBr 3  69 74 65     
0050DEr 3               
0050DEr 3               nt_blk:
0050DEr 3  03 00                .byte 3, 0
0050E0r 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
0050E4r 3  rr rr        
0050E6r 3  62 6C 6B             .byte "blk"
0050E9r 3               
0050E9r 3               nt_scr:
0050E9r 3  03 00                .byte 3, 0
0050EBr 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
0050EFr 3  rr rr        
0050F1r 3  73 63 72             .byte "scr"
0050F4r 3               
0050F4r 3               nt_blkbuffer:
0050F4r 3  09 00                .byte 9, 0
0050F6r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
0050FAr 3  rr rr        
0050FCr 3  62 6C 6B 62          .byte "blkbuffer"
005100r 3  75 66 66 65  
005104r 3  72           
005105r 3               
005105r 3               nt_buffblocknum:
005105r 3  0C 00                .byte 12, 0
005107r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
00510Br 3  rr rr        
00510Dr 3  62 75 66 66          .byte "buffblocknum"
005111r 3  62 6C 6F 63  
005115r 3  6B 6E 75 6D  
005119r 3               
005119r 3               nt_buffstatus:
005119r 3  0A 00                .byte 10, 0
00511Br 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
00511Fr 3  rr rr        
005121r 3  62 75 66 66          .byte "buffstatus"
005125r 3  73 74 61 74  
005129r 3  75 73        
00512Br 3               
00512Br 3               nt_buffer_colon:
00512Br 3  07 00                .byte 7, 0
00512Dr 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
005131r 3  rr rr        
005133r 3  62 75 66 66          .byte "buffer:"
005137r 3  65 72 3A     
00513Ar 3               
00513Ar 3               nt_useraddr:
00513Ar 3  08 00                .byte 8, 0
00513Cr 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
005140r 3  rr rr        
005142r 3  75 73 65 72          .byte "useraddr"
005146r 3  61 64 64 72  
00514Ar 3               
00514Ar 3               nt_action_of:
00514Ar 3  09 04                .byte 9, IM
00514Cr 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
005150r 3  rr rr        
005152r 3  61 63 74 69          .byte "action-of"
005156r 3  6F 6E 2D 6F  
00515Ar 3  66           
00515Br 3               
00515Br 3               nt_is:
00515Br 3  02 04                .byte 2, IM
00515Dr 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
005161r 3  rr rr        
005163r 3  69 73                .byte "is"
005165r 3               
005165r 3               nt_defer_store:
005165r 3  06 00                .byte 6, 0
005167r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
00516Br 3  rr rr        
00516Dr 3  64 65 66 65          .byte "defer!"
005171r 3  72 21        
005173r 3               
005173r 3               nt_defer_fetch:
005173r 3  06 00                .byte 6, 0
005175r 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
005179r 3  rr rr        
00517Br 3  64 65 66 65          .byte "defer@"
00517Fr 3  72 40        
005181r 3               
005181r 3               nt_endcase:
005181r 3  07 0D                .byte 7, IM+CO+NN
005183r 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
005187r 3  rr rr        
005189r 3  65 6E 64 63          .byte "endcase"
00518Dr 3  61 73 65     
005190r 3               
005190r 3               nt_endof:
005190r 3  05 0D                .byte 5, IM+CO+NN
005192r 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
005196r 3  rr rr        
005198r 3  65 6E 64 6F          .byte "endof"
00519Cr 3  66           
00519Dr 3               
00519Dr 3               nt_of:
00519Dr 3  02 0D                .byte 2, IM+CO+NN
00519Fr 3  rr rr rr rr          .word nt_endof, xt_of, z_of
0051A3r 3  rr rr        
0051A5r 3  6F 66                .byte "of"
0051A7r 3               
0051A7r 3               nt_case:
0051A7r 3  04 0D                .byte 4, IM+CO+NN
0051A9r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
0051ADr 3  rr rr        
0051AFr 3  63 61 73 65          .byte "case"
0051B3r 3               
0051B3r 3               nt_while:
0051B3r 3  05 0D                .byte 5, IM+CO+NN
0051B5r 3  rr rr rr rr          .word nt_case, xt_while, z_while
0051B9r 3  rr rr        
0051BBr 3  77 68 69 6C          .byte "while"
0051BFr 3  65           
0051C0r 3               
0051C0r 3               nt_until:
0051C0r 3  05 0D                .byte 5, IM+CO+NN
0051C2r 3  rr rr rr rr          .word nt_while, xt_until, z_until
0051C6r 3  rr rr        
0051C8r 3  75 6E 74 69          .byte "until"
0051CCr 3  6C           
0051CDr 3               
0051CDr 3               nt_repeat:
0051CDr 3  06 0D                .byte 6, IM+CO+NN
0051CFr 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
0051D3r 3  rr rr        
0051D5r 3  72 65 70 65          .byte "repeat"
0051D9r 3  61 74        
0051DBr 3               
0051DBr 3               nt_else:
0051DBr 3  04 0D                .byte 4, IM+CO+NN
0051DDr 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
0051E1r 3  rr rr        
0051E3r 3  65 6C 73 65          .byte "else"
0051E7r 3               
0051E7r 3               nt_then:
0051E7r 3  04 0D                .byte 4, IM+CO+NN
0051E9r 3  rr rr rr rr          .word nt_else, xt_then, z_then
0051EDr 3  rr rr        
0051EFr 3  74 68 65 6E          .byte "then"
0051F3r 3               
0051F3r 3               nt_if:
0051F3r 3  02 0D                .byte 2, IM+CO+NN
0051F5r 3  rr rr rr rr          .word nt_then, xt_if, z_if
0051F9r 3  rr rr        
0051FBr 3  69 66                .byte "if"
0051FDr 3               
0051FDr 3               nt_dot_paren:
0051FDr 3  02 04                .byte 2, IM
0051FFr 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
005203r 3  rr rr        
005205r 3  2E 28                .byte ".("
005207r 3               
005207r 3               nt_paren:
005207r 3  01 04                .byte 1, IM
005209r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
00520Dr 3  rr rr        
00520Fr 3  28                   .byte "("
005210r 3               
005210r 3               nt_word:
005210r 3  04 10                .byte 4, UF
005212r 3  rr rr rr rr          .word nt_paren, xt_word, z_word
005216r 3  rr rr        
005218r 3  77 6F 72 64          .byte "word"
00521Cr 3               
00521Cr 3               nt_find:
00521Cr 3  04 10                .byte 4, UF
00521Er 3  rr rr rr rr          .word nt_word, xt_find, z_find
005222r 3  rr rr        
005224r 3  66 69 6E 64          .byte "find"
005228r 3               
005228r 3               nt_environment_q:
005228r 3  0C 10                .byte 12, UF
00522Ar 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
00522Er 3  rr rr        
005230r 3  65 6E 76 69          .byte "environment?"
005234r 3  72 6F 6E 6D  
005238r 3  65 6E 74 3F  
00523Cr 3               
00523Cr 3               nt_search:
00523Cr 3  06 18                .byte 6, UF+NN
00523Er 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
005242r 3  rr rr        
005244r 3  73 65 61 72          .byte "search"
005248r 3  63 68        
00524Ar 3               
00524Ar 3               nt_compare:
00524Ar 3  07 10                .byte 7, UF
00524Cr 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
005250r 3  rr rr        
005252r 3  63 6F 6D 70          .byte "compare"
005256r 3  61 72 65     
005259r 3               
005259r 3               nt_disasm:
005259r 3  06 10                .byte 6, UF
00525Br 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
00525Fr 3  rr rr        
005261r 3  64 69 73 61          .byte "disasm"
005265r 3  73 6D        
005267r 3               
005267r 3               nt_dot_s:
005267r 3  02 00                .byte 2, 0
005269r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
00526Dr 3  rr rr        
00526Fr 3  2E 73                .byte ".s"
005271r 3               
005271r 3               nt_dump:
005271r 3  04 10                .byte 4, UF
005273r 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
005277r 3  rr rr        
005279r 3  64 75 6D 70          .byte "dump"
00527Dr 3               
00527Dr 3               nt_bell:
00527Dr 3  04 00                .byte 4, 0
00527Fr 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
005283r 3  rr rr        
005285r 3  62 65 6C 6C          .byte "bell"
005289r 3               
005289r 3               nt_align:
005289r 3  05 00                .byte 5, 0
00528Br 3  rr rr rr rr          .word nt_bell, xt_align, z_align
00528Fr 3  rr rr        
005291r 3  61 6C 69 67          .byte "align"
005295r 3  6E           
005296r 3               
005296r 3               nt_aligned:             ; same code as ALIGN
005296r 3  07 00                .byte 7, 0
005298r 3  rr rr rr rr          .word nt_align, xt_align, z_align
00529Cr 3  rr rr        
00529Er 3  61 6C 69 67          .byte "aligned"
0052A2r 3  6E 65 64     
0052A5r 3               
0052A5r 3               nt_wordsize:
0052A5r 3  08 10                .byte 8, UF
0052A7r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
0052ABr 3  rr rr        
0052ADr 3  77 6F 72 64          .byte "wordsize"
0052B1r 3  73 69 7A 65  
0052B5r 3               
0052B5r 3               nt_words:
0052B5r 3  05 00                .byte 5, 0
0052B7r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
0052BBr 3  rr rr        
0052BDr 3  77 6F 72 64          .byte "words"
0052C1r 3  73           
0052C2r 3               
0052C2r 3               nt_marker:
0052C2r 3  06 04                .byte 6, IM
0052C4r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
0052C8r 3  rr rr        
0052CAr 3  6D 61 72 6B          .byte "marker"
0052CEr 3  65 72        
0052D0r 3               
0052D0r 3               nt_at_xy:
0052D0r 3  05 10                .byte 5, UF
0052D2r 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
0052D6r 3  rr rr        
0052D8r 3  61 74 2D 78          .byte "at-xy"
0052DCr 3  79           
0052DDr 3               
0052DDr 3               nt_page:
0052DDr 3  04 00                .byte 4, 0
0052DFr 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
0052E3r 3  rr rr        
0052E5r 3  70 61 67 65          .byte "page"
0052E9r 3               
0052E9r 3               nt_cr:
0052E9r 3  02 00                .byte 2, 0
0052EBr 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
0052EFr 3  rr rr        
0052F1r 3  63 72                .byte "cr"
0052F3r 3               
0052F3r 3               nt_input:
0052F3r 3  05 00                .byte 5, 0
0052F5r 3  rr rr rr rr          .word nt_cr, xt_input, z_input
0052F9r 3  rr rr        
0052FBr 3  69 6E 70 75          .byte "input"
0052FFr 3  74           
005300r 3               
005300r 3               nt_output:
005300r 3  06 00                .byte 6, 0
005302r 3  rr rr rr rr          .word nt_input, xt_output, z_output
005306r 3  rr rr        
005308r 3  6F 75 74 70          .byte "output"
00530Cr 3  75 74        
00530Er 3               
00530Er 3               nt_sign:
00530Er 3  04 10                .byte 4, UF
005310r 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
005314r 3  rr rr        
005316r 3  73 69 67 6E          .byte "sign"
00531Ar 3               
00531Ar 3               nt_hold:
00531Ar 3  04 10                .byte 4, UF
00531Cr 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
005320r 3  rr rr        
005322r 3  68 6F 6C 64          .byte "hold"
005326r 3               
005326r 3               nt_number_sign_greater:
005326r 3  02 10                .byte 2, UF
005328r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
00532Cr 3  rr rr        
00532Er 3  23 3E                .byte "#>"
005330r 3               
005330r 3               nt_number_sign_s:
005330r 3  02 10                .byte 2, UF
005332r 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
005336r 3  rr rr        
005338r 3  23 73                .byte "#s"
00533Ar 3               
00533Ar 3               nt_number_sign:
00533Ar 3  01 10                .byte 1, UF
00533Cr 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
005340r 3  rr rr        
005342r 3  23                   .byte "#"
005343r 3               
005343r 3               nt_less_number_sign:
005343r 3  02 00                .byte 2, 0
005345r 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
005349r 3  rr rr        
00534Br 3  3C 23                .byte "<#"
00534Dr 3               
00534Dr 3               nt_to_in:
00534Dr 3  03 00                .byte 3, 0
00534Fr 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
005353r 3  rr rr        
005355r 3  3E 69 6E             .byte ">in"
005358r 3               
005358r 3               nt_within:
005358r 3  06 10                .byte 6, UF
00535Ar 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
00535Er 3  rr rr        
005360r 3  77 69 74 68          .byte "within"
005364r 3  69 6E        
005366r 3               
005366r 3               nt_hexstore:
005366r 3  08 10                .byte 8, UF
005368r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
00536Cr 3  rr rr        
00536Er 3  68 65 78 73          .byte "hexstore"
005372r 3  74 6F 72 65  
005376r 3               
005376r 3               nt_cleave:
005376r 3  06 10                .byte 6, UF
005378r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
00537Cr 3  rr rr        
00537Er 3  63 6C 65 61          .byte "cleave"
005382r 3  76 65        
005384r 3               
005384r 3               nt_pad:
005384r 3  03 00                .byte 3, 0
005386r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
00538Ar 3  rr rr        
00538Cr 3  70 61 64             .byte "pad"
00538Fr 3               
00538Fr 3               nt_cmove:
00538Fr 3  05 10                .byte 5, UF
005391r 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
005395r 3  rr rr        
005397r 3  63 6D 6F 76          .byte "cmove"
00539Br 3  65           
00539Cr 3               
00539Cr 3               nt_cmove_up:
00539Cr 3  06 10                .byte 6, UF
00539Er 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
0053A2r 3  rr rr        
0053A4r 3  63 6D 6F 76          .byte "cmove>"
0053A8r 3  65 3E        
0053AAr 3               
0053AAr 3               nt_move:
0053AAr 3  04 18                .byte 4, NN+UF
0053ACr 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
0053B0r 3  rr rr        
0053B2r 3  6D 6F 76 65          .byte "move"
0053B6r 3               
0053B6r 3               nt_backslash:
0053B6r 3  01 04                .byte 1, IM
0053B8r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
0053BCr 3  rr rr        
0053BEr 3  5C                   .byte $5c
0053BFr 3               
0053BFr 3               nt_star_slash:
0053BFr 3  02 10                .byte 2, UF
0053C1r 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
0053C5r 3  rr rr        
0053C7r 3  2A 2F                .byte "*/"
0053C9r 3               
0053C9r 3               nt_star_slash_mod:
0053C9r 3  05 10                .byte 5, UF
0053CBr 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
0053CFr 3  rr rr        
0053D1r 3  2A 2F 6D 6F          .byte "*/mod"
0053D5r 3  64           
0053D6r 3               
0053D6r 3               nt_mod:
0053D6r 3  03 10                .byte 3, UF
0053D8r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
0053DCr 3  rr rr        
0053DEr 3  6D 6F 64             .byte "mod"
0053E1r 3               
0053E1r 3               nt_slash_mod:
0053E1r 3  04 10                .byte 4, UF
0053E3r 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
0053E7r 3  rr rr        
0053E9r 3  2F 6D 6F 64          .byte "/mod"
0053EDr 3               
0053EDr 3               nt_slash:
0053EDr 3  01 10                .byte 1, UF
0053EFr 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
0053F3r 3  rr rr        
0053F5r 3  2F                   .byte "/"
0053F6r 3               
0053F6r 3               nt_fm_slash_mod:
0053F6r 3  06 10                .byte 6, UF
0053F8r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
0053FCr 3  rr rr        
0053FEr 3  66 6D 2F 6D          .byte "fm/mod"
005402r 3  6F 64        
005404r 3               
005404r 3               nt_sm_slash_rem:
005404r 3  06 10                .byte 6, UF
005406r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
00540Ar 3  rr rr        
00540Cr 3  73 6D 2F 72          .byte "sm/rem"
005410r 3  65 6D        
005412r 3               
005412r 3               nt_um_slash_mod:
005412r 3  06 10                .byte 6, UF
005414r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
005418r 3  rr rr        
00541Ar 3  75 6D 2F 6D          .byte "um/mod"
00541Er 3  6F 64        
005420r 3               
005420r 3               nt_star:
005420r 3  01 10                .byte 1, UF
005422r 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
005426r 3  rr rr        
005428r 3  2A                   .byte "*"
005429r 3               
005429r 3               nt_um_star:
005429r 3  03 10                .byte 3, UF
00542Br 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
00542Fr 3  rr rr        
005431r 3  75 6D 2A             .byte "um*"
005434r 3               
005434r 3               nt_m_star:
005434r 3  02 10                .byte 2, UF
005436r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
00543Ar 3  rr rr        
00543Cr 3  6D 2A                .byte "m*"
00543Er 3               
00543Er 3               nt_count:
00543Er 3  05 10                .byte 5, UF
005440r 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
005444r 3  rr rr        
005446r 3  63 6F 75 6E          .byte "count"
00544Ar 3  74           
00544Br 3               
00544Br 3               nt_decimal:
00544Br 3  07 00                .byte 7, 0
00544Dr 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
005451r 3  rr rr        
005453r 3  64 65 63 69          .byte "decimal"
005457r 3  6D 61 6C     
00545Ar 3               
00545Ar 3               nt_hex:
00545Ar 3  03 00                .byte 3, 0
00545Cr 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
005460r 3  rr rr        
005462r 3  68 65 78             .byte "hex"
005465r 3               
005465r 3               nt_to_number:
005465r 3  07 10                .byte 7, UF
005467r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
00546Br 3  rr rr        
00546Dr 3  3E 6E 75 6D          .byte ">number"
005471r 3  62 65 72     
005474r 3               
005474r 3               nt_number:
005474r 3  06 10                .byte 6, UF
005476r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
00547Ar 3  rr rr        
00547Cr 3  6E 75 6D 62          .byte "number"
005480r 3  65 72        
005482r 3               
005482r 3               nt_digit_question:
005482r 3  06 10                .byte 6, UF
005484r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
005488r 3  rr rr        
00548Ar 3  64 69 67 69          .byte "digit?"
00548Er 3  74 3F        
005490r 3               
005490r 3               nt_base:
005490r 3  04 00                .byte 4, 0
005492r 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
005496r 3  rr rr        
005498r 3  62 61 73 65          .byte "base"
00549Cr 3               
00549Cr 3               nt_evaluate:
00549Cr 3  08 10                .byte 8, UF
00549Er 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
0054A2r 3  rr rr        
0054A4r 3  65 76 61 6C          .byte "evaluate"
0054A8r 3  75 61 74 65  
0054ACr 3               
0054ACr 3               nt_state:
0054ACr 3  05 00                .byte 5, 0
0054AEr 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
0054B2r 3  rr rr        
0054B4r 3  73 74 61 74          .byte "state"
0054B8r 3  65           
0054B9r 3               
0054B9r 3               nt_again:
0054B9r 3  05 17                .byte 5, AN+CO+IM+UF
0054BBr 3  rr rr rr rr          .word nt_state, xt_again, z_again
0054BFr 3  rr rr        
0054C1r 3  61 67 61 69          .byte "again"
0054C5r 3  6E           
0054C6r 3               
0054C6r 3               nt_begin:
0054C6r 3  05 07                .byte 5, AN+CO+IM
0054C8r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
0054CCr 3  rr rr        
0054CEr 3  62 65 67 69          .byte "begin"
0054D2r 3  6E           
0054D3r 3               
0054D3r 3               nt_quit:
0054D3r 3  04 00                .byte 4, 0
0054D5r 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
0054D9r 3  rr rr        
0054DBr 3  71 75 69 74          .byte "quit"
0054DFr 3               
0054DFr 3               nt_recurse:
0054DFr 3  07 0D                .byte 7, CO+IM+NN
0054E1r 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
0054E5r 3  rr rr        
0054E7r 3  72 65 63 75          .byte "recurse"
0054EBr 3  72 73 65     
0054EEr 3               
0054EEr 3               nt_leave:
0054EEr 3  05 03                .byte 5, AN+CO
0054F0r 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
0054F4r 3  rr rr        
0054F6r 3  6C 65 61 76          .byte "leave"
0054FAr 3  65           
0054FBr 3               
0054FBr 3               nt_unloop:
0054FBr 3  06 03                .byte 6, AN+CO
0054FDr 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
005501r 3  rr rr        
005503r 3  75 6E 6C 6F          .byte "unloop"
005507r 3  6F 70        
005509r 3               
005509r 3               nt_exit:
005509r 3  04 03                .byte 4, AN+CO
00550Br 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
00550Fr 3  rr rr        
005511r 3  65 78 69 74          .byte "exit"
005515r 3               
005515r 3               nt_plus_loop:
005515r 3  05 05                .byte 5, CO+IM
005517r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
00551Br 3  rr rr        
00551Dr 3  2B 6C 6F 6F          .byte "+loop"
005521r 3  70           
005522r 3               
005522r 3               nt_loop:
005522r 3  04 05                .byte 4, CO+IM
005524r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
005528r 3  rr rr        
00552Ar 3  6C 6F 6F 70          .byte "loop"
00552Er 3               
00552Er 3               nt_j:
00552Er 3  01 03                .byte 1, AN+CO
005530r 3  rr rr rr rr          .word nt_loop, xt_j, z_j
005534r 3  rr rr        
005536r 3  6A                   .byte "j"
005537r 3               
005537r 3               nt_i:
005537r 3  01 03                .byte 1, AN+CO
005539r 3  rr rr rr rr          .word nt_j, xt_i, z_i
00553Dr 3  rr rr        
00553Fr 3  69                   .byte "i"
005540r 3               
005540r 3               nt_question_do:
005540r 3  03 0D                .byte 3, CO+IM+NN
005542r 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
005546r 3  rr rr        
005548r 3  3F 64 6F             .byte "?do"
00554Br 3               
00554Br 3               nt_do:
00554Br 3  02 0D                .byte 2, CO+IM+NN
00554Dr 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
005551r 3  rr rr        
005553r 3  64 6F                .byte "do"
005555r 3               
005555r 3               nt_abort_quote:
005555r 3  06 0D                .byte 6, CO+IM+NN
005557r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
00555Br 3  rr rr        
00555Dr 3  61 62 6F 72          .byte "abort", $22
005561r 3  74 22        
005563r 3               
005563r 3               nt_abort:
005563r 3  05 00                .byte 5, 0
005565r 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
005569r 3  rr rr        
00556Br 3  61 62 6F 72          .byte "abort"
00556Fr 3  74           
005570r 3               
005570r 3               nt_strip_underflow:
005570r 3  0F 00                .byte 15, 0
005572r 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
005576r 3  rr rr        
005578r 3  73 74 72 69          .byte "strip-underflow"
00557Cr 3  70 2D 75 6E  
005580r 3  64 65 72 66  
005587r 3               
005587r 3               nt_nc_limit:
005587r 3  08 00                .byte 8, 0
005589r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
00558Dr 3  rr rr        
00558Fr 3  6E 63 2D 6C          .byte "nc-limit"
005593r 3  69 6D 69 74  
005597r 3               
005597r 3               nt_allow_native:
005597r 3  0C 00                .byte 12, 0
005599r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
00559Dr 3  rr rr        
00559Fr 3  61 6C 6C 6F          .byte "allow-native"
0055A3r 3  77 2D 6E 61  
0055A7r 3  74 69 76 65  
0055ABr 3               
0055ABr 3               nt_always_native:
0055ABr 3  0D 00                .byte 13, 0
0055ADr 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
0055B1r 3  rr rr        
0055B3r 3  61 6C 77 61          .byte "always-native"
0055B7r 3  79 73 2D 6E  
0055BBr 3  61 74 69 76  
0055C0r 3               
0055C0r 3               nt_never_native:
0055C0r 3  0C 00                .byte 12, 0
0055C2r 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
0055C6r 3  rr rr        
0055C8r 3  6E 65 76 65          .byte "never-native"
0055CCr 3  72 2D 6E 61  
0055D0r 3  74 69 76 65  
0055D4r 3               
0055D4r 3               nt_compile_only:
0055D4r 3  0C 00                .byte 12, 0
0055D6r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
0055DAr 3  rr rr        
0055DCr 3  63 6F 6D 70          .byte "compile-only"
0055E0r 3  69 6C 65 2D  
0055E4r 3  6F 6E 6C 79  
0055E8r 3               
0055E8r 3               nt_immediate:
0055E8r 3  09 00                .byte 9, 0
0055EAr 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
0055EEr 3  rr rr        
0055F0r 3  69 6D 6D 65          .byte "immediate"
0055F4r 3  64 69 61 74  
0055F8r 3  65           
0055F9r 3               
0055F9r 3               nt_postpone:
0055F9r 3  08 05                .byte 8, IM+CO
0055FBr 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
0055FFr 3  rr rr        
005601r 3  70 6F 73 74          .byte "postpone"
005605r 3  70 6F 6E 65  
005609r 3               
005609r 3               nt_s_backslash_quote:
005609r 3  03 04                .byte 3, IM
00560Br 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
00560Fr 3  rr rr        
005611r 3  73 5C 22             .byte "s", $5C, $22
005614r 3               
005614r 3               nt_s_quote:
005614r 3  02 0C                .byte 2, IM+NN
005616r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
00561Ar 3  rr rr        
00561Cr 3  73 22                .byte "s", $22
00561Er 3               
00561Er 3               nt_dot_quote:
00561Er 3  02 05                .byte 2, CO+IM
005620r 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
005624r 3  rr rr        
005626r 3  2E 22                .byte ".", $22
005628r 3               
005628r 3               nt_sliteral:
005628r 3  08 15                .byte 8, CO+IM+UF
00562Ar 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
00562Er 3  rr rr        
005630r 3  73 6C 69 74          .byte "sliteral"
005634r 3  65 72 61 6C  
005638r 3               
005638r 3               nt_literal:
005638r 3  07 15                .byte 7, IM+CO+UF
00563Ar 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
00563Er 3  rr rr        
005640r 3  6C 69 74 65          .byte "literal"
005644r 3  72 61 6C     
005647r 3               
005647r 3               nt_right_bracket:
005647r 3  01 04                .byte 1, IM
005649r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
00564Dr 3  rr rr        
00564Fr 3  5D                   .byte "]"
005650r 3               
005650r 3               nt_left_bracket:
005650r 3  01 05                .byte 1, IM+CO
005652r 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
005656r 3  rr rr        
005658r 3  5B                   .byte "["
005659r 3               
005659r 3               nt_compile_comma:
005659r 3  08 18                .byte 8, UF+NN
00565Br 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
00565Fr 3  rr rr        
005661r 3  63 6F 6D 70          .byte "compile,"
005665r 3  69 6C 65 2C  
005669r 3               
005669r 3               nt_colon_noname:
005669r 3  07 00                .byte 7, 0
00566Br 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
00566Fr 3  rr rr        
005671r 3  3A 6E 6F 6E          .byte ":noname"
005675r 3  61 6D 65     
005678r 3               
005678r 3               nt_semicolon:
005678r 3  01 05                .byte 1, CO+IM
00567Ar 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
00567Er 3  rr rr        
005680r 3  3B                   .byte ";"
005681r 3               
005681r 3               nt_colon:
005681r 3  01 00                .byte 1, 0
005683r 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
005687r 3  rr rr        
005689r 3  3A                   .byte ":"
00568Ar 3               
00568Ar 3               nt_source_id:
00568Ar 3  09 00                .byte 9, 0
00568Cr 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
005690r 3  rr rr        
005692r 3  73 6F 75 72          .byte "source-id"
005696r 3  63 65 2D 69  
00569Ar 3  64           
00569Br 3               
00569Br 3               nt_source:
00569Br 3  06 00                .byte 6, 0
00569Dr 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
0056A1r 3  rr rr        
0056A3r 3  73 6F 75 72          .byte "source"
0056A7r 3  63 65        
0056A9r 3               
0056A9r 3               nt_execute_parsing:
0056A9r 3  0F 10                .byte 15, UF
0056ABr 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
0056AFr 3  rr rr        
0056B1r 3  65 78 65 63          .byte "execute-parsing"
0056B5r 3  75 74 65 2D  
0056B9r 3  70 61 72 73  
0056C0r 3               
0056C0r 3               nt_parse:
0056C0r 3  05 10                .byte 5, UF
0056C2r 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
0056C6r 3  rr rr        
0056C8r 3  70 61 72 73          .byte "parse"
0056CCr 3  65           
0056CDr 3               
0056CDr 3               nt_parse_name:
0056CDr 3  0A 08                .byte 10, NN
0056CFr 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
0056D3r 3  rr rr        
0056D5r 3  70 61 72 73          .byte "parse-name"
0056D9r 3  65 2D 6E 61  
0056DDr 3  6D 65        
0056DFr 3               
0056DFr 3               nt_latestnt:
0056DFr 3  08 00                .byte 8, 0
0056E1r 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
0056E5r 3  rr rr        
0056E7r 3  6C 61 74 65          .byte "latestnt"
0056EBr 3  73 74 6E 74  
0056EFr 3               
0056EFr 3               nt_latestxt:
0056EFr 3  08 00                .byte 8, 0
0056F1r 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
0056F5r 3  rr rr        
0056F7r 3  6C 61 74 65          .byte "latestxt"
0056FBr 3  73 74 78 74  
0056FFr 3               
0056FFr 3               nt_defer:
0056FFr 3  05 00                .byte 5, 0
005701r 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
005705r 3  rr rr        
005707r 3  64 65 66 65          .byte "defer"
00570Br 3  72           
00570Cr 3               
00570Cr 3               nt_to_body:
00570Cr 3  05 10                .byte 5, UF
00570Er 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
005712r 3  rr rr        
005714r 3  3E 62 6F 64          .byte ">body"
005718r 3  79           
005719r 3               
005719r 3               nt_name_to_string:
005719r 3  0B 10                .byte 11, UF
00571Br 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
00571Fr 3  rr rr        
005721r 3  6E 61 6D 65          .byte "name>string"
005725r 3  3E 73 74 72  
005729r 3  69 6E 67     
00572Cr 3               
00572Cr 3               nt_int_to_name:
00572Cr 3  08 10                .byte 8, UF
00572Er 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
005732r 3  rr rr        
005734r 3  69 6E 74 3E          .byte "int>name"
005738r 3  6E 61 6D 65  
00573Cr 3               
00573Cr 3               nt_name_to_int:
00573Cr 3  08 10                .byte 8, UF
00573Er 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
005742r 3  rr rr        
005744r 3  6E 61 6D 65          .byte "name>int"
005748r 3  3E 69 6E 74  
00574Cr 3               
00574Cr 3               nt_bracket_tick:
00574Cr 3  03 05                .byte 3, CO+IM
00574Er 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
005752r 3  rr rr        
005754r 3  5B 27 5D             .byte "[']"
005757r 3               
005757r 3               nt_tick:
005757r 3  01 00                .byte 1, 0
005759r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
00575Dr 3  rr rr        
00575Fr 3  27                   .byte "'"
005760r 3               
005760r 3               nt_find_name:
005760r 3  09 10                .byte 9, UF
005762r 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
005766r 3  rr rr        
005768r 3  66 69 6E 64          .byte "find-name"
00576Cr 3  2D 6E 61 6D  
005770r 3  65           
005771r 3               
005771r 3               nt_fill:
005771r 3  04 10                .byte 4, UF
005773r 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
005777r 3  rr rr        
005779r 3  66 69 6C 6C          .byte "fill"
00577Dr 3               
00577Dr 3               nt_blank:
00577Dr 3  05 00                .byte 5, 0     ; underflow checked by FILL
00577Fr 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
005783r 3  rr rr        
005785r 3  62 6C 61 6E          .byte "blank"
005789r 3  6B           
00578Ar 3               
00578Ar 3               nt_erase:
00578Ar 3  05 00                .byte 5, 0      ; underflow checked by FILL
00578Cr 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
005790r 3  rr rr        
005792r 3  65 72 61 73          .byte "erase"
005796r 3  65           
005797r 3               
005797r 3               nt_d_plus:
005797r 3  02 10                .byte 2, UF
005799r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
00579Dr 3  rr rr        
00579Fr 3  64 2B                .byte "d+"
0057A1r 3               
0057A1r 3               nt_d_minus:
0057A1r 3  02 10                .byte 2, UF
0057A3r 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
0057A7r 3  rr rr        
0057A9r 3  64 2D                .byte "d-"
0057ABr 3               
0057ABr 3               nt_d_to_s:
0057ABr 3  03 10                .byte 3, UF
0057ADr 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
0057B1r 3  rr rr        
0057B3r 3  64 3E 73             .byte "d>s"
0057B6r 3               
0057B6r 3               nt_s_to_d:
0057B6r 3  03 10                .byte 3, UF
0057B8r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
0057BCr 3  rr rr        
0057BEr 3  73 3E 64             .byte "s>d"
0057C1r 3               
0057C1r 3               nt_to:
0057C1r 3  02 0C                .byte 2, NN+IM
0057C3r 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
0057C7r 3  rr rr        
0057C9r 3  74 6F                .byte "to"
0057CBr 3               
0057CBr 3               nt_value:               ; same code as CONSTANT
0057CBr 3  05 10                .byte 5, UF
0057CDr 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
0057D1r 3  rr rr        
0057D3r 3  76 61 6C 75          .byte "value"
0057D7r 3  65           
0057D8r 3               
0057D8r 3               nt_constant:
0057D8r 3  08 10                .byte 8, UF
0057DAr 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
0057DEr 3  rr rr        
0057E0r 3  63 6F 6E 73          .byte "constant"
0057E4r 3  74 61 6E 74  
0057E8r 3               
0057E8r 3               nt_variable:
0057E8r 3  08 00                .byte 8, 0
0057EAr 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
0057EEr 3  rr rr        
0057F0r 3  76 61 72 69          .byte "variable"
0057F4r 3  61 62 6C 65  
0057F8r 3               
0057F8r 3               nt_does:
0057F8r 3  05 05                .byte 5, CO+IM
0057FAr 3  rr rr rr rr          .word nt_variable, xt_does, z_does
0057FEr 3  rr rr        
005800r 3  64 6F 65 73          .byte "does>"
005804r 3  3E           
005805r 3               
005805r 3               nt_create:
005805r 3  06 00                .byte 6, 0
005807r 3  rr rr rr rr          .word nt_does, xt_create, z_create
00580Br 3  rr rr        
00580Dr 3  63 72 65 61          .byte "create"
005811r 3  74 65        
005813r 3               
005813r 3               nt_allot:
005813r 3  05 10                .byte 5, UF
005815r 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
005819r 3  rr rr        
00581Br 3  61 6C 6C 6F          .byte "allot"
00581Fr 3  74           
005820r 3               
005820r 3               nt_key:
005820r 3  03 00                .byte 3, 0
005822r 3  rr rr rr rr          .word nt_allot, xt_key, z_key
005826r 3  rr rr        
005828r 3  6B 65 79             .byte "key"
00582Br 3               
00582Br 3               nt_depth:
00582Br 3  05 00                .byte 5, 0
00582Dr 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
005831r 3  rr rr        
005833r 3  64 65 70 74          .byte "depth"
005837r 3  68           
005838r 3               
005838r 3               nt_unused:
005838r 3  06 00                .byte 6, 0
00583Ar 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
00583Er 3  rr rr        
005840r 3  75 6E 75 73          .byte "unused"
005844r 3  65 64        
005846r 3               
005846r 3               nt_r_to_input:
005846r 3  07 08                .byte 7, NN
005848r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
00584Cr 3  rr rr        
00584Er 3  72 3E 69 6E          .byte "r>input"
005852r 3  70 75 74     
005855r 3               
005855r 3               nt_input_to_r:
005855r 3  07 08                .byte 7, NN
005857r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
00585Br 3  rr rr        
00585Dr 3  69 6E 70 75          .byte "input>r"
005861r 3  74 3E 72     
005864r 3               
005864r 3               nt_accept:
005864r 3  06 18                .byte 6, UF+NN
005866r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
00586Ar 3  rr rr        
00586Cr 3  61 63 63 65          .byte "accept"
005870r 3  70 74        
005872r 3               
005872r 3               nt_refill:
005872r 3  06 00                .byte 6, 0
005874r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
005878r 3  rr rr        
00587Ar 3  72 65 66 69          .byte "refill"
00587Er 3  6C 6C        
005880r 3               
005880r 3               nt_slash_string:
005880r 3  07 10                .byte 7, UF
005882r 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
005886r 3  rr rr        
005888r 3  2F 73 74 72          .byte "/string"
00588Cr 3  69 6E 67     
00588Fr 3               
00588Fr 3               nt_minus_leading:
00588Fr 3  08 10                .byte 8, UF
005891r 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
005895r 3  rr rr        
005897r 3  2D 6C 65 61          .byte "-leading"
00589Br 3  64 69 6E 67  
00589Fr 3               
00589Fr 3               nt_minus_trailing:
00589Fr 3  09 10                .byte 9, UF
0058A1r 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
0058A5r 3  rr rr        
0058A7r 3  2D 74 72 61          .byte "-trailing"
0058ABr 3  69 6C 69 6E  
0058AFr 3  67           
0058B0r 3               
0058B0r 3               nt_bl:
0058B0r 3  02 00                .byte 2, 0
0058B2r 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
0058B6r 3  rr rr        
0058B8r 3  62 6C                .byte "bl"
0058BAr 3               
0058BAr 3               nt_spaces:
0058BAr 3  06 10                .byte 6, UF
0058BCr 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
0058C0r 3  rr rr        
0058C2r 3  73 70 61 63          .byte "spaces"
0058C6r 3  65 73        
0058C8r 3               
0058C8r 3               nt_bounds:
0058C8r 3  06 10                .byte 6, UF
0058CAr 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
0058CEr 3  rr rr        
0058D0r 3  62 6F 75 6E          .byte "bounds"
0058D4r 3  64 73        
0058D6r 3               
0058D6r 3               nt_c_comma:
0058D6r 3  02 10                .byte 2, UF
0058D8r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
0058DCr 3  rr rr        
0058DEr 3  63 2C                .byte "c,"
0058E0r 3               
0058E0r 3               nt_dnegate:
0058E0r 3  07 10                .byte 7, UF
0058E2r 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
0058E6r 3  rr rr        
0058E8r 3  64 6E 65 67          .byte "dnegate"
0058ECr 3  61 74 65     
0058EFr 3               
0058EFr 3               nt_negate:
0058EFr 3  06 10                .byte 6, UF
0058F1r 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
0058F5r 3  rr rr        
0058F7r 3  6E 65 67 61          .byte "negate"
0058FBr 3  74 65        
0058FDr 3               
0058FDr 3               nt_invert:
0058FDr 3  06 10                .byte 6, UF
0058FFr 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
005903r 3  rr rr        
005905r 3  69 6E 76 65          .byte "invert"
005909r 3  72 74        
00590Br 3               
00590Br 3               nt_two_to_r:
00590Br 3  03 11                .byte 3, CO+UF          ; native is special case
00590Dr 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
005911r 3  rr rr        
005913r 3  32 3E 72             .byte "2>r"
005916r 3               
005916r 3               nt_two_r_from:
005916r 3  03 01                .byte 3, CO             ; native is special case
005918r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
00591Cr 3  rr rr        
00591Er 3  32 72 3E             .byte "2r>"
005921r 3               
005921r 3               nt_two_r_fetch:
005921r 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
005923r 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
005927r 3  rr rr        
005929r 3  32 72 40             .byte "2r@"
00592Cr 3               
00592Cr 3               nt_two_literal:
00592Cr 3  08 14                .byte 8, UF+IM
00592Er 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
005932r 3  rr rr        
005934r 3  32 6C 69 74          .byte "2literal"
005938r 3  65 72 61 6C  
00593Cr 3               
00593Cr 3               nt_two_constant:
00593Cr 3  09 10                .byte 9, UF
00593Er 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
005942r 3  rr rr        
005944r 3  32 63 6F 6E          .byte "2constant"
005948r 3  73 74 61 6E  
00594Cr 3  74           
00594Dr 3               
00594Dr 3               nt_two_variable:
00594Dr 3  09 00                .byte 9, 0
00594Fr 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
005953r 3  rr rr        
005955r 3  32 76 61 72          .byte "2variable"
005959r 3  69 61 62 6C  
00595Dr 3  65           
00595Er 3               
00595Er 3               nt_two_fetch:
00595Er 3  02 10                .byte 2, UF
005960r 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
005964r 3  rr rr        
005966r 3  32 40                .byte "2@"
005968r 3               
005968r 3               nt_two_store:
005968r 3  02 10                .byte 2, UF
00596Ar 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
00596Er 3  rr rr        
005970r 3  32 21                .byte "2!"
005972r 3               
005972r 3               nt_two_over:
005972r 3  05 10                .byte 5, UF
005974r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
005978r 3  rr rr        
00597Ar 3  32 6F 76 65          .byte "2over"
00597Er 3  72           
00597Fr 3               
00597Fr 3               nt_two_swap:
00597Fr 3  05 10                .byte 5, UF
005981r 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
005985r 3  rr rr        
005987r 3  32 73 77 61          .byte "2swap"
00598Br 3  70           
00598Cr 3               
00598Cr 3               nt_two_drop:
00598Cr 3  05 10                .byte 5, UF
00598Er 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
005992r 3  rr rr        
005994r 3  32 64 72 6F          .byte "2drop"
005998r 3  70           
005999r 3               
005999r 3               nt_max:
005999r 3  03 10                .byte 3, UF
00599Br 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
00599Fr 3  rr rr        
0059A1r 3  6D 61 78             .byte "max"
0059A4r 3               
0059A4r 3               nt_min:
0059A4r 3  03 10                .byte 3, UF
0059A6r 3  rr rr rr rr          .word nt_max, xt_min, z_min
0059AAr 3  rr rr        
0059ACr 3  6D 69 6E             .byte "min"
0059AFr 3               
0059AFr 3               nt_zero_less:
0059AFr 3  02 10                .byte 2, UF
0059B1r 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
0059B5r 3  rr rr        
0059B7r 3  30 3C                .byte "0<"
0059B9r 3               
0059B9r 3               nt_zero_greater:
0059B9r 3  02 10                .byte 2, UF
0059BBr 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
0059BFr 3  rr rr        
0059C1r 3  30 3E                .byte "0>"
0059C3r 3               
0059C3r 3               nt_zero_unequal:
0059C3r 3  03 10                .byte 3, UF
0059C5r 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
0059C9r 3  rr rr        
0059CBr 3  30 3C 3E             .byte "0<>"
0059CEr 3               
0059CEr 3               nt_zero_equal:
0059CEr 3  02 10                .byte 2, UF
0059D0r 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
0059D4r 3  rr rr        
0059D6r 3  30 3D                .byte "0="
0059D8r 3               
0059D8r 3               nt_greater_than:
0059D8r 3  01 10                .byte 1, UF
0059DAr 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
0059DEr 3  rr rr        
0059E0r 3  3E                   .byte ">"
0059E1r 3               
0059E1r 3               nt_u_greater_than:
0059E1r 3  02 10                .byte 2, UF
0059E3r 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
0059E7r 3  rr rr        
0059E9r 3  75 3E                .byte "u>"
0059EBr 3               
0059EBr 3               nt_u_less_than:
0059EBr 3  02 10                .byte 2, UF
0059EDr 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
0059F1r 3  rr rr        
0059F3r 3  75 3C                .byte "u<"
0059F5r 3               
0059F5r 3               nt_less_than:
0059F5r 3  01 10                .byte 1, UF
0059F7r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
0059FBr 3  rr rr        
0059FDr 3  3C                   .byte "<"
0059FEr 3               
0059FEr 3               nt_not_equals:
0059FEr 3  02 10                .byte 2, UF
005A00r 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
005A04r 3  rr rr        
005A06r 3  3C 3E                .byte "<>"
005A08r 3               
005A08r 3               nt_equal:
005A08r 3  01 10                .byte 1, UF
005A0Ar 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
005A0Er 3  rr rr        
005A10r 3  3D                   .byte "="
005A11r 3               
005A11r 3               nt_two_slash:
005A11r 3  02 10                .byte 2, UF
005A13r 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
005A17r 3  rr rr        
005A19r 3  32 2F                .byte "2/"
005A1Br 3               
005A1Br 3               nt_two_star:
005A1Br 3  02 10                .byte 2, UF
005A1Dr 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
005A21r 3  rr rr        
005A23r 3  32 2A                .byte "2*"
005A25r 3               
005A25r 3               nt_one_plus:
005A25r 3  02 10                .byte 2, UF
005A27r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
005A2Br 3  rr rr        
005A2Dr 3  31 2B                .byte "1+"
005A2Fr 3               
005A2Fr 3               nt_one_minus:
005A2Fr 3  02 10                .byte 2, UF
005A31r 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
005A35r 3  rr rr        
005A37r 3  31 2D                .byte "1-"
005A39r 3               
005A39r 3               nt_here:
005A39r 3  04 00                .byte 4, 0
005A3Br 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
005A3Fr 3  rr rr        
005A41r 3  68 65 72 65          .byte "here"
005A45r 3               
005A45r 3               nt_cell_plus:
005A45r 3  05 10                .byte 5, UF
005A47r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
005A4Br 3  rr rr        
005A4Dr 3  63 65 6C 6C          .byte "cell+"
005A51r 3  2B           
005A52r 3               
005A52r 3               nt_cells:
005A52r 3  05 00                .byte 5, 0
005A54r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
005A58r 3  rr rr        
005A5Ar 3  63 65 6C 6C          .byte "cells"
005A5Er 3  73           
005A5Fr 3               
005A5Fr 3               nt_chars:
005A5Fr 3  05 12                .byte 5, AN+UF   ; deleted during compile
005A61r 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
005A65r 3  rr rr        
005A67r 3  63 68 61 72          .byte "chars"
005A6Br 3  73           
005A6Cr 3               
005A6Cr 3               nt_char_plus:
005A6Cr 3  05 00                .byte 5, 0
005A6Er 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
005A72r 3  rr rr        
005A74r 3  63 68 61 72          .byte "char+"
005A78r 3  2B           
005A79r 3               
005A79r 3               nt_bracket_char:
005A79r 3  06 05                .byte 6, CO+IM
005A7Br 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
005A7Fr 3  rr rr        
005A81r 3  5B 63 68 61          .byte "[char]"
005A85r 3  72 5D        
005A87r 3               
005A87r 3               nt_char:
005A87r 3  04 00                .byte 4, 0
005A89r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
005A8Dr 3  rr rr        
005A8Fr 3  63 68 61 72          .byte "char"
005A93r 3               
005A93r 3               nt_pick:
005A93r 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
005A95r 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
005A99r 3  rr rr        
005A9Br 3  70 69 63 6B          .byte "pick"
005A9Fr 3               
005A9Fr 3               nt_lshift:
005A9Fr 3  06 10                .byte 6, UF
005AA1r 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
005AA5r 3  rr rr        
005AA7r 3  6C 73 68 69          .byte "lshift"
005AABr 3  66 74        
005AADr 3               
005AADr 3               nt_rshift:
005AADr 3  06 10                .byte 6, UF
005AAFr 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
005AB3r 3  rr rr        
005AB5r 3  72 73 68 69          .byte "rshift"
005AB9r 3  66 74        
005ABBr 3               
005ABBr 3               nt_xor:
005ABBr 3  03 10                .byte 3, UF
005ABDr 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
005AC1r 3  rr rr        
005AC3r 3  78 6F 72             .byte "xor"
005AC6r 3               
005AC6r 3               nt_or:
005AC6r 3  02 10                .byte 2, UF
005AC8r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
005ACCr 3  rr rr        
005ACEr 3  6F 72                .byte "or"
005AD0r 3               
005AD0r 3               nt_and:
005AD0r 3  03 10                .byte 3, UF
005AD2r 3  rr rr rr rr          .word nt_or, xt_and, z_and
005AD6r 3  rr rr        
005AD8r 3  61 6E 64             .byte "and"
005ADBr 3               
005ADBr 3               nt_dabs:
005ADBr 3  04 10                .byte 4, UF
005ADDr 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
005AE1r 3  rr rr        
005AE3r 3  64 61 62 73          .byte "dabs"
005AE7r 3               
005AE7r 3               nt_abs:
005AE7r 3  03 10                .byte 3, UF
005AE9r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
005AEDr 3  rr rr        
005AEFr 3  61 62 73             .byte "abs"
005AF2r 3               
005AF2r 3               nt_minus:
005AF2r 3  01 10                .byte 1, UF
005AF4r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
005AF8r 3  rr rr        
005AFAr 3  2D                   .byte "-"
005AFBr 3               
005AFBr 3               nt_plus:
005AFBr 3  01 10                .byte 1, UF
005AFDr 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
005B01r 3  rr rr        
005B03r 3  2B                   .byte "+"
005B04r 3               
005B04r 3               nt_question_dup:
005B04r 3  04 10                .byte 4, UF
005B06r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
005B0Ar 3  rr rr        
005B0Cr 3  3F 64 75 70          .byte "?dup"
005B10r 3               
005B10r 3               nt_two_dup:
005B10r 3  04 10                .byte 4, UF
005B12r 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
005B16r 3  rr rr        
005B18r 3  32 64 75 70          .byte "2dup"
005B1Cr 3               
005B1Cr 3               nt_two:
005B1Cr 3  01 00                .byte 1, 0
005B1Er 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
005B22r 3  rr rr        
005B24r 3  32                   .byte "2"
005B25r 3               
005B25r 3               nt_one:
005B25r 3  01 00                .byte 1, 0
005B27r 3  rr rr rr rr          .word nt_two, xt_one, z_one
005B2Br 3  rr rr        
005B2Dr 3  31                   .byte "1"
005B2Er 3               
005B2Er 3               nt_zero:
005B2Er 3  01 00                .byte 1, 0
005B30r 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
005B34r 3  rr rr        
005B36r 3  30                   .byte "0"
005B37r 3               
005B37r 3               nt_space:
005B37r 3  05 00                .byte 5, 0
005B39r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
005B3Dr 3  rr rr        
005B3Fr 3  73 70 61 63          .byte "space"
005B43r 3  65           
005B44r 3               
005B44r 3               nt_true:
005B44r 3  04 00                .byte 4, 0
005B46r 3  rr rr rr rr          .word nt_space, xt_true, z_true
005B4Ar 3  rr rr        
005B4Cr 3  74 72 75 65          .byte "true"
005B50r 3               
005B50r 3               nt_false:
005B50r 3  05 00                .byte 5, 0
005B52r 3  rr rr rr rr          .word nt_true, xt_false, z_false
005B56r 3  rr rr        
005B58r 3  66 61 6C 73          .byte "false"
005B5Cr 3  65           
005B5Dr 3               
005B5Dr 3               nt_question:
005B5Dr 3  01 00                .byte 1, 0
005B5Fr 3  rr rr rr rr          .word nt_false, xt_question, z_question
005B63r 3  rr rr        
005B65r 3  3F                   .byte "?"
005B66r 3               
005B66r 3               nt_ud_dot_r:
005B66r 3  04 10                .byte 4, UF
005B68r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
005B6Cr 3  rr rr        
005B6Er 3  75 64 2E 72          .byte "ud.r"
005B72r 3               
005B72r 3               nt_ud_dot:
005B72r 3  03 10                .byte 3, UF
005B74r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
005B78r 3  rr rr        
005B7Ar 3  75 64 2E             .byte "ud."
005B7Dr 3               
005B7Dr 3               nt_d_dot_r:
005B7Dr 3  03 10                .byte 3, UF
005B7Fr 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
005B83r 3  rr rr        
005B85r 3  64 2E 72             .byte "d.r"
005B88r 3               
005B88r 3               nt_d_dot:
005B88r 3  02 10                .byte 2, UF
005B8Ar 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
005B8Er 3  rr rr        
005B90r 3  64 2E                .byte "d."
005B92r 3               
005B92r 3               nt_dot_r:
005B92r 3  02 10                .byte 2, UF
005B94r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
005B98r 3  rr rr        
005B9Ar 3  2E 72                .byte ".r"
005B9Cr 3               
005B9Cr 3               nt_u_dot_r:
005B9Cr 3  03 10                .byte 3, UF
005B9Er 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
005BA2r 3  rr rr        
005BA4r 3  75 2E 72             .byte "u.r"
005BA7r 3               
005BA7r 3               nt_u_dot:
005BA7r 3  02 10                .byte 2, UF
005BA9r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
005BADr 3  rr rr        
005BAFr 3  75 2E                .byte "u."
005BB1r 3               
005BB1r 3               nt_dot:
005BB1r 3  01 10                .byte 1, UF
005BB3r 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
005BB7r 3  rr rr        
005BB9r 3  2E                   .byte "."
005BBAr 3               
005BBAr 3               nt_type:
005BBAr 3  04 10                .byte 4, UF
005BBCr 3  rr rr rr rr          .word nt_dot, xt_type, z_type
005BC0r 3  rr rr        
005BC2r 3  74 79 70 65          .byte "type"
005BC6r 3               
005BC6r 3               nt_emit:
005BC6r 3  04 18                .byte 4, NN+UF
005BC8r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
005BCCr 3  rr rr        
005BCEr 3  65 6D 69 74          .byte "emit"
005BD2r 3               
005BD2r 3               nt_execute:
005BD2r 3  07 10                .byte 7, UF
005BD4r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
005BD8r 3  rr rr        
005BDAr 3  65 78 65 63          .byte "execute"
005BDEr 3  75 74 65     
005BE1r 3               
005BE1r 3               nt_plus_store:
005BE1r 3  02 10                .byte 2, UF
005BE3r 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
005BE7r 3  rr rr        
005BE9r 3  2B 21                .byte "+!"
005BEBr 3               
005BEBr 3               nt_c_store:
005BEBr 3  02 10                .byte 2, UF
005BEDr 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
005BF1r 3  rr rr        
005BF3r 3  63 21                .byte "c!"
005BF5r 3               
005BF5r 3               nt_c_fetch:
005BF5r 3  02 10                .byte 2, UF
005BF7r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
005BFBr 3  rr rr        
005BFDr 3  63 40                .byte "c@"
005BFFr 3               
005BFFr 3               nt_comma:
005BFFr 3  01 10                .byte 1, UF
005C01r 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
005C05r 3  rr rr        
005C07r 3  2C                   .byte ","
005C08r 3               
005C08r 3               nt_tuck:
005C08r 3  04 10                .byte 4, UF
005C0Ar 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
005C0Er 3  rr rr        
005C10r 3  74 75 63 6B          .byte "tuck"
005C14r 3               
005C14r 3               nt_not_rote:
005C14r 3  04 10                .byte 4, UF
005C16r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
005C1Ar 3  rr rr        
005C1Cr 3  2D 72 6F 74          .byte "-rot"
005C20r 3               
005C20r 3               nt_rot:
005C20r 3  03 10                .byte 3, UF
005C22r 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
005C26r 3  rr rr        
005C28r 3  72 6F 74             .byte "rot"
005C2Br 3               
005C2Br 3               nt_nip:
005C2Br 3  03 10                .byte 3, UF
005C2Dr 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
005C31r 3  rr rr        
005C33r 3  6E 69 70             .byte "nip"
005C36r 3               
005C36r 3               nt_r_fetch:
005C36r 3  02 01                .byte 2, CO    ; native is special case
005C38r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
005C3Cr 3  rr rr        
005C3Er 3  72 40                .byte "r@"
005C40r 3               
005C40r 3               nt_r_from:
005C40r 3  02 01                .byte 2, CO    ; native is special case
005C42r 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
005C46r 3  rr rr        
005C48r 3  72 3E                .byte "r>"
005C4Ar 3               
005C4Ar 3               nt_to_r:
005C4Ar 3  02 11                .byte 2, CO+UF ; native is special case
005C4Cr 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
005C50r 3  rr rr        
005C52r 3  3E 72                .byte ">r"
005C54r 3               
005C54r 3               nt_over:
005C54r 3  04 10                .byte 4, UF
005C56r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
005C5Ar 3  rr rr        
005C5Cr 3  6F 76 65 72          .byte "over"
005C60r 3               
005C60r 3               nt_fetch:
005C60r 3  01 10                .byte 1, UF
005C62r 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
005C66r 3  rr rr        
005C68r 3  40                   .byte "@"
005C69r 3               
005C69r 3               nt_store:
005C69r 3  01 10                .byte 1, UF
005C6Br 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
005C6Fr 3  rr rr        
005C71r 3  21                   .byte "!"
005C72r 3               
005C72r 3               nt_swap:
005C72r 3  04 10                .byte 4, UF
005C74r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
005C78r 3  rr rr        
005C7Ar 3  73 77 61 70          .byte "swap"
005C7Er 3               
005C7Er 3               nt_dup:
005C7Er 3  03 10                .byte 3, UF
005C80r 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
005C84r 3  rr rr        
005C86r 3  64 75 70             .byte "dup"
005C89r 3               
005C89r 3               ; DROP is always the first native word in the Dictionary
005C89r 3               dictionary_start:
005C89r 3               nt_drop:
005C89r 3  04 10                .byte 4, UF
005C8Br 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
005C8Fr 3  rr rr        
005C91r 3  64 72 6F 70          .byte "drop"
005C95r 3               
005C95r 3               ; END of FORTH-WORDLIST
005C95r 3               
005C95r 3               
005C95r 3               ; ROOT-WORDLIST
005C95r 3                       ; This is a short wordlist that has just the words needed to
005C95r 3                       ; set the wordlists. These words are also included in the
005C95r 3                       ; FORTH-WORDLIST as well.
005C95r 3               
005C95r 3               nt_root_words:
005C95r 3  05 00                .byte 5, 0
005C97r 3  00 00 rr rr          .word 0000, xt_words, z_words
005C9Br 3  rr rr        
005C9Dr 3  77 6F 72 64          .byte "words"
005CA1r 3  73           
005CA2r 3               
005CA2r 3               nt_root_forth_wordlist: ; shares code with ZERO
005CA2r 3  0E 00                .byte 14, 0
005CA4r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
005CA8r 3  rr rr        
005CAAr 3  66 6F 72 74          .byte "forth-wordlist"
005CAEr 3  68 2D 77 6F  
005CB2r 3  72 64 6C 69  
005CB8r 3               
005CB8r 3               nt_root_forth:
005CB8r 3  05 00                .byte 5, 0
005CBAr 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
005CBEr 3  rr rr        
005CC0r 3  66 6F 72 74          .byte "forth"
005CC4r 3  68           
005CC5r 3               
005CC5r 3               root_dictionary_start:
005CC5r 3               nt_root_set_order:
005CC5r 3  09 00                .byte 9, 0
005CC7r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
005CCBr 3  rr rr        
005CCDr 3  73 65 74 2D          .byte "set-order"
005CD1r 3  6F 72 64 65  
005CD5r 3  72           
005CD6r 3               
005CD6r 3               ; END of ROOT-WORDLIST
005CD6r 3               
005CD6r 3               
005CD6r 3               ; EDITOR-WORDLIST
005CD6r 3               
005CD6r 3               nt_editor_enter_screen:
005CD6r 3  0C 00                .byte 12, 0
005CD8r 3  00 00 rr rr          .word 0000, xt_editor_enter_screen, z_editor_enter_screen
005CDCr 3  rr rr        
005CDEr 3  65 6E 74 65          .byte "enter-screen"
005CE2r 3  72 2D 73 63  
005CE6r 3  72 65 65 6E  
005CEAr 3               
005CEAr 3               nt_editor_erase_screen:
005CEAr 3  0C 00                .byte 12, 0
005CECr 3  rr rr rr rr          .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
005CF0r 3  rr rr        
005CF2r 3  65 72 61 73          .byte "erase-screen"
005CF6r 3  65 2D 73 63  
005CFAr 3  72 65 65 6E  
005CFEr 3               
005CFEr 3               nt_editor_el:
005CFEr 3  02 00                .byte 2, 0
005D00r 3  rr rr rr rr          .word nt_editor_erase_screen, xt_editor_el, z_editor_el
005D04r 3  rr rr        
005D06r 3  65 6C                .byte "el"
005D08r 3               
005D08r 3               nt_editor_l:
005D08r 3  01 00                .byte 1, 0
005D0Ar 3  rr rr rr rr          .word nt_editor_el, xt_editor_l, z_editor_l
005D0Er 3  rr rr        
005D10r 3  6C                   .byte "l"
005D11r 3               
005D11r 3               nt_editor_line:
005D11r 3  04 10                .byte 4, UF
005D13r 3  rr rr rr rr          .word nt_editor_l, xt_editor_line, z_editor_line
005D17r 3  rr rr        
005D19r 3  6C 69 6E 65          .byte "line"
005D1Dr 3               
005D1Dr 3               editor_dictionary_start:
005D1Dr 3               nt_editor_o:
005D1Dr 3  01 00                .byte 1, 0
005D1Fr 3  rr rr rr rr          .word nt_editor_line, xt_editor_o, z_editor_o
005D23r 3  rr rr        
005D25r 3  6F                   .byte "o"
005D26r 3               
005D26r 3               ; END of EDITOR-WORDLIST
005D26r 3               
005D26r 3               
005D26r 3               ; ASSEMBLER-WORDLIST
005D26r 3               
005D26r 3               ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
005D26r 3               ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
005D26r 3               ; immediate addressing is replaced by an "h" (for example, the label code for
005D26r 3               ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
005D26r 3               assembler_dictionary_start:
005D26r 3               nt_asm_adc_h:
005D26r 3  05 04        		.byte 5, IM
005D28r 3  rr rr                        .word nt_asm_adc_x
005D2Ar 3  rr rr rr rr  		.word xt_asm_adc_h, z_asm_adc_h
005D2Er 3  61 64 63 2E  		.byte "adc.#"
005D32r 3  23           
005D33r 3               
005D33r 3               nt_asm_adc_x:
005D33r 3  05 04        		.byte 5, IM
005D35r 3  rr rr                        .word nt_asm_adc_y
005D37r 3  rr rr rr rr  		.word xt_asm_adc_x, z_asm_adc_x
005D3Br 3  61 64 63 2E  		.byte "adc.x"
005D3Fr 3  78           
005D40r 3               
005D40r 3               nt_asm_adc_y:
005D40r 3  05 04        		.byte 5, IM
005D42r 3  rr rr                        .word nt_asm_adc_z
005D44r 3  rr rr rr rr  		.word xt_asm_adc_y, z_asm_adc_y
005D48r 3  61 64 63 2E  		.byte "adc.y"
005D4Cr 3  79           
005D4Dr 3               
005D4Dr 3               nt_asm_adc_z:
005D4Dr 3  05 04        		.byte 5, IM
005D4Fr 3  rr rr                        .word nt_asm_adc_zi
005D51r 3  rr rr rr rr  		.word xt_asm_adc_z, z_asm_adc_z
005D55r 3  61 64 63 2E  		.byte "adc.z"
005D59r 3  7A           
005D5Ar 3               
005D5Ar 3               nt_asm_adc_zi:
005D5Ar 3  06 04        		.byte 6, IM
005D5Cr 3  rr rr                        .word nt_asm_adc_ziy
005D5Er 3  rr rr rr rr  		.word xt_asm_adc_zi, z_asm_adc_zi
005D62r 3  61 64 63 2E  		.byte "adc.zi"
005D66r 3  7A 69        
005D68r 3               
005D68r 3               nt_asm_adc_ziy:
005D68r 3  07 04        		.byte 7, IM
005D6Ar 3  rr rr                        .word nt_asm_adc_zx
005D6Cr 3  rr rr rr rr  		.word xt_asm_adc_ziy, z_asm_adc_ziy
005D70r 3  61 64 63 2E  		.byte "adc.ziy"
005D74r 3  7A 69 79     
005D77r 3               
005D77r 3               nt_asm_adc_zx:
005D77r 3  06 04        		.byte 6, IM
005D79r 3  rr rr                        .word nt_asm_adc_zxi
005D7Br 3  rr rr rr rr  		.word xt_asm_adc_zx, z_asm_adc_zx
005D7Fr 3  61 64 63 2E  		.byte "adc.zx"
005D83r 3  7A 78        
005D85r 3               
005D85r 3               nt_asm_adc_zxi:
005D85r 3  07 04        		.byte 7, IM
005D87r 3  rr rr                        .word nt_asm_and
005D89r 3  rr rr rr rr  		.word xt_asm_adc_zxi, z_asm_adc_zxi
005D8Dr 3  61 64 63 2E  		.byte "adc.zxi"
005D91r 3  7A 78 69     
005D94r 3               
005D94r 3               nt_asm_and:     ; not "and" because of conflicts with Forth word
005D94r 3  04 04        		.byte 4, IM
005D96r 3  rr rr                        .word nt_asm_and_h
005D98r 3  rr rr rr rr  		.word xt_asm_and, z_asm_and
005D9Cr 3  61 6E 64 2E  		.byte "and."
005DA0r 3               
005DA0r 3               nt_asm_and_h:
005DA0r 3  05 04        		.byte 5, IM
005DA2r 3  rr rr                        .word nt_asm_and_x
005DA4r 3  rr rr rr rr  		.word xt_asm_and_h, z_asm_and_h
005DA8r 3  61 6E 64 2E  		.byte "and.#"
005DACr 3  23           
005DADr 3               
005DADr 3               nt_asm_and_x:
005DADr 3  05 04        		.byte 5, IM
005DAFr 3  rr rr                        .word nt_asm_and_y
005DB1r 3  rr rr rr rr  		.word xt_asm_and_x, z_asm_and_x
005DB5r 3  61 6E 64 2E  		.byte "and.x"
005DB9r 3  78           
005DBAr 3               
005DBAr 3               nt_asm_and_y:
005DBAr 3  05 04        		.byte 5, IM
005DBCr 3  rr rr                        .word nt_asm_and_z
005DBEr 3  rr rr rr rr  		.word xt_asm_and_y, z_asm_and_y
005DC2r 3  61 6E 64 2E  		.byte "and.y"
005DC6r 3  79           
005DC7r 3               
005DC7r 3               nt_asm_and_z:
005DC7r 3  05 04        		.byte 5, IM
005DC9r 3  rr rr                        .word nt_asm_and_zi
005DCBr 3  rr rr rr rr  		.word xt_asm_and_z, z_asm_and_z
005DCFr 3  61 6E 64 2E  		.byte "and.z"
005DD3r 3  7A           
005DD4r 3               
005DD4r 3               nt_asm_and_zi:
005DD4r 3  06 04        		.byte 6, IM
005DD6r 3  rr rr                        .word nt_asm_and_ziy
005DD8r 3  rr rr rr rr  		.word xt_asm_and_zi, z_asm_and_zi
005DDCr 3  61 6E 64 2E  		.byte "and.zi"
005DE0r 3  7A 69        
005DE2r 3               
005DE2r 3               nt_asm_and_ziy:
005DE2r 3  07 04        		.byte 7, IM
005DE4r 3  rr rr                        .word nt_asm_and_zx
005DE6r 3  rr rr rr rr  		.word xt_asm_and_ziy, z_asm_and_ziy
005DEAr 3  61 6E 64 2E  		.byte "and.ziy"
005DEEr 3  7A 69 79     
005DF1r 3               
005DF1r 3               nt_asm_and_zx:
005DF1r 3  06 04        		.byte 6, IM
005DF3r 3  rr rr                        .word nt_asm_and_zxi
005DF5r 3  rr rr rr rr  		.word xt_asm_and_zx, z_asm_and_zx
005DF9r 3  61 6E 64 2E  		.byte "and.zx"
005DFDr 3  7A 78        
005DFFr 3               
005DFFr 3               nt_asm_and_zxi:
005DFFr 3  07 04        		.byte 7, IM
005E01r 3  rr rr                        .word nt_asm_asl
005E03r 3  rr rr rr rr  		.word xt_asm_and_zxi, z_asm_and_zxi
005E07r 3  61 6E 64 2E  		.byte "and.zxi"
005E0Br 3  7A 78 69     
005E0Er 3               
005E0Er 3               nt_asm_asl:
005E0Er 3  03 04        		.byte 3, IM
005E10r 3  rr rr                        .word nt_asm_asl_a
005E12r 3  rr rr rr rr  		.word xt_asm_asl, z_asm_asl
005E16r 3  61 73 6C     		.byte "asl"
005E19r 3               
005E19r 3               nt_asm_asl_a:
005E19r 3  05 04        		.byte 5, IM
005E1Br 3  rr rr                        .word nt_asm_asl_x
005E1Dr 3  rr rr rr rr  		.word xt_asm_asl_a, z_asm_asl_a
005E21r 3  61 73 6C 2E  		.byte "asl.a"
005E25r 3  61           
005E26r 3               
005E26r 3               nt_asm_asl_x:
005E26r 3  05 04        		.byte 5, IM
005E28r 3  rr rr                        .word nt_asm_asl_z
005E2Ar 3  rr rr rr rr  		.word xt_asm_asl_x, z_asm_asl_x
005E2Er 3  61 73 6C 2E  		.byte "asl.x"
005E32r 3  78           
005E33r 3               
005E33r 3               nt_asm_asl_z:
005E33r 3  05 04        		.byte 5, IM
005E35r 3  rr rr                        .word nt_asm_asl_zx
005E37r 3  rr rr rr rr  		.word xt_asm_asl_z, z_asm_asl_z
005E3Br 3  61 73 6C 2E  		.byte "asl.z"
005E3Fr 3  7A           
005E40r 3               
005E40r 3               nt_asm_asl_zx:
005E40r 3  06 04        		.byte 6, IM
005E42r 3  rr rr                        .word nt_asm_bcc
005E44r 3  rr rr rr rr  		.word xt_asm_asl_zx, z_asm_asl_zx
005E48r 3  61 73 6C 2E  		.byte "asl.zx"
005E4Cr 3  7A 78        
005E4Er 3               
005E4Er 3               nt_asm_bcc:
005E4Er 3  03 04        		.byte 3, IM
005E50r 3  rr rr                        .word nt_asm_bcs
005E52r 3  rr rr rr rr  		.word xt_asm_bcc, z_asm_bcc
005E56r 3  62 63 63     		.byte "bcc"
005E59r 3               
005E59r 3               nt_asm_bcs:
005E59r 3  03 04        		.byte 3, IM
005E5Br 3  rr rr                        .word nt_asm_beq
005E5Dr 3  rr rr rr rr  		.word xt_asm_bcs, z_asm_bcs
005E61r 3  62 63 73     		.byte "bcs"
005E64r 3               
005E64r 3               nt_asm_beq:
005E64r 3  03 04        		.byte 3, IM
005E66r 3  rr rr                        .word nt_asm_bit
005E68r 3  rr rr rr rr  		.word xt_asm_beq, z_asm_beq
005E6Cr 3  62 65 71     		.byte "beq"
005E6Fr 3               
005E6Fr 3               nt_asm_bit:
005E6Fr 3  03 04        		.byte 3, IM
005E71r 3  rr rr                        .word nt_asm_bit_h
005E73r 3  rr rr rr rr  		.word xt_asm_bit, z_asm_bit
005E77r 3  62 69 74     		.byte "bit"
005E7Ar 3               
005E7Ar 3               nt_asm_bit_h:
005E7Ar 3  05 04        		.byte 5, IM
005E7Cr 3  rr rr                        .word nt_asm_bit_x
005E7Er 3  rr rr rr rr  		.word xt_asm_bit_h, z_asm_bit_h
005E82r 3  62 69 74 2E  		.byte "bit.#"
005E86r 3  23           
005E87r 3               
005E87r 3               nt_asm_bit_x:
005E87r 3  05 04        		.byte 5, IM
005E89r 3  rr rr                        .word nt_asm_bit_z
005E8Br 3  rr rr rr rr  		.word xt_asm_bit_x, z_asm_bit_x
005E8Fr 3  62 69 74 2E  		.byte "bit.x"
005E93r 3  78           
005E94r 3               
005E94r 3               nt_asm_bit_z:
005E94r 3  05 04        		.byte 5, IM
005E96r 3  rr rr                        .word nt_asm_bit_zx
005E98r 3  rr rr rr rr  		.word xt_asm_bit_z, z_asm_bit_z
005E9Cr 3  62 69 74 2E  		.byte "bit.z"
005EA0r 3  7A           
005EA1r 3               
005EA1r 3               nt_asm_bit_zx:
005EA1r 3  06 04        		.byte 6, IM
005EA3r 3  rr rr                        .word nt_asm_bmi
005EA5r 3  rr rr rr rr  		.word xt_asm_bit_zx, z_asm_bit_zx
005EA9r 3  62 69 74 2E  		.byte "bit.zx"
005EADr 3  7A 78        
005EAFr 3               
005EAFr 3               nt_asm_bmi:
005EAFr 3  03 04        		.byte 3, IM
005EB1r 3  rr rr                        .word nt_asm_bne
005EB3r 3  rr rr rr rr  		.word xt_asm_bmi, z_asm_bmi
005EB7r 3  62 6D 69     		.byte "bmi"
005EBAr 3               
005EBAr 3               nt_asm_bne:
005EBAr 3  03 04        		.byte 3, IM
005EBCr 3  rr rr                        .word nt_asm_bpl
005EBEr 3  rr rr rr rr  		.word xt_asm_bne, z_asm_bne
005EC2r 3  62 6E 65     		.byte "bne"
005EC5r 3               
005EC5r 3               nt_asm_bpl:
005EC5r 3  03 04        		.byte 3, IM
005EC7r 3  rr rr                        .word nt_asm_bra
005EC9r 3  rr rr rr rr  		.word xt_asm_bpl, z_asm_bpl
005ECDr 3  62 70 6C     		.byte "bpl"
005ED0r 3               
005ED0r 3               nt_asm_bra:
005ED0r 3  03 04        		.byte 3, IM
005ED2r 3  rr rr                        .word nt_asm_brk
005ED4r 3  rr rr rr rr  		.word xt_asm_bra, z_asm_bra
005ED8r 3  62 72 61     		.byte "bra"
005EDBr 3               
005EDBr 3               nt_asm_brk:
005EDBr 3  03 04        		.byte 3, IM
005EDDr 3  rr rr                        .word nt_asm_bvc
005EDFr 3  rr rr rr rr  		.word xt_asm_brk, z_asm_brk
005EE3r 3  62 72 6B     		.byte "brk"
005EE6r 3               
005EE6r 3               nt_asm_bvc:
005EE6r 3  03 04        		.byte 3, IM
005EE8r 3  rr rr                        .word nt_asm_bvs
005EEAr 3  rr rr rr rr  		.word xt_asm_bvc, z_asm_bvc
005EEEr 3  62 76 63     		.byte "bvc"
005EF1r 3               
005EF1r 3               nt_asm_bvs:
005EF1r 3  03 04        		.byte 3, IM
005EF3r 3  rr rr                        .word nt_asm_clc
005EF5r 3  rr rr rr rr  		.word xt_asm_bvs, z_asm_bvs
005EF9r 3  62 76 73     		.byte "bvs"
005EFCr 3               
005EFCr 3               nt_asm_clc:
005EFCr 3  03 04        		.byte 3, IM
005EFEr 3  rr rr                        .word nt_asm_cld
005F00r 3  rr rr rr rr  		.word xt_asm_clc, z_asm_clc
005F04r 3  63 6C 63     		.byte "clc"
005F07r 3               
005F07r 3               nt_asm_cld:
005F07r 3  03 04        		.byte 3, IM
005F09r 3  rr rr                        .word nt_asm_cli
005F0Br 3  rr rr rr rr  		.word xt_asm_cld, z_asm_cld
005F0Fr 3  63 6C 64     		.byte "cld"
005F12r 3               
005F12r 3               nt_asm_cli:
005F12r 3  03 04        		.byte 3, IM
005F14r 3  rr rr                        .word nt_asm_clv
005F16r 3  rr rr rr rr  		.word xt_asm_cli, z_asm_cli
005F1Ar 3  63 6C 69     		.byte "cli"
005F1Dr 3               
005F1Dr 3               nt_asm_clv:
005F1Dr 3  03 04        		.byte 3, IM
005F1Fr 3  rr rr                        .word nt_asm_cmp
005F21r 3  rr rr rr rr  		.word xt_asm_clv, z_asm_clv
005F25r 3  63 6C 76     		.byte "clv"
005F28r 3               
005F28r 3               nt_asm_cmp:
005F28r 3  03 04        		.byte 3, IM
005F2Ar 3  rr rr                        .word nt_asm_cmp_h
005F2Cr 3  rr rr rr rr  		.word xt_asm_cmp, z_asm_cmp
005F30r 3  63 6D 70     		.byte "cmp"
005F33r 3               
005F33r 3               nt_asm_cmp_h:
005F33r 3  05 04        		.byte 5, IM
005F35r 3  rr rr                        .word nt_asm_cmp_x
005F37r 3  rr rr rr rr  		.word xt_asm_cmp_h, z_asm_cmp_h
005F3Br 3  63 6D 70 2E  		.byte "cmp.#"
005F3Fr 3  23           
005F40r 3               
005F40r 3               nt_asm_cmp_x:
005F40r 3  05 04        		.byte 5, IM
005F42r 3  rr rr                        .word nt_asm_cmp_y
005F44r 3  rr rr rr rr  		.word xt_asm_cmp_x, z_asm_cmp_x
005F48r 3  63 6D 70 2E  		.byte "cmp.x"
005F4Cr 3  78           
005F4Dr 3               
005F4Dr 3               nt_asm_cmp_y:
005F4Dr 3  05 04        		.byte 5, IM
005F4Fr 3  rr rr                        .word nt_asm_cmp_z
005F51r 3  rr rr rr rr  		.word xt_asm_cmp_y, z_asm_cmp_y
005F55r 3  63 6D 70 2E  		.byte "cmp.y"
005F59r 3  79           
005F5Ar 3               
005F5Ar 3               nt_asm_cmp_z:
005F5Ar 3  05 04        		.byte 5, IM
005F5Cr 3  rr rr                        .word nt_asm_cmp_zi
005F5Er 3  rr rr rr rr  		.word xt_asm_cmp_z, z_asm_cmp_z
005F62r 3  63 6D 70 2E  		.byte "cmp.z"
005F66r 3  7A           
005F67r 3               
005F67r 3               nt_asm_cmp_zi:
005F67r 3  06 04        		.byte 6, IM
005F69r 3  rr rr                        .word nt_asm_cmp_ziy
005F6Br 3  rr rr rr rr  		.word xt_asm_cmp_zi, z_asm_cmp_zi
005F6Fr 3  63 6D 70 2E  		.byte "cmp.zi"
005F73r 3  7A 69        
005F75r 3               
005F75r 3               nt_asm_cmp_ziy:
005F75r 3  07 04        		.byte 7, IM
005F77r 3  rr rr                        .word nt_asm_cmp_zx
005F79r 3  rr rr rr rr  		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
005F7Dr 3  63 6D 70 2E  		.byte "cmp.ziy"
005F81r 3  7A 69 79     
005F84r 3               
005F84r 3               nt_asm_cmp_zx:
005F84r 3  06 04        		.byte 6, IM
005F86r 3  rr rr                        .word nt_asm_cmp_zxi
005F88r 3  rr rr rr rr  		.word xt_asm_cmp_zx, z_asm_cmp_zx
005F8Cr 3  63 6D 70 2E  		.byte "cmp.zx"
005F90r 3  7A 78        
005F92r 3               
005F92r 3               nt_asm_cmp_zxi:
005F92r 3  07 04        		.byte 7, IM
005F94r 3  rr rr                        .word nt_asm_cpx
005F96r 3  rr rr rr rr  		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
005F9Ar 3  63 6D 70 2E  		.byte "cmp.zxi"
005F9Er 3  7A 78 69     
005FA1r 3               
005FA1r 3               nt_asm_cpx:
005FA1r 3  03 04        		.byte 3, IM
005FA3r 3  rr rr                        .word nt_asm_cpx_h
005FA5r 3  rr rr rr rr  		.word xt_asm_cpx, z_asm_cpx
005FA9r 3  63 70 78     		.byte "cpx"
005FACr 3               
005FACr 3               nt_asm_cpx_h:
005FACr 3  05 04        		.byte 5, IM
005FAEr 3  rr rr                        .word nt_asm_cpx_z
005FB0r 3  rr rr rr rr  		.word xt_asm_cpx_h, z_asm_cpx_h
005FB4r 3  63 70 78 2E  		.byte "cpx.#"
005FB8r 3  23           
005FB9r 3               
005FB9r 3               nt_asm_cpx_z:
005FB9r 3  05 04        		.byte 5, IM
005FBBr 3  rr rr                        .word nt_asm_cpy
005FBDr 3  rr rr rr rr  		.word xt_asm_cpx_z, z_asm_cpx_z
005FC1r 3  63 70 78 2E  		.byte "cpx.z"
005FC5r 3  7A           
005FC6r 3               
005FC6r 3               nt_asm_cpy:
005FC6r 3  03 04        		.byte 3, IM
005FC8r 3  rr rr                        .word nt_asm_cpy_h
005FCAr 3  rr rr rr rr  		.word xt_asm_cpy, z_asm_cpy
005FCEr 3  63 70 79     		.byte "cpy"
005FD1r 3               
005FD1r 3               nt_asm_cpy_h:
005FD1r 3  05 04        		.byte 5, IM
005FD3r 3  rr rr                        .word nt_asm_cpy_z
005FD5r 3  rr rr rr rr  		.word xt_asm_cpy_h, z_asm_cpy_h
005FD9r 3  63 70 79 2E  		.byte "cpy.#"
005FDDr 3  23           
005FDEr 3               
005FDEr 3               nt_asm_cpy_z:
005FDEr 3  05 04        		.byte 5, IM
005FE0r 3  rr rr                        .word nt_asm_dec
005FE2r 3  rr rr rr rr  		.word xt_asm_cpy_z, z_asm_cpy_z
005FE6r 3  63 70 79 2E  		.byte "cpy.z"
005FEAr 3  7A           
005FEBr 3               
005FEBr 3               nt_asm_dec:
005FEBr 3  03 04        		.byte 3, IM
005FEDr 3  rr rr                        .word nt_asm_dec_a
005FEFr 3  rr rr rr rr  		.word xt_asm_dec, z_asm_dec
005FF3r 3  64 65 63     		.byte "dec"
005FF6r 3               
005FF6r 3               nt_asm_dec_a:
005FF6r 3  05 04        		.byte 5, IM
005FF8r 3  rr rr                        .word nt_asm_dec_x
005FFAr 3  rr rr rr rr  		.word xt_asm_dec_a, z_asm_dec_a
005FFEr 3  64 65 63 2E  		.byte "dec.a"
006002r 3  61           
006003r 3               
006003r 3               nt_asm_dec_x:
006003r 3  05 04        		.byte 5, IM
006005r 3  rr rr                        .word nt_asm_dec_z
006007r 3  rr rr rr rr  		.word xt_asm_dec_x, z_asm_dec_x
00600Br 3  64 65 63 2E  		.byte "dec.x"
00600Fr 3  78           
006010r 3               
006010r 3               nt_asm_dec_z:
006010r 3  05 04        		.byte 5, IM
006012r 3  rr rr                        .word nt_asm_dec_zx
006014r 3  rr rr rr rr  		.word xt_asm_dec_z, z_asm_dec_z
006018r 3  64 65 63 2E  		.byte "dec.z"
00601Cr 3  7A           
00601Dr 3               
00601Dr 3               nt_asm_dec_zx:
00601Dr 3  06 04        		.byte 6, IM
00601Fr 3  rr rr                        .word nt_asm_dex
006021r 3  rr rr rr rr  		.word xt_asm_dec_zx, z_asm_dec_zx
006025r 3  64 65 63 2E  		.byte "dec.zx"
006029r 3  7A 78        
00602Br 3               
00602Br 3               nt_asm_dex:
00602Br 3  03 04        		.byte 3, IM
00602Dr 3  rr rr                        .word nt_asm_dey
00602Fr 3  rr rr rr rr  		.word xt_asm_dex, z_asm_dex
006033r 3  64 65 78     		.byte "dex"
006036r 3               
006036r 3               nt_asm_dey:
006036r 3  03 04        		.byte 3, IM
006038r 3  rr rr                        .word nt_asm_eor
00603Ar 3  rr rr rr rr  		.word xt_asm_dey, z_asm_dey
00603Er 3  64 65 79     		.byte "dey"
006041r 3               
006041r 3               nt_asm_eor:
006041r 3  03 04        		.byte 3, IM
006043r 3  rr rr                        .word nt_asm_eor_h
006045r 3  rr rr rr rr  		.word xt_asm_eor, z_asm_eor
006049r 3  65 6F 72     		.byte "eor"
00604Cr 3               
00604Cr 3               nt_asm_eor_h:
00604Cr 3  05 04        		.byte 5, IM
00604Er 3  rr rr                        .word nt_asm_eor_x
006050r 3  rr rr rr rr  		.word xt_asm_eor_h, z_asm_eor_h
006054r 3  65 6F 72 2E  		.byte "eor.#"
006058r 3  23           
006059r 3               
006059r 3               nt_asm_eor_x:
006059r 3  05 04        		.byte 5, IM
00605Br 3  rr rr                        .word nt_asm_eor_y
00605Dr 3  rr rr rr rr  		.word xt_asm_eor_x, z_asm_eor_x
006061r 3  65 6F 72 2E  		.byte "eor.x"
006065r 3  78           
006066r 3               
006066r 3               nt_asm_eor_y:
006066r 3  05 04        		.byte 5, IM
006068r 3  rr rr                        .word nt_asm_eor_z
00606Ar 3  rr rr rr rr  		.word xt_asm_eor_y, z_asm_eor_y
00606Er 3  65 6F 72 2E  		.byte "eor.y"
006072r 3  79           
006073r 3               
006073r 3               nt_asm_eor_z:
006073r 3  05 04        		.byte 5, IM
006075r 3  rr rr                        .word nt_asm_eor_zi
006077r 3  rr rr rr rr  		.word xt_asm_eor_z, z_asm_eor_z
00607Br 3  65 6F 72 2E  		.byte "eor.z"
00607Fr 3  7A           
006080r 3               
006080r 3               nt_asm_eor_zi:
006080r 3  06 04        		.byte 6, IM
006082r 3  rr rr                        .word nt_asm_eor_ziy
006084r 3  rr rr rr rr  		.word xt_asm_eor_zi, z_asm_eor_zi
006088r 3  65 6F 72 2E  		.byte "eor.zi"
00608Cr 3  7A 69        
00608Er 3               
00608Er 3               nt_asm_eor_ziy:
00608Er 3  07 04        		.byte 7, IM
006090r 3  rr rr                        .word nt_asm_eor_zx
006092r 3  rr rr rr rr  		.word xt_asm_eor_ziy, z_asm_eor_ziy
006096r 3  65 6F 72 2E  		.byte "eor.ziy"
00609Ar 3  7A 69 79     
00609Dr 3               
00609Dr 3               nt_asm_eor_zx:
00609Dr 3  06 04        		.byte 6, IM
00609Fr 3  rr rr                        .word nt_asm_eor_zxi
0060A1r 3  rr rr rr rr  		.word xt_asm_eor_zx, z_asm_eor_zx
0060A5r 3  65 6F 72 2E  		.byte "eor.zx"
0060A9r 3  7A 78        
0060ABr 3               
0060ABr 3               nt_asm_eor_zxi:
0060ABr 3  07 04        		.byte 7, IM
0060ADr 3  rr rr                        .word nt_asm_inc
0060AFr 3  rr rr rr rr  		.word xt_asm_eor_zxi, z_asm_eor_zxi
0060B3r 3  65 6F 72 2E  		.byte "eor.zxi"
0060B7r 3  7A 78 69     
0060BAr 3               
0060BAr 3               nt_asm_inc:
0060BAr 3  03 04        		.byte 3, IM
0060BCr 3  rr rr                        .word nt_asm_inc_a
0060BEr 3  rr rr rr rr  		.word xt_asm_inc, z_asm_inc
0060C2r 3  69 6E 63     		.byte "inc"
0060C5r 3               
0060C5r 3               nt_asm_inc_a:
0060C5r 3  05 04        		.byte 5, IM
0060C7r 3  rr rr                        .word nt_asm_inc_x
0060C9r 3  rr rr rr rr  		.word xt_asm_inc_a, z_asm_inc_a
0060CDr 3  69 6E 63 2E  		.byte "inc.a"
0060D1r 3  61           
0060D2r 3               
0060D2r 3               nt_asm_inc_x:
0060D2r 3  05 04        		.byte 5, IM
0060D4r 3  rr rr                        .word nt_asm_inc_z
0060D6r 3  rr rr rr rr  		.word xt_asm_inc_x, z_asm_inc_x
0060DAr 3  69 6E 63 2E  		.byte "inc.x"
0060DEr 3  78           
0060DFr 3               
0060DFr 3               nt_asm_inc_z:
0060DFr 3  05 04        		.byte 5, IM
0060E1r 3  rr rr                        .word nt_asm_inc_zx
0060E3r 3  rr rr rr rr  		.word xt_asm_inc_z, z_asm_inc_z
0060E7r 3  69 6E 63 2E  		.byte "inc.z"
0060EBr 3  7A           
0060ECr 3               
0060ECr 3               nt_asm_inc_zx:
0060ECr 3  06 04        		.byte 6, IM
0060EEr 3  rr rr                        .word nt_asm_inx
0060F0r 3  rr rr rr rr  		.word xt_asm_inc_zx, z_asm_inc_zx
0060F4r 3  69 6E 63 2E  		.byte "inc.zx"
0060F8r 3  7A 78        
0060FAr 3               
0060FAr 3               nt_asm_inx:
0060FAr 3  03 04        		.byte 3, IM
0060FCr 3  rr rr                        .word nt_asm_iny
0060FEr 3  rr rr rr rr  		.word xt_asm_inx, z_asm_inx
006102r 3  69 6E 78     		.byte "inx"
006105r 3               
006105r 3               nt_asm_iny:
006105r 3  03 04        		.byte 3, IM
006107r 3  rr rr                        .word nt_asm_jmp
006109r 3  rr rr rr rr  		.word xt_asm_iny, z_asm_iny
00610Dr 3  69 6E 79     		.byte "iny"
006110r 3               
006110r 3               nt_asm_jmp:
006110r 3  03 04        		.byte 3, IM
006112r 3  rr rr                        .word nt_asm_jmp_i
006114r 3  rr rr rr rr  		.word xt_asm_jmp, z_asm_jmp
006118r 3  6A 6D 70     		.byte "jmp"
00611Br 3               
00611Br 3               nt_asm_jmp_i:
00611Br 3  05 04        		.byte 5, IM
00611Dr 3  rr rr                        .word nt_asm_jmp_xi
00611Fr 3  rr rr rr rr  		.word xt_asm_jmp_i, z_asm_jmp_i
006123r 3  6A 6D 70 2E  		.byte "jmp.i"
006127r 3  69           
006128r 3               
006128r 3               nt_asm_jmp_xi:
006128r 3  06 04        		.byte 6, IM
00612Ar 3  rr rr                        .word nt_asm_jsr
00612Cr 3  rr rr rr rr  		.word xt_asm_jmp_xi, z_asm_jmp_xi
006130r 3  6A 6D 70 2E  		.byte "jmp.xi"
006134r 3  78 69        
006136r 3               
006136r 3               nt_asm_jsr:
006136r 3  03 04        		.byte 3, IM
006138r 3  rr rr                        .word nt_asm_lda
00613Ar 3  rr rr rr rr  		.word xt_asm_jsr, z_asm_jsr
00613Er 3  6A 73 72     		.byte "jsr"
006141r 3               
006141r 3               nt_asm_lda:
006141r 3  03 04        		.byte 3, IM
006143r 3  rr rr                        .word nt_asm_lda_h
006145r 3  rr rr rr rr  		.word xt_asm_lda, z_asm_lda
006149r 3  6C 64 61     		.byte "lda"
00614Cr 3               
00614Cr 3               nt_asm_lda_h:
00614Cr 3  05 04        		.byte 5, IM
00614Er 3  rr rr                        .word nt_asm_lda_x
006150r 3  rr rr rr rr  		.word xt_asm_lda_h, z_asm_lda_h
006154r 3  6C 64 61 2E  		.byte "lda.#"
006158r 3  23           
006159r 3               
006159r 3               nt_asm_lda_x:
006159r 3  05 04        		.byte 5, IM
00615Br 3  rr rr                        .word nt_asm_lda_y
00615Dr 3  rr rr rr rr  		.word xt_asm_lda_x, z_asm_lda_x
006161r 3  6C 64 61 2E  		.byte "lda.x"
006165r 3  78           
006166r 3               
006166r 3               nt_asm_lda_y:
006166r 3  05 04        		.byte 5, IM
006168r 3  rr rr                        .word nt_asm_lda_z
00616Ar 3  rr rr rr rr  		.word xt_asm_lda_y, z_asm_lda_y
00616Er 3  6C 64 61 2E  		.byte "lda.y"
006172r 3  79           
006173r 3               
006173r 3               nt_asm_lda_z:
006173r 3  05 04        		.byte 5, IM
006175r 3  rr rr                        .word nt_asm_lda_zi
006177r 3  rr rr rr rr  		.word xt_asm_lda_z, z_asm_lda_z
00617Br 3  6C 64 61 2E  		.byte "lda.z"
00617Fr 3  7A           
006180r 3               
006180r 3               nt_asm_lda_zi:
006180r 3  06 04        		.byte 6, IM
006182r 3  rr rr                        .word nt_asm_lda_ziy
006184r 3  rr rr rr rr  		.word xt_asm_lda_zi, z_asm_lda_zi
006188r 3  6C 64 61 2E  		.byte "lda.zi"
00618Cr 3  7A 69        
00618Er 3               
00618Er 3               nt_asm_lda_ziy:
00618Er 3  07 04        		.byte 7, IM
006190r 3  rr rr                        .word nt_asm_lda_zx
006192r 3  rr rr rr rr  		.word xt_asm_lda_ziy, z_asm_lda_ziy
006196r 3  6C 64 61 2E  		.byte "lda.ziy"
00619Ar 3  7A 69 79     
00619Dr 3               
00619Dr 3               nt_asm_lda_zx:
00619Dr 3  06 04        		.byte 6, IM
00619Fr 3  rr rr                        .word nt_asm_lda_zxi
0061A1r 3  rr rr rr rr  		.word xt_asm_lda_zx, z_asm_lda_zx
0061A5r 3  6C 64 61 2E  		.byte "lda.zx"
0061A9r 3  7A 78        
0061ABr 3               
0061ABr 3               nt_asm_lda_zxi:
0061ABr 3  07 04        		.byte 7, IM
0061ADr 3  rr rr                        .word nt_asm_ldx
0061AFr 3  rr rr rr rr  		.word xt_asm_lda_zxi, z_asm_lda_zxi
0061B3r 3  6C 64 61 2E  		.byte "lda.zxi"
0061B7r 3  7A 78 69     
0061BAr 3               
0061BAr 3               nt_asm_ldx:
0061BAr 3  03 04        		.byte 3, IM
0061BCr 3  rr rr                        .word nt_asm_ldx_h
0061BEr 3  rr rr rr rr  		.word xt_asm_ldx, z_asm_ldx
0061C2r 3  6C 64 78     		.byte "ldx"
0061C5r 3               
0061C5r 3               nt_asm_ldx_h:
0061C5r 3  05 04        		.byte 5, IM
0061C7r 3  rr rr                        .word nt_asm_ldx_y
0061C9r 3  rr rr rr rr  		.word xt_asm_ldx_h, z_asm_ldx_h
0061CDr 3  6C 64 78 2E  		.byte "ldx.#"
0061D1r 3  23           
0061D2r 3               
0061D2r 3               nt_asm_ldx_y:
0061D2r 3  05 04        		.byte 5, IM
0061D4r 3  rr rr                        .word nt_asm_ldx_z
0061D6r 3  rr rr rr rr  		.word xt_asm_ldx_y, z_asm_ldx_y
0061DAr 3  6C 64 78 2E  		.byte "ldx.y"
0061DEr 3  79           
0061DFr 3               
0061DFr 3               nt_asm_ldx_z:
0061DFr 3  05 04        		.byte 5, IM
0061E1r 3  rr rr                        .word nt_asm_ldx_zy
0061E3r 3  rr rr rr rr  		.word xt_asm_ldx_z, z_asm_ldx_z
0061E7r 3  6C 64 78 2E  		.byte "ldx.z"
0061EBr 3  7A           
0061ECr 3               
0061ECr 3               nt_asm_ldx_zy:
0061ECr 3  06 04        		.byte 6, IM
0061EEr 3  rr rr                        .word nt_asm_ldy
0061F0r 3  rr rr rr rr  		.word xt_asm_ldx_zy, z_asm_ldx_zy
0061F4r 3  6C 64 78 2E  		.byte "ldx.zy"
0061F8r 3  7A 79        
0061FAr 3               
0061FAr 3               nt_asm_ldy:
0061FAr 3  03 04        		.byte 3, IM
0061FCr 3  rr rr                        .word nt_asm_ldy_h
0061FEr 3  rr rr rr rr  		.word xt_asm_ldy, z_asm_ldy
006202r 3  6C 64 79     		.byte "ldy"
006205r 3               
006205r 3               nt_asm_ldy_h:
006205r 3  05 04        		.byte 5, IM
006207r 3  rr rr                        .word nt_asm_ldy_x
006209r 3  rr rr rr rr  		.word xt_asm_ldy_h, z_asm_ldy_h
00620Dr 3  6C 64 79 2E  		.byte "ldy.#"
006211r 3  23           
006212r 3               
006212r 3               nt_asm_ldy_x:
006212r 3  05 04        		.byte 5, IM
006214r 3  rr rr                        .word nt_asm_ldy_z
006216r 3  rr rr rr rr  		.word xt_asm_ldy_x, z_asm_ldy_x
00621Ar 3  6C 64 79 2E  		.byte "ldy.x"
00621Er 3  78           
00621Fr 3               
00621Fr 3               nt_asm_ldy_z:
00621Fr 3  05 04        		.byte 5, IM
006221r 3  rr rr                        .word nt_asm_ldy_zx
006223r 3  rr rr rr rr  		.word xt_asm_ldy_z, z_asm_ldy_z
006227r 3  6C 64 79 2E  		.byte "ldy.z"
00622Br 3  7A           
00622Cr 3               
00622Cr 3               nt_asm_ldy_zx:
00622Cr 3  06 04        		.byte 6, IM
00622Er 3  rr rr                        .word nt_asm_lsr
006230r 3  rr rr rr rr  		.word xt_asm_ldy_zx, z_asm_ldy_zx
006234r 3  6C 64 79 2E  		.byte "ldy.zx"
006238r 3  7A 78        
00623Ar 3               
00623Ar 3               nt_asm_lsr:
00623Ar 3  03 04        		.byte 3, IM
00623Cr 3  rr rr                        .word nt_asm_lsr_a
00623Er 3  rr rr rr rr  		.word xt_asm_lsr, z_asm_lsr
006242r 3  6C 73 72     		.byte "lsr"
006245r 3               
006245r 3               nt_asm_lsr_a:
006245r 3  05 04        		.byte 5, IM
006247r 3  rr rr                        .word nt_asm_lsr_x
006249r 3  rr rr rr rr  		.word xt_asm_lsr_a, z_asm_lsr_a
00624Dr 3  6C 73 72 2E  		.byte "lsr.a"
006251r 3  61           
006252r 3               
006252r 3               nt_asm_lsr_x:
006252r 3  05 04        		.byte 5, IM
006254r 3  rr rr                        .word nt_asm_lsr_z
006256r 3  rr rr rr rr  		.word xt_asm_lsr_x, z_asm_lsr_x
00625Ar 3  6C 73 72 2E  		.byte "lsr.x"
00625Er 3  78           
00625Fr 3               
00625Fr 3               nt_asm_lsr_z:
00625Fr 3  05 04        		.byte 5, IM
006261r 3  rr rr                        .word nt_asm_lsr_zx
006263r 3  rr rr rr rr  		.word xt_asm_lsr_z, z_asm_lsr_z
006267r 3  6C 73 72 2E  		.byte "lsr.z"
00626Br 3  7A           
00626Cr 3               
00626Cr 3               nt_asm_lsr_zx:
00626Cr 3  06 04        		.byte 6, IM
00626Er 3  rr rr                        .word nt_asm_nop
006270r 3  rr rr rr rr  		.word xt_asm_lsr_zx, z_asm_lsr_zx
006274r 3  6C 73 72 2E  		.byte "lsr.zx"
006278r 3  7A 78        
00627Ar 3               
00627Ar 3               nt_asm_nop:
00627Ar 3  03 04        		.byte 3, IM
00627Cr 3  rr rr                        .word nt_asm_ora
00627Er 3  rr rr rr rr  		.word xt_asm_nop, z_asm_nop
006282r 3  6E 6F 70     		.byte "nop"
006285r 3               
006285r 3               nt_asm_ora:
006285r 3  03 04        		.byte 3, IM
006287r 3  rr rr                        .word nt_asm_ora_h
006289r 3  rr rr rr rr  		.word xt_asm_ora, z_asm_ora
00628Dr 3  6F 72 61     		.byte "ora"
006290r 3               
006290r 3               nt_asm_ora_h:
006290r 3  05 04        		.byte 5, IM
006292r 3  rr rr                        .word nt_asm_ora_x
006294r 3  rr rr rr rr  		.word xt_asm_ora_h, z_asm_ora_h
006298r 3  6F 72 61 2E  		.byte "ora.#"
00629Cr 3  23           
00629Dr 3               
00629Dr 3               nt_asm_ora_x:
00629Dr 3  05 04        		.byte 5, IM
00629Fr 3  rr rr                        .word nt_asm_ora_y
0062A1r 3  rr rr rr rr  		.word xt_asm_ora_x, z_asm_ora_x
0062A5r 3  6F 72 61 2E  		.byte "ora.x"
0062A9r 3  78           
0062AAr 3               
0062AAr 3               nt_asm_ora_y:
0062AAr 3  05 04        		.byte 5, IM
0062ACr 3  rr rr                        .word nt_asm_ora_z
0062AEr 3  rr rr rr rr  		.word xt_asm_ora_y, z_asm_ora_y
0062B2r 3  6F 72 61 2E  		.byte "ora.y"
0062B6r 3  79           
0062B7r 3               
0062B7r 3               nt_asm_ora_z:
0062B7r 3  05 04        		.byte 5, IM
0062B9r 3  rr rr                        .word nt_asm_ora_zi
0062BBr 3  rr rr rr rr  		.word xt_asm_ora_z, z_asm_ora_z
0062BFr 3  6F 72 61 2E  		.byte "ora.z"
0062C3r 3  7A           
0062C4r 3               
0062C4r 3               nt_asm_ora_zi:
0062C4r 3  06 04        		.byte 6, IM
0062C6r 3  rr rr                        .word nt_asm_ora_ziy
0062C8r 3  rr rr rr rr  		.word xt_asm_ora_zi, z_asm_ora_zi
0062CCr 3  6F 72 61 2E  		.byte "ora.zi"
0062D0r 3  7A 69        
0062D2r 3               
0062D2r 3               nt_asm_ora_ziy:
0062D2r 3  07 04        		.byte 7, IM
0062D4r 3  rr rr                        .word nt_asm_ora_zx
0062D6r 3  rr rr rr rr  		.word xt_asm_ora_ziy, z_asm_ora_ziy
0062DAr 3  6F 72 61 2E  		.byte "ora.ziy"
0062DEr 3  7A 69 79     
0062E1r 3               
0062E1r 3               nt_asm_ora_zx:
0062E1r 3  06 04        		.byte 6, IM
0062E3r 3  rr rr                        .word nt_asm_ora_zxi
0062E5r 3  rr rr rr rr  		.word xt_asm_ora_zx, z_asm_ora_zx
0062E9r 3  6F 72 61 2E  		.byte "ora.zx"
0062EDr 3  7A 78        
0062EFr 3               
0062EFr 3               nt_asm_ora_zxi:
0062EFr 3  07 04        		.byte 7, IM
0062F1r 3  rr rr                        .word nt_asm_pha
0062F3r 3  rr rr rr rr  		.word xt_asm_ora_zxi, z_asm_ora_zxi
0062F7r 3  6F 72 61 2E  		.byte "ora.zxi"
0062FBr 3  7A 78 69     
0062FEr 3               
0062FEr 3               nt_asm_pha:
0062FEr 3  03 04        		.byte 3, IM
006300r 3  rr rr                        .word nt_asm_php
006302r 3  rr rr rr rr  		.word xt_asm_pha, z_asm_pha
006306r 3  70 68 61     		.byte "pha"
006309r 3               
006309r 3               nt_asm_php:
006309r 3  03 04        		.byte 3, IM
00630Br 3  rr rr                        .word nt_asm_phx
00630Dr 3  rr rr rr rr  		.word xt_asm_php, z_asm_php
006311r 3  70 68 70     		.byte "php"
006314r 3               
006314r 3               nt_asm_phx:
006314r 3  03 04        		.byte 3, IM
006316r 3  rr rr                        .word nt_asm_phy
006318r 3  rr rr rr rr  		.word xt_asm_phx, z_asm_phx
00631Cr 3  70 68 78     		.byte "phx"
00631Fr 3               
00631Fr 3               nt_asm_phy:
00631Fr 3  03 04        		.byte 3, IM
006321r 3  rr rr                        .word nt_asm_pla
006323r 3  rr rr rr rr  		.word xt_asm_phy, z_asm_phy
006327r 3  70 68 79     		.byte "phy"
00632Ar 3               
00632Ar 3               nt_asm_pla:
00632Ar 3  03 04        		.byte 3, IM
00632Cr 3  rr rr                        .word nt_asm_plp
00632Er 3  rr rr rr rr  		.word xt_asm_pla, z_asm_pla
006332r 3  70 6C 61     		.byte "pla"
006335r 3               
006335r 3               nt_asm_plp:
006335r 3  03 04        		.byte 3, IM
006337r 3  rr rr                        .word nt_asm_plx
006339r 3  rr rr rr rr  		.word xt_asm_plp, z_asm_plp
00633Dr 3  70 6C 70     		.byte "plp"
006340r 3               
006340r 3               nt_asm_plx:
006340r 3  03 04        		.byte 3, IM
006342r 3  rr rr                        .word nt_asm_ply
006344r 3  rr rr rr rr  		.word xt_asm_plx, z_asm_plx
006348r 3  70 6C 78     		.byte "plx"
00634Br 3               
00634Br 3               nt_asm_ply:
00634Br 3  03 04        		.byte 3, IM
00634Dr 3  rr rr                        .word nt_asm_rol
00634Fr 3  rr rr rr rr  		.word xt_asm_ply, z_asm_ply
006353r 3  70 6C 79     		.byte "ply"
006356r 3               
006356r 3               nt_asm_rol:
006356r 3  03 04        		.byte 3, IM
006358r 3  rr rr                        .word nt_asm_rol_a
00635Ar 3  rr rr rr rr  		.word xt_asm_rol, z_asm_rol
00635Er 3  72 6F 6C     		.byte "rol"
006361r 3               
006361r 3               nt_asm_rol_a:
006361r 3  05 04        		.byte 5, IM
006363r 3  rr rr                        .word nt_asm_rol_x
006365r 3  rr rr rr rr  		.word xt_asm_rol_a, z_asm_rol_a
006369r 3  72 6F 6C 2E  		.byte "rol.a"
00636Dr 3  61           
00636Er 3               
00636Er 3               nt_asm_rol_x:
00636Er 3  05 04        		.byte 5, IM
006370r 3  rr rr                        .word nt_asm_rol_z
006372r 3  rr rr rr rr  		.word xt_asm_rol_x, z_asm_rol_x
006376r 3  72 6F 6C 2E  		.byte "rol.x"
00637Ar 3  78           
00637Br 3               
00637Br 3               nt_asm_rol_z:
00637Br 3  05 04        		.byte 5, IM
00637Dr 3  rr rr                        .word nt_asm_rol_zx
00637Fr 3  rr rr rr rr  		.word xt_asm_rol_z, z_asm_rol_z
006383r 3  72 6F 6C 2E  		.byte "rol.z"
006387r 3  7A           
006388r 3               
006388r 3               nt_asm_rol_zx:
006388r 3  06 04        		.byte 6, IM
00638Ar 3  rr rr                        .word nt_asm_ror
00638Cr 3  rr rr rr rr  		.word xt_asm_rol_zx, z_asm_rol_zx
006390r 3  72 6F 6C 2E  		.byte "rol.zx"
006394r 3  7A 78        
006396r 3               
006396r 3               nt_asm_ror:
006396r 3  03 04        		.byte 3, IM
006398r 3  rr rr                        .word nt_asm_ror_a
00639Ar 3  rr rr rr rr  		.word xt_asm_ror, z_asm_ror
00639Er 3  72 6F 72     		.byte "ror"
0063A1r 3               
0063A1r 3               nt_asm_ror_a:
0063A1r 3  05 04        		.byte 5, IM
0063A3r 3  rr rr                        .word nt_asm_ror_x
0063A5r 3  rr rr rr rr  		.word xt_asm_ror_a, z_asm_ror_a
0063A9r 3  72 6F 72 2E  		.byte "ror.a"
0063ADr 3  61           
0063AEr 3               
0063AEr 3               nt_asm_ror_x:
0063AEr 3  05 04        		.byte 5, IM
0063B0r 3  rr rr                        .word nt_asm_ror_z
0063B2r 3  rr rr rr rr  		.word xt_asm_ror_x, z_asm_ror_x
0063B6r 3  72 6F 72 2E  		.byte "ror.x"
0063BAr 3  78           
0063BBr 3               
0063BBr 3               nt_asm_ror_z:
0063BBr 3  05 04        		.byte 5, IM
0063BDr 3  rr rr                        .word nt_asm_ror_zx
0063BFr 3  rr rr rr rr  		.word xt_asm_ror_z, z_asm_ror_z
0063C3r 3  72 6F 72 2E  		.byte "ror.z"
0063C7r 3  7A           
0063C8r 3               
0063C8r 3               nt_asm_ror_zx:
0063C8r 3  06 04        		.byte 6, IM
0063CAr 3  rr rr                        .word nt_asm_rti
0063CCr 3  rr rr rr rr  		.word xt_asm_ror_zx, z_asm_ror_zx
0063D0r 3  72 6F 72 2E  		.byte "ror.zx"
0063D4r 3  7A 78        
0063D6r 3               
0063D6r 3               nt_asm_rti:
0063D6r 3  03 04        		.byte 3, IM
0063D8r 3  rr rr                        .word nt_asm_rts
0063DAr 3  rr rr rr rr  		.word xt_asm_rti, z_asm_rti
0063DEr 3  72 74 69     		.byte "rti"
0063E1r 3               
0063E1r 3               nt_asm_rts:
0063E1r 3  03 04        		.byte 3, IM
0063E3r 3  rr rr                        .word nt_asm_sbc
0063E5r 3  rr rr rr rr  		.word xt_asm_rts, z_asm_rts
0063E9r 3  72 74 73     		.byte "rts"
0063ECr 3               
0063ECr 3               nt_asm_sbc:
0063ECr 3  03 04        		.byte 3, IM
0063EEr 3  rr rr                        .word nt_asm_sbc_h
0063F0r 3  rr rr rr rr  		.word xt_asm_sbc, z_asm_sbc
0063F4r 3  73 62 63     		.byte "sbc"
0063F7r 3               
0063F7r 3               nt_asm_sbc_h:
0063F7r 3  05 04        		.byte 5, IM
0063F9r 3  rr rr                        .word nt_asm_sbc_x
0063FBr 3  rr rr rr rr  		.word xt_asm_sbc_h, z_asm_sbc_h
0063FFr 3  73 62 63 2E  		.byte "sbc.#"
006403r 3  23           
006404r 3               
006404r 3               nt_asm_sbc_x:
006404r 3  05 04        		.byte 5, IM
006406r 3  rr rr                        .word nt_asm_sbc_y
006408r 3  rr rr rr rr  		.word xt_asm_sbc_x, z_asm_sbc_x
00640Cr 3  73 62 63 2E  		.byte "sbc.x"
006410r 3  78           
006411r 3               
006411r 3               nt_asm_sbc_y:
006411r 3  05 04        		.byte 5, IM
006413r 3  rr rr                        .word nt_asm_sbc_z
006415r 3  rr rr rr rr  		.word xt_asm_sbc_y, z_asm_sbc_y
006419r 3  73 62 63 2E  		.byte "sbc.y"
00641Dr 3  79           
00641Er 3               
00641Er 3               nt_asm_sbc_z:
00641Er 3  05 04        		.byte 5, IM
006420r 3  rr rr                        .word nt_asm_sbc_zi
006422r 3  rr rr rr rr  		.word xt_asm_sbc_z, z_asm_sbc_z
006426r 3  73 62 63 2E  		.byte "sbc.z"
00642Ar 3  7A           
00642Br 3               
00642Br 3               nt_asm_sbc_zi:
00642Br 3  06 04        		.byte 6, IM
00642Dr 3  rr rr                        .word nt_asm_sbc_ziy
00642Fr 3  rr rr rr rr  		.word xt_asm_sbc_zi, z_asm_sbc_zi
006433r 3  73 62 63 2E  		.byte "sbc.zi"
006437r 3  7A 69        
006439r 3               
006439r 3               nt_asm_sbc_ziy:
006439r 3  07 04        		.byte 7, IM
00643Br 3  rr rr                        .word nt_asm_sbc_zx
00643Dr 3  rr rr rr rr  		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
006441r 3  73 62 63 2E  		.byte "sbc.ziy"
006445r 3  7A 69 79     
006448r 3               
006448r 3               nt_asm_sbc_zx:
006448r 3  06 04        		.byte 6, IM
00644Ar 3  rr rr                        .word nt_asm_sbc_zxi
00644Cr 3  rr rr rr rr  		.word xt_asm_sbc_zx, z_asm_sbc_zx
006450r 3  73 62 63 2E  		.byte "sbc.zx"
006454r 3  7A 78        
006456r 3               
006456r 3               nt_asm_sbc_zxi:
006456r 3  07 04        		.byte 7, IM
006458r 3  rr rr                        .word nt_asm_sec
00645Ar 3  rr rr rr rr  		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
00645Er 3  73 62 63 2E  		.byte "sbc.zxi"
006462r 3  7A 78 69     
006465r 3               
006465r 3               nt_asm_sec:
006465r 3  03 04        		.byte 3, IM
006467r 3  rr rr                        .word nt_asm_sed
006469r 3  rr rr rr rr  		.word xt_asm_sec, z_asm_sec
00646Dr 3  73 65 63     		.byte "sec"
006470r 3               
006470r 3               nt_asm_sed:
006470r 3  03 04        		.byte 3, IM
006472r 3  rr rr                        .word nt_asm_sei
006474r 3  rr rr rr rr  		.word xt_asm_sed, z_asm_sed
006478r 3  73 65 64     		.byte "sed"
00647Br 3               
00647Br 3               nt_asm_sei:
00647Br 3  03 04        		.byte 3, IM
00647Dr 3  rr rr                        .word nt_asm_sta
00647Fr 3  rr rr rr rr  		.word xt_asm_sei, z_asm_sei
006483r 3  73 65 69     		.byte "sei"
006486r 3               
006486r 3               nt_asm_sta:
006486r 3  03 04        		.byte 3, IM
006488r 3  rr rr                        .word nt_asm_sta_x
00648Ar 3  rr rr rr rr  		.word xt_asm_sta, z_asm_sta
00648Er 3  73 74 61     		.byte "sta"
006491r 3               
006491r 3               nt_asm_sta_x:
006491r 3  05 04        		.byte 5, IM
006493r 3  rr rr                        .word nt_asm_sta_y
006495r 3  rr rr rr rr  		.word xt_asm_sta_x, z_asm_sta_x
006499r 3  73 74 61 2E  		.byte "sta.x"
00649Dr 3  78           
00649Er 3               
00649Er 3               nt_asm_sta_y:
00649Er 3  05 04        		.byte 5, IM
0064A0r 3  rr rr                        .word nt_asm_sta_z
0064A2r 3  rr rr rr rr  		.word xt_asm_sta_y, z_asm_sta_y
0064A6r 3  73 74 61 2E  		.byte "sta.y"
0064AAr 3  79           
0064ABr 3               
0064ABr 3               nt_asm_sta_z:
0064ABr 3  05 04        		.byte 5, IM
0064ADr 3  rr rr                        .word nt_asm_sta_zi
0064AFr 3  rr rr rr rr  		.word xt_asm_sta_z, z_asm_sta_z
0064B3r 3  73 74 61 2E  		.byte "sta.z"
0064B7r 3  7A           
0064B8r 3               
0064B8r 3               nt_asm_sta_zi:
0064B8r 3  06 04        		.byte 6, IM
0064BAr 3  rr rr                        .word nt_asm_sta_ziy
0064BCr 3  rr rr rr rr  		.word xt_asm_sta_zi, z_asm_sta_zi
0064C0r 3  73 74 61 2E  		.byte "sta.zi"
0064C4r 3  7A 69        
0064C6r 3               
0064C6r 3               nt_asm_sta_ziy:
0064C6r 3  07 04        		.byte 7, IM
0064C8r 3  rr rr                        .word nt_asm_sta_zx
0064CAr 3  rr rr rr rr  		.word xt_asm_sta_ziy, z_asm_sta_ziy
0064CEr 3  73 74 61 2E  		.byte "sta.ziy"
0064D2r 3  7A 69 79     
0064D5r 3               
0064D5r 3               nt_asm_sta_zx:
0064D5r 3  06 04        		.byte 6, IM
0064D7r 3  rr rr                        .word nt_asm_sta_zxi
0064D9r 3  rr rr rr rr  		.word xt_asm_sta_zx, z_asm_sta_zx
0064DDr 3  73 74 61 2E  		.byte "sta.zx"
0064E1r 3  7A 78        
0064E3r 3               
0064E3r 3               nt_asm_sta_zxi:
0064E3r 3  07 04        		.byte 7, IM
0064E5r 3  rr rr                        .word nt_asm_stx
0064E7r 3  rr rr rr rr  		.word xt_asm_sta_zxi, z_asm_sta_zxi
0064EBr 3  73 74 61 2E  		.byte "sta.zxi"
0064EFr 3  7A 78 69     
0064F2r 3               
0064F2r 3               nt_asm_stx:
0064F2r 3  03 04        		.byte 3, IM
0064F4r 3  rr rr                        .word nt_asm_stx_z
0064F6r 3  rr rr rr rr  		.word xt_asm_stx, z_asm_stx
0064FAr 3  73 74 78     		.byte "stx"
0064FDr 3               
0064FDr 3               nt_asm_stx_z:
0064FDr 3  05 04        		.byte 5, IM
0064FFr 3  rr rr                        .word nt_asm_stx_zy
006501r 3  rr rr rr rr  		.word xt_asm_stx_z, z_asm_stx_z
006505r 3  73 74 78 2E  		.byte "stx.z"
006509r 3  7A           
00650Ar 3               
00650Ar 3               nt_asm_stx_zy:
00650Ar 3  06 04        		.byte 6, IM
00650Cr 3  rr rr                        .word nt_asm_sty
00650Er 3  rr rr rr rr  		.word xt_asm_stx_zy, z_asm_stx_zy
006512r 3  73 74 78 2E  		.byte "stx.zy"
006516r 3  7A 79        
006518r 3               
006518r 3               nt_asm_sty:
006518r 3  03 04        		.byte 3, IM
00651Ar 3  rr rr                        .word nt_asm_sty_z
00651Cr 3  rr rr rr rr  		.word xt_asm_sty, z_asm_sty
006520r 3  73 74 79     		.byte "sty"
006523r 3               
006523r 3               nt_asm_sty_z:
006523r 3  05 04        		.byte 5, IM
006525r 3  rr rr                        .word nt_asm_sty_zx
006527r 3  rr rr rr rr  		.word xt_asm_sty_z, z_asm_sty_z
00652Br 3  73 74 79 2E  		.byte "sty.z"
00652Fr 3  7A           
006530r 3               
006530r 3               nt_asm_sty_zx:
006530r 3  06 04        		.byte 6, IM
006532r 3  rr rr                        .word nt_asm_stz
006534r 3  rr rr rr rr  		.word xt_asm_sty_zx, z_asm_sty_zx
006538r 3  73 74 79 2E  		.byte "sty.zx"
00653Cr 3  7A 78        
00653Er 3               
00653Er 3               nt_asm_stz:
00653Er 3  03 04        		.byte 3, IM
006540r 3  rr rr                        .word nt_asm_stz_x
006542r 3  rr rr rr rr  		.word xt_asm_stz, z_asm_stz
006546r 3  73 74 7A     		.byte "stz"
006549r 3               
006549r 3               nt_asm_stz_x:
006549r 3  05 04        		.byte 5, IM
00654Br 3  rr rr                        .word nt_asm_stz_z
00654Dr 3  rr rr rr rr  		.word xt_asm_stz_x, z_asm_stz_x
006551r 3  73 74 7A 2E  		.byte "stz.x"
006555r 3  78           
006556r 3               
006556r 3               nt_asm_stz_z:
006556r 3  05 04        		.byte 5, IM
006558r 3  rr rr                        .word nt_asm_stz_zx
00655Ar 3  rr rr rr rr  		.word xt_asm_stz_z, z_asm_stz_z
00655Er 3  73 74 7A 2E  		.byte "stz.z"
006562r 3  7A           
006563r 3               
006563r 3               nt_asm_stz_zx:
006563r 3  06 04        		.byte 6, IM
006565r 3  rr rr                        .word nt_asm_tax
006567r 3  rr rr rr rr  		.word xt_asm_stz_zx, z_asm_stz_zx
00656Br 3  73 74 7A 2E  		.byte "stz.zx"
00656Fr 3  7A 78        
006571r 3               
006571r 3               nt_asm_tax:
006571r 3  03 04        		.byte 3, IM
006573r 3  rr rr                        .word nt_asm_tay
006575r 3  rr rr rr rr  		.word xt_asm_tax, z_asm_tax
006579r 3  74 61 78     		.byte "tax"
00657Cr 3               
00657Cr 3               nt_asm_tay:
00657Cr 3  03 04        		.byte 3, IM
00657Er 3  rr rr                        .word nt_asm_trb
006580r 3  rr rr rr rr  		.word xt_asm_tay, z_asm_tay
006584r 3  74 61 79     		.byte "tay"
006587r 3               
006587r 3               nt_asm_trb:
006587r 3  03 04        		.byte 3, IM
006589r 3  rr rr                        .word nt_asm_trb_z
00658Br 3  rr rr rr rr  		.word xt_asm_trb, z_asm_trb
00658Fr 3  74 72 62     		.byte "trb"
006592r 3               
006592r 3               nt_asm_trb_z:
006592r 3  05 04        		.byte 5, IM
006594r 3  rr rr                        .word nt_asm_tsb
006596r 3  rr rr rr rr  		.word xt_asm_trb_z, z_asm_trb_z
00659Ar 3  74 72 62 2E  		.byte "trb.z"
00659Er 3  7A           
00659Fr 3               
00659Fr 3               nt_asm_tsb:
00659Fr 3  03 04        		.byte 3, IM
0065A1r 3  rr rr                        .word nt_asm_tsb_z
0065A3r 3  rr rr rr rr  		.word xt_asm_tsb, z_asm_tsb
0065A7r 3  74 73 62     		.byte "tsb"
0065AAr 3               
0065AAr 3               nt_asm_tsb_z:
0065AAr 3  05 04        		.byte 5, IM
0065ACr 3  rr rr                        .word nt_asm_tsx
0065AEr 3  rr rr rr rr  		.word xt_asm_tsb_z, z_asm_tsb_z
0065B2r 3  74 73 62 2E  		.byte "tsb.z"
0065B6r 3  7A           
0065B7r 3               
0065B7r 3               nt_asm_tsx:
0065B7r 3  03 04        		.byte 3, IM
0065B9r 3  rr rr                        .word nt_asm_txa
0065BBr 3  rr rr rr rr  		.word xt_asm_tsx, z_asm_tsx
0065BFr 3  74 73 78     		.byte "tsx"
0065C2r 3               
0065C2r 3               nt_asm_txa:
0065C2r 3  03 04        		.byte 3, IM
0065C4r 3  rr rr                        .word nt_asm_txs
0065C6r 3  rr rr rr rr  		.word xt_asm_txa, z_asm_txa
0065CAr 3  74 78 61     		.byte "txa"
0065CDr 3               
0065CDr 3               nt_asm_txs:
0065CDr 3  03 04        		.byte 3, IM
0065CFr 3  rr rr                        .word nt_asm_tya
0065D1r 3  rr rr rr rr  		.word xt_asm_txs, z_asm_txs
0065D5r 3  74 78 73     		.byte "txs"
0065D8r 3               
0065D8r 3               nt_asm_tya:
0065D8r 3  03 04        		.byte 3, IM
0065DAr 3  rr rr                        .word nt_asm_arrow
0065DCr 3  rr rr rr rr  		.word xt_asm_tya, z_asm_tya
0065E0r 3  74 79 61     		.byte "tya"
0065E3r 3               
0065E3r 3               ; Assembler pseudo-instructions, directives and macros
0065E3r 3               
0065E3r 3               nt_asm_arrow:   ; uses same code as HERE, but immediate
0065E3r 3  03 04                        .byte 3, IM
0065E5r 3  rr rr                        .word nt_asm_back_jump
0065E7r 3  rr rr rr rr                  .word xt_asm_arrow, z_asm_arrow
0065EBr 3  2D 2D 3E                     .byte "-->"
0065EEr 3               
0065EEr 3               
0065EEr 3               nt_asm_back_jump:  ; syntactic sugar, does nothing
0065EEr 3  02 04                        .byte 2, IM
0065F0r 3  rr rr                        .word nt_asm_back_branch
0065F2r 3  rr rr rr rr                  .word xt_asm_back_jump, z_asm_back_jump
0065F6r 3  3C 6A                        .byte "<j"
0065F8r 3               
0065F8r 3               nt_asm_back_branch:
0065F8r 3  02 04                        .byte 2, IM
0065FAr 3  rr rr                        .word nt_asm_push_a
0065FCr 3  rr rr rr rr                  .word xt_asm_back_branch, z_asm_back_branch
006600r 3  3C 62                        .byte "<b"
006602r 3               
006602r 3               nt_asm_push_a:
006602r 3  06 04                        .byte 6, IM
006604r 3  00 00                        .word 0000
006606r 3  rr rr rr rr                  .word xt_asm_push_a, z_asm_push_a
00660Ar 3  70 75 73 68                  .byte "push-a"
00660Er 3  2D 61        
006610r 3               
006610r 3               
006610r 3               
006610r 3               ; END of ASSEMBLER-WORDLIST
006610r 3               
006610r 3               ; END
006610r 3               
006610r 2               .include "strings.asm"          ; Strings, including error messages
006610r 3               ; List of Strings for Tali Forth 2
006610r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
006610r 3               ; First version: 01. Apr 2016 (for Liara Forth)
006610r 3               ; This version: 28. Dec 2018
006610r 3               
006610r 3               ; This file is included by taliforth.asm
006610r 3               
006610r 3               ; ## GENERAL STRINGS
006610r 3               
006610r 3               ; All general strings must be zero-terminated, names start with "s_",
006610r 3               ; aliases with "str_"
006610r 3               
006610r 3               str_ok =              0
006610r 3               str_compile =         1
006610r 3               str_redefined =       2
006610r 3               str_wid_forth =       3
006610r 3               str_abc_lower =       4
006610r 3               str_abc_upper =       5
006610r 3               str_wid_editor =      6
006610r 3               str_wid_assembler =   7
006610r 3               str_wid_root =        8
006610r 3               str_see_flags =       9
006610r 3               str_see_nt =         10
006610r 3               str_see_xt =         11
006610r 3               str_see_size =       12
006610r 3               
006610r 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
006610r 3               ; to tables as error and string numbers.
006610r 3               string_table:
006610r 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
006614r 3  rr rr rr rr  
006618r 3  rr rr        
00661Ar 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
00661Er 3  rr rr rr rr  
006622r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
006626r 3  rr rr rr rr  
00662Ar 3               
00662Ar 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
00662Er 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
006632r 3  70 69 6C 65  
006636r 3  64 00        
006638r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
00663Cr 3  66 69 6E 65  
006640r 3  64 20 00     
006643r 3               
006643r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
006647r 3  34 35 36 37  
00664Br 3  38 39 61 62  
006667r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
00666Br 3  34 35 36 37  
00666Fr 3  38 39 41 42  
00668Br 3               
00668Br 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
00668Fr 3  6D 62 6C 65  
006693r 3  72 20 00     
006696r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
00669Ar 3  6F 72 20 00  
00669Er 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
0066A2r 3  68 20 00     
0066A5r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
0066A9r 3  20 00        
0066ABr 3               
0066ABr 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
0066AFr 3  73 20 28 43  
0066B3r 3  4F 20 41 4E  
0066C7r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
0066CBr 3  00           
0066CCr 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
0066D0r 3  00           
0066D1r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
0066D5r 3  20 28 64 65  
0066D9r 3  63 69 6D 61  
0066E2r 3               
0066E2r 3               
0066E2r 3               ; ## ERROR STRINGS
0066E2r 3               
0066E2r 3               ; All error strings must be zero-terminated, all names start with "es_",
0066E2r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
0066E2r 3               ; as well
0066E2r 3               
0066E2r 3               err_allot =        0
0066E2r 3               err_badsource =    1
0066E2r 3               err_compileonly =  2
0066E2r 3               err_defer =        3
0066E2r 3               err_divzero =      4
0066E2r 3               err_noname =       5
0066E2r 3               err_refill =       6
0066E2r 3               err_state =        7
0066E2r 3               err_syntax =       8
0066E2r 3               err_underflow =    9
0066E2r 3               err_negallot =     10
0066E2r 3               err_wordlist =     11
0066E2r 3               err_blockwords =   12
0066E2r 3               
0066E2r 3               error_table:
0066E2r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
0066E6r 3  rr rr rr rr  
0066EAr 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
0066EEr 3  rr rr rr rr  
0066F2r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
0066F6r 3  rr rr rr rr  
0066FAr 3  rr rr                .word es_blockwords                                    ; 12
0066FCr 3               
0066FCr 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
006700r 3  54 20 75 73  
006704r 3  69 6E 67 20  
00671Dr 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
006721r 3  67 61 6C 20  
006725r 3  53 4F 55 52  
00673Dr 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
006741r 3  72 70 72 65  
006745r 3  74 69 6E 67  
00675Er 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
006762r 3  52 65 64 20  
006766r 3  77 6F 72 64  
00677Br 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
00677Fr 3  73 69 6F 6E  
006783r 3  20 62 79 20  
00678Cr 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
006790r 3  69 6E 67 20  
006794r 3  66 61 69 6C  
00679Cr 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
0067A0r 3  20 63 6F 75  
0067A4r 3  6C 64 20 6E  
0067CAr 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
0067CEr 3  61 64 79 20  
0067D2r 3  69 6E 20 63  
0067E2r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
0067E6r 3  66 69 6E 65  
0067EAr 3  64 20 77 6F  
0067F1r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
0067F5r 3  6B 20 75 6E  
0067F9r 3  64 65 72 66  
006801r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
006805r 3  6D 65 6D 6F  
006809r 3  72 79 20 66  
00681Dr 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
006821r 3  6F 72 64 6C  
006825r 3  69 73 74 73  
006834r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
006838r 3  73 65 20 61  
00683Cr 3  73 73 69 67  
006873r 3               
006873r 3               ; ## ENVIRONMENT STRINGS
006873r 3               
006873r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
006873r 3               ; Length byte first, then the string itself that is not rpt. not
006873r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
006873r 3               ; "envs_".
006873r 3               
006873r 3               ; These return a single-cell number
006873r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
006877r 3  55 4E 54 45  
00687Br 3  44 2D 53 54  
006883r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
006887r 3  4C 44        
006889r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
00688Dr 3  44           
00688Er 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
006892r 3  52 45 53 53  
006896r 3  2D 55 4E 49  
0068A0r 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
0068A4r 3  4F 52 45 44  
0068A8r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
0068ACr 3  2D 43 48 41  
0068B0r 3  52           
0068B1r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
0068B5r 3  2D 4E        
0068B7r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
0068BBr 3  2D 55        
0068BDr 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
0068C1r 3  55 52 4E 2D  
0068C5r 3  53 54 41 43  
0068D0r 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
0068D4r 3  43 4B 2D 43  
0068D8r 3  45 4C 4C 53  
0068DCr 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
0068E0r 3  44 4C 49 53  
0068E4r 3  54 53        
0068E6r 3               
0068E6r 3               ; These return a double-cell number
0068E6r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
0068EAr 3  2D 44        
0068ECr 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
0068F0r 3  2D 55 44     
0068F3r 3               
0068F3r 3               ; END
0068F3r 3               
0068F3r 2               
0068F3r 2               
0068F3r 2               ; =====================================================================
0068F3r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
0068F3r 2               
0068F3r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
0068F3r 2               ; at compile time so they are available at run time. Words that use this
0068F3r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
0068F3r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
0068F3r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
0068F3r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
0068F3r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
0068F3r 2               ; Bowie.
0068F3r 2               
0068F3r 2               ;               ldy #>addr      ; MSB   ; "Young"
0068F3r 2               ;               lda #<addr      ; LSB   ; "Americans"
0068F3r 2               ;               jsr cmpl_subroutine
0068F3r 2               
0068F3r 2               ; Also, we keep a routine here to compile a single byte passed through A.
0068F3r 2               
0068F3r 2               cmpl_subroutine:
0068F3r 2                               ; This is the entry point to compile JSR <ADDR>
0068F3r 2  48                           pha             ; save LSB of address
0068F4r 2  A9 20                        lda #$20        ; load opcode for JSR
0068F6r 2  80 03                        bra cmpl_common
0068F8r 2               cmpl_jump:
0068F8r 2                               ; This is the entry point to compile JMP <ADDR>
0068F8r 2  48                           pha             ; save LSB of address
0068F9r 2  A9 4C                        lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
0068FBr 2               cmpl_common:
0068FBr 2                               ; At this point, A contains the opcode to be compiled,
0068FBr 2                               ; the LSB of the address is on the 65c02 stack, and the MSB of
0068FBr 2                               ; the address is in Y
0068FBr 2  20 rr rr                     jsr cmpl_a      ; compile opcode
0068FEr 2  68                           pla             ; retrieve address LSB; fall thru to cmpl_word
0068FFr 2               cmpl_word:
0068FFr 2                               ; This is the entry point to compile a word (little-endian)
0068FFr 2  20 rr rr                     jsr cmpl_a      ; compile LSB of address
006902r 2  98                           tya             ; fall thru for MSB
006903r 2               cmpl_a:
006903r 2                               ; This is the entry point to compile a single byte which
006903r 2                               ; is passed in A. The built-in assembler assumes that this
006903r 2                               ; routine does not modify Y.
006903r 2  92 00                        sta (cp)
006905r 2  E6 00                        inc cp
006907r 2  D0 02                        bne _done
006909r 2  E6 01                        inc cp+1
00690Br 2               _done:
00690Br 2  60                           rts
00690Cr 2               
00690Cr 2               
00690Cr 2               
00690Cr 2               ; =====================================================================
00690Cr 2               ; CODE FIELD ROUTINES
00690Cr 2               
00690Cr 2               doconst:
00690Cr 2                       ; """Execute a CONSTANT: Push the data in the first two bytes of
00690Cr 2                       ; the Data Field onto the Data Stack
00690Cr 2                       ; """
00690Cr 2  CA                           dex             ; make room for constant
00690Dr 2  CA                           dex
00690Er 2               
00690Er 2                               ; The value we need is stored in the two bytes after the
00690Er 2                               ; JSR return address, which in turn is what is on top of
00690Er 2                               ; the Return Stack
00690Er 2  68                           pla             ; LSB of return address
00690Fr 2  85 24                        sta tmp1
006911r 2  68                           pla             ; MSB of return address
006912r 2  85 25                        sta tmp1+1
006914r 2               
006914r 2                               ; Start LDY with 1 instead of 0 because of how JSR stores
006914r 2                               ; the return address on the 65c02
006914r 2  A0 01                        ldy #1
006916r 2  B1 24                        lda (tmp1),y
006918r 2  95 00                        sta 0,x
00691Ar 2  C8                           iny
00691Br 2  B1 24                        lda (tmp1),y
00691Dr 2  95 01                        sta 1,x
00691Fr 2               
00691Fr 2                               ; This takes us back to the original caller, not the
00691Fr 2                               ; DOCONST caller
00691Fr 2  60                           rts
006920r 2               
006920r 2               
006920r 2               dodefer:
006920r 2                       ; """Execute a DEFER statement at runtime: Execute the address we
006920r 2                       ; find after the caller in the Data Field
006920r 2                       ; """
006920r 2                               ; The xt we need is stored in the two bytes after the JSR
006920r 2                               ; return address, which is what is on top of the Return
006920r 2                               ; Stack. So all we have to do is replace our return jump
006920r 2                               ; with what we find there
006920r 2  68                           pla             ; LSB
006921r 2  85 24                        sta tmp1
006923r 2  68                           pla             ; MSB
006924r 2  85 25                        sta tmp1+1
006926r 2               
006926r 2  A0 01                        ldy #1
006928r 2  B1 24                        lda (tmp1),y
00692Ar 2  85 26                        sta tmp2
00692Cr 2  C8                           iny
00692Dr 2  B1 24                        lda (tmp1),y
00692Fr 2  85 27                        sta tmp2+1
006931r 2               
006931r 2  6C 26 00                     jmp (tmp2)      ; This is actually a jump to the new target
006934r 2               
006934r 2               defer_error:
006934r 2                               ; """Error routine for undefined DEFER: Complain and abort"""
006934r 2  A9 03                        lda #err_defer
006936r 2  4C rr rr                     jmp error
006939r 2               
006939r 2               dodoes:
006939r 2                       ; """Execute the runtime portion of DOES>. See DOES> and
006939r 2                       ; docs/create-does.txt for details and
006939r 2                       ; http://www.bradrodriguez.com/papers/moving3.htm
006939r 2                       ; """
006939r 2                               ; Assumes the address of the CFA of the original defining word
006939r 2                               ; (say, CONSTANT) is on the top of the Return Stack. Save it
006939r 2                               ; for a later jump, adding one byte because of the way the
006939r 2                               ; 6502 works
006939r 2  7A                           ply             ; LSB
00693Ar 2  68                           pla             ; MSB
00693Br 2  C8                           iny
00693Cr 2  D0 01                        bne @1
00693Er 2  1A                           inc
00693Fr 2               @1:
00693Fr 2  84 26                        sty tmp2
006941r 2  85 27                        sta tmp2+1
006943r 2               
006943r 2                               ; Next on the Return Stack should be the address of the PFA of
006943r 2                               ; the calling defined word (say, the name of whatever constant we
006943r 2                               ; just defined). Move this to the Data Stack, again adding one.
006943r 2  CA                           dex
006944r 2  CA                           dex
006945r 2               
006945r 2  7A                           ply
006946r 2  68                           pla
006947r 2  C8                           iny
006948r 2  D0 01                        bne @2
00694Ar 2  1A                           inc
00694Br 2               @2:
00694Br 2  94 00                        sty 0,x         ; LSB
00694Dr 2  95 01                        sta 1,x         ; MSB
00694Fr 2               
00694Fr 2                               ; This leaves the return address from the original main routine
00694Fr 2                               ; on top of the Return Stack. We leave that untouched and jump
00694Fr 2                               ; to the special code of the defining word. It's RTS instruction
00694Fr 2                               ; will take us back to the main routine
00694Fr 2  6C 26 00                     jmp (tmp2)
006952r 2               
006952r 2               
006952r 2               dovar:
006952r 2                       ; """Execute a variable: Push the address of the first bytes of
006952r 2                       ; the Data Field onto the stack. This is called with JSR so we
006952r 2                       ; can pick up the address of the calling variable off the 65c02's
006952r 2                       ; stack. The final RTS takes us to the original caller of the
006952r 2                       ; routine that itself called DOVAR. This is the default
006952r 2                       ; routine installed with CREATE.
006952r 2                       ; """
006952r 2                               ; Pull the return address off the machine's stack, adding
006952r 2                               ; one because of the way the 65c02 handles subroutines
006952r 2  7A                           ply             ; LSB
006953r 2  68                           pla             ; MSB
006954r 2  C8                           iny
006955r 2  D0 01                        bne @1
006957r 2  1A                           inc
006958r 2               @1:
006958r 2  CA                           dex
006959r 2  CA                           dex
00695Ar 2               
00695Ar 2  95 01                        sta 1,x
00695Cr 2  98                           tya
00695Dr 2  95 00                        sta 0,x
00695Fr 2               
00695Fr 2  60                           rts
006960r 2               
006960r 2               ; =====================================================================
006960r 2               ; LOW LEVEL HELPER FUNCTIONS
006960r 2               
006960r 2               byte_to_ascii:
006960r 2                       ; """Convert byte in A to two ASCII hex digits and EMIT them"""
006960r 2               .scope
006960r 2  48                           pha
006961r 2  4A                           lsr             ; convert high nibble first
006962r 2  4A                           lsr
006963r 2  4A                           lsr
006964r 2  4A                           lsr
006965r 2  20 rr rr                     jsr _nibble_to_ascii
006968r 2  68                           pla
006969r 2               
006969r 2                               ; fall through to _nibble_to_ascii
006969r 2               
006969r 2               _nibble_to_ascii:
006969r 2                       ; """Private helper function for byte_to_ascii: Print lower nibble
006969r 2                       ; of A and and EMIT it. This does the actual work.
006969r 2                       ; """
006969r 2  29 0F                        and #$0F
00696Br 2  09 30                        ora #'0'
00696Dr 2  C9 3A                        cmp #$3A        ; '9+1
00696Fr 2  90 02                        bcc @1
006971r 2  69 06                        adc #$06
006973r 2               
006973r 2  4C rr rr     @1:               jmp emit_a
006976r 2               
006976r 2  60                           rts
006977r 2               .endscope
006977r 2               
006977r 2               compare_16bit:
006977r 2                       ; """Compare TOS/NOS and return results in form of the 65c02 flags
006977r 2                       ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
006977r 2                       ; also http://www.6502.org/tutorials/compare_beyond.html
006977r 2                       ; For signed numbers, Z signals equality and N which number is larger:
006977r 2                       ;       if TOS = NOS: Z=1 and N=0
006977r 2                       ;       if TOS > NOS: Z=0 and N=0
006977r 2                       ;       if TOS < NOS: Z=0 and N=1
006977r 2                       ; For unsigned numbers, Z signals equality and C which number is larger:
006977r 2                       ;       if TOS = NOS: Z=1 and N=0
006977r 2                       ;       if TOS > NOS: Z=0 and C=1
006977r 2                       ;       if TOS < NOS: Z=0 and C=0
006977r 2                       ; Compared to the book routine, WORD1 (MINUED) is TOS
006977r 2                       ;                               WORD2 (SUBTRAHEND) is NOS
006977r 2                       ; """
006977r 2               .scope
006977r 2                               ; Compare LSB first to set the carry flag
006977r 2  B5 00                        lda 0,x                 ; LSB of TOS
006979r 2  D5 02                        cmp 2,x                 ; LSB of NOS
00697Br 2  F0 0A                        beq _equal
00697Dr 2               
00697Dr 2                               ; LSBs are not equal, compare MSB
00697Dr 2  B5 01                        lda 1,x                 ; MSB of TOS
00697Fr 2  F5 03                        sbc 3,x                 ; MSB of NOS
006981r 2  09 01                        ora #1                  ; Make zero flag 0 because not equal
006983r 2  70 08                        bvs _overflow
006985r 2  80 08                        bra _not_equal
006987r 2               _equal:
006987r 2                               ; Low bytes are equal, so we compare high bytes
006987r 2  B5 01                        lda 1,x                 ; MSB of TOS
006989r 2  F5 03                        sbc 3,x                 ; MSB of NOS
00698Br 2  50 04                        bvc _done
00698Dr 2               _overflow:
00698Dr 2                               ; Handle overflow because we use signed numbers
00698Dr 2  49 80                        eor #$80                ; complement negative flag
00698Fr 2               _not_equal:
00698Fr 2  09 01                        ora #1                  ; if overflow, we can't be eqal
006991r 2               _done:
006991r 2  60                           rts
006992r 2               .endscope
006992r 2               
006992r 2               current_to_dp:
006992r 2                       ; """Look up the current (compilation) dictionary pointer
006992r 2                       ; in the wordlist set and put it into the dp zero-page
006992r 2                       ; variable. Uses A and Y.
006992r 2                       ; """
006992r 2                               ; Determine which wordlist is current
006992r 2  A0 04                        ldy #current_offset
006994r 2  B1 1E                        lda (up),y      ; current is a byte variable
006996r 2  0A                           asl             ; turn it into an offset (in cells)
006997r 2               
006997r 2                               ; Get the dictionary pointer for that wordlist.
006997r 2  18                           clc
006998r 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
00699Ar 2  A8                           tay
00699Br 2  B1 1E                        lda (up),y              ; get the dp for that wordlist.
00699Dr 2  85 02                        sta dp
00699Fr 2  C8                           iny
0069A0r 2  B1 1E                        lda (up),y
0069A2r 2  85 03                        sta dp+1
0069A4r 2               
0069A4r 2  60                           rts
0069A5r 2               
0069A5r 2               
0069A5r 2               dp_to_current:
0069A5r 2                       ; """Look up which wordlist is current and update its pointer
0069A5r 2                       ; with the value in dp. Uses A and Y.
0069A5r 2                       ; """
0069A5r 2                               ; Determine which wordlist is current
0069A5r 2  A0 04                        ldy #current_offset
0069A7r 2  B1 1E                        lda (up),y      ; current is a byte variable
0069A9r 2  0A                           asl             ; turn it into an offset (in cells)
0069AAr 2               
0069AAr 2                               ; Get the dictionary pointer for that wordlist.
0069AAr 2  18                           clc
0069ABr 2  69 06                        adc #wordlists_offset   ; add offset to wordlists base.
0069ADr 2  A8                           tay
0069AEr 2  A5 02                        lda dp
0069B0r 2  91 1E                        sta (up),y              ; get the dp for that wordlist.
0069B2r 2  C8                           iny
0069B3r 2  A5 03                        lda dp+1
0069B5r 2  91 1E                        sta (up),y
0069B7r 2               
0069B7r 2  60                           rts
0069B8r 2               
0069B8r 2               interpret:
0069B8r 2               .scope
0069B8r 2                       ; """Core routine for the interpreter called by EVALUATE and QUIT.
0069B8r 2                       ; Process one line only. Assumes that the address of name is in
0069B8r 2                       ; cib and the length of the whole input line string is in ciblen
0069B8r 2                       ; """
0069B8r 2                               ; Normally we would use PARSE here with the SPACE character as
0069B8r 2                               ; a parameter (PARSE replaces WORD in modern Forths). However,
0069B8r 2                               ; Gforth's PARSE-NAME makes more sense as it uses spaces as
0069B8r 2                               ; delimiters per default and skips any leading spaces, which
0069B8r 2                               ; PARSE doesn't
0069B8r 2               _loop:
0069B8r 2  20 rr rr                     jsr xt_parse_name       ; ( "string" -- addr u )
0069BBr 2               
0069BBr 2                               ; If PARSE-NAME returns 0 (empty line), no characters were left
0069BBr 2                               ; in the line and we need to go get a new line
0069BBr 2  B5 00                        lda 0,x
0069BDr 2  15 01                        ora 1,x
0069BFr 2  F0 70                        beq _line_done
0069C1r 2               
0069C1r 2                               ; Go to FIND-NAME to see if this is a word we know. We have to
0069C1r 2                               ; make a copy of the address in case it isn't a word we know and
0069C1r 2                               ; we have to go see if it is a number
0069C1r 2  20 rr rr                     jsr xt_two_dup          ; ( addr u -- addr u addr u )
0069C4r 2  20 rr rr                     jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
0069C7r 2               
0069C7r 2                               ; A zero signals that we didn't find a word in the Dictionary
0069C7r 2  B5 00                        lda 0,x
0069C9r 2  15 01                        ora 1,x
0069CBr 2  D0 28                        bne _got_name_token
0069CDr 2               
0069CDr 2                               ; We didn't get any nt we know of, so let's see if this is
0069CDr 2                               ; a number.
0069CDr 2  E8                           inx                     ; ( addr u 0 -- addr u )
0069CEr 2  E8                           inx
0069CFr 2               
0069CFr 2                               ; If the number conversion doesn't work, NUMBER will do the
0069CFr 2                               ; complaining for us
0069CFr 2  20 rr rr                     jsr xt_number           ; ( addr u -- u|d )
0069D2r 2               
0069D2r 2                               ; Otherweise, if we're interpreting, we're done
0069D2r 2  A5 16                        lda state
0069D4r 2  F0 E2                        beq _loop
0069D6r 2               
0069D6r 2                               ; We're compiling, so there is a bit more work.  Check
0069D6r 2                               ; status bit 5 to see if it's a single or double-cell
0069D6r 2                               ; number.
0069D6r 2  A9 20                        lda #$20
0069D8r 2  24 20                        bit status
0069DAr 2  F0 0D                        beq _single_number
0069DCr 2               
0069DCr 2                               ; It's a double cell number.  If we swap the
0069DCr 2                               ; upper and lower half, we can use the literal_runtime twice
0069DCr 2                               ; to compile it into the dictionary.
0069DCr 2  20 rr rr                     jsr xt_swap
0069DFr 2  A0 rr                        ldy #>literal_runtime
0069E1r 2  A9 rr                        lda #<literal_runtime
0069E3r 2  20 rr rr                     jsr cmpl_subroutine
0069E6r 2               
0069E6r 2                               ; compile our number
0069E6r 2  20 rr rr                     jsr xt_comma
0069E9r 2               
0069E9r 2                               ; Fall into _single_number to process the other half.
0069E9r 2               _single_number:
0069E9r 2  A0 rr                        ldy #>literal_runtime
0069EBr 2  A9 rr                        lda #<literal_runtime
0069EDr 2  20 rr rr                     jsr cmpl_subroutine
0069F0r 2               
0069F0r 2                               ; compile our number
0069F0r 2  20 rr rr                     jsr xt_comma
0069F3r 2               
0069F3r 2                               ; That was so much fun, let's do it again!
0069F3r 2  80 C3                        bra _loop
0069F5r 2               
0069F5r 2               _got_name_token:
0069F5r 2                               ; We have a known word's nt TOS. We're going to need its xt
0069F5r 2                               ; though, which is four bytes father down.
0069F5r 2               
0069F5r 2                               ; We arrive here with ( addr u nt ), so we NIP twice
0069F5r 2  B5 00                        lda 0,x
0069F7r 2  95 04                        sta 4,x
0069F9r 2  B5 01                        lda 1,x
0069FBr 2  95 05                        sta 5,x
0069FDr 2               
0069FDr 2  E8                           inx
0069FEr 2  E8                           inx
0069FFr 2  E8                           inx
006A00r 2  E8                           inx                     ; ( nt )
006A01r 2               
006A01r 2                               ; Save a version of nt for error handling and compilation stuff
006A01r 2  B5 00                        lda 0,x
006A03r 2  85 22                        sta tmpbranch
006A05r 2  B5 01                        lda 1,x
006A07r 2  85 23                        sta tmpbranch+1
006A09r 2               
006A09r 2  20 rr rr                     jsr xt_name_to_int      ; ( nt - xt )
006A0Cr 2               
006A0Cr 2                               ; See if we are in interpret or compile mode, 0 is interpret
006A0Cr 2  A5 16                        lda state
006A0Er 2  D0 13                        bne _compile
006A10r 2               
006A10r 2                               ; We are interpreting, so EXECUTE the xt that is TOS. First,
006A10r 2                               ; though, see if this isn't a compile-only word, which would be
006A10r 2                               ; illegal. The status byte is the second one of the header.
006A10r 2  A0 01                        ldy #1
006A12r 2  B1 22                        lda (tmpbranch),y
006A14r 2  29 01                        and #CO                 ; mask everything but Compile Only bit
006A16r 2  F0 05                        beq _interpret
006A18r 2               
006A18r 2  A9 02                        lda #err_compileonly
006A1Ar 2  4C rr rr                     jmp error
006A1Dr 2               
006A1Dr 2               _interpret:
006A1Dr 2                               ; We JSR to EXECUTE instead of calling the xt directly because
006A1Dr 2                               ; the RTS of the word we're executing will bring us back here,
006A1Dr 2                               ; skipping EXECUTE completely during RTS. If we were to execute
006A1Dr 2                               ; xt directly, we have to fool around with the Return Stack
006A1Dr 2                               ; instead, which is actually slightly slower
006A1Dr 2  20 rr rr                     jsr xt_execute
006A20r 2               
006A20r 2                               ; That's quite enough for this word, let's get the next one
006A20r 2  4C rr rr                     jmp _loop
006A23r 2               
006A23r 2               _compile:
006A23r 2                               ; We're compiling! However, we need to see if this is an
006A23r 2                               ; IMMEDIATE word, which would mean we execute it right now even
006A23r 2                               ; during compilation mode. Fortunately, we saved the nt so life
006A23r 2                               ; is easier. The flags are in the second byte of the header
006A23r 2  A0 01                        ldy #1
006A25r 2  B1 22                        lda (tmpbranch),y
006A27r 2  29 04                        and #IM                 ; Mask all but IM bit
006A29r 2  D0 F2                        bne _interpret          ; IMMEDIATE word, execute right now
006A2Br 2               
006A2Br 2                               ; Compile the xt into the Dictionary with COMPILE,
006A2Br 2  20 rr rr                     jsr xt_compile_comma
006A2Er 2  4C rr rr                     jmp _loop
006A31r 2               
006A31r 2               _line_done:
006A31r 2                               ; drop stuff from PARSE_NAME
006A31r 2  E8                           inx
006A32r 2  E8                           inx
006A33r 2  E8                           inx
006A34r 2  E8                           inx
006A35r 2               
006A35r 2  60                           rts
006A36r 2               .endscope
006A36r 2               
006A36r 2               
006A36r 2               is_printable:
006A36r 2               .scope
006A36r 2                       ; """Given a character in A, check if it is a printable ASCII
006A36r 2                       ; character in the range from $20 to $7E inclusive. Returns the
006A36r 2                       ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
006A36r 2                       ; is printable. Keeps A. See
006A36r 2                       ; http://www.obelisk.me.uk/6502/algorithms.html for a
006A36r 2                       ; discussion of various ways to do this
006A36r 2  C9 20                        cmp #AscSP              ; $20
006A38r 2  90 08                        bcc _done
006A3Ar 2  C9 7F                        cmp #'~' + 1             ; $7E
006A3Cr 2  B0 03                        bcs _failed
006A3Er 2               
006A3Er 2  38                           sec
006A3Fr 2  80 01                        bra _done
006A41r 2               _failed:
006A41r 2  18                           clc
006A42r 2               _done:
006A42r 2  60                           rts
006A43r 2               .endscope
006A43r 2               
006A43r 2               
006A43r 2               is_whitespace:
006A43r 2               .scope
006A43r 2                       ; """Given a character in A, check if it is a whitespace
006A43r 2                       ; character, that is, an ASCII value from 0 to 32 (where
006A43r 2                       ; 32 is SPACE). Returns the result in the Carry Flag:
006A43r 2                       ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
006A43r 2                       ; that it is whitespace. See PARSE and PARSE-NAME for
006A43r 2                       ; a discussion of the uses. Does not change A or Y.
006A43r 2  C9 00                        cmp #00         ; explicit comparison to leave Y untouched
006A45r 2  90 08                        bcc _done
006A47r 2               
006A47r 2  C9 21                        cmp #AscSP+1
006A49r 2  B0 03                        bcs _failed
006A4Br 2               
006A4Br 2  38                           sec
006A4Cr 2  80 01                        bra _done
006A4Er 2               _failed:
006A4Er 2  18                           clc
006A4Fr 2               _done:
006A4Fr 2  60                           rts
006A50r 2               .endscope
006A50r 2               
006A50r 2               
006A50r 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
006A50r 2               ; required for the word. This routine flows into the generic error handling
006A50r 2               ; code
006A50r 2               underflow_1:
006A50r 2                       ; """Make sure we have at least one cell on the Data Stack"""
006A50r 2  E0 77                        cpx #dsp0-1
006A52r 2  10 10                        bpl underflow_error
006A54r 2  60                           rts
006A55r 2               underflow_2:
006A55r 2                       ; """Make sure we have at least two cells on the Data Stack"""
006A55r 2  E0 75                        cpx #dsp0-3
006A57r 2  10 0B                        bpl underflow_error
006A59r 2  60                           rts
006A5Ar 2               underflow_3:
006A5Ar 2                       ; """Make sure we have at least three cells on the Data Stack"""
006A5Ar 2  E0 73                        cpx #dsp0-5
006A5Cr 2  10 06                        bpl underflow_error
006A5Er 2  60                           rts
006A5Fr 2               underflow_4:
006A5Fr 2                       ; """Make sure we have at least four cells on the Data Stack"""
006A5Fr 2  E0 71                        cpx #dsp0-7
006A61r 2  10 01                        bpl underflow_error
006A63r 2  60                           rts
006A64r 2               
006A64r 2               underflow_error:
006A64r 2                               ; Entry for COLD/ABORT/QUIT
006A64r 2  A9 09                        lda #err_underflow      ; fall through to error
006A66r 2               
006A66r 2               error:
006A66r 2                       ; """Given the error number in a, print the associated error string and
006A66r 2                       ; call abort. Uses tmp3.
006A66r 2                       ; """
006A66r 2  0A                           asl
006A67r 2  A8                           tay
006A68r 2  B9 rr rr                     lda error_table,y
006A6Br 2  85 28                        sta tmp3                ; LSB
006A6Dr 2  C8                           iny
006A6Er 2  B9 rr rr                     lda error_table,y
006A71r 2  85 29                        sta tmp3+1              ; MSB
006A73r 2               
006A73r 2  20 rr rr                     jsr print_common
006A76r 2  20 rr rr                     jsr xt_cr
006A79r 2  4C rr rr                     jmp xt_abort            ; no jsr, as we clobber return stack
006A7Cr 2               
006A7Cr 2               
006A7Cr 2               ; =====================================================================
006A7Cr 2               ; PRINTING ROUTINES
006A7Cr 2               
006A7Cr 2               ; We distinguish two types of print calls, both of which take the string number
006A7Cr 2               ; (see strings.asm) in A:
006A7Cr 2               
006A7Cr 2               ;       print_string       - with a line feed
006A7Cr 2               ;       print_string_no_lf - without a line feed
006A7Cr 2               
006A7Cr 2               ; In addition, print_common provides a lower-level alternative for error
006A7Cr 2               ; handling and anything else that provides the address of the
006A7Cr 2               ; zero-terminated string directly in tmp3. All of those routines assume that
006A7Cr 2               ; printing should be more concerned with size than speed, because anything to
006A7Cr 2               ; do with humans reading text is going to be slow.
006A7Cr 2               
006A7Cr 2               print_string_no_lf:
006A7Cr 2                       ; """Given the number of a zero-terminated string in A, print it to the
006A7Cr 2                       ; current output without adding a LF. Uses Y and tmp3 by falling
006A7Cr 2                       ; through to print_common
006A7Cr 2                       ; """
006A7Cr 2                               ; Get the entry from the string table
006A7Cr 2  0A                           asl
006A7Dr 2  A8                           tay
006A7Er 2  B9 rr rr                     lda string_table,y
006A81r 2  85 28                        sta tmp3                ; LSB
006A83r 2  C8                           iny
006A84r 2  B9 rr rr                     lda string_table,y
006A87r 2  85 29                        sta tmp3+1              ; MSB
006A89r 2               
006A89r 2                               ; fall through to print_common
006A89r 2               print_common:
006A89r 2                       ; """Common print routine used by both the print functions and
006A89r 2                       ; the error printing routine. Assumes string address is in tmp3. Uses
006A89r 2                       ; Y.
006A89r 2                       ; """
006A89r 2               .scope
006A89r 2  A0 00                        ldy #0
006A8Br 2               _loop:
006A8Br 2  B1 28                        lda (tmp3),y
006A8Dr 2  F0 06                        beq _done               ; strings are zero-terminated
006A8Fr 2               
006A8Fr 2  20 rr rr                     jsr emit_a              ; allows vectoring via output
006A92r 2  C8                           iny
006A93r 2  80 F6                        bra _loop
006A95r 2               _done:
006A95r 2  60                           rts
006A96r 2               .endscope
006A96r 2               
006A96r 2               print_string:
006A96r 2                       ; """Print a zero-terminated string to the console/screen, adding a LF.
006A96r 2                       ; We do not check to see if the index is out of range. Uses tmp3.
006A96r 2                       ; """
006A96r 2  20 rr rr                     jsr print_string_no_lf
006A99r 2  4C rr rr                     jmp xt_cr               ; JSR/RTS because never compiled
006A9Cr 2               
006A9Cr 2               
006A9Cr 2               print_u:
006A9Cr 2                       ; """basic printing routine used by higher-level constructs,
006A9Cr 2                       ; the equivalent of the forth word  0 <# #s #> type  which is
006A9Cr 2                       ; basically u. without the space at the end. used for various
006A9Cr 2                       ; outputs
006A9Cr 2                       ; """
006A9Cr 2  20 rr rr                     jsr xt_zero                     ; 0
006A9Fr 2  20 rr rr                     jsr xt_less_number_sign         ; <#
006AA2r 2  20 rr rr                     jsr xt_number_sign_s            ; #S
006AA5r 2  20 rr rr                     jsr xt_number_sign_greater      ; #>
006AA8r 2  4C rr rr                     jmp xt_type                     ; JSR/RTS because never compiled
006AABr 2               
006AABr 2               ; END
006AABr 2               
006AABr 1               
006AABr 1               ; =====================================================================
006AABr 1               ; FINALLY
006AABr 1               
006AABr 1               ; Of the 32 KiB we use, 24 KiB are reserved for Tali (from $8000 to $DFFF)
006AABr 1               ; and the last eight (from $E000 to $FFFF) are left for whatever the user
006AABr 1               ; wants to use them for.
006AABr 1               
006AABr 1               
006AABr 1               ; ******************************************************************
006AABr 1               ; *  Hardware definitions for Planck 6502 computer                 *
006AABr 1               ; *  Change these depending on the slot in which                   *
006AABr 1               ; *  you want to put each card                                     *
006AABr 1               ; *  As a reminder here are the addresses for each slot:           *
006AABr 1               ; *                                                                *
006AABr 1               ; * START ADDRESS    |   END ADDRESS       |     DESCRIPTION       *
006AABr 1               ; * 0xFF80           |   0xFF8F            | SLOT1 Selected        *
006AABr 1               ; * 0xFF90           |   0xFF9F            | SLOT2 Selected        *
006AABr 1               ; * 0xFFA0           |   0xFFAF            | SLOT3 Selected        *
006AABr 1               ; * 0xFFB0           |   0xFFBF            | SLOT4 Selected        *
006AABr 1               ; * 0xFFC0           |   0xFFCF            | SLOT5 Selected        *
006AABr 1               ; ******************************************************************
006AABr 1               ;
006AABr 1               ;
006AABr 1               
006AABr 1               .segment "KERNEL"
000000r 1               
000000r 1               ; Default kernel file for Tali Forth 2
000000r 1               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 1               ; First version: 19. Jan 2014
000000r 1               ; This version: 18. Feb 2018
000000r 1               ;
000000r 1               ; This section attempts to isolate the hardware-dependent parts of Tali
000000r 1               ; Forth 2 to make it easier for people to port it to their own machines.
000000r 1               ; Ideally, you shouldn't have to touch any other files. There are three
000000r 1               ; routines and one string that must be present for Tali to run:
000000r 1               ;
000000r 1               ;       kernel_init - Initialize the low-level hardware
000000r 1               ;       kernel_getc - Get single character in A from the keyboard (blocks)
000000r 1               ;       kernel_putc - Prints the character in A to the screen
000000r 1               ;       s_kernel_id - The zero-terminated string printed at boot
000000r 1               ;
000000r 1               
000000r 1               
000000r 1               v_reset:
000000r 1               kernel_init:
000000r 1                       ; """Initialize the hardware. This is called with a JMP and not
000000r 1                       ; a JSR because we don't have anything set up for that yet. With
000000r 1                       ; py65mon, of course, this is really easy. -- At the end, we JMP
000000r 1                       ; back to the label forth to start the Forth system.
000000r 1                       ; """
000000r 1               
000000r 1  A9 01                lda #1
000002r 1  8D 81 FF             sta PORTA
000005r 1  A9 FF                lda #$FF
000007r 1  8D 83 FF             sta DDRA
00000Ar 1  8D 82 FF             sta DDRB
00000Dr 1               
00000Dr 1  A0 04                ldy #04
00000Fr 1  20 rr rr             jsr delay_long
000012r 1               
000012r 1  20 rr rr             jsr video_init
000015r 1               
000015r 1               
000015r 1  20 rr rr             jsr ps2_init
000018r 1  20 rr rr             jsr timer_init
00001Br 1  20 rr rr             jsr Init_ACIA
00001Er 1               
00001Er 1  20 rr rr             jsr lcd_init
000021r 1               
000021r 1               v_nmi:
000021r 1  58                   cli
000022r 1                       ; lda #$55
000022r 1                       ; sta PORTA
000022r 1                       ; We've successfully set everything up, so print the kernel
000022r 1                       ; string
000022r 1  A2 00                ldx #0
000024r 1               @loop:
000024r 1  BD rr rr             lda s_kernel_id,x
000027r 1  F0 06                beq @done
000029r 1  20 rr rr             jsr kernel_putc
00002Cr 1  E8                   inx
00002Dr 1  80 F5                bra @loop
00002Fr 1               @done:
00002Fr 1  A9 01                lda #1
000031r 1  8D 80 FF             sta PORTB
000034r 1  4C rr rr             jmp forth
000037r 1               
000037r 1               
000037r 1               
000037r 1               ; The Planck computer runs Tali Forth 2 as the OS, to there is nowhere to go back to.
000037r 1               ; Just restart TALI.
000037r 1               platform_bye:
000037r 1  4C rr rr             jmp kernel_init
00003Ar 1               
00003Ar 1               
00003Ar 1                   ;; Init ACIA to 115200 8,N,1
00003Ar 1                   ;; Uses: A (not restored)
00003Ar 1               Init_ACIA:
00003Ar 1  8D E1 FF             sta ACIA_STATUS        ; soft reset (value not important)
00003Dr 1                                               ; set specific modes and functions
00003Dr 1  64 96                stz has_acia
00003Fr 1  A9 0B                lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000041r 1                       ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
000041r 1  8D E2 FF             sta ACIA_COMMAND        ; store to the command register
000044r 1  AD E2 FF             lda ACIA_COMMAND        ; load command register again
000047r 1  C9 0B                cmp #$0B                ; if not the same
000049r 1  D0 10                bne acia_absent         ; then it means the ACIA is not connected
00004Br 1  AD E1 FF             lda ACIA_STATUS         ; Read the ACAI status to
00004Er 1  29 60                and #$60                ; check if present or absent
000050r 1  D0 09                bne acia_absent
000052r 1  A9 01                lda #1
000054r 1  85 96                sta has_acia           ; remember that ACIA is here
000056r 1  A9 10                lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000058r 1                       ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000058r 1  8D E3 FF             sta ACIA_CTRL          ; program the ctl register
00005Br 1               
00005Br 1               acia_absent:
00005Br 1  A0 14                ldy #20
00005Dr 1               aa_loop:
00005Dr 1  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
000060r 1  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
000063r 1  88                   dey
000064r 1  D0 F7                bne aa_loop
000066r 1               aa_end:
000066r 1  60                   rts
000067r 1               
000067r 1               
000067r 1                       ;; Get_Char - get a character from the serial port into A.
000067r 1                       ;; Set the carry flag if char is valid.
000067r 1                       ;; Return immediately with carry flag clear if no char available.
000067r 1                       ;; Uses: A (return value)
000067r 1               Get_Char:
000067r 1  A5 96                lda has_acia                    ; if no ACIA
000069r 1  F0 0F                beq no_acia_char_available      ; exit now
00006Br 1  AD E1 FF             lda ACIA_STATUS                 ; Read the ACAI status to
00006Er 1  29 08                and #$08                        ; Check if there is character in the receiver
000070r 1  F0 08                beq no_acia_char_available      ; Exit now if we don't get one.
000072r 1  AD E0 FF             lda ACIA_DATA                   ; Load it into the accumulator
000075r 1  38                   sec                             ; Set Carry to show we got a character
000076r 1  20 rr rr             jsr check_ctrl_c
000079r 1  60                   rts                             ; Return
00007Ar 1               
00007Ar 1               no_acia_char_available:                 ; no ACIA char available
00007Ar 1  DA                   phx                             ; save X
00007Br 1  A6 85                ldx KB_BUF_R_PTR                ; check the keyboard buffer
00007Dr 1  BD 01 7B             lda KB_BUF, x
000080r 1  F0 0B                beq no_ps2_char_available       ; exit if nothing found
000082r 1  9E 01 7B             stz KB_BUF, x                   ; if there was a character, reset this buffer cell
000085r 1  E6 85                inc KB_BUF_R_PTR                ; and increment the read pointer
000087r 1               
000087r 1  38                   sec                             ; mark character present
000088r 1  FA                   plx                             ; restore X
000089r 1  20 rr rr             jsr check_ctrl_c
00008Cr 1  60                   rts                             ; return
00008Dr 1               no_ps2_char_available:                  ; no keyboard char
00008Dr 1  E6 85                inc KB_BUF_R_PTR                ; increment read pointer for next time
00008Fr 1  FA                   plx                             ; restore X
000090r 1               no_char_available:
000090r 1  18                   clc                             ; Indicate no char available.
000091r 1  60                   rts                             ; return
000092r 1               
000092r 1               
000092r 1               
000092r 1               
000092r 1               
000092r 1               kernel_getc:
000092r 1                       ; """Get a single character from the keyboard (waits for key).
000092r 1                       ; """
000092r 1                       ;; Get_Char_Wait - same as Get_Char only blocking.
000092r 1                       ;; Uses: A (return value)
000092r 1               Get_Char_Wait:
000092r 1  20 rr rr             jsr Get_Char
000095r 1  90 FB                bcc Get_Char_Wait
000097r 1  60                   rts
000098r 1               
000098r 1               check_ctrl_c:
000098r 1                       ;; Check if we have ctrl-C character, if so jump to nmi
000098r 1  C9 03                cmp #$03
00009Ar 1  D0 03                bne exit_ctrl_c
00009Cr 1               
00009Cr 1               
00009Cr 1  4C rr rr             jmp xt_abort
00009Fr 1               
00009Fr 1               exit_ctrl_c:
00009Fr 1  38                   sec
0000A0r 1  60                   rts
0000A1r 1               
0000A1r 1               kernel_putc:
0000A1r 1                       ; """Print a single character to the console. """
0000A1r 1                       ;; Send_Char - send character in A out serial port.
0000A1r 1                       ;; Uses: A (original value restored)
0000A1r 1               Send_Char:
0000A1r 1  48                   pha
0000A2r 1  20 rr rr             jsr char_out
0000A5r 1  5A                   phy
0000A6r 1  A4 96                ldy has_acia
0000A8r 1  F0 08                beq send_char_exit
0000AAr 1  8D E0 FF             sta ACIA_DATA
0000ADr 1               
0000ADr 1                       ; nedd to provide additional delay for ACIA
0000ADr 1  A0 20                ldy #$20
0000AFr 1  20 rr rr             jsr delay_short
0000B2r 1                       ; Delay is provided by writing to the LCD screen
0000B2r 1                       ;ldy #$32            ;minimal delay; The min delay increased when added diode on SLOW. Why?
0000B2r 1                       ;jsr delay_short
0000B2r 1                       ;ldy #$30
0000B2r 1                       ;jsr delay
0000B2r 1               
0000B2r 1                       ;jsr char_out
0000B2r 1               send_char_exit:
0000B2r 1                       ;jsr lcd_print
0000B2r 1  7A                   ply
0000B3r 1  68                   pla
0000B4r 1  60                   rts
0000B5r 1               
0000B5r 1               
0000B5r 1               v_irq:                          ; IRQ handler
0000B5r 1  48                   pha
0000B6r 1  5A                   phy
0000B7r 1                       ; check if bit 7 of IFR is set
0000B7r 1  AD 8D FF             lda IFR
0000BAr 1  10 2B                bpl v_exit  ; Interrupt not from VIA, exit
0000BCr 1               
0000BCr 1  29 08                and #$08        ; ps2 has priority
0000BEr 1  D0 09                bne v_ps2
0000C0r 1  AD 8D FF             lda IFR
0000C3r 1  29 40                and #$40
0000C5r 1  D0 17                bne v_timer
0000C7r 1  80 1E                bra v_exit
0000C9r 1               
0000C9r 1               
0000C9r 1               v_ps2:
0000C9r 1  A5 7A                lda time
0000CBr 1  85 7E                sta last_ps2_time
0000CDr 1  A5 7B                lda time+1
0000CFr 1  85 7F                sta last_ps2_time+1
0000D1r 1  A5 7C                lda time+2
0000D3r 1  85 80                sta last_ps2_time+2
0000D5r 1  A5 7D                lda time+3
0000D7r 1  85 81                sta last_ps2_time+3
0000D9r 1                       ; this delay is here to ensure we prevent desynchronization
0000D9r 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
0000D9r 1                       ; jsr delay_short
0000D9r 1               
0000D9r 1               
0000D9r 1  20 rr rr             jsr ps2_irq
0000DCr 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
0000DCr 1                       ; jsr delay_short
0000DCr 1  80 09                bra v_exit
0000DEr 1               v_timer:
0000DEr 1  AD 84 FF             lda T1CL
0000E1r 1  20 rr rr             jsr timer_irq
0000E4r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
0000E7r 1                       ; check if there is a char waiting to be printed to the lcd
0000E7r 1                       ; lda lcd_char
0000E7r 1                       ; beq v_exit
0000E7r 1                       ; jsr lcd_print
0000E7r 1                       ; stz lcd_char
0000E7r 1               
0000E7r 1               v_exit:
0000E7r 1  7A                   ply
0000E8r 1  68                   pla
0000E9r 1  40                   rti
0000EAr 1               
0000EAr 1               ; Leave the following string as the last entry in the kernel routine so it
0000EAr 1               ; is easier to see where the kernel ends in hex dumps. This string is
0000EAr 1               ; displayed after a successful boot
0000EAr 1               s_kernel_id:
0000EAr 1  54 61 6C 69          .byte "Tali Forth 2.1 for Planck 6502", 0
0000EEr 1  20 46 6F 72  
0000F2r 1  74 68 20 32  
000109r 1               
000109r 1               
000109r 1               
000109r 1               ; Add the interrupt vectors
000109r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000006r 1               
000006r 1               ; END
000006r 1               
000006r 1               
