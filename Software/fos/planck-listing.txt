ca65 V2.18 - N/A
Main file   : platform/planck/main.s
Current file: platform/planck/main.s

000000r 1               CLOCK_SPEED = 24000000
000000r 1               
000000r 1               ram_end = $8000
000000r 1               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/via.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               VIA1_BASE   = $FF80
000000r 2               PORTB = VIA1_BASE
000000r 2               PORTA  = VIA1_BASE+1
000000r 2               DDRB = VIA1_BASE+2
000000r 2               DDRA = VIA1_BASE+3
000000r 2               
000000r 2               
000000r 2               T1CL = VIA1_BASE + 4
000000r 2               T1CH = VIA1_BASE + 5
000000r 2               T1LL = VIA1_BASE + 6
000000r 2               T1LH = VIA1_BASE + 7
000000r 2               ACR = VIA1_BASE + 11
000000r 2               PCR = VIA1_BASE + 12
000000r 2               IFR = VIA1_BASE + 13
000000r 2               IER = VIA1_BASE + 14
000000r 2               
000000r 1               .include "drivers/ps2.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               DATA = $80   ; Data is in bit 7 of PORTA
000000r 2               ; clock is on CA2
000000r 2               SHIFT = $1
000000r 2               ALT = $2
000000r 2               
000000r 2               KB_STATE_START = $0
000000r 2               KB_STATE_DATA = $1
000000r 2               KB_STATE_PARITY = $2
000000r 2               KB_STATE_STOP = $3
000000r 2               
000000r 2               KB_INIT_STATE_RESET = $0
000000r 2               KB_INIT_STATE_RESET_ACK = $1
000000r 2               KB_INIT_STATE_LEDS = $2
000000r 2               KB_INIT_STATE_LEDS_ACK = $3
000000r 2               KB_INIT_STATE_LEDS_DATA = $4
000000r 2               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 2               
000000r 2               LSHIFT_KEY = $12
000000r 2               RSHIFT_KEY = $59
000000r 2               
000000r 2               TIMER_DELAY = $C4
000000r 2               
000000r 2               
000000r 1               .include "drivers/lcd.inc"
000000r 2               
000000r 2               ; HD 44780 driver
000000r 2               ; all pins on VIA PORTA, 4 bit mode
000000r 2               
000000r 2               ; PORTA0 is free
000000r 2               LCD_BASE = $FFC0
000000r 2               LCD_ADDR_DISABLED = LCD_BASE
000000r 2               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 2               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 2               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 2               
000000r 2               
000000r 2               ; A0: RS
000000r 2               ; A1: E
000000r 2               
000000r 1               .include "drivers/vga.inc"
000000r 2               VIDEO_BASE = $FFB0
000000r 2               
000000r 2               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 2               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;// also contains the increment ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 2               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 2               VIDEO_DATA = VIDEO_BASE + 3
000000r 2               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 2               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 2               
000000r 2               VIDEO_HIRES_HCHARS = 80
000000r 2               VIDEO_HIRES_VCHARS = 60
000000r 2               
000000r 1               
000000r 1               .include "drivers/zp.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               ; next_addr: .res 1
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               .segment "ZEROPAGE": zeropage
000000r 2               
000000r 2  xx xx        stack_p: .res 2
000002r 2  xx xx xx xx  time: .res 4
000006r 2  xx xx xx xx  last_ps2_time: .res 4
00000Ar 2               
00000Ar 2  xx           KB_BUF_W_PTR: .res 1
00000Br 2  xx           KB_BUF_R_PTR: .res 1
00000Cr 2  xx           control_keys: .res 1
00000Dr 2  xx           character: .res 1
00000Er 2  xx           debug: .res 1
00000Fr 2  xx xx        sd_buffer_address: .res 2
000011r 2  xx           temp_bits: .res 1
000012r 2  xx           LCD_BUF_W_PTR: .res 1
000013r 2  xx           LCD_BUF_R_PTR: .res 1
000014r 2  xx xx        fat32_filenamepointer: .res 2
000016r 2               
000016r 1               
000016r 1               
000016r 1               .segment "BSS"
000000r 1  xx xx xx xx  LCD_BUF: .res 128
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000080r 1  xx xx xx xx  KB_BUF: .res 128
000084r 1  xx xx xx xx  
000088r 1  xx xx xx xx  
000100r 1               
000100r 1  xx xx xx xx  FAT_VARS: .res 24
000104r 1  xx xx xx xx  
000108r 1  xx xx xx xx  
000118r 1  xx xx        SD_TMP: .res 2
00011Ar 1               
00011Ar 1  xx           SD_CRC: .res 1
00011Br 1  xx           SD_SLAVE: .res 1
00011Cr 1  xx xx xx xx  SD_ARG: .res 4
000120r 1               
000120r 1  xx           line: .res 1
000121r 1  xx           char: .res 1
000122r 1  xx           lcd_absent: .res 1
000123r 1  xx           lcd_pos: .res 1
000124r 1  xx           has_acia: .res 1
000125r 1  xx           spi_tmp: .res 1
000126r 1  xx           spi_tmp2: .res 1
000127r 1  xx           spi_slave: .res 1
000128r 1  xx           sd_sector: .res 1
000129r 1               
000129r 1  xx           to_send: .res 1
00012Ar 1  xx           KB_STATE: .res 1
00012Br 1  xx           KB_TEMP: .res 1
00012Cr 1  xx           KB_PARITY: .res 1
00012Dr 1  xx           KB_BIT: .res 1
00012Er 1  xx           KB_INIT_STATE: .res 1
00012Fr 1  xx           KB_INIT_WAIT: .res 1
000130r 1               
000130r 1  xx           ready: .res 1
000131r 1               
000131r 1  xx           ignore_next: .res 1
000132r 1  xx xx xx xx  SD_BUF: .res $800
000136r 1  xx xx xx xx  
00013Ar 1  xx xx xx xx  
000932r 1               
000932r 1               .segment "RODATA"
000000r 1               
000000r 1               .include "drivers/keycodes.s"
000000r 2               
000000r 2               
000000r 2               ASCIITBL:
000000r 2  00               .byte $00               ; 00 no key pressed
000001r 2  89               .byte $89               ; 01 F9
000002r 2  87               .byte $87               ; 02 relocated F7
000003r 2  85               .byte $85               ; 03 F5
000004r 2  83               .byte $83               ; 04 F3
000005r 2  81               .byte $81               ; 05 F1
000006r 2  82               .byte $82               ; 06 F2
000007r 2  8C               .byte $8C               ; 07 F12
000008r 2  00               .byte $00               ; 08
000009r 2  8A               .byte $8A               ; 09 F10
00000Ar 2  88               .byte $88               ; 0A F8
00000Br 2  86               .byte $86               ; 0B F6
00000Cr 2  84               .byte $84               ; 0C F4
00000Dr 2  09               .byte $09               ; 0D tab
00000Er 2  60               .byte $60               ; 0E `~
00000Fr 2  8F               .byte $8F               ; 0F relocated Print Screen key
000010r 2  03               .byte $03               ; 10 relocated Pause/Break key
000011r 2  A0               .byte $A0               ; 11 left alt (right alt too)
000012r 2  00               .byte $00               ; 12 left shift
000013r 2  E0               .byte $E0               ; 13 relocated Alt release code
000014r 2  00               .byte $00               ; 14 left ctrl (right ctrl too)
000015r 2  71               .byte $71               ; 15 qQ
000016r 2  31               .byte $31               ; 16 1!
000017r 2  00               .byte $00               ; 17
000018r 2  00               .byte $00               ; 18
000019r 2  00               .byte $00               ; 19
00001Ar 2  7A               .byte $7A               ; 1A zZ
00001Br 2  73               .byte $73               ; 1B sS
00001Cr 2  61               .byte $61               ; 1C aA
00001Dr 2  77               .byte $77               ; 1D wW
00001Er 2  32               .byte $32               ; 1E 2@
00001Fr 2  A1               .byte $A1               ; 1F Windows 98 menu key (left side)
000020r 2  02               .byte $02               ; 20 relocated ctrl-break key
000021r 2  63               .byte $63               ; 21 cC
000022r 2  78               .byte $78               ; 22 xX
000023r 2  64               .byte $64               ; 23 dD
000024r 2  65               .byte $65               ; 24 eE
000025r 2  34               .byte $34               ; 25 4$
000026r 2  33               .byte $33               ; 26 3#
000027r 2  A2               .byte $A2               ; 27 Windows 98 menu key (right side)
000028r 2  00               .byte $00               ; 28
000029r 2  20               .byte $20               ; 29 space
00002Ar 2  76               .byte $76               ; 2A vV
00002Br 2  66               .byte $66               ; 2B fF
00002Cr 2  74               .byte $74               ; 2C tT
00002Dr 2  72               .byte $72               ; 2D rR
00002Er 2  35               .byte $35               ; 2E 5%
00002Fr 2  A3               .byte $A3               ; 2F Windows 98 option key (right click, right side)
000030r 2  00               .byte $00               ; 30
000031r 2  6E               .byte $6E               ; 31 nN
000032r 2  62               .byte $62               ; 32 bB
000033r 2  68               .byte $68               ; 33 hH
000034r 2  67               .byte $67               ; 34 gG
000035r 2  79               .byte $79               ; 35 yY
000036r 2  36               .byte $36               ; 36 6^
000037r 2  00               .byte $00               ; 37
000038r 2  00               .byte $00               ; 38
000039r 2  00               .byte $00               ; 39
00003Ar 2  6D               .byte $6D               ; 3A mM
00003Br 2  6A               .byte $6A               ; 3B jJ
00003Cr 2  75               .byte $75               ; 3C uU
00003Dr 2  37               .byte $37               ; 3D 7&
00003Er 2  38               .byte $38               ; 3E 8*
00003Fr 2  00               .byte $00               ; 3F
000040r 2  00               .byte $00               ; 40
000041r 2  2C               .byte $2C               ; 41 ,<
000042r 2  6B               .byte $6B               ; 42 kK
000043r 2  69               .byte $69               ; 43 iI
000044r 2  6F               .byte $6F               ; 44 oO
000045r 2  30               .byte $30               ; 45 0)
000046r 2  39               .byte $39               ; 46 9(
000047r 2  00               .byte $00               ; 47
000048r 2  00               .byte $00               ; 48
000049r 2  2E               .byte $2E               ; 49 .>
00004Ar 2  2F               .byte $2F               ; 4A /?
00004Br 2  6C               .byte $6C               ; 4B lL
00004Cr 2  3B               .byte $3B               ; 4C ;:
00004Dr 2  70               .byte $70               ; 4D pP
00004Er 2  2D               .byte $2D               ; 4E -_
00004Fr 2  00               .byte $00               ; 4F
000050r 2  00               .byte $00               ; 50
000051r 2  00               .byte $00               ; 51
000052r 2  27               .byte $27               ; 52 '"
000053r 2  00               .byte $00               ; 53
000054r 2  5B               .byte $5B               ; 54 [{
000055r 2  3D               .byte $3D               ; 55 =+
000056r 2  00               .byte $00               ; 56
000057r 2  00               .byte $00               ; 57
000058r 2  00               .byte $00               ; 58 caps
000059r 2  00               .byte $00               ; 59 r shift
00005Ar 2  0D               .byte $0D               ; 5A <Enter>
00005Br 2  5D               .byte $5D               ; 5B ]}
00005Cr 2  00               .byte $00               ; 5C
00005Dr 2  5C               .byte $5C               ; 5D \|
00005Er 2  00               .byte $00               ; 5E
00005Fr 2  00               .byte $00               ; 5F
000060r 2  00               .byte $00               ; 60
000061r 2  00               .byte $00               ; 61
000062r 2  00               .byte $00               ; 62
000063r 2  00               .byte $00               ; 63
000064r 2  00               .byte $00               ; 64
000065r 2  00               .byte $00               ; 65
000066r 2  08               .byte $08               ; 66 bkspace
000067r 2  00               .byte $00               ; 67
000068r 2  00               .byte $00               ; 68
000069r 2  31               .byte $31               ; 69 kp 1
00006Ar 2  2F               .byte $2f               ; 6A kp / converted from E04A in code
00006Br 2  34               .byte $34               ; 6B kp 4
00006Cr 2  37               .byte $37               ; 6C kp 7
00006Dr 2  00               .byte $00               ; 6D
00006Er 2  00               .byte $00               ; 6E
00006Fr 2  00               .byte $00               ; 6F
000070r 2  30               .byte $30               ; 70 kp 0
000071r 2  2E               .byte $2E               ; 71 kp .
000072r 2  32               .byte $32               ; 72 kp 2
000073r 2  35               .byte $35               ; 73 kp 5
000074r 2  36               .byte $36               ; 74 kp 6
000075r 2  38               .byte $38               ; 75 kp 8
000076r 2  1B               .byte $1B               ; 76 esc
000077r 2  00               .byte $00               ; 77 num lock
000078r 2  8B               .byte $8B               ; 78 F11
000079r 2  2B               .byte $2B               ; 79 kp +
00007Ar 2  33               .byte $33               ; 7A kp 3
00007Br 2  2D               .byte $2D               ; 7B kp -
00007Cr 2  2A               .byte $2A               ; 7C kp *
00007Dr 2  39               .byte $39               ; 7D kp 9
00007Er 2  8D               .byte $8D               ; 7E scroll lock
00007Fr 2  00               .byte $00               ; 7F
000080r 2                   ;
000080r 2                   ; Table for shifted scancodes
000080r 2                   ;
000080r 2  00               .byte $00               ; 80
000081r 2  C9               .byte $C9               ; 81 F9
000082r 2  C7               .byte $C7               ; 82 relocated F7
000083r 2  C5               .byte $C5               ; 83 F5 (F7 actual scancode=83)
000084r 2  C3               .byte $C3               ; 84 F3
000085r 2  C1               .byte $C1               ; 85 F1
000086r 2  C2               .byte $C2               ; 86 F2
000087r 2  CC               .byte $CC               ; 87 F12
000088r 2  00               .byte $00               ; 88
000089r 2  CA               .byte $CA               ; 89 F10
00008Ar 2  C8               .byte $C8               ; 8A F8
00008Br 2  C6               .byte $C6               ; 8B F6
00008Cr 2  C4               .byte $C4               ; 8C F4
00008Dr 2  09               .byte $09               ; 8D tab
00008Er 2  7E               .byte $7E               ; 8E `~
00008Fr 2  CF               .byte $CF               ; 8F relocated Print Screen key
000090r 2  03               .byte $03               ; 90 relocated Pause/Break key
000091r 2  A0               .byte $A0               ; 91 left alt (right alt)
000092r 2  00               .byte $00               ; 92 left shift
000093r 2  E0               .byte $E0               ; 93 relocated Alt release code
000094r 2  00               .byte $00               ; 94 left ctrl (and right ctrl)
000095r 2  51               .byte $51               ; 95 qQ
000096r 2  21               .byte $21               ; 96 1!
000097r 2  00               .byte $00               ; 97
000098r 2  00               .byte $00               ; 98
000099r 2  00               .byte $00               ; 99
00009Ar 2  5A               .byte $5A               ; 9A zZ
00009Br 2  53               .byte $53               ; 9B sS
00009Cr 2  41               .byte $41               ; 9C aA
00009Dr 2  57               .byte $57               ; 9D wW
00009Er 2  40               .byte $40               ; 9E 2@
00009Fr 2  E1               .byte $E1               ; 9F Windows 98 menu key (left side)
0000A0r 2  02               .byte $02               ; A0 relocated ctrl-break key
0000A1r 2  43               .byte $43               ; A1 cC
0000A2r 2  58               .byte $58               ; A2 xX
0000A3r 2  44               .byte $44               ; A3 dD
0000A4r 2  45               .byte $45               ; A4 eE
0000A5r 2  24               .byte $24               ; A5 4$
0000A6r 2  23               .byte $23               ; A6 3#
0000A7r 2  E2               .byte $E2               ; A7 Windows 98 menu key (right side)
0000A8r 2  00               .byte $00               ; A8
0000A9r 2  20               .byte $20               ; A9 space
0000AAr 2  56               .byte $56               ; AA vV
0000ABr 2  46               .byte $46               ; AB fF
0000ACr 2  54               .byte $54               ; AC tT
0000ADr 2  52               .byte $52               ; AD rR
0000AEr 2  25               .byte $25               ; AE 5%
0000AFr 2  E3               .byte $E3               ; AF Windows 98 option key (right click, right side)
0000B0r 2  00               .byte $00               ; B0
0000B1r 2  4E               .byte $4E               ; B1 nN
0000B2r 2  42               .byte $42               ; B2 bB
0000B3r 2  48               .byte $48               ; B3 hH
0000B4r 2  47               .byte $47               ; B4 gG
0000B5r 2  59               .byte $59               ; B5 yY
0000B6r 2  5E               .byte $5E               ; B6 6^
0000B7r 2  00               .byte $00               ; B7
0000B8r 2  00               .byte $00               ; B8
0000B9r 2  00               .byte $00               ; B9
0000BAr 2  4D               .byte $4D               ; BA mM
0000BBr 2  4A               .byte $4A               ; BB jJ
0000BCr 2  55               .byte $55               ; BC uU
0000BDr 2  26               .byte $26               ; BD 7&
0000BEr 2  2A               .byte $2A               ; BE 8*
0000BFr 2  00               .byte $00               ; BF
0000C0r 2  00               .byte $00               ; C0
0000C1r 2  3C               .byte $3C               ; C1 ,<
0000C2r 2  4B               .byte $4B               ; C2 kK
0000C3r 2  49               .byte $49               ; C3 iI
0000C4r 2  4F               .byte $4F               ; C4 oO
0000C5r 2  29               .byte $29               ; C5 0)
0000C6r 2  28               .byte $28               ; C6 9(
0000C7r 2  00               .byte $00               ; C7
0000C8r 2  00               .byte $00               ; C8
0000C9r 2  3E               .byte $3E               ; C9 .>
0000CAr 2  3F               .byte $3F               ; CA /?
0000CBr 2  4C               .byte $4C               ; CB lL
0000CCr 2  3A               .byte $3A               ; CC ;:
0000CDr 2  50               .byte $50               ; CD pP
0000CEr 2  5F               .byte $5F               ; CE -_
0000CFr 2  00               .byte $00               ; CF
0000D0r 2  00               .byte $00               ; D0
0000D1r 2  00               .byte $00               ; D1
0000D2r 2  22               .byte $22               ; D2 '"
0000D3r 2  00               .byte $00               ; D3
0000D4r 2  7B               .byte $7B               ; D4 [{
0000D5r 2  2B               .byte $2B               ; D5 =+
0000D6r 2  00               .byte $00               ; D6
0000D7r 2  00               .byte $00               ; D7
0000D8r 2  00               .byte $00               ; D8 caps
0000D9r 2  00               .byte $00               ; D9 r shift
0000DAr 2  0D               .byte $0D               ; DA <Enter>
0000DBr 2  7D               .byte $7D               ; DB ]}
0000DCr 2  00               .byte $00               ; DC
0000DDr 2  7C               .byte $7C               ; DD \|
0000DEr 2  00               .byte $00               ; DE
0000DFr 2  00               .byte $00               ; DF
0000E0r 2  00               .byte $00               ; E0
0000E1r 2  00               .byte $00               ; E1
0000E2r 2  00               .byte $00               ; E2
0000E3r 2  00               .byte $00               ; E3
0000E4r 2  00               .byte $00               ; E4
0000E5r 2  00               .byte $00               ; E5
0000E6r 2  08               .byte $08               ; E6 bkspace
0000E7r 2  00               .byte $00               ; E7
0000E8r 2  00               .byte $00               ; E8
0000E9r 2  91               .byte $91               ; E9 kp 1
0000EAr 2  2F               .byte $2f               ; EA kp / converted from E04A in code
0000EBr 2  94               .byte $94               ; EB kp 4
0000ECr 2  97               .byte $97               ; EC kp 7
0000EDr 2  00               .byte $00               ; ED
0000EEr 2  00               .byte $00               ; EE
0000EFr 2  00               .byte $00               ; EF
0000F0r 2  90               .byte $90               ; F0 kp 0
0000F1r 2  7F               .byte $7F               ; F1 kp .
0000F2r 2  92               .byte $92               ; F2 kp 2
0000F3r 2  95               .byte $95               ; F3 kp 5
0000F4r 2  96               .byte $96               ; F4 kp 6
0000F5r 2  98               .byte $98               ; F5 kp 8
0000F6r 2  1B               .byte $1B               ; F6 esc
0000F7r 2  00               .byte $00               ; F7 num lock
0000F8r 2  CB               .byte $CB               ; F8 F11
0000F9r 2  2B               .byte $2B               ; F9 kp +
0000FAr 2  93               .byte $93               ; FA kp 3
0000FBr 2  2D               .byte $2D               ; FB kp -
0000FCr 2  2A               .byte $2A               ; FC kp *
0000FDr 2  99               .byte $99               ; FD kp 9
0000FEr 2  CD               .byte $CD               ; FE scroll lock
0000FFr 2               
0000FFr 2               
0000FFr 2               
0000FFr 2               
0000FFr 1               
0000FFr 1               .import    copydata
0000FFr 1               
0000FFr 1               .segment "STARTUP"
000000r 1               
000000r 1               v_reset:
000000r 1  20 rr rr         JSR     copydata
000003r 1  4C rr rr         jmp kernel_init
000006r 1               
000006r 1               .segment "DATA"
000000r 1               
000000r 1               .include "drivers/acia.s"
000000r 2               acia_init:
000000r 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
000003r 2                                           ; set specific modes and functions
000003r 2  9C rr rr         stz has_acia
000006r 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000008r 2                   ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
000008r 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
00000Br 2  AD E2 FF         lda ACIA_CMD        ; load command register again
00000Er 2  C9 0B            cmp #$0B                ; if not the same
000010r 2  D0 11            bne acia_absent         ; then it means the ACIA is not connected
000012r 2  AD E1 FF         lda ACIA_STATUS         ; Read the ACAI status to
000015r 2  29 60            and #$60                ; check if present or absent
000017r 2  D0 0A            bne acia_absent
000019r 2  A9 01            lda #1
00001Br 2  8D rr rr         sta has_acia           ; remember that ACIA is here
00001Er 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000020r 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000020r 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
000023r 2               
000023r 2               acia_absent:
000023r 2  A0 14                ldy #20
000025r 2               aa_loop:
000025r 2  20 rr rr             jsr delay_short
000028r 2  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
00002Br 2  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
00002Er 2  88                   dey
00002Fr 2  D0 F4                bne aa_loop
000031r 2               aa_end:
000031r 2  60                   rts
000032r 2               
000032r 2               acia_out:
000032r 2  48               pha
000033r 2  5A               phy
000034r 2  8D E0 FF         sta ACIA_DATA
000037r 2  A0 40            ldy #$40            ;minimal delay is $02
000039r 2  20 rr rr         jsr delay_short
00003Cr 2  7A               ply
00003Dr 2  68               pla
00003Er 2  60               rts
00003Fr 2               
00003Fr 2               acia_getc:
00003Fr 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
000042r 2  29 08            and #$08                        ; Check if there is character in the receiver
000044r 2  F0 05            beq @no_char      ; Exit now if we don't get one.
000046r 2  AD E0 FF         lda ACIA_DATA
000049r 2  38               sec
00004Ar 2  60               rts
00004Br 2               @no_char:
00004Br 2  18               clc
00004Cr 2  60               rts
00004Dr 2               
00004Dr 2               acia_irq:
00004Dr 2  48               pha
00004Er 2  2C E1 FF         bit ACIA_STATUS
000051r 2  10 06            bpl @exit
000053r 2               @irq_receive:
000053r 2                   ; we now have the byte, we need to add it to the keyboard buffer
000053r 2  AD E0 FF         lda ACIA_DATA
000056r 2               
000056r 2  8D rr rr         sta KB_BUF
000059r 2                   ;sta ACIA1_DATA
000059r 2               
000059r 2               @exit:
000059r 2  68               pla
00005Ar 2  60               rts
00005Br 2               
00005Br 1               .include "drivers/timer.s"
00005Br 2               
00005Br 2               
00005Br 2               COUNTER = CLOCK_SPEED/400        ; n/s
00005Br 2               
00005Br 2               
00005Br 2               timer_init:
00005Br 2  AD 8E FF         lda IER
00005Er 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000060r 2  8D 8E FF         sta IER
000063r 2  A9 40            lda #$40        ; timer one free run mode
000065r 2  8D 8B FF         sta ACR
000068r 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
00006Ar 2  8D 84 FF         sta T1CL
00006Dr 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
00006Fr 2               
00006Fr 2  8D 85 FF         sta T1CH
000072r 2  A9 00            lda #0              ; reset time variable
000074r 2  85 rr            sta time
000076r 2  85 rr            sta time+1
000078r 2  85 rr            sta time+2
00007Ar 2  85 rr            sta time+3
00007Cr 2  58               cli
00007Dr 2  60               rts
00007Er 2               
00007Er 2               
00007Er 2               timer_irq:
00007Er 2  E6 rr            inc time
000080r 2  F0 01            beq @inc1
000082r 2               @exit1:
000082r 2                   ; this resets the PS/2 temp variables
000082r 2                   ;jsr reset_ps2
000082r 2  60               rts
000083r 2               @inc1:
000083r 2  E6 rr            inc time+1
000085r 2  F0 02            beq @inc2
000087r 2  80 F9            bra @exit1
000089r 2               @inc2:
000089r 2  E6 rr            inc time+2
00008Br 2  F0 02            beq @inc3
00008Dr 2  80 F3            bra @exit1
00008Fr 2               @inc3:
00008Fr 2  E6 rr            inc time+3
000091r 2  80 EF            bra @exit1
000093r 2  60               rts
000094r 2               
000094r 1               ; .include "drivers/ps2.s"
000094r 1               .include "drivers/delayroutines.s"
000094r 2               ; Copyright 2020 Jonathan Foucher
000094r 2               
000094r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000094r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000094r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000094r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000094r 2               ; is furnished to do so, subject to the following conditions:
000094r 2               
000094r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000094r 2               ; substantial portions of the Software.
000094r 2               
000094r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000094r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000094r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000094r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000094r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000094r 2               ; DEALINGS IN THE SOFTWARE.
000094r 2               
000094r 2               
000094r 2               ; this routine delays by 2304 * y + 23 cycles
000094r 2               delay:
000094r 2  DA             phx       ; 3 cycles
000095r 2  5A             phy       ; 3 cycles
000096r 2               two:
000096r 2  A2 FF          ldx #$ff  ; 2 cycles
000098r 2               one:
000098r 2  EA             nop       ; 2 cycles
000099r 2  EA             nop       ; 2 cycles
00009Ar 2  CA             dex       ; 2 cycles
00009Br 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
00009Dr 2  88             dey       ; 2 cycles
00009Er 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
0000A0r 2  7A             ply       ; 4 cycles
0000A1r 2  FA             plx       ; 4 cycles
0000A2r 2  60             rts       ; 6 cycles
0000A3r 2               
0000A3r 2               ; delay is in Y register
0000A3r 2               delay_long:
0000A3r 2  48             pha
0000A4r 2  5A             phy
0000A5r 2  DA             phx
0000A6r 2  98             tya
0000A7r 2  AA             tax
0000A8r 2               delay_long_loop:
0000A8r 2  A0 FF          ldy #$ff
0000AAr 2  20 rr rr       jsr delay
0000ADr 2  CA             dex
0000AEr 2  D0 F8          bne delay_long_loop
0000B0r 2  FA             plx
0000B1r 2  7A             ply
0000B2r 2  68             pla
0000B3r 2  60             rts
0000B4r 2               
0000B4r 2               delay_short:        ; delay Y * 19 cycles
0000B4r 2  5A             phy
0000B5r 2               delay_short_loop:
0000B5r 2  EA             nop               ; 2 cycles
0000B6r 2  EA             nop               ; 2 cycles
0000B7r 2  EA             nop               ; 2 cycles
0000B8r 2  EA             nop               ; 2 cycles
0000B9r 2  EA             nop               ; 2 cycles
0000BAr 2  EA             nop               ; 2 cycles
0000BBr 2  EA             nop               ; 2 cycles
0000BCr 2               
0000BCr 2               
0000BCr 2  88             dey               ; 2 cycles
0000BDr 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
0000BFr 2  7A             ply
0000C0r 2  60             rts
0000C1r 2               
0000C1r 1               ; .include "drivers/lcd.s"
0000C1r 1               .include "drivers/spi.s"
0000C1r 2               ; SPI defines
0000C1r 2               
0000C1r 2               SS = $07   ; Slave Select with lowest 3 bits
0000C1r 2               SCK = $08   ; Clock on bit 3
0000C1r 2               MISO = $10  ; MISO on bit 4
0000C1r 2               MOSI = $20  ; MOSI on bit 5
0000C1r 2               CONF = $40  ; CONF on bit 6
0000C1r 2               
0000C1r 2               spi_init:
0000C1r 2  AD 80 FF         lda PORTB               ; load current port B
0000C4r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
0000C6r 2  09 40            ora #CONF               ; set CONF high
0000C8r 2  8D 80 FF         sta PORTB               ; save to PORTB
0000CBr 2  AD 82 FF         lda DDRB                ; get current direction register
0000CEr 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
0000D0r 2  29 EF            and #($FF^MISO)                 ; set MISO as input
0000D2r 2  8D 82 FF         sta DDRB
0000D5r 2  A9 FF            lda #$FF
0000D7r 2  8D 83 FF         sta DDRA
0000DAr 2  8D 81 FF         sta PORTA
0000DDr 2               
0000DDr 2  60               rts
0000DEr 2               
0000DEr 2               spi_select:
0000DEr 2                   ; selected slave in A
0000DEr 2  29 07            and #SS                 ; mask slave select bits
0000E0r 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
0000E3r 2  8D 81 FF         sta PORTA
0000E6r 2  8D rr rr         sta spi_slave
0000E9r 2  5A               phy
0000EAr 2  A0 01            ldy #$1
0000ECr 2  20 rr rr         jsr delay_short         ; slight delay
0000EFr 2  09 40            ora #CONF               ; set CONF high to latch address
0000F1r 2  8D 80 FF         sta PORTB               ; save to PORTB
0000F4r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
0000F5r 2  60               rts
0000F6r 2               
0000F6r 2               spi_clk_toggle:
0000F6r 2  60               rts
0000F7r 2               
0000F7r 2               spi_transceive:
0000F7r 2                   ; send data in A, received data will be in A
0000F7r 2  5A               phy
0000F8r 2                   ; save data in RAM
0000F8r 2  8D rr rr         sta spi_tmp
0000FBr 2                   ; reset X
0000FBr 2  DA               phx
0000FCr 2  A2 08            ldx #8
0000FEr 2                   ; reset result
0000FEr 2  9C rr rr         stz spi_tmp2
000101r 2               spi_send_loop:
000101r 2  0E rr rr         asl spi_tmp
000104r 2  90 08            bcc bit_unset
000106r 2               bit_set:
000106r 2  AD 80 FF         lda PORTB
000109r 2  09 60            ora #(MOSI | CONF)
00010Br 2  4C rr rr         jmp clock_on
00010Er 2               bit_unset:
00010Er 2  AD 80 FF         lda PORTB
000111r 2  29 DF            and #(($FF^MOSI) | CONF)
000113r 2               clock_on:
000113r 2                   ; set data bit
000113r 2  0D rr rr         ora spi_slave
000116r 2  8D 80 FF         sta PORTB
000119r 2               
000119r 2                   ; set clock on
000119r 2  09 48            ora #(SCK | CONF)
00011Br 2  0D rr rr         ora spi_slave
00011Er 2  8D 80 FF         sta PORTB
000121r 2               
000121r 2                   ; read bit from slave, maybe add slight delay here ?
000121r 2  AD 80 FF         lda PORTB
000124r 2  29 10            and #MISO           ; mask miso bit
000126r 2  D0 07            bne spi_bit_set      ; bit is set
000128r 2                   ; bit is unset
000128r 2  18               clc
000129r 2  2E rr rr         rol spi_tmp2
00012Cr 2  4C rr rr         jmp clock_off
00012Fr 2               
00012Fr 2               spi_bit_set:
00012Fr 2  38               sec
000130r 2  2E rr rr         rol spi_tmp2
000133r 2               
000133r 2               
000133r 2               clock_off:
000133r 2  AD 80 FF         lda PORTB
000136r 2  29 F7            and #(($FF^SCK) | CONF)
000138r 2  0D rr rr         ora spi_slave
00013Br 2  8D 80 FF         sta PORTB
00013Er 2               end_loop:
00013Er 2  CA               dex
00013Fr 2  D0 C0            bne spi_send_loop
000141r 2                   ; set data low
000141r 2  A0 01            ldy #$1
000143r 2  20 rr rr         jsr delay_short
000146r 2  AD 80 FF         lda PORTB
000149r 2  0D rr rr         ora spi_slave
00014Cr 2  29 DF            and #(($FF^MOSI) | CONF)
00014Er 2  8D 80 FF         sta PORTB
000151r 2  FA               plx
000152r 2  7A               ply
000153r 2  AD rr rr         lda spi_tmp2
000156r 2  60               rts
000157r 2               
000157r 1               .include "drivers/sd.s"
000157r 2               ; SD card driver
000157r 2               
000157r 2               ; SD card initialization routine
000157r 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
000157r 2               
000157r 2               sd_init:                    ; slave address in A
000157r 2  8D rr rr         sta SD_SLAVE             ; save slave address for later use
00015Ar 2  DA               phx
00015Br 2  20 rr rr         jsr spi_init                ; init SPI system
00015Er 2  A9 00            lda #0
000160r 2  20 rr rr         jsr spi_select          ; DEselect slave
000163r 2  8D rr rr         sta SD_ARG
000166r 2  8D rr rr         sta SD_ARG+1            ; clear command argument
000169r 2  8D rr rr         sta SD_ARG+2
00016Cr 2  8D rr rr         sta SD_ARG+3
00016Fr 2  A9 95            lda #$95
000171r 2  8D rr rr         sta SD_CRC              ; set CRC for CMD0
000174r 2                   ; clear SD buffer
000174r 2  A2 FF            ldx #$FF
000176r 2               clear_sd_buf_loop1:
000176r 2  9E rr rr         stz SD_BUF, X
000179r 2  CA               dex
00017Ar 2  D0 FA            bne clear_sd_buf_loop1
00017Cr 2               
00017Cr 2  CA               dex
00017Dr 2               clear_sd_buf_loop2:
00017Dr 2  9E rr rr         stz SD_BUF+256, x
000180r 2  CA               dex
000181r 2  D0 FA            bne clear_sd_buf_loop2
000183r 2               
000183r 2                   ; send 10 bytes of $FF With SD card deselected
000183r 2               
000183r 2  A2 0A            ldx #10
000185r 2               init_loop:
000185r 2  A9 FF            lda #$FF
000187r 2  20 rr rr         jsr spi_transceive
00018Ar 2  CA               dex
00018Br 2  D0 F8            bne init_loop
00018Dr 2               
00018Dr 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
000190r 2  C9 01            cmp #$01                ; Check for idle state
000192r 2  D0 55            bne sd_error
000194r 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
000197r 2  C9 01            cmp #$01                ; Check for idle state
000199r 2  D0 4E            bne sd_error
00019Br 2                   ; TODO check if long response is $01AA
00019Br 2               
00019Br 2                   ; wait for card to be initialized
00019Br 2  A2 FF            ldx #$ff    ; Max times to loop
00019Dr 2  9C rr rr         stz SD_ARG
0001A0r 2  9C rr rr         stz SD_ARG+1
0001A3r 2  9C rr rr         stz SD_ARG+2
0001A6r 2  9C rr rr         stz SD_ARG+3
0001A9r 2               sd_init_loop2:
0001A9r 2  CA               dex
0001AAr 2  F0 3D            beq sd_error
0001ACr 2  9C rr rr         stz SD_ARG+3
0001AFr 2  A9 37            lda #55
0001B1r 2  20 rr rr         jsr sd_command
0001B4r 2  A9 40            lda #$40
0001B6r 2  8D rr rr         sta SD_ARG+3
0001B9r 2  A9 29            lda #41
0001BBr 2  20 rr rr         jsr sd_command
0001BEr 2               
0001BEr 2  D0 E9            bne sd_init_loop2
0001C0r 2               
0001C0r 2  A9 3A            lda #58
0001C2r 2  20 rr rr         jsr sd_command
0001C5r 2  AD rr rr         lda SD_BUF
0001C8r 2  29 40            and #$40
0001CAr 2  F0 07            beq force_block_size    ; CCS bit is unset, force block addressing
0001CCr 2               sd_init_exit_success:
0001CCr 2  FA               plx
0001CDr 2  9C rr rr         stz SD_CRC              ; reset CRC to zero
0001D0r 2  A9 00            lda #0
0001D2r 2               
0001D2r 2  60               rts
0001D3r 2               
0001D3r 2               force_block_size:
0001D3r 2  9C rr rr         stz SD_ARG
0001D6r 2  9C rr rr         stz SD_ARG+1
0001D9r 2  A9 02            lda #$2
0001DBr 2  8D rr rr         sta SD_ARG+2
0001DEr 2  9C rr rr         stz SD_ARG+3    ; set block size to $200 (512 bytes)
0001E1r 2  A9 10            lda #$10
0001E3r 2  20 rr rr         jsr sd_command
0001E6r 2  4C rr rr         jmp sd_init_exit_success
0001E9r 2               
0001E9r 2               sd_error:
0001E9r 2  FA               plx
0001EAr 2  A9 01            lda #1
0001ECr 2  60               rts
0001EDr 2               
0001EDr 2               sd_command:         ; command index is in A
0001EDr 2  29 3F            and #$3F        ; only keep low 6 bits
0001EFr 2  8D rr rr         sta SD_TMP
0001F2r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
0001F4r 2               
0001F4r 2                   ; Select chip
0001F4r 2  20 rr rr         jsr sd_command_start
0001F7r 2               
0001F7r 2  20 rr rr         jsr spi_transceive  ; send command index
0001FAr 2                   ; command argument is in SD_ARG
0001FAr 2                   ; SPI is big endian, so reverse argument order
0001FAr 2  AD rr rr         lda SD_ARG + 3
0001FDr 2  20 rr rr         jsr spi_transceive
000200r 2  AD rr rr         lda SD_ARG+2
000203r 2  20 rr rr         jsr spi_transceive
000206r 2  AD rr rr         lda SD_ARG+1
000209r 2  20 rr rr         jsr spi_transceive
00020Cr 2  AD rr rr         lda SD_ARG
00020Fr 2  20 rr rr         jsr spi_transceive
000212r 2  AD rr rr         lda SD_CRC          ; send hardcoded CRC if available
000215r 2  20 rr rr         jsr spi_transceive
000218r 2               
000218r 2                   ; wait for a zero to be received in the top bit of the response
000218r 2               sd_response_wait_loop:
000218r 2  A9 FF            lda #$FF
00021Ar 2  20 rr rr         jsr spi_transceive
00021Dr 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
00021Fr 2               
00021Fr 2  48               pha
000220r 2               
000220r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
000220r 2               
000220r 2                   ; get 32 bits of response for CMD 8 and CMD 58
000220r 2  AD rr rr         lda SD_TMP
000223r 2  C9 08            cmp #8
000225r 2  F0 0D            beq long_response
000227r 2  C9 3A            cmp #58
000229r 2  F0 09            beq long_response
00022Br 2  C9 11            cmp #$11
00022Dr 2  F0 03            beq sd_command_exit_no_end
00022Fr 2               
00022Fr 2               sd_command_exit:
00022Fr 2  20 rr rr         jsr sd_command_end
000232r 2               sd_command_exit_no_end:
000232r 2  68               pla
000233r 2                   ; return the response
000233r 2  60               rts
000234r 2               
000234r 2               long_response:
000234r 2  A9 FF            lda #$FF
000236r 2  20 rr rr         jsr spi_transceive
000239r 2  8D rr rr         sta SD_BUF
00023Cr 2  A9 FF            lda #$FF
00023Er 2  20 rr rr         jsr spi_transceive
000241r 2  8D rr rr         sta SD_BUF+1
000244r 2  A9 FF            lda #$FF
000246r 2  20 rr rr         jsr spi_transceive
000249r 2  8D rr rr         sta SD_BUF+2
00024Cr 2  A9 FF            lda #$FF
00024Er 2  20 rr rr         jsr spi_transceive
000251r 2  8D rr rr         sta SD_BUF+3
000254r 2  4C rr rr         jmp sd_command_exit
000257r 2               
000257r 2               ; send SD card CMD0
000257r 2               sd_cmd_0:
000257r 2  A9 95            lda #$95
000259r 2  8D rr rr         sta SD_CRC
00025Cr 2  9C rr rr         stz SD_ARG
00025Fr 2  9C rr rr         stz SD_ARG+1
000262r 2  9C rr rr         stz SD_ARG+2
000265r 2  9C rr rr         stz SD_ARG+3
000268r 2  A9 00            lda #0
00026Ar 2  20 rr rr         jsr sd_command
00026Dr 2  60               rts
00026Er 2               
00026Er 2               ; send SD card CMD8
00026Er 2               sd_cmd_8:
00026Er 2  A9 87            lda #$87
000270r 2  8D rr rr         sta SD_CRC
000273r 2                   ; store in little endian
000273r 2                   ; will be converted to big endian when sending command
000273r 2  9C rr rr         stz SD_ARG+3
000276r 2  9C rr rr         stz SD_ARG+2
000279r 2  A9 01            lda #1
00027Br 2  8D rr rr         sta SD_ARG+1
00027Er 2  A9 AA            lda #$AA
000280r 2  8D rr rr         sta SD_ARG
000283r 2  A9 48            lda #$48
000285r 2  20 rr rr         jsr sd_command
000288r 2               
000288r 2  60               rts
000289r 2               
000289r 2               sd_command_start:
000289r 2  48               pha                         ; Save A
00028Ar 2  AD rr rr         lda SD_SLAVE
00028Dr 2  20 rr rr         jsr spi_select
000290r 2  68               pla                         ; Restore A
000291r 2  60               rts
000292r 2               
000292r 2               sd_command_end:
000292r 2  48               pha
000293r 2  A9 00            lda #0
000295r 2  20 rr rr         jsr spi_select
000298r 2  A9 FF            lda #$FF
00029Ar 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
00029Dr 2  68               pla
00029Er 2  60               rts
00029Fr 2               
00029Fr 2               
00029Fr 2               sd_readsector:
00029Fr 2                   ; Read a sector from the SD card.  A sector is 512 bytes.
00029Fr 2                   ;
00029Fr 2                   ; Parameters:
00029Fr 2                   ;    sd_sector   32-bit sector number
00029Fr 2                   ;    sd_buffer_address     address of buffer to receive data
00029Fr 2  DA               phx
0002A0r 2  20 rr rr         jsr sd_command_start
0002A3r 2                   ; Command 17, arg is sector number, crc not checked
0002A3r 2  A9 11            lda #$11                    ; CMD17 - READ_SINGLE_BLOCK
0002A5r 2  20 rr rr         jsr sd_command
0002A8r 2               
0002A8r 2  C9 00            cmp #0              ; Check if command accepted by card
0002AAr 2  D0 29            bne @fail
0002ACr 2  A2 FF            ldx #$FF
0002AEr 2               @feloop:
0002AEr 2  CA               dex
0002AFr 2  F0 24            beq @fail           ; the card took too long to get ready
0002B1r 2  A9 FF            lda #$FF
0002B3r 2  20 rr rr         jsr spi_transceive
0002B6r 2  C9 FE            cmp #$FE            ; are we about to receive data ?
0002B8r 2  D0 F4            bne @feloop
0002BAr 2               
0002BAr 2                   ; Read page by page
0002BAr 2  20 rr rr         jsr readpage
0002BDr 2  E6 rr            inc sd_buffer_address+1
0002BFr 2  20 rr rr         jsr readpage
0002C2r 2  C6 rr            dec sd_buffer_address+1
0002C4r 2               
0002C4r 2  A9 FF            lda #$FF
0002C6r 2  20 rr rr         jsr spi_transceive      ; read and discard CRC
0002C9r 2  A9 FF            lda #$FF
0002CBr 2  20 rr rr         jsr spi_transceive
0002CEr 2  20 rr rr         jsr sd_command_end
0002D1r 2  FA               plx
0002D2r 2  A9 00            lda #0
0002D4r 2  60               rts
0002D5r 2               
0002D5r 2               @fail:
0002D5r 2                   ; return 1 means fail
0002D5r 2  20 rr rr         jsr sd_command_end
0002D8r 2  FA               plx
0002D9r 2  A9 01            lda #1
0002DBr 2  60               rts
0002DCr 2               
0002DCr 2               readpage:
0002DCr 2                   ; Read 256 bytes to the address at zp_sd_address
0002DCr 2  5A               phy
0002DDr 2  A0 00            ldy #0
0002DFr 2               @readloop:
0002DFr 2  A9 FF            lda #$FF
0002E1r 2  20 rr rr         jsr spi_transceive
0002E4r 2  91 rr            sta (sd_buffer_address),y
0002E6r 2  C8               iny
0002E7r 2  D0 F6            bne @readloop
0002E9r 2  7A               ply
0002EAr 2  60               rts
0002EBr 2               
0002EBr 2               sd_init_success_message:
0002EBr 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
0002EFr 2  69 6E 69 74  
0002F3r 2  20 4F 4B 0D  
0002F8r 2               
0002F8r 2               sd_init_error_message:
0002F8r 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
0002FCr 2  69 6E 69 74  
000300r 2  20 46 41 49  
000308r 2               
000308r 2               sd_read_error_message:
000308r 2  0D 53 44 20      .byte $0D,"SD read FAIL", $0D, 7, 0
00030Cr 2  72 65 61 64  
000310r 2  20 46 41 49  
000318r 2               
000318r 1               ; .include "drivers/vga.s"
000318r 1               .include "drivers/fat32.s"
000318r 2               
000318r 2               ; PARTITION TYPE
000318r 2               ; 00h 	Unknown or Nothing
000318r 2               ; 01h 	12-bit FAT
000318r 2               ; 04h 	16-bit FAT (Partition Smallerthan 32MB)
000318r 2               ; 05h 	Extended MS-DOS Partition
000318r 2               ; 06h 	16-bit FAT (Partition Largerthan 32MB)
000318r 2               ; 0Bh 	32-bit FAT (Partition Up to2048GB)
000318r 2               ; 0Ch 	Same as 0BH, but uses LBA1 13h Extensions
000318r 2               ; 0Eh 	Same as 06H, but uses LBA1 13h Extensions
000318r 2               ; 0Fh 	Same as 05H, but uses LBA1 13h Extensions
000318r 2               FSTYPE_FAT32 = $0B
000318r 2               FSTYPE_FAT32_1 = $0C
000318r 2               fat32_readbuffer = SD_BUF
000318r 2               
000318r 2               fat32_fatstart          = FAT_VARS + $00  ; 4 bytes
000318r 2               fat32_datastart         = FAT_VARS + $04  ; 4 bytes
000318r 2               fat32_rootcluster       = FAT_VARS + $08  ; 4 bytes
000318r 2               fat32_sectorspercluster = FAT_VARS + $0c  ; 1 byte
000318r 2               fat32_pendingsectors    = FAT_VARS + $0d  ; 1 byte
000318r 2               fat32_address           = FAT_VARS + $0e  ; 2 bytes
000318r 2               fat32_nextcluster       = FAT_VARS + $10  ; 4 bytes
000318r 2               fat32_bytesremaining    = line; FAT_VARS + $14  ; 4 bytes
000318r 2               
000318r 2               
000318r 2               
000318r 2               fat32_init:
000318r 2                   ; Initialize the module - read the MBR etc, find the partition,
000318r 2                   ; and set up the variables ready for navigating the filesystem
000318r 2               
000318r 2                   ; Read the MBR and extract pertinent information
000318r 2  DA               phx
000319r 2               
000319r 2                   ; Sector 0
000319r 2  A9 00            lda #0
00031Br 2  8D rr rr         sta SD_ARG
00031Er 2  8D rr rr         sta SD_ARG+1
000321r 2  8D rr rr         sta SD_ARG+2
000324r 2  8D rr rr         sta SD_ARG+3
000327r 2               
000327r 2                   ; Target buffer
000327r 2  A9 rr            lda #<fat32_readbuffer
000329r 2  85 rr            sta sd_buffer_address
00032Br 2  A9 rr            lda #>fat32_readbuffer
00032Dr 2  85 rr            sta sd_buffer_address+1
00032Fr 2               
00032Fr 2                   ; Do the read
00032Fr 2  20 rr rr         jsr sd_readsector
000332r 2               
000332r 2                   ; Check some things
000332r 2  AD rr rr         lda fat32_readbuffer+510 ; Boot sector signature 55
000335r 2  C9 55            cmp #$55
000337r 2  D0 3B            bne @fail
000339r 2  AD rr rr         lda fat32_readbuffer+511 ; Boot sector signature aa
00033Cr 2  C9 AA            cmp #$aa
00033Er 2  D0 34            bne @fail
000340r 2               
000340r 2                   ; Find a FAT32 partition
000340r 2  A2 00            ldx #0
000342r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000345r 2  C9 0B            cmp #FSTYPE_FAT32
000347r 2  F0 2E            beq @foundpart
000349r 2  C9 0C            cmp #FSTYPE_FAT32_1
00034Br 2  F0 2A            beq @foundpart
00034Dr 2  A2 10            ldx #$10
00034Fr 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000352r 2  C9 0B            cmp #FSTYPE_FAT32
000354r 2  F0 21            beq @foundpart
000356r 2  C9 0C            cmp #FSTYPE_FAT32_1
000358r 2  F0 1D            beq @foundpart
00035Ar 2               
00035Ar 2  A2 20            ldx #$20
00035Cr 2  BD rr rr         lda fat32_readbuffer+$1C2, x
00035Fr 2  C9 0B            cmp #FSTYPE_FAT32
000361r 2  F0 14            beq @foundpart
000363r 2  C9 0C            cmp #FSTYPE_FAT32_1
000365r 2  F0 10            beq @foundpart
000367r 2               
000367r 2  A2 30            ldx #$30
000369r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
00036Cr 2  C9 0B            cmp #FSTYPE_FAT32
00036Er 2  F0 07            beq @foundpart
000370r 2  C9 0C            cmp #FSTYPE_FAT32_1
000372r 2  F0 03            beq @foundpart
000374r 2               
000374r 2               
000374r 2               @fail:
000374r 2  4C rr rr         jmp @error
000377r 2               
000377r 2               @foundpart:
000377r 2                   ; Read the FAT32 LBA BEGIN
000377r 2               
000377r 2  BD rr rr         lda fat32_readbuffer + $1C6,x
00037Ar 2  8D rr rr         sta SD_ARG
00037Dr 2  BD rr rr         lda fat32_readbuffer+$1C7,x
000380r 2  8D rr rr         sta SD_ARG+1
000383r 2  BD rr rr         lda fat32_readbuffer+$1C8,x
000386r 2  8D rr rr         sta SD_ARG+2
000389r 2  BD rr rr         lda fat32_readbuffer+$1C9,x
00038Cr 2  8D rr rr         sta SD_ARG+3
00038Fr 2               
00038Fr 2  20 rr rr         jsr sd_readsector   ; read FAT32 Volume ID block
000392r 2  C9 01            cmp #1              ; readsector returns 1 on failure
000394r 2  F0 DE            beq @fail
000396r 2               
000396r 2                   ; Check some things
000396r 2  AD rr rr         lda fat32_readbuffer+510 ; FAT32 Volume ID sector signature 55
000399r 2  C9 55            cmp #$55
00039Br 2  D0 D7            bne @fail
00039Dr 2  AD rr rr         lda fat32_readbuffer+511 ; FAT32 Volume ID sector signature aa
0003A0r 2  C9 AA            cmp #$aa
0003A2r 2  D0 D0            bne @fail
0003A4r 2               
0003A4r 2  AD rr rr         lda fat32_readbuffer+$11 ; RootEntCnt should be 0 for FAT32
0003A7r 2  0D rr rr         ora fat32_readbuffer+$12
0003AAr 2  D0 C8            bne @fail
0003ACr 2               
0003ACr 2  AD rr rr         lda fat32_readbuffer+$13 ; TotSec16 should be 0 for FAT32
0003AFr 2  0D rr rr         ora fat32_readbuffer+$14
0003B2r 2  D0 C0            bne @fail
0003B4r 2               
0003B4r 2                   ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
0003B4r 2  AD rr rr         lda fat32_readbuffer+$0B ; low byte should be zero
0003B7r 2  D0 BB            bne @fail
0003B9r 2  AD rr rr         lda fat32_readbuffer+$0C ; high byte is 2 (512), 4, 8, or 16
0003BCr 2  C9 02            cmp #2
0003BEr 2  D0 B4            bne @fail
0003C0r 2               
0003C0r 2                   ; Calculate the starting sector of the FAT
0003C0r 2  18               clc
0003C1r 2  AD rr rr         lda SD_ARG
0003C4r 2  6D rr rr         adc fat32_readbuffer+$0E    ; reserved sectors lo
0003C7r 2  8D rr rr         sta fat32_fatstart
0003CAr 2  8D rr rr         sta fat32_datastart
0003CDr 2  AD rr rr         lda SD_ARG+1
0003D0r 2  6D rr rr         adc fat32_readbuffer+$0F    ; reserved sectors hi
0003D3r 2  8D rr rr         sta fat32_fatstart+1
0003D6r 2  8D rr rr         sta fat32_datastart+1
0003D9r 2  AD rr rr         lda SD_ARG+2
0003DCr 2  69 00            adc #0
0003DEr 2  8D rr rr         sta fat32_fatstart+2
0003E1r 2  8D rr rr         sta fat32_datastart+2
0003E4r 2  AD rr rr         lda SD_ARG+3
0003E7r 2  69 00            adc #0
0003E9r 2  8D rr rr         sta fat32_fatstart+3
0003ECr 2  8D rr rr         sta fat32_datastart+3
0003EFr 2               
0003EFr 2                   ; Calculate the starting sector of the data area
0003EFr 2  AE rr rr         ldx fat32_readbuffer+16   ; number of FATs
0003F2r 2               @skipfatsloop:
0003F2r 2  18               clc
0003F3r 2  AD rr rr         lda fat32_datastart
0003F6r 2  6D rr rr         adc fat32_readbuffer+36 ; fatsize 0
0003F9r 2  8D rr rr         sta fat32_datastart
0003FCr 2  AD rr rr         lda fat32_datastart+1
0003FFr 2  6D rr rr         adc fat32_readbuffer+37 ; fatsize 1
000402r 2  8D rr rr         sta fat32_datastart+1
000405r 2  AD rr rr         lda fat32_datastart+2
000408r 2  6D rr rr         adc fat32_readbuffer+38 ; fatsize 2
00040Br 2  8D rr rr         sta fat32_datastart+2
00040Er 2  AD rr rr         lda fat32_datastart+3
000411r 2  6D rr rr         adc fat32_readbuffer+39 ; fatsize 3
000414r 2  8D rr rr         sta fat32_datastart+3
000417r 2  CA               dex
000418r 2  D0 D8            bne @skipfatsloop
00041Ar 2               
00041Ar 2                   ; Sectors-per-cluster is a power of two from 1 to 128
00041Ar 2  AD rr rr         lda fat32_readbuffer+13
00041Dr 2  8D rr rr         sta fat32_sectorspercluster
000420r 2               
000420r 2                   ; Remember the root cluster
000420r 2  AD rr rr         lda fat32_readbuffer+44
000423r 2  8D rr rr         sta fat32_rootcluster
000426r 2  AD rr rr         lda fat32_readbuffer+45
000429r 2  8D rr rr         sta fat32_rootcluster+1
00042Cr 2  AD rr rr         lda fat32_readbuffer+46
00042Fr 2  8D rr rr         sta fat32_rootcluster+2
000432r 2  AD rr rr         lda fat32_readbuffer+47
000435r 2  8D rr rr         sta fat32_rootcluster+3
000438r 2               
000438r 2  FA               plx
000439r 2  A9 00            lda #0
00043Br 2  60               rts
00043Cr 2               
00043Cr 2               @error:
00043Cr 2  FA               plx
00043Dr 2  A9 01            lda #1
00043Fr 2  60               rts
000440r 2               
000440r 2               
000440r 2               fat32_seekcluster:
000440r 2  5A               phy
000441r 2                   ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
000441r 2               
000441r 2                   ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
000441r 2  AD rr rr         lda fat32_nextcluster
000444r 2  0A               asl
000445r 2  AD rr rr         lda fat32_nextcluster+1
000448r 2  2A               rol
000449r 2  8D rr rr         sta SD_ARG
00044Cr 2  AD rr rr         lda fat32_nextcluster+2
00044Fr 2  2A               rol
000450r 2  8D rr rr         sta SD_ARG+1
000453r 2  AD rr rr         lda fat32_nextcluster+3
000456r 2  2A               rol
000457r 2  8D rr rr         sta SD_ARG+2
00045Ar 2                   ; note: cluster numbers never have the top bit set, so no carry can occur
00045Ar 2                   ; Add FAT starting sector
00045Ar 2  AD rr rr         lda SD_ARG
00045Dr 2  6D rr rr         adc fat32_fatstart
000460r 2  8D rr rr         sta SD_ARG
000463r 2  AD rr rr         lda SD_ARG+1
000466r 2  6D rr rr         adc fat32_fatstart+1
000469r 2  8D rr rr         sta SD_ARG+1
00046Cr 2  AD rr rr         lda SD_ARG+2
00046Fr 2  6D rr rr         adc fat32_fatstart+2
000472r 2  8D rr rr         sta SD_ARG+2
000475r 2  A9 00            lda #0
000477r 2  6D rr rr         adc fat32_fatstart+3
00047Ar 2  8D rr rr         sta SD_ARG+3
00047Dr 2                   ; Target buffer
00047Dr 2  A9 rr            lda #<fat32_readbuffer
00047Fr 2  85 rr            sta sd_buffer_address
000481r 2  A9 rr            lda #>fat32_readbuffer
000483r 2  85 rr            sta sd_buffer_address+1
000485r 2                   ; Read the sector from the FAT
000485r 2  20 rr rr         jsr sd_readsector
000488r 2               
000488r 2                   ; Before using this FAT data, set currentsector ready to read the cluster itself
000488r 2                   ; We need to multiply the cluster number minus two by the number of sectors per
000488r 2                   ; cluster, then add the data region start sector
000488r 2               
000488r 2                   ; Subtract two from cluster number
000488r 2  38               sec
000489r 2  AD rr rr         lda fat32_nextcluster
00048Cr 2  E9 02            sbc #2
00048Er 2  8D rr rr         sta SD_ARG
000491r 2  AD rr rr         lda fat32_nextcluster+1
000494r 2  E9 00            sbc #0
000496r 2  8D rr rr         sta SD_ARG+1
000499r 2  AD rr rr         lda fat32_nextcluster+2
00049Cr 2  E9 00            sbc #0
00049Er 2  8D rr rr         sta SD_ARG+2
0004A1r 2  AD rr rr         lda fat32_nextcluster+3
0004A4r 2  E9 00            sbc #0
0004A6r 2  8D rr rr         sta SD_ARG+3
0004A9r 2               
0004A9r 2                   ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
0004A9r 2  AD rr rr         lda fat32_sectorspercluster
0004ACr 2               @spcshiftloop:
0004ACr 2  4A               lsr
0004ADr 2  B0 0F            bcs @spcshiftloopdone
0004AFr 2  0E rr rr         asl SD_ARG
0004B2r 2  2E rr rr         rol SD_ARG+1
0004B5r 2  2E rr rr         rol SD_ARG+2
0004B8r 2  2E rr rr         rol SD_ARG+3
0004BBr 2  4C rr rr         jmp @spcshiftloop
0004BEr 2               @spcshiftloopdone:
0004BEr 2               
0004BEr 2                   ; Add the data region start sector
0004BEr 2  18               clc
0004BFr 2  AD rr rr         lda SD_ARG
0004C2r 2  6D rr rr         adc fat32_datastart
0004C5r 2  8D rr rr         sta SD_ARG
0004C8r 2  AD rr rr         lda SD_ARG+1
0004CBr 2  6D rr rr         adc fat32_datastart+1
0004CEr 2  8D rr rr         sta SD_ARG+1
0004D1r 2  AD rr rr         lda SD_ARG+2
0004D4r 2  6D rr rr         adc fat32_datastart+2
0004D7r 2  8D rr rr         sta SD_ARG+2
0004DAr 2  AD rr rr         lda SD_ARG+3
0004DDr 2  6D rr rr         adc fat32_datastart+3
0004E0r 2  8D rr rr         sta SD_ARG+3
0004E3r 2               
0004E3r 2                   ; That's now ready for later code to read this sector in - tell it how many consecutive
0004E3r 2                   ; sectors it can now read
0004E3r 2  AD rr rr         lda fat32_sectorspercluster
0004E6r 2  8D rr rr         sta fat32_pendingsectors
0004E9r 2               
0004E9r 2                   ; Now go back to looking up the next cluster in the chain
0004E9r 2                   ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
0004E9r 2               
0004E9r 2                   ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
0004E9r 2  AD rr rr         lda fat32_nextcluster
0004ECr 2  29 7F            and #$7f
0004EEr 2  0A               asl
0004EFr 2  0A               asl
0004F0r 2  A8               tay ; Y = low byte of offset
0004F1r 2                   ; Add the potentially carried bit to the high byte of the address
0004F1r 2  A5 rr            lda sd_buffer_address+1
0004F3r 2  69 00            adc #0
0004F5r 2  85 rr            sta sd_buffer_address+1
0004F7r 2               
0004F7r 2                   ; Copy out the next cluster in the chain for later use
0004F7r 2  B1 rr            lda (sd_buffer_address),y
0004F9r 2  8D rr rr         sta fat32_nextcluster
0004FCr 2  C8               iny
0004FDr 2  B1 rr            lda (sd_buffer_address),y
0004FFr 2  8D rr rr         sta fat32_nextcluster+1
000502r 2  C8               iny
000503r 2  B1 rr            lda (sd_buffer_address),y
000505r 2  8D rr rr         sta fat32_nextcluster+2
000508r 2  C8               iny
000509r 2  B1 rr            lda (sd_buffer_address),y
00050Br 2  29 0F            and #$0f
00050Dr 2  8D rr rr         sta fat32_nextcluster+3
000510r 2               
000510r 2                   ; See if it's the end of the chain
000510r 2  09 F0            ora #$f0
000512r 2  2D rr rr         and fat32_nextcluster+2
000515r 2  2D rr rr         and fat32_nextcluster+1
000518r 2  C9 FF            cmp #$ff
00051Ar 2  D0 0A            bne @notendofchain
00051Cr 2  AD rr rr         lda fat32_nextcluster
00051Fr 2  C9 F8            cmp #$f8
000521r 2  90 03            bcc @notendofchain
000523r 2               
000523r 2                   ; It's the end of the chain, set the top bits so that we can tell this later on
000523r 2  8D rr rr         sta fat32_nextcluster+3
000526r 2               @notendofchain:
000526r 2  7A               ply
000527r 2  60               rts
000528r 2               
000528r 2               
000528r 2               fat32_readnextsector:
000528r 2                   ; Reads the next sector from a cluster chain into the buffer at fat32_address.
000528r 2                   ;
000528r 2                   ; Advances the current sector ready for the next read and looks up the next cluster
000528r 2                   ; in the chain when necessary.
000528r 2                   ;
000528r 2                   ; On return, carry is clear if data was read, or set if the cluster chain has ended.
000528r 2               
000528r 2                   ; Maybe there are pending sectors in the current cluster
000528r 2  AD rr rr         lda fat32_pendingsectors
00052Br 2  D0 08            bne @readsector
00052Dr 2               
00052Dr 2                   ; No pending sectors, check for end of cluster chain
00052Dr 2  AD rr rr         lda fat32_nextcluster+3
000530r 2  30 27            bmi @endofchain
000532r 2               
000532r 2                   ; Prepare to read the next cluster
000532r 2  20 rr rr         jsr fat32_seekcluster
000535r 2               
000535r 2               @readsector:
000535r 2  CE rr rr         dec fat32_pendingsectors
000538r 2               
000538r 2                   ; Set up target address
000538r 2  AD rr rr         lda fat32_address
00053Br 2  85 rr            sta sd_buffer_address
00053Dr 2  AD rr rr         lda fat32_address+1
000540r 2  85 rr            sta sd_buffer_address+1
000542r 2               
000542r 2                   ; Read the sector
000542r 2  20 rr rr         jsr sd_readsector
000545r 2               
000545r 2                   ; Advance to next sector
000545r 2  EE rr rr         inc SD_ARG
000548r 2  D0 0D            bne @sectorincrementdone
00054Ar 2  EE rr rr         inc SD_ARG+1
00054Dr 2  D0 08            bne @sectorincrementdone
00054Fr 2  EE rr rr         inc SD_ARG+2
000552r 2  D0 03            bne @sectorincrementdone
000554r 2  EE rr rr         inc SD_ARG+3
000557r 2               @sectorincrementdone:
000557r 2               
000557r 2                   ; Success - clear carry and return
000557r 2  18               clc
000558r 2  60               rts
000559r 2               
000559r 2               @endofchain:
000559r 2                   ; End of chain - set carry and return
000559r 2  38               sec
00055Ar 2  60               rts
00055Br 2               
00055Br 2               
00055Br 2               fat32_openroot:
00055Br 2                   ; Prepare to read the root directory
00055Br 2               
00055Br 2  AD rr rr         lda fat32_rootcluster
00055Er 2  8D rr rr         sta fat32_nextcluster
000561r 2  AD rr rr         lda fat32_rootcluster+1
000564r 2  8D rr rr         sta fat32_nextcluster+1
000567r 2  AD rr rr         lda fat32_rootcluster+2
00056Ar 2  8D rr rr         sta fat32_nextcluster+2
00056Dr 2  AD rr rr         lda fat32_rootcluster+3
000570r 2  8D rr rr         sta fat32_nextcluster+3
000573r 2               
000573r 2  20 rr rr         jsr fat32_seekcluster
000576r 2               
000576r 2                   ; Set the pointer to a large value so we always read a sector the first time through
000576r 2                   ; lda #$ff
000576r 2                   ; sta sd_buffer_address+1
000576r 2  A9 00            lda #0   ; return success
000578r 2  60               rts
000579r 2               
000579r 2               
000579r 2               fat32_opendirent:
000579r 2  5A               phy
00057Ar 2                   ; Prepare to read from a file or directory based on a dirent
00057Ar 2                   ;
00057Ar 2                   ; Point sd_buffer_address at the dirent
00057Ar 2               
00057Ar 2                   ; Remember file size in bytes remaining
00057Ar 2  A0 1C            ldy #28
00057Cr 2  B1 rr            lda (sd_buffer_address),y
00057Er 2  8D rr rr         sta fat32_bytesremaining
000581r 2  C8               iny
000582r 2  B1 rr            lda (sd_buffer_address),y
000584r 2  8D rr rr         sta fat32_bytesremaining+1
000587r 2  C8               iny
000588r 2  B1 rr            lda (sd_buffer_address),y
00058Ar 2  8D rr rr         sta fat32_bytesremaining+2
00058Dr 2  C8               iny
00058Er 2  B1 rr            lda (sd_buffer_address),y
000590r 2  8D rr rr         sta fat32_bytesremaining+3
000593r 2               
000593r 2                   ; Seek to first cluster
000593r 2  A0 1A            ldy #26
000595r 2  B1 rr            lda (sd_buffer_address),y
000597r 2  8D rr rr         sta fat32_nextcluster
00059Ar 2  C8               iny
00059Br 2  B1 rr            lda (sd_buffer_address),y
00059Dr 2  8D rr rr         sta fat32_nextcluster+1
0005A0r 2  A0 14            ldy #20
0005A2r 2  B1 rr            lda (sd_buffer_address),y
0005A4r 2  8D rr rr         sta fat32_nextcluster+2
0005A7r 2  C8               iny
0005A8r 2  B1 rr            lda (sd_buffer_address),y
0005AAr 2  8D rr rr         sta fat32_nextcluster+3
0005ADr 2               
0005ADr 2  20 rr rr         jsr fat32_seekcluster
0005B0r 2               
0005B0r 2                   ; Set the pointer to a large value so we always read a sector the first time through
0005B0r 2                   ; lda #$ff
0005B0r 2                   ; sta sd_buffer_address+1
0005B0r 2  7A               ply
0005B1r 2  60               rts
0005B2r 2               
0005B2r 2               
0005B2r 2               fat32_readdirent:
0005B2r 2                   ; Read a directory entry from the open directory
0005B2r 2                   ;
0005B2r 2                   ; On exit the carry is set if there were no more directory entries.
0005B2r 2                   ;
0005B2r 2                   ; Otherwise, A is set to the file's attribute byte and
0005B2r 2                   ; zp_sd_address points at the returned directory entry.
0005B2r 2                   ; LFNs and empty entries are ignored automatically.
0005B2r 2               
0005B2r 2                   ; Increment pointer by 32 to point to next entry
0005B2r 2  A9 31            lda #'1'
0005B4r 2  20 rr rr         jsr kernel_putc
0005B7r 2  5A               phy
0005B8r 2  18               clc
0005B9r 2  A5 rr            lda sd_buffer_address
0005BBr 2  69 20            adc #32
0005BDr 2  85 rr            sta sd_buffer_address
0005BFr 2  A5 rr            lda sd_buffer_address+1
0005C1r 2  69 00            adc #0
0005C3r 2  85 rr            sta sd_buffer_address+1
0005C5r 2  8D 81 FF         sta PORTA
0005C8r 2               
0005C8r 2                   ; If it's not at the end of the buffer, we have data already
0005C8r 2  C9 rr            cmp #>(fat32_readbuffer+$200)
0005CAr 2  90 12            bcc @gotdata
0005CCr 2               
0005CCr 2                   ; Read another sector
0005CCr 2  A9 rr            lda #<fat32_readbuffer
0005CEr 2  8D rr rr         sta fat32_address
0005D1r 2  A9 rr            lda #>fat32_readbuffer
0005D3r 2  8D rr rr         sta fat32_address+1
0005D6r 2  20 rr rr         jsr fat32_readnextsector
0005D9r 2  90 03            bcc @gotdata
0005DBr 2               
0005DBr 2               @endofdirectory:
0005DBr 2  7A               ply
0005DCr 2  38               sec
0005DDr 2  60               rts
0005DEr 2               
0005DEr 2               @gotdata:
0005DEr 2                   ; Check first character
0005DEr 2  A0 00            ldy #0
0005E0r 2  B1 rr            lda (sd_buffer_address),y
0005E2r 2               
0005E2r 2                   ; End of directory => abort
0005E2r 2  F0 F7            beq @endofdirectory
0005E4r 2               
0005E4r 2                   ; Empty entry => start again
0005E4r 2  C9 E5            cmp #$e5
0005E6r 2  F0 CA            beq fat32_readdirent
0005E8r 2               
0005E8r 2  A9 35            lda #'5'
0005EAr 2  20 rr rr         jsr kernel_putc
0005EDr 2               
0005EDr 2                   ; Check attributes
0005EDr 2  A0 0B            ldy #11
0005EFr 2  B1 rr            lda (sd_buffer_address),y
0005F1r 2  29 3F            and #$3f
0005F3r 2  C9 0F            cmp #$0f ; LFN => start again
0005F5r 2  F0 BB            beq fat32_readdirent
0005F7r 2               
0005F7r 2  A9 36            lda #'6'
0005F9r 2  20 rr rr         jsr kernel_putc
0005FCr 2                   ; Yield this result
0005FCr 2  7A               ply
0005FDr 2  18               clc
0005FEr 2  60               rts
0005FFr 2               
0005FFr 2               
0005FFr 2               fat32_finddirent:
0005FFr 2                   ; The directory should already be open for iteration.
0005FFr 2                   ; Pointer to filename is in fat32_filenamepointer and fat32_filenamepointer + 1
0005FFr 2               
0005FFr 2                   ; Iterate until name is found or end of directory
0005FFr 2  5A               phy
000600r 2               @direntloop:
000600r 2  20 rr rr         jsr fat32_readdirent
000603r 2  A0 0A            ldy #10
000605r 2  90 04            bcc @comparenameloop
000607r 2  7A               ply
000608r 2  A9 01            lda #1
00060Ar 2  60               rts ; return not found
00060Br 2               
00060Br 2               @comparenameloop:
00060Br 2  B1 rr            lda (sd_buffer_address),y
00060Dr 2  D1 rr            cmp (fat32_filenamepointer),y
00060Fr 2  D0 EF            bne @direntloop ; no match
000611r 2  88               dey
000612r 2  10 F7            bpl @comparenameloop
000614r 2               
000614r 2                   ; Found it
000614r 2  7A               ply
000615r 2  A9 00            lda #0
000617r 2  60               rts
000618r 2               
000618r 2               
000618r 2               fat32_file_readbyte:
000618r 2                   ; Read a byte from an open file
000618r 2                   ;
000618r 2                   ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
000618r 2               
000618r 2  38               sec
000619r 2               
000619r 2                   ; Is there any data to read at all?
000619r 2  AD rr rr         lda fat32_bytesremaining
00061Cr 2  0D rr rr         ora fat32_bytesremaining+1
00061Fr 2  0D rr rr         ora fat32_bytesremaining+2
000622r 2  0D rr rr         ora fat32_bytesremaining+3
000625r 2  F0 49            beq @rts
000627r 2               
000627r 2                   ; Decrement the remaining byte count
000627r 2  AD rr rr         lda fat32_bytesremaining
00062Ar 2  E9 01            sbc #1
00062Cr 2  8D rr rr         sta fat32_bytesremaining
00062Fr 2  AD rr rr         lda fat32_bytesremaining+1
000632r 2  E9 00            sbc #0
000634r 2  8D rr rr         sta fat32_bytesremaining+1
000637r 2  AD rr rr         lda fat32_bytesremaining+2
00063Ar 2  E9 00            sbc #0
00063Cr 2  8D rr rr         sta fat32_bytesremaining+2
00063Fr 2  AD rr rr         lda fat32_bytesremaining+3
000642r 2  E9 00            sbc #0
000644r 2  8D rr rr         sta fat32_bytesremaining+3
000647r 2               
000647r 2                   ; Need to read a new sector?
000647r 2  A5 rr            lda sd_buffer_address+1
000649r 2  C9 rr            cmp #>(fat32_readbuffer+$200)
00064Br 2  90 0F            bcc @gotdata
00064Dr 2               
00064Dr 2                   ; Read another sector
00064Dr 2  A9 rr            lda #<fat32_readbuffer
00064Fr 2  8D rr rr         sta fat32_address
000652r 2  A9 rr            lda #>fat32_readbuffer
000654r 2  8D rr rr         sta fat32_address+1
000657r 2               
000657r 2  20 rr rr         jsr fat32_readnextsector
00065Ar 2  B0 14            bcs @rts                    ; this shouldn't happen
00065Cr 2               
00065Cr 2               @gotdata:
00065Cr 2  5A               phy
00065Dr 2  A0 00            ldy #0
00065Fr 2  B1 rr            lda (sd_buffer_address),y
000661r 2  7A               ply
000662r 2  E6 rr            inc sd_buffer_address
000664r 2  D0 0A            bne @rts
000666r 2  E6 rr            inc sd_buffer_address+1
000668r 2  D0 06            bne @rts
00066Ar 2  E6 rr            inc sd_buffer_address+2
00066Cr 2  D0 02            bne @rts
00066Er 2  E6 rr            inc sd_buffer_address+3
000670r 2               
000670r 2               @rts:
000670r 2  60               rts
000671r 2               
000671r 2               
000671r 2               fat32_file_read:
000671r 2                   ; Read a whole file into memory.  It's assumed the file has just been opened
000671r 2                   ; and no data has been read yet.
000671r 2                   ;
000671r 2                   ; Also we read whole sectors, so data in the target region beyond the end of the
000671r 2                   ; file may get overwritten, up to the next 512-byte boundary.
000671r 2                   ;
000671r 2                   ; And we don't properly support 64k+ files, as it's unnecessary complication given
000671r 2                   ; the 6502's small address space
000671r 2               
000671r 2                   ; Round the size up to the next whole sector
000671r 2  AD rr rr         lda fat32_bytesremaining
000674r 2  C9 01            cmp #1                      ; set carry if bottom 8 bits not zero
000676r 2  AD rr rr         lda fat32_bytesremaining+1
000679r 2  69 00            adc #0                      ; add carry, if any
00067Br 2  4A               lsr                         ; divide by 2
00067Cr 2  69 00            adc #0                      ; round up
00067Er 2               
00067Er 2                   ; No data?
00067Er 2  F0 17            beq @done
000680r 2               
000680r 2                   ; Store sector count - not a byte count any more
000680r 2  8D rr rr         sta fat32_bytesremaining
000683r 2               
000683r 2                   ; Read entire sectors to the user-supplied buffer
000683r 2               @wholesectorreadloop:
000683r 2                   ; Read a sector to fat32_address
000683r 2  20 rr rr         jsr fat32_readnextsector
000686r 2               
000686r 2                   ; Advance fat32_address by 512 bytes
000686r 2  AD rr rr         lda fat32_address+1
000689r 2  69 02            adc #2                      ; carry already clear
00068Br 2  8D rr rr         sta fat32_address+1
00068Er 2               
00068Er 2  AE rr rr         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
000691r 2  CA               dex
000692r 2  8E rr rr         stx fat32_bytesremaining    ; note - actually stores sectors remaining
000695r 2               
000695r 2  D0 EC            bne @wholesectorreadloop
000697r 2               
000697r 2               @done:
000697r 2  60               rts
000698r 2               
000698r 2               
000698r 1               
000698r 1               .include "../../forth.s"
000698r 2               .include "../../macros.s"
000698r 3               .macro  printascii   addr
000698r 3                   ldx #0
000698r 3               @loop:
000698r 3                   lda addr,x
000698r 3                   beq @done
000698r 3                   jsr kernel_putc
000698r 3                   inx
000698r 3                   bra @loop
000698r 3               @done:
000698r 3               .endmacro
000698r 3               
000698r 3               
000698r 2               
000698r 2               
000698r 2               ; Definitions for Tali Forth 2
000698r 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000698r 2               ; First version: 01. Apr 2016 (Liara Forth)
000698r 2               ; This version: 29. Jan 2020
000698r 2               
000698r 2               ; This file is included by taliforth.asm. These are the general
000698r 2               ; definitions; platform-specific definitions such as the
000698r 2               ; memory map are kept in the platform folder.
000698r 2               
000698r 2               
000698r 2               ; User Variables:
000698r 2               ; Block variables
000698r 2               blk_offset =  0        ; BLK : UP + 0
000698r 2               scr_offset =  2        ; SCR : UP + 2
000698r 2               
000698r 2               ; Wordlists
000698r 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000698r 2               num_wordlists_offset =  5
000698r 2                                          ; #WORDLISTS (byte) : UP + 5
000698r 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000698r 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000698r 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000698r 2                                          ;          (Number of wordlists in search order)
000698r 2               search_order_offset =  31
000698r 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000698r 2                                          ; Allowing for 9 to keep offsets even.
000698r 2               max_wordlists =  12    ; Maximum number of wordlists supported
000698r 2                                          ; 4 Tali built-ins + 8 user wordlists
000698r 2               
000698r 2               ; Buffer variables
000698r 2               blkbuffer_offset =     40   ; Address of buffer
000698r 2               buffblocknum_offset =  42   ; Block number current in buffer
000698r 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000698r 2               
000698r 2               ; Block I/O vectors
000698r 2               blockread_offset =     46   ; Vector to block reading routine
000698r 2               blockwrite_offset =    48   ; Vector to block writing routine
000698r 2               
000698r 2               
000698r 2               ; ASCII CHARACTERS
000698r 2               AscCC =   $03  ; break (CTRL-c)
000698r 2               AscBELL = $07  ; bell sound
000698r 2               AscBS =   $08  ; backspace
000698r 2               AscLF =   $0a  ; line feed
000698r 2               AscCR =   $0d  ; carriage return
000698r 2               AscESC =  $1b  ; escape
000698r 2               AscSP =   $20  ; space
000698r 2               AscDEL =  $7f  ; delete (CTRL-h)
000698r 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000698r 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000698r 2               
000698r 2               ; DICTIONARY FLAGS
000698r 2               ; The first three bits are currently unused
000698r 2               CO = 1  ; Compile Only
000698r 2               AN = 2  ; Always Native Compile
000698r 2               IM = 4  ; Immediate Word
000698r 2               NN = 8  ; Never Native Compile
000698r 2               UF = 16 ; Includes Underflow Check (RESERVED)
000698r 2               HC = 32 ; Word has Code Field Area (CFA)
000698r 2               
000698r 2               
000698r 2               ; VARIOUS
000698r 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000698r 2               
000698r 2               ; END
000698r 2               
000698r 2               .segment "ZEROPAGE": zeropage
000016r 2               ; ZERO PAGE ADDRESSES/VARIABLES
000016r 2               
000016r 2               ; These are kept at the top of Zero Page, with the most important variables at
000016r 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
000016r 2               ; an overflow, the lower, less important variables will be clobbered first,
000016r 2               ; giving the system a chance to recover. In other words, they are part of the
000016r 2               ; floodplain.
000016r 2               
000016r 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000016r 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000016r 2               
000016r 2  xx xx        cp: .res 2   ; Compiler Pointer
000018r 2  xx xx        dp: .res 2   ; Dictionary Pointer
00001Ar 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
00001Cr 2                                          ; a :NONAME declared word (see status)
00001Cr 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
00001Er 2  xx xx        cib: .res 2   ; address of current input buffer
000020r 2  xx xx        ciblen: .res 2  ; length of current input buffer
000022r 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
000024r 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
000026r 2  xx xx        output: .res 2  ; vector for EMIT
000028r 2  xx xx        input: .res 2  ; vector for KEY
00002Ar 2  xx xx        havekey: .res 2  ; vector for KEY?
00002Cr 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
00002Er 2  xx xx        base: .res 2  ; number radix, default decimal
000030r 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
000032r 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
000034r 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
000036r 2  xx xx        status: .res 2  ; internal status information
000038r 2                                          ; (used by : :NONAME ; ACCEPT)
000038r 2                                          ; Bit 7 = Redefined word message postpone
000038r 2                                          ;         When set before calling CREATE, it will
000038r 2                                          ;         not print the "redefined xxxx" message if
000038r 2                                          ;         the word exists. Instead, this bit will
000038r 2                                          ;         be reused and after CREATE has run, it will
000038r 2                                          ;         be set if the word was redefined and 0 if
000038r 2                                          ;         not. This bit should be 0 when not in use.
000038r 2                                          ; Bit 6 = 1 for normal ":" definitions
000038r 2                                          ;         WORKWORD contains nt of word being compiled
000038r 2                                          ;       = 0 for :NONAME definitions
000038r 2                                          ;         WORKWORD contains xt of word being compiled
000038r 2                                          ; Bit 5 = 1 for NUMBER returning a double word
000038r 2                                          ;       = 0 for NUMBER returning a single word
000038r 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
000038r 2                                          ;       = 0 CTRL-n recalls previous history
000038r 2                                          ; Bit 2 = Current history buffer msb
000038r 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
000038r 2                                          ; Bit 0 = Current history buffer lsb
000038r 2                                          ; status+1 is used by ACCEPT to hold history lengths.
000038r 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
00003Ar 2  xx xx        tmp1: .res 2  ; temporary storage
00003Cr 2  xx xx        tmp2: .res 2  ; temporary storage
00003Er 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
000040r 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
000042r 2  xx xx        tmptos: .res 2  ; temporary TOS storage
000044r 2  xx xx        editor1: .res 2  ; temporary for editors
000046r 2  xx xx        editor2: .res 2  ; temporary for editors
000048r 2  xx xx        editor3: .res 2  ; temporary for editors
00004Ar 2  xx xx        tohold: .res 2  ; pointer for formatted output
00004Cr 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
000050r 2  xx xx xx xx  
000054r 2  xx xx xx xx  dsp_start: .res 128 ; reserve 128 bytes for data stack (64 16 bit cells)
000058r 2  xx xx xx xx  
00005Cr 2  xx xx xx xx  
0000D4r 2               dsp0 = $FF          ; first data stack location. Data stack grows down
0000D4r 2               rsp0 =      $FF     ; starting stack pointer
0000D4r 2               stack0 =    $0100   ; location of the stack
0000D4r 2               
0000D4r 2               
0000D4r 2               .segment "BSS"
000932r 2  xx xx xx xx  hist_buff: .res $400
000936r 2  xx xx xx xx  
00093Ar 2  xx xx xx xx  
000D32r 2  xx xx xx xx  buffer0: .res $100
000D36r 2  xx xx xx xx  
000D3Ar 2  xx xx xx xx  
000E32r 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
000698r 2               
000698r 2               forth:
000698r 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
000698r 3               ; Low-level Forth word routines
000698r 3               ; Tali Forth 2 for the 65c02
000698r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000698r 3               ; First version: 19. Jan 2014
000698r 3               ; This version: 03. Jan 2018
000698r 3               
000698r 3               ; This list is ordered alphabetically by the names of the words, not their
000698r 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000698r 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000698r 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000698r 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000698r 3               
000698r 3               ;       TBA --> fragment --> coded --> tested --> auto
000698r 3               
000698r 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000698r 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000698r 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000698r 3               
000698r 3               ; ## COLD ( -- ) "Reset the Forth system"
000698r 3               ; ## "cold"  tested  Tali Forth
000698r 3               ;       """Reset the Forth system. Does not restart the kernel,
000698r 3               ;       use the 65c02 reset for that. Flows into ABORT.
000698r 3               ;       """
000698r 3               xt_cold:
000698r 3  D8                           cld
000699r 3               
000699r 3                               ; Set the OUTPUT vector to the default kernel_putc
000699r 3                               ; We do this really early so we can print error messages
000699r 3                               ; during debugging
000699r 3  A9 rr                        lda #<kernel_putc
00069Br 3  85 rr                        sta output
00069Dr 3  A9 rr                        lda #>kernel_putc
00069Fr 3  85 rr                        sta output+1
0006A1r 3               
0006A1r 3                               ; Load all of the important zero page variables from ROM
0006A1r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
0006A3r 3               
0006A3r 3               @load_zp_loop:
0006A3r 3                               ; This loop loads them back to front. We can use X here
0006A3r 3                               ; because Tali hasn't started using the stack yet.
0006A3r 3  BD rr rr                     lda cold_zp_table,x
0006A6r 3  95 rr                        sta cp,x
0006A8r 3  CA                           dex
0006A9r 3  D0 F8                        bne @load_zp_loop
0006ABr 3               
0006ABr 3                               ; Copy the 0th element.
0006ABr 3  AD rr rr                     lda cold_zp_table
0006AEr 3  85 rr                        sta cp
0006B0r 3                               ; Initialize 65c02 stack (Return Stack)
0006B0r 3  A2 FF                        ldx #rsp0
0006B2r 3  9A                           txs
0006B3r 3               
0006B3r 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
0006B3r 3                               ; can load high-level words with EVALUATE
0006B3r 3  A2 FF                        ldx #dsp0
0006B5r 3               
0006B5r 3               
0006B5r 3                               ; Initialize the user variables.
0006B5r 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
0006B7r 3  A9 00                        lda #0
0006B9r 3               
0006B9r 3               @load_user_vars_loop:
0006B9r 3                               ; Like the zero page variables, these are initialized
0006B9r 3                               ; back to front.
0006B9r 3  B9 rr rr                     lda cold_user_table,y
0006BCr 3  91 rr                        sta (up),y
0006BEr 3  88                           dey
0006BFr 3  D0 F8                        bne @load_user_vars_loop
0006C1r 3               
0006C1r 3                               ; Copy the 0th element.
0006C1r 3  AD rr rr                     lda cold_user_table
0006C4r 3  92 rr                        sta (up)
0006C6r 3  20 rr rr                     jsr xt_cr
0006C9r 3               
0006C9r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
0006C9r 3                               ; you do not have any high-level words, this part can be
0006C9r 3                               ; commented out.
0006C9r 3  CA                           dex
0006CAr 3  CA                           dex
0006CBr 3  CA                           dex
0006CCr 3  CA                           dex
0006CDr 3               
0006CDr 3               
0006CDr 3                               ; start address goes NOS
0006CDr 3  A9 rr                        lda #<forth_words_start
0006CFr 3  95 02                        sta 2,x
0006D1r 3  A9 rr                        lda #>forth_words_start
0006D3r 3  95 03                        sta 3,x
0006D5r 3               
0006D5r 3                               ; length goes TOS
0006D5r 3  A9 rr                        lda #<forth_words_end
0006D7r 3  38                           sec
0006D8r 3  E9 rr                        sbc #<forth_words_start
0006DAr 3  95 00                        sta 0,x
0006DCr 3               
0006DCr 3  A9 rr                        lda #>forth_words_end
0006DEr 3  E9 rr                        sbc #>forth_words_start
0006E0r 3  95 01                        sta 1,x
0006E2r 3               
0006E2r 3               
0006E2r 3  20 rr rr                     jsr xt_evaluate
0006E5r 3               
0006E5r 3                               ; Now define any user words via EVALUATE. If you do not have
0006E5r 3                               ; any user-defined words, this part can be commented out as
0006E5r 3                               ; well.
0006E5r 3  CA                           dex
0006E6r 3  CA                           dex
0006E7r 3  CA                           dex
0006E8r 3  CA                           dex
0006E9r 3               
0006E9r 3               
0006E9r 3                               ; start address goes NOS
0006E9r 3  A9 rr                        lda #<user_words_start
0006EBr 3  95 02                        sta 2,x
0006EDr 3  A9 rr                        lda #>user_words_start
0006EFr 3  95 03                        sta 3,x
0006F1r 3               
0006F1r 3                               ; length goes TOS
0006F1r 3  A9 rr                        lda #<user_words_end
0006F3r 3  38                           sec
0006F4r 3  E9 rr                        sbc #<user_words_start
0006F6r 3  95 00                        sta 0,x
0006F8r 3               
0006F8r 3  A9 rr                        lda #>user_words_end
0006FAr 3  E9 rr                        sbc #>user_words_start
0006FCr 3  95 01                        sta 1,x
0006FEr 3               
0006FEr 3  20 rr rr                     jsr xt_evaluate
000701r 3               
000701r 3                               ; Initialize all of the history buffers by putting a zero in
000701r 3                               ; each length byte.
000701r 3  9C rr rr                     stz hist_buff
000704r 3  9C rr rr                     stz hist_buff+$80
000707r 3  9C rr rr                     stz hist_buff+$100
00070Ar 3  9C rr rr                     stz hist_buff+$180
00070Dr 3  9C rr rr                     stz hist_buff+$200
000710r 3  9C rr rr                     stz hist_buff+$280
000713r 3  9C rr rr                     stz hist_buff+$300
000716r 3  9C rr rr                     stz hist_buff+$380
000719r 3               
000719r 3               
000719r 3                               ; fall through to ABORT
000719r 3               
000719r 3               
000719r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
000719r 3               ; ## "abort"  tested  ANS core
000719r 3                       ; """https://forth-standard.org/standard/core/ABORT
000719r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
000719r 3                       ; subroutine if we want to because we are going to reset the 65c02's
000719r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
000719r 3                       ; actually delete the stuff on the Data Stack.
000719r 3                       ; """
000719r 3               xt_abort:
000719r 3  A2 FF                        ldx #dsp0
00071Br 3               
00071Br 3                               ; fall through to QUIT
00071Br 3               
00071Br 3               
00071Br 3               ; ## QUIT ( -- ) "Reset the input and get new input"
00071Br 3               ; ## "quit"  tested  ANS core
00071Br 3                       ; """https://forth-standard.org/standard/core/QUIT
00071Br 3                       ; Rest the input and start command loop
00071Br 3                       ; """
00071Br 3               
00071Br 3               xt_quit:
00071Br 3                               ; Clear the Return Stack. This is a little screwed up
00071Br 3                               ; because the 65c02 can only set the Return Stack via X,
00071Br 3                               ; which is our Data Stack pointer. The ANS specification
00071Br 3                               ; demands, however, that ABORT reset the Data Stack pointer
00071Br 3  8A                           txa             ; Save the DSP that we just defined
00071Cr 3  A2 FF                        ldx #rsp0
00071Er 3  9A                           txs
00071Fr 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000720r 3               
000720r 3                               ; make sure instruction pointer is empty
000720r 3  64 rr                        stz ip
000722r 3  64 rr                        stz ip+1
000724r 3               
000724r 3                               ; SOURCE-ID is zero (keyboard input)
000724r 3  64 rr                        stz insrc
000726r 3  64 rr                        stz insrc+1
000728r 3               
000728r 3                               ; STATE is zero (interpret, not compile)
000728r 3  64 rr                        stz state
00072Ar 3  64 rr                        stz state+1
00072Cr 3               @get_line:
00072Cr 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
00072Er 3  85 rr                        sta cib
000730r 3  A9 rr                        lda #>buffer0
000732r 3  85 rr                        sta cib+1
000734r 3               
000734r 3                               ; Size of current input buffer (CIB) is zero
000734r 3  64 rr                        stz ciblen
000736r 3  64 rr                        stz ciblen+1
000738r 3               
000738r 3                               ; Accept a line from the current import source. This is how
000738r 3                               ; modern Forths to it.
000738r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00073Br 3               
00073Br 3                               ; Test flag: LSB of TOS
00073Br 3  B5 00                        lda 0,x
00073Dr 3  D0 05                        bne @success
00073Fr 3               
00073Fr 3                               ; If REFILL returned a FALSE flag, something went wrong and we
00073Fr 3                               ; need to print an error message and reset the machine. We
00073Fr 3                               ; don't need to save TOS because we're going to clobber it
00073Fr 3                               ; anyway when we go back to ABORT.
00073Fr 3  A9 06                        lda #err_refill
000741r 3  4C rr rr                     jmp error
000744r 3               
000744r 3               @success:
000744r 3                               ; Assume we have successfully accepted a string of input from
000744r 3                               ; a source, with address cib and length of input in ciblen. We
000744r 3                               ; arrive here still with the TRUE flag from REFILL as TOS
000744r 3  E8                           inx                     ; drop
000745r 3  E8                           inx
000746r 3               
000746r 3                               ; Main compile/execute routine
000746r 3  20 rr rr                     jsr interpret
000749r 3               
000749r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
000749r 3                               ; overflow because it is so rare
000749r 3  E0 FF                        cpx #dsp0
00074Br 3  F0 05                        beq @stack_ok
00074Dr 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
00074Fr 3               
00074Fr 3  4C rr rr                     jmp underflow_error
000752r 3               
000752r 3               @stack_ok:
000752r 3                               ; Display system prompt if all went well. If we're interpreting,
000752r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
000752r 3                               ; space at beginning of the string.
000752r 3  A5 rr                        lda state
000754r 3  F0 02                        beq @print
000756r 3               
000756r 3  A9 01                        lda #1                  ; number for "compile" string
000758r 3               @print:
000758r 3  20 rr rr                     jsr print_string
00075Br 3               
00075Br 3                               ; Awesome line, everybody! Now get the next one.
00075Br 3  80 CF                        bra @get_line
00075Dr 3               
00075Dr 3               z_cold:
00075Dr 3               z_abort:
00075Dr 3               z_quit:         ; no RTS required
00075Dr 3               
00075Dr 3               
00075Dr 3               
00075Dr 3               ; This table holds all of the initial values for the variables in zero page.
00075Dr 3               ; This table is used by COLD.
00075Dr 3               cold_zp_table:
00075Dr 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
00075Fr 3                                               ; block buffer
00075Fr 3  rr rr                .word dictionary_start  ; dp
000761r 3  00 00                .word 0                 ; workword
000763r 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000765r 3  rr rr                .word buffer0           ; cib
000767r 3  00 00                .word 0                 ; ciblen
000769r 3  00 00                .word 0                 ; toin
00076Br 3  00 00                .word 0                 ; ip
00076Dr 3  rr rr                .word kernel_putc       ; output
00076Fr 3  rr rr                .word kernel_getc       ; input
000771r 3  00 00                .word 0                 ; havekey
000773r 3  00 00                .word 0                 ; state (0 = interpret)
000775r 3  0A 00                .word 10                ; base
000777r 3  14 00                .word 20                ; nc-limit
000779r 3  00 00                .word 0                 ; uf_strip (off by default)
00077Br 3  rr rr                .word cp0               ; up (user vars put right at beginning of
00077Dr 3                                               ; available RAM)
00077Dr 3  00 00                .word 0                 ; status
00077Fr 3               cold_zp_table_end:
00077Fr 3               
00077Fr 3               ; No further ZP variables are initialized. The variables past this point are
00077Fr 3               ; all temporaries.
00077Fr 3               
00077Fr 3               ; This table holds the inital values for the user variables. This table is
00077Fr 3               ; used by COLD.
00077Fr 3               cold_user_table:
00077Fr 3  00 00                .word 0                         ; BLK
000781r 3  00 00                .word 0                         ; SCR
000783r 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
000784r 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000785r 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
000787r 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
000789r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
00078Br 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
00078Dr 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000791r 3  00 00 00 00  
000795r 3  00 00 00 00  
00079Dr 3  01                   .byte 1                         ; #ORDER
00079Er 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
0007A2r 3  00 00 00 00  
0007A6r 3  00           
0007A7r 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
0007A9r 3  00 00                .word 0                         ; block in buffer
0007ABr 3  00 00                .word 0                         ; buffer status (not in use)
0007ADr 3  rr rr                .word xt_block_word_error       ; block-read vector
0007AFr 3  rr rr                .word xt_block_word_error       ; block-write vector
0007B1r 3               cold_user_table_end:
0007B1r 3               
0007B1r 3               
0007B1r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
0007B1r 3               ; ## "abort""  tested  ANS core
0007B1r 3                       ; """https://forth-standard.org/standard/core/ABORTq
0007B1r 3                       ; Abort and print a string.
0007B1r 3                       ; """
0007B1r 3               
0007B1r 3               xt_abort_quote:
0007B1r 3                               ; save the string
0007B1r 3  20 rr rr                     jsr xt_s_quote          ; S"
0007B4r 3               
0007B4r 3                               ; compile run-time part
0007B4r 3  A0 rr                        ldy #>abort_quote_runtime
0007B6r 3  A9 rr                        lda #<abort_quote_runtime
0007B8r 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
0007BBr 3               
0007BBr 3  60           z_abort_quote:  rts
0007BCr 3               
0007BCr 3               
0007BCr 3               abort_quote_runtime:
0007BCr 3                       ; """Runtime aspect of ABORT_QUOTE"""
0007BCr 3               
0007BCr 3                               ; We arrive here with ( f addr u )
0007BCr 3  B5 04                        lda 4,x
0007BEr 3  15 05                        ora 5,x
0007C0r 3  F0 09                        beq @done       ; if FALSE, we're done
0007C2r 3               
0007C2r 3                               ; We're true, so print string and ABORT. We follow Gforth
0007C2r 3                               ; in going to a new line after the string
0007C2r 3  20 rr rr                     jsr xt_type
0007C5r 3  20 rr rr                     jsr xt_cr
0007C8r 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
0007CBr 3               @done:
0007CBr 3                               ; Drop three entries from the Data Stack
0007CBr 3  8A                           txa
0007CCr 3  18                           clc
0007CDr 3  69 06                        adc #6
0007CFr 3  AA                           tax
0007D0r 3               
0007D0r 3  60                           rts
0007D1r 3               
0007D1r 3               
0007D1r 3               
0007D1r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
0007D1r 3               ; ## "abs"  auto  ANS core
0007D1r 3                       ; """https://forth-standard.org/standard/core/ABS
0007D1r 3                       ; Return the absolute value of a number.
0007D1r 3                       ; """
0007D1r 3               
0007D1r 3               xt_abs:
0007D1r 3  20 rr rr                     jsr underflow_1
0007D4r 3               
0007D4r 3  B5 01                        lda 1,x
0007D6r 3  10 0D                        bpl @done       ; positive number, easy money!
0007D8r 3               
0007D8r 3                               ; negative: calculate 0 - n
0007D8r 3  38                           sec
0007D9r 3  A9 00                        lda #0
0007DBr 3  F5 00                        sbc 0,x         ; LSB
0007DDr 3  95 00                        sta 0,x
0007DFr 3               
0007DFr 3  A9 00                        lda #0          ; MSB
0007E1r 3  F5 01                        sbc 1,x
0007E3r 3  95 01                        sta 1,x
0007E5r 3               
0007E5r 3               @done:
0007E5r 3  60           z_abs:          rts
0007E6r 3               
0007E6r 3               
0007E6r 3               
0007E6r 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
0007E6r 3               ; ## "accept"  auto  ANS core
0007E6r 3                       ; """https://forth-standard.org/standard/core/ACCEPT
0007E6r 3                       ; Receive a string of at most n1 characters, placing them at
0007E6r 3                       ; addr. Return the actual number of characters as n2. Characters
0007E6r 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
0007E6r 3                       ; modern Forths.
0007E6r 3                       ; """
0007E6r 3               
0007E6r 3               xt_accept:
0007E6r 3  20 rr rr                     jsr underflow_2
0007E9r 3               
0007E9r 3                               ; Abort if we were asked to receive 0 chars
0007E9r 3  B5 00                        lda 0,x
0007EBr 3  15 01                        ora 1,x
0007EDr 3  D0 09                        bne @not_zero
0007EFr 3               
0007EFr 3  E8                           inx
0007F0r 3  E8                           inx
0007F1r 3  74 00                        stz 0,x
0007F3r 3  74 01                        stz 1,x
0007F5r 3               
0007F5r 3  4C rr rr                     jmp accept_done
0007F8r 3               
0007F8r 3               @not_zero:
0007F8r 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
0007FAr 3  85 rr                        sta tmp2
0007FCr 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
0007FEr 3               
0007FEr 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000800r 3  85 rr                        sta tmp1
000802r 3  B5 03                        lda 3,x
000804r 3  85 rr                        sta tmp1+1
000806r 3               
000806r 3  E8                           inx
000807r 3  E8                           inx
000808r 3               
000808r 3  A0 00                        ldy #0
00080Ar 3               
00080Ar 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
00080Ar 3                               ; from bit 2 to 3 is OK)
00080Ar 3  A5 rr                        lda status
00080Cr 3  29 F7                        and #$f7
00080Er 3               
00080Er 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
00080Er 3  1A                           inc
00080Fr 3               
00080Fr 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
00080Fr 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
00080Fr 3                               ; received and won't be used to calculate the history buffer
00080Fr 3                               ; offset.
00080Fr 3  09 08                        ora #$08
000811r 3  85 rr                        sta status
000813r 3               
000813r 3               accept_loop:
000813r 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000813r 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000813r 3                               ; vt100 terminal clears the screen automatically.
000813r 3               
000813r 3                               ; This is the internal version of KEY without all the mucking
000813r 3                               ; about with the Data Stack while still using the input vector
000813r 3  20 rr rr                     jsr key_a
000816r 3               
000816r 3                               ; We quit on both line feed and carriage return
000816r 3  C9 0A                        cmp #AscLF
000818r 3  F0 20                        beq @eol
00081Ar 3  C9 0D                        cmp #AscCR
00081Cr 3  F0 1C                        beq @eol
00081Er 3               
00081Er 3                               ; BACKSPACE and DEL do the same thing for the moment
00081Er 3  C9 08                        cmp #AscBS
000820r 3  F0 22                        beq @backspace
000822r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000824r 3  F0 1E                        beq @backspace
000826r 3               
000826r 3                               ; Check for CTRL-p and CTRL-n to recall input history
000826r 3  C9 10                        cmp #AscCP
000828r 3  F0 36                        beq @ctrl_p
00082Ar 3  C9 0E                        cmp #AscCN
00082Cr 3  F0 44                        beq @ctrl_n
00082Er 3               
00082Er 3                               ; That's enough for now. Save and echo character.
00082Er 3  91 rr                        sta (tmp1),y
000830r 3  C8                           iny
000831r 3               
000831r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000831r 3  20 rr rr                     jsr emit_a
000834r 3               
000834r 3  C4 rr                        cpy tmp2        ; reached character limit?
000836r 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
000838r 3  80 03                        bra @buffer_full
00083Ar 3               
00083Ar 3               @eol:
00083Ar 3  20 rr rr                     jsr xt_space    ; print final space
00083Dr 3               
00083Dr 3               @buffer_full:
00083Dr 3                               ; REFILL updates ciblen and toin, we don't need to do it here
00083Dr 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
00083Fr 3  74 01                        stz 1,x         ; we only accept 256 chars
000841r 3               
000841r 3  4C rr rr                     jmp accept_done
000844r 3               
000844r 3               @backspace:
000844r 3                               ; Handle backspace and delete kex, which currently do the same
000844r 3                               ; thing
000844r 3  C0 00                        cpy #0          ; buffer empty?
000846r 3  D0 06                        bne @1
000848r 3               
000848r 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
00084Ar 3  20 rr rr                     jsr emit_a
00084Dr 3  C8                           iny
00084Er 3               @1:
00084Er 3  88                           dey
00084Fr 3  A9 08                        lda #AscBS      ; move back one
000851r 3  20 rr rr                     jsr emit_a
000854r 3  A9 20                        lda #AscSP      ; print a space (rubout)
000856r 3  20 rr rr                     jsr emit_a
000859r 3  A9 08                        lda #AscBS      ; move back over space
00085Br 3  20 rr rr                     jsr emit_a
00085Er 3               
00085Er 3  80 B3                        bra accept_loop
000860r 3               
000860r 3               @ctrl_p:
000860r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000860r 3               
000860r 3                               ; Select the previous buffer
000860r 3  A5 rr                        lda status
000862r 3               
000862r 3                               ; Check for 0 (need to wrap back to 7)
000862r 3  29 07                        and #7
000864r 3  D0 08                        bne @ctrl_p_dec
000866r 3               
000866r 3                               ; We need to wrap back to 7.
000866r 3  A5 rr                        lda status
000868r 3  09 07                        ora #7
00086Ar 3  85 rr                        sta status
00086Cr 3  80 11                        bra @recall_history
00086Er 3               
00086Er 3               @ctrl_p_dec:
00086Er 3                               ; It's safe to decrement the buffer index directly.
00086Er 3  C6 rr                        dec status
000870r 3  80 0D                        bra @recall_history
000872r 3               
000872r 3               @ctrl_n:
000872r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000872r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000872r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000872r 3                               ; history buffer.
000872r 3  A9 08                        lda #$8
000874r 3  24 rr                        bit status
000876r 3  D0 07                        bne @recall_history
000878r 3               
000878r 3                               ; This isn't the first time CTRL-n has been pressed, select the
000878r 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
000878r 3  A5 rr                        lda status
00087Ar 3  29 F7                        and #$f7
00087Cr 3               
00087Cr 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
00087Cr 3  1A                           inc
00087Dr 3               
00087Dr 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
00087Dr 3                               ; be cleared below.
00087Dr 3  85 rr                        sta status
00087Fr 3               
00087Fr 3                               ; Falls through to @recall_history
00087Fr 3               
00087Fr 3               @recall_history:
00087Fr 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
00087Fr 3  A9 08                        lda #%00001000
000881r 3  14 rr                        trb status
000883r 3               
000883r 3  20 rr rr                     jsr total_recall
000886r 3               
000886r 3                               ; tmp3 now has the address of the previous history buffer.
000886r 3                               ; First byte of buffer is length. Clear the line by sending
000886r 3                               ; CR, Y spaces, then CR.
000886r 3  A9 0D                        lda #AscCR
000888r 3  20 rr rr                     jsr emit_a
00088Br 3               
00088Br 3               input_clear:
00088Br 3  C0 00                        cpy #0
00088Dr 3  F0 08                        beq input_cleared
00088Fr 3               
00088Fr 3  A9 20                        lda #AscSP
000891r 3  20 rr rr                     jsr emit_a
000894r 3  88                           dey
000895r 3  80 F4                        bra input_clear
000897r 3               
000897r 3               input_cleared:
000897r 3  A9 0D                        lda #AscCR
000899r 3  20 rr rr                     jsr emit_a
00089Cr 3               
00089Cr 3                               ; Save the history length byte into histinfo+1
00089Cr 3                               ; ldy #0        ; Y is already 0 by clearing the line.
00089Cr 3  B1 rr                        lda (tmp3),y
00089Er 3  85 rr                        sta status+1
0008A0r 3               
0008A0r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
0008A0r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
0008A0r 3                               ; buffer)
0008A0r 3  E6 rr                        inc tmp3
0008A2r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
0008A4r 3  E6 rr                        inc tmp3+1
0008A6r 3               @2:
0008A6r 3                               ; Copy the history buffer into the input buffer,
0008A6r 3                               ; sending the characters to the output as we go.
0008A6r 3  A9 0D                        lda #AscCR
0008A8r 3  20 rr rr                     jsr emit_a
0008ABr 3               
0008ABr 3               @history_loop:
0008ABr 3                               ; See if we have reached the end of the history buffer.
0008ABr 3  C4 rr                        cpy status+1
0008ADr 3  D0 03                        bne @3
0008AFr 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
0008B2r 3               @3:
0008B2r 3                               ; See if we have reached the end of the input buffer.
0008B2r 3                               ; (only comparing to lower byte as we currently limit
0008B2r 3                               ; to 255 characters max)
0008B2r 3  C4 rr                        cpy tmp2
0008B4r 3  F0 0A                        beq @hist_filled_buffer
0008B6r 3               
0008B6r 3                               ; Copy a character and echo.
0008B6r 3  B1 rr                        lda (tmp3),y
0008B8r 3  91 rr                        sta (tmp1),y
0008BAr 3  20 rr rr                     jsr emit_a
0008BDr 3               
0008BDr 3                               ; Move to the next character.
0008BDr 3  C8                           iny
0008BEr 3  80 EB                        bra @history_loop
0008C0r 3               
0008C0r 3               @hist_filled_buffer:
0008C0r 3                               ; We don't want a history recall to EOL our buffer,
0008C0r 3                               ; so back up one character and return to editing.
0008C0r 3  88                           dey
0008C1r 3  4C rr rr                     jmp accept_loop
0008C4r 3               accept_done:
0008C4r 3               @done:
0008C4r 3                               ; Copy the input buffer into the currently
0008C4r 3                               ; selected history buffer.
0008C4r 3  20 rr rr                     jsr total_recall
0008C7r 3  85 rr                        sta status+1
0008C9r 3               
0008C9r 3                               ; Also save it in the first buffer byte.
0008C9r 3  A0 00                        ldy #0
0008CBr 3  91 rr                        sta (tmp3),y
0008CDr 3               
0008CDr 3                               ; Move path the count to the data bytes
0008CDr 3  E6 rr                        inc tmp3
0008CFr 3  D0 02                        bne @4           ; Increment the upper byte on carry.
0008D1r 3  E6 rr                        inc tmp3+1
0008D3r 3               @4:
0008D3r 3                               ; Copy the characters from the input buffer to the
0008D3r 3                               ; history buffer.
0008D3r 3               
0008D3r 3               @save_history_loop:
0008D3r 3  C4 rr                        cpy status+1
0008D5r 3  F0 07                        beq @save_history_done
0008D7r 3               
0008D7r 3  B1 rr                        lda (tmp1),y
0008D9r 3  91 rr                        sta (tmp3),y
0008DBr 3  C8                           iny
0008DCr 3  80 F5                        bra @save_history_loop
0008DEr 3               
0008DEr 3               @save_history_done:
0008DEr 3               z_accept:
0008DEr 3  60                           rts
0008DFr 3               
0008DFr 3               total_recall:
0008DFr 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
0008DFr 3               
0008DFr 3                               ; Generate the address of the buffer in tmp3. Start with the
0008DFr 3                               ; base address.
0008DFr 3  A9 rr                        lda #<hist_buff
0008E1r 3  85 rr                        sta tmp3
0008E3r 3  A9 rr                        lda #>hist_buff
0008E5r 3  85 rr                        sta tmp3+1
0008E7r 3               
0008E7r 3                               ; This is a bit annoying as some bits go into each byte.
0008E7r 3                               ; .....xxx gets put into address like ......xx x.......
0008E7r 3  A5 rr                        lda status
0008E9r 3  6A                           ror
0008EAr 3  29 03                        and #3
0008ECr 3  18                           clc
0008EDr 3  65 rr                        adc tmp3+1
0008EFr 3  85 rr                        sta tmp3+1
0008F1r 3               
0008F1r 3  A5 rr                        lda status
0008F3r 3  6A                           ror             ; Rotate through carry into msb.
0008F4r 3  6A                           ror
0008F5r 3  29 80                        and #$80
0008F7r 3  18                           clc
0008F8r 3  65 rr                        adc tmp3
0008FAr 3  85 rr                        sta tmp3
0008FCr 3  90 02                        bcc @1           ; Increment the upper byte on carry.
0008FEr 3  E6 rr                        inc tmp3+1
000900r 3               @1:
000900r 3                               ; Save the current length of the input buffer in
000900r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000900r 3  98                           tya
000901r 3  C9 80                        cmp #$80
000903r 3  90 02                        bcc @2
000905r 3  A9 7F                        lda #$7F
000907r 3               @2:
000907r 3  60                           rts
000908r 3               
000908r 3               
000908r 3               
000908r 3               
000908r 3               
000908r 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000908r 3               ; ## "action-of"  auto  ANS core ext
000908r 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000908r 3               
000908r 3               xt_action_of:
000908r 3                               ; This is a state aware word with differet behavior
000908r 3                               ; when used while compiling vs interpreting.
000908r 3                               ; Check STATE
000908r 3  A5 rr                        lda state
00090Ar 3  05 rr                        ora state+1
00090Cr 3  F0 0C                        beq @interpreting
00090Er 3               
00090Er 3               @compiling:
00090Er 3                               ; Run ['] to compile the xt of the next word
00090Er 3                               ; as a literal.
00090Er 3  20 rr rr                     jsr xt_bracket_tick
000911r 3               
000911r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000911r 3  A0 rr                        ldy #>xt_defer_fetch
000913r 3  A9 rr                        lda #<xt_defer_fetch
000915r 3  20 rr rr                     jsr cmpl_subroutine
000918r 3  80 06                        bra @done
00091Ar 3               
00091Ar 3               @interpreting:
00091Ar 3  20 rr rr                     jsr xt_tick
00091Dr 3  20 rr rr                     jsr xt_defer_fetch
000920r 3               
000920r 3               @done:
000920r 3  60           z_action_of:           rts
000921r 3               
000921r 3               
000921r 3               
000921r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000921r 3               ; ## "again"  tested  ANS core ext
000921r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000921r 3               
000921r 3               xt_again:
000921r 3  20 rr rr                     jsr underflow_1
000924r 3               
000924r 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000924r 3                               ; so we have the range and don't have to calculate the
000924r 3                               ; offset.
000924r 3  A0 00                        ldy #0
000926r 3  A9 4C                        lda #$4C        ; JMP
000928r 3  91 rr                        sta (cp),y
00092Ar 3  C8                           iny
00092Br 3               
00092Br 3  B5 00                        lda 0,x         ; LSB of address
00092Dr 3  91 rr                        sta (cp),y
00092Fr 3  C8                           iny
000930r 3               
000930r 3  B5 01                        lda 1,x         ; MSB of address
000932r 3  91 rr                        sta (cp),y
000934r 3  C8                           iny
000935r 3               
000935r 3                               ; Allot the space we just used
000935r 3  98                           tya
000936r 3  18                           clc
000937r 3  65 rr                        adc cp
000939r 3  85 rr                        sta cp
00093Br 3  90 02                        bcc @done
00093Dr 3  E6 rr                        inc cp+1
00093Fr 3               @done:
00093Fr 3  E8                           inx
000940r 3  E8                           inx
000941r 3               
000941r 3  60           z_again:        rts
000942r 3               
000942r 3               
000942r 3               
000942r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000942r 3               ; ## "align"  auto  ANS core
000942r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000942r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000942r 3                       ; routine as well, and also does nothing
000942r 3                       ; """
000942r 3               
000942r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000942r 3               ; ## "aligned"  auto  ANS core
000942r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000942r 3               
000942r 3               xt_align:
000942r 3               xt_aligned:
000942r 3               z_align:
000942r 3  60           z_aligned:      rts             ; stripped out during native compile
000943r 3               
000943r 3               
000943r 3               
000943r 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000943r 3               ; ## "allot"  auto  ANS core
000943r 3                       ; """https://forth-standard.org/standard/core/ALLOT
000943r 3                       ; Reserve a certain number of bytes (not cells) or release them.
000943r 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000943r 3                       ; to the beginning of the Dictionary. If n is positive (the most
000943r 3                       ; common case), reserve n bytes, but not past the end of the
000943r 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000943r 3                       ; """
000943r 3               
000943r 3               xt_allot:
000943r 3  20 rr rr                     jsr underflow_1
000946r 3               
000946r 3                               ; Releasing memory is going to be a very rare operation,
000946r 3                               ; so we check for it at the beginning and try to make
000946r 3                               ; the most common case as fast as possible
000946r 3  B5 01                        lda 1,x
000948r 3  30 22                        bmi @release
00094Ar 3               
00094Ar 3                               ; Common case: We are reserving memory, not releasing it
00094Ar 3  18                           clc
00094Br 3  A5 rr                        lda cp
00094Dr 3  75 00                        adc 0,x
00094Fr 3  85 rr                        sta cp
000951r 3               
000951r 3  A5 rr                        lda cp+1
000953r 3  75 01                        adc 1,x
000955r 3  85 rr                        sta cp+1
000957r 3               
000957r 3                               ; Wait, did we just grant more space than we have? This is
000957r 3                               ; a check we only do here, not for other situations like cmpl_a
000957r 3                               ; where smaller amounts are reserved.
000957r 3  A0 FF                        ldy #<cp_end
000959r 3  C4 rr                        cpy cp
00095Br 3  A9 7F                        lda #>cp_end
00095Dr 3  E5 rr                        sbc cp+1
00095Fr 3  B0 48                        bcs @done               ; we're fine.
000961r 3               
000961r 3                               ; Oops, that was too much, we're beyond the end of
000961r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000961r 3                               ; an error
000961r 3  84 rr                        sty cp                  ; still #<cp_end
000963r 3  A9 7F                        lda #>cp_end
000965r 3  85 rr                        sta cp+1
000967r 3               
000967r 3  A9 00                        lda #err_allot
000969r 3  4C rr rr                     jmp error
00096Cr 3               
00096Cr 3               @release:
00096Cr 3                  		; The ANS standard doesn't really say what to do if too much
00096Cr 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
00096Cr 3                               ; even an official test. Gforth is little help either. The good
00096Cr 3                               ; news is, this is going to be a rare case. We want to use as
00096Cr 3                               ; few bytes as possible.
00096Cr 3               
00096Cr 3                               ; What we do is let the user free anything up to the beginning
00096Cr 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
00096Cr 3                               ; their own risk. This means that the Dictionary pointer DP
00096Cr 3                               ; might end up pointing to garbage. However, an attempt to
00096Cr 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
00096Cr 3                               ; the DP pointing to the last word in RAM (should be DROP) and
00096Cr 3                               ; an error message.
00096Cr 3               
00096Cr 3                               ; We arrive here with ( n ) which is negative. First step,
00096Cr 3                               ; subtract the number TOS from the CP for a new CP
00096Cr 3  CA                           dex
00096Dr 3  CA                           dex
00096Er 3  A5 rr                        lda cp
000970r 3  95 00                        sta 0,x
000972r 3  A5 rr                        lda cp+1
000974r 3  95 01                        sta 1,x
000976r 3               
000976r 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000979r 3               
000979r 3                               ; Second step, see if we've gone too far. We compare the new
000979r 3                               ; CP on TOS (which, if we've really screwed up, might be
000979r 3                               ; negative) with CP0. This is a signed comparison
000979r 3  CA                           dex
00097Ar 3  CA                           dex                             ; new CP now NOS
00097Br 3  A9 rr                        lda #<cp0
00097Dr 3  95 00                        sta 0,x
00097Fr 3  A9 rr                        lda #>cp0
000981r 3  95 01                        sta 1,x                         ; CP0 is TOS
000983r 3               
000983r 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000986r 3               
000986r 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000986r 3                               ; This means we want Z=1 or N=1
000986r 3  F0 17                        beq @nega_done
000988r 3  30 15                        bmi @nega_done
00098Ar 3               
00098Ar 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
00098Ar 3                               ; word in ROM (should be DROP), and abort with an error
00098Ar 3  A9 rr                        lda #<cp0
00098Cr 3  85 rr                        sta cp
00098Er 3  A9 rr                        lda #>cp0
000990r 3  85 rr                        sta cp+1
000992r 3               
000992r 3  A9 rr                        lda #<dictionary_start
000994r 3  85 rr                        sta dp
000996r 3  A9 rr                        lda #>dictionary_start
000998r 3  85 rr                        sta dp+1
00099Ar 3               
00099Ar 3  A9 0A                        lda #err_negallot
00099Cr 3  4C rr rr                     jmp error
00099Fr 3               
00099Fr 3               @nega_done:
00099Fr 3                               ; Save new CP, which is NOS
00099Fr 3  B5 02                        lda 2,x
0009A1r 3  85 rr                        sta cp
0009A3r 3  B5 03                        lda 3,x
0009A5r 3  85 rr                        sta cp+1
0009A7r 3               
0009A7r 3  E8                           inx
0009A8r 3  E8                           inx                     ; drop through to @done
0009A9r 3               @done:
0009A9r 3  E8                           inx
0009AAr 3  E8                           inx
0009ABr 3               z_allot:
0009ABr 3  60                           rts
0009ACr 3               
0009ACr 3               
0009ACr 3               
0009ACr 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
0009ACr 3               ; ## "allow-native"  auto  Tali Forth
0009ACr 3               xt_allow_native:
0009ACr 3  20 rr rr                     jsr current_to_dp
0009AFr 3  A0 01                        ldy #1          ; offset for status byte
0009B1r 3  B1 rr                        lda (dp),y
0009B3r 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
0009B5r 3  91 rr                        sta (dp),y
0009B7r 3               z_allow_native:
0009B7r 3  60                           rts
0009B8r 3               
0009B8r 3               
0009B8r 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
0009B8r 3               ; ## "also"  auto  ANS search ext
0009B8r 3                       ; """http://forth-standard.org/standard/search/ALSO"""
0009B8r 3               xt_also:
0009B8r 3  20 rr rr                     jsr xt_get_order
0009BBr 3  20 rr rr                     jsr xt_over
0009BEr 3  20 rr rr                     jsr xt_swap
0009C1r 3  20 rr rr                     jsr xt_one_plus
0009C4r 3  20 rr rr                     jsr xt_set_order
0009C7r 3               
0009C7r 3  60           z_also:         rts
0009C8r 3               
0009C8r 3               
0009C8r 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
0009C8r 3               ; ## "always-native"  auto  Tali Forth
0009C8r 3               xt_always_native:
0009C8r 3  20 rr rr                     jsr current_to_dp
0009CBr 3  A0 01                        ldy #1          ; offset for status byte
0009CDr 3  B1 rr                        lda (dp),y
0009CFr 3  09 02                        ora #AN         ; Make sure AN flag is set
0009D1r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
0009D3r 3  91 rr                        sta (dp),y
0009D5r 3               z_always_native:
0009D5r 3  60                           rts
0009D6r 3               
0009D6r 3               
0009D6r 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
0009D6r 3               ; ## "and"  auto  ANS core
0009D6r 3                       ; """https://forth-standard.org/standard/core/AND"""
0009D6r 3               xt_and:
0009D6r 3  20 rr rr                     jsr underflow_2
0009D9r 3               
0009D9r 3  B5 00                        lda 0,x
0009DBr 3  35 02                        and 2,x
0009DDr 3  95 02                        sta 2,x
0009DFr 3               
0009DFr 3  B5 01                        lda 1,x
0009E1r 3  35 03                        and 3,x
0009E3r 3  95 03                        sta 3,x
0009E5r 3               
0009E5r 3  E8                           inx
0009E6r 3  E8                           inx
0009E7r 3               
0009E7r 3  60           z_and:          rts
0009E8r 3               
0009E8r 3               
0009E8r 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
0009E8r 3               ; ## "assembler-wordlist"  tested  Tali Assembler
0009E8r 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
0009E8r 3                       ; assembler words to the search order so they can be used.
0009E8r 3                       ; See the tutorial on Wordlists and the Search Order for
0009E8r 3                       ; more information.
0009E8r 3                       ;
0009E8r 3                       ; This is a dummy entry, the code is shared with TWO
0009E8r 3                       ; """
0009E8r 3               
0009E8r 3               
0009E8r 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
0009E8r 3               ; ## "at-xy"  tested  ANS facility
0009E8r 3                       ; """https://forth-standard.org/standard/facility/AT-XY
0009E8r 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
0009E8r 3                       ; ANSI code is ESC[<n>;<m>H
0009E8r 3                       ;
0009E8r 3                       ; Do not use U. to print the numbers because the
0009E8r 3                       ; trailing space will not work with xterm
0009E8r 3                       ; """
0009E8r 3               xt_at_xy:
0009E8r 3  20 rr rr                     jsr underflow_2
0009EBr 3               
0009EBr 3  A9 1B                        lda #AscESC
0009EDr 3  20 rr rr                     jsr emit_a
0009F0r 3  A9 5B                        lda #$5B        ; ASCII for "["
0009F2r 3  20 rr rr                     jsr emit_a
0009F5r 3  20 rr rr                     jsr print_u
0009F8r 3  A9 3B                        lda #$3B        ; ASCII for ";"
0009FAr 3  20 rr rr                     jsr emit_a
0009FDr 3  20 rr rr                     jsr print_u
000A00r 3  A9 48                        lda #'H'
000A02r 3  20 rr rr                     jsr emit_a
000A05r 3               
000A05r 3  60           z_at_xy:        rts
000A06r 3               
000A06r 3               
000A06r 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
000A06r 3               ; ## "\"  auto  ANS core ext
000A06r 3                       ; """https://forth-standard.org/standard/core/bs"""
000A06r 3               xt_backslash:
000A06r 3  A5 rr                        lda ciblen
000A08r 3  85 rr                        sta toin
000A0Ar 3  A5 rr                        lda ciblen+1
000A0Cr 3  85 rr                        sta toin+1
000A0Er 3               
000A0Er 3  60           z_backslash:    rts
000A0Fr 3               
000A0Fr 3               
000A0Fr 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000A0Fr 3               ; ## "base"  auto  ANS core
000A0Fr 3                       ; """https://forth-standard.org/standard/core/BASE
000A0Fr 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000A0Fr 3                       ; ingore the MSB
000A0Fr 3                       ; """
000A0Fr 3               xt_base:
000A0Fr 3  CA                           dex
000A10r 3  CA                           dex
000A11r 3  A9 rr                        lda #<base
000A13r 3  95 00                        sta 0,x         ; LSB
000A15r 3  74 01                        stz 1,x         ; MSB is always 0
000A17r 3               
000A17r 3  60           z_base:         rts
000A18r 3               
000A18r 3               
000A18r 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000A18r 3               ; ## "begin"  auto  ANS core
000A18r 3                       ; """https://forth-standard.org/standard/core/BEGIN
000A18r 3                       ;
000A18r 3                       ; This is just an immediate version of here which could just
000A18r 3                       ; as well be coded in Forth as
000A18r 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000A18r 3                       ; Since this is a compiling word, we don't care that much about
000A18r 3                       ; about speed
000A18r 3                       ; """
000A18r 3               
000A18r 3               xt_begin:
000A18r 3  20 rr rr                     jsr xt_here
000A1Br 3  60           z_begin:        rts
000A1Cr 3               
000A1Cr 3               
000A1Cr 3               
000A1Cr 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000A1Cr 3               ; ## "bell"  tested  Tali Forth
000A1Cr 3               xt_bell:
000A1Cr 3  A9 07                        lda #7          ; ASCII value for BELl
000A1Er 3  20 rr rr                     jsr emit_a
000A21r 3               
000A21r 3  60           z_bell:         rts
000A22r 3               
000A22r 3               
000A22r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000A22r 3               ; ## "bl"  auto  ANS core
000A22r 3                       ; """https://forth-standard.org/standard/core/BL"""
000A22r 3               
000A22r 3               xt_bl:
000A22r 3  CA                           dex
000A23r 3  CA                           dex
000A24r 3  A9 20                        lda #AscSP
000A26r 3  95 00                        sta 0,x
000A28r 3  74 01                        stz 1,x
000A2Ar 3               
000A2Ar 3  60           z_bl:           rts
000A2Br 3               
000A2Br 3               
000A2Br 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000A2Br 3               ; ## "block"  auto  ANS block
000A2Br 3                       ; """https://forth-standard.org/standard/block/BLK"""
000A2Br 3               xt_blk:
000A2Br 3                               ; BLK is at UP + blk_offset
000A2Br 3  CA                           dex
000A2Cr 3  CA                           dex
000A2Dr 3  18                           clc
000A2Er 3  A5 rr                        lda up
000A30r 3  69 00                        adc #blk_offset ; Add offset
000A32r 3  95 00                        sta 0,x
000A34r 3  A5 rr                        lda up+1
000A36r 3  69 00                        adc #0          ; Adding carry
000A38r 3  95 01                        sta 1,x
000A3Ar 3               
000A3Ar 3  60           z_blk:          rts
000A3Br 3               
000A3Br 3               
000A3Br 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
000A3Br 3               ; ## "blkbuffer"  auto  Tali block
000A3Br 3               xt_blkbuffer:
000A3Br 3                               ; blkbuffer address is at UP + blkbuffer_offset.
000A3Br 3                               ; Unlike some of the other user variables, we actually
000A3Br 3                               ; want to push the address stored here, which will
000A3Br 3                               ; point to somewhere outside of the user variables.
000A3Br 3  CA                           dex
000A3Cr 3  CA                           dex
000A3Dr 3                               ; Put the address on the stack.
000A3Dr 3  A0 28                        ldy #blkbuffer_offset
000A3Fr 3  B1 rr                        lda (up),y
000A41r 3  95 00                        sta 0,x
000A43r 3  C8                           iny             ; Move along to the next byte
000A44r 3  B1 rr                        lda (up),y
000A46r 3  95 01                        sta 1,x
000A48r 3               
000A48r 3  60           z_blkbuffer:    rts
000A49r 3               
000A49r 3               
000A49r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
000A49r 3               ; ## "block"  auto  ANS block
000A49r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
000A49r 3               
000A49r 3               xt_block:
000A49r 3               
000A49r 3                               ; See if the block requested is the same as the one we
000A49r 3                               ; currently have in the buffer. Check the LSB.
000A49r 3  A0 2A                        ldy #buffblocknum_offset
000A4Br 3  B1 rr                        lda (up),y
000A4Dr 3  D5 00                        cmp 0,x
000A4Fr 3  D0 0F                        bne @not_in_buffer
000A51r 3               
000A51r 3                               ; Check the MSB.
000A51r 3  C8                           iny
000A52r 3  B1 rr                        lda (up),y
000A54r 3  D5 01                        cmp 1,x
000A56r 3  D0 08                        bne @not_in_buffer
000A58r 3               
000A58r 3                               ; The block is in the buffer. See if the buffer is in use.
000A58r 3  A0 2C                        ldy #buffstatus_offset
000A5Ar 3  B1 rr                        lda (up),y
000A5Cr 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000A5Er 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000A60r 3                                               ; @done will replace the block# with the
000A60r 3                                               ; buffer address.
000A60r 3               @not_in_buffer:
000A60r 3                               ; Check the buffer status
000A60r 3  A0 2C                        ldy #buffstatus_offset
000A62r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000A64r 3  C9 03                        cmp #3          ; LSB is needed.
000A66r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000A68r 3               
000A68r 3                               ; We need to save the block.
000A68r 3  20 rr rr                     jsr xt_blkbuffer
000A6Br 3  20 rr rr                     jsr xt_buffblocknum
000A6Er 3  20 rr rr                     jsr xt_fetch
000A71r 3  20 rr rr                     jsr xt_block_write
000A74r 3               
000A74r 3               @buffer_available:
000A74r 3                               ; Save the block number.
000A74r 3  A0 2A                        ldy #buffblocknum_offset
000A76r 3  B5 00                        lda 0,x
000A78r 3  91 rr                        sta (up),y
000A7Ar 3  C8                           iny
000A7Br 3  B5 01                        lda 1,x
000A7Dr 3  91 rr                        sta (up),y
000A7Fr 3               
000A7Fr 3                               ; Get the requested block.
000A7Fr 3  20 rr rr                     jsr xt_blkbuffer
000A82r 3  20 rr rr                     jsr xt_swap
000A85r 3  20 rr rr                     jsr xt_block_read
000A88r 3               
000A88r 3                               ; Mark the buffer as clean and in-use.
000A88r 3  A9 01                        lda #1
000A8Ar 3  A0 2C                        ldy #buffstatus_offset
000A8Cr 3  91 rr                        sta (up),y
000A8Er 3               
000A8Er 3                               ; Make room on the stack for the return address.
000A8Er 3  CA                           dex
000A8Fr 3  CA                           dex
000A90r 3               
000A90r 3               @done:
000A90r 3                               ; It's in the buffer. Return the buffer address.
000A90r 3  A0 28                        ldy #blkbuffer_offset
000A92r 3  B1 rr                        lda (up),y
000A94r 3  95 00                        sta 0,x
000A96r 3  C8                           iny
000A97r 3  B1 rr                        lda (up),y
000A99r 3  95 01                        sta 1,x
000A9Br 3               
000A9Br 3  60           z_block:        rts
000A9Cr 3               
000A9Cr 3               
000A9Cr 3               
000A9Cr 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000A9Cr 3               ; ## "block-ramdrive-init"  auto  Tali block
000A9Cr 3                       ; """Create a RAM drive, with the given number of
000A9Cr 3                       ; blocks, in the dictionary along with setting up the block words to
000A9Cr 3                       ; use it.  The read/write routines do not provide bounds checking.
000A9Cr 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000A9Cr 3                       ; """
000A9Cr 3               
000A9Cr 3               xt_block_ramdrive_init:
000A9Cr 3  20 rr rr                     jsr underflow_1
000A9Fr 3               
000A9Fr 3                               ; Store the string to run here as a string literal.
000A9Fr 3                               ; See SLITERAL for the format information. This way, we
000A9Fr 3                               ; don't have the words defined below in the Dictionary until
000A9Fr 3                               ; we really use them.
000A9Fr 3  4C rr rr                     jmp @after_ramdrive_code
000AA2r 3               
000AA2r 3               @ramdrive_code:
000AA2r 3  62 61 73 65          .byte "base @ swap decimal"
000AA6r 3  20 40 20 73  
000AAAr 3  77 61 70 20  
000AB5r 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000AB9r 3  34 20 2A     
000ABCr 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000AC0r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
000AC4r 3  66 65 72 3A  
000AC8r 3  20 72 61 6D  
000AD1r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000AD1r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
000AD5r 3  6C 6F 63 6B  
000AD9r 3  2D 72 65 61  
000AE7r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000AEBr 3  64 72 69 76  
000AEFr 3  65 20 73 77  
000B0Fr 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000B13r 3  6C 6F 63 6B  
000B17r 3  2D 77 72 69  
000B26r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000B2Ar 3  64 72 69 76  
000B2Er 3  65 20 73 77  
000B49r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000B4Dr 3  6C 6F 63 6B  
000B51r 3  2D 72 65 61  
000B73r 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
000B77r 3  6C 6F 63 6B  
000B7Br 3  2D 77 72 69  
000B9Fr 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000BA3r 3  64 72 69 76  
000BA7r 3  65 20 73 77  
000BBAr 3               
000BBAr 3               @after_ramdrive_code:
000BBAr 3  20 rr rr                     jsr sliteral_runtime
000BBDr 3               
000BBDr 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000BC1r 3               
000BC1r 3                               ; The address and length of the ramdrive code is now on the
000BC1r 3                               ; stack. Call EVALUATE to run it.
000BC1r 3  20 rr rr                     jsr xt_evaluate
000BC4r 3               
000BC4r 3               z_block_ramdrive_init:
000BC4r 3  60                           rts
000BC5r 3               
000BC5r 3               
000BC5r 3               
000BC5r 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
000BC5r 3               ; ## "block-read"  auto  Tali block
000BC5r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000BC5r 3                       ; with their own version to read a block from storage.
000BC5r 3                       ; The stack parameters are ( buffer_address block# -- ).
000BC5r 3                       ; """
000BC5r 3               xt_block_read:
000BC5r 3                               ; Execute the BLOCK-READ-VECTOR
000BC5r 3  A0 2E                        ldy #blockread_offset
000BC7r 3  B1 rr                        lda (up),y
000BC9r 3  85 rr                        sta tmp1
000BCBr 3  C8                           iny
000BCCr 3  B1 rr                        lda (up),y
000BCEr 3  85 rr                        sta tmp1+1
000BD0r 3               
000BD0r 3  6C rr rr                     jmp (tmp1)
000BD3r 3               
000BD3r 3               z_block_read:   ; No RTS needed
000BD3r 3               
000BD3r 3               
000BD3r 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
000BD3r 3               ; ## "block-read-vector"  auto  Tali block
000BD3r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000BD3r 3                       ; with their own version to read a block from storage.
000BD3r 3                       ; This word gives the address of the vector so it can be replaced.
000BD3r 3                       ; """
000BD3r 3               xt_block_read_vector:
000BD3r 3                               ; Get the BLOCK-READ-VECTOR address
000BD3r 3  CA                           dex
000BD4r 3  CA                           dex
000BD5r 3  18                           clc
000BD6r 3  A5 rr                        lda up
000BD8r 3  69 2E                        adc #blockread_offset
000BDAr 3  95 00                        sta 0,x
000BDCr 3  A5 rr                        lda up+1
000BDEr 3  69 00                        adc #0          ; Add carry
000BE0r 3  95 01                        sta 1,x
000BE2r 3               
000BE2r 3               z_block_read_vector:
000BE2r 3  60                           rts
000BE3r 3               
000BE3r 3               
000BE3r 3               ; This is the default error message the vectored words BLOCK-READ and
000BE3r 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
000BE3r 3               xt_block_word_error:
000BE3r 3  A9 0C                        lda #err_blockwords
000BE5r 3  4C rr rr                     jmp error       ; no RTS needed
000BE8r 3               z_block_word_error:
000BE8r 3               
000BE8r 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000BE8r 3               ; ## "block-write"  auto  Tali block
000BE8r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000BE8r 3                       ; with their own version to write a block to storage.
000BE8r 3                       ; The stack parameters are ( buffer_address block# -- ).
000BE8r 3                       ; """
000BE8r 3               xt_block_write:
000BE8r 3                               ; Execute the BLOCK-READ-VECTOR
000BE8r 3  A0 30                        ldy #blockwrite_offset
000BEAr 3  B1 rr                        lda (up),y
000BECr 3  85 rr                        sta tmp1
000BEEr 3  C8                           iny
000BEFr 3  B1 rr                        lda (up),y
000BF1r 3  85 rr                        sta tmp1+1
000BF3r 3  6C rr rr                     jmp (tmp1)
000BF6r 3               
000BF6r 3               z_block_write:  ; No RTS needed
000BF6r 3               
000BF6r 3               
000BF6r 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
000BF6r 3               ; ## "block-write-vector"  auto  Tali block
000BF6r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000BF6r 3                       ; with their own version to write a block to storage.
000BF6r 3                       ; This word gives the address of the vector so it can be replaced.
000BF6r 3                       ; """
000BF6r 3               xt_block_write_vector:
000BF6r 3                               ; Get the BLOCK-WRITE-VECTOR address
000BF6r 3  CA                           dex
000BF7r 3  CA                           dex
000BF8r 3  18                           clc
000BF9r 3  A5 rr                        lda up
000BFBr 3  69 30                        adc #blockwrite_offset
000BFDr 3  95 00                        sta 0,x
000BFFr 3  A5 rr                        lda up+1
000C01r 3  69 00                        adc #0          ; Add carry
000C03r 3  95 01                        sta 1,x
000C05r 3               
000C05r 3               z_block_write_vector:
000C05r 3  60                           rts
000C06r 3               
000C06r 3               
000C06r 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
000C06r 3               ; ## "bounds"  auto  Gforth
000C06r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
000C06r 3                       ; Given a string, return the correct Data Stack parameters for
000C06r 3                       ; a DO/LOOP loop over its characters. This is realized as
000C06r 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
000C06r 3                       ; """
000C06r 3               xt_bounds:
000C06r 3  20 rr rr                     jsr underflow_2
000C09r 3               
000C09r 3  18                           clc
000C0Ar 3  B5 00                        lda 0,x                 ; LSB u
000C0Cr 3  B4 02                        ldy 2,x                 ; LSB addr
000C0Er 3  75 02                        adc 2,x
000C10r 3  95 02                        sta 2,x                 ; LSB addr+u
000C12r 3  94 00                        sty 0,x
000C14r 3               
000C14r 3  B5 01                        lda 1,x                 ; MSB u
000C16r 3  B4 03                        ldy 3,x                 ; MSB addr
000C18r 3  75 03                        adc 3,x
000C1Ar 3  95 03                        sta 3,x                 ; MSB addr+u
000C1Cr 3  94 01                        sty 1,x
000C1Er 3               
000C1Er 3  60           z_bounds:       rts
000C1Fr 3               
000C1Fr 3               
000C1Fr 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000C1Fr 3               ; ## "[char]"  auto  ANS core
000C1Fr 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000C1Fr 3                       ; Compile the ASCII value of a character as a literal. This is an
000C1Fr 3                       ; immediate, compile-only word.
000C1Fr 3                       ;
000C1Fr 3                       ; A definition given in
000C1Fr 3                       ; http://forth-standard.org/standard/implement is
000C1Fr 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000C1Fr 3                       ; """
000C1Fr 3               xt_bracket_char:
000C1Fr 3  20 rr rr                     jsr xt_char
000C22r 3  20 rr rr                     jsr xt_literal
000C25r 3  60           z_bracket_char: rts
000C26r 3               
000C26r 3               
000C26r 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000C26r 3               ; ## "[']"  auto  ANS core
000C26r 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000C26r 3               xt_bracket_tick:
000C26r 3  20 rr rr                     jsr xt_tick
000C29r 3  20 rr rr                     jsr xt_literal
000C2Cr 3  60           z_bracket_tick: rts
000C2Dr 3               
000C2Dr 3               
000C2Dr 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000C2Dr 3               ; ## "buffblocknum"  auto  Tali block
000C2Dr 3               xt_buffblocknum:
000C2Dr 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000C2Dr 3  CA                           dex
000C2Er 3  CA                           dex
000C2Fr 3  18                           clc
000C30r 3  A5 rr                        lda up
000C32r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000C34r 3  95 00                        sta 0,x
000C36r 3  A5 rr                        lda up+1
000C38r 3  69 00                        adc #0                          ; Adding carry
000C3Ar 3  95 01                        sta 1,x
000C3Cr 3               
000C3Cr 3  60           z_buffblocknum: rts
000C3Dr 3               
000C3Dr 3               
000C3Dr 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000C3Dr 3               ; ## "buffer"  auto  ANS block
000C3Dr 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000C3Dr 3               
000C3Dr 3               xt_buffer:
000C3Dr 3                               ; Check the buffer status
000C3Dr 3  A0 2C                        ldy #buffstatus_offset
000C3Fr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000C41r 3  C9 03                        cmp #3          ; LSB is needed.
000C43r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000C45r 3               
000C45r 3                               ; We need to save the block.
000C45r 3  20 rr rr                     jsr xt_blkbuffer
000C48r 3  20 rr rr                     jsr xt_buffblocknum
000C4Br 3  20 rr rr                     jsr xt_fetch
000C4Er 3  20 rr rr                     jsr xt_block_write
000C51r 3               
000C51r 3               @buffer_available:
000C51r 3                               ; Save the block number.
000C51r 3  A0 2A                        ldy #buffblocknum_offset
000C53r 3  B5 00                        lda 0,x
000C55r 3  91 rr                        sta (up),y
000C57r 3  C8                           iny
000C58r 3  B5 01                        lda 1,x
000C5Ar 3  91 rr                        sta (up),y
000C5Cr 3               
000C5Cr 3                               ; Mark the buffer as clean and in-use.
000C5Cr 3  A9 01                        lda #1
000C5Er 3  A0 2C                        ldy #buffstatus_offset
000C60r 3  91 rr                        sta (up),y
000C62r 3               
000C62r 3               @done:
000C62r 3                               ; Return the buffer address.
000C62r 3  A0 28                        ldy #blkbuffer_offset
000C64r 3  B1 rr                        lda (up),y
000C66r 3  95 00                        sta 0,x
000C68r 3  C8                           iny
000C69r 3  B1 rr                        lda (up),y
000C6Br 3  95 01                        sta 1,x
000C6Dr 3               
000C6Dr 3  60           z_buffer:       rts
000C6Er 3               
000C6Er 3               
000C6Er 3               
000C6Er 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
000C6Er 3               ; ## "buffer:"  auto  ANS core ext
000C6Er 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
000C6Er 3                               ; Create a buffer of size u that puts its address on the stack
000C6Er 3                               ; when its name is used.
000C6Er 3                               ; """
000C6Er 3               xt_buffer_colon:
000C6Er 3  20 rr rr                     jsr xt_create
000C71r 3  20 rr rr                     jsr xt_allot
000C74r 3  60           z_buffer_colon: rts
000C75r 3               
000C75r 3               
000C75r 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
000C75r 3               ; ## "buffstatus"  auto  Tali block
000C75r 3               xt_buffstatus:
000C75r 3                               ; BUFFSTATUS is at UP + buffstatus_offset
000C75r 3  CA                           dex
000C76r 3  CA                           dex
000C77r 3  18                           clc
000C78r 3  A5 rr                        lda up
000C7Ar 3  69 2C                        adc #buffstatus_offset  ; Add offset
000C7Cr 3  95 00                        sta 0,x
000C7Er 3  A5 rr                        lda up+1
000C80r 3  69 00                        adc #0                  ; Adding carry
000C82r 3  95 01                        sta 1,x
000C84r 3               
000C84r 3  60           z_buffstatus:   rts
000C85r 3               
000C85r 3               
000C85r 3               ; ## BYE ( -- ) "Break"
000C85r 3               ; ## "bye"  tested  ANS tools ext
000C85r 3                       ; """https://forth-standard.org/standard/tools/BYE"""
000C85r 3               
000C85r 3               xt_bye:
000C85r 3                               ;brk
000C85r 3  4C rr rr                     jmp platform_bye
000C88r 3               z_bye:          ;rts             ; never reached
000C88r 3               
000C88r 3               
000C88r 3               
000C88r 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
000C88r 3               ; ## "c,"  auto  ANS core
000C88r 3                       ; """https://forth-standard.org/standard/core/CComma"""
000C88r 3               
000C88r 3               xt_c_comma:
000C88r 3  20 rr rr                     jsr underflow_1
000C8Br 3               
000C8Br 3  B5 00                        lda 0,x
000C8Dr 3  20 rr rr                     jsr cmpl_a
000C90r 3               
000C90r 3  E8                           inx
000C91r 3  E8                           inx
000C92r 3               
000C92r 3  60           z_c_comma:      rts
000C93r 3               
000C93r 3               
000C93r 3               
000C93r 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
000C93r 3               ; ## "c@"  auto  ANS core
000C93r 3                       ; """https://forth-standard.org/standard/core/CFetch"""
000C93r 3               xt_c_fetch:
000C93r 3  20 rr rr                     jsr underflow_1
000C96r 3               
000C96r 3  A1 00                        lda (0,x)
000C98r 3  95 00                        sta 0,x
000C9Ar 3  74 01                        stz 1,x         ; Ignore LSB
000C9Cr 3               
000C9Cr 3  60           z_c_fetch:      rts
000C9Dr 3               
000C9Dr 3               
000C9Dr 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000C9Dr 3               ; ## "c!"  auto  ANS core
000C9Dr 3                       ; """https://forth-standard.org/standard/core/CStore"""
000C9Dr 3               xt_c_store:
000C9Dr 3  20 rr rr                     jsr underflow_2
000CA0r 3               
000CA0r 3  B5 02                        lda 2,x
000CA2r 3  81 00                        sta (0,x)
000CA4r 3               
000CA4r 3  E8                           inx
000CA5r 3  E8                           inx
000CA6r 3  E8                           inx
000CA7r 3  E8                           inx
000CA8r 3               
000CA8r 3  60           z_c_store:      rts
000CA9r 3               
000CA9r 3               
000CA9r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000CA9r 3               ; ## "case"  auto  ANS core ext
000CA9r 3                       ; """http://forth-standard.org/standard/core/CASE
000CA9r 3                       ;
000CA9r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000CA9r 3                       ; """
000CA9r 3               
000CA9r 3               
000CA9r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000CA9r 3               ; ## "cell+"  auto  ANS core
000CA9r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000CA9r 3                       ; Add the number of bytes ("address units") that one cell needs.
000CA9r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000CA9r 3                       ; """
000CA9r 3               
000CA9r 3               xt_cell_plus:
000CA9r 3  20 rr rr                     jsr underflow_1
000CACr 3               
000CACr 3  F6 00                        inc 0,x
000CAEr 3  D0 02                        bne @1
000CB0r 3  F6 01                        inc 1,x
000CB2r 3               @1:
000CB2r 3  F6 00                        inc 0,x
000CB4r 3  D0 02                        bne @done
000CB6r 3  F6 01                        inc 1,x
000CB8r 3               @done:
000CB8r 3  60           z_cell_plus:    rts
000CB9r 3               
000CB9r 3               
000CB9r 3               
000CB9r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000CB9r 3               ; ## "cells"  auto  ANS core
000CB9r 3                       ; """https://forth-standard.org/standard/core/CELLS
000CB9r 3                       ;
000CB9r 3                       ; Dummy entry for the CELLS word, the code is the same as for
000CB9r 3                       ; 2*, which is where the header directs us to
000CB9r 3                       ; """
000CB9r 3               
000CB9r 3               
000CB9r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000CB9r 3               ; ## "char"  auto  ANS core
000CB9r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000CB9r 3               
000CB9r 3               xt_char:
000CB9r 3                               ; get character from string, returns ( addr u )
000CB9r 3  20 rr rr                     jsr xt_parse_name
000CBCr 3               
000CBCr 3                               ; if we got back a zero, we have a problem
000CBCr 3  B5 00                        lda 0,x
000CBEr 3  15 01                        ora 1,x
000CC0r 3  D0 05                        bne @not_empty
000CC2r 3               
000CC2r 3  A9 05                        lda #err_noname
000CC4r 3  4C rr rr                     jmp error
000CC7r 3               
000CC7r 3               @not_empty:
000CC7r 3  E8                           inx             ; drop number of characters, leave addr
000CC8r 3  E8                           inx
000CC9r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000CCBr 3  95 00                        sta 0,x
000CCDr 3  74 01                        stz 1,x         ; MSB is always zero
000CCFr 3               
000CCFr 3  60           z_char:         rts
000CD0r 3               
000CD0r 3               
000CD0r 3               
000CD0r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000CD0r 3               ; ## "char+"  auto  ANS core
000CD0r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000CD0r 3                       ;
000CD0r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000CD0r 3                       ; """
000CD0r 3               
000CD0r 3               
000CD0r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000CD0r 3               ; ## "chars"  auto  ANS core
000CD0r 3                       ; """https://forth-standard.org/standard/core/CHARS
000CD0r 3                       ; Return how many address units n chars are. Since this is an 8 bit
000CD0r 3                       ; machine, this does absolutely nothing and is included for
000CD0r 3                       ; compatibility with other Forth versions
000CD0r 3                       ; """
000CD0r 3               
000CD0r 3               xt_chars:
000CD0r 3                               ; Checking for underflow seems a bit stupid because this
000CD0r 3                               ; routine does nothing on this machine. However, the user
000CD0r 3                               ; should be warned that there is something wrong with the
000CD0r 3                               ; code if this occurs.
000CD0r 3  20 rr rr                     jsr underflow_1
000CD3r 3               
000CD3r 3  60           z_chars:        rts
000CD4r 3               
000CD4r 3               
000CD4r 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
000CD4r 3               ; ## "cleave"  auto  Tali Forth
000CD4r 3               
000CD4r 3                       ; """Given a range of memory with words delimited by whitespace,return
000CD4r 3                       ; the first word at the top of the stack and the rest of the word
000CD4r 3                       ; following it.
000CD4r 3                       ;
000CD4r 3                       ; Example:
000CD4r 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
000CD4r 3                       ; s" w1" cleave        -> "" "w1"
000CD4r 3                       ;
000CD4r 3                       ; Since it will be used in loops a lot, we want it to work in pure
000CD4r 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
000CD4r 3                       ; strip leading delimiters.
000CD4r 3                       ; """
000CD4r 3               
000CD4r 3               xt_cleave:
000CD4r 3  20 rr rr                     jsr underflow_2
000CD7r 3               
000CD7r 3                               ; We arrive here with ( addr u ). We need to strip any leading
000CD7r 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
000CD7r 3                               ; remember how many spaces were stripped. This means we can't
000CD7r 3                               ; calculate the length of the remainder. Fortunately, Tali
000CD7r 3                               ; Forth has just the word we need for this:
000CD7r 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000CDAr 3               
000CDAr 3                               ; The main part we can turn over to PARSE-NAME, except that we
000CDAr 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000CDAr 3                               ; We get around this by cheating: We place ( addr u ) in the
000CDAr 3                               ; input buffer and then call PARSE-NAME.
000CDAr 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000CDDr 3               
000CDDr 3  B5 00                        lda 0,x         ; u is new ciblen
000CDFr 3  85 rr                        sta ciblen
000CE1r 3  B5 01                        lda 1,x
000CE3r 3  85 rr                        sta ciblen+1
000CE5r 3               
000CE5r 3  B5 02                        lda 2,x         ; addr is new cib
000CE7r 3  85 rr                        sta cib
000CE9r 3  B5 03                        lda 3,x
000CEBr 3  85 rr                        sta cib+1
000CEDr 3               
000CEDr 3  64 rr                        stz toin        ; >IN pointer is zero
000CEFr 3  64 rr                        stz toin+1
000CF1r 3               
000CF1r 3                               ; PARSE-NAME gives us back the substring of the first word
000CF1r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
000CF4r 3               
000CF4r 3                               ; If we were given an empty string, then we're done. It's the
000CF4r 3                               ; resposibility of the user to catch this as a sign to end the
000CF4r 3                               ; any loop
000CF4r 3  B5 00                        lda 0,x
000CF6r 3  15 01                        ora 1,x
000CF8r 3  F0 23                        beq @done
000CFAr 3               
000CFAr 3                               ; Now we have to adjust the original string
000CFAr 3  B5 04                        lda 4,x         ; LSB of original u
000CFCr 3  38                           sec
000CFDr 3  F5 00                        sbc 0,x
000CFFr 3  95 04                        sta 4,x
000D01r 3               
000D01r 3  B5 05                        lda 5,x         ; MSB of original u
000D03r 3  F5 01                        sbc 1,x
000D05r 3  95 05                        sta 5,x
000D07r 3               
000D07r 3  B5 06                        lda 6,x         ; LSB of original addr
000D09r 3  18                           clc
000D0Ar 3  75 00                        adc 0,x
000D0Cr 3  95 06                        sta 6,x
000D0Er 3               
000D0Er 3  B5 07                        lda 7,x         ; MSB of original addr
000D10r 3  75 01                        adc 1,x
000D12r 3  95 07                        sta 7,x
000D14r 3               
000D14r 3                               ; There is one small problem: PARSE-NAME will probably have
000D14r 3                               ; left the string with the rest of the words with leading
000D14r 3                               ; delimiters. We use our magic -LEADING again
000D14r 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
000D17r 3  20 rr rr                     jsr xt_minus_leading
000D1Ar 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000D1Dr 3               @done:
000D1Dr 3                               ; Restore input
000D1Dr 3  20 rr rr                     jsr xt_r_to_input
000D20r 3               
000D20r 3  60           z_cleave:       rts
000D21r 3               
000D21r 3               
000D21r 3               
000D21r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000D21r 3               ; ## "cmove"  auto  ANS string
000D21r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000D21r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000D21r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000D21r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000D21r 3                       ; "move left".
000D21r 3                       ;
000D21r 3                       ; There are no official tests for this word.
000D21r 3                       ; """
000D21r 3               
000D21r 3               xt_cmove:
000D21r 3  20 rr rr                     jsr underflow_3
000D24r 3               
000D24r 3                               ; move destination address to where we can work with it
000D24r 3  B5 02                        lda 2,x
000D26r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000D28r 3  B5 03                        lda 3,x
000D2Ar 3  85 rr                        sta tmp2+1
000D2Cr 3               
000D2Cr 3                               ; move source address to where we can work with it
000D2Cr 3  B5 04                        lda 4,x
000D2Er 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000D30r 3  B5 05                        lda 5,x
000D32r 3  85 rr                        sta tmp1+1
000D34r 3               
000D34r 3  A0 00                        ldy #0
000D36r 3  B5 01                        lda 1,x         ; number of whole pages to move
000D38r 3  F0 0F                        beq @dopartial
000D3Ar 3               
000D3Ar 3               @page:
000D3Ar 3  B1 rr                        lda (tmp1),y
000D3Cr 3  91 rr                        sta (tmp2),y
000D3Er 3  C8                           iny
000D3Fr 3  D0 F9                        bne @page
000D41r 3               
000D41r 3  E6 rr                        inc tmp1+1
000D43r 3  E6 rr                        inc tmp2+1
000D45r 3  D6 01                        dec 1,x
000D47r 3  D0 F1                        bne @page
000D49r 3               
000D49r 3               @dopartial:
000D49r 3  B5 00                        lda 0,x         ; length of last page
000D4Br 3  F0 09                        beq @done
000D4Dr 3               
000D4Dr 3               @partial:
000D4Dr 3  B1 rr                        lda (tmp1),y
000D4Fr 3  91 rr                        sta (tmp2),y
000D51r 3  C8                           iny
000D52r 3               
000D52r 3  D6 00                        dec 0,x
000D54r 3  D0 F7                        bne @partial
000D56r 3               
000D56r 3               @done:          ; clear the stack
000D56r 3  8A                           txa
000D57r 3  18                           clc
000D58r 3  69 06                        adc #6
000D5Ar 3  AA                           tax
000D5Br 3               
000D5Br 3  60           z_cmove:        rts
000D5Cr 3               
000D5Cr 3               
000D5Cr 3               
000D5Cr 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
000D5Cr 3               ; ## "cmove>"  auto  ANS string
000D5Cr 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
000D5Cr 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
000D5Cr 3                       ; Routines", p. 201, where it is called "move right".
000D5Cr 3                       ;
000D5Cr 3                       ; There are no official tests for this word.
000D5Cr 3                       ; """
000D5Cr 3               
000D5Cr 3               xt_cmove_up:
000D5Cr 3  20 rr rr                     jsr underflow_3
000D5Fr 3               
000D5Fr 3                               ; Move destination address to where we can work with it
000D5Fr 3  B5 02                        lda 2,x
000D61r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000D63r 3  B5 03                        lda 3,x
000D65r 3  18                           clc
000D66r 3  75 01                        adc 1,x
000D68r 3  85 rr                        sta tmp2+1      ; point to last page of destination
000D6Ar 3               
000D6Ar 3                               ; Move source address to where we can work with it
000D6Ar 3  B5 04                        lda 4,x
000D6Cr 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000D6Er 3  B5 05                        lda 5,x
000D70r 3  18                           clc
000D71r 3  75 01                        adc 1,x
000D73r 3  85 rr                        sta tmp1+1      ; point to last page of source
000D75r 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
000D77r 3               
000D77r 3                               ; Move the last partial page first
000D77r 3  B4 00                        ldy 0,x         ; length of last page
000D79r 3  F0 0E                        beq @nopartial
000D7Br 3               
000D7Br 3               @outerloop:
000D7Br 3  88                           dey
000D7Cr 3  F0 07                        beq @finishpage
000D7Er 3               
000D7Er 3               @innerloop:
000D7Er 3  B1 rr                        lda (tmp1),y
000D80r 3  91 rr                        sta (tmp2),y
000D82r 3  88                           dey
000D83r 3  D0 F9                        bne @innerloop
000D85r 3               
000D85r 3               @finishpage:
000D85r 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
000D87r 3  92 rr                        sta (tmp2)
000D89r 3               
000D89r 3               @nopartial:
000D89r 3  C6 rr                        dec tmp1+1      ; back up to previous pages
000D8Br 3  C6 rr                        dec tmp2+1
000D8Dr 3  D6 01                        dec 1,x
000D8Fr 3  D0 EA                        bne @outerloop
000D91r 3               @done:
000D91r 3                               ; clear up the stack and leave
000D91r 3  8A                           txa
000D92r 3  18                           clc
000D93r 3  69 06                        adc #6
000D95r 3  AA                           tax
000D96r 3               
000D96r 3  60           z_cmove_up:     rts
000D97r 3               
000D97r 3               
000D97r 3               
000D97r 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
000D97r 3               ; ## ":"  auto  ANS core
000D97r 3                       ; """https://forth-standard.org/standard/core/Colon
000D97r 3                       ;
000D97r 3                       ; Use the CREATE routine and fill in the rest by hand.
000D97r 3                       ; """
000D97r 3               
000D97r 3               xt_colon:
000D97r 3                               ; If we're already in the compile state, complain
000D97r 3                               ; and quit
000D97r 3  A5 rr                        lda state
000D99r 3  05 rr                        ora state+1
000D9Br 3  F0 05                        beq @1
000D9Dr 3               
000D9Dr 3  A9 07                        lda #err_state
000D9Fr 3  4C rr rr                     jmp error
000DA2r 3               @1:
000DA2r 3                               ; switch to compile state
000DA2r 3  C6 rr                        dec state
000DA4r 3  C6 rr                        dec state+1
000DA6r 3               
000DA6r 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
000DA6r 3                               ; word
000DA6r 3  A9 40                        lda #%01000000
000DA8r 3  04 rr                        tsb status
000DAAr 3               
000DAAr 3                               ; CREATE is going to change the DP to point to the new word's
000DAAr 3                               ; header. While this is fine for (say) variables, it would mean
000DAAr 3                               ; that FIND-NAME etc would find a half-finished word when
000DAAr 3                               ; looking in the Dictionary. To prevent this, we save the old
000DAAr 3                               ; version of DP and restore it later. The new DP is placed in
000DAAr 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000DAAr 3  20 rr rr                     jsr current_to_dp
000DADr 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
000DAFr 3  48                           pha
000DB0r 3  A5 rr                        lda dp
000DB2r 3  48                           pha
000DB3r 3               
000DB3r 3                               ; Tell create not to print warning for duplicate name.
000DB3r 3  A9 80                        lda #%10000000
000DB5r 3  04 rr                        tsb status
000DB7r 3               
000DB7r 3  20 rr rr                     jsr xt_create
000DBAr 3               
000DBAr 3                               ; Get the nt (not the xt!) of the new word as described above.
000DBAr 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000DBAr 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000DBDr 3  A5 rr                        lda dp
000DBFr 3  85 rr                        sta workword
000DC1r 3  A5 rr                        lda dp+1
000DC3r 3  85 rr                        sta workword+1
000DC5r 3               
000DC5r 3                               ; Restore original DP
000DC5r 3  68                           pla
000DC6r 3  85 rr                        sta dp
000DC8r 3  68                           pla
000DC9r 3  85 rr                        sta dp+1
000DCBr 3  20 rr rr                     jsr dp_to_current
000DCEr 3               
000DCEr 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000DCEr 3                               ; back up three bytes and overwrite that.
000DCEr 3  A5 rr                        lda cp
000DD0r 3  38                           sec
000DD1r 3  E9 03                        sbc #3
000DD3r 3  85 rr                        sta cp
000DD5r 3  B0 02                        bcs @done
000DD7r 3  C6 rr                        dec cp+1
000DD9r 3               @done:
000DD9r 3  60           z_colon:        rts
000DDAr 3               
000DDAr 3               
000DDAr 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000DDAr 3               ; ## ":NONAME"  auto  ANS core
000DDAr 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000DDAr 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000DDAr 3                       ; """
000DDAr 3               
000DDAr 3               xt_colon_noname:
000DDAr 3                               ; If we're already in the compile state, complain
000DDAr 3                               ; and quit
000DDAr 3  A5 rr                        lda state
000DDCr 3  05 rr                        ora state+1
000DDEr 3  F0 05                        beq @1
000DE0r 3               
000DE0r 3  A9 07                        lda #err_state
000DE2r 3  4C rr rr                     jmp error
000DE5r 3               @1:
000DE5r 3                               ; switch to compile state
000DE5r 3  C6 rr                        dec state
000DE7r 3  C6 rr                        dec state+1
000DE9r 3               
000DE9r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000DE9r 3                               ; a :NONAME word.
000DE9r 3  A9 40                        lda #%01000000
000DEBr 3  14 rr                        trb status
000DEDr 3               
000DEDr 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000DEDr 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000DEDr 3                               ; nt and they will modify their behavior.
000DEDr 3  A5 rr                        lda cp
000DEFr 3  85 rr                        sta workword
000DF1r 3  A5 rr                        lda cp+1
000DF3r 3  85 rr                        sta workword+1
000DF5r 3               @done:
000DF5r 3  60           z_colon_noname:        rts
000DF6r 3               
000DF6r 3               
000DF6r 3               
000DF6r 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
000DF6r 3               ; ## ","  auto  ANS core
000DF6r 3                       ; """https://forth-standard.org/standard/core/Comma
000DF6r 3                       ; Store TOS at current place in memory.
000DF6r 3                       ;
000DF6r 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
000DF6r 3                       ; """
000DF6r 3               
000DF6r 3               xt_comma:
000DF6r 3  20 rr rr                     jsr underflow_1
000DF9r 3               
000DF9r 3  B5 00                        lda 0,x
000DFBr 3  92 rr                        sta (cp)
000DFDr 3               
000DFDr 3  E6 rr                        inc cp
000DFFr 3  D0 02                        bne @1
000E01r 3  E6 rr                        inc cp+1
000E03r 3               @1:
000E03r 3  B5 01                        lda 1,x
000E05r 3  92 rr                        sta (cp)
000E07r 3               
000E07r 3  E6 rr                        inc cp
000E09r 3  D0 02                        bne @done
000E0Br 3  E6 rr                        inc cp+1
000E0Dr 3               @done:
000E0Dr 3  E8                           inx
000E0Er 3  E8                           inx
000E0Fr 3               
000E0Fr 3  60           z_comma:        rts
000E10r 3               
000E10r 3               
000E10r 3               
000E10r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000E10r 3               ; ## "compare"   auto  ANS string
000E10r 3                       ; """https://forth-standard.org/standard/string/COMPARE
000E10r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000E10r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000E10r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000E10r 3                       ; that entirely matches the beginning of the other string, but is
000E10r 3                       ; shorter, is considered less than the longer string.
000E10r 3                       ; """
000E10r 3               
000E10r 3               xt_compare:
000E10r 3  20 rr rr                     jsr underflow_4
000E13r 3               
000E13r 3                               ; Load the two string addresses into tmp1 and tmp2.
000E13r 3  B5 02                        lda 2,x
000E15r 3  85 rr                        sta tmp2
000E17r 3  B5 03                        lda 3,x
000E19r 3  85 rr                        sta tmp2+1
000E1Br 3  B5 06                        lda 6,x
000E1Dr 3  85 rr                        sta tmp1
000E1Fr 3  B5 07                        lda 7,x
000E21r 3  85 rr                        sta tmp1+1
000E23r 3                               ; The counts will be used in-place on the stack.
000E23r 3               
000E23r 3               @compare_loop:
000E23r 3                               ; Check to see if we are out of letters.
000E23r 3               
000E23r 3                               ; Check string1
000E23r 3  B5 04                        lda 4,x
000E25r 3  15 05                        ora 5,x
000E27r 3  F0 2C                        beq @str1_done
000E29r 3               
000E29r 3                               ; Check string2
000E29r 3  B5 00                        lda 0,x
000E2Br 3  15 01                        ora 1,x
000E2Dr 3  F0 3A                        beq @greater    ; Str2 empty first
000E2Fr 3               
000E2Fr 3               @check_letter:
000E2Fr 3                               ; Both strings have at least one letter left.
000E2Fr 3                               ; Check the letters against each other.
000E2Fr 3  B2 rr                        lda (tmp1)
000E31r 3  D2 rr                        cmp (tmp2)
000E33r 3  90 26                        bcc @less
000E35r 3  D0 32                        bne @greater
000E37r 3               @next_letter:
000E37r 3                               ; Move both tmp pointers and decrement the counts
000E37r 3                               ; on the stack.
000E37r 3                               ; Increment tmp1
000E37r 3  E6 rr                        inc tmp1
000E39r 3  D0 02                        bne @1
000E3Br 3  E6 rr                        inc tmp1+1
000E3Dr 3               @1:
000E3Dr 3                               ; Increment tmp2
000E3Dr 3  E6 rr                        inc tmp2
000E3Fr 3  D0 02                        bne @2
000E41r 3  E6 rr                        inc tmp2+1
000E43r 3               @2:
000E43r 3                               ; Decrement count1 on the stack.
000E43r 3  B5 04                        lda 4,x
000E45r 3  D0 02                        bne @3
000E47r 3  D6 05                        dec 5,x
000E49r 3               @3:
000E49r 3  D6 04                        dec 4,x
000E4Br 3               
000E4Br 3                               ; Decrement count2 on the stack.
000E4Br 3  B5 00                        lda 0,x
000E4Dr 3  D0 02                        bne @4
000E4Fr 3  D6 01                        dec 1,x
000E51r 3               @4:
000E51r 3  D6 00                        dec 0,x
000E53r 3               
000E53r 3                               ; Loop around and check again.
000E53r 3  80 CE                        bra @compare_loop
000E55r 3               
000E55r 3               @str1_done:
000E55r 3                               ; String 1 is out of letters. Check string 2.
000E55r 3  B5 00                        lda 0,x
000E57r 3  15 01                        ora 1,x
000E59r 3  F0 08                        beq @equal      ; Both out of letters
000E5Br 3               
000E5Br 3                               ; Falls into less (str1 is out but str2 has more)
000E5Br 3               @less:
000E5Br 3                               ; Return -1
000E5Br 3  A9 FF                        lda #$FF
000E5Dr 3  95 06                        sta 6,x
000E5Fr 3  95 07                        sta 7,x
000E61r 3  80 0C                        bra @done
000E63r 3               @equal:
000E63r 3                               ; Return 0
000E63r 3  74 06                        stz 6,x
000E65r 3  74 07                        stz 7,x
000E67r 3  80 06                        bra @done
000E69r 3               @greater:
000E69r 3                               ; Return 1
000E69r 3  A9 01                        lda #1
000E6Br 3  95 06                        sta 6,x
000E6Dr 3  74 07                        stz 7,x
000E6Fr 3                               ; Falls into @done
000E6Fr 3               @done:
000E6Fr 3                               ; Remove all but the result from the stack.
000E6Fr 3  8A                           txa
000E70r 3  18                           clc
000E71r 3  69 06                        adc #6
000E73r 3  AA                           tax
000E74r 3               
000E74r 3  60           z_compare:      rts
000E75r 3               
000E75r 3               
000E75r 3               
000E75r 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
000E75r 3               ; ## "compile,"  auto  ANS core ext
000E75r 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
000E75r 3                       ; Compile the given xt in the current word definition. It is an
000E75r 3                       ; error if we are not in the compile state. Because we are using
000E75r 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
000E75r 3                       ; the traditional way. By default, native compiled is allowed, unless
000E75r 3                       ; there is a NN (Never Native) flag associated. If not, we use the
000E75r 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
000E75r 3                       ; is too large to be natively coded: If the size is larger than
000E75r 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
000E75r 3                       ; Native) flag is set, the word is always natively compiled.
000E75r 3                       ; """
000E75r 3               
000E75r 3               xt_compile_comma:
000E75r 3  20 rr rr                     jsr underflow_1
000E78r 3               
000E78r 3                               ; See if this is an Always Native (AN) word by checking the
000E78r 3                               ; AN flag. We need nt for this. First, save a copy of xt to
000E78r 3                               ; the Return Stack
000E78r 3  B5 01                        lda 1,x                 ; MSB
000E7Ar 3  48                           pha
000E7Br 3  B5 00                        lda 0,x
000E7Dr 3  48                           pha                     ; LSB
000E7Er 3               
000E7Er 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
000E81r 3               
000E81r 3                               ; See if this xt even has an nt.
000E81r 3  B5 00                        lda 0,x
000E83r 3  15 01                        ora 1,x
000E85r 3  D0 03                        bne @check_nt
000E87r 3               
000E87r 3                               ; No nt in dictionary. Just compile as a JSR.
000E87r 3  4C rr rr                     jmp @compile_as_jump
000E8Ar 3               
000E8Ar 3               @check_nt:
000E8Ar 3                               ; put nt away for safe keeping
000E8Ar 3  B5 00                        lda 0,x
000E8Cr 3  85 rr                        sta tmptos
000E8Er 3  B5 01                        lda 1,x
000E90r 3  85 rr                        sta tmptos+1
000E92r 3               
000E92r 3                               ; status byte is one further down
000E92r 3  F6 00                        inc 0,x
000E94r 3  D0 02                        bne @1
000E96r 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
000E98r 3               @1:
000E98r 3  A1 00                        lda (0,x)
000E9Ar 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
000E9Cr 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
000E9Er 3  F0 0D                        beq @compile_check
000EA0r 3               
000EA0r 3                               ; We're natively compiling no matter what. Get length and
000EA0r 3                               ; compile in code. Get the original nt back
000EA0r 3  A5 rr                        lda tmptos
000EA2r 3  95 00                        sta 0,x
000EA4r 3  A5 rr                        lda tmptos+1
000EA6r 3  95 01                        sta 1,x
000EA8r 3               
000EA8r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000EABr 3               
000EABr 3  80 27                        bra @compile_as_code
000EADr 3               
000EADr 3               @compile_check:
000EADr 3                               ; See if Native Compile is even alowed by checking the NN
000EADr 3                               ; flag
000EADr 3  A5 rr                        lda tmp3
000EAFr 3  29 08                        and #NN
000EB1r 3  F0 03                        beq @check_size_limit
000EB3r 3               
000EB3r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000EB6r 3               
000EB6r 3               @check_size_limit:
000EB6r 3                               ; Native compile is a legal option, but we need to see what
000EB6r 3                               ; limit the user set for size (in nc_limit)
000EB6r 3  A5 rr                        lda tmptos
000EB8r 3  95 00                        sta 0,x
000EBAr 3  A5 rr                        lda tmptos+1
000EBCr 3  95 01                        sta 1,x
000EBEr 3               
000EBEr 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000EC1r 3               
000EC1r 3                               ; Check the wordsize MSB against the user-defined limit.
000EC1r 3  B5 01                        lda 1,x
000EC3r 3  C5 rr                        cmp nc_limit+1
000EC5r 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
000EC7r 3  D0 08                        bne @jumpto_compile_as_jump
000EC9r 3               
000EC9r 3                               ; Check the wordsize LSB against the user-defined limit.
000EC9r 3  B5 00                        lda 0,x
000ECBr 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
000ECDr 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
000ECFr 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
000ED1r 3               
000ED1r 3               @jumpto_compile_as_jump:
000ED1r 3                               ; If the wordsize is greater than the user-defined
000ED1r 3                               ; limit, it will be compiled as a subroutine jump.
000ED1r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000ED4r 3               
000ED4r 3               @compile_as_code:
000ED4r 3                               ; We arrive here with the length of the word's code TOS and
000ED4r 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
000ED4r 3                               ; on the data stack
000ED4r 3  CA                           dex
000ED5r 3  CA                           dex                     ; ( -- u ? )
000ED6r 3  CA                           dex
000ED7r 3  CA                           dex                     ; ( -- u ? ? )
000ED8r 3               
000ED8r 3  B5 04                        lda 4,x
000EDAr 3  95 00                        sta 0,x                 ; LSB of u
000EDCr 3  B5 05                        lda 5,x
000EDEr 3  95 01                        sta 1,x                 ; ( -- u ? u )
000EE0r 3               
000EE0r 3  68                           pla
000EE1r 3  95 04                        sta 4,x                 ; LSB of xt
000EE3r 3  68                           pla
000EE4r 3  95 05                        sta 5,x                 ; ( -- xt ? u )
000EE6r 3               
000EE6r 3  A5 rr                        lda cp                  ; LSB of cp
000EE8r 3  95 02                        sta 2,x
000EEAr 3  A5 rr                        lda cp+1
000EECr 3  95 03                        sta 3,x                 ; ( -- xt cp u )
000EEEr 3               
000EEEr 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
000EEEr 3               
000EEEr 3                               ; Native compiling allows us to strip the stack antics off
000EEEr 3                               ; a number of words that use the Return Stack such as >R, R>,
000EEEr 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
000EEEr 3                               ; xt with the contents of the table
000EEEr 3  A0 00                        ldy #0
000EF0r 3               
000EF0r 3               @strip_loop:
000EF0r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
000EF3r 3  D5 04                        cmp 4,x                 ; LSB of xt
000EF5r 3  D0 07                        bne @next_entry
000EF7r 3               
000EF7r 3                               ; LSB is the same, test MSB
000EF7r 3  B9 rr rr                     lda @strip_table+1,y
000EFAr 3  D5 05                        cmp 5,x
000EFCr 3  F0 0C                        beq @found_entry
000EFEr 3               
000EFEr 3                               ; MSB is not equal. Pretend though that we've come from LSB
000EFEr 3                               ; so we can use the next step for both cases
000EFEr 3               @next_entry:
000EFEr 3                               ; Not a word that needs stripping, so check next entry in table
000EFEr 3                               ; Let's see if we're done with the table (marked by zero entry)
000EFEr 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
000F01r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
000F04r 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
000F06r 3               
000F06r 3  C8                           iny
000F07r 3  C8                           iny
000F08r 3  80 E6                        bra @strip_loop
000F0Ar 3               @found_entry:
000F0Ar 3                               ; This word is one of the ones that needs to have its size
000F0Ar 3                               ; adjusted during native compile. We find the values in the
000F0Ar 3                               ; next table with the same index, which is Y. However, Y is
000F0Ar 3                               ; pointing to the MSB, so we need to go back to the LSB and
000F0Ar 3                               ; halve the index before we can use it.
000F0Ar 3  98                           tya
000F0Br 3  4A                           lsr
000F0Cr 3  A8                           tay
000F0Dr 3               
000F0Dr 3                               ; Get the adjustment out of the size table. We were clever
000F0Dr 3                               ; enough to make sure the cut on both ends of the code is
000F0Dr 3                               ; is the same size.
000F0Dr 3  B9 rr rr                     lda @strip_size,y
000F10r 3  85 rr                        sta tmptos              ; save a copy
000F12r 3               
000F12r 3                               ; Adjust xt: Start later
000F12r 3  18                           clc
000F13r 3  75 04                        adc 4,x
000F15r 3  95 04                        sta 4,x
000F17r 3  90 02                        bcc @2
000F19r 3  F6 05                        inc 5,x                 ; we just care about the carry
000F1Br 3               @2:
000F1Br 3               
000F1Br 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
000F1Br 3                               ; bottom of the code, we have to double the value
000F1Br 3  06 rr                        asl tmptos
000F1Dr 3               
000F1Dr 3  38                           sec
000F1Er 3  B5 00                        lda 0,x
000F20r 3  E5 rr                        sbc tmptos
000F22r 3  95 00                        sta 0,x
000F24r 3  B0 02                        bcs @3
000F26r 3  D6 01                        dec 1,x                 ; we just care about the borrow
000F28r 3               @3:
000F28r 3                               ; drop through to underflow check stripping
000F28r 3               
000F28r 3               @underflow_strip:
000F28r 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
000F28r 3               
000F28r 3                               ; The user can choose to remove the unterflow testing in those
000F28r 3                               ; words that have the UF flag. This shortens the word by
000F28r 3                               ; 3 bytes if there is no underflow.
000F28r 3               
000F28r 3                               ; See if the user wants underflow stripping turned on
000F28r 3  A5 rr                        lda uf_strip
000F2Ar 3  05 rr                        ora uf_strip+1
000F2Cr 3  F0 1C                        beq @specials_done
000F2Er 3               
000F2Er 3                               ; See if this word even contains underflow checking
000F2Er 3  A5 rr                        lda tmp3
000F30r 3  29 10                        and #UF
000F32r 3  F0 16                        beq @specials_done
000F34r 3               
000F34r 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
000F34r 3                               ; long. Note hat PICK is a special case.
000F34r 3               
000F34r 3                               ; Adjust xt: Start later
000F34r 3  18                           clc
000F35r 3  B5 04                        lda 4,x
000F37r 3  69 03                        adc #3
000F39r 3  95 04                        sta 4,x
000F3Br 3  90 02                        bcc @4
000F3Dr 3  F6 05                        inc 5,x                  ; we just care about the carry
000F3Fr 3               @4:
000F3Fr 3                               ; Adjust u: End earlier
000F3Fr 3  38                           sec
000F40r 3  B5 00                        lda 0,x
000F42r 3  E9 03                        sbc #3
000F44r 3  95 00                        sta 0,x
000F46r 3  B0 02                        bcs @5
000F48r 3  D6 01                        dec 1,x                  ; we just care about the borrow
000F4Ar 3               @5:
000F4Ar 3               
000F4Ar 3                               ; --- END OF SPECIAL CASES ---
000F4Ar 3               @specials_done:
000F4Ar 3                               ; Store size of area to be copied for calculation of
000F4Ar 3                               ; new CP. We have to do this after all of the special cases
000F4Ar 3                               ; because they might change the size
000F4Ar 3  B5 01                        lda 1,x                 ; MSB
000F4Cr 3  48                           pha
000F4Dr 3  B5 00                        lda 0,x                 ; LSB
000F4Fr 3  48                           pha
000F50r 3               
000F50r 3                               ; Enough of this, let's move those bytes already! We have
000F50r 3                               ; ( xt cp u ) on the stack at this point
000F50r 3  20 rr rr                     jsr xt_move
000F53r 3               
000F53r 3                               ; Update CP
000F53r 3  18                           clc
000F54r 3  68                           pla                     ; LSB
000F55r 3  65 rr                        adc cp
000F57r 3  85 rr                        sta cp
000F59r 3               
000F59r 3  68                           pla                     ; MSB
000F5Ar 3  65 rr                        adc cp+1
000F5Cr 3  85 rr                        sta cp+1
000F5Er 3               
000F5Er 3  80 2C                        bra @done
000F60r 3               
000F60r 3               @strip_table:
000F60r 3                              ; List of words we strip the Return Stack antics from
000F60r 3                              ; during native compile, zero terminated. The index here
000F60r 3                              ; must be the same as for the sizes
000F60r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
000F64r 3  rr rr        
000F66r 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
000F6Ar 3  00 00        
000F6Cr 3               
000F6Cr 3               @strip_size:
000F6Cr 3                               ; List of bytes to be stripped from the words that get their
000F6Cr 3                               ; Return Stack antics removed during native compile. Index must
000F6Cr 3                               ; be the same as for the xts. Zero terminated.
000F6Cr 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
000F70r 3  06 00        
000F72r 3               
000F72r 3               @compile_as_jump:
000F72r 3                               ; Compile xt as a subroutine jump
000F72r 3  A9 20                        lda #$20
000F74r 3  92 rr                        sta (cp)
000F76r 3               
000F76r 3  A0 01                        ldy #1
000F78r 3  68                           pla             ; LSB
000F79r 3  91 rr                        sta (cp),y
000F7Br 3  C8                           iny
000F7Cr 3  68                           pla             ; MSB
000F7Dr 3  91 rr                        sta (cp),y
000F7Fr 3               
000F7Fr 3                               ; allot space we just used
000F7Fr 3  A9 03                        lda #3
000F81r 3  18                           clc
000F82r 3  65 rr                        adc cp
000F84r 3  85 rr                        sta cp
000F86r 3  90 02                        bcc @6
000F88r 3  E6 rr                        inc cp+1
000F8Ar 3               @6:
000F8Ar 3  E8                           inx             ; drop xt
000F8Br 3  E8                           inx
000F8Cr 3               @done:
000F8Cr 3               z_compile_comma:
000F8Cr 3  60                           rts
000F8Dr 3               
000F8Dr 3               
000F8Dr 3               
000F8Dr 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
000F8Dr 3               ; ## "compile-only"  tested  Tali Forth
000F8Dr 3                       ; """Set the Compile Only flag (CO) of the most recently defined
000F8Dr 3                       ; word.
000F8Dr 3                       ;
000F8Dr 3                       ; The alternative way to do this is to define a word
000F8Dr 3                       ; ?COMPILE that makes sure  we're in compile mode
000F8Dr 3                       ; """
000F8Dr 3               
000F8Dr 3               xt_compile_only:
000F8Dr 3  20 rr rr                     jsr current_to_dp
000F90r 3  A0 01                        ldy #1          ; offset for status byte
000F92r 3  B1 rr                        lda (dp),y
000F94r 3  09 01                        ora #CO        ; make sure bit 7 is set
000F96r 3  91 rr                        sta (dp),y
000F98r 3               
000F98r 3  60           z_compile_only: rts
000F99r 3               
000F99r 3               
000F99r 3               
000F99r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
000F99r 3               ; ## "constant"  auto  ANS core
000F99r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
000F99r 3                       ;
000F99r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
000F99r 3                       ; more in assembler and let CREATE do the heavy lifting.
000F99r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
000F99r 3                       ; a primer on how this works in various Forths. This is the
000F99r 3                       ; same code as VALUE in our case.
000F99r 3                       ; """
000F99r 3               xt_value:
000F99r 3               xt_constant:
000F99r 3  20 rr rr                     jsr underflow_1
000F9Cr 3               
000F9Cr 3  20 rr rr                     jsr xt_create
000F9Fr 3               
000F9Fr 3                           	; CREATE by default installs a subroutine jump to DOVAR,
000F9Fr 3                               ; but we want DOCONST for constants. Go back two bytes and
000F9Fr 3                               ; replace the subroutine jump target
000F9Fr 3  38                           sec
000FA0r 3  A5 rr                        lda cp
000FA2r 3  E9 02                        sbc #2
000FA4r 3  85 rr                        sta tmp1
000FA6r 3  A5 rr                        lda cp+1
000FA8r 3  E9 00                        sbc #0
000FAAr 3  85 rr                        sta tmp1+1
000FACr 3               
000FACr 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
000FAEr 3  92 rr                        sta (tmp1)
000FB0r 3  A0 01                        ldy #1
000FB2r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
000FB4r 3  91 rr                        sta (tmp1),y
000FB6r 3               
000FB6r 3                               ; Now we save the constant number itself in the next cell
000FB6r 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
000FB9r 3               
000FB9r 3               adjust_z:
000FB9r 3                               ; Now the length of the complete word (z_word) has increased by
000FB9r 3                               ; two. We need to update that number or else words such as SEE
000FB9r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
000FB9r 3                               ; VALUE and DEFER
000FB9r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
000FBCr 3               
000FBCr 3                               ; z_word is six bytes further down
000FBCr 3  B5 00                        lda 0,x
000FBEr 3  85 rr                        sta tmp1
000FC0r 3  B5 01                        lda 1,x
000FC2r 3  85 rr                        sta tmp1+1
000FC4r 3               
000FC4r 3  A0 06                        ldy #6
000FC6r 3  B1 rr                        lda (tmp1),y
000FC8r 3  18                           clc
000FC9r 3  69 02                        adc #2
000FCBr 3  91 rr                        sta (tmp1),y
000FCDr 3  C8                           iny
000FCEr 3  B1 rr                        lda (tmp1),y
000FD0r 3  69 00                        adc #0                  ; only need carry
000FD2r 3  91 rr                        sta (tmp1),y
000FD4r 3               
000FD4r 3  E8                           inx
000FD5r 3  E8                           inx
000FD6r 3               
000FD6r 3               z_value:
000FD6r 3  60           z_constant:     rts
000FD7r 3               
000FD7r 3               
000FD7r 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
000FD7r 3               ; ## "count"  auto  ANS core
000FD7r 3                       ; """https://forth-standard.org/standard/core/COUNT
000FD7r 3                       ; Convert old-style character string to address-length pair. Note
000FD7r 3                       ; that the length of the string c-addr is stored in character length
000FD7r 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
000FD7r 3                       ; though COUNT can also be used to step through a string character by
000FD7r 3                       ; character.
000FD7r 3                       ; """
000FD7r 3               xt_count:
000FD7r 3  20 rr rr                     jsr underflow_1
000FDAr 3               
000FDAr 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
000FDCr 3  A8                           tay
000FDDr 3               
000FDDr 3                               ; move start address up by one
000FDDr 3  F6 00                        inc 0,x         ; LSB
000FDFr 3  D0 02                        bne @1
000FE1r 3  F6 01                        inc 1,x         ; MSB
000FE3r 3               
000FE3r 3                               ; save number of characters to stack
000FE3r 3               @1:
000FE3r 3  98                           tya
000FE4r 3  CA                           dex
000FE5r 3  CA                           dex
000FE6r 3  95 00                        sta 0,x         ; LSB
000FE8r 3  74 01                        stz 1,x         ; MSB, always zero
000FEAr 3               
000FEAr 3  60           z_count:        rts
000FEBr 3               
000FEBr 3               
000FEBr 3               ; ## CR ( -- ) "Print a line feed"
000FEBr 3               ; ## "cr"  auto  ANS core
000FEBr 3                       ; """https://forth-standard.org/standard/core/CR"""
000FEBr 3               xt_cr:
000FEBr 3  A9 0A                        lda #AscLF
000FEDr 3  20 rr rr                     jsr emit_a
000FF0r 3  60           z_cr:           rts
000FF1r 3               
000FF1r 3               
000FF1r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
000FF1r 3               ; ## "create"  auto  ANS core
000FF1r 3                       ; """https://forth-standard.org/standard/core/CREATE
000FF1r 3                       ;
000FF1r 3                       ; See the drawing in headers.asm for details on the header
000FF1r 3                       ; """
000FF1r 3               
000FF1r 3               xt_create:
000FF1r 3                               ; get string
000FF1r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
000FF4r 3               
000FF4r 3                               ; if we were given an empty string, we complain and quit
000FF4r 3  B5 00                        lda 0,x
000FF6r 3  15 01                        ora 1,x
000FF8r 3  D0 05                        bne @got_name
000FFAr 3               
000FFAr 3  A9 05                        lda #err_noname
000FFCr 3  4C rr rr                     jmp error
000FFFr 3               
000FFFr 3               @got_name:
000FFFr 3                               ; Enforce maximal length of string by overwriting the MSB of
000FFFr 3                               ; the length. There is a possible error here: If the string
000FFFr 3                               ; is exactly 255 chars long, then a lot of the following
000FFFr 3                               ; additions will fail because of wrapping
000FFFr 3  74 01                        stz 1,x
001001r 3               
001001r 3                               ; Check to see if this name already exists.
001001r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
001004r 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
001007r 3               
001007r 3  B5 00                        lda 0,x
001009r 3  15 01                        ora 1,x
00100Br 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
00100Dr 3               
00100Dr 3                               ; This name already exists.  See if we are supposed to print
00100Dr 3                               ; the message for it.
00100Dr 3  E8                           inx                     ; Drop flag (nt) from find-name.
00100Er 3  E8                           inx
00100Fr 3               
00100Fr 3                               ; Check bit 7
00100Fr 3  24 rr                        bit status
001011r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
001013r 3               
001013r 3                               ; We aren't supposed to print the redefined message ourselves,
001013r 3                               ; but we should indicate that it is redefined (for ; to print
001013r 3                               ; later).
001013r 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
001015r 3  05 rr                        ora status
001017r 3  85 rr                        sta status
001019r 3  80 18                        bra @process_name
00101Br 3               
00101Br 3               @redefined_name:
00101Br 3                               ; Print the message that the name is redefined.
00101Br 3  A9 02                        lda #str_redefined
00101Dr 3  20 rr rr                     jsr print_string_no_lf
001020r 3               
001020r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
001023r 3  20 rr rr                     jsr xt_type
001026r 3  20 rr rr                     jsr xt_space
001029r 3               
001029r 3  80 08                        bra @process_name
00102Br 3               
00102Br 3               @new_name:
00102Br 3  E8                           inx                     ; Drop flag (0) from find-name.
00102Cr 3  E8                           inx
00102Dr 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
00102Fr 3  25 rr                        and status
001031r 3  85 rr                        sta status
001033r 3               
001033r 3               @process_name:
001033r 3  B5 00                        lda 0,x
001035r 3  85 rr                        sta tmp2                ; store length of string in tmp2
001037r 3               
001037r 3                               ; remember the first free byte of memory as the start of
001037r 3                               ; the new word
001037r 3  A5 rr                        lda cp
001039r 3  85 rr                        sta tmp1
00103Br 3  A5 rr                        lda cp+1
00103Dr 3  85 rr                        sta tmp1+1
00103Fr 3               
00103Fr 3                               ; We need 8 bytes plus the length of the string for our new header.
00103Fr 3                               ; This is also the offset for the start of the code field (the
00103Fr 3                               ; xt_ label) so we need to remember it. Otherwise, we could
00103Fr 3                               ; just allot the space afterwards
00103Fr 3  B5 00                        lda 0,x
001041r 3  18                           clc
001042r 3  69 08                        adc #8
001044r 3  85 rr                        sta tmp3                ; total header length
001046r 3               
001046r 3                               ; We need three more bytes for for the hardcoded code field
001046r 3                               ; area (CFA), the "payload" of the word which by default will
001046r 3                               ; be a subroutine jump to DOVAR
001046r 3  18                           clc
001047r 3  69 03                        adc #3
001049r 3               
001049r 3                               ; We overwrite the length of the string returned by PARSE-NAME
001049r 3                               ; and then call ALLOT
001049r 3  95 00                        sta 0,x
00104Br 3  74 01                        stz 1,x         ; max header size is 255 chars
00104Dr 3  20 rr rr                     jsr xt_allot    ; ( addr )
001050r 3               
001050r 3                               ; Get the CURRENT dictionary pointer.
001050r 3  20 rr rr                     jsr current_to_dp
001053r 3               
001053r 3                               ; Now we walk through the header with Y as the index, adding
001053r 3                               ; information byte-by-byte
001053r 3  A0 00                        ldy #0
001055r 3               
001055r 3                               ; HEADER BYTE 0: Length of string
001055r 3  A5 rr                        lda tmp2
001057r 3  91 rr                        sta (tmp1),y
001059r 3               
001059r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
001059r 3                               ; to "never native", user will have to decide if they should
001059r 3                               ; be inlined
001059r 3  A9 08                        lda #NN
00105Br 3               
00105Br 3                               ; Also, words defined by CREATE are marked in the header has
00105Br 3                               ; having a Code Field Area (CFA), which is a bit tricky for
00105Br 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
00105Br 3                               ; correctly with DOES> and CREATE. See the discussion at
00105Br 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
00105Br 3  09 20                        ora #HC
00105Dr 3  C8                           iny
00105Er 3  91 rr                        sta (tmp1),y
001060r 3  C8                           iny
001061r 3               
001061r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
001061r 3                               ; in the Dictionary
001061r 3  A5 rr                        lda dp
001063r 3  91 rr                        sta (tmp1),y
001065r 3  C8                           iny
001066r 3  A5 rr                        lda dp+1
001068r 3  91 rr                        sta (tmp1),y
00106Ar 3  C8                           iny
00106Br 3               
00106Br 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
00106Br 3  A5 rr                        lda tmp1+1
00106Dr 3  85 rr                        sta dp+1
00106Fr 3  A5 rr                        lda tmp1
001071r 3  85 rr                        sta dp
001073r 3               
001073r 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
001073r 3                               ; This begins after the header so we take the length of the
001073r 3                               ; header, which we cleverly saved in tmp3, and use it as an
001073r 3                               ; offset to the address of the start of the word. We come here
001073r 3                               ; with tmp1 in A
001073r 3  18                           clc
001074r 3  65 rr                        adc tmp3        ; add total header length
001076r 3  91 rr                        sta (tmp1),y
001078r 3  48                           pha             ; we need this in the next step
001079r 3  C8                           iny
00107Ar 3               
00107Ar 3  A5 rr                        lda tmp1+1
00107Cr 3  69 00                        adc #0          ; only need the carry
00107Er 3  91 rr                        sta (tmp1),y
001080r 3  C8                           iny
001081r 3               
001081r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
001081r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
001081r 3                               ; bytes down, and then one more byte so that the z_ label points
001081r 3                               ; to the (still fictional) RTS instruction for correct compilation
001081r 3  68                           pla             ; LSB of "z_" address
001082r 3  18                           clc
001083r 3  69 03                        adc #3
001085r 3  91 rr                        sta (tmp1),y
001087r 3               
001087r 3  88                           dey             ; get the MSB of xt back
001088r 3  B1 rr                        lda (tmp1),y
00108Ar 3  69 00                        adc #0          ; only need the carry
00108Cr 3  C8                           iny
00108Dr 3  C8                           iny
00108Er 3  91 rr                        sta (tmp1),y
001090r 3  C8                           iny
001091r 3               
001091r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
001091r 3                               ; length in tmp2. We subtract 8 from the address so we can
001091r 3                               ; use the same loop index, which is already 8 byte ahead at
001091r 3                               ; this point
001091r 3  B5 00                        lda 0,x
001093r 3  38                           sec
001094r 3  E9 08                        sbc #8
001096r 3  85 rr                        sta tmptos
001098r 3               
001098r 3  B5 01                        lda 1,x
00109Ar 3  E9 00                        sbc #0          ; only need carry
00109Cr 3  85 rr                        sta tmptos+1
00109Er 3               
00109Er 3               @name_loop:
00109Er 3  B1 rr                        lda (tmptos),y
0010A0r 3               
0010A0r 3                               ; Make sure it goes into the dictionary in lower case.
0010A0r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0010A2r 3  B0 07                        bcs @store_name
0010A4r 3  C9 41                        cmp #$41        ; ASCII 'A'
0010A6r 3  90 03                        bcc @store_name
0010A8r 3               
0010A8r 3                               ; An uppercase letter has been located. Make it
0010A8r 3                               ; lowercase.
0010A8r 3  18                           clc
0010A9r 3  69 20                        adc #$20
0010ABr 3               
0010ABr 3                               ; Fall into @store_name.
0010ABr 3               
0010ABr 3               @store_name:
0010ABr 3  91 rr                        sta (tmp1),y
0010ADr 3  C8                           iny
0010AEr 3  C6 rr                        dec tmp2
0010B0r 3  D0 EC                        bne @name_loop
0010B2r 3               
0010B2r 3                               ; After thename string comes the code field, starting at the
0010B2r 3                               ; current xt of this word, which is initially a jump to the
0010B2r 3                               ; subroutine to DOVAR. We code this jump by hand
0010B2r 3  A9 20                        lda #$20        ; opcode of JSR
0010B4r 3  91 rr                        sta (tmp1),y
0010B6r 3  C8                           iny
0010B7r 3  A9 rr                        lda #<dovar
0010B9r 3  91 rr                        sta (tmp1),y
0010BBr 3  C8                           iny
0010BCr 3  A9 rr                        lda #>dovar
0010BEr 3  91 rr                        sta (tmp1),y
0010C0r 3               
0010C0r 3                               ; Update the CURRENT wordlist with the new DP.
0010C0r 3                               ; We do this down here because this routine uses Y.
0010C0r 3  20 rr rr                     jsr dp_to_current
0010C3r 3               
0010C3r 3                               ; And we're done. Restore stack
0010C3r 3  E8                           inx
0010C4r 3  E8                           inx
0010C5r 3               
0010C5r 3  60           z_create:       rts
0010C6r 3               
0010C6r 3               
0010C6r 3               
0010C6r 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
0010C6r 3               ; ## "d-"  auto  ANS double
0010C6r 3                       ; """https://forth-standard.org/standard/double/DMinus"""
0010C6r 3               
0010C6r 3               xt_d_minus:
0010C6r 3  20 rr rr                     jsr underflow_4 ; two double numbers
0010C9r 3               
0010C9r 3  38                           sec
0010CAr 3               
0010CAr 3  B5 06                        lda 6,x         ; LSB of lower word
0010CCr 3  F5 02                        sbc 2,x
0010CEr 3  95 06                        sta 6,x
0010D0r 3               
0010D0r 3  B5 07                        lda 7,x         ; MSB of lower word
0010D2r 3  F5 03                        sbc 3,x
0010D4r 3  95 07                        sta 7,x
0010D6r 3               
0010D6r 3  B5 04                        lda 4,x         ; LSB of upper word
0010D8r 3  F5 00                        sbc 0,x
0010DAr 3  95 04                        sta 4,x
0010DCr 3               
0010DCr 3  B5 05                        lda 5,x         ; MSB of upper word
0010DEr 3  F5 01                        sbc 1,x
0010E0r 3  95 05                        sta 5,x
0010E2r 3               
0010E2r 3  E8                           inx
0010E3r 3  E8                           inx
0010E4r 3  E8                           inx
0010E5r 3  E8                           inx
0010E6r 3               
0010E6r 3  60           z_d_minus:      rts
0010E7r 3               
0010E7r 3               
0010E7r 3               
0010E7r 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
0010E7r 3               ; ## "d+"  auto  ANS double
0010E7r 3                       ; """https://forth-standard.org/standard/double/DPlus"""
0010E7r 3               
0010E7r 3               xt_d_plus:
0010E7r 3  20 rr rr                     jsr underflow_4 ; two double numbers
0010EAr 3               
0010EAr 3  18                           clc
0010EBr 3  B5 02                        lda 2,x         ; LSB of lower word
0010EDr 3  75 06                        adc 6,x
0010EFr 3  95 06                        sta 6,x
0010F1r 3               
0010F1r 3  B5 03                        lda 3,x         ; MSB of lower word
0010F3r 3  75 07                        adc 7,x
0010F5r 3  95 07                        sta 7,x
0010F7r 3               
0010F7r 3  B5 00                        lda 0,x         ; LSB of upper word
0010F9r 3  75 04                        adc 4,x
0010FBr 3  95 04                        sta 4,x
0010FDr 3               
0010FDr 3  B5 01                        lda 1,x         ; MSB of upper word
0010FFr 3  75 05                        adc 5,x
001101r 3  95 05                        sta 5,x
001103r 3               
001103r 3  E8                           inx
001104r 3  E8                           inx
001105r 3  E8                           inx
001106r 3  E8                           inx
001107r 3               
001107r 3  60           z_d_plus:       rts
001108r 3               
001108r 3               
001108r 3               
001108r 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
001108r 3               ; ## "d>s"  auto  ANS double
001108r 3                       ; """https://forth-standard.org/standard/double/DtoS
001108r 3                       ; Though this is basically just DROP, we keep it
001108r 3                       ; separate so we can test for underflow
001108r 3                       ; """
001108r 3               
001108r 3               xt_d_to_s:
001108r 3  20 rr rr                     jsr underflow_2
00110Br 3               
00110Br 3  E8                           inx
00110Cr 3  E8                           inx
00110Dr 3               
00110Dr 3  60           z_d_to_s:       rts
00110Er 3               
00110Er 3               
00110Er 3               
00110Er 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
00110Er 3               ; ## "dabs"  auto  ANS double
00110Er 3                       ; """https://forth-standard.org/standard/double/DABS"""
00110Er 3               
00110Er 3               xt_dabs:
00110Er 3  20 rr rr                     jsr underflow_2 ; double number
001111r 3               
001111r 3  B5 01                        lda 1,x         ; MSB of high cell
001113r 3  10 17                        bpl @done       ; positive, we get off light
001115r 3               
001115r 3                               ; negative, calculate 0 - d
001115r 3  A0 00                        ldy #0
001117r 3  38                           sec
001118r 3               
001118r 3  98                           tya
001119r 3  F5 02                        sbc 2,x         ; LSB of low cell
00111Br 3  95 02                        sta 2,x
00111Dr 3               
00111Dr 3  98                           tya
00111Er 3  F5 03                        sbc 3,x         ; MSB of low cell
001120r 3  95 03                        sta 3,x
001122r 3               
001122r 3  98                           tya
001123r 3  F5 00                        sbc 0,x         ; LSB of high cell
001125r 3  95 00                        sta 0,x
001127r 3               
001127r 3  98                           tya
001128r 3  F5 01                        sbc 1,x         ; MSB of high cell
00112Ar 3  95 01                        sta 1,x
00112Cr 3               @done:
00112Cr 3  60           z_dabs:         rts
00112Dr 3               
00112Dr 3               
00112Dr 3               
00112Dr 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
00112Dr 3               ; ## "decimal"  auto  ANS core
00112Dr 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
00112Dr 3               xt_decimal:
00112Dr 3  A9 0A                        lda #10
00112Fr 3  85 rr                        sta base
001131r 3  64 rr                        stz base+1              ; paranoid
001133r 3               
001133r 3  60           z_decimal:      rts
001134r 3               
001134r 3               
001134r 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
001134r 3               ; ## "defer"  auto  ANS core ext
001134r 3                       ; """https://forth-standard.org/standard/core/DEFER
001134r 3                       ; Reserve an name that can be linked to various xt by IS.
001134r 3                       ;
001134r 3                       ; The ANS reference implementation is
001134r 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
001134r 3                       ; But we use this routine as a low-level word so things go faster
001134r 3               
001134r 3               xt_defer:
001134r 3  20 rr rr                     jsr xt_create
001137r 3               
001137r 3                               ; CREATE by default installs a subroutine jump to DOVAR,
001137r 3                               ; but we actually want DODEFER this time. Go back two
001137r 3                               ; bytes and repace the subroutine jump target
001137r 3  A5 rr                        lda cp          ; LSB
001139r 3  38                           sec
00113Ar 3  E9 02                        sbc #2
00113Cr 3  85 rr                        sta tmp1
00113Er 3               
00113Er 3  A5 rr                        lda cp+1        ; MSB
001140r 3  E9 00                        sbc #0          ; we only care about the borrow
001142r 3  85 rr                        sta tmp1+1
001144r 3               
001144r 3                               ; Save the target address
001144r 3  A0 00                        ldy #0
001146r 3  A9 rr                        lda #<dodefer   ; LSB
001148r 3  91 rr                        sta (tmp1),y
00114Ar 3  C8                           iny
00114Br 3  A9 rr                        lda #>dodefer   ; MSB
00114Dr 3  91 rr                        sta (tmp1),y
00114Fr 3               
00114Fr 3               
00114Fr 3                               ; DODEFER executes the next address it finds after
00114Fr 3                               ; its call. As default, we include the error
00114Fr 3                               ; "Defer not defined"
00114Fr 3  A9 rr                        lda #<defer_error
001151r 3  92 rr                        sta (cp)
001153r 3  E6 rr                        inc cp
001155r 3  D0 02                        bne @1
001157r 3  E6 rr                        inc cp+1
001159r 3               @1:
001159r 3  A9 rr                        lda #>defer_error
00115Br 3  92 rr                        sta (cp)
00115Dr 3  E6 rr                        inc cp
00115Fr 3  D0 02                        bne @2
001161r 3  E6 rr                        inc cp+1
001163r 3               @2:
001163r 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
001166r 3               
001166r 3  60           z_defer:        rts
001167r 3               
001167r 3               
001167r 3               
001167r 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
001167r 3               ; ## "defer@"  auto  ANS core ext
001167r 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
001167r 3               
001167r 3               xt_defer_fetch:
001167r 3                               ; No underflow checking as >BODY does it.
001167r 3  20 rr rr                     jsr xt_to_body
00116Ar 3  20 rr rr                     jsr xt_fetch
00116Dr 3  60           z_defer_fetch:  rts
00116Er 3               
00116Er 3               
00116Er 3               
00116Er 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
00116Er 3               ; ## "defer!"  auto  ANS core ext
00116Er 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
00116Er 3               
00116Er 3               xt_defer_store:
00116Er 3                               ; No underflow checking as >BODY and ! do it.
00116Er 3  20 rr rr                     jsr xt_to_body
001171r 3  20 rr rr                     jsr xt_store
001174r 3  60           z_defer_store:  rts
001175r 3               
001175r 3               
001175r 3               
001175r 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
001175r 3               ; ## "definitions" auto ANS search
001175r 3               xt_definitions:
001175r 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
001177r 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
001179r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
00117Br 3  91 rr                        sta (up),y
00117Dr 3  60           z_definitions:  rts
00117Er 3               
00117Er 3               
00117Er 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
00117Er 3               ; ## "depth"  auto  ANS core
00117Er 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
00117Er 3               xt_depth:
00117Er 3  A9 FF                        lda #dsp0
001180r 3  86 rr                        stx tmpdsp
001182r 3  38                           sec
001183r 3  E5 rr                        sbc tmpdsp
001185r 3               
001185r 3                               ; divide by two because each cell is two bytes
001185r 3  4A                           lsr
001186r 3               
001186r 3  CA                           dex
001187r 3  CA                           dex
001188r 3  95 00                        sta 0,x
00118Ar 3  74 01                        stz 1,x
00118Cr 3               
00118Cr 3  60           z_depth:        rts
00118Dr 3               
00118Dr 3               
00118Dr 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
00118Dr 3               ; ## "digit?"  auto  Tali Forth
00118Dr 3                       ; """Inspired by the pForth instruction DIGIT, see
00118Dr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00118Dr 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
00118Dr 3                       ; pForth, we get the base (radix) ourselves instead of having the
00118Dr 3                       ; user provide it. There is no standard name for this routine, which
00118Dr 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
00118Dr 3                       ; """
00118Dr 3               
00118Dr 3               xt_digit_question:
00118Dr 3  20 rr rr                     jsr underflow_1
001190r 3               
001190r 3                               ; one way or another, we're going to need room for the
001190r 3                               ; flag on the stack
001190r 3  CA                           dex
001191r 3  CA                           dex
001192r 3  74 00                        stz 0,x                 ; default flag is failure
001194r 3  74 01                        stz 1,x
001196r 3  74 03                        stz 3,x                 ; paranoid
001198r 3               
001198r 3                               ; Check the character, now in the LSB of NOS. First, make
001198r 3                               ; sure we're not below the ASCII code for "0"
001198r 3  B5 02                        lda 2,x
00119Ar 3  C9 30                        cmp #'0'
00119Cr 3  90 23                        bcc @done               ; failure flag already set
00119Er 3               
00119Er 3                               ; Next, see if we are below "9", because that would make
00119Er 3                               ; this a normal number
00119Er 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
0011A0r 3  90 12                        bcc @checkbase
0011A2r 3               
0011A2r 3                               ; Well, then let's see if this is the gap between "9" and "A"
0011A2r 3                               ; so we can treat the whole range as a number
0011A2r 3  C9 41                        cmp #'A'
0011A4r 3  90 1B                        bcc @done               ; failure flag is already set
0011A6r 3               
0011A6r 3                               ; probably a letter, so we make sure it is uppercase
0011A6r 3  C9 61                        cmp #'a'
0011A8r 3  90 07                        bcc @case_done          ; not lower case, too low
0011AAr 3  C9 7B                        cmp #'z'+1
0011ACr 3  B0 03                        bcs @case_done          ; not lower case, too high
0011AEr 3               
0011AEr 3  18                           clc                     ; just right
0011AFr 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
0011B1r 3               
0011B1r 3               @case_done:
0011B1r 3                               ; get rid of the gap between "9" and "A" so we can treat
0011B1r 3                               ; the whole range as one number
0011B1r 3  38                           sec
0011B2r 3  E9 07                        sbc #7                  ; fall through to @checkbase
0011B4r 3               
0011B4r 3               @checkbase:
0011B4r 3                               ; we have a number, now see if it falls inside the range
0011B4r 3                               ; provided by BASE
0011B4r 3  38                           sec
0011B5r 3  E9 30                        sbc #'0'                 ; this is also the conversion step
0011B7r 3  C5 rr                        cmp base
0011B9r 3  B0 06                        bcs @done               ; already have false flag
0011BBr 3               
0011BBr 3                               ; Found a legal number
0011BBr 3  95 02                        sta 2,x                 ; put number in NOS
0011BDr 3  D6 00                        dec 0,x                 ; set success flag
0011BFr 3  D6 01                        dec 1,x
0011C1r 3               
0011C1r 3               @done:
0011C1r 3               z_digit_question:
0011C1r 3  60                           rts
0011C2r 3               
0011C2r 3               
0011C2r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
0011C2r 3               ; ## "disasm"  tested  Tali Forth
0011C2r 3                       ; """Convert a segment of memory to assembler output. This
0011C2r 3                       ; word is vectored so people can add their own disassembler.
0011C2r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
0011C2r 3                       ; code, see the section on The Disassembler in the manual and
0011C2r 3                       ; the file disassembler.asm for more details.
0011C2r 3                       ; """
0011C2r 3               xt_disasm:
0011C2r 3  20 rr rr                     jsr underflow_2
0011C5r 3                           .ifdef disassembler
0011C5r 3                               jsr disassembler
0011C5r 3                           .endif
0011C5r 3               
0011C5r 3  60           z_disasm:       rts
0011C6r 3               
0011C6r 3               
0011C6r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
0011C6r 3               ; ## "dnegate"  auto  ANS double
0011C6r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
0011C6r 3               xt_dnegate:
0011C6r 3  20 rr rr                     jsr underflow_2 ; double number
0011C9r 3               
0011C9r 3  A0 00             		ldy #0
0011CBr 3  38                           sec
0011CCr 3               
0011CCr 3  98                           tya
0011CDr 3  F5 02                        sbc 2,x         ; LSB of low cell
0011CFr 3  95 02                        sta 2,x
0011D1r 3               
0011D1r 3  98                           tya
0011D2r 3  F5 03                        sbc 3,x         ; MSB of low cell
0011D4r 3  95 03                        sta 3,x
0011D6r 3               
0011D6r 3  98                           tya
0011D7r 3  F5 00                        sbc 0,x         ; LSB of high cell
0011D9r 3  95 00                        sta 0,x
0011DBr 3               
0011DBr 3  98                           tya
0011DCr 3  F5 01                        sbc 1,x         ; MSB of high cell
0011DEr 3  95 01                        sta 1,x
0011E0r 3               
0011E0r 3  60           z_dnegate:      rts
0011E1r 3               
0011E1r 3               
0011E1r 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
0011E1r 3               ; ## "?do"  auto  ANS core ext
0011E1r 3                       ; """https://forth-standard.org/standard/core/qDO"""
0011E1r 3               xt_question_do:
0011E1r 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
0011E1r 3                               ; to mark which is which
0011E1r 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
0011E3r 3  85 rr                        sta tmp1
0011E5r 3  80 02                        bra do_common           ; skip flag for DO
0011E7r 3               
0011E7r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
0011E7r 3               ; ## "do"  auto  ANS core
0011E7r 3                       ; """https://forth-standard.org/standard/core/DO
0011E7r 3                       ;
0011E7r 3                       ; Compile-time part of DO. Could be realized in Forth as
0011E7r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
0011E7r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
0011E7r 3                       ; a routine that pushes the end address to the Return Stack at run
0011E7r 3                       ; time. This is based on a suggestion by Garth Wilson, see
0011E7r 3                       ; the Control Flow section of the manual for details.
0011E7r 3                       ;
0011E7r 3                       ; This may not be native compile. Don't check for a stack underflow
0011E7r 3                       ; """
0011E7r 3               
0011E7r 3               xt_do:
0011E7r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
0011E7r 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
0011E9r 3               do_common:
0011E9r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
0011E9r 3                               ; compile the address we need to LDA at runtime
0011E9r 3  CA                           dex
0011EAr 3  CA                           dex
0011EBr 3  A5 rr                        lda cp
0011EDr 3  95 00                        sta 0,x                 ; LSB
0011EFr 3  A5 rr                        lda cp+1
0011F1r 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
0011F3r 3               
0011F3r 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
0011F3r 3                               ; replace by the actual LDA/PHA instructions
0011F3r 3  A9 05                        lda #5                  ; we don't really care about the value,
0011F5r 3  A8                           tay                     ; so we use 5 to be tricky
0011F6r 3               @loop:
0011F6r 3  91 rr                        sta (cp),y
0011F8r 3  88                           dey
0011F9r 3  10 FB                        bpl @loop
0011FBr 3               
0011FBr 3                               ; update CP
0011FBr 3  1A                           inc             ; we used 5 as a dummy value, this is why
0011FCr 3  18                           clc
0011FDr 3  65 rr                        adc cp
0011FFr 3  85 rr                        sta cp
001201r 3  90 02                        bcc @1
001203r 3  E6 rr                        inc cp+1
001205r 3               @1:
001205r 3                               ; compile the (?DO) portion of ?DO if appropriate
001205r 3  A5 rr                        lda tmp1
001207r 3  F0 17                        beq @compile_do
001209r 3               
001209r 3                               ; We came from ?DO, so compile its runtime first. We do
001209r 3                               ; this with a quick loop because we know it has to be
001209r 3                               ; Always Native anyway
001209r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
00120Br 3  5A                           phy             ; save counter to calculate new CP
00120Cr 3               @2:
00120Cr 3  B9 rr rr                     lda question_do_runtime,y
00120Fr 3  91 rr                        sta (cp),y
001211r 3  88                           dey
001212r 3  10 F8                        bpl @2
001214r 3               
001214r 3                               ; adjust CP
001214r 3  68                           pla             ; retrieve counter
001215r 3  18                           clc
001216r 3  65 rr                        adc cp
001218r 3  85 rr                        sta cp
00121Ar 3  A5 rr                        lda cp+1
00121Cr 3  69 00                        adc #0          ; only care about carry
00121Er 3  85 rr                        sta cp+1        ; fall through to @compile_do
001220r 3               
001220r 3               @compile_do:
001220r 3                               ; compile runtime part of DO.
001220r 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
001222r 3  5A                           phy             ; save counter to calculate new CP
001223r 3               @3:
001223r 3  B9 rr rr                     lda do_runtime,y
001226r 3  91 rr                        sta (cp),y
001228r 3  88                           dey
001229r 3  10 F8                        bpl @3
00122Br 3               
00122Br 3                               ; adjust CP
00122Br 3  68                           pla             ; retrieve counter
00122Cr 3  18                           clc
00122Dr 3  65 rr                        adc cp
00122Fr 3  85 rr                        sta cp
001231r 3  A5 rr                        lda cp+1
001233r 3  69 00                        adc #0          ; only care about carry
001235r 3  85 rr                        sta cp+1
001237r 3               
001237r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
001237r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
001237r 3                               ; do with the HERE we're saving for LEAVE
001237r 3  CA                           dex
001238r 3  CA                           dex
001239r 3  A5 rr                        lda cp          ; LSB
00123Br 3  95 00                        sta 0,x
00123Dr 3  A5 rr                        lda cp+1        ; MSB
00123Fr 3  95 01                        sta 1,x
001241r 3               z_question_do:
001241r 3  60           z_do:           rts
001242r 3               
001242r 3               
001242r 3               do_runtime:
001242r 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
001242r 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
001242r 3                       ; the FIG Forth loop (you can see which version you have by running
001242r 3                       ; a loop with start and limit as the same value, for instance
001242r 3                       ; 0 0 DO -- these will walk through the number space). We use a
001242r 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
001242r 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
001242r 3                       ; for further discussion of this. The source given there for
001242r 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
001242r 3                       ; in some Forths. Usually, we would define this as a separate word
001242r 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
001242r 3                       ; However, we can do it faster if we just copy the bytes
001242r 3                       ; of this routine with a simple loop in DO.
001242r 3                       ; """
001242r 3                               ; First step: create fudge factor (FUFA) by subtracting the
001242r 3                               ; limit from $8000, the number that will trip the overflow
001242r 3                               ; flag
001242r 3  38                           sec
001243r 3  A9 00                        lda #0
001245r 3  F5 02                        sbc 2,x         ; LSB of limit
001247r 3  95 02                        sta 2,x         ; save FUFA for later use
001249r 3               
001249r 3  A9 80                        lda #$80
00124Br 3  F5 03                        sbc 3,x         ; MSB of limit
00124Dr 3  95 03                        sta 3,x         ; save FUFA for later use
00124Fr 3  48                           pha             ; FUFA replaces limit on R stack
001250r 3  B5 02                        lda 2,x         ; LSB of limit
001252r 3  48                           pha
001253r 3               
001253r 3                               ; Second step: index is FUFA plus original index
001253r 3  18                           clc
001254r 3  B5 00                        lda 0,x         ; LSB of original index
001256r 3  75 02                        adc 2,x         ; add LSB of FUFA
001258r 3  95 00                        sta 0,x
00125Ar 3  B5 01                        lda 1,x         ; MSB of orginal index
00125Cr 3  75 03                        adc 3,x         ; add MSB of FUFA
00125Er 3  48                           pha
00125Fr 3  B5 00                        lda 0,x         ; LSB of index
001261r 3  48                           pha
001262r 3               
001262r 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
001262r 3                               ; use it later. Clean the Data Stack
001262r 3  E8                           inx
001263r 3  E8                           inx
001264r 3  E8                           inx
001265r 3  E8                           inx             ; no RTS because this is copied into code
001266r 3               do_runtime_end:
001266r 3               
001266r 3               question_do_runtime:
001266r 3               
001266r 3                       ; """This is called (?DO) in some Forths. See the explanation at
001266r 3                       ; do_runtime for the background on this design
001266r 3                       ; """
001266r 3                               ; see if TOS and NOS are equal. Change this to assembler
001266r 3                               ; for speed
001266r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
001269r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
00126Cr 3               
00126Cr 3  B5 00                        lda 0,x
00126Er 3  15 01                        ora 1,x
001270r 3  F0 06                        beq @do_do
001272r 3               
001272r 3                               ; We're equal, so dump everything and jump beyond the loop.
001272r 3                               ; But first, dump six entries off of the Data Stack
001272r 3  8A                           txa
001273r 3  18                           clc
001274r 3  69 06                        adc #6
001276r 3  AA                           tax
001277r 3               
001277r 3                               ; Then abort the whole loop
001277r 3  60                           rts
001278r 3               @do_do:
001278r 3  E8                           inx             ; clear flag from EQUAL off stack
001279r 3  E8                           inx             ; no RTS because this is copied into code
00127Ar 3               question_do_runtime_end:
00127Ar 3               
00127Ar 3               
00127Ar 3               
00127Ar 3               ; ## DOES ( -- ) "Add payload when defining new words"
00127Ar 3               ; ## "does>"  auto  ANS core
00127Ar 3                       ; """https://forth-standard.org/standard/core/DOES
00127Ar 3                       ; Create the payload for defining new defining words. See
00127Ar 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
00127Ar 3                       ; the Developer Guide in the manual for a discussion of
00127Ar 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
00127Ar 3                       ; """
00127Ar 3               
00127Ar 3               xt_does:
00127Ar 3                               ; compile a subroutine jump to runtime of DOES>
00127Ar 3  A0 rr                        ldy #>does_runtime
00127Cr 3  A9 rr                        lda #<does_runtime
00127Er 3  20 rr rr                     jsr cmpl_subroutine
001281r 3               
001281r 3                               ; compile a subroutine jump to DODOES. In traditional
001281r 3                               ; terms, this is the Code Field Area (CFA) of the new
001281r 3                               ; word
001281r 3  A0 rr                        ldy #>dodoes
001283r 3  A9 rr                        lda #<dodoes
001285r 3  20 rr rr                     jsr cmpl_subroutine
001288r 3               
001288r 3  60           z_does:         rts
001289r 3               
001289r 3               
001289r 3               does_runtime:
001289r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
001289r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
001289r 3                       ; address that contains a subroutine jump to DODOES. We don't
001289r 3                       ; jump to DODOES directly because we need to work our magic with
001289r 3                       ; the return addresses. This routine is also known as "(DOES)" in
001289r 3                       ; other Forths
001289r 3                       ; """
001289r 3               
001289r 3  7A                           ply             ; LSB
00128Ar 3  68                           pla             ; MSB
00128Br 3               
00128Br 3  C8                           iny
00128Cr 3  D0 01                        bne @1
00128Er 3  1A                           inc
00128Fr 3               @1:
00128Fr 3  84 rr                        sty tmp1
001291r 3  85 rr                        sta tmp1+1
001293r 3               
001293r 3                               ; CREATE has also already modified the DP to point to the new
001293r 3                               ; word. We have no idea which instructions followed the CREATE
001293r 3                               ; command if there is a DOES> so the CP could point anywhere
001293r 3                               ; by now. The address of the word's xt is four bytes down.
001293r 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
001296r 3  A5 rr                        lda dp
001298r 3  18                           clc
001299r 3  69 04                        adc #4
00129Br 3  85 rr                        sta tmp2
00129Dr 3  A5 rr                        lda dp+1
00129Fr 3  69 00                        adc #0          ; we only care about the carry
0012A1r 3  85 rr                        sta tmp2+1
0012A3r 3               
0012A3r 3                               ; Now we get that address and add one byte to skip over the JSR
0012A3r 3                               ; opcode
0012A3r 3  B2 rr                        lda (tmp2)
0012A5r 3  18                           clc
0012A6r 3  69 01                        adc #1
0012A8r 3  85 rr                        sta tmp3
0012AAr 3  A0 01                        ldy #1
0012ACr 3  B1 rr                        lda (tmp2),y
0012AEr 3  69 00                        adc #0          ; we only care about the carry
0012B0r 3  85 rr                        sta tmp3+1
0012B2r 3               
0012B2r 3                               ; Replace the DOVAR address with our own
0012B2r 3  A5 rr                        lda tmp1        ; LSB
0012B4r 3  92 rr                        sta (tmp3)
0012B6r 3  A5 rr                        lda tmp1+1
0012B8r 3  91 rr                        sta (tmp3),y    ; Y is still 1
0012BAr 3               
0012BAr 3                               ; Since we removed the return address that brought us here, we
0012BAr 3                               ; go back to whatever the main routine was. Otherwise, we we
0012BAr 3                               ; smash into the subroutine jump to DODOES.
0012BAr 3  60                           rts
0012BBr 3               
0012BBr 3               
0012BBr 3               
0012BBr 3               ; ## DOT ( u -- ) "Print TOS"
0012BBr 3               ; ## "."  auto  ANS core
0012BBr 3                       ; """https://forth-standard.org/standard/core/d"""
0012BBr 3               
0012BBr 3               xt_dot:
0012BBr 3  20 rr rr                     jsr underflow_1
0012BEr 3               
0012BEr 3  20 rr rr                     jsr xt_dup                      ; ( n n )
0012C1r 3  20 rr rr                     jsr xt_abs                      ; ( n u )
0012C4r 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
0012C7r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
0012CAr 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
0012CDr 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
0012D0r 3  20 rr rr                     jsr xt_sign                     ; ( ud )
0012D3r 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
0012D6r 3  20 rr rr                     jsr xt_type
0012D9r 3  20 rr rr                     jsr xt_space
0012DCr 3               
0012DCr 3  60           z_dot:          rts
0012DDr 3               
0012DDr 3               
0012DDr 3               
0012DDr 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
0012DDr 3               ; ## ".("  auto  ANS core
0012DDr 3                       ; """http://forth-standard.org/standard/core/Dotp"""
0012DDr 3               
0012DDr 3               xt_dot_paren:
0012DDr 3                               ; Put a right paren on the stack.
0012DDr 3  CA                           dex
0012DEr 3  CA                           dex
0012DFr 3  A9 29                        lda #41     ; Right parenthesis
0012E1r 3  95 00                        sta 0,x
0012E3r 3  74 01                        stz 1,x
0012E5r 3               
0012E5r 3  20 rr rr                     jsr xt_parse
0012E8r 3  20 rr rr                     jsr xt_type
0012EBr 3               
0012EBr 3  60           z_dot_paren:    rts
0012ECr 3               
0012ECr 3               
0012ECr 3               
0012ECr 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
0012ECr 3               ; ## ".""  auto  ANS core ext
0012ECr 3                       ; """https://forth-standard.org/standard/core/Dotq
0012ECr 3                       ; Compile string that is printed during run time. ANS Forth wants
0012ECr 3                       ; this to be compile-only, even though everybody and their friend
0012ECr 3                       ; uses it for everything. We follow the book here, and recommend
0012ECr 3                       ; `.(` for general printing.
0012ECr 3                       ; """
0012ECr 3               
0012ECr 3               xt_dot_quote:
0012ECr 3                               ; we let S" do the heavy lifting. Since we're in
0012ECr 3                               ; compile mode, it will save the string and reproduce it
0012ECr 3                               ; during runtime
0012ECr 3  20 rr rr                     jsr xt_s_quote
0012EFr 3               
0012EFr 3                               ; We then let TYPE do the actual printing
0012EFr 3  A0 rr                        ldy #>xt_type
0012F1r 3  A9 rr                        lda #<xt_type
0012F3r 3  20 rr rr                     jsr cmpl_subroutine
0012F6r 3               
0012F6r 3  60           z_dot_quote:    rts
0012F7r 3               
0012F7r 3               
0012F7r 3               
0012F7r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
0012F7r 3               ; ## ".r"  tested  ANS core ext
0012F7r 3                       ; """https://forth-standard.org/standard/core/DotR
0012F7r 3                       ;
0012F7r 3                       ; Based on the Forth code
0012F7r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
0012F7r 3                       ; """
0012F7r 3               
0012F7r 3               xt_dot_r:
0012F7r 3  20 rr rr                     jsr underflow_2
0012FAr 3               
0012FAr 3  20 rr rr                     jsr xt_to_r
0012FDr 3  20 rr rr                     jsr xt_dup
001300r 3  20 rr rr                     jsr xt_abs
001303r 3  20 rr rr                     jsr xt_zero
001306r 3  20 rr rr                     jsr xt_less_number_sign
001309r 3  20 rr rr                     jsr xt_number_sign_s
00130Cr 3  20 rr rr                     jsr xt_rot
00130Fr 3  20 rr rr                     jsr xt_sign
001312r 3  20 rr rr                     jsr xt_number_sign_greater
001315r 3  20 rr rr                     jsr xt_r_from
001318r 3  20 rr rr                     jsr xt_over
00131Br 3  20 rr rr                     jsr xt_minus
00131Er 3  20 rr rr                     jsr xt_spaces
001321r 3  20 rr rr                     jsr xt_type
001324r 3               
001324r 3  60           z_dot_r:        rts
001325r 3               
001325r 3               
001325r 3               
001325r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
001325r 3               ; ## ".s"  tested  ANS tools
001325r 3                       ; """https://forth-standard.org/standard/tools/DotS
001325r 3                       ; Print content of Data Stack non-distructively. We follow the format
001325r 3                       ; of Gforth and print the number of elements first in brackets,
001325r 3                       ; followed by the Data Stack content (if any).
001325r 3                       ;
001325r 3                       ; Since this is for humans, we don't have to worry about speed.
001325r 3                       ; """
001325r 3               
001325r 3               xt_dot_s:
001325r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
001328r 3               
001328r 3                               ; Print stack depth in brackets
001328r 3  A9 3C                        lda #$3c        ; ASCII for "<"
00132Ar 3  20 rr rr                     jsr emit_a
00132Dr 3               
00132Dr 3                               ; We keep a copy of the number of the things on the stack
00132Dr 3                               ; to use as a counter later down. This assumes that there
00132Dr 3                               ; are less than 255 elements on the stack
00132Dr 3  B5 00                        lda 0,x
00132Fr 3  48                           pha
001330r 3               
001330r 3                               ; print unsigned number without the trailing space
001330r 3  CA                           dex             ; DUP
001331r 3  CA                           dex
001332r 3  95 00                        sta 0,x
001334r 3  74 01                        stz 1,x
001336r 3               
001336r 3  20 rr rr                     jsr print_u
001339r 3               
001339r 3  A9 3E                        lda #$3e        ; ASCII for ">"
00133Br 3  20 rr rr                     jsr emit_a
00133Er 3  A9 20                        lda #AscSP      ; ASCII for SPACE
001340r 3  20 rr rr                     jsr emit_a
001343r 3               
001343r 3  E8                           inx
001344r 3  E8                           inx
001345r 3               
001345r 3                               ; There will be lots of cases where the stack is empty. If that
001345r 3                               ; is so, get out of here quickly
001345r 3  E0 FF                        cpx #dsp0
001347r 3  F0 1E                        beq @done
001349r 3               
001349r 3               @have_stack:
001349r 3                               ; We have at least one element on the stack. The depth of the
001349r 3                               ; stack is on the stack, we can use it as a counter. We go
001349r 3                               ; from bottom to top
001349r 3  7A                           ply
00134Ar 3               
00134Ar 3  A9 FE                        lda #dsp0-1     ; go up one to avoid garbage
00134Cr 3  85 rr                        sta tmp3
00134Er 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
001350r 3               @loop:
001350r 3  CA                           dex
001351r 3  CA                           dex
001352r 3               
001352r 3  B2 rr                        lda (tmp3)
001354r 3  95 01                        sta 1,x
001356r 3  C6 rr                        dec tmp3
001358r 3               
001358r 3  B2 rr                        lda (tmp3)
00135Ar 3  95 00                        sta 0,x
00135Cr 3  C6 rr                        dec tmp3
00135Er 3  5A                           phy
00135Fr 3               
00135Fr 3  20 rr rr                     jsr xt_dot
001362r 3               
001362r 3  7A                           ply
001363r 3  88                           dey
001364r 3  D0 EA                        bne @loop
001366r 3               
001366r 3  48                           pha             ; dummy to balance stack
001367r 3               @done:
001367r 3  68                           pla
001368r 3  60           z_dot_s:        rts
001369r 3               
001369r 3               
001369r 3               
001369r 3               ; ## D_DOT ( d -- ) "Print double"
001369r 3               ; ## "d."  tested  ANS double
001369r 3                       ; """http://forth-standard.org/standard/double/Dd"""
001369r 3                       ;
001369r 3                       ; From the Forth code:
001369r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
001369r 3                       ; """
001369r 3               
001369r 3               xt_d_dot:
001369r 3  20 rr rr                     jsr underflow_2
00136Cr 3               
00136Cr 3  20 rr rr                     jsr xt_tuck
00136Fr 3  20 rr rr                     jsr xt_dabs
001372r 3  20 rr rr                     jsr xt_less_number_sign
001375r 3  20 rr rr                     jsr xt_number_sign_s
001378r 3  20 rr rr                     jsr xt_rot
00137Br 3  20 rr rr                     jsr xt_sign
00137Er 3  20 rr rr                     jsr xt_number_sign_greater
001381r 3  20 rr rr                     jsr xt_type
001384r 3  20 rr rr                     jsr xt_space
001387r 3               
001387r 3  60           z_d_dot:        rts
001388r 3               
001388r 3               
001388r 3               
001388r 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
001388r 3               ; ## "d.r"  tested  ANS double
001388r 3                       ; """http://forth-standard.org/standard/double/DDotR"""
001388r 3                       ; Based on the Forth code
001388r 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
001388r 3                       ; """
001388r 3               
001388r 3               xt_d_dot_r:
001388r 3  20 rr rr                     jsr underflow_3
00138Br 3                               ; From the forth code:
00138Br 3  20 rr rr                     jsr xt_to_r
00138Er 3  20 rr rr                     jsr xt_tuck
001391r 3  20 rr rr                     jsr xt_dabs
001394r 3  20 rr rr                     jsr xt_less_number_sign
001397r 3  20 rr rr                     jsr xt_number_sign_s
00139Ar 3  20 rr rr                     jsr xt_rot
00139Dr 3  20 rr rr                     jsr xt_sign
0013A0r 3  20 rr rr                     jsr xt_number_sign_greater
0013A3r 3  20 rr rr                     jsr xt_r_from
0013A6r 3  20 rr rr                     jsr xt_over
0013A9r 3  20 rr rr                     jsr xt_minus
0013ACr 3  20 rr rr                     jsr xt_spaces
0013AFr 3  20 rr rr                     jsr xt_type
0013B2r 3               
0013B2r 3  60           z_d_dot_r:      rts
0013B3r 3               
0013B3r 3               
0013B3r 3               
0013B3r 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
0013B3r 3               ; ## "drop"  auto  ANS core
0013B3r 3                       ; """https://forth-standard.org/standard/core/DROP"""
0013B3r 3               xt_drop:
0013B3r 3  20 rr rr                     jsr underflow_1
0013B6r 3               
0013B6r 3  E8                           inx
0013B7r 3  E8                           inx
0013B8r 3               
0013B8r 3  60           z_drop:         rts
0013B9r 3               
0013B9r 3               
0013B9r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
0013B9r 3               ; ## "dump"  tested  ANS tools
0013B9r 3                       ; """https://forth-standard.org/standard/tools/DUMP
0013B9r 3                       ;
0013B9r 3                       ; DUMP's exact output is defined as "implementation dependent".
0013B9r 3                       ; This is in assembler because it is
0013B9r 3                       ; useful for testing and development, so we want to have it work
0013B9r 3                       ; as soon as possible. Uses TMP2
0013B9r 3                       ; """
0013B9r 3               
0013B9r 3               xt_dump:
0013B9r 3  20 rr rr                     jsr underflow_2
0013BCr 3               @row:
0013BCr 3                               ; start counter for 16 numbers per row
0013BCr 3  A0 10                        ldy #16
0013BEr 3               
0013BEr 3                               ; We use TMP2 as the index for the ASCII characters
0013BEr 3                               ; that we print at the and of the hex block. We
0013BEr 3                               ; start saving them at HERE (CP)
0013BEr 3  64 rr                        stz tmp2
0013C0r 3               
0013C0r 3  20 rr rr                     jsr xt_cr
0013C3r 3               
0013C3r 3                               ; print address number
0013C3r 3  B5 03                        lda 3,x
0013C5r 3  20 rr rr                     jsr byte_to_ascii
0013C8r 3  B5 02                        lda 2,x
0013CAr 3  20 rr rr                     jsr byte_to_ascii
0013CDr 3               
0013CDr 3  20 rr rr                     jsr xt_space
0013D0r 3  20 rr rr                     jsr xt_space
0013D3r 3               @loop:
0013D3r 3                               ; if there are zero bytes left to display, we're done
0013D3r 3  B5 00                        lda 0,x
0013D5r 3  15 01                        ora 1,x
0013D7r 3  F0 39                        beq @all_printed
0013D9r 3               
0013D9r 3                               ; dump the contents
0013D9r 3  A1 02                        lda (2,x)
0013DBr 3  48                           pha                     ; byte_to_ascii destroys A
0013DCr 3  20 rr rr                     jsr byte_to_ascii
0013DFr 3  20 rr rr                     jsr xt_space
0013E2r 3  68                           pla
0013E3r 3               
0013E3r 3                               ; Handle ASCII printing
0013E3r 3  20 rr rr                     jsr is_printable
0013E6r 3  B0 02                        bcs @printable
0013E8r 3  A9 2E                        lda #'.'                 ; Print dot if not printable
0013EAr 3               @printable:
0013EAr 3  5A                           phy                     ; save counter
0013EBr 3  A4 rr                        ldy tmp2
0013EDr 3  91 rr                        sta (cp),y
0013EFr 3  E6 rr                        inc tmp2
0013F1r 3  7A                           ply
0013F2r 3               
0013F2r 3                               ; extra space after eight bytes
0013F2r 3  C0 09                        cpy #9
0013F4r 3  D0 03                        bne @next_char
0013F6r 3  20 rr rr                     jsr xt_space
0013F9r 3               
0013F9r 3               @next_char:
0013F9r 3  F6 02                        inc 2,x
0013FBr 3  D0 02                        bne @counter
0013FDr 3  F6 03                        inc 3,x
0013FFr 3               
0013FFr 3               @counter:
0013FFr 3                               ; loop counter
0013FFr 3  B5 00                        lda 0,x
001401r 3  D0 02                        bne @1
001403r 3  D6 01                        dec 1,x
001405r 3               @1:
001405r 3  D6 00                        dec 0,x
001407r 3  88                           dey
001408r 3  D0 C9                        bne @loop               ; next byte
00140Ar 3               
00140Ar 3                               ; Done with one line, print the ASCII version of these
00140Ar 3                               ; characters
00140Ar 3  20 rr rr                     jsr xt_space
00140Dr 3  20 rr rr                     jsr print_ascii
001410r 3               
001410r 3  80 AA                        bra @row                ; new row
001412r 3               
001412r 3               @all_printed:
001412r 3                               ; See if there are any ASCII characters in the buffer
001412r 3                               ; left to print
001412r 3  A5 rr                        lda tmp2
001414r 3  F0 06                        beq @done
001416r 3               
001416r 3                               ; In theory, we could try to make the ASCII part line
001416r 3                               ; up with the line before it. But that is a hassle (we
001416r 3                               ; use three bytes for each missed hex entry, and
001416r 3                               ; then there is the gap after eight entries) and it
001416r 3                               ; makes it harder to read. We settle for one extra
001416r 3                               ; space instead for the moment
001416r 3  20 rr rr                     jsr xt_space
001419r 3  20 rr rr                     jsr print_ascii
00141Cr 3               @done:
00141Cr 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
00141Fr 3  60           z_dump:         rts
001420r 3               
001420r 3               
001420r 3               print_ascii:
001420r 3                               ; Print the ASCII characters that we have saved from
001420r 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
001420r 3                               ; is not compiled (DUMP is probably never compiled anyway)
001420r 3                               ; but we keep it inside the scope of DUMP.
001420r 3  A0 00                        ldy #0
001422r 3               @ascii_loop:
001422r 3  B1 rr                        lda (cp),y
001424r 3  20 rr rr                     jsr emit_a
001427r 3  C8                           iny
001428r 3               
001428r 3                               ; extra space after eight chars
001428r 3  C0 08                        cpy #8
00142Ar 3  D0 03                        bne @1
00142Cr 3  20 rr rr                     jsr xt_space
00142Fr 3               @1:
00142Fr 3  C6 rr                        dec tmp2
001431r 3  D0 EF                        bne @ascii_loop
001433r 3               
001433r 3  60                           rts
001434r 3               
001434r 3               
001434r 3               
001434r 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
001434r 3               ; ## "dup"  auto  ANS core
001434r 3                       ; """https://forth-standard.org/standard/core/DUP"""
001434r 3               xt_dup:
001434r 3  20 rr rr                     jsr underflow_1
001437r 3               
001437r 3  CA                           dex
001438r 3  CA                           dex
001439r 3               
001439r 3  B5 02                        lda 2,x         ; LSB
00143Br 3  95 00                        sta 0,x
00143Dr 3  B5 03                        lda 3,x         ; MSB
00143Fr 3  95 01                        sta 1,x
001441r 3               
001441r 3  60           z_dup:          rts
001442r 3               
001442r 3               
001442r 3               ; ## ED ( -- u ) "Line-based editor"
001442r 3               ; ## "ed"  fragment  Tali Forth
001442r 3                       ; """Start the line-based editor ed6502. See separate file
001442r 3                       ; ed.asm or the manual for details.
001442r 3                       ; """
001442r 3               xt_ed:
001442r 3                           .ifdef ed6502
001442r 3                               jsr ed6502      ; kept in separate file
001442r 3                           .endif
001442r 3               
001442r 3  60           z_ed:           rts
001443r 3               
001443r 3               
001443r 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
001443r 3               ; ## "editor-wordlist"  tested  Tali Editor
001443r 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
001443r 3                       ; words to the search order so they can be used.  This will need
001443r 3                       ; to be done before any of the words marked "Tali Editor" can be
001443r 3                       ; used.  See the tutorial on Wordlists and the Search Order for
001443r 3                       ; more information.
001443r 3               
001443r 3                       ;
001443r 3                       ; This is a dummy entry, the code is shared with ONE
001443r 3                       ; """
001443r 3               
001443r 3               
001443r 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
001443r 3               ; ## "else"  auto  ANS core
001443r 3                       ; """http://forth-standard.org/standard/core/ELSE
001443r 3                       ;
001443r 3                       ; The code is shared with ENDOF
001443r 3                       ; """
001443r 3               
001443r 3               xt_else:
001443r 3               xt_endof:
001443r 3                               ; Put an unconditional branch.
001443r 3  A0 rr                        ldy #>branch_runtime
001445r 3  A9 rr                        lda #<branch_runtime
001447r 3  20 rr rr                     jsr cmpl_subroutine
00144Ar 3               
00144Ar 3                               ; Put the address of the branch address on the stack.
00144Ar 3  20 rr rr                     jsr xt_here
00144Dr 3               
00144Dr 3                               ; Use zero for the branch address for now.
00144Dr 3                               ; THEN will fill it in later.
00144Dr 3  20 rr rr                     jsr xt_zero
001450r 3  20 rr rr                     jsr xt_comma
001453r 3               
001453r 3                               ; Get the address to jump to (just after the
001453r 3                               ; unconditional branch) for the IF to jump to
001453r 3                               ; when false.
001453r 3  20 rr rr                     jsr xt_here
001456r 3  20 rr rr                     jsr xt_rot
001459r 3               
001459r 3                               ; Update the original if 0branch address.
001459r 3  20 rr rr                     jsr xt_store
00145Cr 3               z_else:
00145Cr 3               z_endof:
00145Cr 3  60                           rts
00145Dr 3               
00145Dr 3               
00145Dr 3               
00145Dr 3               branch_runtime:
00145Dr 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
00145Dr 3                       ; formally part of a separate word BRANCH which was later removed.
00145Dr 3                       ; """
00145Dr 3               
00145Dr 3                               ; The address on the Return Stack points to the last byte
00145Dr 3                               ; of the JSR address, one byte below the branch literal
00145Dr 3  68                           pla
00145Er 3  85 rr                        sta tmpbranch
001460r 3  68                           pla
001461r 3  85 rr                        sta tmpbranch+1
001463r 3               
001463r 3                               ; Keep in mind: the address we just popped points one byte
001463r 3                               ; lower than the branch literal we want to grab
001463r 3  A0 01                        ldy #1
001465r 3  B1 rr                        lda (tmpbranch),y  ; LSB
001467r 3  85 rr                        sta tmp1
001469r 3  C8                           iny
00146Ar 3  B1 rr                        lda (tmpbranch),y  ; MSB
00146Cr 3  85 rr                        sta tmp1+1
00146Er 3               
00146Er 3  6C rr rr                     jmp (tmp1)
001471r 3               
001471r 3               
001471r 3               
001471r 3               ; ## EMIT ( char -- ) "Print character to current output"
001471r 3               ; ## "emit"  auto  ANS core
001471r 3                       ; """https://forth-standard.org/standard/core/EMIT
001471r 3                       ; Run-time default for EMIT. The user can revector this by changing
001471r 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
001471r 3                       ; do not check to see if we have been given a valid ASCII character.
001471r 3                       ; Don't make this native compile.
001471r 3                       ; """
001471r 3               
001471r 3               xt_emit:
001471r 3  20 rr rr                     jsr underflow_1
001474r 3               
001474r 3  B5 00                        lda 0,x
001476r 3  E8                           inx
001477r 3  E8                           inx
001478r 3               
001478r 3               emit_a:
001478r 3                       ; We frequently want to print the character in A without fooling
001478r 3                       ; around with the Data Stack. This is emit_a's job, which still
001478r 3                       ; allows the output to be vectored. Call it with JSR as you
001478r 3                       ; would XT_EMIT
001478r 3  6C rr rr                     jmp (output)            ; JSR/RTS
00147Br 3               
00147Br 3               z_emit:         ; never reached
00147Br 3               
00147Br 3               
00147Br 3               
00147Br 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
00147Br 3               ; ## "empty-buffers"  tested  ANS block ext
00147Br 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
00147Br 3               xt_empty_buffers:
00147Br 3                               ; Set the buffer status to empty.
00147Br 3  A0 2C                        ldy #buffstatus_offset
00147Dr 3  A9 00                        lda #0
00147Fr 3  91 rr                        sta (up),y      ; Only LSB is used.
001481r 3               z_empty_buffers:
001481r 3  60                           rts
001482r 3               
001482r 3               
001482r 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
001482r 3               ; ## "endcase"  auto  ANS core ext
001482r 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
001482r 3               
001482r 3               xt_endcase:
001482r 3                               ; Postpone DROP to remove the item
001482r 3                               ; being checked.
001482r 3  A0 rr                        ldy #>xt_drop
001484r 3  A9 rr                        lda #<xt_drop
001486r 3  20 rr rr                     jsr cmpl_subroutine
001489r 3               
001489r 3                               ; There are a number of address (of branches that need their
001489r 3                               ; jump addressed filled in with the address of right here).
001489r 3                               ; Keep calling THEN to deal with them until we reach the
001489r 3                               ; 0 that CASE put on the stack at the beginning.
001489r 3               @endcase_loop:
001489r 3                               ; Check for 0 on the stack.
001489r 3  B5 00                        lda 0,x
00148Br 3  15 01                        ora 1,x
00148Dr 3  F0 05                        beq @done
00148Fr 3               
00148Fr 3  20 rr rr                     jsr xt_then
001492r 3  80 F5                        bra @endcase_loop
001494r 3               @done:
001494r 3                               ; Remove the 0 from the stack.
001494r 3  E8                           inx
001495r 3  E8                           inx
001496r 3  60           z_endcase:      rts
001497r 3               
001497r 3               
001497r 3               
001497r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
001497r 3               ; ## "endof"  auto  ANS core ext
001497r 3                       ; """http://forth-standard.org/standard/core/ENDOF
001497r 3                       ; This is a dummy entry, the code is shared with ELSE
001497r 3                       ; """
001497r 3               
001497r 3               
001497r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
001497r 3               ; ## "environment?"  auto  ANS core
001497r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
001497r 3                       ;
001497r 3                       ; By ANS definition, we use upper-case strings here, see the
001497r 3                       ; string file for details. This can be realized as a high-level
001497r 3                       ; Forth word as
001497r 3                       ;
001497r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
001497r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
001497r 3                       ; HEX
001497r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
001497r 3                       ; CASE
001497r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
001497r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
001497r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
001497r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
001497r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
001497r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
001497r 3                       ; S" MAX-D"              STRING_OF
001497r 3                                                    ; 7FFFFFFF. TRUE ENDOF
001497r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
001497r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
001497r 3                       ; S" MAX-UD"             STRING_OF
001497r 3                                                    ; FFFFFFFF. TRUE ENDOF
001497r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
001497r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
001497r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
001497r 3                       ; ENDCASE ;
001497r 3                       ;
001497r 3                       ; but that uses lots of memory and increases the start up time. This
001497r 3                       ; word is rarely used so we can try to keep it short at the expense
001497r 3                       ; of speed.
001497r 3                       ; """
001497r 3               
001497r 3               xt_environment_q:
001497r 3  20 rr rr                     jsr underflow_1
00149Ar 3               
00149Ar 3                               ; This code is table-driven: We walk through the list of
00149Ar 3                               ; strings until we find one that matches, and then we take
00149Ar 3                               ; the equivalent data from the results table. This is made
00149Ar 3                               ; a bit harder by the fact that some of these return a
00149Ar 3                               ; double-cell number and some a single-cell one.
00149Ar 3               
00149Ar 3                               ; We will walk through the table with variables that return
00149Ar 3                               ; a single-cell result
00149Ar 3  A0 00                        ldy #00                 ; counter for table
00149Cr 3               
00149Cr 3                               ; We use a flag on the the stack to signal if we have a single-cell
00149Cr 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
00149Cr 3                               ; double-cell.
00149Cr 3  5A                           phy
00149Dr 3               @table_loop:
00149Dr 3                               ; We arrived here with the address of the string to be checked
00149Dr 3                               ; on the stack. We make a copy. Index is in Y
00149Dr 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
0014A0r 3               
0014A0r 3                               ; We do our work on the TOS to speed things up
0014A0r 3  CA                           dex
0014A1r 3  CA                           dex                     ; ( addr u addr u ? )
0014A2r 3               
0014A2r 3                               ; Get address of string to check from table
0014A2r 3  B9 rr rr                     lda env_table_single,y
0014A5r 3  95 00                        sta 0,x
0014A7r 3  C8                           iny
0014A8r 3  B9 rr rr                     lda env_table_single,y
0014ABr 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
0014ADr 3  C8                           iny
0014AEr 3               
0014AEr 3                               ; See if this is the last entry. The LSB is still in A
0014AEr 3  15 00                        ora 0,x
0014B0r 3  F0 4D                        beq @table_done
0014B2r 3               
0014B2r 3                               ; We have a string entry. The address there is stored in
0014B2r 3                               ; old-style address format, that is, the first byte is the
0014B2r 3                               ; length of the string
0014B2r 3  5A                           phy                     ; save Y, which is used by COUNT
0014B3r 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
0014B6r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
0014B9r 3  7A                           ply
0014BAr 3               
0014BAr 3                               ; If we found a match (flag is zero -- COMPARE is weird
0014BAr 3                               ; that way), return the result
0014BAr 3  B5 00                        lda 0,x
0014BCr 3  15 01                        ora 1,x
0014BEr 3  F0 04                        beq @got_result
0014C0r 3               
0014C0r 3                               ; Flag is not zero, so not a perfect match, so try next
0014C0r 3                               ; word
0014C0r 3  E8                           inx                     ; DROP, now ( addr u )
0014C1r 3  E8                           inx
0014C2r 3               
0014C2r 3  80 D9                        bra @table_loop
0014C4r 3               
0014C4r 3               @got_result:
0014C4r 3                               ; We arrive here with ( addr u -1 ) and know that we've found
0014C4r 3                               ; a match. The index of the match+2 is in Y.
0014C4r 3  E8                           inx                     ; drop flag, now ( addr u )
0014C5r 3  E8                           inx
0014C6r 3  88                           dey                     ; go back to index we had
0014C7r 3  88                           dey
0014C8r 3               
0014C8r 3                               ; See if this is a single-cell word.
0014C8r 3  68                           pla
0014C9r 3  D0 0D                        bne @double_result
0014CBr 3               
0014CBr 3                               ; Single-cell result
0014CBr 3  B9 rr rr                     lda env_results_single,y
0014CEr 3  95 02                        sta 2,x
0014D0r 3  C8                           iny
0014D1r 3  B9 rr rr                     lda env_results_single,y
0014D4r 3  95 03                        sta 3,x                 ; ( res u )
0014D6r 3               
0014D6r 3  80 1F                        bra @set_flag
0014D8r 3               
0014D8r 3               @double_result:
0014D8r 3                               ; This is a double-celled result, which means we have to
0014D8r 3                               ; fool around with the index some more. We also need a
0014D8r 3                               ; further cell on the stack
0014D8r 3  CA                           dex                     ; ( addr u ? )
0014D9r 3  CA                           dex
0014DAr 3               
0014DAr 3                               ; We have 11 single-cell words we check, plus the 0000 as
0014DAr 3                               ; a marker for the end of the table, so we arrive here
0014DAr 3                               ; with Y as 22 or more. To get the index for the double-
0014DAr 3                               ; cell words, we move the result
0014DAr 3  98                           tya
0014DBr 3  38                           sec
0014DCr 3  E9 18                        sbc #24
0014DEr 3               
0014DEr 3                               ; We have four bytes per entry in the table, but the index
0014DEr 3                               ; keeps increasing by two, so we only have to multiply by
0014DEr 3                               ; two (shift left once) to get the right result
0014DEr 3  0A                           asl
0014DFr 3  A8                           tay
0014E0r 3               
0014E0r 3  B9 rr rr                     lda env_results_double,y
0014E3r 3  95 02                        sta 2,x
0014E5r 3  C8                           iny
0014E6r 3  B9 rr rr                     lda env_results_double,y
0014E9r 3  95 03                        sta 3,x                 ; ( res u ? )
0014EBr 3  C8                           iny
0014ECr 3               
0014ECr 3  B9 rr rr                     lda env_results_double,y
0014EFr 3  95 04                        sta 4,x
0014F1r 3  C8                           iny
0014F2r 3  B9 rr rr                     lda env_results_double,y
0014F5r 3  95 05                        sta 5,x                 ; ( res res ? )
0014F7r 3               
0014F7r 3                               ; fall through to @set_flag
0014F7r 3               @set_flag:
0014F7r 3  A9 FF                        lda #$ff
0014F9r 3  95 00                        sta 0,x
0014FBr 3  95 01                        sta 1,x                 ; ( res f )
0014FDr 3               
0014FDr 3  80 14                        bra @done
0014FFr 3               @table_done:
0014FFr 3                               ; We're done with a table, because the entry was a zero.
0014FFr 3                               ; We arrive here with ( addr u addr u 0 )
0014FFr 3               
0014FFr 3                               ; We take the flag from stack and increase it by one. If the
0014FFr 3                               ; flag is zero, we have just completed the single-cell number
0014FFr 3                               ; strings, so we in increase the flag and try again. Otherwise,
0014FFr 3                               ; we're done with the double-cell table without having found
0014FFr 3                               ; a match, and we're done
0014FFr 3  68                           pla
001500r 3  D0 09                        bne @no_match
001502r 3               
001502r 3                               ; Flag is zero, increase it to one and start over to check
001502r 3                               ; double-cell values
001502r 3  1A                           inc
001503r 3  48                           pha
001504r 3               
001504r 3  8A                           txa
001505r 3  18                           clc
001506r 3  69 06                        adc #6                  ; skip six bytes
001508r 3  AA                           tax                     ; ( addr u )
001509r 3               
001509r 3  80 92                        bra @table_loop
00150Br 3               @no_match:
00150Br 3                               ; Bummer, not found. We arrive here with
00150Br 3                               ; ( addr u addr u 0 ) and need to return just a zero
00150Br 3  8A                           txa
00150Cr 3  18                           clc
00150Dr 3  69 0A                        adc #10
00150Fr 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
001510r 3               
001510r 3  20 rr rr                     jsr xt_false
001513r 3               @done:
001513r 3               z_environment_q:
001513r 3  60                           rts
001514r 3               
001514r 3               
001514r 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
001514r 3               ; results and one for the double-celled results. The zero cell at the
001514r 3               ; end of each table marks its, uh, end. The strings themselves are defined
001514r 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
001514r 3               ; have to adapt the result code for double printout, where we subtract 22
001514r 3               ; (two bytes each single-cell string and two bytes for the end-of-table
001514r 3               ; marker 0000
001514r 3               env_table_single:
001514r 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
001518r 3  rr rr rr rr  
00151Cr 3  rr rr        
00151Er 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
001522r 3  rr rr rr rr  
001526r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
00152Ar 3  00 00        
00152Cr 3               
00152Cr 3               env_table_double:
00152Cr 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
001530r 3  00 00        
001532r 3               
001532r 3               env_results_single:
001532r 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
001534r 3  FF 00                .word $00FF     ; /HOLD
001536r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
001538r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
00153Ar 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
00153Cr 3  FF 00                .word $00FF     ; MAX-CHAR
00153Er 3  FF 7F                .word $7FFF     ; MAX-N
001540r 3  FF FF                .word $FFFF     ; MAX-U
001542r 3  80 00                .word $0080     ; RETURN-STACK-CELLS
001544r 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
001546r 3  09 00                .word $0009     ; WORDLISTS
001548r 3               
001548r 3               env_results_double:
001548r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
00154Cr 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
001550r 3               
001550r 3               
001550r 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
001550r 3               ; ## "="  auto  ANS core
001550r 3                       ; """https://forth-standard.org/standard/core/Equal"""
001550r 3               
001550r 3               xt_equal:
001550r 3  20 rr rr                     jsr underflow_2
001553r 3               
001553r 3  B5 00                        lda 0,x                 ; LSB
001555r 3  D5 02                        cmp 2,x
001557r 3  D0 0A                        bne @false
001559r 3               
001559r 3  B5 01                        lda 1,x                 ; MSB
00155Br 3  D5 03                        cmp 3,x
00155Dr 3  D0 04                        bne @false
00155Fr 3               
00155Fr 3  A9 FF                        lda #$ff
001561r 3  80 02                        bra @done
001563r 3               
001563r 3  A9 00        @false:         lda #0                  ; drop thru to done
001565r 3               
001565r 3  95 02        @done:          sta 2,x
001567r 3  95 03                        sta 3,x
001569r 3               
001569r 3  E8                           inx
00156Ar 3  E8                           inx
00156Br 3               
00156Br 3  60           z_equal:        rts
00156Cr 3               
00156Cr 3               
00156Cr 3               
00156Cr 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
00156Cr 3               ; ## "blank"  auto  ANS string
00156Cr 3                       ; """https://forth-standard.org/standard/string/BLANK"""
00156Cr 3               xt_blank:
00156Cr 3                               ; We don't check for underflow here because
00156Cr 3                               ; we deal with that in FILL
00156Cr 3  CA                           dex
00156Dr 3  CA                           dex
00156Er 3  A9 20                        lda #AscSP
001570r 3  95 00                        sta 0,x
001572r 3  74 01                        stz 1,x
001574r 3               
001574r 3  80 06                        bra xt_fill     ; skip over code for ERASE
001576r 3               
001576r 3               
001576r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
001576r 3               ; ## "erase"  auto  ANS core ext
001576r 3                       ; """https://forth-standard.org/standard/core/ERASE
001576r 3                       ; Note that ERASE works with "address" units
001576r 3                       ; (bytes), not cells.
001576r 3                       ; """
001576r 3               
001576r 3               xt_erase:
001576r 3                               ; We don't check for underflow here because
001576r 3                               ; we deal with that in FILL
001576r 3  CA                           dex
001577r 3  CA                           dex
001578r 3  74 00                        stz 0,x
00157Ar 3  74 01                        stz 1,x
00157Cr 3               
00157Cr 3                               ; fall through to FILL
00157Cr 3               
00157Cr 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
00157Cr 3               ; ## "fill"  auto  ANS core
00157Cr 3                       ; """https://forth-standard.org/standard/core/FILL
00157Cr 3                       ; Fill u bytes of memory with char starting at addr. Note that
00157Cr 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
00157Cr 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
00157Cr 3                       ; happens when we reach the end of the address space
00157Cr 3                       ; """
00157Cr 3               xt_fill:
00157Cr 3  20 rr rr                     jsr underflow_3
00157Fr 3               
00157Fr 3                               ; We use tmp1 to hold the address
00157Fr 3  B5 04                        lda 4,x         ; LSB
001581r 3  85 rr                        sta tmp1
001583r 3  B5 05                        lda 5,x
001585r 3  85 rr                        sta tmp1+1
001587r 3               
001587r 3                               ; We use tmp2 to hold the counter
001587r 3  B5 02                        lda 2,x
001589r 3  85 rr                        sta tmp2
00158Br 3  B5 03                        lda 3,x
00158Dr 3  85 rr                        sta tmp2+1
00158Fr 3               
00158Fr 3                               ; We use Y to hold the character
00158Fr 3  B5 00                        lda 0,x
001591r 3  A8                           tay
001592r 3               @loop:
001592r 3                               ; Unfortunately, we also need to make sure that we don't
001592r 3                               ; write further than the end of the RAM. So RAM_END must
001592r 3                               ; be larger or equal to the current address
001592r 3  A9 80                        lda #>ram_end           ; MSB
001594r 3  C5 rr                        cmp tmp1+1
001596r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
001598r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
00159Ar 3               
00159Ar 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
00159Cr 3  C5 rr                        cmp tmp1
00159Er 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
0015A0r 3               
0015A0r 3               @check_counter:
0015A0r 3                               ; See if our counter has reached zero
0015A0r 3  A5 rr                        lda tmp2
0015A2r 3  05 rr                        ora tmp2+1
0015A4r 3  F0 13                        beq @done
0015A6r 3               
0015A6r 3                               ; We're not in ROM and we still have stuff on the counter, so
0015A6r 3                               ; let's actually do what we came here to do
0015A6r 3  98                           tya
0015A7r 3  92 rr                        sta (tmp1)
0015A9r 3               
0015A9r 3                               ; Adjust the counter
0015A9r 3  A5 rr                        lda tmp2
0015ABr 3  D0 02                        bne @1
0015ADr 3  C6 rr                        dec tmp2+1
0015AFr 3  C6 rr        @1:               dec tmp2
0015B1r 3               
0015B1r 3                               ; Next address
0015B1r 3  E6 rr                        inc tmp1
0015B3r 3  D0 DD                        bne @loop
0015B5r 3  E6 rr                        inc tmp1+1
0015B7r 3               
0015B7r 3  80 D9                        bra @loop
0015B9r 3               
0015B9r 3               @done:
0015B9r 3                               ; Drop three cells off the Data Stack. This uses one byte
0015B9r 3                               ; less than six times INX
0015B9r 3  8A                           txa
0015BAr 3  18                           clc
0015BBr 3  69 06                        adc #6
0015BDr 3  AA                           tax
0015BEr 3               z_blank:
0015BEr 3               z_erase:
0015BEr 3  60           z_fill:         rts
0015BFr 3               
0015BFr 3               
0015BFr 3               
0015BFr 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
0015BFr 3               ; ## "execute"  auto  ANS core
0015BFr 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
0015BFr 3               xt_execute:
0015BFr 3  20 rr rr                     jsr underflow_1
0015C2r 3               
0015C2r 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
0015C5r 3               
0015C5r 3  60           z_execute:      rts
0015C6r 3               
0015C6r 3               doexecute:
0015C6r 3  B5 00                        lda 0,x
0015C8r 3  85 rr                        sta ip
0015CAr 3  B5 01                        lda 1,x
0015CCr 3  85 rr                        sta ip+1
0015CEr 3               
0015CEr 3  E8                           inx
0015CFr 3  E8                           inx
0015D0r 3               
0015D0r 3                               ; we don't need a RTS here because we highjack the RTS of
0015D0r 3                               ; the word we're calling to get back to xt_execute
0015D0r 3  6C rr rr                     jmp (ip)
0015D3r 3               
0015D3r 3               ; end of doexecute
0015D3r 3               
0015D3r 3               
0015D3r 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
0015D3r 3               ; ## "execute-parsing"  auto  Gforth
0015D3r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
0015D3r 3                       ; Execute the parsing word defined by the execution token (xt) on the
0015D3r 3                       ; string as if it were passed on the command line. See the file
0015D3r 3                       ; tests/tali.fs for examples.
0015D3r 3                       ;
0015D3r 3                       ; Note that this word is coded completely
0015D3r 3                       ; different in its Gforth version, see the file execute-parsing.fs
0015D3r 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
0015D3r 3                       ; """
0015D3r 3               xt_execute_parsing:
0015D3r 3  20 rr rr                     jsr underflow_3
0015D6r 3               
0015D6r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
0015D9r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
0015DCr 3               
0015DCr 3  B5 00                        lda 0,x                 ; TOS is new ciblen
0015DEr 3  85 rr                        sta ciblen
0015E0r 3  B5 01                        lda 1,x
0015E2r 3  85 rr                        sta ciblen+1
0015E4r 3               
0015E4r 3  B5 02                        lda 2,x                 ; NOS is new cib
0015E6r 3  85 rr                        sta cib
0015E8r 3  B5 03                        lda 3,x
0015EAr 3  85 rr                        sta cib+1
0015ECr 3               
0015ECr 3  64 rr                        stz toin                ; Set >IN to zero
0015EEr 3  64 rr                        stz toin+1
0015F0r 3               
0015F0r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
0015F3r 3  20 rr rr                     jsr xt_execute
0015F6r 3               
0015F6r 3  20 rr rr                     jsr xt_r_to_input
0015F9r 3               
0015F9r 3               z_execute_parsing:
0015F9r 3  60                           rts
0015FAr 3               
0015FAr 3               
0015FAr 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
0015FAr 3               ; ## "exit"  auto  ANS core
0015FAr 3                       ; """https://forth-standard.org/standard/core/EXIT
0015FAr 3                       ; If we're in a loop, we need to UNLOOP first and get everything
0015FAr 3                       ; we we might have put on the Return Stack off as well. This should
0015FAr 3                       ; be natively compiled.
0015FAr 3                       ; """
0015FAr 3               
0015FAr 3               xt_exit:
0015FAr 3  60                           rts             ; keep before z_exit
0015FBr 3               z_exit:                         ; never reached
0015FBr 3               
0015FBr 3               
0015FBr 3               
0015FBr 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
0015FBr 3               ; ## "false"  auto  ANS core ext
0015FBr 3                       ; """https://forth-standard.org/standard/core/FALSE"""
0015FBr 3               xt_false:
0015FBr 3  CA                           dex
0015FCr 3  CA                           dex
0015FDr 3  74 00                        stz 0,x
0015FFr 3  74 01                        stz 1,x
001601r 3               
001601r 3  60           z_false:        rts
001602r 3               
001602r 3               
001602r 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
001602r 3               ; ## "@"  auto  ANS core
001602r 3                       ; """https://forth-standard.org/standard/core/Fetch"""
001602r 3               xt_fetch:
001602r 3  20 rr rr                     jsr underflow_1
001605r 3               
001605r 3  A1 00                        lda (0,x)               ; LSB
001607r 3  A8                           tay
001608r 3  F6 00                        inc 0,x
00160Ar 3  D0 02                        bne @1
00160Cr 3  F6 01                        inc 1,x
00160Er 3               @1:
00160Er 3  A1 00                        lda (0,x)               ; MSB
001610r 3  95 01                        sta 1,x
001612r 3  94 00                        sty 0,x
001614r 3               
001614r 3  60           z_fetch:        rts
001615r 3               
001615r 3               
001615r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
001615r 3               ; ## "find"  auto  ANS core
001615r 3                       ; """https://forth-standard.org/standard/core/FIND
001615r 3                       ; Included for backwards compatibility only, because it still
001615r 3                       ; can be found in so may examples. It should, however, be replaced
001615r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
001615r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
001615r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
001615r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
001615r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
001615r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001615r 3                       ; """
001615r 3               
001615r 3               xt_find:
001615r 3  20 rr rr                     jsr underflow_1
001618r 3               
001618r 3                               ; Save address in case conversion fails. We use the
001618r 3                               ; Return Stack instead of temporary variables like TMP1
001618r 3                               ; because this is shorter and anybody still using FIND
001618r 3                               ; can't be worried about speed anyway
001618r 3  B5 01                        lda 1,x                 ; MSB
00161Ar 3  48                           pha
00161Br 3  B5 00                        lda 0,x                 ; LSB
00161Dr 3  48                           pha
00161Er 3               
00161Er 3                               ; Convert ancient-type counted string address to
00161Er 3                               ; modern format
00161Er 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
001621r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
001624r 3               
001624r 3  B5 00                        lda 0,x
001626r 3  15 01                        ora 1,x
001628r 3  D0 0B                        bne @found_word
00162Ar 3               
00162Ar 3                               ; No word found. Return address of the string and a false
00162Ar 3                               ; flag
00162Ar 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
00162Dr 3               
00162Dr 3                               ; The address needs to be restored.
00162Dr 3  68                           pla                     ; LSB of address
00162Er 3  95 02                        sta 2,x
001630r 3  68                           pla
001631r 3  95 03                        sta 3,x                 ; MSB of address
001633r 3               
001633r 3  80 27                        bra @done               ; ( addr 0 )
001635r 3               
001635r 3               @found_word:
001635r 3                               ; We don't need the address after all, dump it
001635r 3  68                           pla
001636r 3  68                           pla
001637r 3               
001637r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
001637r 3                               ; convert the return values to FIND's format
001637r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00163Ar 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
00163Dr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001640r 3               
001640r 3  A0 00                        ldy #0                  ; Prepare flag
001642r 3               
001642r 3                               ; The flags are in the second byte of the header
001642r 3  F6 00                        inc 0,x
001644r 3  D0 02                        bne @1
001646r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
001648r 3               @1:
001648r 3  A1 00                        lda (0,x)               ; ( xt char )
00164Ar 3  29 04                        and #IM
00164Cr 3  D0 08                        bne @immediate          ; bit set, we're immediate
00164Er 3               
00164Er 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001650r 3  95 00                        sta 0,x
001652r 3  95 01                        sta 1,x
001654r 3  80 06                        bra @done
001656r 3               
001656r 3               @immediate:
001656r 3  A9 01                        lda #1                  ; We're immediate, return 1
001658r 3  95 00                        sta 0,x
00165Ar 3  74 01                        stz 1,x
00165Cr 3               @done:
00165Cr 3  60           z_find:         rts
00165Dr 3               
00165Dr 3               
00165Dr 3               
00165Dr 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
00165Dr 3               ; ## "find-name"  auto  Gforth
00165Dr 3               
00165Dr 3               xt_find_name:
00165Dr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00165Dr 3                       ; Given a string, find the Name Token (nt) of a word or return
00165Dr 3                       ; zero if the word is not in the dictionary. We use this instead of
00165Dr 3                       ; ancient FIND to look up words in the Dictionary passed by
00165Dr 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
00165Dr 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
00165Dr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00165Dr 3                       ; FIND calls this word
00165Dr 3                       ; """
00165Dr 3  20 rr rr                     jsr underflow_2
001660r 3               
001660r 3                               ; check for special case of an empty string (length zero)
001660r 3  B5 00                        lda 0,x
001662r 3  15 01                        ora 1,x
001664r 3  D0 03                        bne @nonempty
001666r 3               
001666r 3  4C rr rr                     jmp @fail_done
001669r 3               
001669r 3               @nonempty:
001669r 3                               ; Set up for traversing the wordlist search order.
001669r 3  64 rr                        stz tmp3                ; Start at the beginning
00166Br 3               
00166Br 3               @wordlist_loop:
00166Br 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
00166Dr 3  A5 rr                        lda tmp3
00166Fr 3  D1 rr                        cmp (up),y              ; Check to see if we are done
001671r 3  D0 03                        bne @have_string
001673r 3               
001673r 3                               ; We ran out of wordlists to search.
001673r 3  4C rr rr                     jmp @fail_done
001676r 3               
001676r 3               @have_string:
001676r 3                               ; set up first loop iteration
001676r 3               
001676r 3                               ; Get the current wordlist id
001676r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
001677r 3  69 1F                        adc #search_order_offset
001679r 3  A8                           tay
00167Ar 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
00167Cr 3                                               ; into the cell array WORDLISTS
00167Cr 3               
00167Cr 3                               ; Get the DP for that wordlist.
00167Cr 3  0A                           asl                     ; Turn offset into cells offset.
00167Dr 3  18                           clc
00167Er 3  69 06                        adc #wordlists_offset
001680r 3  A8                           tay
001681r 3  B1 rr                        lda (up),y
001683r 3  85 rr                        sta tmp1
001685r 3  C8                           iny
001686r 3  B1 rr                        lda (up),y
001688r 3  85 rr                        sta tmp1+1
00168Ar 3               
00168Ar 3  B5 02                        lda 2,x                 ; Address of mystery string
00168Cr 3  85 rr                        sta tmp2
00168Er 3  B5 03                        lda 3,x
001690r 3  85 rr                        sta tmp2+1
001692r 3               
001692r 3               @loop:
001692r 3                               ; first quick test: Are strings the same length?
001692r 3  B2 rr                        lda (tmp1)
001694r 3  D5 00                        cmp 0,x
001696r 3  D0 54                        bne @next_entry
001698r 3               
001698r 3               @compare_string:
001698r 3                               ; are the same length, so we now have to compare each
001698r 3                               ; character
001698r 3               
001698r 3                               ; second quick test: Is the first character the same?
001698r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
00169Ar 3               
00169Ar 3                               ; Lowercase the incoming charcter.
00169Ar 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
00169Cr 3  B0 07                        bcs @compare_first
00169Er 3  C9 41                        cmp #$41        ; ASCII 'A'
0016A0r 3  90 03                        bcc @compare_first
0016A2r 3               
0016A2r 3                               ; An uppercase letter has been located.  Make it
0016A2r 3                               ; lowercase.
0016A2r 3  18                           clc
0016A3r 3  69 20                        adc #$20
0016A5r 3               
0016A5r 3               @compare_first:
0016A5r 3  A0 08                        ldy #8          ; Offset in nt to name
0016A7r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
0016A9r 3  D0 41                        bne @next_entry
0016ABr 3               
0016ABr 3                               ; String length is the same and the first character is the
0016ABr 3                               ; same. If the length of the string is 1, we're already done
0016ABr 3  B5 00                        lda 0,x
0016ADr 3  3A                           dec
0016AEr 3  F0 2C                        beq @success
0016B0r 3               
0016B0r 3                               ; No such luck: The strings are the same length and the first
0016B0r 3                               ; char is the same, but the word is more than one char long.
0016B0r 3                               ; So we suck it up and compare every single character. We go
0016B0r 3                               ; from back to front, because words like CELLS and CELL+ would
0016B0r 3                               ; take longer otherwise. We can also shorten the loop by one
0016B0r 3                               ; because we've already compared the first char.
0016B0r 3               
0016B0r 3                               ; The string of the word we're testing against is 8 bytes down
0016B0r 3  A5 rr                        lda tmp1
0016B2r 3  48                           pha             ; Preserve tmp1 on the return stack.
0016B3r 3  18                           clc
0016B4r 3  69 08                        adc #8
0016B6r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
0016B8r 3  A5 rr                        lda tmp1+1
0016BAr 3  48                           pha             ; Preserve tmp1+1 on the return stack.
0016BBr 3  69 00                        adc #0          ; we only need the carry
0016BDr 3  85 rr                        sta tmp1+1
0016BFr 3               
0016BFr 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0016C1r 3  88                           dey
0016C2r 3               
0016C2r 3               @string_loop:
0016C2r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
0016C4r 3               
0016C4r 3                               ; Lowercase the incoming charcter.
0016C4r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0016C6r 3  B0 07                        bcs @check_char
0016C8r 3  C9 41                        cmp #$41        ; ASCII 'A'
0016CAr 3  90 03                        bcc @check_char
0016CCr 3               
0016CCr 3                               ; An uppercase letter has been located.  Make it
0016CCr 3                               ; lowercase.
0016CCr 3  18                           clc
0016CDr 3  69 20                        adc #$20
0016CFr 3               
0016CFr 3               @check_char:
0016CFr 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
0016D1r 3  D0 13                        bne @next_entry_tmp1
0016D3r 3               
0016D3r 3  88                           dey
0016D4r 3  D0 EC                        bne @string_loop
0016D6r 3               
0016D6r 3               @success_tmp1:
0016D6r 3  68                           pla             ; Restore tmp1 from the return stack.
0016D7r 3  85 rr                        sta tmp1+1
0016D9r 3  68                           pla
0016DAr 3  85 rr                        sta tmp1
0016DCr 3               
0016DCr 3               @success:
0016DCr 3                               ; The strings match. Put correct nt NOS, because we'll drop
0016DCr 3                               ; TOS before we leave
0016DCr 3  A5 rr                        lda tmp1
0016DEr 3  95 02                        sta 2,x
0016E0r 3  A5 rr                        lda tmp1+1
0016E2r 3  95 03                        sta 3,x
0016E4r 3               
0016E4r 3  80 20                        bra @done
0016E6r 3               
0016E6r 3               @next_entry_tmp1:
0016E6r 3  68                           pla             ; Restore tmp1 from the return stack.
0016E7r 3  85 rr                        sta tmp1+1
0016E9r 3  68                           pla
0016EAr 3  85 rr                        sta tmp1
0016ECr 3               
0016ECr 3               @next_entry:
0016ECr 3                               ; Not the same, so we get the next word. Next header
0016ECr 3                               ; address is two bytes down
0016ECr 3  A0 02                        ldy #2
0016EEr 3  B1 rr                        lda (tmp1),y
0016F0r 3  48                           pha
0016F1r 3  C8                           iny
0016F2r 3  B1 rr                        lda (tmp1),y
0016F4r 3  85 rr                        sta tmp1+1
0016F6r 3  68                           pla
0016F7r 3  85 rr                        sta tmp1
0016F9r 3               
0016F9r 3                               ; If we got a zero, we've walked the whole Dictionary and
0016F9r 3                               ; return as a failure, otherwise try again
0016F9r 3  05 rr                        ora tmp1+1
0016FBr 3  D0 95                        bne @loop
0016FDr 3               
0016FDr 3                               ; Move on to the next wordlist in the search order.
0016FDr 3  E6 rr                        inc tmp3
0016FFr 3  4C rr rr                     jmp @wordlist_loop
001702r 3               
001702r 3               @fail_done:
001702r 3  74 02                        stz 2,x         ; failure flag
001704r 3  74 03                        stz 3,x
001706r 3               @done:
001706r 3  E8                           inx
001707r 3  E8                           inx
001708r 3               
001708r 3  60           z_find_name:    rts
001709r 3               
001709r 3               
001709r 3               
001709r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001709r 3               ; ## "flush"  auto  ANS block
001709r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001709r 3               xt_flush:
001709r 3  20 rr rr                     jsr xt_save_buffers
00170Cr 3               
00170Cr 3                               ; Set the buffer status to empty.
00170Cr 3  A0 2C                        ldy #buffstatus_offset
00170Er 3  A9 00                        lda #0
001710r 3  91 rr                        sta (up),y      ; Only LSB is used.
001712r 3               z_flush:
001712r 3  60                           rts
001713r 3               
001713r 3               
001713r 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001713r 3               ; ## "fm/mod"  auto  ANS core
001713r 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001713r 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001713r 3                       ;
001713r 3                       ; There are various ways to realize this. We follow EForth with
001713r 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001713r 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001713r 3                       ; See (http://www.forth.org/eforth.html). However you can also
001713r 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001713r 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001713r 3                       ; """
001713r 3               
001713r 3               xt_fm_slash_mod:
001713r 3  20 rr rr                     jsr underflow_3
001716r 3               
001716r 3                               ; if sign of n1 is negative, negate both n1 and d
001716r 3  64 rr                        stz tmp2        ; default: n is positive
001718r 3  B5 01                        lda 1,x         ; MSB of n1
00171Ar 3  10 0E                        bpl @check_d
00171Cr 3               
00171Cr 3  E6 rr                        inc tmp2        ; set flag to negative for n1
00171Er 3  20 rr rr                     jsr xt_negate   ; NEGATE
001721r 3  20 rr rr                     jsr xt_to_r     ; >R
001724r 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001727r 3  20 rr rr                     jsr xt_r_from   ; R>
00172Ar 3               
00172Ar 3               @check_d:
00172Ar 3                               ; If d is negative, add n1 to high cell of d
00172Ar 3  B5 03                        lda 3,x         ; MSB of high word of d
00172Cr 3  10 0D                        bpl @multiply
00172Er 3               
00172Er 3  18                           clc
00172Fr 3  B5 00                        lda 0,x         ; LSB of n1
001731r 3  75 02                        adc 2,x         ; LSB of dh
001733r 3  95 02                        sta 2,x
001735r 3               
001735r 3  B5 01                        lda 1,x         ; MSB of n1
001737r 3  75 03                        adc 3,x         ; MSB of dh
001739r 3  95 03                        sta 3,x
00173Br 3               
00173Br 3               @multiply:
00173Br 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
00173Er 3               
00173Er 3                               ; if n was negative, negate the result
00173Er 3  A5 rr                        lda tmp2
001740r 3  F0 07                        beq @done
001742r 3               
001742r 3  E8                           inx             ; pretend that we SWAP
001743r 3  E8                           inx
001744r 3  20 rr rr                     jsr xt_negate
001747r 3  CA                           dex
001748r 3  CA                           dex
001749r 3               @done:
001749r 3  60           z_fm_slash_mod: rts
00174Ar 3               
00174Ar 3               
00174Ar 3               
00174Ar 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
00174Ar 3               ; ## "forth"  auto  ANS search ext
00174Ar 3                       ; """https://forth-standard.org/standard/search/FORTH"""
00174Ar 3               xt_forth:
00174Ar 3  A0 1F                        ldy #search_order_offset
00174Cr 3  A9 00                        lda #0          ; The WID for Forth is 0.
00174Er 3               
00174Er 3  91 rr                        sta (up),y
001750r 3               z_forth:
001750r 3  60                           rts
001751r 3               
001751r 3               
001751r 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
001751r 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
001751r 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
001751r 3               load_evaluate:
001751r 3                               ; Set a flag (using tmp1) to not zero BLK
001751r 3  A9 FF                        lda #$FF
001753r 3  85 rr                        sta tmp1
001755r 3  80 11                        bra load_evaluate_start
001757r 3               
001757r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
001757r 3               ; ## "evaluate"  auto  ANS core
001757r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
001757r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
001757r 3                       ; After processing the line, revert to old input source. We use this
001757r 3                       ; to compile high-level Forth words and user-defined words during
001757r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
001757r 3                       ; accept more than 255 characters here, even though it's a pain in
001757r 3                       ; the 8-bit.
001757r 3                       ; """
001757r 3               
001757r 3               xt_evaluate:
001757r 3  20 rr rr                     jsr underflow_2
00175Ar 3               
00175Ar 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
00175Ar 3                               ; and will set the block number.
00175Ar 3  64 rr                        stz tmp1
00175Cr 3               
00175Cr 3                               ; If u is zero (which can happen a lot for the user-defined
00175Cr 3                               ; words), just leave again
00175Cr 3  B5 00                        lda 0,x
00175Er 3  15 01                        ora 1,x
001760r 3  D0 06                        bne _eval_got_work
001762r 3               
001762r 3  E8                           inx
001763r 3  E8                           inx
001764r 3  E8                           inx
001765r 3  E8                           inx
001766r 3               
001766r 3  80 42                        bra _eval_done
001768r 3               
001768r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
001768r 3               load_evaluate_start:
001768r 3               _eval_got_work:
001768r 3                               ; Save the current value of BLK on the return stack.
001768r 3  A0 01                        ldy #blk_offset+1
00176Ar 3  B1 rr                        lda (up),y
00176Cr 3  48                           pha
00176Dr 3  88                           dey
00176Er 3  B1 rr                        lda (up),y
001770r 3  48                           pha
001771r 3               
001771r 3                               ; See if we should zero BLK.
001771r 3  A5 rr                        lda tmp1
001773r 3  D0 05                        bne @nozero
001775r 3               
001775r 3                               ; Set BLK to zero.
001775r 3                               ; lda #0        ; A is already zero from loading tmp1
001775r 3  91 rr                        sta (up),y
001777r 3  C8                           iny
001778r 3  91 rr                        sta (up),y
00177Ar 3               
00177Ar 3               @nozero:
00177Ar 3                               ; Save the input state to the Return Stack
00177Ar 3  20 rr rr                     jsr xt_input_to_r
00177Dr 3               
00177Dr 3                               ; set SOURCE-ID to -1
00177Dr 3  A9 FF                        lda #$ff
00177Fr 3  85 rr                        sta insrc
001781r 3  85 rr                        sta insrc+1
001783r 3               
001783r 3                               ; set >IN to zero
001783r 3  64 rr                        stz toin
001785r 3  64 rr                        stz toin+1
001787r 3               
001787r 3                               ; move TOS and NOS to input buffers
001787r 3  B5 00                        lda 0,x
001789r 3  85 rr                        sta ciblen
00178Br 3  B5 01                        lda 1,x
00178Dr 3  85 rr                        sta ciblen+1
00178Fr 3               
00178Fr 3  B5 02                        lda 2,x
001791r 3  85 rr                        sta cib
001793r 3  B5 03                        lda 3,x
001795r 3  85 rr                        sta cib+1
001797r 3               
001797r 3  E8                           inx             ; A clean stack is a clean mind
001798r 3  E8                           inx
001799r 3  E8                           inx
00179Ar 3  E8                           inx
00179Br 3               
00179Br 3  20 rr rr                     jsr interpret   ; ( -- )
00179Er 3               
00179Er 3                               ; restore variables
00179Er 3  20 rr rr                     jsr xt_r_to_input
0017A1r 3               
0017A1r 3                               ; Restore BLK from the return stack.
0017A1r 3  A0 00                        ldy #blk_offset
0017A3r 3  68                           pla
0017A4r 3  91 rr                        sta (up),y
0017A6r 3  C8                           iny
0017A7r 3  68                           pla
0017A8r 3  91 rr                        sta (up),y
0017AAr 3               
0017AAr 3               _eval_done:
0017AAr 3  60           z_evaluate:     rts
0017ABr 3               
0017ABr 3               
0017ABr 3               
0017ABr 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
0017ABr 3               ; ## "forth-wordlist"  auto  ANS search
0017ABr 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
0017ABr 3                       ; This is a dummy entry, the actual code is shared with ZERO.
0017ABr 3               
0017ABr 3               
0017ABr 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
0017ABr 3               ; ## "get-current" auto ANS search
0017ABr 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
0017ABr 3               
0017ABr 3               xt_get_current:
0017ABr 3                               ; This is a little different than some of the variables
0017ABr 3                               ; in the user area as we want the value rather than
0017ABr 3                               ; the address.
0017ABr 3  CA                           dex
0017ACr 3  CA                           dex
0017ADr 3  A0 04                        ldy #current_offset
0017AFr 3  B1 rr                        lda (up),y
0017B1r 3  95 00                        sta 0,x         ; CURRENT is a byte variable
0017B3r 3  74 01                        stz 1,x         ; so the MSB is zero.
0017B5r 3               
0017B5r 3  60           z_get_current:  rts
0017B6r 3               
0017B6r 3               
0017B6r 3               
0017B6r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
0017B6r 3               ; ## "get-order" auto ANS search
0017B6r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
0017B6r 3               
0017B6r 3               xt_get_order:
0017B6r 3                               ; Get #ORDER - the number of wordlists in the search order.
0017B6r 3  A0 1E                        ldy #num_order_offset
0017B8r 3  B1 rr                        lda (up),y
0017BAr 3  85 rr                        sta tmp1
0017BCr 3  F0 16                        beq @done       ; If zero, there are no wordlists.
0017BEr 3               
0017BEr 3               @loop:
0017BEr 3                               ; Count down towards the front of the list.
0017BEr 3                               ; By decrementing first, we also turn the length into an offset.
0017BEr 3  C6 rr                        dec tmp1        ; Count down by bytes.
0017C0r 3               
0017C0r 3                               ; Get a pointer to the current wordlist, working back to front.
0017C0r 3  A9 1F                        lda #search_order_offset
0017C2r 3  18                           clc
0017C3r 3  65 rr                        adc tmp1
0017C5r 3  A8                           tay
0017C6r 3               
0017C6r 3                               ; Put that wordlist id on the stack.
0017C6r 3  CA                           dex
0017C7r 3  CA                           dex
0017C8r 3  B1 rr                        lda (up),y
0017CAr 3  95 00                        sta 0,x         ; Search order array is bytes, so
0017CCr 3  74 01                        stz 1,x         ; put a zero in the high byte.
0017CEr 3               
0017CEr 3                               ; See if that was the last one to process (first in the list).
0017CEr 3  A9 00                        lda #0
0017D0r 3  C5 rr                        cmp tmp1
0017D2r 3  D0 EA                        bne @loop
0017D4r 3               
0017D4r 3               @done:
0017D4r 3                               ; Put the number of items on the stack.
0017D4r 3  CA                           dex
0017D5r 3  CA                           dex
0017D6r 3  A0 1E                        ldy #num_order_offset
0017D8r 3  B1 rr                        lda (up),y
0017DAr 3  95 00                        sta 0,x
0017DCr 3  74 01                        stz 1,x         ; We only support 8 wordlists.
0017DEr 3               
0017DEr 3  60           z_get_order:    rts
0017DFr 3               
0017DFr 3               
0017DFr 3               
0017DFr 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
0017DFr 3               ; ## ">"  auto  ANS core
0017DFr 3                       ; """https://forth-standard.org/standard/core/more"""
0017DFr 3               
0017DFr 3               xt_greater_than:
0017DFr 3  20 rr rr                     jsr underflow_2
0017E2r 3               
0017E2r 3  A0 00                        ldy #0          ; default false
0017E4r 3  20 rr rr                     jsr compare_16bit
0017E7r 3               
0017E7r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
0017E7r 3  F0 03                        beq @false
0017E9r 3  10 01                        bpl @false
0017EBr 3               
0017EBr 3                               ; true
0017EBr 3  88                           dey
0017ECr 3               @false:
0017ECr 3  98                           tya
0017EDr 3               
0017EDr 3  E8                           inx
0017EEr 3  E8                           inx
0017EFr 3  95 00                        sta 0,x
0017F1r 3  95 01                        sta 1,x
0017F3r 3               
0017F3r 3  60           z_greater_than: rts
0017F4r 3               
0017F4r 3               
0017F4r 3               
0017F4r 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
0017F4r 3               ; ## "here"  auto  ANS core
0017F4r 3                       ; """https://forth-standard.org/standard/core/HERE
0017F4r 3                       ; This code is also used by the assembler directive ARROW
0017F4r 3                       ; ("->") though as immediate"""
0017F4r 3               xt_here:
0017F4r 3               xt_asm_arrow:
0017F4r 3  CA                           dex
0017F5r 3  CA                           dex
0017F6r 3  A5 rr                        lda cp
0017F8r 3  95 00                        sta 0,x
0017FAr 3  A5 rr                        lda cp+1
0017FCr 3  95 01                        sta 1,x
0017FEr 3               
0017FEr 3               z_asm_arrow:
0017FEr 3  60           z_here:         rts
0017FFr 3               
0017FFr 3               
0017FFr 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
0017FFr 3               ; ## "hex"  auto  ANS core ext
0017FFr 3                       ; """https://forth-standard.org/standard/core/HEX"""
0017FFr 3               xt_hex:
0017FFr 3  A9 10                        lda #16
001801r 3  85 rr                        sta base
001803r 3  64 rr                        stz base+1              ; paranoid
001805r 3               
001805r 3  60           z_hex:          rts
001806r 3               
001806r 3               
001806r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001806r 3               ; ## "hexstore"  auto  Tali
001806r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001806r 3                       ; by spaces, store the numbers at the address addr2, returning the
001806r 3                       ; number of elements. Non-number elements are skipped, an zero-length
001806r 3                       ; string produces a zero output.
001806r 3                       ; """
001806r 3               
001806r 3               xt_hexstore:
001806r 3  20 rr rr                     jsr underflow_3
001809r 3               
001809r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
00180Cr 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
00180Fr 3               
00180Fr 3               @loop:
00180Fr 3                               ; Loop until string is totally consumed
00180Fr 3  B5 00                        lda 0,x
001811r 3  15 01                        ora 1,x
001813r 3  F0 36                        beq @done
001815r 3               
001815r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001818r 3               
001818r 3                               ; Prepare the conversion of the number.
001818r 3  20 rr rr                     jsr xt_two_to_r
00181Br 3  20 rr rr                     jsr xt_zero
00181Er 3  20 rr rr                     jsr xt_zero
001821r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001824r 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001827r 3               
001827r 3                               ; If u4 is not zero, we have leftover chars and have to do
001827r 3                               ; things differently
001827r 3  B5 00                        lda 0,x
001829r 3  15 01                        ora 1,x
00182Br 3  D0 17                        bne @have_chars_left
00182Dr 3               
00182Dr 3                               ; Normal case, this number is all done
00182Dr 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001830r 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001833r 3               
001833r 3                               ; Store the new value
001833r 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
001836r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
001839r 3               
001839r 3                               ; Increase counter
001839r 3  20 rr rr                     jsr xt_r_from           ; R>
00183Cr 3  20 rr rr                     jsr xt_one_plus         ; 1+
00183Fr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001842r 3  80 CB                        bra @loop
001844r 3               
001844r 3               @have_chars_left:
001844r 3                               ; Pathological case: Drop the rest of this number off the stack
001844r 3                               ; and continue with the next word. Doesn't print a warning. We
001844r 3                               ; need to drop four cells, that is, eight bytes
001844r 3  8A                           txa
001845r 3  18                           clc
001846r 3  69 08                        adc #8
001848r 3  AA                           tax
001849r 3  80 C4                        bra @loop
00184Br 3               
00184Br 3               @done:
00184Br 3                               ; Clean up return stack and calculate number of chars stored
00184Br 3  E8                           inx
00184Cr 3  E8                           inx
00184Dr 3  E8                           inx
00184Er 3  E8                           inx                     ; 2DROP
00184Fr 3               
00184Fr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001852r 3  20 rr rr                     jsr xt_swap
001855r 3  20 rr rr                     jsr xt_minus            ; ( n )
001858r 3               
001858r 3  60           z_hexstore:     rts
001859r 3               
001859r 3               
001859r 3               
001859r 3               ; ## HOLD ( char -- ) "Insert character at current output"
001859r 3               ; ## "hold"  auto  ANS core
001859r 3                       ; """https://forth-standard.org/standard/core/HOLD
001859r 3                       ; Insert a character at the current position of a pictured numeric
001859r 3                       ; output string on
001859r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001859r 3                       ;
001859r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
001859r 3                       ; variable tohold instead of HLD.
001859r 3                       ; """
001859r 3               xt_hold:
001859r 3  20 rr rr                     jsr underflow_1
00185Cr 3               
00185Cr 3  A5 rr                        lda tohold
00185Er 3  D0 02                        bne @1
001860r 3  C6 rr                        dec tohold+1
001862r 3               @1:
001862r 3  C6 rr                        dec tohold
001864r 3               
001864r 3  B5 00                        lda 0,x
001866r 3  92 rr                        sta (tohold)
001868r 3  E8                           inx
001869r 3  E8                           inx
00186Ar 3               
00186Ar 3  60           z_hold:         rts
00186Br 3               
00186Br 3               
00186Br 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
00186Br 3               ; ## "i"  auto  ANS core
00186Br 3                       ; """https://forth-standard.org/standard/core/I
00186Br 3                       ; Note that this is not the same as R@ because we use a fudge
00186Br 3                       ; factor for loop control; see the Control Flow section of the
00186Br 3                       ; manual for details.
00186Br 3                       ;
00186Br 3                       ; We should make this native compile for speed.
00186Br 3                       ; """
00186Br 3               
00186Br 3               xt_i:
00186Br 3  CA                           dex
00186Cr 3  CA                           dex
00186Dr 3               
00186Dr 3                               ; Get the fudged index off of the top of the stack. It's
00186Dr 3                               ; easier to do math on the stack directly than to pop and
00186Dr 3                               ; push stuff around
00186Dr 3  86 rr                        stx tmpdsp
00186Fr 3  BA                           tsx
001870r 3               
001870r 3  38                           sec
001871r 3  BD 01 01                     lda $0101,x     ; LSB
001874r 3  FD 03 01                     sbc $0103,x
001877r 3  A8                           tay
001878r 3               
001878r 3  BD 02 01                     lda $0102,x     ; MSB
00187Br 3  FD 04 01                     sbc $0104,x
00187Er 3               
00187Er 3  A6 rr                        ldx tmpdsp
001880r 3               
001880r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001882r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001884r 3               
001884r 3  60           z_i:            rts
001885r 3               
001885r 3               
001885r 3               
001885r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001885r 3               ; ## "if"  auto  ANS core
001885r 3                       ; """http://forth-standard.org/standard/core/IF"""
001885r 3               
001885r 3               xt_if:
001885r 3                               ; Compile a 0BRANCH
001885r 3  A0 rr                        ldy #>zero_branch_runtime
001887r 3  A9 rr                        lda #<zero_branch_runtime
001889r 3  20 rr rr                     jsr cmpl_subroutine
00188Cr 3               
00188Cr 3                               ; Put the origination address on the stack for else/then
00188Cr 3  20 rr rr                     jsr xt_here
00188Fr 3               
00188Fr 3                               ; Stuff zero in for the branch address right now.
00188Fr 3                               ; THEN or ELSE will fix it later.
00188Fr 3  20 rr rr                     jsr xt_zero
001892r 3  20 rr rr                     jsr xt_comma
001895r 3  60           z_if:           rts
001896r 3               
001896r 3               
001896r 3               zero_branch_runtime:
001896r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001896r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001896r 3                       ; runtime.
001896r 3                       ; """
001896r 3               
001896r 3                               ; We use the return value on the 65c02 stack to determine
001896r 3                               ; where we want to return to.
001896r 3  68                           pla
001897r 3  85 rr                        sta tmpbranch
001899r 3  68                           pla
00189Ar 3  85 rr                        sta tmpbranch+1
00189Cr 3               
00189Cr 3                               ; See if the flag is zero, which is the whole purpose of
00189Cr 3                               ; this all
00189Cr 3  B5 00                        lda 0,x
00189Er 3  15 01                        ora 1,x
0018A0r 3  F0 0F                        beq @zero
0018A2r 3               
0018A2r 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
0018A2r 3                               ; the part between IF and THEN
0018A2r 3  A5 rr                        lda tmpbranch   ; LSB
0018A4r 3  18                           clc
0018A5r 3  69 02                        adc #2
0018A7r 3  85 rr                        sta tmp1
0018A9r 3  A5 rr                        lda tmpbranch+1 ; MSB
0018ABr 3  69 00                        adc #0          ; For carry
0018ADr 3  85 rr                        sta tmp1+1
0018AFr 3               
0018AFr 3  80 13                        bra @done
0018B1r 3               
0018B1r 3               @zero:
0018B1r 3                               ; Flag is FALSE (0) so we take the jump to the address given in
0018B1r 3                               ; the next two bytes. However, the address points to the last
0018B1r 3                               ; byte of the JSR instruction, not to the next byte afterwards
0018B1r 3  A0 01                        ldy #1
0018B3r 3  B1 rr                        lda (tmpbranch),y
0018B5r 3  85 rr                        sta tmp1
0018B7r 3  C8                           iny
0018B8r 3  B1 rr                        lda (tmpbranch),y
0018BAr 3  85 rr                        sta tmp1+1
0018BCr 3               
0018BCr 3                               ; Now we have to subtract one byte from the address
0018BCr 3                               ; given because of the way the 6502 calculates RTS
0018BCr 3  A5 rr                        lda tmp1
0018BEr 3  D0 02                        bne @1
0018C0r 3  C6 rr                        dec tmp1+1
0018C2r 3               @1:
0018C2r 3  C6 rr                        dec tmp1
0018C4r 3               
0018C4r 3               @done:
0018C4r 3                               ; However we got here, tmp1 has the value we push to jump
0018C4r 3                               ; to
0018C4r 3  A5 rr                        lda tmp1+1
0018C6r 3  48                           pha             ; MSB first
0018C7r 3  A5 rr                        lda tmp1
0018C9r 3  48                           pha
0018CAr 3               
0018CAr 3                               ; clean up the stack and jump
0018CAr 3  E8                           inx
0018CBr 3  E8                           inx
0018CCr 3               
0018CCr 3  60                           rts
0018CDr 3               
0018CDr 3               
0018CDr 3               
0018CDr 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
0018CDr 3               ; ## "immediate"  auto  ANS core
0018CDr 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
0018CDr 3                       ; Make sure the most recently defined word is immediate. Will only
0018CDr 3                       ; affect the last word in the dictionary. Note that if the word is
0018CDr 3                       ; defined in ROM, this will have no affect, but will not produce an
0018CDr 3                       ; error message.
0018CDr 3                       ; """
0018CDr 3               xt_immediate:
0018CDr 3  20 rr rr                     jsr current_to_dp
0018D0r 3  A0 01                        ldy #1          ; offset for status byte
0018D2r 3  B1 rr                        lda (dp),y
0018D4r 3  09 04                        ora #IM        ; make sure bit 7 is set
0018D6r 3  91 rr                        sta (dp),y
0018D8r 3               
0018D8r 3  60           z_immediate:    rts
0018D9r 3               
0018D9r 3               
0018D9r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
0018D9r 3               ; ## "input" tested Tali Forth
0018D9r 3               
0018D9r 3               xt_input:
0018D9r 3  CA                           dex
0018DAr 3  CA                           dex
0018DBr 3  A9 rr                        lda #<input
0018DDr 3  95 00                        sta 0,x
0018DFr 3  A9 rr                        lda #>input
0018E1r 3  95 01                        sta 1,x
0018E3r 3               
0018E3r 3  60           z_input:        rts
0018E4r 3               
0018E4r 3               
0018E4r 3               
0018E4r 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
0018E4r 3               ; ## "input>r"  tested  Tali Forth
0018E4r 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
0018E4r 3                       ; toin to the Return Stack. Used by EVALUTE.
0018E4r 3                       ;
0018E4r 3                       ; The naive way of doing
0018E4r 3                       ; this is to push each two-byte variable to the stack in the form of
0018E4r 3                       ;
0018E4r 3                       ;       lda insrc
0018E4r 3                       ;       pha
0018E4r 3                       ;       lda insrc+1
0018E4r 3                       ;       pha
0018E4r 3                       ;
0018E4r 3                       ; for a total of 24 byte of instruction in one direction and later
0018E4r 3                       ; a further 24 bytes to reverse the process. We shorten this at the
0018E4r 3                       ; cost of some speed by assuming the four variables are grouped
0018E4r 3                       ; together on the Zero Page and start with insrc (see definitions.asm
0018E4r 3                       ; for details). The reverse operation is r_to_input. These words must
0018E4r 3                       ; be flagged as Never Native. Uses tmp1
0018E4r 3                       ; """
0018E4r 3               
0018E4r 3               xt_input_to_r:
0018E4r 3                               ; We arrive here with the return address on the top of the
0018E4r 3                               ; 65c02's stack. We need to move it out of the way first
0018E4r 3  68                           pla
0018E5r 3  85 rr                        sta tmp1
0018E7r 3  68                           pla
0018E8r 3  85 rr                        sta tmp1+1
0018EAr 3               
0018EAr 3                               ; This assumes that insrc is the first of eight bytes and
0018EAr 3                               ; toin+1 the last in the sequence we want to save from the Zero
0018EAr 3                               ; Page.
0018EAr 3  A0 07                        ldy #7
0018ECr 3               @loop:
0018ECr 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
0018EFr 3  48                           pha
0018F0r 3  88                           dey
0018F1r 3  10 F9                        bpl @loop
0018F3r 3               
0018F3r 3                               ; Restore address for return jump
0018F3r 3  A5 rr                        lda tmp1+1
0018F5r 3  48                           pha
0018F6r 3  A5 rr                        lda tmp1
0018F8r 3  48                           pha
0018F9r 3               
0018F9r 3  60           z_input_to_r: 	rts
0018FAr 3               
0018FAr 3               
0018FAr 3               
0018FAr 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
0018FAr 3               ; ## "int>name"  auto  Tali Forth
0018FAr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0018FAr 3                       ; This is called >NAME in Gforth, but we change it to
0018FAr 3                       ; INT>NAME to match NAME>INT
0018FAr 3                       ; """
0018FAr 3               
0018FAr 3               xt_int_to_name:
0018FAr 3  20 rr rr                     jsr underflow_1
0018FDr 3               
0018FDr 3                               ; Unfortunately, to find the header, we have to walk through
0018FDr 3                               ; all of the wordlists. We are running out of tmp variables.
0018FDr 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
0018FDr 3                               ; hold the current wordlist on the data stack. This searches
0018FDr 3                               ; all of the wordlists in id order.
0018FDr 3  CA                           dex
0018FEr 3  CA                           dex
0018FFr 3  74 00                        stz 0,x
001901r 3  74 01                        stz 1,x
001903r 3               
001903r 3               @wordlist_loop:
001903r 3                               ; A needs to have the current wordlist id in it at
001903r 3                               ; the top of this loop.
001903r 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001905r 3               
001905r 3                               ; Get the DP for that wordlist.
001905r 3  0A                           asl                     ; Turn offset into cells offset.
001906r 3  18                           clc
001907r 3  69 06                        adc #wordlists_offset
001909r 3  A8                           tay
00190Ar 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
00190Cr 3  85 rr                        sta tmp2                ; into tmp2
00190Er 3  C8                           iny
00190Fr 3  B1 rr                        lda (up),y
001911r 3  85 rr                        sta tmp2+1
001913r 3               
001913r 3                               ; Check for an empty wordlist (DP will be 0)
001913r 3  A5 rr                        lda tmp2
001915r 3  05 rr                        ora tmp2+1
001917r 3  F0 38                        beq @next_wordlist
001919r 3               
001919r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
00191Br 3  85 rr                        sta tmp3        ; Save target xt in tmp3
00191Dr 3  B5 03                        lda 3,x
00191Fr 3  85 rr                        sta tmp3+1
001921r 3               
001921r 3               @loop:
001921r 3  A0 04                        ldy #4          ; xt is four bytes down
001923r 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
001925r 3  C5 rr                        cmp tmp3
001927r 3  D0 07                        bne @no_match
001929r 3               
001929r 3                               ; LSB is the same, now check MSB
001929r 3  C8                           iny
00192Ar 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
00192Cr 3  C5 rr                        cmp tmp3+1
00192Er 3  F0 32                        beq @match
001930r 3               
001930r 3               @no_match:
001930r 3                               ; no match, so we need to get the next word. Next nt is two
001930r 3                               ; bytes down
001930r 3  18                           clc
001931r 3  A5 rr                        lda tmp2
001933r 3  69 02                        adc #2
001935r 3  85 rr                        sta tmp2
001937r 3  A5 rr                        lda tmp2+1
001939r 3  69 00                        adc #0          ; only care about carry
00193Br 3  85 rr                        sta tmp2+1
00193Dr 3               
00193Dr 3  A0 00                        ldy #0
00193Fr 3  B1 rr                        lda (tmp2),y
001941r 3  48                           pha
001942r 3  C8                           iny
001943r 3  11 rr                        ora (tmp2),y
001945r 3  F0 09                        beq @zero
001947r 3               
001947r 3                               ; Not zero continue
001947r 3  B1 rr                        lda (tmp2),y
001949r 3  85 rr                        sta tmp2+1
00194Br 3  68                           pla
00194Cr 3  85 rr                        sta tmp2
00194Er 3  80 D1                        bra @loop
001950r 3               
001950r 3               @zero:
001950r 3                               ; if next word is zero, the xt has no nt in this wordlist
001950r 3  68                           pla             ; Leftover from above loop
001951r 3               
001951r 3               @next_wordlist:
001951r 3                               ; Move on to the next wordlist.
001951r 3  B5 00                        lda 0,x
001953r 3  1A                           inc
001954r 3  95 00                        sta 0,x
001956r 3  C9 0C                        cmp #max_wordlists
001958r 3  D0 A9                        bne @wordlist_loop
00195Ar 3               
00195Ar 3                               ; We didn't find it in any of the wordlists.
00195Ar 3                               ; Remove the wordlist id from the stack.
00195Ar 3  E8                           inx
00195Br 3  E8                           inx
00195Cr 3               
00195Cr 3                               ; We return a zero to indicate that we didn't find it.
00195Cr 3  74 00                        stz 0,x
00195Er 3  74 01                        stz 1,x
001960r 3  80 0A                        bra z_int_to_name
001962r 3               
001962r 3               @match:
001962r 3                               ; We found it. Remove wordlist id from stack.
001962r 3  E8                           inx
001963r 3  E8                           inx
001964r 3               
001964r 3                               ; It's a match! Replace TOS with nt
001964r 3  A5 rr                        lda tmp2
001966r 3  95 00                        sta 0,x
001968r 3  A5 rr                        lda tmp2+1
00196Ar 3  95 01                        sta 1,x
00196Cr 3               
00196Cr 3  60           z_int_to_name:  rts
00196Dr 3               
00196Dr 3               
00196Dr 3               
00196Dr 3               ; ## INVERT ( n -- n ) "Complement of TOS"
00196Dr 3               ; ## "invert"  auto  ANS core
00196Dr 3                       ; """https://forth-standard.org/standard/core/INVERT"""
00196Dr 3               xt_invert:
00196Dr 3  20 rr rr                     jsr underflow_1
001970r 3               
001970r 3  A9 FF                        lda #$FF
001972r 3  55 00                        eor 0,x         ; LSB
001974r 3  95 00                        sta 0,x
001976r 3               
001976r 3  A9 FF                        lda #$FF
001978r 3  55 01                        eor 1,x         ; MSB
00197Ar 3  95 01                        sta 1,x
00197Cr 3               
00197Cr 3  60           z_invert:       rts
00197Dr 3               
00197Dr 3               
00197Dr 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
00197Dr 3               ; ## "is"  auto  ANS core ext
00197Dr 3                       ; """http://forth-standard.org/standard/core/IS"""
00197Dr 3               
00197Dr 3               xt_is:
00197Dr 3                               ; This is a state aware word with differet behavior
00197Dr 3                               ; when used while compiling vs interpreting.
00197Dr 3                               ; Check STATE
00197Dr 3  A5 rr                        lda state
00197Fr 3  05 rr                        ora state+1
001981r 3  F0 0C                        beq @interpreting
001983r 3               
001983r 3               @compiling:
001983r 3                               ; Run ['] to compile the xt of the next word as a literal.
001983r 3  20 rr rr                     jsr xt_bracket_tick
001986r 3               
001986r 3                               ; Postpone DEFER! by compiling a JSR to it.
001986r 3  A0 rr                        ldy #>xt_defer_store
001988r 3  A9 rr                        lda #<xt_defer_store
00198Ar 3  20 rr rr                     jsr cmpl_subroutine
00198Dr 3               
00198Dr 3  80 06                        bra @done
00198Fr 3               
00198Fr 3               @interpreting:
00198Fr 3  20 rr rr                     jsr xt_tick
001992r 3  20 rr rr                     jsr xt_defer_store
001995r 3               @done:
001995r 3  60           z_is:           rts
001996r 3               
001996r 3               
001996r 3               
001996r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001996r 3               ; ## "j"  auto  ANS core
001996r 3                       ; """https://forth-standard.org/standard/core/J
001996r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001996r 3                       ; a fudge factor for loop control; see the Control Flow section of
001996r 3                       ; the manual for more details.
001996r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001996r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001996r 3                       ; implementation would just have two.
001996r 3                       ;
001996r 3                       ; Make this native compiled for speed
001996r 3                       ; """
001996r 3               
001996r 3               xt_j:
001996r 3  CA                           dex
001997r 3  CA                           dex
001998r 3               
001998r 3                               ; Get the fudged index off from the stack. It's easier to
001998r 3                               ; do math on the stack directly than to pop and push stuff
001998r 3                               ; around
001998r 3  86 rr                        stx tmpdsp
00199Ar 3  BA                           tsx
00199Br 3               
00199Br 3  38                           sec
00199Cr 3  BD 07 01                     lda $0107,x     ; LSB
00199Fr 3  FD 09 01                     sbc $0109,x
0019A2r 3  A8                           tay
0019A3r 3               
0019A3r 3  BD 08 01                     lda $0108,x     ; MSB
0019A6r 3  FD 0A 01                     sbc $010A,x
0019A9r 3               
0019A9r 3  A6 rr                        ldx tmpdsp
0019ABr 3               
0019ABr 3  95 01                        sta 1,x         ; MSB of de-fudged index
0019ADr 3  94 00                        sty 0,x         ; LSB of de-fudged index
0019AFr 3               
0019AFr 3  60           z_j:            rts
0019B0r 3               
0019B0r 3               
0019B0r 3               
0019B0r 3               ; ## KEY ( -- char ) "Get one character from the input"
0019B0r 3               ; ## "key"  tested  ANS core
0019B0r 3               xt_key:
0019B0r 3                       ; """https://forth-standard.org/standard/core/KEY
0019B0r 3                       ; Get a single character of input from the vectored
0019B0r 3                       ; input without echoing.
0019B0r 3                       ; """
0019B0r 3  20 rr rr                     jsr key_a               ; returns char in A
0019B3r 3               
0019B3r 3  CA                           dex
0019B4r 3  CA                           dex
0019B5r 3  95 00                        sta 0,x
0019B7r 3  74 01                        stz 1,x
0019B9r 3               
0019B9r 3  60           z_key:          rts
0019BAr 3               
0019BAr 3               key_a:
0019BAr 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
0019BAr 3                       ; 65816, so we have to fake the indirect jump to vector it.
0019BAr 3                       ; This is depressingly slow. We use this routine internally
0019BAr 3                       ; to avoid manipulating the Data Stack when we just want a
0019BAr 3                       ; character
0019BAr 3  6C rr rr                     jmp (input)             ; JSR/RTS
0019BDr 3               
0019BDr 3               
0019BDr 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
0019BDr 3               ; ## "latestnt"  auto  Tali Forth
0019BDr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0019BDr 3                       ; The Gforth version of this word is called LATEST
0019BDr 3                       ; """
0019BDr 3               xt_latestnt:
0019BDr 3  CA                           dex
0019BEr 3  CA                           dex
0019BFr 3               
0019BFr 3  20 rr rr                     jsr current_to_dp
0019C2r 3               
0019C2r 3  A5 rr                        lda dp
0019C4r 3  95 00                        sta 0,x
0019C6r 3  A5 rr                        lda dp+1
0019C8r 3  95 01                        sta 1,x
0019CAr 3               
0019CAr 3  60           z_latestnt:     rts
0019CBr 3               
0019CBr 3               
0019CBr 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
0019CBr 3               ; ## "latestxt"  auto  Gforth
0019CBr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
0019CBr 3               xt_latestxt:
0019CBr 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
0019CEr 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
0019D1r 3               
0019D1r 3  60           z_latestxt:     rts
0019D2r 3               
0019D2r 3               
0019D2r 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
0019D2r 3               ; ## "leave"  auto  ANS core
0019D2r 3                       ; """https://forth-standard.org/standard/core/LEAVE
0019D2r 3                       ; Note that this does not work with anything but a DO/LOOP in
0019D2r 3                       ; contrast to other versions such as discussed at
0019D2r 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
0019D2r 3                       ;
0019D2r 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
0019D2r 3                       ; See the Control Flow section in the manual for details of how this works.
0019D2r 3                       ; This must be native compile and not IMMEDIATE
0019D2r 3                       ; """
0019D2r 3               
0019D2r 3               xt_leave:
0019D2r 3                               ; We dump the limit/start entries off the Return Stack
0019D2r 3                               ; (four bytes)
0019D2r 3  68                           pla
0019D3r 3  68                           pla
0019D4r 3  68                           pla
0019D5r 3  68                           pla
0019D6r 3               
0019D6r 3  60                           rts             ; this must be compiled, so keep before z_leave
0019D7r 3               z_leave:                        ; not reached, not compiled
0019D7r 3               
0019D7r 3               
0019D7r 3               
0019D7r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
0019D7r 3               ; ## "["  auto  ANS core
0019D7r 3                       ; """https://forth-standard.org/standard/core/Bracket
0019D7r 3                       ; This is an immediate and compile-only word
0019D7r 3                       ; """
0019D7r 3               xt_left_bracket:
0019D7r 3  64 rr                        stz state
0019D9r 3  64 rr                        stz state+1
0019DBr 3               
0019DBr 3  60           z_left_bracket: rts
0019DCr 3               
0019DCr 3               
0019DCr 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
0019DCr 3               ; ## "<#"  auto  ANS core
0019DCr 3                       ; """https://forth-standard.org/standard/core/num-start
0019DCr 3                       ; Start the process to create pictured numeric output.
0019DCr 3                       ;
0019DCr 3                       ; The new
0019DCr 3                       ; string is constructed from back to front, saving the new character
0019DCr 3                       ; at the beginning of the output string. Since we use PAD as a
0019DCr 3                       ; starting address and work backward (!), the string is constructed
0019DCr 3                       ; in the space between the end of the Dictionary (as defined by CP)
0019DCr 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
0019DCr 3                       ; programs don't fool around with the PAD but still use its address.
0019DCr 3                       ; Based on pForth
0019DCr 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0019DCr 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
0019DCr 3                       ; internal variable tohold instead of HLD.
0019DCr 3                       ; """
0019DCr 3               xt_less_number_sign:
0019DCr 3  20 rr rr                     jsr xt_pad      ; ( addr )
0019DFr 3               
0019DFr 3  B5 00                        lda 0,x
0019E1r 3  85 rr                        sta tohold
0019E3r 3  B5 01                        lda 1,x
0019E5r 3  85 rr                        sta tohold+1
0019E7r 3               
0019E7r 3  E8                           inx
0019E8r 3  E8                           inx
0019E9r 3               
0019E9r 3               z_less_number_sign:
0019E9r 3  60                           rts
0019EAr 3               
0019EAr 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
0019EAr 3               ; ## "<"  auto  ANS core
0019EAr 3                       ; """https://forth-standard.org/standard/core/less"""
0019EAr 3               
0019EAr 3               xt_less_than:
0019EAr 3  20 rr rr                     jsr underflow_2
0019EDr 3               
0019EDr 3  A0 00                        ldy #0          ; default false
0019EFr 3  20 rr rr                     jsr compare_16bit
0019F2r 3               
0019F2r 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
0019F2r 3  F0 03                        beq @false
0019F4r 3  30 01                        bmi @false
0019F6r 3               
0019F6r 3                               ; true
0019F6r 3  88                           dey
0019F7r 3               @false:
0019F7r 3  98                           tya
0019F8r 3               
0019F8r 3  E8                           inx
0019F9r 3  E8                           inx
0019FAr 3  95 00                        sta 0,x
0019FCr 3  95 01                        sta 1,x
0019FEr 3               
0019FEr 3  60           z_less_than:    rts
0019FFr 3               
0019FFr 3               
0019FFr 3               
0019FFr 3               ; ## LIST ( scr# -- ) "List the given screen"
0019FFr 3               ; ## "list"  tested  ANS block ext
0019FFr 3                       ; """https://forth-standard.org/standard/block/LIST"""
0019FFr 3               
0019FFr 3               xt_list:
0019FFr 3  20 rr rr                     jsr underflow_1
001A02r 3               
001A02r 3                               ; Save the screen number in SCR
001A02r 3  20 rr rr                     jsr xt_scr
001A05r 3  20 rr rr                     jsr xt_store
001A08r 3               
001A08r 3                               ; Use L from the editor-wordlist to display the screen.
001A08r 3  20 rr rr                     jsr xt_editor_l
001A0Br 3               
001A0Br 3  60           z_list:         rts
001A0Cr 3               
001A0Cr 3               
001A0Cr 3               
001A0Cr 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001A0Cr 3               ; ## "literal"  auto  ANS core
001A0Cr 3                       ; """https://forth-standard.org/standard/core/LITERAL
001A0Cr 3                       ; Compile-only word to store TOS so that it is pushed on stack
001A0Cr 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001A0Cr 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001A0Cr 3                       ;
001A0Cr 3                       ; Note the cmpl_ routines use TMPTOS
001A0Cr 3                       ; """
001A0Cr 3               xt_literal:
001A0Cr 3  20 rr rr                     jsr underflow_1
001A0Fr 3               
001A0Fr 3  A0 rr                        ldy #>literal_runtime
001A11r 3  A9 rr                        lda #<literal_runtime
001A13r 3  20 rr rr                     jsr cmpl_subroutine
001A16r 3               
001A16r 3                               ; Compile the value that is to be pushed on the Stack during
001A16r 3                               ; runtime
001A16r 3  20 rr rr                     jsr xt_comma
001A19r 3               
001A19r 3  60           z_literal:      rts
001A1Ar 3               
001A1Ar 3               literal_runtime:
001A1Ar 3               
001A1Ar 3                               ; During runtime, we push the value following this word back
001A1Ar 3                               ; on the Data Stack. The subroutine jump that brought us
001A1Ar 3                               ; here put the address to return to on the Return Stack -
001A1Ar 3                               ; this points to the data we need to get. This routine is
001A1Ar 3                               ; also called (LITERAL) in some Forths
001A1Ar 3  CA                           dex
001A1Br 3  CA                           dex
001A1Cr 3               
001A1Cr 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001A1Cr 3                               ; so we are actually popping the address-1 of the literal
001A1Cr 3  68                           pla             ; LSB
001A1Dr 3  85 rr                        sta tmp1
001A1Fr 3  68                           pla             ; MSB
001A20r 3  85 rr                        sta tmp1+1
001A22r 3               
001A22r 3                               ; Fetch the actual literal value and push it on Data stack
001A22r 3  A0 01                        ldy #1
001A24r 3  B1 rr                        lda (tmp1),y    ; LSB
001A26r 3  95 00                        sta 0,x
001A28r 3  C8                           iny
001A29r 3  B1 rr                        lda (tmp1),y    ; MSB
001A2Br 3  95 01                        sta 1,x
001A2Dr 3               
001A2Dr 3                               ; Adjust return address and push back on the Return Stack
001A2Dr 3  98                           tya
001A2Er 3  18                           clc
001A2Fr 3  65 rr                        adc tmp1
001A31r 3  A8                           tay
001A32r 3  A5 rr                        lda tmp1+1
001A34r 3  69 00                        adc #0
001A36r 3  48                           pha
001A37r 3  5A                           phy
001A38r 3               
001A38r 3  60                           rts
001A39r 3               
001A39r 3               
001A39r 3               
001A39r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
001A39r 3               ; ## "load"  auto  ANS block
001A39r 3                       ; """https://forth-standard.org/standard/block/LOAD
001A39r 3                       ;
001A39r 3                       ; Note: LOAD current works because there is only one buffer.
001A39r 3                       ; If/when multiple buffers are supported, we'll have to deal
001A39r 3                       ; with the fact that it might re-load the old block into a
001A39r 3                       ; different buffer.
001A39r 3                       ; """
001A39r 3               
001A39r 3               xt_load:
001A39r 3  20 rr rr                     jsr underflow_1
001A3Cr 3               
001A3Cr 3                               ; Save the current value of BLK on the return stack.
001A3Cr 3  A0 01                        ldy #blk_offset+1
001A3Er 3  B1 rr                        lda (up),y
001A40r 3  48                           pha
001A41r 3  88                           dey
001A42r 3  B1 rr                        lda (up),y
001A44r 3  48                           pha
001A45r 3               
001A45r 3                               ; Set BLK to the given block/screen number.
001A45r 3  B5 00                        lda 0,x
001A47r 3  91 rr                        sta (up),y
001A49r 3  C8                           iny
001A4Ar 3  B5 01                        lda 1,x
001A4Cr 3  91 rr                        sta (up),y
001A4Er 3               
001A4Er 3                               ; Load that block into a buffer
001A4Er 3  20 rr rr                     jsr xt_block
001A51r 3               
001A51r 3                               ; Put 1024 on the stack for the screen length.
001A51r 3  CA                           dex
001A52r 3  CA                           dex
001A53r 3  A9 04                        lda #4
001A55r 3  95 01                        sta 1,x
001A57r 3  74 00                        stz 0,x
001A59r 3               
001A59r 3                               ; Jump to a special evluate target. This bypasses the underflow
001A59r 3                               ; check and skips the zeroing of BLK.
001A59r 3  20 rr rr                     jsr load_evaluate
001A5Cr 3               
001A5Cr 3                               ; Restore the value of BLK from before the LOAD command.
001A5Cr 3  A0 00                        ldy #blk_offset
001A5Er 3  68                           pla
001A5Fr 3  91 rr                        sta (up),y
001A61r 3  C8                           iny
001A62r 3  68                           pla
001A63r 3  91 rr                        sta (up),y
001A65r 3               
001A65r 3                               ; If BLK is not zero, read it back into the buffer.
001A65r 3                               ; A still has MSB
001A65r 3  88                           dey
001A66r 3  11 rr                        ora (up),y
001A68r 3  F0 12                        beq @done
001A6Ar 3               
001A6Ar 3                               ; The block needs to be read back into the buffer.
001A6Ar 3  CA                           dex
001A6Br 3  CA                           dex
001A6Cr 3  A0 00                        ldy #blk_offset
001A6Er 3  B1 rr                        lda (up),y
001A70r 3  95 00                        sta 0,x
001A72r 3  C8                           iny
001A73r 3  B1 rr                        lda (up),y
001A75r 3  95 01                        sta 1,x
001A77r 3  20 rr rr                     jsr xt_block
001A7Ar 3               
001A7Ar 3                               ; Drop the buffer address.
001A7Ar 3  E8                           inx
001A7Br 3  E8                           inx
001A7Cr 3               
001A7Cr 3               @done:
001A7Cr 3  60           z_load:         rts
001A7Dr 3               
001A7Dr 3               
001A7Dr 3               
001A7Dr 3               ; ## LOOP ( -- ) "Finish loop construct"
001A7Dr 3               ; ## "loop"  auto  ANS core
001A7Dr 3                       ; """https://forth-standard.org/standard/core/LOOP
001A7Dr 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001A7Dr 3                       ; the stack and then call +LOOP.
001A7Dr 3                       ;
001A7Dr 3                       ; In Forth, this is
001A7Dr 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001A7Dr 3                       ;       IMMEDIATE ; COMPILE-ONLY
001A7Dr 3                       ; """
001A7Dr 3               xt_loop:
001A7Dr 3                               ; Have the finished word push 1 on the stack
001A7Dr 3  A0 rr                        ldy #>xt_one
001A7Fr 3  A9 rr                        lda #<xt_one
001A81r 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
001A84r 3               
001A84r 3               
001A84r 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
001A84r 3               ; ## "+loop"  auto  ANS core
001A84r 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
001A84r 3                       ;
001A84r 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
001A84r 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
001A84r 3                       ;       COMPILE-ONLY
001A84r 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
001A84r 3                       ; address for looping as TOS and the address for aborting the loop
001A84r 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
001A84r 3                       ; DO and the Control Flow section of the manual for details).
001A84r 3                       ; """
001A84r 3               
001A84r 3               xt_plus_loop:
001A84r 3                               ; Compile the run-time part. We do this with a short loop
001A84r 3                               ; and not a call to COMPILE, because it has to be natively
001A84r 3                               ; coded anyway.
001A84r 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
001A86r 3  5A                           phy             ; save counter to adjust CP
001A87r 3               @1:
001A87r 3  B9 rr rr                     lda plus_loop_runtime,y
001A8Ar 3  91 rr                        sta (cp),y
001A8Cr 3  88                           dey
001A8Dr 3  10 F8                        bpl @1
001A8Fr 3               
001A8Fr 3                               ; Adjust CP
001A8Fr 3  68                           pla
001A90r 3  18                           clc
001A91r 3  65 rr                        adc cp
001A93r 3  85 rr                        sta cp
001A95r 3  A5 rr                        lda cp+1
001A97r 3  69 00                        adc #0          ; only need carry
001A99r 3  85 rr                        sta cp+1
001A9Br 3               
001A9Br 3                               ; The address we need to loop back to is TOS. Store it so
001A9Br 3                               ; the runtime part of +LOOP jumps back up there
001A9Br 3  20 rr rr                     jsr xt_comma
001A9Er 3               
001A9Er 3                               ; Compile an UNLOOP for when we're all done. This is a series
001A9Er 3                               ; of six PLA, so we just do it here instead jumping around
001A9Er 3                               ; all over the place
001A9Er 3  A9 68                        lda #$68                ; opcode for PLA
001AA0r 3  A0 06                        ldy #6
001AA2r 3               @2:
001AA2r 3  91 rr                        sta (cp),y
001AA4r 3  88                           dey
001AA5r 3  10 FB                        bpl @2
001AA7r 3               
001AA7r 3                               ; Adjust CP
001AA7r 3  A9 06                        lda #6
001AA9r 3  18                           clc
001AAAr 3  65 rr                        adc cp
001AACr 3  85 rr                        sta cp
001AAEr 3  A5 rr                        lda cp+1
001AB0r 3  69 00                        adc #0                  ; only need carry
001AB2r 3  85 rr                        sta cp+1
001AB4r 3               
001AB4r 3                               ; Complete compile of DO/?DO by replacing the six
001AB4r 3                               ; dummy bytes by PHA instructions. The address where
001AB4r 3                               ; they are located is on the Data Stack
001AB4r 3  B5 00                        lda 0,x
001AB6r 3  85 rr                        sta tmp1
001AB8r 3  B5 01                        lda 1,x
001ABAr 3  85 rr                        sta tmp1+1
001ABCr 3  E8                           inx
001ABDr 3  E8                           inx
001ABEr 3               
001ABEr 3                               ; Because of the way that CP works, we don't have to save
001ABEr 3                               ; CP, but CP-1
001ABEr 3  A5 rr                        lda cp
001AC0r 3  38                           sec
001AC1r 3  E9 01                        sbc #1
001AC3r 3  85 rr                        sta tmp2
001AC5r 3  A5 rr                        lda cp+1
001AC7r 3  E9 00                        sbc #0
001AC9r 3  85 rr                        sta tmp2+1
001ACBr 3               
001ACBr 3                               ; now compile this in the DO/?DO routine
001ACBr 3  A0 00                        ldy #0
001ACDr 3               
001ACDr 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001ACFr 3  91 rr                        sta (tmp1),y
001AD1r 3  C8                           iny
001AD2r 3  A5 rr                        lda tmp2+1      ; MSB
001AD4r 3  91 rr                        sta (tmp1),y
001AD6r 3  C8                           iny
001AD7r 3  A9 48                        lda #$48        ; Opcode for PHA
001AD9r 3  91 rr                        sta (tmp1),y
001ADBr 3  C8                           iny
001ADCr 3               
001ADCr 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001ADEr 3  91 rr                        sta (tmp1),y
001AE0r 3  C8                           iny
001AE1r 3  A5 rr                        lda tmp2        ; LSB
001AE3r 3  91 rr                        sta (tmp1),y
001AE5r 3  C8                           iny
001AE6r 3  A9 48                        lda #$48        ; Opcode for PHA
001AE8r 3  91 rr                        sta (tmp1),y
001AEAr 3               z_loop:
001AEAr 3  60           z_plus_loop:    rts
001AEBr 3               
001AEBr 3               
001AEBr 3               plus_loop_runtime:
001AEBr 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001AEBr 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001AEBr 3                       ; loop control so we can test with the Overflow Flag. See
001AEBr 3                       ; the Control Flow section of the manual for details.
001AEBr 3                       ; The step value is TOS in the loop. This
001AEBr 3                       ; must always be native compiled. In some Forths, this is a separate
001AEBr 3                       ; word called (+LOOP) or (LOOP)
001AEBr 3                       ; """
001AEBr 3               
001AEBr 3  18                           clc
001AECr 3  68                           pla             ; LSB of index
001AEDr 3  75 00                        adc 0,x         ; LSB of step
001AEFr 3  A8                           tay             ; temporary storage of LSB
001AF0r 3               
001AF0r 3  B8                           clv
001AF1r 3  68                           pla             ; MSB of index
001AF2r 3  75 01                        adc 1,x         ; MSB of step
001AF4r 3  48                           pha             ; put MSB of index back on stack
001AF5r 3               
001AF5r 3  98                           tya             ; put LSB of index back on stack
001AF6r 3  48                           pha
001AF7r 3               
001AF7r 3  E8                           inx             ; dump step from TOS
001AF8r 3  E8                           inx
001AF9r 3               
001AF9r 3                               ; If V flag is set, we're done looping and continue
001AF9r 3                               ; after the +LOOP instruction
001AF9r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001AFBr 3               
001AFBr 3               @hack:          ; This is why this routine must be natively compiled: We
001AFBr 3                               ; compile the opcode for JMP here without an address to
001AFBr 3                               ; go to, which is added by the next next instruction of
001AFBr 3                               ; LOOP/+LOOP during compile time
001AFBr 3  4C                           .byte $4C
001AFCr 3               
001AFCr 3               plus_loop_runtime_end:
001AFCr 3               
001AFCr 3               
001AFCr 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001AFCr 3               ; ## "lshift"  auto  ANS core
001AFCr 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001AFCr 3               
001AFCr 3               xt_lshift:
001AFCr 3  20 rr rr                     jsr underflow_2
001AFFr 3               
001AFFr 3                               ; max shift 16 times
001AFFr 3  B5 00                        lda 0,x
001B01r 3  29 0F                        and #%00001111
001B03r 3  F0 08                        beq @done
001B05r 3               
001B05r 3  A8                           tay
001B06r 3               
001B06r 3               @loop:
001B06r 3  16 02                        asl 2,x
001B08r 3  36 03                        rol 3,x
001B0Ar 3  88                           dey
001B0Br 3  D0 F9                        bne @loop
001B0Dr 3               
001B0Dr 3               @done:
001B0Dr 3  E8                           inx
001B0Er 3  E8                           inx
001B0Fr 3               
001B0Fr 3  60           z_lshift:       rts
001B10r 3               
001B10r 3               
001B10r 3               
001B10r 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001B10r 3               ; ## "m*"  auto  ANS core
001B10r 3                       ; """https://forth-standard.org/standard/core/MTimes
001B10r 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001B10r 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001B10r 3                       ;
001B10r 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001B10r 3                       ; with  : D+- O< IF DNEGATE THEN ;
001B10r 3                       ; """
001B10r 3               
001B10r 3               xt_m_star:
001B10r 3  20 rr rr                     jsr underflow_2
001B13r 3               
001B13r 3                               ; figure out the sign
001B13r 3  B5 01                        lda 1,x         ; MSB of n1
001B15r 3  55 03                        eor 3,x         ; MSB of n2
001B17r 3               
001B17r 3                               ; UM* uses all kinds of temporary variables so we don't
001B17r 3                               ; risk a conflict but just take the cycle hit and push
001B17r 3                               ; this to the stack
001B17r 3  48                           pha
001B18r 3               
001B18r 3                               ; get the absolute value of both numbers so we can feed
001B18r 3                               ; them to UM*, which does the real work
001B18r 3  20 rr rr                     jsr xt_abs
001B1Br 3  20 rr rr                     jsr xt_swap
001B1Er 3  20 rr rr                     jsr xt_abs
001B21r 3               
001B21r 3  20 rr rr                     jsr xt_um_star          ; ( d )
001B24r 3               
001B24r 3                               ; handle the sign
001B24r 3  68                           pla
001B25r 3  10 03                        bpl @done
001B27r 3               
001B27r 3  20 rr rr                     jsr xt_dnegate
001B2Ar 3               @done:
001B2Ar 3  60           z_m_star:       rts
001B2Br 3               
001B2Br 3               
001B2Br 3               
001B2Br 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001B2Br 3               ; ## "marker"  auto  ANS core ext
001B2Br 3                       ; """https://forth-standard.org/standard/core/MARKER
001B2Br 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001B2Br 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001B2Br 3                       ; Run the named word at a later time to restore all of the wordlists
001B2Br 3                       ; to their state when the word was created with marker.  Any words
001B2Br 3                       ; created after the marker (including the marker) will be forgotten.
001B2Br 3                       ;
001B2Br 3                       ; To do this, we want to end up with something that jumps to a
001B2Br 3                       ; run-time component with a link to the original CP and DP values:
001B2Br 3                       ;
001B2Br 3                       ;       jsr marker_runtime
001B2Br 3                       ;       <Original CP MSB>
001B2Br 3                       ;       <Original CP LSB>
001B2Br 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001B2Br 3                       ;       <Original DP LSB>
001B2Br 3                       ;       < USER variables from offset 4 to 39 >
001B2Br 3                       ;
001B2Br 3                       ;       The user variables include:
001B2Br 3                       ;       CURRENT (byte variable)
001B2Br 3                       ;       <All wordlists> (currently 12) (cell array)
001B2Br 3                       ;       <#ORDER> (byte variable)
001B2Br 3                       ;       <All search order> (currently 9) (byte array)
001B2Br 3                       ;
001B2Br 3                       ; This code uses tmp1 and tmp2
001B2Br 3                       ; """
001B2Br 3               
001B2Br 3               xt_marker:
001B2Br 3                               ; Before we do anything, we need to save CP, which
001B2Br 3                               ; after all is the whole point of this operation. CREATE
001B2Br 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001B2Br 3                               ; to the stack
001B2Br 3  20 rr rr                     jsr current_to_dp
001B2Er 3               
001B2Er 3  A5 rr                        lda dp
001B30r 3  48                           pha
001B31r 3  A5 rr                        lda dp+1
001B33r 3  48                           pha
001B34r 3               
001B34r 3  A5 rr                        lda cp
001B36r 3  48                           pha
001B37r 3  A5 rr                        lda cp+1
001B39r 3  48                           pha
001B3Ar 3               
001B3Ar 3  20 rr rr                     jsr xt_create
001B3Dr 3               
001B3Dr 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001B3Dr 3                               ; we have to replace by a jump to marker_runtime. We back up
001B3Dr 3                               ; two bytes and then overwrite the address
001B3Dr 3  A5 rr                        lda cp          ; LSB
001B3Fr 3  38                           sec
001B40r 3  E9 02                        sbc #2
001B42r 3  85 rr                        sta cp
001B44r 3               
001B44r 3  A5 rr                        lda cp+1        ; MSB
001B46r 3  E9 00                        sbc #0          ; we only care about the borrow
001B48r 3  85 rr                        sta cp+1
001B4Ar 3               
001B4Ar 3                               ; Add the address of the runtime component
001B4Ar 3  A0 rr                        ldy #>marker_runtime
001B4Cr 3  A9 rr                        lda #<marker_runtime
001B4Er 3  20 rr rr                     jsr cmpl_word
001B51r 3               
001B51r 3                               ; Add original CP as payload
001B51r 3  7A                           ply                     ; MSB
001B52r 3  68                           pla                     ; LSB
001B53r 3  20 rr rr                     jsr cmpl_word
001B56r 3               
001B56r 3                               ; Add original DP as payload
001B56r 3  7A                           ply                     ; MSB
001B57r 3  68                           pla                     ; LSB
001B58r 3  20 rr rr                     jsr cmpl_word
001B5Br 3               
001B5Br 3                               ; Add the user variables for the wordlists and search order.
001B5Br 3                               ; We're compiling them in byte order.
001B5Br 3  A0 04                        ldy #4                  ; Start at CURRENT
001B5Dr 3               @marker_loop:
001B5Dr 3  B1 rr                        lda (up),y
001B5Fr 3  20 rr rr                     jsr cmpl_a
001B62r 3  C8                           iny
001B63r 3  98                           tya
001B64r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001B66r 3  D0 F5                        bne @marker_loop
001B68r 3               
001B68r 3  60           z_marker:       rts
001B69r 3               
001B69r 3               
001B69r 3               
001B69r 3               marker_runtime:
001B69r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
001B69r 3                       ; when this marker was defined. We arrive here with the return
001B69r 3                       ; address on the Return Stack in the usual 65c02 format
001B69r 3                       ; """
001B69r 3               
001B69r 3                               ; Get the address of the string address off the stack and
001B69r 3                               ; increase by one because of the RTS mechanics
001B69r 3  68                           pla
001B6Ar 3  85 rr                        sta tmp1        ; LSB of address
001B6Cr 3  68                           pla
001B6Dr 3  85 rr                        sta tmp1+1      ; MSB of address
001B6Fr 3               
001B6Fr 3  E6 rr                        inc tmp1
001B71r 3  D0 02                        bne @1
001B73r 3  E6 rr                        inc tmp1+1
001B75r 3               @1:
001B75r 3  A0 00                        ldy #0
001B77r 3               
001B77r 3                               ; CP was stored first
001B77r 3  B1 rr                        lda (tmp1),y
001B79r 3  85 rr                        sta cp
001B7Br 3  C8                           iny
001B7Cr 3  B1 rr                        lda (tmp1),y
001B7Er 3  85 rr                        sta cp+1
001B80r 3               
001B80r 3                               ; Next was DP
001B80r 3  C8                           iny
001B81r 3  B1 rr                        lda (tmp1),y
001B83r 3  85 rr                        sta dp
001B85r 3  C8                           iny
001B86r 3  B1 rr                        lda (tmp1),y
001B88r 3  85 rr                        sta dp+1
001B8Ar 3               
001B8Ar 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001B8Ar 3                               ; to start restoring the wordlists and search order.
001B8Ar 3  A0 04                        ldy #4
001B8Cr 3               
001B8Cr 3               @marker_restore_loop:
001B8Cr 3                               ; Copy from the dictionary back on top of the wordlists
001B8Cr 3                               ; and search order.
001B8Cr 3  B1 rr                        lda (tmp1), y
001B8Er 3  91 rr                        sta (up), y
001B90r 3  C8                           iny
001B91r 3  98                           tya
001B92r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001B94r 3  D0 F6                        bne @marker_restore_loop
001B96r 3               
001B96r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001B99r 3               
001B99r 3                               ; The return instruction takes us back to the original caller
001B99r 3  60                           rts
001B9Ar 3               
001B9Ar 3               
001B9Ar 3               
001B9Ar 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001B9Ar 3               ; ## "max"  auto  ANS core
001B9Ar 3                       ; """https://forth-standard.org/standard/core/MAX
001B9Ar 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001B9Ar 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001B9Ar 3                       ; Flag indicates which number is larger. See also
001B9Ar 3                       ; http://6502.org/tutorials/compare_instructions.html and
001B9Ar 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001B9Ar 3                       ; """
001B9Ar 3               
001B9Ar 3               xt_max:
001B9Ar 3  20 rr rr                     jsr underflow_2
001B9Dr 3               
001B9Dr 3                               ; Compare LSB. We do this first to set the carry flag
001B9Dr 3  B5 00                        lda 0,x         ; LSB of TOS
001B9Fr 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001BA1r 3               
001BA1r 3  B5 01                        lda 1,x         ; MSB of TOS
001BA3r 3  F5 03                        sbc 3,x         ; MSB of NOS
001BA5r 3  50 02                        bvc @no_overflow
001BA7r 3               
001BA7r 3                               ; handle overflow, because we use signed numbers
001BA7r 3  49 80                        eor #$80        ; complement negative flag
001BA9r 3               
001BA9r 3               @no_overflow:
001BA9r 3                               ; if negative, NOS is larger and needs to be kept
001BA9r 3  30 08                        bmi @keep_nos
001BABr 3               
001BABr 3                               ; move TOS to NOS
001BABr 3  B5 00                        lda 0,x
001BADr 3  95 02                        sta 2,x
001BAFr 3  B5 01                        lda 1,x
001BB1r 3  95 03                        sta 3,x
001BB3r 3               
001BB3r 3               @keep_nos:
001BB3r 3  E8                           inx
001BB4r 3  E8                           inx
001BB5r 3               
001BB5r 3  60           z_max:          rts
001BB6r 3               
001BB6r 3               
001BB6r 3               
001BB6r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001BB6r 3               ; ## "min"  auto  ANS core
001BB6r 3                       ; """https://forth-standard.org/standard/core/MIN
001BB6r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001BB6r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001BB6r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001BB6r 3                       ; """
001BB6r 3               
001BB6r 3               xt_min:
001BB6r 3  20 rr rr                     jsr underflow_2
001BB9r 3               
001BB9r 3                               ; compare LSB. We do this first to set the carry flag
001BB9r 3  B5 00                        lda 0,x         ; LSB of TOS
001BBBr 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001BBDr 3               
001BBDr 3  B5 01                        lda 1,x         ; MSB of TOS
001BBFr 3  F5 03                        sbc 3,x         ; MSB of NOS
001BC1r 3  50 02                        bvc @no_overflow
001BC3r 3               
001BC3r 3                               ; handle overflow because we use signed numbers
001BC3r 3  49 80                        eor #$80
001BC5r 3               
001BC5r 3               @no_overflow:
001BC5r 3                               ; if negative, NOS is larger and needs to be dumped
001BC5r 3  10 08                        bpl @keep_nos
001BC7r 3               
001BC7r 3                               ; move TOS to NOS
001BC7r 3  B5 00                        lda 0,x
001BC9r 3  95 02                        sta 2,x
001BCBr 3  B5 01                        lda 1,x
001BCDr 3  95 03                        sta 3,x
001BCFr 3               
001BCFr 3               @keep_nos:
001BCFr 3  E8                           inx
001BD0r 3  E8                           inx
001BD1r 3               
001BD1r 3  60           z_min:          rts
001BD2r 3               
001BD2r 3               
001BD2r 3               
001BD2r 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001BD2r 3               ; ## "-"  auto  ANS core
001BD2r 3                       ; """https://forth-standard.org/standard/core/Minus"""
001BD2r 3               xt_minus:
001BD2r 3  20 rr rr                     jsr underflow_2
001BD5r 3               
001BD5r 3  38                           sec
001BD6r 3  B5 02                        lda 2,x         ; LSB
001BD8r 3  F5 00                        sbc 0,x
001BDAr 3  95 02                        sta 2,x
001BDCr 3               
001BDCr 3  B5 03                        lda 3,x         ; MSB
001BDEr 3  F5 01                        sbc 1,x
001BE0r 3  95 03                        sta 3,x
001BE2r 3               
001BE2r 3  E8                           inx
001BE3r 3  E8                           inx
001BE4r 3               
001BE4r 3  60           z_minus:        rts
001BE5r 3               
001BE5r 3               
001BE5r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001BE5r 3               ; ## "-leading"  auto  Tali String
001BE5r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001BE5r 3                       ; """
001BE5r 3               
001BE5r 3               xt_minus_leading:
001BE5r 3  20 rr rr                     jsr underflow_2
001BE8r 3               
001BE8r 3               @loop:
001BE8r 3                               ; Quit if we were given an empty string. This also terminates
001BE8r 3                               ; the main loop
001BE8r 3  B5 00                        lda 0,x
001BEAr 3  15 01                        ora 1,x
001BECr 3  F0 0F                        beq @done
001BEEr 3               
001BEEr 3  A1 02                        lda (2,x)               ; get first character
001BF0r 3  20 rr rr                     jsr is_whitespace
001BF3r 3  90 08                        bcc @done
001BF5r 3               
001BF5r 3                               ; It's whitespace, move one down
001BF5r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001BF8r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001BFBr 3               
001BFBr 3  80 EB                        bra @loop
001BFDr 3               @done:
001BFDr 3               z_minus_leading:
001BFDr 3  60                           rts
001BFEr 3               
001BFEr 3               
001BFEr 3               
001BFEr 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001BFEr 3               ; ## "-trailing"  auto  ANS string
001BFEr 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001BFEr 3                       ; Remove trailing spaces
001BFEr 3                       ; """
001BFEr 3               
001BFEr 3               xt_minus_trailing:
001BFEr 3  20 rr rr                     jsr underflow_2
001C01r 3               
001C01r 3                               ; if length entry is zero, return a zero and leave the
001C01r 3                               ; address part untouched
001C01r 3  B5 00                        lda 0,x         ; LSB of n
001C03r 3  15 01                        ora 1,x         ; MSB of n
001C05r 3  F0 33                        beq @done
001C07r 3               
001C07r 3                               ; Compute address of last char in tmp1 as
001C07r 3                               ; addr + u1 - 1
001C07r 3               
001C07r 3                               ; addr + u1
001C07r 3  18                           clc
001C08r 3  B5 02                        lda 2,x         ; LSB of addr
001C0Ar 3  75 00                        adc 0,x
001C0Cr 3  85 rr                        sta tmp1
001C0Er 3  B5 03                        lda 3,x         ; MSB of addr
001C10r 3  75 01                        adc 1,x
001C12r 3  85 rr                        sta tmp1+1
001C14r 3               
001C14r 3                               ; - 1
001C14r 3  A5 rr                        lda tmp1
001C16r 3  D0 02                        bne @1
001C18r 3  C6 rr                        dec tmp1+1
001C1Ar 3               @1:
001C1Ar 3  C6 rr                        dec tmp1
001C1Cr 3               
001C1Cr 3               @loop:
001C1Cr 3                               ; While spaces are found, move tmp1 backwards and
001C1Cr 3                               ; decrease the count on the data stack.
001C1Cr 3  B2 rr                        lda (tmp1)
001C1Er 3  C9 20                        cmp #AscSP
001C20r 3  D0 18                        bne @done
001C22r 3               
001C22r 3                               ; Move back one address.
001C22r 3  A5 rr                        lda tmp1
001C24r 3  D0 02                        bne @2
001C26r 3  C6 rr                        dec tmp1+1
001C28r 3               @2:
001C28r 3  C6 rr                        dec tmp1
001C2Ar 3               
001C2Ar 3                               ; Decrement count by one.
001C2Ar 3  B5 00                        lda 0,x
001C2Cr 3  D0 02                        bne @3
001C2Er 3  D6 01                        dec 1,x
001C30r 3               @3:
001C30r 3  D6 00                        dec 0,x
001C32r 3               
001C32r 3                               ; Check if there are any characters left.
001C32r 3  B5 00                        lda 0,x
001C34r 3  15 01                        ora 1,x
001C36r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
001C38r 3               
001C38r 3  80 E2                        bra @loop
001C3Ar 3               
001C3Ar 3               @done:
001C3Ar 3               z_minus_trailing:
001C3Ar 3  60                           rts
001C3Br 3               
001C3Br 3               
001C3Br 3               
001C3Br 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001C3Br 3               ; ## "mod"  auto  ANS core
001C3Br 3                       ; """https://forth-standard.org/standard/core/MOD
001C3Br 3                       ;
001C3Br 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001C3Br 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001C3Br 3                       ; """
001C3Br 3               xt_mod:
001C3Br 3  20 rr rr                     jsr underflow_2
001C3Er 3               
001C3Er 3  20 rr rr                     jsr xt_slash_mod
001C41r 3               
001C41r 3  E8                           inx             ; DROP
001C42r 3  E8                           inx
001C43r 3               z_mod:
001C43r 3  60                           rts
001C44r 3               
001C44r 3               
001C44r 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
001C44r 3               ; ## "move"  auto  ANS core
001C44r 3                       ; """https://forth-standard.org/standard/core/MOVE
001C44r 3                       ; Copy u "address units" from addr1 to addr2. Since our address
001C44r 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
001C44r 3                       ; is actually the only one of these three words that is in the CORE
001C44r 3                       ; set.
001C44r 3                       ;
001C44r 3                       ; This word must not be natively compiled.
001C44r 3                       ; """
001C44r 3               
001C44r 3               xt_move:
001C44r 3                               ; We let CMOVE and CMOVE> check if there is underflow or
001C44r 3                               ; we've been told to copy zero bytes
001C44r 3               
001C44r 3                               ; compare MSB first
001C44r 3  B5 03                        lda 3,x                 ; MSB of addr2
001C46r 3  D5 05                        cmp 5,x                 ; MSB of addr1
001C48r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001C4Ar 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001C4Cr 3               
001C4Cr 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001C4Fr 3               
001C4Fr 3               @lsb:
001C4Fr 3                               ; MSB were equal, so do the whole thing over with LSB
001C4Fr 3  B5 02                        lda 2,x                 ; LSB of addr2
001C51r 3  D5 04                        cmp 4,x                 ; LSB of addr1
001C53r 3  F0 08                        beq @equal              ; LSB is equal as well
001C55r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
001C57r 3               
001C57r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001C5Ar 3               
001C5Ar 3               @to_move_up:
001C5Ar 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
001C5Dr 3               @equal:
001C5Dr 3                               ; drop three entries from Data Stack
001C5Dr 3  8A                           txa
001C5Er 3  18                           clc
001C5Fr 3  69 06                        adc #6
001C61r 3  AA                           tax
001C62r 3               
001C62r 3  60           z_move:         rts
001C63r 3               
001C63r 3               
001C63r 3               
001C63r 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
001C63r 3               ; ## "name>int"  tested  Gforth
001C63r 3                       ; """See
001C63r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001C63r 3                       ; """
001C63r 3               
001C63r 3               xt_name_to_int:
001C63r 3  20 rr rr                     jsr underflow_1
001C66r 3               
001C66r 3                               ; The xt starts four bytes down from the nt
001C66r 3  B5 00                        lda 0,x
001C68r 3  18                           clc
001C69r 3  69 04                        adc #4
001C6Br 3  85 rr                        sta tmp3
001C6Dr 3               
001C6Dr 3  B5 01                        lda 1,x
001C6Fr 3  90 01                        bcc @done
001C71r 3  1A                           inc
001C72r 3               @done:
001C72r 3  85 rr                        sta tmp3+1
001C74r 3               
001C74r 3  A0 00                        ldy #0
001C76r 3  B1 rr                        lda (tmp3),y
001C78r 3  95 00                        sta 0,x
001C7Ar 3  C8                           iny
001C7Br 3  B1 rr                        lda (tmp3),y
001C7Dr 3  95 01                        sta 1,x
001C7Fr 3               
001C7Fr 3  60           z_name_to_int:  rts
001C80r 3               
001C80r 3               
001C80r 3               
001C80r 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
001C80r 3               ; ## "name>string"  tested  Gforth
001C80r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
001C80r 3               
001C80r 3               xt_name_to_string:
001C80r 3  20 rr rr                     jsr underflow_1
001C83r 3               
001C83r 3  CA                           dex
001C84r 3  CA                           dex
001C85r 3               
001C85r 3                               ; the length of the string is the first byte of the
001C85r 3                               ; header pointed to by nt
001C85r 3  A1 02                        lda (2,x)
001C87r 3  95 00                        sta 0,x
001C89r 3  74 01                        stz 1,x
001C8Br 3               
001C8Br 3                               ; the string itself always starts eight bytes down
001C8Br 3  B5 02                        lda 2,x         ; LSB
001C8Dr 3  18                           clc
001C8Er 3  69 08                        adc #8
001C90r 3  A8                           tay
001C91r 3  B5 03                        lda 3,x         ; MSB
001C93r 3  69 00                        adc #0          ; just need carry
001C95r 3  95 03                        sta 3,x
001C97r 3  94 02                        sty 2,x
001C99r 3               
001C99r 3               z_name_to_string:
001C99r 3  60                           rts
001C9Ar 3               
001C9Ar 3               
001C9Ar 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001C9Ar 3               ; ## "nc-limit"  tested  Tali Forth
001C9Ar 3               
001C9Ar 3               xt_nc_limit:
001C9Ar 3  CA                           dex
001C9Br 3  CA                           dex
001C9Cr 3  A9 rr                        lda #<nc_limit
001C9Er 3  95 00                        sta 0,x
001CA0r 3  A9 rr                        lda #>nc_limit
001CA2r 3  95 01                        sta 1,x
001CA4r 3               
001CA4r 3  60           z_nc_limit:     rts
001CA5r 3               
001CA5r 3               
001CA5r 3               
001CA5r 3               ; ## NEGATE ( n -- n ) "Two's complement"
001CA5r 3               ; ## "negate"  auto  ANS core
001CA5r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001CA5r 3               xt_negate:
001CA5r 3  20 rr rr                     jsr underflow_1
001CA8r 3               
001CA8r 3  A9 00                	lda #0
001CAAr 3  38                           sec
001CABr 3  F5 00                        sbc 0,x         ; LSB
001CADr 3  95 00                        sta 0,x
001CAFr 3               
001CAFr 3  A9 00                        lda #0
001CB1r 3  F5 01                        sbc 1,x         ; MSB
001CB3r 3  95 01                        sta 1,x
001CB5r 3               
001CB5r 3  60           z_negate:       rts
001CB6r 3               
001CB6r 3               
001CB6r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001CB6r 3               ; ## "never-native"  auto  Tali Forth
001CB6r 3               xt_never_native:
001CB6r 3  20 rr rr                     jsr current_to_dp
001CB9r 3  A0 01                        ldy #1          ; offset for status byte
001CBBr 3  B1 rr                        lda (dp),y
001CBDr 3  09 08                        ora #NN         ; Make sure NN flag is set
001CBFr 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
001CC1r 3  91 rr                        sta (dp),y
001CC3r 3               z_never_native:
001CC3r 3  60                           rts
001CC4r 3               
001CC4r 3               
001CC4r 3               ; ## NIP ( b a -- a ) "Delete NOS"
001CC4r 3               ; ## "nip"  auto  ANS core ext
001CC4r 3                       ; """https://forth-standard.org/standard/core/NIP"""
001CC4r 3               xt_nip:
001CC4r 3  20 rr rr                     jsr underflow_2
001CC7r 3               
001CC7r 3  B5 00                        lda 0,x         ; LSB
001CC9r 3  95 02                        sta 2,x
001CCBr 3  B5 01                        lda 1,x         ; MSB
001CCDr 3  95 03                        sta 3,x
001CCFr 3               
001CCFr 3  E8                           inx
001CD0r 3  E8                           inx
001CD1r 3               
001CD1r 3  60           z_nip:          rts
001CD2r 3               
001CD2r 3               
001CD2r 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
001CD2r 3               ; ## "<>"  auto  ANS core ext
001CD2r 3                       ; """https://forth-standard.org/standard/core/ne
001CD2r 3                       ;
001CD2r 3                       ; This is just a variant of EQUAL, we code it separately
001CD2r 3                       ; for speed.
001CD2r 3                       ; """
001CD2r 3               
001CD2r 3               xt_not_equals:
001CD2r 3  20 rr rr                     jsr underflow_2
001CD5r 3               
001CD5r 3  A0 00                        ldy #0                  ; default is true
001CD7r 3               
001CD7r 3  B5 00                        lda 0,x                 ; LSB
001CD9r 3  D5 02                        cmp 2,x
001CDBr 3  D0 0A                        bne @not_equal
001CDDr 3               
001CDDr 3                               ; LSB is equal
001CDDr 3  B5 01                        lda 1,x                 ; MSB
001CDFr 3  D5 03                        cmp 3,x
001CE1r 3  D0 04                        bne @not_equal
001CE3r 3               
001CE3r 3  A9 FF                        lda #$FF
001CE5r 3  80 01                        bra @done
001CE7r 3               
001CE7r 3               @not_equal:
001CE7r 3  88                           dey                     ; drop thru to done
001CE8r 3               
001CE8r 3               @done:
001CE8r 3  98                           tya
001CE9r 3  E8                           inx
001CEAr 3  E8                           inx
001CEBr 3  95 00                        sta 0,x
001CEDr 3  95 01                        sta 1,x
001CEFr 3               
001CEFr 3  60           z_not_equals:   rts
001CF0r 3               
001CF0r 3               
001CF0r 3               
001CF0r 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
001CF0r 3               ; ## "-rot"  auto  Gforth
001CF0r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
001CF0r 3               
001CF0r 3               xt_not_rote:
001CF0r 3  20 rr rr                     jsr underflow_3
001CF3r 3               
001CF3r 3  B4 01                        ldy 1,x         ; MSB first
001CF5r 3  B5 03                        lda 3,x
001CF7r 3  95 01                        sta 1,x
001CF9r 3               
001CF9r 3  B5 05                        lda 5,x
001CFBr 3  95 03                        sta 3,x
001CFDr 3  94 05                        sty 5,x
001CFFr 3               
001CFFr 3  B4 00                        ldy 0,x         ; LSB second
001D01r 3  B5 02                        lda 2,x
001D03r 3  95 00                        sta 0,x
001D05r 3               
001D05r 3  B5 04                        lda 4,x
001D07r 3  95 02                        sta 2,x
001D09r 3  94 04                        sty 4,x
001D0Br 3               
001D0Br 3  60           z_not_rote:     rts
001D0Cr 3               
001D0Cr 3               
001D0Cr 3               
001D0Cr 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001D0Cr 3               ; ## "number"  auto  Tali Forth
001D0Cr 3                       ; """Convert a number string to a double or single cell number. This
001D0Cr 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001D0Cr 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001D0Cr 3                       ; Based in part on the "Starting Forth" code
001D0Cr 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001D0Cr 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001D0Cr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001D0Cr 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001D0Cr 3                       ; dot to signal a double cell number is required to be the last
001D0Cr 3                       ; character of the string.
001D0Cr 3                       ;
001D0Cr 3                       ; Number calls >NUMBER which in turn calls UM*,
001D0Cr 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001D0Cr 3                       ; a pain.
001D0Cr 3                       ;"""
001D0Cr 3               
001D0Cr 3               xt_number:
001D0Cr 3  20 rr rr                     jsr underflow_2
001D0Fr 3               
001D0Fr 3                               ; we keep the flags for sign and double in tmpdsp because
001D0Fr 3                               ; we've run out of temporary variables
001D0Fr 3  64 rr                        stz tmpdsp      ; flag for double
001D11r 3  64 rr                        stz tmpdsp+1    ; flag for minus
001D13r 3               
001D13r 3                               ; If the first character is a minus, strip it off and set
001D13r 3                               ; the flag
001D13r 3  A1 02                        lda (2,x)
001D15r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001D17r 3  D0 0A                        bne @check_dot
001D19r 3               
001D19r 3                               ; It's a minus
001D19r 3  C6 rr                        dec tmpdsp+1
001D1Br 3  F6 02                        inc 2,x         ; start one character later
001D1Dr 3  D0 02                        bne @1
001D1Fr 3  F6 03                        inc 3,x
001D21r 3               @1:
001D21r 3  D6 00                        dec 0,x         ; decrease string length by one
001D23r 3               
001D23r 3               @check_dot:
001D23r 3                               ; If the last character is a dot, strip it off and set a
001D23r 3                               ; flag. We can use tmptos as a temporary variable
001D23r 3  B5 02                        lda 2,x         ; LSB of address
001D25r 3  18                           clc
001D26r 3  75 00                        adc 0,x         ; length of string
001D28r 3  85 rr                        sta tmptos
001D2Ar 3  B5 03                        lda 3,x
001D2Cr 3  69 00                        adc #0          ; only need carry
001D2Er 3  85 rr                        sta tmptos+1
001D30r 3               
001D30r 3                               ; tmptos now points to the first character after the string,
001D30r 3                               ; but we need the last character
001D30r 3  A5 rr                        lda tmptos
001D32r 3  D0 02                        bne @2
001D34r 3  C6 rr                        dec tmptos+1
001D36r 3               @2:
001D36r 3  C6 rr                        dec tmptos
001D38r 3               
001D38r 3  B2 rr                        lda (tmptos)
001D3Ar 3  C9 2E                        cmp #'.'
001D3Cr 3  D0 04                        bne @main
001D3Er 3               
001D3Er 3                               ; We have a dot, which means this is a double number. Flag
001D3Er 3                               ; the fact and reduce string length by one
001D3Er 3  C6 rr                        dec tmpdsp
001D40r 3  D6 00                        dec 0,x
001D42r 3               
001D42r 3               @main:
001D42r 3                               ; Set up stack for subroutine jump to >NUMBER, which means
001D42r 3                               ; we have to go ( addr u --> ud addr u )
001D42r 3  CA                           dex
001D43r 3  CA                           dex
001D44r 3  CA                           dex
001D45r 3  CA                           dex
001D46r 3               
001D46r 3  B5 04                        lda 4,x         ; LSB of length
001D48r 3  95 00                        sta 0,x
001D4Ar 3  74 01                        stz 1,x         ; MSB, max length 255 chars
001D4Cr 3               
001D4Cr 3  B5 06                        lda 6,x         ; LSB of address
001D4Er 3  95 02                        sta 2,x
001D50r 3  B5 07                        lda 7,x         ; MSB of address
001D52r 3  95 03                        sta 3,x
001D54r 3               
001D54r 3  74 04                        stz 4,x         ; clear space for ud
001D56r 3  74 05                        stz 5,x
001D58r 3  74 06                        stz 6,x
001D5Ar 3  74 07                        stz 7,x
001D5Cr 3               
001D5Cr 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
001D5Fr 3               
001D5Fr 3                               ; test length of returned string, which should be zero
001D5Fr 3  B5 00                        lda 0,x
001D61r 3  F0 15                        beq @all_converted
001D63r 3               
001D63r 3                               ; Something went wrong, we still have characters left over,
001D63r 3                               ; so we print an error and abort. If the NUMBER was called
001D63r 3                               ; by INTERPRET, we've already checked for Forth words, so
001D63r 3                               ; we're in deep trouble one way or another
001D63r 3  A9 3E                        lda #$3E        ; ASCII for ">"
001D65r 3  20 rr rr                     jsr emit_a
001D68r 3  20 rr rr                     jsr xt_type
001D6Br 3  A9 3C                        lda #$3C        ; ASCII for "<"
001D6Dr 3  20 rr rr                     jsr emit_a
001D70r 3  20 rr rr                     jsr xt_space
001D73r 3               
001D73r 3  A9 08                        lda #err_syntax
001D75r 3  4C rr rr                     jmp error
001D78r 3               
001D78r 3               @all_converted:
001D78r 3                               ; We can drop the string info
001D78r 3  E8                           inx
001D79r 3  E8                           inx
001D7Ar 3  E8                           inx
001D7Br 3  E8                           inx
001D7Cr 3               
001D7Cr 3                               ; We have a double-cell number on the Data Stack that might
001D7Cr 3                               ; actually have a minus and might actually be single-cell
001D7Cr 3  A5 rr                        lda tmpdsp      ; flag for double
001D7Er 3  F0 0D                        beq @single
001D80r 3               
001D80r 3                               ; Set status bit 5 to indicate this is a double number
001D80r 3  A9 20                        lda #%00100000
001D82r 3  04 rr                        tsb status
001D84r 3               
001D84r 3                               ; This is a double cell number. If it had a minus, we'll have
001D84r 3                               ; to negate it
001D84r 3  A5 rr                        lda tmpdsp+1
001D86r 3  F0 12                        beq @done       ; no minus, all done
001D88r 3               
001D88r 3  20 rr rr                     jsr xt_dnegate
001D8Br 3               
001D8Br 3  80 0D                        bra @done
001D8Dr 3               
001D8Dr 3               @single:
001D8Dr 3                               ; This is a single number, so we just drop the top cell
001D8Dr 3  E8                           inx
001D8Er 3  E8                           inx
001D8Fr 3               
001D8Fr 3                               ; Clear status bit 5 to indicate this is a single number
001D8Fr 3  A9 20                        lda #%00100000
001D91r 3  14 rr                        trb status
001D93r 3               
001D93r 3                               ; If we had a minus, we'll have to negate it
001D93r 3  A5 rr                        lda tmpdsp+1
001D95r 3  F0 03                        beq @done       ; no minus, all done
001D97r 3               
001D97r 3  20 rr rr                     jsr xt_negate
001D9Ar 3               @done:
001D9Ar 3  60           z_number:       rts
001D9Br 3               
001D9Br 3               
001D9Br 3               
001D9Br 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001D9Br 3               ; ## "#"  auto  ANS core
001D9Br 3                       ; """https://forth-standard.org/standard/core/num
001D9Br 3                       ; Add one char to the beginning of the pictured output string.
001D9Br 3                       ;
001D9Br 3                       ; Based on
001D9Br 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001D9Br 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001D9Br 3                       ; """
001D9Br 3               xt_number_sign:
001D9Br 3  20 rr rr                     jsr underflow_2         ; double number
001D9Er 3               
001D9Er 3  20 rr rr                     jsr xt_base
001DA1r 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
001DA4r 3               
001DA4r 3                               ; The following code is the ancient Forth word UD/MOD, which in
001DA4r 3                               ; various Forths (including Gforth) lives on under the hood,
001DA4r 3                               ; even though it's not an ANS standard word, it doesn't appear
001DA4r 3                               ; in the docs, it's only used here, and there are no tests for
001DA4r 3                               ; it. This is why we got rid of it. We'll be converting this
001DA4r 3                               ; mess to something more sane in the long run.
001DA4r 3  20 rr rr                     jsr xt_to_r             ; >r
001DA7r 3  20 rr rr                     jsr xt_zero             ; 0
001DAAr 3  20 rr rr                     jsr xt_r_fetch          ; r@
001DADr 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001DB0r 3  20 rr rr                     jsr xt_rot              ; rot
001DB3r 3  20 rr rr                     jsr xt_rot              ; rot
001DB6r 3  20 rr rr                     jsr xt_r_from           ; r>
001DB9r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001DBCr 3  20 rr rr                     jsr xt_rot              ; rot
001DBFr 3                               ; end of UD/MOD ( rem ud )
001DBFr 3               
001DBFr 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
001DC2r 3               
001DC2r 3                               ; Convert the number that is left over to an ASCII character. We
001DC2r 3                               ; use a string lookup for speed. Use either abc_str_lower for
001DC2r 3                               ; lower case or abc_str_upper for upper case (prefered)
001DC2r 3  B5 00                        lda 0,x
001DC4r 3  A8                           tay
001DC5r 3  B9 rr rr                     lda s_abc_upper,y
001DC8r 3  95 00                        sta 0,x
001DCAr 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
001DCCr 3               
001DCCr 3  20 rr rr                     jsr xt_hold
001DCFr 3               
001DCFr 3               z_number_sign:
001DCFr 3  60                           rts
001DD0r 3               
001DD0r 3               
001DD0r 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
001DD0r 3               ; ## "#>"  auto  ANS core
001DD0r 3                       ; """https://forth-standard.org/standard/core/num-end
001DD0r 3                       ; Finish conversion of pictured number string, putting address and
001DD0r 3                       ; length on the Data Stack.
001DD0r 3                       ;
001DD0r 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
001DD0r 3                       ; Based on
001DD0r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001DD0r 3                       ; """
001DD0r 3               xt_number_sign_greater:
001DD0r 3               
001DD0r 3  20 rr rr                     jsr underflow_2         ; double number
001DD3r 3               
001DD3r 3                               ; The start address lives in tohold
001DD3r 3  A5 rr                        lda tohold
001DD5r 3  95 00                        sta 0,x         ; LSB of tohold
001DD7r 3  95 02                        sta 2,x
001DD9r 3  A5 rr                        lda tohold+1
001DDBr 3  95 01                        sta 1,x         ; MSB of addr
001DDDr 3  95 03                        sta 3,x         ; ( addr addr )
001DDFr 3               
001DDFr 3                               ; The length of the string is pad - addr
001DDFr 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
001DE2r 3               
001DE2r 3  38                           sec
001DE3r 3  B5 00                        lda 0,x         ; LSB of pad address
001DE5r 3  F5 02                        sbc 2,x
001DE7r 3  95 02                        sta 2,x
001DE9r 3               
001DE9r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001DEBr 3  F5 03                        sbc 3,x
001DEDr 3  95 03                        sta 3,x         ; ( addr u pad )
001DEFr 3               
001DEFr 3  E8                           inx
001DF0r 3  E8                           inx
001DF1r 3               
001DF1r 3               z_number_sign_greater:
001DF1r 3  60                           rts
001DF2r 3               
001DF2r 3               
001DF2r 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
001DF2r 3               ; ## "#s"  auto  ANS core
001DF2r 3                       ; """https://forth-standard.org/standard/core/numS
001DF2r 3                       ; Completely convert number for pictured numerical output.
001DF2r 3                       ;
001DF2r 3                       ; Based on
001DF2r 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
001DF2r 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
001DF2r 3                       ; """
001DF2r 3               
001DF2r 3               xt_number_sign_s:
001DF2r 3  20 rr rr                     jsr underflow_2
001DF5r 3               @loop:
001DF5r 3                               ; convert a single number ("#")
001DF5r 3  20 rr rr                     jsr xt_number_sign
001DF8r 3               
001DF8r 3                               ; stop when double-celled number in TOS is zero:
001DF8r 3  B5 00                        lda 0,x
001DFAr 3  15 01                        ora 1,x
001DFCr 3  15 02                        ora 2,x
001DFEr 3  15 03                        ora 3,x
001E00r 3  D0 F3                        bne @loop
001E02r 3               
001E02r 3               z_number_sign_s:
001E02r 3  60                           rts
001E03r 3               
001E03r 3               
001E03r 3               
001E03r 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
001E03r 3               ; ## "of"  auto  ANS core ext
001E03r 3                       ; """http://forth-standard.org/standard/core/OF"""
001E03r 3               
001E03r 3               xt_of:
001E03r 3                               ; Check if value is equal to this case.
001E03r 3                               ; Postpone over (eg. compile a jsr to it)
001E03r 3  A0 rr                        ldy #>xt_over
001E05r 3  A9 rr                        lda #<xt_over
001E07r 3  20 rr rr                     jsr cmpl_subroutine
001E0Ar 3               
001E0Ar 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001E0Ar 3  A0 rr                        ldy #>xt_equal
001E0Cr 3  A9 rr                        lda #<xt_equal
001E0Er 3  20 rr rr                     jsr cmpl_subroutine
001E11r 3               
001E11r 3  20 rr rr                     jsr xt_if
001E14r 3               
001E14r 3                               ; If it's true, consume the original value.
001E14r 3                               ; Postpone DROP (eg. compile a jsr to it)
001E14r 3  A0 rr                        ldy #>xt_drop
001E16r 3  A9 rr                        lda #<xt_drop
001E18r 3  20 rr rr                     jsr cmpl_subroutine
001E1Br 3               
001E1Br 3  60           z_of:           rts
001E1Cr 3               
001E1Cr 3               
001E1Cr 3               
001E1Cr 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
001E1Cr 3               ; ## "1"  auto  Tali Forth
001E1Cr 3                       ; """This is also the code for EDITOR-WORDLIST"""
001E1Cr 3               xt_editor_wordlist:
001E1Cr 3               xt_one:
001E1Cr 3  CA                           dex
001E1Dr 3  CA                           dex
001E1Er 3  A9 01                        lda #1
001E20r 3  95 00                        sta 0,x
001E22r 3  74 01                        stz 1,x
001E24r 3               
001E24r 3               z_editor_wordlist:
001E24r 3               z_one:
001E24r 3  60                           rts
001E25r 3               
001E25r 3               
001E25r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001E25r 3               ; ## "1-"  auto  ANS core
001E25r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001E25r 3               
001E25r 3               xt_one_minus:
001E25r 3  20 rr rr                     jsr underflow_1
001E28r 3               
001E28r 3  B5 00                        lda 0,x
001E2Ar 3  D0 02                        bne @1
001E2Cr 3  D6 01                        dec 1,x
001E2Er 3               @1:
001E2Er 3  D6 00                        dec 0,x
001E30r 3               
001E30r 3  60           z_one_minus:    rts
001E31r 3               
001E31r 3               
001E31r 3               
001E31r 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
001E31r 3               ; ## "1+"  auto  ANS core
001E31r 3                       ; """https://forth-standard.org/standard/core/OnePlus
001E31r 3                       ;
001E31r 3                       ; Code is shared with CHAR-PLUS
001E31r 3                       ; """
001E31r 3               
001E31r 3               xt_char_plus:
001E31r 3               xt_one_plus:
001E31r 3  20 rr rr                     jsr underflow_1
001E34r 3               
001E34r 3  F6 00                        inc 0,x
001E36r 3  D0 02                        bne @done
001E38r 3  F6 01                        inc 1,x
001E3Ar 3               
001E3Ar 3               @done:
001E3Ar 3               z_char_plus:
001E3Ar 3  60           z_one_plus:     rts
001E3Br 3               
001E3Br 3               
001E3Br 3               
001E3Br 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
001E3Br 3               ; ## "only"  auto  ANS search ext
001E3Br 3                       ; """https://forth-standard.org/standard/search/ONLY"""
001E3Br 3               
001E3Br 3               xt_only:
001E3Br 3                               ; Put -1 on data stack.
001E3Br 3  CA                           dex
001E3Cr 3  CA                           dex
001E3Dr 3  A9 FF                        lda #$FF
001E3Fr 3  95 00                        sta 0,x
001E41r 3  95 01                        sta 1,x
001E43r 3               
001E43r 3                               ; Invoke set-order to set the minimum search order.
001E43r 3  20 rr rr                     jsr xt_set_order
001E46r 3               
001E46r 3  60           z_only:         rts
001E47r 3               
001E47r 3               
001E47r 3               
001E47r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
001E47r 3               ; ## "or"  auto  ANS core
001E47r 3                       ; """https://forth-standard.org/standard/core/OR"
001E47r 3               xt_or:
001E47r 3  20 rr rr                     jsr underflow_2
001E4Ar 3               
001E4Ar 3  B5 00                        lda 0,x
001E4Cr 3  15 02                        ora 2,x
001E4Er 3  95 02                        sta 2,x
001E50r 3               
001E50r 3  B5 01                        lda 1,x
001E52r 3  15 03                        ora 3,x
001E54r 3  95 03                        sta 3,x
001E56r 3               
001E56r 3  E8                           inx
001E57r 3  E8                           inx
001E58r 3               
001E58r 3  60           z_or:           rts
001E59r 3               
001E59r 3               
001E59r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
001E59r 3               ; ## "order"  auto  ANS core
001E59r 3                       ; """https://forth-standard.org/standard/search/ORDER
001E59r 3                       ; Note the search order is displayed from first search to last
001E59r 3                       ; searched and is therefore exactly the reverse of the order in which
001E59r 3                       ; Forth stacks are displayed.
001E59r 3                       ;
001E59r 3                       ; A Forth implementation of this word is:
001E59r 3                       ;
001E59r 3                       ; 	: .wid ( wid -- )
001E59r 3                       ; 	dup 0=  if ." Forth "  drop    else
001E59r 3                       ; 	dup 1 = if ." Editor " drop    else
001E59r 3                       ; 	dup 2 = if ." Assembler " drop else
001E59r 3                       ; 	dup 3 = if ." Root " drop      else
001E59r 3                       ; 	           . ( just print the number )
001E59r 3                       ; 	then then then then ;
001E59r 3                       ;
001E59r 3                       ; : ORDER ( -- )
001E59r 3                       ; 	cr get-order 0 ?do .wid loop
001E59r 3                       ; 	space space get-current .wid ;
001E59r 3                       ;
001E59r 3                       ; This is an interactive program, so speed
001E59r 3                       ; is not as important as size. We assume we do not have more than 255
001E59r 3                       ; wordlists.
001E59r 3                       ; """
001E59r 3               
001E59r 3               xt_order:
001E59r 3  20 rr rr                     jsr xt_cr
001E5Cr 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
001E5Fr 3               
001E5Fr 3                               ; Paranoid: Check if there are no wordlists, a rather
001E5Fr 3                               ; pathological case. this would mean ( 0 ) on the stack. In
001E5Fr 3                               ; that case, we just drop n and run
001E5Fr 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
001E61r 3  F0 1E                        beq @drop_done
001E63r 3               
001E63r 3               @have_wordlists:
001E63r 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
001E63r 3                               ; on the stack
001E63r 3  A8                           tay
001E64r 3               @loop:
001E64r 3  E8                           inx
001E65r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
001E66r 3  B5 00                        lda 0,x
001E68r 3               
001E68r 3  5A                           phy
001E69r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
001E6Cr 3  7A                           ply
001E6Dr 3               
001E6Dr 3  88                           dey
001E6Er 3  D0 F4                        bne @loop
001E70r 3               
001E70r 3                               ; We've printed the wordlists, now we add the current wordlist.
001E70r 3                               ; This follows the convention of Gforth
001E70r 3  20 rr rr                     jsr xt_space
001E73r 3  20 rr rr                     jsr xt_space
001E76r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
001E79r 3               
001E79r 3  B5 00                        lda 0,x
001E7Br 3  20 rr rr                     jsr _print_wid_string
001E7Er 3  20 rr rr                     jsr xt_cr
001E81r 3               
001E81r 3               @drop_done:
001E81r 3  E8                           inx
001E82r 3  E8                           inx
001E83r 3               z_order:
001E83r 3  60                           rts
001E84r 3               
001E84r 3               _print_wid_string:
001E84r 3                       ; """Helper function for ORDER: Given a WID in A, print the
001E84r 3                       ; corresponding string. If there is no such word list defined, just
001E84r 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
001E84r 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
001E84r 3                       ; theory, we could speed this up by having the WID be the same as the
001E84r 3                       ; number of the strings. However, ORDER is used rather infrequently and
001E84r 3                       ; this would make changes to the strings.asm file very dangerous, so we
001E84r 3                       ; follow the slightly more complicated route with a translation table.
001E84r 3                       ; """
001E84r 3                               ; If the WID is larger than 3, we have no string avaliable and
001E84r 3                               ; just print the number.
001E84r 3                               ; See http://6502.org/tutorials/compare_instructions.html
001E84r 3                               ; for details
001E84r 3  C9 04                        cmp #4
001E86r 3  90 09                        bcc @output_string      ; less than 4, print a real string
001E88r 3               
001E88r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
001E88r 3                               ; print the number
001E88r 3  CA                           dex
001E89r 3  CA                           dex
001E8Ar 3  95 00                        sta 0,x
001E8Cr 3  74 01                        stz 1,x
001E8Er 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
001E91r 3               
001E91r 3               @output_string:
001E91r 3                               ; Get the string number based on WID 0 to 3
001E91r 3  A8                           tay
001E92r 3  B9 rr rr                     lda @wid_data,y
001E95r 3               
001E95r 3                               ; Print without a line feed
001E95r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
001E98r 3               
001E98r 3               @wid_data:
001E98r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
001E98r 3                       ; less than 4.
001E98r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
001E99r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
001E9Ar 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
001E9Br 3  08                   .byte str_wid_root             ; WID 3: "Root"
001E9Cr 3               
001E9Cr 3               
001E9Cr 3               
001E9Cr 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
001E9Cr 3               ; ## "output"  tested  Tali Forth
001E9Cr 3               xt_output:
001E9Cr 3                       ; """Return the address where the jump target for EMIT is stored (but
001E9Cr 3                       ; not the vector itself). By default, this will hold the value of
001E9Cr 3                       ; kernel_putc routine, but this can be changed by the user, hence this
001E9Cr 3                       ; routine.
001E9Cr 3                       ; """
001E9Cr 3  CA                           dex
001E9Dr 3  CA                           dex
001E9Er 3  A9 rr                        lda #<output
001EA0r 3  95 00                        sta 0,x
001EA2r 3  A9 rr                        lda #>output
001EA4r 3  95 01                        sta 1,x
001EA6r 3               
001EA6r 3  60           z_output:       rts
001EA7r 3               
001EA7r 3               
001EA7r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
001EA7r 3               ; ## "over"  auto  ANS core
001EA7r 3                       ; """https://forth-standard.org/standard/core/OVER"""
001EA7r 3               xt_over:
001EA7r 3  20 rr rr                     jsr underflow_2
001EAAr 3               
001EAAr 3  CA                           dex
001EABr 3  CA                           dex
001EACr 3               
001EACr 3  B5 04                        lda 4,x         ; LSB
001EAEr 3  95 00                        sta 0,x
001EB0r 3  B5 05                        lda 5,x         ; MSB
001EB2r 3  95 01                        sta 1,x
001EB4r 3               
001EB4r 3  60           z_over:         rts
001EB5r 3               
001EB5r 3               
001EB5r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
001EB5r 3               ; ## "pad"  auto  ANS core ext
001EB5r 3                       ; """https://forth-standard.org/standard/core/PAD
001EB5r 3                       ; Return address to a temporary area in free memory for user. Must
001EB5r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
001EB5r 3                       ; the compile area pointer (CP) and therefore varies in position.
001EB5r 3                       ; This area is reserved for the user and not used by the system
001EB5r 3                       ; """
001EB5r 3               xt_pad:
001EB5r 3  CA                           dex
001EB6r 3  CA                           dex
001EB7r 3               
001EB7r 3  A5 rr                        lda cp
001EB9r 3  18                           clc
001EBAr 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
001EBCr 3  95 00                        sta 0,x
001EBEr 3               
001EBEr 3  A5 rr                        lda cp+1
001EC0r 3  69 00                        adc #0          ; only need carry
001EC2r 3  95 01                        sta 1,x
001EC4r 3               
001EC4r 3  60           z_pad:          rts
001EC5r 3               
001EC5r 3               
001EC5r 3               ; ## PAGE ( -- ) "Clear the screen"
001EC5r 3               ; ## "page"  tested  ANS facility
001EC5r 3                       ; """https://forth-standard.org/standard/facility/PAGE
001EC5r 3                       ; Clears a page if supported by ANS terminal codes. This is
001EC5r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
001EC5r 3                       ; left of the screen
001EC5r 3                       ; """
001EC5r 3               xt_page:
001EC5r 3  A9 1B                        lda #AscESC
001EC7r 3  20 rr rr                     jsr emit_a
001ECAr 3  A9 5B                        lda #$5B        ; ASCII for "["
001ECCr 3  20 rr rr                     jsr emit_a
001ECFr 3  A9 32                        lda #'2'
001ED1r 3  20 rr rr                     jsr emit_a
001ED4r 3  A9 4A                        lda #'J'
001ED6r 3  20 rr rr                     jsr emit_a
001ED9r 3               
001ED9r 3                               ; move cursor to top left of screen
001ED9r 3  20 rr rr                     jsr xt_zero
001EDCr 3  20 rr rr                     jsr xt_zero
001EDFr 3  20 rr rr                     jsr xt_at_xy
001EE2r 3               
001EE2r 3  60           z_page:         rts
001EE3r 3               
001EE3r 3               
001EE3r 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
001EE3r 3               ; ## "("  auto  ANS core
001EE3r 3                       ; """http://forth-standard.org/standard/core/p"""
001EE3r 3               
001EE3r 3               xt_paren:
001EE3r 3                               ; Put a right paren on the stack.
001EE3r 3  CA                           dex
001EE4r 3  CA                           dex
001EE5r 3  A9 29                        lda #41     ; Right parenthesis
001EE7r 3  95 00                        sta 0,x
001EE9r 3  74 01                        stz 1,x
001EEBr 3               
001EEBr 3                               ; Call parse.
001EEBr 3  20 rr rr                     jsr xt_parse
001EEEr 3               
001EEEr 3                               ; Throw away the result.
001EEEr 3  E8                           inx
001EEFr 3  E8                           inx
001EF0r 3  E8                           inx
001EF1r 3  E8                           inx
001EF2r 3               
001EF2r 3  60           z_paren:        rts
001EF3r 3               
001EF3r 3               
001EF3r 3               
001EF3r 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
001EF3r 3               ; ## "parse-name"  auto  ANS core ext
001EF3r 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
001EF3r 3                       ; Find next word in input string, skipping leading whitespace. This is
001EF3r 3                       ; a special form of PARSE and drops through to that word. See PARSE
001EF3r 3                       ; for more detail. We use this word internally for the interpreter
001EF3r 3                       ; because it is a lot easier to use. Reference implementations at
001EF3r 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
001EF3r 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
001EF3r 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
001EF3r 3                       ; though the ANS standard talks about skipping "spaces", whitespace
001EF3r 3                       ; is actually perfectly legal (see for example
001EF3r 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
001EF3r 3                       ; Otherwise, PARSE-NAME chokes on tabs.
001EF3r 3                       ; """
001EF3r 3               
001EF3r 3               xt_parse_name:
001EF3r 3                               ; To enable the compilation of the high-level Forth words
001EF3r 3                               ; in forth-words.asm and user-words.asm at boot time,
001EF3r 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
001EF3r 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
001EF3r 3                               ; to the current location is in toin (>IN). We need to check,
001EF3r 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
001EF3r 3                               ; we can't just use Y as an index.
001EF3r 3               
001EF3r 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
001EF3r 3  A5 rr                        lda ciblen              ; LSB of counter
001EF5r 3  38                           sec
001EF6r 3  E5 rr                        sbc toin
001EF8r 3  85 rr                        sta tmp1
001EFAr 3  A5 rr                        lda ciblen+1            ; MSB
001EFCr 3  E5 rr                        sbc toin+1
001EFEr 3  85 rr                        sta tmp1+1
001F00r 3               
001F00r 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
001F00r 3  A5 rr                        lda tmp1
001F02r 3  05 rr                        ora tmp1+1
001F04r 3  F0 28                        beq @empty_line
001F06r 3               
001F06r 3                               ; We walk through the characters starting at CIB+TOIN, so we
001F06r 3                               ; save a temp version of that in tmp2
001F06r 3  A5 rr                        lda cib
001F08r 3  18                           clc
001F09r 3  65 rr                        adc toin
001F0Br 3  85 rr                        sta tmp2                ; LSB of first character
001F0Dr 3  A5 rr                        lda cib+1
001F0Fr 3  65 rr                        adc toin+1
001F11r 3  85 rr                        sta tmp2+1              ; MSB
001F13r 3               
001F13r 3               @skip_loop:
001F13r 3  B2 rr                        lda (tmp2)              ; work copy of cib
001F15r 3  20 rr rr                     jsr is_whitespace
001F18r 3  90 1F                        bcc @char_found
001F1Ar 3               
001F1Ar 3                               ; Char is still whitespace, continue
001F1Ar 3  E6 rr                        inc tmp2
001F1Cr 3  D0 02                        bne @2
001F1Er 3  E6 rr                        inc tmp2+1
001F20r 3               @2:
001F20r 3                               ; Adjust counter
001F20r 3  A5 rr                        lda tmp1
001F22r 3  D0 02                        bne @3
001F24r 3  C6 rr                        dec tmp1+1
001F26r 3               @3:
001F26r 3  C6 rr                        dec tmp1
001F28r 3               
001F28r 3  A5 rr                        lda tmp1
001F2Ar 3  05 rr                        ora tmp1+1
001F2Cr 3  D0 E5                        bne @skip_loop          ; fall through if empty line
001F2Er 3               
001F2Er 3               @empty_line:
001F2Er 3                               ; Neither the ANS Forth nor the Gforth documentation say
001F2Er 3                               ; what to return as an address if a string with only
001F2Er 3                               ; spaces is given. For speed reasons, we just return junk
001F2Er 3                               ; NOS, with the TOS zero as per standard
001F2Er 3  CA                           dex
001F2Fr 3  CA                           dex
001F30r 3  CA                           dex
001F31r 3  CA                           dex
001F32r 3               
001F32r 3  74 00                        stz 0,x                 ; TOS is zero
001F34r 3  74 01                        stz 1,x
001F36r 3               
001F36r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
001F39r 3               
001F39r 3               @char_found:
001F39r 3                               ; We arrive here with tmp2 pointing to the first non-space
001F39r 3                               ; character. This is where the word really starts, so
001F39r 3                               ; we use it to calculate the new >IN by subtracting
001F39r 3  A5 rr                        lda tmp2
001F3Br 3  38                           sec
001F3Cr 3  E5 rr                        sbc cib
001F3Er 3  85 rr                        sta toin
001F40r 3  A5 rr                        lda tmp2+1
001F42r 3  E5 rr                        sbc cib+1
001F44r 3  85 rr                        sta toin+1
001F46r 3               
001F46r 3                               ; prepare Data Stack for PARSE by adding space
001F46r 3                               ; as the delimiter
001F46r 3  CA                           dex
001F47r 3  CA                           dex
001F48r 3               
001F48r 3  A9 20                        lda #AscSP
001F4Ar 3  95 00                        sta 0,x
001F4Cr 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
001F4Er 3               
001F4Er 3               
001F4Er 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
001F4Er 3               ; ## "parse"  tested  ANS core ext
001F4Er 3                       ; """https://forth-standard.org/standard/core/PARSE
001F4Er 3                       ; Find word in input string delimited by character given. Do not
001F4Er 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
001F4Er 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
001F4Er 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
001F4Er 3                       ;
001F4Er 3                       ;
001F4Er 3                       ;     cib  cib+toin   cib+ciblen
001F4Er 3                       ;      v      v            v
001F4Er 3                       ;     |###################|
001F4Er 3                       ;
001F4Er 3                       ;     |------>|  toin (>IN)
001F4Er 3                       ;     |------------------->|  ciblen
001F4Er 3                       ;
001F4Er 3                       ; The input string is stored starting at the address in the Current
001F4Er 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
001F4Er 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
001F4Er 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
001F4Er 3                       ; useful string if there are any characters at all. As with
001F4Er 3                       ; PARSE-NAME, we must be able to handle strings with a length of
001F4Er 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
001F4Er 3                       ; """
001F4Er 3               
001F4Er 3               xt_parse:
001F4Er 3  20 rr rr                     jsr underflow_1
001F51r 3               
001F51r 3                               ; If the input buffer is empty, we just return
001F51r 3  A5 rr                        lda ciblen
001F53r 3  05 rr                        ora ciblen+1
001F55r 3  F0 0C                        beq @abort_parse
001F57r 3               
001F57r 3                               ; If the pointer >IN is larger or equal to the length of
001F57r 3                               ; the input buffer (CIBLEN), the line is done. Put
001F57r 3                               ; differently, we only continue if >IN is smaller than
001F57r 3                               ; CIBLEN
001F57r 3  A5 rr                        lda toin+1              ; MSB
001F59r 3  C5 rr                        cmp ciblen+1
001F5Br 3  90 0E                        bcc @go_parse           ; unsigned comparison
001F5Dr 3               
001F5Dr 3  A5 rr                        lda toin                ; LSB
001F5Fr 3  C5 rr                        cmp ciblen
001F61r 3  90 08                        bcc @go_parse
001F63r 3               
001F63r 3               @abort_parse:
001F63r 3                               ; Sorry, this line is over
001F63r 3  CA                           dex
001F64r 3  CA                           dex
001F65r 3  74 00                        stz 0,x
001F67r 3  74 01                        stz 1,x
001F69r 3               
001F69r 3  80 7A                        bra @done
001F6Br 3               @go_parse:
001F6Br 3                               ; We actually have work to do. Save the delimiter in
001F6Br 3                               ; tmptos.
001F6Br 3  B5 00                        lda 0,x
001F6Dr 3  85 rr                        sta tmptos
001F6Fr 3               
001F6Fr 3                               ; We can now prepare the Data Stack for the return value
001F6Fr 3  CA                           dex
001F70r 3  CA                           dex
001F71r 3               
001F71r 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
001F71r 3                               ; tmp2 is initially the same as tmp1, then the work index
001F71r 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
001F71r 3               
001F71r 3                               ; Calculate the beginning of the string, which is also the
001F71r 3                               ; address to return
001F71r 3  A5 rr                        lda cib
001F73r 3  18                           clc
001F74r 3  65 rr                        adc toin        ; LSB
001F76r 3  85 rr                        sta tmp1
001F78r 3  85 rr                        sta tmp2
001F7Ar 3  95 02                        sta 2,x
001F7Cr 3               
001F7Cr 3  A5 rr                        lda cib+1
001F7Er 3  65 rr                        adc toin+1      ; MSB
001F80r 3  85 rr                        sta tmp1+1
001F82r 3  85 rr                        sta tmp2+1
001F84r 3  95 03                        sta 3,x
001F86r 3               
001F86r 3                               ; Calculate the address where the input buffer ends plus 1, so
001F86r 3                               ; we can compare it with TOIN, which is an index
001F86r 3  A5 rr                        lda cib
001F88r 3  18                           clc
001F89r 3  65 rr                        adc ciblen
001F8Br 3  85 rr                        sta tmp3
001F8Dr 3  A5 rr                        lda cib+1
001F8Fr 3  65 rr                        adc ciblen+1
001F91r 3  85 rr                        sta tmp3+1
001F93r 3               
001F93r 3                               ; Initialize the offset we use to adjust EOL or found delimiter
001F93r 3  64 rr                        stz tmptos+1
001F95r 3               @loop:
001F95r 3                               ; If we are at the end of the string, quit
001F95r 3  A5 rr                        lda tmp2
001F97r 3  C5 rr                        cmp tmp3
001F99r 3  D0 06                        bne @not_empty
001F9Br 3               
001F9Br 3  A5 rr                        lda tmp2+1
001F9Dr 3  C5 rr                        cmp tmp3+1
001F9Fr 3  F0 1D                        beq @eol
001FA1r 3               @not_empty:
001FA1r 3                               ; We have to do this the hard way. In fact, it's really
001FA1r 3                               ; hard since if we are dealing with a SPACE, the standard
001FA1r 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
001FA1r 3                               ; Tali would choke on tabs between words. For details, see
001FA1r 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
001FA1r 3                               ; In theory, we could make this faster by defining a delimiter
001FA1r 3                               ; that is 00 as the sign that we skip all whitespace, thereby
001FA1r 3                               ; avoiding having to test every time. However, somebody,
001FA1r 3                               ; somewhere might want to parse a zero-delimited list. Since
001FA1r 3                               ; any byte value could be chosen for that, we just test for
001FA1r 3                               ; a space every single time for the moment.
001FA1r 3  B2 rr                        lda (tmp2)
001FA3r 3               
001FA3r 3  A4 rr                        ldy tmptos
001FA5r 3  C0 20                        cpy #AscSP
001FA7r 3  D0 07                        bne @not_whitespace
001FA9r 3               
001FA9r 3                               ; The delimiter is a space, so we're looking for all
001FA9r 3                               ; whitespace
001FA9r 3  20 rr rr                     jsr is_whitespace
001FACr 3  90 02                        bcc @not_whitespace
001FAEr 3  80 0C                        bra @found_delimiter
001FB0r 3               
001FB0r 3               @not_whitespace:
001FB0r 3                               ; The delimiter is not a space, so we're looking for
001FB0r 3                               ; whatever it is
001FB0r 3  C5 rr                        cmp tmptos
001FB2r 3  F0 08                        beq @found_delimiter
001FB4r 3               
001FB4r 3                               ; Not a delimiter, next character
001FB4r 3  E6 rr                        inc tmp2
001FB6r 3  D0 DD                        bne @loop
001FB8r 3  E6 rr                        inc tmp2+1
001FBAr 3  80 D9                        bra @loop
001FBCr 3               
001FBCr 3               @found_delimiter:
001FBCr 3                               ; Increase the offset: If we've found a delimiter, we want
001FBCr 3                               ; TOIN to point to the character after it, not the delimiter
001FBCr 3                               ; itself
001FBCr 3  E6 rr                        inc tmptos+1
001FBEr 3               @eol:
001FBEr 3                               ; The length of the new string is tmp2-tmp1
001FBEr 3  A5 rr                        lda tmp2
001FC0r 3  38                           sec
001FC1r 3  E5 rr                        sbc tmp1
001FC3r 3  95 00                        sta 0,x
001FC5r 3               
001FC5r 3  A5 rr                        lda tmp2+1
001FC7r 3  E5 rr                        sbc tmp1+1
001FC9r 3  95 01                        sta 1,x
001FCBr 3               
001FCBr 3                               ; The new offset is tmp2-cib
001FCBr 3  A5 rr                        lda tmp2
001FCDr 3  38                           sec
001FCEr 3  E5 rr                        sbc cib
001FD0r 3  85 rr                        sta toin
001FD2r 3  A5 rr                        lda tmp2+1
001FD4r 3  E5 rr                        sbc cib+1
001FD6r 3  85 rr                        sta toin+1
001FD8r 3               
001FD8r 3                               ; Add in the delimiter
001FD8r 3  A5 rr                        lda toin
001FDAr 3  18                           clc
001FDBr 3  65 rr                        adc tmptos+1
001FDDr 3  85 rr                        sta toin
001FDFr 3  A5 rr                        lda toin+1
001FE1r 3  69 00                        adc #0          ; we only need the carry
001FE3r 3  85 rr                        sta toin+1
001FE5r 3               @done:
001FE5r 3               z_parse_name:
001FE5r 3  60           z_parse:        rts
001FE6r 3               
001FE6r 3               
001FE6r 3               
001FE6r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
001FE6r 3               ; ## "pick"  auto  ANS core ext
001FE6r 3                       ; """https://forth-standard.org/standard/core/PICK
001FE6r 3                       ; Take the u-th element out of the stack and put it on TOS,
001FE6r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
001FE6r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
001FE6r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
001FE6r 3                       ; """
001FE6r 3               
001FE6r 3               xt_pick:
001FE6r 3                               ; Checking for underflow is difficult because it depends on
001FE6r 3                               ; which element we want to grab. We could probably figure
001FE6r 3                               ; something out, but it wouldn't work with underflow stripping
001FE6r 3                               ; Since using PICK is considered poor form anyway, we just
001FE6r 3                               ; leave it as it is
001FE6r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
001FE8r 3  8A                           txa
001FE9r 3  75 00                        adc 0,x
001FEBr 3  A8                           tay
001FECr 3               
001FECr 3  B9 02 00                     lda 0002,y
001FEFr 3  95 00                        sta 0,x
001FF1r 3  B9 03 00                     lda 0003,y
001FF4r 3  95 01                        sta 1,x
001FF6r 3               
001FF6r 3  60           z_pick:         rts
001FF7r 3               
001FF7r 3               
001FF7r 3               
001FF7r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
001FF7r 3               ; ## "+"  auto  ANS core
001FF7r 3                       ; """https://forth-standard.org/standard/core/Plus"""
001FF7r 3               xt_plus:
001FF7r 3  20 rr rr                     jsr underflow_2
001FFAr 3               
001FFAr 3  18                           clc
001FFBr 3  B5 00                        lda 0,x         ; LSB
001FFDr 3  75 02                        adc 2,x
001FFFr 3  95 02                        sta 2,x
002001r 3               
002001r 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
002003r 3  75 03                        adc 3,x
002005r 3  95 03                        sta 3,x
002007r 3               
002007r 3  E8                           inx
002008r 3  E8                           inx
002009r 3               
002009r 3  60           z_plus:         rts
00200Ar 3               
00200Ar 3               
00200Ar 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
00200Ar 3               ; ## "+!"  auto  ANS core
00200Ar 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
00200Ar 3               xt_plus_store:
00200Ar 3  20 rr rr                     jsr underflow_2
00200Dr 3               
00200Dr 3                               ; move address to tmp1 so we can work with it
00200Dr 3  B5 00                        lda 0,x
00200Fr 3  85 rr                        sta tmp1
002011r 3  B5 01                        lda 1,x
002013r 3  85 rr                        sta tmp1+1
002015r 3               
002015r 3  A0 00                        ldy #0          ; LSB
002017r 3  B1 rr                        lda (tmp1),y
002019r 3  18                           clc
00201Ar 3  75 02                        adc 2,x
00201Cr 3  91 rr                        sta (tmp1),y
00201Er 3               
00201Er 3  C8                           iny             ; MSB
00201Fr 3  B1 rr                        lda (tmp1),y
002021r 3  75 03                        adc 3,x
002023r 3  91 rr                        sta (tmp1),y
002025r 3               
002025r 3  E8                           inx
002026r 3  E8                           inx
002027r 3  E8                           inx
002028r 3  E8                           inx
002029r 3               
002029r 3  60           z_plus_store:   rts
00202Ar 3               
00202Ar 3               
00202Ar 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
00202Ar 3               ; ## "postpone"  auto   ANS core
00202Ar 3                       ; """https://forth-standard.org/standard/core/POSTPONE
00202Ar 3                       ; Add the compilation behavior of a word to a new word at
00202Ar 3                       ; compile time. If the word that follows it is immediate, include
00202Ar 3                       ; it so that it will be compiled when the word being defined is
00202Ar 3                       ; itself used for a new word. Tricky, but very useful.
00202Ar 3                       ;
00202Ar 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
00202Ar 3                       ; on the Data Stack). This means we cannot build words with
00202Ar 3                       ; "jsr xt_postpone, jsr <word>" directly.
00202Ar 3                       ; """
00202Ar 3               
00202Ar 3               xt_postpone:
00202Ar 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
00202Dr 3               
00202Dr 3                               ; if there was no word provided, complain and quit
00202Dr 3  B5 00                        lda 0,x
00202Fr 3  15 01                        ora 1,x
002031r 3  D0 05                        bne @1
002033r 3               
002033r 3  A9 05                        lda #err_noname
002035r 3  4C rr rr                     jmp error
002038r 3               @1:
002038r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
00203Br 3               
00203Br 3                               ; if word not in Dictionary, complain and quit
00203Br 3  D0 05                        bne @2
00203Dr 3  A9 05                        lda #err_noname
00203Fr 3  4C rr rr                     jmp error
002042r 3               
002042r 3               @2:
002042r 3                               ; keep a copy of nt for later
002042r 3  B5 00                        lda 0,x
002044r 3  85 rr                        sta tmp1
002046r 3  B5 01                        lda 1,x
002048r 3  85 rr                        sta tmp1+1
00204Ar 3               
00204Ar 3                               ; We need the xt instead of the nt
00204Ar 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
00204Dr 3               
00204Dr 3                               ; See if this is an immediate word. This is easier
00204Dr 3                               ; with nt than with xt. The status byte of the word
00204Dr 3                               ; is nt+1
00204Dr 3  E6 rr                        inc tmp1
00204Fr 3  D0 02                        bne @3
002051r 3  E6 rr                        inc tmp1+1
002053r 3               @3:
002053r 3  B2 rr                        lda (tmp1)
002055r 3  29 04                        and #IM         ; mask all but Intermediate flag
002057r 3  F0 05                        beq @not_immediate
002059r 3               
002059r 3                               ; We're immediate, so instead of executing it right now, we
002059r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
002059r 3                               ; takes us back to the original caller
002059r 3  20 rr rr                     jsr xt_compile_comma
00205Cr 3  80 0A                        bra @done
00205Er 3               
00205Er 3               @not_immediate:
00205Er 3                               ; This is not an immediate word, so we enact "deferred
00205Er 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
00205Er 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
00205Er 3                               ; a subroutine jump to COMPILE,
00205Er 3  20 rr rr                     jsr xt_literal
002061r 3               
002061r 3                               ; Last, compile COMPILE,
002061r 3  A0 rr                        ldy #>xt_compile_comma
002063r 3  A9 rr                        lda #<xt_compile_comma
002065r 3  20 rr rr                     jsr cmpl_subroutine
002068r 3               @done:
002068r 3  60           z_postpone:     rts
002069r 3               
002069r 3               
002069r 3               
002069r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
002069r 3               ; ## "previous"  auto  ANS search ext
002069r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
002069r 3               
002069r 3               xt_previous:
002069r 3  20 rr rr                     jsr xt_get_order
00206Cr 3  20 rr rr                     jsr xt_nip
00206Fr 3  20 rr rr                     jsr xt_one_minus
002072r 3  20 rr rr                     jsr xt_set_order
002075r 3               
002075r 3  60           z_previous:     rts
002076r 3               
002076r 3               
002076r 3               
002076r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
002076r 3               ; ## "?"  tested  ANS tools
002076r 3                       ; """https://forth-standard.org/standard/tools/q
002076r 3                       ;
002076r 3                       ; Only used interactively. Since humans are so slow, we
002076r 3                       ; save size and just go for the subroutine jumps
002076r 3                       ; """
002076r 3               xt_question:
002076r 3                               ; FETCH takes care of underflow check
002076r 3  20 rr rr                     jsr xt_fetch
002079r 3  20 rr rr                     jsr xt_dot
00207Cr 3               
00207Cr 3  60           z_question:     rts
00207Dr 3               
00207Dr 3               
00207Dr 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
00207Dr 3               ; ## "?dup"  auto  ANS core
00207Dr 3                       ; """https://forth-standard.org/standard/core/qDUP"""
00207Dr 3               
00207Dr 3               xt_question_dup:
00207Dr 3  20 rr rr                     jsr underflow_1
002080r 3               
002080r 3                               ; Check if TOS is zero
002080r 3  B5 00                        lda 0,x
002082r 3  15 01                        ora 1,x
002084r 3  F0 0A                        beq @done
002086r 3               
002086r 3                               ; not zero, duplicate
002086r 3  CA                           dex
002087r 3  CA                           dex
002088r 3  B5 02                        lda 2,x
00208Ar 3  95 00                        sta 0,x
00208Cr 3  B5 03                        lda 3,x
00208Er 3  95 01                        sta 1,x
002090r 3               @done:
002090r 3  60           z_question_dup: rts
002091r 3               
002091r 3               
002091r 3               
002091r 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
002091r 3               ; ## "r@"  auto  ANS core
002091r 3                       ; """https://forth-standard.org/standard/core/RFetch
002091r 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
002091r 3                       ; work normally as well
002091r 3                       ;
002091r 3                       ; An alternative way to write this word
002091r 3                       ; would be to access the elements on the stack directly like 2R@
002091r 3                       ; does, these versions should be compared at some point.
002091r 3                       ; """
002091r 3               xt_r_fetch:
002091r 3                               ; get the return address
002091r 3  7A                           ply             ; LSB
002092r 3  84 rr                        sty tmp1
002094r 3  7A                           ply             ; MSB
002095r 3               
002095r 3                               ; --- CUT FOR NATIVE COMPILE ---
002095r 3               
002095r 3                               ; get the actual top of Return Stack
002095r 3  CA                           dex
002096r 3  CA                           dex
002097r 3               
002097r 3  68                           pla             ; LSB
002098r 3  95 00                        sta 0,x
00209Ar 3  68                           pla             ; MSB
00209Br 3  95 01                        sta 1,x
00209Dr 3               
00209Dr 3                               ; now we have to put that value back
00209Dr 3  48                           pha
00209Er 3  B5 00                        lda 0,x
0020A0r 3  48                           pha
0020A1r 3               
0020A1r 3                               ; --- CUT FOR NATIVE COMPILE ---
0020A1r 3               
0020A1r 3                               ; restore return value
0020A1r 3  5A                           phy             ; MSB
0020A2r 3  A4 rr                        ldy tmp1
0020A4r 3  5A                           phy             ; LSB
0020A5r 3               
0020A5r 3  60           z_r_fetch:      rts
0020A6r 3               
0020A6r 3               
0020A6r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
0020A6r 3               ; ## "r>"  auto  ANS core
0020A6r 3                       ; """https://forth-standard.org/standard/core/Rfrom
0020A6r 3                       ; Move Top of Return Stack to Top of Data Stack.
0020A6r 3                       ;
0020A6r 3                       ; We have to move
0020A6r 3                       ; the RTS address out of the way first. This word is handled
0020A6r 3                       ; differently for native and and subroutine compilation, see COMPILE,
0020A6r 3                       ; This is a compile-only word
0020A6r 3                       ; """
0020A6r 3               
0020A6r 3               xt_r_from:
0020A6r 3                               ; Rescue the address of the return jump that is currently
0020A6r 3                               ; on top of the Return Stack. If this word is natively
0020A6r 3                               ; compiled, this is a total waste of time
0020A6r 3  68                           pla             ; LSB
0020A7r 3  85 rr                        sta tmptos
0020A9r 3  7A                           ply             ; MSB
0020AAr 3               
0020AAr 3                               ; --- CUT FOR NATIVE CODING ---
0020AAr 3               
0020AAr 3  CA                           dex
0020ABr 3  CA                           dex
0020ACr 3               
0020ACr 3                               ; now we can access the actual data
0020ACr 3               
0020ACr 3  68                           pla             ; LSB
0020ADr 3  95 00                        sta 0,x
0020AFr 3  68                           pla             ; MSB
0020B0r 3  95 01                        sta 1,x
0020B2r 3               
0020B2r 3                               ; --- CUT FOR NATIVE CODING ---
0020B2r 3               
0020B2r 3                               ; restore the return address
0020B2r 3  5A                           phy             ; MSB
0020B3r 3  A5 rr                        lda tmptos
0020B5r 3  48                           pha             ; LSB
0020B6r 3               
0020B6r 3  60           z_r_from:       rts
0020B7r 3               
0020B7r 3               
0020B7r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
0020B7r 3               ; ## "r>input"  tested  Tali Forth
0020B7r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
0020B7r 3                       ; and toin from the Return Stack.
0020B7r 3                       ;
0020B7r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
0020B7r 3                       ; """
0020B7r 3               
0020B7r 3               xt_r_to_input:
0020B7r 3               
0020B7r 3                               ; We arrive here with the return address on the top of the
0020B7r 3                               ; 65c02's stack. We need to move it out of the way first
0020B7r 3  68                           pla
0020B8r 3  85 rr                        sta tmp1
0020BAr 3  68                           pla
0020BBr 3  85 rr                        sta tmp1+1
0020BDr 3               
0020BDr 3                               ; This assumes that insrc is the first of eight bytes and
0020BDr 3                               ; toin+1 the last in the sequence we want to save from the Zero
0020BDr 3                               ; Page. Since we went in reverse order, insrc is now on the top
0020BDr 3                               ; of the Return Stack.
0020BDr 3  A0 00                        ldy #0
0020BFr 3               @loop:
0020BFr 3  68                           pla
0020C0r 3  99 rr rr                     sta insrc,y
0020C3r 3  C8                           iny
0020C4r 3  C0 08                        cpy #8
0020C6r 3  D0 F7                        bne @loop
0020C8r 3               
0020C8r 3                               ; Restore address for return jump
0020C8r 3  A5 rr                        lda tmp1+1
0020CAr 3  48                           pha
0020CBr 3  A5 rr                        lda tmp1
0020CDr 3  48                           pha
0020CEr 3               
0020CEr 3  60           z_r_to_input: 	rts
0020CFr 3               
0020CFr 3               
0020CFr 3               
0020CFr 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
0020CFr 3               ; ## "recurse"  auto  ANS core
0020CFr 3                       ; """https://forth-standard.org/standard/core/RECURSE
0020CFr 3                       ;
0020CFr 3                       ; This word may not be natively compiled
0020CFr 3                       ; """
0020CFr 3               
0020CFr 3               xt_recurse:
0020CFr 3                               ; The whole routine amounts to compiling a reference to
0020CFr 3                               ; the word that is being compiled. First, we save the JSR
0020CFr 3                               ; instruction
0020CFr 3  A0 00                        ldy #0
0020D1r 3               
0020D1r 3  A9 20                        lda #$20        ; opcode for JSR
0020D3r 3  91 rr                        sta (cp),y
0020D5r 3  C8                           iny
0020D6r 3               
0020D6r 3                               ; Next, we save the LSB and MSB of the xt of the word
0020D6r 3                               ; we are currently working on. We first need to see if
0020D6r 3                               ; WORKWORD has the nt (: started the word) or the
0020D6r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
0020D6r 3  24 rr                        bit status
0020D8r 3  70 0C                        bvs @nt_in_workword
0020DAr 3               
0020DAr 3                               ; This is a special :NONAME word. Just copy the xt
0020DAr 3                               ; from WORKWORD into the dictionary.
0020DAr 3  A5 rr                        lda workword
0020DCr 3  91 rr                        sta (cp),y
0020DEr 3  C8                           iny
0020DFr 3  A5 rr                        lda workword+1
0020E1r 3  91 rr                        sta (cp),y
0020E3r 3  C8                           iny
0020E4r 3  80 1B                        bra @update_cp
0020E6r 3               
0020E6r 3               @nt_in_workword:
0020E6r 3                               ; This is a regular : word, so the xt is four bytes down
0020E6r 3                               ; from the nt which we saved in WORKWORD. We could probably
0020E6r 3                               ; use NAME>INT here but this is going to be faster, and
0020E6r 3                               ; fast counts with recursion
0020E6r 3  A5 rr                        lda workword            ; LSB
0020E8r 3  18                           clc
0020E9r 3  69 04                        adc #4
0020EBr 3  85 rr                        sta tmp1
0020EDr 3  A5 rr                        lda workword+1          ; MSB
0020EFr 3  69 00                        adc #0
0020F1r 3  85 rr                        sta tmp1+1
0020F3r 3               
0020F3r 3  B2 rr                        lda (tmp1)
0020F5r 3  91 rr                        sta (cp),y
0020F7r 3  5A                           phy
0020F8r 3  A0 01                        ldy #1
0020FAr 3  B1 rr                        lda (tmp1),y
0020FCr 3  7A                           ply
0020FDr 3  C8                           iny
0020FEr 3  91 rr                        sta (cp),y
002100r 3  C8                           iny
002101r 3               
002101r 3               @update_cp:
002101r 3  98                           tya
002102r 3  18                           clc
002103r 3  65 rr                        adc cp
002105r 3  85 rr                        sta cp
002107r 3  90 02                        bcc @done
002109r 3  E6 rr                        inc cp+1
00210Br 3               @done:
00210Br 3  60           z_recurse:      rts
00210Cr 3               
00210Cr 3               
00210Cr 3               
00210Cr 3               ; ## REFILL ( -- f ) "Refill the input buffer"
00210Cr 3               ; ## "refill"  tested  ANS core ext
00210Cr 3                       ; """https://forth-standard.org/standard/core/REFILL
00210Cr 3                       ; Attempt to fill the input buffer from the input source, returning
00210Cr 3                       ; a true flag if successful. When the input source is the user input
00210Cr 3                       ; device, attempt to receive input into the terminal input buffer. If
00210Cr 3                       ; successful, make the result the input buffer, set >IN to zero, and
00210Cr 3                       ; return true. Receipt of a line containing no characters is considered
00210Cr 3                       ; successful. If there is no input available from the current input
00210Cr 3                       ; source, return false. When the input source is a string from EVALUATE,
00210Cr 3                       ; return false and perform no other action." See
00210Cr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
00210Cr 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
00210Cr 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
00210Cr 3                       ; entire block as a 1024 byte string.
00210Cr 3                       ; """"
00210Cr 3               
00210Cr 3               xt_refill:
00210Cr 3                               ; Get input source from SOURCE-ID. This is an
00210Cr 3                               ; optimized version of a subroutine jump to SOURCE-ID
00210Cr 3  A5 rr                        lda insrc               ; cheat: We only check LSB
00210Er 3  D0 2D                        bne @src_not_kbd
002110r 3               
002110r 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
002110r 3                               ; with ACCEPT, which wants the address of the current input
002110r 3                               ; buffer NOS and the max number of characters to accept TOS
002110r 3  CA                           dex
002111r 3  CA                           dex
002112r 3  CA                           dex
002113r 3  CA                           dex
002114r 3               
002114r 3  A5 rr                        lda cib                 ; address of CIB is NOS
002116r 3  95 02                        sta 2,x
002118r 3  A5 rr                        lda cib+1
00211Ar 3  95 03                        sta 3,x
00211Cr 3               
00211Cr 3  64 rr                        stz ciblen              ; go in with empty buffer
00211Er 3  64 rr                        stz ciblen+1
002120r 3               
002120r 3  A9 FF                        lda #bsize              ; max number of chars is TOS
002122r 3  95 00                        sta 0,x
002124r 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
002126r 3               
002126r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
002129r 3               
002129r 3                               ; ACCEPT returns the number of characters accepted, which
002129r 3                               ; belong in CIBLEN
002129r 3  B5 00                        lda 0,x
00212Br 3  85 rr                        sta ciblen
00212Dr 3  B5 01                        lda 1,x
00212Fr 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
002131r 3               
002131r 3                               ; make >IN point to beginning of buffer
002131r 3  64 rr                        stz toin
002133r 3  64 rr                        stz toin+1
002135r 3               
002135r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
002137r 3  95 00                        sta 0,x
002139r 3  95 01                        sta 1,x
00213Br 3               
00213Br 3  80 10                        bra @done
00213Dr 3               
00213Dr 3               @src_not_kbd:
00213Dr 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
00213Dr 3                               ; memory or a file (remember, no blocks in this version).
00213Dr 3                               ; If source is a string, we were given the flag -1 ($FFFF)
00213Dr 3  1A                           inc
00213Er 3  D0 08                        bne @src_not_string
002140r 3               
002140r 3                               ; Simply return FALSE flag as per specification
002140r 3  CA                           dex
002141r 3  CA                           dex
002142r 3  74 00                        stz 0,x
002144r 3  74 01                        stz 1,x
002146r 3               
002146r 3  80 05                        bra z_refill
002148r 3               
002148r 3               @src_not_string:
002148r 3                               ; Since we don't have blocks, this must mean that we are trying
002148r 3                               ; to read from a file. However, we don't have files yet, so we
002148r 3                               ; report an error and jump to ABORT.
002148r 3  A9 01                        lda #err_badsource
00214Ar 3  4C rr rr                     jmp error
00214Dr 3               @done:
00214Dr 3  60           z_refill:       rts
00214Er 3               
00214Er 3               
00214Er 3               
00214Er 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
00214Er 3               ; ## "repeat"  auto  ANS core
00214Er 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
00214Er 3               
00214Er 3               xt_repeat:
00214Er 3                               ; Run again first
00214Er 3  20 rr rr                     jsr xt_again
002151r 3               
002151r 3                               ; Stuff HERE in for the branch address
002151r 3                               ; to get out of the loop
002151r 3  20 rr rr                     jsr xt_here
002154r 3  20 rr rr                     jsr xt_swap
002157r 3  20 rr rr                     jsr xt_store
00215Ar 3               
00215Ar 3  60           z_repeat:       rts
00215Br 3               
00215Br 3               
00215Br 3               
00215Br 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
00215Br 3               ; ## "]"  auto  ANS core
00215Br 3                       ; """https://forth-standard.org/standard/right-bracket
00215Br 3                       ; This is an immediate word.
00215Br 3                       ; """
00215Br 3               xt_right_bracket:
00215Br 3  A9 FF                        lda #$FF
00215Dr 3  85 rr                        sta state
00215Fr 3  85 rr                        sta state+1
002161r 3               z_right_bracket:
002161r 3  60                           rts
002162r 3               
002162r 3               
002162r 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
002162r 3               ; ## "root-wordlist"  tested  Tali Editor
002162r 3               xt_root_wordlist:
002162r 3  CA                           dex             ; The WID for the Root wordlist is 3.
002163r 3  CA                           dex
002164r 3  A9 03                        lda #3
002166r 3  95 00                        sta 0,x
002168r 3  74 01                        stz 1,x
00216Ar 3               
00216Ar 3               z_root_wordlist:
00216Ar 3  60                           rts
00216Br 3               
00216Br 3               
00216Br 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
00216Br 3               ; ## "rot"  auto  ANS core
00216Br 3                       ; """https://forth-standard.org/standard/core/ROT
00216Br 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
00216Br 3                       ; on top!
00216Br 3                       ; """
00216Br 3               
00216Br 3               xt_rot:
00216Br 3  20 rr rr                     jsr underflow_3
00216Er 3               
00216Er 3  B4 05                        ldy 5,x         ; MSB first
002170r 3  B5 03                        lda 3,x
002172r 3  95 05                        sta 5,x
002174r 3  B5 01                        lda 1,x
002176r 3  95 03                        sta 3,x
002178r 3  94 01                        sty 1,x
00217Ar 3               
00217Ar 3  B4 04                        ldy 4,x         ; LSB next
00217Cr 3  B5 02                        lda 2,x
00217Er 3  95 04                        sta 4,x
002180r 3  B5 00                        lda 0,x
002182r 3  95 02                        sta 2,x
002184r 3  94 00                        sty 0,x
002186r 3               
002186r 3  60           z_rot:          rts
002187r 3               
002187r 3               
002187r 3               
002187r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
002187r 3               ; ## "rshift"  auto  ANS core
002187r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
002187r 3               xt_rshift:
002187r 3  20 rr rr                     jsr underflow_2
00218Ar 3               
00218Ar 3                               ; We shift maximal by 16 bits, mask everything else
00218Ar 3  B5 00                        lda 0,x
00218Cr 3  29 0F                        and #%00001111
00218Er 3  F0 08                        beq @done               ; if 0 shifts, quit
002190r 3               
002190r 3  A8                           tay
002191r 3               @loop:
002191r 3  56 03                        lsr 3,x
002193r 3  76 02                        ror 2,x
002195r 3  88                           dey
002196r 3  D0 F9                        bne @loop
002198r 3               @done:
002198r 3  E8                           inx
002199r 3  E8                           inx
00219Ar 3               
00219Ar 3  60           z_rshift:       rts
00219Br 3               
00219Br 3               
00219Br 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
00219Br 3               ; ## "s\""  auto  ANS core
00219Br 3                       ; """https://forth-standard.org/standard/core/Seq
00219Br 3                       ; Store address and length of string given, returning ( addr u ).
00219Br 3                       ; ANS core claims this is compile-only, but the file set expands it
00219Br 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
00219Br 3                       ; are evil. We follow general usage. This is just like S" except
00219Br 3                       ; that it allows for some special escaped characters.
00219Br 3                       ; """
00219Br 3               
00219Br 3               xt_s_backslash_quote:
00219Br 3                               ; tmp2 will be used to determine if we are handling
00219Br 3                               ; escaped characters or not. In this case, we are,
00219Br 3                               ; so set it to $FF (the upper byte will be used to
00219Br 3                               ; determine if we just had a \ and the next character
00219Br 3                               ; needs to be modifed as an escaped character).
00219Br 3  A9 FF                        lda #$FF
00219Dr 3  85 rr                        sta tmp2
00219Fr 3  64 rr                        stz tmp2+1
0021A1r 3               
0021A1r 3                               ; Now that the flag is set, jump into s_quote to process
0021A1r 3                               ; the string.
0021A1r 3  20 rr rr                     jsr s_quote_start
0021A4r 3               @done:
0021A4r 3               z_s_backslash_quote:
0021A4r 3  60                           rts
0021A5r 3               
0021A5r 3               
0021A5r 3               ; This is a helper function for s_backslash_quote to convert a character
0021A5r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
0021A5r 3               convert_hex_value:
0021A5r 3               
0021A5r 3  C9 41                cmp #'A'
0021A7r 3  90 07                bcc @digit
0021A9r 3               
0021A9r 3                       ; It's A-F
0021A9r 3  29 DF                and #$DF                ; Make it uppercase.
0021ABr 3  38                   sec
0021ACr 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
0021AEr 3  80 03                bra @done
0021B0r 3               
0021B0r 3               @digit:
0021B0r 3                       ; It's 0-9
0021B0r 3  38                   sec
0021B1r 3  E9 30                sbc #'0'
0021B3r 3               
0021B3r 3               @done:
0021B3r 3  60                   rts
0021B4r 3               
0021B4r 3               
0021B4r 3               
0021B4r 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
0021B4r 3               ; ## "search-wordlist" auto ANS search
0021B4r 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
0021B4r 3               
0021B4r 3               xt_search_wordlist:
0021B4r 3  20 rr rr                     jsr underflow_3
0021B7r 3               
0021B7r 3                               ; Set up tmp1 with the wordlist indicated by wid
0021B7r 3                               ; on the stack. Start by putting the base address
0021B7r 3                               ; of the wordlists in tmp2.
0021B7r 3  A5 rr                        lda up
0021B9r 3  18                           clc
0021BAr 3  69 06                        adc #wordlists_offset
0021BCr 3  85 rr                        sta tmp2
0021BEr 3  A5 rr                        lda up+1
0021C0r 3  69 00                        adc #0          ; Adding carry
0021C2r 3  85 rr                        sta tmp2+1
0021C4r 3               
0021C4r 3                               ; Add the wid (in cells) to the base address.
0021C4r 3  B5 00                        lda 0,x
0021C6r 3  0A                           asl             ; Convert wid to offset in cells (x2)
0021C7r 3  65 rr                        adc tmp2
0021C9r 3  85 rr                        sta tmp2
0021CBr 3  90 02                        bcc @1
0021CDr 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
0021CFr 3               
0021CFr 3                               ; tmp2 now holds the address of the dictionary pointer
0021CFr 3                               ; for the given wordlist.
0021CFr 3               @1:
0021CFr 3                               ; Remove the wid from the stack.
0021CFr 3  E8                           inx
0021D0r 3  E8                           inx
0021D1r 3               
0021D1r 3                               ; check for special case of an empty string (length zero)
0021D1r 3  B5 00                        lda 0,x
0021D3r 3  15 01                        ora 1,x
0021D5r 3  D0 03                        bne @check_wordlist
0021D7r 3  4C rr rr                     jmp @done
0021DAr 3               
0021DAr 3               @check_wordlist:
0021DAr 3                               ; Check for special case of empty wordlist
0021DAr 3                               ; (dictionary pointer, in tmp2, is 0)
0021DAr 3  A5 rr                        lda tmp2
0021DCr 3  05 rr                        ora tmp2+1
0021DEr 3  D0 03                        bne @have_string
0021E0r 3  4C rr rr                     jmp @done
0021E3r 3               
0021E3r 3               @have_string:
0021E3r 3                               ; set up first loop iteration
0021E3r 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
0021E5r 3  85 rr                        sta tmp1
0021E7r 3               
0021E7r 3  E6 rr                        inc tmp2                ; Move to the upper byte
0021E9r 3  D0 02                        bne @2
0021EBr 3  E6 rr                        inc tmp2+1
0021EDr 3               @2:
0021EDr 3  B2 rr                        lda (tmp2)
0021EFr 3  85 rr                        sta tmp1+1
0021F1r 3               
0021F1r 3                               ; Reuse tmp2 to hold the address of the mystery string.
0021F1r 3  B5 02                        lda 2,x                 ; Address of mystery string
0021F3r 3  85 rr                        sta tmp2
0021F5r 3  B5 03                        lda 3,x
0021F7r 3  85 rr                        sta tmp2+1
0021F9r 3               
0021F9r 3               @loop:
0021F9r 3                               ; first quick test: Are strings the same length?
0021F9r 3  B2 rr                        lda (tmp1)
0021FBr 3  D5 00                        cmp 0,x
0021FDr 3  D0 7B                        bne @next_entry
0021FFr 3               
0021FFr 3               @compare_string:
0021FFr 3                               ; are the same length, so we now have to compare each
0021FFr 3                               ; character
0021FFr 3               
0021FFr 3                               ; second quick test: Is the first character the same?
0021FFr 3  B2 rr                        lda (tmp2)      ; first character of mystery string
002201r 3               
002201r 3                               ; Lowercase the incoming charcter.
002201r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
002203r 3  B0 07                        bcs @compare_first
002205r 3  C9 41                        cmp #$41        ; ASCII 'A'
002207r 3  90 03                        bcc @compare_first
002209r 3               
002209r 3                               ; An uppercase letter has been located.  Make it
002209r 3                               ; lowercase.
002209r 3  18                           clc
00220Ar 3  69 20                        adc #$20
00220Cr 3               
00220Cr 3               @compare_first:
00220Cr 3  A0 08                        ldy #8          ; Offset in nt to name
00220Er 3  D1 rr                        cmp (tmp1),y    ; first character of current word
002210r 3  D0 68                        bne @next_entry
002212r 3               
002212r 3                               ; string length are the same and the first character is the
002212r 3                               ; same. If the length of the string is 1, we're already done
002212r 3  B5 00                        lda 0,x
002214r 3  3A                           dec
002215r 3  F0 2C                        beq @success
002217r 3               
002217r 3                               ; No such luck: The strings are the same length and the first
002217r 3                               ; char is the same, but the word is more than one char long.
002217r 3                               ; So we suck it up and compare every single character. We go
002217r 3                               ; from back to front, because words like CELLS and CELL+ would
002217r 3                               ; take longer otherwise. We can also shorten the loop by one
002217r 3                               ; because we've already compared the first char.
002217r 3               
002217r 3                               ; The string of the word we're testing against is 8 bytes down
002217r 3  A5 rr                        lda tmp1
002219r 3  48                           pha             ; Preserve tmp1 on the return stack.
00221Ar 3  18                           clc
00221Br 3  69 08                        adc #8
00221Dr 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
00221Fr 3  A5 rr                        lda tmp1+1
002221r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
002222r 3  69 00                        adc #0          ; we only need the carry
002224r 3  85 rr                        sta tmp1+1
002226r 3               
002226r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
002228r 3  88                           dey
002229r 3               
002229r 3               @string_loop:
002229r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
00222Br 3               
00222Br 3                               ; Lowercase the incoming charcter.
00222Br 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
00222Dr 3  B0 07                        bcs @check_char
00222Fr 3  C9 41                        cmp #$41        ; ASCII 'A'
002231r 3  90 03                        bcc @check_char
002233r 3               
002233r 3                               ; An uppercase letter has been located.  Make it
002233r 3                               ; lowercase.
002233r 3  18                           clc
002234r 3  69 20                        adc #$20
002236r 3               @check_char:
002236r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
002238r 3  D0 3A                        bne @next_entry_tmp1
00223Ar 3               
00223Ar 3  88                           dey
00223Br 3  D0 EC                        bne @string_loop
00223Dr 3               
00223Dr 3               @success_tmp1:
00223Dr 3  68                           pla             ; Restore tmp1 from the return stack.
00223Er 3  85 rr                        sta tmp1+1
002240r 3  68                           pla
002241r 3  85 rr                        sta tmp1
002243r 3               
002243r 3               @success:
002243r 3                               ; The strings match. Drop the count and put correct nt TOS
002243r 3  E8                           inx
002244r 3  E8                           inx
002245r 3  A5 rr                        lda tmp1
002247r 3  95 00                        sta 0,x
002249r 3  A5 rr                        lda tmp1+1
00224Br 3  95 01                        sta 1,x
00224Dr 3               
00224Dr 3                               ; Change the nt into an xt, but save a copy of the nt
00224Dr 3                               ; to look up whether the word is immediate or not.
00224Dr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002250r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
002253r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
002256r 3               
002256r 3  A0 00                        ldy #0                  ; Prepare flag
002258r 3               
002258r 3                               ; The flags are in the second byte of the header
002258r 3  F6 00                        inc 0,x
00225Ar 3  D0 02                        bne @3
00225Cr 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
00225Er 3               @3:
00225Er 3  A1 00                        lda (0,x)               ; ( xt char )
002260r 3  29 04                        and #IM
002262r 3  D0 08                        bne @immediate          ; bit set, we're immediate
002264r 3               
002264r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
002266r 3  95 00                        sta 0,x
002268r 3  95 01                        sta 1,x
00226Ar 3  80 28                        bra @done_nodrop
00226Cr 3               
00226Cr 3               @immediate:
00226Cr 3  A9 01                        lda #1                  ; We're immediate, return 1
00226Er 3  95 00                        sta 0,x
002270r 3  74 01                        stz 1,x
002272r 3               
002272r 3  80 20                        bra @done_nodrop
002274r 3               
002274r 3               @next_entry_tmp1:
002274r 3  68                           pla             ; Restore tmp1 from the return stack.
002275r 3  85 rr                        sta tmp1+1
002277r 3  68                           pla
002278r 3  85 rr                        sta tmp1
00227Ar 3               @next_entry:
00227Ar 3                               ; Not the same, so we get the next word. Next header
00227Ar 3                               ; address is two bytes down
00227Ar 3  A0 02                        ldy #2
00227Cr 3  B1 rr                        lda (tmp1),y
00227Er 3  48                           pha
00227Fr 3  C8                           iny
002280r 3  B1 rr                        lda (tmp1),y
002282r 3  85 rr                        sta tmp1+1
002284r 3  68                           pla
002285r 3  85 rr                        sta tmp1
002287r 3               
002287r 3                               ; If we got a zero, we've walked the whole Dictionary and
002287r 3                               ; return as a failure, otherwise try again
002287r 3  05 rr                        ora tmp1+1
002289r 3  F0 03                        beq @fail_done
00228Br 3  4C rr rr                     jmp @loop
00228Er 3               
00228Er 3               @fail_done:
00228Er 3  74 02                        stz 2,x         ; failure flag
002290r 3  74 03                        stz 3,x
002292r 3               @done:
002292r 3  E8                           inx
002293r 3  E8                           inx
002294r 3               @done_nodrop:
002294r 3               z_search_wordlist:
002294r 3  60                           rts
002295r 3               
002295r 3               
002295r 3               
002295r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
002295r 3               ; ## "see" tested  ANS tools
002295r 3                       ; """https://forth-standard.org/standard/tools/SEE
002295r 3                       ; SEE takes the name of a word and prints its name token (nt),
002295r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
002295r 3                       ; code and disassembles it.
002295r 3                       ; """
002295r 3               
002295r 3               xt_see:
002295r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
002298r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
00229Br 3               
00229Br 3                               ; If we got back a zero we don't know that word and so we quit
00229Br 3                               ; with an error
00229Br 3  B5 00                        lda 0,x
00229Dr 3  15 01                        ora 1,x
00229Fr 3  D0 05                        bne @1
0022A1r 3               
0022A1r 3  A9 05                        lda #err_noname
0022A3r 3  4C rr rr                     jmp error
0022A6r 3               @1:
0022A6r 3  20 rr rr                     jsr xt_cr
0022A9r 3               
0022A9r 3                               ; We have a legal word, so let's get serious. Save the current
0022A9r 3                               ; number base and use hexadecimal instead.
0022A9r 3  A5 rr                        lda base
0022ABr 3  48                           pha
0022ACr 3  20 rr rr                     jsr xt_hex
0022AFr 3               
0022AFr 3  A9 0A                        lda #str_see_nt
0022B1r 3  20 rr rr                     jsr print_string_no_lf
0022B4r 3               
0022B4r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0022B7r 3  20 rr rr                     jsr xt_u_dot
0022BAr 3  20 rr rr                     jsr xt_space            ; ( nt )
0022BDr 3               
0022BDr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0022C0r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0022C3r 3               
0022C3r 3  A9 0B                        lda #str_see_xt
0022C5r 3  20 rr rr                     jsr print_string_no_lf
0022C8r 3               
0022C8r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
0022CBr 3  20 rr rr                     jsr xt_u_dot
0022CEr 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
0022D1r 3               
0022D1r 3                               ; We print letters for flags and then later follow it with 1 or
0022D1r 3                               ; 0 to mark if which flag is set
0022D1r 3  A9 09                        lda #str_see_flags
0022D3r 3  20 rr rr                     jsr print_string_no_lf
0022D6r 3               
0022D6r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
0022D9r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
0022DCr 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
0022DFr 3               
0022DFr 3  B5 00                        lda 0,x
0022E1r 3               
0022E1r 3                               ; This is crude, but for the moment it is good enough
0022E1r 3  A0 06                        ldy #6                  ; Not all bits are used
0022E3r 3               @flag_loop:
0022E3r 3  48                           pha
0022E4r 3  29 01                        and #%00000001
0022E6r 3  18                           clc
0022E7r 3  69 30                        adc #$30                ; ASCII "0"
0022E9r 3  20 rr rr                     jsr emit_a
0022ECr 3  20 rr rr                     jsr xt_space
0022EFr 3               
0022EFr 3  68                           pla
0022F0r 3  6A                           ror                     ; Next flag
0022F1r 3               
0022F1r 3  88                           dey
0022F2r 3  D0 EF                        bne @flag_loop
0022F4r 3               
0022F4r 3  20 rr rr                     jsr xt_cr
0022F7r 3               
0022F7r 3  E8                           inx
0022F8r 3  E8                           inx                     ; ( nt xt )
0022F9r 3               
0022F9r 3                               ; Figure out the size
0022F9r 3  A9 0C                        lda #str_see_size
0022FBr 3  20 rr rr                     jsr print_string_no_lf
0022FEr 3               
0022FEr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
002301r 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
002304r 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
002307r 3  20 rr rr                     jsr xt_decimal
00230Ar 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
00230Dr 3  20 rr rr                     jsr xt_hex
002310r 3  20 rr rr                     jsr xt_cr
002313r 3               
002313r 3                               ; Dump hex and disassemble
002313r 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
002316r 3  20 rr rr                     jsr xt_dump
002319r 3  20 rr rr                     jsr xt_cr
00231Cr 3  20 rr rr                     jsr xt_disasm
00231Fr 3               
00231Fr 3  68                           pla
002320r 3  85 rr                        sta base
002322r 3               
002322r 3  60           z_see:          rts
002323r 3               
002323r 3               
002323r 3               
002323r 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
002323r 3               ; ## "set-current" auto ANS search
002323r 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
002323r 3               
002323r 3               xt_set_current:
002323r 3  20 rr rr                     jsr underflow_1
002326r 3               
002326r 3                               ; Save the value from the data stack.
002326r 3  A0 04                        ldy #current_offset
002328r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
00232Ar 3  91 rr                        sta (up),y      ; so only the LSB is used.
00232Cr 3               
00232Cr 3  E8                           inx
00232Dr 3  E8                           inx
00232Er 3               
00232Er 3  60           z_set_current:  rts
00232Fr 3               
00232Fr 3               
00232Fr 3               
00232Fr 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
00232Fr 3               ; ## "set-order" auto ANS search
00232Fr 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
00232Fr 3               
00232Fr 3               xt_set_order:
00232Fr 3                               ; Test for -1 TOS
00232Fr 3  A9 FF                        lda #$FF
002331r 3  D5 01                        cmp 1,x
002333r 3  D0 12                        bne @start
002335r 3  D5 00                        cmp 0,x
002337r 3  D0 0E                        bne @start
002339r 3               
002339r 3                               ; There is a -1 TOS.  Replace it with the default
002339r 3                               ; search order, which is just the FORTH-WORDLIST.
002339r 3  CA                           dex             ; Make room for the count.
00233Ar 3  CA                           dex
00233Br 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
00233Dr 3  A9 03                        lda #3
00233Fr 3  95 02                        sta 2,x
002341r 3  74 01                        stz 1,x         ; Count is 1.
002343r 3  A9 01                        lda #1
002345r 3  95 00                        sta 0,x
002347r 3               
002347r 3                               ; Continue processing with ( forth-wordlist 1 -- )
002347r 3               @start:
002347r 3                               ; Set #ORDER - the number of wordlists in the search order.
002347r 3  A0 1E                        ldy #num_order_offset
002349r 3  B5 00                        lda 0,x
00234Br 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
00234Dr 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
00234Fr 3                                               ; Only the low byte is saved in tmp1 as
00234Fr 3                                               ; only 8 wordlists are allowed.
00234Fr 3               
00234Fr 3  E8                           inx             ; Drop the count off the data stack.
002350r 3  E8                           inx
002351r 3               
002351r 3                               ; Check if there are zero wordlists.
002351r 3  A5 rr                        lda tmp1
002353r 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
002355r 3               
002355r 3                               ; Move the wordlist ids from the data stack to the search order.
002355r 3  A0 1F                        ldy #search_order_offset
002357r 3               @loop:
002357r 3                               ; Move one wordlist id over into the search order.
002357r 3  B5 00                        lda 0,x         ; The search order is a byte array
002359r 3  91 rr                        sta (up),y      ; so only save the LSB
00235Br 3  C8                           iny
00235Cr 3               
00235Cr 3                               ; Remove it from the data stack.
00235Cr 3  E8                           inx
00235Dr 3  E8                           inx
00235Er 3               
00235Er 3                               ; See if that was the last one to process (first in the list).
00235Er 3  C6 rr                        dec tmp1
002360r 3  D0 F5                        bne @loop
002362r 3               
002362r 3               @done:
002362r 3  60           z_set_order:    rts
002363r 3               
002363r 3               
002363r 3               
002363r 3               
002363r 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002363r 3               ; ## "s""  auto  ANS core
002363r 3                       ; """https://forth-standard.org/standard/core/Sq
002363r 3                       ; Store address and length of string given, returning ( addr u ).
002363r 3                       ; ANS core claims this is compile-only, but the file set expands it
002363r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002363r 3                       ; are evil. We follow general usage.
002363r 3                       ;
002363r 3                       ; Can also be realized as
002363r 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
002363r 3                       ; but it is used so much we want it in code.
002363r 3                       ; """
002363r 3               
002363r 3               xt_s_quote:
002363r 3                               ; tmp2 will be used to determine if we are handling
002363r 3                               ; escaped characters or not.  In this case, we are
002363r 3                               ; not, so set it to zero.
002363r 3  64 rr                        stz tmp2
002365r 3  64 rr                        stz tmp2+1
002367r 3               
002367r 3               s_quote_start:
002367r 3                               ; Make room on the data stack for the address.
002367r 3  CA                           dex
002368r 3  CA                           dex
002369r 3                               ; Make room on the data stack for the count.
002369r 3  CA                           dex
00236Ar 3  CA                           dex
00236Br 3               
00236Br 3                               ; Put a jmp over the string data with address to be filled
00236Br 3                               ; in later.
00236Br 3  A9 4C                        lda #$4C
00236Dr 3  20 rr rr                     jsr cmpl_a
002370r 3               
002370r 3                               ; Address to be filled in later, just use $4C for the moment
002370r 3  20 rr rr                     jsr cmpl_a
002373r 3  20 rr rr                     jsr cmpl_a
002376r 3               
002376r 3                               ; Save the current value of HERE on the data stack for the
002376r 3                               ; address of the string.
002376r 3  A5 rr                        lda cp
002378r 3  95 02                        sta 2,x
00237Ar 3  A5 rr                        lda cp+1
00237Cr 3  95 03                        sta 3,x
00237Er 3               
00237Er 3               @savechars_loop:
00237Er 3                               ; Start saving the string into the dictionary up to the
00237Er 3                               ; ending double quote. First, check to see if the input
00237Er 3                               ; buffer is empty.
00237Er 3  A5 rr                        lda toin+1              ; MSB
002380r 3  C5 rr                        cmp ciblen+1
002382r 3  90 2A                        bcc @input_fine         ; unsigned comparison
002384r 3               
002384r 3  A5 rr                        lda toin                ; LSB
002386r 3  C5 rr                        cmp ciblen
002388r 3  90 24                        bcc @input_fine
00238Ar 3               
00238Ar 3                               ; Input buffer is empty. Refill it. Refill calls accept,
00238Ar 3                               ; which uses tmp2 and tmp3. Save and restore them.
00238Ar 3  A5 rr                        lda tmp2
00238Cr 3  48                           pha
00238Dr 3  A5 rr                        lda tmp2+1
00238Fr 3  48                           pha
002390r 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
002392r 3  48                           pha
002393r 3               
002393r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
002396r 3               
002396r 3  68                           pla
002397r 3  85 rr                        sta tmp3
002399r 3  68                           pla
00239Ar 3  85 rr                        sta tmp2+1
00239Cr 3  68                           pla
00239Dr 3  85 rr                        sta tmp2
00239Fr 3               
00239Fr 3                               ; Check result of refill.
00239Fr 3  B5 00                        lda 0,x
0023A1r 3  15 01                        ora 1,x
0023A3r 3  D0 05                        bne @refill_ok
0023A5r 3               
0023A5r 3                               ; Something when wrong with refill.
0023A5r 3  A9 06                        lda #err_refill
0023A7r 3  4C rr rr                     jmp error
0023AAr 3               
0023AAr 3               @refill_ok:
0023AAr 3                               ; Remove the refill flag from the data stack.
0023AAr 3  E8                           inx
0023ABr 3  E8                           inx
0023ACr 3               
0023ACr 3                               ; For refill success, jump back up to the empty check, just in
0023ACr 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
0023ACr 3                               ; input)
0023ACr 3  80 D0                        bra @savechars_loop
0023AEr 3               
0023AEr 3               @input_fine:
0023AEr 3                               ; There should be at least one valid char to use.
0023AEr 3                               ; Calculate it's address at CIB+TOIN into tmp1
0023AEr 3  A5 rr                        lda cib
0023B0r 3  18                           clc
0023B1r 3  65 rr                        adc toin        ; LSB
0023B3r 3  85 rr                        sta tmp1
0023B5r 3  A5 rr                        lda cib+1
0023B7r 3  65 rr                        adc toin+1      ; MSB
0023B9r 3  85 rr                        sta tmp1+1
0023BBr 3               
0023BBr 3                               ; Get the character
0023BBr 3  B2 rr                        lda (tmp1)
0023BDr 3               
0023BDr 3                               ; Check to see if we are handling escaped characters.
0023BDr 3  24 rr                        bit tmp2
0023BFr 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
0023C1r 3  4C rr rr                     jmp @regular_char
0023C4r 3               
0023C4r 3               @handle_escapes:
0023C4r 3                               ; We are handling escaped characters.  See if we have
0023C4r 3                               ; already seen the backslash.
0023C4r 3  24 rr                        bit tmp2+1
0023C6r 3  30 03                        bmi @escaped
0023C8r 3  4C rr rr                     jmp @not_escaped
0023CBr 3               
0023CBr 3               @escaped:
0023CBr 3               
0023CBr 3                               ; We have seen a backslash (previous character). Check to see if
0023CBr 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
0023CBr 3                               ; be clear in that case )
0023CBr 3  70 22                        bvs @check_esc_chars
0023CDr 3               
0023CDr 3                               ; We are in the middle of a \x sequence. Check to see if we
0023CDr 3                               ; are on the first or second digit.
0023CDr 3  A9 01                        lda #1
0023CFr 3  24 rr                        bit tmp2+1
0023D1r 3  D0 10                        bne @esc_x_second_digit
0023D3r 3               
0023D3r 3                               ; First digit.
0023D3r 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
0023D5r 3  B2 rr                        lda (tmp1)  ; Get the char again.
0023D7r 3               
0023D7r 3                               ; Convert to hex
0023D7r 3  20 rr rr                     jsr convert_hex_value
0023DAr 3               
0023DAr 3                               ; This is the upper nybble, so move it up.
0023DAr 3  0A                           asl
0023DBr 3  0A                           asl
0023DCr 3  0A                           asl
0023DDr 3  0A                           asl
0023DEr 3  85 rr                        sta tmp3    ; Save it for later.
0023E0r 3  4C rr rr                     jmp @next_character
0023E3r 3               
0023E3r 3               @esc_x_second_digit:
0023E3r 3               
0023E3r 3                               ; We are on the second hex digit of a \x sequence. Clear the
0023E3r 3                               ; escaped character flag (because we are handling it right
0023E3r 3                               ; here)
0023E3r 3  64 rr                        stz tmp2+1
0023E5r 3  B2 rr                        lda (tmp1)
0023E7r 3               
0023E7r 3                               ; Convert to hex, combine with value in tmp3
0023E7r 3  20 rr rr                     jsr convert_hex_value
0023EAr 3  05 rr                        ora tmp3
0023ECr 3               
0023ECr 3  4C rr rr                     jmp @save_character
0023EFr 3               
0023EFr 3               @check_esc_chars:
0023EFr 3                               ; Clear the escaped character flag (because we are
0023EFr 3                               ; handling it right here)
0023EFr 3  64 rr                        stz tmp2+1
0023F1r 3               
0023F1r 3                               ; Process the escaped character
0023F1r 3               @check_esc_a:
0023F1r 3  C9 61                        cmp #'a'
0023F3r 3  D0 05                        bne @check_esc_b
0023F5r 3               
0023F5r 3                               ; BEL (ASCII value 7)
0023F5r 3  A9 07                        lda #7
0023F7r 3  4C rr rr                     jmp @save_character
0023FAr 3               
0023FAr 3               @check_esc_b:
0023FAr 3  C9 62                        cmp #'b'
0023FCr 3  D0 05                        bne @check_esc_e
0023FEr 3               
0023FEr 3                               ; Backspace (ASCII value 8)
0023FEr 3  A9 08                        lda #8
002400r 3  4C rr rr                     jmp @save_character
002403r 3               
002403r 3               @check_esc_e:
002403r 3  C9 65                        cmp #'e'
002405r 3  D0 04                        bne @check_esc_f
002407r 3               
002407r 3                               ; ESC (ASCII value 27)
002407r 3  A9 1B                        lda #27
002409r 3  80 75                        bra @save_character
00240Br 3               
00240Br 3               @check_esc_f:
00240Br 3  C9 66                        cmp #'f'
00240Dr 3  D0 04                        bne @check_esc_l
00240Fr 3               
00240Fr 3                               ; FF (ASCII value 12)
00240Fr 3  A9 0C                        lda #12
002411r 3  80 6D                        bra @save_character
002413r 3               
002413r 3               @check_esc_l:
002413r 3  C9 6C                        cmp #'l'
002415r 3  D0 04                        bne @check_esc_m
002417r 3               
002417r 3                               ; LF (ASCII value 10)
002417r 3  A9 0A                        lda #10
002419r 3  80 65                        bra @save_character
00241Br 3               
00241Br 3               @check_esc_m:
00241Br 3                               ; This one is not like the others because we save two
00241Br 3                               ; characters
00241Br 3  C9 6D                        cmp #'m'
00241Dr 3  D0 09                        bne @check_esc_n
00241Fr 3               
00241Fr 3                               ; CR/LF pair (ASCII values 13, 10)
00241Fr 3  A9 0D                        lda #13
002421r 3  20 rr rr                     jsr cmpl_a
002424r 3  A9 0A                        lda #10
002426r 3  80 58                        bra @save_character
002428r 3               
002428r 3               @check_esc_n:
002428r 3  C9 6E                        cmp #'n'
00242Ar 3  D0 04                        bne @check_esc_q
00242Cr 3               
00242Cr 3                               ; newline, impl. dependant, using LF (ASCII values 10)
00242Cr 3  A9 0A                        lda #10
00242Er 3  80 50                        bra @save_character
002430r 3               
002430r 3               @check_esc_q:
002430r 3  C9 71                        cmp #'q'
002432r 3  D0 04                        bne @check_esc_r
002434r 3               
002434r 3                               ; Double quote (ASCII value 34)
002434r 3  A9 22                        lda #34
002436r 3  80 48                        bra @save_character
002438r 3               
002438r 3               @check_esc_r:
002438r 3  C9 72                        cmp #'r'
00243Ar 3  D0 04                        bne @check_esc_t
00243Cr 3               
00243Cr 3                               ; CR (ASCII value 13)
00243Cr 3  A9 0D                        lda #13
00243Er 3  80 40                        bra @save_character
002440r 3               
002440r 3               @check_esc_t:
002440r 3  C9 74                        cmp #'t'
002442r 3  D0 04                        bne @check_esc_v
002444r 3               
002444r 3                               ; Horizontal TAB (ASCII value 9)
002444r 3  A9 09                        lda #9
002446r 3  80 38                        bra @save_character
002448r 3               
002448r 3               @check_esc_v:
002448r 3  C9 76                        cmp #'v'
00244Ar 3  D0 04                        bne @check_esc_z
00244Cr 3               
00244Cr 3                               ; Vertical TAB (ASCII value 11)
00244Cr 3  A9 0B                        lda #11
00244Er 3  80 30                        bra @save_character
002450r 3               
002450r 3               @check_esc_z:
002450r 3  C9 7A                        cmp #'z'
002452r 3  D0 04                        bne @check_esc_quote
002454r 3               
002454r 3                               ; NULL (ASCII value 0)
002454r 3  A9 00                        lda #0
002456r 3  80 28                        bra @save_character
002458r 3               
002458r 3               @check_esc_quote:
002458r 3  C9 22                        cmp #$22
00245Ar 3  D0 04                        bne @check_esc_x
00245Cr 3               
00245Cr 3                               ; Double quote (ASCII value 34)
00245Cr 3  A9 22                        lda #34
00245Er 3  80 20                        bra @save_character
002460r 3               
002460r 3               @check_esc_x:
002460r 3  C9 78                        cmp #'x'
002462r 3  D0 06                        bne @check_esc_backslash
002464r 3               
002464r 3                               ; This one is difficult. We need to get the next TWO
002464r 3                               ; characters (which might require a refill in the middle)
002464r 3                               ; and combine them as two hex digits. We do this by
002464r 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
002464r 3                               ; and using bit 0 to keep track of which digit we are on.
002464r 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
002466r 3  85 rr                        sta tmp2+1
002468r 3  80 19                        bra @next_character
00246Ar 3               
00246Ar 3               @check_esc_backslash:
00246Ar 3  C9 5C                        cmp #$5C
00246Cr 3  D0 04                        bne @not_escaped
00246Er 3               
00246Er 3                               ; Backslash (ASCII value 92)
00246Er 3  A9 5C                        lda #92
002470r 3  80 0E                        bra @save_character
002472r 3               
002472r 3               @not_escaped:
002472r 3                               ; Check for the backslash to see if we should escape
002472r 3                               ; the next char.
002472r 3  C9 5C                        cmp #$5C        ; The backslash char
002474r 3  D0 06                        bne @regular_char
002476r 3               
002476r 3                               ; We found a backslash.  Don't save anyhing, but set
002476r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
002476r 3                               ; try to get the next char here as it may require a
002476r 3                               ; refill of the input buffer.
002476r 3  A9 FF                        lda #$FF
002478r 3  85 rr                        sta tmp2+1
00247Ar 3  80 07                        bra @next_character
00247Cr 3               
00247Cr 3               @regular_char:
00247Cr 3                               ; Check if the current character is the end of the string.
00247Cr 3  C9 22                        cmp #$22        ; ASCII for "
00247Er 3  F0 0C                        beq @found_string_end
002480r 3               
002480r 3               @save_character:
002480r 3                               ; If we didn't reach the end of the string, compile this
002480r 3                               ; character into the dictionary
002480r 3  20 rr rr                     jsr cmpl_a
002483r 3               
002483r 3               @next_character:
002483r 3                               ; Move on to the next character.
002483r 3  E6 rr                        inc toin
002485r 3  D0 02                        bne @savechars_loop_longjump
002487r 3  E6 rr                        inc toin+1
002489r 3               
002489r 3               @savechars_loop_longjump:
002489r 3  4C rr rr                     jmp @savechars_loop
00248Cr 3               
00248Cr 3               @found_string_end:
00248Cr 3                               ; Use up the delimiter.
00248Cr 3  E6 rr                        inc toin
00248Er 3  D0 02                        bne @1
002490r 3  E6 rr                        inc toin+1
002492r 3               @1:
002492r 3                               ; Calculate the length of the string, which is the
002492r 3                               ; difference between cp and the address of the start
002492r 3                               ; of the string (currently saved on the stack).
002492r 3  A5 rr                        lda cp
002494r 3  38                           sec
002495r 3  F5 02                        sbc 2,x
002497r 3  95 00                        sta 0,x         ; LSB
002499r 3  A5 rr                        lda cp+1
00249Br 3  F5 03                        sbc 3,x
00249Dr 3  95 01                        sta 1,x         ; MSB
00249Fr 3               
00249Fr 3                               ; Update the address of the jump-over jmp instruction.
00249Fr 3                               ; First determine location of jmp instructions address.
00249Fr 3                               ; It should be 2 bytes before the start of the string.
00249Fr 3                               ; Compute it into tmp1, which is no longer being used.
00249Fr 3  B5 02                        lda 2,x
0024A1r 3  38                           sec
0024A2r 3  E9 02                        sbc #2
0024A4r 3  85 rr                        sta tmp1
0024A6r 3  B5 03                        lda 3,x
0024A8r 3  E9 00                        sbc #0          ; Propagate borrow
0024AAr 3  85 rr                        sta tmp1+1
0024ACr 3               
0024ACr 3                               ; Update the address of the jump to HERE.
0024ACr 3  A5 rr                        lda cp
0024AEr 3  92 rr                        sta (tmp1)
0024B0r 3  A0 01                        ldy #1
0024B2r 3  A5 rr                        lda cp+1
0024B4r 3  91 rr                        sta (tmp1),y
0024B6r 3               
0024B6r 3                               ; What happens next depends on the state (which is bad, but
0024B6r 3                               ; that's the way it works at the moment). If we are
0024B6r 3                               ; interpretating, we save the string to a transient buffer
0024B6r 3                               ; and return that address (used for file calls, see
0024B6r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
0024B6r 3                               ; compiling, we just need SLITERAL
0024B6r 3  A5 rr                        lda state
0024B8r 3  05 rr                        ora state+1             ; paranoid
0024BAr 3  F0 03                        beq @done
0024BCr 3               
0024BCr 3                               ; Jump into the middle of the sliteral word, after the
0024BCr 3                               ; string data has been compiled into the dictionary,
0024BCr 3                               ; because we've already done that step.
0024BCr 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
0024BFr 3               
0024BFr 3               @done:
0024BFr 3  60           z_s_quote:      rts
0024C0r 3               
0024C0r 3               
0024C0r 3               
0024C0r 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
0024C0r 3               ; ## "s>d"  auto  ANS core
0024C0r 3                       ; """https://forth-standard.org/standard/core/StoD"""
0024C0r 3               
0024C0r 3               xt_s_to_d:
0024C0r 3  20 rr rr                     jsr underflow_1
0024C3r 3               
0024C3r 3  CA                           dex
0024C4r 3  CA                           dex
0024C5r 3  74 00                        stz 0,x
0024C7r 3  74 01                        stz 1,x
0024C9r 3               
0024C9r 3  B5 03                        lda 3,x
0024CBr 3  10 04                        bpl @done
0024CDr 3               
0024CDr 3                               ; negative, extend sign
0024CDr 3  D6 00                        dec 0,x
0024CFr 3  D6 01                        dec 1,x
0024D1r 3               @done:
0024D1r 3  60           z_s_to_d:       rts
0024D2r 3               
0024D2r 3               
0024D2r 3               
0024D2r 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
0024D2r 3               ; ## "save-buffers"  tested  ANS block
0024D2r 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
0024D2r 3               
0024D2r 3               xt_save_buffers:
0024D2r 3                               ; Check the buffer status
0024D2r 3  A0 2C                        ldy #buffstatus_offset
0024D4r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
0024D6r 3  C9 03                        cmp #3          ; LSB is needed.
0024D8r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
0024DAr 3               
0024DAr 3                               ; We need to save the block.
0024DAr 3  20 rr rr                     jsr xt_blkbuffer
0024DDr 3  20 rr rr                     jsr xt_buffblocknum
0024E0r 3  20 rr rr                     jsr xt_fetch
0024E3r 3  20 rr rr                     jsr xt_block_write
0024E6r 3               
0024E6r 3                               ; Mark the buffer as clean now.
0024E6r 3  A9 01                        lda #1
0024E8r 3  A0 2C                        ldy #buffstatus_offset
0024EAr 3  91 rr                        sta (up),y
0024ECr 3               
0024ECr 3               @done:
0024ECr 3  60           z_save_buffers: rts
0024EDr 3               
0024EDr 3               
0024EDr 3               
0024EDr 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
0024EDr 3               ; ## "scr"  auto  ANS block ext
0024EDr 3                       ; """https://forth-standard.org/standard/block/SCR"""
0024EDr 3               xt_scr:
0024EDr 3                               ; SCR is at UP + scr_offset
0024EDr 3  CA                           dex
0024EEr 3  CA                           dex
0024EFr 3  18                           clc
0024F0r 3  A5 rr                        lda up
0024F2r 3  69 02                        adc #scr_offset ; Add offset
0024F4r 3  95 00                        sta 0,x
0024F6r 3  A5 rr                        lda up+1
0024F8r 3  69 00                        adc #0          ; Adding carry
0024FAr 3  95 01                        sta 1,x
0024FCr 3               
0024FCr 3  60           z_scr:          rts
0024FDr 3               
0024FDr 3               
0024FDr 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
0024FDr 3               ; ## "search"   auto  ANS string
0024FDr 3                       ; """https://forth-standard.org/standard/string/SEARCH
0024FDr 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
0024FDr 3                       ; addr1 u1). If a match is found the flag will be true and
0024FDr 3                       ; addr3 will have the address of the start of the match and u3 will have
0024FDr 3                       ; the number of characters remaining from the match point to the end
0024FDr 3                       ; of the original string1. If a match is not found, the flag will be
0024FDr 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
0024FDr 3                       ; """
0024FDr 3               
0024FDr 3               xt_search:
0024FDr 3  20 rr rr                     jsr underflow_4
002500r 3               
002500r 3                               ; ANS says if the second string is a zero-length string it
002500r 3                               ; automatically matches.
002500r 3  B5 00                        lda 0,x
002502r 3  15 01                        ora 1,x
002504r 3  D0 0B                        bne @start_search
002506r 3               
002506r 3                               ; The second string is a zero length string.  Just remove
002506r 3                               ; the second string and put a true flag.
002506r 3  E8                           inx             ; Remove u2
002507r 3  E8                           inx
002508r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
00250Ar 3  95 00                        sta 0,x
00250Cr 3  95 01                        sta 1,x
00250Er 3  4C rr rr                     jmp z_search
002511r 3               
002511r 3               @start_search:
002511r 3                               ; Put an offset (starting at zero) on the stack.
002511r 3  20 rr rr                     jsr xt_zero
002514r 3               
002514r 3               @search_loop:
002514r 3                               ; We stop (not found) when u2 + offset > u1
002514r 3                               ; Calculate u2+offset into tmp1
002514r 3  18                           clc
002515r 3  B5 00                        lda 0,x
002517r 3  75 02                        adc 2,x
002519r 3  85 rr                        sta tmp1
00251Br 3  B5 01                        lda 1,x
00251Dr 3  75 03                        adc 3,x
00251Fr 3               
00251Fr 3               
00251Fr 3                               ; Compare to u1. Start with the high byte
00251Fr 3  D5 07                        cmp 7,x
002521r 3  90 12                        bcc @init_comparison ; Obviously less
002523r 3  D0 06                        bne @not_found
002525r 3               
002525r 3                               ; The upper address byte matched - check the lower byte
002525r 3                               ; Load u1 first so we can use just a carry to check.
002525r 3  B5 06                        lda 6,x
002527r 3  C5 rr                        cmp tmp1
002529r 3  B0 0A                        bcs @init_comparison
00252Br 3               
00252Br 3               @not_found:
00252Br 3                               ; The substring isn't in the main string.
00252Br 3                               ; Return just the main string and a false flag.
00252Br 3  E8                           inx             ; Remove offset
00252Cr 3  E8                           inx
00252Dr 3  E8                           inx             ; Remove u2
00252Er 3  E8                           inx
00252Fr 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
002531r 3  74 01                        stz 1,x
002533r 3  80 66                        bra z_search
002535r 3               
002535r 3               @init_comparison:
002535r 3                               ; Use tmp1 to hold address in string 1.
002535r 3                               ; Use tmp2 to hold address in string 2.
002535r 3                               ; Use tmp3 to hold the number of characters left to check.
002535r 3               
002535r 3                               ; Compute the starting address in string 1
002535r 3                               ; as addr1 + offset
002535r 3  18                           clc
002536r 3  B5 08                        lda 8,x
002538r 3  75 00                        adc 0,x
00253Ar 3  85 rr                        sta tmp1
00253Cr 3  B5 09                        lda 9,x
00253Er 3  75 01                        adc 1,x
002540r 3  85 rr                        sta tmp1+1
002542r 3               
002542r 3                               ; The starting address in string 2 is just addr2.
002542r 3  B5 04                        lda 4,x
002544r 3  85 rr                        sta tmp2
002546r 3  B5 05                        lda 5,x
002548r 3  85 rr                        sta tmp2+1
00254Ar 3               
00254Ar 3                               ; The number of characters to check is u2.
00254Ar 3  B5 02                        lda 2,x
00254Cr 3  85 rr                        sta tmp3
00254Er 3  B5 03                        lda 3,x
002550r 3  85 rr                        sta tmp3+1
002552r 3               
002552r 3               @comparison_loop:
002552r 3                               ; Check to see if the current characters match.
002552r 3  B2 rr                        lda (tmp1)
002554r 3  D2 rr                        cmp (tmp2)
002556r 3  F0 05                        beq @letters_match
002558r 3               
002558r 3                               ; One of the letters didn't match.
002558r 3                               ; Increment the offset and try again.
002558r 3  20 rr rr                     jsr xt_one_plus
00255Br 3  80 B7                        bra @search_loop
00255Dr 3               
00255Dr 3               @letters_match:
00255Dr 3                               ; The letters match.  Advance the pointers until the
00255Dr 3                               ; count reaches zero.
00255Dr 3  E6 rr                        inc tmp1
00255Fr 3  D0 02                        bne @1
002561r 3  E6 rr                        inc tmp1+1
002563r 3               @1:
002563r 3  E6 rr                        inc tmp2
002565r 3  D0 02                        bne @2
002567r 3  E6 rr                        inc tmp2+1
002569r 3               @2:
002569r 3                               ; Decrement the count of remaining letters to check.
002569r 3  A5 rr                        lda tmp3
00256Br 3  D0 02                        bne @3
00256Dr 3  C6 rr                        dec tmp3+1
00256Fr 3               @3:
00256Fr 3  C6 rr                        dec tmp3
002571r 3               
002571r 3                               ; Check if we've reached zero.
002571r 3  A5 rr                        lda tmp3
002573r 3  05 rr                        ora tmp3+1
002575r 3  D0 DB                        bne @comparison_loop ; Check the next letter
002577r 3               
002577r 3                               ; We've run out of letters and they all match!
002577r 3                               ; Return (addr1+offset) (u1-offset) true
002577r 3                               ; Add offset to addr1.
002577r 3  18                           clc
002578r 3  B5 00                        lda 0,x
00257Ar 3  75 08                        adc 8,x
00257Cr 3  95 08                        sta 8,x
00257Er 3  B5 01                        lda 1,x
002580r 3  75 09                        adc 9,x
002582r 3  95 09                        sta 9,x
002584r 3               
002584r 3                               ; Subtract offset from u1.
002584r 3  38                           sec
002585r 3  B5 06                        lda 6,x
002587r 3  F5 00                        sbc 0,x
002589r 3  95 06                        sta 6,x
00258Br 3  B5 07                        lda 7,x
00258Dr 3  F5 01                        sbc 1,x
00258Fr 3  95 07                        sta 7,x
002591r 3               
002591r 3                               ; Replace addr2, u2, and offset with a true flag.
002591r 3  E8                           inx             ; drop offset
002592r 3  E8                           inx
002593r 3  E8                           inx             ; drop u2
002594r 3  E8                           inx
002595r 3  A9 FF                        lda #$FF
002597r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
002599r 3  95 01                        sta 1,x
00259Br 3               
00259Br 3  60           z_search:       rts
00259Cr 3               
00259Cr 3               
00259Cr 3               
00259Cr 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
00259Cr 3               ; ## ";"  auto  ANS core
00259Cr 3                       ; """https://forth-standard.org/standard/core/Semi
00259Cr 3                       ; End the compilation of a new word into the Dictionary.
00259Cr 3                       ;
00259Cr 3                       ; When we
00259Cr 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
00259Cr 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
00259Cr 3                       ; A Forth definition would be (see "Starting Forth"):
00259Cr 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
00259Cr 3                       ; practice of Gforth, we warn here if a word has been redefined.
00259Cr 3                       ; """
00259Cr 3               
00259Cr 3               xt_semicolon:
00259Cr 3                               ; Check if this is a : word or a :NONAME word.
00259Cr 3  24 rr                        bit status
00259Er 3  70 11                        bvs @colonword
0025A0r 3               
0025A0r 3                               ; This is a :NONAME word - just put an RTS on the end and
0025A0r 3                               ; the address (held in workword) on the stack.
0025A0r 3  A9 60                        lda #$60                ; opcode for RTS
0025A2r 3  20 rr rr                     jsr cmpl_a
0025A5r 3               
0025A5r 3  CA                           dex
0025A6r 3  CA                           dex
0025A7r 3  A5 rr                        lda workword
0025A9r 3  95 00                        sta 0,x
0025ABr 3  A5 rr                        lda workword+1
0025ADr 3  95 01                        sta 1,x
0025AFr 3  80 45                        bra @semicolon_done
0025B1r 3               
0025B1r 3               @colonword:
0025B1r 3                               ; CP is the byte that will be the address we use in the
0025B1r 3                               ; header as the end-of-compile address (z_word). This is
0025B1r 3                               ; six bytes down from the header
0025B1r 3  A0 06                        ldy #6
0025B3r 3  A5 rr                        lda cp
0025B5r 3  91 rr                        sta (workword),y
0025B7r 3  C8                           iny
0025B8r 3  A5 rr                        lda cp+1
0025BAr 3  91 rr                        sta (workword),y
0025BCr 3               
0025BCr 3                               ; Allocate one further byte and save the RTS instruction
0025BCr 3                               ; there
0025BCr 3  A9 60                        lda #$60                ; opcode for RTS
0025BEr 3  20 rr rr                     jsr cmpl_a
0025C1r 3               
0025C1r 3                               ; Before we formally add the word to the Dictionary, we
0025C1r 3                               ; check to see if it is already present, and if yes, we
0025C1r 3                               ; warn the user.
0025C1r 3               
0025C1r 3                               ; See if word already in Dictionary.
0025C1r 3                               ; (STATUS bit 7 will be high as CREATE already
0025C1r 3                               ;  checked for us.)
0025C1r 3  24 rr                        bit status
0025C3r 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
0025C5r 3               
0025C5r 3                               ; We start by putting the string of the
0025C5r 3                               ; word we're defining on the stack
0025C5r 3  CA                           dex
0025C6r 3  CA                           dex
0025C7r 3  CA                           dex
0025C8r 3  CA                           dex
0025C9r 3               
0025C9r 3                               ; WORKWORD points to the beginning of the head of our new
0025C9r 3                               ; word, where the first byte is the length of the string
0025C9r 3                               ; We can't use LATESTNT because we haven't added the new
0025C9r 3                               ; word to the Dictionary yet
0025C9r 3  B2 rr                        lda (workword)
0025CBr 3  95 00                        sta 0,x
0025CDr 3  74 01                        stz 1,x
0025CFr 3               
0025CFr 3                               ; Eight bytes below WORKWORD is the actual beginning of
0025CFr 3                               ; the string
0025CFr 3  A5 rr                        lda workword
0025D1r 3  18                           clc
0025D2r 3  69 08                        adc #8
0025D4r 3  95 02                        sta 2,x
0025D6r 3  A5 rr                        lda workword+1
0025D8r 3  69 00                        adc #0                  ; only want carry
0025DAr 3  95 03                        sta 3,x
0025DCr 3               
0025DCr 3                               ; This word is already in the Dictionary, so we print a
0025DCr 3                               ; warning to the user.
0025DCr 3  A9 02                        lda #str_redefined       ; address of string "redefined"
0025DEr 3  20 rr rr                     jsr print_string_no_lf
0025E1r 3               
0025E1r 3                               ; Now we print the offending word.
0025E1r 3  20 rr rr                     jsr xt_type
0025E4r 3  20 rr rr                     jsr xt_space
0025E7r 3               
0025E7r 3                               ; Clear bit 7 of status (so future words will print message
0025E7r 3                               ; by defaut)
0025E7r 3  A9 80                        lda #%10000000
0025E9r 3  14 rr                        trb status
0025EBr 3               
0025EBr 3               @new_word:
0025EBr 3                               ; Let's get this over with. Save beginning of our word
0025EBr 3                               ; as new last word in the Dictionary
0025EBr 3  A5 rr                        lda workword
0025EDr 3  85 rr                        sta dp
0025EFr 3  A5 rr                        lda workword+1
0025F1r 3  85 rr                        sta dp+1
0025F3r 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
0025F6r 3                                                       ; CURRENT wordlist.
0025F6r 3               @semicolon_done:
0025F6r 3                               ; Word definition complete. Return compile flag to zero
0025F6r 3                               ; to return to interpret mode
0025F6r 3  64 rr                        stz state
0025F8r 3  64 rr                        stz state+1
0025FAr 3               
0025FAr 3  60           z_semicolon:    rts
0025FBr 3               
0025FBr 3               
0025FBr 3               
0025FBr 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
0025FBr 3               ; ## "sign"  auto  ANS core
0025FBr 3                       ; """https://forth-standard.org/standard/core/SIGN
0025FBr 3                       ;
0025FBr 3                       ; Code based on
0025FBr 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0025FBr 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
0025FBr 3                       ; """
0025FBr 3               
0025FBr 3               xt_sign:
0025FBr 3  20 rr rr                     jsr underflow_1
0025FEr 3               
0025FEr 3  B5 01                        lda 1,x         ; check MSB of TOS
002600r 3  30 04                        bmi @minus
002602r 3               
002602r 3  E8                           inx
002603r 3  E8                           inx
002604r 3  80 09                        bra @done
002606r 3               @minus:
002606r 3  A9 2D                        lda #$2D        ; ASCII for "-"
002608r 3  95 00                        sta 0,x         ; overwrite TOS
00260Ar 3  74 01                        stz 1,x         ; paranoid
00260Cr 3               
00260Cr 3  20 rr rr                     jsr xt_hold
00260Fr 3               @done:
00260Fr 3  60           z_sign:         rts
002610r 3               
002610r 3               
002610r 3               
002610r 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
002610r 3               ; ## "/"  auto  ANS core
002610r 3                       ; """https://forth-standard.org/standard/core/Div
002610r 3                       ;
002610r 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
002610r 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
002610r 3                       ; This code is currently unoptimized. This code without the SLASH
002610r 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
002610r 3                       ; """
002610r 3               
002610r 3               xt_slash:
002610r 3                               ; With all the multiplication going on, it would be hard to
002610r 3                               ; make sure that one of our temporary variables is not
002610r 3                               ; overwritten. We make sure that doesn't happen by taking the
002610r 3                               ; hit of pushing the flag to the 65c02's stack
002610r 3  A9 00                        lda #0
002612r 3  48                           pha
002613r 3  80 03                        bra _common
002615r 3               
002615r 3               xt_slash_mod:
002615r 3                               ; Note that /MOD accesses this code
002615r 3  A9 FF                        lda #$FF
002617r 3  48                           pha             ; falls through to _common
002618r 3               
002618r 3               _common:
002618r 3  20 rr rr                     jsr xt_to_r             ; >R
00261Br 3  20 rr rr                     jsr xt_s_to_d           ; S>D
00261Er 3  20 rr rr                     jsr xt_r_from           ; R>
002621r 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
002624r 3               
002624r 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
002624r 3                               ; $FF is SLASH MOD
002624r 3  68                           pla
002625r 3  D0 05                        bne @done
002627r 3               
002627r 3                               ; The following code is for SLASH only
002627r 3  20 rr rr                     jsr xt_swap
00262Ar 3  E8                           inx             ; DROP
00262Br 3  E8                           inx
00262Cr 3               @done:
00262Cr 3               z_slash_mod:
00262Cr 3  60           z_slash:        rts
00262Dr 3               
00262Dr 3               
00262Dr 3               
00262Dr 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
00262Dr 3               ; ## "/mod"  auto  ANS core
00262Dr 3                       ; """https://forth-standard.org/standard/core/DivMOD
00262Dr 3                       ;
00262Dr 3                       ; This is a dummy entry, the actual code is shared with SLASH
00262Dr 3                       ; """
00262Dr 3               
00262Dr 3               
00262Dr 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
00262Dr 3               ; ## "/string"  auto  ANS string
00262Dr 3                       ; """https://forth-standard.org/standard/string/DivSTRING
00262Dr 3                       ;
00262Dr 3                       ; Forth code is
00262Dr 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
00262Dr 3                       ; Put differently, we need to add TOS and 3OS, and subtract
00262Dr 3                       ; TOS from NOS, and then drop TOS
00262Dr 3                       ; """
00262Dr 3               
00262Dr 3               xt_slash_string:
00262Dr 3  20 rr rr                     jsr underflow_3
002630r 3               
002630r 3  18                           clc             ; 3OS+TOS
002631r 3  B5 00                        lda 0,x
002633r 3  75 04                        adc 4,x
002635r 3  95 04                        sta 4,x
002637r 3               
002637r 3  B5 01                        lda 1,x
002639r 3  75 05                        adc 5,x
00263Br 3  95 05                        sta 5,x
00263Dr 3               
00263Dr 3  38                           sec             ; NOS-TOS
00263Er 3  B5 02                        lda 2,x
002640r 3  F5 00                        sbc 0,x
002642r 3  95 02                        sta 2,x
002644r 3               
002644r 3  B5 03                        lda 3,x
002646r 3  F5 01                        sbc 1,x
002648r 3  95 03                        sta 3,x
00264Ar 3               
00264Ar 3  E8                           inx
00264Br 3  E8                           inx
00264Cr 3               
00264Cr 3  60           z_slash_string: rts
00264Dr 3               
00264Dr 3               
00264Dr 3               
00264Dr 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
00264Dr 3               ; ## "sliteral" auto  ANS string
00264Dr 3                       ; """https://forth-standard.org/standard/string/SLITERAL
00264Dr 3                       ; Add the runtime for an existing string.
00264Dr 3                       ; """
00264Dr 3               
00264Dr 3               xt_sliteral:
00264Dr 3  20 rr rr                     jsr underflow_2
002650r 3               
002650r 3                               ; We can't assume that ( addr u ) of the current string is in
002650r 3                               ; a stable area (eg. already in the dictionary.) Copy the
002650r 3                               ; string data into the dictionary using move.
002650r 3               
002650r 3                               ; Put a jmp over the string data with address to be filled
002650r 3                               ; in later.
002650r 3  A9 4C                        lda #$4C
002652r 3  20 rr rr                     jsr cmpl_a
002655r 3               
002655r 3                               ; Address to be filled in later.
002655r 3  20 rr rr                     jsr cmpl_a
002658r 3  20 rr rr                     jsr cmpl_a
00265Br 3               
00265Br 3                               ; Turn the data stack from ( addr u ) into
00265Br 3                               ; ( here u addr here u ) so move can be called with
00265Br 3                               ; the remaining items on the stack ready for processing.
00265Br 3                               ; Reserve three extra words on the stack.
00265Br 3  8A                           txa
00265Cr 3  38                           sec
00265Dr 3  E9 06                        sbc #6
00265Fr 3  AA                           tax
002660r 3               
002660r 3                               ; Move addr down from TOS-4 to TOS-2
002660r 3  B5 08                        lda 8,x
002662r 3  95 04                        sta 4,x
002664r 3  B5 09                        lda 9,x
002666r 3  95 05                        sta 5,x
002668r 3               
002668r 3                               ; Copy u from TOS-3 to TOS
002668r 3  B5 06                        lda 6,x
00266Ar 3  95 00                        sta 0,x
00266Cr 3  B5 07                        lda 7,x
00266Er 3  95 01                        sta 1,x
002670r 3               
002670r 3                               ; Put HERE into TOS-1 and TOS-4
002670r 3  A5 rr                        lda cp
002672r 3  95 08                        sta 8,x
002674r 3  95 02                        sta 2,x
002676r 3  A5 rr                        lda cp+1
002678r 3  95 09                        sta 9,x
00267Ar 3  95 03                        sta 3,x
00267Cr 3               
00267Cr 3                               ; Copy the string into the dictionary.
00267Cr 3  20 rr rr                     jsr xt_move
00267Fr 3               
00267Fr 3                               ; Update cp.
00267Fr 3  18                           clc
002680r 3  A5 rr                        lda cp
002682r 3  75 00                        adc 0,x
002684r 3  85 rr                        sta cp
002686r 3  A5 rr                        lda cp+1
002688r 3  75 01                        adc 1,x
00268Ar 3  85 rr                        sta cp+1
00268Cr 3               
00268Cr 3                               ; Update the address of the jump-over jmp instruction.
00268Cr 3                               ; First determine location of jmp instructions address.
00268Cr 3                               ; It should be 2 bytes before the start of the string.
00268Cr 3               
00268Cr 3                               ; Compute it into tmp1, which is no longer being used.
00268Cr 3  B5 02                        lda 2,x
00268Er 3  38                           sec
00268Fr 3  E9 02                        sbc #2
002691r 3  85 rr                        sta tmp1
002693r 3  B5 03                        lda 3,x
002695r 3  E9 00                        sbc #0          ; Propagate borrow
002697r 3  85 rr                        sta tmp1+1
002699r 3               
002699r 3                               ; Update the address of the jump to HERE.
002699r 3  A5 rr                        lda cp
00269Br 3  92 rr                        sta (tmp1)
00269Dr 3  A0 01                        ldy #1
00269Fr 3  A5 rr                        lda cp+1
0026A1r 3  91 rr                        sta (tmp1),y
0026A3r 3               
0026A3r 3                               ; Stack is now ( addr2 u ) where addr2 is the new
0026A3r 3                               ; location in the dictionary.
0026A3r 3               
0026A3r 3               sliteral_const_str:
0026A3r 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
0026A3r 3                               ; pushes the new ( addr u ) pair to the Data Stack.
0026A3r 3                               ; When we're done, the code will look like this:
0026A3r 3               
0026A3r 3                               ; xt -->    jmp a
0026A3r 3                               ;           <string data bytes>
0026A3r 3                               ;  a -->    jsr sliteral_runtime
0026A3r 3                               ;           <string address>
0026A3r 3                               ;           <string length>
0026A3r 3                               ; rts -->
0026A3r 3               
0026A3r 3                               ; This means we'll have to adjust the return address for two
0026A3r 3                               ; cells, not just one
0026A3r 3  A0 rr                        ldy #>sliteral_runtime
0026A5r 3  A9 rr                        lda #<sliteral_runtime
0026A7r 3  20 rr rr                     jsr cmpl_subroutine
0026AAr 3               
0026AAr 3                               ; We want to have the address end up as NOS and the length
0026AAr 3                               ; as TOS, so we store the address first
0026AAr 3  B4 03                        ldy 3,x                ; address MSB
0026ACr 3  B5 02                        lda 2,x                ; address LSB
0026AEr 3  20 rr rr                     jsr cmpl_word
0026B1r 3               
0026B1r 3  B4 01                        ldy 1,x                ; length MSB
0026B3r 3  B5 00                        lda 0,x                ; length LSB
0026B5r 3  20 rr rr                     jsr cmpl_word
0026B8r 3               
0026B8r 3                               ; clean up and leave
0026B8r 3  E8                           inx
0026B9r 3  E8                           inx
0026BAr 3  E8                           inx
0026BBr 3  E8                           inx
0026BCr 3               
0026BCr 3  60           z_sliteral:     rts
0026BDr 3               
0026BDr 3               
0026BDr 3               sliteral_runtime:
0026BDr 3               
0026BDr 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
0026BDr 3                       ; the Data Stack. We arrive here with the return address as the
0026BDr 3                       ; top of Return Stack, which points to the address of the string
0026BDr 3                       ; """
0026BDr 3  CA                           dex
0026BEr 3  CA                           dex
0026BFr 3  CA                           dex
0026C0r 3  CA                           dex
0026C1r 3               
0026C1r 3                               ; Get the address of the string address off the stack and
0026C1r 3                               ; increase by one because of the RTS mechanics
0026C1r 3  68                           pla
0026C2r 3  85 rr                        sta tmp1        ; LSB of address
0026C4r 3  68                           pla
0026C5r 3  85 rr                        sta tmp1+1      ; MSB of address
0026C7r 3               
0026C7r 3                               ; Walk through both and save them
0026C7r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
0026C9r 3  B1 rr                        lda (tmp1),y
0026CBr 3  95 02                        sta 2,x         ; LSB of address
0026CDr 3  C8                           iny
0026CEr 3               
0026CEr 3  B1 rr                        lda (tmp1),y
0026D0r 3  95 03                        sta 3,x         ; MSB of address
0026D2r 3  C8                           iny
0026D3r 3               
0026D3r 3  B1 rr                        lda (tmp1),y
0026D5r 3  95 00                        sta 0,x         ; LSB of length
0026D7r 3  C8                           iny
0026D8r 3               
0026D8r 3  B1 rr                        lda (tmp1),y
0026DAr 3  95 01                        sta 1,x         ; MSB of length
0026DCr 3               
0026DCr 3                               ; restore return address
0026DCr 3  18                           clc
0026DDr 3  A5 rr                        lda tmp1
0026DFr 3  69 04                        adc #4
0026E1r 3  A8                           tay             ; LSB
0026E2r 3  A5 rr                        lda tmp1+1
0026E4r 3  69 00                        adc #0          ; we only need carry
0026E6r 3  48                           pha             ; MSB
0026E7r 3  5A                           phy
0026E8r 3               
0026E8r 3  60                           rts
0026E9r 3               
0026E9r 3               
0026E9r 3               
0026E9r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
0026E9r 3               ; ## "sm/rem"  auto  ANS core
0026E9r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
0026E9r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
0026E9r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
0026E9r 3                       ;
0026E9r 3                       ; Forth:
0026E9r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
0026E9r 3                       ; R> ?NEGATE SWAP
0026E9r 3                       ; """
0026E9r 3               
0026E9r 3               xt_sm_slash_rem:
0026E9r 3  20 rr rr                     jsr underflow_3 ; contains double number
0026ECr 3               
0026ECr 3                               ; push MSB of high cell of d to Data Stack so we can check
0026ECr 3                               ; its sign later
0026ECr 3  B5 03                        lda 3,x
0026EEr 3  48                           pha
0026EFr 3               
0026EFr 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
0026EFr 3                               ; its sign later as well
0026EFr 3  B5 01                        lda 1,x
0026F1r 3  55 03                        eor 3,x
0026F3r 3  48                           pha
0026F4r 3               
0026F4r 3                               ; Prepare division by getting absolute of n1 and d
0026F4r 3  20 rr rr                     jsr xt_abs
0026F7r 3  E8                           inx             ; pretend we pushed n1 to R
0026F8r 3  E8                           inx
0026F9r 3               
0026F9r 3  20 rr rr                     jsr xt_dabs
0026FCr 3  CA                           dex
0026FDr 3  CA                           dex
0026FEr 3               
0026FEr 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
002701r 3               
002701r 3                               ; if the XOR compiled above is negative, negate the
002701r 3                               ; quotient (n3)
002701r 3  68                           pla
002702r 3  10 03                        bpl @1
002704r 3  20 rr rr                     jsr xt_negate
002707r 3               @1:
002707r 3                               ; if d was negative, negate the remainder (n2)
002707r 3  68                           pla
002708r 3  10 07                        bpl @done
00270Ar 3               
00270Ar 3  E8                           inx             ; pretend we pushed quotient to R
00270Br 3  E8                           inx
00270Cr 3  20 rr rr                     jsr xt_negate
00270Fr 3  CA                           dex
002710r 3  CA                           dex
002711r 3               
002711r 3               @done:
002711r 3  60           z_sm_slash_rem: rts
002712r 3               
002712r 3               
002712r 3               
002712r 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002712r 3               ; ## "source"  auto  ANS core
002712r 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002712r 3               xt_source:
002712r 3                               ; add address
002712r 3  CA                           dex
002713r 3  CA                           dex
002714r 3  A5 rr                        lda cib
002716r 3  95 00                        sta 0,x
002718r 3  A5 rr                        lda cib+1
00271Ar 3  95 01                        sta 1,x
00271Cr 3               
00271Cr 3                               ; add size
00271Cr 3  CA                           dex
00271Dr 3  CA                           dex
00271Er 3  A5 rr                        lda ciblen
002720r 3  95 00                        sta 0,x
002722r 3  A5 rr                        lda ciblen+1
002724r 3  95 01                        sta 1,x
002726r 3               
002726r 3  60           z_source:       rts
002727r 3               
002727r 3               
002727r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002727r 3               ; ## "source-id"  tested  ANS core ext
002727r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002727r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002727r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002727r 3                       ; string, and a text file gives the fileid.
002727r 3                       ; """
002727r 3               xt_source_id:
002727r 3  CA                           dex
002728r 3  CA                           dex
002729r 3               
002729r 3  A5 rr                        lda insrc
00272Br 3  95 00                        sta 0,x
00272Dr 3  A5 rr                        lda insrc+1
00272Fr 3  95 01                        sta 1,x
002731r 3               
002731r 3  60           z_source_id:    rts
002732r 3               
002732r 3               
002732r 3               ; ## SPACE ( -- ) "Print a single space"
002732r 3               ; ## "space"  auto  ANS core
002732r 3                       ; """https://forth-standard.org/standard/core/SPACE"""
002732r 3               xt_space:
002732r 3  A9 20                        lda #AscSP
002734r 3  20 rr rr                     jsr emit_a
002737r 3               
002737r 3  60           z_space:        rts
002738r 3               
002738r 3               
002738r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
002738r 3               ; ## "spaces"  auto  ANS core
002738r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
002738r 3               
002738r 3               xt_spaces:
002738r 3  20 rr rr                     jsr underflow_1
00273Br 3               
00273Br 3                               ; catch any zero in TOS fast
00273Br 3  B5 00                        lda 0,x
00273Dr 3  15 01                        ora 1,x
00273Fr 3  F0 2A                        beq @done
002741r 3               
002741r 3                               ; Usually we're only going to print far less than 256 spaces,
002741r 3                               ; so we create a quick loop for that. Short loop could be realized
002741r 3                               ; as a separate subroutine, but unless we're really pressed for
002741r 3                               ; memory at some point, this is faster
002741r 3  B4 01                        ldy 1,x
002743r 3  D0 0C                        bne @lots_of_spaces
002745r 3               
002745r 3  B4 00                        ldy 0,x
002747r 3               @quick_loop:
002747r 3                               ; we reach here knowing that there must be a number that is not
002747r 3                               ; zero in the TOS
002747r 3  A9 20                        lda #AscSP
002749r 3  20 rr rr                     jsr emit_a
00274Cr 3  88                           dey
00274Dr 3  F0 1C                        beq @done
00274Fr 3  80 F6                        bra @quick_loop
002751r 3               
002751r 3               @lots_of_spaces:
002751r 3                               ; We go through the first loop once to get rid of the lower
002751r 3                               ; counter byte. This could be zero
002751r 3  B4 00                        ldy 0,x
002753r 3               
002753r 3               @first_slow_loop:
002753r 3  F0 08                        beq @slow_outer_loop
002755r 3  A9 20                        lda #AscSP
002757r 3  20 rr rr                     jsr emit_a
00275Ar 3  88                           dey
00275Br 3  80 F6                        bra @first_slow_loop
00275Dr 3               
00275Dr 3               @slow_outer_loop:
00275Dr 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
00275Dr 3  A0 00                        ldy #00
00275Fr 3               
00275Fr 3               @slow_inner_loop:
00275Fr 3  A9 20                        lda #AscSP
002761r 3  20 rr rr                     jsr emit_a
002764r 3  88                           dey
002765r 3  D0 F8                        bne @slow_inner_loop
002767r 3               
002767r 3  D6 01                        dec 1,x
002769r 3  D0 F2                        bne @slow_outer_loop
00276Br 3               
00276Br 3               @done:
00276Br 3  E8                           inx             ; drop
00276Cr 3  E8                           inx
00276Dr 3               
00276Dr 3  60           z_spaces:       rts
00276Er 3               
00276Er 3               
00276Er 3               
00276Er 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
00276Er 3               ; ## "*"  auto  ANS core
00276Er 3                       ; """https://forth-standard.org/standard/core/Times
00276Er 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
00276Er 3                       ;
00276Er 3                       ; This is nothing  more than UM* DROP
00276Er 3                       ; """
00276Er 3               
00276Er 3               xt_star:
00276Er 3  20 rr rr                     jsr underflow_2
002771r 3               
002771r 3  20 rr rr                     jsr xt_um_star
002774r 3  E8                           inx
002775r 3  E8                           inx
002776r 3               
002776r 3  60           z_star:         rts
002777r 3               
002777r 3               
002777r 3               
002777r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
002777r 3               ; ## "*/"  auto  ANS core
002777r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
002777r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
002777r 3                       ; without a remainder. This is */MOD without the mod.
002777r 3                       ;
002777r 3                       ; This word
002777r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
002777r 3                       ; pretty much what we do here
002777r 3                       ; """
002777r 3               xt_star_slash:
002777r 3                               ; We let */MOD check for underflow
002777r 3  20 rr rr                     jsr xt_star_slash_mod
00277Ar 3  20 rr rr                     jsr xt_swap
00277Dr 3  E8                           inx
00277Er 3  E8                           inx
00277Fr 3               z_star_slash:
00277Fr 3  60                           rts
002780r 3               
002780r 3               
002780r 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
002780r 3               ; ## "*/mod"  auto  ANS core
002780r 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
002780r 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
002780r 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
002780r 3                       ; single-cell quotient n5.
002780r 3                       ;
002780r 3                       ; In Forth, this is
002780r 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
002780r 3                       ; """
002780r 3               xt_star_slash_mod:
002780r 3  20 rr rr                     jsr underflow_3
002783r 3               
002783r 3  20 rr rr                     jsr xt_to_r
002786r 3  20 rr rr                     jsr xt_m_star
002789r 3  20 rr rr                     jsr xt_r_from
00278Cr 3  20 rr rr                     jsr xt_sm_slash_rem
00278Fr 3               
00278Fr 3               z_star_slash_mod:
00278Fr 3  60                           rts
002790r 3               
002790r 3               
002790r 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002790r 3               ; ## "state"  auto  ANS core
002790r 3                       ; """https://forth-standard.org/standard/core/STATE
002790r 3                       ; STATE is true when in compilation state, false otherwise. Note
002790r 3                       ; we do not return the state itself, but only the address where
002790r 3                       ; it lives. The state should not be changed directly by the user; see
002790r 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002790r 3                       ; """
002790r 3               xt_state:
002790r 3  CA                           dex
002791r 3  CA                           dex
002792r 3  A9 rr                        lda #<state
002794r 3  95 00                        sta 0,x
002796r 3  A9 rr                        lda #>state
002798r 3  95 01                        sta 1,x
00279Ar 3               
00279Ar 3  60           z_state:        rts
00279Br 3               
00279Br 3               
00279Br 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
00279Br 3               ; ## "!"  auto  ANS core
00279Br 3                       ; """https://forth-standard.org/standard/core/Store"""
00279Br 3               xt_store:
00279Br 3  20 rr rr                     jsr underflow_2
00279Er 3               
00279Er 3  B5 02                        lda 2,x         ; LSB
0027A0r 3  81 00                        sta (0,x)
0027A2r 3               
0027A2r 3  F6 00                        inc 0,x
0027A4r 3  D0 02                        bne @1
0027A6r 3  F6 01                        inc 1,x
0027A8r 3               @1:
0027A8r 3  B5 03                        lda 3,x         ; MSB
0027AAr 3  81 00                        sta (0,x)
0027ACr 3               
0027ACr 3  E8                           inx             ; 2DROP
0027ADr 3  E8                           inx
0027AEr 3  E8                           inx
0027AFr 3  E8                           inx
0027B0r 3               
0027B0r 3  60           z_store:        rts
0027B1r 3               
0027B1r 3               
0027B1r 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
0027B1r 3               ; ## "strip-underflow"  tested  Tali Forth
0027B1r 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
0027B1r 3                       ; checking should be removed during the compilation of new words.
0027B1r 3                       ; Default is false.
0027B1r 3                       ; """
0027B1r 3               xt_strip_underflow:
0027B1r 3  CA                           dex
0027B2r 3  CA                           dex
0027B3r 3               
0027B3r 3  A9 rr                        lda #<uf_strip
0027B5r 3  95 00                        sta 0,x
0027B7r 3  A9 rr                        lda #>uf_strip
0027B9r 3  95 01                        sta 1,x
0027BBr 3               
0027BBr 3               z_strip_underflow:
0027BBr 3  60                           rts
0027BCr 3               
0027BCr 3               
0027BCr 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
0027BCr 3               ; ## "swap"  auto  ANS core
0027BCr 3                       ; """https://forth-standard.org/standard/core/SWAP"""
0027BCr 3               xt_swap:
0027BCr 3  20 rr rr                     jsr underflow_2
0027BFr 3               
0027BFr 3  B5 00                        lda 0,x         ; LSB
0027C1r 3  B4 02                        ldy 2,x
0027C3r 3  95 02                        sta 2,x
0027C5r 3  94 00                        sty 0,x
0027C7r 3               
0027C7r 3  B5 01                        lda 1,x         ; MSB
0027C9r 3  B4 03                        ldy 3,x
0027CBr 3  95 03                        sta 3,x
0027CDr 3  94 01                        sty 1,x
0027CFr 3               
0027CFr 3  60           z_swap:         rts
0027D0r 3               
0027D0r 3               
0027D0r 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
0027D0r 3               ; ## "then"  auto  ANS core
0027D0r 3                       ; """http://forth-standard.org/standard/core/THEN"""
0027D0r 3               xt_then:
0027D0r 3                               ; Get the address to jump to.
0027D0r 3  20 rr rr                     jsr xt_here
0027D3r 3               
0027D3r 3                               ; Stuff HERE in for the branch address back
0027D3r 3                               ; at the IF or ELSE (origination address is on stack).
0027D3r 3  20 rr rr                     jsr xt_swap
0027D6r 3  20 rr rr                     jsr xt_store
0027D9r 3               
0027D9r 3  60           z_then:         rts
0027DAr 3               
0027DAr 3               
0027DAr 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
0027DAr 3               ; ## "thru"  tested  ANS block ext
0027DAr 3                       ; """https://forth-standard.org/standard/block/THRU"""
0027DAr 3               
0027DAr 3               xt_thru:
0027DAr 3  20 rr rr                     jsr underflow_2
0027DDr 3               
0027DDr 3                               ; We need to loop here, and can't use the data stack
0027DDr 3                               ; because the LOADed screens might use it.  We'll
0027DDr 3                               ; need to use the same trick that DO loops use, holding
0027DDr 3                               ; the limit and current index on the return stack.
0027DDr 3               
0027DDr 3                               ; Put the ending screen number on the return stack
0027DDr 3  B5 01                        lda 1,x
0027DFr 3  48                           pha
0027E0r 3  B5 00                        lda 0,x
0027E2r 3  48                           pha
0027E3r 3  E8                           inx
0027E4r 3  E8                           inx
0027E5r 3               @thru_loop:
0027E5r 3                               ; Put the starting screen number on the stack,
0027E5r 3                               ; but keep a copy
0027E5r 3  B5 01                        lda 1,x
0027E7r 3  48                           pha
0027E8r 3  B5 00                        lda 0,x
0027EAr 3  48                           pha
0027EBr 3               
0027EBr 3                               ; Load this screen.
0027EBr 3  20 rr rr                     jsr xt_load
0027EEr 3               
0027EEr 3                               ; Get the number and limit back off the stack.  Rather than
0027EEr 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
0027EEr 3               
0027EEr 3                               ; Get the screen we just loaded.
0027EEr 3  68                           pla
0027EFr 3  85 rr                        sta tmp1
0027F1r 3  68                           pla
0027F2r 3  85 rr                        sta tmp1+1
0027F4r 3               
0027F4r 3                               ; Get the ending screen.
0027F4r 3  68                           pla
0027F5r 3  85 rr                        sta tmp2
0027F7r 3  68                           pla
0027F8r 3  85 rr                        sta tmp2+1
0027FAr 3               
0027FAr 3                               ; See if we just loaded the last screen.
0027FAr 3                               ; A already has the MSB of the last screen in it.
0027FAr 3  C5 rr                        cmp tmp1+1
0027FCr 3  D0 08                        bne @next_screen
0027FEr 3  A5 rr                        lda tmp2        ; Compare the LSB
002800r 3  C5 rr                        cmp tmp1
002802r 3  D0 02                        bne @next_screen
002804r 3  80 18                        bra @done       ; We just did the last screen.
002806r 3               
002806r 3               @next_screen:
002806r 3                               ; Put the ending screen back on the data stack.
002806r 3  A5 rr                        lda tmp2+1
002808r 3  48                           pha
002809r 3  A5 rr                        lda tmp2
00280Br 3  48                           pha
00280Cr 3               
00280Cr 3                               ; Increment the current screen.
00280Cr 3  E6 rr                        inc tmp1
00280Er 3  D0 02                        bne @1
002810r 3  E6 rr                        inc tmp1+1
002812r 3               @1:
002812r 3                               ; Put the current screen on the stack to prepare for
002812r 3                               ; the next loop.
002812r 3  CA                           dex
002813r 3  CA                           dex
002814r 3  A5 rr                        lda tmp1
002816r 3  95 00                        sta 0,x
002818r 3  A5 rr                        lda tmp1+1
00281Ar 3  95 01                        sta 1,x
00281Cr 3  80 C7                        bra @thru_loop
00281Er 3               @done:
00281Er 3  60           z_thru:         rts
00281Fr 3               
00281Fr 3               
00281Fr 3               
00281Fr 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
00281Fr 3               ; ## "'"  auto  ANS core
00281Fr 3                       ; """https://forth-standard.org/standard/core/Tick"""
00281Fr 3               
00281Fr 3               xt_tick:
00281Fr 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002822r 3               
002822r 3                               ; if we got a zero, there was a problem getting the
002822r 3                               ; name of the word
002822r 3  B5 00                        lda 0,x
002824r 3  15 01                        ora 1,x
002826r 3  D0 05                        bne @1
002828r 3               
002828r 3  A9 05                        lda #err_noname
00282Ar 3  4C rr rr                     jmp error
00282Dr 3               @1:
00282Dr 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002830r 3               
002830r 3                               ; If we didn't find the word in the Dictionary, abort
002830r 3  B5 00                        lda 0,x
002832r 3  15 01                        ora 1,x
002834r 3  D0 05                        bne @2
002836r 3               
002836r 3  A9 08                        lda #err_syntax
002838r 3  4C rr rr                     jmp error
00283Br 3               @2:
00283Br 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
00283Er 3               
00283Er 3  60           z_tick:         rts
00283Fr 3               
00283Fr 3               
00283Fr 3               
00283Fr 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
00283Fr 3               ; ## "to"  auto  ANS core ext
00283Fr 3                       ; """https://forth-standard.org/standard/core/TO
00283Fr 3                       ; Gives a new value to a, uh, VALUE.
00283Fr 3                       ;
00283Fr 3                       ; One possible Forth
00283Fr 3                       ; implementation is  ' >BODY !  but given the problems we have
00283Fr 3                       ; with >BODY on STC Forths, we do this the hard way. Since
00283Fr 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
00283Fr 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
00283Fr 3                       ;
00283Fr 3                       ; Note that the standard has different behaviors for TO depending
00283Fr 3                       ; on the state (https://forth-standard.org/standard/core/TO).
00283Fr 3                       ; This makes TO state-dependent (which is bad) and also rather
00283Fr 3                       ; complex (see the Gforth implementation for comparison). This
00283Fr 3                       ; word may not be natively compiled and must be immediate. Frankly,
00283Fr 3                       ; it would have made more sense to have two words for this.
00283Fr 3                       ; """
00283Fr 3               
00283Fr 3               xt_to:
00283Fr 3                               ; One way or the other, we need the xt of the word after this
00283Fr 3                               ; one. At this point, we don't know if we are interpreted or
00283Fr 3                               ; compile, so we don't know if there is a value n on the stack,
00283Fr 3                               ; so we can't do an underflow check yet
00283Fr 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002842r 3               
002842r 3                               ; The PFA (DFA in this case) is three bytes down,
002842r 3                               ; after the jump to DOCONST
002842r 3  B5 00                        lda 0,x                 ; LSB
002844r 3  18                           clc
002845r 3  69 03                        adc #3
002847r 3  85 rr                        sta tmp1
002849r 3  B5 01                        lda 1,x                 ; MSB
00284Br 3  69 00                        adc #0                  ; we just want the carry
00284Dr 3  85 rr                        sta tmp1+1
00284Fr 3               
00284Fr 3  E8                           inx
002850r 3  E8                           inx                     ; ( [n] )
002851r 3               
002851r 3                               ; Now it gets ugly. See which state we are in
002851r 3  A5 rr                        lda state
002853r 3  05 rr                        ora state+1
002855r 3  F0 34                        beq @interpret
002857r 3               
002857r 3                               ; Well, we're compiling. We want to end up with simple
002857r 3                               ; code that just takes the number that is TOS and saves
002857r 3                               ; it in the address of the xt we were just given. So we
002857r 3                               ; want to compile this routine:
002857r 3                               ;
002857r 3                               ;       lda 0,x                 - B5 00
002857r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002857r 3                               ;       lda 1,x                 - B5 01
002857r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002857r 3                               ;       inx                     - E8
002857r 3                               ;       inx                     - E8
002857r 3                               ;
002857r 3                               ; which at least is nice and short. Other than that, we pretty
002857r 3                               ; much have to do this the hard and long way, because with the
002857r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
002857r 3                               ; range and store them with a loop. Sigh.
002857r 3               
002857r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
002859r 3  A9 B5                        lda #$B5
00285Br 3  20 rr rr                     jsr cmpl_word
00285Er 3               
00285Er 3  A9 8D                        lda #$8D                ; Code for STA abs
002860r 3  20 rr rr                     jsr cmpl_a
002863r 3               
002863r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002865r 3  A5 rr                        lda tmp1
002867r 3  20 rr rr                     jsr cmpl_word
00286Ar 3               
00286Ar 3  A0 01                        ldy #$01                ; Code for LDA 1,X
00286Cr 3  A9 B5                        lda #$B5
00286Er 3  20 rr rr                     jsr cmpl_word
002871r 3               
002871r 3  A9 8D                        lda #$8D                ; Code for STA abs
002873r 3  20 rr rr                     jsr cmpl_a
002876r 3               
002876r 3  E6 rr                        inc tmp1                ; Calculate MSB
002878r 3  D0 02                        bne @1
00287Ar 3  E6 rr                        inc tmp1+1
00287Cr 3               @1:
00287Cr 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
00287Er 3  A5 rr                        lda tmp1
002880r 3  20 rr rr                     jsr cmpl_word
002883r 3               
002883r 3  A0 E8                        ldy #$E8                ; Code for INX
002885r 3  98                           tya
002886r 3  20 rr rr                     jsr cmpl_word
002889r 3               
002889r 3  80 0F                        bra @done
00288Br 3               
00288Br 3               @interpret:
00288Br 3                               ; We're interpreting, so we arrive here with n
00288Br 3                               ; on the stack. This is an annoying place to put
00288Br 3                               ; the underflow check because we can't
00288Br 3                               ; automatically strip it out
00288Br 3  20 rr rr                     jsr underflow_1
00288Er 3               
00288Er 3                               ; We skip over the jump to DOCONST and store the number
00288Er 3                               ; in the Program Field Area (PDF, in this case more a
00288Er 3                               ; Data Field Area
00288Er 3  B5 00                        lda 0,x
002890r 3  92 rr                        sta (tmp1)              ; LSB
002892r 3               
002892r 3  A0 01                        ldy #1
002894r 3  B5 01                        lda 1,x                 ; MSB
002896r 3  91 rr                        sta (tmp1),y            ; fall through to common
002898r 3               
002898r 3  E8                           inx                     ; DROP
002899r 3  E8                           inx
00289Ar 3               @done:
00289Ar 3  60           z_to:           rts
00289Br 3               
00289Br 3               
00289Br 3               
00289Br 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
00289Br 3               ; ## ">body"  auto  ANS core
00289Br 3                       ; """https://forth-standard.org/standard/core/toBODY
00289Br 3                       ; Given a word's execution token (xt), return the address of the
00289Br 3                       ; start of that word's parameter field (PFA). This is defined as the
00289Br 3                       ; address that HERE would return right after CREATE.
00289Br 3                       ;
00289Br 3                       ; This is a
00289Br 3                       ; difficult word for STC Forths, because most words don't actually
00289Br 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
00289Br 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
00289Br 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
00289Br 3                       ; """
00289Br 3               
00289Br 3               xt_to_body:
00289Br 3  20 rr rr                     jsr underflow_1
00289Er 3               
00289Er 3                               ; Ideally, xt already points to the CFA. We just need to check
00289Er 3                               ; the HC flag for special cases
00289Er 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
0028A1r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
0028A4r 3               
0028A4r 3                               ; The status byte is nt+1
0028A4r 3  F6 00                        inc 0,x
0028A6r 3  D0 02                        bne @1
0028A8r 3  F6 01                        inc 1,x
0028AAr 3               @1:
0028AAr 3  A1 00                        lda (0,x)               ; get status byte
0028ACr 3  29 20                        and #HC
0028AEr 3  F0 0D                        beq @no_cfa
0028B0r 3               
0028B0r 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
0028B0r 3                               ; so we add three to xt, which is NOS
0028B0r 3  18                           clc
0028B1r 3  B5 02                        lda 2,x         ; LSB
0028B3r 3  69 03                        adc #3
0028B5r 3  95 02                        sta 2,x
0028B7r 3  B5 03                        lda 3,x         ; MSB
0028B9r 3  69 00                        adc #0          ; we conly care about the carry
0028BBr 3  95 03                        sta 3,x         ; Fall through to @no_cfa
0028BDr 3               @no_cfa:
0028BDr 3  E8                           inx             ; get rid of the nt
0028BEr 3  E8                           inx
0028BFr 3               @done:
0028BFr 3  60           z_to_body:      rts
0028C0r 3               
0028C0r 3               
0028C0r 3               
0028C0r 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
0028C0r 3               ; ## ">in"  auto  ANS core
0028C0r 3               xt_to_in:
0028C0r 3  CA                           dex
0028C1r 3  CA                           dex
0028C2r 3               
0028C2r 3  A9 rr                        lda #<toin
0028C4r 3  95 00                        sta 0,x
0028C6r 3  A9 rr                        lda #>toin      ; paranoid, should be zero
0028C8r 3  95 01                        sta 1,x
0028CAr 3               
0028CAr 3  60           z_to_in:        rts
0028CBr 3               
0028CBr 3               
0028CBr 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
0028CBr 3               ; ## ">number"  auto  ANS core
0028CBr 3                       ; """https://forth-standard.org/standard/core/toNUMBER
0028CBr 3                       ; Convert a string to a double number. Logic here is based on the
0028CBr 3                       ; routine by Phil Burk of the same name in pForth, see
0028CBr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0028CBr 3                       ; for the original Forth code. We arrive here from NUMBER which has
0028CBr 3                       ; made sure that we don't have to deal with a sign and we don't have
0028CBr 3                       ; to deal with a dot as a last character that signalizes double -
0028CBr 3                       ; this should be a pure number string.
0028CBr 3                       ;
0028CBr 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
0028CBr 3                       ; cannot access any of those.
0028CBr 3                       ;
0028CBr 3                       ; For the math routine, we move the inputs to the scratchpad to
0028CBr 3                       ; avoid having to fool around with the Data Stack.
0028CBr 3                       ;
0028CBr 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0028CBr 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
0028CBr 3                       ;     |           |           |           |           |
0028CBr 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
0028CBr 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0028CBr 3                       ;
0028CBr 3                       ; The math routine works by converting one character to its
0028CBr 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
0028CBr 3                       ; the moment. We then multiply the UD-HI value with the radix
0028CBr 3                       ; (from BASE) using UM*, which returns a double-cell result. We
0028CBr 3                       ; discard the high cell of that result (UD-HI-HI) and store the
0028CBr 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
0028CBr 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
0028CBr 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
0028CBr 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
0028CBr 3                       ; storing the result back in S and S+2, before we start another
0028CBr 3                       ; round with it as the new UD-LO and UD-HI.
0028CBr 3                       ; """
0028CBr 3               
0028CBr 3               
0028CBr 3               xt_to_number:
0028CBr 3  20 rr rr                     jsr underflow_4
0028CEr 3               
0028CEr 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
0028CEr 3                               ; After this step, the original ud-lo and ud-hi will still be on
0028CEr 3                               ; the Data Stack, but will be ignored and later overwritten
0028CEr 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
0028CEr 3  B5 06                        lda 6,x         ; ud-lo LSB
0028D0r 3  85 rr                        sta scratch
0028D2r 3  B5 07                        lda 7,x         ; ud-lo MSB
0028D4r 3  85 rr                        sta scratch+1
0028D6r 3               
0028D6r 3  B5 04                        lda 4,x         ; ud-hi LSB
0028D8r 3  85 rr                        sta scratch+2
0028DAr 3  B5 05                        lda 5,x         ; ud-hi MSB
0028DCr 3  85 rr                        sta scratch+3
0028DEr 3               
0028DEr 3                               ; Push down one on the Data Stack to use TOS for character
0028DEr 3                               ; conversion ( ud-lo ud-hi addr u x )
0028DEr 3  CA                           dex
0028DFr 3  CA                           dex
0028E0r 3               
0028E0r 3               @loop:
0028E0r 3                               ; Get one character based on address
0028E0r 3  A1 04                        lda (4,x)
0028E2r 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
0028E4r 3  74 01                        stz 1,x                 ; paranoid
0028E6r 3               
0028E6r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
0028E9r 3               
0028E9r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
0028E9r 3                               ; check the flag. If it is zero, we return what we have and
0028E9r 3                               ; let the caller (usually NUMBER) complain
0028E9r 3  B5 00                        lda 0,x
0028EBr 3  D0 04                        bne @digit_ok
0028EDr 3               
0028EDr 3  E8                           inx
0028EEr 3  E8                           inx
0028EFr 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
0028F1r 3               
0028F1r 3               @digit_ok:
0028F1r 3                               ; Conversion was successful. We arrive here with
0028F1r 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
0028F1r 3                               ; math routine
0028F1r 3               
0028F1r 3                               ; Save n so we don't have to fool around with the
0028F1r 3                               ; Data Stack
0028F1r 3  B5 02                        lda 2,x
0028F3r 3  85 rr                        sta scratch+4
0028F5r 3  B5 03                        lda 3,x
0028F7r 3  85 rr                        sta scratch+5
0028F9r 3               
0028F9r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
0028F9r 3                               ; original one on the Data Stack) with the radix from BASE.
0028F9r 3                               ; We can clobber TOS and NOS because we saved n
0028F9r 3  A5 rr                        lda scratch+2
0028FBr 3  95 02                        sta 2,x         ; NOS
0028FDr 3  A5 rr                        lda scratch+3
0028FFr 3  95 03                        sta 3,x
002901r 3               
002901r 3  A5 rr                        lda base
002903r 3  95 00                        sta 0,x         ; TOS
002905r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002907r 3               
002907r 3                               ; UM* returns a double-celled number
002907r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
00290Ar 3               
00290Ar 3                               ; Move ud-hi-lo to safety
00290Ar 3  B5 02                        lda 2,x         ; ud-hi-lo
00290Cr 3  85 rr                        sta scratch+6
00290Er 3  B5 03                        lda 3,x
002910r 3  85 rr                        sta scratch+7
002912r 3               
002912r 3                               ; Now we multiply ud-lo, overwriting the stack entries
002912r 3  A5 rr                        lda scratch
002914r 3  95 02                        sta 2,x
002916r 3  A5 rr                        lda scratch+1
002918r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
00291Ar 3               
00291Ar 3  A5 rr                        lda base
00291Cr 3  95 00                        sta 0,x
00291Er 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002920r 3               
002920r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002923r 3               
002923r 3  B5 00                        lda 0,x
002925r 3  85 rr                        sta scratch+2
002927r 3  B5 01                        lda 1,x
002929r 3  85 rr                        sta scratch+3
00292Br 3               
00292Br 3  B5 02                        lda 2,x
00292Dr 3  85 rr                        sta scratch
00292Fr 3  B5 03                        lda 3,x
002931r 3  85 rr                        sta scratch+1
002933r 3               
002933r 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002933r 3                               ; both in the scratch pad
002933r 3  18                           clc
002934r 3  A5 rr                        lda scratch     ; ud-lo LSB
002936r 3  65 rr                        adc scratch+4   ; n LSB
002938r 3  85 rr                        sta scratch     ; this is the new ud-lo
00293Ar 3  A5 rr                        lda scratch+1   ; ud-lo MSB
00293Cr 3  65 rr                        adc scratch+5   ; n MSB
00293Er 3  85 rr                        sta scratch+1
002940r 3               
002940r 3  A5 rr                        lda scratch+2   ; LSB
002942r 3  65 rr                        adc scratch+6
002944r 3  85 rr                        sta scratch+2   ; this is the new ud-hi
002946r 3  A5 rr                        lda scratch+3   ; MSB
002948r 3  65 rr                        adc scratch+7
00294Ar 3  85 rr                        sta scratch+3
00294Cr 3               
00294Cr 3                               ; Clean up: Get rid of one of the two top elements on
00294Cr 3                               ; the Data Stack. We don't really care which one
00294Cr 3  E8                           inx
00294Dr 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
00294Er 3               
00294Er 3                               ; One character down. Move address up
00294Er 3  F6 04                        inc 4,x
002950r 3  D0 02                        bne @1
002952r 3  F6 05                        inc 5,x
002954r 3               @1:
002954r 3                               ; Decrease counter
002954r 3  D6 02                        dec 2,x
002956r 3  D0 88                        bne @loop
002958r 3               
002958r 3               @done:
002958r 3                               ; Counter has reached zero or we have an error. In both
002958r 3                               ; cases, we clean up the Data Stack and return. Error gives
002958r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002958r 3                               ; ( ud-lo ud-hi addr u ud-lo )
002958r 3  E8                           inx
002959r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
00295Ar 3               
00295Ar 3                               ; The new ud-lo and ud-hi are still on the scratch pad
00295Ar 3  A5 rr                        lda scratch     ; new ud-lo
00295Cr 3  95 06                        sta 6,x
00295Er 3  A5 rr                        lda scratch+1
002960r 3  95 07                        sta 7,x
002962r 3               
002962r 3  A5 rr                        lda scratch+2
002964r 3  95 04                        sta 4,x
002966r 3  A5 rr                        lda scratch+3
002968r 3  95 05                        sta 5,x
00296Ar 3               
00296Ar 3  60           z_to_number:    rts
00296Br 3               
00296Br 3               
00296Br 3               
00296Br 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
00296Br 3               ; ## ">order"  tested  Gforth search
00296Br 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
00296Br 3               
00296Br 3               xt_to_order:
00296Br 3                               ; Put the wid on the return stack for now.
00296Br 3  20 rr rr                     jsr xt_to_r
00296Er 3               
00296Er 3                               ; Get the current search order.
00296Er 3  20 rr rr                     jsr xt_get_order
002971r 3               
002971r 3                               ; Get back the wid and add it to the list.
002971r 3  20 rr rr                     jsr xt_r_from
002974r 3  20 rr rr                     jsr xt_swap
002977r 3  20 rr rr                     jsr xt_one_plus
00297Ar 3               
00297Ar 3                               ; Set the search order with the new list.
00297Ar 3  20 rr rr                     jsr xt_set_order
00297Dr 3               
00297Dr 3  60           z_to_order:     rts
00297Er 3               
00297Er 3               
00297Er 3               
00297Er 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
00297Er 3               ; ## ">r"  auto  ANS core
00297Er 3                       ; """https://forth-standard.org/standard/core/toR
00297Er 3                       ; This word is handled differently for native and for
00297Er 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
00297Er 3                       ; word.
00297Er 3                       ; """
00297Er 3               xt_to_r:
00297Er 3                               ; Save the return address. If this word is natively
00297Er 3                               ; coded, this is a complete waste of cycles, but
00297Er 3                               ; required for subroutine coding
00297Er 3  68                           pla             ; LSB
00297Fr 3  85 rr                        sta tmptos
002981r 3  7A                           ply             ; MSB
002982r 3               
002982r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002982r 3               
002982r 3                               ; We check for underflow in the second step, so we can
002982r 3                               ; strip off the stack thrashing for native compiling first
002982r 3  20 rr rr                     jsr underflow_1
002985r 3               
002985r 3                               ; now we can do the actual work
002985r 3  B5 01                        lda 1,x         ; MSB
002987r 3  48                           pha
002988r 3  B5 00                        lda 0,x         ; LSB
00298Ar 3  48                           pha
00298Br 3               
00298Br 3  E8                           inx
00298Cr 3  E8                           inx
00298Dr 3               
00298Dr 3                               ; --- CUT HERE FOR NATIVE CODING ---
00298Dr 3               
00298Dr 3                               ; restore return address
00298Dr 3  5A                           phy             ; MSB
00298Er 3  A5 rr                        lda tmptos
002990r 3  48                           pha             ; LSB
002991r 3               
002991r 3  60           z_to_r:         rts
002992r 3               
002992r 3               
002992r 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002992r 3               ; ## "true"  auto  ANS core ext
002992r 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002992r 3               xt_true:
002992r 3  CA                           dex
002993r 3  CA                           dex
002994r 3  A9 FF                        lda #$FF
002996r 3  95 00                        sta 0,x
002998r 3  95 01                        sta 1,x
00299Ar 3               
00299Ar 3  60           z_true:         rts
00299Br 3               
00299Br 3               
00299Br 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
00299Br 3               ; ## "tuck"  auto  ANS core ext
00299Br 3                       ; """https://forth-standard.org/standard/core/TUCK"""
00299Br 3               xt_tuck:
00299Br 3  20 rr rr                     jsr underflow_2
00299Er 3               
00299Er 3  CA                           dex
00299Fr 3  CA                           dex
0029A0r 3               
0029A0r 3  B4 04                        ldy 4,x         ; LSB
0029A2r 3  B5 02                        lda 2,x
0029A4r 3  95 04                        sta 4,x
0029A6r 3  94 02                        sty 2,x
0029A8r 3  95 00                        sta 0,x
0029AAr 3               
0029AAr 3  B4 05                        ldy 5,x         ; MSB
0029ACr 3  B5 03                        lda 3,x
0029AEr 3  95 05                        sta 5,x
0029B0r 3  94 03                        sty 3,x         ; bba
0029B2r 3  95 01                        sta 1,x         ; baa
0029B4r 3               
0029B4r 3  60           z_tuck:         rts
0029B5r 3               
0029B5r 3               
0029B5r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
0029B5r 3               ; ## "2"  auto  Tali Forth
0029B5r 3                       ;
0029B5r 3                       ; This code is shared with ASSEMBLER-WORDLIST
0029B5r 3               xt_assembler_wordlist:
0029B5r 3               xt_two:
0029B5r 3  CA                           dex
0029B6r 3  CA                           dex
0029B7r 3  A9 02                        lda #2
0029B9r 3  95 00                        sta 0,x
0029BBr 3  74 01                        stz 1,x
0029BDr 3               
0029BDr 3               z_assembler_wordlist:
0029BDr 3  60           z_two:          rts
0029BEr 3               
0029BEr 3               
0029BEr 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
0029BEr 3               ; ## "2drop"  auto  ANS core
0029BEr 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
0029BEr 3               xt_two_drop:
0029BEr 3  20 rr rr                     jsr underflow_2
0029C1r 3               
0029C1r 3  E8                           inx
0029C2r 3  E8                           inx
0029C3r 3  E8                           inx
0029C4r 3  E8                           inx
0029C5r 3               
0029C5r 3  60           z_two_drop:     rts
0029C6r 3               
0029C6r 3               
0029C6r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
0029C6r 3               ; ## "2dup"  auto  ANS core
0029C6r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
0029C6r 3               xt_two_dup:
0029C6r 3  20 rr rr                     jsr underflow_2
0029C9r 3               
0029C9r 3  CA                           dex
0029CAr 3  CA                           dex
0029CBr 3  CA                           dex
0029CCr 3  CA                           dex
0029CDr 3               
0029CDr 3  B5 04                        lda 4,x         ; TOS
0029CFr 3  95 00                        sta 0,x
0029D1r 3  B5 05                        lda 5,x
0029D3r 3  95 01                        sta 1,x
0029D5r 3               
0029D5r 3  B5 06                        lda 6,x         ; NOS
0029D7r 3  95 02                        sta 2,x
0029D9r 3  B5 07                        lda 7,x
0029DBr 3  95 03                        sta 3,x
0029DDr 3               
0029DDr 3  60           z_two_dup:      rts
0029DEr 3               
0029DEr 3               
0029DEr 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
0029DEr 3               ; ## "2@"  auto  ANS core
0029DEr 3                       ; """https://forth-standard.org/standard/core/TwoFetch
0029DEr 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
0029DEr 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
0029DEr 3                       ; """
0029DEr 3               xt_two_fetch:
0029DEr 3  20 rr rr                     jsr underflow_1
0029E1r 3               
0029E1r 3  B5 00                        lda 0,x
0029E3r 3  85 rr                        sta tmp1
0029E5r 3  B4 01                        ldy 1,x
0029E7r 3  84 rr                        sty tmp1+1
0029E9r 3               
0029E9r 3  CA                           dex             ; reuse one stack element
0029EAr 3  CA                           dex
0029EBr 3               
0029EBr 3  B2 rr                        lda (tmp1)      ; copy LSB
0029EDr 3  95 00                        sta 0,x
0029EFr 3  A0 01                        ldy #1          ; copy next
0029F1r 3  B1 rr                        lda (tmp1),y
0029F3r 3  95 01                        sta 1,x
0029F5r 3  C8                           iny             ; copy next
0029F6r 3  B1 rr                        lda (tmp1),y
0029F8r 3  95 02                        sta 2,x
0029FAr 3  C8                           iny             ; copy next
0029FBr 3  B1 rr                        lda (tmp1),y
0029FDr 3  95 03                        sta 3,x
0029FFr 3               
0029FFr 3  60           z_two_fetch:    rts
002A00r 3               
002A00r 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
002A00r 3               ; ## "2over"  auto  ANS core
002A00r 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
002A00r 3               xt_two_over:
002A00r 3  20 rr rr                     jsr underflow_4
002A03r 3               
002A03r 3  CA                           dex
002A04r 3  CA                           dex
002A05r 3  CA                           dex
002A06r 3  CA                           dex
002A07r 3               
002A07r 3  B5 08                        lda 8,x
002A09r 3  95 00                        sta 0,x
002A0Br 3               
002A0Br 3  B5 09                        lda 9,x
002A0Dr 3  95 01                        sta 1,x
002A0Fr 3               
002A0Fr 3  B5 0A                        lda 10,x
002A11r 3  95 02                        sta 2,x
002A13r 3               
002A13r 3  B5 0B                        lda 11,x
002A15r 3  95 03                        sta 3,x
002A17r 3               
002A17r 3  60           z_two_over:     rts
002A18r 3               
002A18r 3               
002A18r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002A18r 3               ; ## "2r@"  auto  ANS core ext
002A18r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002A18r 3                       ;
002A18r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002A18r 3                       ; assembler. We use trickery to access the elements on the Return
002A18r 3                       ; Stack instead of pulling the return address first and storing
002A18r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002A18r 3                       ; it as Never Native; at some point, we should compare versions to
002A18r 3                       ; see if an Always Native version would be better
002A18r 3                       ; """
002A18r 3               xt_two_r_fetch:
002A18r 3               		; make room on the Data Stack
002A18r 3  CA                           dex
002A19r 3  CA                           dex
002A1Ar 3  CA                           dex
002A1Br 3  CA                           dex
002A1Cr 3               
002A1Cr 3                               ; Get four bytes off of Return Stack. This assumes that
002A1Cr 3                               ; we took a subroutine jump here so the first two entries
002A1Cr 3                               ; are the return address
002A1Cr 3  8A                           txa
002A1Dr 3  BA                           tsx
002A1Er 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002A1Fr 3  7A                           ply
002A20r 3  AA                           tax
002A21r 3               
002A21r 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002A21r 3                               ; the return address for this word. This is a whole lot
002A21r 3                               ; easier on the 65816
002A21r 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002A24r 3  95 00                        sta 0,x
002A26r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002A29r 3  95 01                        sta 1,x
002A2Br 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002A2Er 3  95 02                        sta 2,x
002A30r 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002A33r 3  95 03                        sta 3,x
002A35r 3               
002A35r 3  60           z_two_r_fetch:  rts
002A36r 3               
002A36r 3               
002A36r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
002A36r 3               ; ## "2r>"  auto  ANS core ext
002A36r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
002A36r 3                       ; Pull top two entries from Return Stack.
002A36r 3                       ;
002A36r 3                       ; Is the same as
002A36r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
002A36r 3                       ; the top value on the ReturnStack for a STC Forth is the
002A36r 3                       ; return address, which we need to get out of the way first.
002A36r 3                       ; Native compile needs to be handled as a special case.
002A36r 3                       ; """
002A36r 3               xt_two_r_from:
002A36r 3                               ; save the return address
002A36r 3  68                           pla                     ; LSB
002A37r 3  85 rr                        sta tmp1
002A39r 3  68                           pla                     ; MSB
002A3Ar 3  85 rr                        sta tmp1+1
002A3Cr 3               
002A3Cr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002A3Cr 3               
002A3Cr 3               		; make room on stack
002A3Cr 3  CA                           dex
002A3Dr 3  CA                           dex
002A3Er 3  CA                           dex
002A3Fr 3  CA                           dex
002A40r 3               
002A40r 3                               ; In theory, we should test for underflow on the Return
002A40r 3                               ; Stack. However, given the traffic there with an STC
002A40r 3                               ; Forth, that's probably not really useful
002A40r 3               
002A40r 3                               ; now we can access the data
002A40r 3  68                           pla                     ; LSB
002A41r 3  95 00                        sta 0,x
002A43r 3  68                           pla                     ; MSB
002A44r 3  95 01                        sta 1,x
002A46r 3               
002A46r 3  68                           pla                     ; LSB
002A47r 3  95 02                        sta 2,x
002A49r 3  68                           pla                     ; MSB
002A4Ar 3  95 03                        sta 3,x
002A4Cr 3               
002A4Cr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002A4Cr 3               
002A4Cr 3                               ; restore return address
002A4Cr 3  A5 rr                        lda tmp1+1              ; MSB
002A4Er 3  48                           pha
002A4Fr 3  A5 rr                        lda tmp1                ; LSB
002A51r 3  48                           pha
002A52r 3               
002A52r 3  60           z_two_r_from:   rts
002A53r 3               
002A53r 3               
002A53r 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002A53r 3               ; ## "2/"  auto  ANS core
002A53r 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002A53r 3               xt_two_slash:
002A53r 3  20 rr rr                     jsr underflow_1
002A56r 3               
002A56r 3                               ; We can't just LSR the LSB and ROR the MSB because that
002A56r 3                               ; would do bad things to the sign
002A56r 3  B5 01                        lda 1,x
002A58r 3  0A                           asl                     ; save the sign
002A59r 3  76 01                        ror 1,x
002A5Br 3  76 00                        ror 0,x
002A5Dr 3               
002A5Dr 3  60           z_two_slash:    rts
002A5Er 3               
002A5Er 3               
002A5Er 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002A5Er 3               ; ## "2*"  auto  ANS core
002A5Er 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002A5Er 3                       ;
002A5Er 3                       ; Also used for CELLS
002A5Er 3                       ; """
002A5Er 3               xt_two_star:
002A5Er 3               xt_cells:
002A5Er 3  20 rr rr                     jsr underflow_1
002A61r 3               
002A61r 3  16 00                        asl 0,x
002A63r 3  36 01                        rol 1,x
002A65r 3               z_cells:
002A65r 3  60           z_two_star:     rts
002A66r 3               
002A66r 3               
002A66r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
002A66r 3               ; ## "2!"  auto  ANS core
002A66r 3                       ; """https://forth-standard.org/standard/core/TwoStore
002A66r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
002A66r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
002A66r 3                       ; """
002A66r 3               xt_two_store:
002A66r 3  20 rr rr                     jsr underflow_3
002A69r 3               
002A69r 3  B5 00                        lda 0,x
002A6Br 3  85 rr                        sta tmp1
002A6Dr 3  B4 01                        ldy 1,x
002A6Fr 3  84 rr                        sty tmp1+1
002A71r 3               
002A71r 3  E8                           inx
002A72r 3  E8                           inx
002A73r 3               
002A73r 3  B5 00                        lda 0,x         ; copy MSB
002A75r 3  92 rr                        sta (tmp1)
002A77r 3  B5 01                        lda 1,x         ; copy next
002A79r 3  A0 01                        ldy #1
002A7Br 3  91 rr                        sta (tmp1),y
002A7Dr 3  B5 02                        lda 2,x         ; copy next
002A7Fr 3  C8                           iny
002A80r 3  91 rr                        sta (tmp1),y
002A82r 3  B5 03                        lda 3,x         ; copy MSB
002A84r 3  C8                           iny
002A85r 3  91 rr                        sta (tmp1),y
002A87r 3               
002A87r 3  E8                           inx             ; 2DROP
002A88r 3  E8                           inx
002A89r 3  E8                           inx
002A8Ar 3  E8                           inx
002A8Br 3               
002A8Br 3  60           z_two_store:    rts
002A8Cr 3               
002A8Cr 3               
002A8Cr 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002A8Cr 3               ; ## "2swap"  auto  ANS core
002A8Cr 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002A8Cr 3               xt_two_swap:
002A8Cr 3  20 rr rr                     jsr underflow_4
002A8Fr 3               
002A8Fr 3                               ; 0 <-> 4
002A8Fr 3  B5 00                        lda 0,x
002A91r 3  B4 04                        ldy 4,x
002A93r 3  95 04                        sta 4,x
002A95r 3  94 00                        sty 0,x
002A97r 3               
002A97r 3                               ; 1 <-> 5
002A97r 3  B5 01                        lda 1,x
002A99r 3  B4 05                        ldy 5,x
002A9Br 3  95 05                        sta 5,x
002A9Dr 3  94 01                        sty 1,x
002A9Fr 3               
002A9Fr 3                               ; 2 <-> 6
002A9Fr 3  B5 02                        lda 2,x
002AA1r 3  B4 06                        ldy 6,x
002AA3r 3  95 06                        sta 6,x
002AA5r 3  94 02                        sty 2,x
002AA7r 3               
002AA7r 3                               ; 3 <-> 7
002AA7r 3  B5 03                        lda 3,x
002AA9r 3  B4 07                        ldy 7,x
002AABr 3  95 07                        sta 7,x
002AADr 3  94 03                        sty 3,x
002AAFr 3               
002AAFr 3  60           z_two_swap:     rts
002AB0r 3               
002AB0r 3               
002AB0r 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
002AB0r 3               ; ## "2>r"  auto  ANS core ext
002AB0r 3                       ; """https://forth-standard.org/standard/core/TwotoR
002AB0r 3                       ; Push top two entries to Return Stack.
002AB0r 3                       ;
002AB0r 3                       ; The same as SWAP >R >R
002AB0r 3                       ; except that if we jumped here, the return address will be in the
002AB0r 3                       ; way. May not be natively compiled unless we're clever and use
002AB0r 3                       ; special routines.
002AB0r 3                       ; """
002AB0r 3               xt_two_to_r:
002AB0r 3                               ; save the return address
002AB0r 3  68                           pla             ; LSB
002AB1r 3  85 rr                        sta tmp1
002AB3r 3  68                           pla             ; MSB
002AB4r 3  85 rr                        sta tmp1+1
002AB6r 3               
002AB6r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002AB6r 3               
002AB6r 3  20 rr rr                     jsr underflow_2
002AB9r 3               
002AB9r 3                               ; now we can move the data
002AB9r 3  B5 03                        lda 3,x         ; MSB
002ABBr 3  48                           pha
002ABCr 3  B5 02                        lda 2,x         ; LSB
002ABEr 3  48                           pha
002ABFr 3               
002ABFr 3                               ; now we can move the data
002ABFr 3  B5 01                        lda 1,x         ; MSB
002AC1r 3  48                           pha
002AC2r 3  B5 00                        lda 0,x         ; LSB
002AC4r 3  48                           pha
002AC5r 3               
002AC5r 3  E8                           inx
002AC6r 3  E8                           inx
002AC7r 3  E8                           inx
002AC8r 3  E8                           inx
002AC9r 3               
002AC9r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002AC9r 3               
002AC9r 3                               ; restore return address
002AC9r 3  A5 rr                        lda tmp1+1      ; MSB
002ACBr 3  48                           pha
002ACCr 3  A5 rr                        lda tmp1        ; LSB
002ACEr 3  48                           pha
002ACFr 3               
002ACFr 3  60           z_two_to_r:     rts
002AD0r 3               
002AD0r 3               
002AD0r 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
002AD0r 3               ; ## "2constant"  auto  ANS double
002AD0r 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
002AD0r 3                       ;
002AD0r 3                       ; Based on the Forth code
002AD0r 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
002AD0r 3                       ; """
002AD0r 3               xt_two_constant:
002AD0r 3  20 rr rr                     jsr underflow_2
002AD3r 3               
002AD3r 3  20 rr rr                     jsr xt_create
002AD6r 3  20 rr rr                     jsr xt_swap
002AD9r 3  20 rr rr                     jsr xt_comma
002ADCr 3  20 rr rr                     jsr xt_comma
002ADFr 3               
002ADFr 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002AE2r 3  20 rr rr                     jsr dodoes
002AE5r 3               
002AE5r 3  20 rr rr                     jsr xt_dup
002AE8r 3  20 rr rr                     jsr xt_fetch
002AEBr 3  20 rr rr                     jsr xt_swap
002AEEr 3  20 rr rr                     jsr xt_cell_plus
002AF1r 3  20 rr rr                     jsr xt_fetch
002AF4r 3               
002AF4r 3  60           z_two_constant: rts
002AF5r 3               
002AF5r 3               
002AF5r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002AF5r 3               ; ## "2literal"  auto  ANS double
002AF5r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002AF5r 3                       ; Based on the Forth code
002AF5r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002AF5r 3                       ; """
002AF5r 3               xt_two_literal:
002AF5r 3  20 rr rr                     jsr underflow_2 ; double number
002AF8r 3               
002AF8r 3  20 rr rr                     jsr xt_swap
002AFBr 3  20 rr rr                     jsr xt_literal
002AFEr 3  20 rr rr                     jsr xt_literal
002B01r 3               
002B01r 3  60           z_two_literal:  rts
002B02r 3               
002B02r 3               
002B02r 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002B02r 3               ; ## "2variable"  auto  ANS double
002B02r 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002B02r 3                       ; The variable is not initialized to zero.
002B02r 3                       ;
002B02r 3                       ; This can be realized in Forth as either
002B02r 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002B02r 3                       ; """
002B02r 3               xt_two_variable:
002B02r 3                               ; We just let CRATE and ALLOT do the heavy lifting
002B02r 3  20 rr rr                     jsr xt_create
002B05r 3               
002B05r 3  CA                           dex
002B06r 3  CA                           dex
002B07r 3  A9 04                        lda #4
002B09r 3  95 00                        sta 0,x
002B0Br 3  74 01                        stz 1,x
002B0Dr 3               
002B0Dr 3  20 rr rr                     jsr xt_allot
002B10r 3               
002B10r 3  60           z_two_variable: rts
002B11r 3               
002B11r 3               
002B11r 3               ; ## TYPE ( addr u -- ) "Print string"
002B11r 3               ; ## "type"  auto  ANS core
002B11r 3                       ; """https://forth-standard.org/standard/core/TYPE
002B11r 3                       ; Works through EMIT to allow OUTPUT revectoring.
002B11r 3                       ; """
002B11r 3               
002B11r 3               xt_type:
002B11r 3  20 rr rr                     jsr underflow_2
002B14r 3               
002B14r 3                               ; Save the starting address into tmp1
002B14r 3  B5 02                        lda 2,x
002B16r 3  85 rr                        sta tmp1
002B18r 3  B5 03                        lda 3,x
002B1Ar 3  85 rr                        sta tmp1+1
002B1Cr 3               @loop:
002B1Cr 3                               ; done if length is zero
002B1Cr 3  B5 00                        lda 0,x
002B1Er 3  15 01                        ora 1,x
002B20r 3  F0 15                        beq @done
002B22r 3               
002B22r 3                               ; Send the current character
002B22r 3  B2 rr                        lda (tmp1)
002B24r 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002B27r 3               
002B27r 3                               ; Move the address along (in tmp1)
002B27r 3  E6 rr                        inc tmp1
002B29r 3  D0 02                        bne @1
002B2Br 3  E6 rr                        inc tmp1+1
002B2Dr 3               @1:
002B2Dr 3                               ; Reduce the count (on the data stack)
002B2Dr 3  B5 00                        lda 0,x
002B2Fr 3  D0 02                        bne @2
002B31r 3  D6 01                        dec 1,x
002B33r 3               @2:
002B33r 3  D6 00                        dec 0,x
002B35r 3               
002B35r 3  80 E5                        bra @loop
002B37r 3               @done:
002B37r 3  E8                           inx
002B38r 3  E8                           inx
002B39r 3  E8                           inx
002B3Ar 3  E8                           inx
002B3Br 3               
002B3Br 3  60           z_type:         rts
002B3Cr 3               
002B3Cr 3               
002B3Cr 3               
002B3Cr 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002B3Cr 3               ; ## "u."  tested  ANS core
002B3Cr 3                       ; """https://forth-standard.org/standard/core/Ud
002B3Cr 3                       ;
002B3Cr 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002B3Cr 3                       ; We use the internal assembler function print_u followed
002B3Cr 3                       ; by a single space
002B3Cr 3                       ; """
002B3Cr 3               xt_u_dot:
002B3Cr 3  20 rr rr                     jsr underflow_1
002B3Fr 3               
002B3Fr 3  20 rr rr                     jsr print_u
002B42r 3  A9 20                        lda #AscSP
002B44r 3  20 rr rr                     jsr emit_a
002B47r 3               
002B47r 3  60           z_u_dot:        rts
002B48r 3               
002B48r 3               
002B48r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
002B48r 3               ; ## "u.r"  tested  ANS core ext
002B48r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
002B48r 3               xt_u_dot_r:
002B48r 3  20 rr rr                     jsr underflow_2
002B4Br 3               
002B4Br 3  20 rr rr                     jsr xt_to_r
002B4Er 3  20 rr rr                     jsr xt_zero
002B51r 3  20 rr rr                     jsr xt_less_number_sign
002B54r 3  20 rr rr                     jsr xt_number_sign_s
002B57r 3  20 rr rr                     jsr xt_number_sign_greater
002B5Ar 3  20 rr rr                     jsr xt_r_from
002B5Dr 3  20 rr rr                     jsr xt_over
002B60r 3  20 rr rr                     jsr xt_minus
002B63r 3  20 rr rr                     jsr xt_spaces
002B66r 3  20 rr rr                     jsr xt_type
002B69r 3               
002B69r 3  60           z_u_dot_r:      rts
002B6Ar 3               
002B6Ar 3               
002B6Ar 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002B6Ar 3               ; ## "u>"  auto  ANS core ext
002B6Ar 3                       ; """https://forth-standard.org/standard/core/Umore"""
002B6Ar 3               xt_u_greater_than:
002B6Ar 3  20 rr rr                     jsr underflow_2
002B6Dr 3               
002B6Dr 3  B5 00                        lda 0,x
002B6Fr 3  D5 02                        cmp 2,x
002B71r 3  B5 01                        lda 1,x
002B73r 3  F5 03                        sbc 3,x
002B75r 3  E8                           inx
002B76r 3  E8                           inx
002B77r 3               
002B77r 3  A9 00                        lda #0
002B79r 3  69 FF                        adc #$ff
002B7Br 3  95 00                        sta 0,x         ; store flag
002B7Dr 3  95 01                        sta 1,x
002B7Fr 3               
002B7Fr 3  60           z_u_greater_than:    rts
002B80r 3               
002B80r 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002B80r 3               ; ## "u<"  auto  ANS core
002B80r 3                       ; """https://forth-standard.org/standard/core/Uless"""
002B80r 3               xt_u_less_than:
002B80r 3  20 rr rr                     jsr underflow_2
002B83r 3               
002B83r 3  B5 02                        lda 2,x
002B85r 3  D5 00                        cmp 0,x
002B87r 3  B5 03                        lda 3,x
002B89r 3  F5 01                        sbc 1,x
002B8Br 3  E8                           inx
002B8Cr 3  E8                           inx
002B8Dr 3               
002B8Dr 3  A9 00                        lda #0
002B8Fr 3  69 FF                        adc #$ff
002B91r 3  95 00                        sta 0,x         ; store flag
002B93r 3  95 01                        sta 1,x
002B95r 3               
002B95r 3  60           z_u_less_than:    rts
002B96r 3               
002B96r 3               
002B96r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002B96r 3               ; ## "ud."  auto  Tali double
002B96r 3                       ;
002B96r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002B96r 3                       ; """
002B96r 3               xt_ud_dot:
002B96r 3  20 rr rr                     jsr underflow_2 ; double number
002B99r 3               
002B99r 3  20 rr rr                     jsr xt_less_number_sign
002B9Cr 3  20 rr rr                     jsr xt_number_sign_s
002B9Fr 3  20 rr rr                     jsr xt_number_sign_greater
002BA2r 3  20 rr rr                     jsr xt_type
002BA5r 3  20 rr rr                     jsr xt_space
002BA8r 3               
002BA8r 3  60           z_ud_dot:        rts
002BA9r 3               
002BA9r 3               
002BA9r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002BA9r 3               ; ## "ud.r"  auto  Tali double
002BA9r 3                       ;
002BA9r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002BA9r 3                       ; """
002BA9r 3               xt_ud_dot_r:
002BA9r 3  20 rr rr                     jsr underflow_3
002BACr 3               
002BACr 3  20 rr rr                     jsr xt_to_r
002BAFr 3  20 rr rr                     jsr xt_less_number_sign
002BB2r 3  20 rr rr                     jsr xt_number_sign_s
002BB5r 3  20 rr rr                     jsr xt_number_sign_greater
002BB8r 3  20 rr rr                     jsr xt_r_from
002BBBr 3  20 rr rr                     jsr xt_over
002BBEr 3  20 rr rr                     jsr xt_minus
002BC1r 3  20 rr rr                     jsr xt_spaces
002BC4r 3  20 rr rr                     jsr xt_type
002BC7r 3               
002BC7r 3  60           z_ud_dot_r:      rts
002BC8r 3               
002BC8r 3               
002BC8r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002BC8r 3               ; ## "um/mod"  auto  ANS core
002BC8r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002BC8r 3                       ; Divide double cell number by single cell number, returning the
002BC8r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002BC8r 3                       ; This is the basic division operation all others use. Based on FIG
002BC8r 3                       ; Forth code, modified by Garth Wilson, see
002BC8r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002BC8r 3                       ;
002BC8r 3                       ; This uses tmp1, tmp1+1, and tmptos
002BC8r 3                       ; """
002BC8r 3               
002BC8r 3               xt_um_slash_mod:
002BC8r 3  20 rr rr                     jsr underflow_3
002BCBr 3               
002BCBr 3                               ; catch division by zero
002BCBr 3  B5 00                        lda 0,x
002BCDr 3  15 01                        ora 1,x
002BCFr 3  D0 05                        bne @not_zero
002BD1r 3               
002BD1r 3  A9 04                        lda #err_divzero
002BD3r 3  4C rr rr                     jmp error
002BD6r 3               
002BD6r 3               @not_zero:
002BD6r 3                               ; We loop 17 times
002BD6r 3  A9 11                        lda #17
002BD8r 3  85 rr                        sta tmptos
002BDAr 3               
002BDAr 3               @loop:
002BDAr 3                               ; rotate low cell of dividend one bit left (LSB)
002BDAr 3  36 04                        rol 4,x
002BDCr 3  36 05                        rol 5,x
002BDEr 3               
002BDEr 3                               ; loop control
002BDEr 3  C6 rr                        dec tmptos
002BE0r 3  F0 22                        beq @done
002BE2r 3               
002BE2r 3                               ; rotate high cell of dividend one bit left (MSB)
002BE2r 3  36 02                        rol 2,x
002BE4r 3  36 03                        rol 3,x
002BE6r 3               
002BE6r 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
002BE8r 3  26 rr                        rol tmp1
002BEAr 3               
002BEAr 3                               ; subtract dividend hi cell minus divisor
002BEAr 3  38                           sec
002BEBr 3  B5 02                        lda 2,x
002BEDr 3  F5 00                        sbc 0,x
002BEFr 3  85 rr                        sta tmp1+1
002BF1r 3  B5 03                        lda 3,x
002BF3r 3  F5 01                        sbc 1,x
002BF5r 3               
002BF5r 3  A8                           tay
002BF6r 3  A5 rr                        lda tmp1
002BF8r 3  E9 00                        sbc #0
002BFAr 3  90 DE                        bcc @loop
002BFCr 3               
002BFCr 3                               ; make result new dividend high cell
002BFCr 3  A5 rr                        lda tmp1+1
002BFEr 3  95 02                        sta 2,x
002C00r 3  94 03                        sty 3,x         ; used as temp storage
002C02r 3               
002C02r 3  80 D6                        bra @loop
002C04r 3               @done:
002C04r 3  E8                           inx
002C05r 3  E8                           inx
002C06r 3               
002C06r 3  20 rr rr                     jsr xt_swap
002C09r 3               
002C09r 3  60           z_um_slash_mod: rts
002C0Ar 3               
002C0Ar 3               
002C0Ar 3               
002C0Ar 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002C0Ar 3               ; ## "um*"  auto  ANS core
002C0Ar 3                       ; """https://forth-standard.org/standard/core/UMTimes
002C0Ar 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002C0Ar 3                       ; Old Forth versions such as FIG Forth call this U*
002C0Ar 3                       ;
002C0Ar 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002C0Ar 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002C0Ar 3                       ; discussion.
002C0Ar 3                       ;
002C0Ar 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002C0Ar 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002C0Ar 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002C0Ar 3                       ;
002C0Ar 3                       ; Consider switching to a table-supported version based on
002C0Ar 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002C0Ar 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002C0Ar 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002C0Ar 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002C0Ar 3                       ; """
002C0Ar 3               
002C0Ar 3               xt_um_star:
002C0Ar 3  20 rr rr                     jsr underflow_2
002C0Dr 3               
002C0Dr 3                               ; to eliminate clc inside the loop, the value at
002C0Dr 3                               ; tmp1 is reduced by 1 in advance
002C0Dr 3  18                           clc
002C0Er 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002C10r 3  E9 00                        sbc #0
002C12r 3  85 rr                        sta tmp2
002C14r 3               
002C14r 3  B5 01                        lda 1,x
002C16r 3  E9 00                        sbc #0
002C18r 3  90 31                        bcc @zero       ; is TOS zero?
002C1Ar 3  85 rr                        sta tmp2+1
002C1Cr 3               
002C1Cr 3  A9 00                        lda #0
002C1Er 3  85 rr                        sta tmp1
002C20r 3  86 rr                        stx tmp3        ; tested for exit from outer loop
002C22r 3  CA                           dex
002C23r 3  CA                           dex
002C24r 3               
002C24r 3               @outer_loop:
002C24r 3  A0 08                        ldy #8          ; counter inner loop
002C26r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002C28r 3               
002C28r 3               @inner_loop:
002C28r 3  90 0C                        bcc @no_add
002C2Ar 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002C2Cr 3  A5 rr                        lda tmp1
002C2Er 3  65 rr                        adc tmp2
002C30r 3  85 rr                        sta tmp1
002C32r 3  A5 rr                        lda tmp1+1
002C34r 3  65 rr                        adc tmp2+1
002C36r 3               
002C36r 3               @no_add:
002C36r 3  6A                           ror
002C37r 3  66 rr                        ror tmp1
002C39r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002C3Br 3               
002C3Br 3  88                           dey
002C3Cr 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002C3Er 3               
002C3Er 3  E8                           inx
002C3Fr 3  E4 rr                        cpx tmp3
002C41r 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002C43r 3               
002C43r 3                               ; all done, store high word of result
002C43r 3  95 01                        sta 1,x
002C45r 3  A5 rr                        lda tmp1
002C47r 3  95 00                        sta 0,x
002C49r 3  80 04                        bra @done
002C4Br 3               
002C4Br 3               @zero:
002C4Br 3  74 02                        stz 2,x
002C4Dr 3  74 03                        stz 3,x
002C4Fr 3               @done:
002C4Fr 3  60           z_um_star:      rts
002C50r 3               
002C50r 3               
002C50r 3               
002C50r 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002C50r 3               ; ## "unloop"  auto  ANS core
002C50r 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002C50r 3                       ;
002C50r 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002C50r 3                       ; """
002C50r 3               xt_unloop:
002C50r 3                               ; Drop fudge number (limit/start from DO/?DO off the
002C50r 3                               ; return stack
002C50r 3  68                           pla
002C51r 3  68                           pla
002C52r 3  68                           pla
002C53r 3  68                           pla
002C54r 3               
002C54r 3                               ; Now drop the LEAVE address that was below them off
002C54r 3                               ; the Return Stack as well
002C54r 3  68                           pla
002C55r 3  68                           pla
002C56r 3               
002C56r 3  60           z_unloop:       rts
002C57r 3               
002C57r 3               
002C57r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
002C57r 3               ; ## "until"  auto  ANS core
002C57r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
002C57r 3               xt_until:
002C57r 3                               ; Compile a 0BRANCH
002C57r 3  A0 rr                        ldy #>zero_branch_runtime
002C59r 3  A9 rr                        lda #<zero_branch_runtime
002C5Br 3  20 rr rr                     jsr cmpl_subroutine
002C5Er 3               
002C5Er 3                               ; The address to loop back to is on the stack.
002C5Er 3                               ; Just compile it as the destination for the
002C5Er 3                               ; 0branch.
002C5Er 3  20 rr rr                     jsr xt_comma
002C61r 3               
002C61r 3  60           z_until:        rts
002C62r 3               
002C62r 3               
002C62r 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
002C62r 3               ; ## "unused"  auto  ANS core ext
002C62r 3                       ; """https://forth-standard.org/standard/core/UNUSED
002C62r 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
002C62r 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
002C62r 3                       ; defaults to $400
002C62r 3                       ; """
002C62r 3               xt_unused:
002C62r 3  CA                           dex
002C63r 3  CA                           dex
002C64r 3               
002C64r 3  A9 FF                        lda #<cp_end
002C66r 3  38                           sec
002C67r 3  E5 rr                        sbc cp
002C69r 3  95 00                        sta 0,x
002C6Br 3               
002C6Br 3  A9 7F                        lda #>cp_end
002C6Dr 3  E5 rr                        sbc cp+1
002C6Fr 3  95 01                        sta 1,x
002C71r 3               
002C71r 3  60           z_unused:       rts
002C72r 3               
002C72r 3               
002C72r 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
002C72r 3               ; ## "update"  auto  ANS block
002C72r 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
002C72r 3               xt_update:
002C72r 3                               ; Turn on the dirty bit. We can't use TSB here because it only
002C72r 3                               ; has Absolute and Direct Pages addressing modes
002C72r 3  A0 2C                        ldy #buffstatus_offset
002C74r 3  B1 rr                        lda (up),y
002C76r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
002C78r 3  91 rr                        sta (up),y
002C7Ar 3               
002C7Ar 3  60           z_update:       rts
002C7Br 3               
002C7Br 3               
002C7Br 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
002C7Br 3               ; ## "useraddr"  tested  Tali Forth
002C7Br 3               xt_useraddr:
002C7Br 3  CA                           dex
002C7Cr 3  CA                           dex
002C7Dr 3  A9 rr                        lda #<up
002C7Fr 3  95 00                        sta 0,x
002C81r 3  A9 rr                        lda #>up
002C83r 3  95 01                        sta 1,x
002C85r 3               
002C85r 3  60           z_useraddr:     rts
002C86r 3               
002C86r 3               
002C86r 3               ; ## VALUE ( n "name" -- ) "Define a value"
002C86r 3               ; ## "value"  auto  ANS core
002C86r 3                       ; """https://forth-standard.org/standard/core/VALUE
002C86r 3                       ;
002C86r 3                       ; This is a dummy header for the WORDLIST. The actual code is
002C86r 3                       ; identical to that of CONSTANT
002C86r 3                       ; """
002C86r 3               
002C86r 3               
002C86r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
002C86r 3               ; ## "variable"  auto  ANS core
002C86r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
002C86r 3                       ; There are various Forth definitions for this word, such as
002C86r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
002C86r 3                       ; second one so the variable is initialized to zero
002C86r 3                       ; """
002C86r 3               xt_variable:
002C86r 3                               ; we let CREATE do the heavy lifting
002C86r 3  20 rr rr                     jsr xt_create
002C89r 3               
002C89r 3                               ; there is no "STZ (CP)" so we have to do this the hard
002C89r 3                               ; way
002C89r 3  A9 00                        lda #0
002C8Br 3               
002C8Br 3  92 rr                        sta (cp)
002C8Dr 3  E6 rr                        inc cp
002C8Fr 3  D0 02                        bne @1
002C91r 3  E6 rr                        inc cp+1
002C93r 3               @1:
002C93r 3  92 rr                        sta (cp)
002C95r 3  E6 rr                        inc cp
002C97r 3  D0 02                        bne @2
002C99r 3  E6 rr                        inc cp+1
002C9Br 3               @2:
002C9Br 3                               ; Now we need to adjust the length of the complete word by two
002C9Br 3  20 rr rr                     jsr adjust_z
002C9Er 3               
002C9Er 3  60           z_variable:     rts
002C9Fr 3               
002C9Fr 3               
002C9Fr 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
002C9Fr 3               ; ## "while"  auto  ANS core
002C9Fr 3                       ; """http://forth-standard.org/standard/core/WHILE"""
002C9Fr 3               xt_while:
002C9Fr 3                               ; Compile a 0branch
002C9Fr 3  A0 rr                        ldy #>zero_branch_runtime
002CA1r 3  A9 rr                        lda #<zero_branch_runtime
002CA3r 3  20 rr rr                     jsr cmpl_subroutine
002CA6r 3               
002CA6r 3                               ; Put the address (here) where the destination
002CA6r 3                               ; address needs to go so it can be put there later.
002CA6r 3  20 rr rr                     jsr xt_here
002CA9r 3               
002CA9r 3                               ; Fill in the destination address with 0 for now.
002CA9r 3  20 rr rr                     jsr xt_zero
002CACr 3  20 rr rr                     jsr xt_comma
002CAFr 3               
002CAFr 3                               ; Swap the two addresses on the stack.
002CAFr 3  20 rr rr                     jsr xt_swap
002CB2r 3               
002CB2r 3  60           z_while:        rts
002CB3r 3               
002CB3r 3               
002CB3r 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
002CB3r 3               ; ## "within"  auto  ANS core ext
002CB3r 3                       ; """https://forth-standard.org/standard/core/WITHIN
002CB3r 3                       ;
002CB3r 3                       ; This an assembler version of the ANS Forth implementation
002CB3r 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
002CB3r 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
002CB3r 3                       ; ROT TUCK > -ROT > INVERT AND
002CB3r 3                       ; """"
002CB3r 3               xt_within:
002CB3r 3  20 rr rr                     jsr underflow_3
002CB6r 3               
002CB6r 3  20 rr rr                     jsr xt_over
002CB9r 3  20 rr rr                     jsr xt_minus
002CBCr 3  20 rr rr                     jsr xt_to_r
002CBFr 3  20 rr rr                     jsr xt_minus
002CC2r 3  20 rr rr                     jsr xt_r_from
002CC5r 3  20 rr rr                     jsr xt_u_less_than
002CC8r 3               
002CC8r 3  60           z_within:       rts
002CC9r 3               
002CC9r 3               
002CC9r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002CC9r 3               ; ## "word"  auto  ANS core
002CC9r 3                       ; """https://forth-standard.org/standard/core/WORD
002CC9r 3                       ; Obsolete parsing word included for backwards compatibility only.
002CC9r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002CC9r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002CC9r 3                       ; Returns the result as a counted string (requires COUNT to convert
002CC9r 3                       ; to modern format), and inserts a space after the string. See "Forth
002CC9r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002CC9r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002CC9r 3                       ; for discussions of why you shouldn't be using WORD anymore.
002CC9r 3                       ;
002CC9r 3                       ; Forth
002CC9r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002CC9r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002CC9r 3                       ; """
002CC9r 3               
002CC9r 3               xt_word:
002CC9r 3  20 rr rr                     jsr underflow_1
002CCCr 3               
002CCCr 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
002CCCr 3                               ; but unlike PARSE
002CCCr 3  A4 rr                        ldy toin                ; >IN
002CCEr 3               @loop:
002CCEr 3  C4 rr                        cpy ciblen              ; quit if end of input
002CD0r 3  F0 09                        beq @found_char
002CD2r 3  B1 rr                        lda (cib),y
002CD4r 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002CD6r 3  D0 03                        bne @found_char
002CD8r 3               
002CD8r 3  C8                           iny
002CD9r 3  80 F3                        bra @loop
002CDBr 3               @found_char:
002CDBr 3                               ; Save index of where word starts
002CDBr 3  84 rr                        sty toin
002CDDr 3               
002CDDr 3                               ; The real work is done by parse
002CDDr 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
002CE0r 3               
002CE0r 3                               ; Convert the modern ( addr u ) string format to obsolete
002CE0r 3                               ; ( caddr ) format. We just do this in the Dictionary
002CE0r 3  B5 00                        lda 0,x
002CE2r 3  92 rr                        sta (cp)                ; Save length of string
002CE4r 3  48                           pha                     ; Keep copy of length for later
002CE5r 3               
002CE5r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002CE8r 3  A5 rr                        lda cp
002CEAr 3  18                           clc
002CEBr 3  69 01                        adc #1
002CEDr 3  95 02                        sta 2,x                 ; LSB of CP
002CEFr 3  A5 rr                        lda cp+1
002CF1r 3  69 00                        adc #0
002CF3r 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002CF5r 3               
002CF5r 3  20 rr rr                     jsr xt_move
002CF8r 3               
002CF8r 3                               ; Return caddr
002CF8r 3  CA                           dex
002CF9r 3  CA                           dex
002CFAr 3  A5 rr                        lda cp
002CFCr 3  95 00                        sta 0,x
002CFEr 3  A5 rr                        lda cp+1
002D00r 3  95 01                        sta 1,x
002D02r 3               
002D02r 3                               ; Adjust CP
002D02r 3  68                           pla                     ; length of string
002D03r 3  18                           clc
002D04r 3  65 rr                        adc cp
002D06r 3  85 rr                        sta cp
002D08r 3  A5 rr                        lda cp+1
002D0Ar 3  69 00                        adc #0                  ; we only need the carry
002D0Cr 3  85 rr                        sta cp+1
002D0Er 3  60           z_word:         rts
002D0Fr 3               
002D0Fr 3               
002D0Fr 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
002D0Fr 3               ; ## "wordlist" auto ANS search
002D0Fr 3                       ; """https://forth-standard.org/standard/search/WORDLIST
002D0Fr 3                       ; See the tutorial on Wordlists and the Search Order for
002D0Fr 3                       ; more information.
002D0Fr 3                       ; """
002D0Fr 3               
002D0Fr 3               xt_wordlist:
002D0Fr 3                               ; Get the current number of wordlists
002D0Fr 3  A0 05                        ldy #num_wordlists_offset
002D11r 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
002D13r 3                                               ; the LSB needs to be checked.
002D13r 3               
002D13r 3                               ; See if we are already at the max.
002D13r 3  C9 0C                        cmp #max_wordlists
002D15r 3  D0 05                        bne @ok
002D17r 3               
002D17r 3                               ; Print an error message if all wordlists used.
002D17r 3  A9 0B                        lda #err_wordlist
002D19r 3  4C rr rr                     jmp error
002D1Cr 3               
002D1Cr 3               @ok:
002D1Cr 3  1A                           inc             ; Increment the wordlist#
002D1Dr 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
002D1Fr 3  CA                           dex             ; and put it on the stack.
002D20r 3  CA                           dex
002D21r 3  95 00                        sta 0,x
002D23r 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002D25r 3               
002D25r 3  60           z_wordlist:     rts
002D26r 3               
002D26r 3               
002D26r 3               
002D26r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002D26r 3               ; ## "words"  tested  ANS tools
002D26r 3                       ; """https://forth-standard.org/standard/tools/WORDS
002D26r 3                       ; This is pretty much only used at the command line so we can
002D26r 3                       ; be slow and try to save space.
002D26r 3                       ; """
002D26r 3               
002D26r 3               xt_words:
002D26r 3                               ; we follow Gforth by starting on the next
002D26r 3                               ; line
002D26r 3  20 rr rr                     jsr xt_cr
002D29r 3               
002D29r 3                               ; We pretty-format the output by inserting a line break
002D29r 3                               ; before the end of the line. We can get away with pushing
002D29r 3                               ; the counter to the stack because this is usually an
002D29r 3                               ; interactive word and speed is not that important
002D29r 3  A9 00                        lda #0
002D2Br 3  48                           pha
002D2Cr 3               
002D2Cr 3                               ; Set up for traversing the wordlist search order.
002D2Cr 3  CA                           dex                     ; Make room on the stack for
002D2Dr 3  CA                           dex                     ; a dictionary pointer.
002D2Er 3  64 rr                        stz tmp3                ; Start at the beginning of
002D30r 3                                                       ; the search order.
002D30r 3               @wordlist_loop:
002D30r 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
002D32r 3  A5 rr                        lda tmp3
002D34r 3  D1 rr                        cmp (up),y              ; See if we are done.
002D36r 3  D0 02                        bne @have_wordlist
002D38r 3               
002D38r 3                               ; We ran out of wordlists to search.
002D38r 3  80 44                        bra @words_done
002D3Ar 3               
002D3Ar 3               @have_wordlist:
002D3Ar 3                               ; start with last word in Dictionary
002D3Ar 3                               ; Get the current wordlist id
002D3Ar 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
002D3Br 3  69 1F                        adc #search_order_offset
002D3Dr 3  A8                           tay
002D3Er 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
002D40r 3               
002D40r 3                               ; Get the DP for that wordlist.
002D40r 3  0A                           asl                     ; Turn offset into cells offset.
002D41r 3  18                           clc
002D42r 3  69 06                        adc #wordlists_offset
002D44r 3  A8                           tay
002D45r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
002D47r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
002D49r 3  C8                           iny
002D4Ar 3  B1 rr                        lda (up),y
002D4Cr 3  95 01                        sta 1,x
002D4Er 3               
002D4Er 3               @loop:
002D4Er 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002D51r 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
002D54r 3               
002D54r 3                               ; Insert line break if we're about to go past the end of the
002D54r 3                               ; line
002D54r 3  68                           pla
002D55r 3  18                           clc
002D56r 3  75 00                        adc 0,x
002D58r 3  1A                           inc                     ; don't forget the space between words
002D59r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
002D5Br 3  90 05                        bcc @1
002D5Dr 3               
002D5Dr 3  20 rr rr                     jsr xt_cr
002D60r 3  A9 00                        lda #0
002D62r 3               @1:
002D62r 3  48                           pha
002D63r 3  20 rr rr                     jsr xt_type             ; ( nt )
002D66r 3               
002D66r 3  A9 20                        lda #AscSP
002D68r 3  20 rr rr                     jsr emit_a
002D6Br 3               
002D6Br 3                               ; get next word, which begins two down
002D6Br 3  20 rr rr                     jsr xt_one_plus         ; 1+
002D6Er 3  20 rr rr                     jsr xt_one_plus         ; 1+
002D71r 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
002D74r 3               
002D74r 3                               ; if next address is zero, we're done
002D74r 3  B5 00                        lda 0,x
002D76r 3  15 01                        ora 1,x
002D78r 3  D0 D4                        bne @loop
002D7Ar 3               
002D7Ar 3                               ; Move on to the next wordlist in the search order.
002D7Ar 3  E6 rr                        inc tmp3
002D7Cr 3  80 B2                        bra @wordlist_loop
002D7Er 3               
002D7Er 3               @words_done:
002D7Er 3  68                           pla                     ; dump counter
002D7Fr 3               
002D7Fr 3  E8                           inx
002D80r 3  E8                           inx
002D81r 3               
002D81r 3  60           z_words:        rts
002D82r 3               
002D82r 3               
002D82r 3               
002D82r 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
002D82r 3               ; ## "wordsize"  auto  Tali Forth
002D82r 3                       ; """Given an word's name token (nt), return the size of the
002D82r 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
002D82r 3                       ; count the final RTS.
002D82r 3                       ; """
002D82r 3               xt_wordsize:
002D82r 3  20 rr rr                     jsr underflow_1
002D85r 3               
002D85r 3                               ; We get the start address of the word from its header entry
002D85r 3                               ; for the start of the actual code (execution token, xt)
002D85r 3                               ; which is four bytes down, and the pointer to the end of the
002D85r 3                               ; code (z_word, six bytes down)
002D85r 3  B5 00                        lda 0,x
002D87r 3  85 rr                        sta tmp1
002D89r 3  B5 01                        lda 1,x
002D8Br 3  85 rr                        sta tmp1+1
002D8Dr 3               
002D8Dr 3  A0 06                        ldy #6
002D8Fr 3  B1 rr                        lda (tmp1),y    ; LSB of z
002D91r 3  88                           dey
002D92r 3  88                           dey
002D93r 3               
002D93r 3  38                           sec
002D94r 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
002D96r 3  95 00                        sta 0,x
002D98r 3               
002D98r 3  A0 07                        ldy #7
002D9Ar 3  B1 rr                        lda (tmp1),y    ; MSB of z
002D9Cr 3  88                           dey
002D9Dr 3  88                           dey
002D9Er 3               
002D9Er 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
002DA0r 3  95 01                        sta 1,x
002DA2r 3               
002DA2r 3  60           z_wordsize:     rts
002DA3r 3               
002DA3r 3               
002DA3r 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
002DA3r 3               ; ## "xor"  auto  ANS core
002DA3r 3                       ; """https://forth-standard.org/standard/core/XOR"""
002DA3r 3               xt_xor:
002DA3r 3  20 rr rr                     jsr underflow_2
002DA6r 3               
002DA6r 3  B5 00                        lda 0,x
002DA8r 3  55 02                        eor 2,x
002DAAr 3  95 02                        sta 2,x
002DACr 3               
002DACr 3  B5 01                        lda 1,x
002DAEr 3  55 03                        eor 3,x
002DB0r 3  95 03                        sta 3,x
002DB2r 3               
002DB2r 3  E8                           inx
002DB3r 3  E8                           inx
002DB4r 3               
002DB4r 3  60           z_xor:          rts
002DB5r 3               
002DB5r 3               
002DB5r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002DB5r 3               ; ## "0"  auto  Tali Forth
002DB5r 3                       ; """The disassembler assumes that this routine does not use Y. Note
002DB5r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002DB5r 3                       ; is 0."""
002DB5r 3               xt_case:
002DB5r 3               xt_forth_wordlist:
002DB5r 3               xt_zero:
002DB5r 3  CA                           dex             ; push
002DB6r 3  CA                           dex
002DB7r 3  74 00                        stz 0,x
002DB9r 3  74 01                        stz 1,x
002DBBr 3               z_case:
002DBBr 3               z_forth_wordlist:
002DBBr 3               z_zero:
002DBBr 3  60                           rts
002DBCr 3               
002DBCr 3               
002DBCr 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
002DBCr 3               ; ## "0="  auto  ANS core
002DBCr 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
002DBCr 3               
002DBCr 3               xt_zero_equal:
002DBCr 3  20 rr rr                     jsr underflow_1
002DBFr 3               
002DBFr 3  B5 00                        lda 0,x
002DC1r 3  15 01                        ora 1,x
002DC3r 3  F0 04                        beq @zero
002DC5r 3               
002DC5r 3                               ; not a zero, so we need a FALSE flag (0)
002DC5r 3  A9 00                        lda #0
002DC7r 3  80 02                        bra @store
002DC9r 3               @zero:
002DC9r 3                               ; We have a zero, so we need a TRUE flag (-1)
002DC9r 3  A9 FF                        lda #$ff
002DCBr 3               @store:
002DCBr 3  95 00                        sta 0,x
002DCDr 3  95 01                        sta 1,x
002DCFr 3               
002DCFr 3  60           z_zero_equal:   rts
002DD0r 3               
002DD0r 3               
002DD0r 3               
002DD0r 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
002DD0r 3               ; ## "0>"  auto  ANS core ext
002DD0r 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
002DD0r 3               
002DD0r 3               xt_zero_greater:
002DD0r 3  20 rr rr                     jsr underflow_1
002DD3r 3               
002DD3r 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002DD5r 3               
002DD5r 3  B5 01                        lda 1,x         ; MSB
002DD7r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002DD9r 3  15 00                        ora 0,x
002DDBr 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
002DDDr 3               
002DDDr 3  88                           dey             ; TOS is postive, make true
002DDEr 3               @done:
002DDEr 3  98                           tya
002DDFr 3  95 00                        sta 0,x
002DE1r 3  95 01                        sta 1,x
002DE3r 3               
002DE3r 3  60           z_zero_greater: rts
002DE4r 3               
002DE4r 3               
002DE4r 3               
002DE4r 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
002DE4r 3               ; ## "0<"  auto  ANS core
002DE4r 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
002DE4r 3               
002DE4r 3               xt_zero_less:
002DE4r 3  20 rr rr                     jsr underflow_1
002DE7r 3               
002DE7r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002DE9r 3               
002DE9r 3  B5 01                        lda 1,x         ; MSB
002DEBr 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
002DEDr 3               
002DEDr 3  88                           dey             ; TOS is negative, make TRUE
002DEEr 3               @done:
002DEEr 3  98                           tya
002DEFr 3  95 00                        sta 0,x
002DF1r 3  95 01                        sta 1,x
002DF3r 3               
002DF3r 3  60           z_zero_less:    rts
002DF4r 3               
002DF4r 3               
002DF4r 3               
002DF4r 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
002DF4r 3               ; ## "0<>"  auto  ANS core ext
002DF4r 3                       ; """https://forth-standard.org/standard/core/Zerone"""
002DF4r 3               
002DF4r 3               xt_zero_unequal:
002DF4r 3  20 rr rr                     jsr underflow_1
002DF7r 3               
002DF7r 3  A0 00                        ldy #0          ; default false
002DF9r 3               
002DF9r 3  B5 00                        lda 0,x
002DFBr 3  15 01                        ora 1,x
002DFDr 3  F0 01                        beq @got_zero
002DFFr 3               
002DFFr 3  88                           dey
002E00r 3               @got_zero:
002E00r 3  98                           tya
002E01r 3  95 00                        sta 0,x
002E03r 3  95 01                        sta 1,x
002E05r 3               
002E05r 3  60           z_zero_unequal: rts
002E06r 3               
002E06r 3               
002E06r 3               
002E06r 3               ; ==========================================================
002E06r 3               ; EDITOR words
002E06r 3               
002E06r 3               ; This routine is used by both enter-screen and erase-screen
002E06r 3               ; to get a buffer for the given screen number and set SCR to
002E06r 3               ; the given screen number.  This word is not in the dictionary.
002E06r 3               xt_editor_screen_helper:
002E06r 3  20 rr rr                     jsr xt_dup
002E09r 3  20 rr rr                     jsr xt_scr
002E0Cr 3  20 rr rr                     jsr xt_store
002E0Fr 3  20 rr rr                     jsr xt_buffer
002E12r 3               z_editor_screen_helper:
002E12r 3  60                           rts
002E13r 3               
002E13r 3               
002E13r 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
002E13r 3               ; ## "enter-screen"  auto  Tali Editor
002E13r 3               
002E13r 3               xt_editor_enter_screen:
002E13r 3                               ; Set the variable SCR and get a buffer for the
002E13r 3                               ; given screen number.
002E13r 3  20 rr rr                     jsr xt_editor_screen_helper
002E16r 3               
002E16r 3                               ; Drop the buffer address.
002E16r 3  20 rr rr                     jsr xt_drop
002E19r 3               
002E19r 3                               ; Overwrite the lines one at a time.
002E19r 3  64 rr                        stz editor1
002E1Br 3               @prompt_loop:
002E1Br 3                               ; Put the current line number on the stack.
002E1Br 3  CA                           dex
002E1Cr 3  CA                           dex
002E1Dr 3  A5 rr                        lda editor1
002E1Fr 3  95 00                        sta 0,x
002E21r 3  74 01                        stz 1,x
002E23r 3               
002E23r 3                               ; Use the O word to prompt for overwrite.
002E23r 3  20 rr rr                     jsr xt_editor_o
002E26r 3               
002E26r 3                               ; Move on to the next line.
002E26r 3  E6 rr                        inc editor1
002E28r 3  A9 10                        lda #16
002E2Ar 3  C5 rr                        cmp editor1
002E2Cr 3  D0 ED                        bne @prompt_loop
002E2Er 3               
002E2Er 3               z_editor_enter_screen:
002E2Er 3  60                           rts
002E2Fr 3               
002E2Fr 3               
002E2Fr 3               
002E2Fr 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
002E2Fr 3               ; ## "erase-screen"  tested  Tali Editor
002E2Fr 3               xt_editor_erase_screen:
002E2Fr 3                               ; Set the variable SCR and get a buffer for the
002E2Fr 3                               ; given screen number.
002E2Fr 3  20 rr rr                     jsr xt_editor_screen_helper
002E32r 3               
002E32r 3                               ; Put 1024 (chars/screen) on stack.
002E32r 3  CA                           dex
002E33r 3  CA                           dex
002E34r 3  74 00                        stz 0,x
002E36r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
002E38r 3  95 01                        sta 1,x
002E3Ar 3               
002E3Ar 3                               ; Erase the entire block (fill with spaces).
002E3Ar 3  20 rr rr                     jsr xt_blank
002E3Dr 3               
002E3Dr 3                               ; Mark buffer as updated.
002E3Dr 3  20 rr rr                     jsr xt_update
002E40r 3               
002E40r 3               z_editor_erase_screen:
002E40r 3  60                           rts
002E41r 3               
002E41r 3               
002E41r 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
002E41r 3               ; ## "el"  tested  Tali Editor
002E41r 3               xt_editor_el:
002E41r 3                               ; Turn the line number into buffer offset.
002E41r 3                               ; This also loads the block into the buffer if it's
002E41r 3                               ; not there for some reason.
002E41r 3  20 rr rr                     jsr xt_editor_line
002E44r 3               
002E44r 3                               ; Put 64 (# of chars/line) on the stack.
002E44r 3  CA                           dex
002E45r 3  CA                           dex
002E46r 3  A9 40                        lda #64
002E48r 3  95 00                        sta 0,x
002E4Ar 3  74 01                        stz 1,x
002E4Cr 3               
002E4Cr 3                               ; Fill with spaces.
002E4Cr 3  20 rr rr                     jsr xt_blank
002E4Fr 3               
002E4Fr 3                               ; Mark buffer as updated.
002E4Fr 3  20 rr rr                     jsr xt_update
002E52r 3               
002E52r 3  60           z_editor_el:    rts
002E53r 3               
002E53r 3               
002E53r 3               ; ## EDITOR_L ( -- ) "List the current screen"
002E53r 3               ; ## "l"  tested  Tali Editor
002E53r 3               
002E53r 3               xt_editor_l:
002E53r 3                               ; Load the current screen
002E53r 3  CA                           dex             ; Put SCR on the stack.
002E54r 3  CA                           dex
002E55r 3  A0 02                        ldy #scr_offset
002E57r 3  B1 rr                        lda (up),y
002E59r 3  95 00                        sta 0,x
002E5Br 3  C8                           iny
002E5Cr 3  B1 rr                        lda (up),y
002E5Er 3  95 01                        sta 1,x
002E60r 3  20 rr rr                     jsr xt_block    ; Get the current screen.
002E63r 3               
002E63r 3  20 rr rr                     jsr xt_cr
002E66r 3               
002E66r 3                               ; Print the screen number.
002E66r 3                               ; We're using sliteral, so we need to set up the
002E66r 3                               ; appropriate data structure (see sliteral)
002E66r 3  80 08                        bra @after_screen_msg
002E68r 3               
002E68r 3               @screen_msg:
002E68r 3  53 63 72 65                  .byte "Screen #"
002E6Cr 3  65 6E 20 23  
002E70r 3               
002E70r 3               @after_screen_msg:
002E70r 3  20 rr rr                     jsr sliteral_runtime
002E73r 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
002E77r 3               
002E77r 3  20 rr rr                     jsr xt_type
002E7Ar 3               
002E7Ar 3                               ; Put the screen number and printed size for u.r on the stack.
002E7Ar 3  20 rr rr                     jsr xt_scr
002E7Dr 3  20 rr rr                     jsr xt_fetch
002E80r 3  CA                           dex
002E81r 3  CA                           dex
002E82r 3  A9 04                        lda #4          ; four spaces
002E84r 3  95 00                        sta 0,x
002E86r 3  74 01                        stz 1,x
002E88r 3  20 rr rr                     jsr xt_u_dot_r
002E8Br 3               
002E8Br 3                               ; The address of the buffer is currently on the stack.
002E8Br 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
002E8Br 3                               ; keep track of the line number in tmp3.
002E8Br 3  64 rr                        stz tmp3
002E8Dr 3               
002E8Dr 3               @line_loop:
002E8Dr 3  20 rr rr                     jsr xt_cr
002E90r 3               
002E90r 3                               ; Print the line number (2-space fixed width)
002E90r 3  CA                           dex
002E91r 3  CA                           dex
002E92r 3  CA                           dex
002E93r 3  CA                           dex
002E94r 3  74 03                        stz 3,x
002E96r 3  A5 rr                        lda tmp3
002E98r 3  95 02                        sta 2,x
002E9Ar 3  74 01                        stz 1,x
002E9Cr 3  A9 02                        lda #2
002E9Er 3  95 00                        sta 0,x
002EA0r 3  20 rr rr                     jsr xt_u_dot_r
002EA3r 3  20 rr rr                     jsr xt_space
002EA6r 3               
002EA6r 3                               ; Print one line using the address on the stack.
002EA6r 3  20 rr rr                     jsr xt_dup
002EA9r 3  CA                           dex
002EAAr 3  CA                           dex
002EABr 3  A9 40                        lda #64
002EADr 3  95 00                        sta 0,x
002EAFr 3  74 01                        stz 1,x
002EB1r 3  20 rr rr                     jsr xt_type
002EB4r 3               
002EB4r 3                               ; Add 64 to the address on the stack to move to the next line.
002EB4r 3  18                           clc
002EB5r 3  A9 40                        lda #64
002EB7r 3  75 00                        adc 0,x
002EB9r 3  95 00                        sta 0,x
002EBBr 3  B5 01                        lda 1,x
002EBDr 3  69 00                        adc #0      ; Add carry
002EBFr 3  95 01                        sta 1,x
002EC1r 3               
002EC1r 3                               ; Increment the line number (held in tmp3)
002EC1r 3  E6 rr                        inc tmp3
002EC3r 3               
002EC3r 3                               ; See if we are done.
002EC3r 3  A5 rr                        lda tmp3
002EC5r 3  C9 10                        cmp #16
002EC7r 3  D0 C4                        bne @line_loop
002EC9r 3               
002EC9r 3  20 rr rr                     jsr xt_cr
002ECCr 3                               ; Drop the address on the stack.
002ECCr 3  E8                           inx
002ECDr 3  E8                           inx
002ECEr 3               
002ECEr 3  60           z_editor_l:            rts
002ECFr 3               
002ECFr 3               
002ECFr 3               
002ECFr 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
002ECFr 3               ; ## "line"  tested  Tali Editor
002ECFr 3               
002ECFr 3               xt_editor_line:
002ECFr 3  20 rr rr                     jsr underflow_1
002ED2r 3               
002ED2r 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
002ED2r 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
002ED4r 3               @shift_tos_left:
002ED4r 3  16 00                        asl 0,x         ; Shift TOS to the left
002ED6r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
002ED8r 3  88                           dey
002ED9r 3  D0 F9                        bne @shift_tos_left
002EDBr 3                               ; Load the current screen into a buffer
002EDBr 3                               ; and get the buffer address
002EDBr 3  20 rr rr                     jsr xt_scr
002EDEr 3  20 rr rr                     jsr xt_fetch
002EE1r 3  20 rr rr                     jsr xt_block
002EE4r 3               
002EE4r 3                               ; Add the offset to the buffer base address.
002EE4r 3  20 rr rr                     jsr xt_plus
002EE7r 3               
002EE7r 3  60           z_editor_line:  rts
002EE8r 3               
002EE8r 3               
002EE8r 3               
002EE8r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
002EE8r 3               ; ## "o"  tested  Tali Editor
002EE8r 3               xt_editor_o:
002EE8r 3                               ; Print prompt
002EE8r 3  20 rr rr                     jsr xt_cr
002EEBr 3  20 rr rr                     jsr xt_dup
002EEEr 3  20 rr rr                     jsr xt_two
002EF1r 3  20 rr rr                     jsr xt_u_dot_r
002EF4r 3  20 rr rr                     jsr xt_space
002EF7r 3  A9 2A                        lda #42         ; ASCII for *
002EF9r 3  20 rr rr                     jsr emit_a
002EFCr 3  20 rr rr                     jsr xt_space
002EFFr 3               
002EFFr 3                               ; Accept new input (directly into the buffer)
002EFFr 3  20 rr rr                     jsr xt_editor_line
002F02r 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
002F05r 3  CA                           dex
002F06r 3  CA                           dex
002F07r 3  A9 40                        lda #64         ; chars/line
002F09r 3  95 00                        sta 0,x
002F0Br 3  74 01                        stz 1,x
002F0Dr 3  20 rr rr                     jsr xt_accept
002F10r 3               
002F10r 3                               ; Fill the rest with spaces.
002F10r 3                               ; Stack is currently ( line_address numchars_from_accept )
002F10r 3  20 rr rr                     jsr xt_dup
002F13r 3  20 rr rr                     jsr xt_not_rote ; -rot
002F16r 3  20 rr rr                     jsr xt_plus
002F19r 3  CA                           dex
002F1Ar 3  CA                           dex
002F1Br 3  A9 40                        lda #64         ; chars/line
002F1Dr 3  95 00                        sta 0,x
002F1Fr 3  74 01                        stz 1,x
002F21r 3  20 rr rr                     jsr xt_rot
002F24r 3  20 rr rr                     jsr xt_minus
002F27r 3  20 rr rr                     jsr xt_blank
002F2Ar 3               
002F2Ar 3                               ; Mark buffer as updated.
002F2Ar 3  20 rr rr                     jsr xt_update
002F2Dr 3               
002F2Dr 3  60           z_editor_o:     rts
002F2Er 3               
002F2Er 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
002F2Er 3               ; ## "lcdput" coded Custom
002F2Er 3               xt_lcdput:
002F2Er 3  20 rr rr                     jsr underflow_1
002F31r 3               
002F31r 3  B5 00                        lda 0,x
002F33r 3                       .ifdef lcd_print
002F33r 3                               jsr lcd_print
002F33r 3                       .endif
002F33r 3  E8                           inx
002F34r 3  E8                           inx
002F35r 3  60           z_lcdput: rts
002F36r 3               
002F36r 3               
002F36r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
002F36r 3               ; ## "lcdprint"  coded Custom
002F36r 3               
002F36r 3               xt_lcdprint:
002F36r 3  20 rr rr                     jsr underflow_2
002F39r 3               
002F39r 3                               ; Save the starting address into tmp1
002F39r 3  B5 02                        lda 2,x
002F3Br 3  85 rr                        sta tmp1
002F3Dr 3  B5 03                        lda 3,x
002F3Fr 3  85 rr                        sta tmp1+1
002F41r 3               @loop:
002F41r 3                               ; done if length is zero
002F41r 3  B5 00                        lda 0,x
002F43r 3  15 01                        ora 1,x
002F45r 3  F0 12                        beq @done
002F47r 3               
002F47r 3                               ; Send the current character
002F47r 3  B2 rr                        lda (tmp1)
002F49r 3                       .ifdef lcd_print
002F49r 3                               jsr lcd_print      ; avoids stack foolery
002F49r 3                       .endif
002F49r 3                               ; Move the address along (in tmp1)
002F49r 3  E6 rr                        inc tmp1
002F4Br 3  D0 02                        bne @1
002F4Dr 3  E6 rr                        inc tmp1+1
002F4Fr 3               @1:
002F4Fr 3                               ; Reduce the count (on the data stack)
002F4Fr 3  B5 00                        lda 0,x
002F51r 3  D0 02                        bne @2
002F53r 3  D6 01                        dec 1,x
002F55r 3               @2:
002F55r 3  D6 00                        dec 0,x
002F57r 3               
002F57r 3  80 E8                        bra @loop
002F59r 3               @done:
002F59r 3  E8                           inx
002F5Ar 3  E8                           inx
002F5Br 3  E8                           inx
002F5Cr 3  E8                           inx
002F5Dr 3               
002F5Dr 3  60           z_lcdprint:         rts
002F5Er 3               
002F5Er 3               
002F5Er 3               
002F5Er 3               ; ## CLS ( -- ) "clea VGA screen"
002F5Er 3               ; ## "cls" coded Custom
002F5Er 3               xt_cls:
002F5Er 3                       .ifdef vga_clear
002F5Er 3                               jsr vga_clear
002F5Er 3                       .endif
002F5Er 3               
002F5Er 3  60           z_cls: rts
002F5Fr 3               
002F5Fr 3               
002F5Fr 3               ; ## SPI_INIT ( -- ) "Init SPI system"
002F5Fr 3               ; ## "spi_init" coded Custom
002F5Fr 3               xt_spi_init:
002F5Fr 3                       .ifdef spi_init
002F5Fr 3  20 rr rr                     jsr spi_init
002F62r 3                       .endif
002F62r 3  60           z_spi_init: rts
002F63r 3               
002F63r 3               
002F63r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
002F63r 3               ; ## "spi_clk_toggle" coded Custom
002F63r 3               xt_spi_clk_toggle:
002F63r 3                       .ifdef spi_clk_toggle
002F63r 3  20 rr rr                     jsr spi_clk_toggle
002F66r 3                       .endif
002F66r 3  60           z_spi_clk_toggle: rts
002F67r 3               
002F67r 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
002F67r 3               ; ## "spi_select" coded Custom
002F67r 3               xt_spi_select:
002F67r 3  20 rr rr                     jsr underflow_1
002F6Ar 3               
002F6Ar 3  B5 00                        lda 0,x
002F6Cr 3                       .ifdef spi_select
002F6Cr 3  20 rr rr                     jsr spi_select
002F6Fr 3                       .endif
002F6Fr 3  E8                           inx
002F70r 3  E8                           inx
002F71r 3  60           z_spi_select: rts
002F72r 3               
002F72r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
002F72r 3               ; ## "spi_transceive" coded Custom
002F72r 3               xt_spi_transceive:
002F72r 3  20 rr rr                     jsr underflow_1
002F75r 3               
002F75r 3  B5 00                        lda 0,x
002F77r 3                       .ifdef spi_transceive
002F77r 3  20 rr rr                     jsr spi_transceive
002F7Ar 3                       .endif
002F7Ar 3  95 00                        sta 0,x         ; put return value in TOS
002F7Cr 3  74 01                        stz 1,X         ;reset value there
002F7Er 3  60           z_spi_transceive: rts
002F7Fr 3               
002F7Fr 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
002F7Fr 3               ; ## "spi_transceive" coded Custom
002F7Fr 3               xt_sd_init:
002F7Fr 3  20 rr rr                     jsr underflow_1
002F82r 3               
002F82r 3  B5 00                        lda 0,x
002F84r 3                       .ifdef sd_init
002F84r 3  20 rr rr                     jsr sd_init
002F87r 3                       .endif
002F87r 3  95 00                        sta 0,x         ; put return value in TOS
002F89r 3  74 01                        stz 1,X         ;reset value there
002F8Br 3  60           z_sd_init: rts
002F8Cr 3               
002F8Cr 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
002F8Cr 3               ; ## "sd_readsector" coded Custom
002F8Cr 3               xt_sd_readsector:
002F8Cr 3  20 rr rr                     jsr underflow_3
002F8Fr 3                       .ifdef sd_readsector
002F8Fr 3                               ; get and save storage address
002F8Fr 3  B5 00                        lda 0,x
002F91r 3  85 rr                        sta sd_buffer_address
002F93r 3  B5 01                        lda 1, x
002F95r 3  85 rr                        sta sd_buffer_address + 1
002F97r 3                               ; get and save sector number (32 bit number, double)
002F97r 3  B5 02                        lda 2, X
002F99r 3  8D rr rr                     sta SD_ARG + 3
002F9Cr 3  B5 03                        lda 3, X
002F9Er 3  8D rr rr                     sta SD_ARG + 2
002FA1r 3  B5 04                        lda 4, X
002FA3r 3  8D rr rr                     sta SD_ARG + 1
002FA6r 3  B5 05                        lda 5, X
002FA8r 3  8D rr rr                     sta SD_ARG
002FABr 3  A9 01                        lda #1
002FADr 3  8D rr rr                     sta SD_CRC
002FB0r 3               
002FB0r 3  20 rr rr                     jsr sd_readsector
002FB3r 3                       .endif
002FB3r 3  95 00                        sta 0,x         ; put return value in TOS
002FB5r 3  74 01                        stz 1,X         ;reset value there
002FB7r 3               
002FB7r 3  E8                           inx
002FB8r 3  E8                           inx
002FB9r 3  E8                           inx
002FBAr 3  E8                           inx
002FBBr 3               
002FBBr 3  60           z_sd_readsector: rts
002FBCr 3               
002FBCr 3               
002FBCr 3               ; ## FAT32_INIT ( u -- u ) "initialize FAT32 file system on passed spi drive address"
002FBCr 3               ; ## "fat32_init" coded Custom
002FBCr 3               xt_fat32_init:
002FBCr 3  20 rr rr                     jsr underflow_1
002FBFr 3               
002FBFr 3  B5 00                        lda 0,x
002FC1r 3                       .ifdef sd_init
002FC1r 3  20 rr rr                     jsr sd_init
002FC4r 3  D0 05                        bne @error
002FC6r 3                       .endif
002FC6r 3                       .ifdef fat32_init
002FC6r 3  20 rr rr                     jsr fat32_init
002FC9r 3  F0 02                        beq @end
002FCBr 3                       .endif
002FCBr 3                       .ifdef fat32_openroot
002FCBr 3                               ; jsr fat32_openroot
002FCBr 3                               ; beq @end
002FCBr 3                       .endif
002FCBr 3               @error:
002FCBr 3  A9 01                        lda #1
002FCDr 3               @end:
002FCDr 3  95 00                        sta 0,x         ; put return value in TOS
002FCFr 3  74 01                        stz 1,X         ;reset value there
002FD1r 3  60           z_fat32_init: rts
002FD2r 3               
002FD2r 3               
002FD2r 3               ; ## FAT32_ROOT ( -- u ) "initialize FAT32 file system on passed spi drive address"
002FD2r 3               ; ## "fat32_root" coded Custom
002FD2r 3               xt_fat32_root:
002FD2r 3               
002FD2r 3                       .ifdef fat32_openroot
002FD2r 3  20 rr rr                     jsr fat32_openroot
002FD5r 3                               ; beq @end
002FD5r 3                       .endif
002FD5r 3               
002FD5r 3               @end:
002FD5r 3  CA                           dex
002FD6r 3  CA                           dex
002FD7r 3  95 00                        sta 0,x         ; put return value in TOS
002FD9r 3  74 01                        stz 1,X         ;reset value there
002FDBr 3  60           z_fat32_root: rts
002FDCr 3               
002FDCr 3               ; ## FAT32_FIND ( addr u -- u ) "Open file from initialized fat32 FS"
002FDCr 3               ; ## "fat32_find" coded Custom
002FDCr 3               xt_fat32_find:
002FDCr 3  20 rr rr                     jsr underflow_2
002FDFr 3  5A                           phy
002FE0r 3  B4 00                        ldy 0,x ; length of string
002FE2r 3  A9 00                        lda #0
002FE4r 3               @reset_loop:
002FE4r 3                           .ifdef fat32_finddirent
002FE4r 3  91 rr                        sta (fat32_filenamepointer),y
002FE6r 3  C8                           iny
002FE7r 3  C0 0B                        cpy #11
002FE9r 3  90 F9                        bcc @reset_loop
002FEBr 3                           .endif
002FEBr 3  E8                           inx     ; get address
002FECr 3  E8                           inx
002FEDr 3                           .ifdef fat32_finddirent
002FEDr 3  B5 00                        lda 0,x
002FEFr 3  85 rr                        sta fat32_filenamepointer
002FF1r 3  B5 01                        lda 1,x
002FF3r 3  85 rr                        sta fat32_filenamepointer+1
002FF5r 3                           .endif
002FF5r 3               
002FF5r 3  7A                           ply
002FF6r 3                           .ifdef fat32_finddirent
002FF6r 3  20 rr rr                     jsr fat32_finddirent    ; find the file from its name
002FF9r 3  F0 02                        beq @end
002FFBr 3                           .endif
002FFBr 3               
002FFBr 3               @error:
002FFBr 3  A9 01                        lda #1
002FFDr 3               @end:
002FFDr 3  95 00                        sta 0,x         ; put return value in TOS
002FFFr 3  74 01                        stz 1,X         ;reset value there
003001r 3  60           z_fat32_find: rts
003002r 3               
003002r 3               ; ## time ( -- addr ) "get time storage address"
003002r 3               ; ## "time" coded Custom
003002r 3               xt_time:
003002r 3                       .ifdef time
003002r 3  A9 rr                lda #time
003004r 3                       .else
003004r 3                       lda #0
003004r 3                       .endif
003004r 3  CA                   dex
003005r 3  CA                   dex
003006r 3  95 00                sta 0,x
003008r 3  74 01                stz 1,x
00300Ar 3               
00300Ar 3               
00300Ar 3  60           z_time: rts
00300Br 3               
00300Br 3               ; TODO add routine to send a block of data in memory via SPI
00300Br 3               ; similar to lcdprint
00300Br 3               
00300Br 3               ; END
00300Br 3               
00300Br 3               
00300Br 2                   .include "headers.s"          ; Headers of native words
00300Br 3               ; Dictionary Headers for Tali Forth 2
00300Br 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00300Br 3               ; First version: 05. Dec 2016 (Liara Forth)
00300Br 3               ; This version: 29. Dec 2018
00300Br 3               
00300Br 3               ; Dictionary headers are kept separately from the code, which allows various
00300Br 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
00300Br 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
00300Br 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
00300Br 3               ; header in the Dictionary. There the link to the next word in the Dictionary
00300Br 3               ; is always one cell down from the current word's own nt. In the code itself,
00300Br 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
00300Br 3               
00300Br 3               ; This gives us the following header structure:
00300Br 3               
00300Br 3               ;              8 bit     8 bit
00300Br 3               ;               LSB       MSB
00300Br 3               ; nt_word ->  +--------+--------+
00300Br 3               ;          +0 | Length | Status |
00300Br 3               ;             +--------+--------+
00300Br 3               ;          +2 | Next Header     | -> nt_next_word
00300Br 3               ;             +-----------------+
00300Br 3               ;          +4 | Start of Code   | -> xt_word
00300Br 3               ;             +-----------------+
00300Br 3               ;          +6 | End of Code     | -> z_word
00300Br 3               ;             +--------+--------+
00300Br 3               ;          +8 | Name   |        |
00300Br 3               ;             +--------+--------+
00300Br 3               ;             |        |        |
00300Br 3               ;             +--------+--------+
00300Br 3               ;             |        |  ...   | (name string does not end with a zero)
00300Br 3               ;          +n +--------+--------+
00300Br 3               
00300Br 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
00300Br 3               ; which are:
00300Br 3               
00300Br 3               ;       CO - Compile Only
00300Br 3               ;       IM - Immediate Word
00300Br 3               ;       NN - Never Native Compile (must always be called by JSR)
00300Br 3               ;       AN - Always Native Compile (may not be called by JSR)
00300Br 3               ;       UF - Contains underflow check
00300Br 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
00300Br 3               
00300Br 3               ; Note there are currently two bits unused.
00300Br 3               
00300Br 3               ; By default, all existing words can be natively compiled (compiled inline) or
00300Br 3               ; as a subroutine jump target; the system decides which variant to use based on
00300Br 3               ; a threshold the user can set. By default, all user-created words are flagged
00300Br 3               ; never-native. The user can override this by using the always-native word
00300Br 3               ; just after defining their new word.  The NN flag forbids native compiling,
00300Br 3               ; the AN flag forces it.
00300Br 3               
00300Br 3               ; The last word (top word in code) is always BYE. It is marked as the last word
00300Br 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
00300Br 3               ; more common ones first (further down in code) so they are found earlier.
00300Br 3               ; Anything to do with output comes later (further up) because things will
00300Br 3               ; always be slow if there is a human involved.
00300Br 3               
00300Br 3               ; The initial skeleton of this list was automatically generated by a script
00300Br 3               ; in the tools folder and then sorted by hand.
00300Br 3               
00300Br 3               nt_bye:
00300Br 3  03                   .byte 3         ; length of word strings
00300Cr 3  00                   .byte 0         ; status byte
00300Dr 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
00300Fr 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
003011r 3  rr rr                .word z_bye     ; end of code (RTS)
003013r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
003016r 3               
003016r 3               
003016r 3               nt_cold:
003016r 3  04 00                .byte 4, 0
003018r 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
00301Cr 3  rr rr        
00301Er 3  63 6F 6C 64          .byte "cold"
003022r 3               
003022r 3               nt_lcdput:
003022r 3  06 10                .byte 6, UF
003024r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
003028r 3  rr rr        
00302Ar 3  6C 63 64 70          .byte "lcdput"
00302Er 3  75 74        
003030r 3               
003030r 3               nt_lcdprint:
003030r 3  08 10                .byte 8, UF
003032r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
003036r 3  rr rr        
003038r 3  6C 63 64 70          .byte "lcdprint"
00303Cr 3  72 69 6E 74  
003040r 3               
003040r 3               nt_cls:
003040r 3  03 00                .byte 3, 0
003042r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
003046r 3  rr rr        
003048r 3  63 6C 73             .byte "cls"
00304Br 3               
00304Br 3               nt_spi_init:
00304Br 3  08 00                .byte 8, 0
00304Dr 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
003051r 3  rr rr        
003053r 3  73 70 69 5F          .byte "spi_init"
003057r 3  69 6E 69 74  
00305Br 3               
00305Br 3               
00305Br 3               nt_spi_clk_toggle:
00305Br 3  0E 00                .byte 14, 0
00305Dr 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
003061r 3  rr rr        
003063r 3  73 70 69 5F          .byte "spi_clk_toggle"
003067r 3  63 6C 6B 5F  
00306Br 3  74 6F 67 67  
003071r 3               
003071r 3               nt_spi_select:
003071r 3  0A 00                .byte 10, 0
003073r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
003077r 3  rr rr        
003079r 3  73 70 69 5F          .byte "spi_select"
00307Dr 3  73 65 6C 65  
003081r 3  63 74        
003083r 3               
003083r 3               nt_spi_transceive:
003083r 3  0E 00                .byte 14, 0
003085r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
003089r 3  rr rr        
00308Br 3  73 70 69 5F          .byte "spi_transceive"
00308Fr 3  74 72 61 6E  
003093r 3  73 63 65 69  
003099r 3               
003099r 3               nt_sd_init:
003099r 3  07 00                .byte 7, 0
00309Br 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
00309Fr 3  rr rr        
0030A1r 3  73 64 5F 69          .byte "sd_init"
0030A5r 3  6E 69 74     
0030A8r 3               
0030A8r 3               
0030A8r 3               nt_sd_readsector:
0030A8r 3  0D 00                .byte 13, 0
0030AAr 3  rr rr rr rr          .word nt_sd_init, xt_sd_readsector, z_sd_readsector
0030AEr 3  rr rr        
0030B0r 3  73 64 5F 72          .byte "sd_readsector"
0030B4r 3  65 61 64 73  
0030B8r 3  65 63 74 6F  
0030BDr 3               
0030BDr 3               
0030BDr 3               nt_fat32_init:
0030BDr 3  0A 00                .byte 10, 0
0030BFr 3  rr rr rr rr          .word nt_sd_readsector, xt_fat32_init, z_fat32_init
0030C3r 3  rr rr        
0030C5r 3  66 61 74 33          .byte "fat32_init"
0030C9r 3  32 5F 69 6E  
0030CDr 3  69 74        
0030CFr 3               
0030CFr 3               nt_fat32_root:
0030CFr 3  0A 00                .byte 10, 0
0030D1r 3  rr rr rr rr          .word nt_fat32_init, xt_fat32_root, z_fat32_root
0030D5r 3  rr rr        
0030D7r 3  66 61 74 33          .byte "fat32_root"
0030DBr 3  32 5F 72 6F  
0030DFr 3  6F 74        
0030E1r 3               
0030E1r 3               nt_fat32_find:
0030E1r 3  0A 00                .byte 10, 0
0030E3r 3  rr rr rr rr          .word nt_fat32_root, xt_fat32_find, z_fat32_find
0030E7r 3  rr rr        
0030E9r 3  66 61 74 33          .byte "fat32_find"
0030EDr 3  32 5F 66 69  
0030F1r 3  6E 64        
0030F3r 3               
0030F3r 3               nt_time:
0030F3r 3  04 00                .byte 4, 0
0030F5r 3  rr rr rr rr          .word nt_fat32_find, xt_time, z_time
0030F9r 3  rr rr        
0030FBr 3  74 69 6D 65          .byte "time"
0030FFr 3               
0030FFr 3               nt_ed:                  ; ed6502
0030FFr 3  02 08                .byte 2, NN
003101r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
003105r 3  rr rr        
003107r 3  65 64                .byte "ed"
003109r 3               
003109r 3  03 08        nt_see: .byte 3, NN
00310Br 3  rr rr rr rr          .word nt_ed, xt_see, z_see
00310Fr 3  rr rr        
003111r 3  73 65 65             .byte "see"
003114r 3               
003114r 3               nt_forth:
003114r 3  05 00                .byte 5, 0
003116r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
00311Ar 3  rr rr        
00311Cr 3  66 6F 72 74          .byte "forth"
003120r 3  68           
003121r 3               
003121r 3               nt_order:
003121r 3  05 00                .byte 5, 0
003123r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
003127r 3  rr rr        
003129r 3  6F 72 64 65          .byte "order"
00312Dr 3  72           
00312Er 3               
00312Er 3               nt_to_order:
00312Er 3  06 00                .byte 6, 0
003130r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
003134r 3  rr rr        
003136r 3  3E 6F 72 64          .byte ">order"
00313Ar 3  65 72        
00313Cr 3               
00313Cr 3               nt_previous:
00313Cr 3  08 00                .byte 8, 0
00313Er 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
003142r 3  rr rr        
003144r 3  70 72 65 76          .byte "previous"
003148r 3  69 6F 75 73  
00314Cr 3               
00314Cr 3               nt_also:
00314Cr 3  04 00                .byte 4, 0
00314Er 3  rr rr rr rr          .word nt_previous, xt_also, z_also
003152r 3  rr rr        
003154r 3  61 6C 73 6F          .byte "also"
003158r 3               
003158r 3               nt_only:
003158r 3  04 00                .byte 4, 0
00315Ar 3  rr rr rr rr          .word nt_also, xt_only, z_only
00315Er 3  rr rr        
003160r 3  6F 6E 6C 79          .byte "only"
003164r 3               
003164r 3               nt_forth_wordlist:      ; shares code with ZERO
003164r 3  0E 00                .byte 14, 0
003166r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
00316Ar 3  rr rr        
00316Cr 3  66 6F 72 74          .byte "forth-wordlist"
003170r 3  68 2D 77 6F  
003174r 3  72 64 6C 69  
00317Ar 3               
00317Ar 3               nt_editor_wordlist:     ; shares code with ONE
00317Ar 3  0F 00                .byte 15, 0
00317Cr 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
003180r 3  rr rr        
003182r 3  65 64 69 74          .byte "editor-wordlist"
003186r 3  6F 72 2D 77  
00318Ar 3  6F 72 64 6C  
003191r 3               
003191r 3               nt_assembler_wordlist:  ; shares code with TWO
003191r 3  12 00                .byte 18, 0
003193r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
003197r 3  rr rr        
003199r 3  61 73 73 65          .byte "assembler-wordlist"
00319Dr 3  6D 62 6C 65  
0031A1r 3  72 2D 77 6F  
0031ABr 3               
0031ABr 3               nt_root_wordlist:
0031ABr 3  0D 00                .byte 13, 0
0031ADr 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
0031B1r 3  rr rr        
0031B3r 3  72 6F 6F 74          .byte "root-wordlist"
0031B7r 3  2D 77 6F 72  
0031BBr 3  64 6C 69 73  
0031C0r 3               
0031C0r 3               nt_get_order:
0031C0r 3  09 00                .byte 9, 0
0031C2r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
0031C6r 3  rr rr        
0031C8r 3  67 65 74 2D          .byte "get-order"
0031CCr 3  6F 72 64 65  
0031D0r 3  72           
0031D1r 3               
0031D1r 3               nt_set_order:
0031D1r 3  09 00                .byte 9, 0
0031D3r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
0031D7r 3  rr rr        
0031D9r 3  73 65 74 2D          .byte "set-order"
0031DDr 3  6F 72 64 65  
0031E1r 3  72           
0031E2r 3               
0031E2r 3               nt_get_current:
0031E2r 3  0B 00                .byte 11, 0
0031E4r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
0031E8r 3  rr rr        
0031EAr 3  67 65 74 2D          .byte "get-current"
0031EEr 3  63 75 72 72  
0031F2r 3  65 6E 74     
0031F5r 3               
0031F5r 3               nt_set_current:
0031F5r 3  0B 10                .byte 11, UF
0031F7r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
0031FBr 3  rr rr        
0031FDr 3  73 65 74 2D          .byte "set-current"
003201r 3  63 75 72 72  
003205r 3  65 6E 74     
003208r 3               
003208r 3               nt_search_wordlist:
003208r 3  0F 10                .byte 15, UF
00320Ar 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
00320Er 3  rr rr        
003210r 3  73 65 61 72          .byte "search-wordlist"
003214r 3  63 68 2D 77  
003218r 3  6F 72 64 6C  
00321Fr 3               
00321Fr 3               nt_wordlist:
00321Fr 3  08 00                .byte 8, 0
003221r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
003225r 3  rr rr        
003227r 3  77 6F 72 64          .byte "wordlist"
00322Br 3  6C 69 73 74  
00322Fr 3               
00322Fr 3               nt_definitions:
00322Fr 3  0B 00                .byte 11, 0
003231r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
003235r 3  rr rr        
003237r 3  64 65 66 69          .byte "definitions"
00323Br 3  6E 69 74 69  
00323Fr 3  6F 6E 73     
003242r 3               
003242r 3               nt_block_ramdrive_init:
003242r 3  13 10                .byte 19, UF
003244r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
003248r 3  rr rr        
00324Ar 3  62 6C 6F 63          .byte "block-ramdrive-init"
00324Er 3  6B 2D 72 61  
003252r 3  6D 64 72 69  
00325Dr 3               
00325Dr 3               nt_list:
00325Dr 3  04 10                .byte 4, UF
00325Fr 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
003263r 3  rr rr        
003265r 3  6C 69 73 74          .byte "list"
003269r 3               
003269r 3               nt_thru:
003269r 3  04 10                .byte 4, UF
00326Br 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
00326Fr 3  rr rr        
003271r 3  74 68 72 75          .byte "thru"
003275r 3               
003275r 3               nt_load:
003275r 3  04 10                .byte 4, UF
003277r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
00327Br 3  rr rr        
00327Dr 3  6C 6F 61 64          .byte "load"
003281r 3               
003281r 3               nt_flush:
003281r 3  05 00                .byte 5, 0
003283r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
003287r 3  rr rr        
003289r 3  66 6C 75 73          .byte "flush"
00328Dr 3  68           
00328Er 3               
00328Er 3               nt_empty_buffers:
00328Er 3  0D 00                .byte 13, 0
003290r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
003294r 3  rr rr        
003296r 3  65 6D 70 74          .byte "empty-buffers"
00329Ar 3  79 2D 62 75  
00329Er 3  66 66 65 72  
0032A3r 3               
0032A3r 3               nt_buffer:
0032A3r 3  06 00                .byte 6, 0
0032A5r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
0032A9r 3  rr rr        
0032ABr 3  62 75 66 66          .byte "buffer"
0032AFr 3  65 72        
0032B1r 3               
0032B1r 3               nt_update:
0032B1r 3  06 00                .byte 6, 0
0032B3r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
0032B7r 3  rr rr        
0032B9r 3  75 70 64 61          .byte "update"
0032BDr 3  74 65        
0032BFr 3               
0032BFr 3               nt_block:
0032BFr 3  05 00                .byte 5, 0
0032C1r 3  rr rr rr rr          .word nt_update, xt_block, z_block
0032C5r 3  rr rr        
0032C7r 3  62 6C 6F 63          .byte "block"
0032CBr 3  6B           
0032CCr 3               
0032CCr 3               nt_save_buffers:
0032CCr 3  0C 00                .byte 12, 0
0032CEr 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
0032D2r 3  rr rr        
0032D4r 3  73 61 76 65          .byte "save-buffers"
0032D8r 3  2D 62 75 66  
0032DCr 3  66 65 72 73  
0032E0r 3               
0032E0r 3               nt_block_read_vector:
0032E0r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
0032E2r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
0032E6r 3  rr rr        
0032E8r 3  62 6C 6F 63          .byte "block-read-vector"
0032ECr 3  6B 2D 72 65  
0032F0r 3  61 64 2D 76  
0032F9r 3               
0032F9r 3               nt_block_read:
0032F9r 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
0032FBr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
0032FFr 3  rr rr        
003301r 3  62 6C 6F 63          .byte "block-read"
003305r 3  6B 2D 72 65  
003309r 3  61 64        
00330Br 3               
00330Br 3               nt_block_write_vector:
00330Br 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
00330Dr 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
003311r 3  rr rr        
003313r 3  62 6C 6F 63          .byte "block-write-vector"
003317r 3  6B 2D 77 72  
00331Br 3  69 74 65 2D  
003325r 3               
003325r 3               nt_block_write:
003325r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
003327r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
00332Br 3  rr rr        
00332Dr 3  62 6C 6F 63          .byte "block-write"
003331r 3  6B 2D 77 72  
003335r 3  69 74 65     
003338r 3               
003338r 3               nt_blk:
003338r 3  03 00                .byte 3, 0
00333Ar 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
00333Er 3  rr rr        
003340r 3  62 6C 6B             .byte "blk"
003343r 3               
003343r 3               nt_scr:
003343r 3  03 00                .byte 3, 0
003345r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
003349r 3  rr rr        
00334Br 3  73 63 72             .byte "scr"
00334Er 3               
00334Er 3               nt_blkbuffer:
00334Er 3  09 00                .byte 9, 0
003350r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
003354r 3  rr rr        
003356r 3  62 6C 6B 62          .byte "blkbuffer"
00335Ar 3  75 66 66 65  
00335Er 3  72           
00335Fr 3               
00335Fr 3               nt_buffblocknum:
00335Fr 3  0C 00                .byte 12, 0
003361r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
003365r 3  rr rr        
003367r 3  62 75 66 66          .byte "buffblocknum"
00336Br 3  62 6C 6F 63  
00336Fr 3  6B 6E 75 6D  
003373r 3               
003373r 3               nt_buffstatus:
003373r 3  0A 00                .byte 10, 0
003375r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
003379r 3  rr rr        
00337Br 3  62 75 66 66          .byte "buffstatus"
00337Fr 3  73 74 61 74  
003383r 3  75 73        
003385r 3               
003385r 3               nt_buffer_colon:
003385r 3  07 00                .byte 7, 0
003387r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
00338Br 3  rr rr        
00338Dr 3  62 75 66 66          .byte "buffer:"
003391r 3  65 72 3A     
003394r 3               
003394r 3               nt_useraddr:
003394r 3  08 00                .byte 8, 0
003396r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
00339Ar 3  rr rr        
00339Cr 3  75 73 65 72          .byte "useraddr"
0033A0r 3  61 64 64 72  
0033A4r 3               
0033A4r 3               nt_action_of:
0033A4r 3  09 04                .byte 9, IM
0033A6r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
0033AAr 3  rr rr        
0033ACr 3  61 63 74 69          .byte "action-of"
0033B0r 3  6F 6E 2D 6F  
0033B4r 3  66           
0033B5r 3               
0033B5r 3               nt_is:
0033B5r 3  02 04                .byte 2, IM
0033B7r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
0033BBr 3  rr rr        
0033BDr 3  69 73                .byte "is"
0033BFr 3               
0033BFr 3               nt_defer_store:
0033BFr 3  06 00                .byte 6, 0
0033C1r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
0033C5r 3  rr rr        
0033C7r 3  64 65 66 65          .byte "defer!"
0033CBr 3  72 21        
0033CDr 3               
0033CDr 3               nt_defer_fetch:
0033CDr 3  06 00                .byte 6, 0
0033CFr 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
0033D3r 3  rr rr        
0033D5r 3  64 65 66 65          .byte "defer@"
0033D9r 3  72 40        
0033DBr 3               
0033DBr 3               nt_endcase:
0033DBr 3  07 0D                .byte 7, IM+CO+NN
0033DDr 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
0033E1r 3  rr rr        
0033E3r 3  65 6E 64 63          .byte "endcase"
0033E7r 3  61 73 65     
0033EAr 3               
0033EAr 3               nt_endof:
0033EAr 3  05 0D                .byte 5, IM+CO+NN
0033ECr 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
0033F0r 3  rr rr        
0033F2r 3  65 6E 64 6F          .byte "endof"
0033F6r 3  66           
0033F7r 3               
0033F7r 3               nt_of:
0033F7r 3  02 0D                .byte 2, IM+CO+NN
0033F9r 3  rr rr rr rr          .word nt_endof, xt_of, z_of
0033FDr 3  rr rr        
0033FFr 3  6F 66                .byte "of"
003401r 3               
003401r 3               nt_case:
003401r 3  04 0D                .byte 4, IM+CO+NN
003403r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
003407r 3  rr rr        
003409r 3  63 61 73 65          .byte "case"
00340Dr 3               
00340Dr 3               nt_while:
00340Dr 3  05 0D                .byte 5, IM+CO+NN
00340Fr 3  rr rr rr rr          .word nt_case, xt_while, z_while
003413r 3  rr rr        
003415r 3  77 68 69 6C          .byte "while"
003419r 3  65           
00341Ar 3               
00341Ar 3               nt_until:
00341Ar 3  05 0D                .byte 5, IM+CO+NN
00341Cr 3  rr rr rr rr          .word nt_while, xt_until, z_until
003420r 3  rr rr        
003422r 3  75 6E 74 69          .byte "until"
003426r 3  6C           
003427r 3               
003427r 3               nt_repeat:
003427r 3  06 0D                .byte 6, IM+CO+NN
003429r 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
00342Dr 3  rr rr        
00342Fr 3  72 65 70 65          .byte "repeat"
003433r 3  61 74        
003435r 3               
003435r 3               nt_else:
003435r 3  04 0D                .byte 4, IM+CO+NN
003437r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
00343Br 3  rr rr        
00343Dr 3  65 6C 73 65          .byte "else"
003441r 3               
003441r 3               nt_then:
003441r 3  04 0D                .byte 4, IM+CO+NN
003443r 3  rr rr rr rr          .word nt_else, xt_then, z_then
003447r 3  rr rr        
003449r 3  74 68 65 6E          .byte "then"
00344Dr 3               
00344Dr 3               nt_if:
00344Dr 3  02 0D                .byte 2, IM+CO+NN
00344Fr 3  rr rr rr rr          .word nt_then, xt_if, z_if
003453r 3  rr rr        
003455r 3  69 66                .byte "if"
003457r 3               
003457r 3               nt_dot_paren:
003457r 3  02 04                .byte 2, IM
003459r 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
00345Dr 3  rr rr        
00345Fr 3  2E 28                .byte ".("
003461r 3               
003461r 3               nt_paren:
003461r 3  01 04                .byte 1, IM
003463r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
003467r 3  rr rr        
003469r 3  28                   .byte "("
00346Ar 3               
00346Ar 3               nt_word:
00346Ar 3  04 10                .byte 4, UF
00346Cr 3  rr rr rr rr          .word nt_paren, xt_word, z_word
003470r 3  rr rr        
003472r 3  77 6F 72 64          .byte "word"
003476r 3               
003476r 3               nt_find:
003476r 3  04 10                .byte 4, UF
003478r 3  rr rr rr rr          .word nt_word, xt_find, z_find
00347Cr 3  rr rr        
00347Er 3  66 69 6E 64          .byte "find"
003482r 3               
003482r 3               nt_environment_q:
003482r 3  0C 10                .byte 12, UF
003484r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
003488r 3  rr rr        
00348Ar 3  65 6E 76 69          .byte "environment?"
00348Er 3  72 6F 6E 6D  
003492r 3  65 6E 74 3F  
003496r 3               
003496r 3               nt_search:
003496r 3  06 18                .byte 6, UF+NN
003498r 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
00349Cr 3  rr rr        
00349Er 3  73 65 61 72          .byte "search"
0034A2r 3  63 68        
0034A4r 3               
0034A4r 3               nt_compare:
0034A4r 3  07 10                .byte 7, UF
0034A6r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
0034AAr 3  rr rr        
0034ACr 3  63 6F 6D 70          .byte "compare"
0034B0r 3  61 72 65     
0034B3r 3               
0034B3r 3               nt_disasm:
0034B3r 3  06 10                .byte 6, UF
0034B5r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
0034B9r 3  rr rr        
0034BBr 3  64 69 73 61          .byte "disasm"
0034BFr 3  73 6D        
0034C1r 3               
0034C1r 3               nt_dot_s:
0034C1r 3  02 00                .byte 2, 0
0034C3r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
0034C7r 3  rr rr        
0034C9r 3  2E 73                .byte ".s"
0034CBr 3               
0034CBr 3               nt_dump:
0034CBr 3  04 10                .byte 4, UF
0034CDr 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
0034D1r 3  rr rr        
0034D3r 3  64 75 6D 70          .byte "dump"
0034D7r 3               
0034D7r 3               nt_bell:
0034D7r 3  04 00                .byte 4, 0
0034D9r 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
0034DDr 3  rr rr        
0034DFr 3  62 65 6C 6C          .byte "bell"
0034E3r 3               
0034E3r 3               nt_align:
0034E3r 3  05 00                .byte 5, 0
0034E5r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
0034E9r 3  rr rr        
0034EBr 3  61 6C 69 67          .byte "align"
0034EFr 3  6E           
0034F0r 3               
0034F0r 3               nt_aligned:             ; same code as ALIGN
0034F0r 3  07 00                .byte 7, 0
0034F2r 3  rr rr rr rr          .word nt_align, xt_align, z_align
0034F6r 3  rr rr        
0034F8r 3  61 6C 69 67          .byte "aligned"
0034FCr 3  6E 65 64     
0034FFr 3               
0034FFr 3               nt_wordsize:
0034FFr 3  08 10                .byte 8, UF
003501r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
003505r 3  rr rr        
003507r 3  77 6F 72 64          .byte "wordsize"
00350Br 3  73 69 7A 65  
00350Fr 3               
00350Fr 3               nt_words:
00350Fr 3  05 00                .byte 5, 0
003511r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
003515r 3  rr rr        
003517r 3  77 6F 72 64          .byte "words"
00351Br 3  73           
00351Cr 3               
00351Cr 3               nt_marker:
00351Cr 3  06 04                .byte 6, IM
00351Er 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
003522r 3  rr rr        
003524r 3  6D 61 72 6B          .byte "marker"
003528r 3  65 72        
00352Ar 3               
00352Ar 3               nt_at_xy:
00352Ar 3  05 10                .byte 5, UF
00352Cr 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
003530r 3  rr rr        
003532r 3  61 74 2D 78          .byte "at-xy"
003536r 3  79           
003537r 3               
003537r 3               nt_page:
003537r 3  04 00                .byte 4, 0
003539r 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
00353Dr 3  rr rr        
00353Fr 3  70 61 67 65          .byte "page"
003543r 3               
003543r 3               nt_cr:
003543r 3  02 00                .byte 2, 0
003545r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
003549r 3  rr rr        
00354Br 3  63 72                .byte "cr"
00354Dr 3               
00354Dr 3               nt_input:
00354Dr 3  05 00                .byte 5, 0
00354Fr 3  rr rr rr rr          .word nt_cr, xt_input, z_input
003553r 3  rr rr        
003555r 3  69 6E 70 75          .byte "input"
003559r 3  74           
00355Ar 3               
00355Ar 3               nt_output:
00355Ar 3  06 00                .byte 6, 0
00355Cr 3  rr rr rr rr          .word nt_input, xt_output, z_output
003560r 3  rr rr        
003562r 3  6F 75 74 70          .byte "output"
003566r 3  75 74        
003568r 3               
003568r 3               nt_sign:
003568r 3  04 10                .byte 4, UF
00356Ar 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
00356Er 3  rr rr        
003570r 3  73 69 67 6E          .byte "sign"
003574r 3               
003574r 3               nt_hold:
003574r 3  04 10                .byte 4, UF
003576r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
00357Ar 3  rr rr        
00357Cr 3  68 6F 6C 64          .byte "hold"
003580r 3               
003580r 3               nt_number_sign_greater:
003580r 3  02 10                .byte 2, UF
003582r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
003586r 3  rr rr        
003588r 3  23 3E                .byte "#>"
00358Ar 3               
00358Ar 3               nt_number_sign_s:
00358Ar 3  02 10                .byte 2, UF
00358Cr 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
003590r 3  rr rr        
003592r 3  23 73                .byte "#s"
003594r 3               
003594r 3               nt_number_sign:
003594r 3  01 10                .byte 1, UF
003596r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
00359Ar 3  rr rr        
00359Cr 3  23                   .byte "#"
00359Dr 3               
00359Dr 3               nt_less_number_sign:
00359Dr 3  02 00                .byte 2, 0
00359Fr 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
0035A3r 3  rr rr        
0035A5r 3  3C 23                .byte "<#"
0035A7r 3               
0035A7r 3               nt_to_in:
0035A7r 3  03 00                .byte 3, 0
0035A9r 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
0035ADr 3  rr rr        
0035AFr 3  3E 69 6E             .byte ">in"
0035B2r 3               
0035B2r 3               nt_within:
0035B2r 3  06 10                .byte 6, UF
0035B4r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
0035B8r 3  rr rr        
0035BAr 3  77 69 74 68          .byte "within"
0035BEr 3  69 6E        
0035C0r 3               
0035C0r 3               nt_hexstore:
0035C0r 3  08 10                .byte 8, UF
0035C2r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
0035C6r 3  rr rr        
0035C8r 3  68 65 78 73          .byte "hexstore"
0035CCr 3  74 6F 72 65  
0035D0r 3               
0035D0r 3               nt_cleave:
0035D0r 3  06 10                .byte 6, UF
0035D2r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
0035D6r 3  rr rr        
0035D8r 3  63 6C 65 61          .byte "cleave"
0035DCr 3  76 65        
0035DEr 3               
0035DEr 3               nt_pad:
0035DEr 3  03 00                .byte 3, 0
0035E0r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
0035E4r 3  rr rr        
0035E6r 3  70 61 64             .byte "pad"
0035E9r 3               
0035E9r 3               nt_cmove:
0035E9r 3  05 10                .byte 5, UF
0035EBr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
0035EFr 3  rr rr        
0035F1r 3  63 6D 6F 76          .byte "cmove"
0035F5r 3  65           
0035F6r 3               
0035F6r 3               nt_cmove_up:
0035F6r 3  06 10                .byte 6, UF
0035F8r 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
0035FCr 3  rr rr        
0035FEr 3  63 6D 6F 76          .byte "cmove>"
003602r 3  65 3E        
003604r 3               
003604r 3               nt_move:
003604r 3  04 18                .byte 4, NN+UF
003606r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
00360Ar 3  rr rr        
00360Cr 3  6D 6F 76 65          .byte "move"
003610r 3               
003610r 3               nt_backslash:
003610r 3  01 04                .byte 1, IM
003612r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
003616r 3  rr rr        
003618r 3  5C                   .byte $5c
003619r 3               
003619r 3               nt_star_slash:
003619r 3  02 10                .byte 2, UF
00361Br 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
00361Fr 3  rr rr        
003621r 3  2A 2F                .byte "*/"
003623r 3               
003623r 3               nt_star_slash_mod:
003623r 3  05 10                .byte 5, UF
003625r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
003629r 3  rr rr        
00362Br 3  2A 2F 6D 6F          .byte "*/mod"
00362Fr 3  64           
003630r 3               
003630r 3               nt_mod:
003630r 3  03 10                .byte 3, UF
003632r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
003636r 3  rr rr        
003638r 3  6D 6F 64             .byte "mod"
00363Br 3               
00363Br 3               nt_slash_mod:
00363Br 3  04 10                .byte 4, UF
00363Dr 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
003641r 3  rr rr        
003643r 3  2F 6D 6F 64          .byte "/mod"
003647r 3               
003647r 3               nt_slash:
003647r 3  01 10                .byte 1, UF
003649r 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
00364Dr 3  rr rr        
00364Fr 3  2F                   .byte "/"
003650r 3               
003650r 3               nt_fm_slash_mod:
003650r 3  06 10                .byte 6, UF
003652r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
003656r 3  rr rr        
003658r 3  66 6D 2F 6D          .byte "fm/mod"
00365Cr 3  6F 64        
00365Er 3               
00365Er 3               nt_sm_slash_rem:
00365Er 3  06 10                .byte 6, UF
003660r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
003664r 3  rr rr        
003666r 3  73 6D 2F 72          .byte "sm/rem"
00366Ar 3  65 6D        
00366Cr 3               
00366Cr 3               nt_um_slash_mod:
00366Cr 3  06 10                .byte 6, UF
00366Er 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
003672r 3  rr rr        
003674r 3  75 6D 2F 6D          .byte "um/mod"
003678r 3  6F 64        
00367Ar 3               
00367Ar 3               nt_star:
00367Ar 3  01 10                .byte 1, UF
00367Cr 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
003680r 3  rr rr        
003682r 3  2A                   .byte "*"
003683r 3               
003683r 3               nt_um_star:
003683r 3  03 10                .byte 3, UF
003685r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
003689r 3  rr rr        
00368Br 3  75 6D 2A             .byte "um*"
00368Er 3               
00368Er 3               nt_m_star:
00368Er 3  02 10                .byte 2, UF
003690r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
003694r 3  rr rr        
003696r 3  6D 2A                .byte "m*"
003698r 3               
003698r 3               nt_count:
003698r 3  05 10                .byte 5, UF
00369Ar 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
00369Er 3  rr rr        
0036A0r 3  63 6F 75 6E          .byte "count"
0036A4r 3  74           
0036A5r 3               
0036A5r 3               nt_decimal:
0036A5r 3  07 00                .byte 7, 0
0036A7r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
0036ABr 3  rr rr        
0036ADr 3  64 65 63 69          .byte "decimal"
0036B1r 3  6D 61 6C     
0036B4r 3               
0036B4r 3               nt_hex:
0036B4r 3  03 00                .byte 3, 0
0036B6r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
0036BAr 3  rr rr        
0036BCr 3  68 65 78             .byte "hex"
0036BFr 3               
0036BFr 3               nt_to_number:
0036BFr 3  07 10                .byte 7, UF
0036C1r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
0036C5r 3  rr rr        
0036C7r 3  3E 6E 75 6D          .byte ">number"
0036CBr 3  62 65 72     
0036CEr 3               
0036CEr 3               nt_number:
0036CEr 3  06 10                .byte 6, UF
0036D0r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
0036D4r 3  rr rr        
0036D6r 3  6E 75 6D 62          .byte "number"
0036DAr 3  65 72        
0036DCr 3               
0036DCr 3               nt_digit_question:
0036DCr 3  06 10                .byte 6, UF
0036DEr 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
0036E2r 3  rr rr        
0036E4r 3  64 69 67 69          .byte "digit?"
0036E8r 3  74 3F        
0036EAr 3               
0036EAr 3               nt_base:
0036EAr 3  04 00                .byte 4, 0
0036ECr 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
0036F0r 3  rr rr        
0036F2r 3  62 61 73 65          .byte "base"
0036F6r 3               
0036F6r 3               nt_evaluate:
0036F6r 3  08 10                .byte 8, UF
0036F8r 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
0036FCr 3  rr rr        
0036FEr 3  65 76 61 6C          .byte "evaluate"
003702r 3  75 61 74 65  
003706r 3               
003706r 3               nt_state:
003706r 3  05 00                .byte 5, 0
003708r 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
00370Cr 3  rr rr        
00370Er 3  73 74 61 74          .byte "state"
003712r 3  65           
003713r 3               
003713r 3               nt_again:
003713r 3  05 17                .byte 5, AN+CO+IM+UF
003715r 3  rr rr rr rr          .word nt_state, xt_again, z_again
003719r 3  rr rr        
00371Br 3  61 67 61 69          .byte "again"
00371Fr 3  6E           
003720r 3               
003720r 3               nt_begin:
003720r 3  05 07                .byte 5, AN+CO+IM
003722r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
003726r 3  rr rr        
003728r 3  62 65 67 69          .byte "begin"
00372Cr 3  6E           
00372Dr 3               
00372Dr 3               nt_quit:
00372Dr 3  04 00                .byte 4, 0
00372Fr 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
003733r 3  rr rr        
003735r 3  71 75 69 74          .byte "quit"
003739r 3               
003739r 3               nt_recurse:
003739r 3  07 0D                .byte 7, CO+IM+NN
00373Br 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
00373Fr 3  rr rr        
003741r 3  72 65 63 75          .byte "recurse"
003745r 3  72 73 65     
003748r 3               
003748r 3               nt_leave:
003748r 3  05 03                .byte 5, AN+CO
00374Ar 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
00374Er 3  rr rr        
003750r 3  6C 65 61 76          .byte "leave"
003754r 3  65           
003755r 3               
003755r 3               nt_unloop:
003755r 3  06 03                .byte 6, AN+CO
003757r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
00375Br 3  rr rr        
00375Dr 3  75 6E 6C 6F          .byte "unloop"
003761r 3  6F 70        
003763r 3               
003763r 3               nt_exit:
003763r 3  04 03                .byte 4, AN+CO
003765r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
003769r 3  rr rr        
00376Br 3  65 78 69 74          .byte "exit"
00376Fr 3               
00376Fr 3               nt_plus_loop:
00376Fr 3  05 05                .byte 5, CO+IM
003771r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
003775r 3  rr rr        
003777r 3  2B 6C 6F 6F          .byte "+loop"
00377Br 3  70           
00377Cr 3               
00377Cr 3               nt_loop:
00377Cr 3  04 05                .byte 4, CO+IM
00377Er 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
003782r 3  rr rr        
003784r 3  6C 6F 6F 70          .byte "loop"
003788r 3               
003788r 3               nt_j:
003788r 3  01 03                .byte 1, AN+CO
00378Ar 3  rr rr rr rr          .word nt_loop, xt_j, z_j
00378Er 3  rr rr        
003790r 3  6A                   .byte "j"
003791r 3               
003791r 3               nt_i:
003791r 3  01 03                .byte 1, AN+CO
003793r 3  rr rr rr rr          .word nt_j, xt_i, z_i
003797r 3  rr rr        
003799r 3  69                   .byte "i"
00379Ar 3               
00379Ar 3               nt_question_do:
00379Ar 3  03 0D                .byte 3, CO+IM+NN
00379Cr 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
0037A0r 3  rr rr        
0037A2r 3  3F 64 6F             .byte "?do"
0037A5r 3               
0037A5r 3               nt_do:
0037A5r 3  02 0D                .byte 2, CO+IM+NN
0037A7r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
0037ABr 3  rr rr        
0037ADr 3  64 6F                .byte "do"
0037AFr 3               
0037AFr 3               nt_abort_quote:
0037AFr 3  06 0D                .byte 6, CO+IM+NN
0037B1r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
0037B5r 3  rr rr        
0037B7r 3  61 62 6F 72          .byte "abort", $22
0037BBr 3  74 22        
0037BDr 3               
0037BDr 3               nt_abort:
0037BDr 3  05 00                .byte 5, 0
0037BFr 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
0037C3r 3  rr rr        
0037C5r 3  61 62 6F 72          .byte "abort"
0037C9r 3  74           
0037CAr 3               
0037CAr 3               nt_strip_underflow:
0037CAr 3  0F 00                .byte 15, 0
0037CCr 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
0037D0r 3  rr rr        
0037D2r 3  73 74 72 69          .byte "strip-underflow"
0037D6r 3  70 2D 75 6E  
0037DAr 3  64 65 72 66  
0037E1r 3               
0037E1r 3               nt_nc_limit:
0037E1r 3  08 00                .byte 8, 0
0037E3r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
0037E7r 3  rr rr        
0037E9r 3  6E 63 2D 6C          .byte "nc-limit"
0037EDr 3  69 6D 69 74  
0037F1r 3               
0037F1r 3               nt_allow_native:
0037F1r 3  0C 00                .byte 12, 0
0037F3r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
0037F7r 3  rr rr        
0037F9r 3  61 6C 6C 6F          .byte "allow-native"
0037FDr 3  77 2D 6E 61  
003801r 3  74 69 76 65  
003805r 3               
003805r 3               nt_always_native:
003805r 3  0D 00                .byte 13, 0
003807r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
00380Br 3  rr rr        
00380Dr 3  61 6C 77 61          .byte "always-native"
003811r 3  79 73 2D 6E  
003815r 3  61 74 69 76  
00381Ar 3               
00381Ar 3               nt_never_native:
00381Ar 3  0C 00                .byte 12, 0
00381Cr 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
003820r 3  rr rr        
003822r 3  6E 65 76 65          .byte "never-native"
003826r 3  72 2D 6E 61  
00382Ar 3  74 69 76 65  
00382Er 3               
00382Er 3               nt_compile_only:
00382Er 3  0C 00                .byte 12, 0
003830r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003834r 3  rr rr        
003836r 3  63 6F 6D 70          .byte "compile-only"
00383Ar 3  69 6C 65 2D  
00383Er 3  6F 6E 6C 79  
003842r 3               
003842r 3               nt_immediate:
003842r 3  09 00                .byte 9, 0
003844r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
003848r 3  rr rr        
00384Ar 3  69 6D 6D 65          .byte "immediate"
00384Er 3  64 69 61 74  
003852r 3  65           
003853r 3               
003853r 3               nt_postpone:
003853r 3  08 05                .byte 8, IM+CO
003855r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
003859r 3  rr rr        
00385Br 3  70 6F 73 74          .byte "postpone"
00385Fr 3  70 6F 6E 65  
003863r 3               
003863r 3               nt_s_backslash_quote:
003863r 3  03 04                .byte 3, IM
003865r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
003869r 3  rr rr        
00386Br 3  73 5C 22             .byte "s", $5C, $22
00386Er 3               
00386Er 3               nt_s_quote:
00386Er 3  02 0C                .byte 2, IM+NN
003870r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
003874r 3  rr rr        
003876r 3  73 22                .byte "s", $22
003878r 3               
003878r 3               nt_dot_quote:
003878r 3  02 05                .byte 2, CO+IM
00387Ar 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
00387Er 3  rr rr        
003880r 3  2E 22                .byte ".", $22
003882r 3               
003882r 3               nt_sliteral:
003882r 3  08 15                .byte 8, CO+IM+UF
003884r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
003888r 3  rr rr        
00388Ar 3  73 6C 69 74          .byte "sliteral"
00388Er 3  65 72 61 6C  
003892r 3               
003892r 3               nt_literal:
003892r 3  07 15                .byte 7, IM+CO+UF
003894r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
003898r 3  rr rr        
00389Ar 3  6C 69 74 65          .byte "literal"
00389Er 3  72 61 6C     
0038A1r 3               
0038A1r 3               nt_right_bracket:
0038A1r 3  01 04                .byte 1, IM
0038A3r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
0038A7r 3  rr rr        
0038A9r 3  5D                   .byte "]"
0038AAr 3               
0038AAr 3               nt_left_bracket:
0038AAr 3  01 05                .byte 1, IM+CO
0038ACr 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
0038B0r 3  rr rr        
0038B2r 3  5B                   .byte "["
0038B3r 3               
0038B3r 3               nt_compile_comma:
0038B3r 3  08 18                .byte 8, UF+NN
0038B5r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
0038B9r 3  rr rr        
0038BBr 3  63 6F 6D 70          .byte "compile,"
0038BFr 3  69 6C 65 2C  
0038C3r 3               
0038C3r 3               nt_colon_noname:
0038C3r 3  07 00                .byte 7, 0
0038C5r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
0038C9r 3  rr rr        
0038CBr 3  3A 6E 6F 6E          .byte ":noname"
0038CFr 3  61 6D 65     
0038D2r 3               
0038D2r 3               nt_semicolon:
0038D2r 3  01 05                .byte 1, CO+IM
0038D4r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
0038D8r 3  rr rr        
0038DAr 3  3B                   .byte ";"
0038DBr 3               
0038DBr 3               nt_colon:
0038DBr 3  01 00                .byte 1, 0
0038DDr 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
0038E1r 3  rr rr        
0038E3r 3  3A                   .byte ":"
0038E4r 3               
0038E4r 3               nt_source_id:
0038E4r 3  09 00                .byte 9, 0
0038E6r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
0038EAr 3  rr rr        
0038ECr 3  73 6F 75 72          .byte "source-id"
0038F0r 3  63 65 2D 69  
0038F4r 3  64           
0038F5r 3               
0038F5r 3               nt_source:
0038F5r 3  06 00                .byte 6, 0
0038F7r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
0038FBr 3  rr rr        
0038FDr 3  73 6F 75 72          .byte "source"
003901r 3  63 65        
003903r 3               
003903r 3               nt_execute_parsing:
003903r 3  0F 10                .byte 15, UF
003905r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
003909r 3  rr rr        
00390Br 3  65 78 65 63          .byte "execute-parsing"
00390Fr 3  75 74 65 2D  
003913r 3  70 61 72 73  
00391Ar 3               
00391Ar 3               nt_parse:
00391Ar 3  05 10                .byte 5, UF
00391Cr 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
003920r 3  rr rr        
003922r 3  70 61 72 73          .byte "parse"
003926r 3  65           
003927r 3               
003927r 3               nt_parse_name:
003927r 3  0A 08                .byte 10, NN
003929r 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
00392Dr 3  rr rr        
00392Fr 3  70 61 72 73          .byte "parse-name"
003933r 3  65 2D 6E 61  
003937r 3  6D 65        
003939r 3               
003939r 3               nt_latestnt:
003939r 3  08 00                .byte 8, 0
00393Br 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
00393Fr 3  rr rr        
003941r 3  6C 61 74 65          .byte "latestnt"
003945r 3  73 74 6E 74  
003949r 3               
003949r 3               nt_latestxt:
003949r 3  08 00                .byte 8, 0
00394Br 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
00394Fr 3  rr rr        
003951r 3  6C 61 74 65          .byte "latestxt"
003955r 3  73 74 78 74  
003959r 3               
003959r 3               nt_defer:
003959r 3  05 00                .byte 5, 0
00395Br 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
00395Fr 3  rr rr        
003961r 3  64 65 66 65          .byte "defer"
003965r 3  72           
003966r 3               
003966r 3               nt_to_body:
003966r 3  05 10                .byte 5, UF
003968r 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
00396Cr 3  rr rr        
00396Er 3  3E 62 6F 64          .byte ">body"
003972r 3  79           
003973r 3               
003973r 3               nt_name_to_string:
003973r 3  0B 10                .byte 11, UF
003975r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
003979r 3  rr rr        
00397Br 3  6E 61 6D 65          .byte "name>string"
00397Fr 3  3E 73 74 72  
003983r 3  69 6E 67     
003986r 3               
003986r 3               nt_int_to_name:
003986r 3  08 10                .byte 8, UF
003988r 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
00398Cr 3  rr rr        
00398Er 3  69 6E 74 3E          .byte "int>name"
003992r 3  6E 61 6D 65  
003996r 3               
003996r 3               nt_name_to_int:
003996r 3  08 10                .byte 8, UF
003998r 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
00399Cr 3  rr rr        
00399Er 3  6E 61 6D 65          .byte "name>int"
0039A2r 3  3E 69 6E 74  
0039A6r 3               
0039A6r 3               nt_bracket_tick:
0039A6r 3  03 05                .byte 3, CO+IM
0039A8r 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
0039ACr 3  rr rr        
0039AEr 3  5B 27 5D             .byte "[']"
0039B1r 3               
0039B1r 3               nt_tick:
0039B1r 3  01 00                .byte 1, 0
0039B3r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
0039B7r 3  rr rr        
0039B9r 3  27                   .byte "'"
0039BAr 3               
0039BAr 3               nt_find_name:
0039BAr 3  09 10                .byte 9, UF
0039BCr 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
0039C0r 3  rr rr        
0039C2r 3  66 69 6E 64          .byte "find-name"
0039C6r 3  2D 6E 61 6D  
0039CAr 3  65           
0039CBr 3               
0039CBr 3               nt_fill:
0039CBr 3  04 10                .byte 4, UF
0039CDr 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
0039D1r 3  rr rr        
0039D3r 3  66 69 6C 6C          .byte "fill"
0039D7r 3               
0039D7r 3               nt_blank:
0039D7r 3  05 00                .byte 5, 0     ; underflow checked by FILL
0039D9r 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
0039DDr 3  rr rr        
0039DFr 3  62 6C 61 6E          .byte "blank"
0039E3r 3  6B           
0039E4r 3               
0039E4r 3               nt_erase:
0039E4r 3  05 00                .byte 5, 0      ; underflow checked by FILL
0039E6r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
0039EAr 3  rr rr        
0039ECr 3  65 72 61 73          .byte "erase"
0039F0r 3  65           
0039F1r 3               
0039F1r 3               nt_d_plus:
0039F1r 3  02 10                .byte 2, UF
0039F3r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
0039F7r 3  rr rr        
0039F9r 3  64 2B                .byte "d+"
0039FBr 3               
0039FBr 3               nt_d_minus:
0039FBr 3  02 10                .byte 2, UF
0039FDr 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
003A01r 3  rr rr        
003A03r 3  64 2D                .byte "d-"
003A05r 3               
003A05r 3               nt_d_to_s:
003A05r 3  03 10                .byte 3, UF
003A07r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
003A0Br 3  rr rr        
003A0Dr 3  64 3E 73             .byte "d>s"
003A10r 3               
003A10r 3               nt_s_to_d:
003A10r 3  03 10                .byte 3, UF
003A12r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
003A16r 3  rr rr        
003A18r 3  73 3E 64             .byte "s>d"
003A1Br 3               
003A1Br 3               nt_to:
003A1Br 3  02 0C                .byte 2, NN+IM
003A1Dr 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
003A21r 3  rr rr        
003A23r 3  74 6F                .byte "to"
003A25r 3               
003A25r 3               nt_value:               ; same code as CONSTANT
003A25r 3  05 10                .byte 5, UF
003A27r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
003A2Br 3  rr rr        
003A2Dr 3  76 61 6C 75          .byte "value"
003A31r 3  65           
003A32r 3               
003A32r 3               nt_constant:
003A32r 3  08 10                .byte 8, UF
003A34r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
003A38r 3  rr rr        
003A3Ar 3  63 6F 6E 73          .byte "constant"
003A3Er 3  74 61 6E 74  
003A42r 3               
003A42r 3               nt_variable:
003A42r 3  08 00                .byte 8, 0
003A44r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
003A48r 3  rr rr        
003A4Ar 3  76 61 72 69          .byte "variable"
003A4Er 3  61 62 6C 65  
003A52r 3               
003A52r 3               nt_does:
003A52r 3  05 05                .byte 5, CO+IM
003A54r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
003A58r 3  rr rr        
003A5Ar 3  64 6F 65 73          .byte "does>"
003A5Er 3  3E           
003A5Fr 3               
003A5Fr 3               nt_create:
003A5Fr 3  06 00                .byte 6, 0
003A61r 3  rr rr rr rr          .word nt_does, xt_create, z_create
003A65r 3  rr rr        
003A67r 3  63 72 65 61          .byte "create"
003A6Br 3  74 65        
003A6Dr 3               
003A6Dr 3               nt_allot:
003A6Dr 3  05 10                .byte 5, UF
003A6Fr 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
003A73r 3  rr rr        
003A75r 3  61 6C 6C 6F          .byte "allot"
003A79r 3  74           
003A7Ar 3               
003A7Ar 3               nt_key:
003A7Ar 3  03 00                .byte 3, 0
003A7Cr 3  rr rr rr rr          .word nt_allot, xt_key, z_key
003A80r 3  rr rr        
003A82r 3  6B 65 79             .byte "key"
003A85r 3               
003A85r 3               nt_depth:
003A85r 3  05 00                .byte 5, 0
003A87r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
003A8Br 3  rr rr        
003A8Dr 3  64 65 70 74          .byte "depth"
003A91r 3  68           
003A92r 3               
003A92r 3               nt_unused:
003A92r 3  06 00                .byte 6, 0
003A94r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
003A98r 3  rr rr        
003A9Ar 3  75 6E 75 73          .byte "unused"
003A9Er 3  65 64        
003AA0r 3               
003AA0r 3               nt_r_to_input:
003AA0r 3  07 08                .byte 7, NN
003AA2r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
003AA6r 3  rr rr        
003AA8r 3  72 3E 69 6E          .byte "r>input"
003AACr 3  70 75 74     
003AAFr 3               
003AAFr 3               nt_input_to_r:
003AAFr 3  07 08                .byte 7, NN
003AB1r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
003AB5r 3  rr rr        
003AB7r 3  69 6E 70 75          .byte "input>r"
003ABBr 3  74 3E 72     
003ABEr 3               
003ABEr 3               nt_accept:
003ABEr 3  06 18                .byte 6, UF+NN
003AC0r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
003AC4r 3  rr rr        
003AC6r 3  61 63 63 65          .byte "accept"
003ACAr 3  70 74        
003ACCr 3               
003ACCr 3               nt_refill:
003ACCr 3  06 00                .byte 6, 0
003ACEr 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
003AD2r 3  rr rr        
003AD4r 3  72 65 66 69          .byte "refill"
003AD8r 3  6C 6C        
003ADAr 3               
003ADAr 3               nt_slash_string:
003ADAr 3  07 10                .byte 7, UF
003ADCr 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
003AE0r 3  rr rr        
003AE2r 3  2F 73 74 72          .byte "/string"
003AE6r 3  69 6E 67     
003AE9r 3               
003AE9r 3               nt_minus_leading:
003AE9r 3  08 10                .byte 8, UF
003AEBr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
003AEFr 3  rr rr        
003AF1r 3  2D 6C 65 61          .byte "-leading"
003AF5r 3  64 69 6E 67  
003AF9r 3               
003AF9r 3               nt_minus_trailing:
003AF9r 3  09 10                .byte 9, UF
003AFBr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
003AFFr 3  rr rr        
003B01r 3  2D 74 72 61          .byte "-trailing"
003B05r 3  69 6C 69 6E  
003B09r 3  67           
003B0Ar 3               
003B0Ar 3               nt_bl:
003B0Ar 3  02 00                .byte 2, 0
003B0Cr 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
003B10r 3  rr rr        
003B12r 3  62 6C                .byte "bl"
003B14r 3               
003B14r 3               nt_spaces:
003B14r 3  06 10                .byte 6, UF
003B16r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
003B1Ar 3  rr rr        
003B1Cr 3  73 70 61 63          .byte "spaces"
003B20r 3  65 73        
003B22r 3               
003B22r 3               nt_bounds:
003B22r 3  06 10                .byte 6, UF
003B24r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
003B28r 3  rr rr        
003B2Ar 3  62 6F 75 6E          .byte "bounds"
003B2Er 3  64 73        
003B30r 3               
003B30r 3               nt_c_comma:
003B30r 3  02 10                .byte 2, UF
003B32r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
003B36r 3  rr rr        
003B38r 3  63 2C                .byte "c,"
003B3Ar 3               
003B3Ar 3               nt_dnegate:
003B3Ar 3  07 10                .byte 7, UF
003B3Cr 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
003B40r 3  rr rr        
003B42r 3  64 6E 65 67          .byte "dnegate"
003B46r 3  61 74 65     
003B49r 3               
003B49r 3               nt_negate:
003B49r 3  06 10                .byte 6, UF
003B4Br 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
003B4Fr 3  rr rr        
003B51r 3  6E 65 67 61          .byte "negate"
003B55r 3  74 65        
003B57r 3               
003B57r 3               nt_invert:
003B57r 3  06 10                .byte 6, UF
003B59r 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
003B5Dr 3  rr rr        
003B5Fr 3  69 6E 76 65          .byte "invert"
003B63r 3  72 74        
003B65r 3               
003B65r 3               nt_two_to_r:
003B65r 3  03 11                .byte 3, CO+UF          ; native is special case
003B67r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
003B6Br 3  rr rr        
003B6Dr 3  32 3E 72             .byte "2>r"
003B70r 3               
003B70r 3               nt_two_r_from:
003B70r 3  03 01                .byte 3, CO             ; native is special case
003B72r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
003B76r 3  rr rr        
003B78r 3  32 72 3E             .byte "2r>"
003B7Br 3               
003B7Br 3               nt_two_r_fetch:
003B7Br 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
003B7Dr 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
003B81r 3  rr rr        
003B83r 3  32 72 40             .byte "2r@"
003B86r 3               
003B86r 3               nt_two_literal:
003B86r 3  08 14                .byte 8, UF+IM
003B88r 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
003B8Cr 3  rr rr        
003B8Er 3  32 6C 69 74          .byte "2literal"
003B92r 3  65 72 61 6C  
003B96r 3               
003B96r 3               nt_two_constant:
003B96r 3  09 10                .byte 9, UF
003B98r 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
003B9Cr 3  rr rr        
003B9Er 3  32 63 6F 6E          .byte "2constant"
003BA2r 3  73 74 61 6E  
003BA6r 3  74           
003BA7r 3               
003BA7r 3               nt_two_variable:
003BA7r 3  09 00                .byte 9, 0
003BA9r 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
003BADr 3  rr rr        
003BAFr 3  32 76 61 72          .byte "2variable"
003BB3r 3  69 61 62 6C  
003BB7r 3  65           
003BB8r 3               
003BB8r 3               nt_two_fetch:
003BB8r 3  02 10                .byte 2, UF
003BBAr 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
003BBEr 3  rr rr        
003BC0r 3  32 40                .byte "2@"
003BC2r 3               
003BC2r 3               nt_two_store:
003BC2r 3  02 10                .byte 2, UF
003BC4r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
003BC8r 3  rr rr        
003BCAr 3  32 21                .byte "2!"
003BCCr 3               
003BCCr 3               nt_two_over:
003BCCr 3  05 10                .byte 5, UF
003BCEr 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
003BD2r 3  rr rr        
003BD4r 3  32 6F 76 65          .byte "2over"
003BD8r 3  72           
003BD9r 3               
003BD9r 3               nt_two_swap:
003BD9r 3  05 10                .byte 5, UF
003BDBr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
003BDFr 3  rr rr        
003BE1r 3  32 73 77 61          .byte "2swap"
003BE5r 3  70           
003BE6r 3               
003BE6r 3               nt_two_drop:
003BE6r 3  05 10                .byte 5, UF
003BE8r 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
003BECr 3  rr rr        
003BEEr 3  32 64 72 6F          .byte "2drop"
003BF2r 3  70           
003BF3r 3               
003BF3r 3               nt_max:
003BF3r 3  03 10                .byte 3, UF
003BF5r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
003BF9r 3  rr rr        
003BFBr 3  6D 61 78             .byte "max"
003BFEr 3               
003BFEr 3               nt_min:
003BFEr 3  03 10                .byte 3, UF
003C00r 3  rr rr rr rr          .word nt_max, xt_min, z_min
003C04r 3  rr rr        
003C06r 3  6D 69 6E             .byte "min"
003C09r 3               
003C09r 3               nt_zero_less:
003C09r 3  02 10                .byte 2, UF
003C0Br 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
003C0Fr 3  rr rr        
003C11r 3  30 3C                .byte "0<"
003C13r 3               
003C13r 3               nt_zero_greater:
003C13r 3  02 10                .byte 2, UF
003C15r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
003C19r 3  rr rr        
003C1Br 3  30 3E                .byte "0>"
003C1Dr 3               
003C1Dr 3               nt_zero_unequal:
003C1Dr 3  03 10                .byte 3, UF
003C1Fr 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
003C23r 3  rr rr        
003C25r 3  30 3C 3E             .byte "0<>"
003C28r 3               
003C28r 3               nt_zero_equal:
003C28r 3  02 10                .byte 2, UF
003C2Ar 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
003C2Er 3  rr rr        
003C30r 3  30 3D                .byte "0="
003C32r 3               
003C32r 3               nt_greater_than:
003C32r 3  01 10                .byte 1, UF
003C34r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
003C38r 3  rr rr        
003C3Ar 3  3E                   .byte ">"
003C3Br 3               
003C3Br 3               nt_u_greater_than:
003C3Br 3  02 10                .byte 2, UF
003C3Dr 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
003C41r 3  rr rr        
003C43r 3  75 3E                .byte "u>"
003C45r 3               
003C45r 3               nt_u_less_than:
003C45r 3  02 10                .byte 2, UF
003C47r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
003C4Br 3  rr rr        
003C4Dr 3  75 3C                .byte "u<"
003C4Fr 3               
003C4Fr 3               nt_less_than:
003C4Fr 3  01 10                .byte 1, UF
003C51r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
003C55r 3  rr rr        
003C57r 3  3C                   .byte "<"
003C58r 3               
003C58r 3               nt_not_equals:
003C58r 3  02 10                .byte 2, UF
003C5Ar 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
003C5Er 3  rr rr        
003C60r 3  3C 3E                .byte "<>"
003C62r 3               
003C62r 3               nt_equal:
003C62r 3  01 10                .byte 1, UF
003C64r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
003C68r 3  rr rr        
003C6Ar 3  3D                   .byte "="
003C6Br 3               
003C6Br 3               nt_two_slash:
003C6Br 3  02 10                .byte 2, UF
003C6Dr 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
003C71r 3  rr rr        
003C73r 3  32 2F                .byte "2/"
003C75r 3               
003C75r 3               nt_two_star:
003C75r 3  02 10                .byte 2, UF
003C77r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
003C7Br 3  rr rr        
003C7Dr 3  32 2A                .byte "2*"
003C7Fr 3               
003C7Fr 3               nt_one_plus:
003C7Fr 3  02 10                .byte 2, UF
003C81r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
003C85r 3  rr rr        
003C87r 3  31 2B                .byte "1+"
003C89r 3               
003C89r 3               nt_one_minus:
003C89r 3  02 10                .byte 2, UF
003C8Br 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
003C8Fr 3  rr rr        
003C91r 3  31 2D                .byte "1-"
003C93r 3               
003C93r 3               nt_here:
003C93r 3  04 00                .byte 4, 0
003C95r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
003C99r 3  rr rr        
003C9Br 3  68 65 72 65          .byte "here"
003C9Fr 3               
003C9Fr 3               nt_cell_plus:
003C9Fr 3  05 10                .byte 5, UF
003CA1r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
003CA5r 3  rr rr        
003CA7r 3  63 65 6C 6C          .byte "cell+"
003CABr 3  2B           
003CACr 3               
003CACr 3               nt_cells:
003CACr 3  05 00                .byte 5, 0
003CAEr 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
003CB2r 3  rr rr        
003CB4r 3  63 65 6C 6C          .byte "cells"
003CB8r 3  73           
003CB9r 3               
003CB9r 3               nt_chars:
003CB9r 3  05 12                .byte 5, AN+UF   ; deleted during compile
003CBBr 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
003CBFr 3  rr rr        
003CC1r 3  63 68 61 72          .byte "chars"
003CC5r 3  73           
003CC6r 3               
003CC6r 3               nt_char_plus:
003CC6r 3  05 00                .byte 5, 0
003CC8r 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
003CCCr 3  rr rr        
003CCEr 3  63 68 61 72          .byte "char+"
003CD2r 3  2B           
003CD3r 3               
003CD3r 3               nt_bracket_char:
003CD3r 3  06 05                .byte 6, CO+IM
003CD5r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
003CD9r 3  rr rr        
003CDBr 3  5B 63 68 61          .byte "[char]"
003CDFr 3  72 5D        
003CE1r 3               
003CE1r 3               nt_char:
003CE1r 3  04 00                .byte 4, 0
003CE3r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
003CE7r 3  rr rr        
003CE9r 3  63 68 61 72          .byte "char"
003CEDr 3               
003CEDr 3               nt_pick:
003CEDr 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
003CEFr 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
003CF3r 3  rr rr        
003CF5r 3  70 69 63 6B          .byte "pick"
003CF9r 3               
003CF9r 3               nt_lshift:
003CF9r 3  06 10                .byte 6, UF
003CFBr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
003CFFr 3  rr rr        
003D01r 3  6C 73 68 69          .byte "lshift"
003D05r 3  66 74        
003D07r 3               
003D07r 3               nt_rshift:
003D07r 3  06 10                .byte 6, UF
003D09r 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
003D0Dr 3  rr rr        
003D0Fr 3  72 73 68 69          .byte "rshift"
003D13r 3  66 74        
003D15r 3               
003D15r 3               nt_xor:
003D15r 3  03 10                .byte 3, UF
003D17r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
003D1Br 3  rr rr        
003D1Dr 3  78 6F 72             .byte "xor"
003D20r 3               
003D20r 3               nt_or:
003D20r 3  02 10                .byte 2, UF
003D22r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
003D26r 3  rr rr        
003D28r 3  6F 72                .byte "or"
003D2Ar 3               
003D2Ar 3               nt_and:
003D2Ar 3  03 10                .byte 3, UF
003D2Cr 3  rr rr rr rr          .word nt_or, xt_and, z_and
003D30r 3  rr rr        
003D32r 3  61 6E 64             .byte "and"
003D35r 3               
003D35r 3               nt_dabs:
003D35r 3  04 10                .byte 4, UF
003D37r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
003D3Br 3  rr rr        
003D3Dr 3  64 61 62 73          .byte "dabs"
003D41r 3               
003D41r 3               nt_abs:
003D41r 3  03 10                .byte 3, UF
003D43r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
003D47r 3  rr rr        
003D49r 3  61 62 73             .byte "abs"
003D4Cr 3               
003D4Cr 3               nt_minus:
003D4Cr 3  01 10                .byte 1, UF
003D4Er 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
003D52r 3  rr rr        
003D54r 3  2D                   .byte "-"
003D55r 3               
003D55r 3               nt_plus:
003D55r 3  01 10                .byte 1, UF
003D57r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
003D5Br 3  rr rr        
003D5Dr 3  2B                   .byte "+"
003D5Er 3               
003D5Er 3               nt_question_dup:
003D5Er 3  04 10                .byte 4, UF
003D60r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
003D64r 3  rr rr        
003D66r 3  3F 64 75 70          .byte "?dup"
003D6Ar 3               
003D6Ar 3               nt_two_dup:
003D6Ar 3  04 10                .byte 4, UF
003D6Cr 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
003D70r 3  rr rr        
003D72r 3  32 64 75 70          .byte "2dup"
003D76r 3               
003D76r 3               nt_two:
003D76r 3  01 00                .byte 1, 0
003D78r 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
003D7Cr 3  rr rr        
003D7Er 3  32                   .byte "2"
003D7Fr 3               
003D7Fr 3               nt_one:
003D7Fr 3  01 00                .byte 1, 0
003D81r 3  rr rr rr rr          .word nt_two, xt_one, z_one
003D85r 3  rr rr        
003D87r 3  31                   .byte "1"
003D88r 3               
003D88r 3               nt_zero:
003D88r 3  01 00                .byte 1, 0
003D8Ar 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
003D8Er 3  rr rr        
003D90r 3  30                   .byte "0"
003D91r 3               
003D91r 3               nt_space:
003D91r 3  05 00                .byte 5, 0
003D93r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
003D97r 3  rr rr        
003D99r 3  73 70 61 63          .byte "space"
003D9Dr 3  65           
003D9Er 3               
003D9Er 3               nt_true:
003D9Er 3  04 00                .byte 4, 0
003DA0r 3  rr rr rr rr          .word nt_space, xt_true, z_true
003DA4r 3  rr rr        
003DA6r 3  74 72 75 65          .byte "true"
003DAAr 3               
003DAAr 3               nt_false:
003DAAr 3  05 00                .byte 5, 0
003DACr 3  rr rr rr rr          .word nt_true, xt_false, z_false
003DB0r 3  rr rr        
003DB2r 3  66 61 6C 73          .byte "false"
003DB6r 3  65           
003DB7r 3               
003DB7r 3               nt_question:
003DB7r 3  01 00                .byte 1, 0
003DB9r 3  rr rr rr rr          .word nt_false, xt_question, z_question
003DBDr 3  rr rr        
003DBFr 3  3F                   .byte "?"
003DC0r 3               
003DC0r 3               nt_ud_dot_r:
003DC0r 3  04 10                .byte 4, UF
003DC2r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
003DC6r 3  rr rr        
003DC8r 3  75 64 2E 72          .byte "ud.r"
003DCCr 3               
003DCCr 3               nt_ud_dot:
003DCCr 3  03 10                .byte 3, UF
003DCEr 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
003DD2r 3  rr rr        
003DD4r 3  75 64 2E             .byte "ud."
003DD7r 3               
003DD7r 3               nt_d_dot_r:
003DD7r 3  03 10                .byte 3, UF
003DD9r 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
003DDDr 3  rr rr        
003DDFr 3  64 2E 72             .byte "d.r"
003DE2r 3               
003DE2r 3               nt_d_dot:
003DE2r 3  02 10                .byte 2, UF
003DE4r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
003DE8r 3  rr rr        
003DEAr 3  64 2E                .byte "d."
003DECr 3               
003DECr 3               nt_dot_r:
003DECr 3  02 10                .byte 2, UF
003DEEr 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
003DF2r 3  rr rr        
003DF4r 3  2E 72                .byte ".r"
003DF6r 3               
003DF6r 3               nt_u_dot_r:
003DF6r 3  03 10                .byte 3, UF
003DF8r 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
003DFCr 3  rr rr        
003DFEr 3  75 2E 72             .byte "u.r"
003E01r 3               
003E01r 3               nt_u_dot:
003E01r 3  02 10                .byte 2, UF
003E03r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
003E07r 3  rr rr        
003E09r 3  75 2E                .byte "u."
003E0Br 3               
003E0Br 3               nt_dot:
003E0Br 3  01 10                .byte 1, UF
003E0Dr 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
003E11r 3  rr rr        
003E13r 3  2E                   .byte "."
003E14r 3               
003E14r 3               nt_type:
003E14r 3  04 10                .byte 4, UF
003E16r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
003E1Ar 3  rr rr        
003E1Cr 3  74 79 70 65          .byte "type"
003E20r 3               
003E20r 3               nt_emit:
003E20r 3  04 18                .byte 4, NN+UF
003E22r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
003E26r 3  rr rr        
003E28r 3  65 6D 69 74          .byte "emit"
003E2Cr 3               
003E2Cr 3               nt_execute:
003E2Cr 3  07 10                .byte 7, UF
003E2Er 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
003E32r 3  rr rr        
003E34r 3  65 78 65 63          .byte "execute"
003E38r 3  75 74 65     
003E3Br 3               
003E3Br 3               nt_plus_store:
003E3Br 3  02 10                .byte 2, UF
003E3Dr 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
003E41r 3  rr rr        
003E43r 3  2B 21                .byte "+!"
003E45r 3               
003E45r 3               nt_c_store:
003E45r 3  02 10                .byte 2, UF
003E47r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
003E4Br 3  rr rr        
003E4Dr 3  63 21                .byte "c!"
003E4Fr 3               
003E4Fr 3               nt_c_fetch:
003E4Fr 3  02 10                .byte 2, UF
003E51r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
003E55r 3  rr rr        
003E57r 3  63 40                .byte "c@"
003E59r 3               
003E59r 3               nt_comma:
003E59r 3  01 10                .byte 1, UF
003E5Br 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
003E5Fr 3  rr rr        
003E61r 3  2C                   .byte ","
003E62r 3               
003E62r 3               nt_tuck:
003E62r 3  04 10                .byte 4, UF
003E64r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
003E68r 3  rr rr        
003E6Ar 3  74 75 63 6B          .byte "tuck"
003E6Er 3               
003E6Er 3               nt_not_rote:
003E6Er 3  04 10                .byte 4, UF
003E70r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
003E74r 3  rr rr        
003E76r 3  2D 72 6F 74          .byte "-rot"
003E7Ar 3               
003E7Ar 3               nt_rot:
003E7Ar 3  03 10                .byte 3, UF
003E7Cr 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
003E80r 3  rr rr        
003E82r 3  72 6F 74             .byte "rot"
003E85r 3               
003E85r 3               nt_nip:
003E85r 3  03 10                .byte 3, UF
003E87r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
003E8Br 3  rr rr        
003E8Dr 3  6E 69 70             .byte "nip"
003E90r 3               
003E90r 3               nt_r_fetch:
003E90r 3  02 01                .byte 2, CO    ; native is special case
003E92r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
003E96r 3  rr rr        
003E98r 3  72 40                .byte "r@"
003E9Ar 3               
003E9Ar 3               nt_r_from:
003E9Ar 3  02 01                .byte 2, CO    ; native is special case
003E9Cr 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
003EA0r 3  rr rr        
003EA2r 3  72 3E                .byte "r>"
003EA4r 3               
003EA4r 3               nt_to_r:
003EA4r 3  02 11                .byte 2, CO+UF ; native is special case
003EA6r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
003EAAr 3  rr rr        
003EACr 3  3E 72                .byte ">r"
003EAEr 3               
003EAEr 3               nt_over:
003EAEr 3  04 10                .byte 4, UF
003EB0r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
003EB4r 3  rr rr        
003EB6r 3  6F 76 65 72          .byte "over"
003EBAr 3               
003EBAr 3               nt_fetch:
003EBAr 3  01 10                .byte 1, UF
003EBCr 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
003EC0r 3  rr rr        
003EC2r 3  40                   .byte "@"
003EC3r 3               
003EC3r 3               nt_store:
003EC3r 3  01 10                .byte 1, UF
003EC5r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
003EC9r 3  rr rr        
003ECBr 3  21                   .byte "!"
003ECCr 3               
003ECCr 3               nt_swap:
003ECCr 3  04 10                .byte 4, UF
003ECEr 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
003ED2r 3  rr rr        
003ED4r 3  73 77 61 70          .byte "swap"
003ED8r 3               
003ED8r 3               nt_dup:
003ED8r 3  03 10                .byte 3, UF
003EDAr 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
003EDEr 3  rr rr        
003EE0r 3  64 75 70             .byte "dup"
003EE3r 3               
003EE3r 3               ; DROP is always the first native word in the Dictionary
003EE3r 3               dictionary_start:
003EE3r 3               nt_drop:
003EE3r 3  04 10                .byte 4, UF
003EE5r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
003EE9r 3  rr rr        
003EEBr 3  64 72 6F 70          .byte "drop"
003EEFr 3               
003EEFr 3               ; END of FORTH-WORDLIST
003EEFr 3               
003EEFr 3               
003EEFr 3               ; ROOT-WORDLIST
003EEFr 3                       ; This is a short wordlist that has just the words needed to
003EEFr 3                       ; set the wordlists. These words are also included in the
003EEFr 3                       ; FORTH-WORDLIST as well.
003EEFr 3               
003EEFr 3               nt_root_words:
003EEFr 3  05 00                .byte 5, 0
003EF1r 3  00 00 rr rr          .word 0000, xt_words, z_words
003EF5r 3  rr rr        
003EF7r 3  77 6F 72 64          .byte "words"
003EFBr 3  73           
003EFCr 3               
003EFCr 3               nt_root_forth_wordlist: ; shares code with ZERO
003EFCr 3  0E 00                .byte 14, 0
003EFEr 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
003F02r 3  rr rr        
003F04r 3  66 6F 72 74          .byte "forth-wordlist"
003F08r 3  68 2D 77 6F  
003F0Cr 3  72 64 6C 69  
003F12r 3               
003F12r 3               nt_root_forth:
003F12r 3  05 00                .byte 5, 0
003F14r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
003F18r 3  rr rr        
003F1Ar 3  66 6F 72 74          .byte "forth"
003F1Er 3  68           
003F1Fr 3               
003F1Fr 3               root_dictionary_start:
003F1Fr 3               nt_root_set_order:
003F1Fr 3  09 00                .byte 9, 0
003F21r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
003F25r 3  rr rr        
003F27r 3  73 65 74 2D          .byte "set-order"
003F2Br 3  6F 72 64 65  
003F2Fr 3  72           
003F30r 3               
003F30r 3               ; END of ROOT-WORDLIST
003F30r 3               
003F30r 3               
003F30r 3               ; ; EDITOR-WORDLIST
003F30r 3               
003F30r 3               ; nt_editor_enter_screen:
003F30r 3               ;         .byte 12, 0
003F30r 3               ;         .word 0000, xt_editor_enter_screen, z_editor_enter_screen
003F30r 3               ;         .byte "enter-screen"
003F30r 3               
003F30r 3               ; nt_editor_erase_screen:
003F30r 3               ;         .byte 12, 0
003F30r 3               ;         .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
003F30r 3               ;         .byte "erase-screen"
003F30r 3               
003F30r 3               ; nt_editor_el:
003F30r 3               ;         .byte 2, 0
003F30r 3               ;         .word nt_editor_erase_screen, xt_editor_el, z_editor_el
003F30r 3               ;         .byte "el"
003F30r 3               
003F30r 3               ; nt_editor_l:
003F30r 3               ;         .byte 1, 0
003F30r 3               ;         .word nt_editor_el, xt_editor_l, z_editor_l
003F30r 3               ;         .byte "l"
003F30r 3               
003F30r 3               ; nt_editor_line:
003F30r 3               ;         .byte 4, UF
003F30r 3               ;         .word nt_editor_l, xt_editor_line, z_editor_line
003F30r 3               ;         .byte "line"
003F30r 3               
003F30r 3               editor_dictionary_start:
003F30r 3               ; nt_editor_o:
003F30r 3               ;         .byte 1, 0
003F30r 3               ;         .word nt_editor_line, xt_editor_o, z_editor_o
003F30r 3               ;         .byte "o"
003F30r 3               
003F30r 3               ; ; END of EDITOR-WORDLIST
003F30r 3               
003F30r 3               
003F30r 3               ; ; ASSEMBLER-WORDLIST
003F30r 3               
003F30r 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
003F30r 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
003F30r 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
003F30r 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
003F30r 3               assembler_dictionary_start:
003F30r 3               ; nt_asm_adc_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_adc_x
003F30r 3               ; 		.word xt_asm_adc_h, z_asm_adc_h
003F30r 3               ; 		.byte "adc.#"
003F30r 3               
003F30r 3               ; nt_asm_adc_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_adc_y
003F30r 3               ; 		.word xt_asm_adc_x, z_asm_adc_x
003F30r 3               ; 		.byte "adc.x"
003F30r 3               
003F30r 3               ; nt_asm_adc_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_adc_z
003F30r 3               ; 		.word xt_asm_adc_y, z_asm_adc_y
003F30r 3               ; 		.byte "adc.y"
003F30r 3               
003F30r 3               ; nt_asm_adc_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_adc_zi
003F30r 3               ; 		.word xt_asm_adc_z, z_asm_adc_z
003F30r 3               ; 		.byte "adc.z"
003F30r 3               
003F30r 3               ; nt_asm_adc_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_adc_ziy
003F30r 3               ; 		.word xt_asm_adc_zi, z_asm_adc_zi
003F30r 3               ; 		.byte "adc.zi"
003F30r 3               
003F30r 3               ; nt_asm_adc_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_adc_zx
003F30r 3               ; 		.word xt_asm_adc_ziy, z_asm_adc_ziy
003F30r 3               ; 		.byte "adc.ziy"
003F30r 3               
003F30r 3               ; nt_asm_adc_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_adc_zxi
003F30r 3               ; 		.word xt_asm_adc_zx, z_asm_adc_zx
003F30r 3               ; 		.byte "adc.zx"
003F30r 3               
003F30r 3               ; nt_asm_adc_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_and
003F30r 3               ; 		.word xt_asm_adc_zxi, z_asm_adc_zxi
003F30r 3               ; 		.byte "adc.zxi"
003F30r 3               
003F30r 3               ; nt_asm_and:     ; not "and" because of conflicts with Forth word
003F30r 3               ; 		.byte 4, IM
003F30r 3               ;                 .word nt_asm_and_h
003F30r 3               ; 		.word xt_asm_and, z_asm_and
003F30r 3               ; 		.byte "and."
003F30r 3               
003F30r 3               ; nt_asm_and_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_and_x
003F30r 3               ; 		.word xt_asm_and_h, z_asm_and_h
003F30r 3               ; 		.byte "and.#"
003F30r 3               
003F30r 3               ; nt_asm_and_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_and_y
003F30r 3               ; 		.word xt_asm_and_x, z_asm_and_x
003F30r 3               ; 		.byte "and.x"
003F30r 3               
003F30r 3               ; nt_asm_and_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_and_z
003F30r 3               ; 		.word xt_asm_and_y, z_asm_and_y
003F30r 3               ; 		.byte "and.y"
003F30r 3               
003F30r 3               ; nt_asm_and_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_and_zi
003F30r 3               ; 		.word xt_asm_and_z, z_asm_and_z
003F30r 3               ; 		.byte "and.z"
003F30r 3               
003F30r 3               ; nt_asm_and_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_and_ziy
003F30r 3               ; 		.word xt_asm_and_zi, z_asm_and_zi
003F30r 3               ; 		.byte "and.zi"
003F30r 3               
003F30r 3               ; nt_asm_and_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_and_zx
003F30r 3               ; 		.word xt_asm_and_ziy, z_asm_and_ziy
003F30r 3               ; 		.byte "and.ziy"
003F30r 3               
003F30r 3               ; nt_asm_and_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_and_zxi
003F30r 3               ; 		.word xt_asm_and_zx, z_asm_and_zx
003F30r 3               ; 		.byte "and.zx"
003F30r 3               
003F30r 3               ; nt_asm_and_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_asl
003F30r 3               ; 		.word xt_asm_and_zxi, z_asm_and_zxi
003F30r 3               ; 		.byte "and.zxi"
003F30r 3               
003F30r 3               ; nt_asm_asl:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_asl_a
003F30r 3               ; 		.word xt_asm_asl, z_asm_asl
003F30r 3               ; 		.byte "asl"
003F30r 3               
003F30r 3               ; nt_asm_asl_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_asl_x
003F30r 3               ; 		.word xt_asm_asl_a, z_asm_asl_a
003F30r 3               ; 		.byte "asl.a"
003F30r 3               
003F30r 3               ; nt_asm_asl_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_asl_z
003F30r 3               ; 		.word xt_asm_asl_x, z_asm_asl_x
003F30r 3               ; 		.byte "asl.x"
003F30r 3               
003F30r 3               ; nt_asm_asl_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_asl_zx
003F30r 3               ; 		.word xt_asm_asl_z, z_asm_asl_z
003F30r 3               ; 		.byte "asl.z"
003F30r 3               
003F30r 3               ; nt_asm_asl_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_bcc
003F30r 3               ; 		.word xt_asm_asl_zx, z_asm_asl_zx
003F30r 3               ; 		.byte "asl.zx"
003F30r 3               
003F30r 3               ; nt_asm_bcc:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bcs
003F30r 3               ; 		.word xt_asm_bcc, z_asm_bcc
003F30r 3               ; 		.byte "bcc"
003F30r 3               
003F30r 3               ; nt_asm_bcs:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_beq
003F30r 3               ; 		.word xt_asm_bcs, z_asm_bcs
003F30r 3               ; 		.byte "bcs"
003F30r 3               
003F30r 3               ; nt_asm_beq:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bit
003F30r 3               ; 		.word xt_asm_beq, z_asm_beq
003F30r 3               ; 		.byte "beq"
003F30r 3               
003F30r 3               ; nt_asm_bit:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bit_h
003F30r 3               ; 		.word xt_asm_bit, z_asm_bit
003F30r 3               ; 		.byte "bit"
003F30r 3               
003F30r 3               ; nt_asm_bit_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_bit_x
003F30r 3               ; 		.word xt_asm_bit_h, z_asm_bit_h
003F30r 3               ; 		.byte "bit.#"
003F30r 3               
003F30r 3               ; nt_asm_bit_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_bit_z
003F30r 3               ; 		.word xt_asm_bit_x, z_asm_bit_x
003F30r 3               ; 		.byte "bit.x"
003F30r 3               
003F30r 3               ; nt_asm_bit_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_bit_zx
003F30r 3               ; 		.word xt_asm_bit_z, z_asm_bit_z
003F30r 3               ; 		.byte "bit.z"
003F30r 3               
003F30r 3               ; nt_asm_bit_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_bmi
003F30r 3               ; 		.word xt_asm_bit_zx, z_asm_bit_zx
003F30r 3               ; 		.byte "bit.zx"
003F30r 3               
003F30r 3               ; nt_asm_bmi:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bne
003F30r 3               ; 		.word xt_asm_bmi, z_asm_bmi
003F30r 3               ; 		.byte "bmi"
003F30r 3               
003F30r 3               ; nt_asm_bne:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bpl
003F30r 3               ; 		.word xt_asm_bne, z_asm_bne
003F30r 3               ; 		.byte "bne"
003F30r 3               
003F30r 3               ; nt_asm_bpl:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bra
003F30r 3               ; 		.word xt_asm_bpl, z_asm_bpl
003F30r 3               ; 		.byte "bpl"
003F30r 3               
003F30r 3               ; nt_asm_bra:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_brk
003F30r 3               ; 		.word xt_asm_bra, z_asm_bra
003F30r 3               ; 		.byte "bra"
003F30r 3               
003F30r 3               ; nt_asm_brk:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bvc
003F30r 3               ; 		.word xt_asm_brk, z_asm_brk
003F30r 3               ; 		.byte "brk"
003F30r 3               
003F30r 3               ; nt_asm_bvc:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_bvs
003F30r 3               ; 		.word xt_asm_bvc, z_asm_bvc
003F30r 3               ; 		.byte "bvc"
003F30r 3               
003F30r 3               ; nt_asm_bvs:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_clc
003F30r 3               ; 		.word xt_asm_bvs, z_asm_bvs
003F30r 3               ; 		.byte "bvs"
003F30r 3               
003F30r 3               ; nt_asm_clc:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cld
003F30r 3               ; 		.word xt_asm_clc, z_asm_clc
003F30r 3               ; 		.byte "clc"
003F30r 3               
003F30r 3               ; nt_asm_cld:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cli
003F30r 3               ; 		.word xt_asm_cld, z_asm_cld
003F30r 3               ; 		.byte "cld"
003F30r 3               
003F30r 3               ; nt_asm_cli:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_clv
003F30r 3               ; 		.word xt_asm_cli, z_asm_cli
003F30r 3               ; 		.byte "cli"
003F30r 3               
003F30r 3               ; nt_asm_clv:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cmp
003F30r 3               ; 		.word xt_asm_clv, z_asm_clv
003F30r 3               ; 		.byte "clv"
003F30r 3               
003F30r 3               ; nt_asm_cmp:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cmp_h
003F30r 3               ; 		.word xt_asm_cmp, z_asm_cmp
003F30r 3               ; 		.byte "cmp"
003F30r 3               
003F30r 3               ; nt_asm_cmp_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cmp_x
003F30r 3               ; 		.word xt_asm_cmp_h, z_asm_cmp_h
003F30r 3               ; 		.byte "cmp.#"
003F30r 3               
003F30r 3               ; nt_asm_cmp_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cmp_y
003F30r 3               ; 		.word xt_asm_cmp_x, z_asm_cmp_x
003F30r 3               ; 		.byte "cmp.x"
003F30r 3               
003F30r 3               ; nt_asm_cmp_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cmp_z
003F30r 3               ; 		.word xt_asm_cmp_y, z_asm_cmp_y
003F30r 3               ; 		.byte "cmp.y"
003F30r 3               
003F30r 3               ; nt_asm_cmp_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cmp_zi
003F30r 3               ; 		.word xt_asm_cmp_z, z_asm_cmp_z
003F30r 3               ; 		.byte "cmp.z"
003F30r 3               
003F30r 3               ; nt_asm_cmp_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_cmp_ziy
003F30r 3               ; 		.word xt_asm_cmp_zi, z_asm_cmp_zi
003F30r 3               ; 		.byte "cmp.zi"
003F30r 3               
003F30r 3               ; nt_asm_cmp_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_cmp_zx
003F30r 3               ; 		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
003F30r 3               ; 		.byte "cmp.ziy"
003F30r 3               
003F30r 3               ; nt_asm_cmp_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_cmp_zxi
003F30r 3               ; 		.word xt_asm_cmp_zx, z_asm_cmp_zx
003F30r 3               ; 		.byte "cmp.zx"
003F30r 3               
003F30r 3               ; nt_asm_cmp_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_cpx
003F30r 3               ; 		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
003F30r 3               ; 		.byte "cmp.zxi"
003F30r 3               
003F30r 3               ; nt_asm_cpx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cpx_h
003F30r 3               ; 		.word xt_asm_cpx, z_asm_cpx
003F30r 3               ; 		.byte "cpx"
003F30r 3               
003F30r 3               ; nt_asm_cpx_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cpx_z
003F30r 3               ; 		.word xt_asm_cpx_h, z_asm_cpx_h
003F30r 3               ; 		.byte "cpx.#"
003F30r 3               
003F30r 3               ; nt_asm_cpx_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cpy
003F30r 3               ; 		.word xt_asm_cpx_z, z_asm_cpx_z
003F30r 3               ; 		.byte "cpx.z"
003F30r 3               
003F30r 3               ; nt_asm_cpy:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_cpy_h
003F30r 3               ; 		.word xt_asm_cpy, z_asm_cpy
003F30r 3               ; 		.byte "cpy"
003F30r 3               
003F30r 3               ; nt_asm_cpy_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_cpy_z
003F30r 3               ; 		.word xt_asm_cpy_h, z_asm_cpy_h
003F30r 3               ; 		.byte "cpy.#"
003F30r 3               
003F30r 3               ; nt_asm_cpy_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_dec
003F30r 3               ; 		.word xt_asm_cpy_z, z_asm_cpy_z
003F30r 3               ; 		.byte "cpy.z"
003F30r 3               
003F30r 3               ; nt_asm_dec:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_dec_a
003F30r 3               ; 		.word xt_asm_dec, z_asm_dec
003F30r 3               ; 		.byte "dec"
003F30r 3               
003F30r 3               ; nt_asm_dec_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_dec_x
003F30r 3               ; 		.word xt_asm_dec_a, z_asm_dec_a
003F30r 3               ; 		.byte "dec.a"
003F30r 3               
003F30r 3               ; nt_asm_dec_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_dec_z
003F30r 3               ; 		.word xt_asm_dec_x, z_asm_dec_x
003F30r 3               ; 		.byte "dec.x"
003F30r 3               
003F30r 3               ; nt_asm_dec_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_dec_zx
003F30r 3               ; 		.word xt_asm_dec_z, z_asm_dec_z
003F30r 3               ; 		.byte "dec.z"
003F30r 3               
003F30r 3               ; nt_asm_dec_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_dex
003F30r 3               ; 		.word xt_asm_dec_zx, z_asm_dec_zx
003F30r 3               ; 		.byte "dec.zx"
003F30r 3               
003F30r 3               ; nt_asm_dex:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_dey
003F30r 3               ; 		.word xt_asm_dex, z_asm_dex
003F30r 3               ; 		.byte "dex"
003F30r 3               
003F30r 3               ; nt_asm_dey:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_eor
003F30r 3               ; 		.word xt_asm_dey, z_asm_dey
003F30r 3               ; 		.byte "dey"
003F30r 3               
003F30r 3               ; nt_asm_eor:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_eor_h
003F30r 3               ; 		.word xt_asm_eor, z_asm_eor
003F30r 3               ; 		.byte "eor"
003F30r 3               
003F30r 3               ; nt_asm_eor_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_eor_x
003F30r 3               ; 		.word xt_asm_eor_h, z_asm_eor_h
003F30r 3               ; 		.byte "eor.#"
003F30r 3               
003F30r 3               ; nt_asm_eor_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_eor_y
003F30r 3               ; 		.word xt_asm_eor_x, z_asm_eor_x
003F30r 3               ; 		.byte "eor.x"
003F30r 3               
003F30r 3               ; nt_asm_eor_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_eor_z
003F30r 3               ; 		.word xt_asm_eor_y, z_asm_eor_y
003F30r 3               ; 		.byte "eor.y"
003F30r 3               
003F30r 3               ; nt_asm_eor_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_eor_zi
003F30r 3               ; 		.word xt_asm_eor_z, z_asm_eor_z
003F30r 3               ; 		.byte "eor.z"
003F30r 3               
003F30r 3               ; nt_asm_eor_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_eor_ziy
003F30r 3               ; 		.word xt_asm_eor_zi, z_asm_eor_zi
003F30r 3               ; 		.byte "eor.zi"
003F30r 3               
003F30r 3               ; nt_asm_eor_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_eor_zx
003F30r 3               ; 		.word xt_asm_eor_ziy, z_asm_eor_ziy
003F30r 3               ; 		.byte "eor.ziy"
003F30r 3               
003F30r 3               ; nt_asm_eor_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_eor_zxi
003F30r 3               ; 		.word xt_asm_eor_zx, z_asm_eor_zx
003F30r 3               ; 		.byte "eor.zx"
003F30r 3               
003F30r 3               ; nt_asm_eor_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_inc
003F30r 3               ; 		.word xt_asm_eor_zxi, z_asm_eor_zxi
003F30r 3               ; 		.byte "eor.zxi"
003F30r 3               
003F30r 3               ; nt_asm_inc:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_inc_a
003F30r 3               ; 		.word xt_asm_inc, z_asm_inc
003F30r 3               ; 		.byte "inc"
003F30r 3               
003F30r 3               ; nt_asm_inc_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_inc_x
003F30r 3               ; 		.word xt_asm_inc_a, z_asm_inc_a
003F30r 3               ; 		.byte "inc.a"
003F30r 3               
003F30r 3               ; nt_asm_inc_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_inc_z
003F30r 3               ; 		.word xt_asm_inc_x, z_asm_inc_x
003F30r 3               ; 		.byte "inc.x"
003F30r 3               
003F30r 3               ; nt_asm_inc_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_inc_zx
003F30r 3               ; 		.word xt_asm_inc_z, z_asm_inc_z
003F30r 3               ; 		.byte "inc.z"
003F30r 3               
003F30r 3               ; nt_asm_inc_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_inx
003F30r 3               ; 		.word xt_asm_inc_zx, z_asm_inc_zx
003F30r 3               ; 		.byte "inc.zx"
003F30r 3               
003F30r 3               ; nt_asm_inx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_iny
003F30r 3               ; 		.word xt_asm_inx, z_asm_inx
003F30r 3               ; 		.byte "inx"
003F30r 3               
003F30r 3               ; nt_asm_iny:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_jmp
003F30r 3               ; 		.word xt_asm_iny, z_asm_iny
003F30r 3               ; 		.byte "iny"
003F30r 3               
003F30r 3               ; nt_asm_jmp:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_jmp_i
003F30r 3               ; 		.word xt_asm_jmp, z_asm_jmp
003F30r 3               ; 		.byte "jmp"
003F30r 3               
003F30r 3               ; nt_asm_jmp_i:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_jmp_xi
003F30r 3               ; 		.word xt_asm_jmp_i, z_asm_jmp_i
003F30r 3               ; 		.byte "jmp.i"
003F30r 3               
003F30r 3               ; nt_asm_jmp_xi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_jsr
003F30r 3               ; 		.word xt_asm_jmp_xi, z_asm_jmp_xi
003F30r 3               ; 		.byte "jmp.xi"
003F30r 3               
003F30r 3               ; nt_asm_jsr:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_lda
003F30r 3               ; 		.word xt_asm_jsr, z_asm_jsr
003F30r 3               ; 		.byte "jsr"
003F30r 3               
003F30r 3               ; nt_asm_lda:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_lda_h
003F30r 3               ; 		.word xt_asm_lda, z_asm_lda
003F30r 3               ; 		.byte "lda"
003F30r 3               
003F30r 3               ; nt_asm_lda_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lda_x
003F30r 3               ; 		.word xt_asm_lda_h, z_asm_lda_h
003F30r 3               ; 		.byte "lda.#"
003F30r 3               
003F30r 3               ; nt_asm_lda_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lda_y
003F30r 3               ; 		.word xt_asm_lda_x, z_asm_lda_x
003F30r 3               ; 		.byte "lda.x"
003F30r 3               
003F30r 3               ; nt_asm_lda_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lda_z
003F30r 3               ; 		.word xt_asm_lda_y, z_asm_lda_y
003F30r 3               ; 		.byte "lda.y"
003F30r 3               
003F30r 3               ; nt_asm_lda_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lda_zi
003F30r 3               ; 		.word xt_asm_lda_z, z_asm_lda_z
003F30r 3               ; 		.byte "lda.z"
003F30r 3               
003F30r 3               ; nt_asm_lda_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_lda_ziy
003F30r 3               ; 		.word xt_asm_lda_zi, z_asm_lda_zi
003F30r 3               ; 		.byte "lda.zi"
003F30r 3               
003F30r 3               ; nt_asm_lda_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_lda_zx
003F30r 3               ; 		.word xt_asm_lda_ziy, z_asm_lda_ziy
003F30r 3               ; 		.byte "lda.ziy"
003F30r 3               
003F30r 3               ; nt_asm_lda_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_lda_zxi
003F30r 3               ; 		.word xt_asm_lda_zx, z_asm_lda_zx
003F30r 3               ; 		.byte "lda.zx"
003F30r 3               
003F30r 3               ; nt_asm_lda_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_ldx
003F30r 3               ; 		.word xt_asm_lda_zxi, z_asm_lda_zxi
003F30r 3               ; 		.byte "lda.zxi"
003F30r 3               
003F30r 3               ; nt_asm_ldx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ldx_h
003F30r 3               ; 		.word xt_asm_ldx, z_asm_ldx
003F30r 3               ; 		.byte "ldx"
003F30r 3               
003F30r 3               ; nt_asm_ldx_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldx_y
003F30r 3               ; 		.word xt_asm_ldx_h, z_asm_ldx_h
003F30r 3               ; 		.byte "ldx.#"
003F30r 3               
003F30r 3               ; nt_asm_ldx_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldx_z
003F30r 3               ; 		.word xt_asm_ldx_y, z_asm_ldx_y
003F30r 3               ; 		.byte "ldx.y"
003F30r 3               
003F30r 3               ; nt_asm_ldx_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldx_zy
003F30r 3               ; 		.word xt_asm_ldx_z, z_asm_ldx_z
003F30r 3               ; 		.byte "ldx.z"
003F30r 3               
003F30r 3               ; nt_asm_ldx_zy:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_ldy
003F30r 3               ; 		.word xt_asm_ldx_zy, z_asm_ldx_zy
003F30r 3               ; 		.byte "ldx.zy"
003F30r 3               
003F30r 3               ; nt_asm_ldy:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ldy_h
003F30r 3               ; 		.word xt_asm_ldy, z_asm_ldy
003F30r 3               ; 		.byte "ldy"
003F30r 3               
003F30r 3               ; nt_asm_ldy_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldy_x
003F30r 3               ; 		.word xt_asm_ldy_h, z_asm_ldy_h
003F30r 3               ; 		.byte "ldy.#"
003F30r 3               
003F30r 3               ; nt_asm_ldy_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldy_z
003F30r 3               ; 		.word xt_asm_ldy_x, z_asm_ldy_x
003F30r 3               ; 		.byte "ldy.x"
003F30r 3               
003F30r 3               ; nt_asm_ldy_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ldy_zx
003F30r 3               ; 		.word xt_asm_ldy_z, z_asm_ldy_z
003F30r 3               ; 		.byte "ldy.z"
003F30r 3               
003F30r 3               ; nt_asm_ldy_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_lsr
003F30r 3               ; 		.word xt_asm_ldy_zx, z_asm_ldy_zx
003F30r 3               ; 		.byte "ldy.zx"
003F30r 3               
003F30r 3               ; nt_asm_lsr:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_lsr_a
003F30r 3               ; 		.word xt_asm_lsr, z_asm_lsr
003F30r 3               ; 		.byte "lsr"
003F30r 3               
003F30r 3               ; nt_asm_lsr_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lsr_x
003F30r 3               ; 		.word xt_asm_lsr_a, z_asm_lsr_a
003F30r 3               ; 		.byte "lsr.a"
003F30r 3               
003F30r 3               ; nt_asm_lsr_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lsr_z
003F30r 3               ; 		.word xt_asm_lsr_x, z_asm_lsr_x
003F30r 3               ; 		.byte "lsr.x"
003F30r 3               
003F30r 3               ; nt_asm_lsr_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_lsr_zx
003F30r 3               ; 		.word xt_asm_lsr_z, z_asm_lsr_z
003F30r 3               ; 		.byte "lsr.z"
003F30r 3               
003F30r 3               ; nt_asm_lsr_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_nop
003F30r 3               ; 		.word xt_asm_lsr_zx, z_asm_lsr_zx
003F30r 3               ; 		.byte "lsr.zx"
003F30r 3               
003F30r 3               ; nt_asm_nop:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ora
003F30r 3               ; 		.word xt_asm_nop, z_asm_nop
003F30r 3               ; 		.byte "nop"
003F30r 3               
003F30r 3               ; nt_asm_ora:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ora_h
003F30r 3               ; 		.word xt_asm_ora, z_asm_ora
003F30r 3               ; 		.byte "ora"
003F30r 3               
003F30r 3               ; nt_asm_ora_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ora_x
003F30r 3               ; 		.word xt_asm_ora_h, z_asm_ora_h
003F30r 3               ; 		.byte "ora.#"
003F30r 3               
003F30r 3               ; nt_asm_ora_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ora_y
003F30r 3               ; 		.word xt_asm_ora_x, z_asm_ora_x
003F30r 3               ; 		.byte "ora.x"
003F30r 3               
003F30r 3               ; nt_asm_ora_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ora_z
003F30r 3               ; 		.word xt_asm_ora_y, z_asm_ora_y
003F30r 3               ; 		.byte "ora.y"
003F30r 3               
003F30r 3               ; nt_asm_ora_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ora_zi
003F30r 3               ; 		.word xt_asm_ora_z, z_asm_ora_z
003F30r 3               ; 		.byte "ora.z"
003F30r 3               
003F30r 3               ; nt_asm_ora_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_ora_ziy
003F30r 3               ; 		.word xt_asm_ora_zi, z_asm_ora_zi
003F30r 3               ; 		.byte "ora.zi"
003F30r 3               
003F30r 3               ; nt_asm_ora_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_ora_zx
003F30r 3               ; 		.word xt_asm_ora_ziy, z_asm_ora_ziy
003F30r 3               ; 		.byte "ora.ziy"
003F30r 3               
003F30r 3               ; nt_asm_ora_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_ora_zxi
003F30r 3               ; 		.word xt_asm_ora_zx, z_asm_ora_zx
003F30r 3               ; 		.byte "ora.zx"
003F30r 3               
003F30r 3               ; nt_asm_ora_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_pha
003F30r 3               ; 		.word xt_asm_ora_zxi, z_asm_ora_zxi
003F30r 3               ; 		.byte "ora.zxi"
003F30r 3               
003F30r 3               ; nt_asm_pha:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_php
003F30r 3               ; 		.word xt_asm_pha, z_asm_pha
003F30r 3               ; 		.byte "pha"
003F30r 3               
003F30r 3               ; nt_asm_php:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_phx
003F30r 3               ; 		.word xt_asm_php, z_asm_php
003F30r 3               ; 		.byte "php"
003F30r 3               
003F30r 3               ; nt_asm_phx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_phy
003F30r 3               ; 		.word xt_asm_phx, z_asm_phx
003F30r 3               ; 		.byte "phx"
003F30r 3               
003F30r 3               ; nt_asm_phy:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_pla
003F30r 3               ; 		.word xt_asm_phy, z_asm_phy
003F30r 3               ; 		.byte "phy"
003F30r 3               
003F30r 3               ; nt_asm_pla:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_plp
003F30r 3               ; 		.word xt_asm_pla, z_asm_pla
003F30r 3               ; 		.byte "pla"
003F30r 3               
003F30r 3               ; nt_asm_plp:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_plx
003F30r 3               ; 		.word xt_asm_plp, z_asm_plp
003F30r 3               ; 		.byte "plp"
003F30r 3               
003F30r 3               ; nt_asm_plx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ply
003F30r 3               ; 		.word xt_asm_plx, z_asm_plx
003F30r 3               ; 		.byte "plx"
003F30r 3               
003F30r 3               ; nt_asm_ply:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_rol
003F30r 3               ; 		.word xt_asm_ply, z_asm_ply
003F30r 3               ; 		.byte "ply"
003F30r 3               
003F30r 3               ; nt_asm_rol:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_rol_a
003F30r 3               ; 		.word xt_asm_rol, z_asm_rol
003F30r 3               ; 		.byte "rol"
003F30r 3               
003F30r 3               ; nt_asm_rol_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_rol_x
003F30r 3               ; 		.word xt_asm_rol_a, z_asm_rol_a
003F30r 3               ; 		.byte "rol.a"
003F30r 3               
003F30r 3               ; nt_asm_rol_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_rol_z
003F30r 3               ; 		.word xt_asm_rol_x, z_asm_rol_x
003F30r 3               ; 		.byte "rol.x"
003F30r 3               
003F30r 3               ; nt_asm_rol_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_rol_zx
003F30r 3               ; 		.word xt_asm_rol_z, z_asm_rol_z
003F30r 3               ; 		.byte "rol.z"
003F30r 3               
003F30r 3               ; nt_asm_rol_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_ror
003F30r 3               ; 		.word xt_asm_rol_zx, z_asm_rol_zx
003F30r 3               ; 		.byte "rol.zx"
003F30r 3               
003F30r 3               ; nt_asm_ror:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_ror_a
003F30r 3               ; 		.word xt_asm_ror, z_asm_ror
003F30r 3               ; 		.byte "ror"
003F30r 3               
003F30r 3               ; nt_asm_ror_a:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ror_x
003F30r 3               ; 		.word xt_asm_ror_a, z_asm_ror_a
003F30r 3               ; 		.byte "ror.a"
003F30r 3               
003F30r 3               ; nt_asm_ror_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ror_z
003F30r 3               ; 		.word xt_asm_ror_x, z_asm_ror_x
003F30r 3               ; 		.byte "ror.x"
003F30r 3               
003F30r 3               ; nt_asm_ror_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_ror_zx
003F30r 3               ; 		.word xt_asm_ror_z, z_asm_ror_z
003F30r 3               ; 		.byte "ror.z"
003F30r 3               
003F30r 3               ; nt_asm_ror_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_rti
003F30r 3               ; 		.word xt_asm_ror_zx, z_asm_ror_zx
003F30r 3               ; 		.byte "ror.zx"
003F30r 3               
003F30r 3               ; nt_asm_rti:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_rts
003F30r 3               ; 		.word xt_asm_rti, z_asm_rti
003F30r 3               ; 		.byte "rti"
003F30r 3               
003F30r 3               ; nt_asm_rts:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sbc
003F30r 3               ; 		.word xt_asm_rts, z_asm_rts
003F30r 3               ; 		.byte "rts"
003F30r 3               
003F30r 3               ; nt_asm_sbc:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sbc_h
003F30r 3               ; 		.word xt_asm_sbc, z_asm_sbc
003F30r 3               ; 		.byte "sbc"
003F30r 3               
003F30r 3               ; nt_asm_sbc_h:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sbc_x
003F30r 3               ; 		.word xt_asm_sbc_h, z_asm_sbc_h
003F30r 3               ; 		.byte "sbc.#"
003F30r 3               
003F30r 3               ; nt_asm_sbc_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sbc_y
003F30r 3               ; 		.word xt_asm_sbc_x, z_asm_sbc_x
003F30r 3               ; 		.byte "sbc.x"
003F30r 3               
003F30r 3               ; nt_asm_sbc_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sbc_z
003F30r 3               ; 		.word xt_asm_sbc_y, z_asm_sbc_y
003F30r 3               ; 		.byte "sbc.y"
003F30r 3               
003F30r 3               ; nt_asm_sbc_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sbc_zi
003F30r 3               ; 		.word xt_asm_sbc_z, z_asm_sbc_z
003F30r 3               ; 		.byte "sbc.z"
003F30r 3               
003F30r 3               ; nt_asm_sbc_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_sbc_ziy
003F30r 3               ; 		.word xt_asm_sbc_zi, z_asm_sbc_zi
003F30r 3               ; 		.byte "sbc.zi"
003F30r 3               
003F30r 3               ; nt_asm_sbc_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_sbc_zx
003F30r 3               ; 		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
003F30r 3               ; 		.byte "sbc.ziy"
003F30r 3               
003F30r 3               ; nt_asm_sbc_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_sbc_zxi
003F30r 3               ; 		.word xt_asm_sbc_zx, z_asm_sbc_zx
003F30r 3               ; 		.byte "sbc.zx"
003F30r 3               
003F30r 3               ; nt_asm_sbc_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_sec
003F30r 3               ; 		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
003F30r 3               ; 		.byte "sbc.zxi"
003F30r 3               
003F30r 3               ; nt_asm_sec:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sed
003F30r 3               ; 		.word xt_asm_sec, z_asm_sec
003F30r 3               ; 		.byte "sec"
003F30r 3               
003F30r 3               ; nt_asm_sed:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sei
003F30r 3               ; 		.word xt_asm_sed, z_asm_sed
003F30r 3               ; 		.byte "sed"
003F30r 3               
003F30r 3               ; nt_asm_sei:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sta
003F30r 3               ; 		.word xt_asm_sei, z_asm_sei
003F30r 3               ; 		.byte "sei"
003F30r 3               
003F30r 3               ; nt_asm_sta:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sta_x
003F30r 3               ; 		.word xt_asm_sta, z_asm_sta
003F30r 3               ; 		.byte "sta"
003F30r 3               
003F30r 3               ; nt_asm_sta_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sta_y
003F30r 3               ; 		.word xt_asm_sta_x, z_asm_sta_x
003F30r 3               ; 		.byte "sta.x"
003F30r 3               
003F30r 3               ; nt_asm_sta_y:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sta_z
003F30r 3               ; 		.word xt_asm_sta_y, z_asm_sta_y
003F30r 3               ; 		.byte "sta.y"
003F30r 3               
003F30r 3               ; nt_asm_sta_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sta_zi
003F30r 3               ; 		.word xt_asm_sta_z, z_asm_sta_z
003F30r 3               ; 		.byte "sta.z"
003F30r 3               
003F30r 3               ; nt_asm_sta_zi:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_sta_ziy
003F30r 3               ; 		.word xt_asm_sta_zi, z_asm_sta_zi
003F30r 3               ; 		.byte "sta.zi"
003F30r 3               
003F30r 3               ; nt_asm_sta_ziy:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_sta_zx
003F30r 3               ; 		.word xt_asm_sta_ziy, z_asm_sta_ziy
003F30r 3               ; 		.byte "sta.ziy"
003F30r 3               
003F30r 3               ; nt_asm_sta_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_sta_zxi
003F30r 3               ; 		.word xt_asm_sta_zx, z_asm_sta_zx
003F30r 3               ; 		.byte "sta.zx"
003F30r 3               
003F30r 3               ; nt_asm_sta_zxi:
003F30r 3               ; 		.byte 7, IM
003F30r 3               ;                 .word nt_asm_stx
003F30r 3               ; 		.word xt_asm_sta_zxi, z_asm_sta_zxi
003F30r 3               ; 		.byte "sta.zxi"
003F30r 3               
003F30r 3               ; nt_asm_stx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_stx_z
003F30r 3               ; 		.word xt_asm_stx, z_asm_stx
003F30r 3               ; 		.byte "stx"
003F30r 3               
003F30r 3               ; nt_asm_stx_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_stx_zy
003F30r 3               ; 		.word xt_asm_stx_z, z_asm_stx_z
003F30r 3               ; 		.byte "stx.z"
003F30r 3               
003F30r 3               ; nt_asm_stx_zy:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_sty
003F30r 3               ; 		.word xt_asm_stx_zy, z_asm_stx_zy
003F30r 3               ; 		.byte "stx.zy"
003F30r 3               
003F30r 3               ; nt_asm_sty:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_sty_z
003F30r 3               ; 		.word xt_asm_sty, z_asm_sty
003F30r 3               ; 		.byte "sty"
003F30r 3               
003F30r 3               ; nt_asm_sty_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_sty_zx
003F30r 3               ; 		.word xt_asm_sty_z, z_asm_sty_z
003F30r 3               ; 		.byte "sty.z"
003F30r 3               
003F30r 3               ; nt_asm_sty_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_stz
003F30r 3               ; 		.word xt_asm_sty_zx, z_asm_sty_zx
003F30r 3               ; 		.byte "sty.zx"
003F30r 3               
003F30r 3               ; nt_asm_stz:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_stz_x
003F30r 3               ; 		.word xt_asm_stz, z_asm_stz
003F30r 3               ; 		.byte "stz"
003F30r 3               
003F30r 3               ; nt_asm_stz_x:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_stz_z
003F30r 3               ; 		.word xt_asm_stz_x, z_asm_stz_x
003F30r 3               ; 		.byte "stz.x"
003F30r 3               
003F30r 3               ; nt_asm_stz_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_stz_zx
003F30r 3               ; 		.word xt_asm_stz_z, z_asm_stz_z
003F30r 3               ; 		.byte "stz.z"
003F30r 3               
003F30r 3               ; nt_asm_stz_zx:
003F30r 3               ; 		.byte 6, IM
003F30r 3               ;                 .word nt_asm_tax
003F30r 3               ; 		.word xt_asm_stz_zx, z_asm_stz_zx
003F30r 3               ; 		.byte "stz.zx"
003F30r 3               
003F30r 3               ; nt_asm_tax:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_tay
003F30r 3               ; 		.word xt_asm_tax, z_asm_tax
003F30r 3               ; 		.byte "tax"
003F30r 3               
003F30r 3               ; nt_asm_tay:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_trb
003F30r 3               ; 		.word xt_asm_tay, z_asm_tay
003F30r 3               ; 		.byte "tay"
003F30r 3               
003F30r 3               ; nt_asm_trb:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_trb_z
003F30r 3               ; 		.word xt_asm_trb, z_asm_trb
003F30r 3               ; 		.byte "trb"
003F30r 3               
003F30r 3               ; nt_asm_trb_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_tsb
003F30r 3               ; 		.word xt_asm_trb_z, z_asm_trb_z
003F30r 3               ; 		.byte "trb.z"
003F30r 3               
003F30r 3               ; nt_asm_tsb:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_tsb_z
003F30r 3               ; 		.word xt_asm_tsb, z_asm_tsb
003F30r 3               ; 		.byte "tsb"
003F30r 3               
003F30r 3               ; nt_asm_tsb_z:
003F30r 3               ; 		.byte 5, IM
003F30r 3               ;                 .word nt_asm_tsx
003F30r 3               ; 		.word xt_asm_tsb_z, z_asm_tsb_z
003F30r 3               ; 		.byte "tsb.z"
003F30r 3               
003F30r 3               ; nt_asm_tsx:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_txa
003F30r 3               ; 		.word xt_asm_tsx, z_asm_tsx
003F30r 3               ; 		.byte "tsx"
003F30r 3               
003F30r 3               ; nt_asm_txa:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_txs
003F30r 3               ; 		.word xt_asm_txa, z_asm_txa
003F30r 3               ; 		.byte "txa"
003F30r 3               
003F30r 3               ; nt_asm_txs:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_tya
003F30r 3               ; 		.word xt_asm_txs, z_asm_txs
003F30r 3               ; 		.byte "txs"
003F30r 3               
003F30r 3               ; nt_asm_tya:
003F30r 3               ; 		.byte 3, IM
003F30r 3               ;                 .word nt_asm_arrow
003F30r 3               ; 		.word xt_asm_tya, z_asm_tya
003F30r 3               ; 		.byte "tya"
003F30r 3               
003F30r 3               ; ; Assembler pseudo-instructions, directives and macros
003F30r 3               
003F30r 3               ; nt_asm_arrow:   ; uses same code as HERE, but immediate
003F30r 3               ;                 .byte 3, IM
003F30r 3               ;                 .word nt_asm_back_jump
003F30r 3               ;                 .word xt_asm_arrow, z_asm_arrow
003F30r 3               ;                 .byte "-->"
003F30r 3               
003F30r 3               
003F30r 3               ; nt_asm_back_jump:  ; syntactic sugar, does nothing
003F30r 3               ;                 .byte 2, IM
003F30r 3               ;                 .word nt_asm_back_branch
003F30r 3               ;                 .word xt_asm_back_jump, z_asm_back_jump
003F30r 3               ;                 .byte "<j"
003F30r 3               
003F30r 3               ; nt_asm_back_branch:
003F30r 3               ;                 .byte 2, IM
003F30r 3               ;                 .word nt_asm_push_a
003F30r 3               ;                 .word xt_asm_back_branch, z_asm_back_branch
003F30r 3               ;                 .byte "<b"
003F30r 3               
003F30r 3               ; nt_asm_push_a:
003F30r 3               ;                 .byte 6, IM
003F30r 3               ;                 .word 0000
003F30r 3               ;                 .word xt_asm_push_a, z_asm_push_a
003F30r 3               ;                 .byte "push-a"
003F30r 3               
003F30r 3               
003F30r 3               
003F30r 3               ; END of ASSEMBLER-WORDLIST
003F30r 3               
003F30r 3               ; END
003F30r 3               
003F30r 2                   .include "strings.s"          ; Headers of native words
003F30r 3               ; List of Strings for Tali Forth 2
003F30r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
003F30r 3               ; First version: 01. Apr 2016 (for Liara Forth)
003F30r 3               ; This version: 28. Dec 2018
003F30r 3               
003F30r 3               ; This file is included by taliforth.asm
003F30r 3               
003F30r 3               ; ## GENERAL STRINGS
003F30r 3               
003F30r 3               ; All general strings must be zero-terminated, names start with "s_",
003F30r 3               ; aliases with "str_"
003F30r 3               
003F30r 3               str_ok =              0
003F30r 3               str_compile =         1
003F30r 3               str_redefined =       2
003F30r 3               str_wid_forth =       3
003F30r 3               str_abc_lower =       4
003F30r 3               str_abc_upper =       5
003F30r 3               str_wid_editor =      6
003F30r 3               str_wid_assembler =   7
003F30r 3               str_wid_root =        8
003F30r 3               str_see_flags =       9
003F30r 3               str_see_nt =         10
003F30r 3               str_see_xt =         11
003F30r 3               str_see_size =       12
003F30r 3               
003F30r 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
003F30r 3               ; to tables as error and string numbers.
003F30r 3               string_table:
003F30r 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
003F34r 3  rr rr rr rr  
003F38r 3  rr rr        
003F3Ar 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
003F3Er 3  rr rr rr rr  
003F42r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
003F46r 3  rr rr rr rr  
003F4Ar 3               
003F4Ar 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
003F4Er 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
003F52r 3  70 69 6C 65  
003F56r 3  64 00        
003F58r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
003F5Cr 3  66 69 6E 65  
003F60r 3  64 20 00     
003F63r 3               
003F63r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
003F67r 3  34 35 36 37  
003F6Br 3  38 39 61 62  
003F87r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
003F8Br 3  34 35 36 37  
003F8Fr 3  38 39 41 42  
003FABr 3               
003FABr 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
003FAFr 3  6D 62 6C 65  
003FB3r 3  72 20 00     
003FB6r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
003FBAr 3  6F 72 20 00  
003FBEr 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
003FC2r 3  68 20 00     
003FC5r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
003FC9r 3  20 00        
003FCBr 3               
003FCBr 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
003FCFr 3  73 20 28 43  
003FD3r 3  4F 20 41 4E  
003FE7r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
003FEBr 3  00           
003FECr 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
003FF0r 3  00           
003FF1r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
003FF5r 3  20 28 64 65  
003FF9r 3  63 69 6D 61  
004002r 3               
004002r 3               
004002r 3               ; ## ERROR STRINGS
004002r 3               
004002r 3               ; All error strings must be zero-terminated, all names start with "es_",
004002r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
004002r 3               ; as well
004002r 3               
004002r 3               err_allot =        0
004002r 3               err_badsource =    1
004002r 3               err_compileonly =  2
004002r 3               err_defer =        3
004002r 3               err_divzero =      4
004002r 3               err_noname =       5
004002r 3               err_refill =       6
004002r 3               err_state =        7
004002r 3               err_syntax =       8
004002r 3               err_underflow =    9
004002r 3               err_negallot =     10
004002r 3               err_wordlist =     11
004002r 3               err_blockwords =   12
004002r 3               
004002r 3               error_table:
004002r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
004006r 3  rr rr rr rr  
00400Ar 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
00400Er 3  rr rr rr rr  
004012r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
004016r 3  rr rr rr rr  
00401Ar 3  rr rr                .word es_blockwords                                    ; 12
00401Cr 3               
00401Cr 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
004020r 3  54 20 75 73  
004024r 3  69 6E 67 20  
00403Dr 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
004041r 3  67 61 6C 20  
004045r 3  53 4F 55 52  
00405Dr 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
004061r 3  72 70 72 65  
004065r 3  74 69 6E 67  
00407Er 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
004082r 3  52 65 64 20  
004086r 3  77 6F 72 64  
00409Br 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
00409Fr 3  73 69 6F 6E  
0040A3r 3  20 62 79 20  
0040ACr 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
0040B0r 3  69 6E 67 20  
0040B4r 3  66 61 69 6C  
0040BCr 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
0040C0r 3  20 63 6F 75  
0040C4r 3  6C 64 20 6E  
0040EAr 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
0040EEr 3  61 64 79 20  
0040F2r 3  69 6E 20 63  
004102r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
004106r 3  66 69 6E 65  
00410Ar 3  64 20 77 6F  
004111r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
004115r 3  6B 20 75 6E  
004119r 3  64 65 72 66  
004121r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
004125r 3  6D 65 6D 6F  
004129r 3  72 79 20 66  
00413Dr 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
004141r 3  6F 72 64 6C  
004145r 3  69 73 74 73  
004154r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
004158r 3  73 65 20 61  
00415Cr 3  73 73 69 67  
004193r 3               
004193r 3               ; ## ENVIRONMENT STRINGS
004193r 3               
004193r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
004193r 3               ; Length byte first, then the string itself that is not rpt. not
004193r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
004193r 3               ; "envs_".
004193r 3               
004193r 3               ; These return a single-cell number
004193r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
004197r 3  55 4E 54 45  
00419Br 3  44 2D 53 54  
0041A3r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
0041A7r 3  4C 44        
0041A9r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
0041ADr 3  44           
0041AEr 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
0041B2r 3  52 45 53 53  
0041B6r 3  2D 55 4E 49  
0041C0r 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
0041C4r 3  4F 52 45 44  
0041C8r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
0041CCr 3  2D 43 48 41  
0041D0r 3  52           
0041D1r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
0041D5r 3  2D 4E        
0041D7r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
0041DBr 3  2D 55        
0041DDr 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
0041E1r 3  55 52 4E 2D  
0041E5r 3  53 54 41 43  
0041F0r 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
0041F4r 3  43 4B 2D 43  
0041F8r 3  45 4C 4C 53  
0041FCr 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
004200r 3  44 4C 49 53  
004204r 3  54 53        
004206r 3               
004206r 3               ; These return a double-cell number
004206r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
00420Ar 3  2D 44        
00420Cr 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
004210r 3  2D 55 44     
004213r 3               
004213r 3               ; END
004213r 3               
004213r 2               
004213r 2               ; High-level Forth words, see forth_code/README.md
004213r 2               forth_words_start:
004213r 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
004217r 2  2E 28 20 52  
00421Br 2  65 61 64 79  
004225r 2               forth_words_end:
004225r 2               
004225r 2               ; User-defined Forth words, see forth_code/README.md
004225r 2               user_words_start:
004225r 2  20 32 30 20  .incbin "forth_code/user_words.asc"
004229r 2  63 6F 6E 73  
00422Dr 2  74 61 6E 74  
0048D1r 2               user_words_end:
0048D1r 2               
0048D1r 2               
0048D1r 2               ; =====================================================================
0048D1r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
0048D1r 2               
0048D1r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
0048D1r 2               ; at compile time so they are available at run time. Words that use this
0048D1r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
0048D1r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
0048D1r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
0048D1r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
0048D1r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
0048D1r 2               ; Bowie.
0048D1r 2               
0048D1r 2               ;               ldy #>addr      ; MSB   ; "Young"
0048D1r 2               ;               lda #<addr      ; LSB   ; "Americans"
0048D1r 2               ;               jsr cmpl_subroutine
0048D1r 2               
0048D1r 2               ; Also, we keep a routine here to compile a single byte passed through A.
0048D1r 2               
0048D1r 2               cmpl_subroutine:
0048D1r 2                   ; This is the entry point to compile JSR <ADDR>
0048D1r 2  48               pha             ; save LSB of address
0048D2r 2  A9 20            lda #$20        ; load opcode for JSR
0048D4r 2  80 03            bra cmpl_common
0048D6r 2               cmpl_jump:
0048D6r 2                   ; This is the entry point to compile JMP <ADDR>
0048D6r 2  48               pha             ; save LSB of address
0048D7r 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
0048D9r 2               cmpl_common:
0048D9r 2                   ; At this point, A contains the opcode to be compiled,
0048D9r 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
0048D9r 2                   ; the address is in Y
0048D9r 2  20 rr rr         jsr cmpl_a      ; compile opcode
0048DCr 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
0048DDr 2               cmpl_word:
0048DDr 2                   ; This is the entry point to compile a word (little-endian)
0048DDr 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
0048E0r 2  98               tya             ; fall thru for MSB
0048E1r 2               cmpl_a:
0048E1r 2                   ; This is the entry point to compile a single byte which
0048E1r 2                   ; is passed in A. The built-in assembler assumes that this
0048E1r 2                   ; routine does not modify Y.
0048E1r 2  92 rr            sta (cp)
0048E3r 2  E6 rr            inc cp
0048E5r 2  D0 02            bne _done
0048E7r 2  E6 rr            inc cp+1
0048E9r 2               _done:
0048E9r 2  60               rts
0048EAr 2               
0048EAr 2               
0048EAr 2               
0048EAr 2               ; =====================================================================
0048EAr 2               ; CODE FIELD ROUTINES
0048EAr 2               
0048EAr 2               doconst:
0048EAr 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
0048EAr 2               ; the Data Field onto the Data Stack
0048EAr 2               ; """
0048EAr 2  CA               dex             ; make room for constant
0048EBr 2  CA               dex
0048ECr 2               
0048ECr 2                   ; The value we need is stored in the two bytes after the
0048ECr 2                   ; JSR return address, which in turn is what is on top of
0048ECr 2                   ; the Return Stack
0048ECr 2  68               pla             ; LSB of return address
0048EDr 2  85 rr            sta tmp1
0048EFr 2  68               pla             ; MSB of return address
0048F0r 2  85 rr            sta tmp1+1
0048F2r 2               
0048F2r 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
0048F2r 2                   ; the return address on the 65c02
0048F2r 2  A0 01            ldy #1
0048F4r 2  B1 rr            lda (tmp1),y
0048F6r 2  95 00            sta 0,x
0048F8r 2  C8               iny
0048F9r 2  B1 rr            lda (tmp1),y
0048FBr 2  95 01            sta 1,x
0048FDr 2               
0048FDr 2                   ; This takes us back to the original caller, not the
0048FDr 2                   ; DOCONST caller
0048FDr 2  60               rts
0048FEr 2               
0048FEr 2               
0048FEr 2               dodefer:
0048FEr 2               ; """Execute a DEFER statement at runtime: Execute the address we
0048FEr 2               ; find after the caller in the Data Field
0048FEr 2               ; """
0048FEr 2                   ; The xt we need is stored in the two bytes after the JSR
0048FEr 2                   ; return address, which is what is on top of the Return
0048FEr 2                   ; Stack. So all we have to do is replace our return jump
0048FEr 2                   ; with what we find there
0048FEr 2  68               pla             ; LSB
0048FFr 2  85 rr            sta tmp1
004901r 2  68               pla             ; MSB
004902r 2  85 rr            sta tmp1+1
004904r 2               
004904r 2  A0 01            ldy #1
004906r 2  B1 rr            lda (tmp1),y
004908r 2  85 rr            sta tmp2
00490Ar 2  C8               iny
00490Br 2  B1 rr            lda (tmp1),y
00490Dr 2  85 rr            sta tmp2+1
00490Fr 2               
00490Fr 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004912r 2               
004912r 2               defer_error:
004912r 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004912r 2  A9 03            lda #err_defer
004914r 2  4C rr rr         jmp error
004917r 2               
004917r 2               dodoes:
004917r 2               ; """Execute the runtime portion of DOES>. See DOES> and
004917r 2               ; docs/create-does.txt for details and
004917r 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004917r 2               ; """
004917r 2                   ; Assumes the address of the CFA of the original defining word
004917r 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004917r 2                   ; for a later jump, adding one byte because of the way the
004917r 2                   ; 6502 works
004917r 2  7A               ply             ; LSB
004918r 2  68               pla             ; MSB
004919r 2  C8               iny
00491Ar 2  D0 01            bne @1
00491Cr 2  1A               inc
00491Dr 2               @1:
00491Dr 2  84 rr            sty tmp2
00491Fr 2  85 rr            sta tmp2+1
004921r 2               
004921r 2                   ; Next on the Return Stack should be the address of the PFA of
004921r 2                   ; the calling defined word (say, the name of whatever constant we
004921r 2                   ; just defined). Move this to the Data Stack, again adding one.
004921r 2  CA               dex
004922r 2  CA               dex
004923r 2               
004923r 2  7A               ply
004924r 2  68               pla
004925r 2  C8               iny
004926r 2  D0 01            bne @2
004928r 2  1A               inc
004929r 2               @2:
004929r 2  94 00            sty 0,x         ; LSB
00492Br 2  95 01            sta 1,x         ; MSB
00492Dr 2               
00492Dr 2                   ; This leaves the return address from the original main routine
00492Dr 2                   ; on top of the Return Stack. We leave that untouched and jump
00492Dr 2                   ; to the special code of the defining word. It's RTS instruction
00492Dr 2                   ; will take us back to the main routine
00492Dr 2  6C rr rr         jmp (tmp2)
004930r 2               
004930r 2               
004930r 2               dovar:
004930r 2               ; """Execute a variable: Push the address of the first bytes of
004930r 2               ; the Data Field onto the stack. This is called with JSR so we
004930r 2               ; can pick up the address of the calling variable off the 65c02's
004930r 2               ; stack. The final RTS takes us to the original caller of the
004930r 2               ; routine that itself called DOVAR. This is the default
004930r 2               ; routine installed with CREATE.
004930r 2               ; """
004930r 2                   ; Pull the return address off the machine's stack, adding
004930r 2                   ; one because of the way the 65c02 handles subroutines
004930r 2  7A               ply             ; LSB
004931r 2  68               pla             ; MSB
004932r 2  C8               iny
004933r 2  D0 01            bne @1
004935r 2  1A               inc
004936r 2               @1:
004936r 2  CA               dex
004937r 2  CA               dex
004938r 2               
004938r 2  95 01            sta 1,x
00493Ar 2  98               tya
00493Br 2  95 00            sta 0,x
00493Dr 2               
00493Dr 2  60               rts
00493Er 2               
00493Er 2               ; =====================================================================
00493Er 2               ; LOW LEVEL HELPER FUNCTIONS
00493Er 2               
00493Er 2               byte_to_ascii:
00493Er 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
00493Er 2               .scope
00493Er 2  48               pha
00493Fr 2  4A               lsr             ; convert high nibble first
004940r 2  4A               lsr
004941r 2  4A               lsr
004942r 2  4A               lsr
004943r 2  20 rr rr         jsr _nibble_to_ascii
004946r 2  68               pla
004947r 2               
004947r 2                   ; fall through to _nibble_to_ascii
004947r 2               
004947r 2               _nibble_to_ascii:
004947r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004947r 2               ; of A and and EMIT it. This does the actual work.
004947r 2               ; """
004947r 2  29 0F            and #$0F
004949r 2  09 30            ora #'0'
00494Br 2  C9 3A            cmp #$3A        ; '9+1
00494Dr 2  90 02            bcc @1
00494Fr 2  69 06            adc #$06
004951r 2               
004951r 2  4C rr rr     @1:               jmp emit_a
004954r 2               
004954r 2  60               rts
004955r 2               .endscope
004955r 2               
004955r 2               compare_16bit:
004955r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004955r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004955r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004955r 2               ; For signed numbers, Z signals equality and N which number is larger:
004955r 2               ;       if TOS = NOS: Z=1 and N=0
004955r 2               ;       if TOS > NOS: Z=0 and N=0
004955r 2               ;       if TOS < NOS: Z=0 and N=1
004955r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004955r 2               ;       if TOS = NOS: Z=1 and N=0
004955r 2               ;       if TOS > NOS: Z=0 and C=1
004955r 2               ;       if TOS < NOS: Z=0 and C=0
004955r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004955r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004955r 2               ; """
004955r 2               .scope
004955r 2                   ; Compare LSB first to set the carry flag
004955r 2  B5 00            lda 0,x                 ; LSB of TOS
004957r 2  D5 02            cmp 2,x                 ; LSB of NOS
004959r 2  F0 0A            beq _equal
00495Br 2               
00495Br 2                   ; LSBs are not equal, compare MSB
00495Br 2  B5 01            lda 1,x                 ; MSB of TOS
00495Dr 2  F5 03            sbc 3,x                 ; MSB of NOS
00495Fr 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004961r 2  70 08            bvs _overflow
004963r 2  80 08            bra _not_equal
004965r 2               _equal:
004965r 2                   ; Low bytes are equal, so we compare high bytes
004965r 2  B5 01            lda 1,x                 ; MSB of TOS
004967r 2  F5 03            sbc 3,x                 ; MSB of NOS
004969r 2  50 04            bvc _done
00496Br 2               _overflow:
00496Br 2                   ; Handle overflow because we use signed numbers
00496Br 2  49 80            eor #$80                ; complement negative flag
00496Dr 2               _not_equal:
00496Dr 2  09 01            ora #1                  ; if overflow, we can't be eqal
00496Fr 2               _done:
00496Fr 2  60               rts
004970r 2               .endscope
004970r 2               
004970r 2               current_to_dp:
004970r 2               ; """Look up the current (compilation) dictionary pointer
004970r 2               ; in the wordlist set and put it into the dp zero-page
004970r 2               ; variable. Uses A and Y.
004970r 2               ; """
004970r 2                   ; Determine which wordlist is current
004970r 2  A0 04            ldy #current_offset
004972r 2  B1 rr            lda (up),y      ; current is a byte variable
004974r 2  0A               asl             ; turn it into an offset (in cells)
004975r 2               
004975r 2                   ; Get the dictionary pointer for that wordlist.
004975r 2  18               clc
004976r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004978r 2  A8               tay
004979r 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
00497Br 2  85 rr            sta dp
00497Dr 2  C8               iny
00497Er 2  B1 rr            lda (up),y
004980r 2  85 rr            sta dp+1
004982r 2               
004982r 2  60               rts
004983r 2               
004983r 2               
004983r 2               dp_to_current:
004983r 2               ; """Look up which wordlist is current and update its pointer
004983r 2               ; with the value in dp. Uses A and Y.
004983r 2               ; """
004983r 2                   ; Determine which wordlist is current
004983r 2  A0 04            ldy #current_offset
004985r 2  B1 rr            lda (up),y      ; current is a byte variable
004987r 2  0A               asl             ; turn it into an offset (in cells)
004988r 2               
004988r 2                   ; Get the dictionary pointer for that wordlist.
004988r 2  18               clc
004989r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
00498Br 2  A8               tay
00498Cr 2  A5 rr            lda dp
00498Er 2  91 rr            sta (up),y              ; get the dp for that wordlist.
004990r 2  C8               iny
004991r 2  A5 rr            lda dp+1
004993r 2  91 rr            sta (up),y
004995r 2               
004995r 2  60               rts
004996r 2               
004996r 2               interpret:
004996r 2               .scope
004996r 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
004996r 2               ; Process one line only. Assumes that the address of name is in
004996r 2               ; cib and the length of the whole input line string is in ciblen
004996r 2               ; """
004996r 2                   ; Normally we would use PARSE here with the SPACE character as
004996r 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
004996r 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
004996r 2                   ; delimiters per default and skips any leading spaces, which
004996r 2                   ; PARSE doesn't
004996r 2               _loop:
004996r 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
004999r 2               
004999r 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
004999r 2                   ; in the line and we need to go get a new line
004999r 2  B5 00            lda 0,x
00499Br 2  15 01            ora 1,x
00499Dr 2  F0 70            beq _line_done
00499Fr 2               
00499Fr 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
00499Fr 2                   ; make a copy of the address in case it isn't a word we know and
00499Fr 2                   ; we have to go see if it is a number
00499Fr 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
0049A2r 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
0049A5r 2               
0049A5r 2                   ; A zero signals that we didn't find a word in the Dictionary
0049A5r 2  B5 00            lda 0,x
0049A7r 2  15 01            ora 1,x
0049A9r 2  D0 28            bne _got_name_token
0049ABr 2               
0049ABr 2                   ; We didn't get any nt we know of, so let's see if this is
0049ABr 2                   ; a number.
0049ABr 2  E8               inx                     ; ( addr u 0 -- addr u )
0049ACr 2  E8               inx
0049ADr 2               
0049ADr 2                   ; If the number conversion doesn't work, NUMBER will do the
0049ADr 2                   ; complaining for us
0049ADr 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
0049B0r 2               
0049B0r 2                   ; Otherweise, if we're interpreting, we're done
0049B0r 2  A5 rr            lda state
0049B2r 2  F0 E2            beq _loop
0049B4r 2               
0049B4r 2                   ; We're compiling, so there is a bit more work.  Check
0049B4r 2                   ; status bit 5 to see if it's a single or double-cell
0049B4r 2                   ; number.
0049B4r 2  A9 20            lda #$20
0049B6r 2  24 rr            bit status
0049B8r 2  F0 0D            beq _single_number
0049BAr 2               
0049BAr 2                   ; It's a double cell number.  If we swap the
0049BAr 2                   ; upper and lower half, we can use the literal_runtime twice
0049BAr 2                   ; to compile it into the dictionary.
0049BAr 2  20 rr rr         jsr xt_swap
0049BDr 2  A0 rr            ldy #>literal_runtime
0049BFr 2  A9 rr            lda #<literal_runtime
0049C1r 2  20 rr rr         jsr cmpl_subroutine
0049C4r 2               
0049C4r 2                   ; compile our number
0049C4r 2  20 rr rr         jsr xt_comma
0049C7r 2               
0049C7r 2                   ; Fall into _single_number to process the other half.
0049C7r 2               _single_number:
0049C7r 2  A0 rr            ldy #>literal_runtime
0049C9r 2  A9 rr            lda #<literal_runtime
0049CBr 2  20 rr rr         jsr cmpl_subroutine
0049CEr 2               
0049CEr 2                   ; compile our number
0049CEr 2  20 rr rr         jsr xt_comma
0049D1r 2               
0049D1r 2                   ; That was so much fun, let's do it again!
0049D1r 2  80 C3            bra _loop
0049D3r 2               
0049D3r 2               _got_name_token:
0049D3r 2                   ; We have a known word's nt TOS. We're going to need its xt
0049D3r 2                   ; though, which is four bytes father down.
0049D3r 2               
0049D3r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
0049D3r 2  B5 00            lda 0,x
0049D5r 2  95 04            sta 4,x
0049D7r 2  B5 01            lda 1,x
0049D9r 2  95 05            sta 5,x
0049DBr 2               
0049DBr 2  E8               inx
0049DCr 2  E8               inx
0049DDr 2  E8               inx
0049DEr 2  E8               inx                     ; ( nt )
0049DFr 2               
0049DFr 2                   ; Save a version of nt for error handling and compilation stuff
0049DFr 2  B5 00            lda 0,x
0049E1r 2  85 rr            sta tmpbranch
0049E3r 2  B5 01            lda 1,x
0049E5r 2  85 rr            sta tmpbranch+1
0049E7r 2               
0049E7r 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
0049EAr 2               
0049EAr 2                   ; See if we are in interpret or compile mode, 0 is interpret
0049EAr 2  A5 rr            lda state
0049ECr 2  D0 13            bne _compile
0049EEr 2               
0049EEr 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
0049EEr 2                   ; though, see if this isn't a compile-only word, which would be
0049EEr 2                   ; illegal. The status byte is the second one of the header.
0049EEr 2  A0 01            ldy #1
0049F0r 2  B1 rr            lda (tmpbranch),y
0049F2r 2  29 01            and #CO                 ; mask everything but Compile Only bit
0049F4r 2  F0 05            beq _interpret
0049F6r 2               
0049F6r 2  A9 02            lda #err_compileonly
0049F8r 2  4C rr rr         jmp error
0049FBr 2               
0049FBr 2               _interpret:
0049FBr 2                   ; We JSR to EXECUTE instead of calling the xt directly because
0049FBr 2                   ; the RTS of the word we're executing will bring us back here,
0049FBr 2                   ; skipping EXECUTE completely during RTS. If we were to execute
0049FBr 2                   ; xt directly, we have to fool around with the Return Stack
0049FBr 2                   ; instead, which is actually slightly slower
0049FBr 2  20 rr rr         jsr xt_execute
0049FEr 2               
0049FEr 2                   ; That's quite enough for this word, let's get the next one
0049FEr 2  4C rr rr         jmp _loop
004A01r 2               
004A01r 2               _compile:
004A01r 2                   ; We're compiling! However, we need to see if this is an
004A01r 2                   ; IMMEDIATE word, which would mean we execute it right now even
004A01r 2                   ; during compilation mode. Fortunately, we saved the nt so life
004A01r 2                   ; is easier. The flags are in the second byte of the header
004A01r 2  A0 01            ldy #1
004A03r 2  B1 rr            lda (tmpbranch),y
004A05r 2  29 04            and #IM                 ; Mask all but IM bit
004A07r 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
004A09r 2               
004A09r 2                   ; Compile the xt into the Dictionary with COMPILE,
004A09r 2  20 rr rr         jsr xt_compile_comma
004A0Cr 2  4C rr rr         jmp _loop
004A0Fr 2               
004A0Fr 2               _line_done:
004A0Fr 2                   ; drop stuff from PARSE_NAME
004A0Fr 2  E8               inx
004A10r 2  E8               inx
004A11r 2  E8               inx
004A12r 2  E8               inx
004A13r 2               
004A13r 2  60               rts
004A14r 2               .endscope
004A14r 2               
004A14r 2               
004A14r 2               is_printable:
004A14r 2               .scope
004A14r 2               ; """Given a character in A, check if it is a printable ASCII
004A14r 2               ; character in the range from $20 to $7E inclusive. Returns the
004A14r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004A14r 2               ; is printable. Keeps A. See
004A14r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004A14r 2               ; discussion of various ways to do this
004A14r 2  C9 20            cmp #AscSP              ; $20
004A16r 2  90 08            bcc _done
004A18r 2  C9 7F            cmp #'~' + 1             ; $7E
004A1Ar 2  B0 03            bcs _failed
004A1Cr 2               
004A1Cr 2  38               sec
004A1Dr 2  80 01            bra _done
004A1Fr 2               _failed:
004A1Fr 2  18               clc
004A20r 2               _done:
004A20r 2  60               rts
004A21r 2               .endscope
004A21r 2               
004A21r 2               
004A21r 2               is_whitespace:
004A21r 2               .scope
004A21r 2               ; """Given a character in A, check if it is a whitespace
004A21r 2               ; character, that is, an ASCII value from 0 to 32 (where
004A21r 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004A21r 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004A21r 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004A21r 2               ; a discussion of the uses. Does not change A or Y.
004A21r 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004A23r 2  90 08            bcc _done
004A25r 2               
004A25r 2  C9 21            cmp #AscSP+1
004A27r 2  B0 03            bcs _failed
004A29r 2               
004A29r 2  38               sec
004A2Ar 2  80 01            bra _done
004A2Cr 2               _failed:
004A2Cr 2  18               clc
004A2Dr 2               _done:
004A2Dr 2  60               rts
004A2Er 2               .endscope
004A2Er 2               
004A2Er 2               
004A2Er 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
004A2Er 2               ; required for the word. This routine flows into the generic error handling
004A2Er 2               ; code
004A2Er 2               underflow_1:
004A2Er 2               ; """Make sure we have at least one cell on the Data Stack"""
004A2Er 2  E0 FE            cpx #dsp0-1
004A30r 2  10 10            bpl underflow_error
004A32r 2  60               rts
004A33r 2               underflow_2:
004A33r 2               ; """Make sure we have at least two cells on the Data Stack"""
004A33r 2  E0 FC            cpx #dsp0-3
004A35r 2  10 0B            bpl underflow_error
004A37r 2  60               rts
004A38r 2               underflow_3:
004A38r 2               ; """Make sure we have at least three cells on the Data Stack"""
004A38r 2  E0 FA            cpx #dsp0-5
004A3Ar 2  10 06            bpl underflow_error
004A3Cr 2  60               rts
004A3Dr 2               underflow_4:
004A3Dr 2               ; """Make sure we have at least four cells on the Data Stack"""
004A3Dr 2  E0 F8            cpx #dsp0-7
004A3Fr 2  10 01            bpl underflow_error
004A41r 2  60               rts
004A42r 2               
004A42r 2               underflow_error:
004A42r 2                   ; Entry for COLD/ABORT/QUIT
004A42r 2  A9 09            lda #err_underflow      ; fall through to error
004A44r 2               
004A44r 2               error:
004A44r 2               ; """Given the error number in a, print the associated error string and
004A44r 2               ; call abort. Uses tmp3.
004A44r 2               ; """
004A44r 2  0A               asl
004A45r 2  A8               tay
004A46r 2  B9 rr rr         lda error_table,y
004A49r 2  85 rr            sta tmp3                ; LSB
004A4Br 2  C8               iny
004A4Cr 2  B9 rr rr         lda error_table,y
004A4Fr 2  85 rr            sta tmp3+1              ; MSB
004A51r 2               
004A51r 2  20 rr rr         jsr print_common
004A54r 2  20 rr rr         jsr xt_cr
004A57r 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
004A5Ar 2               
004A5Ar 2               
004A5Ar 2               ; =====================================================================
004A5Ar 2               ; PRINTING ROUTINES
004A5Ar 2               
004A5Ar 2               ; We distinguish two types of print calls, both of which take the string number
004A5Ar 2               ; (see strings.asm) in A:
004A5Ar 2               
004A5Ar 2               ;       print_string       - with a line feed
004A5Ar 2               ;       print_string_no_lf - without a line feed
004A5Ar 2               
004A5Ar 2               ; In addition, print_common provides a lower-level alternative for error
004A5Ar 2               ; handling and anything else that provides the address of the
004A5Ar 2               ; zero-terminated string directly in tmp3. All of those routines assume that
004A5Ar 2               ; printing should be more concerned with size than speed, because anything to
004A5Ar 2               ; do with humans reading text is going to be slow.
004A5Ar 2               
004A5Ar 2               print_string_no_lf:
004A5Ar 2               ; """Given the number of a zero-terminated string in A, print it to the
004A5Ar 2               ; current output without adding a LF. Uses Y and tmp3 by falling
004A5Ar 2               ; through to print_common
004A5Ar 2               ; """
004A5Ar 2                   ; Get the entry from the string table
004A5Ar 2  0A               asl
004A5Br 2  A8               tay
004A5Cr 2  B9 rr rr         lda string_table,y
004A5Fr 2  85 rr            sta tmp3                ; LSB
004A61r 2  C8               iny
004A62r 2  B9 rr rr         lda string_table,y
004A65r 2  85 rr            sta tmp3+1              ; MSB
004A67r 2               
004A67r 2                   ; fall through to print_common
004A67r 2               print_common:
004A67r 2               ; """Common print routine used by both the print functions and
004A67r 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004A67r 2               ; Y.
004A67r 2               ; """
004A67r 2               .scope
004A67r 2  A0 00            ldy #0
004A69r 2               _loop:
004A69r 2  B1 rr            lda (tmp3),y
004A6Br 2  F0 06            beq _done               ; strings are zero-terminated
004A6Dr 2               
004A6Dr 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004A70r 2  C8               iny
004A71r 2  80 F6            bra _loop
004A73r 2               _done:
004A73r 2  60               rts
004A74r 2               .endscope
004A74r 2               
004A74r 2               print_string:
004A74r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004A74r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004A74r 2               ; """
004A74r 2  20 rr rr         jsr print_string_no_lf
004A77r 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
004A7Ar 2               
004A7Ar 2               
004A7Ar 2               print_u:
004A7Ar 2               ; """basic printing routine used by higher-level constructs,
004A7Ar 2               ; the equivalent of the forth word  0 <# #s #> type  which is
004A7Ar 2               ; basically u. without the space at the end. used for various
004A7Ar 2               ; outputs
004A7Ar 2               ; """
004A7Ar 2  20 rr rr         jsr xt_zero                     ; 0
004A7Dr 2  20 rr rr         jsr xt_less_number_sign         ; <#
004A80r 2  20 rr rr         jsr xt_number_sign_s            ; #S
004A83r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004A86r 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
004A89r 2               
004A89r 2               ; END
004A89r 2               
004A89r 1               
004A89r 1               
004A89r 1               
004A89r 1               kernel_init:
004A89r 1               v_nmi:
004A89r 1  A9 FF            lda #$FF
004A8Br 1  8D 82 FF         sta DDRB
004A8Er 1  8D 83 FF         sta DDRA
004A91r 1  9C 81 FF         stz PORTA
004A94r 1  9C 80 FF         stz PORTB
004A97r 1               .ifdef video_init
004A97r 1                   jsr video_init
004A97r 1               .endif
004A97r 1               .ifdef ps2_init
004A97r 1                   jsr ps2_init
004A97r 1               .endif
004A97r 1               .ifdef timer_init
004A97r 1  20 rr rr         jsr timer_init
004A9Ar 1               .endif
004A9Ar 1  20 rr rr         jsr acia_init
004A9Dr 1               .ifdef lcd_init
004A9Dr 1                   jsr lcd_init
004A9Dr 1               .endif
004A9Dr 1               
004A9Dr 1               
004A9Dr 1  A2 00 BD rr      printascii welcome_message
004AA1r 1  rr F0 06 20  
004AA5r 1  rr rr E8 80  
004AAAr 1               
004AAAr 1  4C rr rr         jmp forth
004AADr 1               
004AADr 1               platform_bye:
004AADr 1  4C rr rr         jmp platform_bye
004AB0r 1               
004AB0r 1               kernel_putc:
004AB0r 1                   ; """Print a single character to the console. """
004AB0r 1                   ;; Send_Char - send character in A out serial port.
004AB0r 1                   ;; Uses: A (original value restored)
004AB0r 1               send_char:
004AB0r 1  48               pha
004AB1r 1                   .ifdef char_out
004AB1r 1                   jsr char_out
004AB1r 1                   .endif
004AB1r 1                   .ifdef acia_out
004AB1r 1  20 rr rr         jsr acia_out
004AB4r 1                   .endif
004AB4r 1               send_char_exit:
004AB4r 1               .ifdef lcd_print
004AB4r 1                   jsr lcd_print
004AB4r 1               .endif
004AB4r 1  68               pla
004AB5r 1  60               rts
004AB6r 1               
004AB6r 1               
004AB6r 1                       ;; Get_Char - get a character from the serial port into A.
004AB6r 1                       ;; Set the carry flag if char is valid.
004AB6r 1                       ;; Return immediately with carry flag clear if no char available.
004AB6r 1                       ;; Uses: A (return value)
004AB6r 1               
004AB6r 1               Get_Char:
004AB6r 1  20 rr rr         jsr acia_getc
004AB9r 1  90 05            bcc get_ps2_char                ; check keyboard buffer if nothing from ACIA
004ABBr 1  20 rr rr         jsr check_ctrl_c
004ABEr 1  38               sec                             ; Set Carry to show we got a character
004ABFr 1  60               rts                             ; Return
004AC0r 1               
004AC0r 1               get_ps2_char:                       ; no ACIA char available, try to get from KB buffer
004AC0r 1               
004AC0r 1               .ifdef ps2_init
004AC0r 1                   phx                             ; save X
004AC0r 1                   ldx KB_BUF_R_PTR                ; check the keyboard buffer
004AC0r 1                   lda KB_BUF, x
004AC0r 1                   beq no_ps2_char_available       ; exit if nothing found
004AC0r 1                   stz KB_BUF, x                   ; if there was a character, reset this buffer cell
004AC0r 1                   inc KB_BUF_R_PTR                ; and increment the read pointer
004AC0r 1               
004AC0r 1                   sec                             ; mark character present
004AC0r 1                   plx                             ; restore X
004AC0r 1                   jsr check_ctrl_c
004AC0r 1                   rts                             ; return
004AC0r 1               no_ps2_char_available:                  ; no keyboard char
004AC0r 1                   inc KB_BUF_R_PTR                ; increment read pointer for next time
004AC0r 1                   plx                             ; restore X
004AC0r 1               .endif
004AC0r 1               no_char_available:
004AC0r 1  18               clc                             ; Indicate no char available.
004AC1r 1  60               rts                             ; return
004AC2r 1               
004AC2r 1               
004AC2r 1               
004AC2r 1               kernel_getc:
004AC2r 1                   ; """Get a single character from the keyboard (waits for key).
004AC2r 1                   ; """
004AC2r 1                   ;; Get_Char_Wait - same as Get_Char only blocking.
004AC2r 1                   ;; Uses: A (return value)
004AC2r 1               Get_Char_Wait:
004AC2r 1  20 rr rr         jsr Get_Char
004AC5r 1  90 FB            bcc Get_Char_Wait
004AC7r 1  60               rts
004AC8r 1               
004AC8r 1               check_ctrl_c:
004AC8r 1                   ;; Check if we have ctrl-C character, if so jump to nmi
004AC8r 1  C9 03            cmp #$03
004ACAr 1  D0 10            bne exit_ctrl_c
004ACCr 1  A2 00 BD rr      printascii abort_message
004AD0r 1  rr F0 06 20  
004AD4r 1  rr rr E8 80  
004AD9r 1  4C rr rr         jmp xt_abort
004ADCr 1               
004ADCr 1               exit_ctrl_c:
004ADCr 1  60               rts
004ADDr 1               
004ADDr 1               
004ADDr 1               
004ADDr 1               v_irq:                          ; IRQ handler
004ADDr 1  48                   pha
004ADEr 1  5A                   phy
004ADFr 1                       ; check if bit 7 of IFR is set
004ADFr 1  AD 8D FF             lda IFR
004AE2r 1  10 18                bpl v_irq_exit  ; Interrupt not from VIA, exit
004AE4r 1               
004AE4r 1  29 08                and #$08        ; ps2 has priority
004AE6r 1  D0 09                bne v_irq_ps2
004AE8r 1  AD 8D FF             lda IFR
004AEBr 1  29 40                and #$40
004AEDr 1  D0 04                bne v_irq_timer
004AEFr 1  80 0B                bra v_irq_exit
004AF1r 1               
004AF1r 1               
004AF1r 1               v_irq_ps2:
004AF1r 1                   .ifdef ps2_irq
004AF1r 1                       lda time
004AF1r 1                       sta last_ps2_time
004AF1r 1                       lda time+1
004AF1r 1                       sta last_ps2_time+1
004AF1r 1                       lda time+2
004AF1r 1                       sta last_ps2_time+2
004AF1r 1                       lda time+3
004AF1r 1                       sta last_ps2_time+3
004AF1r 1                       ; this delay is here to ensure we prevent desynchronization
004AF1r 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004AF1r 1                       ; jsr delay_short
004AF1r 1               
004AF1r 1               
004AF1r 1                       jsr ps2_irq
004AF1r 1               
004AF1r 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004AF1r 1                       ; jsr delay_short
004AF1r 1                   .endif
004AF1r 1  80 09                bra v_irq_exit
004AF3r 1               
004AF3r 1               v_irq_timer:
004AF3r 1  AD 84 FF             lda T1CL
004AF6r 1                   .ifdef timer_irq
004AF6r 1  20 rr rr             jsr timer_irq
004AF9r 1                   .endif
004AF9r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
004AFCr 1                       ; check if there is a char waiting to be printed to the lcd
004AFCr 1                       ; lda lcd_char
004AFCr 1                       ; beq v_exit
004AFCr 1                       ; jsr lcd_print
004AFCr 1                       ; stz lcd_char
004AFCr 1               
004AFCr 1               v_irq_exit:
004AFCr 1  7A                   ply
004AFDr 1  68                   pla
004AFEr 1  40                   rti
004AFFr 1               
004AFFr 1               .segment "RODATA"
0000FFr 1               
0000FFr 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", $0D, "Type 'words' for available words", 0
000103r 1  6F 6D 65 20  
000107r 1  74 6F 20 50  
000137r 1  0D 0A 00     abort_message: .byte AscCR, AscLF, 0
00013Ar 1               
00013Ar 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
