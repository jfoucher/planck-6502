ca65 V2.18 - N/A
Main file   : platform/planck/main.s
Current file: platform/planck/main.s

000000r 1               
000000r 1               .include "../../macros.s"
000000r 2               .macro  printascii   addr
000000r 2               .local @loop
000000r 2               .local @done
000000r 2                   phx
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda addr,x
000000r 2                   beq @done
000000r 2                   jsr kernel_putc
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @done:
000000r 2                   plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro  cp16   src, dest
000000r 2                   lda src
000000r 2                   sta dest
000000r 2                   lda src + 1
000000r 2                   sta dest + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro printstr addr, len
000000r 2               .repeat len, I
000000r 2               lda addr + I
000000r 2               jsr kernel_putc
000000r 2               .endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl16 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro lsr16 src
000000r 2                   lsr src + 1
000000r 2                   ror src
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc16 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment the MSB if LSB wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16 src
000000r 2               .local @skip
000000r 2                   lda src
000000r 2                   bne @skip
000000r 2                   dec src + 1
000000r 2               @skip:
000000r 2                   dec src
000000r 2               .endmacro
000000r 2               
000000r 2               .macro add16 first, second, result
000000r 2                   CLC             ;Ensure carry is clear
000000r 2                   LDA first+0       ;Add the two least significant bytes
000000r 2                   ADC second+0
000000r 2                   STA result+0       ;... and store the result
000000r 2                   LDA first+1       ;Add the two most significant bytes
000000r 2                   ADC second+1       ;... and any propagated carry bit
000000r 2                   STA result+1       ;... and store the result
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro push_axy
000000r 2               	pha		; push accumulator to stack
000000r 2               	phx
000000r 2                   phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro pull_axy
000000r 2               	ply		; pull y from stack
000000r 2               	plx		; pull x from stack
000000r 2               	pla		; pull a from stack
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro push_ax
000000r 2               	pha
000000r 2               	phx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ax
000000r 2               	pla
000000r 2               	plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_ay
000000r 2               	pha
000000r 2               	phy
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ay
000000r 2               	pla
000000r 2               	ply
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro mov16 SRC, DEST
000000r 2               	lda SRC
000000r 2               	sta DEST
000000r 2               	lda SRC+1
000000r 2               	sta DEST+1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro mov32 SRC, DEST
000000r 2               	lda SRC
000000r 2               	sta DEST
000000r 2               	lda SRC+1
000000r 2               	sta DEST+1
000000r 2               	lda SRC+2
000000r 2               	sta DEST+2
000000r 2               	lda SRC+3
000000r 2               	sta DEST+3
000000r 2               .endmacro
000000r 2               
000000r 1               CLOCK_SPEED = 24000000
000000r 1               
000000r 1               ram_end = $8000
000000r 1               
000000r 1               ; select includes to enable card drivers
000000r 1               
000000r 1               .include "drivers/cf.inc"
000000r 2               
000000r 2               CF_READ_SECTOR_COMMAND = $20
000000r 2               CF_ADDRESS = $FFA0
000000r 2               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/via.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               VIA1_BASE   = $FF80
000000r 2               PORTB = VIA1_BASE
000000r 2               PORTA  = VIA1_BASE+1
000000r 2               DDRB = VIA1_BASE+2
000000r 2               DDRA = VIA1_BASE+3
000000r 2               
000000r 2               
000000r 2               T1CL = VIA1_BASE + 4
000000r 2               T1CH = VIA1_BASE + 5
000000r 2               T1LL = VIA1_BASE + 6
000000r 2               T1LH = VIA1_BASE + 7
000000r 2               ACR = VIA1_BASE + 11
000000r 2               PCR = VIA1_BASE + 12
000000r 2               IFR = VIA1_BASE + 13
000000r 2               IER = VIA1_BASE + 14
000000r 2               
000000r 1               .include "drivers/sd.inc"
000000r 2               SD = 1
000000r 2               
000000r 1               ; .include "drivers/ps2.inc"
000000r 1               ; .include "drivers/4004.inc"
000000r 1               ; .include "drivers/lcd.inc"
000000r 1               ; .include "drivers/vga.inc"
000000r 1               ; .include "drivers/keyboard.inc"
000000r 1               
000000r 1               .segment "ZEROPAGE": zeropage
000000r 1               
000000r 1               .include "drivers/zp.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               ; next_addr: .res 1
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2  xx xx        tmp_var: .res 2
000002r 2  xx xx        stack_p: .res 2
000004r 2               .ifdef VIA1_BASE
000004r 2  xx xx xx xx  time: .res 4
000008r 2               .endif
000008r 2               
000008r 2               .ifdef CF_ADDRESS
000008r 2  xx xx        CF_POINTER: .res 2
00000Ar 2  xx xx        CF_BUF_PTR: .res 2
00000Cr 2               
00000Cr 2               .endif
00000Cr 2               .if .def(CF_ADDRESS)
00000Cr 2  xx xx        FAT_PTR1: .res 2
00000Er 2  xx xx        FAT_PTR2: .res 2
000010r 2               .elseif .def(SD)
000010r 2               FAT_PTR1: .res 2
000010r 2               FAT_PTR2: .res 2
000010r 2               .endif
000010r 2               
000010r 1               
000010r 1               .segment "BSS"
000000r 1               .ifdef VIA1_BASE
000000r 1  xx           lcd_absent: .res 1
000001r 1               .endif
000001r 1               .ifdef ACIA_BASE
000001r 1  xx           has_acia: .res 1
000002r 1               .endif
000002r 1               
000002r 1               .ifdef CF_ADDRESS
000002r 1               
000002r 1               .endif
000002r 1               
000002r 1               
000002r 1               
000002r 1               .segment "STARTUP"
000000r 1               .import    copydata
000000r 1               .import zerobss
000000r 1               zero_ram:
000000r 1  A2 FF            ldx #$FF
000002r 1               zero_zp:
000002r 1  74 00            stz 0, x
000004r 1  CA               dex
000005r 1  D0 FB            bne zero_zp
000007r 1  64 00            stz $00
000009r 1  A9 00            lda #0
00000Br 1  85 01            sta $01
00000Dr 1               
00000Dr 1  A2 80            ldx #$80
00000Fr 1  A0 00            ldy #0
000011r 1  A9 00            lda #0
000013r 1               @loop:
000013r 1  91 00            sta ($0), y
000015r 1  C8               iny
000016r 1  D0 FB            bne @loop
000018r 1  E6 01            inc $1
00001Ar 1  CA               dex
00001Br 1  D0 F6            bne @loop
00001Dr 1               
00001Dr 1  4C rr rr         jmp ram_zeroed
000020r 1               
000020r 1               v_reset:
000020r 1  4C rr rr         jmp zero_ram
000023r 1               ram_zeroed:
000023r 1  20 rr rr         JSR     copydata
000026r 1  20 rr rr         jsr zerobss
000029r 1               
000029r 1  4C rr rr         jmp kernel_init
00002Cr 1               
00002Cr 1               
00002Cr 1               
00002Cr 1               .segment "DATA"
000000r 1               
000000r 1               .include "drivers/delayroutines.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               ; this routine delays by 2304 * y + 23 cycles
000000r 2               delay:
000000r 2  DA             phx       ; 3 cycles
000001r 2  5A             phy       ; 3 cycles
000002r 2               two:
000002r 2  A2 FF          ldx #$ff  ; 2 cycles
000004r 2               one:
000004r 2  EA             nop       ; 2 cycles
000005r 2  EA             nop       ; 2 cycles
000006r 2  CA             dex       ; 2 cycles
000007r 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
000009r 2  88             dey       ; 2 cycles
00000Ar 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
00000Cr 2  7A             ply       ; 4 cycles
00000Dr 2  FA             plx       ; 4 cycles
00000Er 2  60             rts       ; 6 cycles
00000Fr 2               
00000Fr 2               ; delay is in Y register
00000Fr 2               delay_long:
00000Fr 2  48             pha
000010r 2  5A             phy
000011r 2  DA             phx
000012r 2  98             tya
000013r 2  AA             tax
000014r 2               delay_long_loop:
000014r 2  A0 FF          ldy #$ff
000016r 2  20 rr rr       jsr delay
000019r 2  CA             dex
00001Ar 2  D0 F8          bne delay_long_loop
00001Cr 2  FA             plx
00001Dr 2  7A             ply
00001Er 2  68             pla
00001Fr 2  60             rts
000020r 2               
000020r 2               delay_short:        ; delay Y * 19 cycles
000020r 2  5A             phy
000021r 2               delay_short_loop:
000021r 2  EA             nop               ; 2 cycles
000022r 2  EA             nop               ; 2 cycles
000023r 2  EA             nop               ; 2 cycles
000024r 2  EA             nop               ; 2 cycles
000025r 2  EA             nop               ; 2 cycles
000026r 2  EA             nop               ; 2 cycles
000027r 2  EA             nop               ; 2 cycles
000028r 2               
000028r 2               
000028r 2  88             dey               ; 2 cycles
000029r 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
00002Br 2  7A             ply
00002Cr 2  60             rts
00002Dr 2               
00002Dr 1               
00002Dr 1               .ifdef VIA1_BASE
00002Dr 1               .include "drivers/timer.s"
00002Dr 2               
00002Dr 2               
00002Dr 2               COUNTER = CLOCK_SPEED/400        ; n/s
00002Dr 2               
00002Dr 2               timer_init:
00002Dr 2  AD 8E FF         lda IER
000030r 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000032r 2  8D 8E FF         sta IER
000035r 2  A9 40            lda #$40        ; timer one free run mode
000037r 2  8D 8B FF         sta ACR
00003Ar 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
00003Cr 2  8D 84 FF         sta T1CL
00003Fr 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
000041r 2               
000041r 2  8D 85 FF         sta T1CH
000044r 2  58               cli
000045r 2  60               rts
000046r 2               
000046r 2               
000046r 2               timer_irq:
000046r 2  E6 rr            inc time
000048r 2  F0 01            beq @inc1
00004Ar 2               @exit1:
00004Ar 2                   ; this resets the PS/2 temp variables
00004Ar 2                   ;jsr reset_ps2
00004Ar 2  60               rts
00004Br 2               @inc1:
00004Br 2  E6 rr            inc time+1
00004Dr 2  F0 02            beq @inc2
00004Fr 2  80 F9            bra @exit1
000051r 2               @inc2:
000051r 2  E6 rr            inc time+2
000053r 2  F0 02            beq @inc3
000055r 2  80 F3            bra @exit1
000057r 2               @inc3:
000057r 2  E6 rr            inc time+3
000059r 2  80 EF            bra @exit1
00005Br 2  60               rts
00005Cr 2               
00005Cr 1               .include "drivers/spi.s"
00005Cr 2               ; SPI defines
00005Cr 2               .ifndef DATA
00005Cr 2               DATA = $80
00005Cr 2               .endif
00005Cr 2               SS = $07   ; Slave Select with lowest 3 bits
00005Cr 2               SCK = $08   ; Clock on bit 3
00005Cr 2               MISO = $10  ; MISO on bit 4
00005Cr 2               MOSI = $20  ; MOSI on bit 5
00005Cr 2               CONF = $40  ; CONF on bit 6
00005Cr 2               
00005Cr 2               .segment "BSS"
000002r 2  xx           spi_tmp: .res 1
000003r 2  xx           spi_tmp2: .res 1
000004r 2  xx           spi_slave: .res 1
000005r 2               
000005r 2               .segment "DATA"
00005Cr 2               
00005Cr 2               spi_init:
00005Cr 2  AD 80 FF         lda PORTB               ; load current port B
00005Fr 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
000061r 2  09 40            ora #CONF               ; set CONF high
000063r 2  8D 80 FF         sta PORTB               ; save to PORTB
000066r 2  AD 82 FF         lda DDRB                ; get current direction register
000069r 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
00006Br 2  29 EF            and #($FF^MISO)                 ; set MISO as input
00006Dr 2  8D 82 FF         sta DDRB
000070r 2  A9 FF            lda #$FF                ; flash leds to see what is going on
000072r 2  8D 83 FF         sta DDRA
000075r 2  8D 81 FF         sta PORTA
000078r 2  60               rts
000079r 2               
000079r 2               spi_select:
000079r 2                   ; selected slave in A
000079r 2  29 07            and #SS                 ; mask slave select bits
00007Br 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
00007Er 2  8D rr rr         sta spi_slave
000081r 2  5A               phy
000082r 2  A0 01            ldy #$1
000084r 2  20 rr rr         jsr delay_short         ; slight delay
000087r 2  09 40            ora #CONF               ; set CONF high to latch address
000089r 2  8D 80 FF         sta PORTB               ; save to PORTB
00008Cr 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
00008Dr 2  60               rts
00008Er 2               
00008Er 2               spi_clk_toggle:
00008Er 2  60               rts
00008Fr 2               
00008Fr 2               spi_transceive:
00008Fr 2                   ; send data in A, received data will be in A
00008Fr 2  5A               phy
000090r 2                   ; save data in RAM
000090r 2  8D rr rr         sta spi_tmp
000093r 2                   ; reset X
000093r 2  DA               phx
000094r 2  A2 08            ldx #8
000096r 2                   ; reset result
000096r 2  9C rr rr         stz spi_tmp2
000099r 2               spi_send_loop:
000099r 2  0E rr rr         asl spi_tmp
00009Cr 2  90 08            bcc bit_unset
00009Er 2               bit_set:
00009Er 2  AD 80 FF         lda PORTB
0000A1r 2  09 60            ora #(MOSI | CONF)
0000A3r 2  4C rr rr         jmp clock_on
0000A6r 2               bit_unset:
0000A6r 2  AD 80 FF         lda PORTB
0000A9r 2  29 DF            and #(($FF^MOSI) | CONF)
0000ABr 2               clock_on:
0000ABr 2                   ; set data bit
0000ABr 2  0D rr rr         ora spi_slave
0000AEr 2  8D 80 FF         sta PORTB
0000B1r 2               
0000B1r 2                   ; set clock on
0000B1r 2  09 48            ora #(SCK | CONF)
0000B3r 2  0D rr rr         ora spi_slave
0000B6r 2  8D 80 FF         sta PORTB
0000B9r 2               
0000B9r 2                   ; read bit from slave, maybe add slight delay here ?
0000B9r 2  AD 80 FF         lda PORTB
0000BCr 2  29 10            and #MISO           ; mask miso bit
0000BEr 2  D0 07            bne spi_bit_set      ; bit is set
0000C0r 2                   ; bit is unset
0000C0r 2  18               clc
0000C1r 2  2E rr rr         rol spi_tmp2
0000C4r 2  4C rr rr         jmp clock_off
0000C7r 2               
0000C7r 2               spi_bit_set:
0000C7r 2  38               sec
0000C8r 2  2E rr rr         rol spi_tmp2
0000CBr 2               
0000CBr 2               
0000CBr 2               clock_off:
0000CBr 2  AD 80 FF         lda PORTB
0000CEr 2  29 F7            and #(($FF^SCK) | CONF)
0000D0r 2  0D rr rr         ora spi_slave
0000D3r 2  8D 80 FF         sta PORTB
0000D6r 2               end_loop:
0000D6r 2  CA               dex
0000D7r 2  D0 C0            bne spi_send_loop
0000D9r 2                   ; set data low
0000D9r 2  A0 01            ldy #$1
0000DBr 2  20 rr rr         jsr delay_short
0000DEr 2  AD 80 FF         lda PORTB
0000E1r 2  0D rr rr         ora spi_slave
0000E4r 2  29 DF            and #(($FF^MOSI) | CONF)
0000E6r 2  8D 80 FF         sta PORTB
0000E9r 2  FA               plx
0000EAr 2  7A               ply
0000EBr 2  AD rr rr         lda spi_tmp2
0000EEr 2  60               rts
0000EFr 2               
0000EFr 1               .endif
0000EFr 1               
0000EFr 1               .ifdef ACIA_BASE
0000EFr 1               .include "drivers/acia.s"
0000EFr 2               ACIA_DELAY = CLOCK_SPEED / 500000
0000EFr 2               
0000EFr 2               acia_init:
0000EFr 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
0000F2r 2                                           ; set specific modes and functions
0000F2r 2  9C rr rr         stz has_acia
0000F5r 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
0000F7r 2                   ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
0000F7r 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
0000FAr 2  AD E2 FF         lda ACIA_CMD        ; load command register again
0000FDr 2  C9 0B            cmp #$0B                ; if not the same
0000FFr 2  D0 11            bne acia_absent         ; then it means the ACIA is not connected
000101r 2  AD E1 FF         lda ACIA_STATUS         ; Read the ACAI status to
000104r 2  29 60            and #$60                ; check if present or absent
000106r 2  D0 0A            bne acia_absent
000108r 2  A9 01            lda #1
00010Ar 2  8D rr rr         sta has_acia           ; remember that ACIA is here
00010Dr 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
00010Fr 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
00010Fr 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
000112r 2               
000112r 2               acia_absent:
000112r 2  A0 14                ldy #20
000114r 2               aa_loop:
000114r 2  20 rr rr             jsr delay_short
000117r 2  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
00011Ar 2  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
00011Dr 2  88                   dey
00011Er 2  D0 F4                bne aa_loop
000120r 2               aa_end:
000120r 2  60                   rts
000121r 2               
000121r 2               acia_out:
000121r 2  48               pha
000122r 2  5A               phy
000123r 2  8D E0 FF         sta ACIA_DATA
000126r 2  A0 30            ldy #ACIA_DELAY            ;minimal delay is $02
000128r 2  20 rr rr         jsr delay_short
00012Br 2  7A               ply
00012Cr 2  68               pla
00012Dr 2  60               rts
00012Er 2               
00012Er 2               acia_getc:
00012Er 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
000131r 2  29 08            and #$08                        ; Check if there is character in the receiver
000133r 2  F0 05            beq @no_char      ; Exit now if we don't get one.
000135r 2  AD E0 FF         lda ACIA_DATA
000138r 2  38               sec
000139r 2  60               rts
00013Ar 2               @no_char:
00013Ar 2  18               clc
00013Br 2  60               rts
00013Cr 2               
00013Cr 1               .endif
00013Cr 1               
00013Cr 1               
00013Cr 1               .ifdef KB_VIA_BASE
00013Cr 1               .include "drivers/keyboard.s"
00013Cr 1               .endif
00013Cr 1               .ifdef KB_INIT_STATE_RESET
00013Cr 1               .include "drivers/ps2.s"
00013Cr 1               .endif
00013Cr 1               
00013Cr 1               .ifdef LCD2_ENABLED
00013Cr 1               .include "drivers/4004.s"
00013Cr 1               .endif
00013Cr 1               .ifdef CF_ADDRESS
00013Cr 1               .include "drivers/cf.s"
00013Cr 2               
00013Cr 2               
00013Cr 2               cf_wait:
00013Cr 2                   ; phy
00013Cr 2                   ; ldy #7
00013Cr 2               @wait_loop:
00013Cr 2                   ; lda (CF_ADDRESS), y
00013Cr 2  AD A7 FF         lda CF_ADDRESS + 7
00013Fr 2  29 80            and #$80
000141r 2  D0 F9            bne @wait_loop
000143r 2                   ; ply
000143r 2  60               rts
000144r 2               
000144r 2               
000144r 2               cf_init:
000144r 2                   ; phy
000144r 2  A9 04            lda #$4
000146r 2                   ; ldy #7
000146r 2                   ; sta (CF_ADDRESS),y
000146r 2  8D A7 FF         sta CF_ADDRESS + 7
000149r 2  20 rr rr         jsr cf_wait
00014Cr 2  A9 E0            lda #$E0
00014Er 2                   ; ldy #6
00014Er 2                   ; sta (CF_ADDRESS),y
00014Er 2  8D A6 FF         sta CF_ADDRESS + 6
000151r 2  A9 01            lda #$1
000153r 2                   ; ldy #1
000153r 2                   ; sta (CF_ADDRESS),y
000153r 2  8D A1 FF         sta CF_ADDRESS + 1
000156r 2  A9 EF            lda #$EF
000158r 2                   ; ldy #7
000158r 2                   ; sta (CF_ADDRESS),y
000158r 2  8D A7 FF         sta CF_ADDRESS + 7
00015Br 2  20 rr rr         jsr cf_wait
00015Er 2  20 rr rr         jsr cf_err
000161r 2                   ; ply
000161r 2  60               rts
000162r 2               
000162r 2               
000162r 2               ; cf_read:
000162r 2               ;     phy
000162r 2               ;     ldy #0
000162r 2               ; @readloop:
000162r 2               ;     ; phy
000162r 2               ;     ; ldy #7
000162r 2               ;     ; lda (CF_ADDRESS), y
000162r 2               ;     lda CF_ADDRESS + 7
000162r 2               ;     and #8
000162r 2               ;     beq @exit
000162r 2               ;     ; jsr cf_wait
000162r 2               ;     ; ldy #0
000162r 2               ;     ; lda (CF_ADDRESS), y
000162r 2               ;     lda CF_ADDRESS
000162r 2               ;     ; ply
000162r 2               ;     sta (CF_BUF_PTR), y
000162r 2               ;     ; jsr cf_wait
000162r 2               ;     iny
000162r 2               ;     bne @readloop
000162r 2               ;     ; if y wraps around to zero, increment buffer page
000162r 2               ;     inc CF_BUF_PTR+1
000162r 2               ;     bra @readloop
000162r 2               ; @exit:
000162r 2               ;     ; we only come here because we read an & 8 from REG 7
000162r 2               ;     ; ply
000162r 2               ;     dec CF_BUF_PTR+1
000162r 2               ;     ply
000162r 2               ;     rts
000162r 2               
000162r 2               ; : cfread 0 buffptr ! begin cfwait cfreg7 c@ 8 and while cfreg0 c@ cfbuffer buffptr @ + c! buffptr @ 1 + buffptr ! repeat ;
000162r 2               
000162r 2               cf_read:
000162r 2  5A               phy
000163r 2  DA               phx
000164r 2  A2 02            ldx #2
000166r 2  A0 00            ldy #0
000168r 2  A9 rr            lda #<DISK_BUFFER
00016Ar 2  85 rr            sta CF_BUF_PTR
00016Cr 2  A9 rr            lda #>DISK_BUFFER
00016Er 2  85 rr            sta CF_BUF_PTR + 1
000170r 2               @begin:
000170r 2                   ; jsr cf_wait
000170r 2                   ; lda CF_ADDRESS + 7
000170r 2                   ; and #$08
000170r 2                   ; beq @exit
000170r 2  AD A0 FF         lda CF_ADDRESS
000173r 2  91 rr            sta (CF_BUF_PTR), y
000175r 2  C8               iny
000176r 2  D0 F8            bne @begin
000178r 2  E6 rr            inc CF_BUF_PTR + 1
00017Ar 2  20 rr rr         jsr cf_wait
00017Dr 2  CA               dex
00017Er 2  D0 F0            bne @begin
000180r 2               @exit:
000180r 2  FA               plx
000181r 2  7A               ply
000182r 2  60               rts
000183r 2               
000183r 2               ; .macro readsector2
000183r 2               ; .scope
000183r 2               
000183r 2               ; outerloop:
000183r 2               ;     ldx #0
000183r 2               ; wait:
000183r 2               ;     ldy #0
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #$80
000183r 2               ;     bne wait
000183r 2               ; load:
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta (CF_BUF_PTR), y
000183r 2               ;     iny
000183r 2               ;     bne load
000183r 2               
000183r 2               ;     inc CF_BUF_PTR + 1
000183r 2               ;     inx
000183r 2               ;     cpx #2
000183r 2               ;     bcc wait
000183r 2               
000183r 2               ; .endscope
000183r 2               ; .endmacro
000183r 2               
000183r 2               ; cf_read:
000183r 2               ;     sei
000183r 2               ;     phy
000183r 2               ;     phx
000183r 2               ;     lda #<DISK_BUFFER
000183r 2               ;     sta CF_BUF_PTR
000183r 2               ;     lda #>DISK_BUFFER
000183r 2               ;     sta CF_BUF_PTR + 1
000183r 2               
000183r 2               ;     readsector2
000183r 2               ; @loop3:
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #8
000183r 2               ;     beq @exit
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     inx
000183r 2               ;     bne @loop3
000183r 2               ; @exit:
000183r 2               ;     plx
000183r 2               ;     ply
000183r 2               ;     cli
000183r 2               ;     rts
000183r 2               
000183r 2               
000183r 2               ; .macro  readsector
000183r 2               ;     .repeat 64, I
000183r 2               ;         .scope
000183r 2               ;     ; ldx #0
000183r 2               ; wait:
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #$80
000183r 2               ;     bne wait
000183r 2               ; load:
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 1
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 2
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 3
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 4
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 5
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 6
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + I * 8 + 7
000183r 2               ;     ; inx
000183r 2               ;     ; cpx #4
000183r 2               ;     ; bcc load
000183r 2               ;         .endscope
000183r 2               ;     .endrep
000183r 2               ; .endmacro
000183r 2               
000183r 2               ; cf_read:
000183r 2               ;     sei
000183r 2               ;     phx
000183r 2               ;     readsector
000183r 2               ; @loop3:
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #8
000183r 2               ;     beq @exit
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     inx
000183r 2               ;     bne @loop3
000183r 2               ; @exit:
000183r 2               ;     plx
000183r 2               ;     cli
000183r 2               ;     rts
000183r 2               
000183r 2               ; cf_read:
000183r 2               ;     sei
000183r 2               ;     phx
000183r 2               ;     ldx #0
000183r 2               ; @loop1:
000183r 2               ; .repeat 16
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #$80
000183r 2               ;     bne @loop1
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER + 16 * I, x
000183r 2               ;     inx
000183r 2               ;     bne @loop1
000183r 2               ; .endrepeat
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #$80
000183r 2               ;     ; bne @loop1
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               
000183r 2               ;     ; txa
000183r 2               ;     ; and #32
000183r 2               ;     ; bne @getbyte1
000183r 2               
000183r 2               ;     ; lda (CF_ADDRESS), y
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #8
000183r 2               ;     ; beq @exit
000183r 2               ;     ; jsr cf_wait
000183r 2               ; @getbyte1:
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER, x
000183r 2               ;     inx
000183r 2               ;     bne @loop1
000183r 2               ; @wait:
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #$80
000183r 2               ;     bne @wait
000183r 2               ; @loop2:
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #$80
000183r 2               ;     ; bne @loop2
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               ;     ; nop
000183r 2               
000183r 2               ;     ; txa
000183r 2               ;     ; and #32
000183r 2               ;     ; bne @getbyte2
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #$80
000183r 2               ;     ; bne @loop2
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #$80
000183r 2               ;     ; bne @loop2
000183r 2               ;     ; lda CF_ADDRESS + 7
000183r 2               ;     ; and #8
000183r 2               ;     ; beq @exit
000183r 2               ;     ; jsr cf_wait
000183r 2               ; @getbyte2:
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     sta DISK_BUFFER+256, x
000183r 2               ;     inx
000183r 2               ;     bne @loop2
000183r 2               ; @loop3:
000183r 2               ;     lda CF_ADDRESS + 7
000183r 2               ;     and #8
000183r 2               ;     beq @exit
000183r 2               ;     lda CF_ADDRESS
000183r 2               ;     inx
000183r 2               ;     bne @loop3
000183r 2               ; @exit:
000183r 2               ;     plx
000183r 2               ;     cli
000183r 2               ;     rts
000183r 2               
000183r 2               cf_set_lba:
000183r 2                   ; phy
000183r 2  AD rr rr         lda FAT_LBA
000186r 2                   ; ldy #3
000186r 2                   ; sta (CF_ADDRESS),y
000186r 2  8D A3 FF         sta CF_ADDRESS + 3
000189r 2  AD rr rr         lda FAT_LBA + 1
00018Cr 2                   ; ldy #4
00018Cr 2                   ; sta (CF_ADDRESS), y
00018Cr 2  8D A4 FF         sta CF_ADDRESS + 4
00018Fr 2  AD rr rr         lda FAT_LBA + 2
000192r 2                   ; ldy #5
000192r 2                   ; sta (CF_ADDRESS), y
000192r 2  8D A5 FF         sta CF_ADDRESS + 5
000195r 2  AD rr rr         lda FAT_LBA + 3
000198r 2  29 0F            and #$0F
00019Ar 2  09 E0            ora #$E0
00019Cr 2                   ; ldy #6
00019Cr 2                   ; sta (CF_ADDRESS), y
00019Cr 2  8D A6 FF         sta CF_ADDRESS + 6
00019Fr 2                   ; ply
00019Fr 2  60               rts
0001A0r 2               
0001A0r 2               cf_do_read:
0001A0r 2  20 rr rr         jsr cf_set_lba
0001A3r 2  A9 01            lda #1
0001A5r 2                   ; ldy #2
0001A5r 2                   ; sta (CF_ADDRESS), y
0001A5r 2  8D A2 FF         sta CF_ADDRESS + 2
0001A8r 2  20 rr rr         jsr cf_wait
0001ABr 2  A9 20            lda #CF_READ_SECTOR_COMMAND
0001ADr 2                   ; ldy #7
0001ADr 2                   ; sta (CF_ADDRESS), y
0001ADr 2  8D A7 FF         sta CF_ADDRESS + 7
0001B0r 2  20 rr rr         jsr cf_wait
0001B3r 2  20 rr rr         jsr cf_read
0001B6r 2  20 rr rr         jsr cf_err
0001B9r 2  60               rts
0001BAr 2               
0001BAr 2               cf_read_sector:
0001BAr 2  78               sei
0001BBr 2  DA               phx
0001BCr 2  20 rr rr         jsr cf_do_read
0001BFr 2  A2 08            ldx #8
0001C1r 2               ; verify:
0001C1r 2               ;     ; ply
0001C1r 2               ;     ; copy to other buffer
0001C1r 2               ;     jsr cf_copy_buffer
0001C1r 2               
0001C1r 2               ;     ; read sector again
0001C1r 2               ;     jsr cf_do_read
0001C1r 2               
0001C1r 2               ;     ; compare buffers
0001C1r 2               ;     jsr cf_compare_buffers
0001C1r 2               ;     bcc @exit                   ; both buffers are the same, exit
0001C1r 2               ;     dex
0001C1r 2               ;     bne verify            ; buffers are not the same, read again
0001C1r 2               @exit:
0001C1r 2  58               cli
0001C2r 2  FA               plx
0001C3r 2  60               rts
0001C4r 2               
0001C4r 2               cf_compare_buffers:
0001C4r 2  DA               phx
0001C5r 2  A2 00            ldx #0
0001C7r 2               @loop:
0001C7r 2  BD rr rr         lda DISK_BUFFER, x
0001CAr 2  DD rr rr         cmp FAT_BUFFER2, x
0001CDr 2  D0 10            bne @exit_fail
0001CFr 2  E8               inx
0001D0r 2  D0 F5            bne @loop
0001D2r 2               @loop2:
0001D2r 2  BD rr rr         lda DISK_BUFFER+256, x
0001D5r 2  DD rr rr         cmp FAT_BUFFER2+256, x
0001D8r 2  D0 05            bne @exit_fail
0001DAr 2  E8               inx
0001DBr 2  D0 F5            bne @loop2
0001DDr 2  80 03            bra @exit_ok
0001DFr 2               @exit_fail:
0001DFr 2  38               sec
0001E0r 2  FA               plx
0001E1r 2  60               rts
0001E2r 2               @exit_ok:
0001E2r 2  18               clc
0001E3r 2  FA               plx
0001E4r 2  60               rts
0001E5r 2               
0001E5r 2               cf_copy_buffer:
0001E5r 2  DA               phx
0001E6r 2  A2 00            ldx #0
0001E8r 2               @loop:
0001E8r 2  BD rr rr         lda DISK_BUFFER, x
0001EBr 2  9D rr rr         sta FAT_BUFFER2, x
0001EEr 2  E8               inx
0001EFr 2  D0 F7            bne @loop
0001F1r 2               @loop2:
0001F1r 2  BD rr rr         lda DISK_BUFFER+256, x
0001F4r 2  9D rr rr         sta FAT_BUFFER2+256, x
0001F7r 2  E8               inx
0001F8r 2  D0 F7            bne @loop2
0001FAr 2               
0001FAr 2  FA               plx
0001FBr 2  60               rts
0001FCr 2               
0001FCr 2               cf_err:
0001FCr 2                   ; phy
0001FCr 2  20 rr rr         jsr cf_wait
0001FFr 2                   ; ldy #7
0001FFr 2                   ; lda (CF_ADDRESS), y
0001FFr 2  AD A7 FF         lda CF_ADDRESS + 7
000202r 2  29 01            and #$01
000204r 2  F0 05            beq @exit
000206r 2               @exit_fail:
000206r 2  A9 21            lda #'!'
000208r 2  20 rr rr         jsr kernel_putc
00020Br 2               @exit:
00020Br 2                   ; ply
00020Br 2  60               rts
00020Cr 2               
00020Cr 2               cf_info:
00020Cr 2               
00020Cr 2               
00020Cr 2               cf_end:
00020Cr 2               
00020Cr 2               
00020Cr 1               .endif
00020Cr 1               .ifdef SD
00020Cr 1               
00020Cr 1               .include "drivers/sd.s"
00020Cr 2               ; SD card driver
00020Cr 2               
00020Cr 2               ; SD card initialization routine
00020Cr 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
00020Cr 2               
00020Cr 2               
00020Cr 2               
00020Cr 2               .segment "ZEROPAGE": zeropage
000010r 2  xx xx        sd_buffer_address: .res 2
000012r 2               
000012r 2               .segment "BSS"
000005r 2  xx           sd_sector: .res 1
000006r 2  xx xx        SD_TMP: .res 2
000008r 2               
000008r 2  xx           SD_CRC: .res 1
000009r 2  xx           SD_SLAVE: .res 1
00000Ar 2  xx xx xx xx  SD_ARG: .res 4
00000Er 2  xx xx xx xx  SD_BUF: .res 4
000012r 2               .segment "DATA"
00020Cr 2               
00020Cr 2               sd_init:                    ; slave address in A
00020Cr 2  8D rr rr         sta SD_SLAVE             ; save slave address for later use
00020Fr 2               
00020Fr 2  DA               phx
000210r 2               
000210r 2  20 rr rr         jsr spi_init                ; init SPI system
000213r 2               
000213r 2  A9 00            lda #0
000215r 2  20 rr rr         jsr spi_select          ; DEselect slave
000218r 2  9C rr rr         stz SD_ARG
00021Br 2  9C rr rr         stz SD_ARG+1            ; clear command argument
00021Er 2  9C rr rr         stz SD_ARG+2
000221r 2  9C rr rr         stz SD_ARG+3
000224r 2  A9 95            lda #$95
000226r 2  8D rr rr         sta SD_CRC              ; set CRC for CMD0
000229r 2                   ; send 10 bytes of $FF With SD card deselected
000229r 2               
000229r 2  A2 0A            ldx #10
00022Br 2               init_loop:
00022Br 2  A9 FF            lda #$FF
00022Dr 2  20 rr rr         jsr spi_transceive
000230r 2  CA               dex
000231r 2  D0 F8            bne init_loop
000233r 2               
000233r 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
000236r 2  C9 01            cmp #$01                ; Check for idle state
000238r 2  D0 55            bne sd_error
00023Ar 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
00023Dr 2  C9 01            cmp #$01                ; Check for idle state
00023Fr 2  D0 4E            bne sd_error
000241r 2                   ; TODO check if long response is $01AA
000241r 2               
000241r 2                   ; wait for card to be initialized
000241r 2  A2 FF            ldx #$ff    ; Max times to loop
000243r 2  9C rr rr         stz SD_ARG
000246r 2  9C rr rr         stz SD_ARG+1
000249r 2  9C rr rr         stz SD_ARG+2
00024Cr 2  9C rr rr         stz SD_ARG+3
00024Fr 2               sd_init_loop2:
00024Fr 2  CA               dex
000250r 2  F0 3D            beq sd_error
000252r 2  9C rr rr         stz SD_ARG+3
000255r 2  A9 37            lda #55
000257r 2  20 rr rr         jsr sd_command
00025Ar 2  A9 40            lda #$40
00025Cr 2  8D rr rr         sta SD_ARG+3
00025Fr 2  A9 29            lda #41
000261r 2  20 rr rr         jsr sd_command
000264r 2               
000264r 2  D0 E9            bne sd_init_loop2
000266r 2               
000266r 2                   ; jmp sd_error
000266r 2               
000266r 2  A9 3A            lda #58
000268r 2  20 rr rr         jsr sd_command
00026Br 2  AD rr rr         lda SD_BUF
00026Er 2  29 40            and #$40
000270r 2  F0 07            beq force_block_size    ; CCS bit is unset, force block addressing
000272r 2               sd_init_exit_success:
000272r 2  FA               plx
000273r 2  9C rr rr         stz SD_CRC              ; reset CRC to zero
000276r 2  A9 00            lda #0
000278r 2               
000278r 2  60               rts
000279r 2               
000279r 2               force_block_size:
000279r 2  9C rr rr         stz SD_ARG
00027Cr 2  9C rr rr         stz SD_ARG+1
00027Fr 2  A9 02            lda #$2
000281r 2  8D rr rr         sta SD_ARG+2
000284r 2  9C rr rr         stz SD_ARG+3    ; set block size to $200 (512 bytes)
000287r 2  A9 10            lda #$10
000289r 2  20 rr rr         jsr sd_command
00028Cr 2  4C rr rr         jmp sd_init_exit_success
00028Fr 2               
00028Fr 2               sd_error:
00028Fr 2  FA               plx
000290r 2  A9 01            lda #1
000292r 2  60               rts
000293r 2               
000293r 2               sd_command:         ; command index is in A
000293r 2  29 3F            and #$3F        ; only keep low 6 bits
000295r 2  8D rr rr         sta SD_TMP
000298r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
00029Ar 2               
00029Ar 2                   ; Select chip
00029Ar 2  20 rr rr         jsr sd_command_start
00029Dr 2               
00029Dr 2  20 rr rr         jsr spi_transceive  ; send command index
0002A0r 2                   ; command argument is in SD_ARG
0002A0r 2                   ; SPI is big endian, so reverse argument order
0002A0r 2  AD rr rr         lda SD_ARG + 3
0002A3r 2  20 rr rr         jsr spi_transceive
0002A6r 2  AD rr rr         lda SD_ARG+2
0002A9r 2  20 rr rr         jsr spi_transceive
0002ACr 2  AD rr rr         lda SD_ARG+1
0002AFr 2  20 rr rr         jsr spi_transceive
0002B2r 2  AD rr rr         lda SD_ARG
0002B5r 2  20 rr rr         jsr spi_transceive
0002B8r 2  AD rr rr         lda SD_CRC          ; send hardcoded CRC if available
0002BBr 2  20 rr rr         jsr spi_transceive
0002BEr 2               
0002BEr 2                   ; wait for a zero to be received in the top bit of the response
0002BEr 2               sd_response_wait_loop:
0002BEr 2  A9 FF            lda #$FF
0002C0r 2  20 rr rr         jsr spi_transceive
0002C3r 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
0002C5r 2               
0002C5r 2  48               pha
0002C6r 2               
0002C6r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
0002C6r 2               
0002C6r 2                   ; get 32 bits of response for CMD 8 and CMD 58
0002C6r 2  AD rr rr         lda SD_TMP
0002C9r 2  C9 08            cmp #8
0002CBr 2  F0 0D            beq long_response
0002CDr 2  C9 3A            cmp #58
0002CFr 2  F0 09            beq long_response
0002D1r 2  C9 11            cmp #$11
0002D3r 2  F0 03            beq sd_command_exit_no_end
0002D5r 2               
0002D5r 2               sd_command_exit:
0002D5r 2  20 rr rr         jsr sd_command_end
0002D8r 2               sd_command_exit_no_end:
0002D8r 2  68               pla
0002D9r 2                   ; return the response
0002D9r 2  60               rts
0002DAr 2               
0002DAr 2               long_response:
0002DAr 2  A9 FF            lda #$FF
0002DCr 2  20 rr rr         jsr spi_transceive
0002DFr 2  8D rr rr         sta SD_BUF
0002E2r 2  A9 FF            lda #$FF
0002E4r 2  20 rr rr         jsr spi_transceive
0002E7r 2  8D rr rr         sta SD_BUF+1
0002EAr 2  A9 FF            lda #$FF
0002ECr 2  20 rr rr         jsr spi_transceive
0002EFr 2  8D rr rr         sta SD_BUF+2
0002F2r 2  A9 FF            lda #$FF
0002F4r 2  20 rr rr         jsr spi_transceive
0002F7r 2  8D rr rr         sta SD_BUF+3
0002FAr 2  4C rr rr         jmp sd_command_exit
0002FDr 2               
0002FDr 2               ; send SD card CMD0
0002FDr 2               sd_cmd_0:
0002FDr 2  A9 95            lda #$95
0002FFr 2  8D rr rr         sta SD_CRC
000302r 2  9C rr rr         stz SD_ARG
000305r 2  9C rr rr         stz SD_ARG+1
000308r 2  9C rr rr         stz SD_ARG+2
00030Br 2  9C rr rr         stz SD_ARG+3
00030Er 2  A9 00            lda #0
000310r 2  20 rr rr         jsr sd_command
000313r 2  60               rts
000314r 2               
000314r 2               ; send SD card CMD8
000314r 2               sd_cmd_8:
000314r 2  A9 87            lda #$87
000316r 2  8D rr rr         sta SD_CRC
000319r 2                   ; store in little endian
000319r 2                   ; will be converted to big endian when sending command
000319r 2  9C rr rr         stz SD_ARG+3
00031Cr 2  9C rr rr         stz SD_ARG+2
00031Fr 2  A9 01            lda #1
000321r 2  8D rr rr         sta SD_ARG+1
000324r 2  A9 AA            lda #$AA
000326r 2  8D rr rr         sta SD_ARG
000329r 2  A9 48            lda #$48
00032Br 2  20 rr rr         jsr sd_command
00032Er 2               
00032Er 2  60               rts
00032Fr 2               
00032Fr 2               sd_command_start:
00032Fr 2  48               pha                         ; Save A
000330r 2  AD rr rr         lda SD_SLAVE
000333r 2  20 rr rr         jsr spi_select
000336r 2  68               pla                         ; Restore A
000337r 2  60               rts
000338r 2               
000338r 2               sd_command_end:
000338r 2  48               pha
000339r 2  A9 00            lda #0
00033Br 2  20 rr rr         jsr spi_select
00033Er 2  A9 FF            lda #$FF
000340r 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
000343r 2  68               pla
000344r 2  60               rts
000345r 2               
000345r 2               
000345r 2               sd_readsector:
000345r 2                   ; Read a sector from the SD card.  A sector is 512 bytes.
000345r 2                   ;
000345r 2                   ; Parameters:
000345r 2               
000345r 2  A9 rr            lda #<DISK_BUFFER
000347r 2  85 rr            sta sd_buffer_address
000349r 2  A9 rr            lda #>DISK_BUFFER
00034Br 2  85 rr            sta sd_buffer_address + 1
00034Dr 2               
00034Dr 2  AD rr rr         lda FAT_LBA
000350r 2  8D rr rr         sta SD_ARG
000353r 2  AD rr rr         lda FAT_LBA + 1
000356r 2  8D rr rr         sta SD_ARG + 1
000359r 2  AD rr rr         lda FAT_LBA + 2
00035Cr 2  8D rr rr         sta SD_ARG + 2
00035Fr 2  AD rr rr         lda FAT_LBA + 2
000362r 2  8D rr rr         sta SD_ARG + 2
000365r 2               
000365r 2  DA               phx
000366r 2  20 rr rr         jsr sd_command_start
000369r 2                   ; Command 17, arg is sector number, crc not checked
000369r 2  A9 11            lda #$11                    ; CMD17 - READ_SINGLE_BLOCK
00036Br 2  20 rr rr         jsr sd_command
00036Er 2               
00036Er 2  C9 00            cmp #0              ; Check if command accepted by card
000370r 2  D0 29            bne @fail
000372r 2  A2 FF            ldx #$FF
000374r 2               @feloop:
000374r 2  CA               dex
000375r 2  F0 24            beq @fail           ; the card took too long to get ready
000377r 2  A9 FF            lda #$FF
000379r 2  20 rr rr         jsr spi_transceive
00037Cr 2  C9 FE            cmp #$FE            ; are we about to receive data ?
00037Er 2  D0 F4            bne @feloop
000380r 2               
000380r 2                   ; Read page by page
000380r 2  20 rr rr         jsr readpage
000383r 2  E6 rr            inc sd_buffer_address+1
000385r 2  20 rr rr         jsr readpage
000388r 2  C6 rr            dec sd_buffer_address+1
00038Ar 2               
00038Ar 2  A9 FF            lda #$FF
00038Cr 2  20 rr rr         jsr spi_transceive      ; read and discard CRC
00038Fr 2  A9 FF            lda #$FF
000391r 2  20 rr rr         jsr spi_transceive
000394r 2  20 rr rr         jsr sd_command_end
000397r 2  FA               plx
000398r 2  A9 00            lda #0
00039Ar 2  60               rts
00039Br 2               
00039Br 2               @fail:
00039Br 2                   ; return 1 means fail
00039Br 2  20 rr rr         jsr sd_command_end
00039Er 2  FA               plx
00039Fr 2  A9 01            lda #1
0003A1r 2  60               rts
0003A2r 2               
0003A2r 2               readpage:
0003A2r 2                   ; Read 256 bytes to the address at zp_sd_address
0003A2r 2  5A               phy
0003A3r 2  A0 00            ldy #0
0003A5r 2               @readloop:
0003A5r 2  A9 FF            lda #$FF
0003A7r 2  20 rr rr         jsr spi_transceive
0003AAr 2  91 rr            sta (sd_buffer_address),y
0003ACr 2  C8               iny
0003ADr 2  D0 F6            bne @readloop
0003AFr 2  7A               ply
0003B0r 2  60               rts
0003B1r 2               
0003B1r 2               sd_init_success_message:
0003B1r 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
0003B5r 2  69 6E 69 74  
0003B9r 2  20 4F 4B 0D  
0003BEr 2               
0003BEr 2               sd_init_error_message:
0003BEr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
0003C2r 2  69 6E 69 74  
0003C6r 2  20 46 41 49  
0003CEr 2               
0003CEr 2               sd_read_error_message:
0003CEr 2  0D 53 44 20      .byte $0D,"SD read FAIL", $0D, 7, 0
0003D2r 2  72 65 61 64  
0003D6r 2  20 46 41 49  
0003DEr 2               
0003DEr 1               
0003DEr 1               .endif
0003DEr 1               
0003DEr 1               .if .def(SD)
0003DEr 1               .include "../../fat16.s"
0003DEr 2               .segment "BSS"
000012r 2               
000012r 2  xx xx xx xx  FAT_LBA: .res 4
000016r 2  xx xx xx xx  FAT_PART_START: .res 4
00001Ar 2  xx xx xx xx  FAT_CURRENT_DIR_SEC: .res 4
00001Er 2  xx xx xx xx  FAT_CURRENT_FILE_SIZE: .res 4
000022r 2  xx xx xx xx  FAT_TMP: .res 4
000026r 2  xx xx        FAT_CURRENT_CLUSTER: .res 2
000028r 2  xx xx        FAT_ROOT_ENT_CNT: .res 2     ; $200
00002Ar 2  xx xx        FAT_ROOT_DIR_SECS: .res 2    ; $02
00002Cr 2  xx xx        FAT_SEC_CNT: .res 2      ; $F5
00002Er 2  xx xx        FAT_FIRST_DATA_SEC: .res 2   ; $022B
000030r 2  xx xx        FAT_FIRST_ROOT_SEC: .res 2   ; $020B
000032r 2  xx           FAT_SEC_PER_CLUS: .res 1     ; $8
000033r 2  xx xx xx xx  FAT_CURRENT_DIR: .res 12
000037r 2  xx xx xx xx  
00003Br 2  xx xx xx xx  
00003Fr 2  xx xx xx xx  FAT_FILE_NAME_TMP: .res 12
000043r 2  xx xx xx xx  
000047r 2  xx xx xx xx  
00004Br 2               
00004Br 2  xx xx xx xx  DISK_BUFFER: .res $200
00004Fr 2  xx xx xx xx  
000053r 2  xx xx xx xx  
00024Br 2  xx xx xx xx  FAT_BUFFER2: .res $200
00024Fr 2  xx xx xx xx  
000253r 2  xx xx xx xx  
00044Br 2               
00044Br 2               .segment "DATA"
0003DEr 2               .if .def(SD)
0003DEr 2  rr rr        io_read_sector_ptr: .word sd_readsector
0003E0r 2               .elseif .def(CF_ADDRESS)
0003E0r 2               io_read_sector_ptr: .word cf_read_sector
0003E0r 2               .endif
0003E0r 2  20 00        fat_entry_size: .byte $20, 0
0003E2r 2               
0003E2r 2               fat_mounted_error1:
0003E2r 2  45 72 72 6F          .asciiz "Error reading boot sector"
0003E6r 2  72 20 72 65  
0003EAr 2  61 64 69 6E  
0003FCr 2               fat_mounted_error2:
0003FCr 2  45 72 72 6F          .asciiz "Error reading FAT sector"
000400r 2  72 20 72 65  
000404r 2  61 64 69 6E  
000415r 2               
000415r 2               
000415r 2               fat_init:
000415r 2               check_fat_sector_signature:
000415r 2  9C rr rr     		stz FAT_LBA
000418r 2  9C rr rr             stz FAT_LBA + 1
00041Br 2  9C rr rr             stz FAT_LBA + 2
00041Er 2  9C rr rr             stz FAT_LBA + 3
000421r 2  9C rr rr             stz FAT_CURRENT_CLUSTER                  ; reset variables
000424r 2  9C rr rr             stz FAT_CURRENT_CLUSTER + 1
000427r 2  9C rr rr             stz FAT_CURRENT_DIR_SEC
00042Ar 2  9C rr rr             stz FAT_CURRENT_DIR_SEC + 1
00042Dr 2  9C rr rr             stz FAT_CURRENT_DIR_SEC + 2
000430r 2  9C rr rr             stz FAT_CURRENT_DIR_SEC + 3
000433r 2               
000433r 2                       ; LBA is set, now read sector
000433r 2  20 rr rr             jsr io_read_sector
000436r 2               
000436r 2               		; we now have the first sector in DISK_BUFFER
000436r 2               .ifdef check_fat_sector_signature
000436r 2                       ; check signature
000436r 2  AD rr rr             lda DISK_BUFFER + $1FE
000439r 2  C9 55                cmp #$55
00043Br 2  D0 07                bne @sigerr
00043Dr 2  AD rr rr             lda DISK_BUFFER + $1FF
000440r 2  C9 AA                cmp #$AA
000442r 2  F0 03                beq @sigok
000444r 2               @sigerr:
000444r 2  4C rr rr             jmp fat_init_error
000447r 2               @sigok:
000447r 2               .endif
000447r 2               
000447r 2                       ; check if this is MBR or FAT start sector
000447r 2  AD rr rr             lda DISK_BUFFER + 54
00044Ar 2  C9 46                cmp #'F'
00044Cr 2  D0 10                bne @read_fat_sector
00044Er 2  AD rr rr             lda DISK_BUFFER + 55
000451r 2  C9 41                cmp #'A'
000453r 2  D0 09                bne @read_fat_sector
000455r 2  AD rr rr             lda DISK_BUFFER + 56
000458r 2  C9 54                cmp #'T'
00045Ar 2  D0 02                bne @read_fat_sector
00045Cr 2               
00045Cr 2  80 38                bra @is_fat_sector
00045Er 2               
00045Er 2               @read_fat_sector:
00045Er 2                       ; read FAT start sector
00045Er 2                       ; and save to sector address to read
00045Er 2  AD rr rr             lda DISK_BUFFER + 454
000461r 2  8D rr rr             sta FAT_LBA
000464r 2  8D rr rr             sta FAT_PART_START
000467r 2  AD rr rr             lda DISK_BUFFER + 455
00046Ar 2  8D rr rr             sta FAT_LBA + 1
00046Dr 2  8D rr rr             sta FAT_PART_START + 1
000470r 2  AD rr rr             lda DISK_BUFFER + 456
000473r 2  8D rr rr             sta FAT_LBA + 2
000476r 2  8D rr rr             sta FAT_PART_START + 2
000479r 2  AD rr rr             lda DISK_BUFFER + 457
00047Cr 2  8D rr rr             sta FAT_LBA + 3
00047Fr 2  8D rr rr             sta FAT_PART_START + 3
000482r 2               
000482r 2                       ; LBA is set, now read sector
000482r 2  20 rr rr             jsr io_read_sector
000485r 2                       ; We now have the FAT start sector in the buffer
000485r 2               .ifdef check_fat_sector_signature
000485r 2                       ; check signature
000485r 2  AD rr rr             lda DISK_BUFFER + $1FE
000488r 2  C9 55                cmp #$55
00048Ar 2  D0 07                bne @sigerr2
00048Cr 2  AD rr rr             lda DISK_BUFFER + $1FF
00048Fr 2  C9 AA                cmp #$AA
000491r 2  F0 03                beq @is_fat_sector
000493r 2               @sigerr2:
000493r 2  4C rr rr             jmp fat_init_error2
000496r 2               @is_fat_sector:
000496r 2               .endif
000496r 2                       ; Check if its partition first sector
000496r 2  AD rr rr             lda DISK_BUFFER + 54
000499r 2  C9 46                cmp #'F'
00049Br 2  D0 F6                bne @sigerr2
00049Dr 2  AD rr rr             lda DISK_BUFFER + 55
0004A0r 2  C9 41                cmp #'A'
0004A2r 2  D0 EF                bne @sigerr2
0004A4r 2  AD rr rr             lda DISK_BUFFER + 56
0004A7r 2  C9 54                cmp #'T'
0004A9r 2  D0 E8                bne @sigerr2
0004ABr 2                       ; Save FAT sectors count
0004ABr 2  AD rr rr 8D          cp16 DISK_BUFFER + 22, FAT_SEC_CNT
0004AFr 2  rr rr AD rr  
0004B3r 2  rr 8D rr rr  
0004B7r 2                       ; Get the sectors per cluster
0004B7r 2  AD rr rr             lda DISK_BUFFER + 13
0004BAr 2  8D rr rr             sta FAT_SEC_PER_CLUS
0004BDr 2                       ; get the number of directory entries in the root directory
0004BDr 2  AD rr rr 8D          cp16 DISK_BUFFER + 17, FAT_ROOT_ENT_CNT
0004C1r 2  rr rr AD rr  
0004C5r 2  rr 8D rr rr  
0004C9r 2               
0004C9r 2                       ;($600 * 32 + 511) / 512
0004C9r 2                       ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec – 1)) / BPB_BytsPerSec;
0004C9r 2  AD rr rr 8D          cp16 FAT_ROOT_ENT_CNT, FAT_ROOT_DIR_SECS
0004CDr 2  rr rr AD rr  
0004D1r 2  rr 8D rr rr  
0004D5r 2                       ; multiply by 32
0004D5r 2  0E rr rr 2E          asl16 FAT_ROOT_DIR_SECS
0004D9r 2  rr rr        
0004DBr 2  0E rr rr 2E          asl16 FAT_ROOT_DIR_SECS
0004DFr 2  rr rr        
0004E1r 2  0E rr rr 2E          asl16 FAT_ROOT_DIR_SECS
0004E5r 2  rr rr        
0004E7r 2  0E rr rr 2E          asl16 FAT_ROOT_DIR_SECS
0004EBr 2  rr rr        
0004EDr 2  0E rr rr 2E          asl16 FAT_ROOT_DIR_SECS
0004F1r 2  rr rr        
0004F3r 2                       ; add 512
0004F3r 2  EE rr rr             inc FAT_ROOT_DIR_SECS+1
0004F6r 2  EE rr rr             inc FAT_ROOT_DIR_SECS+1
0004F9r 2                       ; subtract 1
0004F9r 2  AD rr rr D0          dec16 FAT_ROOT_DIR_SECS
0004FDr 2  03 CE rr rr  
000501r 2  CE rr rr     
000504r 2                       ; divide by 512
000504r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000508r 2  rr rr        
00050Ar 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
00050Er 2  rr rr        
000510r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000514r 2  rr rr        
000516r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
00051Ar 2  rr rr        
00051Cr 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000520r 2  rr rr        
000522r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000526r 2  rr rr        
000528r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
00052Cr 2  rr rr        
00052Er 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000532r 2  rr rr        
000534r 2  4E rr rr 6E          lsr16 FAT_ROOT_DIR_SECS
000538r 2  rr rr        
00053Ar 2               
00053Ar 2                       ; FirstRootDirSecNum = BPB_ResvdSecCnt + (BPB_NumFATs * BPB_FATSz16) + FAT_PART_START;
00053Ar 2                       ; CF_FIRST_ROOT_SEC = 1 + 2*CF_FAT_SEC_CNT + FAT_PART_START
00053Ar 2               
00053Ar 2               
00053Ar 2  AD rr rr 8D          cp16 FAT_SEC_CNT, FAT_FIRST_ROOT_SEC
00053Er 2  rr rr AD rr  
000542r 2  rr 8D rr rr  
000546r 2  0E rr rr 2E          asl16 FAT_FIRST_ROOT_SEC
00054Ar 2  rr rr        
00054Cr 2  EE rr rr D0          inc16 FAT_FIRST_ROOT_SEC
000550r 2  03 EE rr rr  
000554r 2  18 AD rr rr          add16 FAT_FIRST_ROOT_SEC, FAT_PART_START, FAT_FIRST_ROOT_SEC
000558r 2  6D rr rr 8D  
00055Cr 2  rr rr AD rr  
000567r 2               
000567r 2  AD rr rr 8D          cp16 FAT_FIRST_ROOT_SEC, FAT_CURRENT_DIR_SEC
00056Br 2  rr rr AD rr  
00056Fr 2  rr 8D rr rr  
000573r 2               
000573r 2                       ; FirstDataSector = BPB_ResvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors;
000573r 2                       ; CF_FIRST_DATA_SEC = 1 + 2*CF_FAT_SEC_CNT + CF_ROOT_DIR_SECS
000573r 2  18 AD rr rr          add16 FAT_FIRST_ROOT_SEC, FAT_ROOT_DIR_SECS, FAT_FIRST_DATA_SEC
000577r 2  6D rr rr 8D  
00057Br 2  rr rr AD rr  
000586r 2               
000586r 2  9C rr rr             stz FAT_CURRENT_CLUSTER
000589r 2  9C rr rr             stz FAT_CURRENT_CLUSTER + 1
00058Cr 2                       ; print volume label
00058Cr 2  AD rr rr 20          printstr DISK_BUFFER + 43, 11
000590r 2  rr rr AD rr  
000594r 2  rr 20 rr rr  
0005CEr 2                       ; printascii cf_fat_mounted_message
0005CEr 2                       ; jsr xt_cr
0005CEr 2               
0005CEr 2  60           		rts
0005CFr 2               
0005CFr 2               fat_init_error:
0005CFr 2  DA A2 00 BD          printascii fat_mounted_error1
0005D3r 2  rr rr F0 06  
0005D7r 2  20 rr rr E8  
0005DEr 2  20 rr rr             jsr xt_cr
0005E1r 2  4C rr rr             jmp xt_abort
0005E4r 2               fat_init_error2:
0005E4r 2  DA A2 00 BD          printascii fat_mounted_error2
0005E8r 2  rr rr F0 06  
0005ECr 2  20 rr rr E8  
0005F3r 2  20 rr rr             jsr xt_cr
0005F6r 2  4C rr rr             jmp xt_abort
0005F9r 2               
0005F9r 2               
0005F9r 2               fat_convert_filename:
0005F9r 2               	; file name address to transform is in FAT_PTR2
0005F9r 2               	; file name length is in FAT_PTR1
0005F9r 2  5A           	phy
0005FAr 2  DA           	phx
0005FBr 2  A0 00        	ldy #0                  ; Y will be used to index original string
0005FDr 2  A2 00        	ldx #0                  ; and X to index transformed string
0005FFr 2               @transform_name_loop:           ; transform file.txt filename format to FAT16 format
0005FFr 2  C4 rr        	cpy FAT_PTR1 				; if Y is bigger than the length of the file name
000601r 2  B0 04        	bcs @load20					; load $20 instead
000603r 2  B1 rr        	lda (FAT_PTR2), y			; otherwise, load next character
000605r 2  80 02        	bra @compare				; and go to compare it
000607r 2               @load20:
000607r 2  A9 20        	lda #$20					; load $20 instead
000609r 2               @compare:
000609r 2  C9 2E        	cmp #'.'					; if it's a dot
00060Br 2  F0 11        	beq @is_dot					; handle the dot
00060Dr 2  C9 41        	cmp #'A'					; if it is a lowercase character
00060Fr 2  90 02        	bcc @save_char				; convert to uppercase
000611r 2  29 DF        	and #$DF
000613r 2               
000613r 2               @save_char:
000613r 2  9D rr rr     	sta FAT_FILE_NAME_TMP, x        ; no dot yet, copy character
000616r 2  E8           	inx
000617r 2               @avoid_dot:
000617r 2  C8           	iny
000618r 2  E0 0B        	cpx #11
00061Ar 2  90 E3        	bcc @transform_name_loop        ; Do next character
00061Cr 2  80 15        	bra @end_trans                  ; We have reached the 11th character for the new string
00061Er 2               
00061Er 2               @is_dot:                            ; we have a dot in the original string
00061Er 2  E0 02        	cpx #2							; do not replace first 2 dots
000620r 2  90 F1        	bcc @save_char
000622r 2  E0 07        	cpx #7						; if the dot is in 8th place, remove it completely
000624r 2  B0 F1        	bcs @avoid_dot
000626r 2               @add_space:
000626r 2  A9 20        	lda #$20                        ; fill the new string until 8 characters have been done
000628r 2               @dont_replace:
000628r 2  9D rr rr     	sta FAT_FILE_NAME_TMP, x
00062Br 2  E8           	inx
00062Cr 2  E0 08        	cpx #8
00062Er 2  90 F6        	bcc @add_space                     ; if we have not reached 8 chars yet, keep adding spaces
000630r 2  C8           	iny
000631r 2  80 CC        	bra @transform_name_loop        ; once we reached 8 characters, go back to do extension
000633r 2               
000633r 2               @end_trans:							; exit with transformed file name in FAT_FILE_NAME_TMP
000633r 2  FA           	plx
000634r 2  7A           	ply
000635r 2  60           	rts
000636r 2               
000636r 2               
000636r 2               fat_find_file:
000636r 2               	; file name to search should be in FAT_FILE_NAME_TMP
000636r 2  5A           	phy
000637r 2               
000637r 2  AD rr rr 8D  	cp16 FAT_CURRENT_DIR_SEC, FAT_LBA
00063Br 2  rr rr AD rr  
00063Fr 2  rr 8D rr rr  
000643r 2  AD rr rr 8D  	cp16 FAT_CURRENT_DIR_SEC + 2, FAT_LBA + 2
000647r 2  rr rr AD rr  
00064Br 2  rr 8D rr rr  
00064Fr 2  20 rr rr     	jsr io_read_sector
000652r 2               
000652r 2  A9 rr        	lda #<DISK_BUFFER
000654r 2  85 rr        	sta FAT_PTR1
000656r 2  A9 rr        	lda #>DISK_BUFFER
000658r 2  85 rr        	sta FAT_PTR1 + 1
00065Ar 2               
00065Ar 2               
00065Ar 2               @outerloop:
00065Ar 2  A0 00        	ldy #0
00065Cr 2  B1 rr        	lda (FAT_PTR1), y                ; load first caracter of file name
00065Er 2  F0 26        	beq @exit                       ; if zero, it means we reached the end of the list
000660r 2  C9 E5        	cmp #$E5
000662r 2  F0 0E        	beq @next_entry                 ; if $E5, it means the entry is deleted, so go to next entry
000664r 2               @loop:
000664r 2  B1 rr        	lda (FAT_PTR1), y                ; load current filename character
000666r 2  D9 rr rr     	cmp FAT_FILE_NAME_TMP, y        ; compare it we the searched filename
000669r 2  D0 07        	bne @next_entry                 ; as soon as they are not the same, go to the next entry
00066Br 2  C8           	iny                             ; increase pointer to character
00066Cr 2  C0 0B        	cpy #11                         ; compare with the total filename length
00066Er 2  90 F4        	bcc @loop                       ; if y is less than the filename string length, keep going
000670r 2  80 11        	bra @exit_found                 ; otherwise, it means we compared all characters of the file name and they all match
000672r 2               @next_entry:
000672r 2  18 A5 rr 6D  	add16 FAT_PTR1, fat_entry_size, FAT_PTR1  ; add 32 to the current entry pointer
000676r 2  rr rr 85 rr  
00067Ar 2  A5 rr 6D rr  
000681r 2  80 D7        	bra @outerloop                          ; process next entry
000683r 2               @exit_found:
000683r 2  38           	sec
000684r 2  80 01        	bra @exit_end
000686r 2               @exit:
000686r 2  18           	clc
000687r 2               @exit_end:
000687r 2               
000687r 2  7A           	ply
000688r 2               
000688r 2  60           	rts
000689r 2               
000689r 2               fat_get_sector_for_cluster:
000689r 2  9C rr rr     	stz FAT_CURRENT_DIR_SEC
00068Cr 2  9C rr rr     	stz FAT_CURRENT_DIR_SEC + 1
00068Fr 2  9C rr rr     	stz FAT_CURRENT_DIR_SEC + 2
000692r 2  9C rr rr     	stz FAT_CURRENT_DIR_SEC + 3
000695r 2               	; cluster number is in CF_CURRENT_CLUSTER
000695r 2               	; Given any valid data cluster number N, the sector number of the first sector of that cluster (again relative to sector 0 of the FAT volume) is computed as follows:
000695r 2               	; FirstSectorofCluster = ((N – 2) * BPB_SecPerClus) + FirstDataSector;
000695r 2               	; (CF_CURRENT_CLUSTER - 2) * CF_SEC_PER_CLUS + CF_FIRST_DATA_SEC
000695r 2  AD rr rr 8D  	cp16 FAT_CURRENT_CLUSTER, FAT_CURRENT_DIR_SEC
000699r 2  rr rr AD rr  
00069Dr 2  rr 8D rr rr  
0006A1r 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC
0006A4r 2  D0 1C        	bne @notzero
0006A6r 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 1
0006A9r 2  D0 17        	bne @notzero
0006ABr 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 2
0006AEr 2  D0 12        	bne @notzero
0006B0r 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 3
0006B3r 2  D0 0D        	bne @notzero
0006B5r 2               
0006B5r 2               	; current cluster is zero, which means the root directory
0006B5r 2  AD rr rr 8D  	cp16 FAT_FIRST_ROOT_SEC, FAT_CURRENT_DIR_SEC
0006B9r 2  rr rr AD rr  
0006BDr 2  rr 8D rr rr  
0006C1r 2  60           	rts
0006C2r 2               @notzero:
0006C2r 2  AD rr rr D0  	dec16 FAT_CURRENT_DIR_SEC
0006C6r 2  03 CE rr rr  
0006CAr 2  CE rr rr     
0006CDr 2  AD rr rr D0  	dec16 FAT_CURRENT_DIR_SEC
0006D1r 2  03 CE rr rr  
0006D5r 2  CE rr rr     
0006D8r 2  AD rr rr     	lda FAT_SEC_PER_CLUS			; load sectors per cluster
0006DBr 2               @shiftleft:
0006DBr 2  4A           	lsr							; rotate right
0006DCr 2  F0 0E        	beq @shifted				; if we haven't shifted far enough, do it again
0006DEr 2               
0006DEr 2  0E rr rr     	asl FAT_CURRENT_DIR_SEC
0006E1r 2  2E rr rr         rol FAT_CURRENT_DIR_SEC + 1
0006E4r 2  2E rr rr     	rol FAT_CURRENT_DIR_SEC + 2
0006E7r 2  2E rr rr     	rol FAT_CURRENT_DIR_SEC + 3
0006EAr 2  80 EF        	bra @shiftleft
0006ECr 2               @shifted:
0006ECr 2  18           	clc
0006EDr 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC		; finally, add first data sector
0006F0r 2  6D rr rr     	adc FAT_FIRST_DATA_SEC
0006F3r 2  8D rr rr     	sta FAT_CURRENT_DIR_SEC
0006F6r 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 1
0006F9r 2  6D rr rr     	adc FAT_FIRST_DATA_SEC + 1
0006FCr 2  8D rr rr     	sta FAT_CURRENT_DIR_SEC + 1
0006FFr 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 2
000702r 2  69 00        	adc #0
000704r 2  8D rr rr     	sta FAT_CURRENT_DIR_SEC + 2
000707r 2  AD rr rr     	lda FAT_CURRENT_DIR_SEC + 3
00070Ar 2  69 00        	adc #0
00070Cr 2  8D rr rr     	sta FAT_CURRENT_DIR_SEC + 3
00070Fr 2               
00070Fr 2               @end:
00070Fr 2  60           	rts
000710r 2               
000710r 2               reduce_filesize_by_one_sector:
000710r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
000713r 2  D0 0B            bne @skip1
000715r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 2
000718r 2  D0 03            bne @skip2
00071Ar 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 3
00071Dr 2               @skip2:
00071Dr 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 2
000720r 2               @skip1:
000720r 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 1
000723r 2               
000723r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
000726r 2  D0 0B            bne @skip3
000728r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 2
00072Br 2  D0 03            bne @skip4
00072Dr 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 3
000730r 2               @skip4:
000730r 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 2
000733r 2               @skip3:
000733r 2  CE rr rr         dec FAT_CURRENT_FILE_SIZE + 1
000736r 2               
000736r 2  60           	rts
000737r 2               
000737r 2               output_sector:
000737r 2  DA           	phx
000738r 2  A2 00        	ldx #0
00073Ar 2               @loop:
00073Ar 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 3
00073Dr 2  D0 0F        	bne @not_end
00073Fr 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 2
000742r 2  D0 0A        	bne @not_end
000744r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
000747r 2  D0 05        	bne @not_end
000749r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE
00074Cr 2  D0 00        	bne @not_end
00074Er 2               @not_end:
00074Er 2  BD rr rr     	lda DISK_BUFFER, x
000751r 2  20 rr rr     	jsr kernel_putc
000754r 2               
000754r 2  CE rr rr     	dec FAT_CURRENT_FILE_SIZE
000757r 2  D0 08        	bne @n
000759r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
00075Cr 2  F0 32        	beq @end
00075Er 2  CE rr rr     	dec FAT_CURRENT_FILE_SIZE + 1
000761r 2               @n:
000761r 2  E8           	inx
000762r 2  D0 D6        	bne @loop
000764r 2  A2 00        	ldx #0
000766r 2               @loop2:
000766r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 3
000769r 2  D0 0F        	bne @not_end2
00076Br 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 2
00076Er 2  D0 0A        	bne @not_end2
000770r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
000773r 2  D0 05        	bne @not_end2
000775r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE
000778r 2  D0 00        	bne @not_end2
00077Ar 2               @not_end2:
00077Ar 2  BD rr rr     	lda DISK_BUFFER+256, x
00077Dr 2  20 rr rr     	jsr kernel_putc
000780r 2               
000780r 2  CE rr rr     	dec FAT_CURRENT_FILE_SIZE
000783r 2  D0 08        	bne @n2
000785r 2  AD rr rr     	lda FAT_CURRENT_FILE_SIZE + 1
000788r 2  F0 06        	beq @end
00078Ar 2  CE rr rr     	dec FAT_CURRENT_FILE_SIZE + 1
00078Dr 2               @n2:
00078Dr 2  E8           	inx
00078Er 2  D0 D6        	bne @loop2
000790r 2               @end:
000790r 2  FA           	plx
000791r 2  60           	rts
000792r 2               
000792r 1               .elseif .def(CF_ADDRESS)
000792r 1               .include "../../fat16.s"
000792r 1               .endif
000792r 1               
000792r 1               .include "drivers/utils.s"
000792r 2               ;  print a 16-bit integer
000792r 2               ; lsb in x, msb in a
000792r 2               print16:
000792r 2  8D rr rr         sta acc+1
000795r 2  8E rr rr         stx acc
000798r 2               
000798r 2  A2 04            ldx #4
00079Ar 2               nextdig:
00079Ar 2  20 rr rr         jsr div
00079Dr 2  AD rr rr         lda ext
0007A0r 2  9D rr rr         sta num,x
0007A3r 2  CA               dex
0007A4r 2  10 F4            bpl nextdig
0007A6r 2               
0007A6r 2               firstdig:
0007A6r 2  E8               inx
0007A7r 2  E0 05            cpx #5
0007A9r 2  F0 17            beq print0
0007ABr 2  BD rr rr         lda num,x
0007AEr 2  F0 F6            beq firstdig
0007B0r 2               
0007B0r 2               ptnxtdig:
0007B0r 2  18               clc
0007B1r 2  69 30            adc #'0'
0007B3r 2  20 rr rr         jsr kernel_putc
0007B6r 2  E8               inx
0007B7r 2  E0 05            cpx #5
0007B9r 2  F0 06            beq pt16done
0007BBr 2  BD rr rr         lda num,x
0007BEr 2  4C rr rr         jmp ptnxtdig
0007C1r 2               
0007C1r 2               pt16done:
0007C1r 2  60               rts
0007C2r 2               
0007C2r 2               print0:
0007C2r 2  A9 30            lda #'0'
0007C4r 2  20 rr rr         jsr kernel_putc
0007C7r 2  60               rts
0007C8r 2               
0007C8r 2  00 00 00 00  num: .byte 0,0,0,0,0
0007CCr 2  00           
0007CDr 2               
0007CDr 2               ; 16/16-bit division, from the fridge
0007CDr 2               ; acc/aux -> acc, remainder in ext
0007CDr 2               div:
0007CDr 2  A9 00            lda #0
0007CFr 2  8D rr rr         sta ext+1
0007D2r 2  A0 10            ldy #$10
0007D4r 2               dloop:
0007D4r 2  0E rr rr         asl acc
0007D7r 2  2E rr rr         rol acc+1
0007DAr 2  2A               rol
0007DBr 2  2E rr rr         rol ext+1
0007DEr 2  48               pha
0007DFr 2  CD rr rr         cmp aux
0007E2r 2  AD rr rr         lda ext+1
0007E5r 2  ED rr rr         sbc aux+1
0007E8r 2  90 0B            bcc div2
0007EAr 2  8D rr rr         sta ext+1
0007EDr 2  68               pla
0007EEr 2  ED rr rr         sbc aux
0007F1r 2  48               pha
0007F2r 2  EE rr rr         inc acc
0007F5r 2               div2:
0007F5r 2  68               pla
0007F6r 2  88               dey
0007F7r 2  D0 DB            bne dloop
0007F9r 2  8D rr rr         sta ext
0007FCr 2  60               rts
0007FDr 2               
0007FDr 2  00 00        acc: .word 0
0007FFr 2  0A 00        aux: .word 10 ; constant
000801r 2  00 00        ext: .word 0
000803r 2               
000803r 2               
000803r 2               
000803r 2               calculate_free_mem:
000803r 2                   ; load dictionary address
000803r 2                   ; fill with $55 until ram_end
000803r 2                   ; read and check same
000803r 2                   ; fill again with zeroes
000803r 2               
000803r 2  AD rr rr         lda up
000806r 2  85 rr            sta stack_p
000808r 2  AD rr rr         lda up + 1
00080Br 2  85 rr            sta stack_p + 1
00080Dr 2               
00080Dr 2  64 rr            stz tmp_var
00080Fr 2  64 rr            stz tmp_var + 1
000811r 2               
000811r 2  A0 00            ldy #0
000813r 2               @loop:
000813r 2  A9 55            lda #$55
000815r 2  91 rr            sta (stack_p), y        ; store to mem address
000817r 2  D1 rr            cmp (stack_p), y        ; compare to what is now there
000819r 2  D0 17            bne @exit               ; no equal, stop couting and exit
00081Br 2  A9 00            lda #0                  ; zero the memory again
00081Dr 2  91 rr            sta (stack_p), y
00081Fr 2  E6 rr            inc tmp_var
000821r 2  D0 02            bne @incok
000823r 2  E6 rr            inc tmp_var + 1
000825r 2               @incok:
000825r 2  C8               iny
000826r 2  D0 EB            bne @loop
000828r 2  A5 rr            lda stack_p + 1
00082Ar 2  C9 80            cmp #>ram_end
00082Cr 2  B0 04            bcs @exit
00082Er 2  E6 rr            inc stack_p + 1
000830r 2  80 E1            bra @loop
000832r 2               @exit:
000832r 2  60               rts
000833r 2               
000833r 2               
000833r 1               
000833r 1               ; .include "drivers/spi.s"
000833r 1               ; .include "drivers/sd.s"
000833r 1               ; .include "drivers/vga.s"
000833r 1               ; .include "drivers/fat32.s"
000833r 1               ; .include "drivers/lcd.s"
000833r 1               
000833r 1               
000833r 1               .include "../../forth.s"
000833r 2               
000833r 2               
000833r 2               ; Definitions for Tali Forth 2
000833r 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000833r 2               ; First version: 01. Apr 2016 (Liara Forth)
000833r 2               ; This version: 29. Jan 2020
000833r 2               
000833r 2               ; This file is included by taliforth.asm. These are the general
000833r 2               ; definitions; platform-specific definitions such as the
000833r 2               ; memory map are kept in the platform folder.
000833r 2               
000833r 2               stack0 =    $0100   ; location of the stack
000833r 2               
000833r 2               ; User Variables:
000833r 2               ; Block variables
000833r 2               blk_offset =  0        ; BLK : UP + 0
000833r 2               scr_offset =  2        ; SCR : UP + 2
000833r 2               
000833r 2               ; Wordlists
000833r 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000833r 2               num_wordlists_offset =  5
000833r 2                                          ; #WORDLISTS (byte) : UP + 5
000833r 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000833r 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000833r 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000833r 2                                          ;          (Number of wordlists in search order)
000833r 2               search_order_offset =  31
000833r 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000833r 2                                          ; Allowing for 9 to keep offsets even.
000833r 2               max_wordlists =  12    ; Maximum number of wordlists supported
000833r 2                                          ; 4 Tali built-ins + 8 user wordlists
000833r 2               
000833r 2               ; Buffer variables
000833r 2               blkbuffer_offset =     40   ; Address of buffer
000833r 2               buffblocknum_offset =  42   ; Block number current in buffer
000833r 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000833r 2               
000833r 2               ; Block I/O vectors
000833r 2               blockread_offset =     46   ; Vector to block reading routine
000833r 2               blockwrite_offset =    48   ; Vector to block writing routine
000833r 2               
000833r 2               
000833r 2               ; ASCII CHARACTERS
000833r 2               AscCC =   $03  ; break (CTRL-c)
000833r 2               AscBELL = $07  ; bell sound
000833r 2               AscBS =   $08  ; backspace
000833r 2               AscLF =   $0a  ; line feed
000833r 2               AscCR =   $0d  ; carriage return
000833r 2               AscESC =  $1b  ; escape
000833r 2               AscSP =   $20  ; space
000833r 2               AscDEL =  $7f  ; delete (CTRL-h)
000833r 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000833r 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000833r 2               
000833r 2               ; DICTIONARY FLAGS
000833r 2               ; The first three bits are currently unused
000833r 2               CO = 1  ; Compile Only
000833r 2               AN = 2  ; Always Native Compile
000833r 2               IM = 4  ; Immediate Word
000833r 2               NN = 8  ; Never Native Compile
000833r 2               UF = 16 ; Includes Underflow Check (RESERVED)
000833r 2               HC = 32 ; Word has Code Field Area (CFA)
000833r 2               
000833r 2               
000833r 2               ; VARIOUS
000833r 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000833r 2               
000833r 2               ; END
000833r 2               
000833r 2               .segment "ZEROPAGE": zeropage
000012r 2               ; ZERO PAGE ADDRESSES/VARIABLES
000012r 2               
000012r 2               ; These are kept at the top of Zero Page, with the most important variables at
000012r 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
000012r 2               ; an overflow, the lower, less important variables will be clobbered first,
000012r 2               ; giving the system a chance to recover. In other words, they are part of the
000012r 2               ; floodplain.
000012r 2               
000012r 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000012r 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000012r 2               
000012r 2  xx xx        cp: .res 2   ; Compiler Pointer
000014r 2  xx xx        dp: .res 2   ; Dictionary Pointer
000016r 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
000018r 2                                          ; a :NONAME declared word (see status)
000018r 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
00001Ar 2  xx xx        cib: .res 2   ; address of current input buffer
00001Cr 2  xx xx        ciblen: .res 2  ; length of current input buffer
00001Er 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
000020r 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
000022r 2  xx xx        output: .res 2  ; vector for EMIT
000024r 2  xx xx        input: .res 2  ; vector for KEY
000026r 2  xx xx        havekey: .res 2  ; vector for KEY?
000028r 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
00002Ar 2  xx xx        base: .res 2  ; number radix, default decimal
00002Cr 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
00002Er 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
000030r 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
000032r 2  xx xx        status: .res 2  ; internal status information
000034r 2                                          ; (used by : :NONAME ; ACCEPT)
000034r 2                                          ; Bit 7 = Redefined word message postpone
000034r 2                                          ;         When set before calling CREATE, it will
000034r 2                                          ;         not print the "redefined xxxx" message if
000034r 2                                          ;         the word exists. Instead, this bit will
000034r 2                                          ;         be reused and after CREATE has run, it will
000034r 2                                          ;         be set if the word was redefined and 0 if
000034r 2                                          ;         not. This bit should be 0 when not in use.
000034r 2                                          ; Bit 6 = 1 for normal ":" definitions
000034r 2                                          ;         WORKWORD contains nt of word being compiled
000034r 2                                          ;       = 0 for :NONAME definitions
000034r 2                                          ;         WORKWORD contains xt of word being compiled
000034r 2                                          ; Bit 5 = 1 for NUMBER returning a double word
000034r 2                                          ;       = 0 for NUMBER returning a single word
000034r 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
000034r 2                                          ;       = 0 CTRL-n recalls previous history
000034r 2                                          ; Bit 2 = Current history buffer msb
000034r 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
000034r 2                                          ; Bit 0 = Current history buffer lsb
000034r 2                                          ; status+1 is used by ACCEPT to hold history lengths.
000034r 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
000036r 2  xx xx        tmp1: .res 2  ; temporary storage
000038r 2  xx xx        tmp2: .res 2  ; temporary storage
00003Ar 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
00003Cr 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
00003Er 2  xx xx        tmptos: .res 2  ; temporary TOS storage
000040r 2  xx xx        editor1: .res 2  ; temporary for editors
000042r 2  xx xx        editor2: .res 2  ; temporary for editors
000044r 2  xx xx        editor3: .res 2  ; temporary for editors
000046r 2  xx xx        tohold: .res 2  ; pointer for formatted output
000048r 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
00004Cr 2  xx xx xx xx  
000050r 2               
000050r 2               .segment "DATASTACK": zeropage
000000r 2  xx xx xx xx  dsp_start: .res 127 ; reserve 128 bytes for data stack (64 16 bit cells)
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
00007Fr 2               dsp0:          ; first data stack location. Data stack grows down
00007Fr 2               rsp0:     ; starting stack pointer
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               .segment "BSS"
00044Br 2  xx xx xx xx  hist_buff: .res $400
00044Fr 2  xx xx xx xx  
000453r 2  xx xx xx xx  
00084Br 2  xx xx xx xx  buffer0: .res $100
00084Fr 2  xx xx xx xx  
000853r 2  xx xx xx xx  
00094Br 2               
00094Br 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
000833r 2               
000833r 2               
000833r 2               
000833r 2               forth:
000833r 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
000833r 3               ; Low-level Forth word routines
000833r 3               ; Tali Forth 2 for the 65c02
000833r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000833r 3               ; First version: 19. Jan 2014
000833r 3               ; This version: 03. Jan 2018
000833r 3               
000833r 3               ; This list is ordered alphabetically by the names of the words, not their
000833r 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000833r 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000833r 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000833r 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000833r 3               
000833r 3               ;       TBA --> fragment --> coded --> tested --> auto
000833r 3               
000833r 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000833r 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000833r 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000833r 3               
000833r 3               ; ## COLD ( -- ) "Reset the Forth system"
000833r 3               ; ## "cold"  tested  Tali Forth
000833r 3               ;       """Reset the Forth system. Does not restart the kernel,
000833r 3               ;       use the 65c02 reset for that. Flows into ABORT.
000833r 3               ;       """
000833r 3               xt_cold:
000833r 3  D8                           cld
000834r 3               
000834r 3                               ; Set the OUTPUT vector to the default kernel_putc
000834r 3                               ; We do this really early so we can print error messages
000834r 3                               ; during debugging
000834r 3  A9 rr                        lda #<kernel_putc
000836r 3  85 rr                        sta output
000838r 3  A9 rr                        lda #>kernel_putc
00083Ar 3  85 rr                        sta output+1
00083Cr 3               
00083Cr 3                               ; Load all of the important zero page variables from ROM
00083Cr 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
00083Er 3               
00083Er 3               @load_zp_loop:
00083Er 3                               ; This loop loads them back to front. We can use X here
00083Er 3                               ; because Tali hasn't started using the stack yet.
00083Er 3  BD rr rr                     lda cold_zp_table,x
000841r 3  95 rr                        sta cp,x
000843r 3  CA                           dex
000844r 3  D0 F8                        bne @load_zp_loop
000846r 3               
000846r 3                               ; Copy the 0th element.
000846r 3  AD rr rr                     lda cold_zp_table
000849r 3  85 rr                        sta cp
00084Br 3                               ; Initialize 65c02 stack (Return Stack)
00084Br 3  A2 rr                        ldx #rsp0
00084Dr 3  9A                           txs
00084Er 3               
00084Er 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
00084Er 3                               ; can load high-level words with EVALUATE
00084Er 3  A2 rr                        ldx #dsp0
000850r 3               
000850r 3               
000850r 3                               ; Initialize the user variables.
000850r 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
000852r 3  A9 00                        lda #0
000854r 3               
000854r 3               @load_user_vars_loop:
000854r 3                               ; Like the zero page variables, these are initialized
000854r 3                               ; back to front.
000854r 3  B9 rr rr                     lda cold_user_table,y
000857r 3  91 rr                        sta (up),y
000859r 3  88                           dey
00085Ar 3  D0 F8                        bne @load_user_vars_loop
00085Cr 3               
00085Cr 3                               ; Copy the 0th element.
00085Cr 3  AD rr rr                     lda cold_user_table
00085Fr 3  92 rr                        sta (up)
000861r 3  20 rr rr                     jsr xt_cr
000864r 3               
000864r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
000864r 3                               ; you do not have any high-level words, this part can be
000864r 3                               ; commented out.
000864r 3  CA                           dex
000865r 3  CA                           dex
000866r 3  CA                           dex
000867r 3  CA                           dex
000868r 3               
000868r 3               
000868r 3                               ; start address goes NOS
000868r 3  A9 rr                        lda #<forth_words_start
00086Ar 3  95 02                        sta 2,x
00086Cr 3  A9 rr                        lda #>forth_words_start
00086Er 3  95 03                        sta 3,x
000870r 3               
000870r 3                               ; length goes TOS
000870r 3  A9 rr                        lda #<forth_words_end
000872r 3  38                           sec
000873r 3  E9 rr                        sbc #<forth_words_start
000875r 3  95 00                        sta 0,x
000877r 3               
000877r 3  A9 rr                        lda #>forth_words_end
000879r 3  E9 rr                        sbc #>forth_words_start
00087Br 3  95 01                        sta 1,x
00087Dr 3               
00087Dr 3               
00087Dr 3  20 rr rr                     jsr xt_evaluate
000880r 3               
000880r 3                               ; Now define any user words via EVALUATE. If you do not have
000880r 3                               ; any user-defined words, this part can be commented out as
000880r 3                               ; well.
000880r 3  CA                           dex
000881r 3  CA                           dex
000882r 3  CA                           dex
000883r 3  CA                           dex
000884r 3               
000884r 3               
000884r 3                               ; start address goes NOS
000884r 3  A9 rr                        lda #<user_words_start
000886r 3  95 02                        sta 2,x
000888r 3  A9 rr                        lda #>user_words_start
00088Ar 3  95 03                        sta 3,x
00088Cr 3               
00088Cr 3                               ; length goes TOS
00088Cr 3  A9 rr                        lda #<user_words_end
00088Er 3  38                           sec
00088Fr 3  E9 rr                        sbc #<user_words_start
000891r 3  95 00                        sta 0,x
000893r 3               
000893r 3  A9 rr                        lda #>user_words_end
000895r 3  E9 rr                        sbc #>user_words_start
000897r 3  95 01                        sta 1,x
000899r 3               
000899r 3  20 rr rr                     jsr xt_evaluate
00089Cr 3               
00089Cr 3                               ; Initialize all of the history buffers by putting a zero in
00089Cr 3                               ; each length byte.
00089Cr 3  9C rr rr                     stz hist_buff
00089Fr 3  9C rr rr                     stz hist_buff+$80
0008A2r 3  9C rr rr                     stz hist_buff+$100
0008A5r 3  9C rr rr                     stz hist_buff+$180
0008A8r 3  9C rr rr                     stz hist_buff+$200
0008ABr 3  9C rr rr                     stz hist_buff+$280
0008AEr 3  9C rr rr                     stz hist_buff+$300
0008B1r 3  9C rr rr                     stz hist_buff+$380
0008B4r 3               
0008B4r 3               
0008B4r 3                               ; fall through to ABORT
0008B4r 3               
0008B4r 3               
0008B4r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
0008B4r 3               ; ## "abort"  tested  ANS core
0008B4r 3                       ; """https://forth-standard.org/standard/core/ABORT
0008B4r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
0008B4r 3                       ; subroutine if we want to because we are going to reset the 65c02's
0008B4r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
0008B4r 3                       ; actually delete the stuff on the Data Stack.
0008B4r 3                       ; """
0008B4r 3               xt_abort:
0008B4r 3  A2 rr                        ldx #dsp0
0008B6r 3               
0008B6r 3                               ; fall through to QUIT
0008B6r 3               
0008B6r 3               
0008B6r 3               ; ## QUIT ( -- ) "Reset the input and get new input"
0008B6r 3               ; ## "quit"  tested  ANS core
0008B6r 3                       ; """https://forth-standard.org/standard/core/QUIT
0008B6r 3                       ; Rest the input and start command loop
0008B6r 3                       ; """
0008B6r 3               
0008B6r 3               xt_quit:
0008B6r 3                               ; Clear the Return Stack. This is a little screwed up
0008B6r 3                               ; because the 65c02 can only set the Return Stack via X,
0008B6r 3                               ; which is our Data Stack pointer. The ANS specification
0008B6r 3                               ; demands, however, that ABORT reset the Data Stack pointer
0008B6r 3  8A                           txa             ; Save the DSP that we just defined
0008B7r 3  A2 rr                        ldx #rsp0
0008B9r 3  9A                           txs
0008BAr 3  AA                           tax             ; Restore the DSP. Dude, seriously.
0008BBr 3               
0008BBr 3                               ; make sure instruction pointer is empty
0008BBr 3  64 rr                        stz ip
0008BDr 3  64 rr                        stz ip+1
0008BFr 3               
0008BFr 3                               ; SOURCE-ID is zero (keyboard input)
0008BFr 3  64 rr                        stz insrc
0008C1r 3  64 rr                        stz insrc+1
0008C3r 3               
0008C3r 3                               ; STATE is zero (interpret, not compile)
0008C3r 3  64 rr                        stz state
0008C5r 3  64 rr                        stz state+1
0008C7r 3               @get_line:
0008C7r 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
0008C9r 3  85 rr                        sta cib
0008CBr 3  A9 rr                        lda #>buffer0
0008CDr 3  85 rr                        sta cib+1
0008CFr 3               
0008CFr 3                               ; Size of current input buffer (CIB) is zero
0008CFr 3  64 rr                        stz ciblen
0008D1r 3  64 rr                        stz ciblen+1
0008D3r 3               
0008D3r 3                               ; Accept a line from the current import source. This is how
0008D3r 3                               ; modern Forths to it.
0008D3r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
0008D6r 3               
0008D6r 3                               ; Test flag: LSB of TOS
0008D6r 3  B5 00                        lda 0,x
0008D8r 3  D0 05                        bne @success
0008DAr 3               
0008DAr 3                               ; If REFILL returned a FALSE flag, something went wrong and we
0008DAr 3                               ; need to print an error message and reset the machine. We
0008DAr 3                               ; don't need to save TOS because we're going to clobber it
0008DAr 3                               ; anyway when we go back to ABORT.
0008DAr 3  A9 06                        lda #err_refill
0008DCr 3  4C rr rr                     jmp error
0008DFr 3               
0008DFr 3               @success:
0008DFr 3                               ; Assume we have successfully accepted a string of input from
0008DFr 3                               ; a source, with address cib and length of input in ciblen. We
0008DFr 3                               ; arrive here still with the TRUE flag from REFILL as TOS
0008DFr 3  E8                           inx                     ; drop
0008E0r 3  E8                           inx
0008E1r 3               
0008E1r 3                               ; Main compile/execute routine
0008E1r 3  20 rr rr                     jsr interpret
0008E4r 3               
0008E4r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
0008E4r 3                               ; overflow because it is so rare
0008E4r 3  E0 rr                        cpx #dsp0
0008E6r 3  F0 05                        beq @stack_ok
0008E8r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
0008EAr 3               
0008EAr 3  4C rr rr                     jmp underflow_error
0008EDr 3               
0008EDr 3               @stack_ok:
0008EDr 3                               ; Display system prompt if all went well. If we're interpreting,
0008EDr 3                               ; this is " ok", if we're compiling, it's " compiled". Note
0008EDr 3                               ; space at beginning of the string.
0008EDr 3  A5 rr                        lda state
0008EFr 3  F0 02                        beq @print
0008F1r 3               
0008F1r 3  A9 01                        lda #1                  ; number for "compile" string
0008F3r 3               @print:
0008F3r 3  20 rr rr                     jsr print_string
0008F6r 3               
0008F6r 3                               ; Awesome line, everybody! Now get the next one.
0008F6r 3  80 CF                        bra @get_line
0008F8r 3               
0008F8r 3               z_cold:
0008F8r 3               z_abort:
0008F8r 3               z_quit:         ; no RTS required
0008F8r 3               
0008F8r 3               
0008F8r 3               
0008F8r 3               ; This table holds all of the initial values for the variables in zero page.
0008F8r 3               ; This table is used by COLD.
0008F8r 3               cold_zp_table:
0008F8r 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
0008FAr 3                                               ; block buffer
0008FAr 3  rr rr                .word dictionary_start  ; dp
0008FCr 3  00 00                .word 0                 ; workword
0008FEr 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000900r 3  rr rr                .word buffer0           ; cib
000902r 3  00 00                .word 0                 ; ciblen
000904r 3  00 00                .word 0                 ; toin
000906r 3  00 00                .word 0                 ; ip
000908r 3  rr rr                .word kernel_putc       ; output
00090Ar 3  rr rr                .word kernel_getc       ; input
00090Cr 3  00 00                .word 0                 ; havekey
00090Er 3  00 00                .word 0                 ; state (0 = interpret)
000910r 3  0A 00                .word 10                ; base
000912r 3  14 00                .word 20                ; nc-limit
000914r 3  00 00                .word 0                 ; uf_strip (off by default)
000916r 3  rr rr                .word cp0               ; up (user vars put right at beginning of
000918r 3                                               ; available RAM)
000918r 3  00 00                .word 0                 ; status
00091Ar 3               cold_zp_table_end:
00091Ar 3               
00091Ar 3               ; No further ZP variables are initialized. The variables past this point are
00091Ar 3               ; all temporaries.
00091Ar 3               
00091Ar 3               ; This table holds the inital values for the user variables. This table is
00091Ar 3               ; used by COLD.
00091Ar 3               cold_user_table:
00091Ar 3  00 00                .word 0                         ; BLK
00091Cr 3  00 00                .word 0                         ; SCR
00091Er 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
00091Fr 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000920r 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
000922r 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
000924r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
000926r 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
000928r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
00092Cr 3  00 00 00 00  
000930r 3  00 00 00 00  
000938r 3  01                   .byte 1                         ; #ORDER
000939r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
00093Dr 3  00 00 00 00  
000941r 3  00           
000942r 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
000944r 3  00 00                .word 0                         ; block in buffer
000946r 3  00 00                .word 0                         ; buffer status (not in use)
000948r 3  rr rr                .word xt_block_word_error       ; block-read vector
00094Ar 3  rr rr                .word xt_block_word_error       ; block-write vector
00094Cr 3               cold_user_table_end:
00094Cr 3               
00094Cr 3               
00094Cr 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
00094Cr 3               ; ## "abort""  tested  ANS core
00094Cr 3                       ; """https://forth-standard.org/standard/core/ABORTq
00094Cr 3                       ; Abort and print a string.
00094Cr 3                       ; """
00094Cr 3               
00094Cr 3               xt_abort_quote:
00094Cr 3                               ; save the string
00094Cr 3  20 rr rr                     jsr xt_s_quote          ; S"
00094Fr 3               
00094Fr 3                               ; compile run-time part
00094Fr 3  A0 rr                        ldy #>abort_quote_runtime
000951r 3  A9 rr                        lda #<abort_quote_runtime
000953r 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000956r 3               
000956r 3  60           z_abort_quote:  rts
000957r 3               
000957r 3               
000957r 3               abort_quote_runtime:
000957r 3                       ; """Runtime aspect of ABORT_QUOTE"""
000957r 3               
000957r 3                               ; We arrive here with ( f addr u )
000957r 3  B5 04                        lda 4,x
000959r 3  15 05                        ora 5,x
00095Br 3  F0 09                        beq @done       ; if FALSE, we're done
00095Dr 3               
00095Dr 3                               ; We're true, so print string and ABORT. We follow Gforth
00095Dr 3                               ; in going to a new line after the string
00095Dr 3  20 rr rr                     jsr xt_type
000960r 3  20 rr rr                     jsr xt_cr
000963r 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000966r 3               @done:
000966r 3                               ; Drop three entries from the Data Stack
000966r 3  8A                           txa
000967r 3  18                           clc
000968r 3  69 06                        adc #6
00096Ar 3  AA                           tax
00096Br 3               
00096Br 3  60                           rts
00096Cr 3               
00096Cr 3               
00096Cr 3               
00096Cr 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
00096Cr 3               ; ## "abs"  auto  ANS core
00096Cr 3                       ; """https://forth-standard.org/standard/core/ABS
00096Cr 3                       ; Return the absolute value of a number.
00096Cr 3                       ; """
00096Cr 3               
00096Cr 3               xt_abs:
00096Cr 3  20 rr rr                     jsr underflow_1
00096Fr 3               
00096Fr 3  B5 01                        lda 1,x
000971r 3  10 0D                        bpl @done       ; positive number, easy money!
000973r 3               
000973r 3                               ; negative: calculate 0 - n
000973r 3  38                           sec
000974r 3  A9 00                        lda #0
000976r 3  F5 00                        sbc 0,x         ; LSB
000978r 3  95 00                        sta 0,x
00097Ar 3               
00097Ar 3  A9 00                        lda #0          ; MSB
00097Cr 3  F5 01                        sbc 1,x
00097Er 3  95 01                        sta 1,x
000980r 3               
000980r 3               @done:
000980r 3  60           z_abs:          rts
000981r 3               
000981r 3               
000981r 3               
000981r 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
000981r 3               ; ## "accept"  auto  ANS core
000981r 3                       ; """https://forth-standard.org/standard/core/ACCEPT
000981r 3                       ; Receive a string of at most n1 characters, placing them at
000981r 3                       ; addr. Return the actual number of characters as n2. Characters
000981r 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
000981r 3                       ; modern Forths.
000981r 3                       ; """
000981r 3               
000981r 3               xt_accept:
000981r 3  20 rr rr                     jsr underflow_2
000984r 3               
000984r 3                               ; Abort if we were asked to receive 0 chars
000984r 3  B5 00                        lda 0,x
000986r 3  15 01                        ora 1,x
000988r 3  D0 09                        bne @not_zero
00098Ar 3               
00098Ar 3  E8                           inx
00098Br 3  E8                           inx
00098Cr 3  74 00                        stz 0,x
00098Er 3  74 01                        stz 1,x
000990r 3               
000990r 3  4C rr rr                     jmp accept_done
000993r 3               
000993r 3               @not_zero:
000993r 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000995r 3  85 rr                        sta tmp2
000997r 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
000999r 3               
000999r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
00099Br 3  85 rr                        sta tmp1
00099Dr 3  B5 03                        lda 3,x
00099Fr 3  85 rr                        sta tmp1+1
0009A1r 3               
0009A1r 3  E8                           inx
0009A2r 3  E8                           inx
0009A3r 3               
0009A3r 3  A0 00                        ldy #0
0009A5r 3               
0009A5r 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
0009A5r 3                               ; from bit 2 to 3 is OK)
0009A5r 3  A5 rr                        lda status
0009A7r 3  29 F7                        and #$f7
0009A9r 3               
0009A9r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
0009A9r 3  1A                           inc
0009AAr 3               
0009AAr 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
0009AAr 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
0009AAr 3                               ; received and won't be used to calculate the history buffer
0009AAr 3                               ; offset.
0009AAr 3  09 08                        ora #$08
0009ACr 3  85 rr                        sta status
0009AEr 3               
0009AEr 3               accept_loop:
0009AEr 3                               ; Out of the box, py65mon catches some CTRL sequences such as
0009AEr 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
0009AEr 3                               ; vt100 terminal clears the screen automatically.
0009AEr 3               
0009AEr 3                               ; This is the internal version of KEY without all the mucking
0009AEr 3                               ; about with the Data Stack while still using the input vector
0009AEr 3  20 rr rr                     jsr key_a
0009B1r 3               
0009B1r 3                               ; We quit on both line feed and carriage return
0009B1r 3  C9 0A                        cmp #AscLF
0009B3r 3  F0 20                        beq @eol
0009B5r 3  C9 0D                        cmp #AscCR
0009B7r 3  F0 1C                        beq @eol
0009B9r 3               
0009B9r 3                               ; BACKSPACE and DEL do the same thing for the moment
0009B9r 3  C9 08                        cmp #AscBS
0009BBr 3  F0 22                        beq @backspace
0009BDr 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
0009BFr 3  F0 1E                        beq @backspace
0009C1r 3               
0009C1r 3                               ; Check for CTRL-p and CTRL-n to recall input history
0009C1r 3  C9 10                        cmp #AscCP
0009C3r 3  F0 36                        beq @ctrl_p
0009C5r 3  C9 0E                        cmp #AscCN
0009C7r 3  F0 44                        beq @ctrl_n
0009C9r 3               
0009C9r 3                               ; That's enough for now. Save and echo character.
0009C9r 3  91 rr                        sta (tmp1),y
0009CBr 3  C8                           iny
0009CCr 3               
0009CCr 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
0009CCr 3  20 rr rr                     jsr emit_a
0009CFr 3               
0009CFr 3  C4 rr                        cpy tmp2        ; reached character limit?
0009D1r 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
0009D3r 3  80 03                        bra @buffer_full
0009D5r 3               
0009D5r 3               @eol:
0009D5r 3  20 rr rr                     jsr xt_space    ; print final space
0009D8r 3               
0009D8r 3               @buffer_full:
0009D8r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
0009D8r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
0009DAr 3  74 01                        stz 1,x         ; we only accept 256 chars
0009DCr 3               
0009DCr 3  4C rr rr                     jmp accept_done
0009DFr 3               
0009DFr 3               @backspace:
0009DFr 3                               ; Handle backspace and delete kex, which currently do the same
0009DFr 3                               ; thing
0009DFr 3  C0 00                        cpy #0          ; buffer empty?
0009E1r 3  D0 06                        bne @1
0009E3r 3               
0009E3r 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
0009E5r 3  20 rr rr                     jsr emit_a
0009E8r 3  C8                           iny
0009E9r 3               @1:
0009E9r 3  88                           dey
0009EAr 3  A9 08                        lda #AscBS      ; move back one
0009ECr 3  20 rr rr                     jsr emit_a
0009EFr 3  A9 20                        lda #AscSP      ; print a space (rubout)
0009F1r 3  20 rr rr                     jsr emit_a
0009F4r 3  A9 08                        lda #AscBS      ; move back over space
0009F6r 3  20 rr rr                     jsr emit_a
0009F9r 3               
0009F9r 3  80 B3                        bra accept_loop
0009FBr 3               
0009FBr 3               @ctrl_p:
0009FBr 3                               ; CTRL-p was pressed. Recall the previous input buffer.
0009FBr 3               
0009FBr 3                               ; Select the previous buffer
0009FBr 3  A5 rr                        lda status
0009FDr 3               
0009FDr 3                               ; Check for 0 (need to wrap back to 7)
0009FDr 3  29 07                        and #7
0009FFr 3  D0 08                        bne @ctrl_p_dec
000A01r 3               
000A01r 3                               ; We need to wrap back to 7.
000A01r 3  A5 rr                        lda status
000A03r 3  09 07                        ora #7
000A05r 3  85 rr                        sta status
000A07r 3  80 11                        bra @recall_history
000A09r 3               
000A09r 3               @ctrl_p_dec:
000A09r 3                               ; It's safe to decrement the buffer index directly.
000A09r 3  C6 rr                        dec status
000A0Br 3  80 0D                        bra @recall_history
000A0Dr 3               
000A0Dr 3               @ctrl_n:
000A0Dr 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000A0Dr 3                               ; the next buffer Check bit 3. If it's set, this is the first
000A0Dr 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000A0Dr 3                               ; history buffer.
000A0Dr 3  A9 08                        lda #$8
000A0Fr 3  24 rr                        bit status
000A11r 3  D0 07                        bne @recall_history
000A13r 3               
000A13r 3                               ; This isn't the first time CTRL-n has been pressed, select the
000A13r 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
000A13r 3  A5 rr                        lda status
000A15r 3  29 F7                        and #$f7
000A17r 3               
000A17r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000A17r 3  1A                           inc
000A18r 3               
000A18r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
000A18r 3                               ; be cleared below.
000A18r 3  85 rr                        sta status
000A1Ar 3               
000A1Ar 3                               ; Falls through to @recall_history
000A1Ar 3               
000A1Ar 3               @recall_history:
000A1Ar 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000A1Ar 3  A9 08                        lda #%00001000
000A1Cr 3  14 rr                        trb status
000A1Er 3               
000A1Er 3  20 rr rr                     jsr total_recall
000A21r 3               
000A21r 3                               ; tmp3 now has the address of the previous history buffer.
000A21r 3                               ; First byte of buffer is length. Clear the line by sending
000A21r 3                               ; CR, Y spaces, then CR.
000A21r 3  A9 0D                        lda #AscCR
000A23r 3  20 rr rr                     jsr emit_a
000A26r 3               
000A26r 3               input_clear:
000A26r 3  C0 00                        cpy #0
000A28r 3  F0 08                        beq input_cleared
000A2Ar 3               
000A2Ar 3  A9 20                        lda #AscSP
000A2Cr 3  20 rr rr                     jsr emit_a
000A2Fr 3  88                           dey
000A30r 3  80 F4                        bra input_clear
000A32r 3               
000A32r 3               input_cleared:
000A32r 3  A9 0D                        lda #AscCR
000A34r 3  20 rr rr                     jsr emit_a
000A37r 3               
000A37r 3                               ; Save the history length byte into histinfo+1
000A37r 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000A37r 3  B1 rr                        lda (tmp3),y
000A39r 3  85 rr                        sta status+1
000A3Br 3               
000A3Br 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000A3Br 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000A3Br 3                               ; buffer)
000A3Br 3  E6 rr                        inc tmp3
000A3Dr 3  D0 02                        bne @2           ; Increment the upper byte on carry.
000A3Fr 3  E6 rr                        inc tmp3+1
000A41r 3               @2:
000A41r 3                               ; Copy the history buffer into the input buffer,
000A41r 3                               ; sending the characters to the output as we go.
000A41r 3  A9 0D                        lda #AscCR
000A43r 3  20 rr rr                     jsr emit_a
000A46r 3               
000A46r 3               @history_loop:
000A46r 3                               ; See if we have reached the end of the history buffer.
000A46r 3  C4 rr                        cpy status+1
000A48r 3  D0 03                        bne @3
000A4Ar 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
000A4Dr 3               @3:
000A4Dr 3                               ; See if we have reached the end of the input buffer.
000A4Dr 3                               ; (only comparing to lower byte as we currently limit
000A4Dr 3                               ; to 255 characters max)
000A4Dr 3  C4 rr                        cpy tmp2
000A4Fr 3  F0 0A                        beq @hist_filled_buffer
000A51r 3               
000A51r 3                               ; Copy a character and echo.
000A51r 3  B1 rr                        lda (tmp3),y
000A53r 3  91 rr                        sta (tmp1),y
000A55r 3  20 rr rr                     jsr emit_a
000A58r 3               
000A58r 3                               ; Move to the next character.
000A58r 3  C8                           iny
000A59r 3  80 EB                        bra @history_loop
000A5Br 3               
000A5Br 3               @hist_filled_buffer:
000A5Br 3                               ; We don't want a history recall to EOL our buffer,
000A5Br 3                               ; so back up one character and return to editing.
000A5Br 3  88                           dey
000A5Cr 3  4C rr rr                     jmp accept_loop
000A5Fr 3               accept_done:
000A5Fr 3               @done:
000A5Fr 3                               ; Copy the input buffer into the currently
000A5Fr 3                               ; selected history buffer.
000A5Fr 3  20 rr rr                     jsr total_recall
000A62r 3  85 rr                        sta status+1
000A64r 3               
000A64r 3                               ; Also save it in the first buffer byte.
000A64r 3  A0 00                        ldy #0
000A66r 3  91 rr                        sta (tmp3),y
000A68r 3               
000A68r 3                               ; Move path the count to the data bytes
000A68r 3  E6 rr                        inc tmp3
000A6Ar 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000A6Cr 3  E6 rr                        inc tmp3+1
000A6Er 3               @4:
000A6Er 3                               ; Copy the characters from the input buffer to the
000A6Er 3                               ; history buffer.
000A6Er 3               
000A6Er 3               @save_history_loop:
000A6Er 3  C4 rr                        cpy status+1
000A70r 3  F0 07                        beq @save_history_done
000A72r 3               
000A72r 3  B1 rr                        lda (tmp1),y
000A74r 3  91 rr                        sta (tmp3),y
000A76r 3  C8                           iny
000A77r 3  80 F5                        bra @save_history_loop
000A79r 3               
000A79r 3               @save_history_done:
000A79r 3               z_accept:
000A79r 3  60                           rts
000A7Ar 3               
000A7Ar 3               total_recall:
000A7Ar 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000A7Ar 3               
000A7Ar 3                               ; Generate the address of the buffer in tmp3. Start with the
000A7Ar 3                               ; base address.
000A7Ar 3  A9 rr                        lda #<hist_buff
000A7Cr 3  85 rr                        sta tmp3
000A7Er 3  A9 rr                        lda #>hist_buff
000A80r 3  85 rr                        sta tmp3+1
000A82r 3               
000A82r 3                               ; This is a bit annoying as some bits go into each byte.
000A82r 3                               ; .....xxx gets put into address like ......xx x.......
000A82r 3  A5 rr                        lda status
000A84r 3  6A                           ror
000A85r 3  29 03                        and #3
000A87r 3  18                           clc
000A88r 3  65 rr                        adc tmp3+1
000A8Ar 3  85 rr                        sta tmp3+1
000A8Cr 3               
000A8Cr 3  A5 rr                        lda status
000A8Er 3  6A                           ror             ; Rotate through carry into msb.
000A8Fr 3  6A                           ror
000A90r 3  29 80                        and #$80
000A92r 3  18                           clc
000A93r 3  65 rr                        adc tmp3
000A95r 3  85 rr                        sta tmp3
000A97r 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000A99r 3  E6 rr                        inc tmp3+1
000A9Br 3               @1:
000A9Br 3                               ; Save the current length of the input buffer in
000A9Br 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000A9Br 3  98                           tya
000A9Cr 3  C9 80                        cmp #$80
000A9Er 3  90 02                        bcc @2
000AA0r 3  A9 7F                        lda #$7F
000AA2r 3               @2:
000AA2r 3  60                           rts
000AA3r 3               
000AA3r 3               
000AA3r 3               
000AA3r 3               
000AA3r 3               
000AA3r 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000AA3r 3               ; ## "action-of"  auto  ANS core ext
000AA3r 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000AA3r 3               
000AA3r 3               xt_action_of:
000AA3r 3                               ; This is a state aware word with differet behavior
000AA3r 3                               ; when used while compiling vs interpreting.
000AA3r 3                               ; Check STATE
000AA3r 3  A5 rr                        lda state
000AA5r 3  05 rr                        ora state+1
000AA7r 3  F0 0C                        beq @interpreting
000AA9r 3               
000AA9r 3               @compiling:
000AA9r 3                               ; Run ['] to compile the xt of the next word
000AA9r 3                               ; as a literal.
000AA9r 3  20 rr rr                     jsr xt_bracket_tick
000AACr 3               
000AACr 3                               ; Postpone DEFER@ by compiling a JSR to it.
000AACr 3  A0 rr                        ldy #>xt_defer_fetch
000AAEr 3  A9 rr                        lda #<xt_defer_fetch
000AB0r 3  20 rr rr                     jsr cmpl_subroutine
000AB3r 3  80 06                        bra @done
000AB5r 3               
000AB5r 3               @interpreting:
000AB5r 3  20 rr rr                     jsr xt_tick
000AB8r 3  20 rr rr                     jsr xt_defer_fetch
000ABBr 3               
000ABBr 3               @done:
000ABBr 3  60           z_action_of:           rts
000ABCr 3               
000ABCr 3               
000ABCr 3               
000ABCr 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000ABCr 3               ; ## "again"  tested  ANS core ext
000ABCr 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000ABCr 3               
000ABCr 3               xt_again:
000ABCr 3  20 rr rr                     jsr underflow_1
000ABFr 3               
000ABFr 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000ABFr 3                               ; so we have the range and don't have to calculate the
000ABFr 3                               ; offset.
000ABFr 3  A0 00                        ldy #0
000AC1r 3  A9 4C                        lda #$4C        ; JMP
000AC3r 3  91 rr                        sta (cp),y
000AC5r 3  C8                           iny
000AC6r 3               
000AC6r 3  B5 00                        lda 0,x         ; LSB of address
000AC8r 3  91 rr                        sta (cp),y
000ACAr 3  C8                           iny
000ACBr 3               
000ACBr 3  B5 01                        lda 1,x         ; MSB of address
000ACDr 3  91 rr                        sta (cp),y
000ACFr 3  C8                           iny
000AD0r 3               
000AD0r 3                               ; Allot the space we just used
000AD0r 3  98                           tya
000AD1r 3  18                           clc
000AD2r 3  65 rr                        adc cp
000AD4r 3  85 rr                        sta cp
000AD6r 3  90 02                        bcc @done
000AD8r 3  E6 rr                        inc cp+1
000ADAr 3               @done:
000ADAr 3  E8                           inx
000ADBr 3  E8                           inx
000ADCr 3               
000ADCr 3  60           z_again:        rts
000ADDr 3               
000ADDr 3               
000ADDr 3               
000ADDr 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000ADDr 3               ; ## "align"  auto  ANS core
000ADDr 3                       ; """https://forth-standard.org/standard/core/ALIGN
000ADDr 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000ADDr 3                       ; routine as well, and also does nothing
000ADDr 3                       ; """
000ADDr 3               
000ADDr 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000ADDr 3               ; ## "aligned"  auto  ANS core
000ADDr 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000ADDr 3               
000ADDr 3               xt_align:
000ADDr 3               xt_aligned:
000ADDr 3               z_align:
000ADDr 3  60           z_aligned:      rts             ; stripped out during native compile
000ADEr 3               
000ADEr 3               
000ADEr 3               
000ADEr 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000ADEr 3               ; ## "allot"  auto  ANS core
000ADEr 3                       ; """https://forth-standard.org/standard/core/ALLOT
000ADEr 3                       ; Reserve a certain number of bytes (not cells) or release them.
000ADEr 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000ADEr 3                       ; to the beginning of the Dictionary. If n is positive (the most
000ADEr 3                       ; common case), reserve n bytes, but not past the end of the
000ADEr 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000ADEr 3                       ; """
000ADEr 3               
000ADEr 3               xt_allot:
000ADEr 3  20 rr rr                     jsr underflow_1
000AE1r 3               
000AE1r 3                               ; Releasing memory is going to be a very rare operation,
000AE1r 3                               ; so we check for it at the beginning and try to make
000AE1r 3                               ; the most common case as fast as possible
000AE1r 3  B5 01                        lda 1,x
000AE3r 3  30 22                        bmi @release
000AE5r 3               
000AE5r 3                               ; Common case: We are reserving memory, not releasing it
000AE5r 3  18                           clc
000AE6r 3  A5 rr                        lda cp
000AE8r 3  75 00                        adc 0,x
000AEAr 3  85 rr                        sta cp
000AECr 3               
000AECr 3  A5 rr                        lda cp+1
000AEEr 3  75 01                        adc 1,x
000AF0r 3  85 rr                        sta cp+1
000AF2r 3               
000AF2r 3                               ; Wait, did we just grant more space than we have? This is
000AF2r 3                               ; a check we only do here, not for other situations like cmpl_a
000AF2r 3                               ; where smaller amounts are reserved.
000AF2r 3  A0 FF                        ldy #<cp_end
000AF4r 3  C4 rr                        cpy cp
000AF6r 3  A9 7F                        lda #>cp_end
000AF8r 3  E5 rr                        sbc cp+1
000AFAr 3  B0 48                        bcs @done               ; we're fine.
000AFCr 3               
000AFCr 3                               ; Oops, that was too much, we're beyond the end of
000AFCr 3                               ; legal Dictionary RAM. Reduce to max memory and report
000AFCr 3                               ; an error
000AFCr 3  84 rr                        sty cp                  ; still #<cp_end
000AFEr 3  A9 7F                        lda #>cp_end
000B00r 3  85 rr                        sta cp+1
000B02r 3               
000B02r 3  A9 00                        lda #err_allot
000B04r 3  4C rr rr                     jmp error
000B07r 3               
000B07r 3               @release:
000B07r 3                  		; The ANS standard doesn't really say what to do if too much
000B07r 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
000B07r 3                               ; even an official test. Gforth is little help either. The good
000B07r 3                               ; news is, this is going to be a rare case. We want to use as
000B07r 3                               ; few bytes as possible.
000B07r 3               
000B07r 3                               ; What we do is let the user free anything up to the beginning
000B07r 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
000B07r 3                               ; their own risk. This means that the Dictionary pointer DP
000B07r 3                               ; might end up pointing to garbage. However, an attempt to
000B07r 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
000B07r 3                               ; the DP pointing to the last word in RAM (should be DROP) and
000B07r 3                               ; an error message.
000B07r 3               
000B07r 3                               ; We arrive here with ( n ) which is negative. First step,
000B07r 3                               ; subtract the number TOS from the CP for a new CP
000B07r 3  CA                           dex
000B08r 3  CA                           dex
000B09r 3  A5 rr                        lda cp
000B0Br 3  95 00                        sta 0,x
000B0Dr 3  A5 rr                        lda cp+1
000B0Fr 3  95 01                        sta 1,x
000B11r 3               
000B11r 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000B14r 3               
000B14r 3                               ; Second step, see if we've gone too far. We compare the new
000B14r 3                               ; CP on TOS (which, if we've really screwed up, might be
000B14r 3                               ; negative) with CP0. This is a signed comparison
000B14r 3  CA                           dex
000B15r 3  CA                           dex                             ; new CP now NOS
000B16r 3  A9 rr                        lda #<cp0
000B18r 3  95 00                        sta 0,x
000B1Ar 3  A9 rr                        lda #>cp0
000B1Cr 3  95 01                        sta 1,x                         ; CP0 is TOS
000B1Er 3               
000B1Er 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000B21r 3               
000B21r 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000B21r 3                               ; This means we want Z=1 or N=1
000B21r 3  F0 17                        beq @nega_done
000B23r 3  30 15                        bmi @nega_done
000B25r 3               
000B25r 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
000B25r 3                               ; word in ROM (should be DROP), and abort with an error
000B25r 3  A9 rr                        lda #<cp0
000B27r 3  85 rr                        sta cp
000B29r 3  A9 rr                        lda #>cp0
000B2Br 3  85 rr                        sta cp+1
000B2Dr 3               
000B2Dr 3  A9 rr                        lda #<dictionary_start
000B2Fr 3  85 rr                        sta dp
000B31r 3  A9 rr                        lda #>dictionary_start
000B33r 3  85 rr                        sta dp+1
000B35r 3               
000B35r 3  A9 0A                        lda #err_negallot
000B37r 3  4C rr rr                     jmp error
000B3Ar 3               
000B3Ar 3               @nega_done:
000B3Ar 3                               ; Save new CP, which is NOS
000B3Ar 3  B5 02                        lda 2,x
000B3Cr 3  85 rr                        sta cp
000B3Er 3  B5 03                        lda 3,x
000B40r 3  85 rr                        sta cp+1
000B42r 3               
000B42r 3  E8                           inx
000B43r 3  E8                           inx                     ; drop through to @done
000B44r 3               @done:
000B44r 3  E8                           inx
000B45r 3  E8                           inx
000B46r 3               z_allot:
000B46r 3  60                           rts
000B47r 3               
000B47r 3               
000B47r 3               
000B47r 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000B47r 3               ; ## "allow-native"  auto  Tali Forth
000B47r 3               xt_allow_native:
000B47r 3  20 rr rr                     jsr current_to_dp
000B4Ar 3  A0 01                        ldy #1          ; offset for status byte
000B4Cr 3  B1 rr                        lda (dp),y
000B4Er 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
000B50r 3  91 rr                        sta (dp),y
000B52r 3               z_allow_native:
000B52r 3  60                           rts
000B53r 3               
000B53r 3               
000B53r 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000B53r 3               ; ## "also"  auto  ANS search ext
000B53r 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000B53r 3               xt_also:
000B53r 3  20 rr rr                     jsr xt_get_order
000B56r 3  20 rr rr                     jsr xt_over
000B59r 3  20 rr rr                     jsr xt_swap
000B5Cr 3  20 rr rr                     jsr xt_one_plus
000B5Fr 3  20 rr rr                     jsr xt_set_order
000B62r 3               
000B62r 3  60           z_also:         rts
000B63r 3               
000B63r 3               
000B63r 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000B63r 3               ; ## "always-native"  auto  Tali Forth
000B63r 3               xt_always_native:
000B63r 3  20 rr rr                     jsr current_to_dp
000B66r 3  A0 01                        ldy #1          ; offset for status byte
000B68r 3  B1 rr                        lda (dp),y
000B6Ar 3  09 02                        ora #AN         ; Make sure AN flag is set
000B6Cr 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
000B6Er 3  91 rr                        sta (dp),y
000B70r 3               z_always_native:
000B70r 3  60                           rts
000B71r 3               
000B71r 3               
000B71r 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
000B71r 3               ; ## "and"  auto  ANS core
000B71r 3                       ; """https://forth-standard.org/standard/core/AND"""
000B71r 3               xt_and:
000B71r 3  20 rr rr                     jsr underflow_2
000B74r 3               
000B74r 3  B5 00                        lda 0,x
000B76r 3  35 02                        and 2,x
000B78r 3  95 02                        sta 2,x
000B7Ar 3               
000B7Ar 3  B5 01                        lda 1,x
000B7Cr 3  35 03                        and 3,x
000B7Er 3  95 03                        sta 3,x
000B80r 3               
000B80r 3  E8                           inx
000B81r 3  E8                           inx
000B82r 3               
000B82r 3  60           z_and:          rts
000B83r 3               
000B83r 3               
000B83r 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000B83r 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000B83r 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000B83r 3                       ; assembler words to the search order so they can be used.
000B83r 3                       ; See the tutorial on Wordlists and the Search Order for
000B83r 3                       ; more information.
000B83r 3                       ;
000B83r 3                       ; This is a dummy entry, the code is shared with TWO
000B83r 3                       ; """
000B83r 3               
000B83r 3               
000B83r 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000B83r 3               ; ## "at-xy"  tested  ANS facility
000B83r 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000B83r 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000B83r 3                       ; ANSI code is ESC[<n>;<m>H
000B83r 3                       ;
000B83r 3                       ; Do not use U. to print the numbers because the
000B83r 3                       ; trailing space will not work with xterm
000B83r 3                       ; """
000B83r 3               xt_at_xy:
000B83r 3  20 rr rr                     jsr underflow_2
000B86r 3               
000B86r 3  A9 1B                        lda #AscESC
000B88r 3  20 rr rr                     jsr emit_a
000B8Br 3  A9 5B                        lda #$5B        ; ASCII for "["
000B8Dr 3  20 rr rr                     jsr emit_a
000B90r 3  20 rr rr                     jsr print_u
000B93r 3  A9 3B                        lda #$3B        ; ASCII for ";"
000B95r 3  20 rr rr                     jsr emit_a
000B98r 3  20 rr rr                     jsr print_u
000B9Br 3  A9 48                        lda #'H'
000B9Dr 3  20 rr rr                     jsr emit_a
000BA0r 3               
000BA0r 3  60           z_at_xy:        rts
000BA1r 3               
000BA1r 3               
000BA1r 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
000BA1r 3               ; ## "\"  auto  ANS core ext
000BA1r 3                       ; """https://forth-standard.org/standard/core/bs"""
000BA1r 3               xt_backslash:
000BA1r 3  A5 rr                        lda ciblen
000BA3r 3  85 rr                        sta toin
000BA5r 3  A5 rr                        lda ciblen+1
000BA7r 3  85 rr                        sta toin+1
000BA9r 3               
000BA9r 3  60           z_backslash:    rts
000BAAr 3               
000BAAr 3               
000BAAr 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000BAAr 3               ; ## "base"  auto  ANS core
000BAAr 3                       ; """https://forth-standard.org/standard/core/BASE
000BAAr 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000BAAr 3                       ; ingore the MSB
000BAAr 3                       ; """
000BAAr 3               xt_base:
000BAAr 3  CA                           dex
000BABr 3  CA                           dex
000BACr 3  A9 rr                        lda #<base
000BAEr 3  95 00                        sta 0,x         ; LSB
000BB0r 3  74 01                        stz 1,x         ; MSB is always 0
000BB2r 3               
000BB2r 3  60           z_base:         rts
000BB3r 3               
000BB3r 3               
000BB3r 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000BB3r 3               ; ## "begin"  auto  ANS core
000BB3r 3                       ; """https://forth-standard.org/standard/core/BEGIN
000BB3r 3                       ;
000BB3r 3                       ; This is just an immediate version of here which could just
000BB3r 3                       ; as well be coded in Forth as
000BB3r 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000BB3r 3                       ; Since this is a compiling word, we don't care that much about
000BB3r 3                       ; about speed
000BB3r 3                       ; """
000BB3r 3               
000BB3r 3               xt_begin:
000BB3r 3  20 rr rr                     jsr xt_here
000BB6r 3  60           z_begin:        rts
000BB7r 3               
000BB7r 3               
000BB7r 3               
000BB7r 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000BB7r 3               ; ## "bell"  tested  Tali Forth
000BB7r 3               xt_bell:
000BB7r 3  A9 07                        lda #7          ; ASCII value for BELl
000BB9r 3  20 rr rr                     jsr emit_a
000BBCr 3               
000BBCr 3  60           z_bell:         rts
000BBDr 3               
000BBDr 3               
000BBDr 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000BBDr 3               ; ## "bl"  auto  ANS core
000BBDr 3                       ; """https://forth-standard.org/standard/core/BL"""
000BBDr 3               
000BBDr 3               xt_bl:
000BBDr 3  CA                           dex
000BBEr 3  CA                           dex
000BBFr 3  A9 20                        lda #AscSP
000BC1r 3  95 00                        sta 0,x
000BC3r 3  74 01                        stz 1,x
000BC5r 3               
000BC5r 3  60           z_bl:           rts
000BC6r 3               
000BC6r 3               
000BC6r 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000BC6r 3               ; ## "block"  auto  ANS block
000BC6r 3                       ; """https://forth-standard.org/standard/block/BLK"""
000BC6r 3               xt_blk:
000BC6r 3                               ; BLK is at UP + blk_offset
000BC6r 3  CA                           dex
000BC7r 3  CA                           dex
000BC8r 3  18                           clc
000BC9r 3  A5 rr                        lda up
000BCBr 3  69 00                        adc #blk_offset ; Add offset
000BCDr 3  95 00                        sta 0,x
000BCFr 3  A5 rr                        lda up+1
000BD1r 3  69 00                        adc #0          ; Adding carry
000BD3r 3  95 01                        sta 1,x
000BD5r 3               
000BD5r 3  60           z_blk:          rts
000BD6r 3               
000BD6r 3               
000BD6r 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
000BD6r 3               ; ## "blkbuffer"  auto  Tali block
000BD6r 3               xt_blkbuffer:
000BD6r 3                               ; blkbuffer address is at UP + blkbuffer_offset.
000BD6r 3                               ; Unlike some of the other user variables, we actually
000BD6r 3                               ; want to push the address stored here, which will
000BD6r 3                               ; point to somewhere outside of the user variables.
000BD6r 3  CA                           dex
000BD7r 3  CA                           dex
000BD8r 3                               ; Put the address on the stack.
000BD8r 3  A0 28                        ldy #blkbuffer_offset
000BDAr 3  B1 rr                        lda (up),y
000BDCr 3  95 00                        sta 0,x
000BDEr 3  C8                           iny             ; Move along to the next byte
000BDFr 3  B1 rr                        lda (up),y
000BE1r 3  95 01                        sta 1,x
000BE3r 3               
000BE3r 3  60           z_blkbuffer:    rts
000BE4r 3               
000BE4r 3               
000BE4r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
000BE4r 3               ; ## "block"  auto  ANS block
000BE4r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
000BE4r 3               
000BE4r 3               xt_block:
000BE4r 3               
000BE4r 3                               ; See if the block requested is the same as the one we
000BE4r 3                               ; currently have in the buffer. Check the LSB.
000BE4r 3  A0 2A                        ldy #buffblocknum_offset
000BE6r 3  B1 rr                        lda (up),y
000BE8r 3  D5 00                        cmp 0,x
000BEAr 3  D0 0F                        bne @not_in_buffer
000BECr 3               
000BECr 3                               ; Check the MSB.
000BECr 3  C8                           iny
000BEDr 3  B1 rr                        lda (up),y
000BEFr 3  D5 01                        cmp 1,x
000BF1r 3  D0 08                        bne @not_in_buffer
000BF3r 3               
000BF3r 3                               ; The block is in the buffer. See if the buffer is in use.
000BF3r 3  A0 2C                        ldy #buffstatus_offset
000BF5r 3  B1 rr                        lda (up),y
000BF7r 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000BF9r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000BFBr 3                                               ; @done will replace the block# with the
000BFBr 3                                               ; buffer address.
000BFBr 3               @not_in_buffer:
000BFBr 3                               ; Check the buffer status
000BFBr 3  A0 2C                        ldy #buffstatus_offset
000BFDr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000BFFr 3  C9 03                        cmp #3          ; LSB is needed.
000C01r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000C03r 3               
000C03r 3                               ; We need to save the block.
000C03r 3  20 rr rr                     jsr xt_blkbuffer
000C06r 3  20 rr rr                     jsr xt_buffblocknum
000C09r 3  20 rr rr                     jsr xt_fetch
000C0Cr 3  20 rr rr                     jsr xt_block_write
000C0Fr 3               
000C0Fr 3               @buffer_available:
000C0Fr 3                               ; Save the block number.
000C0Fr 3  A0 2A                        ldy #buffblocknum_offset
000C11r 3  B5 00                        lda 0,x
000C13r 3  91 rr                        sta (up),y
000C15r 3  C8                           iny
000C16r 3  B5 01                        lda 1,x
000C18r 3  91 rr                        sta (up),y
000C1Ar 3               
000C1Ar 3                               ; Get the requested block.
000C1Ar 3  20 rr rr                     jsr xt_blkbuffer
000C1Dr 3  20 rr rr                     jsr xt_swap
000C20r 3  20 rr rr                     jsr xt_block_read
000C23r 3               
000C23r 3                               ; Mark the buffer as clean and in-use.
000C23r 3  A9 01                        lda #1
000C25r 3  A0 2C                        ldy #buffstatus_offset
000C27r 3  91 rr                        sta (up),y
000C29r 3               
000C29r 3                               ; Make room on the stack for the return address.
000C29r 3  CA                           dex
000C2Ar 3  CA                           dex
000C2Br 3               
000C2Br 3               @done:
000C2Br 3                               ; It's in the buffer. Return the buffer address.
000C2Br 3  A0 28                        ldy #blkbuffer_offset
000C2Dr 3  B1 rr                        lda (up),y
000C2Fr 3  95 00                        sta 0,x
000C31r 3  C8                           iny
000C32r 3  B1 rr                        lda (up),y
000C34r 3  95 01                        sta 1,x
000C36r 3               
000C36r 3  60           z_block:        rts
000C37r 3               
000C37r 3               
000C37r 3               
000C37r 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000C37r 3               ; ## "block-ramdrive-init"  auto  Tali block
000C37r 3                       ; """Create a RAM drive, with the given number of
000C37r 3                       ; blocks, in the dictionary along with setting up the block words to
000C37r 3                       ; use it.  The read/write routines do not provide bounds checking.
000C37r 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000C37r 3                       ; """
000C37r 3               
000C37r 3               xt_block_ramdrive_init:
000C37r 3  20 rr rr                     jsr underflow_1
000C3Ar 3               
000C3Ar 3                               ; Store the string to run here as a string literal.
000C3Ar 3                               ; See SLITERAL for the format information. This way, we
000C3Ar 3                               ; don't have the words defined below in the Dictionary until
000C3Ar 3                               ; we really use them.
000C3Ar 3  4C rr rr                     jmp @after_ramdrive_code
000C3Dr 3               
000C3Dr 3               @ramdrive_code:
000C3Dr 3  62 61 73 65          .byte "base @ swap decimal"
000C41r 3  20 40 20 73  
000C45r 3  77 61 70 20  
000C50r 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000C54r 3  34 20 2A     
000C57r 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000C5Br 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
000C5Fr 3  66 65 72 3A  
000C63r 3  20 72 61 6D  
000C6Cr 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000C6Cr 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
000C70r 3  6C 6F 63 6B  
000C74r 3  2D 72 65 61  
000C82r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000C86r 3  64 72 69 76  
000C8Ar 3  65 20 73 77  
000CAAr 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000CAEr 3  6C 6F 63 6B  
000CB2r 3  2D 77 72 69  
000CC1r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000CC5r 3  64 72 69 76  
000CC9r 3  65 20 73 77  
000CE4r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000CE8r 3  6C 6F 63 6B  
000CECr 3  2D 72 65 61  
000D0Er 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
000D12r 3  6C 6F 63 6B  
000D16r 3  2D 77 72 69  
000D3Ar 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000D3Er 3  64 72 69 76  
000D42r 3  65 20 73 77  
000D55r 3               
000D55r 3               @after_ramdrive_code:
000D55r 3  20 rr rr                     jsr sliteral_runtime
000D58r 3               
000D58r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000D5Cr 3               
000D5Cr 3                               ; The address and length of the ramdrive code is now on the
000D5Cr 3                               ; stack. Call EVALUATE to run it.
000D5Cr 3  20 rr rr                     jsr xt_evaluate
000D5Fr 3               
000D5Fr 3               z_block_ramdrive_init:
000D5Fr 3  60                           rts
000D60r 3               
000D60r 3               
000D60r 3               
000D60r 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
000D60r 3               ; ## "block-read"  auto  Tali block
000D60r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000D60r 3                       ; with their own version to read a block from storage.
000D60r 3                       ; The stack parameters are ( buffer_address block# -- ).
000D60r 3                       ; """
000D60r 3               xt_block_read:
000D60r 3                               ; Execute the BLOCK-READ-VECTOR
000D60r 3  A0 2E                        ldy #blockread_offset
000D62r 3  B1 rr                        lda (up),y
000D64r 3  85 rr                        sta tmp1
000D66r 3  C8                           iny
000D67r 3  B1 rr                        lda (up),y
000D69r 3  85 rr                        sta tmp1+1
000D6Br 3               
000D6Br 3  6C rr rr                     jmp (tmp1)
000D6Er 3               
000D6Er 3               z_block_read:   ; No RTS needed
000D6Er 3               
000D6Er 3               
000D6Er 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
000D6Er 3               ; ## "block-read-vector"  auto  Tali block
000D6Er 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000D6Er 3                       ; with their own version to read a block from storage.
000D6Er 3                       ; This word gives the address of the vector so it can be replaced.
000D6Er 3                       ; """
000D6Er 3               xt_block_read_vector:
000D6Er 3                               ; Get the BLOCK-READ-VECTOR address
000D6Er 3  CA                           dex
000D6Fr 3  CA                           dex
000D70r 3  18                           clc
000D71r 3  A5 rr                        lda up
000D73r 3  69 2E                        adc #blockread_offset
000D75r 3  95 00                        sta 0,x
000D77r 3  A5 rr                        lda up+1
000D79r 3  69 00                        adc #0          ; Add carry
000D7Br 3  95 01                        sta 1,x
000D7Dr 3               
000D7Dr 3               z_block_read_vector:
000D7Dr 3  60                           rts
000D7Er 3               
000D7Er 3               
000D7Er 3               ; This is the default error message the vectored words BLOCK-READ and
000D7Er 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
000D7Er 3               xt_block_word_error:
000D7Er 3  A9 0C                        lda #err_blockwords
000D80r 3  4C rr rr                     jmp error       ; no RTS needed
000D83r 3               z_block_word_error:
000D83r 3               
000D83r 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000D83r 3               ; ## "block-write"  auto  Tali block
000D83r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000D83r 3                       ; with their own version to write a block to storage.
000D83r 3                       ; The stack parameters are ( buffer_address block# -- ).
000D83r 3                       ; """
000D83r 3               xt_block_write:
000D83r 3                               ; Execute the BLOCK-READ-VECTOR
000D83r 3  A0 30                        ldy #blockwrite_offset
000D85r 3  B1 rr                        lda (up),y
000D87r 3  85 rr                        sta tmp1
000D89r 3  C8                           iny
000D8Ar 3  B1 rr                        lda (up),y
000D8Cr 3  85 rr                        sta tmp1+1
000D8Er 3  6C rr rr                     jmp (tmp1)
000D91r 3               
000D91r 3               z_block_write:  ; No RTS needed
000D91r 3               
000D91r 3               
000D91r 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
000D91r 3               ; ## "block-write-vector"  auto  Tali block
000D91r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000D91r 3                       ; with their own version to write a block to storage.
000D91r 3                       ; This word gives the address of the vector so it can be replaced.
000D91r 3                       ; """
000D91r 3               xt_block_write_vector:
000D91r 3                               ; Get the BLOCK-WRITE-VECTOR address
000D91r 3  CA                           dex
000D92r 3  CA                           dex
000D93r 3  18                           clc
000D94r 3  A5 rr                        lda up
000D96r 3  69 30                        adc #blockwrite_offset
000D98r 3  95 00                        sta 0,x
000D9Ar 3  A5 rr                        lda up+1
000D9Cr 3  69 00                        adc #0          ; Add carry
000D9Er 3  95 01                        sta 1,x
000DA0r 3               
000DA0r 3               z_block_write_vector:
000DA0r 3  60                           rts
000DA1r 3               
000DA1r 3               
000DA1r 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
000DA1r 3               ; ## "bounds"  auto  Gforth
000DA1r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
000DA1r 3                       ; Given a string, return the correct Data Stack parameters for
000DA1r 3                       ; a DO/LOOP loop over its characters. This is realized as
000DA1r 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
000DA1r 3                       ; """
000DA1r 3               xt_bounds:
000DA1r 3  20 rr rr                     jsr underflow_2
000DA4r 3               
000DA4r 3  18                           clc
000DA5r 3  B5 00                        lda 0,x                 ; LSB u
000DA7r 3  B4 02                        ldy 2,x                 ; LSB addr
000DA9r 3  75 02                        adc 2,x
000DABr 3  95 02                        sta 2,x                 ; LSB addr+u
000DADr 3  94 00                        sty 0,x
000DAFr 3               
000DAFr 3  B5 01                        lda 1,x                 ; MSB u
000DB1r 3  B4 03                        ldy 3,x                 ; MSB addr
000DB3r 3  75 03                        adc 3,x
000DB5r 3  95 03                        sta 3,x                 ; MSB addr+u
000DB7r 3  94 01                        sty 1,x
000DB9r 3               
000DB9r 3  60           z_bounds:       rts
000DBAr 3               
000DBAr 3               
000DBAr 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000DBAr 3               ; ## "[char]"  auto  ANS core
000DBAr 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000DBAr 3                       ; Compile the ASCII value of a character as a literal. This is an
000DBAr 3                       ; immediate, compile-only word.
000DBAr 3                       ;
000DBAr 3                       ; A definition given in
000DBAr 3                       ; http://forth-standard.org/standard/implement is
000DBAr 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000DBAr 3                       ; """
000DBAr 3               xt_bracket_char:
000DBAr 3  20 rr rr                     jsr xt_char
000DBDr 3  20 rr rr                     jsr xt_literal
000DC0r 3  60           z_bracket_char: rts
000DC1r 3               
000DC1r 3               
000DC1r 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000DC1r 3               ; ## "[']"  auto  ANS core
000DC1r 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000DC1r 3               xt_bracket_tick:
000DC1r 3  20 rr rr                     jsr xt_tick
000DC4r 3  20 rr rr                     jsr xt_literal
000DC7r 3  60           z_bracket_tick: rts
000DC8r 3               
000DC8r 3               
000DC8r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000DC8r 3               ; ## "buffblocknum"  auto  Tali block
000DC8r 3               xt_buffblocknum:
000DC8r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000DC8r 3  CA                           dex
000DC9r 3  CA                           dex
000DCAr 3  18                           clc
000DCBr 3  A5 rr                        lda up
000DCDr 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000DCFr 3  95 00                        sta 0,x
000DD1r 3  A5 rr                        lda up+1
000DD3r 3  69 00                        adc #0                          ; Adding carry
000DD5r 3  95 01                        sta 1,x
000DD7r 3               
000DD7r 3  60           z_buffblocknum: rts
000DD8r 3               
000DD8r 3               
000DD8r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000DD8r 3               ; ## "buffer"  auto  ANS block
000DD8r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000DD8r 3               
000DD8r 3               xt_buffer:
000DD8r 3                               ; Check the buffer status
000DD8r 3  A0 2C                        ldy #buffstatus_offset
000DDAr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000DDCr 3  C9 03                        cmp #3          ; LSB is needed.
000DDEr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000DE0r 3               
000DE0r 3                               ; We need to save the block.
000DE0r 3  20 rr rr                     jsr xt_blkbuffer
000DE3r 3  20 rr rr                     jsr xt_buffblocknum
000DE6r 3  20 rr rr                     jsr xt_fetch
000DE9r 3  20 rr rr                     jsr xt_block_write
000DECr 3               
000DECr 3               @buffer_available:
000DECr 3                               ; Save the block number.
000DECr 3  A0 2A                        ldy #buffblocknum_offset
000DEEr 3  B5 00                        lda 0,x
000DF0r 3  91 rr                        sta (up),y
000DF2r 3  C8                           iny
000DF3r 3  B5 01                        lda 1,x
000DF5r 3  91 rr                        sta (up),y
000DF7r 3               
000DF7r 3                               ; Mark the buffer as clean and in-use.
000DF7r 3  A9 01                        lda #1
000DF9r 3  A0 2C                        ldy #buffstatus_offset
000DFBr 3  91 rr                        sta (up),y
000DFDr 3               
000DFDr 3               @done:
000DFDr 3                               ; Return the buffer address.
000DFDr 3  A0 28                        ldy #blkbuffer_offset
000DFFr 3  B1 rr                        lda (up),y
000E01r 3  95 00                        sta 0,x
000E03r 3  C8                           iny
000E04r 3  B1 rr                        lda (up),y
000E06r 3  95 01                        sta 1,x
000E08r 3               
000E08r 3  60           z_buffer:       rts
000E09r 3               
000E09r 3               
000E09r 3               
000E09r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
000E09r 3               ; ## "buffer:"  auto  ANS core ext
000E09r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
000E09r 3                               ; Create a buffer of size u that puts its address on the stack
000E09r 3                               ; when its name is used.
000E09r 3                               ; """
000E09r 3               xt_buffer_colon:
000E09r 3  20 rr rr                     jsr xt_create
000E0Cr 3  20 rr rr                     jsr xt_allot
000E0Fr 3  60           z_buffer_colon: rts
000E10r 3               
000E10r 3               
000E10r 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
000E10r 3               ; ## "buffstatus"  auto  Tali block
000E10r 3               xt_buffstatus:
000E10r 3                               ; BUFFSTATUS is at UP + buffstatus_offset
000E10r 3  CA                           dex
000E11r 3  CA                           dex
000E12r 3  18                           clc
000E13r 3  A5 rr                        lda up
000E15r 3  69 2C                        adc #buffstatus_offset  ; Add offset
000E17r 3  95 00                        sta 0,x
000E19r 3  A5 rr                        lda up+1
000E1Br 3  69 00                        adc #0                  ; Adding carry
000E1Dr 3  95 01                        sta 1,x
000E1Fr 3               
000E1Fr 3  60           z_buffstatus:   rts
000E20r 3               
000E20r 3               
000E20r 3               ; ## BYE ( -- ) "Break"
000E20r 3               ; ## "bye"  tested  ANS tools ext
000E20r 3                       ; """https://forth-standard.org/standard/tools/BYE"""
000E20r 3               
000E20r 3               xt_bye:
000E20r 3                               ;brk
000E20r 3  4C rr rr                     jmp platform_bye
000E23r 3               z_bye:          ;rts             ; never reached
000E23r 3               
000E23r 3               
000E23r 3               
000E23r 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
000E23r 3               ; ## "c,"  auto  ANS core
000E23r 3                       ; """https://forth-standard.org/standard/core/CComma"""
000E23r 3               
000E23r 3               xt_c_comma:
000E23r 3  20 rr rr                     jsr underflow_1
000E26r 3               
000E26r 3  B5 00                        lda 0,x
000E28r 3  20 rr rr                     jsr cmpl_a
000E2Br 3               
000E2Br 3  E8                           inx
000E2Cr 3  E8                           inx
000E2Dr 3               
000E2Dr 3  60           z_c_comma:      rts
000E2Er 3               
000E2Er 3               
000E2Er 3               
000E2Er 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
000E2Er 3               ; ## "c@"  auto  ANS core
000E2Er 3                       ; """https://forth-standard.org/standard/core/CFetch"""
000E2Er 3               xt_c_fetch:
000E2Er 3  20 rr rr                     jsr underflow_1
000E31r 3               
000E31r 3  A1 00                        lda (0,x)
000E33r 3  95 00                        sta 0,x
000E35r 3  74 01                        stz 1,x         ; Ignore LSB
000E37r 3               
000E37r 3  60           z_c_fetch:      rts
000E38r 3               
000E38r 3               
000E38r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000E38r 3               ; ## "c!"  auto  ANS core
000E38r 3                       ; """https://forth-standard.org/standard/core/CStore"""
000E38r 3               xt_c_store:
000E38r 3  20 rr rr                     jsr underflow_2
000E3Br 3               
000E3Br 3  B5 02                        lda 2,x
000E3Dr 3  81 00                        sta (0,x)
000E3Fr 3               
000E3Fr 3  E8                           inx
000E40r 3  E8                           inx
000E41r 3  E8                           inx
000E42r 3  E8                           inx
000E43r 3               
000E43r 3  60           z_c_store:      rts
000E44r 3               
000E44r 3               
000E44r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000E44r 3               ; ## "case"  auto  ANS core ext
000E44r 3                       ; """http://forth-standard.org/standard/core/CASE
000E44r 3                       ;
000E44r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000E44r 3                       ; """
000E44r 3               
000E44r 3               
000E44r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000E44r 3               ; ## "cell+"  auto  ANS core
000E44r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000E44r 3                       ; Add the number of bytes ("address units") that one cell needs.
000E44r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000E44r 3                       ; """
000E44r 3               
000E44r 3               xt_cell_plus:
000E44r 3  20 rr rr                     jsr underflow_1
000E47r 3               
000E47r 3  F6 00                        inc 0,x
000E49r 3  D0 02                        bne @1
000E4Br 3  F6 01                        inc 1,x
000E4Dr 3               @1:
000E4Dr 3  F6 00                        inc 0,x
000E4Fr 3  D0 02                        bne @done
000E51r 3  F6 01                        inc 1,x
000E53r 3               @done:
000E53r 3  60           z_cell_plus:    rts
000E54r 3               
000E54r 3               
000E54r 3               
000E54r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000E54r 3               ; ## "cells"  auto  ANS core
000E54r 3                       ; """https://forth-standard.org/standard/core/CELLS
000E54r 3                       ;
000E54r 3                       ; Dummy entry for the CELLS word, the code is the same as for
000E54r 3                       ; 2*, which is where the header directs us to
000E54r 3                       ; """
000E54r 3               
000E54r 3               
000E54r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000E54r 3               ; ## "char"  auto  ANS core
000E54r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000E54r 3               
000E54r 3               xt_char:
000E54r 3                               ; get character from string, returns ( addr u )
000E54r 3  20 rr rr                     jsr xt_parse_name
000E57r 3               
000E57r 3                               ; if we got back a zero, we have a problem
000E57r 3  B5 00                        lda 0,x
000E59r 3  15 01                        ora 1,x
000E5Br 3  D0 05                        bne @not_empty
000E5Dr 3               
000E5Dr 3  A9 05                        lda #err_noname
000E5Fr 3  4C rr rr                     jmp error
000E62r 3               
000E62r 3               @not_empty:
000E62r 3  E8                           inx             ; drop number of characters, leave addr
000E63r 3  E8                           inx
000E64r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000E66r 3  95 00                        sta 0,x
000E68r 3  74 01                        stz 1,x         ; MSB is always zero
000E6Ar 3               
000E6Ar 3  60           z_char:         rts
000E6Br 3               
000E6Br 3               
000E6Br 3               
000E6Br 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000E6Br 3               ; ## "char+"  auto  ANS core
000E6Br 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000E6Br 3                       ;
000E6Br 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000E6Br 3                       ; """
000E6Br 3               
000E6Br 3               
000E6Br 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000E6Br 3               ; ## "chars"  auto  ANS core
000E6Br 3                       ; """https://forth-standard.org/standard/core/CHARS
000E6Br 3                       ; Return how many address units n chars are. Since this is an 8 bit
000E6Br 3                       ; machine, this does absolutely nothing and is included for
000E6Br 3                       ; compatibility with other Forth versions
000E6Br 3                       ; """
000E6Br 3               
000E6Br 3               xt_chars:
000E6Br 3                               ; Checking for underflow seems a bit stupid because this
000E6Br 3                               ; routine does nothing on this machine. However, the user
000E6Br 3                               ; should be warned that there is something wrong with the
000E6Br 3                               ; code if this occurs.
000E6Br 3  20 rr rr                     jsr underflow_1
000E6Er 3               
000E6Er 3  60           z_chars:        rts
000E6Fr 3               
000E6Fr 3               
000E6Fr 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
000E6Fr 3               ; ## "cleave"  auto  Tali Forth
000E6Fr 3               
000E6Fr 3                       ; """Given a range of memory with words delimited by whitespace,return
000E6Fr 3                       ; the first word at the top of the stack and the rest of the word
000E6Fr 3                       ; following it.
000E6Fr 3                       ;
000E6Fr 3                       ; Example:
000E6Fr 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
000E6Fr 3                       ; s" w1" cleave        -> "" "w1"
000E6Fr 3                       ;
000E6Fr 3                       ; Since it will be used in loops a lot, we want it to work in pure
000E6Fr 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
000E6Fr 3                       ; strip leading delimiters.
000E6Fr 3                       ; """
000E6Fr 3               
000E6Fr 3               xt_cleave:
000E6Fr 3  20 rr rr                     jsr underflow_2
000E72r 3               
000E72r 3                               ; We arrive here with ( addr u ). We need to strip any leading
000E72r 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
000E72r 3                               ; remember how many spaces were stripped. This means we can't
000E72r 3                               ; calculate the length of the remainder. Fortunately, Tali
000E72r 3                               ; Forth has just the word we need for this:
000E72r 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000E75r 3               
000E75r 3                               ; The main part we can turn over to PARSE-NAME, except that we
000E75r 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000E75r 3                               ; We get around this by cheating: We place ( addr u ) in the
000E75r 3                               ; input buffer and then call PARSE-NAME.
000E75r 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000E78r 3               
000E78r 3  B5 00                        lda 0,x         ; u is new ciblen
000E7Ar 3  85 rr                        sta ciblen
000E7Cr 3  B5 01                        lda 1,x
000E7Er 3  85 rr                        sta ciblen+1
000E80r 3               
000E80r 3  B5 02                        lda 2,x         ; addr is new cib
000E82r 3  85 rr                        sta cib
000E84r 3  B5 03                        lda 3,x
000E86r 3  85 rr                        sta cib+1
000E88r 3               
000E88r 3  64 rr                        stz toin        ; >IN pointer is zero
000E8Ar 3  64 rr                        stz toin+1
000E8Cr 3               
000E8Cr 3                               ; PARSE-NAME gives us back the substring of the first word
000E8Cr 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
000E8Fr 3               
000E8Fr 3                               ; If we were given an empty string, then we're done. It's the
000E8Fr 3                               ; resposibility of the user to catch this as a sign to end the
000E8Fr 3                               ; any loop
000E8Fr 3  B5 00                        lda 0,x
000E91r 3  15 01                        ora 1,x
000E93r 3  F0 23                        beq @done
000E95r 3               
000E95r 3                               ; Now we have to adjust the original string
000E95r 3  B5 04                        lda 4,x         ; LSB of original u
000E97r 3  38                           sec
000E98r 3  F5 00                        sbc 0,x
000E9Ar 3  95 04                        sta 4,x
000E9Cr 3               
000E9Cr 3  B5 05                        lda 5,x         ; MSB of original u
000E9Er 3  F5 01                        sbc 1,x
000EA0r 3  95 05                        sta 5,x
000EA2r 3               
000EA2r 3  B5 06                        lda 6,x         ; LSB of original addr
000EA4r 3  18                           clc
000EA5r 3  75 00                        adc 0,x
000EA7r 3  95 06                        sta 6,x
000EA9r 3               
000EA9r 3  B5 07                        lda 7,x         ; MSB of original addr
000EABr 3  75 01                        adc 1,x
000EADr 3  95 07                        sta 7,x
000EAFr 3               
000EAFr 3                               ; There is one small problem: PARSE-NAME will probably have
000EAFr 3                               ; left the string with the rest of the words with leading
000EAFr 3                               ; delimiters. We use our magic -LEADING again
000EAFr 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
000EB2r 3  20 rr rr                     jsr xt_minus_leading
000EB5r 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000EB8r 3               @done:
000EB8r 3                               ; Restore input
000EB8r 3  20 rr rr                     jsr xt_r_to_input
000EBBr 3               
000EBBr 3  60           z_cleave:       rts
000EBCr 3               
000EBCr 3               
000EBCr 3               
000EBCr 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000EBCr 3               ; ## "cmove"  auto  ANS string
000EBCr 3                       ; """https://forth-standard.org/standard/string/CMOVE
000EBCr 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000EBCr 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000EBCr 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000EBCr 3                       ; "move left".
000EBCr 3                       ;
000EBCr 3                       ; There are no official tests for this word.
000EBCr 3                       ; """
000EBCr 3               
000EBCr 3               xt_cmove:
000EBCr 3  20 rr rr                     jsr underflow_3
000EBFr 3               
000EBFr 3                               ; move destination address to where we can work with it
000EBFr 3  B5 02                        lda 2,x
000EC1r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000EC3r 3  B5 03                        lda 3,x
000EC5r 3  85 rr                        sta tmp2+1
000EC7r 3               
000EC7r 3                               ; move source address to where we can work with it
000EC7r 3  B5 04                        lda 4,x
000EC9r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000ECBr 3  B5 05                        lda 5,x
000ECDr 3  85 rr                        sta tmp1+1
000ECFr 3               
000ECFr 3  A0 00                        ldy #0
000ED1r 3  B5 01                        lda 1,x         ; number of whole pages to move
000ED3r 3  F0 0F                        beq @dopartial
000ED5r 3               
000ED5r 3               @page:
000ED5r 3  B1 rr                        lda (tmp1),y
000ED7r 3  91 rr                        sta (tmp2),y
000ED9r 3  C8                           iny
000EDAr 3  D0 F9                        bne @page
000EDCr 3               
000EDCr 3  E6 rr                        inc tmp1+1
000EDEr 3  E6 rr                        inc tmp2+1
000EE0r 3  D6 01                        dec 1,x
000EE2r 3  D0 F1                        bne @page
000EE4r 3               
000EE4r 3               @dopartial:
000EE4r 3  B5 00                        lda 0,x         ; length of last page
000EE6r 3  F0 09                        beq @done
000EE8r 3               
000EE8r 3               @partial:
000EE8r 3  B1 rr                        lda (tmp1),y
000EEAr 3  91 rr                        sta (tmp2),y
000EECr 3  C8                           iny
000EEDr 3               
000EEDr 3  D6 00                        dec 0,x
000EEFr 3  D0 F7                        bne @partial
000EF1r 3               
000EF1r 3               @done:          ; clear the stack
000EF1r 3  8A                           txa
000EF2r 3  18                           clc
000EF3r 3  69 06                        adc #6
000EF5r 3  AA                           tax
000EF6r 3               
000EF6r 3  60           z_cmove:        rts
000EF7r 3               
000EF7r 3               
000EF7r 3               
000EF7r 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
000EF7r 3               ; ## "cmove>"  auto  ANS string
000EF7r 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
000EF7r 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
000EF7r 3                       ; Routines", p. 201, where it is called "move right".
000EF7r 3                       ;
000EF7r 3                       ; There are no official tests for this word.
000EF7r 3                       ; """
000EF7r 3               
000EF7r 3               xt_cmove_up:
000EF7r 3  20 rr rr                     jsr underflow_3
000EFAr 3               
000EFAr 3                               ; Move destination address to where we can work with it
000EFAr 3  B5 02                        lda 2,x
000EFCr 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000EFEr 3  B5 03                        lda 3,x
000F00r 3  18                           clc
000F01r 3  75 01                        adc 1,x
000F03r 3  85 rr                        sta tmp2+1      ; point to last page of destination
000F05r 3               
000F05r 3                               ; Move source address to where we can work with it
000F05r 3  B5 04                        lda 4,x
000F07r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000F09r 3  B5 05                        lda 5,x
000F0Br 3  18                           clc
000F0Cr 3  75 01                        adc 1,x
000F0Er 3  85 rr                        sta tmp1+1      ; point to last page of source
000F10r 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
000F12r 3               
000F12r 3                               ; Move the last partial page first
000F12r 3  B4 00                        ldy 0,x         ; length of last page
000F14r 3  F0 0E                        beq @nopartial
000F16r 3               
000F16r 3               @outerloop:
000F16r 3  88                           dey
000F17r 3  F0 07                        beq @finishpage
000F19r 3               
000F19r 3               @innerloop:
000F19r 3  B1 rr                        lda (tmp1),y
000F1Br 3  91 rr                        sta (tmp2),y
000F1Dr 3  88                           dey
000F1Er 3  D0 F9                        bne @innerloop
000F20r 3               
000F20r 3               @finishpage:
000F20r 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
000F22r 3  92 rr                        sta (tmp2)
000F24r 3               
000F24r 3               @nopartial:
000F24r 3  C6 rr                        dec tmp1+1      ; back up to previous pages
000F26r 3  C6 rr                        dec tmp2+1
000F28r 3  D6 01                        dec 1,x
000F2Ar 3  D0 EA                        bne @outerloop
000F2Cr 3               @done:
000F2Cr 3                               ; clear up the stack and leave
000F2Cr 3  8A                           txa
000F2Dr 3  18                           clc
000F2Er 3  69 06                        adc #6
000F30r 3  AA                           tax
000F31r 3               
000F31r 3  60           z_cmove_up:     rts
000F32r 3               
000F32r 3               
000F32r 3               
000F32r 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
000F32r 3               ; ## ":"  auto  ANS core
000F32r 3                       ; """https://forth-standard.org/standard/core/Colon
000F32r 3                       ;
000F32r 3                       ; Use the CREATE routine and fill in the rest by hand.
000F32r 3                       ; """
000F32r 3               
000F32r 3               xt_colon:
000F32r 3                               ; If we're already in the compile state, complain
000F32r 3                               ; and quit
000F32r 3  A5 rr                        lda state
000F34r 3  05 rr                        ora state+1
000F36r 3  F0 05                        beq @1
000F38r 3               
000F38r 3  A9 07                        lda #err_state
000F3Ar 3  4C rr rr                     jmp error
000F3Dr 3               @1:
000F3Dr 3                               ; switch to compile state
000F3Dr 3  C6 rr                        dec state
000F3Fr 3  C6 rr                        dec state+1
000F41r 3               
000F41r 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
000F41r 3                               ; word
000F41r 3  A9 40                        lda #%01000000
000F43r 3  04 rr                        tsb status
000F45r 3               
000F45r 3                               ; CREATE is going to change the DP to point to the new word's
000F45r 3                               ; header. While this is fine for (say) variables, it would mean
000F45r 3                               ; that FIND-NAME etc would find a half-finished word when
000F45r 3                               ; looking in the Dictionary. To prevent this, we save the old
000F45r 3                               ; version of DP and restore it later. The new DP is placed in
000F45r 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000F45r 3  20 rr rr                     jsr current_to_dp
000F48r 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
000F4Ar 3  48                           pha
000F4Br 3  A5 rr                        lda dp
000F4Dr 3  48                           pha
000F4Er 3               
000F4Er 3                               ; Tell create not to print warning for duplicate name.
000F4Er 3  A9 80                        lda #%10000000
000F50r 3  04 rr                        tsb status
000F52r 3               
000F52r 3  20 rr rr                     jsr xt_create
000F55r 3               
000F55r 3                               ; Get the nt (not the xt!) of the new word as described above.
000F55r 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000F55r 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000F58r 3  A5 rr                        lda dp
000F5Ar 3  85 rr                        sta workword
000F5Cr 3  A5 rr                        lda dp+1
000F5Er 3  85 rr                        sta workword+1
000F60r 3               
000F60r 3                               ; Restore original DP
000F60r 3  68                           pla
000F61r 3  85 rr                        sta dp
000F63r 3  68                           pla
000F64r 3  85 rr                        sta dp+1
000F66r 3  20 rr rr                     jsr dp_to_current
000F69r 3               
000F69r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000F69r 3                               ; back up three bytes and overwrite that.
000F69r 3  A5 rr                        lda cp
000F6Br 3  38                           sec
000F6Cr 3  E9 03                        sbc #3
000F6Er 3  85 rr                        sta cp
000F70r 3  B0 02                        bcs @done
000F72r 3  C6 rr                        dec cp+1
000F74r 3               @done:
000F74r 3  60           z_colon:        rts
000F75r 3               
000F75r 3               
000F75r 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000F75r 3               ; ## ":NONAME"  auto  ANS core
000F75r 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000F75r 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000F75r 3                       ; """
000F75r 3               
000F75r 3               xt_colon_noname:
000F75r 3                               ; If we're already in the compile state, complain
000F75r 3                               ; and quit
000F75r 3  A5 rr                        lda state
000F77r 3  05 rr                        ora state+1
000F79r 3  F0 05                        beq @1
000F7Br 3               
000F7Br 3  A9 07                        lda #err_state
000F7Dr 3  4C rr rr                     jmp error
000F80r 3               @1:
000F80r 3                               ; switch to compile state
000F80r 3  C6 rr                        dec state
000F82r 3  C6 rr                        dec state+1
000F84r 3               
000F84r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000F84r 3                               ; a :NONAME word.
000F84r 3  A9 40                        lda #%01000000
000F86r 3  14 rr                        trb status
000F88r 3               
000F88r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000F88r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000F88r 3                               ; nt and they will modify their behavior.
000F88r 3  A5 rr                        lda cp
000F8Ar 3  85 rr                        sta workword
000F8Cr 3  A5 rr                        lda cp+1
000F8Er 3  85 rr                        sta workword+1
000F90r 3               @done:
000F90r 3  60           z_colon_noname:        rts
000F91r 3               
000F91r 3               
000F91r 3               
000F91r 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
000F91r 3               ; ## ","  auto  ANS core
000F91r 3                       ; """https://forth-standard.org/standard/core/Comma
000F91r 3                       ; Store TOS at current place in memory.
000F91r 3                       ;
000F91r 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
000F91r 3                       ; """
000F91r 3               
000F91r 3               xt_comma:
000F91r 3  20 rr rr                     jsr underflow_1
000F94r 3               
000F94r 3  B5 00                        lda 0,x
000F96r 3  92 rr                        sta (cp)
000F98r 3               
000F98r 3  E6 rr                        inc cp
000F9Ar 3  D0 02                        bne @1
000F9Cr 3  E6 rr                        inc cp+1
000F9Er 3               @1:
000F9Er 3  B5 01                        lda 1,x
000FA0r 3  92 rr                        sta (cp)
000FA2r 3               
000FA2r 3  E6 rr                        inc cp
000FA4r 3  D0 02                        bne @done
000FA6r 3  E6 rr                        inc cp+1
000FA8r 3               @done:
000FA8r 3  E8                           inx
000FA9r 3  E8                           inx
000FAAr 3               
000FAAr 3  60           z_comma:        rts
000FABr 3               
000FABr 3               
000FABr 3               
000FABr 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000FABr 3               ; ## "compare"   auto  ANS string
000FABr 3                       ; """https://forth-standard.org/standard/string/COMPARE
000FABr 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000FABr 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000FABr 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000FABr 3                       ; that entirely matches the beginning of the other string, but is
000FABr 3                       ; shorter, is considered less than the longer string.
000FABr 3                       ; """
000FABr 3               
000FABr 3               xt_compare:
000FABr 3  20 rr rr                     jsr underflow_4
000FAEr 3               
000FAEr 3                               ; Load the two string addresses into tmp1 and tmp2.
000FAEr 3  B5 02                        lda 2,x
000FB0r 3  85 rr                        sta tmp2
000FB2r 3  B5 03                        lda 3,x
000FB4r 3  85 rr                        sta tmp2+1
000FB6r 3  B5 06                        lda 6,x
000FB8r 3  85 rr                        sta tmp1
000FBAr 3  B5 07                        lda 7,x
000FBCr 3  85 rr                        sta tmp1+1
000FBEr 3                               ; The counts will be used in-place on the stack.
000FBEr 3               
000FBEr 3               @compare_loop:
000FBEr 3                               ; Check to see if we are out of letters.
000FBEr 3               
000FBEr 3                               ; Check string1
000FBEr 3  B5 04                        lda 4,x
000FC0r 3  15 05                        ora 5,x
000FC2r 3  F0 2C                        beq @str1_done
000FC4r 3               
000FC4r 3                               ; Check string2
000FC4r 3  B5 00                        lda 0,x
000FC6r 3  15 01                        ora 1,x
000FC8r 3  F0 3A                        beq @greater    ; Str2 empty first
000FCAr 3               
000FCAr 3               @check_letter:
000FCAr 3                               ; Both strings have at least one letter left.
000FCAr 3                               ; Check the letters against each other.
000FCAr 3  B2 rr                        lda (tmp1)
000FCCr 3  D2 rr                        cmp (tmp2)
000FCEr 3  90 26                        bcc @less
000FD0r 3  D0 32                        bne @greater
000FD2r 3               @next_letter:
000FD2r 3                               ; Move both tmp pointers and decrement the counts
000FD2r 3                               ; on the stack.
000FD2r 3                               ; Increment tmp1
000FD2r 3  E6 rr                        inc tmp1
000FD4r 3  D0 02                        bne @1
000FD6r 3  E6 rr                        inc tmp1+1
000FD8r 3               @1:
000FD8r 3                               ; Increment tmp2
000FD8r 3  E6 rr                        inc tmp2
000FDAr 3  D0 02                        bne @2
000FDCr 3  E6 rr                        inc tmp2+1
000FDEr 3               @2:
000FDEr 3                               ; Decrement count1 on the stack.
000FDEr 3  B5 04                        lda 4,x
000FE0r 3  D0 02                        bne @3
000FE2r 3  D6 05                        dec 5,x
000FE4r 3               @3:
000FE4r 3  D6 04                        dec 4,x
000FE6r 3               
000FE6r 3                               ; Decrement count2 on the stack.
000FE6r 3  B5 00                        lda 0,x
000FE8r 3  D0 02                        bne @4
000FEAr 3  D6 01                        dec 1,x
000FECr 3               @4:
000FECr 3  D6 00                        dec 0,x
000FEEr 3               
000FEEr 3                               ; Loop around and check again.
000FEEr 3  80 CE                        bra @compare_loop
000FF0r 3               
000FF0r 3               @str1_done:
000FF0r 3                               ; String 1 is out of letters. Check string 2.
000FF0r 3  B5 00                        lda 0,x
000FF2r 3  15 01                        ora 1,x
000FF4r 3  F0 08                        beq @equal      ; Both out of letters
000FF6r 3               
000FF6r 3                               ; Falls into less (str1 is out but str2 has more)
000FF6r 3               @less:
000FF6r 3                               ; Return -1
000FF6r 3  A9 FF                        lda #$FF
000FF8r 3  95 06                        sta 6,x
000FFAr 3  95 07                        sta 7,x
000FFCr 3  80 0C                        bra @done
000FFEr 3               @equal:
000FFEr 3                               ; Return 0
000FFEr 3  74 06                        stz 6,x
001000r 3  74 07                        stz 7,x
001002r 3  80 06                        bra @done
001004r 3               @greater:
001004r 3                               ; Return 1
001004r 3  A9 01                        lda #1
001006r 3  95 06                        sta 6,x
001008r 3  74 07                        stz 7,x
00100Ar 3                               ; Falls into @done
00100Ar 3               @done:
00100Ar 3                               ; Remove all but the result from the stack.
00100Ar 3  8A                           txa
00100Br 3  18                           clc
00100Cr 3  69 06                        adc #6
00100Er 3  AA                           tax
00100Fr 3               
00100Fr 3  60           z_compare:      rts
001010r 3               
001010r 3               
001010r 3               
001010r 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
001010r 3               ; ## "compile,"  auto  ANS core ext
001010r 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
001010r 3                       ; Compile the given xt in the current word definition. It is an
001010r 3                       ; error if we are not in the compile state. Because we are using
001010r 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
001010r 3                       ; the traditional way. By default, native compiled is allowed, unless
001010r 3                       ; there is a NN (Never Native) flag associated. If not, we use the
001010r 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
001010r 3                       ; is too large to be natively coded: If the size is larger than
001010r 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
001010r 3                       ; Native) flag is set, the word is always natively compiled.
001010r 3                       ; """
001010r 3               
001010r 3               xt_compile_comma:
001010r 3  20 rr rr                     jsr underflow_1
001013r 3               
001013r 3                               ; See if this is an Always Native (AN) word by checking the
001013r 3                               ; AN flag. We need nt for this. First, save a copy of xt to
001013r 3                               ; the Return Stack
001013r 3  B5 01                        lda 1,x                 ; MSB
001015r 3  48                           pha
001016r 3  B5 00                        lda 0,x
001018r 3  48                           pha                     ; LSB
001019r 3               
001019r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
00101Cr 3               
00101Cr 3                               ; See if this xt even has an nt.
00101Cr 3  B5 00                        lda 0,x
00101Er 3  15 01                        ora 1,x
001020r 3  D0 03                        bne @check_nt
001022r 3               
001022r 3                               ; No nt in dictionary. Just compile as a JSR.
001022r 3  4C rr rr                     jmp @compile_as_jump
001025r 3               
001025r 3               @check_nt:
001025r 3                               ; put nt away for safe keeping
001025r 3  B5 00                        lda 0,x
001027r 3  85 rr                        sta tmptos
001029r 3  B5 01                        lda 1,x
00102Br 3  85 rr                        sta tmptos+1
00102Dr 3               
00102Dr 3                               ; status byte is one further down
00102Dr 3  F6 00                        inc 0,x
00102Fr 3  D0 02                        bne @1
001031r 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
001033r 3               @1:
001033r 3  A1 00                        lda (0,x)
001035r 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
001037r 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
001039r 3  F0 0D                        beq @compile_check
00103Br 3               
00103Br 3                               ; We're natively compiling no matter what. Get length and
00103Br 3                               ; compile in code. Get the original nt back
00103Br 3  A5 rr                        lda tmptos
00103Dr 3  95 00                        sta 0,x
00103Fr 3  A5 rr                        lda tmptos+1
001041r 3  95 01                        sta 1,x
001043r 3               
001043r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
001046r 3               
001046r 3  80 27                        bra @compile_as_code
001048r 3               
001048r 3               @compile_check:
001048r 3                               ; See if Native Compile is even alowed by checking the NN
001048r 3                               ; flag
001048r 3  A5 rr                        lda tmp3
00104Ar 3  29 08                        and #NN
00104Cr 3  F0 03                        beq @check_size_limit
00104Er 3               
00104Er 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
001051r 3               
001051r 3               @check_size_limit:
001051r 3                               ; Native compile is a legal option, but we need to see what
001051r 3                               ; limit the user set for size (in nc_limit)
001051r 3  A5 rr                        lda tmptos
001053r 3  95 00                        sta 0,x
001055r 3  A5 rr                        lda tmptos+1
001057r 3  95 01                        sta 1,x
001059r 3               
001059r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
00105Cr 3               
00105Cr 3                               ; Check the wordsize MSB against the user-defined limit.
00105Cr 3  B5 01                        lda 1,x
00105Er 3  C5 rr                        cmp nc_limit+1
001060r 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
001062r 3  D0 08                        bne @jumpto_compile_as_jump
001064r 3               
001064r 3                               ; Check the wordsize LSB against the user-defined limit.
001064r 3  B5 00                        lda 0,x
001066r 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
001068r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
00106Ar 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
00106Cr 3               
00106Cr 3               @jumpto_compile_as_jump:
00106Cr 3                               ; If the wordsize is greater than the user-defined
00106Cr 3                               ; limit, it will be compiled as a subroutine jump.
00106Cr 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00106Fr 3               
00106Fr 3               @compile_as_code:
00106Fr 3                               ; We arrive here with the length of the word's code TOS and
00106Fr 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
00106Fr 3                               ; on the data stack
00106Fr 3  CA                           dex
001070r 3  CA                           dex                     ; ( -- u ? )
001071r 3  CA                           dex
001072r 3  CA                           dex                     ; ( -- u ? ? )
001073r 3               
001073r 3  B5 04                        lda 4,x
001075r 3  95 00                        sta 0,x                 ; LSB of u
001077r 3  B5 05                        lda 5,x
001079r 3  95 01                        sta 1,x                 ; ( -- u ? u )
00107Br 3               
00107Br 3  68                           pla
00107Cr 3  95 04                        sta 4,x                 ; LSB of xt
00107Er 3  68                           pla
00107Fr 3  95 05                        sta 5,x                 ; ( -- xt ? u )
001081r 3               
001081r 3  A5 rr                        lda cp                  ; LSB of cp
001083r 3  95 02                        sta 2,x
001085r 3  A5 rr                        lda cp+1
001087r 3  95 03                        sta 3,x                 ; ( -- xt cp u )
001089r 3               
001089r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
001089r 3               
001089r 3                               ; Native compiling allows us to strip the stack antics off
001089r 3                               ; a number of words that use the Return Stack such as >R, R>,
001089r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
001089r 3                               ; xt with the contents of the table
001089r 3  A0 00                        ldy #0
00108Br 3               
00108Br 3               @strip_loop:
00108Br 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
00108Er 3  D5 04                        cmp 4,x                 ; LSB of xt
001090r 3  D0 07                        bne @next_entry
001092r 3               
001092r 3                               ; LSB is the same, test MSB
001092r 3  B9 rr rr                     lda @strip_table+1,y
001095r 3  D5 05                        cmp 5,x
001097r 3  F0 0C                        beq @found_entry
001099r 3               
001099r 3                               ; MSB is not equal. Pretend though that we've come from LSB
001099r 3                               ; so we can use the next step for both cases
001099r 3               @next_entry:
001099r 3                               ; Not a word that needs stripping, so check next entry in table
001099r 3                               ; Let's see if we're done with the table (marked by zero entry)
001099r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
00109Cr 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
00109Fr 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
0010A1r 3               
0010A1r 3  C8                           iny
0010A2r 3  C8                           iny
0010A3r 3  80 E6                        bra @strip_loop
0010A5r 3               @found_entry:
0010A5r 3                               ; This word is one of the ones that needs to have its size
0010A5r 3                               ; adjusted during native compile. We find the values in the
0010A5r 3                               ; next table with the same index, which is Y. However, Y is
0010A5r 3                               ; pointing to the MSB, so we need to go back to the LSB and
0010A5r 3                               ; halve the index before we can use it.
0010A5r 3  98                           tya
0010A6r 3  4A                           lsr
0010A7r 3  A8                           tay
0010A8r 3               
0010A8r 3                               ; Get the adjustment out of the size table. We were clever
0010A8r 3                               ; enough to make sure the cut on both ends of the code is
0010A8r 3                               ; is the same size.
0010A8r 3  B9 rr rr                     lda @strip_size,y
0010ABr 3  85 rr                        sta tmptos              ; save a copy
0010ADr 3               
0010ADr 3                               ; Adjust xt: Start later
0010ADr 3  18                           clc
0010AEr 3  75 04                        adc 4,x
0010B0r 3  95 04                        sta 4,x
0010B2r 3  90 02                        bcc @2
0010B4r 3  F6 05                        inc 5,x                 ; we just care about the carry
0010B6r 3               @2:
0010B6r 3               
0010B6r 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
0010B6r 3                               ; bottom of the code, we have to double the value
0010B6r 3  06 rr                        asl tmptos
0010B8r 3               
0010B8r 3  38                           sec
0010B9r 3  B5 00                        lda 0,x
0010BBr 3  E5 rr                        sbc tmptos
0010BDr 3  95 00                        sta 0,x
0010BFr 3  B0 02                        bcs @3
0010C1r 3  D6 01                        dec 1,x                 ; we just care about the borrow
0010C3r 3               @3:
0010C3r 3                               ; drop through to underflow check stripping
0010C3r 3               
0010C3r 3               @underflow_strip:
0010C3r 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
0010C3r 3               
0010C3r 3                               ; The user can choose to remove the unterflow testing in those
0010C3r 3                               ; words that have the UF flag. This shortens the word by
0010C3r 3                               ; 3 bytes if there is no underflow.
0010C3r 3               
0010C3r 3                               ; See if the user wants underflow stripping turned on
0010C3r 3  A5 rr                        lda uf_strip
0010C5r 3  05 rr                        ora uf_strip+1
0010C7r 3  F0 1C                        beq @specials_done
0010C9r 3               
0010C9r 3                               ; See if this word even contains underflow checking
0010C9r 3  A5 rr                        lda tmp3
0010CBr 3  29 10                        and #UF
0010CDr 3  F0 16                        beq @specials_done
0010CFr 3               
0010CFr 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
0010CFr 3                               ; long. Note hat PICK is a special case.
0010CFr 3               
0010CFr 3                               ; Adjust xt: Start later
0010CFr 3  18                           clc
0010D0r 3  B5 04                        lda 4,x
0010D2r 3  69 03                        adc #3
0010D4r 3  95 04                        sta 4,x
0010D6r 3  90 02                        bcc @4
0010D8r 3  F6 05                        inc 5,x                  ; we just care about the carry
0010DAr 3               @4:
0010DAr 3                               ; Adjust u: End earlier
0010DAr 3  38                           sec
0010DBr 3  B5 00                        lda 0,x
0010DDr 3  E9 03                        sbc #3
0010DFr 3  95 00                        sta 0,x
0010E1r 3  B0 02                        bcs @5
0010E3r 3  D6 01                        dec 1,x                  ; we just care about the borrow
0010E5r 3               @5:
0010E5r 3               
0010E5r 3                               ; --- END OF SPECIAL CASES ---
0010E5r 3               @specials_done:
0010E5r 3                               ; Store size of area to be copied for calculation of
0010E5r 3                               ; new CP. We have to do this after all of the special cases
0010E5r 3                               ; because they might change the size
0010E5r 3  B5 01                        lda 1,x                 ; MSB
0010E7r 3  48                           pha
0010E8r 3  B5 00                        lda 0,x                 ; LSB
0010EAr 3  48                           pha
0010EBr 3               
0010EBr 3                               ; Enough of this, let's move those bytes already! We have
0010EBr 3                               ; ( xt cp u ) on the stack at this point
0010EBr 3  20 rr rr                     jsr xt_move
0010EEr 3               
0010EEr 3                               ; Update CP
0010EEr 3  18                           clc
0010EFr 3  68                           pla                     ; LSB
0010F0r 3  65 rr                        adc cp
0010F2r 3  85 rr                        sta cp
0010F4r 3               
0010F4r 3  68                           pla                     ; MSB
0010F5r 3  65 rr                        adc cp+1
0010F7r 3  85 rr                        sta cp+1
0010F9r 3               
0010F9r 3  80 2C                        bra @done
0010FBr 3               
0010FBr 3               @strip_table:
0010FBr 3                              ; List of words we strip the Return Stack antics from
0010FBr 3                              ; during native compile, zero terminated. The index here
0010FBr 3                              ; must be the same as for the sizes
0010FBr 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
0010FFr 3  rr rr        
001101r 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
001105r 3  00 00        
001107r 3               
001107r 3               @strip_size:
001107r 3                               ; List of bytes to be stripped from the words that get their
001107r 3                               ; Return Stack antics removed during native compile. Index must
001107r 3                               ; be the same as for the xts. Zero terminated.
001107r 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
00110Br 3  06 00        
00110Dr 3               
00110Dr 3               @compile_as_jump:
00110Dr 3                               ; Compile xt as a subroutine jump
00110Dr 3  A9 20                        lda #$20
00110Fr 3  92 rr                        sta (cp)
001111r 3               
001111r 3  A0 01                        ldy #1
001113r 3  68                           pla             ; LSB
001114r 3  91 rr                        sta (cp),y
001116r 3  C8                           iny
001117r 3  68                           pla             ; MSB
001118r 3  91 rr                        sta (cp),y
00111Ar 3               
00111Ar 3                               ; allot space we just used
00111Ar 3  A9 03                        lda #3
00111Cr 3  18                           clc
00111Dr 3  65 rr                        adc cp
00111Fr 3  85 rr                        sta cp
001121r 3  90 02                        bcc @6
001123r 3  E6 rr                        inc cp+1
001125r 3               @6:
001125r 3  E8                           inx             ; drop xt
001126r 3  E8                           inx
001127r 3               @done:
001127r 3               z_compile_comma:
001127r 3  60                           rts
001128r 3               
001128r 3               
001128r 3               
001128r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
001128r 3               ; ## "compile-only"  tested  Tali Forth
001128r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
001128r 3                       ; word.
001128r 3                       ;
001128r 3                       ; The alternative way to do this is to define a word
001128r 3                       ; ?COMPILE that makes sure  we're in compile mode
001128r 3                       ; """
001128r 3               
001128r 3               xt_compile_only:
001128r 3  20 rr rr                     jsr current_to_dp
00112Br 3  A0 01                        ldy #1          ; offset for status byte
00112Dr 3  B1 rr                        lda (dp),y
00112Fr 3  09 01                        ora #CO        ; make sure bit 7 is set
001131r 3  91 rr                        sta (dp),y
001133r 3               
001133r 3  60           z_compile_only: rts
001134r 3               
001134r 3               
001134r 3               
001134r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
001134r 3               ; ## "constant"  auto  ANS core
001134r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
001134r 3                       ;
001134r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
001134r 3                       ; more in assembler and let CREATE do the heavy lifting.
001134r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
001134r 3                       ; a primer on how this works in various Forths. This is the
001134r 3                       ; same code as VALUE in our case.
001134r 3                       ; """
001134r 3               xt_value:
001134r 3               xt_constant:
001134r 3  20 rr rr                     jsr underflow_1
001137r 3               
001137r 3  20 rr rr                     jsr xt_create
00113Ar 3               
00113Ar 3                           	; CREATE by default installs a subroutine jump to DOVAR,
00113Ar 3                               ; but we want DOCONST for constants. Go back two bytes and
00113Ar 3                               ; replace the subroutine jump target
00113Ar 3  38                           sec
00113Br 3  A5 rr                        lda cp
00113Dr 3  E9 02                        sbc #2
00113Fr 3  85 rr                        sta tmp1
001141r 3  A5 rr                        lda cp+1
001143r 3  E9 00                        sbc #0
001145r 3  85 rr                        sta tmp1+1
001147r 3               
001147r 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
001149r 3  92 rr                        sta (tmp1)
00114Br 3  A0 01                        ldy #1
00114Dr 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
00114Fr 3  91 rr                        sta (tmp1),y
001151r 3               
001151r 3                               ; Now we save the constant number itself in the next cell
001151r 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
001154r 3               
001154r 3               adjust_z:
001154r 3                               ; Now the length of the complete word (z_word) has increased by
001154r 3                               ; two. We need to update that number or else words such as SEE
001154r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
001154r 3                               ; VALUE and DEFER
001154r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
001157r 3               
001157r 3                               ; z_word is six bytes further down
001157r 3  B5 00                        lda 0,x
001159r 3  85 rr                        sta tmp1
00115Br 3  B5 01                        lda 1,x
00115Dr 3  85 rr                        sta tmp1+1
00115Fr 3               
00115Fr 3  A0 06                        ldy #6
001161r 3  B1 rr                        lda (tmp1),y
001163r 3  18                           clc
001164r 3  69 02                        adc #2
001166r 3  91 rr                        sta (tmp1),y
001168r 3  C8                           iny
001169r 3  B1 rr                        lda (tmp1),y
00116Br 3  69 00                        adc #0                  ; only need carry
00116Dr 3  91 rr                        sta (tmp1),y
00116Fr 3               
00116Fr 3  E8                           inx
001170r 3  E8                           inx
001171r 3               
001171r 3               z_value:
001171r 3  60           z_constant:     rts
001172r 3               
001172r 3               
001172r 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
001172r 3               ; ## "count"  auto  ANS core
001172r 3                       ; """https://forth-standard.org/standard/core/COUNT
001172r 3                       ; Convert old-style character string to address-length pair. Note
001172r 3                       ; that the length of the string c-addr is stored in character length
001172r 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
001172r 3                       ; though COUNT can also be used to step through a string character by
001172r 3                       ; character.
001172r 3                       ; """
001172r 3               xt_count:
001172r 3  20 rr rr                     jsr underflow_1
001175r 3               
001175r 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
001177r 3  A8                           tay
001178r 3               
001178r 3                               ; move start address up by one
001178r 3  F6 00                        inc 0,x         ; LSB
00117Ar 3  D0 02                        bne @1
00117Cr 3  F6 01                        inc 1,x         ; MSB
00117Er 3               
00117Er 3                               ; save number of characters to stack
00117Er 3               @1:
00117Er 3  98                           tya
00117Fr 3  CA                           dex
001180r 3  CA                           dex
001181r 3  95 00                        sta 0,x         ; LSB
001183r 3  74 01                        stz 1,x         ; MSB, always zero
001185r 3               
001185r 3  60           z_count:        rts
001186r 3               
001186r 3               
001186r 3               ; ## CR ( -- ) "Print a line feed"
001186r 3               ; ## "cr"  auto  ANS core
001186r 3                       ; """https://forth-standard.org/standard/core/CR"""
001186r 3               xt_cr:
001186r 3  A9 0A                        lda #AscLF
001188r 3  20 rr rr                     jsr emit_a
00118Br 3  60           z_cr:           rts
00118Cr 3               
00118Cr 3               
00118Cr 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
00118Cr 3               ; ## "create"  auto  ANS core
00118Cr 3                       ; """https://forth-standard.org/standard/core/CREATE
00118Cr 3                       ;
00118Cr 3                       ; See the drawing in headers.asm for details on the header
00118Cr 3                       ; """
00118Cr 3               
00118Cr 3               xt_create:
00118Cr 3                               ; get string
00118Cr 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00118Fr 3               
00118Fr 3                               ; if we were given an empty string, we complain and quit
00118Fr 3  B5 00                        lda 0,x
001191r 3  15 01                        ora 1,x
001193r 3  D0 05                        bne @got_name
001195r 3               
001195r 3  A9 05                        lda #err_noname
001197r 3  4C rr rr                     jmp error
00119Ar 3               
00119Ar 3               @got_name:
00119Ar 3                               ; Enforce maximal length of string by overwriting the MSB of
00119Ar 3                               ; the length. There is a possible error here: If the string
00119Ar 3                               ; is exactly 255 chars long, then a lot of the following
00119Ar 3                               ; additions will fail because of wrapping
00119Ar 3  74 01                        stz 1,x
00119Cr 3               
00119Cr 3                               ; Check to see if this name already exists.
00119Cr 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
00119Fr 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
0011A2r 3               
0011A2r 3  B5 00                        lda 0,x
0011A4r 3  15 01                        ora 1,x
0011A6r 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
0011A8r 3               
0011A8r 3                               ; This name already exists.  See if we are supposed to print
0011A8r 3                               ; the message for it.
0011A8r 3  E8                           inx                     ; Drop flag (nt) from find-name.
0011A9r 3  E8                           inx
0011AAr 3               
0011AAr 3                               ; Check bit 7
0011AAr 3  24 rr                        bit status
0011ACr 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
0011AEr 3               
0011AEr 3                               ; We aren't supposed to print the redefined message ourselves,
0011AEr 3                               ; but we should indicate that it is redefined (for ; to print
0011AEr 3                               ; later).
0011AEr 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
0011B0r 3  05 rr                        ora status
0011B2r 3  85 rr                        sta status
0011B4r 3  80 18                        bra @process_name
0011B6r 3               
0011B6r 3               @redefined_name:
0011B6r 3                               ; Print the message that the name is redefined.
0011B6r 3  A9 02                        lda #str_redefined
0011B8r 3  20 rr rr                     jsr print_string_no_lf
0011BBr 3               
0011BBr 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
0011BEr 3  20 rr rr                     jsr xt_type
0011C1r 3  20 rr rr                     jsr xt_space
0011C4r 3               
0011C4r 3  80 08                        bra @process_name
0011C6r 3               
0011C6r 3               @new_name:
0011C6r 3  E8                           inx                     ; Drop flag (0) from find-name.
0011C7r 3  E8                           inx
0011C8r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
0011CAr 3  25 rr                        and status
0011CCr 3  85 rr                        sta status
0011CEr 3               
0011CEr 3               @process_name:
0011CEr 3  B5 00                        lda 0,x
0011D0r 3  85 rr                        sta tmp2                ; store length of string in tmp2
0011D2r 3               
0011D2r 3                               ; remember the first free byte of memory as the start of
0011D2r 3                               ; the new word
0011D2r 3  A5 rr                        lda cp
0011D4r 3  85 rr                        sta tmp1
0011D6r 3  A5 rr                        lda cp+1
0011D8r 3  85 rr                        sta tmp1+1
0011DAr 3               
0011DAr 3                               ; We need 8 bytes plus the length of the string for our new header.
0011DAr 3                               ; This is also the offset for the start of the code field (the
0011DAr 3                               ; xt_ label) so we need to remember it. Otherwise, we could
0011DAr 3                               ; just allot the space afterwards
0011DAr 3  B5 00                        lda 0,x
0011DCr 3  18                           clc
0011DDr 3  69 08                        adc #8
0011DFr 3  85 rr                        sta tmp3                ; total header length
0011E1r 3               
0011E1r 3                               ; We need three more bytes for for the hardcoded code field
0011E1r 3                               ; area (CFA), the "payload" of the word which by default will
0011E1r 3                               ; be a subroutine jump to DOVAR
0011E1r 3  18                           clc
0011E2r 3  69 03                        adc #3
0011E4r 3               
0011E4r 3                               ; We overwrite the length of the string returned by PARSE-NAME
0011E4r 3                               ; and then call ALLOT
0011E4r 3  95 00                        sta 0,x
0011E6r 3  74 01                        stz 1,x         ; max header size is 255 chars
0011E8r 3  20 rr rr                     jsr xt_allot    ; ( addr )
0011EBr 3               
0011EBr 3                               ; Get the CURRENT dictionary pointer.
0011EBr 3  20 rr rr                     jsr current_to_dp
0011EEr 3               
0011EEr 3                               ; Now we walk through the header with Y as the index, adding
0011EEr 3                               ; information byte-by-byte
0011EEr 3  A0 00                        ldy #0
0011F0r 3               
0011F0r 3                               ; HEADER BYTE 0: Length of string
0011F0r 3  A5 rr                        lda tmp2
0011F2r 3  91 rr                        sta (tmp1),y
0011F4r 3               
0011F4r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
0011F4r 3                               ; to "never native", user will have to decide if they should
0011F4r 3                               ; be inlined
0011F4r 3  A9 08                        lda #NN
0011F6r 3               
0011F6r 3                               ; Also, words defined by CREATE are marked in the header has
0011F6r 3                               ; having a Code Field Area (CFA), which is a bit tricky for
0011F6r 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
0011F6r 3                               ; correctly with DOES> and CREATE. See the discussion at
0011F6r 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
0011F6r 3  09 20                        ora #HC
0011F8r 3  C8                           iny
0011F9r 3  91 rr                        sta (tmp1),y
0011FBr 3  C8                           iny
0011FCr 3               
0011FCr 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
0011FCr 3                               ; in the Dictionary
0011FCr 3  A5 rr                        lda dp
0011FEr 3  91 rr                        sta (tmp1),y
001200r 3  C8                           iny
001201r 3  A5 rr                        lda dp+1
001203r 3  91 rr                        sta (tmp1),y
001205r 3  C8                           iny
001206r 3               
001206r 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
001206r 3  A5 rr                        lda tmp1+1
001208r 3  85 rr                        sta dp+1
00120Ar 3  A5 rr                        lda tmp1
00120Cr 3  85 rr                        sta dp
00120Er 3               
00120Er 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
00120Er 3                               ; This begins after the header so we take the length of the
00120Er 3                               ; header, which we cleverly saved in tmp3, and use it as an
00120Er 3                               ; offset to the address of the start of the word. We come here
00120Er 3                               ; with tmp1 in A
00120Er 3  18                           clc
00120Fr 3  65 rr                        adc tmp3        ; add total header length
001211r 3  91 rr                        sta (tmp1),y
001213r 3  48                           pha             ; we need this in the next step
001214r 3  C8                           iny
001215r 3               
001215r 3  A5 rr                        lda tmp1+1
001217r 3  69 00                        adc #0          ; only need the carry
001219r 3  91 rr                        sta (tmp1),y
00121Br 3  C8                           iny
00121Cr 3               
00121Cr 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
00121Cr 3                               ; we execute a jump to the DOVAR routine, so we need to move three
00121Cr 3                               ; bytes down, and then one more byte so that the z_ label points
00121Cr 3                               ; to the (still fictional) RTS instruction for correct compilation
00121Cr 3  68                           pla             ; LSB of "z_" address
00121Dr 3  18                           clc
00121Er 3  69 03                        adc #3
001220r 3  91 rr                        sta (tmp1),y
001222r 3               
001222r 3  88                           dey             ; get the MSB of xt back
001223r 3  B1 rr                        lda (tmp1),y
001225r 3  69 00                        adc #0          ; only need the carry
001227r 3  C8                           iny
001228r 3  C8                           iny
001229r 3  91 rr                        sta (tmp1),y
00122Br 3  C8                           iny
00122Cr 3               
00122Cr 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
00122Cr 3                               ; length in tmp2. We subtract 8 from the address so we can
00122Cr 3                               ; use the same loop index, which is already 8 byte ahead at
00122Cr 3                               ; this point
00122Cr 3  B5 00                        lda 0,x
00122Er 3  38                           sec
00122Fr 3  E9 08                        sbc #8
001231r 3  85 rr                        sta tmptos
001233r 3               
001233r 3  B5 01                        lda 1,x
001235r 3  E9 00                        sbc #0          ; only need carry
001237r 3  85 rr                        sta tmptos+1
001239r 3               
001239r 3               @name_loop:
001239r 3  B1 rr                        lda (tmptos),y
00123Br 3               
00123Br 3                               ; Make sure it goes into the dictionary in lower case.
00123Br 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
00123Dr 3  B0 07                        bcs @store_name
00123Fr 3  C9 41                        cmp #$41        ; ASCII 'A'
001241r 3  90 03                        bcc @store_name
001243r 3               
001243r 3                               ; An uppercase letter has been located. Make it
001243r 3                               ; lowercase.
001243r 3  18                           clc
001244r 3  69 20                        adc #$20
001246r 3               
001246r 3                               ; Fall into @store_name.
001246r 3               
001246r 3               @store_name:
001246r 3  91 rr                        sta (tmp1),y
001248r 3  C8                           iny
001249r 3  C6 rr                        dec tmp2
00124Br 3  D0 EC                        bne @name_loop
00124Dr 3               
00124Dr 3                               ; After thename string comes the code field, starting at the
00124Dr 3                               ; current xt of this word, which is initially a jump to the
00124Dr 3                               ; subroutine to DOVAR. We code this jump by hand
00124Dr 3  A9 20                        lda #$20        ; opcode of JSR
00124Fr 3  91 rr                        sta (tmp1),y
001251r 3  C8                           iny
001252r 3  A9 rr                        lda #<dovar
001254r 3  91 rr                        sta (tmp1),y
001256r 3  C8                           iny
001257r 3  A9 rr                        lda #>dovar
001259r 3  91 rr                        sta (tmp1),y
00125Br 3               
00125Br 3                               ; Update the CURRENT wordlist with the new DP.
00125Br 3                               ; We do this down here because this routine uses Y.
00125Br 3  20 rr rr                     jsr dp_to_current
00125Er 3               
00125Er 3                               ; And we're done. Restore stack
00125Er 3  E8                           inx
00125Fr 3  E8                           inx
001260r 3               
001260r 3  60           z_create:       rts
001261r 3               
001261r 3               
001261r 3               
001261r 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
001261r 3               ; ## "d-"  auto  ANS double
001261r 3                       ; """https://forth-standard.org/standard/double/DMinus"""
001261r 3               
001261r 3               xt_d_minus:
001261r 3  20 rr rr                     jsr underflow_4 ; two double numbers
001264r 3               
001264r 3  38                           sec
001265r 3               
001265r 3  B5 06                        lda 6,x         ; LSB of lower word
001267r 3  F5 02                        sbc 2,x
001269r 3  95 06                        sta 6,x
00126Br 3               
00126Br 3  B5 07                        lda 7,x         ; MSB of lower word
00126Dr 3  F5 03                        sbc 3,x
00126Fr 3  95 07                        sta 7,x
001271r 3               
001271r 3  B5 04                        lda 4,x         ; LSB of upper word
001273r 3  F5 00                        sbc 0,x
001275r 3  95 04                        sta 4,x
001277r 3               
001277r 3  B5 05                        lda 5,x         ; MSB of upper word
001279r 3  F5 01                        sbc 1,x
00127Br 3  95 05                        sta 5,x
00127Dr 3               
00127Dr 3  E8                           inx
00127Er 3  E8                           inx
00127Fr 3  E8                           inx
001280r 3  E8                           inx
001281r 3               
001281r 3  60           z_d_minus:      rts
001282r 3               
001282r 3               
001282r 3               
001282r 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
001282r 3               ; ## "d+"  auto  ANS double
001282r 3                       ; """https://forth-standard.org/standard/double/DPlus"""
001282r 3               
001282r 3               xt_d_plus:
001282r 3  20 rr rr                     jsr underflow_4 ; two double numbers
001285r 3               
001285r 3  18                           clc
001286r 3  B5 02                        lda 2,x         ; LSB of lower word
001288r 3  75 06                        adc 6,x
00128Ar 3  95 06                        sta 6,x
00128Cr 3               
00128Cr 3  B5 03                        lda 3,x         ; MSB of lower word
00128Er 3  75 07                        adc 7,x
001290r 3  95 07                        sta 7,x
001292r 3               
001292r 3  B5 00                        lda 0,x         ; LSB of upper word
001294r 3  75 04                        adc 4,x
001296r 3  95 04                        sta 4,x
001298r 3               
001298r 3  B5 01                        lda 1,x         ; MSB of upper word
00129Ar 3  75 05                        adc 5,x
00129Cr 3  95 05                        sta 5,x
00129Er 3               
00129Er 3  E8                           inx
00129Fr 3  E8                           inx
0012A0r 3  E8                           inx
0012A1r 3  E8                           inx
0012A2r 3               
0012A2r 3  60           z_d_plus:       rts
0012A3r 3               
0012A3r 3               
0012A3r 3               
0012A3r 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
0012A3r 3               ; ## "d>s"  auto  ANS double
0012A3r 3                       ; """https://forth-standard.org/standard/double/DtoS
0012A3r 3                       ; Though this is basically just DROP, we keep it
0012A3r 3                       ; separate so we can test for underflow
0012A3r 3                       ; """
0012A3r 3               
0012A3r 3               xt_d_to_s:
0012A3r 3  20 rr rr                     jsr underflow_2
0012A6r 3               
0012A6r 3  E8                           inx
0012A7r 3  E8                           inx
0012A8r 3               
0012A8r 3  60           z_d_to_s:       rts
0012A9r 3               
0012A9r 3               
0012A9r 3               
0012A9r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
0012A9r 3               ; ## "dabs"  auto  ANS double
0012A9r 3                       ; """https://forth-standard.org/standard/double/DABS"""
0012A9r 3               
0012A9r 3               xt_dabs:
0012A9r 3  20 rr rr                     jsr underflow_2 ; double number
0012ACr 3               
0012ACr 3  B5 01                        lda 1,x         ; MSB of high cell
0012AEr 3  10 17                        bpl @done       ; positive, we get off light
0012B0r 3               
0012B0r 3                               ; negative, calculate 0 - d
0012B0r 3  A0 00                        ldy #0
0012B2r 3  38                           sec
0012B3r 3               
0012B3r 3  98                           tya
0012B4r 3  F5 02                        sbc 2,x         ; LSB of low cell
0012B6r 3  95 02                        sta 2,x
0012B8r 3               
0012B8r 3  98                           tya
0012B9r 3  F5 03                        sbc 3,x         ; MSB of low cell
0012BBr 3  95 03                        sta 3,x
0012BDr 3               
0012BDr 3  98                           tya
0012BEr 3  F5 00                        sbc 0,x         ; LSB of high cell
0012C0r 3  95 00                        sta 0,x
0012C2r 3               
0012C2r 3  98                           tya
0012C3r 3  F5 01                        sbc 1,x         ; MSB of high cell
0012C5r 3  95 01                        sta 1,x
0012C7r 3               @done:
0012C7r 3  60           z_dabs:         rts
0012C8r 3               
0012C8r 3               
0012C8r 3               
0012C8r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
0012C8r 3               ; ## "decimal"  auto  ANS core
0012C8r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
0012C8r 3               xt_decimal:
0012C8r 3  A9 0A                        lda #10
0012CAr 3  85 rr                        sta base
0012CCr 3  64 rr                        stz base+1              ; paranoid
0012CEr 3               
0012CEr 3  60           z_decimal:      rts
0012CFr 3               
0012CFr 3               
0012CFr 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
0012CFr 3               ; ## "defer"  auto  ANS core ext
0012CFr 3                       ; """https://forth-standard.org/standard/core/DEFER
0012CFr 3                       ; Reserve an name that can be linked to various xt by IS.
0012CFr 3                       ;
0012CFr 3                       ; The ANS reference implementation is
0012CFr 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
0012CFr 3                       ; But we use this routine as a low-level word so things go faster
0012CFr 3               
0012CFr 3               xt_defer:
0012CFr 3  20 rr rr                     jsr xt_create
0012D2r 3               
0012D2r 3                               ; CREATE by default installs a subroutine jump to DOVAR,
0012D2r 3                               ; but we actually want DODEFER this time. Go back two
0012D2r 3                               ; bytes and repace the subroutine jump target
0012D2r 3  A5 rr                        lda cp          ; LSB
0012D4r 3  38                           sec
0012D5r 3  E9 02                        sbc #2
0012D7r 3  85 rr                        sta tmp1
0012D9r 3               
0012D9r 3  A5 rr                        lda cp+1        ; MSB
0012DBr 3  E9 00                        sbc #0          ; we only care about the borrow
0012DDr 3  85 rr                        sta tmp1+1
0012DFr 3               
0012DFr 3                               ; Save the target address
0012DFr 3  A0 00                        ldy #0
0012E1r 3  A9 rr                        lda #<dodefer   ; LSB
0012E3r 3  91 rr                        sta (tmp1),y
0012E5r 3  C8                           iny
0012E6r 3  A9 rr                        lda #>dodefer   ; MSB
0012E8r 3  91 rr                        sta (tmp1),y
0012EAr 3               
0012EAr 3               
0012EAr 3                               ; DODEFER executes the next address it finds after
0012EAr 3                               ; its call. As default, we include the error
0012EAr 3                               ; "Defer not defined"
0012EAr 3  A9 rr                        lda #<defer_error
0012ECr 3  92 rr                        sta (cp)
0012EEr 3  E6 rr                        inc cp
0012F0r 3  D0 02                        bne @1
0012F2r 3  E6 rr                        inc cp+1
0012F4r 3               @1:
0012F4r 3  A9 rr                        lda #>defer_error
0012F6r 3  92 rr                        sta (cp)
0012F8r 3  E6 rr                        inc cp
0012FAr 3  D0 02                        bne @2
0012FCr 3  E6 rr                        inc cp+1
0012FEr 3               @2:
0012FEr 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
001301r 3               
001301r 3  60           z_defer:        rts
001302r 3               
001302r 3               
001302r 3               
001302r 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
001302r 3               ; ## "defer@"  auto  ANS core ext
001302r 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
001302r 3               
001302r 3               xt_defer_fetch:
001302r 3                               ; No underflow checking as >BODY does it.
001302r 3  20 rr rr                     jsr xt_to_body
001305r 3  20 rr rr                     jsr xt_fetch
001308r 3  60           z_defer_fetch:  rts
001309r 3               
001309r 3               
001309r 3               
001309r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
001309r 3               ; ## "defer!"  auto  ANS core ext
001309r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
001309r 3               
001309r 3               xt_defer_store:
001309r 3                               ; No underflow checking as >BODY and ! do it.
001309r 3  20 rr rr                     jsr xt_to_body
00130Cr 3  20 rr rr                     jsr xt_store
00130Fr 3  60           z_defer_store:  rts
001310r 3               
001310r 3               
001310r 3               
001310r 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
001310r 3               ; ## "definitions" auto ANS search
001310r 3               xt_definitions:
001310r 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
001312r 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
001314r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
001316r 3  91 rr                        sta (up),y
001318r 3  60           z_definitions:  rts
001319r 3               
001319r 3               
001319r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
001319r 3               ; ## "depth"  auto  ANS core
001319r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
001319r 3               xt_depth:
001319r 3  A9 rr                        lda #dsp0
00131Br 3  86 rr                        stx tmpdsp
00131Dr 3  38                           sec
00131Er 3  E5 rr                        sbc tmpdsp
001320r 3               
001320r 3                               ; divide by two because each cell is two bytes
001320r 3  4A                           lsr
001321r 3               
001321r 3  CA                           dex
001322r 3  CA                           dex
001323r 3  95 00                        sta 0,x
001325r 3  74 01                        stz 1,x
001327r 3               
001327r 3  60           z_depth:        rts
001328r 3               
001328r 3               
001328r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
001328r 3               ; ## "digit?"  auto  Tali Forth
001328r 3                       ; """Inspired by the pForth instruction DIGIT, see
001328r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001328r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
001328r 3                       ; pForth, we get the base (radix) ourselves instead of having the
001328r 3                       ; user provide it. There is no standard name for this routine, which
001328r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
001328r 3                       ; """
001328r 3               
001328r 3               xt_digit_question:
001328r 3  20 rr rr                     jsr underflow_1
00132Br 3               
00132Br 3                               ; one way or another, we're going to need room for the
00132Br 3                               ; flag on the stack
00132Br 3  CA                           dex
00132Cr 3  CA                           dex
00132Dr 3  74 00                        stz 0,x                 ; default flag is failure
00132Fr 3  74 01                        stz 1,x
001331r 3  74 03                        stz 3,x                 ; paranoid
001333r 3               
001333r 3                               ; Check the character, now in the LSB of NOS. First, make
001333r 3                               ; sure we're not below the ASCII code for "0"
001333r 3  B5 02                        lda 2,x
001335r 3  C9 30                        cmp #'0'
001337r 3  90 23                        bcc @done               ; failure flag already set
001339r 3               
001339r 3                               ; Next, see if we are below "9", because that would make
001339r 3                               ; this a normal number
001339r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
00133Br 3  90 12                        bcc @checkbase
00133Dr 3               
00133Dr 3                               ; Well, then let's see if this is the gap between "9" and "A"
00133Dr 3                               ; so we can treat the whole range as a number
00133Dr 3  C9 41                        cmp #'A'
00133Fr 3  90 1B                        bcc @done               ; failure flag is already set
001341r 3               
001341r 3                               ; probably a letter, so we make sure it is uppercase
001341r 3  C9 61                        cmp #'a'
001343r 3  90 07                        bcc @case_done          ; not lower case, too low
001345r 3  C9 7B                        cmp #'z'+1
001347r 3  B0 03                        bcs @case_done          ; not lower case, too high
001349r 3               
001349r 3  18                           clc                     ; just right
00134Ar 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
00134Cr 3               
00134Cr 3               @case_done:
00134Cr 3                               ; get rid of the gap between "9" and "A" so we can treat
00134Cr 3                               ; the whole range as one number
00134Cr 3  38                           sec
00134Dr 3  E9 07                        sbc #7                  ; fall through to @checkbase
00134Fr 3               
00134Fr 3               @checkbase:
00134Fr 3                               ; we have a number, now see if it falls inside the range
00134Fr 3                               ; provided by BASE
00134Fr 3  38                           sec
001350r 3  E9 30                        sbc #'0'                 ; this is also the conversion step
001352r 3  C5 rr                        cmp base
001354r 3  B0 06                        bcs @done               ; already have false flag
001356r 3               
001356r 3                               ; Found a legal number
001356r 3  95 02                        sta 2,x                 ; put number in NOS
001358r 3  D6 00                        dec 0,x                 ; set success flag
00135Ar 3  D6 01                        dec 1,x
00135Cr 3               
00135Cr 3               @done:
00135Cr 3               z_digit_question:
00135Cr 3  60                           rts
00135Dr 3               
00135Dr 3               
00135Dr 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
00135Dr 3               ; ## "disasm"  tested  Tali Forth
00135Dr 3                       ; """Convert a segment of memory to assembler output. This
00135Dr 3                       ; word is vectored so people can add their own disassembler.
00135Dr 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
00135Dr 3                       ; code, see the section on The Disassembler in the manual and
00135Dr 3                       ; the file disassembler.asm for more details.
00135Dr 3                       ; """
00135Dr 3               xt_disasm:
00135Dr 3  20 rr rr                     jsr underflow_2
001360r 3                           .ifdef disassembler
001360r 3                               jsr disassembler
001360r 3                           .endif
001360r 3               
001360r 3  60           z_disasm:       rts
001361r 3               
001361r 3               
001361r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
001361r 3               ; ## "dnegate"  auto  ANS double
001361r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
001361r 3               xt_dnegate:
001361r 3  20 rr rr                     jsr underflow_2 ; double number
001364r 3               
001364r 3  A0 00             		ldy #0
001366r 3  38                           sec
001367r 3               
001367r 3  98                           tya
001368r 3  F5 02                        sbc 2,x         ; LSB of low cell
00136Ar 3  95 02                        sta 2,x
00136Cr 3               
00136Cr 3  98                           tya
00136Dr 3  F5 03                        sbc 3,x         ; MSB of low cell
00136Fr 3  95 03                        sta 3,x
001371r 3               
001371r 3  98                           tya
001372r 3  F5 00                        sbc 0,x         ; LSB of high cell
001374r 3  95 00                        sta 0,x
001376r 3               
001376r 3  98                           tya
001377r 3  F5 01                        sbc 1,x         ; MSB of high cell
001379r 3  95 01                        sta 1,x
00137Br 3               
00137Br 3  60           z_dnegate:      rts
00137Cr 3               
00137Cr 3               
00137Cr 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
00137Cr 3               ; ## "?do"  auto  ANS core ext
00137Cr 3                       ; """https://forth-standard.org/standard/core/qDO"""
00137Cr 3               xt_question_do:
00137Cr 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
00137Cr 3                               ; to mark which is which
00137Cr 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
00137Er 3  85 rr                        sta tmp1
001380r 3  80 02                        bra do_common           ; skip flag for DO
001382r 3               
001382r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
001382r 3               ; ## "do"  auto  ANS core
001382r 3                       ; """https://forth-standard.org/standard/core/DO
001382r 3                       ;
001382r 3                       ; Compile-time part of DO. Could be realized in Forth as
001382r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
001382r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
001382r 3                       ; a routine that pushes the end address to the Return Stack at run
001382r 3                       ; time. This is based on a suggestion by Garth Wilson, see
001382r 3                       ; the Control Flow section of the manual for details.
001382r 3                       ;
001382r 3                       ; This may not be native compile. Don't check for a stack underflow
001382r 3                       ; """
001382r 3               
001382r 3               xt_do:
001382r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
001382r 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
001384r 3               do_common:
001384r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
001384r 3                               ; compile the address we need to LDA at runtime
001384r 3  CA                           dex
001385r 3  CA                           dex
001386r 3  A5 rr                        lda cp
001388r 3  95 00                        sta 0,x                 ; LSB
00138Ar 3  A5 rr                        lda cp+1
00138Cr 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
00138Er 3               
00138Er 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
00138Er 3                               ; replace by the actual LDA/PHA instructions
00138Er 3  A9 05                        lda #5                  ; we don't really care about the value,
001390r 3  A8                           tay                     ; so we use 5 to be tricky
001391r 3               @loop:
001391r 3  91 rr                        sta (cp),y
001393r 3  88                           dey
001394r 3  10 FB                        bpl @loop
001396r 3               
001396r 3                               ; update CP
001396r 3  1A                           inc             ; we used 5 as a dummy value, this is why
001397r 3  18                           clc
001398r 3  65 rr                        adc cp
00139Ar 3  85 rr                        sta cp
00139Cr 3  90 02                        bcc @1
00139Er 3  E6 rr                        inc cp+1
0013A0r 3               @1:
0013A0r 3                               ; compile the (?DO) portion of ?DO if appropriate
0013A0r 3  A5 rr                        lda tmp1
0013A2r 3  F0 17                        beq @compile_do
0013A4r 3               
0013A4r 3                               ; We came from ?DO, so compile its runtime first. We do
0013A4r 3                               ; this with a quick loop because we know it has to be
0013A4r 3                               ; Always Native anyway
0013A4r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
0013A6r 3  5A                           phy             ; save counter to calculate new CP
0013A7r 3               @2:
0013A7r 3  B9 rr rr                     lda question_do_runtime,y
0013AAr 3  91 rr                        sta (cp),y
0013ACr 3  88                           dey
0013ADr 3  10 F8                        bpl @2
0013AFr 3               
0013AFr 3                               ; adjust CP
0013AFr 3  68                           pla             ; retrieve counter
0013B0r 3  18                           clc
0013B1r 3  65 rr                        adc cp
0013B3r 3  85 rr                        sta cp
0013B5r 3  A5 rr                        lda cp+1
0013B7r 3  69 00                        adc #0          ; only care about carry
0013B9r 3  85 rr                        sta cp+1        ; fall through to @compile_do
0013BBr 3               
0013BBr 3               @compile_do:
0013BBr 3                               ; compile runtime part of DO.
0013BBr 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
0013BDr 3  5A                           phy             ; save counter to calculate new CP
0013BEr 3               @3:
0013BEr 3  B9 rr rr                     lda do_runtime,y
0013C1r 3  91 rr                        sta (cp),y
0013C3r 3  88                           dey
0013C4r 3  10 F8                        bpl @3
0013C6r 3               
0013C6r 3                               ; adjust CP
0013C6r 3  68                           pla             ; retrieve counter
0013C7r 3  18                           clc
0013C8r 3  65 rr                        adc cp
0013CAr 3  85 rr                        sta cp
0013CCr 3  A5 rr                        lda cp+1
0013CEr 3  69 00                        adc #0          ; only care about carry
0013D0r 3  85 rr                        sta cp+1
0013D2r 3               
0013D2r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
0013D2r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
0013D2r 3                               ; do with the HERE we're saving for LEAVE
0013D2r 3  CA                           dex
0013D3r 3  CA                           dex
0013D4r 3  A5 rr                        lda cp          ; LSB
0013D6r 3  95 00                        sta 0,x
0013D8r 3  A5 rr                        lda cp+1        ; MSB
0013DAr 3  95 01                        sta 1,x
0013DCr 3               z_question_do:
0013DCr 3  60           z_do:           rts
0013DDr 3               
0013DDr 3               
0013DDr 3               do_runtime:
0013DDr 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
0013DDr 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
0013DDr 3                       ; the FIG Forth loop (you can see which version you have by running
0013DDr 3                       ; a loop with start and limit as the same value, for instance
0013DDr 3                       ; 0 0 DO -- these will walk through the number space). We use a
0013DDr 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
0013DDr 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
0013DDr 3                       ; for further discussion of this. The source given there for
0013DDr 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
0013DDr 3                       ; in some Forths. Usually, we would define this as a separate word
0013DDr 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
0013DDr 3                       ; However, we can do it faster if we just copy the bytes
0013DDr 3                       ; of this routine with a simple loop in DO.
0013DDr 3                       ; """
0013DDr 3                               ; First step: create fudge factor (FUFA) by subtracting the
0013DDr 3                               ; limit from $8000, the number that will trip the overflow
0013DDr 3                               ; flag
0013DDr 3  38                           sec
0013DEr 3  A9 00                        lda #0
0013E0r 3  F5 02                        sbc 2,x         ; LSB of limit
0013E2r 3  95 02                        sta 2,x         ; save FUFA for later use
0013E4r 3               
0013E4r 3  A9 80                        lda #$80
0013E6r 3  F5 03                        sbc 3,x         ; MSB of limit
0013E8r 3  95 03                        sta 3,x         ; save FUFA for later use
0013EAr 3  48                           pha             ; FUFA replaces limit on R stack
0013EBr 3  B5 02                        lda 2,x         ; LSB of limit
0013EDr 3  48                           pha
0013EEr 3               
0013EEr 3                               ; Second step: index is FUFA plus original index
0013EEr 3  18                           clc
0013EFr 3  B5 00                        lda 0,x         ; LSB of original index
0013F1r 3  75 02                        adc 2,x         ; add LSB of FUFA
0013F3r 3  95 00                        sta 0,x
0013F5r 3  B5 01                        lda 1,x         ; MSB of orginal index
0013F7r 3  75 03                        adc 3,x         ; add MSB of FUFA
0013F9r 3  48                           pha
0013FAr 3  B5 00                        lda 0,x         ; LSB of index
0013FCr 3  48                           pha
0013FDr 3               
0013FDr 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
0013FDr 3                               ; use it later. Clean the Data Stack
0013FDr 3  E8                           inx
0013FEr 3  E8                           inx
0013FFr 3  E8                           inx
001400r 3  E8                           inx             ; no RTS because this is copied into code
001401r 3               do_runtime_end:
001401r 3               
001401r 3               question_do_runtime:
001401r 3               
001401r 3                       ; """This is called (?DO) in some Forths. See the explanation at
001401r 3                       ; do_runtime for the background on this design
001401r 3                       ; """
001401r 3                               ; see if TOS and NOS are equal. Change this to assembler
001401r 3                               ; for speed
001401r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
001404r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
001407r 3               
001407r 3  B5 00                        lda 0,x
001409r 3  15 01                        ora 1,x
00140Br 3  F0 06                        beq @do_do
00140Dr 3               
00140Dr 3                               ; We're equal, so dump everything and jump beyond the loop.
00140Dr 3                               ; But first, dump six entries off of the Data Stack
00140Dr 3  8A                           txa
00140Er 3  18                           clc
00140Fr 3  69 06                        adc #6
001411r 3  AA                           tax
001412r 3               
001412r 3                               ; Then abort the whole loop
001412r 3  60                           rts
001413r 3               @do_do:
001413r 3  E8                           inx             ; clear flag from EQUAL off stack
001414r 3  E8                           inx             ; no RTS because this is copied into code
001415r 3               question_do_runtime_end:
001415r 3               
001415r 3               
001415r 3               
001415r 3               ; ## DOES ( -- ) "Add payload when defining new words"
001415r 3               ; ## "does>"  auto  ANS core
001415r 3                       ; """https://forth-standard.org/standard/core/DOES
001415r 3                       ; Create the payload for defining new defining words. See
001415r 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
001415r 3                       ; the Developer Guide in the manual for a discussion of
001415r 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
001415r 3                       ; """
001415r 3               
001415r 3               xt_does:
001415r 3                               ; compile a subroutine jump to runtime of DOES>
001415r 3  A0 rr                        ldy #>does_runtime
001417r 3  A9 rr                        lda #<does_runtime
001419r 3  20 rr rr                     jsr cmpl_subroutine
00141Cr 3               
00141Cr 3                               ; compile a subroutine jump to DODOES. In traditional
00141Cr 3                               ; terms, this is the Code Field Area (CFA) of the new
00141Cr 3                               ; word
00141Cr 3  A0 rr                        ldy #>dodoes
00141Er 3  A9 rr                        lda #<dodoes
001420r 3  20 rr rr                     jsr cmpl_subroutine
001423r 3               
001423r 3  60           z_does:         rts
001424r 3               
001424r 3               
001424r 3               does_runtime:
001424r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
001424r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
001424r 3                       ; address that contains a subroutine jump to DODOES. We don't
001424r 3                       ; jump to DODOES directly because we need to work our magic with
001424r 3                       ; the return addresses. This routine is also known as "(DOES)" in
001424r 3                       ; other Forths
001424r 3                       ; """
001424r 3               
001424r 3  7A                           ply             ; LSB
001425r 3  68                           pla             ; MSB
001426r 3               
001426r 3  C8                           iny
001427r 3  D0 01                        bne @1
001429r 3  1A                           inc
00142Ar 3               @1:
00142Ar 3  84 rr                        sty tmp1
00142Cr 3  85 rr                        sta tmp1+1
00142Er 3               
00142Er 3                               ; CREATE has also already modified the DP to point to the new
00142Er 3                               ; word. We have no idea which instructions followed the CREATE
00142Er 3                               ; command if there is a DOES> so the CP could point anywhere
00142Er 3                               ; by now. The address of the word's xt is four bytes down.
00142Er 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
001431r 3  A5 rr                        lda dp
001433r 3  18                           clc
001434r 3  69 04                        adc #4
001436r 3  85 rr                        sta tmp2
001438r 3  A5 rr                        lda dp+1
00143Ar 3  69 00                        adc #0          ; we only care about the carry
00143Cr 3  85 rr                        sta tmp2+1
00143Er 3               
00143Er 3                               ; Now we get that address and add one byte to skip over the JSR
00143Er 3                               ; opcode
00143Er 3  B2 rr                        lda (tmp2)
001440r 3  18                           clc
001441r 3  69 01                        adc #1
001443r 3  85 rr                        sta tmp3
001445r 3  A0 01                        ldy #1
001447r 3  B1 rr                        lda (tmp2),y
001449r 3  69 00                        adc #0          ; we only care about the carry
00144Br 3  85 rr                        sta tmp3+1
00144Dr 3               
00144Dr 3                               ; Replace the DOVAR address with our own
00144Dr 3  A5 rr                        lda tmp1        ; LSB
00144Fr 3  92 rr                        sta (tmp3)
001451r 3  A5 rr                        lda tmp1+1
001453r 3  91 rr                        sta (tmp3),y    ; Y is still 1
001455r 3               
001455r 3                               ; Since we removed the return address that brought us here, we
001455r 3                               ; go back to whatever the main routine was. Otherwise, we we
001455r 3                               ; smash into the subroutine jump to DODOES.
001455r 3  60                           rts
001456r 3               
001456r 3               
001456r 3               
001456r 3               ; ## DOT ( u -- ) "Print TOS"
001456r 3               ; ## "."  auto  ANS core
001456r 3                       ; """https://forth-standard.org/standard/core/d"""
001456r 3               
001456r 3               xt_dot:
001456r 3  20 rr rr                     jsr underflow_1
001459r 3               
001459r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
00145Cr 3  20 rr rr                     jsr xt_abs                      ; ( n u )
00145Fr 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
001462r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
001465r 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
001468r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
00146Br 3  20 rr rr                     jsr xt_sign                     ; ( ud )
00146Er 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
001471r 3  20 rr rr                     jsr xt_type
001474r 3  20 rr rr                     jsr xt_space
001477r 3               
001477r 3  60           z_dot:          rts
001478r 3               
001478r 3               
001478r 3               
001478r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
001478r 3               ; ## ".("  auto  ANS core
001478r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
001478r 3               
001478r 3               xt_dot_paren:
001478r 3                               ; Put a right paren on the stack.
001478r 3  CA                           dex
001479r 3  CA                           dex
00147Ar 3  A9 29                        lda #41     ; Right parenthesis
00147Cr 3  95 00                        sta 0,x
00147Er 3  74 01                        stz 1,x
001480r 3               
001480r 3  20 rr rr                     jsr xt_parse
001483r 3  20 rr rr                     jsr xt_type
001486r 3               
001486r 3  60           z_dot_paren:    rts
001487r 3               
001487r 3               
001487r 3               
001487r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
001487r 3               ; ## ".""  auto  ANS core ext
001487r 3                       ; """https://forth-standard.org/standard/core/Dotq
001487r 3                       ; Compile string that is printed during run time. ANS Forth wants
001487r 3                       ; this to be compile-only, even though everybody and their friend
001487r 3                       ; uses it for everything. We follow the book here, and recommend
001487r 3                       ; `.(` for general printing.
001487r 3                       ; """
001487r 3               
001487r 3               xt_dot_quote:
001487r 3                               ; we let S" do the heavy lifting. Since we're in
001487r 3                               ; compile mode, it will save the string and reproduce it
001487r 3                               ; during runtime
001487r 3  20 rr rr                     jsr xt_s_quote
00148Ar 3               
00148Ar 3                               ; We then let TYPE do the actual printing
00148Ar 3  A0 rr                        ldy #>xt_type
00148Cr 3  A9 rr                        lda #<xt_type
00148Er 3  20 rr rr                     jsr cmpl_subroutine
001491r 3               
001491r 3  60           z_dot_quote:    rts
001492r 3               
001492r 3               
001492r 3               
001492r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
001492r 3               ; ## ".r"  tested  ANS core ext
001492r 3                       ; """https://forth-standard.org/standard/core/DotR
001492r 3                       ;
001492r 3                       ; Based on the Forth code
001492r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
001492r 3                       ; """
001492r 3               
001492r 3               xt_dot_r:
001492r 3  20 rr rr                     jsr underflow_2
001495r 3               
001495r 3  20 rr rr                     jsr xt_to_r
001498r 3  20 rr rr                     jsr xt_dup
00149Br 3  20 rr rr                     jsr xt_abs
00149Er 3  20 rr rr                     jsr xt_zero
0014A1r 3  20 rr rr                     jsr xt_less_number_sign
0014A4r 3  20 rr rr                     jsr xt_number_sign_s
0014A7r 3  20 rr rr                     jsr xt_rot
0014AAr 3  20 rr rr                     jsr xt_sign
0014ADr 3  20 rr rr                     jsr xt_number_sign_greater
0014B0r 3  20 rr rr                     jsr xt_r_from
0014B3r 3  20 rr rr                     jsr xt_over
0014B6r 3  20 rr rr                     jsr xt_minus
0014B9r 3  20 rr rr                     jsr xt_spaces
0014BCr 3  20 rr rr                     jsr xt_type
0014BFr 3               
0014BFr 3  60           z_dot_r:        rts
0014C0r 3               
0014C0r 3               
0014C0r 3               
0014C0r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
0014C0r 3               ; ## ".s"  tested  ANS tools
0014C0r 3                       ; """https://forth-standard.org/standard/tools/DotS
0014C0r 3                       ; Print content of Data Stack non-distructively. We follow the format
0014C0r 3                       ; of Gforth and print the number of elements first in brackets,
0014C0r 3                       ; followed by the Data Stack content (if any).
0014C0r 3                       ;
0014C0r 3                       ; Since this is for humans, we don't have to worry about speed.
0014C0r 3                       ; """
0014C0r 3               
0014C0r 3               xt_dot_s:
0014C0r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
0014C3r 3               
0014C3r 3                               ; Print stack depth in brackets
0014C3r 3  A9 3C                        lda #$3c        ; ASCII for "<"
0014C5r 3  20 rr rr                     jsr emit_a
0014C8r 3               
0014C8r 3                               ; We keep a copy of the number of the things on the stack
0014C8r 3                               ; to use as a counter later down. This assumes that there
0014C8r 3                               ; are less than 255 elements on the stack
0014C8r 3  B5 00                        lda 0,x
0014CAr 3  48                           pha
0014CBr 3               
0014CBr 3                               ; print unsigned number without the trailing space
0014CBr 3  CA                           dex             ; DUP
0014CCr 3  CA                           dex
0014CDr 3  95 00                        sta 0,x
0014CFr 3  74 01                        stz 1,x
0014D1r 3               
0014D1r 3  20 rr rr                     jsr print_u
0014D4r 3               
0014D4r 3  A9 3E                        lda #$3e        ; ASCII for ">"
0014D6r 3  20 rr rr                     jsr emit_a
0014D9r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
0014DBr 3  20 rr rr                     jsr emit_a
0014DEr 3               
0014DEr 3  E8                           inx
0014DFr 3  E8                           inx
0014E0r 3               
0014E0r 3                               ; There will be lots of cases where the stack is empty. If that
0014E0r 3                               ; is so, get out of here quickly
0014E0r 3  E0 rr                        cpx #dsp0
0014E2r 3  F0 1E                        beq @done
0014E4r 3               
0014E4r 3               @have_stack:
0014E4r 3                               ; We have at least one element on the stack. The depth of the
0014E4r 3                               ; stack is on the stack, we can use it as a counter. We go
0014E4r 3                               ; from bottom to top
0014E4r 3  7A                           ply
0014E5r 3               
0014E5r 3  A9 rr                        lda #dsp0-1     ; go up one to avoid garbage
0014E7r 3  85 rr                        sta tmp3
0014E9r 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
0014EBr 3               @loop:
0014EBr 3  CA                           dex
0014ECr 3  CA                           dex
0014EDr 3               
0014EDr 3  B2 rr                        lda (tmp3)
0014EFr 3  95 01                        sta 1,x
0014F1r 3  C6 rr                        dec tmp3
0014F3r 3               
0014F3r 3  B2 rr                        lda (tmp3)
0014F5r 3  95 00                        sta 0,x
0014F7r 3  C6 rr                        dec tmp3
0014F9r 3  5A                           phy
0014FAr 3               
0014FAr 3  20 rr rr                     jsr xt_dot
0014FDr 3               
0014FDr 3  7A                           ply
0014FEr 3  88                           dey
0014FFr 3  D0 EA                        bne @loop
001501r 3               
001501r 3  48                           pha             ; dummy to balance stack
001502r 3               @done:
001502r 3  68                           pla
001503r 3  60           z_dot_s:        rts
001504r 3               
001504r 3               
001504r 3               
001504r 3               ; ## D_DOT ( d -- ) "Print double"
001504r 3               ; ## "d."  tested  ANS double
001504r 3                       ; """http://forth-standard.org/standard/double/Dd"""
001504r 3                       ;
001504r 3                       ; From the Forth code:
001504r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
001504r 3                       ; """
001504r 3               
001504r 3               xt_d_dot:
001504r 3  20 rr rr                     jsr underflow_2
001507r 3               
001507r 3  20 rr rr                     jsr xt_tuck
00150Ar 3  20 rr rr                     jsr xt_dabs
00150Dr 3  20 rr rr                     jsr xt_less_number_sign
001510r 3  20 rr rr                     jsr xt_number_sign_s
001513r 3  20 rr rr                     jsr xt_rot
001516r 3  20 rr rr                     jsr xt_sign
001519r 3  20 rr rr                     jsr xt_number_sign_greater
00151Cr 3  20 rr rr                     jsr xt_type
00151Fr 3  20 rr rr                     jsr xt_space
001522r 3               
001522r 3  60           z_d_dot:        rts
001523r 3               
001523r 3               
001523r 3               
001523r 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
001523r 3               ; ## "d.r"  tested  ANS double
001523r 3                       ; """http://forth-standard.org/standard/double/DDotR"""
001523r 3                       ; Based on the Forth code
001523r 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
001523r 3                       ; """
001523r 3               
001523r 3               xt_d_dot_r:
001523r 3  20 rr rr                     jsr underflow_3
001526r 3                               ; From the forth code:
001526r 3  20 rr rr                     jsr xt_to_r
001529r 3  20 rr rr                     jsr xt_tuck
00152Cr 3  20 rr rr                     jsr xt_dabs
00152Fr 3  20 rr rr                     jsr xt_less_number_sign
001532r 3  20 rr rr                     jsr xt_number_sign_s
001535r 3  20 rr rr                     jsr xt_rot
001538r 3  20 rr rr                     jsr xt_sign
00153Br 3  20 rr rr                     jsr xt_number_sign_greater
00153Er 3  20 rr rr                     jsr xt_r_from
001541r 3  20 rr rr                     jsr xt_over
001544r 3  20 rr rr                     jsr xt_minus
001547r 3  20 rr rr                     jsr xt_spaces
00154Ar 3  20 rr rr                     jsr xt_type
00154Dr 3               
00154Dr 3  60           z_d_dot_r:      rts
00154Er 3               
00154Er 3               
00154Er 3               
00154Er 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
00154Er 3               ; ## "drop"  auto  ANS core
00154Er 3                       ; """https://forth-standard.org/standard/core/DROP"""
00154Er 3               xt_drop:
00154Er 3  20 rr rr                     jsr underflow_1
001551r 3               
001551r 3  E8                           inx
001552r 3  E8                           inx
001553r 3               
001553r 3  60           z_drop:         rts
001554r 3               
001554r 3               
001554r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
001554r 3               ; ## "dump"  tested  ANS tools
001554r 3                       ; """https://forth-standard.org/standard/tools/DUMP
001554r 3                       ;
001554r 3                       ; DUMP's exact output is defined as "implementation dependent".
001554r 3                       ; This is in assembler because it is
001554r 3                       ; useful for testing and development, so we want to have it work
001554r 3                       ; as soon as possible. Uses TMP2
001554r 3                       ; """
001554r 3               
001554r 3               xt_dump:
001554r 3  20 rr rr                     jsr underflow_2
001557r 3               @row:
001557r 3                               ; start counter for 16 numbers per row
001557r 3  A0 10                        ldy #16
001559r 3               
001559r 3                               ; We use TMP2 as the index for the ASCII characters
001559r 3                               ; that we print at the and of the hex block. We
001559r 3                               ; start saving them at HERE (CP)
001559r 3  64 rr                        stz tmp2
00155Br 3               
00155Br 3  20 rr rr                     jsr xt_cr
00155Er 3               
00155Er 3                               ; print address number
00155Er 3  B5 03                        lda 3,x
001560r 3  20 rr rr                     jsr byte_to_ascii
001563r 3  B5 02                        lda 2,x
001565r 3  20 rr rr                     jsr byte_to_ascii
001568r 3               
001568r 3  20 rr rr                     jsr xt_space
00156Br 3  20 rr rr                     jsr xt_space
00156Er 3               @loop:
00156Er 3                               ; if there are zero bytes left to display, we're done
00156Er 3  B5 00                        lda 0,x
001570r 3  15 01                        ora 1,x
001572r 3  F0 39                        beq @all_printed
001574r 3               
001574r 3                               ; dump the contents
001574r 3  A1 02                        lda (2,x)
001576r 3  48                           pha                     ; byte_to_ascii destroys A
001577r 3  20 rr rr                     jsr byte_to_ascii
00157Ar 3  20 rr rr                     jsr xt_space
00157Dr 3  68                           pla
00157Er 3               
00157Er 3                               ; Handle ASCII printing
00157Er 3  20 rr rr                     jsr is_printable
001581r 3  B0 02                        bcs @printable
001583r 3  A9 2E                        lda #'.'                 ; Print dot if not printable
001585r 3               @printable:
001585r 3  5A                           phy                     ; save counter
001586r 3  A4 rr                        ldy tmp2
001588r 3  91 rr                        sta (cp),y
00158Ar 3  E6 rr                        inc tmp2
00158Cr 3  7A                           ply
00158Dr 3               
00158Dr 3                               ; extra space after eight bytes
00158Dr 3  C0 09                        cpy #9
00158Fr 3  D0 03                        bne @next_char
001591r 3  20 rr rr                     jsr xt_space
001594r 3               
001594r 3               @next_char:
001594r 3  F6 02                        inc 2,x
001596r 3  D0 02                        bne @counter
001598r 3  F6 03                        inc 3,x
00159Ar 3               
00159Ar 3               @counter:
00159Ar 3                               ; loop counter
00159Ar 3  B5 00                        lda 0,x
00159Cr 3  D0 02                        bne @1
00159Er 3  D6 01                        dec 1,x
0015A0r 3               @1:
0015A0r 3  D6 00                        dec 0,x
0015A2r 3  88                           dey
0015A3r 3  D0 C9                        bne @loop               ; next byte
0015A5r 3               
0015A5r 3                               ; Done with one line, print the ASCII version of these
0015A5r 3                               ; characters
0015A5r 3  20 rr rr                     jsr xt_space
0015A8r 3  20 rr rr                     jsr print_ascii
0015ABr 3               
0015ABr 3  80 AA                        bra @row                ; new row
0015ADr 3               
0015ADr 3               @all_printed:
0015ADr 3                               ; See if there are any ASCII characters in the buffer
0015ADr 3                               ; left to print
0015ADr 3  A5 rr                        lda tmp2
0015AFr 3  F0 06                        beq @done
0015B1r 3               
0015B1r 3                               ; In theory, we could try to make the ASCII part line
0015B1r 3                               ; up with the line before it. But that is a hassle (we
0015B1r 3                               ; use three bytes for each missed hex entry, and
0015B1r 3                               ; then there is the gap after eight entries) and it
0015B1r 3                               ; makes it harder to read. We settle for one extra
0015B1r 3                               ; space instead for the moment
0015B1r 3  20 rr rr                     jsr xt_space
0015B4r 3  20 rr rr                     jsr print_ascii
0015B7r 3               @done:
0015B7r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
0015BAr 3  60           z_dump:         rts
0015BBr 3               
0015BBr 3               
0015BBr 3               print_ascii:
0015BBr 3                               ; Print the ASCII characters that we have saved from
0015BBr 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
0015BBr 3                               ; is not compiled (DUMP is probably never compiled anyway)
0015BBr 3                               ; but we keep it inside the scope of DUMP.
0015BBr 3  A0 00                        ldy #0
0015BDr 3               @ascii_loop:
0015BDr 3  B1 rr                        lda (cp),y
0015BFr 3  20 rr rr                     jsr emit_a
0015C2r 3  C8                           iny
0015C3r 3               
0015C3r 3                               ; extra space after eight chars
0015C3r 3  C0 08                        cpy #8
0015C5r 3  D0 03                        bne @1
0015C7r 3  20 rr rr                     jsr xt_space
0015CAr 3               @1:
0015CAr 3  C6 rr                        dec tmp2
0015CCr 3  D0 EF                        bne @ascii_loop
0015CEr 3               
0015CEr 3  60                           rts
0015CFr 3               
0015CFr 3               
0015CFr 3               
0015CFr 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
0015CFr 3               ; ## "dup"  auto  ANS core
0015CFr 3                       ; """https://forth-standard.org/standard/core/DUP"""
0015CFr 3               xt_dup:
0015CFr 3  20 rr rr                     jsr underflow_1
0015D2r 3               
0015D2r 3  CA                           dex
0015D3r 3  CA                           dex
0015D4r 3               
0015D4r 3  B5 02                        lda 2,x         ; LSB
0015D6r 3  95 00                        sta 0,x
0015D8r 3  B5 03                        lda 3,x         ; MSB
0015DAr 3  95 01                        sta 1,x
0015DCr 3               
0015DCr 3  60           z_dup:          rts
0015DDr 3               
0015DDr 3               
0015DDr 3               ; ## ED ( -- u ) "Line-based editor"
0015DDr 3               ; ## "ed"  fragment  Tali Forth
0015DDr 3                       ; """Start the line-based editor ed6502. See separate file
0015DDr 3                       ; ed.asm or the manual for details.
0015DDr 3                       ; """
0015DDr 3               xt_ed:
0015DDr 3                           .ifdef ed6502
0015DDr 3                               jsr ed6502      ; kept in separate file
0015DDr 3                           .endif
0015DDr 3               
0015DDr 3  60           z_ed:           rts
0015DEr 3               
0015DEr 3               
0015DEr 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
0015DEr 3               ; ## "editor-wordlist"  tested  Tali Editor
0015DEr 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
0015DEr 3                       ; words to the search order so they can be used.  This will need
0015DEr 3                       ; to be done before any of the words marked "Tali Editor" can be
0015DEr 3                       ; used.  See the tutorial on Wordlists and the Search Order for
0015DEr 3                       ; more information.
0015DEr 3               
0015DEr 3                       ;
0015DEr 3                       ; This is a dummy entry, the code is shared with ONE
0015DEr 3                       ; """
0015DEr 3               
0015DEr 3               
0015DEr 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
0015DEr 3               ; ## "else"  auto  ANS core
0015DEr 3                       ; """http://forth-standard.org/standard/core/ELSE
0015DEr 3                       ;
0015DEr 3                       ; The code is shared with ENDOF
0015DEr 3                       ; """
0015DEr 3               
0015DEr 3               xt_else:
0015DEr 3               xt_endof:
0015DEr 3                               ; Put an unconditional branch.
0015DEr 3  A0 rr                        ldy #>branch_runtime
0015E0r 3  A9 rr                        lda #<branch_runtime
0015E2r 3  20 rr rr                     jsr cmpl_subroutine
0015E5r 3               
0015E5r 3                               ; Put the address of the branch address on the stack.
0015E5r 3  20 rr rr                     jsr xt_here
0015E8r 3               
0015E8r 3                               ; Use zero for the branch address for now.
0015E8r 3                               ; THEN will fill it in later.
0015E8r 3  20 rr rr                     jsr xt_zero
0015EBr 3  20 rr rr                     jsr xt_comma
0015EEr 3               
0015EEr 3                               ; Get the address to jump to (just after the
0015EEr 3                               ; unconditional branch) for the IF to jump to
0015EEr 3                               ; when false.
0015EEr 3  20 rr rr                     jsr xt_here
0015F1r 3  20 rr rr                     jsr xt_rot
0015F4r 3               
0015F4r 3                               ; Update the original if 0branch address.
0015F4r 3  20 rr rr                     jsr xt_store
0015F7r 3               z_else:
0015F7r 3               z_endof:
0015F7r 3  60                           rts
0015F8r 3               
0015F8r 3               
0015F8r 3               
0015F8r 3               branch_runtime:
0015F8r 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
0015F8r 3                       ; formally part of a separate word BRANCH which was later removed.
0015F8r 3                       ; """
0015F8r 3               
0015F8r 3                               ; The address on the Return Stack points to the last byte
0015F8r 3                               ; of the JSR address, one byte below the branch literal
0015F8r 3  68                           pla
0015F9r 3  85 rr                        sta tmpbranch
0015FBr 3  68                           pla
0015FCr 3  85 rr                        sta tmpbranch+1
0015FEr 3               
0015FEr 3                               ; Keep in mind: the address we just popped points one byte
0015FEr 3                               ; lower than the branch literal we want to grab
0015FEr 3  A0 01                        ldy #1
001600r 3  B1 rr                        lda (tmpbranch),y  ; LSB
001602r 3  85 rr                        sta tmp1
001604r 3  C8                           iny
001605r 3  B1 rr                        lda (tmpbranch),y  ; MSB
001607r 3  85 rr                        sta tmp1+1
001609r 3               
001609r 3  6C rr rr                     jmp (tmp1)
00160Cr 3               
00160Cr 3               
00160Cr 3               
00160Cr 3               ; ## EMIT ( char -- ) "Print character to current output"
00160Cr 3               ; ## "emit"  auto  ANS core
00160Cr 3                       ; """https://forth-standard.org/standard/core/EMIT
00160Cr 3                       ; Run-time default for EMIT. The user can revector this by changing
00160Cr 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
00160Cr 3                       ; do not check to see if we have been given a valid ASCII character.
00160Cr 3                       ; Don't make this native compile.
00160Cr 3                       ; """
00160Cr 3               
00160Cr 3               xt_emit:
00160Cr 3  20 rr rr                     jsr underflow_1
00160Fr 3               
00160Fr 3  B5 00                        lda 0,x
001611r 3  E8                           inx
001612r 3  E8                           inx
001613r 3               
001613r 3               emit_a:
001613r 3                       ; We frequently want to print the character in A without fooling
001613r 3                       ; around with the Data Stack. This is emit_a's job, which still
001613r 3                       ; allows the output to be vectored. Call it with JSR as you
001613r 3                       ; would XT_EMIT
001613r 3  6C rr rr                     jmp (output)            ; JSR/RTS
001616r 3               
001616r 3               z_emit:         ; never reached
001616r 3               
001616r 3               
001616r 3               
001616r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
001616r 3               ; ## "empty-buffers"  tested  ANS block ext
001616r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
001616r 3               xt_empty_buffers:
001616r 3                               ; Set the buffer status to empty.
001616r 3  A0 2C                        ldy #buffstatus_offset
001618r 3  A9 00                        lda #0
00161Ar 3  91 rr                        sta (up),y      ; Only LSB is used.
00161Cr 3               z_empty_buffers:
00161Cr 3  60                           rts
00161Dr 3               
00161Dr 3               
00161Dr 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
00161Dr 3               ; ## "endcase"  auto  ANS core ext
00161Dr 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
00161Dr 3               
00161Dr 3               xt_endcase:
00161Dr 3                               ; Postpone DROP to remove the item
00161Dr 3                               ; being checked.
00161Dr 3  A0 rr                        ldy #>xt_drop
00161Fr 3  A9 rr                        lda #<xt_drop
001621r 3  20 rr rr                     jsr cmpl_subroutine
001624r 3               
001624r 3                               ; There are a number of address (of branches that need their
001624r 3                               ; jump addressed filled in with the address of right here).
001624r 3                               ; Keep calling THEN to deal with them until we reach the
001624r 3                               ; 0 that CASE put on the stack at the beginning.
001624r 3               @endcase_loop:
001624r 3                               ; Check for 0 on the stack.
001624r 3  B5 00                        lda 0,x
001626r 3  15 01                        ora 1,x
001628r 3  F0 05                        beq @done
00162Ar 3               
00162Ar 3  20 rr rr                     jsr xt_then
00162Dr 3  80 F5                        bra @endcase_loop
00162Fr 3               @done:
00162Fr 3                               ; Remove the 0 from the stack.
00162Fr 3  E8                           inx
001630r 3  E8                           inx
001631r 3  60           z_endcase:      rts
001632r 3               
001632r 3               
001632r 3               
001632r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
001632r 3               ; ## "endof"  auto  ANS core ext
001632r 3                       ; """http://forth-standard.org/standard/core/ENDOF
001632r 3                       ; This is a dummy entry, the code is shared with ELSE
001632r 3                       ; """
001632r 3               
001632r 3               
001632r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
001632r 3               ; ## "environment?"  auto  ANS core
001632r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
001632r 3                       ;
001632r 3                       ; By ANS definition, we use upper-case strings here, see the
001632r 3                       ; string file for details. This can be realized as a high-level
001632r 3                       ; Forth word as
001632r 3                       ;
001632r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
001632r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
001632r 3                       ; HEX
001632r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
001632r 3                       ; CASE
001632r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
001632r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
001632r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
001632r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
001632r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
001632r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
001632r 3                       ; S" MAX-D"              STRING_OF
001632r 3                                                    ; 7FFFFFFF. TRUE ENDOF
001632r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
001632r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
001632r 3                       ; S" MAX-UD"             STRING_OF
001632r 3                                                    ; FFFFFFFF. TRUE ENDOF
001632r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
001632r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
001632r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
001632r 3                       ; ENDCASE ;
001632r 3                       ;
001632r 3                       ; but that uses lots of memory and increases the start up time. This
001632r 3                       ; word is rarely used so we can try to keep it short at the expense
001632r 3                       ; of speed.
001632r 3                       ; """
001632r 3               
001632r 3               xt_environment_q:
001632r 3  20 rr rr                     jsr underflow_1
001635r 3               
001635r 3                               ; This code is table-driven: We walk through the list of
001635r 3                               ; strings until we find one that matches, and then we take
001635r 3                               ; the equivalent data from the results table. This is made
001635r 3                               ; a bit harder by the fact that some of these return a
001635r 3                               ; double-cell number and some a single-cell one.
001635r 3               
001635r 3                               ; We will walk through the table with variables that return
001635r 3                               ; a single-cell result
001635r 3  A0 00                        ldy #00                 ; counter for table
001637r 3               
001637r 3                               ; We use a flag on the the stack to signal if we have a single-cell
001637r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
001637r 3                               ; double-cell.
001637r 3  5A                           phy
001638r 3               @table_loop:
001638r 3                               ; We arrived here with the address of the string to be checked
001638r 3                               ; on the stack. We make a copy. Index is in Y
001638r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
00163Br 3               
00163Br 3                               ; We do our work on the TOS to speed things up
00163Br 3  CA                           dex
00163Cr 3  CA                           dex                     ; ( addr u addr u ? )
00163Dr 3               
00163Dr 3                               ; Get address of string to check from table
00163Dr 3  B9 rr rr                     lda env_table_single,y
001640r 3  95 00                        sta 0,x
001642r 3  C8                           iny
001643r 3  B9 rr rr                     lda env_table_single,y
001646r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
001648r 3  C8                           iny
001649r 3               
001649r 3                               ; See if this is the last entry. The LSB is still in A
001649r 3  15 00                        ora 0,x
00164Br 3  F0 4D                        beq @table_done
00164Dr 3               
00164Dr 3                               ; We have a string entry. The address there is stored in
00164Dr 3                               ; old-style address format, that is, the first byte is the
00164Dr 3                               ; length of the string
00164Dr 3  5A                           phy                     ; save Y, which is used by COUNT
00164Er 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
001651r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
001654r 3  7A                           ply
001655r 3               
001655r 3                               ; If we found a match (flag is zero -- COMPARE is weird
001655r 3                               ; that way), return the result
001655r 3  B5 00                        lda 0,x
001657r 3  15 01                        ora 1,x
001659r 3  F0 04                        beq @got_result
00165Br 3               
00165Br 3                               ; Flag is not zero, so not a perfect match, so try next
00165Br 3                               ; word
00165Br 3  E8                           inx                     ; DROP, now ( addr u )
00165Cr 3  E8                           inx
00165Dr 3               
00165Dr 3  80 D9                        bra @table_loop
00165Fr 3               
00165Fr 3               @got_result:
00165Fr 3                               ; We arrive here with ( addr u -1 ) and know that we've found
00165Fr 3                               ; a match. The index of the match+2 is in Y.
00165Fr 3  E8                           inx                     ; drop flag, now ( addr u )
001660r 3  E8                           inx
001661r 3  88                           dey                     ; go back to index we had
001662r 3  88                           dey
001663r 3               
001663r 3                               ; See if this is a single-cell word.
001663r 3  68                           pla
001664r 3  D0 0D                        bne @double_result
001666r 3               
001666r 3                               ; Single-cell result
001666r 3  B9 rr rr                     lda env_results_single,y
001669r 3  95 02                        sta 2,x
00166Br 3  C8                           iny
00166Cr 3  B9 rr rr                     lda env_results_single,y
00166Fr 3  95 03                        sta 3,x                 ; ( res u )
001671r 3               
001671r 3  80 1F                        bra @set_flag
001673r 3               
001673r 3               @double_result:
001673r 3                               ; This is a double-celled result, which means we have to
001673r 3                               ; fool around with the index some more. We also need a
001673r 3                               ; further cell on the stack
001673r 3  CA                           dex                     ; ( addr u ? )
001674r 3  CA                           dex
001675r 3               
001675r 3                               ; We have 11 single-cell words we check, plus the 0000 as
001675r 3                               ; a marker for the end of the table, so we arrive here
001675r 3                               ; with Y as 22 or more. To get the index for the double-
001675r 3                               ; cell words, we move the result
001675r 3  98                           tya
001676r 3  38                           sec
001677r 3  E9 18                        sbc #24
001679r 3               
001679r 3                               ; We have four bytes per entry in the table, but the index
001679r 3                               ; keeps increasing by two, so we only have to multiply by
001679r 3                               ; two (shift left once) to get the right result
001679r 3  0A                           asl
00167Ar 3  A8                           tay
00167Br 3               
00167Br 3  B9 rr rr                     lda env_results_double,y
00167Er 3  95 02                        sta 2,x
001680r 3  C8                           iny
001681r 3  B9 rr rr                     lda env_results_double,y
001684r 3  95 03                        sta 3,x                 ; ( res u ? )
001686r 3  C8                           iny
001687r 3               
001687r 3  B9 rr rr                     lda env_results_double,y
00168Ar 3  95 04                        sta 4,x
00168Cr 3  C8                           iny
00168Dr 3  B9 rr rr                     lda env_results_double,y
001690r 3  95 05                        sta 5,x                 ; ( res res ? )
001692r 3               
001692r 3                               ; fall through to @set_flag
001692r 3               @set_flag:
001692r 3  A9 FF                        lda #$ff
001694r 3  95 00                        sta 0,x
001696r 3  95 01                        sta 1,x                 ; ( res f )
001698r 3               
001698r 3  80 14                        bra @done
00169Ar 3               @table_done:
00169Ar 3                               ; We're done with a table, because the entry was a zero.
00169Ar 3                               ; We arrive here with ( addr u addr u 0 )
00169Ar 3               
00169Ar 3                               ; We take the flag from stack and increase it by one. If the
00169Ar 3                               ; flag is zero, we have just completed the single-cell number
00169Ar 3                               ; strings, so we in increase the flag and try again. Otherwise,
00169Ar 3                               ; we're done with the double-cell table without having found
00169Ar 3                               ; a match, and we're done
00169Ar 3  68                           pla
00169Br 3  D0 09                        bne @no_match
00169Dr 3               
00169Dr 3                               ; Flag is zero, increase it to one and start over to check
00169Dr 3                               ; double-cell values
00169Dr 3  1A                           inc
00169Er 3  48                           pha
00169Fr 3               
00169Fr 3  8A                           txa
0016A0r 3  18                           clc
0016A1r 3  69 06                        adc #6                  ; skip six bytes
0016A3r 3  AA                           tax                     ; ( addr u )
0016A4r 3               
0016A4r 3  80 92                        bra @table_loop
0016A6r 3               @no_match:
0016A6r 3                               ; Bummer, not found. We arrive here with
0016A6r 3                               ; ( addr u addr u 0 ) and need to return just a zero
0016A6r 3  8A                           txa
0016A7r 3  18                           clc
0016A8r 3  69 0A                        adc #10
0016AAr 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
0016ABr 3               
0016ABr 3  20 rr rr                     jsr xt_false
0016AEr 3               @done:
0016AEr 3               z_environment_q:
0016AEr 3  60                           rts
0016AFr 3               
0016AFr 3               
0016AFr 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
0016AFr 3               ; results and one for the double-celled results. The zero cell at the
0016AFr 3               ; end of each table marks its, uh, end. The strings themselves are defined
0016AFr 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
0016AFr 3               ; have to adapt the result code for double printout, where we subtract 22
0016AFr 3               ; (two bytes each single-cell string and two bytes for the end-of-table
0016AFr 3               ; marker 0000
0016AFr 3               env_table_single:
0016AFr 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
0016B3r 3  rr rr rr rr  
0016B7r 3  rr rr        
0016B9r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
0016BDr 3  rr rr rr rr  
0016C1r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
0016C5r 3  00 00        
0016C7r 3               
0016C7r 3               env_table_double:
0016C7r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
0016CBr 3  00 00        
0016CDr 3               
0016CDr 3               env_results_single:
0016CDr 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
0016CFr 3  FF 00                .word $00FF     ; /HOLD
0016D1r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
0016D3r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
0016D5r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
0016D7r 3  FF 00                .word $00FF     ; MAX-CHAR
0016D9r 3  FF 7F                .word $7FFF     ; MAX-N
0016DBr 3  FF FF                .word $FFFF     ; MAX-U
0016DDr 3  80 00                .word $0080     ; RETURN-STACK-CELLS
0016DFr 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
0016E1r 3  09 00                .word $0009     ; WORDLISTS
0016E3r 3               
0016E3r 3               env_results_double:
0016E3r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
0016E7r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
0016EBr 3               
0016EBr 3               
0016EBr 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
0016EBr 3               ; ## "="  auto  ANS core
0016EBr 3                       ; """https://forth-standard.org/standard/core/Equal"""
0016EBr 3               
0016EBr 3               xt_equal:
0016EBr 3  20 rr rr                     jsr underflow_2
0016EEr 3               
0016EEr 3  B5 00                        lda 0,x                 ; LSB
0016F0r 3  D5 02                        cmp 2,x
0016F2r 3  D0 0A                        bne @false
0016F4r 3               
0016F4r 3  B5 01                        lda 1,x                 ; MSB
0016F6r 3  D5 03                        cmp 3,x
0016F8r 3  D0 04                        bne @false
0016FAr 3               
0016FAr 3  A9 FF                        lda #$ff
0016FCr 3  80 02                        bra @done
0016FEr 3               
0016FEr 3  A9 00        @false:         lda #0                  ; drop thru to done
001700r 3               
001700r 3  95 02        @done:          sta 2,x
001702r 3  95 03                        sta 3,x
001704r 3               
001704r 3  E8                           inx
001705r 3  E8                           inx
001706r 3               
001706r 3  60           z_equal:        rts
001707r 3               
001707r 3               
001707r 3               
001707r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
001707r 3               ; ## "blank"  auto  ANS string
001707r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
001707r 3               xt_blank:
001707r 3                               ; We don't check for underflow here because
001707r 3                               ; we deal with that in FILL
001707r 3  CA                           dex
001708r 3  CA                           dex
001709r 3  A9 20                        lda #AscSP
00170Br 3  95 00                        sta 0,x
00170Dr 3  74 01                        stz 1,x
00170Fr 3               
00170Fr 3  80 06                        bra xt_fill     ; skip over code for ERASE
001711r 3               
001711r 3               
001711r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
001711r 3               ; ## "erase"  auto  ANS core ext
001711r 3                       ; """https://forth-standard.org/standard/core/ERASE
001711r 3                       ; Note that ERASE works with "address" units
001711r 3                       ; (bytes), not cells.
001711r 3                       ; """
001711r 3               
001711r 3               xt_erase:
001711r 3                               ; We don't check for underflow here because
001711r 3                               ; we deal with that in FILL
001711r 3  CA                           dex
001712r 3  CA                           dex
001713r 3  74 00                        stz 0,x
001715r 3  74 01                        stz 1,x
001717r 3               
001717r 3                               ; fall through to FILL
001717r 3               
001717r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
001717r 3               ; ## "fill"  auto  ANS core
001717r 3                       ; """https://forth-standard.org/standard/core/FILL
001717r 3                       ; Fill u bytes of memory with char starting at addr. Note that
001717r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
001717r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
001717r 3                       ; happens when we reach the end of the address space
001717r 3                       ; """
001717r 3               xt_fill:
001717r 3  20 rr rr                     jsr underflow_3
00171Ar 3               
00171Ar 3                               ; We use tmp1 to hold the address
00171Ar 3  B5 04                        lda 4,x         ; LSB
00171Cr 3  85 rr                        sta tmp1
00171Er 3  B5 05                        lda 5,x
001720r 3  85 rr                        sta tmp1+1
001722r 3               
001722r 3                               ; We use tmp2 to hold the counter
001722r 3  B5 02                        lda 2,x
001724r 3  85 rr                        sta tmp2
001726r 3  B5 03                        lda 3,x
001728r 3  85 rr                        sta tmp2+1
00172Ar 3               
00172Ar 3                               ; We use Y to hold the character
00172Ar 3  B5 00                        lda 0,x
00172Cr 3  A8                           tay
00172Dr 3               @loop:
00172Dr 3                               ; Unfortunately, we also need to make sure that we don't
00172Dr 3                               ; write further than the end of the RAM. So RAM_END must
00172Dr 3                               ; be larger or equal to the current address
00172Dr 3  A9 80                        lda #>ram_end           ; MSB
00172Fr 3  C5 rr                        cmp tmp1+1
001731r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
001733r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
001735r 3               
001735r 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
001737r 3  C5 rr                        cmp tmp1
001739r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
00173Br 3               
00173Br 3               @check_counter:
00173Br 3                               ; See if our counter has reached zero
00173Br 3  A5 rr                        lda tmp2
00173Dr 3  05 rr                        ora tmp2+1
00173Fr 3  F0 13                        beq @done
001741r 3               
001741r 3                               ; We're not in ROM and we still have stuff on the counter, so
001741r 3                               ; let's actually do what we came here to do
001741r 3  98                           tya
001742r 3  92 rr                        sta (tmp1)
001744r 3               
001744r 3                               ; Adjust the counter
001744r 3  A5 rr                        lda tmp2
001746r 3  D0 02                        bne @1
001748r 3  C6 rr                        dec tmp2+1
00174Ar 3  C6 rr        @1:               dec tmp2
00174Cr 3               
00174Cr 3                               ; Next address
00174Cr 3  E6 rr                        inc tmp1
00174Er 3  D0 DD                        bne @loop
001750r 3  E6 rr                        inc tmp1+1
001752r 3               
001752r 3  80 D9                        bra @loop
001754r 3               
001754r 3               @done:
001754r 3                               ; Drop three cells off the Data Stack. This uses one byte
001754r 3                               ; less than six times INX
001754r 3  8A                           txa
001755r 3  18                           clc
001756r 3  69 06                        adc #6
001758r 3  AA                           tax
001759r 3               z_blank:
001759r 3               z_erase:
001759r 3  60           z_fill:         rts
00175Ar 3               
00175Ar 3               
00175Ar 3               
00175Ar 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
00175Ar 3               ; ## "execute"  auto  ANS core
00175Ar 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
00175Ar 3               xt_execute:
00175Ar 3  20 rr rr                     jsr underflow_1
00175Dr 3               
00175Dr 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
001760r 3               
001760r 3  60           z_execute:      rts
001761r 3               
001761r 3               doexecute:
001761r 3  B5 00                        lda 0,x
001763r 3  85 rr                        sta ip
001765r 3  B5 01                        lda 1,x
001767r 3  85 rr                        sta ip+1
001769r 3               
001769r 3  E8                           inx
00176Ar 3  E8                           inx
00176Br 3               
00176Br 3                               ; we don't need a RTS here because we highjack the RTS of
00176Br 3                               ; the word we're calling to get back to xt_execute
00176Br 3  6C rr rr                     jmp (ip)
00176Er 3               
00176Er 3               ; end of doexecute
00176Er 3               
00176Er 3               
00176Er 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
00176Er 3               ; ## "execute-parsing"  auto  Gforth
00176Er 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
00176Er 3                       ; Execute the parsing word defined by the execution token (xt) on the
00176Er 3                       ; string as if it were passed on the command line. See the file
00176Er 3                       ; tests/tali.fs for examples.
00176Er 3                       ;
00176Er 3                       ; Note that this word is coded completely
00176Er 3                       ; different in its Gforth version, see the file execute-parsing.fs
00176Er 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
00176Er 3                       ; """
00176Er 3               xt_execute_parsing:
00176Er 3  20 rr rr                     jsr underflow_3
001771r 3               
001771r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
001774r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
001777r 3               
001777r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
001779r 3  85 rr                        sta ciblen
00177Br 3  B5 01                        lda 1,x
00177Dr 3  85 rr                        sta ciblen+1
00177Fr 3               
00177Fr 3  B5 02                        lda 2,x                 ; NOS is new cib
001781r 3  85 rr                        sta cib
001783r 3  B5 03                        lda 3,x
001785r 3  85 rr                        sta cib+1
001787r 3               
001787r 3  64 rr                        stz toin                ; Set >IN to zero
001789r 3  64 rr                        stz toin+1
00178Br 3               
00178Br 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
00178Er 3  20 rr rr                     jsr xt_execute
001791r 3               
001791r 3  20 rr rr                     jsr xt_r_to_input
001794r 3               
001794r 3               z_execute_parsing:
001794r 3  60                           rts
001795r 3               
001795r 3               
001795r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
001795r 3               ; ## "exit"  auto  ANS core
001795r 3                       ; """https://forth-standard.org/standard/core/EXIT
001795r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
001795r 3                       ; we we might have put on the Return Stack off as well. This should
001795r 3                       ; be natively compiled.
001795r 3                       ; """
001795r 3               
001795r 3               xt_exit:
001795r 3  60                           rts             ; keep before z_exit
001796r 3               z_exit:                         ; never reached
001796r 3               
001796r 3               
001796r 3               
001796r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
001796r 3               ; ## "false"  auto  ANS core ext
001796r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
001796r 3               xt_false:
001796r 3  CA                           dex
001797r 3  CA                           dex
001798r 3  74 00                        stz 0,x
00179Ar 3  74 01                        stz 1,x
00179Cr 3               
00179Cr 3  60           z_false:        rts
00179Dr 3               
00179Dr 3               
00179Dr 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
00179Dr 3               ; ## "@"  auto  ANS core
00179Dr 3                       ; """https://forth-standard.org/standard/core/Fetch"""
00179Dr 3               xt_fetch:
00179Dr 3  20 rr rr                     jsr underflow_1
0017A0r 3               
0017A0r 3  A1 00                        lda (0,x)               ; LSB
0017A2r 3  A8                           tay
0017A3r 3  F6 00                        inc 0,x
0017A5r 3  D0 02                        bne @1
0017A7r 3  F6 01                        inc 1,x
0017A9r 3               @1:
0017A9r 3  A1 00                        lda (0,x)               ; MSB
0017ABr 3  95 01                        sta 1,x
0017ADr 3  94 00                        sty 0,x
0017AFr 3               
0017AFr 3  60           z_fetch:        rts
0017B0r 3               
0017B0r 3               
0017B0r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
0017B0r 3               ; ## "find"  auto  ANS core
0017B0r 3                       ; """https://forth-standard.org/standard/core/FIND
0017B0r 3                       ; Included for backwards compatibility only, because it still
0017B0r 3                       ; can be found in so may examples. It should, however, be replaced
0017B0r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
0017B0r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
0017B0r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
0017B0r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
0017B0r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
0017B0r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0017B0r 3                       ; """
0017B0r 3               
0017B0r 3               xt_find:
0017B0r 3  20 rr rr                     jsr underflow_1
0017B3r 3               
0017B3r 3                               ; Save address in case conversion fails. We use the
0017B3r 3                               ; Return Stack instead of temporary variables like TMP1
0017B3r 3                               ; because this is shorter and anybody still using FIND
0017B3r 3                               ; can't be worried about speed anyway
0017B3r 3  B5 01                        lda 1,x                 ; MSB
0017B5r 3  48                           pha
0017B6r 3  B5 00                        lda 0,x                 ; LSB
0017B8r 3  48                           pha
0017B9r 3               
0017B9r 3                               ; Convert ancient-type counted string address to
0017B9r 3                               ; modern format
0017B9r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
0017BCr 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
0017BFr 3               
0017BFr 3  B5 00                        lda 0,x
0017C1r 3  15 01                        ora 1,x
0017C3r 3  D0 0B                        bne @found_word
0017C5r 3               
0017C5r 3                               ; No word found. Return address of the string and a false
0017C5r 3                               ; flag
0017C5r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
0017C8r 3               
0017C8r 3                               ; The address needs to be restored.
0017C8r 3  68                           pla                     ; LSB of address
0017C9r 3  95 02                        sta 2,x
0017CBr 3  68                           pla
0017CCr 3  95 03                        sta 3,x                 ; MSB of address
0017CEr 3               
0017CEr 3  80 27                        bra @done               ; ( addr 0 )
0017D0r 3               
0017D0r 3               @found_word:
0017D0r 3                               ; We don't need the address after all, dump it
0017D0r 3  68                           pla
0017D1r 3  68                           pla
0017D2r 3               
0017D2r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
0017D2r 3                               ; convert the return values to FIND's format
0017D2r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0017D5r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0017D8r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0017DBr 3               
0017DBr 3  A0 00                        ldy #0                  ; Prepare flag
0017DDr 3               
0017DDr 3                               ; The flags are in the second byte of the header
0017DDr 3  F6 00                        inc 0,x
0017DFr 3  D0 02                        bne @1
0017E1r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0017E3r 3               @1:
0017E3r 3  A1 00                        lda (0,x)               ; ( xt char )
0017E5r 3  29 04                        and #IM
0017E7r 3  D0 08                        bne @immediate          ; bit set, we're immediate
0017E9r 3               
0017E9r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
0017EBr 3  95 00                        sta 0,x
0017EDr 3  95 01                        sta 1,x
0017EFr 3  80 06                        bra @done
0017F1r 3               
0017F1r 3               @immediate:
0017F1r 3  A9 01                        lda #1                  ; We're immediate, return 1
0017F3r 3  95 00                        sta 0,x
0017F5r 3  74 01                        stz 1,x
0017F7r 3               @done:
0017F7r 3  60           z_find:         rts
0017F8r 3               
0017F8r 3               
0017F8r 3               
0017F8r 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
0017F8r 3               ; ## "find-name"  auto  Gforth
0017F8r 3               
0017F8r 3               xt_find_name:
0017F8r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0017F8r 3                       ; Given a string, find the Name Token (nt) of a word or return
0017F8r 3                       ; zero if the word is not in the dictionary. We use this instead of
0017F8r 3                       ; ancient FIND to look up words in the Dictionary passed by
0017F8r 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
0017F8r 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
0017F8r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0017F8r 3                       ; FIND calls this word
0017F8r 3                       ; """
0017F8r 3  20 rr rr                     jsr underflow_2
0017FBr 3               
0017FBr 3                               ; check for special case of an empty string (length zero)
0017FBr 3  B5 00                        lda 0,x
0017FDr 3  15 01                        ora 1,x
0017FFr 3  D0 03                        bne @nonempty
001801r 3               
001801r 3  4C rr rr                     jmp @fail_done
001804r 3               
001804r 3               @nonempty:
001804r 3                               ; Set up for traversing the wordlist search order.
001804r 3  64 rr                        stz tmp3                ; Start at the beginning
001806r 3               
001806r 3               @wordlist_loop:
001806r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
001808r 3  A5 rr                        lda tmp3
00180Ar 3  D1 rr                        cmp (up),y              ; Check to see if we are done
00180Cr 3  D0 03                        bne @have_string
00180Er 3               
00180Er 3                               ; We ran out of wordlists to search.
00180Er 3  4C rr rr                     jmp @fail_done
001811r 3               
001811r 3               @have_string:
001811r 3                               ; set up first loop iteration
001811r 3               
001811r 3                               ; Get the current wordlist id
001811r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
001812r 3  69 1F                        adc #search_order_offset
001814r 3  A8                           tay
001815r 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
001817r 3                                               ; into the cell array WORDLISTS
001817r 3               
001817r 3                               ; Get the DP for that wordlist.
001817r 3  0A                           asl                     ; Turn offset into cells offset.
001818r 3  18                           clc
001819r 3  69 06                        adc #wordlists_offset
00181Br 3  A8                           tay
00181Cr 3  B1 rr                        lda (up),y
00181Er 3  85 rr                        sta tmp1
001820r 3  C8                           iny
001821r 3  B1 rr                        lda (up),y
001823r 3  85 rr                        sta tmp1+1
001825r 3               
001825r 3  B5 02                        lda 2,x                 ; Address of mystery string
001827r 3  85 rr                        sta tmp2
001829r 3  B5 03                        lda 3,x
00182Br 3  85 rr                        sta tmp2+1
00182Dr 3               
00182Dr 3               @loop:
00182Dr 3                               ; first quick test: Are strings the same length?
00182Dr 3  B2 rr                        lda (tmp1)
00182Fr 3  D5 00                        cmp 0,x
001831r 3  D0 54                        bne @next_entry
001833r 3               
001833r 3               @compare_string:
001833r 3                               ; are the same length, so we now have to compare each
001833r 3                               ; character
001833r 3               
001833r 3                               ; second quick test: Is the first character the same?
001833r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001835r 3               
001835r 3                               ; Lowercase the incoming charcter.
001835r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001837r 3  B0 07                        bcs @compare_first
001839r 3  C9 41                        cmp #$41        ; ASCII 'A'
00183Br 3  90 03                        bcc @compare_first
00183Dr 3               
00183Dr 3                               ; An uppercase letter has been located.  Make it
00183Dr 3                               ; lowercase.
00183Dr 3  18                           clc
00183Er 3  69 20                        adc #$20
001840r 3               
001840r 3               @compare_first:
001840r 3  A0 08                        ldy #8          ; Offset in nt to name
001842r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
001844r 3  D0 41                        bne @next_entry
001846r 3               
001846r 3                               ; String length is the same and the first character is the
001846r 3                               ; same. If the length of the string is 1, we're already done
001846r 3  B5 00                        lda 0,x
001848r 3  3A                           dec
001849r 3  F0 2C                        beq @success
00184Br 3               
00184Br 3                               ; No such luck: The strings are the same length and the first
00184Br 3                               ; char is the same, but the word is more than one char long.
00184Br 3                               ; So we suck it up and compare every single character. We go
00184Br 3                               ; from back to front, because words like CELLS and CELL+ would
00184Br 3                               ; take longer otherwise. We can also shorten the loop by one
00184Br 3                               ; because we've already compared the first char.
00184Br 3               
00184Br 3                               ; The string of the word we're testing against is 8 bytes down
00184Br 3  A5 rr                        lda tmp1
00184Dr 3  48                           pha             ; Preserve tmp1 on the return stack.
00184Er 3  18                           clc
00184Fr 3  69 08                        adc #8
001851r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001853r 3  A5 rr                        lda tmp1+1
001855r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001856r 3  69 00                        adc #0          ; we only need the carry
001858r 3  85 rr                        sta tmp1+1
00185Ar 3               
00185Ar 3  B4 00                        ldy 0,x         ; index is length of string minus 1
00185Cr 3  88                           dey
00185Dr 3               
00185Dr 3               @string_loop:
00185Dr 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
00185Fr 3               
00185Fr 3                               ; Lowercase the incoming charcter.
00185Fr 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001861r 3  B0 07                        bcs @check_char
001863r 3  C9 41                        cmp #$41        ; ASCII 'A'
001865r 3  90 03                        bcc @check_char
001867r 3               
001867r 3                               ; An uppercase letter has been located.  Make it
001867r 3                               ; lowercase.
001867r 3  18                           clc
001868r 3  69 20                        adc #$20
00186Ar 3               
00186Ar 3               @check_char:
00186Ar 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
00186Cr 3  D0 13                        bne @next_entry_tmp1
00186Er 3               
00186Er 3  88                           dey
00186Fr 3  D0 EC                        bne @string_loop
001871r 3               
001871r 3               @success_tmp1:
001871r 3  68                           pla             ; Restore tmp1 from the return stack.
001872r 3  85 rr                        sta tmp1+1
001874r 3  68                           pla
001875r 3  85 rr                        sta tmp1
001877r 3               
001877r 3               @success:
001877r 3                               ; The strings match. Put correct nt NOS, because we'll drop
001877r 3                               ; TOS before we leave
001877r 3  A5 rr                        lda tmp1
001879r 3  95 02                        sta 2,x
00187Br 3  A5 rr                        lda tmp1+1
00187Dr 3  95 03                        sta 3,x
00187Fr 3               
00187Fr 3  80 20                        bra @done
001881r 3               
001881r 3               @next_entry_tmp1:
001881r 3  68                           pla             ; Restore tmp1 from the return stack.
001882r 3  85 rr                        sta tmp1+1
001884r 3  68                           pla
001885r 3  85 rr                        sta tmp1
001887r 3               
001887r 3               @next_entry:
001887r 3                               ; Not the same, so we get the next word. Next header
001887r 3                               ; address is two bytes down
001887r 3  A0 02                        ldy #2
001889r 3  B1 rr                        lda (tmp1),y
00188Br 3  48                           pha
00188Cr 3  C8                           iny
00188Dr 3  B1 rr                        lda (tmp1),y
00188Fr 3  85 rr                        sta tmp1+1
001891r 3  68                           pla
001892r 3  85 rr                        sta tmp1
001894r 3               
001894r 3                               ; If we got a zero, we've walked the whole Dictionary and
001894r 3                               ; return as a failure, otherwise try again
001894r 3  05 rr                        ora tmp1+1
001896r 3  D0 95                        bne @loop
001898r 3               
001898r 3                               ; Move on to the next wordlist in the search order.
001898r 3  E6 rr                        inc tmp3
00189Ar 3  4C rr rr                     jmp @wordlist_loop
00189Dr 3               
00189Dr 3               @fail_done:
00189Dr 3  74 02                        stz 2,x         ; failure flag
00189Fr 3  74 03                        stz 3,x
0018A1r 3               @done:
0018A1r 3  E8                           inx
0018A2r 3  E8                           inx
0018A3r 3               
0018A3r 3  60           z_find_name:    rts
0018A4r 3               
0018A4r 3               
0018A4r 3               
0018A4r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
0018A4r 3               ; ## "flush"  auto  ANS block
0018A4r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
0018A4r 3               xt_flush:
0018A4r 3  20 rr rr                     jsr xt_save_buffers
0018A7r 3               
0018A7r 3                               ; Set the buffer status to empty.
0018A7r 3  A0 2C                        ldy #buffstatus_offset
0018A9r 3  A9 00                        lda #0
0018ABr 3  91 rr                        sta (up),y      ; Only LSB is used.
0018ADr 3               z_flush:
0018ADr 3  60                           rts
0018AEr 3               
0018AEr 3               
0018AEr 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
0018AEr 3               ; ## "fm/mod"  auto  ANS core
0018AEr 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
0018AEr 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
0018AEr 3                       ;
0018AEr 3                       ; There are various ways to realize this. We follow EForth with
0018AEr 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
0018AEr 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
0018AEr 3                       ; See (http://www.forth.org/eforth.html). However you can also
0018AEr 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
0018AEr 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
0018AEr 3                       ; """
0018AEr 3               
0018AEr 3               xt_fm_slash_mod:
0018AEr 3  20 rr rr                     jsr underflow_3
0018B1r 3               
0018B1r 3                               ; if sign of n1 is negative, negate both n1 and d
0018B1r 3  64 rr                        stz tmp2        ; default: n is positive
0018B3r 3  B5 01                        lda 1,x         ; MSB of n1
0018B5r 3  10 0E                        bpl @check_d
0018B7r 3               
0018B7r 3  E6 rr                        inc tmp2        ; set flag to negative for n1
0018B9r 3  20 rr rr                     jsr xt_negate   ; NEGATE
0018BCr 3  20 rr rr                     jsr xt_to_r     ; >R
0018BFr 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
0018C2r 3  20 rr rr                     jsr xt_r_from   ; R>
0018C5r 3               
0018C5r 3               @check_d:
0018C5r 3                               ; If d is negative, add n1 to high cell of d
0018C5r 3  B5 03                        lda 3,x         ; MSB of high word of d
0018C7r 3  10 0D                        bpl @multiply
0018C9r 3               
0018C9r 3  18                           clc
0018CAr 3  B5 00                        lda 0,x         ; LSB of n1
0018CCr 3  75 02                        adc 2,x         ; LSB of dh
0018CEr 3  95 02                        sta 2,x
0018D0r 3               
0018D0r 3  B5 01                        lda 1,x         ; MSB of n1
0018D2r 3  75 03                        adc 3,x         ; MSB of dh
0018D4r 3  95 03                        sta 3,x
0018D6r 3               
0018D6r 3               @multiply:
0018D6r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
0018D9r 3               
0018D9r 3                               ; if n was negative, negate the result
0018D9r 3  A5 rr                        lda tmp2
0018DBr 3  F0 07                        beq @done
0018DDr 3               
0018DDr 3  E8                           inx             ; pretend that we SWAP
0018DEr 3  E8                           inx
0018DFr 3  20 rr rr                     jsr xt_negate
0018E2r 3  CA                           dex
0018E3r 3  CA                           dex
0018E4r 3               @done:
0018E4r 3  60           z_fm_slash_mod: rts
0018E5r 3               
0018E5r 3               
0018E5r 3               
0018E5r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
0018E5r 3               ; ## "forth"  auto  ANS search ext
0018E5r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
0018E5r 3               xt_forth:
0018E5r 3  A0 1F                        ldy #search_order_offset
0018E7r 3  A9 00                        lda #0          ; The WID for Forth is 0.
0018E9r 3               
0018E9r 3  91 rr                        sta (up),y
0018EBr 3               z_forth:
0018EBr 3  60                           rts
0018ECr 3               
0018ECr 3               
0018ECr 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
0018ECr 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
0018ECr 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
0018ECr 3               load_evaluate:
0018ECr 3                               ; Set a flag (using tmp1) to not zero BLK
0018ECr 3  A9 FF                        lda #$FF
0018EEr 3  85 rr                        sta tmp1
0018F0r 3  80 11                        bra load_evaluate_start
0018F2r 3               
0018F2r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
0018F2r 3               ; ## "evaluate"  auto  ANS core
0018F2r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
0018F2r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
0018F2r 3                       ; After processing the line, revert to old input source. We use this
0018F2r 3                       ; to compile high-level Forth words and user-defined words during
0018F2r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
0018F2r 3                       ; accept more than 255 characters here, even though it's a pain in
0018F2r 3                       ; the 8-bit.
0018F2r 3                       ; """
0018F2r 3               
0018F2r 3               xt_evaluate:
0018F2r 3  20 rr rr                     jsr underflow_2
0018F5r 3               
0018F5r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
0018F5r 3                               ; and will set the block number.
0018F5r 3  64 rr                        stz tmp1
0018F7r 3               
0018F7r 3                               ; If u is zero (which can happen a lot for the user-defined
0018F7r 3                               ; words), just leave again
0018F7r 3  B5 00                        lda 0,x
0018F9r 3  15 01                        ora 1,x
0018FBr 3  D0 06                        bne _eval_got_work
0018FDr 3               
0018FDr 3  E8                           inx
0018FEr 3  E8                           inx
0018FFr 3  E8                           inx
001900r 3  E8                           inx
001901r 3               
001901r 3  80 42                        bra _eval_done
001903r 3               
001903r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
001903r 3               load_evaluate_start:
001903r 3               _eval_got_work:
001903r 3                               ; Save the current value of BLK on the return stack.
001903r 3  A0 01                        ldy #blk_offset+1
001905r 3  B1 rr                        lda (up),y
001907r 3  48                           pha
001908r 3  88                           dey
001909r 3  B1 rr                        lda (up),y
00190Br 3  48                           pha
00190Cr 3               
00190Cr 3                               ; See if we should zero BLK.
00190Cr 3  A5 rr                        lda tmp1
00190Er 3  D0 05                        bne @nozero
001910r 3               
001910r 3                               ; Set BLK to zero.
001910r 3                               ; lda #0        ; A is already zero from loading tmp1
001910r 3  91 rr                        sta (up),y
001912r 3  C8                           iny
001913r 3  91 rr                        sta (up),y
001915r 3               
001915r 3               @nozero:
001915r 3                               ; Save the input state to the Return Stack
001915r 3  20 rr rr                     jsr xt_input_to_r
001918r 3               
001918r 3                               ; set SOURCE-ID to -1
001918r 3  A9 FF                        lda #$ff
00191Ar 3  85 rr                        sta insrc
00191Cr 3  85 rr                        sta insrc+1
00191Er 3               
00191Er 3                               ; set >IN to zero
00191Er 3  64 rr                        stz toin
001920r 3  64 rr                        stz toin+1
001922r 3               
001922r 3                               ; move TOS and NOS to input buffers
001922r 3  B5 00                        lda 0,x
001924r 3  85 rr                        sta ciblen
001926r 3  B5 01                        lda 1,x
001928r 3  85 rr                        sta ciblen+1
00192Ar 3               
00192Ar 3  B5 02                        lda 2,x
00192Cr 3  85 rr                        sta cib
00192Er 3  B5 03                        lda 3,x
001930r 3  85 rr                        sta cib+1
001932r 3               
001932r 3  E8                           inx             ; A clean stack is a clean mind
001933r 3  E8                           inx
001934r 3  E8                           inx
001935r 3  E8                           inx
001936r 3               
001936r 3  20 rr rr                     jsr interpret   ; ( -- )
001939r 3               
001939r 3                               ; restore variables
001939r 3  20 rr rr                     jsr xt_r_to_input
00193Cr 3               
00193Cr 3                               ; Restore BLK from the return stack.
00193Cr 3  A0 00                        ldy #blk_offset
00193Er 3  68                           pla
00193Fr 3  91 rr                        sta (up),y
001941r 3  C8                           iny
001942r 3  68                           pla
001943r 3  91 rr                        sta (up),y
001945r 3               
001945r 3               _eval_done:
001945r 3  60           z_evaluate:     rts
001946r 3               
001946r 3               
001946r 3               
001946r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001946r 3               ; ## "forth-wordlist"  auto  ANS search
001946r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001946r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001946r 3               
001946r 3               
001946r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001946r 3               ; ## "get-current" auto ANS search
001946r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001946r 3               
001946r 3               xt_get_current:
001946r 3                               ; This is a little different than some of the variables
001946r 3                               ; in the user area as we want the value rather than
001946r 3                               ; the address.
001946r 3  CA                           dex
001947r 3  CA                           dex
001948r 3  A0 04                        ldy #current_offset
00194Ar 3  B1 rr                        lda (up),y
00194Cr 3  95 00                        sta 0,x         ; CURRENT is a byte variable
00194Er 3  74 01                        stz 1,x         ; so the MSB is zero.
001950r 3               
001950r 3  60           z_get_current:  rts
001951r 3               
001951r 3               
001951r 3               
001951r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001951r 3               ; ## "get-order" auto ANS search
001951r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001951r 3               
001951r 3               xt_get_order:
001951r 3                               ; Get #ORDER - the number of wordlists in the search order.
001951r 3  A0 1E                        ldy #num_order_offset
001953r 3  B1 rr                        lda (up),y
001955r 3  85 rr                        sta tmp1
001957r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
001959r 3               
001959r 3               @loop:
001959r 3                               ; Count down towards the front of the list.
001959r 3                               ; By decrementing first, we also turn the length into an offset.
001959r 3  C6 rr                        dec tmp1        ; Count down by bytes.
00195Br 3               
00195Br 3                               ; Get a pointer to the current wordlist, working back to front.
00195Br 3  A9 1F                        lda #search_order_offset
00195Dr 3  18                           clc
00195Er 3  65 rr                        adc tmp1
001960r 3  A8                           tay
001961r 3               
001961r 3                               ; Put that wordlist id on the stack.
001961r 3  CA                           dex
001962r 3  CA                           dex
001963r 3  B1 rr                        lda (up),y
001965r 3  95 00                        sta 0,x         ; Search order array is bytes, so
001967r 3  74 01                        stz 1,x         ; put a zero in the high byte.
001969r 3               
001969r 3                               ; See if that was the last one to process (first in the list).
001969r 3  A9 00                        lda #0
00196Br 3  C5 rr                        cmp tmp1
00196Dr 3  D0 EA                        bne @loop
00196Fr 3               
00196Fr 3               @done:
00196Fr 3                               ; Put the number of items on the stack.
00196Fr 3  CA                           dex
001970r 3  CA                           dex
001971r 3  A0 1E                        ldy #num_order_offset
001973r 3  B1 rr                        lda (up),y
001975r 3  95 00                        sta 0,x
001977r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
001979r 3               
001979r 3  60           z_get_order:    rts
00197Ar 3               
00197Ar 3               
00197Ar 3               
00197Ar 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
00197Ar 3               ; ## ">"  auto  ANS core
00197Ar 3                       ; """https://forth-standard.org/standard/core/more"""
00197Ar 3               
00197Ar 3               xt_greater_than:
00197Ar 3  20 rr rr                     jsr underflow_2
00197Dr 3               
00197Dr 3  A0 00                        ldy #0          ; default false
00197Fr 3  20 rr rr                     jsr compare_16bit
001982r 3               
001982r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001982r 3  F0 03                        beq @false
001984r 3  10 01                        bpl @false
001986r 3               
001986r 3                               ; true
001986r 3  88                           dey
001987r 3               @false:
001987r 3  98                           tya
001988r 3               
001988r 3  E8                           inx
001989r 3  E8                           inx
00198Ar 3  95 00                        sta 0,x
00198Cr 3  95 01                        sta 1,x
00198Er 3               
00198Er 3  60           z_greater_than: rts
00198Fr 3               
00198Fr 3               
00198Fr 3               
00198Fr 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
00198Fr 3               ; ## "here"  auto  ANS core
00198Fr 3                       ; """https://forth-standard.org/standard/core/HERE
00198Fr 3                       ; This code is also used by the assembler directive ARROW
00198Fr 3                       ; ("->") though as immediate"""
00198Fr 3               xt_here:
00198Fr 3               xt_asm_arrow:
00198Fr 3  CA                           dex
001990r 3  CA                           dex
001991r 3  A5 rr                        lda cp
001993r 3  95 00                        sta 0,x
001995r 3  A5 rr                        lda cp+1
001997r 3  95 01                        sta 1,x
001999r 3               
001999r 3               z_asm_arrow:
001999r 3  60           z_here:         rts
00199Ar 3               
00199Ar 3               
00199Ar 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
00199Ar 3               ; ## "hex"  auto  ANS core ext
00199Ar 3                       ; """https://forth-standard.org/standard/core/HEX"""
00199Ar 3               xt_hex:
00199Ar 3  A9 10                        lda #16
00199Cr 3  85 rr                        sta base
00199Er 3  64 rr                        stz base+1              ; paranoid
0019A0r 3               
0019A0r 3  60           z_hex:          rts
0019A1r 3               
0019A1r 3               
0019A1r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
0019A1r 3               ; ## "hexstore"  auto  Tali
0019A1r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
0019A1r 3                       ; by spaces, store the numbers at the address addr2, returning the
0019A1r 3                       ; number of elements. Non-number elements are skipped, an zero-length
0019A1r 3                       ; string produces a zero output.
0019A1r 3                       ; """
0019A1r 3               
0019A1r 3               xt_hexstore:
0019A1r 3  20 rr rr                     jsr underflow_3
0019A4r 3               
0019A4r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
0019A7r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
0019AAr 3               
0019AAr 3               @loop:
0019AAr 3                               ; Loop until string is totally consumed
0019AAr 3  B5 00                        lda 0,x
0019ACr 3  15 01                        ora 1,x
0019AEr 3  F0 36                        beq @done
0019B0r 3               
0019B0r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
0019B3r 3               
0019B3r 3                               ; Prepare the conversion of the number.
0019B3r 3  20 rr rr                     jsr xt_two_to_r
0019B6r 3  20 rr rr                     jsr xt_zero
0019B9r 3  20 rr rr                     jsr xt_zero
0019BCr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
0019BFr 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
0019C2r 3               
0019C2r 3                               ; If u4 is not zero, we have leftover chars and have to do
0019C2r 3                               ; things differently
0019C2r 3  B5 00                        lda 0,x
0019C4r 3  15 01                        ora 1,x
0019C6r 3  D0 17                        bne @have_chars_left
0019C8r 3               
0019C8r 3                               ; Normal case, this number is all done
0019C8r 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
0019CBr 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
0019CEr 3               
0019CEr 3                               ; Store the new value
0019CEr 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
0019D1r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
0019D4r 3               
0019D4r 3                               ; Increase counter
0019D4r 3  20 rr rr                     jsr xt_r_from           ; R>
0019D7r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0019DAr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
0019DDr 3  80 CB                        bra @loop
0019DFr 3               
0019DFr 3               @have_chars_left:
0019DFr 3                               ; Pathological case: Drop the rest of this number off the stack
0019DFr 3                               ; and continue with the next word. Doesn't print a warning. We
0019DFr 3                               ; need to drop four cells, that is, eight bytes
0019DFr 3  8A                           txa
0019E0r 3  18                           clc
0019E1r 3  69 08                        adc #8
0019E3r 3  AA                           tax
0019E4r 3  80 C4                        bra @loop
0019E6r 3               
0019E6r 3               @done:
0019E6r 3                               ; Clean up return stack and calculate number of chars stored
0019E6r 3  E8                           inx
0019E7r 3  E8                           inx
0019E8r 3  E8                           inx
0019E9r 3  E8                           inx                     ; 2DROP
0019EAr 3               
0019EAr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
0019EDr 3  20 rr rr                     jsr xt_swap
0019F0r 3  20 rr rr                     jsr xt_minus            ; ( n )
0019F3r 3               
0019F3r 3  60           z_hexstore:     rts
0019F4r 3               
0019F4r 3               
0019F4r 3               
0019F4r 3               ; ## HOLD ( char -- ) "Insert character at current output"
0019F4r 3               ; ## "hold"  auto  ANS core
0019F4r 3                       ; """https://forth-standard.org/standard/core/HOLD
0019F4r 3                       ; Insert a character at the current position of a pictured numeric
0019F4r 3                       ; output string on
0019F4r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0019F4r 3                       ;
0019F4r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
0019F4r 3                       ; variable tohold instead of HLD.
0019F4r 3                       ; """
0019F4r 3               xt_hold:
0019F4r 3  20 rr rr                     jsr underflow_1
0019F7r 3               
0019F7r 3  A5 rr                        lda tohold
0019F9r 3  D0 02                        bne @1
0019FBr 3  C6 rr                        dec tohold+1
0019FDr 3               @1:
0019FDr 3  C6 rr                        dec tohold
0019FFr 3               
0019FFr 3  B5 00                        lda 0,x
001A01r 3  92 rr                        sta (tohold)
001A03r 3  E8                           inx
001A04r 3  E8                           inx
001A05r 3               
001A05r 3  60           z_hold:         rts
001A06r 3               
001A06r 3               
001A06r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
001A06r 3               ; ## "i"  auto  ANS core
001A06r 3                       ; """https://forth-standard.org/standard/core/I
001A06r 3                       ; Note that this is not the same as R@ because we use a fudge
001A06r 3                       ; factor for loop control; see the Control Flow section of the
001A06r 3                       ; manual for details.
001A06r 3                       ;
001A06r 3                       ; We should make this native compile for speed.
001A06r 3                       ; """
001A06r 3               
001A06r 3               xt_i:
001A06r 3  CA                           dex
001A07r 3  CA                           dex
001A08r 3               
001A08r 3                               ; Get the fudged index off of the top of the stack. It's
001A08r 3                               ; easier to do math on the stack directly than to pop and
001A08r 3                               ; push stuff around
001A08r 3  86 rr                        stx tmpdsp
001A0Ar 3  BA                           tsx
001A0Br 3               
001A0Br 3  38                           sec
001A0Cr 3  BD 01 01                     lda $0101,x     ; LSB
001A0Fr 3  FD 03 01                     sbc $0103,x
001A12r 3  A8                           tay
001A13r 3               
001A13r 3  BD 02 01                     lda $0102,x     ; MSB
001A16r 3  FD 04 01                     sbc $0104,x
001A19r 3               
001A19r 3  A6 rr                        ldx tmpdsp
001A1Br 3               
001A1Br 3  95 01                        sta 1,x         ; MSB of de-fudged index
001A1Dr 3  94 00                        sty 0,x         ; LSB of de-fudged index
001A1Fr 3               
001A1Fr 3  60           z_i:            rts
001A20r 3               
001A20r 3               
001A20r 3               
001A20r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001A20r 3               ; ## "if"  auto  ANS core
001A20r 3                       ; """http://forth-standard.org/standard/core/IF"""
001A20r 3               
001A20r 3               xt_if:
001A20r 3                               ; Compile a 0BRANCH
001A20r 3  A0 rr                        ldy #>zero_branch_runtime
001A22r 3  A9 rr                        lda #<zero_branch_runtime
001A24r 3  20 rr rr                     jsr cmpl_subroutine
001A27r 3               
001A27r 3                               ; Put the origination address on the stack for else/then
001A27r 3  20 rr rr                     jsr xt_here
001A2Ar 3               
001A2Ar 3                               ; Stuff zero in for the branch address right now.
001A2Ar 3                               ; THEN or ELSE will fix it later.
001A2Ar 3  20 rr rr                     jsr xt_zero
001A2Dr 3  20 rr rr                     jsr xt_comma
001A30r 3  60           z_if:           rts
001A31r 3               
001A31r 3               
001A31r 3               zero_branch_runtime:
001A31r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001A31r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001A31r 3                       ; runtime.
001A31r 3                       ; """
001A31r 3               
001A31r 3                               ; We use the return value on the 65c02 stack to determine
001A31r 3                               ; where we want to return to.
001A31r 3  68                           pla
001A32r 3  85 rr                        sta tmpbranch
001A34r 3  68                           pla
001A35r 3  85 rr                        sta tmpbranch+1
001A37r 3               
001A37r 3                               ; See if the flag is zero, which is the whole purpose of
001A37r 3                               ; this all
001A37r 3  B5 00                        lda 0,x
001A39r 3  15 01                        ora 1,x
001A3Br 3  F0 0F                        beq @zero
001A3Dr 3               
001A3Dr 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001A3Dr 3                               ; the part between IF and THEN
001A3Dr 3  A5 rr                        lda tmpbranch   ; LSB
001A3Fr 3  18                           clc
001A40r 3  69 02                        adc #2
001A42r 3  85 rr                        sta tmp1
001A44r 3  A5 rr                        lda tmpbranch+1 ; MSB
001A46r 3  69 00                        adc #0          ; For carry
001A48r 3  85 rr                        sta tmp1+1
001A4Ar 3               
001A4Ar 3  80 13                        bra @done
001A4Cr 3               
001A4Cr 3               @zero:
001A4Cr 3                               ; Flag is FALSE (0) so we take the jump to the address given in
001A4Cr 3                               ; the next two bytes. However, the address points to the last
001A4Cr 3                               ; byte of the JSR instruction, not to the next byte afterwards
001A4Cr 3  A0 01                        ldy #1
001A4Er 3  B1 rr                        lda (tmpbranch),y
001A50r 3  85 rr                        sta tmp1
001A52r 3  C8                           iny
001A53r 3  B1 rr                        lda (tmpbranch),y
001A55r 3  85 rr                        sta tmp1+1
001A57r 3               
001A57r 3                               ; Now we have to subtract one byte from the address
001A57r 3                               ; given because of the way the 6502 calculates RTS
001A57r 3  A5 rr                        lda tmp1
001A59r 3  D0 02                        bne @1
001A5Br 3  C6 rr                        dec tmp1+1
001A5Dr 3               @1:
001A5Dr 3  C6 rr                        dec tmp1
001A5Fr 3               
001A5Fr 3               @done:
001A5Fr 3                               ; However we got here, tmp1 has the value we push to jump
001A5Fr 3                               ; to
001A5Fr 3  A5 rr                        lda tmp1+1
001A61r 3  48                           pha             ; MSB first
001A62r 3  A5 rr                        lda tmp1
001A64r 3  48                           pha
001A65r 3               
001A65r 3                               ; clean up the stack and jump
001A65r 3  E8                           inx
001A66r 3  E8                           inx
001A67r 3               
001A67r 3  60                           rts
001A68r 3               
001A68r 3               
001A68r 3               
001A68r 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
001A68r 3               ; ## "immediate"  auto  ANS core
001A68r 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
001A68r 3                       ; Make sure the most recently defined word is immediate. Will only
001A68r 3                       ; affect the last word in the dictionary. Note that if the word is
001A68r 3                       ; defined in ROM, this will have no affect, but will not produce an
001A68r 3                       ; error message.
001A68r 3                       ; """
001A68r 3               xt_immediate:
001A68r 3  20 rr rr                     jsr current_to_dp
001A6Br 3  A0 01                        ldy #1          ; offset for status byte
001A6Dr 3  B1 rr                        lda (dp),y
001A6Fr 3  09 04                        ora #IM        ; make sure bit 7 is set
001A71r 3  91 rr                        sta (dp),y
001A73r 3               
001A73r 3  60           z_immediate:    rts
001A74r 3               
001A74r 3               
001A74r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001A74r 3               ; ## "input" tested Tali Forth
001A74r 3               
001A74r 3               xt_input:
001A74r 3  CA                           dex
001A75r 3  CA                           dex
001A76r 3  A9 rr                        lda #<input
001A78r 3  95 00                        sta 0,x
001A7Ar 3  A9 rr                        lda #>input
001A7Cr 3  95 01                        sta 1,x
001A7Er 3               
001A7Er 3  60           z_input:        rts
001A7Fr 3               
001A7Fr 3               
001A7Fr 3               
001A7Fr 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
001A7Fr 3               ; ## "input>r"  tested  Tali Forth
001A7Fr 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
001A7Fr 3                       ; toin to the Return Stack. Used by EVALUTE.
001A7Fr 3                       ;
001A7Fr 3                       ; The naive way of doing
001A7Fr 3                       ; this is to push each two-byte variable to the stack in the form of
001A7Fr 3                       ;
001A7Fr 3                       ;       lda insrc
001A7Fr 3                       ;       pha
001A7Fr 3                       ;       lda insrc+1
001A7Fr 3                       ;       pha
001A7Fr 3                       ;
001A7Fr 3                       ; for a total of 24 byte of instruction in one direction and later
001A7Fr 3                       ; a further 24 bytes to reverse the process. We shorten this at the
001A7Fr 3                       ; cost of some speed by assuming the four variables are grouped
001A7Fr 3                       ; together on the Zero Page and start with insrc (see definitions.asm
001A7Fr 3                       ; for details). The reverse operation is r_to_input. These words must
001A7Fr 3                       ; be flagged as Never Native. Uses tmp1
001A7Fr 3                       ; """
001A7Fr 3               
001A7Fr 3               xt_input_to_r:
001A7Fr 3                               ; We arrive here with the return address on the top of the
001A7Fr 3                               ; 65c02's stack. We need to move it out of the way first
001A7Fr 3  68                           pla
001A80r 3  85 rr                        sta tmp1
001A82r 3  68                           pla
001A83r 3  85 rr                        sta tmp1+1
001A85r 3               
001A85r 3                               ; This assumes that insrc is the first of eight bytes and
001A85r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001A85r 3                               ; Page.
001A85r 3  A0 07                        ldy #7
001A87r 3               @loop:
001A87r 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
001A8Ar 3  48                           pha
001A8Br 3  88                           dey
001A8Cr 3  10 F9                        bpl @loop
001A8Er 3               
001A8Er 3                               ; Restore address for return jump
001A8Er 3  A5 rr                        lda tmp1+1
001A90r 3  48                           pha
001A91r 3  A5 rr                        lda tmp1
001A93r 3  48                           pha
001A94r 3               
001A94r 3  60           z_input_to_r: 	rts
001A95r 3               
001A95r 3               
001A95r 3               
001A95r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001A95r 3               ; ## "int>name"  auto  Tali Forth
001A95r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001A95r 3                       ; This is called >NAME in Gforth, but we change it to
001A95r 3                       ; INT>NAME to match NAME>INT
001A95r 3                       ; """
001A95r 3               
001A95r 3               xt_int_to_name:
001A95r 3  20 rr rr                     jsr underflow_1
001A98r 3               
001A98r 3                               ; Unfortunately, to find the header, we have to walk through
001A98r 3                               ; all of the wordlists. We are running out of tmp variables.
001A98r 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
001A98r 3                               ; hold the current wordlist on the data stack. This searches
001A98r 3                               ; all of the wordlists in id order.
001A98r 3  CA                           dex
001A99r 3  CA                           dex
001A9Ar 3  74 00                        stz 0,x
001A9Cr 3  74 01                        stz 1,x
001A9Er 3               
001A9Er 3               @wordlist_loop:
001A9Er 3                               ; A needs to have the current wordlist id in it at
001A9Er 3                               ; the top of this loop.
001A9Er 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001AA0r 3               
001AA0r 3                               ; Get the DP for that wordlist.
001AA0r 3  0A                           asl                     ; Turn offset into cells offset.
001AA1r 3  18                           clc
001AA2r 3  69 06                        adc #wordlists_offset
001AA4r 3  A8                           tay
001AA5r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
001AA7r 3  85 rr                        sta tmp2                ; into tmp2
001AA9r 3  C8                           iny
001AAAr 3  B1 rr                        lda (up),y
001AACr 3  85 rr                        sta tmp2+1
001AAEr 3               
001AAEr 3                               ; Check for an empty wordlist (DP will be 0)
001AAEr 3  A5 rr                        lda tmp2
001AB0r 3  05 rr                        ora tmp2+1
001AB2r 3  F0 38                        beq @next_wordlist
001AB4r 3               
001AB4r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001AB6r 3  85 rr                        sta tmp3        ; Save target xt in tmp3
001AB8r 3  B5 03                        lda 3,x
001ABAr 3  85 rr                        sta tmp3+1
001ABCr 3               
001ABCr 3               @loop:
001ABCr 3  A0 04                        ldy #4          ; xt is four bytes down
001ABEr 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
001AC0r 3  C5 rr                        cmp tmp3
001AC2r 3  D0 07                        bne @no_match
001AC4r 3               
001AC4r 3                               ; LSB is the same, now check MSB
001AC4r 3  C8                           iny
001AC5r 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
001AC7r 3  C5 rr                        cmp tmp3+1
001AC9r 3  F0 32                        beq @match
001ACBr 3               
001ACBr 3               @no_match:
001ACBr 3                               ; no match, so we need to get the next word. Next nt is two
001ACBr 3                               ; bytes down
001ACBr 3  18                           clc
001ACCr 3  A5 rr                        lda tmp2
001ACEr 3  69 02                        adc #2
001AD0r 3  85 rr                        sta tmp2
001AD2r 3  A5 rr                        lda tmp2+1
001AD4r 3  69 00                        adc #0          ; only care about carry
001AD6r 3  85 rr                        sta tmp2+1
001AD8r 3               
001AD8r 3  A0 00                        ldy #0
001ADAr 3  B1 rr                        lda (tmp2),y
001ADCr 3  48                           pha
001ADDr 3  C8                           iny
001ADEr 3  11 rr                        ora (tmp2),y
001AE0r 3  F0 09                        beq @zero
001AE2r 3               
001AE2r 3                               ; Not zero continue
001AE2r 3  B1 rr                        lda (tmp2),y
001AE4r 3  85 rr                        sta tmp2+1
001AE6r 3  68                           pla
001AE7r 3  85 rr                        sta tmp2
001AE9r 3  80 D1                        bra @loop
001AEBr 3               
001AEBr 3               @zero:
001AEBr 3                               ; if next word is zero, the xt has no nt in this wordlist
001AEBr 3  68                           pla             ; Leftover from above loop
001AECr 3               
001AECr 3               @next_wordlist:
001AECr 3                               ; Move on to the next wordlist.
001AECr 3  B5 00                        lda 0,x
001AEEr 3  1A                           inc
001AEFr 3  95 00                        sta 0,x
001AF1r 3  C9 0C                        cmp #max_wordlists
001AF3r 3  D0 A9                        bne @wordlist_loop
001AF5r 3               
001AF5r 3                               ; We didn't find it in any of the wordlists.
001AF5r 3                               ; Remove the wordlist id from the stack.
001AF5r 3  E8                           inx
001AF6r 3  E8                           inx
001AF7r 3               
001AF7r 3                               ; We return a zero to indicate that we didn't find it.
001AF7r 3  74 00                        stz 0,x
001AF9r 3  74 01                        stz 1,x
001AFBr 3  80 0A                        bra z_int_to_name
001AFDr 3               
001AFDr 3               @match:
001AFDr 3                               ; We found it. Remove wordlist id from stack.
001AFDr 3  E8                           inx
001AFEr 3  E8                           inx
001AFFr 3               
001AFFr 3                               ; It's a match! Replace TOS with nt
001AFFr 3  A5 rr                        lda tmp2
001B01r 3  95 00                        sta 0,x
001B03r 3  A5 rr                        lda tmp2+1
001B05r 3  95 01                        sta 1,x
001B07r 3               
001B07r 3  60           z_int_to_name:  rts
001B08r 3               
001B08r 3               
001B08r 3               
001B08r 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001B08r 3               ; ## "invert"  auto  ANS core
001B08r 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001B08r 3               xt_invert:
001B08r 3  20 rr rr                     jsr underflow_1
001B0Br 3               
001B0Br 3  A9 FF                        lda #$FF
001B0Dr 3  55 00                        eor 0,x         ; LSB
001B0Fr 3  95 00                        sta 0,x
001B11r 3               
001B11r 3  A9 FF                        lda #$FF
001B13r 3  55 01                        eor 1,x         ; MSB
001B15r 3  95 01                        sta 1,x
001B17r 3               
001B17r 3  60           z_invert:       rts
001B18r 3               
001B18r 3               
001B18r 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001B18r 3               ; ## "is"  auto  ANS core ext
001B18r 3                       ; """http://forth-standard.org/standard/core/IS"""
001B18r 3               
001B18r 3               xt_is:
001B18r 3                               ; This is a state aware word with differet behavior
001B18r 3                               ; when used while compiling vs interpreting.
001B18r 3                               ; Check STATE
001B18r 3  A5 rr                        lda state
001B1Ar 3  05 rr                        ora state+1
001B1Cr 3  F0 0C                        beq @interpreting
001B1Er 3               
001B1Er 3               @compiling:
001B1Er 3                               ; Run ['] to compile the xt of the next word as a literal.
001B1Er 3  20 rr rr                     jsr xt_bracket_tick
001B21r 3               
001B21r 3                               ; Postpone DEFER! by compiling a JSR to it.
001B21r 3  A0 rr                        ldy #>xt_defer_store
001B23r 3  A9 rr                        lda #<xt_defer_store
001B25r 3  20 rr rr                     jsr cmpl_subroutine
001B28r 3               
001B28r 3  80 06                        bra @done
001B2Ar 3               
001B2Ar 3               @interpreting:
001B2Ar 3  20 rr rr                     jsr xt_tick
001B2Dr 3  20 rr rr                     jsr xt_defer_store
001B30r 3               @done:
001B30r 3  60           z_is:           rts
001B31r 3               
001B31r 3               
001B31r 3               
001B31r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001B31r 3               ; ## "j"  auto  ANS core
001B31r 3                       ; """https://forth-standard.org/standard/core/J
001B31r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001B31r 3                       ; a fudge factor for loop control; see the Control Flow section of
001B31r 3                       ; the manual for more details.
001B31r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001B31r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001B31r 3                       ; implementation would just have two.
001B31r 3                       ;
001B31r 3                       ; Make this native compiled for speed
001B31r 3                       ; """
001B31r 3               
001B31r 3               xt_j:
001B31r 3  CA                           dex
001B32r 3  CA                           dex
001B33r 3               
001B33r 3                               ; Get the fudged index off from the stack. It's easier to
001B33r 3                               ; do math on the stack directly than to pop and push stuff
001B33r 3                               ; around
001B33r 3  86 rr                        stx tmpdsp
001B35r 3  BA                           tsx
001B36r 3               
001B36r 3  38                           sec
001B37r 3  BD 07 01                     lda $0107,x     ; LSB
001B3Ar 3  FD 09 01                     sbc $0109,x
001B3Dr 3  A8                           tay
001B3Er 3               
001B3Er 3  BD 08 01                     lda $0108,x     ; MSB
001B41r 3  FD 0A 01                     sbc $010A,x
001B44r 3               
001B44r 3  A6 rr                        ldx tmpdsp
001B46r 3               
001B46r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001B48r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001B4Ar 3               
001B4Ar 3  60           z_j:            rts
001B4Br 3               
001B4Br 3               
001B4Br 3               
001B4Br 3               ; ## KEY ( -- char ) "Get one character from the input"
001B4Br 3               ; ## "key"  tested  ANS core
001B4Br 3               xt_key:
001B4Br 3                       ; """https://forth-standard.org/standard/core/KEY
001B4Br 3                       ; Get a single character of input from the vectored
001B4Br 3                       ; input without echoing.
001B4Br 3                       ; """
001B4Br 3  20 rr rr                     jsr key_a               ; returns char in A
001B4Er 3               
001B4Er 3  CA                           dex
001B4Fr 3  CA                           dex
001B50r 3  95 00                        sta 0,x
001B52r 3  74 01                        stz 1,x
001B54r 3               
001B54r 3  60           z_key:          rts
001B55r 3               
001B55r 3               key_a:
001B55r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001B55r 3                       ; 65816, so we have to fake the indirect jump to vector it.
001B55r 3                       ; This is depressingly slow. We use this routine internally
001B55r 3                       ; to avoid manipulating the Data Stack when we just want a
001B55r 3                       ; character
001B55r 3  6C rr rr                     jmp (input)             ; JSR/RTS
001B58r 3               
001B58r 3               
001B58r 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
001B58r 3               ; ## "latestnt"  auto  Tali Forth
001B58r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001B58r 3                       ; The Gforth version of this word is called LATEST
001B58r 3                       ; """
001B58r 3               xt_latestnt:
001B58r 3  CA                           dex
001B59r 3  CA                           dex
001B5Ar 3               
001B5Ar 3  20 rr rr                     jsr current_to_dp
001B5Dr 3               
001B5Dr 3  A5 rr                        lda dp
001B5Fr 3  95 00                        sta 0,x
001B61r 3  A5 rr                        lda dp+1
001B63r 3  95 01                        sta 1,x
001B65r 3               
001B65r 3  60           z_latestnt:     rts
001B66r 3               
001B66r 3               
001B66r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001B66r 3               ; ## "latestxt"  auto  Gforth
001B66r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001B66r 3               xt_latestxt:
001B66r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
001B69r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
001B6Cr 3               
001B6Cr 3  60           z_latestxt:     rts
001B6Dr 3               
001B6Dr 3               
001B6Dr 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
001B6Dr 3               ; ## "leave"  auto  ANS core
001B6Dr 3                       ; """https://forth-standard.org/standard/core/LEAVE
001B6Dr 3                       ; Note that this does not work with anything but a DO/LOOP in
001B6Dr 3                       ; contrast to other versions such as discussed at
001B6Dr 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
001B6Dr 3                       ;
001B6Dr 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
001B6Dr 3                       ; See the Control Flow section in the manual for details of how this works.
001B6Dr 3                       ; This must be native compile and not IMMEDIATE
001B6Dr 3                       ; """
001B6Dr 3               
001B6Dr 3               xt_leave:
001B6Dr 3                               ; We dump the limit/start entries off the Return Stack
001B6Dr 3                               ; (four bytes)
001B6Dr 3  68                           pla
001B6Er 3  68                           pla
001B6Fr 3  68                           pla
001B70r 3  68                           pla
001B71r 3               
001B71r 3  60                           rts             ; this must be compiled, so keep before z_leave
001B72r 3               z_leave:                        ; not reached, not compiled
001B72r 3               
001B72r 3               
001B72r 3               
001B72r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001B72r 3               ; ## "["  auto  ANS core
001B72r 3                       ; """https://forth-standard.org/standard/core/Bracket
001B72r 3                       ; This is an immediate and compile-only word
001B72r 3                       ; """
001B72r 3               xt_left_bracket:
001B72r 3  64 rr                        stz state
001B74r 3  64 rr                        stz state+1
001B76r 3               
001B76r 3  60           z_left_bracket: rts
001B77r 3               
001B77r 3               
001B77r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
001B77r 3               ; ## "<#"  auto  ANS core
001B77r 3                       ; """https://forth-standard.org/standard/core/num-start
001B77r 3                       ; Start the process to create pictured numeric output.
001B77r 3                       ;
001B77r 3                       ; The new
001B77r 3                       ; string is constructed from back to front, saving the new character
001B77r 3                       ; at the beginning of the output string. Since we use PAD as a
001B77r 3                       ; starting address and work backward (!), the string is constructed
001B77r 3                       ; in the space between the end of the Dictionary (as defined by CP)
001B77r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
001B77r 3                       ; programs don't fool around with the PAD but still use its address.
001B77r 3                       ; Based on pForth
001B77r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001B77r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
001B77r 3                       ; internal variable tohold instead of HLD.
001B77r 3                       ; """
001B77r 3               xt_less_number_sign:
001B77r 3  20 rr rr                     jsr xt_pad      ; ( addr )
001B7Ar 3               
001B7Ar 3  B5 00                        lda 0,x
001B7Cr 3  85 rr                        sta tohold
001B7Er 3  B5 01                        lda 1,x
001B80r 3  85 rr                        sta tohold+1
001B82r 3               
001B82r 3  E8                           inx
001B83r 3  E8                           inx
001B84r 3               
001B84r 3               z_less_number_sign:
001B84r 3  60                           rts
001B85r 3               
001B85r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001B85r 3               ; ## "<"  auto  ANS core
001B85r 3                       ; """https://forth-standard.org/standard/core/less"""
001B85r 3               
001B85r 3               xt_less_than:
001B85r 3  20 rr rr                     jsr underflow_2
001B88r 3               
001B88r 3  A0 00                        ldy #0          ; default false
001B8Ar 3  20 rr rr                     jsr compare_16bit
001B8Dr 3               
001B8Dr 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
001B8Dr 3  F0 03                        beq @false
001B8Fr 3  30 01                        bmi @false
001B91r 3               
001B91r 3                               ; true
001B91r 3  88                           dey
001B92r 3               @false:
001B92r 3  98                           tya
001B93r 3               
001B93r 3  E8                           inx
001B94r 3  E8                           inx
001B95r 3  95 00                        sta 0,x
001B97r 3  95 01                        sta 1,x
001B99r 3               
001B99r 3  60           z_less_than:    rts
001B9Ar 3               
001B9Ar 3               
001B9Ar 3               
001B9Ar 3               ; ## LIST ( scr# -- ) "List the given screen"
001B9Ar 3               ; ## "list"  tested  ANS block ext
001B9Ar 3                       ; """https://forth-standard.org/standard/block/LIST"""
001B9Ar 3               
001B9Ar 3               xt_list:
001B9Ar 3  20 rr rr                     jsr underflow_1
001B9Dr 3               
001B9Dr 3                               ; Save the screen number in SCR
001B9Dr 3  20 rr rr                     jsr xt_scr
001BA0r 3  20 rr rr                     jsr xt_store
001BA3r 3               
001BA3r 3                               ; Use L from the editor-wordlist to display the screen.
001BA3r 3  20 rr rr                     jsr xt_editor_l
001BA6r 3               
001BA6r 3  60           z_list:         rts
001BA7r 3               
001BA7r 3               
001BA7r 3               
001BA7r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001BA7r 3               ; ## "literal"  auto  ANS core
001BA7r 3                       ; """https://forth-standard.org/standard/core/LITERAL
001BA7r 3                       ; Compile-only word to store TOS so that it is pushed on stack
001BA7r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001BA7r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001BA7r 3                       ;
001BA7r 3                       ; Note the cmpl_ routines use TMPTOS
001BA7r 3                       ; """
001BA7r 3               xt_literal:
001BA7r 3  20 rr rr                     jsr underflow_1
001BAAr 3               
001BAAr 3  A0 rr                        ldy #>literal_runtime
001BACr 3  A9 rr                        lda #<literal_runtime
001BAEr 3  20 rr rr                     jsr cmpl_subroutine
001BB1r 3               
001BB1r 3                               ; Compile the value that is to be pushed on the Stack during
001BB1r 3                               ; runtime
001BB1r 3  20 rr rr                     jsr xt_comma
001BB4r 3               
001BB4r 3  60           z_literal:      rts
001BB5r 3               
001BB5r 3               literal_runtime:
001BB5r 3               
001BB5r 3                               ; During runtime, we push the value following this word back
001BB5r 3                               ; on the Data Stack. The subroutine jump that brought us
001BB5r 3                               ; here put the address to return to on the Return Stack -
001BB5r 3                               ; this points to the data we need to get. This routine is
001BB5r 3                               ; also called (LITERAL) in some Forths
001BB5r 3  CA                           dex
001BB6r 3  CA                           dex
001BB7r 3               
001BB7r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001BB7r 3                               ; so we are actually popping the address-1 of the literal
001BB7r 3  68                           pla             ; LSB
001BB8r 3  85 rr                        sta tmp1
001BBAr 3  68                           pla             ; MSB
001BBBr 3  85 rr                        sta tmp1+1
001BBDr 3               
001BBDr 3                               ; Fetch the actual literal value and push it on Data stack
001BBDr 3  A0 01                        ldy #1
001BBFr 3  B1 rr                        lda (tmp1),y    ; LSB
001BC1r 3  95 00                        sta 0,x
001BC3r 3  C8                           iny
001BC4r 3  B1 rr                        lda (tmp1),y    ; MSB
001BC6r 3  95 01                        sta 1,x
001BC8r 3               
001BC8r 3                               ; Adjust return address and push back on the Return Stack
001BC8r 3  98                           tya
001BC9r 3  18                           clc
001BCAr 3  65 rr                        adc tmp1
001BCCr 3  A8                           tay
001BCDr 3  A5 rr                        lda tmp1+1
001BCFr 3  69 00                        adc #0
001BD1r 3  48                           pha
001BD2r 3  5A                           phy
001BD3r 3               
001BD3r 3  60                           rts
001BD4r 3               
001BD4r 3               
001BD4r 3               
001BD4r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
001BD4r 3               ; ## "load"  auto  ANS block
001BD4r 3                       ; """https://forth-standard.org/standard/block/LOAD
001BD4r 3                       ;
001BD4r 3                       ; Note: LOAD current works because there is only one buffer.
001BD4r 3                       ; If/when multiple buffers are supported, we'll have to deal
001BD4r 3                       ; with the fact that it might re-load the old block into a
001BD4r 3                       ; different buffer.
001BD4r 3                       ; """
001BD4r 3               
001BD4r 3               xt_load:
001BD4r 3  20 rr rr                     jsr underflow_1
001BD7r 3               
001BD7r 3                               ; Save the current value of BLK on the return stack.
001BD7r 3  A0 01                        ldy #blk_offset+1
001BD9r 3  B1 rr                        lda (up),y
001BDBr 3  48                           pha
001BDCr 3  88                           dey
001BDDr 3  B1 rr                        lda (up),y
001BDFr 3  48                           pha
001BE0r 3               
001BE0r 3                               ; Set BLK to the given block/screen number.
001BE0r 3  B5 00                        lda 0,x
001BE2r 3  91 rr                        sta (up),y
001BE4r 3  C8                           iny
001BE5r 3  B5 01                        lda 1,x
001BE7r 3  91 rr                        sta (up),y
001BE9r 3               
001BE9r 3                               ; Load that block into a buffer
001BE9r 3  20 rr rr                     jsr xt_block
001BECr 3               
001BECr 3                               ; Put 1024 on the stack for the screen length.
001BECr 3  CA                           dex
001BEDr 3  CA                           dex
001BEEr 3  A9 04                        lda #4
001BF0r 3  95 01                        sta 1,x
001BF2r 3  74 00                        stz 0,x
001BF4r 3               
001BF4r 3                               ; Jump to a special evluate target. This bypasses the underflow
001BF4r 3                               ; check and skips the zeroing of BLK.
001BF4r 3  20 rr rr                     jsr load_evaluate
001BF7r 3               
001BF7r 3                               ; Restore the value of BLK from before the LOAD command.
001BF7r 3  A0 00                        ldy #blk_offset
001BF9r 3  68                           pla
001BFAr 3  91 rr                        sta (up),y
001BFCr 3  C8                           iny
001BFDr 3  68                           pla
001BFEr 3  91 rr                        sta (up),y
001C00r 3               
001C00r 3                               ; If BLK is not zero, read it back into the buffer.
001C00r 3                               ; A still has MSB
001C00r 3  88                           dey
001C01r 3  11 rr                        ora (up),y
001C03r 3  F0 12                        beq @done
001C05r 3               
001C05r 3                               ; The block needs to be read back into the buffer.
001C05r 3  CA                           dex
001C06r 3  CA                           dex
001C07r 3  A0 00                        ldy #blk_offset
001C09r 3  B1 rr                        lda (up),y
001C0Br 3  95 00                        sta 0,x
001C0Dr 3  C8                           iny
001C0Er 3  B1 rr                        lda (up),y
001C10r 3  95 01                        sta 1,x
001C12r 3  20 rr rr                     jsr xt_block
001C15r 3               
001C15r 3                               ; Drop the buffer address.
001C15r 3  E8                           inx
001C16r 3  E8                           inx
001C17r 3               
001C17r 3               @done:
001C17r 3  60           z_load:         rts
001C18r 3               
001C18r 3               
001C18r 3               
001C18r 3               ; ## LOOP ( -- ) "Finish loop construct"
001C18r 3               ; ## "loop"  auto  ANS core
001C18r 3                       ; """https://forth-standard.org/standard/core/LOOP
001C18r 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001C18r 3                       ; the stack and then call +LOOP.
001C18r 3                       ;
001C18r 3                       ; In Forth, this is
001C18r 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001C18r 3                       ;       IMMEDIATE ; COMPILE-ONLY
001C18r 3                       ; """
001C18r 3               xt_loop:
001C18r 3                               ; Have the finished word push 1 on the stack
001C18r 3  A0 rr                        ldy #>xt_one
001C1Ar 3  A9 rr                        lda #<xt_one
001C1Cr 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
001C1Fr 3               
001C1Fr 3               
001C1Fr 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
001C1Fr 3               ; ## "+loop"  auto  ANS core
001C1Fr 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
001C1Fr 3                       ;
001C1Fr 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
001C1Fr 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
001C1Fr 3                       ;       COMPILE-ONLY
001C1Fr 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
001C1Fr 3                       ; address for looping as TOS and the address for aborting the loop
001C1Fr 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
001C1Fr 3                       ; DO and the Control Flow section of the manual for details).
001C1Fr 3                       ; """
001C1Fr 3               
001C1Fr 3               xt_plus_loop:
001C1Fr 3                               ; Compile the run-time part. We do this with a short loop
001C1Fr 3                               ; and not a call to COMPILE, because it has to be natively
001C1Fr 3                               ; coded anyway.
001C1Fr 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
001C21r 3  5A                           phy             ; save counter to adjust CP
001C22r 3               @1:
001C22r 3  B9 rr rr                     lda plus_loop_runtime,y
001C25r 3  91 rr                        sta (cp),y
001C27r 3  88                           dey
001C28r 3  10 F8                        bpl @1
001C2Ar 3               
001C2Ar 3                               ; Adjust CP
001C2Ar 3  68                           pla
001C2Br 3  18                           clc
001C2Cr 3  65 rr                        adc cp
001C2Er 3  85 rr                        sta cp
001C30r 3  A5 rr                        lda cp+1
001C32r 3  69 00                        adc #0          ; only need carry
001C34r 3  85 rr                        sta cp+1
001C36r 3               
001C36r 3                               ; The address we need to loop back to is TOS. Store it so
001C36r 3                               ; the runtime part of +LOOP jumps back up there
001C36r 3  20 rr rr                     jsr xt_comma
001C39r 3               
001C39r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001C39r 3                               ; of six PLA, so we just do it here instead jumping around
001C39r 3                               ; all over the place
001C39r 3  A9 68                        lda #$68                ; opcode for PLA
001C3Br 3  A0 06                        ldy #6
001C3Dr 3               @2:
001C3Dr 3  91 rr                        sta (cp),y
001C3Fr 3  88                           dey
001C40r 3  10 FB                        bpl @2
001C42r 3               
001C42r 3                               ; Adjust CP
001C42r 3  A9 06                        lda #6
001C44r 3  18                           clc
001C45r 3  65 rr                        adc cp
001C47r 3  85 rr                        sta cp
001C49r 3  A5 rr                        lda cp+1
001C4Br 3  69 00                        adc #0                  ; only need carry
001C4Dr 3  85 rr                        sta cp+1
001C4Fr 3               
001C4Fr 3                               ; Complete compile of DO/?DO by replacing the six
001C4Fr 3                               ; dummy bytes by PHA instructions. The address where
001C4Fr 3                               ; they are located is on the Data Stack
001C4Fr 3  B5 00                        lda 0,x
001C51r 3  85 rr                        sta tmp1
001C53r 3  B5 01                        lda 1,x
001C55r 3  85 rr                        sta tmp1+1
001C57r 3  E8                           inx
001C58r 3  E8                           inx
001C59r 3               
001C59r 3                               ; Because of the way that CP works, we don't have to save
001C59r 3                               ; CP, but CP-1
001C59r 3  A5 rr                        lda cp
001C5Br 3  38                           sec
001C5Cr 3  E9 01                        sbc #1
001C5Er 3  85 rr                        sta tmp2
001C60r 3  A5 rr                        lda cp+1
001C62r 3  E9 00                        sbc #0
001C64r 3  85 rr                        sta tmp2+1
001C66r 3               
001C66r 3                               ; now compile this in the DO/?DO routine
001C66r 3  A0 00                        ldy #0
001C68r 3               
001C68r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001C6Ar 3  91 rr                        sta (tmp1),y
001C6Cr 3  C8                           iny
001C6Dr 3  A5 rr                        lda tmp2+1      ; MSB
001C6Fr 3  91 rr                        sta (tmp1),y
001C71r 3  C8                           iny
001C72r 3  A9 48                        lda #$48        ; Opcode for PHA
001C74r 3  91 rr                        sta (tmp1),y
001C76r 3  C8                           iny
001C77r 3               
001C77r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001C79r 3  91 rr                        sta (tmp1),y
001C7Br 3  C8                           iny
001C7Cr 3  A5 rr                        lda tmp2        ; LSB
001C7Er 3  91 rr                        sta (tmp1),y
001C80r 3  C8                           iny
001C81r 3  A9 48                        lda #$48        ; Opcode for PHA
001C83r 3  91 rr                        sta (tmp1),y
001C85r 3               z_loop:
001C85r 3  60           z_plus_loop:    rts
001C86r 3               
001C86r 3               
001C86r 3               plus_loop_runtime:
001C86r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001C86r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001C86r 3                       ; loop control so we can test with the Overflow Flag. See
001C86r 3                       ; the Control Flow section of the manual for details.
001C86r 3                       ; The step value is TOS in the loop. This
001C86r 3                       ; must always be native compiled. In some Forths, this is a separate
001C86r 3                       ; word called (+LOOP) or (LOOP)
001C86r 3                       ; """
001C86r 3               
001C86r 3  18                           clc
001C87r 3  68                           pla             ; LSB of index
001C88r 3  75 00                        adc 0,x         ; LSB of step
001C8Ar 3  A8                           tay             ; temporary storage of LSB
001C8Br 3               
001C8Br 3  B8                           clv
001C8Cr 3  68                           pla             ; MSB of index
001C8Dr 3  75 01                        adc 1,x         ; MSB of step
001C8Fr 3  48                           pha             ; put MSB of index back on stack
001C90r 3               
001C90r 3  98                           tya             ; put LSB of index back on stack
001C91r 3  48                           pha
001C92r 3               
001C92r 3  E8                           inx             ; dump step from TOS
001C93r 3  E8                           inx
001C94r 3               
001C94r 3                               ; If V flag is set, we're done looping and continue
001C94r 3                               ; after the +LOOP instruction
001C94r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001C96r 3               
001C96r 3               @hack:          ; This is why this routine must be natively compiled: We
001C96r 3                               ; compile the opcode for JMP here without an address to
001C96r 3                               ; go to, which is added by the next next instruction of
001C96r 3                               ; LOOP/+LOOP during compile time
001C96r 3  4C                           .byte $4C
001C97r 3               
001C97r 3               plus_loop_runtime_end:
001C97r 3               
001C97r 3               
001C97r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001C97r 3               ; ## "lshift"  auto  ANS core
001C97r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001C97r 3               
001C97r 3               xt_lshift:
001C97r 3  20 rr rr                     jsr underflow_2
001C9Ar 3               
001C9Ar 3                               ; max shift 16 times
001C9Ar 3  B5 00                        lda 0,x
001C9Cr 3  29 0F                        and #%00001111
001C9Er 3  F0 08                        beq @done
001CA0r 3               
001CA0r 3  A8                           tay
001CA1r 3               
001CA1r 3               @loop:
001CA1r 3  16 02                        asl 2,x
001CA3r 3  36 03                        rol 3,x
001CA5r 3  88                           dey
001CA6r 3  D0 F9                        bne @loop
001CA8r 3               
001CA8r 3               @done:
001CA8r 3  E8                           inx
001CA9r 3  E8                           inx
001CAAr 3               
001CAAr 3  60           z_lshift:       rts
001CABr 3               
001CABr 3               
001CABr 3               
001CABr 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001CABr 3               ; ## "m*"  auto  ANS core
001CABr 3                       ; """https://forth-standard.org/standard/core/MTimes
001CABr 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001CABr 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001CABr 3                       ;
001CABr 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001CABr 3                       ; with  : D+- O< IF DNEGATE THEN ;
001CABr 3                       ; """
001CABr 3               
001CABr 3               xt_m_star:
001CABr 3  20 rr rr                     jsr underflow_2
001CAEr 3               
001CAEr 3                               ; figure out the sign
001CAEr 3  B5 01                        lda 1,x         ; MSB of n1
001CB0r 3  55 03                        eor 3,x         ; MSB of n2
001CB2r 3               
001CB2r 3                               ; UM* uses all kinds of temporary variables so we don't
001CB2r 3                               ; risk a conflict but just take the cycle hit and push
001CB2r 3                               ; this to the stack
001CB2r 3  48                           pha
001CB3r 3               
001CB3r 3                               ; get the absolute value of both numbers so we can feed
001CB3r 3                               ; them to UM*, which does the real work
001CB3r 3  20 rr rr                     jsr xt_abs
001CB6r 3  20 rr rr                     jsr xt_swap
001CB9r 3  20 rr rr                     jsr xt_abs
001CBCr 3               
001CBCr 3  20 rr rr                     jsr xt_um_star          ; ( d )
001CBFr 3               
001CBFr 3                               ; handle the sign
001CBFr 3  68                           pla
001CC0r 3  10 03                        bpl @done
001CC2r 3               
001CC2r 3  20 rr rr                     jsr xt_dnegate
001CC5r 3               @done:
001CC5r 3  60           z_m_star:       rts
001CC6r 3               
001CC6r 3               
001CC6r 3               
001CC6r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001CC6r 3               ; ## "marker"  auto  ANS core ext
001CC6r 3                       ; """https://forth-standard.org/standard/core/MARKER
001CC6r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001CC6r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001CC6r 3                       ; Run the named word at a later time to restore all of the wordlists
001CC6r 3                       ; to their state when the word was created with marker.  Any words
001CC6r 3                       ; created after the marker (including the marker) will be forgotten.
001CC6r 3                       ;
001CC6r 3                       ; To do this, we want to end up with something that jumps to a
001CC6r 3                       ; run-time component with a link to the original CP and DP values:
001CC6r 3                       ;
001CC6r 3                       ;       jsr marker_runtime
001CC6r 3                       ;       <Original CP MSB>
001CC6r 3                       ;       <Original CP LSB>
001CC6r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001CC6r 3                       ;       <Original DP LSB>
001CC6r 3                       ;       < USER variables from offset 4 to 39 >
001CC6r 3                       ;
001CC6r 3                       ;       The user variables include:
001CC6r 3                       ;       CURRENT (byte variable)
001CC6r 3                       ;       <All wordlists> (currently 12) (cell array)
001CC6r 3                       ;       <#ORDER> (byte variable)
001CC6r 3                       ;       <All search order> (currently 9) (byte array)
001CC6r 3                       ;
001CC6r 3                       ; This code uses tmp1 and tmp2
001CC6r 3                       ; """
001CC6r 3               
001CC6r 3               xt_marker:
001CC6r 3                               ; Before we do anything, we need to save CP, which
001CC6r 3                               ; after all is the whole point of this operation. CREATE
001CC6r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001CC6r 3                               ; to the stack
001CC6r 3  20 rr rr                     jsr current_to_dp
001CC9r 3               
001CC9r 3  A5 rr                        lda dp
001CCBr 3  48                           pha
001CCCr 3  A5 rr                        lda dp+1
001CCEr 3  48                           pha
001CCFr 3               
001CCFr 3  A5 rr                        lda cp
001CD1r 3  48                           pha
001CD2r 3  A5 rr                        lda cp+1
001CD4r 3  48                           pha
001CD5r 3               
001CD5r 3  20 rr rr                     jsr xt_create
001CD8r 3               
001CD8r 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001CD8r 3                               ; we have to replace by a jump to marker_runtime. We back up
001CD8r 3                               ; two bytes and then overwrite the address
001CD8r 3  A5 rr                        lda cp          ; LSB
001CDAr 3  38                           sec
001CDBr 3  E9 02                        sbc #2
001CDDr 3  85 rr                        sta cp
001CDFr 3               
001CDFr 3  A5 rr                        lda cp+1        ; MSB
001CE1r 3  E9 00                        sbc #0          ; we only care about the borrow
001CE3r 3  85 rr                        sta cp+1
001CE5r 3               
001CE5r 3                               ; Add the address of the runtime component
001CE5r 3  A0 rr                        ldy #>marker_runtime
001CE7r 3  A9 rr                        lda #<marker_runtime
001CE9r 3  20 rr rr                     jsr cmpl_word
001CECr 3               
001CECr 3                               ; Add original CP as payload
001CECr 3  7A                           ply                     ; MSB
001CEDr 3  68                           pla                     ; LSB
001CEEr 3  20 rr rr                     jsr cmpl_word
001CF1r 3               
001CF1r 3                               ; Add original DP as payload
001CF1r 3  7A                           ply                     ; MSB
001CF2r 3  68                           pla                     ; LSB
001CF3r 3  20 rr rr                     jsr cmpl_word
001CF6r 3               
001CF6r 3                               ; Add the user variables for the wordlists and search order.
001CF6r 3                               ; We're compiling them in byte order.
001CF6r 3  A0 04                        ldy #4                  ; Start at CURRENT
001CF8r 3               @marker_loop:
001CF8r 3  B1 rr                        lda (up),y
001CFAr 3  20 rr rr                     jsr cmpl_a
001CFDr 3  C8                           iny
001CFEr 3  98                           tya
001CFFr 3  C9 28                        cmp #40                 ; One past the end of the search order.
001D01r 3  D0 F5                        bne @marker_loop
001D03r 3               
001D03r 3  60           z_marker:       rts
001D04r 3               
001D04r 3               
001D04r 3               
001D04r 3               marker_runtime:
001D04r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
001D04r 3                       ; when this marker was defined. We arrive here with the return
001D04r 3                       ; address on the Return Stack in the usual 65c02 format
001D04r 3                       ; """
001D04r 3               
001D04r 3                               ; Get the address of the string address off the stack and
001D04r 3                               ; increase by one because of the RTS mechanics
001D04r 3  68                           pla
001D05r 3  85 rr                        sta tmp1        ; LSB of address
001D07r 3  68                           pla
001D08r 3  85 rr                        sta tmp1+1      ; MSB of address
001D0Ar 3               
001D0Ar 3  E6 rr                        inc tmp1
001D0Cr 3  D0 02                        bne @1
001D0Er 3  E6 rr                        inc tmp1+1
001D10r 3               @1:
001D10r 3  A0 00                        ldy #0
001D12r 3               
001D12r 3                               ; CP was stored first
001D12r 3  B1 rr                        lda (tmp1),y
001D14r 3  85 rr                        sta cp
001D16r 3  C8                           iny
001D17r 3  B1 rr                        lda (tmp1),y
001D19r 3  85 rr                        sta cp+1
001D1Br 3               
001D1Br 3                               ; Next was DP
001D1Br 3  C8                           iny
001D1Cr 3  B1 rr                        lda (tmp1),y
001D1Er 3  85 rr                        sta dp
001D20r 3  C8                           iny
001D21r 3  B1 rr                        lda (tmp1),y
001D23r 3  85 rr                        sta dp+1
001D25r 3               
001D25r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001D25r 3                               ; to start restoring the wordlists and search order.
001D25r 3  A0 04                        ldy #4
001D27r 3               
001D27r 3               @marker_restore_loop:
001D27r 3                               ; Copy from the dictionary back on top of the wordlists
001D27r 3                               ; and search order.
001D27r 3  B1 rr                        lda (tmp1), y
001D29r 3  91 rr                        sta (up), y
001D2Br 3  C8                           iny
001D2Cr 3  98                           tya
001D2Dr 3  C9 28                        cmp #40                 ; One past the end of the search order.
001D2Fr 3  D0 F6                        bne @marker_restore_loop
001D31r 3               
001D31r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001D34r 3               
001D34r 3                               ; The return instruction takes us back to the original caller
001D34r 3  60                           rts
001D35r 3               
001D35r 3               
001D35r 3               
001D35r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001D35r 3               ; ## "max"  auto  ANS core
001D35r 3                       ; """https://forth-standard.org/standard/core/MAX
001D35r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001D35r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001D35r 3                       ; Flag indicates which number is larger. See also
001D35r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001D35r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001D35r 3                       ; """
001D35r 3               
001D35r 3               xt_max:
001D35r 3  20 rr rr                     jsr underflow_2
001D38r 3               
001D38r 3                               ; Compare LSB. We do this first to set the carry flag
001D38r 3  B5 00                        lda 0,x         ; LSB of TOS
001D3Ar 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001D3Cr 3               
001D3Cr 3  B5 01                        lda 1,x         ; MSB of TOS
001D3Er 3  F5 03                        sbc 3,x         ; MSB of NOS
001D40r 3  50 02                        bvc @no_overflow
001D42r 3               
001D42r 3                               ; handle overflow, because we use signed numbers
001D42r 3  49 80                        eor #$80        ; complement negative flag
001D44r 3               
001D44r 3               @no_overflow:
001D44r 3                               ; if negative, NOS is larger and needs to be kept
001D44r 3  30 08                        bmi @keep_nos
001D46r 3               
001D46r 3                               ; move TOS to NOS
001D46r 3  B5 00                        lda 0,x
001D48r 3  95 02                        sta 2,x
001D4Ar 3  B5 01                        lda 1,x
001D4Cr 3  95 03                        sta 3,x
001D4Er 3               
001D4Er 3               @keep_nos:
001D4Er 3  E8                           inx
001D4Fr 3  E8                           inx
001D50r 3               
001D50r 3  60           z_max:          rts
001D51r 3               
001D51r 3               
001D51r 3               
001D51r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001D51r 3               ; ## "min"  auto  ANS core
001D51r 3                       ; """https://forth-standard.org/standard/core/MIN
001D51r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001D51r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001D51r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001D51r 3                       ; """
001D51r 3               
001D51r 3               xt_min:
001D51r 3  20 rr rr                     jsr underflow_2
001D54r 3               
001D54r 3                               ; compare LSB. We do this first to set the carry flag
001D54r 3  B5 00                        lda 0,x         ; LSB of TOS
001D56r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001D58r 3               
001D58r 3  B5 01                        lda 1,x         ; MSB of TOS
001D5Ar 3  F5 03                        sbc 3,x         ; MSB of NOS
001D5Cr 3  50 02                        bvc @no_overflow
001D5Er 3               
001D5Er 3                               ; handle overflow because we use signed numbers
001D5Er 3  49 80                        eor #$80
001D60r 3               
001D60r 3               @no_overflow:
001D60r 3                               ; if negative, NOS is larger and needs to be dumped
001D60r 3  10 08                        bpl @keep_nos
001D62r 3               
001D62r 3                               ; move TOS to NOS
001D62r 3  B5 00                        lda 0,x
001D64r 3  95 02                        sta 2,x
001D66r 3  B5 01                        lda 1,x
001D68r 3  95 03                        sta 3,x
001D6Ar 3               
001D6Ar 3               @keep_nos:
001D6Ar 3  E8                           inx
001D6Br 3  E8                           inx
001D6Cr 3               
001D6Cr 3  60           z_min:          rts
001D6Dr 3               
001D6Dr 3               
001D6Dr 3               
001D6Dr 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001D6Dr 3               ; ## "-"  auto  ANS core
001D6Dr 3                       ; """https://forth-standard.org/standard/core/Minus"""
001D6Dr 3               xt_minus:
001D6Dr 3  20 rr rr                     jsr underflow_2
001D70r 3               
001D70r 3  38                           sec
001D71r 3  B5 02                        lda 2,x         ; LSB
001D73r 3  F5 00                        sbc 0,x
001D75r 3  95 02                        sta 2,x
001D77r 3               
001D77r 3  B5 03                        lda 3,x         ; MSB
001D79r 3  F5 01                        sbc 1,x
001D7Br 3  95 03                        sta 3,x
001D7Dr 3               
001D7Dr 3  E8                           inx
001D7Er 3  E8                           inx
001D7Fr 3               
001D7Fr 3  60           z_minus:        rts
001D80r 3               
001D80r 3               
001D80r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001D80r 3               ; ## "-leading"  auto  Tali String
001D80r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001D80r 3                       ; """
001D80r 3               
001D80r 3               xt_minus_leading:
001D80r 3  20 rr rr                     jsr underflow_2
001D83r 3               
001D83r 3               @loop:
001D83r 3                               ; Quit if we were given an empty string. This also terminates
001D83r 3                               ; the main loop
001D83r 3  B5 00                        lda 0,x
001D85r 3  15 01                        ora 1,x
001D87r 3  F0 0F                        beq @done
001D89r 3               
001D89r 3  A1 02                        lda (2,x)               ; get first character
001D8Br 3  20 rr rr                     jsr is_whitespace
001D8Er 3  90 08                        bcc @done
001D90r 3               
001D90r 3                               ; It's whitespace, move one down
001D90r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001D93r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001D96r 3               
001D96r 3  80 EB                        bra @loop
001D98r 3               @done:
001D98r 3               z_minus_leading:
001D98r 3  60                           rts
001D99r 3               
001D99r 3               
001D99r 3               
001D99r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001D99r 3               ; ## "-trailing"  auto  ANS string
001D99r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001D99r 3                       ; Remove trailing spaces
001D99r 3                       ; """
001D99r 3               
001D99r 3               xt_minus_trailing:
001D99r 3  20 rr rr                     jsr underflow_2
001D9Cr 3               
001D9Cr 3                               ; if length entry is zero, return a zero and leave the
001D9Cr 3                               ; address part untouched
001D9Cr 3  B5 00                        lda 0,x         ; LSB of n
001D9Er 3  15 01                        ora 1,x         ; MSB of n
001DA0r 3  F0 33                        beq @done
001DA2r 3               
001DA2r 3                               ; Compute address of last char in tmp1 as
001DA2r 3                               ; addr + u1 - 1
001DA2r 3               
001DA2r 3                               ; addr + u1
001DA2r 3  18                           clc
001DA3r 3  B5 02                        lda 2,x         ; LSB of addr
001DA5r 3  75 00                        adc 0,x
001DA7r 3  85 rr                        sta tmp1
001DA9r 3  B5 03                        lda 3,x         ; MSB of addr
001DABr 3  75 01                        adc 1,x
001DADr 3  85 rr                        sta tmp1+1
001DAFr 3               
001DAFr 3                               ; - 1
001DAFr 3  A5 rr                        lda tmp1
001DB1r 3  D0 02                        bne @1
001DB3r 3  C6 rr                        dec tmp1+1
001DB5r 3               @1:
001DB5r 3  C6 rr                        dec tmp1
001DB7r 3               
001DB7r 3               @loop:
001DB7r 3                               ; While spaces are found, move tmp1 backwards and
001DB7r 3                               ; decrease the count on the data stack.
001DB7r 3  B2 rr                        lda (tmp1)
001DB9r 3  C9 20                        cmp #AscSP
001DBBr 3  D0 18                        bne @done
001DBDr 3               
001DBDr 3                               ; Move back one address.
001DBDr 3  A5 rr                        lda tmp1
001DBFr 3  D0 02                        bne @2
001DC1r 3  C6 rr                        dec tmp1+1
001DC3r 3               @2:
001DC3r 3  C6 rr                        dec tmp1
001DC5r 3               
001DC5r 3                               ; Decrement count by one.
001DC5r 3  B5 00                        lda 0,x
001DC7r 3  D0 02                        bne @3
001DC9r 3  D6 01                        dec 1,x
001DCBr 3               @3:
001DCBr 3  D6 00                        dec 0,x
001DCDr 3               
001DCDr 3                               ; Check if there are any characters left.
001DCDr 3  B5 00                        lda 0,x
001DCFr 3  15 01                        ora 1,x
001DD1r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
001DD3r 3               
001DD3r 3  80 E2                        bra @loop
001DD5r 3               
001DD5r 3               @done:
001DD5r 3               z_minus_trailing:
001DD5r 3  60                           rts
001DD6r 3               
001DD6r 3               
001DD6r 3               
001DD6r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001DD6r 3               ; ## "mod"  auto  ANS core
001DD6r 3                       ; """https://forth-standard.org/standard/core/MOD
001DD6r 3                       ;
001DD6r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001DD6r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001DD6r 3                       ; """
001DD6r 3               xt_mod:
001DD6r 3  20 rr rr                     jsr underflow_2
001DD9r 3               
001DD9r 3  20 rr rr                     jsr xt_slash_mod
001DDCr 3               
001DDCr 3  E8                           inx             ; DROP
001DDDr 3  E8                           inx
001DDEr 3               z_mod:
001DDEr 3  60                           rts
001DDFr 3               
001DDFr 3               
001DDFr 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
001DDFr 3               ; ## "move"  auto  ANS core
001DDFr 3                       ; """https://forth-standard.org/standard/core/MOVE
001DDFr 3                       ; Copy u "address units" from addr1 to addr2. Since our address
001DDFr 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
001DDFr 3                       ; is actually the only one of these three words that is in the CORE
001DDFr 3                       ; set.
001DDFr 3                       ;
001DDFr 3                       ; This word must not be natively compiled.
001DDFr 3                       ; """
001DDFr 3               
001DDFr 3               xt_move:
001DDFr 3                               ; We let CMOVE and CMOVE> check if there is underflow or
001DDFr 3                               ; we've been told to copy zero bytes
001DDFr 3               
001DDFr 3                               ; compare MSB first
001DDFr 3  B5 03                        lda 3,x                 ; MSB of addr2
001DE1r 3  D5 05                        cmp 5,x                 ; MSB of addr1
001DE3r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001DE5r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001DE7r 3               
001DE7r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001DEAr 3               
001DEAr 3               @lsb:
001DEAr 3                               ; MSB were equal, so do the whole thing over with LSB
001DEAr 3  B5 02                        lda 2,x                 ; LSB of addr2
001DECr 3  D5 04                        cmp 4,x                 ; LSB of addr1
001DEEr 3  F0 08                        beq @equal              ; LSB is equal as well
001DF0r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
001DF2r 3               
001DF2r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001DF5r 3               
001DF5r 3               @to_move_up:
001DF5r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
001DF8r 3               @equal:
001DF8r 3                               ; drop three entries from Data Stack
001DF8r 3  8A                           txa
001DF9r 3  18                           clc
001DFAr 3  69 06                        adc #6
001DFCr 3  AA                           tax
001DFDr 3               
001DFDr 3  60           z_move:         rts
001DFEr 3               
001DFEr 3               
001DFEr 3               
001DFEr 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
001DFEr 3               ; ## "name>int"  tested  Gforth
001DFEr 3                       ; """See
001DFEr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001DFEr 3                       ; """
001DFEr 3               
001DFEr 3               xt_name_to_int:
001DFEr 3  20 rr rr                     jsr underflow_1
001E01r 3               
001E01r 3                               ; The xt starts four bytes down from the nt
001E01r 3  B5 00                        lda 0,x
001E03r 3  18                           clc
001E04r 3  69 04                        adc #4
001E06r 3  85 rr                        sta tmp3
001E08r 3               
001E08r 3  B5 01                        lda 1,x
001E0Ar 3  90 01                        bcc @done
001E0Cr 3  1A                           inc
001E0Dr 3               @done:
001E0Dr 3  85 rr                        sta tmp3+1
001E0Fr 3               
001E0Fr 3  A0 00                        ldy #0
001E11r 3  B1 rr                        lda (tmp3),y
001E13r 3  95 00                        sta 0,x
001E15r 3  C8                           iny
001E16r 3  B1 rr                        lda (tmp3),y
001E18r 3  95 01                        sta 1,x
001E1Ar 3               
001E1Ar 3  60           z_name_to_int:  rts
001E1Br 3               
001E1Br 3               
001E1Br 3               
001E1Br 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
001E1Br 3               ; ## "name>string"  tested  Gforth
001E1Br 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
001E1Br 3               
001E1Br 3               xt_name_to_string:
001E1Br 3  20 rr rr                     jsr underflow_1
001E1Er 3               
001E1Er 3  CA                           dex
001E1Fr 3  CA                           dex
001E20r 3               
001E20r 3                               ; the length of the string is the first byte of the
001E20r 3                               ; header pointed to by nt
001E20r 3  A1 02                        lda (2,x)
001E22r 3  95 00                        sta 0,x
001E24r 3  74 01                        stz 1,x
001E26r 3               
001E26r 3                               ; the string itself always starts eight bytes down
001E26r 3  B5 02                        lda 2,x         ; LSB
001E28r 3  18                           clc
001E29r 3  69 08                        adc #8
001E2Br 3  A8                           tay
001E2Cr 3  B5 03                        lda 3,x         ; MSB
001E2Er 3  69 00                        adc #0          ; just need carry
001E30r 3  95 03                        sta 3,x
001E32r 3  94 02                        sty 2,x
001E34r 3               
001E34r 3               z_name_to_string:
001E34r 3  60                           rts
001E35r 3               
001E35r 3               
001E35r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001E35r 3               ; ## "nc-limit"  tested  Tali Forth
001E35r 3               
001E35r 3               xt_nc_limit:
001E35r 3  CA                           dex
001E36r 3  CA                           dex
001E37r 3  A9 rr                        lda #<nc_limit
001E39r 3  95 00                        sta 0,x
001E3Br 3  A9 rr                        lda #>nc_limit
001E3Dr 3  95 01                        sta 1,x
001E3Fr 3               
001E3Fr 3  60           z_nc_limit:     rts
001E40r 3               
001E40r 3               
001E40r 3               
001E40r 3               ; ## NEGATE ( n -- n ) "Two's complement"
001E40r 3               ; ## "negate"  auto  ANS core
001E40r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001E40r 3               xt_negate:
001E40r 3  20 rr rr                     jsr underflow_1
001E43r 3               
001E43r 3  A9 00                	lda #0
001E45r 3  38                           sec
001E46r 3  F5 00                        sbc 0,x         ; LSB
001E48r 3  95 00                        sta 0,x
001E4Ar 3               
001E4Ar 3  A9 00                        lda #0
001E4Cr 3  F5 01                        sbc 1,x         ; MSB
001E4Er 3  95 01                        sta 1,x
001E50r 3               
001E50r 3  60           z_negate:       rts
001E51r 3               
001E51r 3               
001E51r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001E51r 3               ; ## "never-native"  auto  Tali Forth
001E51r 3               xt_never_native:
001E51r 3  20 rr rr                     jsr current_to_dp
001E54r 3  A0 01                        ldy #1          ; offset for status byte
001E56r 3  B1 rr                        lda (dp),y
001E58r 3  09 08                        ora #NN         ; Make sure NN flag is set
001E5Ar 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
001E5Cr 3  91 rr                        sta (dp),y
001E5Er 3               z_never_native:
001E5Er 3  60                           rts
001E5Fr 3               
001E5Fr 3               
001E5Fr 3               ; ## NIP ( b a -- a ) "Delete NOS"
001E5Fr 3               ; ## "nip"  auto  ANS core ext
001E5Fr 3                       ; """https://forth-standard.org/standard/core/NIP"""
001E5Fr 3               xt_nip:
001E5Fr 3  20 rr rr                     jsr underflow_2
001E62r 3               
001E62r 3  B5 00                        lda 0,x         ; LSB
001E64r 3  95 02                        sta 2,x
001E66r 3  B5 01                        lda 1,x         ; MSB
001E68r 3  95 03                        sta 3,x
001E6Ar 3               
001E6Ar 3  E8                           inx
001E6Br 3  E8                           inx
001E6Cr 3               
001E6Cr 3  60           z_nip:          rts
001E6Dr 3               
001E6Dr 3               
001E6Dr 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
001E6Dr 3               ; ## "<>"  auto  ANS core ext
001E6Dr 3                       ; """https://forth-standard.org/standard/core/ne
001E6Dr 3                       ;
001E6Dr 3                       ; This is just a variant of EQUAL, we code it separately
001E6Dr 3                       ; for speed.
001E6Dr 3                       ; """
001E6Dr 3               
001E6Dr 3               xt_not_equals:
001E6Dr 3  20 rr rr                     jsr underflow_2
001E70r 3               
001E70r 3  A0 00                        ldy #0                  ; default is true
001E72r 3               
001E72r 3  B5 00                        lda 0,x                 ; LSB
001E74r 3  D5 02                        cmp 2,x
001E76r 3  D0 0A                        bne @not_equal
001E78r 3               
001E78r 3                               ; LSB is equal
001E78r 3  B5 01                        lda 1,x                 ; MSB
001E7Ar 3  D5 03                        cmp 3,x
001E7Cr 3  D0 04                        bne @not_equal
001E7Er 3               
001E7Er 3  A9 FF                        lda #$FF
001E80r 3  80 01                        bra @done
001E82r 3               
001E82r 3               @not_equal:
001E82r 3  88                           dey                     ; drop thru to done
001E83r 3               
001E83r 3               @done:
001E83r 3  98                           tya
001E84r 3  E8                           inx
001E85r 3  E8                           inx
001E86r 3  95 00                        sta 0,x
001E88r 3  95 01                        sta 1,x
001E8Ar 3               
001E8Ar 3  60           z_not_equals:   rts
001E8Br 3               
001E8Br 3               
001E8Br 3               
001E8Br 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
001E8Br 3               ; ## "-rot"  auto  Gforth
001E8Br 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
001E8Br 3               
001E8Br 3               xt_not_rote:
001E8Br 3  20 rr rr                     jsr underflow_3
001E8Er 3               
001E8Er 3  B4 01                        ldy 1,x         ; MSB first
001E90r 3  B5 03                        lda 3,x
001E92r 3  95 01                        sta 1,x
001E94r 3               
001E94r 3  B5 05                        lda 5,x
001E96r 3  95 03                        sta 3,x
001E98r 3  94 05                        sty 5,x
001E9Ar 3               
001E9Ar 3  B4 00                        ldy 0,x         ; LSB second
001E9Cr 3  B5 02                        lda 2,x
001E9Er 3  95 00                        sta 0,x
001EA0r 3               
001EA0r 3  B5 04                        lda 4,x
001EA2r 3  95 02                        sta 2,x
001EA4r 3  94 04                        sty 4,x
001EA6r 3               
001EA6r 3  60           z_not_rote:     rts
001EA7r 3               
001EA7r 3               
001EA7r 3               
001EA7r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001EA7r 3               ; ## "number"  auto  Tali Forth
001EA7r 3                       ; """Convert a number string to a double or single cell number. This
001EA7r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001EA7r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001EA7r 3                       ; Based in part on the "Starting Forth" code
001EA7r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001EA7r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001EA7r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001EA7r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001EA7r 3                       ; dot to signal a double cell number is required to be the last
001EA7r 3                       ; character of the string.
001EA7r 3                       ;
001EA7r 3                       ; Number calls >NUMBER which in turn calls UM*,
001EA7r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001EA7r 3                       ; a pain.
001EA7r 3                       ;"""
001EA7r 3               
001EA7r 3               xt_number:
001EA7r 3  20 rr rr                     jsr underflow_2
001EAAr 3               
001EAAr 3                               ; we keep the flags for sign and double in tmpdsp because
001EAAr 3                               ; we've run out of temporary variables
001EAAr 3  64 rr                        stz tmpdsp      ; flag for double
001EACr 3  64 rr                        stz tmpdsp+1    ; flag for minus
001EAEr 3               
001EAEr 3                               ; If the first character is a minus, strip it off and set
001EAEr 3                               ; the flag
001EAEr 3  A1 02                        lda (2,x)
001EB0r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001EB2r 3  D0 0A                        bne @check_dot
001EB4r 3               
001EB4r 3                               ; It's a minus
001EB4r 3  C6 rr                        dec tmpdsp+1
001EB6r 3  F6 02                        inc 2,x         ; start one character later
001EB8r 3  D0 02                        bne @1
001EBAr 3  F6 03                        inc 3,x
001EBCr 3               @1:
001EBCr 3  D6 00                        dec 0,x         ; decrease string length by one
001EBEr 3               
001EBEr 3               @check_dot:
001EBEr 3                               ; If the last character is a dot, strip it off and set a
001EBEr 3                               ; flag. We can use tmptos as a temporary variable
001EBEr 3  B5 02                        lda 2,x         ; LSB of address
001EC0r 3  18                           clc
001EC1r 3  75 00                        adc 0,x         ; length of string
001EC3r 3  85 rr                        sta tmptos
001EC5r 3  B5 03                        lda 3,x
001EC7r 3  69 00                        adc #0          ; only need carry
001EC9r 3  85 rr                        sta tmptos+1
001ECBr 3               
001ECBr 3                               ; tmptos now points to the first character after the string,
001ECBr 3                               ; but we need the last character
001ECBr 3  A5 rr                        lda tmptos
001ECDr 3  D0 02                        bne @2
001ECFr 3  C6 rr                        dec tmptos+1
001ED1r 3               @2:
001ED1r 3  C6 rr                        dec tmptos
001ED3r 3               
001ED3r 3  B2 rr                        lda (tmptos)
001ED5r 3  C9 2E                        cmp #'.'
001ED7r 3  D0 04                        bne @main
001ED9r 3               
001ED9r 3                               ; We have a dot, which means this is a double number. Flag
001ED9r 3                               ; the fact and reduce string length by one
001ED9r 3  C6 rr                        dec tmpdsp
001EDBr 3  D6 00                        dec 0,x
001EDDr 3               
001EDDr 3               @main:
001EDDr 3                               ; Set up stack for subroutine jump to >NUMBER, which means
001EDDr 3                               ; we have to go ( addr u --> ud addr u )
001EDDr 3  CA                           dex
001EDEr 3  CA                           dex
001EDFr 3  CA                           dex
001EE0r 3  CA                           dex
001EE1r 3               
001EE1r 3  B5 04                        lda 4,x         ; LSB of length
001EE3r 3  95 00                        sta 0,x
001EE5r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
001EE7r 3               
001EE7r 3  B5 06                        lda 6,x         ; LSB of address
001EE9r 3  95 02                        sta 2,x
001EEBr 3  B5 07                        lda 7,x         ; MSB of address
001EEDr 3  95 03                        sta 3,x
001EEFr 3               
001EEFr 3  74 04                        stz 4,x         ; clear space for ud
001EF1r 3  74 05                        stz 5,x
001EF3r 3  74 06                        stz 6,x
001EF5r 3  74 07                        stz 7,x
001EF7r 3               
001EF7r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
001EFAr 3               
001EFAr 3                               ; test length of returned string, which should be zero
001EFAr 3  B5 00                        lda 0,x
001EFCr 3  F0 15                        beq @all_converted
001EFEr 3               
001EFEr 3                               ; Something went wrong, we still have characters left over,
001EFEr 3                               ; so we print an error and abort. If the NUMBER was called
001EFEr 3                               ; by INTERPRET, we've already checked for Forth words, so
001EFEr 3                               ; we're in deep trouble one way or another
001EFEr 3  A9 3E                        lda #$3E        ; ASCII for ">"
001F00r 3  20 rr rr                     jsr emit_a
001F03r 3  20 rr rr                     jsr xt_type
001F06r 3  A9 3C                        lda #$3C        ; ASCII for "<"
001F08r 3  20 rr rr                     jsr emit_a
001F0Br 3  20 rr rr                     jsr xt_space
001F0Er 3               
001F0Er 3  A9 08                        lda #err_syntax
001F10r 3  4C rr rr                     jmp error
001F13r 3               
001F13r 3               @all_converted:
001F13r 3                               ; We can drop the string info
001F13r 3  E8                           inx
001F14r 3  E8                           inx
001F15r 3  E8                           inx
001F16r 3  E8                           inx
001F17r 3               
001F17r 3                               ; We have a double-cell number on the Data Stack that might
001F17r 3                               ; actually have a minus and might actually be single-cell
001F17r 3  A5 rr                        lda tmpdsp      ; flag for double
001F19r 3  F0 0D                        beq @single
001F1Br 3               
001F1Br 3                               ; Set status bit 5 to indicate this is a double number
001F1Br 3  A9 20                        lda #%00100000
001F1Dr 3  04 rr                        tsb status
001F1Fr 3               
001F1Fr 3                               ; This is a double cell number. If it had a minus, we'll have
001F1Fr 3                               ; to negate it
001F1Fr 3  A5 rr                        lda tmpdsp+1
001F21r 3  F0 12                        beq @done       ; no minus, all done
001F23r 3               
001F23r 3  20 rr rr                     jsr xt_dnegate
001F26r 3               
001F26r 3  80 0D                        bra @done
001F28r 3               
001F28r 3               @single:
001F28r 3                               ; This is a single number, so we just drop the top cell
001F28r 3  E8                           inx
001F29r 3  E8                           inx
001F2Ar 3               
001F2Ar 3                               ; Clear status bit 5 to indicate this is a single number
001F2Ar 3  A9 20                        lda #%00100000
001F2Cr 3  14 rr                        trb status
001F2Er 3               
001F2Er 3                               ; If we had a minus, we'll have to negate it
001F2Er 3  A5 rr                        lda tmpdsp+1
001F30r 3  F0 03                        beq @done       ; no minus, all done
001F32r 3               
001F32r 3  20 rr rr                     jsr xt_negate
001F35r 3               @done:
001F35r 3  60           z_number:       rts
001F36r 3               
001F36r 3               
001F36r 3               
001F36r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001F36r 3               ; ## "#"  auto  ANS core
001F36r 3                       ; """https://forth-standard.org/standard/core/num
001F36r 3                       ; Add one char to the beginning of the pictured output string.
001F36r 3                       ;
001F36r 3                       ; Based on
001F36r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001F36r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001F36r 3                       ; """
001F36r 3               xt_number_sign:
001F36r 3  20 rr rr                     jsr underflow_2         ; double number
001F39r 3               
001F39r 3  20 rr rr                     jsr xt_base
001F3Cr 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
001F3Fr 3               
001F3Fr 3                               ; The following code is the ancient Forth word UD/MOD, which in
001F3Fr 3                               ; various Forths (including Gforth) lives on under the hood,
001F3Fr 3                               ; even though it's not an ANS standard word, it doesn't appear
001F3Fr 3                               ; in the docs, it's only used here, and there are no tests for
001F3Fr 3                               ; it. This is why we got rid of it. We'll be converting this
001F3Fr 3                               ; mess to something more sane in the long run.
001F3Fr 3  20 rr rr                     jsr xt_to_r             ; >r
001F42r 3  20 rr rr                     jsr xt_zero             ; 0
001F45r 3  20 rr rr                     jsr xt_r_fetch          ; r@
001F48r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001F4Br 3  20 rr rr                     jsr xt_rot              ; rot
001F4Er 3  20 rr rr                     jsr xt_rot              ; rot
001F51r 3  20 rr rr                     jsr xt_r_from           ; r>
001F54r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001F57r 3  20 rr rr                     jsr xt_rot              ; rot
001F5Ar 3                               ; end of UD/MOD ( rem ud )
001F5Ar 3               
001F5Ar 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
001F5Dr 3               
001F5Dr 3                               ; Convert the number that is left over to an ASCII character. We
001F5Dr 3                               ; use a string lookup for speed. Use either abc_str_lower for
001F5Dr 3                               ; lower case or abc_str_upper for upper case (prefered)
001F5Dr 3  B5 00                        lda 0,x
001F5Fr 3  A8                           tay
001F60r 3  B9 rr rr                     lda s_abc_upper,y
001F63r 3  95 00                        sta 0,x
001F65r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
001F67r 3               
001F67r 3  20 rr rr                     jsr xt_hold
001F6Ar 3               
001F6Ar 3               z_number_sign:
001F6Ar 3  60                           rts
001F6Br 3               
001F6Br 3               
001F6Br 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
001F6Br 3               ; ## "#>"  auto  ANS core
001F6Br 3                       ; """https://forth-standard.org/standard/core/num-end
001F6Br 3                       ; Finish conversion of pictured number string, putting address and
001F6Br 3                       ; length on the Data Stack.
001F6Br 3                       ;
001F6Br 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
001F6Br 3                       ; Based on
001F6Br 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001F6Br 3                       ; """
001F6Br 3               xt_number_sign_greater:
001F6Br 3               
001F6Br 3  20 rr rr                     jsr underflow_2         ; double number
001F6Er 3               
001F6Er 3                               ; The start address lives in tohold
001F6Er 3  A5 rr                        lda tohold
001F70r 3  95 00                        sta 0,x         ; LSB of tohold
001F72r 3  95 02                        sta 2,x
001F74r 3  A5 rr                        lda tohold+1
001F76r 3  95 01                        sta 1,x         ; MSB of addr
001F78r 3  95 03                        sta 3,x         ; ( addr addr )
001F7Ar 3               
001F7Ar 3                               ; The length of the string is pad - addr
001F7Ar 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
001F7Dr 3               
001F7Dr 3  38                           sec
001F7Er 3  B5 00                        lda 0,x         ; LSB of pad address
001F80r 3  F5 02                        sbc 2,x
001F82r 3  95 02                        sta 2,x
001F84r 3               
001F84r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001F86r 3  F5 03                        sbc 3,x
001F88r 3  95 03                        sta 3,x         ; ( addr u pad )
001F8Ar 3               
001F8Ar 3  E8                           inx
001F8Br 3  E8                           inx
001F8Cr 3               
001F8Cr 3               z_number_sign_greater:
001F8Cr 3  60                           rts
001F8Dr 3               
001F8Dr 3               
001F8Dr 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
001F8Dr 3               ; ## "#s"  auto  ANS core
001F8Dr 3                       ; """https://forth-standard.org/standard/core/numS
001F8Dr 3                       ; Completely convert number for pictured numerical output.
001F8Dr 3                       ;
001F8Dr 3                       ; Based on
001F8Dr 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
001F8Dr 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
001F8Dr 3                       ; """
001F8Dr 3               
001F8Dr 3               xt_number_sign_s:
001F8Dr 3  20 rr rr                     jsr underflow_2
001F90r 3               @loop:
001F90r 3                               ; convert a single number ("#")
001F90r 3  20 rr rr                     jsr xt_number_sign
001F93r 3               
001F93r 3                               ; stop when double-celled number in TOS is zero:
001F93r 3  B5 00                        lda 0,x
001F95r 3  15 01                        ora 1,x
001F97r 3  15 02                        ora 2,x
001F99r 3  15 03                        ora 3,x
001F9Br 3  D0 F3                        bne @loop
001F9Dr 3               
001F9Dr 3               z_number_sign_s:
001F9Dr 3  60                           rts
001F9Er 3               
001F9Er 3               
001F9Er 3               
001F9Er 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
001F9Er 3               ; ## "of"  auto  ANS core ext
001F9Er 3                       ; """http://forth-standard.org/standard/core/OF"""
001F9Er 3               
001F9Er 3               xt_of:
001F9Er 3                               ; Check if value is equal to this case.
001F9Er 3                               ; Postpone over (eg. compile a jsr to it)
001F9Er 3  A0 rr                        ldy #>xt_over
001FA0r 3  A9 rr                        lda #<xt_over
001FA2r 3  20 rr rr                     jsr cmpl_subroutine
001FA5r 3               
001FA5r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001FA5r 3  A0 rr                        ldy #>xt_equal
001FA7r 3  A9 rr                        lda #<xt_equal
001FA9r 3  20 rr rr                     jsr cmpl_subroutine
001FACr 3               
001FACr 3  20 rr rr                     jsr xt_if
001FAFr 3               
001FAFr 3                               ; If it's true, consume the original value.
001FAFr 3                               ; Postpone DROP (eg. compile a jsr to it)
001FAFr 3  A0 rr                        ldy #>xt_drop
001FB1r 3  A9 rr                        lda #<xt_drop
001FB3r 3  20 rr rr                     jsr cmpl_subroutine
001FB6r 3               
001FB6r 3  60           z_of:           rts
001FB7r 3               
001FB7r 3               
001FB7r 3               
001FB7r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
001FB7r 3               ; ## "1"  auto  Tali Forth
001FB7r 3                       ; """This is also the code for EDITOR-WORDLIST"""
001FB7r 3               xt_editor_wordlist:
001FB7r 3               xt_one:
001FB7r 3  CA                           dex
001FB8r 3  CA                           dex
001FB9r 3  A9 01                        lda #1
001FBBr 3  95 00                        sta 0,x
001FBDr 3  74 01                        stz 1,x
001FBFr 3               
001FBFr 3               z_editor_wordlist:
001FBFr 3               z_one:
001FBFr 3  60                           rts
001FC0r 3               
001FC0r 3               
001FC0r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001FC0r 3               ; ## "1-"  auto  ANS core
001FC0r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001FC0r 3               
001FC0r 3               xt_one_minus:
001FC0r 3  20 rr rr                     jsr underflow_1
001FC3r 3               
001FC3r 3  B5 00                        lda 0,x
001FC5r 3  D0 02                        bne @1
001FC7r 3  D6 01                        dec 1,x
001FC9r 3               @1:
001FC9r 3  D6 00                        dec 0,x
001FCBr 3               
001FCBr 3  60           z_one_minus:    rts
001FCCr 3               
001FCCr 3               
001FCCr 3               
001FCCr 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
001FCCr 3               ; ## "1+"  auto  ANS core
001FCCr 3                       ; """https://forth-standard.org/standard/core/OnePlus
001FCCr 3                       ;
001FCCr 3                       ; Code is shared with CHAR-PLUS
001FCCr 3                       ; """
001FCCr 3               
001FCCr 3               xt_char_plus:
001FCCr 3               xt_one_plus:
001FCCr 3  20 rr rr                     jsr underflow_1
001FCFr 3               
001FCFr 3  F6 00                        inc 0,x
001FD1r 3  D0 02                        bne @done
001FD3r 3  F6 01                        inc 1,x
001FD5r 3               
001FD5r 3               @done:
001FD5r 3               z_char_plus:
001FD5r 3  60           z_one_plus:     rts
001FD6r 3               
001FD6r 3               
001FD6r 3               
001FD6r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
001FD6r 3               ; ## "only"  auto  ANS search ext
001FD6r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
001FD6r 3               
001FD6r 3               xt_only:
001FD6r 3                               ; Put -1 on data stack.
001FD6r 3  CA                           dex
001FD7r 3  CA                           dex
001FD8r 3  A9 FF                        lda #$FF
001FDAr 3  95 00                        sta 0,x
001FDCr 3  95 01                        sta 1,x
001FDEr 3               
001FDEr 3                               ; Invoke set-order to set the minimum search order.
001FDEr 3  20 rr rr                     jsr xt_set_order
001FE1r 3               
001FE1r 3  60           z_only:         rts
001FE2r 3               
001FE2r 3               
001FE2r 3               
001FE2r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
001FE2r 3               ; ## "or"  auto  ANS core
001FE2r 3                       ; """https://forth-standard.org/standard/core/OR"
001FE2r 3               xt_or:
001FE2r 3  20 rr rr                     jsr underflow_2
001FE5r 3               
001FE5r 3  B5 00                        lda 0,x
001FE7r 3  15 02                        ora 2,x
001FE9r 3  95 02                        sta 2,x
001FEBr 3               
001FEBr 3  B5 01                        lda 1,x
001FEDr 3  15 03                        ora 3,x
001FEFr 3  95 03                        sta 3,x
001FF1r 3               
001FF1r 3  E8                           inx
001FF2r 3  E8                           inx
001FF3r 3               
001FF3r 3  60           z_or:           rts
001FF4r 3               
001FF4r 3               
001FF4r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
001FF4r 3               ; ## "order"  auto  ANS core
001FF4r 3                       ; """https://forth-standard.org/standard/search/ORDER
001FF4r 3                       ; Note the search order is displayed from first search to last
001FF4r 3                       ; searched and is therefore exactly the reverse of the order in which
001FF4r 3                       ; Forth stacks are displayed.
001FF4r 3                       ;
001FF4r 3                       ; A Forth implementation of this word is:
001FF4r 3                       ;
001FF4r 3                       ; 	: .wid ( wid -- )
001FF4r 3                       ; 	dup 0=  if ." Forth "  drop    else
001FF4r 3                       ; 	dup 1 = if ." Editor " drop    else
001FF4r 3                       ; 	dup 2 = if ." Assembler " drop else
001FF4r 3                       ; 	dup 3 = if ." Root " drop      else
001FF4r 3                       ; 	           . ( just print the number )
001FF4r 3                       ; 	then then then then ;
001FF4r 3                       ;
001FF4r 3                       ; : ORDER ( -- )
001FF4r 3                       ; 	cr get-order 0 ?do .wid loop
001FF4r 3                       ; 	space space get-current .wid ;
001FF4r 3                       ;
001FF4r 3                       ; This is an interactive program, so speed
001FF4r 3                       ; is not as important as size. We assume we do not have more than 255
001FF4r 3                       ; wordlists.
001FF4r 3                       ; """
001FF4r 3               
001FF4r 3               xt_order:
001FF4r 3  20 rr rr                     jsr xt_cr
001FF7r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
001FFAr 3               
001FFAr 3                               ; Paranoid: Check if there are no wordlists, a rather
001FFAr 3                               ; pathological case. this would mean ( 0 ) on the stack. In
001FFAr 3                               ; that case, we just drop n and run
001FFAr 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
001FFCr 3  F0 1E                        beq @drop_done
001FFEr 3               
001FFEr 3               @have_wordlists:
001FFEr 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
001FFEr 3                               ; on the stack
001FFEr 3  A8                           tay
001FFFr 3               @loop:
001FFFr 3  E8                           inx
002000r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
002001r 3  B5 00                        lda 0,x
002003r 3               
002003r 3  5A                           phy
002004r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
002007r 3  7A                           ply
002008r 3               
002008r 3  88                           dey
002009r 3  D0 F4                        bne @loop
00200Br 3               
00200Br 3                               ; We've printed the wordlists, now we add the current wordlist.
00200Br 3                               ; This follows the convention of Gforth
00200Br 3  20 rr rr                     jsr xt_space
00200Er 3  20 rr rr                     jsr xt_space
002011r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
002014r 3               
002014r 3  B5 00                        lda 0,x
002016r 3  20 rr rr                     jsr _print_wid_string
002019r 3  20 rr rr                     jsr xt_cr
00201Cr 3               
00201Cr 3               @drop_done:
00201Cr 3  E8                           inx
00201Dr 3  E8                           inx
00201Er 3               z_order:
00201Er 3  60                           rts
00201Fr 3               
00201Fr 3               _print_wid_string:
00201Fr 3                       ; """Helper function for ORDER: Given a WID in A, print the
00201Fr 3                       ; corresponding string. If there is no such word list defined, just
00201Fr 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
00201Fr 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
00201Fr 3                       ; theory, we could speed this up by having the WID be the same as the
00201Fr 3                       ; number of the strings. However, ORDER is used rather infrequently and
00201Fr 3                       ; this would make changes to the strings.asm file very dangerous, so we
00201Fr 3                       ; follow the slightly more complicated route with a translation table.
00201Fr 3                       ; """
00201Fr 3                               ; If the WID is larger than 3, we have no string avaliable and
00201Fr 3                               ; just print the number.
00201Fr 3                               ; See http://6502.org/tutorials/compare_instructions.html
00201Fr 3                               ; for details
00201Fr 3  C9 04                        cmp #4
002021r 3  90 09                        bcc @output_string      ; less than 4, print a real string
002023r 3               
002023r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
002023r 3                               ; print the number
002023r 3  CA                           dex
002024r 3  CA                           dex
002025r 3  95 00                        sta 0,x
002027r 3  74 01                        stz 1,x
002029r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
00202Cr 3               
00202Cr 3               @output_string:
00202Cr 3                               ; Get the string number based on WID 0 to 3
00202Cr 3  A8                           tay
00202Dr 3  B9 rr rr                     lda @wid_data,y
002030r 3               
002030r 3                               ; Print without a line feed
002030r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
002033r 3               
002033r 3               @wid_data:
002033r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
002033r 3                       ; less than 4.
002033r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
002034r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
002035r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
002036r 3  08                   .byte str_wid_root             ; WID 3: "Root"
002037r 3               
002037r 3               
002037r 3               
002037r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
002037r 3               ; ## "output"  tested  Tali Forth
002037r 3               xt_output:
002037r 3                       ; """Return the address where the jump target for EMIT is stored (but
002037r 3                       ; not the vector itself). By default, this will hold the value of
002037r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
002037r 3                       ; routine.
002037r 3                       ; """
002037r 3  CA                           dex
002038r 3  CA                           dex
002039r 3  A9 rr                        lda #<output
00203Br 3  95 00                        sta 0,x
00203Dr 3  A9 rr                        lda #>output
00203Fr 3  95 01                        sta 1,x
002041r 3               
002041r 3  60           z_output:       rts
002042r 3               
002042r 3               
002042r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
002042r 3               ; ## "over"  auto  ANS core
002042r 3                       ; """https://forth-standard.org/standard/core/OVER"""
002042r 3               xt_over:
002042r 3  20 rr rr                     jsr underflow_2
002045r 3               
002045r 3  CA                           dex
002046r 3  CA                           dex
002047r 3               
002047r 3  B5 04                        lda 4,x         ; LSB
002049r 3  95 00                        sta 0,x
00204Br 3  B5 05                        lda 5,x         ; MSB
00204Dr 3  95 01                        sta 1,x
00204Fr 3               
00204Fr 3  60           z_over:         rts
002050r 3               
002050r 3               
002050r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
002050r 3               ; ## "pad"  auto  ANS core ext
002050r 3                       ; """https://forth-standard.org/standard/core/PAD
002050r 3                       ; Return address to a temporary area in free memory for user. Must
002050r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
002050r 3                       ; the compile area pointer (CP) and therefore varies in position.
002050r 3                       ; This area is reserved for the user and not used by the system
002050r 3                       ; """
002050r 3               xt_pad:
002050r 3  CA                           dex
002051r 3  CA                           dex
002052r 3               
002052r 3  A5 rr                        lda cp
002054r 3  18                           clc
002055r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
002057r 3  95 00                        sta 0,x
002059r 3               
002059r 3  A5 rr                        lda cp+1
00205Br 3  69 00                        adc #0          ; only need carry
00205Dr 3  95 01                        sta 1,x
00205Fr 3               
00205Fr 3  60           z_pad:          rts
002060r 3               
002060r 3               
002060r 3               ; ## PAGE ( -- ) "Clear the screen"
002060r 3               ; ## "page"  tested  ANS facility
002060r 3                       ; """https://forth-standard.org/standard/facility/PAGE
002060r 3                       ; Clears a page if supported by ANS terminal codes. This is
002060r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
002060r 3                       ; left of the screen
002060r 3                       ; """
002060r 3               xt_page:
002060r 3  A9 1B                        lda #AscESC
002062r 3  20 rr rr                     jsr emit_a
002065r 3  A9 5B                        lda #$5B        ; ASCII for "["
002067r 3  20 rr rr                     jsr emit_a
00206Ar 3  A9 32                        lda #'2'
00206Cr 3  20 rr rr                     jsr emit_a
00206Fr 3  A9 4A                        lda #'J'
002071r 3  20 rr rr                     jsr emit_a
002074r 3               
002074r 3                               ; move cursor to top left of screen
002074r 3  20 rr rr                     jsr xt_zero
002077r 3  20 rr rr                     jsr xt_zero
00207Ar 3  20 rr rr                     jsr xt_at_xy
00207Dr 3               
00207Dr 3  60           z_page:         rts
00207Er 3               
00207Er 3               
00207Er 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
00207Er 3               ; ## "("  auto  ANS core
00207Er 3                       ; """http://forth-standard.org/standard/core/p"""
00207Er 3               
00207Er 3               xt_paren:
00207Er 3                               ; Put a right paren on the stack.
00207Er 3  CA                           dex
00207Fr 3  CA                           dex
002080r 3  A9 29                        lda #41     ; Right parenthesis
002082r 3  95 00                        sta 0,x
002084r 3  74 01                        stz 1,x
002086r 3               
002086r 3                               ; Call parse.
002086r 3  20 rr rr                     jsr xt_parse
002089r 3               
002089r 3                               ; Throw away the result.
002089r 3  E8                           inx
00208Ar 3  E8                           inx
00208Br 3  E8                           inx
00208Cr 3  E8                           inx
00208Dr 3               
00208Dr 3  60           z_paren:        rts
00208Er 3               
00208Er 3               
00208Er 3               
00208Er 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
00208Er 3               ; ## "parse-name"  auto  ANS core ext
00208Er 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
00208Er 3                       ; Find next word in input string, skipping leading whitespace. This is
00208Er 3                       ; a special form of PARSE and drops through to that word. See PARSE
00208Er 3                       ; for more detail. We use this word internally for the interpreter
00208Er 3                       ; because it is a lot easier to use. Reference implementations at
00208Er 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
00208Er 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
00208Er 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
00208Er 3                       ; though the ANS standard talks about skipping "spaces", whitespace
00208Er 3                       ; is actually perfectly legal (see for example
00208Er 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
00208Er 3                       ; Otherwise, PARSE-NAME chokes on tabs.
00208Er 3                       ; """
00208Er 3               
00208Er 3               xt_parse_name:
00208Er 3                               ; To enable the compilation of the high-level Forth words
00208Er 3                               ; in forth-words.asm and user-words.asm at boot time,
00208Er 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
00208Er 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
00208Er 3                               ; to the current location is in toin (>IN). We need to check,
00208Er 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
00208Er 3                               ; we can't just use Y as an index.
00208Er 3               
00208Er 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
00208Er 3  A5 rr                        lda ciblen              ; LSB of counter
002090r 3  38                           sec
002091r 3  E5 rr                        sbc toin
002093r 3  85 rr                        sta tmp1
002095r 3  A5 rr                        lda ciblen+1            ; MSB
002097r 3  E5 rr                        sbc toin+1
002099r 3  85 rr                        sta tmp1+1
00209Br 3               
00209Br 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
00209Br 3  A5 rr                        lda tmp1
00209Dr 3  05 rr                        ora tmp1+1
00209Fr 3  F0 28                        beq @empty_line
0020A1r 3               
0020A1r 3                               ; We walk through the characters starting at CIB+TOIN, so we
0020A1r 3                               ; save a temp version of that in tmp2
0020A1r 3  A5 rr                        lda cib
0020A3r 3  18                           clc
0020A4r 3  65 rr                        adc toin
0020A6r 3  85 rr                        sta tmp2                ; LSB of first character
0020A8r 3  A5 rr                        lda cib+1
0020AAr 3  65 rr                        adc toin+1
0020ACr 3  85 rr                        sta tmp2+1              ; MSB
0020AEr 3               
0020AEr 3               @skip_loop:
0020AEr 3  B2 rr                        lda (tmp2)              ; work copy of cib
0020B0r 3  20 rr rr                     jsr is_whitespace
0020B3r 3  90 1F                        bcc @char_found
0020B5r 3               
0020B5r 3                               ; Char is still whitespace, continue
0020B5r 3  E6 rr                        inc tmp2
0020B7r 3  D0 02                        bne @2
0020B9r 3  E6 rr                        inc tmp2+1
0020BBr 3               @2:
0020BBr 3                               ; Adjust counter
0020BBr 3  A5 rr                        lda tmp1
0020BDr 3  D0 02                        bne @3
0020BFr 3  C6 rr                        dec tmp1+1
0020C1r 3               @3:
0020C1r 3  C6 rr                        dec tmp1
0020C3r 3               
0020C3r 3  A5 rr                        lda tmp1
0020C5r 3  05 rr                        ora tmp1+1
0020C7r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
0020C9r 3               
0020C9r 3               @empty_line:
0020C9r 3                               ; Neither the ANS Forth nor the Gforth documentation say
0020C9r 3                               ; what to return as an address if a string with only
0020C9r 3                               ; spaces is given. For speed reasons, we just return junk
0020C9r 3                               ; NOS, with the TOS zero as per standard
0020C9r 3  CA                           dex
0020CAr 3  CA                           dex
0020CBr 3  CA                           dex
0020CCr 3  CA                           dex
0020CDr 3               
0020CDr 3  74 00                        stz 0,x                 ; TOS is zero
0020CFr 3  74 01                        stz 1,x
0020D1r 3               
0020D1r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
0020D4r 3               
0020D4r 3               @char_found:
0020D4r 3                               ; We arrive here with tmp2 pointing to the first non-space
0020D4r 3                               ; character. This is where the word really starts, so
0020D4r 3                               ; we use it to calculate the new >IN by subtracting
0020D4r 3  A5 rr                        lda tmp2
0020D6r 3  38                           sec
0020D7r 3  E5 rr                        sbc cib
0020D9r 3  85 rr                        sta toin
0020DBr 3  A5 rr                        lda tmp2+1
0020DDr 3  E5 rr                        sbc cib+1
0020DFr 3  85 rr                        sta toin+1
0020E1r 3               
0020E1r 3                               ; prepare Data Stack for PARSE by adding space
0020E1r 3                               ; as the delimiter
0020E1r 3  CA                           dex
0020E2r 3  CA                           dex
0020E3r 3               
0020E3r 3  A9 20                        lda #AscSP
0020E5r 3  95 00                        sta 0,x
0020E7r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
0020E9r 3               
0020E9r 3               
0020E9r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
0020E9r 3               ; ## "parse"  tested  ANS core ext
0020E9r 3                       ; """https://forth-standard.org/standard/core/PARSE
0020E9r 3                       ; Find word in input string delimited by character given. Do not
0020E9r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
0020E9r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
0020E9r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
0020E9r 3                       ;
0020E9r 3                       ;
0020E9r 3                       ;     cib  cib+toin   cib+ciblen
0020E9r 3                       ;      v      v            v
0020E9r 3                       ;     |###################|
0020E9r 3                       ;
0020E9r 3                       ;     |------>|  toin (>IN)
0020E9r 3                       ;     |------------------->|  ciblen
0020E9r 3                       ;
0020E9r 3                       ; The input string is stored starting at the address in the Current
0020E9r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
0020E9r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
0020E9r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
0020E9r 3                       ; useful string if there are any characters at all. As with
0020E9r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
0020E9r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
0020E9r 3                       ; """
0020E9r 3               
0020E9r 3               xt_parse:
0020E9r 3  20 rr rr                     jsr underflow_1
0020ECr 3               
0020ECr 3                               ; If the input buffer is empty, we just return
0020ECr 3  A5 rr                        lda ciblen
0020EEr 3  05 rr                        ora ciblen+1
0020F0r 3  F0 0C                        beq @abort_parse
0020F2r 3               
0020F2r 3                               ; If the pointer >IN is larger or equal to the length of
0020F2r 3                               ; the input buffer (CIBLEN), the line is done. Put
0020F2r 3                               ; differently, we only continue if >IN is smaller than
0020F2r 3                               ; CIBLEN
0020F2r 3  A5 rr                        lda toin+1              ; MSB
0020F4r 3  C5 rr                        cmp ciblen+1
0020F6r 3  90 0E                        bcc @go_parse           ; unsigned comparison
0020F8r 3               
0020F8r 3  A5 rr                        lda toin                ; LSB
0020FAr 3  C5 rr                        cmp ciblen
0020FCr 3  90 08                        bcc @go_parse
0020FEr 3               
0020FEr 3               @abort_parse:
0020FEr 3                               ; Sorry, this line is over
0020FEr 3  CA                           dex
0020FFr 3  CA                           dex
002100r 3  74 00                        stz 0,x
002102r 3  74 01                        stz 1,x
002104r 3               
002104r 3  80 7A                        bra @done
002106r 3               @go_parse:
002106r 3                               ; We actually have work to do. Save the delimiter in
002106r 3                               ; tmptos.
002106r 3  B5 00                        lda 0,x
002108r 3  85 rr                        sta tmptos
00210Ar 3               
00210Ar 3                               ; We can now prepare the Data Stack for the return value
00210Ar 3  CA                           dex
00210Br 3  CA                           dex
00210Cr 3               
00210Cr 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
00210Cr 3                               ; tmp2 is initially the same as tmp1, then the work index
00210Cr 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
00210Cr 3               
00210Cr 3                               ; Calculate the beginning of the string, which is also the
00210Cr 3                               ; address to return
00210Cr 3  A5 rr                        lda cib
00210Er 3  18                           clc
00210Fr 3  65 rr                        adc toin        ; LSB
002111r 3  85 rr                        sta tmp1
002113r 3  85 rr                        sta tmp2
002115r 3  95 02                        sta 2,x
002117r 3               
002117r 3  A5 rr                        lda cib+1
002119r 3  65 rr                        adc toin+1      ; MSB
00211Br 3  85 rr                        sta tmp1+1
00211Dr 3  85 rr                        sta tmp2+1
00211Fr 3  95 03                        sta 3,x
002121r 3               
002121r 3                               ; Calculate the address where the input buffer ends plus 1, so
002121r 3                               ; we can compare it with TOIN, which is an index
002121r 3  A5 rr                        lda cib
002123r 3  18                           clc
002124r 3  65 rr                        adc ciblen
002126r 3  85 rr                        sta tmp3
002128r 3  A5 rr                        lda cib+1
00212Ar 3  65 rr                        adc ciblen+1
00212Cr 3  85 rr                        sta tmp3+1
00212Er 3               
00212Er 3                               ; Initialize the offset we use to adjust EOL or found delimiter
00212Er 3  64 rr                        stz tmptos+1
002130r 3               @loop:
002130r 3                               ; If we are at the end of the string, quit
002130r 3  A5 rr                        lda tmp2
002132r 3  C5 rr                        cmp tmp3
002134r 3  D0 06                        bne @not_empty
002136r 3               
002136r 3  A5 rr                        lda tmp2+1
002138r 3  C5 rr                        cmp tmp3+1
00213Ar 3  F0 1D                        beq @eol
00213Cr 3               @not_empty:
00213Cr 3                               ; We have to do this the hard way. In fact, it's really
00213Cr 3                               ; hard since if we are dealing with a SPACE, the standard
00213Cr 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
00213Cr 3                               ; Tali would choke on tabs between words. For details, see
00213Cr 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
00213Cr 3                               ; In theory, we could make this faster by defining a delimiter
00213Cr 3                               ; that is 00 as the sign that we skip all whitespace, thereby
00213Cr 3                               ; avoiding having to test every time. However, somebody,
00213Cr 3                               ; somewhere might want to parse a zero-delimited list. Since
00213Cr 3                               ; any byte value could be chosen for that, we just test for
00213Cr 3                               ; a space every single time for the moment.
00213Cr 3  B2 rr                        lda (tmp2)
00213Er 3               
00213Er 3  A4 rr                        ldy tmptos
002140r 3  C0 20                        cpy #AscSP
002142r 3  D0 07                        bne @not_whitespace
002144r 3               
002144r 3                               ; The delimiter is a space, so we're looking for all
002144r 3                               ; whitespace
002144r 3  20 rr rr                     jsr is_whitespace
002147r 3  90 02                        bcc @not_whitespace
002149r 3  80 0C                        bra @found_delimiter
00214Br 3               
00214Br 3               @not_whitespace:
00214Br 3                               ; The delimiter is not a space, so we're looking for
00214Br 3                               ; whatever it is
00214Br 3  C5 rr                        cmp tmptos
00214Dr 3  F0 08                        beq @found_delimiter
00214Fr 3               
00214Fr 3                               ; Not a delimiter, next character
00214Fr 3  E6 rr                        inc tmp2
002151r 3  D0 DD                        bne @loop
002153r 3  E6 rr                        inc tmp2+1
002155r 3  80 D9                        bra @loop
002157r 3               
002157r 3               @found_delimiter:
002157r 3                               ; Increase the offset: If we've found a delimiter, we want
002157r 3                               ; TOIN to point to the character after it, not the delimiter
002157r 3                               ; itself
002157r 3  E6 rr                        inc tmptos+1
002159r 3               @eol:
002159r 3                               ; The length of the new string is tmp2-tmp1
002159r 3  A5 rr                        lda tmp2
00215Br 3  38                           sec
00215Cr 3  E5 rr                        sbc tmp1
00215Er 3  95 00                        sta 0,x
002160r 3               
002160r 3  A5 rr                        lda tmp2+1
002162r 3  E5 rr                        sbc tmp1+1
002164r 3  95 01                        sta 1,x
002166r 3               
002166r 3                               ; The new offset is tmp2-cib
002166r 3  A5 rr                        lda tmp2
002168r 3  38                           sec
002169r 3  E5 rr                        sbc cib
00216Br 3  85 rr                        sta toin
00216Dr 3  A5 rr                        lda tmp2+1
00216Fr 3  E5 rr                        sbc cib+1
002171r 3  85 rr                        sta toin+1
002173r 3               
002173r 3                               ; Add in the delimiter
002173r 3  A5 rr                        lda toin
002175r 3  18                           clc
002176r 3  65 rr                        adc tmptos+1
002178r 3  85 rr                        sta toin
00217Ar 3  A5 rr                        lda toin+1
00217Cr 3  69 00                        adc #0          ; we only need the carry
00217Er 3  85 rr                        sta toin+1
002180r 3               @done:
002180r 3               z_parse_name:
002180r 3  60           z_parse:        rts
002181r 3               
002181r 3               
002181r 3               
002181r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
002181r 3               ; ## "pick"  auto  ANS core ext
002181r 3                       ; """https://forth-standard.org/standard/core/PICK
002181r 3                       ; Take the u-th element out of the stack and put it on TOS,
002181r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
002181r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
002181r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
002181r 3                       ; """
002181r 3               
002181r 3               xt_pick:
002181r 3                               ; Checking for underflow is difficult because it depends on
002181r 3                               ; which element we want to grab. We could probably figure
002181r 3                               ; something out, but it wouldn't work with underflow stripping
002181r 3                               ; Since using PICK is considered poor form anyway, we just
002181r 3                               ; leave it as it is
002181r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
002183r 3  8A                           txa
002184r 3  75 00                        adc 0,x
002186r 3  A8                           tay
002187r 3               
002187r 3  B9 02 00                     lda 0002,y
00218Ar 3  95 00                        sta 0,x
00218Cr 3  B9 03 00                     lda 0003,y
00218Fr 3  95 01                        sta 1,x
002191r 3               
002191r 3  60           z_pick:         rts
002192r 3               
002192r 3               
002192r 3               
002192r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
002192r 3               ; ## "+"  auto  ANS core
002192r 3                       ; """https://forth-standard.org/standard/core/Plus"""
002192r 3               xt_plus:
002192r 3  20 rr rr                     jsr underflow_2
002195r 3               
002195r 3  18                           clc
002196r 3  B5 00                        lda 0,x         ; LSB
002198r 3  75 02                        adc 2,x
00219Ar 3  95 02                        sta 2,x
00219Cr 3               
00219Cr 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
00219Er 3  75 03                        adc 3,x
0021A0r 3  95 03                        sta 3,x
0021A2r 3               
0021A2r 3  E8                           inx
0021A3r 3  E8                           inx
0021A4r 3               
0021A4r 3  60           z_plus:         rts
0021A5r 3               
0021A5r 3               
0021A5r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
0021A5r 3               ; ## "+!"  auto  ANS core
0021A5r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
0021A5r 3               xt_plus_store:
0021A5r 3  20 rr rr                     jsr underflow_2
0021A8r 3               
0021A8r 3                               ; move address to tmp1 so we can work with it
0021A8r 3  B5 00                        lda 0,x
0021AAr 3  85 rr                        sta tmp1
0021ACr 3  B5 01                        lda 1,x
0021AEr 3  85 rr                        sta tmp1+1
0021B0r 3               
0021B0r 3  A0 00                        ldy #0          ; LSB
0021B2r 3  B1 rr                        lda (tmp1),y
0021B4r 3  18                           clc
0021B5r 3  75 02                        adc 2,x
0021B7r 3  91 rr                        sta (tmp1),y
0021B9r 3               
0021B9r 3  C8                           iny             ; MSB
0021BAr 3  B1 rr                        lda (tmp1),y
0021BCr 3  75 03                        adc 3,x
0021BEr 3  91 rr                        sta (tmp1),y
0021C0r 3               
0021C0r 3  E8                           inx
0021C1r 3  E8                           inx
0021C2r 3  E8                           inx
0021C3r 3  E8                           inx
0021C4r 3               
0021C4r 3  60           z_plus_store:   rts
0021C5r 3               
0021C5r 3               
0021C5r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
0021C5r 3               ; ## "postpone"  auto   ANS core
0021C5r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
0021C5r 3                       ; Add the compilation behavior of a word to a new word at
0021C5r 3                       ; compile time. If the word that follows it is immediate, include
0021C5r 3                       ; it so that it will be compiled when the word being defined is
0021C5r 3                       ; itself used for a new word. Tricky, but very useful.
0021C5r 3                       ;
0021C5r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
0021C5r 3                       ; on the Data Stack). This means we cannot build words with
0021C5r 3                       ; "jsr xt_postpone, jsr <word>" directly.
0021C5r 3                       ; """
0021C5r 3               
0021C5r 3               xt_postpone:
0021C5r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
0021C8r 3               
0021C8r 3                               ; if there was no word provided, complain and quit
0021C8r 3  B5 00                        lda 0,x
0021CAr 3  15 01                        ora 1,x
0021CCr 3  D0 05                        bne @1
0021CEr 3               
0021CEr 3  A9 05                        lda #err_noname
0021D0r 3  4C rr rr                     jmp error
0021D3r 3               @1:
0021D3r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
0021D6r 3               
0021D6r 3                               ; if word not in Dictionary, complain and quit
0021D6r 3  D0 05                        bne @2
0021D8r 3  A9 05                        lda #err_noname
0021DAr 3  4C rr rr                     jmp error
0021DDr 3               
0021DDr 3               @2:
0021DDr 3                               ; keep a copy of nt for later
0021DDr 3  B5 00                        lda 0,x
0021DFr 3  85 rr                        sta tmp1
0021E1r 3  B5 01                        lda 1,x
0021E3r 3  85 rr                        sta tmp1+1
0021E5r 3               
0021E5r 3                               ; We need the xt instead of the nt
0021E5r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
0021E8r 3               
0021E8r 3                               ; See if this is an immediate word. This is easier
0021E8r 3                               ; with nt than with xt. The status byte of the word
0021E8r 3                               ; is nt+1
0021E8r 3  E6 rr                        inc tmp1
0021EAr 3  D0 02                        bne @3
0021ECr 3  E6 rr                        inc tmp1+1
0021EEr 3               @3:
0021EEr 3  B2 rr                        lda (tmp1)
0021F0r 3  29 04                        and #IM         ; mask all but Intermediate flag
0021F2r 3  F0 05                        beq @not_immediate
0021F4r 3               
0021F4r 3                               ; We're immediate, so instead of executing it right now, we
0021F4r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
0021F4r 3                               ; takes us back to the original caller
0021F4r 3  20 rr rr                     jsr xt_compile_comma
0021F7r 3  80 0A                        bra @done
0021F9r 3               
0021F9r 3               @not_immediate:
0021F9r 3                               ; This is not an immediate word, so we enact "deferred
0021F9r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
0021F9r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
0021F9r 3                               ; a subroutine jump to COMPILE,
0021F9r 3  20 rr rr                     jsr xt_literal
0021FCr 3               
0021FCr 3                               ; Last, compile COMPILE,
0021FCr 3  A0 rr                        ldy #>xt_compile_comma
0021FEr 3  A9 rr                        lda #<xt_compile_comma
002200r 3  20 rr rr                     jsr cmpl_subroutine
002203r 3               @done:
002203r 3  60           z_postpone:     rts
002204r 3               
002204r 3               
002204r 3               
002204r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
002204r 3               ; ## "previous"  auto  ANS search ext
002204r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
002204r 3               
002204r 3               xt_previous:
002204r 3  20 rr rr                     jsr xt_get_order
002207r 3  20 rr rr                     jsr xt_nip
00220Ar 3  20 rr rr                     jsr xt_one_minus
00220Dr 3  20 rr rr                     jsr xt_set_order
002210r 3               
002210r 3  60           z_previous:     rts
002211r 3               
002211r 3               
002211r 3               
002211r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
002211r 3               ; ## "?"  tested  ANS tools
002211r 3                       ; """https://forth-standard.org/standard/tools/q
002211r 3                       ;
002211r 3                       ; Only used interactively. Since humans are so slow, we
002211r 3                       ; save size and just go for the subroutine jumps
002211r 3                       ; """
002211r 3               xt_question:
002211r 3                               ; FETCH takes care of underflow check
002211r 3  20 rr rr                     jsr xt_fetch
002214r 3  20 rr rr                     jsr xt_dot
002217r 3               
002217r 3  60           z_question:     rts
002218r 3               
002218r 3               
002218r 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
002218r 3               ; ## "?dup"  auto  ANS core
002218r 3                       ; """https://forth-standard.org/standard/core/qDUP"""
002218r 3               
002218r 3               xt_question_dup:
002218r 3  20 rr rr                     jsr underflow_1
00221Br 3               
00221Br 3                               ; Check if TOS is zero
00221Br 3  B5 00                        lda 0,x
00221Dr 3  15 01                        ora 1,x
00221Fr 3  F0 0A                        beq @done
002221r 3               
002221r 3                               ; not zero, duplicate
002221r 3  CA                           dex
002222r 3  CA                           dex
002223r 3  B5 02                        lda 2,x
002225r 3  95 00                        sta 0,x
002227r 3  B5 03                        lda 3,x
002229r 3  95 01                        sta 1,x
00222Br 3               @done:
00222Br 3  60           z_question_dup: rts
00222Cr 3               
00222Cr 3               
00222Cr 3               
00222Cr 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
00222Cr 3               ; ## "r@"  auto  ANS core
00222Cr 3                       ; """https://forth-standard.org/standard/core/RFetch
00222Cr 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
00222Cr 3                       ; work normally as well
00222Cr 3                       ;
00222Cr 3                       ; An alternative way to write this word
00222Cr 3                       ; would be to access the elements on the stack directly like 2R@
00222Cr 3                       ; does, these versions should be compared at some point.
00222Cr 3                       ; """
00222Cr 3               xt_r_fetch:
00222Cr 3                               ; get the return address
00222Cr 3  7A                           ply             ; LSB
00222Dr 3  84 rr                        sty tmp1
00222Fr 3  7A                           ply             ; MSB
002230r 3               
002230r 3                               ; --- CUT FOR NATIVE COMPILE ---
002230r 3               
002230r 3                               ; get the actual top of Return Stack
002230r 3  CA                           dex
002231r 3  CA                           dex
002232r 3               
002232r 3  68                           pla             ; LSB
002233r 3  95 00                        sta 0,x
002235r 3  68                           pla             ; MSB
002236r 3  95 01                        sta 1,x
002238r 3               
002238r 3                               ; now we have to put that value back
002238r 3  48                           pha
002239r 3  B5 00                        lda 0,x
00223Br 3  48                           pha
00223Cr 3               
00223Cr 3                               ; --- CUT FOR NATIVE COMPILE ---
00223Cr 3               
00223Cr 3                               ; restore return value
00223Cr 3  5A                           phy             ; MSB
00223Dr 3  A4 rr                        ldy tmp1
00223Fr 3  5A                           phy             ; LSB
002240r 3               
002240r 3  60           z_r_fetch:      rts
002241r 3               
002241r 3               
002241r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
002241r 3               ; ## "r>"  auto  ANS core
002241r 3                       ; """https://forth-standard.org/standard/core/Rfrom
002241r 3                       ; Move Top of Return Stack to Top of Data Stack.
002241r 3                       ;
002241r 3                       ; We have to move
002241r 3                       ; the RTS address out of the way first. This word is handled
002241r 3                       ; differently for native and and subroutine compilation, see COMPILE,
002241r 3                       ; This is a compile-only word
002241r 3                       ; """
002241r 3               
002241r 3               xt_r_from:
002241r 3                               ; Rescue the address of the return jump that is currently
002241r 3                               ; on top of the Return Stack. If this word is natively
002241r 3                               ; compiled, this is a total waste of time
002241r 3  68                           pla             ; LSB
002242r 3  85 rr                        sta tmptos
002244r 3  7A                           ply             ; MSB
002245r 3               
002245r 3                               ; --- CUT FOR NATIVE CODING ---
002245r 3               
002245r 3  CA                           dex
002246r 3  CA                           dex
002247r 3               
002247r 3                               ; now we can access the actual data
002247r 3               
002247r 3  68                           pla             ; LSB
002248r 3  95 00                        sta 0,x
00224Ar 3  68                           pla             ; MSB
00224Br 3  95 01                        sta 1,x
00224Dr 3               
00224Dr 3                               ; --- CUT FOR NATIVE CODING ---
00224Dr 3               
00224Dr 3                               ; restore the return address
00224Dr 3  5A                           phy             ; MSB
00224Er 3  A5 rr                        lda tmptos
002250r 3  48                           pha             ; LSB
002251r 3               
002251r 3  60           z_r_from:       rts
002252r 3               
002252r 3               
002252r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
002252r 3               ; ## "r>input"  tested  Tali Forth
002252r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
002252r 3                       ; and toin from the Return Stack.
002252r 3                       ;
002252r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
002252r 3                       ; """
002252r 3               
002252r 3               xt_r_to_input:
002252r 3               
002252r 3                               ; We arrive here with the return address on the top of the
002252r 3                               ; 65c02's stack. We need to move it out of the way first
002252r 3  68                           pla
002253r 3  85 rr                        sta tmp1
002255r 3  68                           pla
002256r 3  85 rr                        sta tmp1+1
002258r 3               
002258r 3                               ; This assumes that insrc is the first of eight bytes and
002258r 3                               ; toin+1 the last in the sequence we want to save from the Zero
002258r 3                               ; Page. Since we went in reverse order, insrc is now on the top
002258r 3                               ; of the Return Stack.
002258r 3  A0 00                        ldy #0
00225Ar 3               @loop:
00225Ar 3  68                           pla
00225Br 3  99 rr rr                     sta insrc,y
00225Er 3  C8                           iny
00225Fr 3  C0 08                        cpy #8
002261r 3  D0 F7                        bne @loop
002263r 3               
002263r 3                               ; Restore address for return jump
002263r 3  A5 rr                        lda tmp1+1
002265r 3  48                           pha
002266r 3  A5 rr                        lda tmp1
002268r 3  48                           pha
002269r 3               
002269r 3  60           z_r_to_input: 	rts
00226Ar 3               
00226Ar 3               
00226Ar 3               
00226Ar 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
00226Ar 3               ; ## "recurse"  auto  ANS core
00226Ar 3                       ; """https://forth-standard.org/standard/core/RECURSE
00226Ar 3                       ;
00226Ar 3                       ; This word may not be natively compiled
00226Ar 3                       ; """
00226Ar 3               
00226Ar 3               xt_recurse:
00226Ar 3                               ; The whole routine amounts to compiling a reference to
00226Ar 3                               ; the word that is being compiled. First, we save the JSR
00226Ar 3                               ; instruction
00226Ar 3  A0 00                        ldy #0
00226Cr 3               
00226Cr 3  A9 20                        lda #$20        ; opcode for JSR
00226Er 3  91 rr                        sta (cp),y
002270r 3  C8                           iny
002271r 3               
002271r 3                               ; Next, we save the LSB and MSB of the xt of the word
002271r 3                               ; we are currently working on. We first need to see if
002271r 3                               ; WORKWORD has the nt (: started the word) or the
002271r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
002271r 3  24 rr                        bit status
002273r 3  70 0C                        bvs @nt_in_workword
002275r 3               
002275r 3                               ; This is a special :NONAME word. Just copy the xt
002275r 3                               ; from WORKWORD into the dictionary.
002275r 3  A5 rr                        lda workword
002277r 3  91 rr                        sta (cp),y
002279r 3  C8                           iny
00227Ar 3  A5 rr                        lda workword+1
00227Cr 3  91 rr                        sta (cp),y
00227Er 3  C8                           iny
00227Fr 3  80 1B                        bra @update_cp
002281r 3               
002281r 3               @nt_in_workword:
002281r 3                               ; This is a regular : word, so the xt is four bytes down
002281r 3                               ; from the nt which we saved in WORKWORD. We could probably
002281r 3                               ; use NAME>INT here but this is going to be faster, and
002281r 3                               ; fast counts with recursion
002281r 3  A5 rr                        lda workword            ; LSB
002283r 3  18                           clc
002284r 3  69 04                        adc #4
002286r 3  85 rr                        sta tmp1
002288r 3  A5 rr                        lda workword+1          ; MSB
00228Ar 3  69 00                        adc #0
00228Cr 3  85 rr                        sta tmp1+1
00228Er 3               
00228Er 3  B2 rr                        lda (tmp1)
002290r 3  91 rr                        sta (cp),y
002292r 3  5A                           phy
002293r 3  A0 01                        ldy #1
002295r 3  B1 rr                        lda (tmp1),y
002297r 3  7A                           ply
002298r 3  C8                           iny
002299r 3  91 rr                        sta (cp),y
00229Br 3  C8                           iny
00229Cr 3               
00229Cr 3               @update_cp:
00229Cr 3  98                           tya
00229Dr 3  18                           clc
00229Er 3  65 rr                        adc cp
0022A0r 3  85 rr                        sta cp
0022A2r 3  90 02                        bcc @done
0022A4r 3  E6 rr                        inc cp+1
0022A6r 3               @done:
0022A6r 3  60           z_recurse:      rts
0022A7r 3               
0022A7r 3               
0022A7r 3               
0022A7r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
0022A7r 3               ; ## "refill"  tested  ANS core ext
0022A7r 3                       ; """https://forth-standard.org/standard/core/REFILL
0022A7r 3                       ; Attempt to fill the input buffer from the input source, returning
0022A7r 3                       ; a true flag if successful. When the input source is the user input
0022A7r 3                       ; device, attempt to receive input into the terminal input buffer. If
0022A7r 3                       ; successful, make the result the input buffer, set >IN to zero, and
0022A7r 3                       ; return true. Receipt of a line containing no characters is considered
0022A7r 3                       ; successful. If there is no input available from the current input
0022A7r 3                       ; source, return false. When the input source is a string from EVALUATE,
0022A7r 3                       ; return false and perform no other action." See
0022A7r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
0022A7r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
0022A7r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
0022A7r 3                       ; entire block as a 1024 byte string.
0022A7r 3                       ; """"
0022A7r 3               
0022A7r 3               xt_refill:
0022A7r 3                               ; Get input source from SOURCE-ID. This is an
0022A7r 3                               ; optimized version of a subroutine jump to SOURCE-ID
0022A7r 3  A5 rr                        lda insrc               ; cheat: We only check LSB
0022A9r 3  D0 2D                        bne @src_not_kbd
0022ABr 3               
0022ABr 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
0022ABr 3                               ; with ACCEPT, which wants the address of the current input
0022ABr 3                               ; buffer NOS and the max number of characters to accept TOS
0022ABr 3  CA                           dex
0022ACr 3  CA                           dex
0022ADr 3  CA                           dex
0022AEr 3  CA                           dex
0022AFr 3               
0022AFr 3  A5 rr                        lda cib                 ; address of CIB is NOS
0022B1r 3  95 02                        sta 2,x
0022B3r 3  A5 rr                        lda cib+1
0022B5r 3  95 03                        sta 3,x
0022B7r 3               
0022B7r 3  64 rr                        stz ciblen              ; go in with empty buffer
0022B9r 3  64 rr                        stz ciblen+1
0022BBr 3               
0022BBr 3  A9 FF                        lda #bsize              ; max number of chars is TOS
0022BDr 3  95 00                        sta 0,x
0022BFr 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
0022C1r 3               
0022C1r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
0022C4r 3               
0022C4r 3                               ; ACCEPT returns the number of characters accepted, which
0022C4r 3                               ; belong in CIBLEN
0022C4r 3  B5 00                        lda 0,x
0022C6r 3  85 rr                        sta ciblen
0022C8r 3  B5 01                        lda 1,x
0022CAr 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
0022CCr 3               
0022CCr 3                               ; make >IN point to beginning of buffer
0022CCr 3  64 rr                        stz toin
0022CEr 3  64 rr                        stz toin+1
0022D0r 3               
0022D0r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
0022D2r 3  95 00                        sta 0,x
0022D4r 3  95 01                        sta 1,x
0022D6r 3               
0022D6r 3  80 10                        bra @done
0022D8r 3               
0022D8r 3               @src_not_kbd:
0022D8r 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
0022D8r 3                               ; memory or a file (remember, no blocks in this version).
0022D8r 3                               ; If source is a string, we were given the flag -1 ($FFFF)
0022D8r 3  1A                           inc
0022D9r 3  D0 08                        bne @src_not_string
0022DBr 3               
0022DBr 3                               ; Simply return FALSE flag as per specification
0022DBr 3  CA                           dex
0022DCr 3  CA                           dex
0022DDr 3  74 00                        stz 0,x
0022DFr 3  74 01                        stz 1,x
0022E1r 3               
0022E1r 3  80 05                        bra z_refill
0022E3r 3               
0022E3r 3               @src_not_string:
0022E3r 3                               ; Since we don't have blocks, this must mean that we are trying
0022E3r 3                               ; to read from a file. However, we don't have files yet, so we
0022E3r 3                               ; report an error and jump to ABORT.
0022E3r 3  A9 01                        lda #err_badsource
0022E5r 3  4C rr rr                     jmp error
0022E8r 3               @done:
0022E8r 3  60           z_refill:       rts
0022E9r 3               
0022E9r 3               
0022E9r 3               
0022E9r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
0022E9r 3               ; ## "repeat"  auto  ANS core
0022E9r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
0022E9r 3               
0022E9r 3               xt_repeat:
0022E9r 3                               ; Run again first
0022E9r 3  20 rr rr                     jsr xt_again
0022ECr 3               
0022ECr 3                               ; Stuff HERE in for the branch address
0022ECr 3                               ; to get out of the loop
0022ECr 3  20 rr rr                     jsr xt_here
0022EFr 3  20 rr rr                     jsr xt_swap
0022F2r 3  20 rr rr                     jsr xt_store
0022F5r 3               
0022F5r 3  60           z_repeat:       rts
0022F6r 3               
0022F6r 3               
0022F6r 3               
0022F6r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
0022F6r 3               ; ## "]"  auto  ANS core
0022F6r 3                       ; """https://forth-standard.org/standard/right-bracket
0022F6r 3                       ; This is an immediate word.
0022F6r 3                       ; """
0022F6r 3               xt_right_bracket:
0022F6r 3  A9 FF                        lda #$FF
0022F8r 3  85 rr                        sta state
0022FAr 3  85 rr                        sta state+1
0022FCr 3               z_right_bracket:
0022FCr 3  60                           rts
0022FDr 3               
0022FDr 3               
0022FDr 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
0022FDr 3               ; ## "root-wordlist"  tested  Tali Editor
0022FDr 3               xt_root_wordlist:
0022FDr 3  CA                           dex             ; The WID for the Root wordlist is 3.
0022FEr 3  CA                           dex
0022FFr 3  A9 03                        lda #3
002301r 3  95 00                        sta 0,x
002303r 3  74 01                        stz 1,x
002305r 3               
002305r 3               z_root_wordlist:
002305r 3  60                           rts
002306r 3               
002306r 3               
002306r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
002306r 3               ; ## "rot"  auto  ANS core
002306r 3                       ; """https://forth-standard.org/standard/core/ROT
002306r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
002306r 3                       ; on top!
002306r 3                       ; """
002306r 3               
002306r 3               xt_rot:
002306r 3  20 rr rr                     jsr underflow_3
002309r 3               
002309r 3  B4 05                        ldy 5,x         ; MSB first
00230Br 3  B5 03                        lda 3,x
00230Dr 3  95 05                        sta 5,x
00230Fr 3  B5 01                        lda 1,x
002311r 3  95 03                        sta 3,x
002313r 3  94 01                        sty 1,x
002315r 3               
002315r 3  B4 04                        ldy 4,x         ; LSB next
002317r 3  B5 02                        lda 2,x
002319r 3  95 04                        sta 4,x
00231Br 3  B5 00                        lda 0,x
00231Dr 3  95 02                        sta 2,x
00231Fr 3  94 00                        sty 0,x
002321r 3               
002321r 3  60           z_rot:          rts
002322r 3               
002322r 3               
002322r 3               
002322r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
002322r 3               ; ## "rshift"  auto  ANS core
002322r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
002322r 3               xt_rshift:
002322r 3  20 rr rr                     jsr underflow_2
002325r 3               
002325r 3                               ; We shift maximal by 16 bits, mask everything else
002325r 3  B5 00                        lda 0,x
002327r 3  29 0F                        and #%00001111
002329r 3  F0 08                        beq @done               ; if 0 shifts, quit
00232Br 3               
00232Br 3  A8                           tay
00232Cr 3               @loop:
00232Cr 3  56 03                        lsr 3,x
00232Er 3  76 02                        ror 2,x
002330r 3  88                           dey
002331r 3  D0 F9                        bne @loop
002333r 3               @done:
002333r 3  E8                           inx
002334r 3  E8                           inx
002335r 3               
002335r 3  60           z_rshift:       rts
002336r 3               
002336r 3               
002336r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002336r 3               ; ## "s\""  auto  ANS core
002336r 3                       ; """https://forth-standard.org/standard/core/Seq
002336r 3                       ; Store address and length of string given, returning ( addr u ).
002336r 3                       ; ANS core claims this is compile-only, but the file set expands it
002336r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002336r 3                       ; are evil. We follow general usage. This is just like S" except
002336r 3                       ; that it allows for some special escaped characters.
002336r 3                       ; """
002336r 3               
002336r 3               xt_s_backslash_quote:
002336r 3                               ; tmp2 will be used to determine if we are handling
002336r 3                               ; escaped characters or not. In this case, we are,
002336r 3                               ; so set it to $FF (the upper byte will be used to
002336r 3                               ; determine if we just had a \ and the next character
002336r 3                               ; needs to be modifed as an escaped character).
002336r 3  A9 FF                        lda #$FF
002338r 3  85 rr                        sta tmp2
00233Ar 3  64 rr                        stz tmp2+1
00233Cr 3               
00233Cr 3                               ; Now that the flag is set, jump into s_quote to process
00233Cr 3                               ; the string.
00233Cr 3  20 rr rr                     jsr s_quote_start
00233Fr 3               @done:
00233Fr 3               z_s_backslash_quote:
00233Fr 3  60                           rts
002340r 3               
002340r 3               
002340r 3               ; This is a helper function for s_backslash_quote to convert a character
002340r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
002340r 3               convert_hex_value:
002340r 3               
002340r 3  C9 41                cmp #'A'
002342r 3  90 07                bcc @digit
002344r 3               
002344r 3                       ; It's A-F
002344r 3  29 DF                and #$DF                ; Make it uppercase.
002346r 3  38                   sec
002347r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
002349r 3  80 03                bra @done
00234Br 3               
00234Br 3               @digit:
00234Br 3                       ; It's 0-9
00234Br 3  38                   sec
00234Cr 3  E9 30                sbc #'0'
00234Er 3               
00234Er 3               @done:
00234Er 3  60                   rts
00234Fr 3               
00234Fr 3               
00234Fr 3               
00234Fr 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
00234Fr 3               ; ## "search-wordlist" auto ANS search
00234Fr 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
00234Fr 3               
00234Fr 3               xt_search_wordlist:
00234Fr 3  20 rr rr                     jsr underflow_3
002352r 3               
002352r 3                               ; Set up tmp1 with the wordlist indicated by wid
002352r 3                               ; on the stack. Start by putting the base address
002352r 3                               ; of the wordlists in tmp2.
002352r 3  A5 rr                        lda up
002354r 3  18                           clc
002355r 3  69 06                        adc #wordlists_offset
002357r 3  85 rr                        sta tmp2
002359r 3  A5 rr                        lda up+1
00235Br 3  69 00                        adc #0          ; Adding carry
00235Dr 3  85 rr                        sta tmp2+1
00235Fr 3               
00235Fr 3                               ; Add the wid (in cells) to the base address.
00235Fr 3  B5 00                        lda 0,x
002361r 3  0A                           asl             ; Convert wid to offset in cells (x2)
002362r 3  65 rr                        adc tmp2
002364r 3  85 rr                        sta tmp2
002366r 3  90 02                        bcc @1
002368r 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
00236Ar 3               
00236Ar 3                               ; tmp2 now holds the address of the dictionary pointer
00236Ar 3                               ; for the given wordlist.
00236Ar 3               @1:
00236Ar 3                               ; Remove the wid from the stack.
00236Ar 3  E8                           inx
00236Br 3  E8                           inx
00236Cr 3               
00236Cr 3                               ; check for special case of an empty string (length zero)
00236Cr 3  B5 00                        lda 0,x
00236Er 3  15 01                        ora 1,x
002370r 3  D0 03                        bne @check_wordlist
002372r 3  4C rr rr                     jmp @done
002375r 3               
002375r 3               @check_wordlist:
002375r 3                               ; Check for special case of empty wordlist
002375r 3                               ; (dictionary pointer, in tmp2, is 0)
002375r 3  A5 rr                        lda tmp2
002377r 3  05 rr                        ora tmp2+1
002379r 3  D0 03                        bne @have_string
00237Br 3  4C rr rr                     jmp @done
00237Er 3               
00237Er 3               @have_string:
00237Er 3                               ; set up first loop iteration
00237Er 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
002380r 3  85 rr                        sta tmp1
002382r 3               
002382r 3  E6 rr                        inc tmp2                ; Move to the upper byte
002384r 3  D0 02                        bne @2
002386r 3  E6 rr                        inc tmp2+1
002388r 3               @2:
002388r 3  B2 rr                        lda (tmp2)
00238Ar 3  85 rr                        sta tmp1+1
00238Cr 3               
00238Cr 3                               ; Reuse tmp2 to hold the address of the mystery string.
00238Cr 3  B5 02                        lda 2,x                 ; Address of mystery string
00238Er 3  85 rr                        sta tmp2
002390r 3  B5 03                        lda 3,x
002392r 3  85 rr                        sta tmp2+1
002394r 3               
002394r 3               @loop:
002394r 3                               ; first quick test: Are strings the same length?
002394r 3  B2 rr                        lda (tmp1)
002396r 3  D5 00                        cmp 0,x
002398r 3  D0 7B                        bne @next_entry
00239Ar 3               
00239Ar 3               @compare_string:
00239Ar 3                               ; are the same length, so we now have to compare each
00239Ar 3                               ; character
00239Ar 3               
00239Ar 3                               ; second quick test: Is the first character the same?
00239Ar 3  B2 rr                        lda (tmp2)      ; first character of mystery string
00239Cr 3               
00239Cr 3                               ; Lowercase the incoming charcter.
00239Cr 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
00239Er 3  B0 07                        bcs @compare_first
0023A0r 3  C9 41                        cmp #$41        ; ASCII 'A'
0023A2r 3  90 03                        bcc @compare_first
0023A4r 3               
0023A4r 3                               ; An uppercase letter has been located.  Make it
0023A4r 3                               ; lowercase.
0023A4r 3  18                           clc
0023A5r 3  69 20                        adc #$20
0023A7r 3               
0023A7r 3               @compare_first:
0023A7r 3  A0 08                        ldy #8          ; Offset in nt to name
0023A9r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
0023ABr 3  D0 68                        bne @next_entry
0023ADr 3               
0023ADr 3                               ; string length are the same and the first character is the
0023ADr 3                               ; same. If the length of the string is 1, we're already done
0023ADr 3  B5 00                        lda 0,x
0023AFr 3  3A                           dec
0023B0r 3  F0 2C                        beq @success
0023B2r 3               
0023B2r 3                               ; No such luck: The strings are the same length and the first
0023B2r 3                               ; char is the same, but the word is more than one char long.
0023B2r 3                               ; So we suck it up and compare every single character. We go
0023B2r 3                               ; from back to front, because words like CELLS and CELL+ would
0023B2r 3                               ; take longer otherwise. We can also shorten the loop by one
0023B2r 3                               ; because we've already compared the first char.
0023B2r 3               
0023B2r 3                               ; The string of the word we're testing against is 8 bytes down
0023B2r 3  A5 rr                        lda tmp1
0023B4r 3  48                           pha             ; Preserve tmp1 on the return stack.
0023B5r 3  18                           clc
0023B6r 3  69 08                        adc #8
0023B8r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
0023BAr 3  A5 rr                        lda tmp1+1
0023BCr 3  48                           pha             ; Preserve tmp1+1 on the return stack.
0023BDr 3  69 00                        adc #0          ; we only need the carry
0023BFr 3  85 rr                        sta tmp1+1
0023C1r 3               
0023C1r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0023C3r 3  88                           dey
0023C4r 3               
0023C4r 3               @string_loop:
0023C4r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
0023C6r 3               
0023C6r 3                               ; Lowercase the incoming charcter.
0023C6r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0023C8r 3  B0 07                        bcs @check_char
0023CAr 3  C9 41                        cmp #$41        ; ASCII 'A'
0023CCr 3  90 03                        bcc @check_char
0023CEr 3               
0023CEr 3                               ; An uppercase letter has been located.  Make it
0023CEr 3                               ; lowercase.
0023CEr 3  18                           clc
0023CFr 3  69 20                        adc #$20
0023D1r 3               @check_char:
0023D1r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
0023D3r 3  D0 3A                        bne @next_entry_tmp1
0023D5r 3               
0023D5r 3  88                           dey
0023D6r 3  D0 EC                        bne @string_loop
0023D8r 3               
0023D8r 3               @success_tmp1:
0023D8r 3  68                           pla             ; Restore tmp1 from the return stack.
0023D9r 3  85 rr                        sta tmp1+1
0023DBr 3  68                           pla
0023DCr 3  85 rr                        sta tmp1
0023DEr 3               
0023DEr 3               @success:
0023DEr 3                               ; The strings match. Drop the count and put correct nt TOS
0023DEr 3  E8                           inx
0023DFr 3  E8                           inx
0023E0r 3  A5 rr                        lda tmp1
0023E2r 3  95 00                        sta 0,x
0023E4r 3  A5 rr                        lda tmp1+1
0023E6r 3  95 01                        sta 1,x
0023E8r 3               
0023E8r 3                               ; Change the nt into an xt, but save a copy of the nt
0023E8r 3                               ; to look up whether the word is immediate or not.
0023E8r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0023EBr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0023EEr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0023F1r 3               
0023F1r 3  A0 00                        ldy #0                  ; Prepare flag
0023F3r 3               
0023F3r 3                               ; The flags are in the second byte of the header
0023F3r 3  F6 00                        inc 0,x
0023F5r 3  D0 02                        bne @3
0023F7r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0023F9r 3               @3:
0023F9r 3  A1 00                        lda (0,x)               ; ( xt char )
0023FBr 3  29 04                        and #IM
0023FDr 3  D0 08                        bne @immediate          ; bit set, we're immediate
0023FFr 3               
0023FFr 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
002401r 3  95 00                        sta 0,x
002403r 3  95 01                        sta 1,x
002405r 3  80 28                        bra @done_nodrop
002407r 3               
002407r 3               @immediate:
002407r 3  A9 01                        lda #1                  ; We're immediate, return 1
002409r 3  95 00                        sta 0,x
00240Br 3  74 01                        stz 1,x
00240Dr 3               
00240Dr 3  80 20                        bra @done_nodrop
00240Fr 3               
00240Fr 3               @next_entry_tmp1:
00240Fr 3  68                           pla             ; Restore tmp1 from the return stack.
002410r 3  85 rr                        sta tmp1+1
002412r 3  68                           pla
002413r 3  85 rr                        sta tmp1
002415r 3               @next_entry:
002415r 3                               ; Not the same, so we get the next word. Next header
002415r 3                               ; address is two bytes down
002415r 3  A0 02                        ldy #2
002417r 3  B1 rr                        lda (tmp1),y
002419r 3  48                           pha
00241Ar 3  C8                           iny
00241Br 3  B1 rr                        lda (tmp1),y
00241Dr 3  85 rr                        sta tmp1+1
00241Fr 3  68                           pla
002420r 3  85 rr                        sta tmp1
002422r 3               
002422r 3                               ; If we got a zero, we've walked the whole Dictionary and
002422r 3                               ; return as a failure, otherwise try again
002422r 3  05 rr                        ora tmp1+1
002424r 3  F0 03                        beq @fail_done
002426r 3  4C rr rr                     jmp @loop
002429r 3               
002429r 3               @fail_done:
002429r 3  74 02                        stz 2,x         ; failure flag
00242Br 3  74 03                        stz 3,x
00242Dr 3               @done:
00242Dr 3  E8                           inx
00242Er 3  E8                           inx
00242Fr 3               @done_nodrop:
00242Fr 3               z_search_wordlist:
00242Fr 3  60                           rts
002430r 3               
002430r 3               
002430r 3               
002430r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
002430r 3               ; ## "see" tested  ANS tools
002430r 3                       ; """https://forth-standard.org/standard/tools/SEE
002430r 3                       ; SEE takes the name of a word and prints its name token (nt),
002430r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
002430r 3                       ; code and disassembles it.
002430r 3                       ; """
002430r 3               
002430r 3               xt_see:
002430r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
002433r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
002436r 3               
002436r 3                               ; If we got back a zero we don't know that word and so we quit
002436r 3                               ; with an error
002436r 3  B5 00                        lda 0,x
002438r 3  15 01                        ora 1,x
00243Ar 3  D0 05                        bne @1
00243Cr 3               
00243Cr 3  A9 05                        lda #err_noname
00243Er 3  4C rr rr                     jmp error
002441r 3               @1:
002441r 3  20 rr rr                     jsr xt_cr
002444r 3               
002444r 3                               ; We have a legal word, so let's get serious. Save the current
002444r 3                               ; number base and use hexadecimal instead.
002444r 3  A5 rr                        lda base
002446r 3  48                           pha
002447r 3  20 rr rr                     jsr xt_hex
00244Ar 3               
00244Ar 3  A9 0A                        lda #str_see_nt
00244Cr 3  20 rr rr                     jsr print_string_no_lf
00244Fr 3               
00244Fr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002452r 3  20 rr rr                     jsr xt_u_dot
002455r 3  20 rr rr                     jsr xt_space            ; ( nt )
002458r 3               
002458r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00245Br 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
00245Er 3               
00245Er 3  A9 0B                        lda #str_see_xt
002460r 3  20 rr rr                     jsr print_string_no_lf
002463r 3               
002463r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
002466r 3  20 rr rr                     jsr xt_u_dot
002469r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
00246Cr 3               
00246Cr 3                               ; We print letters for flags and then later follow it with 1 or
00246Cr 3                               ; 0 to mark if which flag is set
00246Cr 3  A9 09                        lda #str_see_flags
00246Er 3  20 rr rr                     jsr print_string_no_lf
002471r 3               
002471r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
002474r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
002477r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
00247Ar 3               
00247Ar 3  B5 00                        lda 0,x
00247Cr 3               
00247Cr 3                               ; This is crude, but for the moment it is good enough
00247Cr 3  A0 06                        ldy #6                  ; Not all bits are used
00247Er 3               @flag_loop:
00247Er 3  48                           pha
00247Fr 3  29 01                        and #%00000001
002481r 3  18                           clc
002482r 3  69 30                        adc #$30                ; ASCII "0"
002484r 3  20 rr rr                     jsr emit_a
002487r 3  20 rr rr                     jsr xt_space
00248Ar 3               
00248Ar 3  68                           pla
00248Br 3  6A                           ror                     ; Next flag
00248Cr 3               
00248Cr 3  88                           dey
00248Dr 3  D0 EF                        bne @flag_loop
00248Fr 3               
00248Fr 3  20 rr rr                     jsr xt_cr
002492r 3               
002492r 3  E8                           inx
002493r 3  E8                           inx                     ; ( nt xt )
002494r 3               
002494r 3                               ; Figure out the size
002494r 3  A9 0C                        lda #str_see_size
002496r 3  20 rr rr                     jsr print_string_no_lf
002499r 3               
002499r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
00249Cr 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
00249Fr 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
0024A2r 3  20 rr rr                     jsr xt_decimal
0024A5r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
0024A8r 3  20 rr rr                     jsr xt_hex
0024ABr 3  20 rr rr                     jsr xt_cr
0024AEr 3               
0024AEr 3                               ; Dump hex and disassemble
0024AEr 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
0024B1r 3  20 rr rr                     jsr xt_dump
0024B4r 3  20 rr rr                     jsr xt_cr
0024B7r 3  20 rr rr                     jsr xt_disasm
0024BAr 3               
0024BAr 3  68                           pla
0024BBr 3  85 rr                        sta base
0024BDr 3               
0024BDr 3  60           z_see:          rts
0024BEr 3               
0024BEr 3               
0024BEr 3               
0024BEr 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
0024BEr 3               ; ## "set-current" auto ANS search
0024BEr 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
0024BEr 3               
0024BEr 3               xt_set_current:
0024BEr 3  20 rr rr                     jsr underflow_1
0024C1r 3               
0024C1r 3                               ; Save the value from the data stack.
0024C1r 3  A0 04                        ldy #current_offset
0024C3r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
0024C5r 3  91 rr                        sta (up),y      ; so only the LSB is used.
0024C7r 3               
0024C7r 3  E8                           inx
0024C8r 3  E8                           inx
0024C9r 3               
0024C9r 3  60           z_set_current:  rts
0024CAr 3               
0024CAr 3               
0024CAr 3               
0024CAr 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
0024CAr 3               ; ## "set-order" auto ANS search
0024CAr 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
0024CAr 3               
0024CAr 3               xt_set_order:
0024CAr 3                               ; Test for -1 TOS
0024CAr 3  A9 FF                        lda #$FF
0024CCr 3  D5 01                        cmp 1,x
0024CEr 3  D0 12                        bne @start
0024D0r 3  D5 00                        cmp 0,x
0024D2r 3  D0 0E                        bne @start
0024D4r 3               
0024D4r 3                               ; There is a -1 TOS.  Replace it with the default
0024D4r 3                               ; search order, which is just the FORTH-WORDLIST.
0024D4r 3  CA                           dex             ; Make room for the count.
0024D5r 3  CA                           dex
0024D6r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
0024D8r 3  A9 03                        lda #3
0024DAr 3  95 02                        sta 2,x
0024DCr 3  74 01                        stz 1,x         ; Count is 1.
0024DEr 3  A9 01                        lda #1
0024E0r 3  95 00                        sta 0,x
0024E2r 3               
0024E2r 3                               ; Continue processing with ( forth-wordlist 1 -- )
0024E2r 3               @start:
0024E2r 3                               ; Set #ORDER - the number of wordlists in the search order.
0024E2r 3  A0 1E                        ldy #num_order_offset
0024E4r 3  B5 00                        lda 0,x
0024E6r 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
0024E8r 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
0024EAr 3                                               ; Only the low byte is saved in tmp1 as
0024EAr 3                                               ; only 8 wordlists are allowed.
0024EAr 3               
0024EAr 3  E8                           inx             ; Drop the count off the data stack.
0024EBr 3  E8                           inx
0024ECr 3               
0024ECr 3                               ; Check if there are zero wordlists.
0024ECr 3  A5 rr                        lda tmp1
0024EEr 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
0024F0r 3               
0024F0r 3                               ; Move the wordlist ids from the data stack to the search order.
0024F0r 3  A0 1F                        ldy #search_order_offset
0024F2r 3               @loop:
0024F2r 3                               ; Move one wordlist id over into the search order.
0024F2r 3  B5 00                        lda 0,x         ; The search order is a byte array
0024F4r 3  91 rr                        sta (up),y      ; so only save the LSB
0024F6r 3  C8                           iny
0024F7r 3               
0024F7r 3                               ; Remove it from the data stack.
0024F7r 3  E8                           inx
0024F8r 3  E8                           inx
0024F9r 3               
0024F9r 3                               ; See if that was the last one to process (first in the list).
0024F9r 3  C6 rr                        dec tmp1
0024FBr 3  D0 F5                        bne @loop
0024FDr 3               
0024FDr 3               @done:
0024FDr 3  60           z_set_order:    rts
0024FEr 3               
0024FEr 3               
0024FEr 3               
0024FEr 3               
0024FEr 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
0024FEr 3               ; ## "s""  auto  ANS core
0024FEr 3                       ; """https://forth-standard.org/standard/core/Sq
0024FEr 3                       ; Store address and length of string given, returning ( addr u ).
0024FEr 3                       ; ANS core claims this is compile-only, but the file set expands it
0024FEr 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
0024FEr 3                       ; are evil. We follow general usage.
0024FEr 3                       ;
0024FEr 3                       ; Can also be realized as
0024FEr 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
0024FEr 3                       ; but it is used so much we want it in code.
0024FEr 3                       ; """
0024FEr 3               
0024FEr 3               xt_s_quote:
0024FEr 3                               ; tmp2 will be used to determine if we are handling
0024FEr 3                               ; escaped characters or not.  In this case, we are
0024FEr 3                               ; not, so set it to zero.
0024FEr 3  64 rr                        stz tmp2
002500r 3  64 rr                        stz tmp2+1
002502r 3               
002502r 3               s_quote_start:
002502r 3                               ; Make room on the data stack for the address.
002502r 3  CA                           dex
002503r 3  CA                           dex
002504r 3                               ; Make room on the data stack for the count.
002504r 3  CA                           dex
002505r 3  CA                           dex
002506r 3               
002506r 3                               ; Put a jmp over the string data with address to be filled
002506r 3                               ; in later.
002506r 3  A9 4C                        lda #$4C
002508r 3  20 rr rr                     jsr cmpl_a
00250Br 3               
00250Br 3                               ; Address to be filled in later, just use $4C for the moment
00250Br 3  20 rr rr                     jsr cmpl_a
00250Er 3  20 rr rr                     jsr cmpl_a
002511r 3               
002511r 3                               ; Save the current value of HERE on the data stack for the
002511r 3                               ; address of the string.
002511r 3  A5 rr                        lda cp
002513r 3  95 02                        sta 2,x
002515r 3  A5 rr                        lda cp+1
002517r 3  95 03                        sta 3,x
002519r 3               
002519r 3               @savechars_loop:
002519r 3                               ; Start saving the string into the dictionary up to the
002519r 3                               ; ending double quote. First, check to see if the input
002519r 3                               ; buffer is empty.
002519r 3  A5 rr                        lda toin+1              ; MSB
00251Br 3  C5 rr                        cmp ciblen+1
00251Dr 3  90 2A                        bcc @input_fine         ; unsigned comparison
00251Fr 3               
00251Fr 3  A5 rr                        lda toin                ; LSB
002521r 3  C5 rr                        cmp ciblen
002523r 3  90 24                        bcc @input_fine
002525r 3               
002525r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
002525r 3                               ; which uses tmp2 and tmp3. Save and restore them.
002525r 3  A5 rr                        lda tmp2
002527r 3  48                           pha
002528r 3  A5 rr                        lda tmp2+1
00252Ar 3  48                           pha
00252Br 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
00252Dr 3  48                           pha
00252Er 3               
00252Er 3  20 rr rr                     jsr xt_refill           ; ( -- f )
002531r 3               
002531r 3  68                           pla
002532r 3  85 rr                        sta tmp3
002534r 3  68                           pla
002535r 3  85 rr                        sta tmp2+1
002537r 3  68                           pla
002538r 3  85 rr                        sta tmp2
00253Ar 3               
00253Ar 3                               ; Check result of refill.
00253Ar 3  B5 00                        lda 0,x
00253Cr 3  15 01                        ora 1,x
00253Er 3  D0 05                        bne @refill_ok
002540r 3               
002540r 3                               ; Something when wrong with refill.
002540r 3  A9 06                        lda #err_refill
002542r 3  4C rr rr                     jmp error
002545r 3               
002545r 3               @refill_ok:
002545r 3                               ; Remove the refill flag from the data stack.
002545r 3  E8                           inx
002546r 3  E8                           inx
002547r 3               
002547r 3                               ; For refill success, jump back up to the empty check, just in
002547r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
002547r 3                               ; input)
002547r 3  80 D0                        bra @savechars_loop
002549r 3               
002549r 3               @input_fine:
002549r 3                               ; There should be at least one valid char to use.
002549r 3                               ; Calculate it's address at CIB+TOIN into tmp1
002549r 3  A5 rr                        lda cib
00254Br 3  18                           clc
00254Cr 3  65 rr                        adc toin        ; LSB
00254Er 3  85 rr                        sta tmp1
002550r 3  A5 rr                        lda cib+1
002552r 3  65 rr                        adc toin+1      ; MSB
002554r 3  85 rr                        sta tmp1+1
002556r 3               
002556r 3                               ; Get the character
002556r 3  B2 rr                        lda (tmp1)
002558r 3               
002558r 3                               ; Check to see if we are handling escaped characters.
002558r 3  24 rr                        bit tmp2
00255Ar 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
00255Cr 3  4C rr rr                     jmp @regular_char
00255Fr 3               
00255Fr 3               @handle_escapes:
00255Fr 3                               ; We are handling escaped characters.  See if we have
00255Fr 3                               ; already seen the backslash.
00255Fr 3  24 rr                        bit tmp2+1
002561r 3  30 03                        bmi @escaped
002563r 3  4C rr rr                     jmp @not_escaped
002566r 3               
002566r 3               @escaped:
002566r 3               
002566r 3                               ; We have seen a backslash (previous character). Check to see if
002566r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
002566r 3                               ; be clear in that case )
002566r 3  70 22                        bvs @check_esc_chars
002568r 3               
002568r 3                               ; We are in the middle of a \x sequence. Check to see if we
002568r 3                               ; are on the first or second digit.
002568r 3  A9 01                        lda #1
00256Ar 3  24 rr                        bit tmp2+1
00256Cr 3  D0 10                        bne @esc_x_second_digit
00256Er 3               
00256Er 3                               ; First digit.
00256Er 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
002570r 3  B2 rr                        lda (tmp1)  ; Get the char again.
002572r 3               
002572r 3                               ; Convert to hex
002572r 3  20 rr rr                     jsr convert_hex_value
002575r 3               
002575r 3                               ; This is the upper nybble, so move it up.
002575r 3  0A                           asl
002576r 3  0A                           asl
002577r 3  0A                           asl
002578r 3  0A                           asl
002579r 3  85 rr                        sta tmp3    ; Save it for later.
00257Br 3  4C rr rr                     jmp @next_character
00257Er 3               
00257Er 3               @esc_x_second_digit:
00257Er 3               
00257Er 3                               ; We are on the second hex digit of a \x sequence. Clear the
00257Er 3                               ; escaped character flag (because we are handling it right
00257Er 3                               ; here)
00257Er 3  64 rr                        stz tmp2+1
002580r 3  B2 rr                        lda (tmp1)
002582r 3               
002582r 3                               ; Convert to hex, combine with value in tmp3
002582r 3  20 rr rr                     jsr convert_hex_value
002585r 3  05 rr                        ora tmp3
002587r 3               
002587r 3  4C rr rr                     jmp @save_character
00258Ar 3               
00258Ar 3               @check_esc_chars:
00258Ar 3                               ; Clear the escaped character flag (because we are
00258Ar 3                               ; handling it right here)
00258Ar 3  64 rr                        stz tmp2+1
00258Cr 3               
00258Cr 3                               ; Process the escaped character
00258Cr 3               @check_esc_a:
00258Cr 3  C9 61                        cmp #'a'
00258Er 3  D0 05                        bne @check_esc_b
002590r 3               
002590r 3                               ; BEL (ASCII value 7)
002590r 3  A9 07                        lda #7
002592r 3  4C rr rr                     jmp @save_character
002595r 3               
002595r 3               @check_esc_b:
002595r 3  C9 62                        cmp #'b'
002597r 3  D0 05                        bne @check_esc_e
002599r 3               
002599r 3                               ; Backspace (ASCII value 8)
002599r 3  A9 08                        lda #8
00259Br 3  4C rr rr                     jmp @save_character
00259Er 3               
00259Er 3               @check_esc_e:
00259Er 3  C9 65                        cmp #'e'
0025A0r 3  D0 04                        bne @check_esc_f
0025A2r 3               
0025A2r 3                               ; ESC (ASCII value 27)
0025A2r 3  A9 1B                        lda #27
0025A4r 3  80 75                        bra @save_character
0025A6r 3               
0025A6r 3               @check_esc_f:
0025A6r 3  C9 66                        cmp #'f'
0025A8r 3  D0 04                        bne @check_esc_l
0025AAr 3               
0025AAr 3                               ; FF (ASCII value 12)
0025AAr 3  A9 0C                        lda #12
0025ACr 3  80 6D                        bra @save_character
0025AEr 3               
0025AEr 3               @check_esc_l:
0025AEr 3  C9 6C                        cmp #'l'
0025B0r 3  D0 04                        bne @check_esc_m
0025B2r 3               
0025B2r 3                               ; LF (ASCII value 10)
0025B2r 3  A9 0A                        lda #10
0025B4r 3  80 65                        bra @save_character
0025B6r 3               
0025B6r 3               @check_esc_m:
0025B6r 3                               ; This one is not like the others because we save two
0025B6r 3                               ; characters
0025B6r 3  C9 6D                        cmp #'m'
0025B8r 3  D0 09                        bne @check_esc_n
0025BAr 3               
0025BAr 3                               ; CR/LF pair (ASCII values 13, 10)
0025BAr 3  A9 0D                        lda #13
0025BCr 3  20 rr rr                     jsr cmpl_a
0025BFr 3  A9 0A                        lda #10
0025C1r 3  80 58                        bra @save_character
0025C3r 3               
0025C3r 3               @check_esc_n:
0025C3r 3  C9 6E                        cmp #'n'
0025C5r 3  D0 04                        bne @check_esc_q
0025C7r 3               
0025C7r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
0025C7r 3  A9 0A                        lda #10
0025C9r 3  80 50                        bra @save_character
0025CBr 3               
0025CBr 3               @check_esc_q:
0025CBr 3  C9 71                        cmp #'q'
0025CDr 3  D0 04                        bne @check_esc_r
0025CFr 3               
0025CFr 3                               ; Double quote (ASCII value 34)
0025CFr 3  A9 22                        lda #34
0025D1r 3  80 48                        bra @save_character
0025D3r 3               
0025D3r 3               @check_esc_r:
0025D3r 3  C9 72                        cmp #'r'
0025D5r 3  D0 04                        bne @check_esc_t
0025D7r 3               
0025D7r 3                               ; CR (ASCII value 13)
0025D7r 3  A9 0D                        lda #13
0025D9r 3  80 40                        bra @save_character
0025DBr 3               
0025DBr 3               @check_esc_t:
0025DBr 3  C9 74                        cmp #'t'
0025DDr 3  D0 04                        bne @check_esc_v
0025DFr 3               
0025DFr 3                               ; Horizontal TAB (ASCII value 9)
0025DFr 3  A9 09                        lda #9
0025E1r 3  80 38                        bra @save_character
0025E3r 3               
0025E3r 3               @check_esc_v:
0025E3r 3  C9 76                        cmp #'v'
0025E5r 3  D0 04                        bne @check_esc_z
0025E7r 3               
0025E7r 3                               ; Vertical TAB (ASCII value 11)
0025E7r 3  A9 0B                        lda #11
0025E9r 3  80 30                        bra @save_character
0025EBr 3               
0025EBr 3               @check_esc_z:
0025EBr 3  C9 7A                        cmp #'z'
0025EDr 3  D0 04                        bne @check_esc_quote
0025EFr 3               
0025EFr 3                               ; NULL (ASCII value 0)
0025EFr 3  A9 00                        lda #0
0025F1r 3  80 28                        bra @save_character
0025F3r 3               
0025F3r 3               @check_esc_quote:
0025F3r 3  C9 22                        cmp #$22
0025F5r 3  D0 04                        bne @check_esc_x
0025F7r 3               
0025F7r 3                               ; Double quote (ASCII value 34)
0025F7r 3  A9 22                        lda #34
0025F9r 3  80 20                        bra @save_character
0025FBr 3               
0025FBr 3               @check_esc_x:
0025FBr 3  C9 78                        cmp #'x'
0025FDr 3  D0 06                        bne @check_esc_backslash
0025FFr 3               
0025FFr 3                               ; This one is difficult. We need to get the next TWO
0025FFr 3                               ; characters (which might require a refill in the middle)
0025FFr 3                               ; and combine them as two hex digits. We do this by
0025FFr 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
0025FFr 3                               ; and using bit 0 to keep track of which digit we are on.
0025FFr 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
002601r 3  85 rr                        sta tmp2+1
002603r 3  80 19                        bra @next_character
002605r 3               
002605r 3               @check_esc_backslash:
002605r 3  C9 5C                        cmp #$5C
002607r 3  D0 04                        bne @not_escaped
002609r 3               
002609r 3                               ; Backslash (ASCII value 92)
002609r 3  A9 5C                        lda #92
00260Br 3  80 0E                        bra @save_character
00260Dr 3               
00260Dr 3               @not_escaped:
00260Dr 3                               ; Check for the backslash to see if we should escape
00260Dr 3                               ; the next char.
00260Dr 3  C9 5C                        cmp #$5C        ; The backslash char
00260Fr 3  D0 06                        bne @regular_char
002611r 3               
002611r 3                               ; We found a backslash.  Don't save anyhing, but set
002611r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
002611r 3                               ; try to get the next char here as it may require a
002611r 3                               ; refill of the input buffer.
002611r 3  A9 FF                        lda #$FF
002613r 3  85 rr                        sta tmp2+1
002615r 3  80 07                        bra @next_character
002617r 3               
002617r 3               @regular_char:
002617r 3                               ; Check if the current character is the end of the string.
002617r 3  C9 22                        cmp #$22        ; ASCII for "
002619r 3  F0 0C                        beq @found_string_end
00261Br 3               
00261Br 3               @save_character:
00261Br 3                               ; If we didn't reach the end of the string, compile this
00261Br 3                               ; character into the dictionary
00261Br 3  20 rr rr                     jsr cmpl_a
00261Er 3               
00261Er 3               @next_character:
00261Er 3                               ; Move on to the next character.
00261Er 3  E6 rr                        inc toin
002620r 3  D0 02                        bne @savechars_loop_longjump
002622r 3  E6 rr                        inc toin+1
002624r 3               
002624r 3               @savechars_loop_longjump:
002624r 3  4C rr rr                     jmp @savechars_loop
002627r 3               
002627r 3               @found_string_end:
002627r 3                               ; Use up the delimiter.
002627r 3  E6 rr                        inc toin
002629r 3  D0 02                        bne @1
00262Br 3  E6 rr                        inc toin+1
00262Dr 3               @1:
00262Dr 3                               ; Calculate the length of the string, which is the
00262Dr 3                               ; difference between cp and the address of the start
00262Dr 3                               ; of the string (currently saved on the stack).
00262Dr 3  A5 rr                        lda cp
00262Fr 3  38                           sec
002630r 3  F5 02                        sbc 2,x
002632r 3  95 00                        sta 0,x         ; LSB
002634r 3  A5 rr                        lda cp+1
002636r 3  F5 03                        sbc 3,x
002638r 3  95 01                        sta 1,x         ; MSB
00263Ar 3               
00263Ar 3                               ; Update the address of the jump-over jmp instruction.
00263Ar 3                               ; First determine location of jmp instructions address.
00263Ar 3                               ; It should be 2 bytes before the start of the string.
00263Ar 3                               ; Compute it into tmp1, which is no longer being used.
00263Ar 3  B5 02                        lda 2,x
00263Cr 3  38                           sec
00263Dr 3  E9 02                        sbc #2
00263Fr 3  85 rr                        sta tmp1
002641r 3  B5 03                        lda 3,x
002643r 3  E9 00                        sbc #0          ; Propagate borrow
002645r 3  85 rr                        sta tmp1+1
002647r 3               
002647r 3                               ; Update the address of the jump to HERE.
002647r 3  A5 rr                        lda cp
002649r 3  92 rr                        sta (tmp1)
00264Br 3  A0 01                        ldy #1
00264Dr 3  A5 rr                        lda cp+1
00264Fr 3  91 rr                        sta (tmp1),y
002651r 3               
002651r 3                               ; What happens next depends on the state (which is bad, but
002651r 3                               ; that's the way it works at the moment). If we are
002651r 3                               ; interpretating, we save the string to a transient buffer
002651r 3                               ; and return that address (used for file calls, see
002651r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
002651r 3                               ; compiling, we just need SLITERAL
002651r 3  A5 rr                        lda state
002653r 3  05 rr                        ora state+1             ; paranoid
002655r 3  F0 03                        beq @done
002657r 3               
002657r 3                               ; Jump into the middle of the sliteral word, after the
002657r 3                               ; string data has been compiled into the dictionary,
002657r 3                               ; because we've already done that step.
002657r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
00265Ar 3               
00265Ar 3               @done:
00265Ar 3  60           z_s_quote:      rts
00265Br 3               
00265Br 3               
00265Br 3               
00265Br 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
00265Br 3               ; ## "s>d"  auto  ANS core
00265Br 3                       ; """https://forth-standard.org/standard/core/StoD"""
00265Br 3               
00265Br 3               xt_s_to_d:
00265Br 3  20 rr rr                     jsr underflow_1
00265Er 3               
00265Er 3  CA                           dex
00265Fr 3  CA                           dex
002660r 3  74 00                        stz 0,x
002662r 3  74 01                        stz 1,x
002664r 3               
002664r 3  B5 03                        lda 3,x
002666r 3  10 04                        bpl @done
002668r 3               
002668r 3                               ; negative, extend sign
002668r 3  D6 00                        dec 0,x
00266Ar 3  D6 01                        dec 1,x
00266Cr 3               @done:
00266Cr 3  60           z_s_to_d:       rts
00266Dr 3               
00266Dr 3               
00266Dr 3               
00266Dr 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
00266Dr 3               ; ## "save-buffers"  tested  ANS block
00266Dr 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
00266Dr 3               
00266Dr 3               xt_save_buffers:
00266Dr 3                               ; Check the buffer status
00266Dr 3  A0 2C                        ldy #buffstatus_offset
00266Fr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
002671r 3  C9 03                        cmp #3          ; LSB is needed.
002673r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
002675r 3               
002675r 3                               ; We need to save the block.
002675r 3  20 rr rr                     jsr xt_blkbuffer
002678r 3  20 rr rr                     jsr xt_buffblocknum
00267Br 3  20 rr rr                     jsr xt_fetch
00267Er 3  20 rr rr                     jsr xt_block_write
002681r 3               
002681r 3                               ; Mark the buffer as clean now.
002681r 3  A9 01                        lda #1
002683r 3  A0 2C                        ldy #buffstatus_offset
002685r 3  91 rr                        sta (up),y
002687r 3               
002687r 3               @done:
002687r 3  60           z_save_buffers: rts
002688r 3               
002688r 3               
002688r 3               
002688r 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
002688r 3               ; ## "scr"  auto  ANS block ext
002688r 3                       ; """https://forth-standard.org/standard/block/SCR"""
002688r 3               xt_scr:
002688r 3                               ; SCR is at UP + scr_offset
002688r 3  CA                           dex
002689r 3  CA                           dex
00268Ar 3  18                           clc
00268Br 3  A5 rr                        lda up
00268Dr 3  69 02                        adc #scr_offset ; Add offset
00268Fr 3  95 00                        sta 0,x
002691r 3  A5 rr                        lda up+1
002693r 3  69 00                        adc #0          ; Adding carry
002695r 3  95 01                        sta 1,x
002697r 3               
002697r 3  60           z_scr:          rts
002698r 3               
002698r 3               
002698r 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
002698r 3               ; ## "search"   auto  ANS string
002698r 3                       ; """https://forth-standard.org/standard/string/SEARCH
002698r 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
002698r 3                       ; addr1 u1). If a match is found the flag will be true and
002698r 3                       ; addr3 will have the address of the start of the match and u3 will have
002698r 3                       ; the number of characters remaining from the match point to the end
002698r 3                       ; of the original string1. If a match is not found, the flag will be
002698r 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
002698r 3                       ; """
002698r 3               
002698r 3               xt_search:
002698r 3  20 rr rr                     jsr underflow_4
00269Br 3               
00269Br 3                               ; ANS says if the second string is a zero-length string it
00269Br 3                               ; automatically matches.
00269Br 3  B5 00                        lda 0,x
00269Dr 3  15 01                        ora 1,x
00269Fr 3  D0 0B                        bne @start_search
0026A1r 3               
0026A1r 3                               ; The second string is a zero length string.  Just remove
0026A1r 3                               ; the second string and put a true flag.
0026A1r 3  E8                           inx             ; Remove u2
0026A2r 3  E8                           inx
0026A3r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
0026A5r 3  95 00                        sta 0,x
0026A7r 3  95 01                        sta 1,x
0026A9r 3  4C rr rr                     jmp z_search
0026ACr 3               
0026ACr 3               @start_search:
0026ACr 3                               ; Put an offset (starting at zero) on the stack.
0026ACr 3  20 rr rr                     jsr xt_zero
0026AFr 3               
0026AFr 3               @search_loop:
0026AFr 3                               ; We stop (not found) when u2 + offset > u1
0026AFr 3                               ; Calculate u2+offset into tmp1
0026AFr 3  18                           clc
0026B0r 3  B5 00                        lda 0,x
0026B2r 3  75 02                        adc 2,x
0026B4r 3  85 rr                        sta tmp1
0026B6r 3  B5 01                        lda 1,x
0026B8r 3  75 03                        adc 3,x
0026BAr 3               
0026BAr 3               
0026BAr 3                               ; Compare to u1. Start with the high byte
0026BAr 3  D5 07                        cmp 7,x
0026BCr 3  90 12                        bcc @init_comparison ; Obviously less
0026BEr 3  D0 06                        bne @not_found
0026C0r 3               
0026C0r 3                               ; The upper address byte matched - check the lower byte
0026C0r 3                               ; Load u1 first so we can use just a carry to check.
0026C0r 3  B5 06                        lda 6,x
0026C2r 3  C5 rr                        cmp tmp1
0026C4r 3  B0 0A                        bcs @init_comparison
0026C6r 3               
0026C6r 3               @not_found:
0026C6r 3                               ; The substring isn't in the main string.
0026C6r 3                               ; Return just the main string and a false flag.
0026C6r 3  E8                           inx             ; Remove offset
0026C7r 3  E8                           inx
0026C8r 3  E8                           inx             ; Remove u2
0026C9r 3  E8                           inx
0026CAr 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
0026CCr 3  74 01                        stz 1,x
0026CEr 3  80 66                        bra z_search
0026D0r 3               
0026D0r 3               @init_comparison:
0026D0r 3                               ; Use tmp1 to hold address in string 1.
0026D0r 3                               ; Use tmp2 to hold address in string 2.
0026D0r 3                               ; Use tmp3 to hold the number of characters left to check.
0026D0r 3               
0026D0r 3                               ; Compute the starting address in string 1
0026D0r 3                               ; as addr1 + offset
0026D0r 3  18                           clc
0026D1r 3  B5 08                        lda 8,x
0026D3r 3  75 00                        adc 0,x
0026D5r 3  85 rr                        sta tmp1
0026D7r 3  B5 09                        lda 9,x
0026D9r 3  75 01                        adc 1,x
0026DBr 3  85 rr                        sta tmp1+1
0026DDr 3               
0026DDr 3                               ; The starting address in string 2 is just addr2.
0026DDr 3  B5 04                        lda 4,x
0026DFr 3  85 rr                        sta tmp2
0026E1r 3  B5 05                        lda 5,x
0026E3r 3  85 rr                        sta tmp2+1
0026E5r 3               
0026E5r 3                               ; The number of characters to check is u2.
0026E5r 3  B5 02                        lda 2,x
0026E7r 3  85 rr                        sta tmp3
0026E9r 3  B5 03                        lda 3,x
0026EBr 3  85 rr                        sta tmp3+1
0026EDr 3               
0026EDr 3               @comparison_loop:
0026EDr 3                               ; Check to see if the current characters match.
0026EDr 3  B2 rr                        lda (tmp1)
0026EFr 3  D2 rr                        cmp (tmp2)
0026F1r 3  F0 05                        beq @letters_match
0026F3r 3               
0026F3r 3                               ; One of the letters didn't match.
0026F3r 3                               ; Increment the offset and try again.
0026F3r 3  20 rr rr                     jsr xt_one_plus
0026F6r 3  80 B7                        bra @search_loop
0026F8r 3               
0026F8r 3               @letters_match:
0026F8r 3                               ; The letters match.  Advance the pointers until the
0026F8r 3                               ; count reaches zero.
0026F8r 3  E6 rr                        inc tmp1
0026FAr 3  D0 02                        bne @1
0026FCr 3  E6 rr                        inc tmp1+1
0026FEr 3               @1:
0026FEr 3  E6 rr                        inc tmp2
002700r 3  D0 02                        bne @2
002702r 3  E6 rr                        inc tmp2+1
002704r 3               @2:
002704r 3                               ; Decrement the count of remaining letters to check.
002704r 3  A5 rr                        lda tmp3
002706r 3  D0 02                        bne @3
002708r 3  C6 rr                        dec tmp3+1
00270Ar 3               @3:
00270Ar 3  C6 rr                        dec tmp3
00270Cr 3               
00270Cr 3                               ; Check if we've reached zero.
00270Cr 3  A5 rr                        lda tmp3
00270Er 3  05 rr                        ora tmp3+1
002710r 3  D0 DB                        bne @comparison_loop ; Check the next letter
002712r 3               
002712r 3                               ; We've run out of letters and they all match!
002712r 3                               ; Return (addr1+offset) (u1-offset) true
002712r 3                               ; Add offset to addr1.
002712r 3  18                           clc
002713r 3  B5 00                        lda 0,x
002715r 3  75 08                        adc 8,x
002717r 3  95 08                        sta 8,x
002719r 3  B5 01                        lda 1,x
00271Br 3  75 09                        adc 9,x
00271Dr 3  95 09                        sta 9,x
00271Fr 3               
00271Fr 3                               ; Subtract offset from u1.
00271Fr 3  38                           sec
002720r 3  B5 06                        lda 6,x
002722r 3  F5 00                        sbc 0,x
002724r 3  95 06                        sta 6,x
002726r 3  B5 07                        lda 7,x
002728r 3  F5 01                        sbc 1,x
00272Ar 3  95 07                        sta 7,x
00272Cr 3               
00272Cr 3                               ; Replace addr2, u2, and offset with a true flag.
00272Cr 3  E8                           inx             ; drop offset
00272Dr 3  E8                           inx
00272Er 3  E8                           inx             ; drop u2
00272Fr 3  E8                           inx
002730r 3  A9 FF                        lda #$FF
002732r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
002734r 3  95 01                        sta 1,x
002736r 3               
002736r 3  60           z_search:       rts
002737r 3               
002737r 3               
002737r 3               
002737r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
002737r 3               ; ## ";"  auto  ANS core
002737r 3                       ; """https://forth-standard.org/standard/core/Semi
002737r 3                       ; End the compilation of a new word into the Dictionary.
002737r 3                       ;
002737r 3                       ; When we
002737r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
002737r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
002737r 3                       ; A Forth definition would be (see "Starting Forth"):
002737r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
002737r 3                       ; practice of Gforth, we warn here if a word has been redefined.
002737r 3                       ; """
002737r 3               
002737r 3               xt_semicolon:
002737r 3                               ; Check if this is a : word or a :NONAME word.
002737r 3  24 rr                        bit status
002739r 3  70 11                        bvs @colonword
00273Br 3               
00273Br 3                               ; This is a :NONAME word - just put an RTS on the end and
00273Br 3                               ; the address (held in workword) on the stack.
00273Br 3  A9 60                        lda #$60                ; opcode for RTS
00273Dr 3  20 rr rr                     jsr cmpl_a
002740r 3               
002740r 3  CA                           dex
002741r 3  CA                           dex
002742r 3  A5 rr                        lda workword
002744r 3  95 00                        sta 0,x
002746r 3  A5 rr                        lda workword+1
002748r 3  95 01                        sta 1,x
00274Ar 3  80 45                        bra @semicolon_done
00274Cr 3               
00274Cr 3               @colonword:
00274Cr 3                               ; CP is the byte that will be the address we use in the
00274Cr 3                               ; header as the end-of-compile address (z_word). This is
00274Cr 3                               ; six bytes down from the header
00274Cr 3  A0 06                        ldy #6
00274Er 3  A5 rr                        lda cp
002750r 3  91 rr                        sta (workword),y
002752r 3  C8                           iny
002753r 3  A5 rr                        lda cp+1
002755r 3  91 rr                        sta (workword),y
002757r 3               
002757r 3                               ; Allocate one further byte and save the RTS instruction
002757r 3                               ; there
002757r 3  A9 60                        lda #$60                ; opcode for RTS
002759r 3  20 rr rr                     jsr cmpl_a
00275Cr 3               
00275Cr 3                               ; Before we formally add the word to the Dictionary, we
00275Cr 3                               ; check to see if it is already present, and if yes, we
00275Cr 3                               ; warn the user.
00275Cr 3               
00275Cr 3                               ; See if word already in Dictionary.
00275Cr 3                               ; (STATUS bit 7 will be high as CREATE already
00275Cr 3                               ;  checked for us.)
00275Cr 3  24 rr                        bit status
00275Er 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
002760r 3               
002760r 3                               ; We start by putting the string of the
002760r 3                               ; word we're defining on the stack
002760r 3  CA                           dex
002761r 3  CA                           dex
002762r 3  CA                           dex
002763r 3  CA                           dex
002764r 3               
002764r 3                               ; WORKWORD points to the beginning of the head of our new
002764r 3                               ; word, where the first byte is the length of the string
002764r 3                               ; We can't use LATESTNT because we haven't added the new
002764r 3                               ; word to the Dictionary yet
002764r 3  B2 rr                        lda (workword)
002766r 3  95 00                        sta 0,x
002768r 3  74 01                        stz 1,x
00276Ar 3               
00276Ar 3                               ; Eight bytes below WORKWORD is the actual beginning of
00276Ar 3                               ; the string
00276Ar 3  A5 rr                        lda workword
00276Cr 3  18                           clc
00276Dr 3  69 08                        adc #8
00276Fr 3  95 02                        sta 2,x
002771r 3  A5 rr                        lda workword+1
002773r 3  69 00                        adc #0                  ; only want carry
002775r 3  95 03                        sta 3,x
002777r 3               
002777r 3                               ; This word is already in the Dictionary, so we print a
002777r 3                               ; warning to the user.
002777r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
002779r 3  20 rr rr                     jsr print_string_no_lf
00277Cr 3               
00277Cr 3                               ; Now we print the offending word.
00277Cr 3  20 rr rr                     jsr xt_type
00277Fr 3  20 rr rr                     jsr xt_space
002782r 3               
002782r 3                               ; Clear bit 7 of status (so future words will print message
002782r 3                               ; by defaut)
002782r 3  A9 80                        lda #%10000000
002784r 3  14 rr                        trb status
002786r 3               
002786r 3               @new_word:
002786r 3                               ; Let's get this over with. Save beginning of our word
002786r 3                               ; as new last word in the Dictionary
002786r 3  A5 rr                        lda workword
002788r 3  85 rr                        sta dp
00278Ar 3  A5 rr                        lda workword+1
00278Cr 3  85 rr                        sta dp+1
00278Er 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
002791r 3                                                       ; CURRENT wordlist.
002791r 3               @semicolon_done:
002791r 3                               ; Word definition complete. Return compile flag to zero
002791r 3                               ; to return to interpret mode
002791r 3  64 rr                        stz state
002793r 3  64 rr                        stz state+1
002795r 3               
002795r 3  60           z_semicolon:    rts
002796r 3               
002796r 3               
002796r 3               
002796r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
002796r 3               ; ## "sign"  auto  ANS core
002796r 3                       ; """https://forth-standard.org/standard/core/SIGN
002796r 3                       ;
002796r 3                       ; Code based on
002796r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
002796r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
002796r 3                       ; """
002796r 3               
002796r 3               xt_sign:
002796r 3  20 rr rr                     jsr underflow_1
002799r 3               
002799r 3  B5 01                        lda 1,x         ; check MSB of TOS
00279Br 3  30 04                        bmi @minus
00279Dr 3               
00279Dr 3  E8                           inx
00279Er 3  E8                           inx
00279Fr 3  80 09                        bra @done
0027A1r 3               @minus:
0027A1r 3  A9 2D                        lda #$2D        ; ASCII for "-"
0027A3r 3  95 00                        sta 0,x         ; overwrite TOS
0027A5r 3  74 01                        stz 1,x         ; paranoid
0027A7r 3               
0027A7r 3  20 rr rr                     jsr xt_hold
0027AAr 3               @done:
0027AAr 3  60           z_sign:         rts
0027ABr 3               
0027ABr 3               
0027ABr 3               
0027ABr 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
0027ABr 3               ; ## "/"  auto  ANS core
0027ABr 3                       ; """https://forth-standard.org/standard/core/Div
0027ABr 3                       ;
0027ABr 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
0027ABr 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
0027ABr 3                       ; This code is currently unoptimized. This code without the SLASH
0027ABr 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
0027ABr 3                       ; """
0027ABr 3               
0027ABr 3               xt_slash:
0027ABr 3                               ; With all the multiplication going on, it would be hard to
0027ABr 3                               ; make sure that one of our temporary variables is not
0027ABr 3                               ; overwritten. We make sure that doesn't happen by taking the
0027ABr 3                               ; hit of pushing the flag to the 65c02's stack
0027ABr 3  A9 00                        lda #0
0027ADr 3  48                           pha
0027AEr 3  80 03                        bra _common
0027B0r 3               
0027B0r 3               xt_slash_mod:
0027B0r 3                               ; Note that /MOD accesses this code
0027B0r 3  A9 FF                        lda #$FF
0027B2r 3  48                           pha             ; falls through to _common
0027B3r 3               
0027B3r 3               _common:
0027B3r 3  20 rr rr                     jsr xt_to_r             ; >R
0027B6r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
0027B9r 3  20 rr rr                     jsr xt_r_from           ; R>
0027BCr 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
0027BFr 3               
0027BFr 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
0027BFr 3                               ; $FF is SLASH MOD
0027BFr 3  68                           pla
0027C0r 3  D0 05                        bne @done
0027C2r 3               
0027C2r 3                               ; The following code is for SLASH only
0027C2r 3  20 rr rr                     jsr xt_swap
0027C5r 3  E8                           inx             ; DROP
0027C6r 3  E8                           inx
0027C7r 3               @done:
0027C7r 3               z_slash_mod:
0027C7r 3  60           z_slash:        rts
0027C8r 3               
0027C8r 3               
0027C8r 3               
0027C8r 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
0027C8r 3               ; ## "/mod"  auto  ANS core
0027C8r 3                       ; """https://forth-standard.org/standard/core/DivMOD
0027C8r 3                       ;
0027C8r 3                       ; This is a dummy entry, the actual code is shared with SLASH
0027C8r 3                       ; """
0027C8r 3               
0027C8r 3               
0027C8r 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
0027C8r 3               ; ## "/string"  auto  ANS string
0027C8r 3                       ; """https://forth-standard.org/standard/string/DivSTRING
0027C8r 3                       ;
0027C8r 3                       ; Forth code is
0027C8r 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
0027C8r 3                       ; Put differently, we need to add TOS and 3OS, and subtract
0027C8r 3                       ; TOS from NOS, and then drop TOS
0027C8r 3                       ; """
0027C8r 3               
0027C8r 3               xt_slash_string:
0027C8r 3  20 rr rr                     jsr underflow_3
0027CBr 3               
0027CBr 3  18                           clc             ; 3OS+TOS
0027CCr 3  B5 00                        lda 0,x
0027CEr 3  75 04                        adc 4,x
0027D0r 3  95 04                        sta 4,x
0027D2r 3               
0027D2r 3  B5 01                        lda 1,x
0027D4r 3  75 05                        adc 5,x
0027D6r 3  95 05                        sta 5,x
0027D8r 3               
0027D8r 3  38                           sec             ; NOS-TOS
0027D9r 3  B5 02                        lda 2,x
0027DBr 3  F5 00                        sbc 0,x
0027DDr 3  95 02                        sta 2,x
0027DFr 3               
0027DFr 3  B5 03                        lda 3,x
0027E1r 3  F5 01                        sbc 1,x
0027E3r 3  95 03                        sta 3,x
0027E5r 3               
0027E5r 3  E8                           inx
0027E6r 3  E8                           inx
0027E7r 3               
0027E7r 3  60           z_slash_string: rts
0027E8r 3               
0027E8r 3               
0027E8r 3               
0027E8r 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
0027E8r 3               ; ## "sliteral" auto  ANS string
0027E8r 3                       ; """https://forth-standard.org/standard/string/SLITERAL
0027E8r 3                       ; Add the runtime for an existing string.
0027E8r 3                       ; """
0027E8r 3               
0027E8r 3               xt_sliteral:
0027E8r 3  20 rr rr                     jsr underflow_2
0027EBr 3               
0027EBr 3                               ; We can't assume that ( addr u ) of the current string is in
0027EBr 3                               ; a stable area (eg. already in the dictionary.) Copy the
0027EBr 3                               ; string data into the dictionary using move.
0027EBr 3               
0027EBr 3                               ; Put a jmp over the string data with address to be filled
0027EBr 3                               ; in later.
0027EBr 3  A9 4C                        lda #$4C
0027EDr 3  20 rr rr                     jsr cmpl_a
0027F0r 3               
0027F0r 3                               ; Address to be filled in later.
0027F0r 3  20 rr rr                     jsr cmpl_a
0027F3r 3  20 rr rr                     jsr cmpl_a
0027F6r 3               
0027F6r 3                               ; Turn the data stack from ( addr u ) into
0027F6r 3                               ; ( here u addr here u ) so move can be called with
0027F6r 3                               ; the remaining items on the stack ready for processing.
0027F6r 3                               ; Reserve three extra words on the stack.
0027F6r 3  8A                           txa
0027F7r 3  38                           sec
0027F8r 3  E9 06                        sbc #6
0027FAr 3  AA                           tax
0027FBr 3               
0027FBr 3                               ; Move addr down from TOS-4 to TOS-2
0027FBr 3  B5 08                        lda 8,x
0027FDr 3  95 04                        sta 4,x
0027FFr 3  B5 09                        lda 9,x
002801r 3  95 05                        sta 5,x
002803r 3               
002803r 3                               ; Copy u from TOS-3 to TOS
002803r 3  B5 06                        lda 6,x
002805r 3  95 00                        sta 0,x
002807r 3  B5 07                        lda 7,x
002809r 3  95 01                        sta 1,x
00280Br 3               
00280Br 3                               ; Put HERE into TOS-1 and TOS-4
00280Br 3  A5 rr                        lda cp
00280Dr 3  95 08                        sta 8,x
00280Fr 3  95 02                        sta 2,x
002811r 3  A5 rr                        lda cp+1
002813r 3  95 09                        sta 9,x
002815r 3  95 03                        sta 3,x
002817r 3               
002817r 3                               ; Copy the string into the dictionary.
002817r 3  20 rr rr                     jsr xt_move
00281Ar 3               
00281Ar 3                               ; Update cp.
00281Ar 3  18                           clc
00281Br 3  A5 rr                        lda cp
00281Dr 3  75 00                        adc 0,x
00281Fr 3  85 rr                        sta cp
002821r 3  A5 rr                        lda cp+1
002823r 3  75 01                        adc 1,x
002825r 3  85 rr                        sta cp+1
002827r 3               
002827r 3                               ; Update the address of the jump-over jmp instruction.
002827r 3                               ; First determine location of jmp instructions address.
002827r 3                               ; It should be 2 bytes before the start of the string.
002827r 3               
002827r 3                               ; Compute it into tmp1, which is no longer being used.
002827r 3  B5 02                        lda 2,x
002829r 3  38                           sec
00282Ar 3  E9 02                        sbc #2
00282Cr 3  85 rr                        sta tmp1
00282Er 3  B5 03                        lda 3,x
002830r 3  E9 00                        sbc #0          ; Propagate borrow
002832r 3  85 rr                        sta tmp1+1
002834r 3               
002834r 3                               ; Update the address of the jump to HERE.
002834r 3  A5 rr                        lda cp
002836r 3  92 rr                        sta (tmp1)
002838r 3  A0 01                        ldy #1
00283Ar 3  A5 rr                        lda cp+1
00283Cr 3  91 rr                        sta (tmp1),y
00283Er 3               
00283Er 3                               ; Stack is now ( addr2 u ) where addr2 is the new
00283Er 3                               ; location in the dictionary.
00283Er 3               
00283Er 3               sliteral_const_str:
00283Er 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
00283Er 3                               ; pushes the new ( addr u ) pair to the Data Stack.
00283Er 3                               ; When we're done, the code will look like this:
00283Er 3               
00283Er 3                               ; xt -->    jmp a
00283Er 3                               ;           <string data bytes>
00283Er 3                               ;  a -->    jsr sliteral_runtime
00283Er 3                               ;           <string address>
00283Er 3                               ;           <string length>
00283Er 3                               ; rts -->
00283Er 3               
00283Er 3                               ; This means we'll have to adjust the return address for two
00283Er 3                               ; cells, not just one
00283Er 3  A0 rr                        ldy #>sliteral_runtime
002840r 3  A9 rr                        lda #<sliteral_runtime
002842r 3  20 rr rr                     jsr cmpl_subroutine
002845r 3               
002845r 3                               ; We want to have the address end up as NOS and the length
002845r 3                               ; as TOS, so we store the address first
002845r 3  B4 03                        ldy 3,x                ; address MSB
002847r 3  B5 02                        lda 2,x                ; address LSB
002849r 3  20 rr rr                     jsr cmpl_word
00284Cr 3               
00284Cr 3  B4 01                        ldy 1,x                ; length MSB
00284Er 3  B5 00                        lda 0,x                ; length LSB
002850r 3  20 rr rr                     jsr cmpl_word
002853r 3               
002853r 3                               ; clean up and leave
002853r 3  E8                           inx
002854r 3  E8                           inx
002855r 3  E8                           inx
002856r 3  E8                           inx
002857r 3               
002857r 3  60           z_sliteral:     rts
002858r 3               
002858r 3               
002858r 3               sliteral_runtime:
002858r 3               
002858r 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
002858r 3                       ; the Data Stack. We arrive here with the return address as the
002858r 3                       ; top of Return Stack, which points to the address of the string
002858r 3                       ; """
002858r 3  CA                           dex
002859r 3  CA                           dex
00285Ar 3  CA                           dex
00285Br 3  CA                           dex
00285Cr 3               
00285Cr 3                               ; Get the address of the string address off the stack and
00285Cr 3                               ; increase by one because of the RTS mechanics
00285Cr 3  68                           pla
00285Dr 3  85 rr                        sta tmp1        ; LSB of address
00285Fr 3  68                           pla
002860r 3  85 rr                        sta tmp1+1      ; MSB of address
002862r 3               
002862r 3                               ; Walk through both and save them
002862r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002864r 3  B1 rr                        lda (tmp1),y
002866r 3  95 02                        sta 2,x         ; LSB of address
002868r 3  C8                           iny
002869r 3               
002869r 3  B1 rr                        lda (tmp1),y
00286Br 3  95 03                        sta 3,x         ; MSB of address
00286Dr 3  C8                           iny
00286Er 3               
00286Er 3  B1 rr                        lda (tmp1),y
002870r 3  95 00                        sta 0,x         ; LSB of length
002872r 3  C8                           iny
002873r 3               
002873r 3  B1 rr                        lda (tmp1),y
002875r 3  95 01                        sta 1,x         ; MSB of length
002877r 3               
002877r 3                               ; restore return address
002877r 3  18                           clc
002878r 3  A5 rr                        lda tmp1
00287Ar 3  69 04                        adc #4
00287Cr 3  A8                           tay             ; LSB
00287Dr 3  A5 rr                        lda tmp1+1
00287Fr 3  69 00                        adc #0          ; we only need carry
002881r 3  48                           pha             ; MSB
002882r 3  5A                           phy
002883r 3               
002883r 3  60                           rts
002884r 3               
002884r 3               
002884r 3               
002884r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002884r 3               ; ## "sm/rem"  auto  ANS core
002884r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002884r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002884r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002884r 3                       ;
002884r 3                       ; Forth:
002884r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002884r 3                       ; R> ?NEGATE SWAP
002884r 3                       ; """
002884r 3               
002884r 3               xt_sm_slash_rem:
002884r 3  20 rr rr                     jsr underflow_3 ; contains double number
002887r 3               
002887r 3                               ; push MSB of high cell of d to Data Stack so we can check
002887r 3                               ; its sign later
002887r 3  B5 03                        lda 3,x
002889r 3  48                           pha
00288Ar 3               
00288Ar 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
00288Ar 3                               ; its sign later as well
00288Ar 3  B5 01                        lda 1,x
00288Cr 3  55 03                        eor 3,x
00288Er 3  48                           pha
00288Fr 3               
00288Fr 3                               ; Prepare division by getting absolute of n1 and d
00288Fr 3  20 rr rr                     jsr xt_abs
002892r 3  E8                           inx             ; pretend we pushed n1 to R
002893r 3  E8                           inx
002894r 3               
002894r 3  20 rr rr                     jsr xt_dabs
002897r 3  CA                           dex
002898r 3  CA                           dex
002899r 3               
002899r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
00289Cr 3               
00289Cr 3                               ; if the XOR compiled above is negative, negate the
00289Cr 3                               ; quotient (n3)
00289Cr 3  68                           pla
00289Dr 3  10 03                        bpl @1
00289Fr 3  20 rr rr                     jsr xt_negate
0028A2r 3               @1:
0028A2r 3                               ; if d was negative, negate the remainder (n2)
0028A2r 3  68                           pla
0028A3r 3  10 07                        bpl @done
0028A5r 3               
0028A5r 3  E8                           inx             ; pretend we pushed quotient to R
0028A6r 3  E8                           inx
0028A7r 3  20 rr rr                     jsr xt_negate
0028AAr 3  CA                           dex
0028ABr 3  CA                           dex
0028ACr 3               
0028ACr 3               @done:
0028ACr 3  60           z_sm_slash_rem: rts
0028ADr 3               
0028ADr 3               
0028ADr 3               
0028ADr 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
0028ADr 3               ; ## "source"  auto  ANS core
0028ADr 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
0028ADr 3               xt_source:
0028ADr 3                               ; add address
0028ADr 3  CA                           dex
0028AEr 3  CA                           dex
0028AFr 3  A5 rr                        lda cib
0028B1r 3  95 00                        sta 0,x
0028B3r 3  A5 rr                        lda cib+1
0028B5r 3  95 01                        sta 1,x
0028B7r 3               
0028B7r 3                               ; add size
0028B7r 3  CA                           dex
0028B8r 3  CA                           dex
0028B9r 3  A5 rr                        lda ciblen
0028BBr 3  95 00                        sta 0,x
0028BDr 3  A5 rr                        lda ciblen+1
0028BFr 3  95 01                        sta 1,x
0028C1r 3               
0028C1r 3  60           z_source:       rts
0028C2r 3               
0028C2r 3               
0028C2r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
0028C2r 3               ; ## "source-id"  tested  ANS core ext
0028C2r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
0028C2r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
0028C2r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
0028C2r 3                       ; string, and a text file gives the fileid.
0028C2r 3                       ; """
0028C2r 3               xt_source_id:
0028C2r 3  CA                           dex
0028C3r 3  CA                           dex
0028C4r 3               
0028C4r 3  A5 rr                        lda insrc
0028C6r 3  95 00                        sta 0,x
0028C8r 3  A5 rr                        lda insrc+1
0028CAr 3  95 01                        sta 1,x
0028CCr 3               
0028CCr 3  60           z_source_id:    rts
0028CDr 3               
0028CDr 3               
0028CDr 3               ; ## SPACE ( -- ) "Print a single space"
0028CDr 3               ; ## "space"  auto  ANS core
0028CDr 3                       ; """https://forth-standard.org/standard/core/SPACE"""
0028CDr 3               xt_space:
0028CDr 3  A9 20                        lda #AscSP
0028CFr 3  20 rr rr                     jsr emit_a
0028D2r 3               
0028D2r 3  60           z_space:        rts
0028D3r 3               
0028D3r 3               
0028D3r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
0028D3r 3               ; ## "spaces"  auto  ANS core
0028D3r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
0028D3r 3               
0028D3r 3               xt_spaces:
0028D3r 3  20 rr rr                     jsr underflow_1
0028D6r 3               
0028D6r 3                               ; catch any zero in TOS fast
0028D6r 3  B5 00                        lda 0,x
0028D8r 3  15 01                        ora 1,x
0028DAr 3  F0 2A                        beq @done
0028DCr 3               
0028DCr 3                               ; Usually we're only going to print far less than 256 spaces,
0028DCr 3                               ; so we create a quick loop for that. Short loop could be realized
0028DCr 3                               ; as a separate subroutine, but unless we're really pressed for
0028DCr 3                               ; memory at some point, this is faster
0028DCr 3  B4 01                        ldy 1,x
0028DEr 3  D0 0C                        bne @lots_of_spaces
0028E0r 3               
0028E0r 3  B4 00                        ldy 0,x
0028E2r 3               @quick_loop:
0028E2r 3                               ; we reach here knowing that there must be a number that is not
0028E2r 3                               ; zero in the TOS
0028E2r 3  A9 20                        lda #AscSP
0028E4r 3  20 rr rr                     jsr emit_a
0028E7r 3  88                           dey
0028E8r 3  F0 1C                        beq @done
0028EAr 3  80 F6                        bra @quick_loop
0028ECr 3               
0028ECr 3               @lots_of_spaces:
0028ECr 3                               ; We go through the first loop once to get rid of the lower
0028ECr 3                               ; counter byte. This could be zero
0028ECr 3  B4 00                        ldy 0,x
0028EEr 3               
0028EEr 3               @first_slow_loop:
0028EEr 3  F0 08                        beq @slow_outer_loop
0028F0r 3  A9 20                        lda #AscSP
0028F2r 3  20 rr rr                     jsr emit_a
0028F5r 3  88                           dey
0028F6r 3  80 F6                        bra @first_slow_loop
0028F8r 3               
0028F8r 3               @slow_outer_loop:
0028F8r 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
0028F8r 3  A0 00                        ldy #00
0028FAr 3               
0028FAr 3               @slow_inner_loop:
0028FAr 3  A9 20                        lda #AscSP
0028FCr 3  20 rr rr                     jsr emit_a
0028FFr 3  88                           dey
002900r 3  D0 F8                        bne @slow_inner_loop
002902r 3               
002902r 3  D6 01                        dec 1,x
002904r 3  D0 F2                        bne @slow_outer_loop
002906r 3               
002906r 3               @done:
002906r 3  E8                           inx             ; drop
002907r 3  E8                           inx
002908r 3               
002908r 3  60           z_spaces:       rts
002909r 3               
002909r 3               
002909r 3               
002909r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
002909r 3               ; ## "*"  auto  ANS core
002909r 3                       ; """https://forth-standard.org/standard/core/Times
002909r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
002909r 3                       ;
002909r 3                       ; This is nothing  more than UM* DROP
002909r 3                       ; """
002909r 3               
002909r 3               xt_star:
002909r 3  20 rr rr                     jsr underflow_2
00290Cr 3               
00290Cr 3  20 rr rr                     jsr xt_um_star
00290Fr 3  E8                           inx
002910r 3  E8                           inx
002911r 3               
002911r 3  60           z_star:         rts
002912r 3               
002912r 3               
002912r 3               
002912r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
002912r 3               ; ## "*/"  auto  ANS core
002912r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
002912r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
002912r 3                       ; without a remainder. This is */MOD without the mod.
002912r 3                       ;
002912r 3                       ; This word
002912r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
002912r 3                       ; pretty much what we do here
002912r 3                       ; """
002912r 3               xt_star_slash:
002912r 3                               ; We let */MOD check for underflow
002912r 3  20 rr rr                     jsr xt_star_slash_mod
002915r 3  20 rr rr                     jsr xt_swap
002918r 3  E8                           inx
002919r 3  E8                           inx
00291Ar 3               z_star_slash:
00291Ar 3  60                           rts
00291Br 3               
00291Br 3               
00291Br 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
00291Br 3               ; ## "*/mod"  auto  ANS core
00291Br 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
00291Br 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
00291Br 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
00291Br 3                       ; single-cell quotient n5.
00291Br 3                       ;
00291Br 3                       ; In Forth, this is
00291Br 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
00291Br 3                       ; """
00291Br 3               xt_star_slash_mod:
00291Br 3  20 rr rr                     jsr underflow_3
00291Er 3               
00291Er 3  20 rr rr                     jsr xt_to_r
002921r 3  20 rr rr                     jsr xt_m_star
002924r 3  20 rr rr                     jsr xt_r_from
002927r 3  20 rr rr                     jsr xt_sm_slash_rem
00292Ar 3               
00292Ar 3               z_star_slash_mod:
00292Ar 3  60                           rts
00292Br 3               
00292Br 3               
00292Br 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
00292Br 3               ; ## "state"  auto  ANS core
00292Br 3                       ; """https://forth-standard.org/standard/core/STATE
00292Br 3                       ; STATE is true when in compilation state, false otherwise. Note
00292Br 3                       ; we do not return the state itself, but only the address where
00292Br 3                       ; it lives. The state should not be changed directly by the user; see
00292Br 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
00292Br 3                       ; """
00292Br 3               xt_state:
00292Br 3  CA                           dex
00292Cr 3  CA                           dex
00292Dr 3  A9 rr                        lda #<state
00292Fr 3  95 00                        sta 0,x
002931r 3  A9 rr                        lda #>state
002933r 3  95 01                        sta 1,x
002935r 3               
002935r 3  60           z_state:        rts
002936r 3               
002936r 3               
002936r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002936r 3               ; ## "!"  auto  ANS core
002936r 3                       ; """https://forth-standard.org/standard/core/Store"""
002936r 3               xt_store:
002936r 3  20 rr rr                     jsr underflow_2
002939r 3               
002939r 3  B5 02                        lda 2,x         ; LSB
00293Br 3  81 00                        sta (0,x)
00293Dr 3               
00293Dr 3  F6 00                        inc 0,x
00293Fr 3  D0 02                        bne @1
002941r 3  F6 01                        inc 1,x
002943r 3               @1:
002943r 3  B5 03                        lda 3,x         ; MSB
002945r 3  81 00                        sta (0,x)
002947r 3               
002947r 3  E8                           inx             ; 2DROP
002948r 3  E8                           inx
002949r 3  E8                           inx
00294Ar 3  E8                           inx
00294Br 3               
00294Br 3  60           z_store:        rts
00294Cr 3               
00294Cr 3               
00294Cr 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
00294Cr 3               ; ## "strip-underflow"  tested  Tali Forth
00294Cr 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
00294Cr 3                       ; checking should be removed during the compilation of new words.
00294Cr 3                       ; Default is false.
00294Cr 3                       ; """
00294Cr 3               xt_strip_underflow:
00294Cr 3  CA                           dex
00294Dr 3  CA                           dex
00294Er 3               
00294Er 3  A9 rr                        lda #<uf_strip
002950r 3  95 00                        sta 0,x
002952r 3  A9 rr                        lda #>uf_strip
002954r 3  95 01                        sta 1,x
002956r 3               
002956r 3               z_strip_underflow:
002956r 3  60                           rts
002957r 3               
002957r 3               
002957r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
002957r 3               ; ## "swap"  auto  ANS core
002957r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
002957r 3               xt_swap:
002957r 3  20 rr rr                     jsr underflow_2
00295Ar 3               
00295Ar 3  B5 00                        lda 0,x         ; LSB
00295Cr 3  B4 02                        ldy 2,x
00295Er 3  95 02                        sta 2,x
002960r 3  94 00                        sty 0,x
002962r 3               
002962r 3  B5 01                        lda 1,x         ; MSB
002964r 3  B4 03                        ldy 3,x
002966r 3  95 03                        sta 3,x
002968r 3  94 01                        sty 1,x
00296Ar 3               
00296Ar 3  60           z_swap:         rts
00296Br 3               
00296Br 3               
00296Br 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
00296Br 3               ; ## "then"  auto  ANS core
00296Br 3                       ; """http://forth-standard.org/standard/core/THEN"""
00296Br 3               xt_then:
00296Br 3                               ; Get the address to jump to.
00296Br 3  20 rr rr                     jsr xt_here
00296Er 3               
00296Er 3                               ; Stuff HERE in for the branch address back
00296Er 3                               ; at the IF or ELSE (origination address is on stack).
00296Er 3  20 rr rr                     jsr xt_swap
002971r 3  20 rr rr                     jsr xt_store
002974r 3               
002974r 3  60           z_then:         rts
002975r 3               
002975r 3               
002975r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002975r 3               ; ## "thru"  tested  ANS block ext
002975r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002975r 3               
002975r 3               xt_thru:
002975r 3  20 rr rr                     jsr underflow_2
002978r 3               
002978r 3                               ; We need to loop here, and can't use the data stack
002978r 3                               ; because the LOADed screens might use it.  We'll
002978r 3                               ; need to use the same trick that DO loops use, holding
002978r 3                               ; the limit and current index on the return stack.
002978r 3               
002978r 3                               ; Put the ending screen number on the return stack
002978r 3  B5 01                        lda 1,x
00297Ar 3  48                           pha
00297Br 3  B5 00                        lda 0,x
00297Dr 3  48                           pha
00297Er 3  E8                           inx
00297Fr 3  E8                           inx
002980r 3               @thru_loop:
002980r 3                               ; Put the starting screen number on the stack,
002980r 3                               ; but keep a copy
002980r 3  B5 01                        lda 1,x
002982r 3  48                           pha
002983r 3  B5 00                        lda 0,x
002985r 3  48                           pha
002986r 3               
002986r 3                               ; Load this screen.
002986r 3  20 rr rr                     jsr xt_load
002989r 3               
002989r 3                               ; Get the number and limit back off the stack.  Rather than
002989r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
002989r 3               
002989r 3                               ; Get the screen we just loaded.
002989r 3  68                           pla
00298Ar 3  85 rr                        sta tmp1
00298Cr 3  68                           pla
00298Dr 3  85 rr                        sta tmp1+1
00298Fr 3               
00298Fr 3                               ; Get the ending screen.
00298Fr 3  68                           pla
002990r 3  85 rr                        sta tmp2
002992r 3  68                           pla
002993r 3  85 rr                        sta tmp2+1
002995r 3               
002995r 3                               ; See if we just loaded the last screen.
002995r 3                               ; A already has the MSB of the last screen in it.
002995r 3  C5 rr                        cmp tmp1+1
002997r 3  D0 08                        bne @next_screen
002999r 3  A5 rr                        lda tmp2        ; Compare the LSB
00299Br 3  C5 rr                        cmp tmp1
00299Dr 3  D0 02                        bne @next_screen
00299Fr 3  80 18                        bra @done       ; We just did the last screen.
0029A1r 3               
0029A1r 3               @next_screen:
0029A1r 3                               ; Put the ending screen back on the data stack.
0029A1r 3  A5 rr                        lda tmp2+1
0029A3r 3  48                           pha
0029A4r 3  A5 rr                        lda tmp2
0029A6r 3  48                           pha
0029A7r 3               
0029A7r 3                               ; Increment the current screen.
0029A7r 3  E6 rr                        inc tmp1
0029A9r 3  D0 02                        bne @1
0029ABr 3  E6 rr                        inc tmp1+1
0029ADr 3               @1:
0029ADr 3                               ; Put the current screen on the stack to prepare for
0029ADr 3                               ; the next loop.
0029ADr 3  CA                           dex
0029AEr 3  CA                           dex
0029AFr 3  A5 rr                        lda tmp1
0029B1r 3  95 00                        sta 0,x
0029B3r 3  A5 rr                        lda tmp1+1
0029B5r 3  95 01                        sta 1,x
0029B7r 3  80 C7                        bra @thru_loop
0029B9r 3               @done:
0029B9r 3  60           z_thru:         rts
0029BAr 3               
0029BAr 3               
0029BAr 3               
0029BAr 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
0029BAr 3               ; ## "'"  auto  ANS core
0029BAr 3                       ; """https://forth-standard.org/standard/core/Tick"""
0029BAr 3               
0029BAr 3               xt_tick:
0029BAr 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
0029BDr 3               
0029BDr 3                               ; if we got a zero, there was a problem getting the
0029BDr 3                               ; name of the word
0029BDr 3  B5 00                        lda 0,x
0029BFr 3  15 01                        ora 1,x
0029C1r 3  D0 05                        bne @1
0029C3r 3               
0029C3r 3  A9 05                        lda #err_noname
0029C5r 3  4C rr rr                     jmp error
0029C8r 3               @1:
0029C8r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
0029CBr 3               
0029CBr 3                               ; If we didn't find the word in the Dictionary, abort
0029CBr 3  B5 00                        lda 0,x
0029CDr 3  15 01                        ora 1,x
0029CFr 3  D0 05                        bne @2
0029D1r 3               
0029D1r 3  A9 08                        lda #err_syntax
0029D3r 3  4C rr rr                     jmp error
0029D6r 3               @2:
0029D6r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
0029D9r 3               
0029D9r 3  60           z_tick:         rts
0029DAr 3               
0029DAr 3               
0029DAr 3               
0029DAr 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
0029DAr 3               ; ## "to"  auto  ANS core ext
0029DAr 3                       ; """https://forth-standard.org/standard/core/TO
0029DAr 3                       ; Gives a new value to a, uh, VALUE.
0029DAr 3                       ;
0029DAr 3                       ; One possible Forth
0029DAr 3                       ; implementation is  ' >BODY !  but given the problems we have
0029DAr 3                       ; with >BODY on STC Forths, we do this the hard way. Since
0029DAr 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
0029DAr 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
0029DAr 3                       ;
0029DAr 3                       ; Note that the standard has different behaviors for TO depending
0029DAr 3                       ; on the state (https://forth-standard.org/standard/core/TO).
0029DAr 3                       ; This makes TO state-dependent (which is bad) and also rather
0029DAr 3                       ; complex (see the Gforth implementation for comparison). This
0029DAr 3                       ; word may not be natively compiled and must be immediate. Frankly,
0029DAr 3                       ; it would have made more sense to have two words for this.
0029DAr 3                       ; """
0029DAr 3               
0029DAr 3               xt_to:
0029DAr 3                               ; One way or the other, we need the xt of the word after this
0029DAr 3                               ; one. At this point, we don't know if we are interpreted or
0029DAr 3                               ; compile, so we don't know if there is a value n on the stack,
0029DAr 3                               ; so we can't do an underflow check yet
0029DAr 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
0029DDr 3               
0029DDr 3                               ; The PFA (DFA in this case) is three bytes down,
0029DDr 3                               ; after the jump to DOCONST
0029DDr 3  B5 00                        lda 0,x                 ; LSB
0029DFr 3  18                           clc
0029E0r 3  69 03                        adc #3
0029E2r 3  85 rr                        sta tmp1
0029E4r 3  B5 01                        lda 1,x                 ; MSB
0029E6r 3  69 00                        adc #0                  ; we just want the carry
0029E8r 3  85 rr                        sta tmp1+1
0029EAr 3               
0029EAr 3  E8                           inx
0029EBr 3  E8                           inx                     ; ( [n] )
0029ECr 3               
0029ECr 3                               ; Now it gets ugly. See which state we are in
0029ECr 3  A5 rr                        lda state
0029EEr 3  05 rr                        ora state+1
0029F0r 3  F0 34                        beq @interpret
0029F2r 3               
0029F2r 3                               ; Well, we're compiling. We want to end up with simple
0029F2r 3                               ; code that just takes the number that is TOS and saves
0029F2r 3                               ; it in the address of the xt we were just given. So we
0029F2r 3                               ; want to compile this routine:
0029F2r 3                               ;
0029F2r 3                               ;       lda 0,x                 - B5 00
0029F2r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0029F2r 3                               ;       lda 1,x                 - B5 01
0029F2r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0029F2r 3                               ;       inx                     - E8
0029F2r 3                               ;       inx                     - E8
0029F2r 3                               ;
0029F2r 3                               ; which at least is nice and short. Other than that, we pretty
0029F2r 3                               ; much have to do this the hard and long way, because with the
0029F2r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
0029F2r 3                               ; range and store them with a loop. Sigh.
0029F2r 3               
0029F2r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
0029F4r 3  A9 B5                        lda #$B5
0029F6r 3  20 rr rr                     jsr cmpl_word
0029F9r 3               
0029F9r 3  A9 8D                        lda #$8D                ; Code for STA abs
0029FBr 3  20 rr rr                     jsr cmpl_a
0029FEr 3               
0029FEr 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002A00r 3  A5 rr                        lda tmp1
002A02r 3  20 rr rr                     jsr cmpl_word
002A05r 3               
002A05r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
002A07r 3  A9 B5                        lda #$B5
002A09r 3  20 rr rr                     jsr cmpl_word
002A0Cr 3               
002A0Cr 3  A9 8D                        lda #$8D                ; Code for STA abs
002A0Er 3  20 rr rr                     jsr cmpl_a
002A11r 3               
002A11r 3  E6 rr                        inc tmp1                ; Calculate MSB
002A13r 3  D0 02                        bne @1
002A15r 3  E6 rr                        inc tmp1+1
002A17r 3               @1:
002A17r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002A19r 3  A5 rr                        lda tmp1
002A1Br 3  20 rr rr                     jsr cmpl_word
002A1Er 3               
002A1Er 3  A0 E8                        ldy #$E8                ; Code for INX
002A20r 3  98                           tya
002A21r 3  20 rr rr                     jsr cmpl_word
002A24r 3               
002A24r 3  80 0F                        bra @done
002A26r 3               
002A26r 3               @interpret:
002A26r 3                               ; We're interpreting, so we arrive here with n
002A26r 3                               ; on the stack. This is an annoying place to put
002A26r 3                               ; the underflow check because we can't
002A26r 3                               ; automatically strip it out
002A26r 3  20 rr rr                     jsr underflow_1
002A29r 3               
002A29r 3                               ; We skip over the jump to DOCONST and store the number
002A29r 3                               ; in the Program Field Area (PDF, in this case more a
002A29r 3                               ; Data Field Area
002A29r 3  B5 00                        lda 0,x
002A2Br 3  92 rr                        sta (tmp1)              ; LSB
002A2Dr 3               
002A2Dr 3  A0 01                        ldy #1
002A2Fr 3  B5 01                        lda 1,x                 ; MSB
002A31r 3  91 rr                        sta (tmp1),y            ; fall through to common
002A33r 3               
002A33r 3  E8                           inx                     ; DROP
002A34r 3  E8                           inx
002A35r 3               @done:
002A35r 3  60           z_to:           rts
002A36r 3               
002A36r 3               
002A36r 3               
002A36r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002A36r 3               ; ## ">body"  auto  ANS core
002A36r 3                       ; """https://forth-standard.org/standard/core/toBODY
002A36r 3                       ; Given a word's execution token (xt), return the address of the
002A36r 3                       ; start of that word's parameter field (PFA). This is defined as the
002A36r 3                       ; address that HERE would return right after CREATE.
002A36r 3                       ;
002A36r 3                       ; This is a
002A36r 3                       ; difficult word for STC Forths, because most words don't actually
002A36r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002A36r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002A36r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002A36r 3                       ; """
002A36r 3               
002A36r 3               xt_to_body:
002A36r 3  20 rr rr                     jsr underflow_1
002A39r 3               
002A39r 3                               ; Ideally, xt already points to the CFA. We just need to check
002A39r 3                               ; the HC flag for special cases
002A39r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
002A3Cr 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
002A3Fr 3               
002A3Fr 3                               ; The status byte is nt+1
002A3Fr 3  F6 00                        inc 0,x
002A41r 3  D0 02                        bne @1
002A43r 3  F6 01                        inc 1,x
002A45r 3               @1:
002A45r 3  A1 00                        lda (0,x)               ; get status byte
002A47r 3  29 20                        and #HC
002A49r 3  F0 0D                        beq @no_cfa
002A4Br 3               
002A4Br 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
002A4Br 3                               ; so we add three to xt, which is NOS
002A4Br 3  18                           clc
002A4Cr 3  B5 02                        lda 2,x         ; LSB
002A4Er 3  69 03                        adc #3
002A50r 3  95 02                        sta 2,x
002A52r 3  B5 03                        lda 3,x         ; MSB
002A54r 3  69 00                        adc #0          ; we conly care about the carry
002A56r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
002A58r 3               @no_cfa:
002A58r 3  E8                           inx             ; get rid of the nt
002A59r 3  E8                           inx
002A5Ar 3               @done:
002A5Ar 3  60           z_to_body:      rts
002A5Br 3               
002A5Br 3               
002A5Br 3               
002A5Br 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
002A5Br 3               ; ## ">in"  auto  ANS core
002A5Br 3               xt_to_in:
002A5Br 3  CA                           dex
002A5Cr 3  CA                           dex
002A5Dr 3               
002A5Dr 3  A9 rr                        lda #<toin
002A5Fr 3  95 00                        sta 0,x
002A61r 3  A9 rr                        lda #>toin      ; paranoid, should be zero
002A63r 3  95 01                        sta 1,x
002A65r 3               
002A65r 3  60           z_to_in:        rts
002A66r 3               
002A66r 3               
002A66r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002A66r 3               ; ## ">number"  auto  ANS core
002A66r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002A66r 3                       ; Convert a string to a double number. Logic here is based on the
002A66r 3                       ; routine by Phil Burk of the same name in pForth, see
002A66r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002A66r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002A66r 3                       ; made sure that we don't have to deal with a sign and we don't have
002A66r 3                       ; to deal with a dot as a last character that signalizes double -
002A66r 3                       ; this should be a pure number string.
002A66r 3                       ;
002A66r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002A66r 3                       ; cannot access any of those.
002A66r 3                       ;
002A66r 3                       ; For the math routine, we move the inputs to the scratchpad to
002A66r 3                       ; avoid having to fool around with the Data Stack.
002A66r 3                       ;
002A66r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002A66r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002A66r 3                       ;     |           |           |           |           |
002A66r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002A66r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002A66r 3                       ;
002A66r 3                       ; The math routine works by converting one character to its
002A66r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002A66r 3                       ; the moment. We then multiply the UD-HI value with the radix
002A66r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002A66r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002A66r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002A66r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002A66r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002A66r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002A66r 3                       ; storing the result back in S and S+2, before we start another
002A66r 3                       ; round with it as the new UD-LO and UD-HI.
002A66r 3                       ; """
002A66r 3               
002A66r 3               
002A66r 3               xt_to_number:
002A66r 3  20 rr rr                     jsr underflow_4
002A69r 3               
002A69r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
002A69r 3                               ; After this step, the original ud-lo and ud-hi will still be on
002A69r 3                               ; the Data Stack, but will be ignored and later overwritten
002A69r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
002A69r 3  B5 06                        lda 6,x         ; ud-lo LSB
002A6Br 3  85 rr                        sta scratch
002A6Dr 3  B5 07                        lda 7,x         ; ud-lo MSB
002A6Fr 3  85 rr                        sta scratch+1
002A71r 3               
002A71r 3  B5 04                        lda 4,x         ; ud-hi LSB
002A73r 3  85 rr                        sta scratch+2
002A75r 3  B5 05                        lda 5,x         ; ud-hi MSB
002A77r 3  85 rr                        sta scratch+3
002A79r 3               
002A79r 3                               ; Push down one on the Data Stack to use TOS for character
002A79r 3                               ; conversion ( ud-lo ud-hi addr u x )
002A79r 3  CA                           dex
002A7Ar 3  CA                           dex
002A7Br 3               
002A7Br 3               @loop:
002A7Br 3                               ; Get one character based on address
002A7Br 3  A1 04                        lda (4,x)
002A7Dr 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
002A7Fr 3  74 01                        stz 1,x                 ; paranoid
002A81r 3               
002A81r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002A84r 3               
002A84r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002A84r 3                               ; check the flag. If it is zero, we return what we have and
002A84r 3                               ; let the caller (usually NUMBER) complain
002A84r 3  B5 00                        lda 0,x
002A86r 3  D0 04                        bne @digit_ok
002A88r 3               
002A88r 3  E8                           inx
002A89r 3  E8                           inx
002A8Ar 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
002A8Cr 3               
002A8Cr 3               @digit_ok:
002A8Cr 3                               ; Conversion was successful. We arrive here with
002A8Cr 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
002A8Cr 3                               ; math routine
002A8Cr 3               
002A8Cr 3                               ; Save n so we don't have to fool around with the
002A8Cr 3                               ; Data Stack
002A8Cr 3  B5 02                        lda 2,x
002A8Er 3  85 rr                        sta scratch+4
002A90r 3  B5 03                        lda 3,x
002A92r 3  85 rr                        sta scratch+5
002A94r 3               
002A94r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002A94r 3                               ; original one on the Data Stack) with the radix from BASE.
002A94r 3                               ; We can clobber TOS and NOS because we saved n
002A94r 3  A5 rr                        lda scratch+2
002A96r 3  95 02                        sta 2,x         ; NOS
002A98r 3  A5 rr                        lda scratch+3
002A9Ar 3  95 03                        sta 3,x
002A9Cr 3               
002A9Cr 3  A5 rr                        lda base
002A9Er 3  95 00                        sta 0,x         ; TOS
002AA0r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002AA2r 3               
002AA2r 3                               ; UM* returns a double-celled number
002AA2r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002AA5r 3               
002AA5r 3                               ; Move ud-hi-lo to safety
002AA5r 3  B5 02                        lda 2,x         ; ud-hi-lo
002AA7r 3  85 rr                        sta scratch+6
002AA9r 3  B5 03                        lda 3,x
002AABr 3  85 rr                        sta scratch+7
002AADr 3               
002AADr 3                               ; Now we multiply ud-lo, overwriting the stack entries
002AADr 3  A5 rr                        lda scratch
002AAFr 3  95 02                        sta 2,x
002AB1r 3  A5 rr                        lda scratch+1
002AB3r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002AB5r 3               
002AB5r 3  A5 rr                        lda base
002AB7r 3  95 00                        sta 0,x
002AB9r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002ABBr 3               
002ABBr 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002ABEr 3               
002ABEr 3  B5 00                        lda 0,x
002AC0r 3  85 rr                        sta scratch+2
002AC2r 3  B5 01                        lda 1,x
002AC4r 3  85 rr                        sta scratch+3
002AC6r 3               
002AC6r 3  B5 02                        lda 2,x
002AC8r 3  85 rr                        sta scratch
002ACAr 3  B5 03                        lda 3,x
002ACCr 3  85 rr                        sta scratch+1
002ACEr 3               
002ACEr 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002ACEr 3                               ; both in the scratch pad
002ACEr 3  18                           clc
002ACFr 3  A5 rr                        lda scratch     ; ud-lo LSB
002AD1r 3  65 rr                        adc scratch+4   ; n LSB
002AD3r 3  85 rr                        sta scratch     ; this is the new ud-lo
002AD5r 3  A5 rr                        lda scratch+1   ; ud-lo MSB
002AD7r 3  65 rr                        adc scratch+5   ; n MSB
002AD9r 3  85 rr                        sta scratch+1
002ADBr 3               
002ADBr 3  A5 rr                        lda scratch+2   ; LSB
002ADDr 3  65 rr                        adc scratch+6
002ADFr 3  85 rr                        sta scratch+2   ; this is the new ud-hi
002AE1r 3  A5 rr                        lda scratch+3   ; MSB
002AE3r 3  65 rr                        adc scratch+7
002AE5r 3  85 rr                        sta scratch+3
002AE7r 3               
002AE7r 3                               ; Clean up: Get rid of one of the two top elements on
002AE7r 3                               ; the Data Stack. We don't really care which one
002AE7r 3  E8                           inx
002AE8r 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002AE9r 3               
002AE9r 3                               ; One character down. Move address up
002AE9r 3  F6 04                        inc 4,x
002AEBr 3  D0 02                        bne @1
002AEDr 3  F6 05                        inc 5,x
002AEFr 3               @1:
002AEFr 3                               ; Decrease counter
002AEFr 3  D6 02                        dec 2,x
002AF1r 3  D0 88                        bne @loop
002AF3r 3               
002AF3r 3               @done:
002AF3r 3                               ; Counter has reached zero or we have an error. In both
002AF3r 3                               ; cases, we clean up the Data Stack and return. Error gives
002AF3r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002AF3r 3                               ; ( ud-lo ud-hi addr u ud-lo )
002AF3r 3  E8                           inx
002AF4r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002AF5r 3               
002AF5r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002AF5r 3  A5 rr                        lda scratch     ; new ud-lo
002AF7r 3  95 06                        sta 6,x
002AF9r 3  A5 rr                        lda scratch+1
002AFBr 3  95 07                        sta 7,x
002AFDr 3               
002AFDr 3  A5 rr                        lda scratch+2
002AFFr 3  95 04                        sta 4,x
002B01r 3  A5 rr                        lda scratch+3
002B03r 3  95 05                        sta 5,x
002B05r 3               
002B05r 3  60           z_to_number:    rts
002B06r 3               
002B06r 3               
002B06r 3               
002B06r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002B06r 3               ; ## ">order"  tested  Gforth search
002B06r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002B06r 3               
002B06r 3               xt_to_order:
002B06r 3                               ; Put the wid on the return stack for now.
002B06r 3  20 rr rr                     jsr xt_to_r
002B09r 3               
002B09r 3                               ; Get the current search order.
002B09r 3  20 rr rr                     jsr xt_get_order
002B0Cr 3               
002B0Cr 3                               ; Get back the wid and add it to the list.
002B0Cr 3  20 rr rr                     jsr xt_r_from
002B0Fr 3  20 rr rr                     jsr xt_swap
002B12r 3  20 rr rr                     jsr xt_one_plus
002B15r 3               
002B15r 3                               ; Set the search order with the new list.
002B15r 3  20 rr rr                     jsr xt_set_order
002B18r 3               
002B18r 3  60           z_to_order:     rts
002B19r 3               
002B19r 3               
002B19r 3               
002B19r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002B19r 3               ; ## ">r"  auto  ANS core
002B19r 3                       ; """https://forth-standard.org/standard/core/toR
002B19r 3                       ; This word is handled differently for native and for
002B19r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002B19r 3                       ; word.
002B19r 3                       ; """
002B19r 3               xt_to_r:
002B19r 3                               ; Save the return address. If this word is natively
002B19r 3                               ; coded, this is a complete waste of cycles, but
002B19r 3                               ; required for subroutine coding
002B19r 3  68                           pla             ; LSB
002B1Ar 3  85 rr                        sta tmptos
002B1Cr 3  7A                           ply             ; MSB
002B1Dr 3               
002B1Dr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002B1Dr 3               
002B1Dr 3                               ; We check for underflow in the second step, so we can
002B1Dr 3                               ; strip off the stack thrashing for native compiling first
002B1Dr 3  20 rr rr                     jsr underflow_1
002B20r 3               
002B20r 3                               ; now we can do the actual work
002B20r 3  B5 01                        lda 1,x         ; MSB
002B22r 3  48                           pha
002B23r 3  B5 00                        lda 0,x         ; LSB
002B25r 3  48                           pha
002B26r 3               
002B26r 3  E8                           inx
002B27r 3  E8                           inx
002B28r 3               
002B28r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002B28r 3               
002B28r 3                               ; restore return address
002B28r 3  5A                           phy             ; MSB
002B29r 3  A5 rr                        lda tmptos
002B2Br 3  48                           pha             ; LSB
002B2Cr 3               
002B2Cr 3  60           z_to_r:         rts
002B2Dr 3               
002B2Dr 3               
002B2Dr 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002B2Dr 3               ; ## "true"  auto  ANS core ext
002B2Dr 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002B2Dr 3               xt_true:
002B2Dr 3  CA                           dex
002B2Er 3  CA                           dex
002B2Fr 3  A9 FF                        lda #$FF
002B31r 3  95 00                        sta 0,x
002B33r 3  95 01                        sta 1,x
002B35r 3               
002B35r 3  60           z_true:         rts
002B36r 3               
002B36r 3               
002B36r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002B36r 3               ; ## "tuck"  auto  ANS core ext
002B36r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002B36r 3               xt_tuck:
002B36r 3  20 rr rr                     jsr underflow_2
002B39r 3               
002B39r 3  CA                           dex
002B3Ar 3  CA                           dex
002B3Br 3               
002B3Br 3  B4 04                        ldy 4,x         ; LSB
002B3Dr 3  B5 02                        lda 2,x
002B3Fr 3  95 04                        sta 4,x
002B41r 3  94 02                        sty 2,x
002B43r 3  95 00                        sta 0,x
002B45r 3               
002B45r 3  B4 05                        ldy 5,x         ; MSB
002B47r 3  B5 03                        lda 3,x
002B49r 3  95 05                        sta 5,x
002B4Br 3  94 03                        sty 3,x         ; bba
002B4Dr 3  95 01                        sta 1,x         ; baa
002B4Fr 3               
002B4Fr 3  60           z_tuck:         rts
002B50r 3               
002B50r 3               
002B50r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002B50r 3               ; ## "2"  auto  Tali Forth
002B50r 3                       ;
002B50r 3                       ; This code is shared with ASSEMBLER-WORDLIST
002B50r 3               xt_assembler_wordlist:
002B50r 3               xt_two:
002B50r 3  CA                           dex
002B51r 3  CA                           dex
002B52r 3  A9 02                        lda #2
002B54r 3  95 00                        sta 0,x
002B56r 3  74 01                        stz 1,x
002B58r 3               
002B58r 3               z_assembler_wordlist:
002B58r 3  60           z_two:          rts
002B59r 3               
002B59r 3               
002B59r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
002B59r 3               ; ## "2drop"  auto  ANS core
002B59r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
002B59r 3               xt_two_drop:
002B59r 3  20 rr rr                     jsr underflow_2
002B5Cr 3               
002B5Cr 3  E8                           inx
002B5Dr 3  E8                           inx
002B5Er 3  E8                           inx
002B5Fr 3  E8                           inx
002B60r 3               
002B60r 3  60           z_two_drop:     rts
002B61r 3               
002B61r 3               
002B61r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002B61r 3               ; ## "2dup"  auto  ANS core
002B61r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002B61r 3               xt_two_dup:
002B61r 3  20 rr rr                     jsr underflow_2
002B64r 3               
002B64r 3  CA                           dex
002B65r 3  CA                           dex
002B66r 3  CA                           dex
002B67r 3  CA                           dex
002B68r 3               
002B68r 3  B5 04                        lda 4,x         ; TOS
002B6Ar 3  95 00                        sta 0,x
002B6Cr 3  B5 05                        lda 5,x
002B6Er 3  95 01                        sta 1,x
002B70r 3               
002B70r 3  B5 06                        lda 6,x         ; NOS
002B72r 3  95 02                        sta 2,x
002B74r 3  B5 07                        lda 7,x
002B76r 3  95 03                        sta 3,x
002B78r 3               
002B78r 3  60           z_two_dup:      rts
002B79r 3               
002B79r 3               
002B79r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
002B79r 3               ; ## "2@"  auto  ANS core
002B79r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
002B79r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
002B79r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
002B79r 3                       ; """
002B79r 3               xt_two_fetch:
002B79r 3  20 rr rr                     jsr underflow_1
002B7Cr 3               
002B7Cr 3  B5 00                        lda 0,x
002B7Er 3  85 rr                        sta tmp1
002B80r 3  B4 01                        ldy 1,x
002B82r 3  84 rr                        sty tmp1+1
002B84r 3               
002B84r 3  CA                           dex             ; reuse one stack element
002B85r 3  CA                           dex
002B86r 3               
002B86r 3  B2 rr                        lda (tmp1)      ; copy LSB
002B88r 3  95 00                        sta 0,x
002B8Ar 3  A0 01                        ldy #1          ; copy next
002B8Cr 3  B1 rr                        lda (tmp1),y
002B8Er 3  95 01                        sta 1,x
002B90r 3  C8                           iny             ; copy next
002B91r 3  B1 rr                        lda (tmp1),y
002B93r 3  95 02                        sta 2,x
002B95r 3  C8                           iny             ; copy next
002B96r 3  B1 rr                        lda (tmp1),y
002B98r 3  95 03                        sta 3,x
002B9Ar 3               
002B9Ar 3  60           z_two_fetch:    rts
002B9Br 3               
002B9Br 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
002B9Br 3               ; ## "2over"  auto  ANS core
002B9Br 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
002B9Br 3               xt_two_over:
002B9Br 3  20 rr rr                     jsr underflow_4
002B9Er 3               
002B9Er 3  CA                           dex
002B9Fr 3  CA                           dex
002BA0r 3  CA                           dex
002BA1r 3  CA                           dex
002BA2r 3               
002BA2r 3  B5 08                        lda 8,x
002BA4r 3  95 00                        sta 0,x
002BA6r 3               
002BA6r 3  B5 09                        lda 9,x
002BA8r 3  95 01                        sta 1,x
002BAAr 3               
002BAAr 3  B5 0A                        lda 10,x
002BACr 3  95 02                        sta 2,x
002BAEr 3               
002BAEr 3  B5 0B                        lda 11,x
002BB0r 3  95 03                        sta 3,x
002BB2r 3               
002BB2r 3  60           z_two_over:     rts
002BB3r 3               
002BB3r 3               
002BB3r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002BB3r 3               ; ## "2r@"  auto  ANS core ext
002BB3r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002BB3r 3                       ;
002BB3r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002BB3r 3                       ; assembler. We use trickery to access the elements on the Return
002BB3r 3                       ; Stack instead of pulling the return address first and storing
002BB3r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002BB3r 3                       ; it as Never Native; at some point, we should compare versions to
002BB3r 3                       ; see if an Always Native version would be better
002BB3r 3                       ; """
002BB3r 3               xt_two_r_fetch:
002BB3r 3               		; make room on the Data Stack
002BB3r 3  CA                           dex
002BB4r 3  CA                           dex
002BB5r 3  CA                           dex
002BB6r 3  CA                           dex
002BB7r 3               
002BB7r 3                               ; Get four bytes off of Return Stack. This assumes that
002BB7r 3                               ; we took a subroutine jump here so the first two entries
002BB7r 3                               ; are the return address
002BB7r 3  8A                           txa
002BB8r 3  BA                           tsx
002BB9r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002BBAr 3  7A                           ply
002BBBr 3  AA                           tax
002BBCr 3               
002BBCr 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002BBCr 3                               ; the return address for this word. This is a whole lot
002BBCr 3                               ; easier on the 65816
002BBCr 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002BBFr 3  95 00                        sta 0,x
002BC1r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002BC4r 3  95 01                        sta 1,x
002BC6r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002BC9r 3  95 02                        sta 2,x
002BCBr 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002BCEr 3  95 03                        sta 3,x
002BD0r 3               
002BD0r 3  60           z_two_r_fetch:  rts
002BD1r 3               
002BD1r 3               
002BD1r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
002BD1r 3               ; ## "2r>"  auto  ANS core ext
002BD1r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
002BD1r 3                       ; Pull top two entries from Return Stack.
002BD1r 3                       ;
002BD1r 3                       ; Is the same as
002BD1r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
002BD1r 3                       ; the top value on the ReturnStack for a STC Forth is the
002BD1r 3                       ; return address, which we need to get out of the way first.
002BD1r 3                       ; Native compile needs to be handled as a special case.
002BD1r 3                       ; """
002BD1r 3               xt_two_r_from:
002BD1r 3                               ; save the return address
002BD1r 3  68                           pla                     ; LSB
002BD2r 3  85 rr                        sta tmp1
002BD4r 3  68                           pla                     ; MSB
002BD5r 3  85 rr                        sta tmp1+1
002BD7r 3               
002BD7r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002BD7r 3               
002BD7r 3               		; make room on stack
002BD7r 3  CA                           dex
002BD8r 3  CA                           dex
002BD9r 3  CA                           dex
002BDAr 3  CA                           dex
002BDBr 3               
002BDBr 3                               ; In theory, we should test for underflow on the Return
002BDBr 3                               ; Stack. However, given the traffic there with an STC
002BDBr 3                               ; Forth, that's probably not really useful
002BDBr 3               
002BDBr 3                               ; now we can access the data
002BDBr 3  68                           pla                     ; LSB
002BDCr 3  95 00                        sta 0,x
002BDEr 3  68                           pla                     ; MSB
002BDFr 3  95 01                        sta 1,x
002BE1r 3               
002BE1r 3  68                           pla                     ; LSB
002BE2r 3  95 02                        sta 2,x
002BE4r 3  68                           pla                     ; MSB
002BE5r 3  95 03                        sta 3,x
002BE7r 3               
002BE7r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002BE7r 3               
002BE7r 3                               ; restore return address
002BE7r 3  A5 rr                        lda tmp1+1              ; MSB
002BE9r 3  48                           pha
002BEAr 3  A5 rr                        lda tmp1                ; LSB
002BECr 3  48                           pha
002BEDr 3               
002BEDr 3  60           z_two_r_from:   rts
002BEEr 3               
002BEEr 3               
002BEEr 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002BEEr 3               ; ## "2/"  auto  ANS core
002BEEr 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002BEEr 3               xt_two_slash:
002BEEr 3  20 rr rr                     jsr underflow_1
002BF1r 3               
002BF1r 3                               ; We can't just LSR the LSB and ROR the MSB because that
002BF1r 3                               ; would do bad things to the sign
002BF1r 3  B5 01                        lda 1,x
002BF3r 3  0A                           asl                     ; save the sign
002BF4r 3  76 01                        ror 1,x
002BF6r 3  76 00                        ror 0,x
002BF8r 3               
002BF8r 3  60           z_two_slash:    rts
002BF9r 3               
002BF9r 3               
002BF9r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002BF9r 3               ; ## "2*"  auto  ANS core
002BF9r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002BF9r 3                       ;
002BF9r 3                       ; Also used for CELLS
002BF9r 3                       ; """
002BF9r 3               xt_two_star:
002BF9r 3               xt_cells:
002BF9r 3  20 rr rr                     jsr underflow_1
002BFCr 3               
002BFCr 3  16 00                        asl 0,x
002BFEr 3  36 01                        rol 1,x
002C00r 3               z_cells:
002C00r 3  60           z_two_star:     rts
002C01r 3               
002C01r 3               
002C01r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
002C01r 3               ; ## "2!"  auto  ANS core
002C01r 3                       ; """https://forth-standard.org/standard/core/TwoStore
002C01r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
002C01r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
002C01r 3                       ; """
002C01r 3               xt_two_store:
002C01r 3  20 rr rr                     jsr underflow_3
002C04r 3               
002C04r 3  B5 00                        lda 0,x
002C06r 3  85 rr                        sta tmp1
002C08r 3  B4 01                        ldy 1,x
002C0Ar 3  84 rr                        sty tmp1+1
002C0Cr 3               
002C0Cr 3  E8                           inx
002C0Dr 3  E8                           inx
002C0Er 3               
002C0Er 3  B5 00                        lda 0,x         ; copy MSB
002C10r 3  92 rr                        sta (tmp1)
002C12r 3  B5 01                        lda 1,x         ; copy next
002C14r 3  A0 01                        ldy #1
002C16r 3  91 rr                        sta (tmp1),y
002C18r 3  B5 02                        lda 2,x         ; copy next
002C1Ar 3  C8                           iny
002C1Br 3  91 rr                        sta (tmp1),y
002C1Dr 3  B5 03                        lda 3,x         ; copy MSB
002C1Fr 3  C8                           iny
002C20r 3  91 rr                        sta (tmp1),y
002C22r 3               
002C22r 3  E8                           inx             ; 2DROP
002C23r 3  E8                           inx
002C24r 3  E8                           inx
002C25r 3  E8                           inx
002C26r 3               
002C26r 3  60           z_two_store:    rts
002C27r 3               
002C27r 3               
002C27r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002C27r 3               ; ## "2swap"  auto  ANS core
002C27r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002C27r 3               xt_two_swap:
002C27r 3  20 rr rr                     jsr underflow_4
002C2Ar 3               
002C2Ar 3                               ; 0 <-> 4
002C2Ar 3  B5 00                        lda 0,x
002C2Cr 3  B4 04                        ldy 4,x
002C2Er 3  95 04                        sta 4,x
002C30r 3  94 00                        sty 0,x
002C32r 3               
002C32r 3                               ; 1 <-> 5
002C32r 3  B5 01                        lda 1,x
002C34r 3  B4 05                        ldy 5,x
002C36r 3  95 05                        sta 5,x
002C38r 3  94 01                        sty 1,x
002C3Ar 3               
002C3Ar 3                               ; 2 <-> 6
002C3Ar 3  B5 02                        lda 2,x
002C3Cr 3  B4 06                        ldy 6,x
002C3Er 3  95 06                        sta 6,x
002C40r 3  94 02                        sty 2,x
002C42r 3               
002C42r 3                               ; 3 <-> 7
002C42r 3  B5 03                        lda 3,x
002C44r 3  B4 07                        ldy 7,x
002C46r 3  95 07                        sta 7,x
002C48r 3  94 03                        sty 3,x
002C4Ar 3               
002C4Ar 3  60           z_two_swap:     rts
002C4Br 3               
002C4Br 3               
002C4Br 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
002C4Br 3               ; ## "2>r"  auto  ANS core ext
002C4Br 3                       ; """https://forth-standard.org/standard/core/TwotoR
002C4Br 3                       ; Push top two entries to Return Stack.
002C4Br 3                       ;
002C4Br 3                       ; The same as SWAP >R >R
002C4Br 3                       ; except that if we jumped here, the return address will be in the
002C4Br 3                       ; way. May not be natively compiled unless we're clever and use
002C4Br 3                       ; special routines.
002C4Br 3                       ; """
002C4Br 3               xt_two_to_r:
002C4Br 3                               ; save the return address
002C4Br 3  68                           pla             ; LSB
002C4Cr 3  85 rr                        sta tmp1
002C4Er 3  68                           pla             ; MSB
002C4Fr 3  85 rr                        sta tmp1+1
002C51r 3               
002C51r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002C51r 3               
002C51r 3  20 rr rr                     jsr underflow_2
002C54r 3               
002C54r 3                               ; now we can move the data
002C54r 3  B5 03                        lda 3,x         ; MSB
002C56r 3  48                           pha
002C57r 3  B5 02                        lda 2,x         ; LSB
002C59r 3  48                           pha
002C5Ar 3               
002C5Ar 3                               ; now we can move the data
002C5Ar 3  B5 01                        lda 1,x         ; MSB
002C5Cr 3  48                           pha
002C5Dr 3  B5 00                        lda 0,x         ; LSB
002C5Fr 3  48                           pha
002C60r 3               
002C60r 3  E8                           inx
002C61r 3  E8                           inx
002C62r 3  E8                           inx
002C63r 3  E8                           inx
002C64r 3               
002C64r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002C64r 3               
002C64r 3                               ; restore return address
002C64r 3  A5 rr                        lda tmp1+1      ; MSB
002C66r 3  48                           pha
002C67r 3  A5 rr                        lda tmp1        ; LSB
002C69r 3  48                           pha
002C6Ar 3               
002C6Ar 3  60           z_two_to_r:     rts
002C6Br 3               
002C6Br 3               
002C6Br 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
002C6Br 3               ; ## "2constant"  auto  ANS double
002C6Br 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
002C6Br 3                       ;
002C6Br 3                       ; Based on the Forth code
002C6Br 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
002C6Br 3                       ; """
002C6Br 3               xt_two_constant:
002C6Br 3  20 rr rr                     jsr underflow_2
002C6Er 3               
002C6Er 3  20 rr rr                     jsr xt_create
002C71r 3  20 rr rr                     jsr xt_swap
002C74r 3  20 rr rr                     jsr xt_comma
002C77r 3  20 rr rr                     jsr xt_comma
002C7Ar 3               
002C7Ar 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002C7Dr 3  20 rr rr                     jsr dodoes
002C80r 3               
002C80r 3  20 rr rr                     jsr xt_dup
002C83r 3  20 rr rr                     jsr xt_fetch
002C86r 3  20 rr rr                     jsr xt_swap
002C89r 3  20 rr rr                     jsr xt_cell_plus
002C8Cr 3  20 rr rr                     jsr xt_fetch
002C8Fr 3               
002C8Fr 3  60           z_two_constant: rts
002C90r 3               
002C90r 3               
002C90r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002C90r 3               ; ## "2literal"  auto  ANS double
002C90r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002C90r 3                       ; Based on the Forth code
002C90r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002C90r 3                       ; """
002C90r 3               xt_two_literal:
002C90r 3  20 rr rr                     jsr underflow_2 ; double number
002C93r 3               
002C93r 3  20 rr rr                     jsr xt_swap
002C96r 3  20 rr rr                     jsr xt_literal
002C99r 3  20 rr rr                     jsr xt_literal
002C9Cr 3               
002C9Cr 3  60           z_two_literal:  rts
002C9Dr 3               
002C9Dr 3               
002C9Dr 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002C9Dr 3               ; ## "2variable"  auto  ANS double
002C9Dr 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002C9Dr 3                       ; The variable is not initialized to zero.
002C9Dr 3                       ;
002C9Dr 3                       ; This can be realized in Forth as either
002C9Dr 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002C9Dr 3                       ; """
002C9Dr 3               xt_two_variable:
002C9Dr 3                               ; We just let CRATE and ALLOT do the heavy lifting
002C9Dr 3  20 rr rr                     jsr xt_create
002CA0r 3               
002CA0r 3  CA                           dex
002CA1r 3  CA                           dex
002CA2r 3  A9 04                        lda #4
002CA4r 3  95 00                        sta 0,x
002CA6r 3  74 01                        stz 1,x
002CA8r 3               
002CA8r 3  20 rr rr                     jsr xt_allot
002CABr 3               
002CABr 3  60           z_two_variable: rts
002CACr 3               
002CACr 3               
002CACr 3               ; ## TYPE ( addr u -- ) "Print string"
002CACr 3               ; ## "type"  auto  ANS core
002CACr 3                       ; """https://forth-standard.org/standard/core/TYPE
002CACr 3                       ; Works through EMIT to allow OUTPUT revectoring.
002CACr 3                       ; """
002CACr 3               
002CACr 3               xt_type:
002CACr 3  20 rr rr                     jsr underflow_2
002CAFr 3               
002CAFr 3                               ; Save the starting address into tmp1
002CAFr 3  B5 02                        lda 2,x
002CB1r 3  85 rr                        sta tmp1
002CB3r 3  B5 03                        lda 3,x
002CB5r 3  85 rr                        sta tmp1+1
002CB7r 3               @loop:
002CB7r 3                               ; done if length is zero
002CB7r 3  B5 00                        lda 0,x
002CB9r 3  15 01                        ora 1,x
002CBBr 3  F0 15                        beq @done
002CBDr 3               
002CBDr 3                               ; Send the current character
002CBDr 3  B2 rr                        lda (tmp1)
002CBFr 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002CC2r 3               
002CC2r 3                               ; Move the address along (in tmp1)
002CC2r 3  E6 rr                        inc tmp1
002CC4r 3  D0 02                        bne @1
002CC6r 3  E6 rr                        inc tmp1+1
002CC8r 3               @1:
002CC8r 3                               ; Reduce the count (on the data stack)
002CC8r 3  B5 00                        lda 0,x
002CCAr 3  D0 02                        bne @2
002CCCr 3  D6 01                        dec 1,x
002CCEr 3               @2:
002CCEr 3  D6 00                        dec 0,x
002CD0r 3               
002CD0r 3  80 E5                        bra @loop
002CD2r 3               @done:
002CD2r 3  E8                           inx
002CD3r 3  E8                           inx
002CD4r 3  E8                           inx
002CD5r 3  E8                           inx
002CD6r 3               
002CD6r 3  60           z_type:         rts
002CD7r 3               
002CD7r 3               
002CD7r 3               
002CD7r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002CD7r 3               ; ## "u."  tested  ANS core
002CD7r 3                       ; """https://forth-standard.org/standard/core/Ud
002CD7r 3                       ;
002CD7r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002CD7r 3                       ; We use the internal assembler function print_u followed
002CD7r 3                       ; by a single space
002CD7r 3                       ; """
002CD7r 3               xt_u_dot:
002CD7r 3  20 rr rr                     jsr underflow_1
002CDAr 3               
002CDAr 3  20 rr rr                     jsr print_u
002CDDr 3  A9 20                        lda #AscSP
002CDFr 3  20 rr rr                     jsr emit_a
002CE2r 3               
002CE2r 3  60           z_u_dot:        rts
002CE3r 3               
002CE3r 3               
002CE3r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
002CE3r 3               ; ## "u.r"  tested  ANS core ext
002CE3r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
002CE3r 3               xt_u_dot_r:
002CE3r 3  20 rr rr                     jsr underflow_2
002CE6r 3               
002CE6r 3  20 rr rr                     jsr xt_to_r
002CE9r 3  20 rr rr                     jsr xt_zero
002CECr 3  20 rr rr                     jsr xt_less_number_sign
002CEFr 3  20 rr rr                     jsr xt_number_sign_s
002CF2r 3  20 rr rr                     jsr xt_number_sign_greater
002CF5r 3  20 rr rr                     jsr xt_r_from
002CF8r 3  20 rr rr                     jsr xt_over
002CFBr 3  20 rr rr                     jsr xt_minus
002CFEr 3  20 rr rr                     jsr xt_spaces
002D01r 3  20 rr rr                     jsr xt_type
002D04r 3               
002D04r 3  60           z_u_dot_r:      rts
002D05r 3               
002D05r 3               
002D05r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002D05r 3               ; ## "u>"  auto  ANS core ext
002D05r 3                       ; """https://forth-standard.org/standard/core/Umore"""
002D05r 3               xt_u_greater_than:
002D05r 3  20 rr rr                     jsr underflow_2
002D08r 3               
002D08r 3  B5 00                        lda 0,x
002D0Ar 3  D5 02                        cmp 2,x
002D0Cr 3  B5 01                        lda 1,x
002D0Er 3  F5 03                        sbc 3,x
002D10r 3  E8                           inx
002D11r 3  E8                           inx
002D12r 3               
002D12r 3  A9 00                        lda #0
002D14r 3  69 FF                        adc #$ff
002D16r 3  95 00                        sta 0,x         ; store flag
002D18r 3  95 01                        sta 1,x
002D1Ar 3               
002D1Ar 3  60           z_u_greater_than:    rts
002D1Br 3               
002D1Br 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002D1Br 3               ; ## "u<"  auto  ANS core
002D1Br 3                       ; """https://forth-standard.org/standard/core/Uless"""
002D1Br 3               xt_u_less_than:
002D1Br 3  20 rr rr                     jsr underflow_2
002D1Er 3               
002D1Er 3  B5 02                        lda 2,x
002D20r 3  D5 00                        cmp 0,x
002D22r 3  B5 03                        lda 3,x
002D24r 3  F5 01                        sbc 1,x
002D26r 3  E8                           inx
002D27r 3  E8                           inx
002D28r 3               
002D28r 3  A9 00                        lda #0
002D2Ar 3  69 FF                        adc #$ff
002D2Cr 3  95 00                        sta 0,x         ; store flag
002D2Er 3  95 01                        sta 1,x
002D30r 3               
002D30r 3  60           z_u_less_than:    rts
002D31r 3               
002D31r 3               
002D31r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002D31r 3               ; ## "ud."  auto  Tali double
002D31r 3                       ;
002D31r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002D31r 3                       ; """
002D31r 3               xt_ud_dot:
002D31r 3  20 rr rr                     jsr underflow_2 ; double number
002D34r 3               
002D34r 3  20 rr rr                     jsr xt_less_number_sign
002D37r 3  20 rr rr                     jsr xt_number_sign_s
002D3Ar 3  20 rr rr                     jsr xt_number_sign_greater
002D3Dr 3  20 rr rr                     jsr xt_type
002D40r 3  20 rr rr                     jsr xt_space
002D43r 3               
002D43r 3  60           z_ud_dot:        rts
002D44r 3               
002D44r 3               
002D44r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002D44r 3               ; ## "ud.r"  auto  Tali double
002D44r 3                       ;
002D44r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002D44r 3                       ; """
002D44r 3               xt_ud_dot_r:
002D44r 3  20 rr rr                     jsr underflow_3
002D47r 3               
002D47r 3  20 rr rr                     jsr xt_to_r
002D4Ar 3  20 rr rr                     jsr xt_less_number_sign
002D4Dr 3  20 rr rr                     jsr xt_number_sign_s
002D50r 3  20 rr rr                     jsr xt_number_sign_greater
002D53r 3  20 rr rr                     jsr xt_r_from
002D56r 3  20 rr rr                     jsr xt_over
002D59r 3  20 rr rr                     jsr xt_minus
002D5Cr 3  20 rr rr                     jsr xt_spaces
002D5Fr 3  20 rr rr                     jsr xt_type
002D62r 3               
002D62r 3  60           z_ud_dot_r:      rts
002D63r 3               
002D63r 3               
002D63r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002D63r 3               ; ## "um/mod"  auto  ANS core
002D63r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002D63r 3                       ; Divide double cell number by single cell number, returning the
002D63r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002D63r 3                       ; This is the basic division operation all others use. Based on FIG
002D63r 3                       ; Forth code, modified by Garth Wilson, see
002D63r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002D63r 3                       ;
002D63r 3                       ; This uses tmp1, tmp1+1, and tmptos
002D63r 3                       ; """
002D63r 3               
002D63r 3               xt_um_slash_mod:
002D63r 3  20 rr rr                     jsr underflow_3
002D66r 3               
002D66r 3                               ; catch division by zero
002D66r 3  B5 00                        lda 0,x
002D68r 3  15 01                        ora 1,x
002D6Ar 3  D0 05                        bne @not_zero
002D6Cr 3               
002D6Cr 3  A9 04                        lda #err_divzero
002D6Er 3  4C rr rr                     jmp error
002D71r 3               
002D71r 3               @not_zero:
002D71r 3                               ; We loop 17 times
002D71r 3  A9 11                        lda #17
002D73r 3  85 rr                        sta tmptos
002D75r 3               
002D75r 3               @loop:
002D75r 3                               ; rotate low cell of dividend one bit left (LSB)
002D75r 3  36 04                        rol 4,x
002D77r 3  36 05                        rol 5,x
002D79r 3               
002D79r 3                               ; loop control
002D79r 3  C6 rr                        dec tmptos
002D7Br 3  F0 22                        beq @done
002D7Dr 3               
002D7Dr 3                               ; rotate high cell of dividend one bit left (MSB)
002D7Dr 3  36 02                        rol 2,x
002D7Fr 3  36 03                        rol 3,x
002D81r 3               
002D81r 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
002D83r 3  26 rr                        rol tmp1
002D85r 3               
002D85r 3                               ; subtract dividend hi cell minus divisor
002D85r 3  38                           sec
002D86r 3  B5 02                        lda 2,x
002D88r 3  F5 00                        sbc 0,x
002D8Ar 3  85 rr                        sta tmp1+1
002D8Cr 3  B5 03                        lda 3,x
002D8Er 3  F5 01                        sbc 1,x
002D90r 3               
002D90r 3  A8                           tay
002D91r 3  A5 rr                        lda tmp1
002D93r 3  E9 00                        sbc #0
002D95r 3  90 DE                        bcc @loop
002D97r 3               
002D97r 3                               ; make result new dividend high cell
002D97r 3  A5 rr                        lda tmp1+1
002D99r 3  95 02                        sta 2,x
002D9Br 3  94 03                        sty 3,x         ; used as temp storage
002D9Dr 3               
002D9Dr 3  80 D6                        bra @loop
002D9Fr 3               @done:
002D9Fr 3  E8                           inx
002DA0r 3  E8                           inx
002DA1r 3               
002DA1r 3  20 rr rr                     jsr xt_swap
002DA4r 3               
002DA4r 3  60           z_um_slash_mod: rts
002DA5r 3               
002DA5r 3               
002DA5r 3               
002DA5r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002DA5r 3               ; ## "um*"  auto  ANS core
002DA5r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002DA5r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002DA5r 3                       ; Old Forth versions such as FIG Forth call this U*
002DA5r 3                       ;
002DA5r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002DA5r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002DA5r 3                       ; discussion.
002DA5r 3                       ;
002DA5r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002DA5r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002DA5r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002DA5r 3                       ;
002DA5r 3                       ; Consider switching to a table-supported version based on
002DA5r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002DA5r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002DA5r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002DA5r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002DA5r 3                       ; """
002DA5r 3               
002DA5r 3               xt_um_star:
002DA5r 3  20 rr rr                     jsr underflow_2
002DA8r 3               
002DA8r 3                               ; to eliminate clc inside the loop, the value at
002DA8r 3                               ; tmp1 is reduced by 1 in advance
002DA8r 3  18                           clc
002DA9r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002DABr 3  E9 00                        sbc #0
002DADr 3  85 rr                        sta tmp2
002DAFr 3               
002DAFr 3  B5 01                        lda 1,x
002DB1r 3  E9 00                        sbc #0
002DB3r 3  90 31                        bcc @zero       ; is TOS zero?
002DB5r 3  85 rr                        sta tmp2+1
002DB7r 3               
002DB7r 3  A9 00                        lda #0
002DB9r 3  85 rr                        sta tmp1
002DBBr 3  86 rr                        stx tmp3        ; tested for exit from outer loop
002DBDr 3  CA                           dex
002DBEr 3  CA                           dex
002DBFr 3               
002DBFr 3               @outer_loop:
002DBFr 3  A0 08                        ldy #8          ; counter inner loop
002DC1r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002DC3r 3               
002DC3r 3               @inner_loop:
002DC3r 3  90 0C                        bcc @no_add
002DC5r 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002DC7r 3  A5 rr                        lda tmp1
002DC9r 3  65 rr                        adc tmp2
002DCBr 3  85 rr                        sta tmp1
002DCDr 3  A5 rr                        lda tmp1+1
002DCFr 3  65 rr                        adc tmp2+1
002DD1r 3               
002DD1r 3               @no_add:
002DD1r 3  6A                           ror
002DD2r 3  66 rr                        ror tmp1
002DD4r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002DD6r 3               
002DD6r 3  88                           dey
002DD7r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002DD9r 3               
002DD9r 3  E8                           inx
002DDAr 3  E4 rr                        cpx tmp3
002DDCr 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002DDEr 3               
002DDEr 3                               ; all done, store high word of result
002DDEr 3  95 01                        sta 1,x
002DE0r 3  A5 rr                        lda tmp1
002DE2r 3  95 00                        sta 0,x
002DE4r 3  80 04                        bra @done
002DE6r 3               
002DE6r 3               @zero:
002DE6r 3  74 02                        stz 2,x
002DE8r 3  74 03                        stz 3,x
002DEAr 3               @done:
002DEAr 3  60           z_um_star:      rts
002DEBr 3               
002DEBr 3               
002DEBr 3               
002DEBr 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002DEBr 3               ; ## "unloop"  auto  ANS core
002DEBr 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002DEBr 3                       ;
002DEBr 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002DEBr 3                       ; """
002DEBr 3               xt_unloop:
002DEBr 3                               ; Drop fudge number (limit/start from DO/?DO off the
002DEBr 3                               ; return stack
002DEBr 3  68                           pla
002DECr 3  68                           pla
002DEDr 3  68                           pla
002DEEr 3  68                           pla
002DEFr 3               
002DEFr 3                               ; Now drop the LEAVE address that was below them off
002DEFr 3                               ; the Return Stack as well
002DEFr 3  68                           pla
002DF0r 3  68                           pla
002DF1r 3               
002DF1r 3  60           z_unloop:       rts
002DF2r 3               
002DF2r 3               
002DF2r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
002DF2r 3               ; ## "until"  auto  ANS core
002DF2r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
002DF2r 3               xt_until:
002DF2r 3                               ; Compile a 0BRANCH
002DF2r 3  A0 rr                        ldy #>zero_branch_runtime
002DF4r 3  A9 rr                        lda #<zero_branch_runtime
002DF6r 3  20 rr rr                     jsr cmpl_subroutine
002DF9r 3               
002DF9r 3                               ; The address to loop back to is on the stack.
002DF9r 3                               ; Just compile it as the destination for the
002DF9r 3                               ; 0branch.
002DF9r 3  20 rr rr                     jsr xt_comma
002DFCr 3               
002DFCr 3  60           z_until:        rts
002DFDr 3               
002DFDr 3               
002DFDr 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
002DFDr 3               ; ## "unused"  auto  ANS core ext
002DFDr 3                       ; """https://forth-standard.org/standard/core/UNUSED
002DFDr 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
002DFDr 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
002DFDr 3                       ; defaults to $400
002DFDr 3                       ; """
002DFDr 3               xt_unused:
002DFDr 3  CA                           dex
002DFEr 3  CA                           dex
002DFFr 3               
002DFFr 3  A9 FF                        lda #<cp_end
002E01r 3  38                           sec
002E02r 3  E5 rr                        sbc cp
002E04r 3  95 00                        sta 0,x
002E06r 3               
002E06r 3  A9 7F                        lda #>cp_end
002E08r 3  E5 rr                        sbc cp+1
002E0Ar 3  95 01                        sta 1,x
002E0Cr 3               
002E0Cr 3  60           z_unused:       rts
002E0Dr 3               
002E0Dr 3               
002E0Dr 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
002E0Dr 3               ; ## "update"  auto  ANS block
002E0Dr 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
002E0Dr 3               xt_update:
002E0Dr 3                               ; Turn on the dirty bit. We can't use TSB here because it only
002E0Dr 3                               ; has Absolute and Direct Pages addressing modes
002E0Dr 3  A0 2C                        ldy #buffstatus_offset
002E0Fr 3  B1 rr                        lda (up),y
002E11r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
002E13r 3  91 rr                        sta (up),y
002E15r 3               
002E15r 3  60           z_update:       rts
002E16r 3               
002E16r 3               
002E16r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
002E16r 3               ; ## "useraddr"  tested  Tali Forth
002E16r 3               xt_useraddr:
002E16r 3  CA                           dex
002E17r 3  CA                           dex
002E18r 3  A9 rr                        lda #<up
002E1Ar 3  95 00                        sta 0,x
002E1Cr 3  A9 rr                        lda #>up
002E1Er 3  95 01                        sta 1,x
002E20r 3               
002E20r 3  60           z_useraddr:     rts
002E21r 3               
002E21r 3               
002E21r 3               ; ## VALUE ( n "name" -- ) "Define a value"
002E21r 3               ; ## "value"  auto  ANS core
002E21r 3                       ; """https://forth-standard.org/standard/core/VALUE
002E21r 3                       ;
002E21r 3                       ; This is a dummy header for the WORDLIST. The actual code is
002E21r 3                       ; identical to that of CONSTANT
002E21r 3                       ; """
002E21r 3               
002E21r 3               
002E21r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
002E21r 3               ; ## "variable"  auto  ANS core
002E21r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
002E21r 3                       ; There are various Forth definitions for this word, such as
002E21r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
002E21r 3                       ; second one so the variable is initialized to zero
002E21r 3                       ; """
002E21r 3               xt_variable:
002E21r 3                               ; we let CREATE do the heavy lifting
002E21r 3  20 rr rr                     jsr xt_create
002E24r 3               
002E24r 3                               ; there is no "STZ (CP)" so we have to do this the hard
002E24r 3                               ; way
002E24r 3  A9 00                        lda #0
002E26r 3               
002E26r 3  92 rr                        sta (cp)
002E28r 3  E6 rr                        inc cp
002E2Ar 3  D0 02                        bne @1
002E2Cr 3  E6 rr                        inc cp+1
002E2Er 3               @1:
002E2Er 3  92 rr                        sta (cp)
002E30r 3  E6 rr                        inc cp
002E32r 3  D0 02                        bne @2
002E34r 3  E6 rr                        inc cp+1
002E36r 3               @2:
002E36r 3                               ; Now we need to adjust the length of the complete word by two
002E36r 3  20 rr rr                     jsr adjust_z
002E39r 3               
002E39r 3  60           z_variable:     rts
002E3Ar 3               
002E3Ar 3               
002E3Ar 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
002E3Ar 3               ; ## "while"  auto  ANS core
002E3Ar 3                       ; """http://forth-standard.org/standard/core/WHILE"""
002E3Ar 3               xt_while:
002E3Ar 3                               ; Compile a 0branch
002E3Ar 3  A0 rr                        ldy #>zero_branch_runtime
002E3Cr 3  A9 rr                        lda #<zero_branch_runtime
002E3Er 3  20 rr rr                     jsr cmpl_subroutine
002E41r 3               
002E41r 3                               ; Put the address (here) where the destination
002E41r 3                               ; address needs to go so it can be put there later.
002E41r 3  20 rr rr                     jsr xt_here
002E44r 3               
002E44r 3                               ; Fill in the destination address with 0 for now.
002E44r 3  20 rr rr                     jsr xt_zero
002E47r 3  20 rr rr                     jsr xt_comma
002E4Ar 3               
002E4Ar 3                               ; Swap the two addresses on the stack.
002E4Ar 3  20 rr rr                     jsr xt_swap
002E4Dr 3               
002E4Dr 3  60           z_while:        rts
002E4Er 3               
002E4Er 3               
002E4Er 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
002E4Er 3               ; ## "within"  auto  ANS core ext
002E4Er 3                       ; """https://forth-standard.org/standard/core/WITHIN
002E4Er 3                       ;
002E4Er 3                       ; This an assembler version of the ANS Forth implementation
002E4Er 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
002E4Er 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
002E4Er 3                       ; ROT TUCK > -ROT > INVERT AND
002E4Er 3                       ; """"
002E4Er 3               xt_within:
002E4Er 3  20 rr rr                     jsr underflow_3
002E51r 3               
002E51r 3  20 rr rr                     jsr xt_over
002E54r 3  20 rr rr                     jsr xt_minus
002E57r 3  20 rr rr                     jsr xt_to_r
002E5Ar 3  20 rr rr                     jsr xt_minus
002E5Dr 3  20 rr rr                     jsr xt_r_from
002E60r 3  20 rr rr                     jsr xt_u_less_than
002E63r 3               
002E63r 3  60           z_within:       rts
002E64r 3               
002E64r 3               
002E64r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002E64r 3               ; ## "word"  auto  ANS core
002E64r 3                       ; """https://forth-standard.org/standard/core/WORD
002E64r 3                       ; Obsolete parsing word included for backwards compatibility only.
002E64r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002E64r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002E64r 3                       ; Returns the result as a counted string (requires COUNT to convert
002E64r 3                       ; to modern format), and inserts a space after the string. See "Forth
002E64r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002E64r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002E64r 3                       ; for discussions of why you shouldn't be using WORD anymore.
002E64r 3                       ;
002E64r 3                       ; Forth
002E64r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002E64r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002E64r 3                       ; """
002E64r 3               
002E64r 3               xt_word:
002E64r 3  20 rr rr                     jsr underflow_1
002E67r 3               
002E67r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
002E67r 3                               ; but unlike PARSE
002E67r 3  A4 rr                        ldy toin                ; >IN
002E69r 3               @loop:
002E69r 3  C4 rr                        cpy ciblen              ; quit if end of input
002E6Br 3  F0 09                        beq @found_char
002E6Dr 3  B1 rr                        lda (cib),y
002E6Fr 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002E71r 3  D0 03                        bne @found_char
002E73r 3               
002E73r 3  C8                           iny
002E74r 3  80 F3                        bra @loop
002E76r 3               @found_char:
002E76r 3                               ; Save index of where word starts
002E76r 3  84 rr                        sty toin
002E78r 3               
002E78r 3                               ; The real work is done by parse
002E78r 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
002E7Br 3               
002E7Br 3                               ; Convert the modern ( addr u ) string format to obsolete
002E7Br 3                               ; ( caddr ) format. We just do this in the Dictionary
002E7Br 3  B5 00                        lda 0,x
002E7Dr 3  92 rr                        sta (cp)                ; Save length of string
002E7Fr 3  48                           pha                     ; Keep copy of length for later
002E80r 3               
002E80r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002E83r 3  A5 rr                        lda cp
002E85r 3  18                           clc
002E86r 3  69 01                        adc #1
002E88r 3  95 02                        sta 2,x                 ; LSB of CP
002E8Ar 3  A5 rr                        lda cp+1
002E8Cr 3  69 00                        adc #0
002E8Er 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002E90r 3               
002E90r 3  20 rr rr                     jsr xt_move
002E93r 3               
002E93r 3                               ; Return caddr
002E93r 3  CA                           dex
002E94r 3  CA                           dex
002E95r 3  A5 rr                        lda cp
002E97r 3  95 00                        sta 0,x
002E99r 3  A5 rr                        lda cp+1
002E9Br 3  95 01                        sta 1,x
002E9Dr 3               
002E9Dr 3                               ; Adjust CP
002E9Dr 3  68                           pla                     ; length of string
002E9Er 3  18                           clc
002E9Fr 3  65 rr                        adc cp
002EA1r 3  85 rr                        sta cp
002EA3r 3  A5 rr                        lda cp+1
002EA5r 3  69 00                        adc #0                  ; we only need the carry
002EA7r 3  85 rr                        sta cp+1
002EA9r 3  60           z_word:         rts
002EAAr 3               
002EAAr 3               
002EAAr 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
002EAAr 3               ; ## "wordlist" auto ANS search
002EAAr 3                       ; """https://forth-standard.org/standard/search/WORDLIST
002EAAr 3                       ; See the tutorial on Wordlists and the Search Order for
002EAAr 3                       ; more information.
002EAAr 3                       ; """
002EAAr 3               
002EAAr 3               xt_wordlist:
002EAAr 3                               ; Get the current number of wordlists
002EAAr 3  A0 05                        ldy #num_wordlists_offset
002EACr 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
002EAEr 3                                               ; the LSB needs to be checked.
002EAEr 3               
002EAEr 3                               ; See if we are already at the max.
002EAEr 3  C9 0C                        cmp #max_wordlists
002EB0r 3  D0 05                        bne @ok
002EB2r 3               
002EB2r 3                               ; Print an error message if all wordlists used.
002EB2r 3  A9 0B                        lda #err_wordlist
002EB4r 3  4C rr rr                     jmp error
002EB7r 3               
002EB7r 3               @ok:
002EB7r 3  1A                           inc             ; Increment the wordlist#
002EB8r 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
002EBAr 3  CA                           dex             ; and put it on the stack.
002EBBr 3  CA                           dex
002EBCr 3  95 00                        sta 0,x
002EBEr 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002EC0r 3               
002EC0r 3  60           z_wordlist:     rts
002EC1r 3               
002EC1r 3               
002EC1r 3               
002EC1r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002EC1r 3               ; ## "words"  tested  ANS tools
002EC1r 3                       ; """https://forth-standard.org/standard/tools/WORDS
002EC1r 3                       ; This is pretty much only used at the command line so we can
002EC1r 3                       ; be slow and try to save space.
002EC1r 3                       ; """
002EC1r 3               
002EC1r 3               xt_words:
002EC1r 3                               ; we follow Gforth by starting on the next
002EC1r 3                               ; line
002EC1r 3  20 rr rr                     jsr xt_cr
002EC4r 3               
002EC4r 3                               ; We pretty-format the output by inserting a line break
002EC4r 3                               ; before the end of the line. We can get away with pushing
002EC4r 3                               ; the counter to the stack because this is usually an
002EC4r 3                               ; interactive word and speed is not that important
002EC4r 3  A9 00                        lda #0
002EC6r 3  48                           pha
002EC7r 3               
002EC7r 3                               ; Set up for traversing the wordlist search order.
002EC7r 3  CA                           dex                     ; Make room on the stack for
002EC8r 3  CA                           dex                     ; a dictionary pointer.
002EC9r 3  64 rr                        stz tmp3                ; Start at the beginning of
002ECBr 3                                                       ; the search order.
002ECBr 3               @wordlist_loop:
002ECBr 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
002ECDr 3  A5 rr                        lda tmp3
002ECFr 3  D1 rr                        cmp (up),y              ; See if we are done.
002ED1r 3  D0 02                        bne @have_wordlist
002ED3r 3               
002ED3r 3                               ; We ran out of wordlists to search.
002ED3r 3  80 44                        bra @words_done
002ED5r 3               
002ED5r 3               @have_wordlist:
002ED5r 3                               ; start with last word in Dictionary
002ED5r 3                               ; Get the current wordlist id
002ED5r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
002ED6r 3  69 1F                        adc #search_order_offset
002ED8r 3  A8                           tay
002ED9r 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
002EDBr 3               
002EDBr 3                               ; Get the DP for that wordlist.
002EDBr 3  0A                           asl                     ; Turn offset into cells offset.
002EDCr 3  18                           clc
002EDDr 3  69 06                        adc #wordlists_offset
002EDFr 3  A8                           tay
002EE0r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
002EE2r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
002EE4r 3  C8                           iny
002EE5r 3  B1 rr                        lda (up),y
002EE7r 3  95 01                        sta 1,x
002EE9r 3               
002EE9r 3               @loop:
002EE9r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002EECr 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
002EEFr 3               
002EEFr 3                               ; Insert line break if we're about to go past the end of the
002EEFr 3                               ; line
002EEFr 3  68                           pla
002EF0r 3  18                           clc
002EF1r 3  75 00                        adc 0,x
002EF3r 3  1A                           inc                     ; don't forget the space between words
002EF4r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
002EF6r 3  90 05                        bcc @1
002EF8r 3               
002EF8r 3  20 rr rr                     jsr xt_cr
002EFBr 3  A9 00                        lda #0
002EFDr 3               @1:
002EFDr 3  48                           pha
002EFEr 3  20 rr rr                     jsr xt_type             ; ( nt )
002F01r 3               
002F01r 3  A9 20                        lda #AscSP
002F03r 3  20 rr rr                     jsr emit_a
002F06r 3               
002F06r 3                               ; get next word, which begins two down
002F06r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002F09r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002F0Cr 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
002F0Fr 3               
002F0Fr 3                               ; if next address is zero, we're done
002F0Fr 3  B5 00                        lda 0,x
002F11r 3  15 01                        ora 1,x
002F13r 3  D0 D4                        bne @loop
002F15r 3               
002F15r 3                               ; Move on to the next wordlist in the search order.
002F15r 3  E6 rr                        inc tmp3
002F17r 3  80 B2                        bra @wordlist_loop
002F19r 3               
002F19r 3               @words_done:
002F19r 3  68                           pla                     ; dump counter
002F1Ar 3               
002F1Ar 3  E8                           inx
002F1Br 3  E8                           inx
002F1Cr 3               
002F1Cr 3  60           z_words:        rts
002F1Dr 3               
002F1Dr 3               
002F1Dr 3               
002F1Dr 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
002F1Dr 3               ; ## "wordsize"  auto  Tali Forth
002F1Dr 3                       ; """Given an word's name token (nt), return the size of the
002F1Dr 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
002F1Dr 3                       ; count the final RTS.
002F1Dr 3                       ; """
002F1Dr 3               xt_wordsize:
002F1Dr 3  20 rr rr                     jsr underflow_1
002F20r 3               
002F20r 3                               ; We get the start address of the word from its header entry
002F20r 3                               ; for the start of the actual code (execution token, xt)
002F20r 3                               ; which is four bytes down, and the pointer to the end of the
002F20r 3                               ; code (z_word, six bytes down)
002F20r 3  B5 00                        lda 0,x
002F22r 3  85 rr                        sta tmp1
002F24r 3  B5 01                        lda 1,x
002F26r 3  85 rr                        sta tmp1+1
002F28r 3               
002F28r 3  A0 06                        ldy #6
002F2Ar 3  B1 rr                        lda (tmp1),y    ; LSB of z
002F2Cr 3  88                           dey
002F2Dr 3  88                           dey
002F2Er 3               
002F2Er 3  38                           sec
002F2Fr 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
002F31r 3  95 00                        sta 0,x
002F33r 3               
002F33r 3  A0 07                        ldy #7
002F35r 3  B1 rr                        lda (tmp1),y    ; MSB of z
002F37r 3  88                           dey
002F38r 3  88                           dey
002F39r 3               
002F39r 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
002F3Br 3  95 01                        sta 1,x
002F3Dr 3               
002F3Dr 3  60           z_wordsize:     rts
002F3Er 3               
002F3Er 3               
002F3Er 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
002F3Er 3               ; ## "xor"  auto  ANS core
002F3Er 3                       ; """https://forth-standard.org/standard/core/XOR"""
002F3Er 3               xt_xor:
002F3Er 3  20 rr rr                     jsr underflow_2
002F41r 3               
002F41r 3  B5 00                        lda 0,x
002F43r 3  55 02                        eor 2,x
002F45r 3  95 02                        sta 2,x
002F47r 3               
002F47r 3  B5 01                        lda 1,x
002F49r 3  55 03                        eor 3,x
002F4Br 3  95 03                        sta 3,x
002F4Dr 3               
002F4Dr 3  E8                           inx
002F4Er 3  E8                           inx
002F4Fr 3               
002F4Fr 3  60           z_xor:          rts
002F50r 3               
002F50r 3               
002F50r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002F50r 3               ; ## "0"  auto  Tali Forth
002F50r 3                       ; """The disassembler assumes that this routine does not use Y. Note
002F50r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002F50r 3                       ; is 0."""
002F50r 3               xt_case:
002F50r 3               xt_forth_wordlist:
002F50r 3               xt_zero:
002F50r 3  CA                           dex             ; push
002F51r 3  CA                           dex
002F52r 3  74 00                        stz 0,x
002F54r 3  74 01                        stz 1,x
002F56r 3               z_case:
002F56r 3               z_forth_wordlist:
002F56r 3               z_zero:
002F56r 3  60                           rts
002F57r 3               
002F57r 3               
002F57r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
002F57r 3               ; ## "0="  auto  ANS core
002F57r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
002F57r 3               
002F57r 3               xt_zero_equal:
002F57r 3  20 rr rr                     jsr underflow_1
002F5Ar 3               
002F5Ar 3  B5 00                        lda 0,x
002F5Cr 3  15 01                        ora 1,x
002F5Er 3  F0 04                        beq @zero
002F60r 3               
002F60r 3                               ; not a zero, so we need a FALSE flag (0)
002F60r 3  A9 00                        lda #0
002F62r 3  80 02                        bra @store
002F64r 3               @zero:
002F64r 3                               ; We have a zero, so we need a TRUE flag (-1)
002F64r 3  A9 FF                        lda #$ff
002F66r 3               @store:
002F66r 3  95 00                        sta 0,x
002F68r 3  95 01                        sta 1,x
002F6Ar 3               
002F6Ar 3  60           z_zero_equal:   rts
002F6Br 3               
002F6Br 3               
002F6Br 3               
002F6Br 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
002F6Br 3               ; ## "0>"  auto  ANS core ext
002F6Br 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
002F6Br 3               
002F6Br 3               xt_zero_greater:
002F6Br 3  20 rr rr                     jsr underflow_1
002F6Er 3               
002F6Er 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002F70r 3               
002F70r 3  B5 01                        lda 1,x         ; MSB
002F72r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002F74r 3  15 00                        ora 0,x
002F76r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
002F78r 3               
002F78r 3  88                           dey             ; TOS is postive, make true
002F79r 3               @done:
002F79r 3  98                           tya
002F7Ar 3  95 00                        sta 0,x
002F7Cr 3  95 01                        sta 1,x
002F7Er 3               
002F7Er 3  60           z_zero_greater: rts
002F7Fr 3               
002F7Fr 3               
002F7Fr 3               
002F7Fr 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
002F7Fr 3               ; ## "0<"  auto  ANS core
002F7Fr 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
002F7Fr 3               
002F7Fr 3               xt_zero_less:
002F7Fr 3  20 rr rr                     jsr underflow_1
002F82r 3               
002F82r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002F84r 3               
002F84r 3  B5 01                        lda 1,x         ; MSB
002F86r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
002F88r 3               
002F88r 3  88                           dey             ; TOS is negative, make TRUE
002F89r 3               @done:
002F89r 3  98                           tya
002F8Ar 3  95 00                        sta 0,x
002F8Cr 3  95 01                        sta 1,x
002F8Er 3               
002F8Er 3  60           z_zero_less:    rts
002F8Fr 3               
002F8Fr 3               
002F8Fr 3               
002F8Fr 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
002F8Fr 3               ; ## "0<>"  auto  ANS core ext
002F8Fr 3                       ; """https://forth-standard.org/standard/core/Zerone"""
002F8Fr 3               
002F8Fr 3               xt_zero_unequal:
002F8Fr 3  20 rr rr                     jsr underflow_1
002F92r 3               
002F92r 3  A0 00                        ldy #0          ; default false
002F94r 3               
002F94r 3  B5 00                        lda 0,x
002F96r 3  15 01                        ora 1,x
002F98r 3  F0 01                        beq @got_zero
002F9Ar 3               
002F9Ar 3  88                           dey
002F9Br 3               @got_zero:
002F9Br 3  98                           tya
002F9Cr 3  95 00                        sta 0,x
002F9Er 3  95 01                        sta 1,x
002FA0r 3               
002FA0r 3  60           z_zero_unequal: rts
002FA1r 3               
002FA1r 3               
002FA1r 3               
002FA1r 3               ; ==========================================================
002FA1r 3               ; EDITOR words
002FA1r 3               
002FA1r 3               ; This routine is used by both enter-screen and erase-screen
002FA1r 3               ; to get a buffer for the given screen number and set SCR to
002FA1r 3               ; the given screen number.  This word is not in the dictionary.
002FA1r 3               xt_editor_screen_helper:
002FA1r 3  20 rr rr                     jsr xt_dup
002FA4r 3  20 rr rr                     jsr xt_scr
002FA7r 3  20 rr rr                     jsr xt_store
002FAAr 3  20 rr rr                     jsr xt_buffer
002FADr 3               z_editor_screen_helper:
002FADr 3  60                           rts
002FAEr 3               
002FAEr 3               
002FAEr 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
002FAEr 3               ; ## "enter-screen"  auto  Tali Editor
002FAEr 3               
002FAEr 3               xt_editor_enter_screen:
002FAEr 3                               ; Set the variable SCR and get a buffer for the
002FAEr 3                               ; given screen number.
002FAEr 3  20 rr rr                     jsr xt_editor_screen_helper
002FB1r 3               
002FB1r 3                               ; Drop the buffer address.
002FB1r 3  20 rr rr                     jsr xt_drop
002FB4r 3               
002FB4r 3                               ; Overwrite the lines one at a time.
002FB4r 3  64 rr                        stz editor1
002FB6r 3               @prompt_loop:
002FB6r 3                               ; Put the current line number on the stack.
002FB6r 3  CA                           dex
002FB7r 3  CA                           dex
002FB8r 3  A5 rr                        lda editor1
002FBAr 3  95 00                        sta 0,x
002FBCr 3  74 01                        stz 1,x
002FBEr 3               
002FBEr 3                               ; Use the O word to prompt for overwrite.
002FBEr 3  20 rr rr                     jsr xt_editor_o
002FC1r 3               
002FC1r 3                               ; Move on to the next line.
002FC1r 3  E6 rr                        inc editor1
002FC3r 3  A9 10                        lda #16
002FC5r 3  C5 rr                        cmp editor1
002FC7r 3  D0 ED                        bne @prompt_loop
002FC9r 3               
002FC9r 3               z_editor_enter_screen:
002FC9r 3  60                           rts
002FCAr 3               
002FCAr 3               
002FCAr 3               
002FCAr 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
002FCAr 3               ; ## "erase-screen"  tested  Tali Editor
002FCAr 3               xt_editor_erase_screen:
002FCAr 3                               ; Set the variable SCR and get a buffer for the
002FCAr 3                               ; given screen number.
002FCAr 3  20 rr rr                     jsr xt_editor_screen_helper
002FCDr 3               
002FCDr 3                               ; Put 1024 (chars/screen) on stack.
002FCDr 3  CA                           dex
002FCEr 3  CA                           dex
002FCFr 3  74 00                        stz 0,x
002FD1r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
002FD3r 3  95 01                        sta 1,x
002FD5r 3               
002FD5r 3                               ; Erase the entire block (fill with spaces).
002FD5r 3  20 rr rr                     jsr xt_blank
002FD8r 3               
002FD8r 3                               ; Mark buffer as updated.
002FD8r 3  20 rr rr                     jsr xt_update
002FDBr 3               
002FDBr 3               z_editor_erase_screen:
002FDBr 3  60                           rts
002FDCr 3               
002FDCr 3               
002FDCr 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
002FDCr 3               ; ## "el"  tested  Tali Editor
002FDCr 3               xt_editor_el:
002FDCr 3                               ; Turn the line number into buffer offset.
002FDCr 3                               ; This also loads the block into the buffer if it's
002FDCr 3                               ; not there for some reason.
002FDCr 3  20 rr rr                     jsr xt_editor_line
002FDFr 3               
002FDFr 3                               ; Put 64 (# of chars/line) on the stack.
002FDFr 3  CA                           dex
002FE0r 3  CA                           dex
002FE1r 3  A9 40                        lda #64
002FE3r 3  95 00                        sta 0,x
002FE5r 3  74 01                        stz 1,x
002FE7r 3               
002FE7r 3                               ; Fill with spaces.
002FE7r 3  20 rr rr                     jsr xt_blank
002FEAr 3               
002FEAr 3                               ; Mark buffer as updated.
002FEAr 3  20 rr rr                     jsr xt_update
002FEDr 3               
002FEDr 3  60           z_editor_el:    rts
002FEEr 3               
002FEEr 3               
002FEEr 3               ; ## EDITOR_L ( -- ) "List the current screen"
002FEEr 3               ; ## "l"  tested  Tali Editor
002FEEr 3               
002FEEr 3               xt_editor_l:
002FEEr 3                               ; Load the current screen
002FEEr 3  CA                           dex             ; Put SCR on the stack.
002FEFr 3  CA                           dex
002FF0r 3  A0 02                        ldy #scr_offset
002FF2r 3  B1 rr                        lda (up),y
002FF4r 3  95 00                        sta 0,x
002FF6r 3  C8                           iny
002FF7r 3  B1 rr                        lda (up),y
002FF9r 3  95 01                        sta 1,x
002FFBr 3  20 rr rr                     jsr xt_block    ; Get the current screen.
002FFEr 3               
002FFEr 3  20 rr rr                     jsr xt_cr
003001r 3               
003001r 3                               ; Print the screen number.
003001r 3                               ; We're using sliteral, so we need to set up the
003001r 3                               ; appropriate data structure (see sliteral)
003001r 3  80 08                        bra @after_screen_msg
003003r 3               
003003r 3               @screen_msg:
003003r 3  53 63 72 65                  .byte "Screen #"
003007r 3  65 6E 20 23  
00300Br 3               
00300Br 3               @after_screen_msg:
00300Br 3  20 rr rr                     jsr sliteral_runtime
00300Er 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
003012r 3               
003012r 3  20 rr rr                     jsr xt_type
003015r 3               
003015r 3                               ; Put the screen number and printed size for u.r on the stack.
003015r 3  20 rr rr                     jsr xt_scr
003018r 3  20 rr rr                     jsr xt_fetch
00301Br 3  CA                           dex
00301Cr 3  CA                           dex
00301Dr 3  A9 04                        lda #4          ; four spaces
00301Fr 3  95 00                        sta 0,x
003021r 3  74 01                        stz 1,x
003023r 3  20 rr rr                     jsr xt_u_dot_r
003026r 3               
003026r 3                               ; The address of the buffer is currently on the stack.
003026r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
003026r 3                               ; keep track of the line number in tmp3.
003026r 3  64 rr                        stz tmp3
003028r 3               
003028r 3               @line_loop:
003028r 3  20 rr rr                     jsr xt_cr
00302Br 3               
00302Br 3                               ; Print the line number (2-space fixed width)
00302Br 3  CA                           dex
00302Cr 3  CA                           dex
00302Dr 3  CA                           dex
00302Er 3  CA                           dex
00302Fr 3  74 03                        stz 3,x
003031r 3  A5 rr                        lda tmp3
003033r 3  95 02                        sta 2,x
003035r 3  74 01                        stz 1,x
003037r 3  A9 02                        lda #2
003039r 3  95 00                        sta 0,x
00303Br 3  20 rr rr                     jsr xt_u_dot_r
00303Er 3  20 rr rr                     jsr xt_space
003041r 3               
003041r 3                               ; Print one line using the address on the stack.
003041r 3  20 rr rr                     jsr xt_dup
003044r 3  CA                           dex
003045r 3  CA                           dex
003046r 3  A9 40                        lda #64
003048r 3  95 00                        sta 0,x
00304Ar 3  74 01                        stz 1,x
00304Cr 3  20 rr rr                     jsr xt_type
00304Fr 3               
00304Fr 3                               ; Add 64 to the address on the stack to move to the next line.
00304Fr 3  18                           clc
003050r 3  A9 40                        lda #64
003052r 3  75 00                        adc 0,x
003054r 3  95 00                        sta 0,x
003056r 3  B5 01                        lda 1,x
003058r 3  69 00                        adc #0      ; Add carry
00305Ar 3  95 01                        sta 1,x
00305Cr 3               
00305Cr 3                               ; Increment the line number (held in tmp3)
00305Cr 3  E6 rr                        inc tmp3
00305Er 3               
00305Er 3                               ; See if we are done.
00305Er 3  A5 rr                        lda tmp3
003060r 3  C9 10                        cmp #16
003062r 3  D0 C4                        bne @line_loop
003064r 3               
003064r 3  20 rr rr                     jsr xt_cr
003067r 3                               ; Drop the address on the stack.
003067r 3  E8                           inx
003068r 3  E8                           inx
003069r 3               
003069r 3  60           z_editor_l:            rts
00306Ar 3               
00306Ar 3               
00306Ar 3               
00306Ar 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
00306Ar 3               ; ## "line"  tested  Tali Editor
00306Ar 3               
00306Ar 3               xt_editor_line:
00306Ar 3  20 rr rr                     jsr underflow_1
00306Dr 3               
00306Dr 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
00306Dr 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
00306Fr 3               @shift_tos_left:
00306Fr 3  16 00                        asl 0,x         ; Shift TOS to the left
003071r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
003073r 3  88                           dey
003074r 3  D0 F9                        bne @shift_tos_left
003076r 3                               ; Load the current screen into a buffer
003076r 3                               ; and get the buffer address
003076r 3  20 rr rr                     jsr xt_scr
003079r 3  20 rr rr                     jsr xt_fetch
00307Cr 3  20 rr rr                     jsr xt_block
00307Fr 3               
00307Fr 3                               ; Add the offset to the buffer base address.
00307Fr 3  20 rr rr                     jsr xt_plus
003082r 3               
003082r 3  60           z_editor_line:  rts
003083r 3               
003083r 3               
003083r 3               
003083r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
003083r 3               ; ## "o"  tested  Tali Editor
003083r 3               xt_editor_o:
003083r 3                               ; Print prompt
003083r 3  20 rr rr                     jsr xt_cr
003086r 3  20 rr rr                     jsr xt_dup
003089r 3  20 rr rr                     jsr xt_two
00308Cr 3  20 rr rr                     jsr xt_u_dot_r
00308Fr 3  20 rr rr                     jsr xt_space
003092r 3  A9 2A                        lda #42         ; ASCII for *
003094r 3  20 rr rr                     jsr emit_a
003097r 3  20 rr rr                     jsr xt_space
00309Ar 3               
00309Ar 3                               ; Accept new input (directly into the buffer)
00309Ar 3  20 rr rr                     jsr xt_editor_line
00309Dr 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
0030A0r 3  CA                           dex
0030A1r 3  CA                           dex
0030A2r 3  A9 40                        lda #64         ; chars/line
0030A4r 3  95 00                        sta 0,x
0030A6r 3  74 01                        stz 1,x
0030A8r 3  20 rr rr                     jsr xt_accept
0030ABr 3               
0030ABr 3                               ; Fill the rest with spaces.
0030ABr 3                               ; Stack is currently ( line_address numchars_from_accept )
0030ABr 3  20 rr rr                     jsr xt_dup
0030AEr 3  20 rr rr                     jsr xt_not_rote ; -rot
0030B1r 3  20 rr rr                     jsr xt_plus
0030B4r 3  CA                           dex
0030B5r 3  CA                           dex
0030B6r 3  A9 40                        lda #64         ; chars/line
0030B8r 3  95 00                        sta 0,x
0030BAr 3  74 01                        stz 1,x
0030BCr 3  20 rr rr                     jsr xt_rot
0030BFr 3  20 rr rr                     jsr xt_minus
0030C2r 3  20 rr rr                     jsr xt_blank
0030C5r 3               
0030C5r 3                               ; Mark buffer as updated.
0030C5r 3  20 rr rr                     jsr xt_update
0030C8r 3               
0030C8r 3  60           z_editor_o:     rts
0030C9r 3               
0030C9r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
0030C9r 3               ; ## "lcdput" coded Custom
0030C9r 3               xt_lcdput:
0030C9r 3  20 rr rr                     jsr underflow_1
0030CCr 3               
0030CCr 3  B5 00                        lda 0,x
0030CEr 3                       .ifdef lcd_print
0030CEr 3                               jsr lcd_print
0030CEr 3                       .endif
0030CEr 3  E8                           inx
0030CFr 3  E8                           inx
0030D0r 3  60           z_lcdput: rts
0030D1r 3               
0030D1r 3               
0030D1r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
0030D1r 3               ; ## "lcdprint"  coded Custom
0030D1r 3               
0030D1r 3               xt_lcdprint:
0030D1r 3  20 rr rr                     jsr underflow_2
0030D4r 3               
0030D4r 3                               ; Save the starting address into tmp1
0030D4r 3  B5 02                        lda 2,x
0030D6r 3  85 rr                        sta tmp1
0030D8r 3  B5 03                        lda 3,x
0030DAr 3  85 rr                        sta tmp1+1
0030DCr 3               @loop:
0030DCr 3                               ; done if length is zero
0030DCr 3  B5 00                        lda 0,x
0030DEr 3  15 01                        ora 1,x
0030E0r 3  F0 12                        beq @done
0030E2r 3               
0030E2r 3                               ; Send the current character
0030E2r 3  B2 rr                        lda (tmp1)
0030E4r 3                       .ifdef lcd_print
0030E4r 3                               jsr lcd_print      ; avoids stack foolery
0030E4r 3                       .endif
0030E4r 3                               ; Move the address along (in tmp1)
0030E4r 3  E6 rr                        inc tmp1
0030E6r 3  D0 02                        bne @1
0030E8r 3  E6 rr                        inc tmp1+1
0030EAr 3               @1:
0030EAr 3                               ; Reduce the count (on the data stack)
0030EAr 3  B5 00                        lda 0,x
0030ECr 3  D0 02                        bne @2
0030EEr 3  D6 01                        dec 1,x
0030F0r 3               @2:
0030F0r 3  D6 00                        dec 0,x
0030F2r 3               
0030F2r 3  80 E8                        bra @loop
0030F4r 3               @done:
0030F4r 3  E8                           inx
0030F5r 3  E8                           inx
0030F6r 3  E8                           inx
0030F7r 3  E8                           inx
0030F8r 3               
0030F8r 3  60           z_lcdprint:         rts
0030F9r 3               
0030F9r 3               
0030F9r 3               
0030F9r 3               ; ## CLS ( -- ) "clea VGA screen"
0030F9r 3               ; ## "cls" coded Custom
0030F9r 3               xt_cls:
0030F9r 3                       .ifdef vga_clear
0030F9r 3                               jsr vga_clear
0030F9r 3                       .endif
0030F9r 3               
0030F9r 3  60           z_cls: rts
0030FAr 3               
0030FAr 3               
0030FAr 3               ; ## SPI_INIT ( -- ) "Init SPI system"
0030FAr 3               ; ## "spi_init" coded Custom
0030FAr 3               xt_spi_init:
0030FAr 3               .ifdef VIA1_BASE
0030FAr 3  20 rr rr                     jsr spi_init
0030FDr 3               .endif
0030FDr 3  60           z_spi_init: rts
0030FEr 3               
0030FEr 3               
0030FEr 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
0030FEr 3               ; ## "spi_clk_toggle" coded Custom
0030FEr 3               xt_spi_clk_toggle:
0030FEr 3               .ifdef VIA1_BASE
0030FEr 3  20 rr rr                     jsr spi_clk_toggle
003101r 3               .endif
003101r 3  60           z_spi_clk_toggle: rts
003102r 3               
003102r 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
003102r 3               ; ## "spi_select" coded Custom
003102r 3               xt_spi_select:
003102r 3               .ifdef VIA1_BASE
003102r 3  20 rr rr                     jsr underflow_1
003105r 3               
003105r 3  B5 00                        lda 0,x
003107r 3               
003107r 3  20 rr rr                     jsr spi_select
00310Ar 3               
00310Ar 3  E8                           inx
00310Br 3  E8                           inx
00310Cr 3               .endif
00310Cr 3  60           z_spi_select: rts
00310Dr 3               
00310Dr 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
00310Dr 3               ; ## "spi_transceive" coded Custom
00310Dr 3               xt_spi_transceive:
00310Dr 3               .ifdef VIA1_BASE
00310Dr 3  20 rr rr                     jsr underflow_1
003110r 3               
003110r 3  B5 00                        lda 0,x
003112r 3               
003112r 3  20 rr rr                     jsr spi_transceive
003115r 3               
003115r 3  95 00                        sta 0,x         ; put return value in TOS
003117r 3  74 01                        stz 1,X         ;reset value there
003119r 3               .endif
003119r 3  60           z_spi_transceive: rts
00311Ar 3               
00311Ar 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
00311Ar 3               ; ## "sd_init" coded Custom
00311Ar 3               xt_sd_init:
00311Ar 3               .ifdef SD
00311Ar 3  20 rr rr                     jsr underflow_1
00311Dr 3               
00311Dr 3  B5 00                        lda 0,x
00311Fr 3  20 rr rr                     jsr sd_init
003122r 3  F0 11                        beq @ok
003124r 3  48                           pha
003125r 3  DA A2 00 BD                  printascii sd_init_error_message
003129r 3  rr rr F0 06  
00312Dr 3  20 rr rr E8  
003134r 3  68                           pla
003135r 3               @ok:
003135r 3  95 00                        sta 0,x         ; put return value in TOS
003137r 3  74 01                        stz 1,X         ;reset value there
003139r 3               .endif
003139r 3  60           z_sd_init: rts
00313Ar 3               
00313Ar 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
00313Ar 3               ; ## "sd_readsector" coded Custom
00313Ar 3               xt_sd_readsector:
00313Ar 3               
00313Ar 3               .ifdef SD
00313Ar 3  20 rr rr                     jsr underflow_2
00313Dr 3                               ; get and save sector number (32 bit number, double)
00313Dr 3                               ; most significant part is TOS
00313Dr 3  B5 00                        lda 0, x
00313Fr 3  8D rr rr                     sta FAT_LBA + 2
003142r 3  B5 01                        lda 1, x
003144r 3  8D rr rr                     sta FAT_LBA + 3
003147r 3                               ; least significant part is NOS
003147r 3  B5 02                        lda 2, x
003149r 3  8D rr rr                     sta FAT_LBA + 0
00314Cr 3  B5 03                        lda 3, x
00314Er 3  8D rr rr                     sta FAT_LBA + 1
003151r 3  A9 01                        lda #1
003153r 3  8D rr rr                     sta SD_CRC
003156r 3               
003156r 3  20 rr rr                     jsr sd_readsector
003159r 3  95 00                        sta 0,x         ; put return value in TOS
00315Br 3  74 01                        stz 1,X         ;reset value there
00315Dr 3               
00315Dr 3  E8                           inx
00315Er 3  E8                           inx
00315Fr 3               .endif
00315Fr 3  60           z_sd_readsector: rts
003160r 3               
003160r 3               
003160r 3               ; ## time ( -- addr ) "get time storage address"
003160r 3               ; ## "time" coded Custom
003160r 3               xt_time:
003160r 3                       .ifdef time
003160r 3  A9 rr                lda #time
003162r 3                       .else
003162r 3                       lda #0
003162r 3                       .endif
003162r 3  CA                   dex
003163r 3  CA                   dex
003164r 3  95 00                sta 0,x
003166r 3  74 01                stz 1,x
003168r 3               
003168r 3               
003168r 3  60           z_time: rts
003169r 3               
003169r 3               xt_cf_init:
003169r 3               .ifdef CF_ADDRESS
003169r 3                       ; jsr underflow_1
003169r 3                       ; save CF card address
003169r 3                       ; lda 0, x
003169r 3                       ; sta CF_ADDRESS
003169r 3                       ; lda 1, x
003169r 3                       ; sta CF_ADDRESS + 1
003169r 3  20 rr rr             jsr cf_init
00316Cr 3                       ; inx
00316Cr 3                       ; inx
00316Cr 3               .endif
00316Cr 3               z_cf_init:
00316Cr 3  60                   rts
00316Dr 3               
00316Dr 3               ; ## fat_init ( addr -- ) "Initialize FAT16 on CF or SD card at specified address"
00316Dr 3               ; ## "fat_init" coded Custom
00316Dr 3               xt_fat_init:
00316Dr 3               .ifdef CF_ADDRESS
00316Dr 3                       ; initialize CF card
00316Dr 3  20 rr rr             jsr cf_init
003170r 3               .endif
003170r 3               .ifdef SD
003170r 3  A9 07                lda #7
003172r 3  20 rr rr             jsr sd_init
003175r 3               .endif
003175r 3  20 rr rr             jsr fat_init
003178r 3               
003178r 3  AD rr rr 20          printstr DISK_BUFFER + 43, 11
00317Cr 3  rr rr AD rr  
003180r 3  rr 20 rr rr  
0031BAr 3                       ; printascii cf_fat_mounted_message
0031BAr 3                       ; jsr xt_cr
0031BAr 3               fat_init_exit:
0031BAr 3  CA                   dex
0031BBr 3  CA                   dex
0031BCr 3  A9 rr                lda #<DISK_BUFFER
0031BEr 3  95 00                sta 0, x
0031C0r 3  A9 rr                lda #>DISK_BUFFER
0031C2r 3  95 01                sta 1, x
0031C4r 3               
0031C4r 3               z_fat_init:
0031C4r 3  60                   rts
0031C5r 3               
0031C5r 3               
0031C5r 3               ls_header:
0031C5r 3  4E 41 4D 45          .asciiz "NAME     EXT  TYPE  SIZE"
0031C9r 3  20 20 20 20  
0031CDr 3  20 45 58 54  
0031DEr 3               xt_cf_ls:
0031DEr 3               .ifdef fat_convert_filename
0031DEr 3                       ; read the current directory entry
0031DEr 3                       ; and save the contents to be displayed later
0031DEr 3               
0031DEr 3                       ; check if fat is inited
0031DEr 3  AD rr rr             lda FAT_SEC_PER_CLUS
0031E1r 3  D0 08                bne @fatok
0031E3r 3  20 rr rr             jsr xt_fat_init
0031E6r 3  E8                   inx     ; drop fat_init return value
0031E7r 3  E8                   inx
0031E8r 3  20 rr rr             jsr xt_cr
0031EBr 3               
0031EBr 3               @fatok:
0031EBr 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC, FAT_LBA
0031EFr 3  rr rr AD rr  
0031F3r 3  rr 8D rr rr  
0031F7r 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC + 2, FAT_LBA + 2
0031FBr 3  rr rr AD rr  
0031FFr 3  rr 8D rr rr  
003203r 3               
003203r 3  20 rr rr             jsr io_read_sector
003206r 3               
003206r 3                       ; current directory first sector is now in buffer
003206r 3                       ; display file names
003206r 3  20 rr rr             jsr xt_cr
003209r 3  DA A2 00 BD          printascii ls_header
00320Dr 3  rr rr F0 06  
003211r 3  20 rr rr E8  
003218r 3  20 rr rr             jsr xt_cr
00321Br 3               
00321Br 3  A9 rr                lda #<DISK_BUFFER
00321Dr 3  85 rr                sta FAT_PTR2
00321Fr 3  A9 rr                lda #>DISK_BUFFER
003221r 3  85 rr                sta FAT_PTR2 + 1
003223r 3               
003223r 3  5A                   phy
003224r 3               @outerloop:
003224r 3  A0 0B                ldy #11
003226r 3  B1 rr                lda (FAT_PTR2), y
003228r 3  C9 0F                cmp #$0F                ; ignore long filenames
00322Ar 3  F0 2A                beq @next_entry
00322Cr 3  A0 00                ldy #0
00322Er 3  B1 rr                lda (FAT_PTR2), Y
003230r 3  F0 35                beq @exit               ; if zero, it means we reached the end of the list
003232r 3  C9 E5                cmp #$E5                ; if $E5, it means the entry is deleted, so go to next entry
003234r 3  F0 20                beq @next_entry
003236r 3               @loop:
003236r 3  B1 rr                lda (FAT_PTR2), y
003238r 3  20 rr rr             jsr emit_a
00323Br 3  C8                   iny
00323Cr 3  C0 08                cpy #8
00323Er 3  D0 05                bne @check_end          ; print space after name and before extension
003240r 3  A9 20                lda #' '
003242r 3  20 rr rr             jsr emit_a
003245r 3               @check_end:
003245r 3  C0 0B                cpy #11
003247r 3  90 ED                bcc @loop
003249r 3                       ; read entry type
003249r 3  B1 rr                lda (FAT_PTR2), y
00324Br 3  20 rr rr             jsr print_entry_type
00324Er 3               
00324Er 3  20 rr rr             jsr print_entry_size
003251r 3  A9 0D                lda #$0D
003253r 3  20 rr rr             jsr emit_a
003256r 3               @next_entry:
003256r 3  18 A5 rr 6D          add16 FAT_PTR2, fat_entry_size, FAT_PTR2
00325Ar 3  rr rr 85 rr  
00325Er 3  A5 rr 6D rr  
003265r 3  80 BD                bra @outerloop
003267r 3               @exit:
003267r 3  7A                   ply
003268r 3               .endif
003268r 3               
003268r 3                       ; dex
003268r 3                       ; dex
003268r 3                       ; lda #<DISK_BUFFER
003268r 3                       ; sta 0, x
003268r 3                       ; lda #>DISK_BUFFER
003268r 3                       ; sta 1, x
003268r 3               
003268r 3               z_cf_ls:
003268r 3  60                   rts
003269r 3               .ifdef fat_convert_filename
003269r 3               print_entry_size:
003269r 3  5A                   phy
00326Ar 3               
00326Ar 3  CA                   dex
00326Br 3  CA                   dex
00326Cr 3  CA                   dex
00326Dr 3  CA                   dex
00326Er 3               
00326Er 3  A0 1C                ldy #28
003270r 3  B1 rr                lda (FAT_PTR2), y
003272r 3  95 02                sta 2,x
003274r 3  A0 1D                ldy #29
003276r 3  B1 rr                lda (FAT_PTR2), y
003278r 3  95 03                sta 3,x
00327Ar 3               
00327Ar 3  A0 1E                ldy #30
00327Cr 3  B1 rr                lda (FAT_PTR2), y
00327Er 3  95 00                sta 0,x
003280r 3               
003280r 3  A0 1F                ldy #31
003282r 3  B1 rr                lda (FAT_PTR2), y
003284r 3  95 01                sta 1,x
003286r 3  20 rr rr             jsr xt_ud_dot
003289r 3  7A                   ply
00328Ar 3  60                   rts
00328Br 3               
00328Br 3               print_entry_type:
00328Br 3  29 10                and #$10
00328Dr 3  D0 02                bne @is_dir
00328Fr 3  80 11                bra @is_file
003291r 3               @is_dir:
003291r 3  DA A2 00 BD          printascii entry_type_dir
003295r 3  rr rr F0 06  
003299r 3  20 rr rr E8  
0032A0r 3  80 0F                bra @exit
0032A2r 3               @is_file:
0032A2r 3  DA A2 00 BD          printascii entry_type_file
0032A6r 3  rr rr F0 06  
0032AAr 3  20 rr rr E8  
0032B1r 3               @exit:
0032B1r 3  60                   rts
0032B2r 3               
0032B2r 3  20 20 20 44  entry_type_dir: .asciiz "   D    "
0032B6r 3  20 20 20 20  
0032BAr 3  00           
0032BBr 3  20 20 20 46  entry_type_file: .asciiz "   F    "
0032BFr 3  20 20 20 20  
0032C3r 3  00           
0032C4r 3               .endif
0032C4r 3               xt_cf_info:
0032C4r 3               .ifdef CF_ADDRESS
0032C4r 3  20 rr rr             jsr cf_init
0032C7r 3  20 rr rr             jsr cf_wait
0032CAr 3  A9 EC                lda #$EC
0032CCr 3  8D A7 FF             sta CF_ADDRESS + 7
0032CFr 3  CA                   dex
0032D0r 3  CA                   dex
0032D1r 3  A9 rr                lda #<DISK_BUFFER
0032D3r 3  95 00                sta 0, x
0032D5r 3  A9 rr                lda #>DISK_BUFFER
0032D7r 3  95 01                sta 1, x
0032D9r 3  20 rr rr             jsr cf_read
0032DCr 3               
0032DCr 3               .endif
0032DCr 3               z_cf_info:
0032DCr 3  60                   rts
0032DDr 3               
0032DDr 3               xt_cf_cd:
0032DDr 3               .ifdef fat_convert_filename
0032DDr 3  5A                   phy
0032DEr 3                       ; check if fat is inited
0032DEr 3  AD rr rr     	lda FAT_SEC_PER_CLUS
0032E1r 3  D0 05        	bne @fatok
0032E3r 3  20 rr rr     	jsr xt_fat_init
0032E6r 3  E8           	inx     ; drop fat_init return value
0032E7r 3  E8           	inx
0032E8r 3               @fatok:
0032E8r 3  B5 00                lda 0, x
0032EAr 3  85 rr                sta FAT_PTR1
0032ECr 3  B5 01                lda 1, x
0032EEr 3  85 rr                sta FAT_PTR1 + 1
0032F0r 3  B5 02                lda 2, x
0032F2r 3  85 rr                sta FAT_PTR2
0032F4r 3  B5 03                lda 3, x
0032F6r 3  85 rr                sta FAT_PTR2+1
0032F8r 3               
0032F8r 3  20 rr rr             jsr fat_convert_filename
0032FBr 3               
0032FBr 3  20 rr rr             jsr fat_find_file               ; after this, the pointer to the entry in DISK_BUFFER is in FAT_PTR1
0032FEr 3  B0 5F                bcs @found
003300r 3  E8                   inx
003301r 3  E8                   inx
003302r 3  E8                   inx
003303r 3  E8                   inx
003304r 3  20 rr rr             jsr xt_cr
003307r 3  AD rr rr 20          printstr FAT_FILE_NAME_TMP, 11
00330Br 3  rr rr AD rr  
00330Fr 3  rr 20 rr rr  
003349r 3  DA A2 00 BD          printascii not_found_error        ; directory not found, abort
00334Dr 3  rr rr F0 06  
003351r 3  20 rr rr E8  
003358r 3  20 rr rr             jsr xt_cr
00335Br 3  7A                   ply
00335Cr 3  20 rr rr             jsr xt_abort
00335Fr 3               @found:
00335Fr 3                       ; check if entry is a directory
00335Fr 3  A0 0B                ldy #11
003361r 3  B1 rr                lda (FAT_PTR1), y
003363r 3  29 10                and #$10
003365r 3  D0 1D                bne @is_dir
003367r 3  20 rr rr             jsr xt_cr
00336Ar 3  DA A2 00 BD          printascii not_dir_error        ; Not a directory, abort
00336Er 3  rr rr F0 06  
003372r 3  20 rr rr E8  
003379r 3  E8                   inx
00337Ar 3  E8                   inx
00337Br 3  E8                   inx
00337Cr 3  E8                   inx
00337Dr 3  7A                   ply
00337Er 3  20 rr rr             jsr xt_cr
003381r 3  20 rr rr             jsr xt_abort
003384r 3               @is_dir:
003384r 3                       ; load cluster number from dir entry
003384r 3  A0 1A                ldy #26
003386r 3  B1 rr                lda (FAT_PTR1), y
003388r 3  8D rr rr             sta FAT_CURRENT_CLUSTER
00338Br 3  C8                   iny
00338Cr 3  B1 rr                lda (FAT_PTR1), y
00338Er 3  8D rr rr             sta FAT_CURRENT_CLUSTER + 1
003391r 3                       ; convert cluster number to sector
003391r 3  20 rr rr             jsr fat_get_sector_for_cluster
003394r 3                       ; save sector number to CF_CURRENT_DIR_SEC
003394r 3               
003394r 3  E8                   inx
003395r 3  E8                   inx
003396r 3  E8                   inx
003397r 3  E8                   inx
003398r 3  7A                   ply
003399r 3               .endif
003399r 3               z_cf_cd:
003399r 3               
003399r 3  60                   rts
00339Ar 3               .ifdef fat_convert_filename
00339Ar 3  4E 6F 74 20  not_dir_error: .asciiz "Not a directory"
00339Er 3  61 20 64 69  
0033A2r 3  72 65 63 74  
0033AAr 3  20 6E 6F 74  not_found_error: .asciiz " not found"
0033AEr 3  20 66 6F 75  
0033B2r 3  6E 64 00     
0033B5r 3               .endif
0033B5r 3               
0033B5r 3               
0033B5r 3               xt_cf_cat:
0033B5r 3               .ifdef fat_convert_filename
0033B5r 3  5A                   phy
0033B6r 3                       ; check if fat is inited
0033B6r 3  AD rr rr     	lda FAT_SEC_PER_CLUS
0033B9r 3  D0 05        	bne @fatok
0033BBr 3  20 rr rr     	jsr xt_fat_init
0033BEr 3  E8           	inx     ; drop fat_init return value
0033BFr 3  E8           	inx
0033C0r 3               @fatok:
0033C0r 3  B5 00                lda 0, x
0033C2r 3  85 rr                sta FAT_PTR1
0033C4r 3  B5 01                lda 1, x
0033C6r 3  85 rr                sta FAT_PTR1 + 1
0033C8r 3  B5 02                lda 2, x
0033CAr 3  85 rr                sta FAT_PTR2
0033CCr 3  B5 03                lda 3, x
0033CEr 3  85 rr                sta FAT_PTR2+1
0033D0r 3               
0033D0r 3  20 rr rr             jsr fat_convert_filename
0033D3r 3               
0033D3r 3  20 rr rr             jsr fat_find_file               ; after this, the pointer to the entry in DISK_BUFFER is in FAT_PTR1
0033D6r 3  B0 5E                bcs @found
0033D8r 3  E8                   inx
0033D9r 3  E8                   inx
0033DAr 3  E8                   inx
0033DBr 3  E8                   inx
0033DCr 3  20 rr rr             jsr xt_cr
0033DFr 3  AD rr rr 20          printstr FAT_FILE_NAME_TMP, 11
0033E3r 3  rr rr AD rr  
0033E7r 3  rr 20 rr rr  
003421r 3  DA A2 00 BD          printascii not_found_error        ; Not a directory, abort
003425r 3  rr rr F0 06  
003429r 3  20 rr rr E8  
003430r 3  20 rr rr             jsr xt_cr
003433r 3  20 rr rr             jsr xt_abort
003436r 3               @found:
003436r 3                       ; check if entry is a directory
003436r 3  A0 0B                ldy #11
003438r 3  B1 rr                lda (FAT_PTR1), y
00343Ar 3  29 10                and #$10
00343Cr 3  F0 1C                beq @is_file
00343Er 3  20 rr rr             jsr xt_cr
003441r 3  DA A2 00 BD          printascii not_file_error        ; Not a directory, abort
003445r 3  rr rr F0 06  
003449r 3  20 rr rr E8  
003450r 3  E8                   inx
003451r 3  E8                   inx
003452r 3  E8                   inx
003453r 3  E8                   inx
003454r 3  20 rr rr             jsr xt_cr
003457r 3  20 rr rr             jsr xt_abort
00345Ar 3               @is_file:
00345Ar 3                       ; load cluster number from dir entry
00345Ar 3  A0 1A                ldy #26
00345Cr 3  B1 rr                lda (FAT_PTR1), y
00345Er 3  8D rr rr             sta FAT_CURRENT_CLUSTER
003461r 3  C8                   iny
003462r 3  B1 rr                lda (FAT_PTR1), y
003464r 3  8D rr rr             sta FAT_CURRENT_CLUSTER + 1
003467r 3  C8                   iny
003468r 3  B1 rr                lda (FAT_PTR1), y
00346Ar 3  8D rr rr             sta FAT_CURRENT_FILE_SIZE
00346Dr 3  C8                   iny
00346Er 3  B1 rr                lda (FAT_PTR1), y
003470r 3  8D rr rr             sta FAT_CURRENT_FILE_SIZE + 1
003473r 3  C8                   iny
003474r 3  B1 rr                lda (FAT_PTR1), y
003476r 3  8D rr rr             sta FAT_CURRENT_FILE_SIZE + 2
003479r 3  C8                   iny
00347Ar 3  B1 rr                lda (FAT_PTR1), y
00347Cr 3  8D rr rr             sta FAT_CURRENT_FILE_SIZE + 3
00347Fr 3                       ; convert cluster number to sector
00347Fr 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC, FAT_TMP
003483r 3  rr rr AD rr  
003487r 3  rr 8D rr rr  
00348Br 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC + 2, FAT_TMP + 2
00348Fr 3  rr rr AD rr  
003493r 3  rr 8D rr rr  
003497r 3  20 rr rr             jsr fat_get_sector_for_cluster
00349Ar 3                       ; save sector number to CF_LBA
00349Ar 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC, FAT_LBA
00349Er 3  rr rr AD rr  
0034A2r 3  rr 8D rr rr  
0034A6r 3  AD rr rr 8D          cp16 FAT_CURRENT_DIR_SEC + 2, FAT_LBA + 2
0034AAr 3  rr rr AD rr  
0034AEr 3  rr 8D rr rr  
0034B2r 3  AD rr rr 8D          cp16 FAT_TMP, FAT_CURRENT_DIR_SEC
0034B6r 3  rr rr AD rr  
0034BAr 3  rr 8D rr rr  
0034BEr 3  AD rr rr 8D          cp16 FAT_TMP + 2, FAT_CURRENT_DIR_SEC + 2
0034C2r 3  rr rr AD rr  
0034C6r 3  rr 8D rr rr  
0034CAr 3               
0034CAr 3                       ; file sector number is in CF_CURRENT_FILE_SEC
0034CAr 3               @read_next_file_sector:
0034CAr 3  20 rr rr             jsr io_read_sector
0034CDr 3  20 rr rr             jsr xt_cr
0034D0r 3  20 rr rr             jsr output_sector
0034D3r 3               
0034D3r 3                       ; jsr reduce_filesize_by_one_sector
0034D3r 3               
0034D3r 3                       ; ; check if filesize is zero
0034D3r 3                       ; lda CF_CURRENT_FILE_SIZE + 3
0034D3r 3                       ; bne @read_next_file_sector
0034D3r 3                       ; lda CF_CURRENT_FILE_SIZE + 2
0034D3r 3                       ; bne @read_next_file_sector
0034D3r 3                       ; lda CF_CURRENT_FILE_SIZE + 1
0034D3r 3                       ; bne @read_next_file_sector
0034D3r 3               
0034D3r 3                       ; lda CF_CURRENT_FILE_SIZE
0034D3r 3                       ; bne @read_next_file_sector
0034D3r 3               
0034D3r 3               
0034D3r 3  E8                   inx
0034D4r 3  E8                   inx
0034D5r 3  E8                   inx
0034D6r 3  E8                   inx
0034D7r 3                       ; lda #<CF_CURRENT_FILE_SIZE
0034D7r 3                       ; sta 0, x
0034D7r 3                       ; lda #>CF_CURRENT_FILE_SIZE
0034D7r 3                       ; sta 1, x
0034D7r 3               
0034D7r 3  7A                   ply
0034D8r 3               .endif
0034D8r 3               z_cf_cat:
0034D8r 3  60                   rts
0034D9r 3               
0034D9r 3               .ifdef fat_convert_filename
0034D9r 3  4E 6F 74 20  not_file_error: .asciiz "Not a file"
0034DDr 3  61 20 66 69  
0034E1r 3  6C 65 00     
0034E4r 3               .endif
0034E4r 3               
0034E4r 3               ; ## cf_readsector ( double -- addr ) "Set LBA block and read to buffer"
0034E4r 3               ; ## "cf_readsector" coded Custom
0034E4r 3               xt_cf_readsector:
0034E4r 3               .ifdef CF_ADDRESS
0034E4r 3  20 rr rr             jsr underflow_2
0034E7r 3                       ; most significant part is TOS
0034E7r 3  B5 00                lda 0, x
0034E9r 3  8D rr rr             sta FAT_LBA + 2
0034ECr 3  B5 01                lda 1, x
0034EEr 3  8D rr rr             sta FAT_LBA + 3
0034F1r 3                       ; least significant part is NOS
0034F1r 3  B5 02                lda 2, x
0034F3r 3  8D rr rr             sta FAT_LBA + 0
0034F6r 3  B5 03                lda 3, x
0034F8r 3  8D rr rr             sta FAT_LBA + 1
0034FBr 3                       ; LBA is set, now read sector
0034FBr 3  20 rr rr             jsr cf_init
0034FEr 3               
0034FEr 3  20 rr rr             jsr cf_read_sector
003501r 3               
003501r 3                       ; return buffer address
003501r 3  E8                   inx
003502r 3  E8                   inx
003503r 3  A9 rr                lda #<DISK_BUFFER
003505r 3  95 00                sta 0, x
003507r 3               
003507r 3  A9 rr                lda #>DISK_BUFFER
003509r 3               
003509r 3  95 01                sta 1, x
00350Br 3               .endif
00350Br 3               z_cf_readsector:
00350Br 3  60                   rts
00350Cr 3               
00350Cr 3               xt_cf_rsptr:
00350Cr 3               .ifdef CF_ADDRESS
00350Cr 3  CA                   dex
00350Dr 3  CA                   dex
00350Er 3  A9 rr                lda #<cf_read_sector
003510r 3  95 00                sta 0, x
003512r 3  A9 rr                lda #>cf_read_sector
003514r 3  95 01                sta 1, x
003516r 3                       .endif
003516r 3               z_cf_rsptr:
003516r 3  60                   rts
003517r 3               
003517r 3               xt_sd_rsptr:
003517r 3               .ifdef SD
003517r 3  CA                   dex
003518r 3  CA                   dex
003519r 3  A9 rr                lda #<sd_readsector
00351Br 3  95 00                sta 0, x
00351Dr 3  A9 rr                lda #>sd_readsector
00351Fr 3  95 01                sta 1, x
003521r 3               .endif
003521r 3               z_sd_rsptr:
003521r 3  60                   rts
003522r 3               
003522r 3               xt_io_readsector:
003522r 3  CA                   dex
003523r 3  CA                   dex
003524r 3  A9 rr                lda #<io_read_sector_ptr
003526r 3  95 00                sta 0, x
003528r 3  A9 rr                lda #>io_read_sector_ptr
00352Ar 3  95 01                sta 1, x
00352Cr 3               z_io_readsector:
00352Cr 3  60                   rts
00352Dr 3               
00352Dr 3               ; END
00352Dr 3               
00352Dr 3               
00352Dr 2                   .include "headers.s"          ; Headers of native words
00352Dr 3               ; Dictionary Headers for Tali Forth 2
00352Dr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00352Dr 3               ; First version: 05. Dec 2016 (Liara Forth)
00352Dr 3               ; This version: 29. Dec 2018
00352Dr 3               
00352Dr 3               ; Dictionary headers are kept separately from the code, which allows various
00352Dr 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
00352Dr 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
00352Dr 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
00352Dr 3               ; header in the Dictionary. There the link to the next word in the Dictionary
00352Dr 3               ; is always one cell down from the current word's own nt. In the code itself,
00352Dr 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
00352Dr 3               
00352Dr 3               ; This gives us the following header structure:
00352Dr 3               
00352Dr 3               ;              8 bit     8 bit
00352Dr 3               ;               LSB       MSB
00352Dr 3               ; nt_word ->  +--------+--------+
00352Dr 3               ;          +0 | Length | Status |
00352Dr 3               ;             +--------+--------+
00352Dr 3               ;          +2 | Next Header     | -> nt_next_word
00352Dr 3               ;             +-----------------+
00352Dr 3               ;          +4 | Start of Code   | -> xt_word
00352Dr 3               ;             +-----------------+
00352Dr 3               ;          +6 | End of Code     | -> z_word
00352Dr 3               ;             +--------+--------+
00352Dr 3               ;          +8 | Name   |        |
00352Dr 3               ;             +--------+--------+
00352Dr 3               ;             |        |        |
00352Dr 3               ;             +--------+--------+
00352Dr 3               ;             |        |  ...   | (name string does not end with a zero)
00352Dr 3               ;          +n +--------+--------+
00352Dr 3               
00352Dr 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
00352Dr 3               ; which are:
00352Dr 3               
00352Dr 3               ;       CO - Compile Only
00352Dr 3               ;       IM - Immediate Word
00352Dr 3               ;       NN - Never Native Compile (must always be called by JSR)
00352Dr 3               ;       AN - Always Native Compile (may not be called by JSR)
00352Dr 3               ;       UF - Contains underflow check
00352Dr 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
00352Dr 3               
00352Dr 3               ; Note there are currently two bits unused.
00352Dr 3               
00352Dr 3               ; By default, all existing words can be natively compiled (compiled inline) or
00352Dr 3               ; as a subroutine jump target; the system decides which variant to use based on
00352Dr 3               ; a threshold the user can set. By default, all user-created words are flagged
00352Dr 3               ; never-native. The user can override this by using the always-native word
00352Dr 3               ; just after defining their new word.  The NN flag forbids native compiling,
00352Dr 3               ; the AN flag forces it.
00352Dr 3               
00352Dr 3               ; The last word (top word in code) is always BYE. It is marked as the last word
00352Dr 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
00352Dr 3               ; more common ones first (further down in code) so they are found earlier.
00352Dr 3               ; Anything to do with output comes later (further up) because things will
00352Dr 3               ; always be slow if there is a human involved.
00352Dr 3               
00352Dr 3               ; The initial skeleton of this list was automatically generated by a script
00352Dr 3               ; in the tools folder and then sorted by hand.
00352Dr 3               
00352Dr 3               nt_bye:
00352Dr 3  03                   .byte 3         ; length of word strings
00352Er 3  00                   .byte 0         ; status byte
00352Fr 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
003531r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
003533r 3  rr rr                .word z_bye     ; end of code (RTS)
003535r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
003538r 3               
003538r 3               
003538r 3               nt_cold:
003538r 3  04 00                .byte 4, 0
00353Ar 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
00353Er 3  rr rr        
003540r 3  63 6F 6C 64          .byte "cold"
003544r 3               
003544r 3               nt_lcdput:
003544r 3  06 10                .byte 6, UF
003546r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
00354Ar 3  rr rr        
00354Cr 3  6C 63 64 70          .byte "lcdput"
003550r 3  75 74        
003552r 3               
003552r 3               nt_lcdprint:
003552r 3  08 10                .byte 8, UF
003554r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
003558r 3  rr rr        
00355Ar 3  6C 63 64 70          .byte "lcdprint"
00355Er 3  72 69 6E 74  
003562r 3               
003562r 3               nt_cls:
003562r 3  03 00                .byte 3, 0
003564r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
003568r 3  rr rr        
00356Ar 3  63 6C 73             .byte "cls"
00356Dr 3               
00356Dr 3               .ifdef VIA1_BASE
00356Dr 3               nt_spi_init:
00356Dr 3  08 00                .byte 8, 0
00356Fr 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
003573r 3  rr rr        
003575r 3  73 70 69 5F          .byte "spi_init"
003579r 3  69 6E 69 74  
00357Dr 3               
00357Dr 3               
00357Dr 3               nt_spi_clk_toggle:
00357Dr 3  0E 00                .byte 14, 0
00357Fr 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
003583r 3  rr rr        
003585r 3  73 70 69 5F          .byte "spi_clk_toggle"
003589r 3  63 6C 6B 5F  
00358Dr 3  74 6F 67 67  
003593r 3               
003593r 3               nt_spi_select:
003593r 3  0A 00                .byte 10, 0
003595r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
003599r 3  rr rr        
00359Br 3  73 70 69 5F          .byte "spi_select"
00359Fr 3  73 65 6C 65  
0035A3r 3  63 74        
0035A5r 3               
0035A5r 3               nt_spi_transceive:
0035A5r 3  0E 00                .byte 14, 0
0035A7r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
0035ABr 3  rr rr        
0035ADr 3  73 70 69 5F          .byte "spi_transceive"
0035B1r 3  74 72 61 6E  
0035B5r 3  73 63 65 69  
0035BBr 3               .endif
0035BBr 3               .ifdef SD
0035BBr 3               nt_sd_init:
0035BBr 3  07 00                .byte 7, 0
0035BDr 3                       .ifdef VIA1_BASE
0035BDr 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
0035C1r 3  rr rr        
0035C3r 3                       .else
0035C3r 3                       .word nt_cls, xt_sd_init, z_sd_init
0035C3r 3                       .endif
0035C3r 3  73 64 5F 69          .byte "sd_init"
0035C7r 3  6E 69 74     
0035CAr 3               nt_sd_rsptr:
0035CAr 3  07 00                .byte 7, 0
0035CCr 3  rr rr rr rr          .word nt_sd_init, xt_sd_rsptr, z_sd_rsptr
0035D0r 3  rr rr        
0035D2r 3  73 64 72 73          .byte "sdrsptr"
0035D6r 3  70 74 72     
0035D9r 3               nt_sd_readsector:
0035D9r 3  0D 00                .byte 13, 0
0035DBr 3  rr rr rr rr          .word nt_sd_rsptr, xt_sd_readsector, z_sd_readsector
0035DFr 3  rr rr        
0035E1r 3  73 64 5F 72          .byte "sd_readsector"
0035E5r 3  65 61 64 73  
0035E9r 3  65 63 74 6F  
0035EEr 3               
0035EEr 3               .endif
0035EEr 3               
0035EEr 3               .ifdef CF_ADDRESS
0035EEr 3               nt_cf_rs:
0035EEr 3  02 00                .byte 2, 0
0035F0r 3                       .ifdef SD
0035F0r 3  rr rr rr rr          .word nt_sd_readsector, xt_cf_readsector, z_cf_readsector
0035F4r 3  rr rr        
0035F6r 3                       .elseif .def(VIA1_BASE)
0035F6r 3                       .word nt_spi_transceive, xt_cf_readsector, z_cf_readsector
0035F6r 3                       .else
0035F6r 3                       .word nt_cls, xt_cf_readsector, z_cf_readsector
0035F6r 3                       .endif
0035F6r 3  72 73                .byte "rs"
0035F8r 3               
0035F8r 3               
0035F8r 3               nt_cf_info:
0035F8r 3  04 00                .byte 4, 0
0035FAr 3  rr rr rr rr          .word nt_cf_rs, xt_cf_info, z_cf_info
0035FEr 3  rr rr        
003600r 3  69 6E 66 6F          .byte "info"
003604r 3               nt_cf_ls:
003604r 3  02 00                .byte 2, 0
003606r 3  rr rr rr rr          .word nt_cf_info, xt_cf_ls, z_cf_ls
00360Ar 3  rr rr        
00360Cr 3  6C 73                .byte "ls"
00360Er 3               
00360Er 3               nt_cf_cd:
00360Er 3  02 00                .byte 2, 0
003610r 3  rr rr rr rr          .word nt_cf_ls, xt_cf_cd, z_cf_cd
003614r 3  rr rr        
003616r 3  63 64                .byte "cd"
003618r 3               
003618r 3               nt_cf_rsptr:
003618r 3  07 00                .byte 7, 0
00361Ar 3  rr rr rr rr          .word nt_cf_cd, xt_cf_rsptr, z_cf_rsptr
00361Er 3  rr rr        
003620r 3  63 66 72 73          .byte "cfrsptr"
003624r 3  70 74 72     
003627r 3               
003627r 3               nt_cf_cat:
003627r 3  03 00                .byte 3, 0
003629r 3  rr rr rr rr          .word nt_cf_rsptr, xt_cf_cat, z_cf_cat
00362Dr 3  rr rr        
00362Fr 3  63 61 74             .byte "cat"
003632r 3               .endif
003632r 3               
003632r 3               nt_fat_init:
003632r 3  03 00                .byte 3, 0
003634r 3                       .ifdef CF_ADDRESS
003634r 3  rr rr rr rr          .word nt_cf_cat, xt_fat_init, z_fat_init
003638r 3  rr rr        
00363Ar 3                       .elseif .def(SD)
00363Ar 3                       .word nt_sd_readsector, xt_fat_init, z_fat_init
00363Ar 3                       .elseif .def(VIA1_BASE)
00363Ar 3                       .word nt_spi_transceive, xt_fat_init, z_fat_init
00363Ar 3                       .else
00363Ar 3                       .word nt_cls, xt_fat_init, z_fat_init
00363Ar 3                       .endif
00363Ar 3  66 61 74             .byte "fat"
00363Dr 3               
00363Dr 3               nt_rsptr:
00363Dr 3  05 00                .byte 5, 0
00363Fr 3  rr rr rr rr          .word nt_fat_init, xt_io_readsector, z_io_readsector
003643r 3  rr rr        
003645r 3  72 73 70 74          .byte "rsptr"
003649r 3  72           
00364Ar 3               
00364Ar 3               nt_time:
00364Ar 3  04 00                .byte 4, 0
00364Cr 3  rr rr rr rr          .word nt_rsptr, xt_time, z_time
003650r 3  rr rr        
003652r 3  74 69 6D 65          .byte "time"
003656r 3               
003656r 3               nt_ed:                  ; ed6502
003656r 3  02 08                .byte 2, NN
003658r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
00365Cr 3  rr rr        
00365Er 3  65 64                .byte "ed"
003660r 3               
003660r 3  03 08        nt_see: .byte 3, NN
003662r 3  rr rr rr rr          .word nt_ed, xt_see, z_see
003666r 3  rr rr        
003668r 3  73 65 65             .byte "see"
00366Br 3               
00366Br 3               nt_forth:
00366Br 3  05 00                .byte 5, 0
00366Dr 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
003671r 3  rr rr        
003673r 3  66 6F 72 74          .byte "forth"
003677r 3  68           
003678r 3               
003678r 3               nt_order:
003678r 3  05 00                .byte 5, 0
00367Ar 3  rr rr rr rr          .word nt_forth, xt_order, z_order
00367Er 3  rr rr        
003680r 3  6F 72 64 65          .byte "order"
003684r 3  72           
003685r 3               
003685r 3               nt_to_order:
003685r 3  06 00                .byte 6, 0
003687r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
00368Br 3  rr rr        
00368Dr 3  3E 6F 72 64          .byte ">order"
003691r 3  65 72        
003693r 3               
003693r 3               nt_previous:
003693r 3  08 00                .byte 8, 0
003695r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
003699r 3  rr rr        
00369Br 3  70 72 65 76          .byte "previous"
00369Fr 3  69 6F 75 73  
0036A3r 3               
0036A3r 3               nt_also:
0036A3r 3  04 00                .byte 4, 0
0036A5r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
0036A9r 3  rr rr        
0036ABr 3  61 6C 73 6F          .byte "also"
0036AFr 3               
0036AFr 3               nt_only:
0036AFr 3  04 00                .byte 4, 0
0036B1r 3  rr rr rr rr          .word nt_also, xt_only, z_only
0036B5r 3  rr rr        
0036B7r 3  6F 6E 6C 79          .byte "only"
0036BBr 3               
0036BBr 3               nt_forth_wordlist:      ; shares code with ZERO
0036BBr 3  0E 00                .byte 14, 0
0036BDr 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
0036C1r 3  rr rr        
0036C3r 3  66 6F 72 74          .byte "forth-wordlist"
0036C7r 3  68 2D 77 6F  
0036CBr 3  72 64 6C 69  
0036D1r 3               
0036D1r 3               nt_editor_wordlist:     ; shares code with ONE
0036D1r 3  0F 00                .byte 15, 0
0036D3r 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
0036D7r 3  rr rr        
0036D9r 3  65 64 69 74          .byte "editor-wordlist"
0036DDr 3  6F 72 2D 77  
0036E1r 3  6F 72 64 6C  
0036E8r 3               
0036E8r 3               nt_assembler_wordlist:  ; shares code with TWO
0036E8r 3  12 00                .byte 18, 0
0036EAr 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
0036EEr 3  rr rr        
0036F0r 3  61 73 73 65          .byte "assembler-wordlist"
0036F4r 3  6D 62 6C 65  
0036F8r 3  72 2D 77 6F  
003702r 3               
003702r 3               nt_root_wordlist:
003702r 3  0D 00                .byte 13, 0
003704r 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
003708r 3  rr rr        
00370Ar 3  72 6F 6F 74          .byte "root-wordlist"
00370Er 3  2D 77 6F 72  
003712r 3  64 6C 69 73  
003717r 3               
003717r 3               nt_get_order:
003717r 3  09 00                .byte 9, 0
003719r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
00371Dr 3  rr rr        
00371Fr 3  67 65 74 2D          .byte "get-order"
003723r 3  6F 72 64 65  
003727r 3  72           
003728r 3               
003728r 3               nt_set_order:
003728r 3  09 00                .byte 9, 0
00372Ar 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
00372Er 3  rr rr        
003730r 3  73 65 74 2D          .byte "set-order"
003734r 3  6F 72 64 65  
003738r 3  72           
003739r 3               
003739r 3               nt_get_current:
003739r 3  0B 00                .byte 11, 0
00373Br 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
00373Fr 3  rr rr        
003741r 3  67 65 74 2D          .byte "get-current"
003745r 3  63 75 72 72  
003749r 3  65 6E 74     
00374Cr 3               
00374Cr 3               nt_set_current:
00374Cr 3  0B 10                .byte 11, UF
00374Er 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
003752r 3  rr rr        
003754r 3  73 65 74 2D          .byte "set-current"
003758r 3  63 75 72 72  
00375Cr 3  65 6E 74     
00375Fr 3               
00375Fr 3               nt_search_wordlist:
00375Fr 3  0F 10                .byte 15, UF
003761r 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
003765r 3  rr rr        
003767r 3  73 65 61 72          .byte "search-wordlist"
00376Br 3  63 68 2D 77  
00376Fr 3  6F 72 64 6C  
003776r 3               
003776r 3               nt_wordlist:
003776r 3  08 00                .byte 8, 0
003778r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
00377Cr 3  rr rr        
00377Er 3  77 6F 72 64          .byte "wordlist"
003782r 3  6C 69 73 74  
003786r 3               
003786r 3               nt_definitions:
003786r 3  0B 00                .byte 11, 0
003788r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
00378Cr 3  rr rr        
00378Er 3  64 65 66 69          .byte "definitions"
003792r 3  6E 69 74 69  
003796r 3  6F 6E 73     
003799r 3               
003799r 3               nt_block_ramdrive_init:
003799r 3  13 10                .byte 19, UF
00379Br 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
00379Fr 3  rr rr        
0037A1r 3  62 6C 6F 63          .byte "block-ramdrive-init"
0037A5r 3  6B 2D 72 61  
0037A9r 3  6D 64 72 69  
0037B4r 3               
0037B4r 3               nt_list:
0037B4r 3  04 10                .byte 4, UF
0037B6r 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
0037BAr 3  rr rr        
0037BCr 3  6C 69 73 74          .byte "list"
0037C0r 3               
0037C0r 3               nt_thru:
0037C0r 3  04 10                .byte 4, UF
0037C2r 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
0037C6r 3  rr rr        
0037C8r 3  74 68 72 75          .byte "thru"
0037CCr 3               
0037CCr 3               nt_load:
0037CCr 3  04 10                .byte 4, UF
0037CEr 3  rr rr rr rr          .word nt_thru, xt_load, z_load
0037D2r 3  rr rr        
0037D4r 3  6C 6F 61 64          .byte "load"
0037D8r 3               
0037D8r 3               nt_flush:
0037D8r 3  05 00                .byte 5, 0
0037DAr 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
0037DEr 3  rr rr        
0037E0r 3  66 6C 75 73          .byte "flush"
0037E4r 3  68           
0037E5r 3               
0037E5r 3               nt_empty_buffers:
0037E5r 3  0D 00                .byte 13, 0
0037E7r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
0037EBr 3  rr rr        
0037EDr 3  65 6D 70 74          .byte "empty-buffers"
0037F1r 3  79 2D 62 75  
0037F5r 3  66 66 65 72  
0037FAr 3               
0037FAr 3               nt_buffer:
0037FAr 3  06 00                .byte 6, 0
0037FCr 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
003800r 3  rr rr        
003802r 3  62 75 66 66          .byte "buffer"
003806r 3  65 72        
003808r 3               
003808r 3               nt_update:
003808r 3  06 00                .byte 6, 0
00380Ar 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
00380Er 3  rr rr        
003810r 3  75 70 64 61          .byte "update"
003814r 3  74 65        
003816r 3               
003816r 3               nt_block:
003816r 3  05 00                .byte 5, 0
003818r 3  rr rr rr rr          .word nt_update, xt_block, z_block
00381Cr 3  rr rr        
00381Er 3  62 6C 6F 63          .byte "block"
003822r 3  6B           
003823r 3               
003823r 3               nt_save_buffers:
003823r 3  0C 00                .byte 12, 0
003825r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
003829r 3  rr rr        
00382Br 3  73 61 76 65          .byte "save-buffers"
00382Fr 3  2D 62 75 66  
003833r 3  66 65 72 73  
003837r 3               
003837r 3               nt_block_read_vector:
003837r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
003839r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
00383Dr 3  rr rr        
00383Fr 3  62 6C 6F 63          .byte "block-read-vector"
003843r 3  6B 2D 72 65  
003847r 3  61 64 2D 76  
003850r 3               
003850r 3               nt_block_read:
003850r 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
003852r 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
003856r 3  rr rr        
003858r 3  62 6C 6F 63          .byte "block-read"
00385Cr 3  6B 2D 72 65  
003860r 3  61 64        
003862r 3               
003862r 3               nt_block_write_vector:
003862r 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
003864r 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
003868r 3  rr rr        
00386Ar 3  62 6C 6F 63          .byte "block-write-vector"
00386Er 3  6B 2D 77 72  
003872r 3  69 74 65 2D  
00387Cr 3               
00387Cr 3               nt_block_write:
00387Cr 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
00387Er 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
003882r 3  rr rr        
003884r 3  62 6C 6F 63          .byte "block-write"
003888r 3  6B 2D 77 72  
00388Cr 3  69 74 65     
00388Fr 3               
00388Fr 3               nt_blk:
00388Fr 3  03 00                .byte 3, 0
003891r 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
003895r 3  rr rr        
003897r 3  62 6C 6B             .byte "blk"
00389Ar 3               
00389Ar 3               nt_scr:
00389Ar 3  03 00                .byte 3, 0
00389Cr 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
0038A0r 3  rr rr        
0038A2r 3  73 63 72             .byte "scr"
0038A5r 3               
0038A5r 3               nt_blkbuffer:
0038A5r 3  09 00                .byte 9, 0
0038A7r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
0038ABr 3  rr rr        
0038ADr 3  62 6C 6B 62          .byte "blkbuffer"
0038B1r 3  75 66 66 65  
0038B5r 3  72           
0038B6r 3               
0038B6r 3               nt_buffblocknum:
0038B6r 3  0C 00                .byte 12, 0
0038B8r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
0038BCr 3  rr rr        
0038BEr 3  62 75 66 66          .byte "buffblocknum"
0038C2r 3  62 6C 6F 63  
0038C6r 3  6B 6E 75 6D  
0038CAr 3               
0038CAr 3               nt_buffstatus:
0038CAr 3  0A 00                .byte 10, 0
0038CCr 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
0038D0r 3  rr rr        
0038D2r 3  62 75 66 66          .byte "buffstatus"
0038D6r 3  73 74 61 74  
0038DAr 3  75 73        
0038DCr 3               
0038DCr 3               nt_buffer_colon:
0038DCr 3  07 00                .byte 7, 0
0038DEr 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
0038E2r 3  rr rr        
0038E4r 3  62 75 66 66          .byte "buffer:"
0038E8r 3  65 72 3A     
0038EBr 3               
0038EBr 3               nt_useraddr:
0038EBr 3  08 00                .byte 8, 0
0038EDr 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
0038F1r 3  rr rr        
0038F3r 3  75 73 65 72          .byte "useraddr"
0038F7r 3  61 64 64 72  
0038FBr 3               
0038FBr 3               nt_action_of:
0038FBr 3  09 04                .byte 9, IM
0038FDr 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
003901r 3  rr rr        
003903r 3  61 63 74 69          .byte "action-of"
003907r 3  6F 6E 2D 6F  
00390Br 3  66           
00390Cr 3               
00390Cr 3               nt_is:
00390Cr 3  02 04                .byte 2, IM
00390Er 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
003912r 3  rr rr        
003914r 3  69 73                .byte "is"
003916r 3               
003916r 3               nt_defer_store:
003916r 3  06 00                .byte 6, 0
003918r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
00391Cr 3  rr rr        
00391Er 3  64 65 66 65          .byte "defer!"
003922r 3  72 21        
003924r 3               
003924r 3               nt_defer_fetch:
003924r 3  06 00                .byte 6, 0
003926r 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
00392Ar 3  rr rr        
00392Cr 3  64 65 66 65          .byte "defer@"
003930r 3  72 40        
003932r 3               
003932r 3               nt_endcase:
003932r 3  07 0D                .byte 7, IM+CO+NN
003934r 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
003938r 3  rr rr        
00393Ar 3  65 6E 64 63          .byte "endcase"
00393Er 3  61 73 65     
003941r 3               
003941r 3               nt_endof:
003941r 3  05 0D                .byte 5, IM+CO+NN
003943r 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
003947r 3  rr rr        
003949r 3  65 6E 64 6F          .byte "endof"
00394Dr 3  66           
00394Er 3               
00394Er 3               nt_of:
00394Er 3  02 0D                .byte 2, IM+CO+NN
003950r 3  rr rr rr rr          .word nt_endof, xt_of, z_of
003954r 3  rr rr        
003956r 3  6F 66                .byte "of"
003958r 3               
003958r 3               nt_case:
003958r 3  04 0D                .byte 4, IM+CO+NN
00395Ar 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
00395Er 3  rr rr        
003960r 3  63 61 73 65          .byte "case"
003964r 3               
003964r 3               nt_while:
003964r 3  05 0D                .byte 5, IM+CO+NN
003966r 3  rr rr rr rr          .word nt_case, xt_while, z_while
00396Ar 3  rr rr        
00396Cr 3  77 68 69 6C          .byte "while"
003970r 3  65           
003971r 3               
003971r 3               nt_until:
003971r 3  05 0D                .byte 5, IM+CO+NN
003973r 3  rr rr rr rr          .word nt_while, xt_until, z_until
003977r 3  rr rr        
003979r 3  75 6E 74 69          .byte "until"
00397Dr 3  6C           
00397Er 3               
00397Er 3               nt_repeat:
00397Er 3  06 0D                .byte 6, IM+CO+NN
003980r 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
003984r 3  rr rr        
003986r 3  72 65 70 65          .byte "repeat"
00398Ar 3  61 74        
00398Cr 3               
00398Cr 3               nt_else:
00398Cr 3  04 0D                .byte 4, IM+CO+NN
00398Er 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
003992r 3  rr rr        
003994r 3  65 6C 73 65          .byte "else"
003998r 3               
003998r 3               nt_then:
003998r 3  04 0D                .byte 4, IM+CO+NN
00399Ar 3  rr rr rr rr          .word nt_else, xt_then, z_then
00399Er 3  rr rr        
0039A0r 3  74 68 65 6E          .byte "then"
0039A4r 3               
0039A4r 3               nt_if:
0039A4r 3  02 0D                .byte 2, IM+CO+NN
0039A6r 3  rr rr rr rr          .word nt_then, xt_if, z_if
0039AAr 3  rr rr        
0039ACr 3  69 66                .byte "if"
0039AEr 3               
0039AEr 3               nt_dot_paren:
0039AEr 3  02 04                .byte 2, IM
0039B0r 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
0039B4r 3  rr rr        
0039B6r 3  2E 28                .byte ".("
0039B8r 3               
0039B8r 3               nt_paren:
0039B8r 3  01 04                .byte 1, IM
0039BAr 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
0039BEr 3  rr rr        
0039C0r 3  28                   .byte "("
0039C1r 3               
0039C1r 3               nt_word:
0039C1r 3  04 10                .byte 4, UF
0039C3r 3  rr rr rr rr          .word nt_paren, xt_word, z_word
0039C7r 3  rr rr        
0039C9r 3  77 6F 72 64          .byte "word"
0039CDr 3               
0039CDr 3               nt_find:
0039CDr 3  04 10                .byte 4, UF
0039CFr 3  rr rr rr rr          .word nt_word, xt_find, z_find
0039D3r 3  rr rr        
0039D5r 3  66 69 6E 64          .byte "find"
0039D9r 3               
0039D9r 3               nt_environment_q:
0039D9r 3  0C 10                .byte 12, UF
0039DBr 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
0039DFr 3  rr rr        
0039E1r 3  65 6E 76 69          .byte "environment?"
0039E5r 3  72 6F 6E 6D  
0039E9r 3  65 6E 74 3F  
0039EDr 3               
0039EDr 3               nt_search:
0039EDr 3  06 18                .byte 6, UF+NN
0039EFr 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
0039F3r 3  rr rr        
0039F5r 3  73 65 61 72          .byte "search"
0039F9r 3  63 68        
0039FBr 3               
0039FBr 3               nt_compare:
0039FBr 3  07 10                .byte 7, UF
0039FDr 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
003A01r 3  rr rr        
003A03r 3  63 6F 6D 70          .byte "compare"
003A07r 3  61 72 65     
003A0Ar 3               
003A0Ar 3               nt_disasm:
003A0Ar 3  06 10                .byte 6, UF
003A0Cr 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
003A10r 3  rr rr        
003A12r 3  64 69 73 61          .byte "disasm"
003A16r 3  73 6D        
003A18r 3               
003A18r 3               nt_dot_s:
003A18r 3  02 00                .byte 2, 0
003A1Ar 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
003A1Er 3  rr rr        
003A20r 3  2E 73                .byte ".s"
003A22r 3               
003A22r 3               nt_dump:
003A22r 3  04 10                .byte 4, UF
003A24r 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
003A28r 3  rr rr        
003A2Ar 3  64 75 6D 70          .byte "dump"
003A2Er 3               
003A2Er 3               nt_bell:
003A2Er 3  04 00                .byte 4, 0
003A30r 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
003A34r 3  rr rr        
003A36r 3  62 65 6C 6C          .byte "bell"
003A3Ar 3               
003A3Ar 3               nt_align:
003A3Ar 3  05 00                .byte 5, 0
003A3Cr 3  rr rr rr rr          .word nt_bell, xt_align, z_align
003A40r 3  rr rr        
003A42r 3  61 6C 69 67          .byte "align"
003A46r 3  6E           
003A47r 3               
003A47r 3               nt_aligned:             ; same code as ALIGN
003A47r 3  07 00                .byte 7, 0
003A49r 3  rr rr rr rr          .word nt_align, xt_align, z_align
003A4Dr 3  rr rr        
003A4Fr 3  61 6C 69 67          .byte "aligned"
003A53r 3  6E 65 64     
003A56r 3               
003A56r 3               nt_wordsize:
003A56r 3  08 10                .byte 8, UF
003A58r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
003A5Cr 3  rr rr        
003A5Er 3  77 6F 72 64          .byte "wordsize"
003A62r 3  73 69 7A 65  
003A66r 3               
003A66r 3               nt_words:
003A66r 3  05 00                .byte 5, 0
003A68r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
003A6Cr 3  rr rr        
003A6Er 3  77 6F 72 64          .byte "words"
003A72r 3  73           
003A73r 3               
003A73r 3               nt_marker:
003A73r 3  06 04                .byte 6, IM
003A75r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
003A79r 3  rr rr        
003A7Br 3  6D 61 72 6B          .byte "marker"
003A7Fr 3  65 72        
003A81r 3               
003A81r 3               nt_at_xy:
003A81r 3  05 10                .byte 5, UF
003A83r 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
003A87r 3  rr rr        
003A89r 3  61 74 2D 78          .byte "at-xy"
003A8Dr 3  79           
003A8Er 3               
003A8Er 3               nt_page:
003A8Er 3  04 00                .byte 4, 0
003A90r 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
003A94r 3  rr rr        
003A96r 3  70 61 67 65          .byte "page"
003A9Ar 3               
003A9Ar 3               nt_cr:
003A9Ar 3  02 00                .byte 2, 0
003A9Cr 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
003AA0r 3  rr rr        
003AA2r 3  63 72                .byte "cr"
003AA4r 3               
003AA4r 3               nt_input:
003AA4r 3  05 00                .byte 5, 0
003AA6r 3  rr rr rr rr          .word nt_cr, xt_input, z_input
003AAAr 3  rr rr        
003AACr 3  69 6E 70 75          .byte "input"
003AB0r 3  74           
003AB1r 3               
003AB1r 3               nt_output:
003AB1r 3  06 00                .byte 6, 0
003AB3r 3  rr rr rr rr          .word nt_input, xt_output, z_output
003AB7r 3  rr rr        
003AB9r 3  6F 75 74 70          .byte "output"
003ABDr 3  75 74        
003ABFr 3               
003ABFr 3               nt_sign:
003ABFr 3  04 10                .byte 4, UF
003AC1r 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
003AC5r 3  rr rr        
003AC7r 3  73 69 67 6E          .byte "sign"
003ACBr 3               
003ACBr 3               nt_hold:
003ACBr 3  04 10                .byte 4, UF
003ACDr 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
003AD1r 3  rr rr        
003AD3r 3  68 6F 6C 64          .byte "hold"
003AD7r 3               
003AD7r 3               nt_number_sign_greater:
003AD7r 3  02 10                .byte 2, UF
003AD9r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
003ADDr 3  rr rr        
003ADFr 3  23 3E                .byte "#>"
003AE1r 3               
003AE1r 3               nt_number_sign_s:
003AE1r 3  02 10                .byte 2, UF
003AE3r 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
003AE7r 3  rr rr        
003AE9r 3  23 73                .byte "#s"
003AEBr 3               
003AEBr 3               nt_number_sign:
003AEBr 3  01 10                .byte 1, UF
003AEDr 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
003AF1r 3  rr rr        
003AF3r 3  23                   .byte "#"
003AF4r 3               
003AF4r 3               nt_less_number_sign:
003AF4r 3  02 00                .byte 2, 0
003AF6r 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
003AFAr 3  rr rr        
003AFCr 3  3C 23                .byte "<#"
003AFEr 3               
003AFEr 3               nt_to_in:
003AFEr 3  03 00                .byte 3, 0
003B00r 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
003B04r 3  rr rr        
003B06r 3  3E 69 6E             .byte ">in"
003B09r 3               
003B09r 3               nt_within:
003B09r 3  06 10                .byte 6, UF
003B0Br 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
003B0Fr 3  rr rr        
003B11r 3  77 69 74 68          .byte "within"
003B15r 3  69 6E        
003B17r 3               
003B17r 3               nt_hexstore:
003B17r 3  08 10                .byte 8, UF
003B19r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
003B1Dr 3  rr rr        
003B1Fr 3  68 65 78 73          .byte "hexstore"
003B23r 3  74 6F 72 65  
003B27r 3               
003B27r 3               nt_cleave:
003B27r 3  06 10                .byte 6, UF
003B29r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
003B2Dr 3  rr rr        
003B2Fr 3  63 6C 65 61          .byte "cleave"
003B33r 3  76 65        
003B35r 3               
003B35r 3               nt_pad:
003B35r 3  03 00                .byte 3, 0
003B37r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
003B3Br 3  rr rr        
003B3Dr 3  70 61 64             .byte "pad"
003B40r 3               
003B40r 3               nt_cmove:
003B40r 3  05 10                .byte 5, UF
003B42r 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
003B46r 3  rr rr        
003B48r 3  63 6D 6F 76          .byte "cmove"
003B4Cr 3  65           
003B4Dr 3               
003B4Dr 3               nt_cmove_up:
003B4Dr 3  06 10                .byte 6, UF
003B4Fr 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
003B53r 3  rr rr        
003B55r 3  63 6D 6F 76          .byte "cmove>"
003B59r 3  65 3E        
003B5Br 3               
003B5Br 3               nt_move:
003B5Br 3  04 18                .byte 4, NN+UF
003B5Dr 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
003B61r 3  rr rr        
003B63r 3  6D 6F 76 65          .byte "move"
003B67r 3               
003B67r 3               nt_backslash:
003B67r 3  01 04                .byte 1, IM
003B69r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
003B6Dr 3  rr rr        
003B6Fr 3  5C                   .byte $5c
003B70r 3               
003B70r 3               nt_star_slash:
003B70r 3  02 10                .byte 2, UF
003B72r 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
003B76r 3  rr rr        
003B78r 3  2A 2F                .byte "*/"
003B7Ar 3               
003B7Ar 3               nt_star_slash_mod:
003B7Ar 3  05 10                .byte 5, UF
003B7Cr 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
003B80r 3  rr rr        
003B82r 3  2A 2F 6D 6F          .byte "*/mod"
003B86r 3  64           
003B87r 3               
003B87r 3               nt_mod:
003B87r 3  03 10                .byte 3, UF
003B89r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
003B8Dr 3  rr rr        
003B8Fr 3  6D 6F 64             .byte "mod"
003B92r 3               
003B92r 3               nt_slash_mod:
003B92r 3  04 10                .byte 4, UF
003B94r 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
003B98r 3  rr rr        
003B9Ar 3  2F 6D 6F 64          .byte "/mod"
003B9Er 3               
003B9Er 3               nt_slash:
003B9Er 3  01 10                .byte 1, UF
003BA0r 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
003BA4r 3  rr rr        
003BA6r 3  2F                   .byte "/"
003BA7r 3               
003BA7r 3               nt_fm_slash_mod:
003BA7r 3  06 10                .byte 6, UF
003BA9r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
003BADr 3  rr rr        
003BAFr 3  66 6D 2F 6D          .byte "fm/mod"
003BB3r 3  6F 64        
003BB5r 3               
003BB5r 3               nt_sm_slash_rem:
003BB5r 3  06 10                .byte 6, UF
003BB7r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
003BBBr 3  rr rr        
003BBDr 3  73 6D 2F 72          .byte "sm/rem"
003BC1r 3  65 6D        
003BC3r 3               
003BC3r 3               nt_um_slash_mod:
003BC3r 3  06 10                .byte 6, UF
003BC5r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
003BC9r 3  rr rr        
003BCBr 3  75 6D 2F 6D          .byte "um/mod"
003BCFr 3  6F 64        
003BD1r 3               
003BD1r 3               nt_star:
003BD1r 3  01 10                .byte 1, UF
003BD3r 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
003BD7r 3  rr rr        
003BD9r 3  2A                   .byte "*"
003BDAr 3               
003BDAr 3               nt_um_star:
003BDAr 3  03 10                .byte 3, UF
003BDCr 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
003BE0r 3  rr rr        
003BE2r 3  75 6D 2A             .byte "um*"
003BE5r 3               
003BE5r 3               nt_m_star:
003BE5r 3  02 10                .byte 2, UF
003BE7r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
003BEBr 3  rr rr        
003BEDr 3  6D 2A                .byte "m*"
003BEFr 3               
003BEFr 3               nt_count:
003BEFr 3  05 10                .byte 5, UF
003BF1r 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
003BF5r 3  rr rr        
003BF7r 3  63 6F 75 6E          .byte "count"
003BFBr 3  74           
003BFCr 3               
003BFCr 3               nt_decimal:
003BFCr 3  07 00                .byte 7, 0
003BFEr 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
003C02r 3  rr rr        
003C04r 3  64 65 63 69          .byte "decimal"
003C08r 3  6D 61 6C     
003C0Br 3               
003C0Br 3               nt_hex:
003C0Br 3  03 00                .byte 3, 0
003C0Dr 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
003C11r 3  rr rr        
003C13r 3  68 65 78             .byte "hex"
003C16r 3               
003C16r 3               nt_to_number:
003C16r 3  07 10                .byte 7, UF
003C18r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
003C1Cr 3  rr rr        
003C1Er 3  3E 6E 75 6D          .byte ">number"
003C22r 3  62 65 72     
003C25r 3               
003C25r 3               nt_number:
003C25r 3  06 10                .byte 6, UF
003C27r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
003C2Br 3  rr rr        
003C2Dr 3  6E 75 6D 62          .byte "number"
003C31r 3  65 72        
003C33r 3               
003C33r 3               nt_digit_question:
003C33r 3  06 10                .byte 6, UF
003C35r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
003C39r 3  rr rr        
003C3Br 3  64 69 67 69          .byte "digit?"
003C3Fr 3  74 3F        
003C41r 3               
003C41r 3               nt_base:
003C41r 3  04 00                .byte 4, 0
003C43r 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
003C47r 3  rr rr        
003C49r 3  62 61 73 65          .byte "base"
003C4Dr 3               
003C4Dr 3               nt_evaluate:
003C4Dr 3  08 10                .byte 8, UF
003C4Fr 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
003C53r 3  rr rr        
003C55r 3  65 76 61 6C          .byte "evaluate"
003C59r 3  75 61 74 65  
003C5Dr 3               
003C5Dr 3               nt_state:
003C5Dr 3  05 00                .byte 5, 0
003C5Fr 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
003C63r 3  rr rr        
003C65r 3  73 74 61 74          .byte "state"
003C69r 3  65           
003C6Ar 3               
003C6Ar 3               nt_again:
003C6Ar 3  05 17                .byte 5, AN+CO+IM+UF
003C6Cr 3  rr rr rr rr          .word nt_state, xt_again, z_again
003C70r 3  rr rr        
003C72r 3  61 67 61 69          .byte "again"
003C76r 3  6E           
003C77r 3               
003C77r 3               nt_begin:
003C77r 3  05 07                .byte 5, AN+CO+IM
003C79r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
003C7Dr 3  rr rr        
003C7Fr 3  62 65 67 69          .byte "begin"
003C83r 3  6E           
003C84r 3               
003C84r 3               nt_quit:
003C84r 3  04 00                .byte 4, 0
003C86r 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
003C8Ar 3  rr rr        
003C8Cr 3  71 75 69 74          .byte "quit"
003C90r 3               
003C90r 3               nt_recurse:
003C90r 3  07 0D                .byte 7, CO+IM+NN
003C92r 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
003C96r 3  rr rr        
003C98r 3  72 65 63 75          .byte "recurse"
003C9Cr 3  72 73 65     
003C9Fr 3               
003C9Fr 3               nt_leave:
003C9Fr 3  05 03                .byte 5, AN+CO
003CA1r 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
003CA5r 3  rr rr        
003CA7r 3  6C 65 61 76          .byte "leave"
003CABr 3  65           
003CACr 3               
003CACr 3               nt_unloop:
003CACr 3  06 03                .byte 6, AN+CO
003CAEr 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
003CB2r 3  rr rr        
003CB4r 3  75 6E 6C 6F          .byte "unloop"
003CB8r 3  6F 70        
003CBAr 3               
003CBAr 3               nt_exit:
003CBAr 3  04 03                .byte 4, AN+CO
003CBCr 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
003CC0r 3  rr rr        
003CC2r 3  65 78 69 74          .byte "exit"
003CC6r 3               
003CC6r 3               nt_plus_loop:
003CC6r 3  05 05                .byte 5, CO+IM
003CC8r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
003CCCr 3  rr rr        
003CCEr 3  2B 6C 6F 6F          .byte "+loop"
003CD2r 3  70           
003CD3r 3               
003CD3r 3               nt_loop:
003CD3r 3  04 05                .byte 4, CO+IM
003CD5r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
003CD9r 3  rr rr        
003CDBr 3  6C 6F 6F 70          .byte "loop"
003CDFr 3               
003CDFr 3               nt_j:
003CDFr 3  01 03                .byte 1, AN+CO
003CE1r 3  rr rr rr rr          .word nt_loop, xt_j, z_j
003CE5r 3  rr rr        
003CE7r 3  6A                   .byte "j"
003CE8r 3               
003CE8r 3               nt_i:
003CE8r 3  01 03                .byte 1, AN+CO
003CEAr 3  rr rr rr rr          .word nt_j, xt_i, z_i
003CEEr 3  rr rr        
003CF0r 3  69                   .byte "i"
003CF1r 3               
003CF1r 3               nt_question_do:
003CF1r 3  03 0D                .byte 3, CO+IM+NN
003CF3r 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
003CF7r 3  rr rr        
003CF9r 3  3F 64 6F             .byte "?do"
003CFCr 3               
003CFCr 3               nt_do:
003CFCr 3  02 0D                .byte 2, CO+IM+NN
003CFEr 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
003D02r 3  rr rr        
003D04r 3  64 6F                .byte "do"
003D06r 3               
003D06r 3               nt_abort_quote:
003D06r 3  06 0D                .byte 6, CO+IM+NN
003D08r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
003D0Cr 3  rr rr        
003D0Er 3  61 62 6F 72          .byte "abort", $22
003D12r 3  74 22        
003D14r 3               
003D14r 3               nt_abort:
003D14r 3  05 00                .byte 5, 0
003D16r 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
003D1Ar 3  rr rr        
003D1Cr 3  61 62 6F 72          .byte "abort"
003D20r 3  74           
003D21r 3               
003D21r 3               nt_strip_underflow:
003D21r 3  0F 00                .byte 15, 0
003D23r 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
003D27r 3  rr rr        
003D29r 3  73 74 72 69          .byte "strip-underflow"
003D2Dr 3  70 2D 75 6E  
003D31r 3  64 65 72 66  
003D38r 3               
003D38r 3               nt_nc_limit:
003D38r 3  08 00                .byte 8, 0
003D3Ar 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
003D3Er 3  rr rr        
003D40r 3  6E 63 2D 6C          .byte "nc-limit"
003D44r 3  69 6D 69 74  
003D48r 3               
003D48r 3               nt_allow_native:
003D48r 3  0C 00                .byte 12, 0
003D4Ar 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
003D4Er 3  rr rr        
003D50r 3  61 6C 6C 6F          .byte "allow-native"
003D54r 3  77 2D 6E 61  
003D58r 3  74 69 76 65  
003D5Cr 3               
003D5Cr 3               nt_always_native:
003D5Cr 3  0D 00                .byte 13, 0
003D5Er 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
003D62r 3  rr rr        
003D64r 3  61 6C 77 61          .byte "always-native"
003D68r 3  79 73 2D 6E  
003D6Cr 3  61 74 69 76  
003D71r 3               
003D71r 3               nt_never_native:
003D71r 3  0C 00                .byte 12, 0
003D73r 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
003D77r 3  rr rr        
003D79r 3  6E 65 76 65          .byte "never-native"
003D7Dr 3  72 2D 6E 61  
003D81r 3  74 69 76 65  
003D85r 3               
003D85r 3               nt_compile_only:
003D85r 3  0C 00                .byte 12, 0
003D87r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003D8Br 3  rr rr        
003D8Dr 3  63 6F 6D 70          .byte "compile-only"
003D91r 3  69 6C 65 2D  
003D95r 3  6F 6E 6C 79  
003D99r 3               
003D99r 3               nt_immediate:
003D99r 3  09 00                .byte 9, 0
003D9Br 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
003D9Fr 3  rr rr        
003DA1r 3  69 6D 6D 65          .byte "immediate"
003DA5r 3  64 69 61 74  
003DA9r 3  65           
003DAAr 3               
003DAAr 3               nt_postpone:
003DAAr 3  08 05                .byte 8, IM+CO
003DACr 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
003DB0r 3  rr rr        
003DB2r 3  70 6F 73 74          .byte "postpone"
003DB6r 3  70 6F 6E 65  
003DBAr 3               
003DBAr 3               nt_s_backslash_quote:
003DBAr 3  03 04                .byte 3, IM
003DBCr 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
003DC0r 3  rr rr        
003DC2r 3  73 5C 22             .byte "s", $5C, $22
003DC5r 3               
003DC5r 3               nt_s_quote:
003DC5r 3  02 0C                .byte 2, IM+NN
003DC7r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
003DCBr 3  rr rr        
003DCDr 3  73 22                .byte "s", $22
003DCFr 3               
003DCFr 3               nt_dot_quote:
003DCFr 3  02 05                .byte 2, CO+IM
003DD1r 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
003DD5r 3  rr rr        
003DD7r 3  2E 22                .byte ".", $22
003DD9r 3               
003DD9r 3               nt_sliteral:
003DD9r 3  08 15                .byte 8, CO+IM+UF
003DDBr 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
003DDFr 3  rr rr        
003DE1r 3  73 6C 69 74          .byte "sliteral"
003DE5r 3  65 72 61 6C  
003DE9r 3               
003DE9r 3               nt_literal:
003DE9r 3  07 15                .byte 7, IM+CO+UF
003DEBr 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
003DEFr 3  rr rr        
003DF1r 3  6C 69 74 65          .byte "literal"
003DF5r 3  72 61 6C     
003DF8r 3               
003DF8r 3               nt_right_bracket:
003DF8r 3  01 04                .byte 1, IM
003DFAr 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
003DFEr 3  rr rr        
003E00r 3  5D                   .byte "]"
003E01r 3               
003E01r 3               nt_left_bracket:
003E01r 3  01 05                .byte 1, IM+CO
003E03r 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
003E07r 3  rr rr        
003E09r 3  5B                   .byte "["
003E0Ar 3               
003E0Ar 3               nt_compile_comma:
003E0Ar 3  08 18                .byte 8, UF+NN
003E0Cr 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
003E10r 3  rr rr        
003E12r 3  63 6F 6D 70          .byte "compile,"
003E16r 3  69 6C 65 2C  
003E1Ar 3               
003E1Ar 3               nt_colon_noname:
003E1Ar 3  07 00                .byte 7, 0
003E1Cr 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
003E20r 3  rr rr        
003E22r 3  3A 6E 6F 6E          .byte ":noname"
003E26r 3  61 6D 65     
003E29r 3               
003E29r 3               nt_semicolon:
003E29r 3  01 05                .byte 1, CO+IM
003E2Br 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
003E2Fr 3  rr rr        
003E31r 3  3B                   .byte ";"
003E32r 3               
003E32r 3               nt_colon:
003E32r 3  01 00                .byte 1, 0
003E34r 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
003E38r 3  rr rr        
003E3Ar 3  3A                   .byte ":"
003E3Br 3               
003E3Br 3               nt_source_id:
003E3Br 3  09 00                .byte 9, 0
003E3Dr 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
003E41r 3  rr rr        
003E43r 3  73 6F 75 72          .byte "source-id"
003E47r 3  63 65 2D 69  
003E4Br 3  64           
003E4Cr 3               
003E4Cr 3               nt_source:
003E4Cr 3  06 00                .byte 6, 0
003E4Er 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
003E52r 3  rr rr        
003E54r 3  73 6F 75 72          .byte "source"
003E58r 3  63 65        
003E5Ar 3               
003E5Ar 3               nt_execute_parsing:
003E5Ar 3  0F 10                .byte 15, UF
003E5Cr 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
003E60r 3  rr rr        
003E62r 3  65 78 65 63          .byte "execute-parsing"
003E66r 3  75 74 65 2D  
003E6Ar 3  70 61 72 73  
003E71r 3               
003E71r 3               nt_parse:
003E71r 3  05 10                .byte 5, UF
003E73r 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
003E77r 3  rr rr        
003E79r 3  70 61 72 73          .byte "parse"
003E7Dr 3  65           
003E7Er 3               
003E7Er 3               nt_parse_name:
003E7Er 3  0A 08                .byte 10, NN
003E80r 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
003E84r 3  rr rr        
003E86r 3  70 61 72 73          .byte "parse-name"
003E8Ar 3  65 2D 6E 61  
003E8Er 3  6D 65        
003E90r 3               
003E90r 3               nt_latestnt:
003E90r 3  08 00                .byte 8, 0
003E92r 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
003E96r 3  rr rr        
003E98r 3  6C 61 74 65          .byte "latestnt"
003E9Cr 3  73 74 6E 74  
003EA0r 3               
003EA0r 3               nt_latestxt:
003EA0r 3  08 00                .byte 8, 0
003EA2r 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
003EA6r 3  rr rr        
003EA8r 3  6C 61 74 65          .byte "latestxt"
003EACr 3  73 74 78 74  
003EB0r 3               
003EB0r 3               nt_defer:
003EB0r 3  05 00                .byte 5, 0
003EB2r 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
003EB6r 3  rr rr        
003EB8r 3  64 65 66 65          .byte "defer"
003EBCr 3  72           
003EBDr 3               
003EBDr 3               nt_to_body:
003EBDr 3  05 10                .byte 5, UF
003EBFr 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
003EC3r 3  rr rr        
003EC5r 3  3E 62 6F 64          .byte ">body"
003EC9r 3  79           
003ECAr 3               
003ECAr 3               nt_name_to_string:
003ECAr 3  0B 10                .byte 11, UF
003ECCr 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
003ED0r 3  rr rr        
003ED2r 3  6E 61 6D 65          .byte "name>string"
003ED6r 3  3E 73 74 72  
003EDAr 3  69 6E 67     
003EDDr 3               
003EDDr 3               nt_int_to_name:
003EDDr 3  08 10                .byte 8, UF
003EDFr 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
003EE3r 3  rr rr        
003EE5r 3  69 6E 74 3E          .byte "int>name"
003EE9r 3  6E 61 6D 65  
003EEDr 3               
003EEDr 3               nt_name_to_int:
003EEDr 3  08 10                .byte 8, UF
003EEFr 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
003EF3r 3  rr rr        
003EF5r 3  6E 61 6D 65          .byte "name>int"
003EF9r 3  3E 69 6E 74  
003EFDr 3               
003EFDr 3               nt_bracket_tick:
003EFDr 3  03 05                .byte 3, CO+IM
003EFFr 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
003F03r 3  rr rr        
003F05r 3  5B 27 5D             .byte "[']"
003F08r 3               
003F08r 3               nt_tick:
003F08r 3  01 00                .byte 1, 0
003F0Ar 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
003F0Er 3  rr rr        
003F10r 3  27                   .byte "'"
003F11r 3               
003F11r 3               nt_find_name:
003F11r 3  09 10                .byte 9, UF
003F13r 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
003F17r 3  rr rr        
003F19r 3  66 69 6E 64          .byte "find-name"
003F1Dr 3  2D 6E 61 6D  
003F21r 3  65           
003F22r 3               
003F22r 3               nt_fill:
003F22r 3  04 10                .byte 4, UF
003F24r 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
003F28r 3  rr rr        
003F2Ar 3  66 69 6C 6C          .byte "fill"
003F2Er 3               
003F2Er 3               nt_blank:
003F2Er 3  05 00                .byte 5, 0     ; underflow checked by FILL
003F30r 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
003F34r 3  rr rr        
003F36r 3  62 6C 61 6E          .byte "blank"
003F3Ar 3  6B           
003F3Br 3               
003F3Br 3               nt_erase:
003F3Br 3  05 00                .byte 5, 0      ; underflow checked by FILL
003F3Dr 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
003F41r 3  rr rr        
003F43r 3  65 72 61 73          .byte "erase"
003F47r 3  65           
003F48r 3               
003F48r 3               nt_d_plus:
003F48r 3  02 10                .byte 2, UF
003F4Ar 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
003F4Er 3  rr rr        
003F50r 3  64 2B                .byte "d+"
003F52r 3               
003F52r 3               nt_d_minus:
003F52r 3  02 10                .byte 2, UF
003F54r 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
003F58r 3  rr rr        
003F5Ar 3  64 2D                .byte "d-"
003F5Cr 3               
003F5Cr 3               nt_d_to_s:
003F5Cr 3  03 10                .byte 3, UF
003F5Er 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
003F62r 3  rr rr        
003F64r 3  64 3E 73             .byte "d>s"
003F67r 3               
003F67r 3               nt_s_to_d:
003F67r 3  03 10                .byte 3, UF
003F69r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
003F6Dr 3  rr rr        
003F6Fr 3  73 3E 64             .byte "s>d"
003F72r 3               
003F72r 3               nt_to:
003F72r 3  02 0C                .byte 2, NN+IM
003F74r 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
003F78r 3  rr rr        
003F7Ar 3  74 6F                .byte "to"
003F7Cr 3               
003F7Cr 3               nt_value:               ; same code as CONSTANT
003F7Cr 3  05 10                .byte 5, UF
003F7Er 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
003F82r 3  rr rr        
003F84r 3  76 61 6C 75          .byte "value"
003F88r 3  65           
003F89r 3               
003F89r 3               nt_constant:
003F89r 3  08 10                .byte 8, UF
003F8Br 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
003F8Fr 3  rr rr        
003F91r 3  63 6F 6E 73          .byte "constant"
003F95r 3  74 61 6E 74  
003F99r 3               
003F99r 3               nt_variable:
003F99r 3  08 00                .byte 8, 0
003F9Br 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
003F9Fr 3  rr rr        
003FA1r 3  76 61 72 69          .byte "variable"
003FA5r 3  61 62 6C 65  
003FA9r 3               
003FA9r 3               nt_does:
003FA9r 3  05 05                .byte 5, CO+IM
003FABr 3  rr rr rr rr          .word nt_variable, xt_does, z_does
003FAFr 3  rr rr        
003FB1r 3  64 6F 65 73          .byte "does>"
003FB5r 3  3E           
003FB6r 3               
003FB6r 3               nt_create:
003FB6r 3  06 00                .byte 6, 0
003FB8r 3  rr rr rr rr          .word nt_does, xt_create, z_create
003FBCr 3  rr rr        
003FBEr 3  63 72 65 61          .byte "create"
003FC2r 3  74 65        
003FC4r 3               
003FC4r 3               nt_allot:
003FC4r 3  05 10                .byte 5, UF
003FC6r 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
003FCAr 3  rr rr        
003FCCr 3  61 6C 6C 6F          .byte "allot"
003FD0r 3  74           
003FD1r 3               
003FD1r 3               nt_key:
003FD1r 3  03 00                .byte 3, 0
003FD3r 3  rr rr rr rr          .word nt_allot, xt_key, z_key
003FD7r 3  rr rr        
003FD9r 3  6B 65 79             .byte "key"
003FDCr 3               
003FDCr 3               nt_depth:
003FDCr 3  05 00                .byte 5, 0
003FDEr 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
003FE2r 3  rr rr        
003FE4r 3  64 65 70 74          .byte "depth"
003FE8r 3  68           
003FE9r 3               
003FE9r 3               nt_unused:
003FE9r 3  06 00                .byte 6, 0
003FEBr 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
003FEFr 3  rr rr        
003FF1r 3  75 6E 75 73          .byte "unused"
003FF5r 3  65 64        
003FF7r 3               
003FF7r 3               nt_r_to_input:
003FF7r 3  07 08                .byte 7, NN
003FF9r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
003FFDr 3  rr rr        
003FFFr 3  72 3E 69 6E          .byte "r>input"
004003r 3  70 75 74     
004006r 3               
004006r 3               nt_input_to_r:
004006r 3  07 08                .byte 7, NN
004008r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
00400Cr 3  rr rr        
00400Er 3  69 6E 70 75          .byte "input>r"
004012r 3  74 3E 72     
004015r 3               
004015r 3               nt_accept:
004015r 3  06 18                .byte 6, UF+NN
004017r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
00401Br 3  rr rr        
00401Dr 3  61 63 63 65          .byte "accept"
004021r 3  70 74        
004023r 3               
004023r 3               nt_refill:
004023r 3  06 00                .byte 6, 0
004025r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
004029r 3  rr rr        
00402Br 3  72 65 66 69          .byte "refill"
00402Fr 3  6C 6C        
004031r 3               
004031r 3               nt_slash_string:
004031r 3  07 10                .byte 7, UF
004033r 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
004037r 3  rr rr        
004039r 3  2F 73 74 72          .byte "/string"
00403Dr 3  69 6E 67     
004040r 3               
004040r 3               nt_minus_leading:
004040r 3  08 10                .byte 8, UF
004042r 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
004046r 3  rr rr        
004048r 3  2D 6C 65 61          .byte "-leading"
00404Cr 3  64 69 6E 67  
004050r 3               
004050r 3               nt_minus_trailing:
004050r 3  09 10                .byte 9, UF
004052r 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
004056r 3  rr rr        
004058r 3  2D 74 72 61          .byte "-trailing"
00405Cr 3  69 6C 69 6E  
004060r 3  67           
004061r 3               
004061r 3               nt_bl:
004061r 3  02 00                .byte 2, 0
004063r 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
004067r 3  rr rr        
004069r 3  62 6C                .byte "bl"
00406Br 3               
00406Br 3               nt_spaces:
00406Br 3  06 10                .byte 6, UF
00406Dr 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
004071r 3  rr rr        
004073r 3  73 70 61 63          .byte "spaces"
004077r 3  65 73        
004079r 3               
004079r 3               nt_bounds:
004079r 3  06 10                .byte 6, UF
00407Br 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
00407Fr 3  rr rr        
004081r 3  62 6F 75 6E          .byte "bounds"
004085r 3  64 73        
004087r 3               
004087r 3               nt_c_comma:
004087r 3  02 10                .byte 2, UF
004089r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
00408Dr 3  rr rr        
00408Fr 3  63 2C                .byte "c,"
004091r 3               
004091r 3               nt_dnegate:
004091r 3  07 10                .byte 7, UF
004093r 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
004097r 3  rr rr        
004099r 3  64 6E 65 67          .byte "dnegate"
00409Dr 3  61 74 65     
0040A0r 3               
0040A0r 3               nt_negate:
0040A0r 3  06 10                .byte 6, UF
0040A2r 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
0040A6r 3  rr rr        
0040A8r 3  6E 65 67 61          .byte "negate"
0040ACr 3  74 65        
0040AEr 3               
0040AEr 3               nt_invert:
0040AEr 3  06 10                .byte 6, UF
0040B0r 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
0040B4r 3  rr rr        
0040B6r 3  69 6E 76 65          .byte "invert"
0040BAr 3  72 74        
0040BCr 3               
0040BCr 3               nt_two_to_r:
0040BCr 3  03 11                .byte 3, CO+UF          ; native is special case
0040BEr 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
0040C2r 3  rr rr        
0040C4r 3  32 3E 72             .byte "2>r"
0040C7r 3               
0040C7r 3               nt_two_r_from:
0040C7r 3  03 01                .byte 3, CO             ; native is special case
0040C9r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
0040CDr 3  rr rr        
0040CFr 3  32 72 3E             .byte "2r>"
0040D2r 3               
0040D2r 3               nt_two_r_fetch:
0040D2r 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
0040D4r 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
0040D8r 3  rr rr        
0040DAr 3  32 72 40             .byte "2r@"
0040DDr 3               
0040DDr 3               nt_two_literal:
0040DDr 3  08 14                .byte 8, UF+IM
0040DFr 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
0040E3r 3  rr rr        
0040E5r 3  32 6C 69 74          .byte "2literal"
0040E9r 3  65 72 61 6C  
0040EDr 3               
0040EDr 3               nt_two_constant:
0040EDr 3  09 10                .byte 9, UF
0040EFr 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
0040F3r 3  rr rr        
0040F5r 3  32 63 6F 6E          .byte "2constant"
0040F9r 3  73 74 61 6E  
0040FDr 3  74           
0040FEr 3               
0040FEr 3               nt_two_variable:
0040FEr 3  09 00                .byte 9, 0
004100r 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
004104r 3  rr rr        
004106r 3  32 76 61 72          .byte "2variable"
00410Ar 3  69 61 62 6C  
00410Er 3  65           
00410Fr 3               
00410Fr 3               nt_two_fetch:
00410Fr 3  02 10                .byte 2, UF
004111r 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
004115r 3  rr rr        
004117r 3  32 40                .byte "2@"
004119r 3               
004119r 3               nt_two_store:
004119r 3  02 10                .byte 2, UF
00411Br 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
00411Fr 3  rr rr        
004121r 3  32 21                .byte "2!"
004123r 3               
004123r 3               nt_two_over:
004123r 3  05 10                .byte 5, UF
004125r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
004129r 3  rr rr        
00412Br 3  32 6F 76 65          .byte "2over"
00412Fr 3  72           
004130r 3               
004130r 3               nt_two_swap:
004130r 3  05 10                .byte 5, UF
004132r 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
004136r 3  rr rr        
004138r 3  32 73 77 61          .byte "2swap"
00413Cr 3  70           
00413Dr 3               
00413Dr 3               nt_two_drop:
00413Dr 3  05 10                .byte 5, UF
00413Fr 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
004143r 3  rr rr        
004145r 3  32 64 72 6F          .byte "2drop"
004149r 3  70           
00414Ar 3               
00414Ar 3               nt_max:
00414Ar 3  03 10                .byte 3, UF
00414Cr 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
004150r 3  rr rr        
004152r 3  6D 61 78             .byte "max"
004155r 3               
004155r 3               nt_min:
004155r 3  03 10                .byte 3, UF
004157r 3  rr rr rr rr          .word nt_max, xt_min, z_min
00415Br 3  rr rr        
00415Dr 3  6D 69 6E             .byte "min"
004160r 3               
004160r 3               nt_zero_less:
004160r 3  02 10                .byte 2, UF
004162r 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
004166r 3  rr rr        
004168r 3  30 3C                .byte "0<"
00416Ar 3               
00416Ar 3               nt_zero_greater:
00416Ar 3  02 10                .byte 2, UF
00416Cr 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
004170r 3  rr rr        
004172r 3  30 3E                .byte "0>"
004174r 3               
004174r 3               nt_zero_unequal:
004174r 3  03 10                .byte 3, UF
004176r 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
00417Ar 3  rr rr        
00417Cr 3  30 3C 3E             .byte "0<>"
00417Fr 3               
00417Fr 3               nt_zero_equal:
00417Fr 3  02 10                .byte 2, UF
004181r 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
004185r 3  rr rr        
004187r 3  30 3D                .byte "0="
004189r 3               
004189r 3               nt_greater_than:
004189r 3  01 10                .byte 1, UF
00418Br 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
00418Fr 3  rr rr        
004191r 3  3E                   .byte ">"
004192r 3               
004192r 3               nt_u_greater_than:
004192r 3  02 10                .byte 2, UF
004194r 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
004198r 3  rr rr        
00419Ar 3  75 3E                .byte "u>"
00419Cr 3               
00419Cr 3               nt_u_less_than:
00419Cr 3  02 10                .byte 2, UF
00419Er 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
0041A2r 3  rr rr        
0041A4r 3  75 3C                .byte "u<"
0041A6r 3               
0041A6r 3               nt_less_than:
0041A6r 3  01 10                .byte 1, UF
0041A8r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
0041ACr 3  rr rr        
0041AEr 3  3C                   .byte "<"
0041AFr 3               
0041AFr 3               nt_not_equals:
0041AFr 3  02 10                .byte 2, UF
0041B1r 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
0041B5r 3  rr rr        
0041B7r 3  3C 3E                .byte "<>"
0041B9r 3               
0041B9r 3               nt_equal:
0041B9r 3  01 10                .byte 1, UF
0041BBr 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
0041BFr 3  rr rr        
0041C1r 3  3D                   .byte "="
0041C2r 3               
0041C2r 3               nt_two_slash:
0041C2r 3  02 10                .byte 2, UF
0041C4r 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
0041C8r 3  rr rr        
0041CAr 3  32 2F                .byte "2/"
0041CCr 3               
0041CCr 3               nt_two_star:
0041CCr 3  02 10                .byte 2, UF
0041CEr 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
0041D2r 3  rr rr        
0041D4r 3  32 2A                .byte "2*"
0041D6r 3               
0041D6r 3               nt_one_plus:
0041D6r 3  02 10                .byte 2, UF
0041D8r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
0041DCr 3  rr rr        
0041DEr 3  31 2B                .byte "1+"
0041E0r 3               
0041E0r 3               nt_one_minus:
0041E0r 3  02 10                .byte 2, UF
0041E2r 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
0041E6r 3  rr rr        
0041E8r 3  31 2D                .byte "1-"
0041EAr 3               
0041EAr 3               nt_here:
0041EAr 3  04 00                .byte 4, 0
0041ECr 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
0041F0r 3  rr rr        
0041F2r 3  68 65 72 65          .byte "here"
0041F6r 3               
0041F6r 3               nt_cell_plus:
0041F6r 3  05 10                .byte 5, UF
0041F8r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
0041FCr 3  rr rr        
0041FEr 3  63 65 6C 6C          .byte "cell+"
004202r 3  2B           
004203r 3               
004203r 3               nt_cells:
004203r 3  05 00                .byte 5, 0
004205r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
004209r 3  rr rr        
00420Br 3  63 65 6C 6C          .byte "cells"
00420Fr 3  73           
004210r 3               
004210r 3               nt_chars:
004210r 3  05 12                .byte 5, AN+UF   ; deleted during compile
004212r 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
004216r 3  rr rr        
004218r 3  63 68 61 72          .byte "chars"
00421Cr 3  73           
00421Dr 3               
00421Dr 3               nt_char_plus:
00421Dr 3  05 00                .byte 5, 0
00421Fr 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
004223r 3  rr rr        
004225r 3  63 68 61 72          .byte "char+"
004229r 3  2B           
00422Ar 3               
00422Ar 3               nt_bracket_char:
00422Ar 3  06 05                .byte 6, CO+IM
00422Cr 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
004230r 3  rr rr        
004232r 3  5B 63 68 61          .byte "[char]"
004236r 3  72 5D        
004238r 3               
004238r 3               nt_char:
004238r 3  04 00                .byte 4, 0
00423Ar 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
00423Er 3  rr rr        
004240r 3  63 68 61 72          .byte "char"
004244r 3               
004244r 3               nt_pick:
004244r 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
004246r 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
00424Ar 3  rr rr        
00424Cr 3  70 69 63 6B          .byte "pick"
004250r 3               
004250r 3               nt_lshift:
004250r 3  06 10                .byte 6, UF
004252r 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
004256r 3  rr rr        
004258r 3  6C 73 68 69          .byte "lshift"
00425Cr 3  66 74        
00425Er 3               
00425Er 3               nt_rshift:
00425Er 3  06 10                .byte 6, UF
004260r 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
004264r 3  rr rr        
004266r 3  72 73 68 69          .byte "rshift"
00426Ar 3  66 74        
00426Cr 3               
00426Cr 3               nt_xor:
00426Cr 3  03 10                .byte 3, UF
00426Er 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
004272r 3  rr rr        
004274r 3  78 6F 72             .byte "xor"
004277r 3               
004277r 3               nt_or:
004277r 3  02 10                .byte 2, UF
004279r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
00427Dr 3  rr rr        
00427Fr 3  6F 72                .byte "or"
004281r 3               
004281r 3               nt_and:
004281r 3  03 10                .byte 3, UF
004283r 3  rr rr rr rr          .word nt_or, xt_and, z_and
004287r 3  rr rr        
004289r 3  61 6E 64             .byte "and"
00428Cr 3               
00428Cr 3               nt_dabs:
00428Cr 3  04 10                .byte 4, UF
00428Er 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
004292r 3  rr rr        
004294r 3  64 61 62 73          .byte "dabs"
004298r 3               
004298r 3               nt_abs:
004298r 3  03 10                .byte 3, UF
00429Ar 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
00429Er 3  rr rr        
0042A0r 3  61 62 73             .byte "abs"
0042A3r 3               
0042A3r 3               nt_minus:
0042A3r 3  01 10                .byte 1, UF
0042A5r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
0042A9r 3  rr rr        
0042ABr 3  2D                   .byte "-"
0042ACr 3               
0042ACr 3               nt_plus:
0042ACr 3  01 10                .byte 1, UF
0042AEr 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
0042B2r 3  rr rr        
0042B4r 3  2B                   .byte "+"
0042B5r 3               
0042B5r 3               nt_question_dup:
0042B5r 3  04 10                .byte 4, UF
0042B7r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
0042BBr 3  rr rr        
0042BDr 3  3F 64 75 70          .byte "?dup"
0042C1r 3               
0042C1r 3               nt_two_dup:
0042C1r 3  04 10                .byte 4, UF
0042C3r 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
0042C7r 3  rr rr        
0042C9r 3  32 64 75 70          .byte "2dup"
0042CDr 3               
0042CDr 3               nt_two:
0042CDr 3  01 00                .byte 1, 0
0042CFr 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
0042D3r 3  rr rr        
0042D5r 3  32                   .byte "2"
0042D6r 3               
0042D6r 3               nt_one:
0042D6r 3  01 00                .byte 1, 0
0042D8r 3  rr rr rr rr          .word nt_two, xt_one, z_one
0042DCr 3  rr rr        
0042DEr 3  31                   .byte "1"
0042DFr 3               
0042DFr 3               nt_zero:
0042DFr 3  01 00                .byte 1, 0
0042E1r 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
0042E5r 3  rr rr        
0042E7r 3  30                   .byte "0"
0042E8r 3               
0042E8r 3               nt_space:
0042E8r 3  05 00                .byte 5, 0
0042EAr 3  rr rr rr rr          .word nt_zero, xt_space, z_space
0042EEr 3  rr rr        
0042F0r 3  73 70 61 63          .byte "space"
0042F4r 3  65           
0042F5r 3               
0042F5r 3               nt_true:
0042F5r 3  04 00                .byte 4, 0
0042F7r 3  rr rr rr rr          .word nt_space, xt_true, z_true
0042FBr 3  rr rr        
0042FDr 3  74 72 75 65          .byte "true"
004301r 3               
004301r 3               nt_false:
004301r 3  05 00                .byte 5, 0
004303r 3  rr rr rr rr          .word nt_true, xt_false, z_false
004307r 3  rr rr        
004309r 3  66 61 6C 73          .byte "false"
00430Dr 3  65           
00430Er 3               
00430Er 3               nt_question:
00430Er 3  01 00                .byte 1, 0
004310r 3  rr rr rr rr          .word nt_false, xt_question, z_question
004314r 3  rr rr        
004316r 3  3F                   .byte "?"
004317r 3               
004317r 3               nt_ud_dot_r:
004317r 3  04 10                .byte 4, UF
004319r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
00431Dr 3  rr rr        
00431Fr 3  75 64 2E 72          .byte "ud.r"
004323r 3               
004323r 3               nt_ud_dot:
004323r 3  03 10                .byte 3, UF
004325r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
004329r 3  rr rr        
00432Br 3  75 64 2E             .byte "ud."
00432Er 3               
00432Er 3               nt_d_dot_r:
00432Er 3  03 10                .byte 3, UF
004330r 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
004334r 3  rr rr        
004336r 3  64 2E 72             .byte "d.r"
004339r 3               
004339r 3               nt_d_dot:
004339r 3  02 10                .byte 2, UF
00433Br 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
00433Fr 3  rr rr        
004341r 3  64 2E                .byte "d."
004343r 3               
004343r 3               nt_dot_r:
004343r 3  02 10                .byte 2, UF
004345r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
004349r 3  rr rr        
00434Br 3  2E 72                .byte ".r"
00434Dr 3               
00434Dr 3               nt_u_dot_r:
00434Dr 3  03 10                .byte 3, UF
00434Fr 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
004353r 3  rr rr        
004355r 3  75 2E 72             .byte "u.r"
004358r 3               
004358r 3               nt_u_dot:
004358r 3  02 10                .byte 2, UF
00435Ar 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
00435Er 3  rr rr        
004360r 3  75 2E                .byte "u."
004362r 3               
004362r 3               nt_dot:
004362r 3  01 10                .byte 1, UF
004364r 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
004368r 3  rr rr        
00436Ar 3  2E                   .byte "."
00436Br 3               
00436Br 3               nt_type:
00436Br 3  04 10                .byte 4, UF
00436Dr 3  rr rr rr rr          .word nt_dot, xt_type, z_type
004371r 3  rr rr        
004373r 3  74 79 70 65          .byte "type"
004377r 3               
004377r 3               nt_emit:
004377r 3  04 18                .byte 4, NN+UF
004379r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
00437Dr 3  rr rr        
00437Fr 3  65 6D 69 74          .byte "emit"
004383r 3               
004383r 3               nt_execute:
004383r 3  07 10                .byte 7, UF
004385r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
004389r 3  rr rr        
00438Br 3  65 78 65 63          .byte "execute"
00438Fr 3  75 74 65     
004392r 3               
004392r 3               nt_plus_store:
004392r 3  02 10                .byte 2, UF
004394r 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
004398r 3  rr rr        
00439Ar 3  2B 21                .byte "+!"
00439Cr 3               
00439Cr 3               nt_c_store:
00439Cr 3  02 10                .byte 2, UF
00439Er 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
0043A2r 3  rr rr        
0043A4r 3  63 21                .byte "c!"
0043A6r 3               
0043A6r 3               nt_c_fetch:
0043A6r 3  02 10                .byte 2, UF
0043A8r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
0043ACr 3  rr rr        
0043AEr 3  63 40                .byte "c@"
0043B0r 3               
0043B0r 3               nt_comma:
0043B0r 3  01 10                .byte 1, UF
0043B2r 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
0043B6r 3  rr rr        
0043B8r 3  2C                   .byte ","
0043B9r 3               
0043B9r 3               nt_tuck:
0043B9r 3  04 10                .byte 4, UF
0043BBr 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
0043BFr 3  rr rr        
0043C1r 3  74 75 63 6B          .byte "tuck"
0043C5r 3               
0043C5r 3               nt_not_rote:
0043C5r 3  04 10                .byte 4, UF
0043C7r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
0043CBr 3  rr rr        
0043CDr 3  2D 72 6F 74          .byte "-rot"
0043D1r 3               
0043D1r 3               nt_rot:
0043D1r 3  03 10                .byte 3, UF
0043D3r 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
0043D7r 3  rr rr        
0043D9r 3  72 6F 74             .byte "rot"
0043DCr 3               
0043DCr 3               nt_nip:
0043DCr 3  03 10                .byte 3, UF
0043DEr 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
0043E2r 3  rr rr        
0043E4r 3  6E 69 70             .byte "nip"
0043E7r 3               
0043E7r 3               nt_r_fetch:
0043E7r 3  02 01                .byte 2, CO    ; native is special case
0043E9r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
0043EDr 3  rr rr        
0043EFr 3  72 40                .byte "r@"
0043F1r 3               
0043F1r 3               nt_r_from:
0043F1r 3  02 01                .byte 2, CO    ; native is special case
0043F3r 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
0043F7r 3  rr rr        
0043F9r 3  72 3E                .byte "r>"
0043FBr 3               
0043FBr 3               nt_to_r:
0043FBr 3  02 11                .byte 2, CO+UF ; native is special case
0043FDr 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
004401r 3  rr rr        
004403r 3  3E 72                .byte ">r"
004405r 3               
004405r 3               nt_over:
004405r 3  04 10                .byte 4, UF
004407r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
00440Br 3  rr rr        
00440Dr 3  6F 76 65 72          .byte "over"
004411r 3               
004411r 3               nt_fetch:
004411r 3  01 10                .byte 1, UF
004413r 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
004417r 3  rr rr        
004419r 3  40                   .byte "@"
00441Ar 3               
00441Ar 3               nt_store:
00441Ar 3  01 10                .byte 1, UF
00441Cr 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
004420r 3  rr rr        
004422r 3  21                   .byte "!"
004423r 3               
004423r 3               nt_swap:
004423r 3  04 10                .byte 4, UF
004425r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
004429r 3  rr rr        
00442Br 3  73 77 61 70          .byte "swap"
00442Fr 3               
00442Fr 3               nt_dup:
00442Fr 3  03 10                .byte 3, UF
004431r 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
004435r 3  rr rr        
004437r 3  64 75 70             .byte "dup"
00443Ar 3               
00443Ar 3               ; DROP is always the first native word in the Dictionary
00443Ar 3               dictionary_start:
00443Ar 3               nt_drop:
00443Ar 3  04 10                .byte 4, UF
00443Cr 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
004440r 3  rr rr        
004442r 3  64 72 6F 70          .byte "drop"
004446r 3               
004446r 3               ; END of FORTH-WORDLIST
004446r 3               
004446r 3               
004446r 3               ; ROOT-WORDLIST
004446r 3                       ; This is a short wordlist that has just the words needed to
004446r 3                       ; set the wordlists. These words are also included in the
004446r 3                       ; FORTH-WORDLIST as well.
004446r 3               
004446r 3               nt_root_words:
004446r 3  05 00                .byte 5, 0
004448r 3  00 00 rr rr          .word 0000, xt_words, z_words
00444Cr 3  rr rr        
00444Er 3  77 6F 72 64          .byte "words"
004452r 3  73           
004453r 3               
004453r 3               nt_root_forth_wordlist: ; shares code with ZERO
004453r 3  0E 00                .byte 14, 0
004455r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
004459r 3  rr rr        
00445Br 3  66 6F 72 74          .byte "forth-wordlist"
00445Fr 3  68 2D 77 6F  
004463r 3  72 64 6C 69  
004469r 3               
004469r 3               nt_root_forth:
004469r 3  05 00                .byte 5, 0
00446Br 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
00446Fr 3  rr rr        
004471r 3  66 6F 72 74          .byte "forth"
004475r 3  68           
004476r 3               
004476r 3               root_dictionary_start:
004476r 3               nt_root_set_order:
004476r 3  09 00                .byte 9, 0
004478r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
00447Cr 3  rr rr        
00447Er 3  73 65 74 2D          .byte "set-order"
004482r 3  6F 72 64 65  
004486r 3  72           
004487r 3               
004487r 3               ; END of ROOT-WORDLIST
004487r 3               
004487r 3               
004487r 3               ; ; EDITOR-WORDLIST
004487r 3               
004487r 3               ; nt_editor_enter_screen:
004487r 3               ;         .byte 12, 0
004487r 3               ;         .word 0000, xt_editor_enter_screen, z_editor_enter_screen
004487r 3               ;         .byte "enter-screen"
004487r 3               
004487r 3               ; nt_editor_erase_screen:
004487r 3               ;         .byte 12, 0
004487r 3               ;         .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
004487r 3               ;         .byte "erase-screen"
004487r 3               
004487r 3               ; nt_editor_el:
004487r 3               ;         .byte 2, 0
004487r 3               ;         .word nt_editor_erase_screen, xt_editor_el, z_editor_el
004487r 3               ;         .byte "el"
004487r 3               
004487r 3               ; nt_editor_l:
004487r 3               ;         .byte 1, 0
004487r 3               ;         .word nt_editor_el, xt_editor_l, z_editor_l
004487r 3               ;         .byte "l"
004487r 3               
004487r 3               ; nt_editor_line:
004487r 3               ;         .byte 4, UF
004487r 3               ;         .word nt_editor_l, xt_editor_line, z_editor_line
004487r 3               ;         .byte "line"
004487r 3               
004487r 3               editor_dictionary_start:
004487r 3               ; nt_editor_o:
004487r 3               ;         .byte 1, 0
004487r 3               ;         .word nt_editor_line, xt_editor_o, z_editor_o
004487r 3               ;         .byte "o"
004487r 3               
004487r 3               ; ; END of EDITOR-WORDLIST
004487r 3               
004487r 3               
004487r 3               ; ; ASSEMBLER-WORDLIST
004487r 3               
004487r 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
004487r 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
004487r 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
004487r 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
004487r 3               assembler_dictionary_start:
004487r 3               ; nt_asm_adc_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_adc_x
004487r 3               ; 		.word xt_asm_adc_h, z_asm_adc_h
004487r 3               ; 		.byte "adc.#"
004487r 3               
004487r 3               ; nt_asm_adc_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_adc_y
004487r 3               ; 		.word xt_asm_adc_x, z_asm_adc_x
004487r 3               ; 		.byte "adc.x"
004487r 3               
004487r 3               ; nt_asm_adc_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_adc_z
004487r 3               ; 		.word xt_asm_adc_y, z_asm_adc_y
004487r 3               ; 		.byte "adc.y"
004487r 3               
004487r 3               ; nt_asm_adc_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_adc_zi
004487r 3               ; 		.word xt_asm_adc_z, z_asm_adc_z
004487r 3               ; 		.byte "adc.z"
004487r 3               
004487r 3               ; nt_asm_adc_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_adc_ziy
004487r 3               ; 		.word xt_asm_adc_zi, z_asm_adc_zi
004487r 3               ; 		.byte "adc.zi"
004487r 3               
004487r 3               ; nt_asm_adc_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_adc_zx
004487r 3               ; 		.word xt_asm_adc_ziy, z_asm_adc_ziy
004487r 3               ; 		.byte "adc.ziy"
004487r 3               
004487r 3               ; nt_asm_adc_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_adc_zxi
004487r 3               ; 		.word xt_asm_adc_zx, z_asm_adc_zx
004487r 3               ; 		.byte "adc.zx"
004487r 3               
004487r 3               ; nt_asm_adc_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_and
004487r 3               ; 		.word xt_asm_adc_zxi, z_asm_adc_zxi
004487r 3               ; 		.byte "adc.zxi"
004487r 3               
004487r 3               ; nt_asm_and:     ; not "and" because of conflicts with Forth word
004487r 3               ; 		.byte 4, IM
004487r 3               ;                 .word nt_asm_and_h
004487r 3               ; 		.word xt_asm_and, z_asm_and
004487r 3               ; 		.byte "and."
004487r 3               
004487r 3               ; nt_asm_and_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_and_x
004487r 3               ; 		.word xt_asm_and_h, z_asm_and_h
004487r 3               ; 		.byte "and.#"
004487r 3               
004487r 3               ; nt_asm_and_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_and_y
004487r 3               ; 		.word xt_asm_and_x, z_asm_and_x
004487r 3               ; 		.byte "and.x"
004487r 3               
004487r 3               ; nt_asm_and_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_and_z
004487r 3               ; 		.word xt_asm_and_y, z_asm_and_y
004487r 3               ; 		.byte "and.y"
004487r 3               
004487r 3               ; nt_asm_and_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_and_zi
004487r 3               ; 		.word xt_asm_and_z, z_asm_and_z
004487r 3               ; 		.byte "and.z"
004487r 3               
004487r 3               ; nt_asm_and_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_and_ziy
004487r 3               ; 		.word xt_asm_and_zi, z_asm_and_zi
004487r 3               ; 		.byte "and.zi"
004487r 3               
004487r 3               ; nt_asm_and_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_and_zx
004487r 3               ; 		.word xt_asm_and_ziy, z_asm_and_ziy
004487r 3               ; 		.byte "and.ziy"
004487r 3               
004487r 3               ; nt_asm_and_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_and_zxi
004487r 3               ; 		.word xt_asm_and_zx, z_asm_and_zx
004487r 3               ; 		.byte "and.zx"
004487r 3               
004487r 3               ; nt_asm_and_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_asl
004487r 3               ; 		.word xt_asm_and_zxi, z_asm_and_zxi
004487r 3               ; 		.byte "and.zxi"
004487r 3               
004487r 3               ; nt_asm_asl:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_asl_a
004487r 3               ; 		.word xt_asm_asl, z_asm_asl
004487r 3               ; 		.byte "asl"
004487r 3               
004487r 3               ; nt_asm_asl_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_asl_x
004487r 3               ; 		.word xt_asm_asl_a, z_asm_asl_a
004487r 3               ; 		.byte "asl.a"
004487r 3               
004487r 3               ; nt_asm_asl_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_asl_z
004487r 3               ; 		.word xt_asm_asl_x, z_asm_asl_x
004487r 3               ; 		.byte "asl.x"
004487r 3               
004487r 3               ; nt_asm_asl_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_asl_zx
004487r 3               ; 		.word xt_asm_asl_z, z_asm_asl_z
004487r 3               ; 		.byte "asl.z"
004487r 3               
004487r 3               ; nt_asm_asl_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_bcc
004487r 3               ; 		.word xt_asm_asl_zx, z_asm_asl_zx
004487r 3               ; 		.byte "asl.zx"
004487r 3               
004487r 3               ; nt_asm_bcc:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bcs
004487r 3               ; 		.word xt_asm_bcc, z_asm_bcc
004487r 3               ; 		.byte "bcc"
004487r 3               
004487r 3               ; nt_asm_bcs:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_beq
004487r 3               ; 		.word xt_asm_bcs, z_asm_bcs
004487r 3               ; 		.byte "bcs"
004487r 3               
004487r 3               ; nt_asm_beq:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bit
004487r 3               ; 		.word xt_asm_beq, z_asm_beq
004487r 3               ; 		.byte "beq"
004487r 3               
004487r 3               ; nt_asm_bit:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bit_h
004487r 3               ; 		.word xt_asm_bit, z_asm_bit
004487r 3               ; 		.byte "bit"
004487r 3               
004487r 3               ; nt_asm_bit_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_bit_x
004487r 3               ; 		.word xt_asm_bit_h, z_asm_bit_h
004487r 3               ; 		.byte "bit.#"
004487r 3               
004487r 3               ; nt_asm_bit_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_bit_z
004487r 3               ; 		.word xt_asm_bit_x, z_asm_bit_x
004487r 3               ; 		.byte "bit.x"
004487r 3               
004487r 3               ; nt_asm_bit_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_bit_zx
004487r 3               ; 		.word xt_asm_bit_z, z_asm_bit_z
004487r 3               ; 		.byte "bit.z"
004487r 3               
004487r 3               ; nt_asm_bit_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_bmi
004487r 3               ; 		.word xt_asm_bit_zx, z_asm_bit_zx
004487r 3               ; 		.byte "bit.zx"
004487r 3               
004487r 3               ; nt_asm_bmi:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bne
004487r 3               ; 		.word xt_asm_bmi, z_asm_bmi
004487r 3               ; 		.byte "bmi"
004487r 3               
004487r 3               ; nt_asm_bne:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bpl
004487r 3               ; 		.word xt_asm_bne, z_asm_bne
004487r 3               ; 		.byte "bne"
004487r 3               
004487r 3               ; nt_asm_bpl:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bra
004487r 3               ; 		.word xt_asm_bpl, z_asm_bpl
004487r 3               ; 		.byte "bpl"
004487r 3               
004487r 3               ; nt_asm_bra:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_brk
004487r 3               ; 		.word xt_asm_bra, z_asm_bra
004487r 3               ; 		.byte "bra"
004487r 3               
004487r 3               ; nt_asm_brk:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bvc
004487r 3               ; 		.word xt_asm_brk, z_asm_brk
004487r 3               ; 		.byte "brk"
004487r 3               
004487r 3               ; nt_asm_bvc:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_bvs
004487r 3               ; 		.word xt_asm_bvc, z_asm_bvc
004487r 3               ; 		.byte "bvc"
004487r 3               
004487r 3               ; nt_asm_bvs:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_clc
004487r 3               ; 		.word xt_asm_bvs, z_asm_bvs
004487r 3               ; 		.byte "bvs"
004487r 3               
004487r 3               ; nt_asm_clc:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cld
004487r 3               ; 		.word xt_asm_clc, z_asm_clc
004487r 3               ; 		.byte "clc"
004487r 3               
004487r 3               ; nt_asm_cld:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cli
004487r 3               ; 		.word xt_asm_cld, z_asm_cld
004487r 3               ; 		.byte "cld"
004487r 3               
004487r 3               ; nt_asm_cli:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_clv
004487r 3               ; 		.word xt_asm_cli, z_asm_cli
004487r 3               ; 		.byte "cli"
004487r 3               
004487r 3               ; nt_asm_clv:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cmp
004487r 3               ; 		.word xt_asm_clv, z_asm_clv
004487r 3               ; 		.byte "clv"
004487r 3               
004487r 3               ; nt_asm_cmp:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cmp_h
004487r 3               ; 		.word xt_asm_cmp, z_asm_cmp
004487r 3               ; 		.byte "cmp"
004487r 3               
004487r 3               ; nt_asm_cmp_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cmp_x
004487r 3               ; 		.word xt_asm_cmp_h, z_asm_cmp_h
004487r 3               ; 		.byte "cmp.#"
004487r 3               
004487r 3               ; nt_asm_cmp_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cmp_y
004487r 3               ; 		.word xt_asm_cmp_x, z_asm_cmp_x
004487r 3               ; 		.byte "cmp.x"
004487r 3               
004487r 3               ; nt_asm_cmp_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cmp_z
004487r 3               ; 		.word xt_asm_cmp_y, z_asm_cmp_y
004487r 3               ; 		.byte "cmp.y"
004487r 3               
004487r 3               ; nt_asm_cmp_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cmp_zi
004487r 3               ; 		.word xt_asm_cmp_z, z_asm_cmp_z
004487r 3               ; 		.byte "cmp.z"
004487r 3               
004487r 3               ; nt_asm_cmp_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_cmp_ziy
004487r 3               ; 		.word xt_asm_cmp_zi, z_asm_cmp_zi
004487r 3               ; 		.byte "cmp.zi"
004487r 3               
004487r 3               ; nt_asm_cmp_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_cmp_zx
004487r 3               ; 		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
004487r 3               ; 		.byte "cmp.ziy"
004487r 3               
004487r 3               ; nt_asm_cmp_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_cmp_zxi
004487r 3               ; 		.word xt_asm_cmp_zx, z_asm_cmp_zx
004487r 3               ; 		.byte "cmp.zx"
004487r 3               
004487r 3               ; nt_asm_cmp_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_cpx
004487r 3               ; 		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
004487r 3               ; 		.byte "cmp.zxi"
004487r 3               
004487r 3               ; nt_asm_cpx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cpx_h
004487r 3               ; 		.word xt_asm_cpx, z_asm_cpx
004487r 3               ; 		.byte "cpx"
004487r 3               
004487r 3               ; nt_asm_cpx_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cpx_z
004487r 3               ; 		.word xt_asm_cpx_h, z_asm_cpx_h
004487r 3               ; 		.byte "cpx.#"
004487r 3               
004487r 3               ; nt_asm_cpx_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cpy
004487r 3               ; 		.word xt_asm_cpx_z, z_asm_cpx_z
004487r 3               ; 		.byte "cpx.z"
004487r 3               
004487r 3               ; nt_asm_cpy:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_cpy_h
004487r 3               ; 		.word xt_asm_cpy, z_asm_cpy
004487r 3               ; 		.byte "cpy"
004487r 3               
004487r 3               ; nt_asm_cpy_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_cpy_z
004487r 3               ; 		.word xt_asm_cpy_h, z_asm_cpy_h
004487r 3               ; 		.byte "cpy.#"
004487r 3               
004487r 3               ; nt_asm_cpy_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_dec
004487r 3               ; 		.word xt_asm_cpy_z, z_asm_cpy_z
004487r 3               ; 		.byte "cpy.z"
004487r 3               
004487r 3               ; nt_asm_dec:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_dec_a
004487r 3               ; 		.word xt_asm_dec, z_asm_dec
004487r 3               ; 		.byte "dec"
004487r 3               
004487r 3               ; nt_asm_dec_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_dec_x
004487r 3               ; 		.word xt_asm_dec_a, z_asm_dec_a
004487r 3               ; 		.byte "dec.a"
004487r 3               
004487r 3               ; nt_asm_dec_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_dec_z
004487r 3               ; 		.word xt_asm_dec_x, z_asm_dec_x
004487r 3               ; 		.byte "dec.x"
004487r 3               
004487r 3               ; nt_asm_dec_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_dec_zx
004487r 3               ; 		.word xt_asm_dec_z, z_asm_dec_z
004487r 3               ; 		.byte "dec.z"
004487r 3               
004487r 3               ; nt_asm_dec_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_dex
004487r 3               ; 		.word xt_asm_dec_zx, z_asm_dec_zx
004487r 3               ; 		.byte "dec.zx"
004487r 3               
004487r 3               ; nt_asm_dex:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_dey
004487r 3               ; 		.word xt_asm_dex, z_asm_dex
004487r 3               ; 		.byte "dex"
004487r 3               
004487r 3               ; nt_asm_dey:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_eor
004487r 3               ; 		.word xt_asm_dey, z_asm_dey
004487r 3               ; 		.byte "dey"
004487r 3               
004487r 3               ; nt_asm_eor:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_eor_h
004487r 3               ; 		.word xt_asm_eor, z_asm_eor
004487r 3               ; 		.byte "eor"
004487r 3               
004487r 3               ; nt_asm_eor_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_eor_x
004487r 3               ; 		.word xt_asm_eor_h, z_asm_eor_h
004487r 3               ; 		.byte "eor.#"
004487r 3               
004487r 3               ; nt_asm_eor_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_eor_y
004487r 3               ; 		.word xt_asm_eor_x, z_asm_eor_x
004487r 3               ; 		.byte "eor.x"
004487r 3               
004487r 3               ; nt_asm_eor_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_eor_z
004487r 3               ; 		.word xt_asm_eor_y, z_asm_eor_y
004487r 3               ; 		.byte "eor.y"
004487r 3               
004487r 3               ; nt_asm_eor_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_eor_zi
004487r 3               ; 		.word xt_asm_eor_z, z_asm_eor_z
004487r 3               ; 		.byte "eor.z"
004487r 3               
004487r 3               ; nt_asm_eor_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_eor_ziy
004487r 3               ; 		.word xt_asm_eor_zi, z_asm_eor_zi
004487r 3               ; 		.byte "eor.zi"
004487r 3               
004487r 3               ; nt_asm_eor_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_eor_zx
004487r 3               ; 		.word xt_asm_eor_ziy, z_asm_eor_ziy
004487r 3               ; 		.byte "eor.ziy"
004487r 3               
004487r 3               ; nt_asm_eor_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_eor_zxi
004487r 3               ; 		.word xt_asm_eor_zx, z_asm_eor_zx
004487r 3               ; 		.byte "eor.zx"
004487r 3               
004487r 3               ; nt_asm_eor_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_inc
004487r 3               ; 		.word xt_asm_eor_zxi, z_asm_eor_zxi
004487r 3               ; 		.byte "eor.zxi"
004487r 3               
004487r 3               ; nt_asm_inc:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_inc_a
004487r 3               ; 		.word xt_asm_inc, z_asm_inc
004487r 3               ; 		.byte "inc"
004487r 3               
004487r 3               ; nt_asm_inc_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_inc_x
004487r 3               ; 		.word xt_asm_inc_a, z_asm_inc_a
004487r 3               ; 		.byte "inc.a"
004487r 3               
004487r 3               ; nt_asm_inc_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_inc_z
004487r 3               ; 		.word xt_asm_inc_x, z_asm_inc_x
004487r 3               ; 		.byte "inc.x"
004487r 3               
004487r 3               ; nt_asm_inc_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_inc_zx
004487r 3               ; 		.word xt_asm_inc_z, z_asm_inc_z
004487r 3               ; 		.byte "inc.z"
004487r 3               
004487r 3               ; nt_asm_inc_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_inx
004487r 3               ; 		.word xt_asm_inc_zx, z_asm_inc_zx
004487r 3               ; 		.byte "inc.zx"
004487r 3               
004487r 3               ; nt_asm_inx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_iny
004487r 3               ; 		.word xt_asm_inx, z_asm_inx
004487r 3               ; 		.byte "inx"
004487r 3               
004487r 3               ; nt_asm_iny:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_jmp
004487r 3               ; 		.word xt_asm_iny, z_asm_iny
004487r 3               ; 		.byte "iny"
004487r 3               
004487r 3               ; nt_asm_jmp:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_jmp_i
004487r 3               ; 		.word xt_asm_jmp, z_asm_jmp
004487r 3               ; 		.byte "jmp"
004487r 3               
004487r 3               ; nt_asm_jmp_i:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_jmp_xi
004487r 3               ; 		.word xt_asm_jmp_i, z_asm_jmp_i
004487r 3               ; 		.byte "jmp.i"
004487r 3               
004487r 3               ; nt_asm_jmp_xi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_jsr
004487r 3               ; 		.word xt_asm_jmp_xi, z_asm_jmp_xi
004487r 3               ; 		.byte "jmp.xi"
004487r 3               
004487r 3               ; nt_asm_jsr:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_lda
004487r 3               ; 		.word xt_asm_jsr, z_asm_jsr
004487r 3               ; 		.byte "jsr"
004487r 3               
004487r 3               ; nt_asm_lda:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_lda_h
004487r 3               ; 		.word xt_asm_lda, z_asm_lda
004487r 3               ; 		.byte "lda"
004487r 3               
004487r 3               ; nt_asm_lda_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lda_x
004487r 3               ; 		.word xt_asm_lda_h, z_asm_lda_h
004487r 3               ; 		.byte "lda.#"
004487r 3               
004487r 3               ; nt_asm_lda_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lda_y
004487r 3               ; 		.word xt_asm_lda_x, z_asm_lda_x
004487r 3               ; 		.byte "lda.x"
004487r 3               
004487r 3               ; nt_asm_lda_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lda_z
004487r 3               ; 		.word xt_asm_lda_y, z_asm_lda_y
004487r 3               ; 		.byte "lda.y"
004487r 3               
004487r 3               ; nt_asm_lda_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lda_zi
004487r 3               ; 		.word xt_asm_lda_z, z_asm_lda_z
004487r 3               ; 		.byte "lda.z"
004487r 3               
004487r 3               ; nt_asm_lda_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_lda_ziy
004487r 3               ; 		.word xt_asm_lda_zi, z_asm_lda_zi
004487r 3               ; 		.byte "lda.zi"
004487r 3               
004487r 3               ; nt_asm_lda_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_lda_zx
004487r 3               ; 		.word xt_asm_lda_ziy, z_asm_lda_ziy
004487r 3               ; 		.byte "lda.ziy"
004487r 3               
004487r 3               ; nt_asm_lda_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_lda_zxi
004487r 3               ; 		.word xt_asm_lda_zx, z_asm_lda_zx
004487r 3               ; 		.byte "lda.zx"
004487r 3               
004487r 3               ; nt_asm_lda_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_ldx
004487r 3               ; 		.word xt_asm_lda_zxi, z_asm_lda_zxi
004487r 3               ; 		.byte "lda.zxi"
004487r 3               
004487r 3               ; nt_asm_ldx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ldx_h
004487r 3               ; 		.word xt_asm_ldx, z_asm_ldx
004487r 3               ; 		.byte "ldx"
004487r 3               
004487r 3               ; nt_asm_ldx_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldx_y
004487r 3               ; 		.word xt_asm_ldx_h, z_asm_ldx_h
004487r 3               ; 		.byte "ldx.#"
004487r 3               
004487r 3               ; nt_asm_ldx_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldx_z
004487r 3               ; 		.word xt_asm_ldx_y, z_asm_ldx_y
004487r 3               ; 		.byte "ldx.y"
004487r 3               
004487r 3               ; nt_asm_ldx_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldx_zy
004487r 3               ; 		.word xt_asm_ldx_z, z_asm_ldx_z
004487r 3               ; 		.byte "ldx.z"
004487r 3               
004487r 3               ; nt_asm_ldx_zy:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_ldy
004487r 3               ; 		.word xt_asm_ldx_zy, z_asm_ldx_zy
004487r 3               ; 		.byte "ldx.zy"
004487r 3               
004487r 3               ; nt_asm_ldy:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ldy_h
004487r 3               ; 		.word xt_asm_ldy, z_asm_ldy
004487r 3               ; 		.byte "ldy"
004487r 3               
004487r 3               ; nt_asm_ldy_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldy_x
004487r 3               ; 		.word xt_asm_ldy_h, z_asm_ldy_h
004487r 3               ; 		.byte "ldy.#"
004487r 3               
004487r 3               ; nt_asm_ldy_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldy_z
004487r 3               ; 		.word xt_asm_ldy_x, z_asm_ldy_x
004487r 3               ; 		.byte "ldy.x"
004487r 3               
004487r 3               ; nt_asm_ldy_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ldy_zx
004487r 3               ; 		.word xt_asm_ldy_z, z_asm_ldy_z
004487r 3               ; 		.byte "ldy.z"
004487r 3               
004487r 3               ; nt_asm_ldy_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_lsr
004487r 3               ; 		.word xt_asm_ldy_zx, z_asm_ldy_zx
004487r 3               ; 		.byte "ldy.zx"
004487r 3               
004487r 3               ; nt_asm_lsr:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_lsr_a
004487r 3               ; 		.word xt_asm_lsr, z_asm_lsr
004487r 3               ; 		.byte "lsr"
004487r 3               
004487r 3               ; nt_asm_lsr_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lsr_x
004487r 3               ; 		.word xt_asm_lsr_a, z_asm_lsr_a
004487r 3               ; 		.byte "lsr.a"
004487r 3               
004487r 3               ; nt_asm_lsr_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lsr_z
004487r 3               ; 		.word xt_asm_lsr_x, z_asm_lsr_x
004487r 3               ; 		.byte "lsr.x"
004487r 3               
004487r 3               ; nt_asm_lsr_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_lsr_zx
004487r 3               ; 		.word xt_asm_lsr_z, z_asm_lsr_z
004487r 3               ; 		.byte "lsr.z"
004487r 3               
004487r 3               ; nt_asm_lsr_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_nop
004487r 3               ; 		.word xt_asm_lsr_zx, z_asm_lsr_zx
004487r 3               ; 		.byte "lsr.zx"
004487r 3               
004487r 3               ; nt_asm_nop:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ora
004487r 3               ; 		.word xt_asm_nop, z_asm_nop
004487r 3               ; 		.byte "nop"
004487r 3               
004487r 3               ; nt_asm_ora:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ora_h
004487r 3               ; 		.word xt_asm_ora, z_asm_ora
004487r 3               ; 		.byte "ora"
004487r 3               
004487r 3               ; nt_asm_ora_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ora_x
004487r 3               ; 		.word xt_asm_ora_h, z_asm_ora_h
004487r 3               ; 		.byte "ora.#"
004487r 3               
004487r 3               ; nt_asm_ora_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ora_y
004487r 3               ; 		.word xt_asm_ora_x, z_asm_ora_x
004487r 3               ; 		.byte "ora.x"
004487r 3               
004487r 3               ; nt_asm_ora_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ora_z
004487r 3               ; 		.word xt_asm_ora_y, z_asm_ora_y
004487r 3               ; 		.byte "ora.y"
004487r 3               
004487r 3               ; nt_asm_ora_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ora_zi
004487r 3               ; 		.word xt_asm_ora_z, z_asm_ora_z
004487r 3               ; 		.byte "ora.z"
004487r 3               
004487r 3               ; nt_asm_ora_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_ora_ziy
004487r 3               ; 		.word xt_asm_ora_zi, z_asm_ora_zi
004487r 3               ; 		.byte "ora.zi"
004487r 3               
004487r 3               ; nt_asm_ora_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_ora_zx
004487r 3               ; 		.word xt_asm_ora_ziy, z_asm_ora_ziy
004487r 3               ; 		.byte "ora.ziy"
004487r 3               
004487r 3               ; nt_asm_ora_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_ora_zxi
004487r 3               ; 		.word xt_asm_ora_zx, z_asm_ora_zx
004487r 3               ; 		.byte "ora.zx"
004487r 3               
004487r 3               ; nt_asm_ora_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_pha
004487r 3               ; 		.word xt_asm_ora_zxi, z_asm_ora_zxi
004487r 3               ; 		.byte "ora.zxi"
004487r 3               
004487r 3               ; nt_asm_pha:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_php
004487r 3               ; 		.word xt_asm_pha, z_asm_pha
004487r 3               ; 		.byte "pha"
004487r 3               
004487r 3               ; nt_asm_php:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_phx
004487r 3               ; 		.word xt_asm_php, z_asm_php
004487r 3               ; 		.byte "php"
004487r 3               
004487r 3               ; nt_asm_phx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_phy
004487r 3               ; 		.word xt_asm_phx, z_asm_phx
004487r 3               ; 		.byte "phx"
004487r 3               
004487r 3               ; nt_asm_phy:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_pla
004487r 3               ; 		.word xt_asm_phy, z_asm_phy
004487r 3               ; 		.byte "phy"
004487r 3               
004487r 3               ; nt_asm_pla:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_plp
004487r 3               ; 		.word xt_asm_pla, z_asm_pla
004487r 3               ; 		.byte "pla"
004487r 3               
004487r 3               ; nt_asm_plp:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_plx
004487r 3               ; 		.word xt_asm_plp, z_asm_plp
004487r 3               ; 		.byte "plp"
004487r 3               
004487r 3               ; nt_asm_plx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ply
004487r 3               ; 		.word xt_asm_plx, z_asm_plx
004487r 3               ; 		.byte "plx"
004487r 3               
004487r 3               ; nt_asm_ply:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_rol
004487r 3               ; 		.word xt_asm_ply, z_asm_ply
004487r 3               ; 		.byte "ply"
004487r 3               
004487r 3               ; nt_asm_rol:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_rol_a
004487r 3               ; 		.word xt_asm_rol, z_asm_rol
004487r 3               ; 		.byte "rol"
004487r 3               
004487r 3               ; nt_asm_rol_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_rol_x
004487r 3               ; 		.word xt_asm_rol_a, z_asm_rol_a
004487r 3               ; 		.byte "rol.a"
004487r 3               
004487r 3               ; nt_asm_rol_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_rol_z
004487r 3               ; 		.word xt_asm_rol_x, z_asm_rol_x
004487r 3               ; 		.byte "rol.x"
004487r 3               
004487r 3               ; nt_asm_rol_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_rol_zx
004487r 3               ; 		.word xt_asm_rol_z, z_asm_rol_z
004487r 3               ; 		.byte "rol.z"
004487r 3               
004487r 3               ; nt_asm_rol_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_ror
004487r 3               ; 		.word xt_asm_rol_zx, z_asm_rol_zx
004487r 3               ; 		.byte "rol.zx"
004487r 3               
004487r 3               ; nt_asm_ror:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_ror_a
004487r 3               ; 		.word xt_asm_ror, z_asm_ror
004487r 3               ; 		.byte "ror"
004487r 3               
004487r 3               ; nt_asm_ror_a:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ror_x
004487r 3               ; 		.word xt_asm_ror_a, z_asm_ror_a
004487r 3               ; 		.byte "ror.a"
004487r 3               
004487r 3               ; nt_asm_ror_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ror_z
004487r 3               ; 		.word xt_asm_ror_x, z_asm_ror_x
004487r 3               ; 		.byte "ror.x"
004487r 3               
004487r 3               ; nt_asm_ror_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_ror_zx
004487r 3               ; 		.word xt_asm_ror_z, z_asm_ror_z
004487r 3               ; 		.byte "ror.z"
004487r 3               
004487r 3               ; nt_asm_ror_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_rti
004487r 3               ; 		.word xt_asm_ror_zx, z_asm_ror_zx
004487r 3               ; 		.byte "ror.zx"
004487r 3               
004487r 3               ; nt_asm_rti:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_rts
004487r 3               ; 		.word xt_asm_rti, z_asm_rti
004487r 3               ; 		.byte "rti"
004487r 3               
004487r 3               ; nt_asm_rts:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sbc
004487r 3               ; 		.word xt_asm_rts, z_asm_rts
004487r 3               ; 		.byte "rts"
004487r 3               
004487r 3               ; nt_asm_sbc:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sbc_h
004487r 3               ; 		.word xt_asm_sbc, z_asm_sbc
004487r 3               ; 		.byte "sbc"
004487r 3               
004487r 3               ; nt_asm_sbc_h:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sbc_x
004487r 3               ; 		.word xt_asm_sbc_h, z_asm_sbc_h
004487r 3               ; 		.byte "sbc.#"
004487r 3               
004487r 3               ; nt_asm_sbc_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sbc_y
004487r 3               ; 		.word xt_asm_sbc_x, z_asm_sbc_x
004487r 3               ; 		.byte "sbc.x"
004487r 3               
004487r 3               ; nt_asm_sbc_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sbc_z
004487r 3               ; 		.word xt_asm_sbc_y, z_asm_sbc_y
004487r 3               ; 		.byte "sbc.y"
004487r 3               
004487r 3               ; nt_asm_sbc_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sbc_zi
004487r 3               ; 		.word xt_asm_sbc_z, z_asm_sbc_z
004487r 3               ; 		.byte "sbc.z"
004487r 3               
004487r 3               ; nt_asm_sbc_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_sbc_ziy
004487r 3               ; 		.word xt_asm_sbc_zi, z_asm_sbc_zi
004487r 3               ; 		.byte "sbc.zi"
004487r 3               
004487r 3               ; nt_asm_sbc_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_sbc_zx
004487r 3               ; 		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
004487r 3               ; 		.byte "sbc.ziy"
004487r 3               
004487r 3               ; nt_asm_sbc_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_sbc_zxi
004487r 3               ; 		.word xt_asm_sbc_zx, z_asm_sbc_zx
004487r 3               ; 		.byte "sbc.zx"
004487r 3               
004487r 3               ; nt_asm_sbc_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_sec
004487r 3               ; 		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
004487r 3               ; 		.byte "sbc.zxi"
004487r 3               
004487r 3               ; nt_asm_sec:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sed
004487r 3               ; 		.word xt_asm_sec, z_asm_sec
004487r 3               ; 		.byte "sec"
004487r 3               
004487r 3               ; nt_asm_sed:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sei
004487r 3               ; 		.word xt_asm_sed, z_asm_sed
004487r 3               ; 		.byte "sed"
004487r 3               
004487r 3               ; nt_asm_sei:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sta
004487r 3               ; 		.word xt_asm_sei, z_asm_sei
004487r 3               ; 		.byte "sei"
004487r 3               
004487r 3               ; nt_asm_sta:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sta_x
004487r 3               ; 		.word xt_asm_sta, z_asm_sta
004487r 3               ; 		.byte "sta"
004487r 3               
004487r 3               ; nt_asm_sta_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sta_y
004487r 3               ; 		.word xt_asm_sta_x, z_asm_sta_x
004487r 3               ; 		.byte "sta.x"
004487r 3               
004487r 3               ; nt_asm_sta_y:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sta_z
004487r 3               ; 		.word xt_asm_sta_y, z_asm_sta_y
004487r 3               ; 		.byte "sta.y"
004487r 3               
004487r 3               ; nt_asm_sta_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sta_zi
004487r 3               ; 		.word xt_asm_sta_z, z_asm_sta_z
004487r 3               ; 		.byte "sta.z"
004487r 3               
004487r 3               ; nt_asm_sta_zi:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_sta_ziy
004487r 3               ; 		.word xt_asm_sta_zi, z_asm_sta_zi
004487r 3               ; 		.byte "sta.zi"
004487r 3               
004487r 3               ; nt_asm_sta_ziy:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_sta_zx
004487r 3               ; 		.word xt_asm_sta_ziy, z_asm_sta_ziy
004487r 3               ; 		.byte "sta.ziy"
004487r 3               
004487r 3               ; nt_asm_sta_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_sta_zxi
004487r 3               ; 		.word xt_asm_sta_zx, z_asm_sta_zx
004487r 3               ; 		.byte "sta.zx"
004487r 3               
004487r 3               ; nt_asm_sta_zxi:
004487r 3               ; 		.byte 7, IM
004487r 3               ;                 .word nt_asm_stx
004487r 3               ; 		.word xt_asm_sta_zxi, z_asm_sta_zxi
004487r 3               ; 		.byte "sta.zxi"
004487r 3               
004487r 3               ; nt_asm_stx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_stx_z
004487r 3               ; 		.word xt_asm_stx, z_asm_stx
004487r 3               ; 		.byte "stx"
004487r 3               
004487r 3               ; nt_asm_stx_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_stx_zy
004487r 3               ; 		.word xt_asm_stx_z, z_asm_stx_z
004487r 3               ; 		.byte "stx.z"
004487r 3               
004487r 3               ; nt_asm_stx_zy:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_sty
004487r 3               ; 		.word xt_asm_stx_zy, z_asm_stx_zy
004487r 3               ; 		.byte "stx.zy"
004487r 3               
004487r 3               ; nt_asm_sty:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_sty_z
004487r 3               ; 		.word xt_asm_sty, z_asm_sty
004487r 3               ; 		.byte "sty"
004487r 3               
004487r 3               ; nt_asm_sty_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_sty_zx
004487r 3               ; 		.word xt_asm_sty_z, z_asm_sty_z
004487r 3               ; 		.byte "sty.z"
004487r 3               
004487r 3               ; nt_asm_sty_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_stz
004487r 3               ; 		.word xt_asm_sty_zx, z_asm_sty_zx
004487r 3               ; 		.byte "sty.zx"
004487r 3               
004487r 3               ; nt_asm_stz:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_stz_x
004487r 3               ; 		.word xt_asm_stz, z_asm_stz
004487r 3               ; 		.byte "stz"
004487r 3               
004487r 3               ; nt_asm_stz_x:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_stz_z
004487r 3               ; 		.word xt_asm_stz_x, z_asm_stz_x
004487r 3               ; 		.byte "stz.x"
004487r 3               
004487r 3               ; nt_asm_stz_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_stz_zx
004487r 3               ; 		.word xt_asm_stz_z, z_asm_stz_z
004487r 3               ; 		.byte "stz.z"
004487r 3               
004487r 3               ; nt_asm_stz_zx:
004487r 3               ; 		.byte 6, IM
004487r 3               ;                 .word nt_asm_tax
004487r 3               ; 		.word xt_asm_stz_zx, z_asm_stz_zx
004487r 3               ; 		.byte "stz.zx"
004487r 3               
004487r 3               ; nt_asm_tax:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_tay
004487r 3               ; 		.word xt_asm_tax, z_asm_tax
004487r 3               ; 		.byte "tax"
004487r 3               
004487r 3               ; nt_asm_tay:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_trb
004487r 3               ; 		.word xt_asm_tay, z_asm_tay
004487r 3               ; 		.byte "tay"
004487r 3               
004487r 3               ; nt_asm_trb:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_trb_z
004487r 3               ; 		.word xt_asm_trb, z_asm_trb
004487r 3               ; 		.byte "trb"
004487r 3               
004487r 3               ; nt_asm_trb_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_tsb
004487r 3               ; 		.word xt_asm_trb_z, z_asm_trb_z
004487r 3               ; 		.byte "trb.z"
004487r 3               
004487r 3               ; nt_asm_tsb:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_tsb_z
004487r 3               ; 		.word xt_asm_tsb, z_asm_tsb
004487r 3               ; 		.byte "tsb"
004487r 3               
004487r 3               ; nt_asm_tsb_z:
004487r 3               ; 		.byte 5, IM
004487r 3               ;                 .word nt_asm_tsx
004487r 3               ; 		.word xt_asm_tsb_z, z_asm_tsb_z
004487r 3               ; 		.byte "tsb.z"
004487r 3               
004487r 3               ; nt_asm_tsx:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_txa
004487r 3               ; 		.word xt_asm_tsx, z_asm_tsx
004487r 3               ; 		.byte "tsx"
004487r 3               
004487r 3               ; nt_asm_txa:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_txs
004487r 3               ; 		.word xt_asm_txa, z_asm_txa
004487r 3               ; 		.byte "txa"
004487r 3               
004487r 3               ; nt_asm_txs:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_tya
004487r 3               ; 		.word xt_asm_txs, z_asm_txs
004487r 3               ; 		.byte "txs"
004487r 3               
004487r 3               ; nt_asm_tya:
004487r 3               ; 		.byte 3, IM
004487r 3               ;                 .word nt_asm_arrow
004487r 3               ; 		.word xt_asm_tya, z_asm_tya
004487r 3               ; 		.byte "tya"
004487r 3               
004487r 3               ; ; Assembler pseudo-instructions, directives and macros
004487r 3               
004487r 3               ; nt_asm_arrow:   ; uses same code as HERE, but immediate
004487r 3               ;                 .byte 3, IM
004487r 3               ;                 .word nt_asm_back_jump
004487r 3               ;                 .word xt_asm_arrow, z_asm_arrow
004487r 3               ;                 .byte "-->"
004487r 3               
004487r 3               
004487r 3               ; nt_asm_back_jump:  ; syntactic sugar, does nothing
004487r 3               ;                 .byte 2, IM
004487r 3               ;                 .word nt_asm_back_branch
004487r 3               ;                 .word xt_asm_back_jump, z_asm_back_jump
004487r 3               ;                 .byte "<j"
004487r 3               
004487r 3               ; nt_asm_back_branch:
004487r 3               ;                 .byte 2, IM
004487r 3               ;                 .word nt_asm_push_a
004487r 3               ;                 .word xt_asm_back_branch, z_asm_back_branch
004487r 3               ;                 .byte "<b"
004487r 3               
004487r 3               ; nt_asm_push_a:
004487r 3               ;                 .byte 6, IM
004487r 3               ;                 .word 0000
004487r 3               ;                 .word xt_asm_push_a, z_asm_push_a
004487r 3               ;                 .byte "push-a"
004487r 3               
004487r 3               
004487r 3               
004487r 3               ; END of ASSEMBLER-WORDLIST
004487r 3               
004487r 3               ; END
004487r 3               
004487r 2                   .include "strings.s"          ; Headers of native words
004487r 3               ; List of Strings for Tali Forth 2
004487r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004487r 3               ; First version: 01. Apr 2016 (for Liara Forth)
004487r 3               ; This version: 28. Dec 2018
004487r 3               
004487r 3               ; This file is included by taliforth.asm
004487r 3               
004487r 3               ; ## GENERAL STRINGS
004487r 3               
004487r 3               ; All general strings must be zero-terminated, names start with "s_",
004487r 3               ; aliases with "str_"
004487r 3               
004487r 3               str_ok =              0
004487r 3               str_compile =         1
004487r 3               str_redefined =       2
004487r 3               str_wid_forth =       3
004487r 3               str_abc_lower =       4
004487r 3               str_abc_upper =       5
004487r 3               str_wid_editor =      6
004487r 3               str_wid_assembler =   7
004487r 3               str_wid_root =        8
004487r 3               str_see_flags =       9
004487r 3               str_see_nt =         10
004487r 3               str_see_xt =         11
004487r 3               str_see_size =       12
004487r 3               
004487r 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
004487r 3               ; to tables as error and string numbers.
004487r 3               string_table:
004487r 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
00448Br 3  rr rr rr rr  
00448Fr 3  rr rr        
004491r 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
004495r 3  rr rr rr rr  
004499r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
00449Dr 3  rr rr rr rr  
0044A1r 3               
0044A1r 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
0044A5r 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
0044A9r 3  70 69 6C 65  
0044ADr 3  64 00        
0044AFr 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
0044B3r 3  66 69 6E 65  
0044B7r 3  64 20 00     
0044BAr 3               
0044BAr 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
0044BEr 3  34 35 36 37  
0044C2r 3  38 39 61 62  
0044DEr 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
0044E2r 3  34 35 36 37  
0044E6r 3  38 39 41 42  
004502r 3               
004502r 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
004506r 3  6D 62 6C 65  
00450Ar 3  72 20 00     
00450Dr 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
004511r 3  6F 72 20 00  
004515r 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
004519r 3  68 20 00     
00451Cr 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
004520r 3  20 00        
004522r 3               
004522r 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
004526r 3  73 20 28 43  
00452Ar 3  4F 20 41 4E  
00453Er 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
004542r 3  00           
004543r 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
004547r 3  00           
004548r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
00454Cr 3  20 28 64 65  
004550r 3  63 69 6D 61  
004559r 3               
004559r 3               
004559r 3               ; ## ERROR STRINGS
004559r 3               
004559r 3               ; All error strings must be zero-terminated, all names start with "es_",
004559r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
004559r 3               ; as well
004559r 3               
004559r 3               err_allot =        0
004559r 3               err_badsource =    1
004559r 3               err_compileonly =  2
004559r 3               err_defer =        3
004559r 3               err_divzero =      4
004559r 3               err_noname =       5
004559r 3               err_refill =       6
004559r 3               err_state =        7
004559r 3               err_syntax =       8
004559r 3               err_underflow =    9
004559r 3               err_negallot =     10
004559r 3               err_wordlist =     11
004559r 3               err_blockwords =   12
004559r 3               
004559r 3               error_table:
004559r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
00455Dr 3  rr rr rr rr  
004561r 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
004565r 3  rr rr rr rr  
004569r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
00456Dr 3  rr rr rr rr  
004571r 3  rr rr                .word es_blockwords                                    ; 12
004573r 3               
004573r 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
004577r 3  54 20 75 73  
00457Br 3  69 6E 67 20  
004594r 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
004598r 3  67 61 6C 20  
00459Cr 3  53 4F 55 52  
0045B4r 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
0045B8r 3  72 70 72 65  
0045BCr 3  74 69 6E 67  
0045D5r 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
0045D9r 3  52 65 64 20  
0045DDr 3  77 6F 72 64  
0045F2r 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
0045F6r 3  73 69 6F 6E  
0045FAr 3  20 62 79 20  
004603r 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
004607r 3  69 6E 67 20  
00460Br 3  66 61 69 6C  
004613r 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
004617r 3  20 63 6F 75  
00461Br 3  6C 64 20 6E  
004641r 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
004645r 3  61 64 79 20  
004649r 3  69 6E 20 63  
004659r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
00465Dr 3  66 69 6E 65  
004661r 3  64 20 77 6F  
004668r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
00466Cr 3  6B 20 75 6E  
004670r 3  64 65 72 66  
004678r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
00467Cr 3  6D 65 6D 6F  
004680r 3  72 79 20 66  
004694r 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
004698r 3  6F 72 64 6C  
00469Cr 3  69 73 74 73  
0046ABr 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
0046AFr 3  73 65 20 61  
0046B3r 3  73 73 69 67  
0046EAr 3               
0046EAr 3               ; ## ENVIRONMENT STRINGS
0046EAr 3               
0046EAr 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
0046EAr 3               ; Length byte first, then the string itself that is not rpt. not
0046EAr 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
0046EAr 3               ; "envs_".
0046EAr 3               
0046EAr 3               ; These return a single-cell number
0046EAr 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
0046EEr 3  55 4E 54 45  
0046F2r 3  44 2D 53 54  
0046FAr 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
0046FEr 3  4C 44        
004700r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
004704r 3  44           
004705r 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
004709r 3  52 45 53 53  
00470Dr 3  2D 55 4E 49  
004717r 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
00471Br 3  4F 52 45 44  
00471Fr 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
004723r 3  2D 43 48 41  
004727r 3  52           
004728r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
00472Cr 3  2D 4E        
00472Er 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
004732r 3  2D 55        
004734r 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
004738r 3  55 52 4E 2D  
00473Cr 3  53 54 41 43  
004747r 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
00474Br 3  43 4B 2D 43  
00474Fr 3  45 4C 4C 53  
004753r 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
004757r 3  44 4C 49 53  
00475Br 3  54 53        
00475Dr 3               
00475Dr 3               ; These return a double-cell number
00475Dr 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
004761r 3  2D 44        
004763r 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
004767r 3  2D 55 44     
00476Ar 3               
00476Ar 3               ; END
00476Ar 3               
00476Ar 2               
00476Ar 2               ; High-level Forth words, see forth_code/README.md
00476Ar 2               forth_words_start:
00476Ar 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
00476Er 2  2E 28 20 52  
004772r 2  65 61 64 79  
00477Cr 2               forth_words_end:
00477Cr 2               
00477Cr 2               ; User-defined Forth words, see forth_code/README.md
00477Cr 2               user_words_start:
00477Cr 2  20 32 30 20  .incbin "forth_code/user_words.asc"
004780r 2  63 6F 6E 73  
004784r 2  74 61 6E 74  
004E3Er 2               user_words_end:
004E3Er 2               
004E3Er 2               
004E3Er 2               ; =====================================================================
004E3Er 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
004E3Er 2               
004E3Er 2               ; These three routines compile instructions such as "jsr xt_words" into a word
004E3Er 2               ; at compile time so they are available at run time. Words that use this
004E3Er 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
004E3Er 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
004E3Er 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
004E3Er 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
004E3Er 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
004E3Er 2               ; Bowie.
004E3Er 2               
004E3Er 2               ;               ldy #>addr      ; MSB   ; "Young"
004E3Er 2               ;               lda #<addr      ; LSB   ; "Americans"
004E3Er 2               ;               jsr cmpl_subroutine
004E3Er 2               
004E3Er 2               ; Also, we keep a routine here to compile a single byte passed through A.
004E3Er 2               
004E3Er 2               cmpl_subroutine:
004E3Er 2                   ; This is the entry point to compile JSR <ADDR>
004E3Er 2  48               pha             ; save LSB of address
004E3Fr 2  A9 20            lda #$20        ; load opcode for JSR
004E41r 2  80 03            bra cmpl_common
004E43r 2               cmpl_jump:
004E43r 2                   ; This is the entry point to compile JMP <ADDR>
004E43r 2  48               pha             ; save LSB of address
004E44r 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
004E46r 2               cmpl_common:
004E46r 2                   ; At this point, A contains the opcode to be compiled,
004E46r 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
004E46r 2                   ; the address is in Y
004E46r 2  20 rr rr         jsr cmpl_a      ; compile opcode
004E49r 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
004E4Ar 2               cmpl_word:
004E4Ar 2                   ; This is the entry point to compile a word (little-endian)
004E4Ar 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
004E4Dr 2  98               tya             ; fall thru for MSB
004E4Er 2               cmpl_a:
004E4Er 2                   ; This is the entry point to compile a single byte which
004E4Er 2                   ; is passed in A. The built-in assembler assumes that this
004E4Er 2                   ; routine does not modify Y.
004E4Er 2  92 rr            sta (cp)
004E50r 2  E6 rr            inc cp
004E52r 2  D0 02            bne _done
004E54r 2  E6 rr            inc cp+1
004E56r 2               _done:
004E56r 2  60               rts
004E57r 2               
004E57r 2               
004E57r 2               
004E57r 2               ; =====================================================================
004E57r 2               ; CODE FIELD ROUTINES
004E57r 2               
004E57r 2               doconst:
004E57r 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
004E57r 2               ; the Data Field onto the Data Stack
004E57r 2               ; """
004E57r 2  CA               dex             ; make room for constant
004E58r 2  CA               dex
004E59r 2               
004E59r 2                   ; The value we need is stored in the two bytes after the
004E59r 2                   ; JSR return address, which in turn is what is on top of
004E59r 2                   ; the Return Stack
004E59r 2  68               pla             ; LSB of return address
004E5Ar 2  85 rr            sta tmp1
004E5Cr 2  68               pla             ; MSB of return address
004E5Dr 2  85 rr            sta tmp1+1
004E5Fr 2               
004E5Fr 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
004E5Fr 2                   ; the return address on the 65c02
004E5Fr 2  A0 01            ldy #1
004E61r 2  B1 rr            lda (tmp1),y
004E63r 2  95 00            sta 0,x
004E65r 2  C8               iny
004E66r 2  B1 rr            lda (tmp1),y
004E68r 2  95 01            sta 1,x
004E6Ar 2               
004E6Ar 2                   ; This takes us back to the original caller, not the
004E6Ar 2                   ; DOCONST caller
004E6Ar 2  60               rts
004E6Br 2               
004E6Br 2               
004E6Br 2               dodefer:
004E6Br 2               ; """Execute a DEFER statement at runtime: Execute the address we
004E6Br 2               ; find after the caller in the Data Field
004E6Br 2               ; """
004E6Br 2                   ; The xt we need is stored in the two bytes after the JSR
004E6Br 2                   ; return address, which is what is on top of the Return
004E6Br 2                   ; Stack. So all we have to do is replace our return jump
004E6Br 2                   ; with what we find there
004E6Br 2  68               pla             ; LSB
004E6Cr 2  85 rr            sta tmp1
004E6Er 2  68               pla             ; MSB
004E6Fr 2  85 rr            sta tmp1+1
004E71r 2               
004E71r 2  A0 01            ldy #1
004E73r 2  B1 rr            lda (tmp1),y
004E75r 2  85 rr            sta tmp2
004E77r 2  C8               iny
004E78r 2  B1 rr            lda (tmp1),y
004E7Ar 2  85 rr            sta tmp2+1
004E7Cr 2               
004E7Cr 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004E7Fr 2               
004E7Fr 2               defer_error:
004E7Fr 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004E7Fr 2  A9 03            lda #err_defer
004E81r 2  4C rr rr         jmp error
004E84r 2               
004E84r 2               dodoes:
004E84r 2               ; """Execute the runtime portion of DOES>. See DOES> and
004E84r 2               ; docs/create-does.txt for details and
004E84r 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004E84r 2               ; """
004E84r 2                   ; Assumes the address of the CFA of the original defining word
004E84r 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004E84r 2                   ; for a later jump, adding one byte because of the way the
004E84r 2                   ; 6502 works
004E84r 2  7A               ply             ; LSB
004E85r 2  68               pla             ; MSB
004E86r 2  C8               iny
004E87r 2  D0 01            bne @1
004E89r 2  1A               inc
004E8Ar 2               @1:
004E8Ar 2  84 rr            sty tmp2
004E8Cr 2  85 rr            sta tmp2+1
004E8Er 2               
004E8Er 2                   ; Next on the Return Stack should be the address of the PFA of
004E8Er 2                   ; the calling defined word (say, the name of whatever constant we
004E8Er 2                   ; just defined). Move this to the Data Stack, again adding one.
004E8Er 2  CA               dex
004E8Fr 2  CA               dex
004E90r 2               
004E90r 2  7A               ply
004E91r 2  68               pla
004E92r 2  C8               iny
004E93r 2  D0 01            bne @2
004E95r 2  1A               inc
004E96r 2               @2:
004E96r 2  94 00            sty 0,x         ; LSB
004E98r 2  95 01            sta 1,x         ; MSB
004E9Ar 2               
004E9Ar 2                   ; This leaves the return address from the original main routine
004E9Ar 2                   ; on top of the Return Stack. We leave that untouched and jump
004E9Ar 2                   ; to the special code of the defining word. It's RTS instruction
004E9Ar 2                   ; will take us back to the main routine
004E9Ar 2  6C rr rr         jmp (tmp2)
004E9Dr 2               
004E9Dr 2               
004E9Dr 2               dovar:
004E9Dr 2               ; """Execute a variable: Push the address of the first bytes of
004E9Dr 2               ; the Data Field onto the stack. This is called with JSR so we
004E9Dr 2               ; can pick up the address of the calling variable off the 65c02's
004E9Dr 2               ; stack. The final RTS takes us to the original caller of the
004E9Dr 2               ; routine that itself called DOVAR. This is the default
004E9Dr 2               ; routine installed with CREATE.
004E9Dr 2               ; """
004E9Dr 2                   ; Pull the return address off the machine's stack, adding
004E9Dr 2                   ; one because of the way the 65c02 handles subroutines
004E9Dr 2  7A               ply             ; LSB
004E9Er 2  68               pla             ; MSB
004E9Fr 2  C8               iny
004EA0r 2  D0 01            bne @1
004EA2r 2  1A               inc
004EA3r 2               @1:
004EA3r 2  CA               dex
004EA4r 2  CA               dex
004EA5r 2               
004EA5r 2  95 01            sta 1,x
004EA7r 2  98               tya
004EA8r 2  95 00            sta 0,x
004EAAr 2               
004EAAr 2  60               rts
004EABr 2               
004EABr 2               ; =====================================================================
004EABr 2               ; LOW LEVEL HELPER FUNCTIONS
004EABr 2               
004EABr 2               byte_to_ascii:
004EABr 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
004EABr 2               .scope
004EABr 2  48               pha
004EACr 2  4A               lsr             ; convert high nibble first
004EADr 2  4A               lsr
004EAEr 2  4A               lsr
004EAFr 2  4A               lsr
004EB0r 2  20 rr rr         jsr _nibble_to_ascii
004EB3r 2  68               pla
004EB4r 2               
004EB4r 2                   ; fall through to _nibble_to_ascii
004EB4r 2               
004EB4r 2               _nibble_to_ascii:
004EB4r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004EB4r 2               ; of A and and EMIT it. This does the actual work.
004EB4r 2               ; """
004EB4r 2  29 0F            and #$0F
004EB6r 2  09 30            ora #'0'
004EB8r 2  C9 3A            cmp #$3A        ; '9+1
004EBAr 2  90 02            bcc @1
004EBCr 2  69 06            adc #$06
004EBEr 2               
004EBEr 2  4C rr rr     @1:               jmp emit_a
004EC1r 2               
004EC1r 2  60               rts
004EC2r 2               .endscope
004EC2r 2               
004EC2r 2               compare_16bit:
004EC2r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004EC2r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004EC2r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004EC2r 2               ; For signed numbers, Z signals equality and N which number is larger:
004EC2r 2               ;       if TOS = NOS: Z=1 and N=0
004EC2r 2               ;       if TOS > NOS: Z=0 and N=0
004EC2r 2               ;       if TOS < NOS: Z=0 and N=1
004EC2r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004EC2r 2               ;       if TOS = NOS: Z=1 and N=0
004EC2r 2               ;       if TOS > NOS: Z=0 and C=1
004EC2r 2               ;       if TOS < NOS: Z=0 and C=0
004EC2r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004EC2r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004EC2r 2               ; """
004EC2r 2               .scope
004EC2r 2                   ; Compare LSB first to set the carry flag
004EC2r 2  B5 00            lda 0,x                 ; LSB of TOS
004EC4r 2  D5 02            cmp 2,x                 ; LSB of NOS
004EC6r 2  F0 0A            beq _equal
004EC8r 2               
004EC8r 2                   ; LSBs are not equal, compare MSB
004EC8r 2  B5 01            lda 1,x                 ; MSB of TOS
004ECAr 2  F5 03            sbc 3,x                 ; MSB of NOS
004ECCr 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004ECEr 2  70 08            bvs _overflow
004ED0r 2  80 08            bra _not_equal
004ED2r 2               _equal:
004ED2r 2                   ; Low bytes are equal, so we compare high bytes
004ED2r 2  B5 01            lda 1,x                 ; MSB of TOS
004ED4r 2  F5 03            sbc 3,x                 ; MSB of NOS
004ED6r 2  50 04            bvc _done
004ED8r 2               _overflow:
004ED8r 2                   ; Handle overflow because we use signed numbers
004ED8r 2  49 80            eor #$80                ; complement negative flag
004EDAr 2               _not_equal:
004EDAr 2  09 01            ora #1                  ; if overflow, we can't be eqal
004EDCr 2               _done:
004EDCr 2  60               rts
004EDDr 2               .endscope
004EDDr 2               
004EDDr 2               current_to_dp:
004EDDr 2               ; """Look up the current (compilation) dictionary pointer
004EDDr 2               ; in the wordlist set and put it into the dp zero-page
004EDDr 2               ; variable. Uses A and Y.
004EDDr 2               ; """
004EDDr 2                   ; Determine which wordlist is current
004EDDr 2  A0 04            ldy #current_offset
004EDFr 2  B1 rr            lda (up),y      ; current is a byte variable
004EE1r 2  0A               asl             ; turn it into an offset (in cells)
004EE2r 2               
004EE2r 2                   ; Get the dictionary pointer for that wordlist.
004EE2r 2  18               clc
004EE3r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004EE5r 2  A8               tay
004EE6r 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
004EE8r 2  85 rr            sta dp
004EEAr 2  C8               iny
004EEBr 2  B1 rr            lda (up),y
004EEDr 2  85 rr            sta dp+1
004EEFr 2               
004EEFr 2  60               rts
004EF0r 2               
004EF0r 2               
004EF0r 2               dp_to_current:
004EF0r 2               ; """Look up which wordlist is current and update its pointer
004EF0r 2               ; with the value in dp. Uses A and Y.
004EF0r 2               ; """
004EF0r 2                   ; Determine which wordlist is current
004EF0r 2  A0 04            ldy #current_offset
004EF2r 2  B1 rr            lda (up),y      ; current is a byte variable
004EF4r 2  0A               asl             ; turn it into an offset (in cells)
004EF5r 2               
004EF5r 2                   ; Get the dictionary pointer for that wordlist.
004EF5r 2  18               clc
004EF6r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004EF8r 2  A8               tay
004EF9r 2  A5 rr            lda dp
004EFBr 2  91 rr            sta (up),y              ; get the dp for that wordlist.
004EFDr 2  C8               iny
004EFEr 2  A5 rr            lda dp+1
004F00r 2  91 rr            sta (up),y
004F02r 2               
004F02r 2  60               rts
004F03r 2               
004F03r 2               interpret:
004F03r 2               .scope
004F03r 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
004F03r 2               ; Process one line only. Assumes that the address of name is in
004F03r 2               ; cib and the length of the whole input line string is in ciblen
004F03r 2               ; """
004F03r 2                   ; Normally we would use PARSE here with the SPACE character as
004F03r 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
004F03r 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
004F03r 2                   ; delimiters per default and skips any leading spaces, which
004F03r 2                   ; PARSE doesn't
004F03r 2               _loop:
004F03r 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
004F06r 2               
004F06r 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
004F06r 2                   ; in the line and we need to go get a new line
004F06r 2  B5 00            lda 0,x
004F08r 2  15 01            ora 1,x
004F0Ar 2  F0 70            beq _line_done
004F0Cr 2               
004F0Cr 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
004F0Cr 2                   ; make a copy of the address in case it isn't a word we know and
004F0Cr 2                   ; we have to go see if it is a number
004F0Cr 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
004F0Fr 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
004F12r 2               
004F12r 2                   ; A zero signals that we didn't find a word in the Dictionary
004F12r 2  B5 00            lda 0,x
004F14r 2  15 01            ora 1,x
004F16r 2  D0 28            bne _got_name_token
004F18r 2               
004F18r 2                   ; We didn't get any nt we know of, so let's see if this is
004F18r 2                   ; a number.
004F18r 2  E8               inx                     ; ( addr u 0 -- addr u )
004F19r 2  E8               inx
004F1Ar 2               
004F1Ar 2                   ; If the number conversion doesn't work, NUMBER will do the
004F1Ar 2                   ; complaining for us
004F1Ar 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
004F1Dr 2               
004F1Dr 2                   ; Otherweise, if we're interpreting, we're done
004F1Dr 2  A5 rr            lda state
004F1Fr 2  F0 E2            beq _loop
004F21r 2               
004F21r 2                   ; We're compiling, so there is a bit more work.  Check
004F21r 2                   ; status bit 5 to see if it's a single or double-cell
004F21r 2                   ; number.
004F21r 2  A9 20            lda #$20
004F23r 2  24 rr            bit status
004F25r 2  F0 0D            beq _single_number
004F27r 2               
004F27r 2                   ; It's a double cell number.  If we swap the
004F27r 2                   ; upper and lower half, we can use the literal_runtime twice
004F27r 2                   ; to compile it into the dictionary.
004F27r 2  20 rr rr         jsr xt_swap
004F2Ar 2  A0 rr            ldy #>literal_runtime
004F2Cr 2  A9 rr            lda #<literal_runtime
004F2Er 2  20 rr rr         jsr cmpl_subroutine
004F31r 2               
004F31r 2                   ; compile our number
004F31r 2  20 rr rr         jsr xt_comma
004F34r 2               
004F34r 2                   ; Fall into _single_number to process the other half.
004F34r 2               _single_number:
004F34r 2  A0 rr            ldy #>literal_runtime
004F36r 2  A9 rr            lda #<literal_runtime
004F38r 2  20 rr rr         jsr cmpl_subroutine
004F3Br 2               
004F3Br 2                   ; compile our number
004F3Br 2  20 rr rr         jsr xt_comma
004F3Er 2               
004F3Er 2                   ; That was so much fun, let's do it again!
004F3Er 2  80 C3            bra _loop
004F40r 2               
004F40r 2               _got_name_token:
004F40r 2                   ; We have a known word's nt TOS. We're going to need its xt
004F40r 2                   ; though, which is four bytes father down.
004F40r 2               
004F40r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
004F40r 2  B5 00            lda 0,x
004F42r 2  95 04            sta 4,x
004F44r 2  B5 01            lda 1,x
004F46r 2  95 05            sta 5,x
004F48r 2               
004F48r 2  E8               inx
004F49r 2  E8               inx
004F4Ar 2  E8               inx
004F4Br 2  E8               inx                     ; ( nt )
004F4Cr 2               
004F4Cr 2                   ; Save a version of nt for error handling and compilation stuff
004F4Cr 2  B5 00            lda 0,x
004F4Er 2  85 rr            sta tmpbranch
004F50r 2  B5 01            lda 1,x
004F52r 2  85 rr            sta tmpbranch+1
004F54r 2               
004F54r 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
004F57r 2               
004F57r 2                   ; See if we are in interpret or compile mode, 0 is interpret
004F57r 2  A5 rr            lda state
004F59r 2  D0 13            bne _compile
004F5Br 2               
004F5Br 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
004F5Br 2                   ; though, see if this isn't a compile-only word, which would be
004F5Br 2                   ; illegal. The status byte is the second one of the header.
004F5Br 2  A0 01            ldy #1
004F5Dr 2  B1 rr            lda (tmpbranch),y
004F5Fr 2  29 01            and #CO                 ; mask everything but Compile Only bit
004F61r 2  F0 05            beq _interpret
004F63r 2               
004F63r 2  A9 02            lda #err_compileonly
004F65r 2  4C rr rr         jmp error
004F68r 2               
004F68r 2               _interpret:
004F68r 2                   ; We JSR to EXECUTE instead of calling the xt directly because
004F68r 2                   ; the RTS of the word we're executing will bring us back here,
004F68r 2                   ; skipping EXECUTE completely during RTS. If we were to execute
004F68r 2                   ; xt directly, we have to fool around with the Return Stack
004F68r 2                   ; instead, which is actually slightly slower
004F68r 2  20 rr rr         jsr xt_execute
004F6Br 2               
004F6Br 2                   ; That's quite enough for this word, let's get the next one
004F6Br 2  4C rr rr         jmp _loop
004F6Er 2               
004F6Er 2               _compile:
004F6Er 2                   ; We're compiling! However, we need to see if this is an
004F6Er 2                   ; IMMEDIATE word, which would mean we execute it right now even
004F6Er 2                   ; during compilation mode. Fortunately, we saved the nt so life
004F6Er 2                   ; is easier. The flags are in the second byte of the header
004F6Er 2  A0 01            ldy #1
004F70r 2  B1 rr            lda (tmpbranch),y
004F72r 2  29 04            and #IM                 ; Mask all but IM bit
004F74r 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
004F76r 2               
004F76r 2                   ; Compile the xt into the Dictionary with COMPILE,
004F76r 2  20 rr rr         jsr xt_compile_comma
004F79r 2  4C rr rr         jmp _loop
004F7Cr 2               
004F7Cr 2               _line_done:
004F7Cr 2                   ; drop stuff from PARSE_NAME
004F7Cr 2  E8               inx
004F7Dr 2  E8               inx
004F7Er 2  E8               inx
004F7Fr 2  E8               inx
004F80r 2               
004F80r 2  60               rts
004F81r 2               .endscope
004F81r 2               
004F81r 2               
004F81r 2               is_printable:
004F81r 2               .scope
004F81r 2               ; """Given a character in A, check if it is a printable ASCII
004F81r 2               ; character in the range from $20 to $7E inclusive. Returns the
004F81r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004F81r 2               ; is printable. Keeps A. See
004F81r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004F81r 2               ; discussion of various ways to do this
004F81r 2  C9 20            cmp #AscSP              ; $20
004F83r 2  90 08            bcc _done
004F85r 2  C9 7F            cmp #'~' + 1             ; $7E
004F87r 2  B0 03            bcs _failed
004F89r 2               
004F89r 2  38               sec
004F8Ar 2  80 01            bra _done
004F8Cr 2               _failed:
004F8Cr 2  18               clc
004F8Dr 2               _done:
004F8Dr 2  60               rts
004F8Er 2               .endscope
004F8Er 2               
004F8Er 2               
004F8Er 2               is_whitespace:
004F8Er 2               .scope
004F8Er 2               ; """Given a character in A, check if it is a whitespace
004F8Er 2               ; character, that is, an ASCII value from 0 to 32 (where
004F8Er 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004F8Er 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004F8Er 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004F8Er 2               ; a discussion of the uses. Does not change A or Y.
004F8Er 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004F90r 2  90 08            bcc _done
004F92r 2               
004F92r 2  C9 21            cmp #AscSP+1
004F94r 2  B0 03            bcs _failed
004F96r 2               
004F96r 2  38               sec
004F97r 2  80 01            bra _done
004F99r 2               _failed:
004F99r 2  18               clc
004F9Ar 2               _done:
004F9Ar 2  60               rts
004F9Br 2               .endscope
004F9Br 2               
004F9Br 2               
004F9Br 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
004F9Br 2               ; required for the word. This routine flows into the generic error handling
004F9Br 2               ; code
004F9Br 2               underflow_1:
004F9Br 2               ; """Make sure we have at least one cell on the Data Stack"""
004F9Br 2  E0 rr            cpx #dsp0-1
004F9Dr 2  10 10            bpl underflow_error
004F9Fr 2  60               rts
004FA0r 2               underflow_2:
004FA0r 2               ; """Make sure we have at least two cells on the Data Stack"""
004FA0r 2  E0 rr            cpx #dsp0-3
004FA2r 2  10 0B            bpl underflow_error
004FA4r 2  60               rts
004FA5r 2               underflow_3:
004FA5r 2               ; """Make sure we have at least three cells on the Data Stack"""
004FA5r 2  E0 rr            cpx #dsp0-5
004FA7r 2  10 06            bpl underflow_error
004FA9r 2  60               rts
004FAAr 2               underflow_4:
004FAAr 2               ; """Make sure we have at least four cells on the Data Stack"""
004FAAr 2  E0 rr            cpx #dsp0-7
004FACr 2  10 01            bpl underflow_error
004FAEr 2  60               rts
004FAFr 2               
004FAFr 2               underflow_error:
004FAFr 2                   ; Entry for COLD/ABORT/QUIT
004FAFr 2  A9 09            lda #err_underflow      ; fall through to error
004FB1r 2               
004FB1r 2               error:
004FB1r 2               ; """Given the error number in a, print the associated error string and
004FB1r 2               ; call abort. Uses tmp3.
004FB1r 2               ; """
004FB1r 2  0A               asl
004FB2r 2  A8               tay
004FB3r 2  B9 rr rr         lda error_table,y
004FB6r 2  85 rr            sta tmp3                ; LSB
004FB8r 2  C8               iny
004FB9r 2  B9 rr rr         lda error_table,y
004FBCr 2  85 rr            sta tmp3+1              ; MSB
004FBEr 2               
004FBEr 2  20 rr rr         jsr print_common
004FC1r 2  20 rr rr         jsr xt_cr
004FC4r 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
004FC7r 2               
004FC7r 2               
004FC7r 2               ; =====================================================================
004FC7r 2               ; PRINTING ROUTINES
004FC7r 2               
004FC7r 2               ; We distinguish two types of print calls, both of which take the string number
004FC7r 2               ; (see strings.asm) in A:
004FC7r 2               
004FC7r 2               ;       print_string       - with a line feed
004FC7r 2               ;       print_string_no_lf - without a line feed
004FC7r 2               
004FC7r 2               ; In addition, print_common provides a lower-level alternative for error
004FC7r 2               ; handling and anything else that provides the address of the
004FC7r 2               ; zero-terminated string directly in tmp3. All of those routines assume that
004FC7r 2               ; printing should be more concerned with size than speed, because anything to
004FC7r 2               ; do with humans reading text is going to be slow.
004FC7r 2               
004FC7r 2               print_string_no_lf:
004FC7r 2               ; """Given the number of a zero-terminated string in A, print it to the
004FC7r 2               ; current output without adding a LF. Uses Y and tmp3 by falling
004FC7r 2               ; through to print_common
004FC7r 2               ; """
004FC7r 2                   ; Get the entry from the string table
004FC7r 2  0A               asl
004FC8r 2  A8               tay
004FC9r 2  B9 rr rr         lda string_table,y
004FCCr 2  85 rr            sta tmp3                ; LSB
004FCEr 2  C8               iny
004FCFr 2  B9 rr rr         lda string_table,y
004FD2r 2  85 rr            sta tmp3+1              ; MSB
004FD4r 2               
004FD4r 2                   ; fall through to print_common
004FD4r 2               print_common:
004FD4r 2               ; """Common print routine used by both the print functions and
004FD4r 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004FD4r 2               ; Y.
004FD4r 2               ; """
004FD4r 2               .scope
004FD4r 2  A0 00            ldy #0
004FD6r 2               _loop:
004FD6r 2  B1 rr            lda (tmp3),y
004FD8r 2  F0 06            beq _done               ; strings are zero-terminated
004FDAr 2               
004FDAr 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004FDDr 2  C8               iny
004FDEr 2  80 F6            bra _loop
004FE0r 2               _done:
004FE0r 2  60               rts
004FE1r 2               .endscope
004FE1r 2               
004FE1r 2               print_string:
004FE1r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004FE1r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004FE1r 2               ; """
004FE1r 2  20 rr rr         jsr print_string_no_lf
004FE4r 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
004FE7r 2               
004FE7r 2               
004FE7r 2               print_u:
004FE7r 2               ; """basic printing routine used by higher-level constructs,
004FE7r 2               ; the equivalent of the forth word  0 <# #s #> type  which is
004FE7r 2               ; basically u. without the space at the end. used for various
004FE7r 2               ; outputs
004FE7r 2               ; """
004FE7r 2  20 rr rr         jsr xt_zero                     ; 0
004FEAr 2  20 rr rr         jsr xt_less_number_sign         ; <#
004FEDr 2  20 rr rr         jsr xt_number_sign_s            ; #S
004FF0r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004FF3r 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
004FF6r 2               
004FF6r 2               ; END
004FF6r 2               
004FF6r 1               
004FF6r 1               .segment "DATA"
004FF6r 1               
004FF6r 1               ; .include "../../ed.s"
004FF6r 1               
004FF6r 1               
004FF6r 1               platform_bye:
004FF6r 1               kernel_init:
004FF6r 1               .ifdef VIA1_BASE
004FF6r 1  A9 FF            lda #$FF
004FF8r 1  8D 82 FF         sta DDRB
004FFBr 1  8D 83 FF         sta DDRA
004FFEr 1  A9 01            lda #1
005000r 1  8D 80 FF         sta PORTB
005003r 1  9C 81 FF         stz PORTA
005006r 1               .endif
005006r 1               .ifdef timer_init
005006r 1  64 rr            stz time
005008r 1  64 rr            stz time+1
00500Ar 1  64 rr            stz time+2
00500Cr 1  64 rr            stz time+3
00500Er 1               .endif
00500Er 1  20 rr rr     jsr acia_init
005011r 1               .ifdef timer_init
005011r 1  20 rr rr         jsr timer_init
005014r 1               .endif
005014r 1               .ifdef video_init
005014r 1                   jsr video_init
005014r 1               .endif
005014r 1               .ifdef ps2_init
005014r 1                   jsr ps2_init
005014r 1               .endif
005014r 1               .ifdef lcd_init
005014r 1                   jsr lcd_init
005014r 1               .endif
005014r 1               .ifdef spi_init
005014r 1  20 rr rr         jsr spi_init
005017r 1               .endif
005017r 1               .ifdef kb_init
005017r 1                   jsr kb_init
005017r 1               .endif
005017r 1  DA A2 00 BD      printascii welcome_message
00501Br 1  rr rr F0 06  
00501Fr 1  20 rr rr E8  
005026r 1               
005026r 1  A9 rr            lda #<dictionary
005028r 1  85 rr            sta up
00502Ar 1  A9 rr            lda #>dictionary
00502Cr 1  85 rr            sta up + 1
00502Er 1               
00502Er 1  20 rr rr         jsr calculate_free_mem
005031r 1  A5 rr            lda tmp_var + 1
005033r 1  A6 rr            ldx tmp_var
005035r 1  20 rr rr         jsr print16
005038r 1               
005038r 1  DA A2 00 BD      printascii free_message
00503Cr 1  rr rr F0 06  
005040r 1  20 rr rr E8  
005047r 1               
005047r 1  4C rr rr         jmp forth
00504Ar 1               
00504Ar 1               v_nmi:
00504Ar 1               
00504Ar 1  20 rr rr         jsr calculate_free_mem
00504Dr 1  A5 rr            lda tmp_var + 1
00504Fr 1  A6 rr            ldx tmp_var
005051r 1  20 rr rr         jsr print16
005054r 1               
005054r 1  DA A2 00 BD      printascii free_message
005058r 1  rr rr F0 06  
00505Cr 1  20 rr rr E8  
005063r 1  DA A2 00 BD      printascii ready_message
005067r 1  rr rr F0 06  
00506Br 1  20 rr rr E8  
005072r 1               
005072r 1  4C rr rr         jmp xt_abort
005075r 1               
005075r 1               
005075r 1               
005075r 1               
005075r 1               io_read_sector:
005075r 1  6C rr rr         jmp (io_read_sector_ptr)        ; jump to read sector routine
005078r 1               
005078r 1               kernel_putc:
005078r 1                   ; """Print a single character to the console. """
005078r 1                   ;; Send_Char - send character in A out serial port.
005078r 1                   ;; Uses: A (original value restored)
005078r 1               send_char:
005078r 1  48               pha
005079r 1                   .ifdef char_out
005079r 1                   jsr char_out
005079r 1                   .endif
005079r 1                   .ifdef acia_out
005079r 1  20 rr rr         jsr acia_out
00507Cr 1                   .endif
00507Cr 1               send_char_exit:
00507Cr 1               .ifdef lcd_print
00507Cr 1                   ; jsr lcd_print
00507Cr 1               .endif
00507Cr 1  68               pla
00507Dr 1  60               rts
00507Er 1               
00507Er 1               
00507Er 1                       ;; Get_Char - get a character from the serial port into A.
00507Er 1                       ;; Set the carry flag if char is valid.
00507Er 1                       ;; Return immediately with carry flag clear if no char available.
00507Er 1                       ;; Uses: A (return value)
00507Er 1               
00507Er 1               Get_Char:
00507Er 1  20 rr rr         jsr acia_getc
005081r 1  90 02            bcc get_ps2_char                ; check keyboard buffer if nothing from ACIA
005083r 1  38               sec                             ; Set Carry to show we got a character
005084r 1  60               rts                             ; Return
005085r 1               
005085r 1               get_ps2_char:                       ; no ACIA char available, try to get from KB buffer
005085r 1               .ifdef ps2_get_char
005085r 1                   jsr ps2_get_char
005085r 1               .endif
005085r 1  90 02            bcc get_kb_char
005087r 1  38               sec
005088r 1               
005088r 1  60               rts
005089r 1               get_kb_char:
005089r 1                   .ifdef kb_get_char
005089r 1               
005089r 1                   ; ldy #5
005089r 1                   ; jsr delay_short
005089r 1                   ; ply
005089r 1                       jsr kb_get_char
005089r 1               
005089r 1                   .endif
005089r 1               exit:                         ; Indicate no char available.
005089r 1  60               rts                             ; return
00508Ar 1               
00508Ar 1               kernel_getc:
00508Ar 1                   ; """Get a single character from the keyboard (waits for key).
00508Ar 1                   ; """
00508Ar 1                   ;; Get_Char_Wait - same as Get_Char only blocking.
00508Ar 1                   ;; Uses: A (return value)
00508Ar 1               Get_Char_Wait:
00508Ar 1  20 rr rr         jsr Get_Char
00508Dr 1  90 FB            bcc Get_Char_Wait
00508Fr 1  60               rts
005090r 1               
005090r 1               
005090r 1               v_irq:                          ; IRQ handler
005090r 1  48                   pha
005091r 1  5A                   phy
005092r 1                       ; lda #'.'
005092r 1                       ; jsr kernel_putc
005092r 1                       ; check if bit 7 of IFR is set
005092r 1               .ifdef IFR
005092r 1  AD 8D FF             lda IFR
005095r 1  10 0B                bpl irq_not_from_via  ; Interrupt not from VIA, exit
005097r 1               
005097r 1  29 08                and #$08        ; ps2 has priority
005099r 1  D0 07                bne v_irq_ps2
00509Br 1  AD 8D FF             lda IFR
00509Er 1  29 40                and #$40
0050A0r 1  D0 02                bne v_irq_timer
0050A2r 1               irq_not_from_via:
0050A2r 1               .endif
0050A2r 1               .ifdef KB_IFR
0050A2r 1               v_kb_irq:
0050A2r 1                       lda KB_IFR
0050A2r 1                       bpl v_irq_exit
0050A2r 1                       and #$40
0050A2r 1                       bne v_kb_irq_timer
0050A2r 1                       bra v_irq_exit
0050A2r 1               .endif
0050A2r 1               
0050A2r 1               v_irq_ps2:
0050A2r 1                   .ifdef ps2_irq
0050A2r 1                       lda time
0050A2r 1                       sta last_ps2_time
0050A2r 1                       lda time+1
0050A2r 1                       sta last_ps2_time+1
0050A2r 1                       lda time+2
0050A2r 1                       sta last_ps2_time+2
0050A2r 1                       lda time+3
0050A2r 1                       sta last_ps2_time+3
0050A2r 1               
0050A2r 1                       jsr ps2_irq
0050A2r 1               
0050A2r 1                   .endif
0050A2r 1  80 27                bra v_irq_exit
0050A4r 1               
0050A4r 1               .ifdef T1CL
0050A4r 1               v_irq_timer:
0050A4r 1  AD 84 FF             lda T1CL
0050A7r 1                       ; clear timer interrupt
0050A7r 1                   .ifdef timer_irq
0050A7r 1  20 rr rr             jsr timer_irq
0050AAr 1                   .endif
0050AAr 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
0050ADr 1                       ; check if there is a char waiting to be printed to the lcd
0050ADr 1                       ; lda lcd_char
0050ADr 1                       ; beq v_exit
0050ADr 1                       ; jsr lcd_print
0050ADr 1                       ; stz lcd_char
0050ADr 1               
0050ADr 1               
0050ADr 1  90 1C                bcc v_irq_exit      ; no character waiting, exit normally
0050AFr 1  C9 03                cmp #$03            ; check if CTRL-C
0050B1r 1  D0 18                bne v_irq_exit      ; not CTRL-C, exit normally
0050B3r 1  DA A2 00 BD          printascii abort_message    ; was a CTRL_C
0050B7r 1  rr rr F0 06  
0050BBr 1  20 rr rr E8  
0050C2r 1  7A                   ply                         ; pull what the ISR pushed
0050C3r 1  68                   pla
0050C4r 1  28                   plp                         ; pull status register
0050C5r 1  68                   pla                         ; pull return address
0050C6r 1  68                   pla
0050C7r 1               
0050C7r 1  58                   cli                         ; clear interrupt diabled bit
0050C8r 1  4C rr rr             jmp xt_abort
0050CBr 1               
0050CBr 1               .endif
0050CBr 1               v_kb_irq_timer:
0050CBr 1               .ifdef kb_time
0050CBr 1                   lda KB_T1CL ; clear timer interrupt
0050CBr 1                   inc kb_time
0050CBr 1                   bne v_irq_exit
0050CBr 1               .endif
0050CBr 1                   ;jsr kb_scan
0050CBr 1               v_irq_exit:
0050CBr 1  7A               ply
0050CCr 1  68               pla
0050CDr 1  40               rti
0050CEr 1               
0050CEr 1  20 62 79 74  free_message: .byte " bytes free", $0D, 0
0050D2r 1  65 73 20 66  
0050D6r 1  72 65 65 0D  
0050DBr 1  52 65 61 64  ready_message: .byte "Ready", $0D, 0
0050DFr 1  79 0D 00     
0050E2r 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", $0D, "Type 'words' for available words", $0D, 0
0050E6r 1  6F 6D 65 20  
0050EAr 1  74 6F 20 50  
00511Br 1  0D 0A 00     abort_message: .byte AscCR, AscLF, 0
00511Er 1               
00511Er 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
