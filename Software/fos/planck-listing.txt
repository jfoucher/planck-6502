ca65 V2.18 - N/A
Main file   : platform/planck/main.s
Current file: platform/planck/main.s

000000r 1               
000000r 1               .include "../../macros.s"
000000r 2               .macro  printascii   addr
000000r 2               .local @loop
000000r 2               .local @done
000000r 2                   phx
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda addr,x
000000r 2                   beq @done
000000r 2                   jsr kernel_putc
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @done:
000000r 2                   plx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro  cp16   src, dest
000000r 2                   lda src
000000r 2                   sta dest
000000r 2                   lda src + 1
000000r 2                   sta dest + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro printstr addr, len
000000r 2               .repeat len, I
000000r 2               lda addr + I
000000r 2               jsr kernel_putc
000000r 2               .endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl16 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl32 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2                   rol src + 2
000000r 2                   rol src + 3
000000r 2               .endmacro
000000r 2               
000000r 2               .macro lsr16 src
000000r 2                   lsr src + 1
000000r 2                   ror src
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc16 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment the MSB if LSB wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc32 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment next byte if LSB wrapped round
000000r 2                   bne @done
000000r 2                   inc src+2       ;Increment the next byte the previous wrapped round
000000r 2                   bne @done
000000r 2                   inc src+3       ;Increment the MSB if previous wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16 src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, just decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2               @skip:
000000r 2                   dec src
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16zero src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2                   beq @end            ; if high byte is also zero, we reached zero, exit now
000000r 2               @skip:
000000r 2                   dec src
000000r 2                   bne @end            ; if low byte is not zero exit now
000000r 2                   lda src + 1         ; if low byte was zero, load high byte to check if it's also zero
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro add16 first, second, result
000000r 2                   CLC             ;Ensure carry is clear
000000r 2                   LDA first+0       ;Add the two least significant bytes
000000r 2                   ADC second+0
000000r 2                   STA result+0       ;... and store the result
000000r 2                   LDA first+1       ;Add the two most significant bytes
000000r 2                   ADC second+1       ;... and any propagated carry bit
000000r 2                   STA result+1       ;... and store the result
000000r 2               .endmacro
000000r 2               
000000r 2               ; compare data at two adresses for defined length
000000r 2               ; On exit, carry is set if there is a match
000000r 2               ; and unset if no match
000000r 2               ; length of data to check is in X
000000r 2               
000000r 2               .macro memcmp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               .local @exit_fail
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   cmp second, x
000000r 2                   bne @exit_fail
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; check 0th element
000000r 2                   cmp second
000000r 2                   bne @exit_fail
000000r 2                   sec
000000r 2                   bra @exit
000000r 2               @exit_fail:
000000r 2                   clc
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               ; copy data from one address to another for defined length
000000r 2               ; length of data to copy is in X
000000r 2               .macro memcp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   sta second, x
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; copy zeroth item
000000r 2                   sta second
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; calculates length of zero terminated string
000000r 2               ; result is in x
000000r 2               .macro strlen address
000000r 2               .local @loop
000000r 2               .local @exit
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda address, x
000000r 2                   beq @exit
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_axy
000000r 2               	pha		; push accumulator to stack
000000r 2               	phx
000000r 2                   phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro pull_axy
000000r 2               	ply		; pull y from stack
000000r 2               	plx		; pull x from stack
000000r 2               	pla		; pull a from stack
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro push_ax
000000r 2               	pha
000000r 2               	phx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ax
000000r 2               	pla
000000r 2               	plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_ay
000000r 2               	pha
000000r 2               	phy
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ay
000000r 2               	pla
000000r 2               	ply
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro mov32 SRC, DEST
000000r 2               	lda SRC
000000r 2               	sta DEST
000000r 2               	lda SRC+1
000000r 2               	sta DEST+1
000000r 2               	lda SRC+2
000000r 2               	sta DEST+2
000000r 2               	lda SRC+3
000000r 2               	sta DEST+3
000000r 2               .endmacro
000000r 2               
000000r 1               CLOCK_SPEED = 24000000
000000r 1               
000000r 1               ram_end = $8000
000000r 1               
000000r 1               ; select includes to enable card drivers
000000r 1               
000000r 1               .include "drivers/cf.inc"
000000r 2               
000000r 2               CF_READ_SECTOR_COMMAND = $20
000000r 2               CF_WRITE_SECTOR_COMMAND = $30
000000r 2               CF_ADDRESS = $FFD0
000000r 2               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/via.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               VIA1_BASE   = $FF80
000000r 2               PORTB = VIA1_BASE
000000r 2               PORTA  = VIA1_BASE+1
000000r 2               DDRB = VIA1_BASE+2
000000r 2               DDRA = VIA1_BASE+3
000000r 2               
000000r 2               
000000r 2               T1CL = VIA1_BASE + 4
000000r 2               T1CH = VIA1_BASE + 5
000000r 2               T1LL = VIA1_BASE + 6
000000r 2               T1LH = VIA1_BASE + 7
000000r 2               ACR = VIA1_BASE + 11
000000r 2               PCR = VIA1_BASE + 12
000000r 2               IFR = VIA1_BASE + 13
000000r 2               IER = VIA1_BASE + 14
000000r 2               
000000r 1               ; .include "drivers/sd.inc"
000000r 1               ; .include "drivers/ps2.inc"
000000r 1               ; .include "drivers/4004.inc"
000000r 1               ; .include "drivers/lcd.inc"
000000r 1               ; .include "drivers/vga.inc"
000000r 1               ; .include "drivers/keyboard.inc"
000000r 1               
000000r 1               .segment "ZEROPAGE": zeropage
000000r 1  xx xx        io_buffer_ptr: .res 2
000002r 1               
000002r 1               .include "drivers/zp.s"
000002r 2               ; Copyright 2020 Jonathan Foucher
000002r 2               
000002r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000002r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000002r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000002r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000002r 2               ; is furnished to do so, subject to the following conditions:
000002r 2               
000002r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000002r 2               ; substantial portions of the Software.
000002r 2               
000002r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000002r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000002r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000002r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000002r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000002r 2               ; DEALINGS IN THE SOFTWARE.
000002r 2               
000002r 2               ; next_addr: .res 1
000002r 2               
000002r 2               
000002r 2  xx xx        tmp_var: .res 2
000004r 2  xx xx        stack_p: .res 2
000006r 2               .ifdef VIA1_BASE
000006r 2  xx xx xx xx  time: .res 4
00000Ar 2               .endif
00000Ar 2               
00000Ar 1               
00000Ar 1               .segment "BSS"
000000r 1               .ifdef VIA1_BASE
000000r 1  xx           lcd_absent: .res 1
000001r 1               .endif
000001r 1               .ifdef ACIA_BASE
000001r 1  xx           has_acia: .res 1
000002r 1               .endif
000002r 1               
000002r 1               .ifdef CF_ADDRESS
000002r 1  xx xx xx xx  IO_BUFFER: .res $400
000006r 1  xx xx xx xx  
00000Ar 1  xx xx xx xx  
000402r 1  xx xx xx xx  IO_SECTOR: .res 4
000406r 1               .endif
000406r 1               
000406r 1               
000406r 1               
000406r 1               .segment "STARTUP"
000000r 1               .import    copydata
000000r 1               .import zerobss
000000r 1               zero_ram:
000000r 1  A2 FF            ldx #$FF
000002r 1               zero_zp:
000002r 1  74 00            stz 0, x
000004r 1  CA               dex
000005r 1  D0 FB            bne zero_zp
000007r 1  64 00            stz $00
000009r 1  A9 00            lda #0
00000Br 1  85 01            sta $01
00000Dr 1               
00000Dr 1  A2 80            ldx #$80
00000Fr 1  A0 00            ldy #0
000011r 1  A9 00            lda #0
000013r 1               @loop:
000013r 1  91 00            sta ($0), y
000015r 1  C8               iny
000016r 1  D0 FB            bne @loop
000018r 1  E6 01            inc $1
00001Ar 1  CA               dex
00001Br 1  D0 F6            bne @loop
00001Dr 1               
00001Dr 1  4C rr rr         jmp ram_zeroed
000020r 1               
000020r 1               v_reset:
000020r 1  4C rr rr         jmp zero_ram
000023r 1               ram_zeroed:
000023r 1  20 rr rr         JSR     copydata
000026r 1  20 rr rr         jsr zerobss
000029r 1               
000029r 1  4C rr rr         jmp kernel_init
00002Cr 1               
00002Cr 1               
00002Cr 1               
00002Cr 1               .segment "DATA"
000000r 1               
000000r 1               .include "drivers/delayroutines.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               ; this routine delays by 2304 * y + 23 cycles
000000r 2               delay:
000000r 2  DA             phx       ; 3 cycles
000001r 2  5A             phy       ; 3 cycles
000002r 2               two:
000002r 2  A2 FF          ldx #$ff  ; 2 cycles
000004r 2               one:
000004r 2  EA             nop       ; 2 cycles
000005r 2  EA             nop       ; 2 cycles
000006r 2  CA             dex       ; 2 cycles
000007r 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
000009r 2  88             dey       ; 2 cycles
00000Ar 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
00000Cr 2  7A             ply       ; 4 cycles
00000Dr 2  FA             plx       ; 4 cycles
00000Er 2  60             rts       ; 6 cycles
00000Fr 2               
00000Fr 2               ; delay is in Y register
00000Fr 2               delay_long:
00000Fr 2  48             pha
000010r 2  5A             phy
000011r 2  DA             phx
000012r 2  98             tya
000013r 2  AA             tax
000014r 2               delay_long_loop:
000014r 2  A0 FF          ldy #$ff
000016r 2  20 rr rr       jsr delay
000019r 2  CA             dex
00001Ar 2  D0 F8          bne delay_long_loop
00001Cr 2  FA             plx
00001Dr 2  7A             ply
00001Er 2  68             pla
00001Fr 2  60             rts
000020r 2               
000020r 2               delay_short:        ; delay Y * 19 cycles
000020r 2  5A             phy
000021r 2               delay_short_loop:
000021r 2  EA             nop               ; 2 cycles
000022r 2  EA             nop               ; 2 cycles
000023r 2  EA             nop               ; 2 cycles
000024r 2  EA             nop               ; 2 cycles
000025r 2  EA             nop               ; 2 cycles
000026r 2  EA             nop               ; 2 cycles
000027r 2  EA             nop               ; 2 cycles
000028r 2               
000028r 2               
000028r 2  88             dey               ; 2 cycles
000029r 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
00002Br 2  7A             ply
00002Cr 2  60             rts
00002Dr 2               
00002Dr 1               
00002Dr 1               .ifdef VIA1_BASE
00002Dr 1               .include "drivers/timer.s"
00002Dr 2               
00002Dr 2               
00002Dr 2               COUNTER = CLOCK_SPEED/400        ; n/s
00002Dr 2               
00002Dr 2               timer_init:
00002Dr 2  AD 8E FF         lda IER
000030r 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000032r 2  8D 8E FF         sta IER
000035r 2  A9 40            lda #$40        ; timer one free run mode
000037r 2  8D 8B FF         sta ACR
00003Ar 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
00003Cr 2  8D 84 FF         sta T1CL
00003Fr 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
000041r 2               
000041r 2  8D 85 FF         sta T1CH
000044r 2  64 rr            stz time
000046r 2  64 rr            stz time+1
000048r 2  64 rr            stz time+2
00004Ar 2  64 rr            stz time+3
00004Cr 2  58               cli
00004Dr 2  60               rts
00004Er 2               
00004Er 2               
00004Er 2               timer_irq:
00004Er 2  E6 rr            inc time
000050r 2  F0 01            beq @inc1
000052r 2               @exit1:
000052r 2                   ; this resets the PS/2 temp variables
000052r 2                   ;jsr reset_ps2
000052r 2  60               rts
000053r 2               @inc1:
000053r 2  E6 rr            inc time+1
000055r 2  F0 02            beq @inc2
000057r 2  80 F9            bra @exit1
000059r 2               @inc2:
000059r 2  E6 rr            inc time+2
00005Br 2  F0 02            beq @inc3
00005Dr 2  80 F3            bra @exit1
00005Fr 2               @inc3:
00005Fr 2  E6 rr            inc time+3
000061r 2  80 EF            bra @exit1
000063r 2  60               rts
000064r 2               
000064r 1               .include "drivers/spi.s"
000064r 2               ; SPI defines
000064r 2               .ifndef DATA
000064r 2               DATA = $80
000064r 2               .endif
000064r 2               SS = $07   ; Slave Select with lowest 3 bits
000064r 2               SCK = $08   ; Clock on bit 3
000064r 2               MISO = $10  ; MISO on bit 4
000064r 2               MOSI = $20  ; MOSI on bit 5
000064r 2               CONF = $40  ; CONF on bit 6
000064r 2               
000064r 2               .segment "BSS"
000406r 2  xx           spi_tmp: .res 1
000407r 2  xx           spi_tmp2: .res 1
000408r 2  xx           spi_slave: .res 1
000409r 2               
000409r 2               .segment "DATA"
000064r 2               
000064r 2               spi_init:
000064r 2  AD 80 FF         lda PORTB               ; load current port B
000067r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
000069r 2  09 40            ora #CONF               ; set CONF high
00006Br 2  8D 80 FF         sta PORTB               ; save to PORTB
00006Er 2  AD 82 FF         lda DDRB                ; get current direction register
000071r 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
000073r 2  29 EF            and #($FF^MISO)                 ; set MISO as input
000075r 2  8D 82 FF         sta DDRB
000078r 2  A9 FF            lda #$FF                ; flash leds to see what is going on
00007Ar 2  8D 83 FF         sta DDRA
00007Dr 2  8D 81 FF         sta PORTA
000080r 2  60               rts
000081r 2               
000081r 2               spi_select:
000081r 2                   ; selected slave in A
000081r 2  29 07            and #SS                 ; mask slave select bits
000083r 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
000086r 2  8D rr rr         sta spi_slave
000089r 2  5A               phy
00008Ar 2  A0 01            ldy #$1
00008Cr 2  20 rr rr         jsr delay_short         ; slight delay
00008Fr 2  09 40            ora #CONF               ; set CONF high to latch address
000091r 2  8D 80 FF         sta PORTB               ; save to PORTB
000094r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
000095r 2  60               rts
000096r 2               
000096r 2               spi_clk_toggle:
000096r 2  60               rts
000097r 2               
000097r 2               spi_transceive:
000097r 2                   ; send data in A, received data will be in A
000097r 2  5A               phy
000098r 2                   ; save data in RAM
000098r 2  8D rr rr         sta spi_tmp
00009Br 2                   ; reset X
00009Br 2  DA               phx
00009Cr 2  A2 08            ldx #8
00009Er 2                   ; reset result
00009Er 2  9C rr rr         stz spi_tmp2
0000A1r 2               spi_send_loop:
0000A1r 2  0E rr rr         asl spi_tmp
0000A4r 2  90 08            bcc bit_unset
0000A6r 2               bit_set:
0000A6r 2  AD 80 FF         lda PORTB
0000A9r 2  09 60            ora #(MOSI | CONF)
0000ABr 2  4C rr rr         jmp clock_on
0000AEr 2               bit_unset:
0000AEr 2  AD 80 FF         lda PORTB
0000B1r 2  29 DF            and #(($FF^MOSI) | CONF)
0000B3r 2               clock_on:
0000B3r 2                   ; set data bit
0000B3r 2  0D rr rr         ora spi_slave
0000B6r 2  8D 80 FF         sta PORTB
0000B9r 2               
0000B9r 2                   ; set clock on
0000B9r 2  09 48            ora #(SCK | CONF)
0000BBr 2  0D rr rr         ora spi_slave
0000BEr 2  8D 80 FF         sta PORTB
0000C1r 2               
0000C1r 2                   ; read bit from slave, maybe add slight delay here ?
0000C1r 2  AD 80 FF         lda PORTB
0000C4r 2  29 10            and #MISO           ; mask miso bit
0000C6r 2  D0 07            bne spi_bit_set      ; bit is set
0000C8r 2                   ; bit is unset
0000C8r 2  18               clc
0000C9r 2  2E rr rr         rol spi_tmp2
0000CCr 2  4C rr rr         jmp clock_off
0000CFr 2               
0000CFr 2               spi_bit_set:
0000CFr 2  38               sec
0000D0r 2  2E rr rr         rol spi_tmp2
0000D3r 2               
0000D3r 2               
0000D3r 2               clock_off:
0000D3r 2  AD 80 FF         lda PORTB
0000D6r 2  29 F7            and #(($FF^SCK) | CONF)
0000D8r 2  0D rr rr         ora spi_slave
0000DBr 2  8D 80 FF         sta PORTB
0000DEr 2               end_loop:
0000DEr 2  CA               dex
0000DFr 2  D0 C0            bne spi_send_loop
0000E1r 2                   ; set data low
0000E1r 2  A0 01            ldy #$1
0000E3r 2  20 rr rr         jsr delay_short
0000E6r 2  AD 80 FF         lda PORTB
0000E9r 2  0D rr rr         ora spi_slave
0000ECr 2  29 DF            and #(($FF^MOSI) | CONF)
0000EEr 2  8D 80 FF         sta PORTB
0000F1r 2  FA               plx
0000F2r 2  7A               ply
0000F3r 2  AD rr rr         lda spi_tmp2
0000F6r 2  60               rts
0000F7r 2               
0000F7r 1               .endif
0000F7r 1               
0000F7r 1               .ifdef ACIA_BASE
0000F7r 1               .include "drivers/acia.s"
0000F7r 2               ACIA_DELAY = CLOCK_SPEED / 500000
0000F7r 2               
0000F7r 2               acia_init:
0000F7r 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
0000FAr 2                                           ; set specific modes and functions
0000FAr 2  9C rr rr         stz has_acia
0000FDr 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
0000FFr 2                   ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
0000FFr 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
000102r 2  AD E2 FF         lda ACIA_CMD        ; load command register again
000105r 2  C9 0B            cmp #$0B                ; if not the same
000107r 2  D0 11            bne acia_absent         ; then it means the ACIA is not connected
000109r 2  AD E1 FF         lda ACIA_STATUS         ; Read the ACAI status to
00010Cr 2  29 60            and #$60                ; check if present or absent
00010Er 2  D0 0A            bne acia_absent
000110r 2  A9 01            lda #1
000112r 2  8D rr rr         sta has_acia           ; remember that ACIA is here
000115r 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000117r 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000117r 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
00011Ar 2               
00011Ar 2               acia_absent:
00011Ar 2  A0 14                ldy #20
00011Cr 2               aa_loop:
00011Cr 2  20 rr rr             jsr delay_short
00011Fr 2  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
000122r 2  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
000125r 2  88                   dey
000126r 2  D0 F4                bne aa_loop
000128r 2               aa_end:
000128r 2  60                   rts
000129r 2               
000129r 2               acia_out:
000129r 2  48               pha
00012Ar 2  5A               phy
00012Br 2  8D E0 FF         sta ACIA_DATA
00012Er 2  A0 30            ldy #ACIA_DELAY            ;minimal delay is $02
000130r 2  20 rr rr         jsr delay_short
000133r 2  7A               ply
000134r 2  68               pla
000135r 2  60               rts
000136r 2               
000136r 2               acia_getc:
000136r 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
000139r 2  29 08            and #$08                        ; Check if there is character in the receiver
00013Br 2  F0 05            beq @no_char      ; Exit now if we don't get one.
00013Dr 2  AD E0 FF         lda ACIA_DATA
000140r 2  38               sec
000141r 2  60               rts
000142r 2               @no_char:
000142r 2  18               clc
000143r 2  60               rts
000144r 2               
000144r 1               .endif
000144r 1               
000144r 1               
000144r 1               .ifdef KB_VIA_BASE
000144r 1               .include "drivers/keyboard.s"
000144r 1               .endif
000144r 1               .ifdef KB_INIT_STATE_RESET
000144r 1               .include "drivers/ps2.s"
000144r 1               .endif
000144r 1               
000144r 1               .ifdef LCD2_ENABLED
000144r 1               .include "drivers/4004.s"
000144r 1               .endif
000144r 1               .ifdef CF_ADDRESS
000144r 1               .include "drivers/cf.s"
000144r 2               .segment "ZEROPAGE": zeropage
00000Ar 2  xx xx        CF_POINTER: .res 2
00000Cr 2               
00000Cr 2               .segment "BSS"
000409r 2  xx xx xx xx  LBA_SIZE: .res 4
00040Dr 2               .segment "DATA"
000144r 2               
000144r 2               
000144r 2               
000144r 2               cf_init:
000144r 2                   ; phy
000144r 2  A9 04            lda #$4
000146r 2                   ; ldy #7
000146r 2                   ; sta (CF_ADDRESS),y
000146r 2  8D D7 FF         sta CF_ADDRESS + 7
000149r 2  20 rr rr         jsr cf_wait
00014Cr 2  A9 E0            lda #$E0
00014Er 2                   ; ldy #6
00014Er 2                   ; sta (CF_ADDRESS),y
00014Er 2  8D D6 FF         sta CF_ADDRESS + 6
000151r 2  A9 01            lda #$1
000153r 2                   ; ldy #1
000153r 2                   ; sta (CF_ADDRESS),y
000153r 2  8D D1 FF         sta CF_ADDRESS + 1
000156r 2  A9 EF            lda #$EF
000158r 2                   ; ldy #7
000158r 2                   ; sta (CF_ADDRESS),y
000158r 2  8D D7 FF         sta CF_ADDRESS + 7
00015Br 2  20 rr rr         jsr cf_wait
00015Er 2  20 rr rr         jsr cf_err
000161r 2                   ; ply
000161r 2  60               rts
000162r 2               
000162r 2               
000162r 2               
000162r 2               
000162r 2               cf_read:
000162r 2  5A               phy
000163r 2  A0 00            ldy #0
000165r 2               @loop:
000165r 2  20 rr rr         jsr cf_wait
000168r 2  AD D0 FF         lda CF_ADDRESS
00016Br 2                   ; jsr kernel_putc
00016Br 2  91 rr            sta (io_buffer_ptr), y
00016Dr 2  C8               iny
00016Er 2  D0 F5            bne @loop
000170r 2  E6 rr            inc io_buffer_ptr + 1
000172r 2               @loop2:
000172r 2  20 rr rr         jsr cf_wait
000175r 2  AD D0 FF         lda CF_ADDRESS
000178r 2                   ; jsr kernel_putc
000178r 2  91 rr            sta (io_buffer_ptr), y
00017Ar 2  C8               iny
00017Br 2  D0 F5            bne @loop2
00017Dr 2  C6 rr            dec io_buffer_ptr + 1
00017Fr 2               @loop3:
00017Fr 2  AD D7 FF         lda CF_ADDRESS + 7
000182r 2  29 08            and #$08
000184r 2  F0 06            beq @exit
000186r 2  AD D0 FF         lda CF_ADDRESS
000189r 2  C8               iny
00018Ar 2  D0 F3            bne @loop3
00018Cr 2               @exit:
00018Cr 2  7A               ply
00018Dr 2  60               rts
00018Er 2               
00018Er 2               
00018Er 2               ; number of sectors to read is in X
00018Er 2               cf_read_sector:
00018Er 2                   ; sei
00018Er 2  20 rr rr         jsr cf_set_lba
000191r 2                   ; ldy #2
000191r 2                   ; sta (CF_ADDRESS), y
000191r 2  A9 01            lda #1
000193r 2  8D D2 FF         sta CF_ADDRESS + 2
000196r 2  20 rr rr         jsr cf_wait
000199r 2  A9 20            lda #CF_READ_SECTOR_COMMAND
00019Br 2                   ; ldy #7
00019Br 2                   ; sta (CF_ADDRESS), y
00019Br 2  8D D7 FF         sta CF_ADDRESS + 7
00019Er 2  20 rr rr         jsr cf_wait
0001A1r 2  20 rr rr         jsr cf_read
0001A4r 2  20 rr rr         jsr cf_err
0001A7r 2                   ; cli
0001A7r 2  60               rts
0001A8r 2               
0001A8r 2               ; number of sectors to write is in X
0001A8r 2               cf_write_sector:
0001A8r 2                   ; sei
0001A8r 2  20 rr rr         jsr cf_set_lba
0001ABr 2  A9 01            lda #1
0001ADr 2                   ; ldy #2
0001ADr 2                   ; sta (CF_ADDRESS), y
0001ADr 2  8D D2 FF         sta CF_ADDRESS + 2
0001B0r 2  20 rr rr         jsr cf_wait
0001B3r 2  A9 30            lda #CF_WRITE_SECTOR_COMMAND
0001B5r 2                   ; ldy #7
0001B5r 2                   ; sta (CF_ADDRESS), y
0001B5r 2  8D D7 FF         sta CF_ADDRESS + 7
0001B8r 2  20 rr rr         jsr cf_wait
0001BBr 2  20 rr rr         jsr cf_write
0001BEr 2  20 rr rr         jsr cf_err
0001C1r 2                   ; cli
0001C1r 2  60               rts
0001C2r 2               
0001C2r 2               
0001C2r 2               cf_write:
0001C2r 2  5A               phy
0001C3r 2  A0 00            ldy #0
0001C5r 2               @loop:
0001C5r 2  20 rr rr         jsr cf_wait
0001C8r 2               
0001C8r 2  B1 rr            lda (io_buffer_ptr), y
0001CAr 2  8D D0 FF         sta CF_ADDRESS
0001CDr 2  C8               iny
0001CEr 2  D0 F5            bne @loop
0001D0r 2  E6 rr            inc io_buffer_ptr + 1
0001D2r 2               @loop2:
0001D2r 2  20 rr rr         jsr cf_wait
0001D5r 2  B1 rr            lda (io_buffer_ptr), y
0001D7r 2  8D D0 FF         sta CF_ADDRESS
0001DAr 2  C8               iny
0001DBr 2  D0 F5            bne @loop2
0001DDr 2  C6 rr            dec io_buffer_ptr + 1
0001DFr 2               @loop3:
0001DFr 2  AD D7 FF         lda CF_ADDRESS + 7
0001E2r 2  29 08            and #$08
0001E4r 2  F0 06            beq @exit
0001E6r 2  8D D0 FF         sta CF_ADDRESS
0001E9r 2  C8               iny
0001EAr 2  D0 F3            bne @loop3
0001ECr 2               @exit:
0001ECr 2  7A               ply
0001EDr 2  60               rts
0001EEr 2               
0001EEr 2               
0001EEr 2               
0001EEr 2               
0001EEr 2               
0001EEr 2               
0001EEr 2               cf_wait:
0001EEr 2                   ; phy
0001EEr 2                   ; ldy #7
0001EEr 2               @wait_loop:
0001EEr 2                   ; lda (CF_ADDRESS), y
0001EEr 2  AD D7 FF         lda CF_ADDRESS + 7
0001F1r 2  29 80            and #$80
0001F3r 2  D0 F9            bne @wait_loop
0001F5r 2                   ; ply
0001F5r 2  60               rts
0001F6r 2               
0001F6r 2               cf_set_lba:
0001F6r 2                   ; phy
0001F6r 2  AD rr rr         lda IO_SECTOR
0001F9r 2                   ; ldy #3
0001F9r 2                   ; sta (CF_ADDRESS),y
0001F9r 2  8D D3 FF         sta CF_ADDRESS + 3
0001FCr 2  AD rr rr         lda IO_SECTOR + 1
0001FFr 2                   ; ldy #4
0001FFr 2                   ; sta (CF_ADDRESS), y
0001FFr 2  8D D4 FF         sta CF_ADDRESS + 4
000202r 2  AD rr rr         lda IO_SECTOR + 2
000205r 2                   ; ldy #5
000205r 2                   ; sta (CF_ADDRESS), y
000205r 2  8D D5 FF         sta CF_ADDRESS + 5
000208r 2  AD rr rr         lda IO_SECTOR + 3
00020Br 2  29 0F            and #$0F
00020Dr 2  09 E0            ora #$E0
00020Fr 2                   ; ldy #6
00020Fr 2                   ; sta (CF_ADDRESS), y
00020Fr 2  8D D6 FF         sta CF_ADDRESS + 6
000212r 2                   ; ply
000212r 2  60               rts
000213r 2               
000213r 2               cf_err:
000213r 2                   ; phy
000213r 2  20 rr rr         jsr cf_wait
000216r 2                   ; ldy #7
000216r 2                   ; lda (CF_ADDRESS), y
000216r 2  AD D7 FF         lda CF_ADDRESS + 7
000219r 2  29 01            and #$01
00021Br 2  F0 05            beq @exit
00021Dr 2               @exit_fail:
00021Dr 2  A9 21            lda #'!'
00021Fr 2  20 rr rr         jsr kernel_putc
000222r 2               @exit:
000222r 2                   ; ply
000222r 2  60               rts
000223r 2               
000223r 2               cf_info:
000223r 2  20 rr rr         jsr cf_init
000226r 2  20 rr rr         jsr cf_wait
000229r 2  A9 EC            lda #$EC
00022Br 2  8D D7 FF         sta CF_ADDRESS + 7
00022Er 2  20 rr rr         jsr cf_read
000231r 2  60               rts
000232r 2               
000232r 2               cf_print_id:
000232r 2                   ; print model number
000232r 2  5A               phy
000233r 2  A0 37            ldy #55
000235r 2               @loop:
000235r 2  B1 rr            lda (io_buffer_ptr), y
000237r 2  20 rr rr         jsr kernel_putc
00023Ar 2  88               dey
00023Br 2  B1 rr            lda (io_buffer_ptr), y
00023Dr 2  20 rr rr         jsr kernel_putc
000240r 2  C8               iny
000241r 2  C8               iny
000242r 2  C8               iny
000243r 2  C0 5F            cpy #(40+55)
000245r 2  90 EE            bcc @loop
000247r 2  7A               ply
000248r 2  60               rts
000249r 2               
000249r 2               cf_print_capacity:
000249r 2  5A               phy
00024Ar 2               
00024Ar 2  20 rr rr         jsr xt_cr
00024Dr 2               
00024Dr 2  A0 78            ldy #120
00024Fr 2                   ; print lba size
00024Fr 2  B1 rr            lda (io_buffer_ptr), y
000251r 2  8D rr rr         sta LBA_SIZE
000254r 2  C8               iny
000255r 2  B1 rr            lda (io_buffer_ptr), y
000257r 2  8D rr rr         sta LBA_SIZE + 1
00025Ar 2               
00025Ar 2  C8               iny
00025Br 2  B1 rr            lda (io_buffer_ptr), y
00025Dr 2  8D rr rr         sta LBA_SIZE + 2
000260r 2               
000260r 2  C8               iny
000261r 2  B1 rr            lda (io_buffer_ptr), y
000263r 2  8D rr rr         sta LBA_SIZE + 3
000266r 2               
000266r 2  A0 09            ldy #9
000268r 2               @loop:
000268r 2  0E rr rr 2E      asl32 LBA_SIZE
00026Cr 2  rr rr 2E rr  
000270r 2  rr 2E rr rr  
000274r 2  88               dey
000275r 2  D0 F1            bne @loop
000277r 2               
000277r 2  CA               dex
000278r 2  CA               dex
000279r 2  CA               dex
00027Ar 2  CA               dex
00027Br 2               
00027Br 2  AD rr rr         lda LBA_SIZE
00027Er 2  95 02            sta 2, x
000280r 2  AD rr rr         lda LBA_SIZE + 1
000283r 2  95 03            sta 3, x
000285r 2  AD rr rr         lda LBA_SIZE + 2
000288r 2  95 00            sta 0, x
00028Ar 2  AD rr rr         lda LBA_SIZE + 3
00028Dr 2  95 01            sta 1, x
00028Fr 2               
00028Fr 2  20 rr rr         jsr xt_ud_dot
000292r 2               
000292r 2  CA               dex
000293r 2  CA               dex
000294r 2  CA               dex
000295r 2  CA               dex
000296r 2  A9 06            lda #6
000298r 2  95 00            sta 0, x
00029Ar 2  74 01            stz 1, x
00029Cr 2  A9 rr            lda #<bytes_msg
00029Er 2  95 02            sta 2, x
0002A0r 2  A9 rr            lda #>bytes_msg
0002A2r 2  95 03            sta 3, x
0002A4r 2  20 rr rr         jsr xt_type
0002A7r 2  20 rr rr         jsr xt_cr
0002AAr 2  7A               ply
0002ABr 2  60               rts
0002ACr 2  20 62 79 74  bytes_msg: .byte " bytes"
0002B0r 2  65 73        
0002B2r 2               cf_end:
0002B2r 2               
0002B2r 2               
0002B2r 1               io_read_sector_address = cf_read_sector
0002B2r 1               io_write_sector_address = cf_write_sector
0002B2r 1               .endif
0002B2r 1               .ifdef SD
0002B2r 1               
0002B2r 1               .include "drivers/sd.s"
0002B2r 1               io_read_sector_address = sd_read_sector
0002B2r 1               
0002B2r 1               .endif
0002B2r 1               
0002B2r 1               ; .if .def(SD)
0002B2r 1               ; .include "../../fat16.s"
0002B2r 1               ; .elseif .def(CF_ADDRESS)
0002B2r 1               ; .include "../../fat16.s"
0002B2r 1               ; .endif
0002B2r 1               
0002B2r 1               .include "../../utils.s"
0002B2r 2               ;  print a 16-bit integer
0002B2r 2               ; lsb in x, msb in a
0002B2r 2               
0002B2r 2               .segment "ZEROPAGE": zeropage
00000Cr 2  xx xx        util_tmp: .res 2
00000Er 2               
00000Er 2               .segment "BSS"
00040Dr 2  xx xx        util_tmp_var: .res 2
00040Fr 2  xx xx xx xx  pad: .res 4
000413r 2               
000413r 2               .segment "DATA"
0002B2r 2               
0002B2r 2               print16:
0002B2r 2  8D rr rr         sta acc+1
0002B5r 2  8E rr rr         stx acc
0002B8r 2               
0002B8r 2  A2 04            ldx #4
0002BAr 2               nextdig:
0002BAr 2  20 rr rr         jsr div
0002BDr 2  AD rr rr         lda ext
0002C0r 2  9D rr rr         sta num,x
0002C3r 2  CA               dex
0002C4r 2  10 F4            bpl nextdig
0002C6r 2               
0002C6r 2               firstdig:
0002C6r 2  E8               inx
0002C7r 2  E0 05            cpx #5
0002C9r 2  F0 17            beq print0
0002CBr 2  BD rr rr         lda num,x
0002CEr 2  F0 F6            beq firstdig
0002D0r 2               
0002D0r 2               ptnxtdig:
0002D0r 2  18               clc
0002D1r 2  69 30            adc #'0'
0002D3r 2  20 rr rr         jsr kernel_putc
0002D6r 2  E8               inx
0002D7r 2  E0 05            cpx #5
0002D9r 2  F0 06            beq pt16done
0002DBr 2  BD rr rr         lda num,x
0002DEr 2  4C rr rr         jmp ptnxtdig
0002E1r 2               
0002E1r 2               pt16done:
0002E1r 2  60               rts
0002E2r 2               
0002E2r 2               print0:
0002E2r 2  A9 30            lda #'0'
0002E4r 2  20 rr rr         jsr kernel_putc
0002E7r 2  60               rts
0002E8r 2               
0002E8r 2  00 00 00 00  num: .byte 0,0,0,0,0
0002ECr 2  00           
0002EDr 2               
0002EDr 2               ; 16/16-bit division, from the fridge
0002EDr 2               ; acc/aux -> acc, remainder in ext
0002EDr 2               div:
0002EDr 2  A9 00            lda #0
0002EFr 2  8D rr rr         sta ext+1
0002F2r 2  A0 10            ldy #$10
0002F4r 2               dloop:
0002F4r 2  0E rr rr         asl acc
0002F7r 2  2E rr rr         rol acc+1
0002FAr 2  2A               rol
0002FBr 2  2E rr rr         rol ext+1
0002FEr 2  48               pha
0002FFr 2  CD rr rr         cmp aux
000302r 2  AD rr rr         lda ext+1
000305r 2  ED rr rr         sbc aux+1
000308r 2  90 0B            bcc div2
00030Ar 2  8D rr rr         sta ext+1
00030Dr 2  68               pla
00030Er 2  ED rr rr         sbc aux
000311r 2  48               pha
000312r 2  EE rr rr         inc acc
000315r 2               div2:
000315r 2  68               pla
000316r 2  88               dey
000317r 2  D0 DB            bne dloop
000319r 2  8D rr rr         sta ext
00031Cr 2  60               rts
00031Dr 2               
00031Dr 2  00 00        acc: .word 0
00031Fr 2  0A 00        aux: .word 10 ; constant
000321r 2  00 00        ext: .word 0
000323r 2               
000323r 2               
000323r 2               
000323r 2               calculate_free_mem:
000323r 2                   ; load dictionary address
000323r 2                   ; fill with $55 until ram_end
000323r 2                   ; read and check same
000323r 2                   ; fill again with zeroes
000323r 2               
000323r 2  9C rr rr         stz util_tmp_var
000326r 2  9C rr rr         stz util_tmp_var + 1
000329r 2               
000329r 2  A0 00            ldy #0
00032Br 2               @loop:
00032Br 2  A9 55            lda #$55
00032Dr 2  91 rr            sta (util_tmp), y        ; store to mem address
00032Fr 2  D1 rr            cmp (util_tmp), y        ; compare to what is now there
000331r 2  D0 19            bne @exit               ; no equal, stop couting and exit
000333r 2  A9 00            lda #0                  ; zero the memory again
000335r 2  91 rr            sta (util_tmp), y
000337r 2  EE rr rr         inc util_tmp_var
00033Ar 2  D0 03            bne @incok
00033Cr 2  EE rr rr         inc util_tmp_var + 1
00033Fr 2               @incok:
00033Fr 2  C8               iny
000340r 2  D0 E9            bne @loop
000342r 2  A5 rr            lda util_tmp + 1
000344r 2  C9 80            cmp #>ram_end
000346r 2  B0 04            bcs @exit
000348r 2  E6 rr            inc util_tmp + 1
00034Ar 2  80 DF            bra @loop
00034Cr 2               @exit:
00034Cr 2  60               rts
00034Dr 2               
00034Dr 2               
00034Dr 2               
00034Dr 2               print_message:
00034Dr 2  68           	pla					; get return address from stack
00034Er 2  85 rr        	sta util_tmp
000350r 2  68           	pla
000351r 2  85 rr        	sta util_tmp + 1
000353r 2               
000353r 2  80 03        	bra @inc
000355r 2               @print:
000355r 2  20 rr rr     	jsr kernel_putc
000358r 2               
000358r 2               @inc:
000358r 2  E6 rr        	inc util_tmp
00035Ar 2  D0 02        	bne @inced
00035Cr 2  E6 rr        	inc util_tmp + 1
00035Er 2               @inced:
00035Er 2  B2 rr        	lda (util_tmp)
000360r 2  D0 F3        	bne @print
000362r 2  A5 rr        	lda util_tmp + 1
000364r 2  48           	pha
000365r 2  A5 rr        	lda util_tmp
000367r 2  48           	pha
000368r 2               print_message_end:
000368r 2  60           	rts
000369r 2               
000369r 2               
000369r 2               print_zp_index_string:
000369r 2               @loop:
000369r 2  B1 rr            lda (util_tmp), y
00036Br 2  F0 06            beq @exit
00036Dr 2  20 rr rr         jsr kernel_putc
000370r 2  C8               iny
000371r 2  D0 F6            bne @loop
000373r 2               @exit:
000373r 2  60               rts
000374r 2               
000374r 2               
000374r 2               output_ascii:
000374r 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
000374r 2  48               pha
000375r 2  4A               lsr             ; convert high nibble first
000376r 2  4A               lsr
000377r 2  4A               lsr
000378r 2  4A               lsr
000379r 2  20 rr rr         jsr output_ascii_nibble_to_ascii
00037Cr 2  68               pla
00037Dr 2               
00037Dr 2                   ; fall through to _nibble_to_ascii
00037Dr 2               
00037Dr 2               output_ascii_nibble_to_ascii:
00037Dr 2               ; """Private helper function for byte_to_ascii: Print lower nibble
00037Dr 2               ; of A and and EMIT it. This does the actual work.
00037Dr 2               ; """
00037Dr 2  29 0F            and #$0F
00037Fr 2  09 30            ora #'0'
000381r 2  C9 3A            cmp #$3A        ; '9+1
000383r 2  90 02            bcc @1
000385r 2  69 06            adc #$06
000387r 2               
000387r 2               @1:
000387r 2  20 rr rr         jsr kernel_putc
00038Ar 2  60               rts
00038Br 2               
00038Br 1               
00038Br 1               ; .include "drivers/spi.s"
00038Br 1               ; .include "drivers/sd.s"
00038Br 1               ; .include "drivers/vga.s"
00038Br 1               ; .include "drivers/fat32.s"
00038Br 1               ; .include "drivers/lcd.s"
00038Br 1               
00038Br 1               
00038Br 1               .include "../../forth.s"
00038Br 2               
00038Br 2               
00038Br 2               ; Definitions for Tali Forth 2
00038Br 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00038Br 2               ; First version: 01. Apr 2016 (Liara Forth)
00038Br 2               ; This version: 29. Jan 2020
00038Br 2               
00038Br 2               ; This file is included by taliforth.asm. These are the general
00038Br 2               ; definitions; platform-specific definitions such as the
00038Br 2               ; memory map are kept in the platform folder.
00038Br 2               
00038Br 2               stack0 =    $0100   ; location of the stack
00038Br 2               
00038Br 2               ; User Variables:
00038Br 2               ; Block variables
00038Br 2               blk_offset =  0        ; BLK : UP + 0
00038Br 2               scr_offset =  2        ; SCR : UP + 2
00038Br 2               
00038Br 2               ; Wordlists
00038Br 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
00038Br 2               num_wordlists_offset =  5
00038Br 2                                          ; #WORDLISTS (byte) : UP + 5
00038Br 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
00038Br 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
00038Br 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
00038Br 2                                          ;          (Number of wordlists in search order)
00038Br 2               search_order_offset =  31
00038Br 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
00038Br 2                                          ; Allowing for 9 to keep offsets even.
00038Br 2               max_wordlists =  12    ; Maximum number of wordlists supported
00038Br 2                                          ; 4 Tali built-ins + 8 user wordlists
00038Br 2               
00038Br 2               ; Buffer variables
00038Br 2               blkbuffer_offset =     40   ; Address of buffer
00038Br 2               buffblocknum_offset =  42   ; Block number current in buffer
00038Br 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
00038Br 2               
00038Br 2               ; Block I/O vectors
00038Br 2               blockread_offset =     46   ; Vector to block reading routine
00038Br 2               blockwrite_offset =    48   ; Vector to block writing routine
00038Br 2               
00038Br 2               
00038Br 2               ; ASCII CHARACTERS
00038Br 2               AscCC =   $03  ; break (CTRL-c)
00038Br 2               AscBELL = $07  ; bell sound
00038Br 2               AscBS =   $08  ; backspace
00038Br 2               AscLF =   $0a  ; line feed
00038Br 2               AscCR =   $0d  ; carriage return
00038Br 2               AscESC =  $1b  ; escape
00038Br 2               AscSP =   $20  ; space
00038Br 2               AscDEL =  $7f  ; delete (CTRL-h)
00038Br 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
00038Br 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
00038Br 2               
00038Br 2               ; DICTIONARY FLAGS
00038Br 2               ; The first three bits are currently unused
00038Br 2               CO = 1  ; Compile Only
00038Br 2               AN = 2  ; Always Native Compile
00038Br 2               IM = 4  ; Immediate Word
00038Br 2               NN = 8  ; Never Native Compile
00038Br 2               UF = 16 ; Includes Underflow Check (RESERVED)
00038Br 2               HC = 32 ; Word has Code Field Area (CFA)
00038Br 2               
00038Br 2               
00038Br 2               ; VARIOUS
00038Br 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
00038Br 2               
00038Br 2               ; END
00038Br 2               
00038Br 2               .segment "ZEROPAGE": zeropage
00000Er 2               ; ZERO PAGE ADDRESSES/VARIABLES
00000Er 2               
00000Er 2               ; These are kept at the top of Zero Page, with the most important variables at
00000Er 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
00000Er 2               ; an overflow, the lower, less important variables will be clobbered first,
00000Er 2               ; giving the system a chance to recover. In other words, they are part of the
00000Er 2               ; floodplain.
00000Er 2               
00000Er 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
00000Er 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
00000Er 2               
00000Er 2  xx xx        cp: .res 2   ; Compiler Pointer
000010r 2  xx xx        dp: .res 2   ; Dictionary Pointer
000012r 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
000014r 2                                          ; a :NONAME declared word (see status)
000014r 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
000016r 2  xx xx        cib: .res 2   ; address of current input buffer
000018r 2  xx xx        ciblen: .res 2  ; length of current input buffer
00001Ar 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
00001Cr 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
00001Er 2  xx xx        output: .res 2  ; vector for EMIT
000020r 2  xx xx        input: .res 2  ; vector for KEY
000022r 2  xx xx        havekey: .res 2  ; vector for KEY?
000024r 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
000026r 2  xx xx        base: .res 2  ; number radix, default decimal
000028r 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
00002Ar 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
00002Cr 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
00002Er 2  xx xx        status: .res 2  ; internal status information
000030r 2                                          ; (used by : :NONAME ; ACCEPT)
000030r 2                                          ; Bit 7 = Redefined word message postpone
000030r 2                                          ;         When set before calling CREATE, it will
000030r 2                                          ;         not print the "redefined xxxx" message if
000030r 2                                          ;         the word exists. Instead, this bit will
000030r 2                                          ;         be reused and after CREATE has run, it will
000030r 2                                          ;         be set if the word was redefined and 0 if
000030r 2                                          ;         not. This bit should be 0 when not in use.
000030r 2                                          ; Bit 6 = 1 for normal ":" definitions
000030r 2                                          ;         WORKWORD contains nt of word being compiled
000030r 2                                          ;       = 0 for :NONAME definitions
000030r 2                                          ;         WORKWORD contains xt of word being compiled
000030r 2                                          ; Bit 5 = 1 for NUMBER returning a double word
000030r 2                                          ;       = 0 for NUMBER returning a single word
000030r 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
000030r 2                                          ;       = 0 CTRL-n recalls previous history
000030r 2                                          ; Bit 2 = Current history buffer msb
000030r 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
000030r 2                                          ; Bit 0 = Current history buffer lsb
000030r 2                                          ; status+1 is used by ACCEPT to hold history lengths.
000030r 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
000032r 2  xx xx        tmp1: .res 2  ; temporary storage
000034r 2  xx xx        tmp2: .res 2  ; temporary storage
000036r 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
000038r 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
00003Ar 2  xx xx        tmptos: .res 2  ; temporary TOS storage
00003Cr 2  xx xx        editor1: .res 2  ; temporary for editors
00003Er 2  xx xx        editor2: .res 2  ; temporary for editors
000040r 2  xx xx        editor3: .res 2  ; temporary for editors
000042r 2  xx xx        tohold: .res 2  ; pointer for formatted output
000044r 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
000048r 2  xx xx xx xx  
00004Cr 2               
00004Cr 2               .segment "DATASTACK": zeropage
000000r 2  xx xx xx xx  dsp_start: .res 127 ; reserve 128 bytes for data stack (64 16 bit cells)
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
00007Fr 2               dsp0:          ; first data stack location. Data stack grows down
00007Fr 2               rsp0:     ; starting stack pointer
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               .segment "BSS"
000413r 2  xx xx xx xx  hist_buff: .res $400
000417r 2  xx xx xx xx  
00041Br 2  xx xx xx xx  
000813r 2  xx xx xx xx  buffer0: .res $100
000817r 2  xx xx xx xx  
00081Br 2  xx xx xx xx  
000913r 2               
000913r 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
00038Br 2               
00038Br 2               
00038Br 2               
00038Br 2               forth:
00038Br 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
00038Br 3               ; Low-level Forth word routines
00038Br 3               ; Tali Forth 2 for the 65c02
00038Br 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00038Br 3               ; First version: 19. Jan 2014
00038Br 3               ; This version: 03. Jan 2018
00038Br 3               
00038Br 3               ; This list is ordered alphabetically by the names of the words, not their
00038Br 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
00038Br 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
00038Br 3               ; status lines that begins with "; ## ", which allows auto-generation of the
00038Br 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
00038Br 3               
00038Br 3               ;       TBA --> fragment --> coded --> tested --> auto
00038Br 3               
00038Br 3               ; "Auto" means that the word is automatically tested by the test suite (good),
00038Br 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
00038Br 3               ; it hasn't been tested at all (bad). See the test suite for more details.
00038Br 3               
00038Br 3               ; ## COLD ( -- ) "Reset the Forth system"
00038Br 3               ; ## "cold"  tested  Tali Forth
00038Br 3               ;       """Reset the Forth system. Does not restart the kernel,
00038Br 3               ;       use the 65c02 reset for that. Flows into ABORT.
00038Br 3               ;       """
00038Br 3               xt_cold:
00038Br 3  D8                           cld
00038Cr 3               
00038Cr 3                               ; Set the OUTPUT vector to the default kernel_putc
00038Cr 3                               ; We do this really early so we can print error messages
00038Cr 3                               ; during debugging
00038Cr 3  A9 rr                        lda #<kernel_putc
00038Er 3  85 rr                        sta output
000390r 3  A9 rr                        lda #>kernel_putc
000392r 3  85 rr                        sta output+1
000394r 3               
000394r 3                               ; Load all of the important zero page variables from ROM
000394r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
000396r 3               
000396r 3               @load_zp_loop:
000396r 3                               ; This loop loads them back to front. We can use X here
000396r 3                               ; because Tali hasn't started using the stack yet.
000396r 3  BD rr rr                     lda cold_zp_table,x
000399r 3  95 rr                        sta cp,x
00039Br 3  CA                           dex
00039Cr 3  D0 F8                        bne @load_zp_loop
00039Er 3               
00039Er 3                               ; Copy the 0th element.
00039Er 3  AD rr rr                     lda cold_zp_table
0003A1r 3  85 rr                        sta cp
0003A3r 3                               ; Initialize 65c02 stack (Return Stack)
0003A3r 3  A2 rr                        ldx #rsp0
0003A5r 3  9A                           txs
0003A6r 3               
0003A6r 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
0003A6r 3                               ; can load high-level words with EVALUATE
0003A6r 3  A2 rr                        ldx #dsp0
0003A8r 3               
0003A8r 3               
0003A8r 3                               ; Initialize the user variables.
0003A8r 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
0003AAr 3  A9 00                        lda #0
0003ACr 3               
0003ACr 3               @load_user_vars_loop:
0003ACr 3                               ; Like the zero page variables, these are initialized
0003ACr 3                               ; back to front.
0003ACr 3  B9 rr rr                     lda cold_user_table,y
0003AFr 3  91 rr                        sta (up),y
0003B1r 3  88                           dey
0003B2r 3  D0 F8                        bne @load_user_vars_loop
0003B4r 3               
0003B4r 3                               ; Copy the 0th element.
0003B4r 3  AD rr rr                     lda cold_user_table
0003B7r 3  92 rr                        sta (up)
0003B9r 3  20 rr rr                     jsr xt_cr
0003BCr 3               
0003BCr 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
0003BCr 3                               ; you do not have any high-level words, this part can be
0003BCr 3                               ; commented out.
0003BCr 3  CA                           dex
0003BDr 3  CA                           dex
0003BEr 3  CA                           dex
0003BFr 3  CA                           dex
0003C0r 3               
0003C0r 3               
0003C0r 3                               ; start address goes NOS
0003C0r 3  A9 rr                        lda #<forth_words_start
0003C2r 3  95 02                        sta 2,x
0003C4r 3  A9 rr                        lda #>forth_words_start
0003C6r 3  95 03                        sta 3,x
0003C8r 3               
0003C8r 3                               ; length goes TOS
0003C8r 3  A9 rr                        lda #<forth_words_end
0003CAr 3  38                           sec
0003CBr 3  E9 rr                        sbc #<forth_words_start
0003CDr 3  95 00                        sta 0,x
0003CFr 3               
0003CFr 3  A9 rr                        lda #>forth_words_end
0003D1r 3  E9 rr                        sbc #>forth_words_start
0003D3r 3  95 01                        sta 1,x
0003D5r 3               
0003D5r 3               
0003D5r 3  20 rr rr                     jsr xt_evaluate
0003D8r 3               
0003D8r 3                               ; Now define any user words via EVALUATE. If you do not have
0003D8r 3                               ; any user-defined words, this part can be commented out as
0003D8r 3                               ; well.
0003D8r 3  CA                           dex
0003D9r 3  CA                           dex
0003DAr 3  CA                           dex
0003DBr 3  CA                           dex
0003DCr 3               
0003DCr 3               
0003DCr 3                               ; start address goes NOS
0003DCr 3  A9 rr                        lda #<user_words_start
0003DEr 3  95 02                        sta 2,x
0003E0r 3  A9 rr                        lda #>user_words_start
0003E2r 3  95 03                        sta 3,x
0003E4r 3               
0003E4r 3                               ; length goes TOS
0003E4r 3  A9 rr                        lda #<user_words_end
0003E6r 3  38                           sec
0003E7r 3  E9 rr                        sbc #<user_words_start
0003E9r 3  95 00                        sta 0,x
0003EBr 3               
0003EBr 3  A9 rr                        lda #>user_words_end
0003EDr 3  E9 rr                        sbc #>user_words_start
0003EFr 3  95 01                        sta 1,x
0003F1r 3               
0003F1r 3  20 rr rr                     jsr xt_evaluate
0003F4r 3               
0003F4r 3                               ; Initialize all of the history buffers by putting a zero in
0003F4r 3                               ; each length byte.
0003F4r 3  9C rr rr                     stz hist_buff
0003F7r 3  9C rr rr                     stz hist_buff+$80
0003FAr 3  9C rr rr                     stz hist_buff+$100
0003FDr 3  9C rr rr                     stz hist_buff+$180
000400r 3  9C rr rr                     stz hist_buff+$200
000403r 3  9C rr rr                     stz hist_buff+$280
000406r 3  9C rr rr                     stz hist_buff+$300
000409r 3  9C rr rr                     stz hist_buff+$380
00040Cr 3               
00040Cr 3               
00040Cr 3                               ; fall through to ABORT
00040Cr 3               
00040Cr 3               
00040Cr 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
00040Cr 3               ; ## "abort"  tested  ANS core
00040Cr 3                       ; """https://forth-standard.org/standard/core/ABORT
00040Cr 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
00040Cr 3                       ; subroutine if we want to because we are going to reset the 65c02's
00040Cr 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
00040Cr 3                       ; actually delete the stuff on the Data Stack.
00040Cr 3                       ; """
00040Cr 3               xt_abort:
00040Cr 3  A2 rr                        ldx #dsp0
00040Er 3               
00040Er 3                               ; fall through to QUIT
00040Er 3               
00040Er 3               
00040Er 3               ; ## QUIT ( -- ) "Reset the input and get new input"
00040Er 3               ; ## "quit"  tested  ANS core
00040Er 3                       ; """https://forth-standard.org/standard/core/QUIT
00040Er 3                       ; Rest the input and start command loop
00040Er 3                       ; """
00040Er 3               
00040Er 3               xt_quit:
00040Er 3                               ; Clear the Return Stack. This is a little screwed up
00040Er 3                               ; because the 65c02 can only set the Return Stack via X,
00040Er 3                               ; which is our Data Stack pointer. The ANS specification
00040Er 3                               ; demands, however, that ABORT reset the Data Stack pointer
00040Er 3  8A                           txa             ; Save the DSP that we just defined
00040Fr 3  A2 rr                        ldx #rsp0
000411r 3  9A                           txs
000412r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000413r 3               
000413r 3                               ; make sure instruction pointer is empty
000413r 3  64 rr                        stz ip
000415r 3  64 rr                        stz ip+1
000417r 3               
000417r 3                               ; SOURCE-ID is zero (keyboard input)
000417r 3  64 rr                        stz insrc
000419r 3  64 rr                        stz insrc+1
00041Br 3               
00041Br 3                               ; STATE is zero (interpret, not compile)
00041Br 3  64 rr                        stz state
00041Dr 3  64 rr                        stz state+1
00041Fr 3               @get_line:
00041Fr 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
000421r 3  85 rr                        sta cib
000423r 3  A9 rr                        lda #>buffer0
000425r 3  85 rr                        sta cib+1
000427r 3               
000427r 3                               ; Size of current input buffer (CIB) is zero
000427r 3  64 rr                        stz ciblen
000429r 3  64 rr                        stz ciblen+1
00042Br 3               
00042Br 3                               ; Accept a line from the current import source. This is how
00042Br 3                               ; modern Forths to it.
00042Br 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00042Er 3               
00042Er 3                               ; Test flag: LSB of TOS
00042Er 3  B5 00                        lda 0,x
000430r 3  D0 05                        bne @success
000432r 3               
000432r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
000432r 3                               ; need to print an error message and reset the machine. We
000432r 3                               ; don't need to save TOS because we're going to clobber it
000432r 3                               ; anyway when we go back to ABORT.
000432r 3  A9 06                        lda #err_refill
000434r 3  4C rr rr                     jmp error
000437r 3               
000437r 3               @success:
000437r 3                               ; Assume we have successfully accepted a string of input from
000437r 3                               ; a source, with address cib and length of input in ciblen. We
000437r 3                               ; arrive here still with the TRUE flag from REFILL as TOS
000437r 3  E8                           inx                     ; drop
000438r 3  E8                           inx
000439r 3               
000439r 3                               ; Main compile/execute routine
000439r 3  20 rr rr                     jsr interpret
00043Cr 3               
00043Cr 3                               ; Test for Data Stack underflow. Tali Forth does not check for
00043Cr 3                               ; overflow because it is so rare
00043Cr 3  E0 rr                        cpx #dsp0
00043Er 3  F0 05                        beq @stack_ok
000440r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
000442r 3               
000442r 3  4C rr rr                     jmp underflow_error
000445r 3               
000445r 3               @stack_ok:
000445r 3                               ; Display system prompt if all went well. If we're interpreting,
000445r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
000445r 3                               ; space at beginning of the string.
000445r 3  A5 rr                        lda state
000447r 3  F0 02                        beq @print
000449r 3               
000449r 3  A9 01                        lda #1                  ; number for "compile" string
00044Br 3               @print:
00044Br 3  20 rr rr                     jsr print_string
00044Er 3               
00044Er 3                               ; Awesome line, everybody! Now get the next one.
00044Er 3  80 CF                        bra @get_line
000450r 3               
000450r 3               z_cold:
000450r 3               z_abort:
000450r 3               z_quit:         ; no RTS required
000450r 3               
000450r 3               
000450r 3               
000450r 3               ; This table holds all of the initial values for the variables in zero page.
000450r 3               ; This table is used by COLD.
000450r 3               cold_zp_table:
000450r 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
000452r 3                                               ; block buffer
000452r 3  rr rr                .word dictionary_start  ; dp
000454r 3  00 00                .word 0                 ; workword
000456r 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000458r 3  rr rr                .word buffer0           ; cib
00045Ar 3  00 00                .word 0                 ; ciblen
00045Cr 3  00 00                .word 0                 ; toin
00045Er 3  00 00                .word 0                 ; ip
000460r 3  rr rr                .word kernel_putc       ; output
000462r 3  rr rr                .word kernel_getc       ; input
000464r 3  00 00                .word 0                 ; havekey
000466r 3  00 00                .word 0                 ; state (0 = interpret)
000468r 3  0A 00                .word 10                ; base
00046Ar 3  14 00                .word 20                ; nc-limit
00046Cr 3  00 00                .word 0                 ; uf_strip (off by default)
00046Er 3  rr rr                .word cp0               ; up (user vars put right at beginning of
000470r 3                                               ; available RAM)
000470r 3  00 00                .word 0                 ; status
000472r 3               cold_zp_table_end:
000472r 3               
000472r 3               ; No further ZP variables are initialized. The variables past this point are
000472r 3               ; all temporaries.
000472r 3               
000472r 3               ; This table holds the inital values for the user variables. This table is
000472r 3               ; used by COLD.
000472r 3               cold_user_table:
000472r 3  00 00                .word 0                         ; BLK
000474r 3  00 00                .word 0                         ; SCR
000476r 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
000477r 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000478r 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
00047Ar 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
00047Cr 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
00047Er 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
000480r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000484r 3  00 00 00 00  
000488r 3  00 00 00 00  
000490r 3  01                   .byte 1                         ; #ORDER
000491r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
000495r 3  00 00 00 00  
000499r 3  00           
00049Ar 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
00049Cr 3  00 00                .word 0                         ; block in buffer
00049Er 3  00 00                .word 0                         ; buffer status (not in use)
0004A0r 3  rr rr                .word xt_block_word_error       ; block-read vector
0004A2r 3  rr rr                .word xt_block_word_error       ; block-write vector
0004A4r 3               cold_user_table_end:
0004A4r 3               
0004A4r 3               
0004A4r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
0004A4r 3               ; ## "abort""  tested  ANS core
0004A4r 3                       ; """https://forth-standard.org/standard/core/ABORTq
0004A4r 3                       ; Abort and print a string.
0004A4r 3                       ; """
0004A4r 3               
0004A4r 3               xt_abort_quote:
0004A4r 3                               ; save the string
0004A4r 3  20 rr rr                     jsr xt_s_quote          ; S"
0004A7r 3               
0004A7r 3                               ; compile run-time part
0004A7r 3  A0 rr                        ldy #>abort_quote_runtime
0004A9r 3  A9 rr                        lda #<abort_quote_runtime
0004ABr 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
0004AEr 3               
0004AEr 3  60           z_abort_quote:  rts
0004AFr 3               
0004AFr 3               
0004AFr 3               abort_quote_runtime:
0004AFr 3                       ; """Runtime aspect of ABORT_QUOTE"""
0004AFr 3               
0004AFr 3                               ; We arrive here with ( f addr u )
0004AFr 3  B5 04                        lda 4,x
0004B1r 3  15 05                        ora 5,x
0004B3r 3  F0 09                        beq @done       ; if FALSE, we're done
0004B5r 3               
0004B5r 3                               ; We're true, so print string and ABORT. We follow Gforth
0004B5r 3                               ; in going to a new line after the string
0004B5r 3  20 rr rr                     jsr xt_type
0004B8r 3  20 rr rr                     jsr xt_cr
0004BBr 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
0004BEr 3               @done:
0004BEr 3                               ; Drop three entries from the Data Stack
0004BEr 3  8A                           txa
0004BFr 3  18                           clc
0004C0r 3  69 06                        adc #6
0004C2r 3  AA                           tax
0004C3r 3               
0004C3r 3  60                           rts
0004C4r 3               
0004C4r 3               
0004C4r 3               
0004C4r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
0004C4r 3               ; ## "abs"  auto  ANS core
0004C4r 3                       ; """https://forth-standard.org/standard/core/ABS
0004C4r 3                       ; Return the absolute value of a number.
0004C4r 3                       ; """
0004C4r 3               
0004C4r 3               xt_abs:
0004C4r 3  20 rr rr                     jsr underflow_1
0004C7r 3               
0004C7r 3  B5 01                        lda 1,x
0004C9r 3  10 0D                        bpl @done       ; positive number, easy money!
0004CBr 3               
0004CBr 3                               ; negative: calculate 0 - n
0004CBr 3  38                           sec
0004CCr 3  A9 00                        lda #0
0004CEr 3  F5 00                        sbc 0,x         ; LSB
0004D0r 3  95 00                        sta 0,x
0004D2r 3               
0004D2r 3  A9 00                        lda #0          ; MSB
0004D4r 3  F5 01                        sbc 1,x
0004D6r 3  95 01                        sta 1,x
0004D8r 3               
0004D8r 3               @done:
0004D8r 3  60           z_abs:          rts
0004D9r 3               
0004D9r 3               
0004D9r 3               
0004D9r 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
0004D9r 3               ; ## "accept"  auto  ANS core
0004D9r 3                       ; """https://forth-standard.org/standard/core/ACCEPT
0004D9r 3                       ; Receive a string of at most n1 characters, placing them at
0004D9r 3                       ; addr. Return the actual number of characters as n2. Characters
0004D9r 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
0004D9r 3                       ; modern Forths.
0004D9r 3                       ; """
0004D9r 3               
0004D9r 3               xt_accept:
0004D9r 3  20 rr rr                     jsr underflow_2
0004DCr 3               
0004DCr 3                               ; Abort if we were asked to receive 0 chars
0004DCr 3  B5 00                        lda 0,x
0004DEr 3  15 01                        ora 1,x
0004E0r 3  D0 09                        bne @not_zero
0004E2r 3               
0004E2r 3  E8                           inx
0004E3r 3  E8                           inx
0004E4r 3  74 00                        stz 0,x
0004E6r 3  74 01                        stz 1,x
0004E8r 3               
0004E8r 3  4C rr rr                     jmp accept_done
0004EBr 3               
0004EBr 3               @not_zero:
0004EBr 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
0004EDr 3  85 rr                        sta tmp2
0004EFr 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
0004F1r 3               
0004F1r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
0004F3r 3  85 rr                        sta tmp1
0004F5r 3  B5 03                        lda 3,x
0004F7r 3  85 rr                        sta tmp1+1
0004F9r 3               
0004F9r 3  E8                           inx
0004FAr 3  E8                           inx
0004FBr 3               
0004FBr 3  A0 00                        ldy #0
0004FDr 3               
0004FDr 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
0004FDr 3                               ; from bit 2 to 3 is OK)
0004FDr 3  A5 rr                        lda status
0004FFr 3  29 F7                        and #$f7
000501r 3               
000501r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000501r 3  1A                           inc
000502r 3               
000502r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000502r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000502r 3                               ; received and won't be used to calculate the history buffer
000502r 3                               ; offset.
000502r 3  09 08                        ora #$08
000504r 3  85 rr                        sta status
000506r 3               
000506r 3               accept_loop:
000506r 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000506r 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000506r 3                               ; vt100 terminal clears the screen automatically.
000506r 3               
000506r 3                               ; This is the internal version of KEY without all the mucking
000506r 3                               ; about with the Data Stack while still using the input vector
000506r 3  20 rr rr                     jsr key_a
000509r 3               
000509r 3                               ; We quit on both line feed and carriage return
000509r 3  C9 0A                        cmp #AscLF
00050Br 3  F0 20                        beq @eol
00050Dr 3  C9 0D                        cmp #AscCR
00050Fr 3  F0 1C                        beq @eol
000511r 3               
000511r 3                               ; BACKSPACE and DEL do the same thing for the moment
000511r 3  C9 08                        cmp #AscBS
000513r 3  F0 22                        beq @backspace
000515r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000517r 3  F0 1E                        beq @backspace
000519r 3               
000519r 3                               ; Check for CTRL-p and CTRL-n to recall input history
000519r 3  C9 10                        cmp #AscCP
00051Br 3  F0 36                        beq @ctrl_p
00051Dr 3  C9 0E                        cmp #AscCN
00051Fr 3  F0 44                        beq @ctrl_n
000521r 3               
000521r 3                               ; That's enough for now. Save and echo character.
000521r 3  91 rr                        sta (tmp1),y
000523r 3  C8                           iny
000524r 3               
000524r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000524r 3  20 rr rr                     jsr emit_a
000527r 3               
000527r 3  C4 rr                        cpy tmp2        ; reached character limit?
000529r 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
00052Br 3  80 03                        bra @buffer_full
00052Dr 3               
00052Dr 3               @eol:
00052Dr 3  20 rr rr                     jsr xt_space    ; print final space
000530r 3               
000530r 3               @buffer_full:
000530r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
000530r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
000532r 3  74 01                        stz 1,x         ; we only accept 256 chars
000534r 3               
000534r 3  4C rr rr                     jmp accept_done
000537r 3               
000537r 3               @backspace:
000537r 3                               ; Handle backspace and delete kex, which currently do the same
000537r 3                               ; thing
000537r 3  C0 00                        cpy #0          ; buffer empty?
000539r 3  D0 06                        bne @1
00053Br 3               
00053Br 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
00053Dr 3  20 rr rr                     jsr emit_a
000540r 3  C8                           iny
000541r 3               @1:
000541r 3  88                           dey
000542r 3  A9 08                        lda #AscBS      ; move back one
000544r 3  20 rr rr                     jsr emit_a
000547r 3  A9 20                        lda #AscSP      ; print a space (rubout)
000549r 3  20 rr rr                     jsr emit_a
00054Cr 3  A9 08                        lda #AscBS      ; move back over space
00054Er 3  20 rr rr                     jsr emit_a
000551r 3               
000551r 3  80 B3                        bra accept_loop
000553r 3               
000553r 3               @ctrl_p:
000553r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000553r 3               
000553r 3                               ; Select the previous buffer
000553r 3  A5 rr                        lda status
000555r 3               
000555r 3                               ; Check for 0 (need to wrap back to 7)
000555r 3  29 07                        and #7
000557r 3  D0 08                        bne @ctrl_p_dec
000559r 3               
000559r 3                               ; We need to wrap back to 7.
000559r 3  A5 rr                        lda status
00055Br 3  09 07                        ora #7
00055Dr 3  85 rr                        sta status
00055Fr 3  80 11                        bra @recall_history
000561r 3               
000561r 3               @ctrl_p_dec:
000561r 3                               ; It's safe to decrement the buffer index directly.
000561r 3  C6 rr                        dec status
000563r 3  80 0D                        bra @recall_history
000565r 3               
000565r 3               @ctrl_n:
000565r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000565r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000565r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000565r 3                               ; history buffer.
000565r 3  A9 08                        lda #$8
000567r 3  24 rr                        bit status
000569r 3  D0 07                        bne @recall_history
00056Br 3               
00056Br 3                               ; This isn't the first time CTRL-n has been pressed, select the
00056Br 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
00056Br 3  A5 rr                        lda status
00056Dr 3  29 F7                        and #$f7
00056Fr 3               
00056Fr 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
00056Fr 3  1A                           inc
000570r 3               
000570r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
000570r 3                               ; be cleared below.
000570r 3  85 rr                        sta status
000572r 3               
000572r 3                               ; Falls through to @recall_history
000572r 3               
000572r 3               @recall_history:
000572r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000572r 3  A9 08                        lda #%00001000
000574r 3  14 rr                        trb status
000576r 3               
000576r 3  20 rr rr                     jsr total_recall
000579r 3               
000579r 3                               ; tmp3 now has the address of the previous history buffer.
000579r 3                               ; First byte of buffer is length. Clear the line by sending
000579r 3                               ; CR, Y spaces, then CR.
000579r 3  A9 0D                        lda #AscCR
00057Br 3  20 rr rr                     jsr emit_a
00057Er 3               
00057Er 3               input_clear:
00057Er 3  C0 00                        cpy #0
000580r 3  F0 08                        beq input_cleared
000582r 3               
000582r 3  A9 20                        lda #AscSP
000584r 3  20 rr rr                     jsr emit_a
000587r 3  88                           dey
000588r 3  80 F4                        bra input_clear
00058Ar 3               
00058Ar 3               input_cleared:
00058Ar 3  A9 0D                        lda #AscCR
00058Cr 3  20 rr rr                     jsr emit_a
00058Fr 3               
00058Fr 3                               ; Save the history length byte into histinfo+1
00058Fr 3                               ; ldy #0        ; Y is already 0 by clearing the line.
00058Fr 3  B1 rr                        lda (tmp3),y
000591r 3  85 rr                        sta status+1
000593r 3               
000593r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000593r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000593r 3                               ; buffer)
000593r 3  E6 rr                        inc tmp3
000595r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
000597r 3  E6 rr                        inc tmp3+1
000599r 3               @2:
000599r 3                               ; Copy the history buffer into the input buffer,
000599r 3                               ; sending the characters to the output as we go.
000599r 3  A9 0D                        lda #AscCR
00059Br 3  20 rr rr                     jsr emit_a
00059Er 3               
00059Er 3               @history_loop:
00059Er 3                               ; See if we have reached the end of the history buffer.
00059Er 3  C4 rr                        cpy status+1
0005A0r 3  D0 03                        bne @3
0005A2r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
0005A5r 3               @3:
0005A5r 3                               ; See if we have reached the end of the input buffer.
0005A5r 3                               ; (only comparing to lower byte as we currently limit
0005A5r 3                               ; to 255 characters max)
0005A5r 3  C4 rr                        cpy tmp2
0005A7r 3  F0 0A                        beq @hist_filled_buffer
0005A9r 3               
0005A9r 3                               ; Copy a character and echo.
0005A9r 3  B1 rr                        lda (tmp3),y
0005ABr 3  91 rr                        sta (tmp1),y
0005ADr 3  20 rr rr                     jsr emit_a
0005B0r 3               
0005B0r 3                               ; Move to the next character.
0005B0r 3  C8                           iny
0005B1r 3  80 EB                        bra @history_loop
0005B3r 3               
0005B3r 3               @hist_filled_buffer:
0005B3r 3                               ; We don't want a history recall to EOL our buffer,
0005B3r 3                               ; so back up one character and return to editing.
0005B3r 3  88                           dey
0005B4r 3  4C rr rr                     jmp accept_loop
0005B7r 3               accept_done:
0005B7r 3               @done:
0005B7r 3                               ; Copy the input buffer into the currently
0005B7r 3                               ; selected history buffer.
0005B7r 3  20 rr rr                     jsr total_recall
0005BAr 3  85 rr                        sta status+1
0005BCr 3               
0005BCr 3                               ; Also save it in the first buffer byte.
0005BCr 3  A0 00                        ldy #0
0005BEr 3  91 rr                        sta (tmp3),y
0005C0r 3               
0005C0r 3                               ; Move path the count to the data bytes
0005C0r 3  E6 rr                        inc tmp3
0005C2r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
0005C4r 3  E6 rr                        inc tmp3+1
0005C6r 3               @4:
0005C6r 3                               ; Copy the characters from the input buffer to the
0005C6r 3                               ; history buffer.
0005C6r 3               
0005C6r 3               @save_history_loop:
0005C6r 3  C4 rr                        cpy status+1
0005C8r 3  F0 07                        beq @save_history_done
0005CAr 3               
0005CAr 3  B1 rr                        lda (tmp1),y
0005CCr 3  91 rr                        sta (tmp3),y
0005CEr 3  C8                           iny
0005CFr 3  80 F5                        bra @save_history_loop
0005D1r 3               
0005D1r 3               @save_history_done:
0005D1r 3               z_accept:
0005D1r 3  60                           rts
0005D2r 3               
0005D2r 3               total_recall:
0005D2r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
0005D2r 3               
0005D2r 3                               ; Generate the address of the buffer in tmp3. Start with the
0005D2r 3                               ; base address.
0005D2r 3  A9 rr                        lda #<hist_buff
0005D4r 3  85 rr                        sta tmp3
0005D6r 3  A9 rr                        lda #>hist_buff
0005D8r 3  85 rr                        sta tmp3+1
0005DAr 3               
0005DAr 3                               ; This is a bit annoying as some bits go into each byte.
0005DAr 3                               ; .....xxx gets put into address like ......xx x.......
0005DAr 3  A5 rr                        lda status
0005DCr 3  6A                           ror
0005DDr 3  29 03                        and #3
0005DFr 3  18                           clc
0005E0r 3  65 rr                        adc tmp3+1
0005E2r 3  85 rr                        sta tmp3+1
0005E4r 3               
0005E4r 3  A5 rr                        lda status
0005E6r 3  6A                           ror             ; Rotate through carry into msb.
0005E7r 3  6A                           ror
0005E8r 3  29 80                        and #$80
0005EAr 3  18                           clc
0005EBr 3  65 rr                        adc tmp3
0005EDr 3  85 rr                        sta tmp3
0005EFr 3  90 02                        bcc @1           ; Increment the upper byte on carry.
0005F1r 3  E6 rr                        inc tmp3+1
0005F3r 3               @1:
0005F3r 3                               ; Save the current length of the input buffer in
0005F3r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
0005F3r 3  98                           tya
0005F4r 3  C9 80                        cmp #$80
0005F6r 3  90 02                        bcc @2
0005F8r 3  A9 7F                        lda #$7F
0005FAr 3               @2:
0005FAr 3  60                           rts
0005FBr 3               
0005FBr 3               
0005FBr 3               
0005FBr 3               
0005FBr 3               
0005FBr 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
0005FBr 3               ; ## "action-of"  auto  ANS core ext
0005FBr 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
0005FBr 3               
0005FBr 3               xt_action_of:
0005FBr 3                               ; This is a state aware word with differet behavior
0005FBr 3                               ; when used while compiling vs interpreting.
0005FBr 3                               ; Check STATE
0005FBr 3  A5 rr                        lda state
0005FDr 3  05 rr                        ora state+1
0005FFr 3  F0 0C                        beq @interpreting
000601r 3               
000601r 3               @compiling:
000601r 3                               ; Run ['] to compile the xt of the next word
000601r 3                               ; as a literal.
000601r 3  20 rr rr                     jsr xt_bracket_tick
000604r 3               
000604r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000604r 3  A0 rr                        ldy #>xt_defer_fetch
000606r 3  A9 rr                        lda #<xt_defer_fetch
000608r 3  20 rr rr                     jsr cmpl_subroutine
00060Br 3  80 06                        bra @done
00060Dr 3               
00060Dr 3               @interpreting:
00060Dr 3  20 rr rr                     jsr xt_tick
000610r 3  20 rr rr                     jsr xt_defer_fetch
000613r 3               
000613r 3               @done:
000613r 3  60           z_action_of:           rts
000614r 3               
000614r 3               
000614r 3               
000614r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000614r 3               ; ## "again"  tested  ANS core ext
000614r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000614r 3               
000614r 3               xt_again:
000614r 3  20 rr rr                     jsr underflow_1
000617r 3               
000617r 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000617r 3                               ; so we have the range and don't have to calculate the
000617r 3                               ; offset.
000617r 3  A0 00                        ldy #0
000619r 3  A9 4C                        lda #$4C        ; JMP
00061Br 3  91 rr                        sta (cp),y
00061Dr 3  C8                           iny
00061Er 3               
00061Er 3  B5 00                        lda 0,x         ; LSB of address
000620r 3  91 rr                        sta (cp),y
000622r 3  C8                           iny
000623r 3               
000623r 3  B5 01                        lda 1,x         ; MSB of address
000625r 3  91 rr                        sta (cp),y
000627r 3  C8                           iny
000628r 3               
000628r 3                               ; Allot the space we just used
000628r 3  98                           tya
000629r 3  18                           clc
00062Ar 3  65 rr                        adc cp
00062Cr 3  85 rr                        sta cp
00062Er 3  90 02                        bcc @done
000630r 3  E6 rr                        inc cp+1
000632r 3               @done:
000632r 3  E8                           inx
000633r 3  E8                           inx
000634r 3               
000634r 3  60           z_again:        rts
000635r 3               
000635r 3               
000635r 3               
000635r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000635r 3               ; ## "align"  auto  ANS core
000635r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000635r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000635r 3                       ; routine as well, and also does nothing
000635r 3                       ; """
000635r 3               
000635r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000635r 3               ; ## "aligned"  auto  ANS core
000635r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000635r 3               
000635r 3               xt_align:
000635r 3               xt_aligned:
000635r 3               z_align:
000635r 3  60           z_aligned:      rts             ; stripped out during native compile
000636r 3               
000636r 3               
000636r 3               
000636r 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000636r 3               ; ## "allot"  auto  ANS core
000636r 3                       ; """https://forth-standard.org/standard/core/ALLOT
000636r 3                       ; Reserve a certain number of bytes (not cells) or release them.
000636r 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000636r 3                       ; to the beginning of the Dictionary. If n is positive (the most
000636r 3                       ; common case), reserve n bytes, but not past the end of the
000636r 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000636r 3                       ; """
000636r 3               
000636r 3               xt_allot:
000636r 3  20 rr rr                     jsr underflow_1
000639r 3               
000639r 3                               ; Releasing memory is going to be a very rare operation,
000639r 3                               ; so we check for it at the beginning and try to make
000639r 3                               ; the most common case as fast as possible
000639r 3  B5 01                        lda 1,x
00063Br 3  30 22                        bmi @release
00063Dr 3               
00063Dr 3                               ; Common case: We are reserving memory, not releasing it
00063Dr 3  18                           clc
00063Er 3  A5 rr                        lda cp
000640r 3  75 00                        adc 0,x
000642r 3  85 rr                        sta cp
000644r 3               
000644r 3  A5 rr                        lda cp+1
000646r 3  75 01                        adc 1,x
000648r 3  85 rr                        sta cp+1
00064Ar 3               
00064Ar 3                               ; Wait, did we just grant more space than we have? This is
00064Ar 3                               ; a check we only do here, not for other situations like cmpl_a
00064Ar 3                               ; where smaller amounts are reserved.
00064Ar 3  A0 FF                        ldy #<cp_end
00064Cr 3  C4 rr                        cpy cp
00064Er 3  A9 7F                        lda #>cp_end
000650r 3  E5 rr                        sbc cp+1
000652r 3  B0 48                        bcs @done               ; we're fine.
000654r 3               
000654r 3                               ; Oops, that was too much, we're beyond the end of
000654r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000654r 3                               ; an error
000654r 3  84 rr                        sty cp                  ; still #<cp_end
000656r 3  A9 7F                        lda #>cp_end
000658r 3  85 rr                        sta cp+1
00065Ar 3               
00065Ar 3  A9 00                        lda #err_allot
00065Cr 3  4C rr rr                     jmp error
00065Fr 3               
00065Fr 3               @release:
00065Fr 3                  		; The ANS standard doesn't really say what to do if too much
00065Fr 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
00065Fr 3                               ; even an official test. Gforth is little help either. The good
00065Fr 3                               ; news is, this is going to be a rare case. We want to use as
00065Fr 3                               ; few bytes as possible.
00065Fr 3               
00065Fr 3                               ; What we do is let the user free anything up to the beginning
00065Fr 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
00065Fr 3                               ; their own risk. This means that the Dictionary pointer DP
00065Fr 3                               ; might end up pointing to garbage. However, an attempt to
00065Fr 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
00065Fr 3                               ; the DP pointing to the last word in RAM (should be DROP) and
00065Fr 3                               ; an error message.
00065Fr 3               
00065Fr 3                               ; We arrive here with ( n ) which is negative. First step,
00065Fr 3                               ; subtract the number TOS from the CP for a new CP
00065Fr 3  CA                           dex
000660r 3  CA                           dex
000661r 3  A5 rr                        lda cp
000663r 3  95 00                        sta 0,x
000665r 3  A5 rr                        lda cp+1
000667r 3  95 01                        sta 1,x
000669r 3               
000669r 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
00066Cr 3               
00066Cr 3                               ; Second step, see if we've gone too far. We compare the new
00066Cr 3                               ; CP on TOS (which, if we've really screwed up, might be
00066Cr 3                               ; negative) with CP0. This is a signed comparison
00066Cr 3  CA                           dex
00066Dr 3  CA                           dex                             ; new CP now NOS
00066Er 3  A9 rr                        lda #<cp0
000670r 3  95 00                        sta 0,x
000672r 3  A9 rr                        lda #>cp0
000674r 3  95 01                        sta 1,x                         ; CP0 is TOS
000676r 3               
000676r 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000679r 3               
000679r 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000679r 3                               ; This means we want Z=1 or N=1
000679r 3  F0 17                        beq @nega_done
00067Br 3  30 15                        bmi @nega_done
00067Dr 3               
00067Dr 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
00067Dr 3                               ; word in ROM (should be DROP), and abort with an error
00067Dr 3  A9 rr                        lda #<cp0
00067Fr 3  85 rr                        sta cp
000681r 3  A9 rr                        lda #>cp0
000683r 3  85 rr                        sta cp+1
000685r 3               
000685r 3  A9 rr                        lda #<dictionary_start
000687r 3  85 rr                        sta dp
000689r 3  A9 rr                        lda #>dictionary_start
00068Br 3  85 rr                        sta dp+1
00068Dr 3               
00068Dr 3  A9 0A                        lda #err_negallot
00068Fr 3  4C rr rr                     jmp error
000692r 3               
000692r 3               @nega_done:
000692r 3                               ; Save new CP, which is NOS
000692r 3  B5 02                        lda 2,x
000694r 3  85 rr                        sta cp
000696r 3  B5 03                        lda 3,x
000698r 3  85 rr                        sta cp+1
00069Ar 3               
00069Ar 3  E8                           inx
00069Br 3  E8                           inx                     ; drop through to @done
00069Cr 3               @done:
00069Cr 3  E8                           inx
00069Dr 3  E8                           inx
00069Er 3               z_allot:
00069Er 3  60                           rts
00069Fr 3               
00069Fr 3               
00069Fr 3               
00069Fr 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
00069Fr 3               ; ## "allow-native"  auto  Tali Forth
00069Fr 3               xt_allow_native:
00069Fr 3  20 rr rr                     jsr current_to_dp
0006A2r 3  A0 01                        ldy #1          ; offset for status byte
0006A4r 3  B1 rr                        lda (dp),y
0006A6r 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
0006A8r 3  91 rr                        sta (dp),y
0006AAr 3               z_allow_native:
0006AAr 3  60                           rts
0006ABr 3               
0006ABr 3               
0006ABr 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
0006ABr 3               ; ## "also"  auto  ANS search ext
0006ABr 3                       ; """http://forth-standard.org/standard/search/ALSO"""
0006ABr 3               xt_also:
0006ABr 3  20 rr rr                     jsr xt_get_order
0006AEr 3  20 rr rr                     jsr xt_over
0006B1r 3  20 rr rr                     jsr xt_swap
0006B4r 3  20 rr rr                     jsr xt_one_plus
0006B7r 3  20 rr rr                     jsr xt_set_order
0006BAr 3               
0006BAr 3  60           z_also:         rts
0006BBr 3               
0006BBr 3               
0006BBr 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
0006BBr 3               ; ## "always-native"  auto  Tali Forth
0006BBr 3               xt_always_native:
0006BBr 3  20 rr rr                     jsr current_to_dp
0006BEr 3  A0 01                        ldy #1          ; offset for status byte
0006C0r 3  B1 rr                        lda (dp),y
0006C2r 3  09 02                        ora #AN         ; Make sure AN flag is set
0006C4r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
0006C6r 3  91 rr                        sta (dp),y
0006C8r 3               z_always_native:
0006C8r 3  60                           rts
0006C9r 3               
0006C9r 3               
0006C9r 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
0006C9r 3               ; ## "and"  auto  ANS core
0006C9r 3                       ; """https://forth-standard.org/standard/core/AND"""
0006C9r 3               xt_and:
0006C9r 3  20 rr rr                     jsr underflow_2
0006CCr 3               
0006CCr 3  B5 00                        lda 0,x
0006CEr 3  35 02                        and 2,x
0006D0r 3  95 02                        sta 2,x
0006D2r 3               
0006D2r 3  B5 01                        lda 1,x
0006D4r 3  35 03                        and 3,x
0006D6r 3  95 03                        sta 3,x
0006D8r 3               
0006D8r 3  E8                           inx
0006D9r 3  E8                           inx
0006DAr 3               
0006DAr 3  60           z_and:          rts
0006DBr 3               
0006DBr 3               
0006DBr 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
0006DBr 3               ; ## "assembler-wordlist"  tested  Tali Assembler
0006DBr 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
0006DBr 3                       ; assembler words to the search order so they can be used.
0006DBr 3                       ; See the tutorial on Wordlists and the Search Order for
0006DBr 3                       ; more information.
0006DBr 3                       ;
0006DBr 3                       ; This is a dummy entry, the code is shared with TWO
0006DBr 3                       ; """
0006DBr 3               
0006DBr 3               
0006DBr 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
0006DBr 3               ; ## "at-xy"  tested  ANS facility
0006DBr 3                       ; """https://forth-standard.org/standard/facility/AT-XY
0006DBr 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
0006DBr 3                       ; ANSI code is ESC[<n>;<m>H
0006DBr 3                       ;
0006DBr 3                       ; Do not use U. to print the numbers because the
0006DBr 3                       ; trailing space will not work with xterm
0006DBr 3                       ; """
0006DBr 3               xt_at_xy:
0006DBr 3  20 rr rr                     jsr underflow_2
0006DEr 3               
0006DEr 3  A9 1B                        lda #AscESC
0006E0r 3  20 rr rr                     jsr emit_a
0006E3r 3  A9 5B                        lda #$5B        ; ASCII for "["
0006E5r 3  20 rr rr                     jsr emit_a
0006E8r 3  20 rr rr                     jsr print_u
0006EBr 3  A9 3B                        lda #$3B        ; ASCII for ";"
0006EDr 3  20 rr rr                     jsr emit_a
0006F0r 3  20 rr rr                     jsr print_u
0006F3r 3  A9 48                        lda #'H'
0006F5r 3  20 rr rr                     jsr emit_a
0006F8r 3               
0006F8r 3  60           z_at_xy:        rts
0006F9r 3               
0006F9r 3               
0006F9r 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
0006F9r 3               ; ## "\"  auto  ANS core ext
0006F9r 3                       ; """https://forth-standard.org/standard/core/bs"""
0006F9r 3               xt_backslash:
0006F9r 3  A5 rr                        lda ciblen
0006FBr 3  85 rr                        sta toin
0006FDr 3  A5 rr                        lda ciblen+1
0006FFr 3  85 rr                        sta toin+1
000701r 3               
000701r 3  60           z_backslash:    rts
000702r 3               
000702r 3               
000702r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000702r 3               ; ## "base"  auto  ANS core
000702r 3                       ; """https://forth-standard.org/standard/core/BASE
000702r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000702r 3                       ; ingore the MSB
000702r 3                       ; """
000702r 3               xt_base:
000702r 3  CA                           dex
000703r 3  CA                           dex
000704r 3  A9 rr                        lda #<base
000706r 3  95 00                        sta 0,x         ; LSB
000708r 3  74 01                        stz 1,x         ; MSB is always 0
00070Ar 3               
00070Ar 3  60           z_base:         rts
00070Br 3               
00070Br 3               
00070Br 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
00070Br 3               ; ## "begin"  auto  ANS core
00070Br 3                       ; """https://forth-standard.org/standard/core/BEGIN
00070Br 3                       ;
00070Br 3                       ; This is just an immediate version of here which could just
00070Br 3                       ; as well be coded in Forth as
00070Br 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
00070Br 3                       ; Since this is a compiling word, we don't care that much about
00070Br 3                       ; about speed
00070Br 3                       ; """
00070Br 3               
00070Br 3               xt_begin:
00070Br 3  20 rr rr                     jsr xt_here
00070Er 3  60           z_begin:        rts
00070Fr 3               
00070Fr 3               
00070Fr 3               
00070Fr 3               ; ## BELL ( -- ) "Emit ASCII BELL"
00070Fr 3               ; ## "bell"  tested  Tali Forth
00070Fr 3               xt_bell:
00070Fr 3  A9 07                        lda #7          ; ASCII value for BELl
000711r 3  20 rr rr                     jsr emit_a
000714r 3               
000714r 3  60           z_bell:         rts
000715r 3               
000715r 3               
000715r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000715r 3               ; ## "bl"  auto  ANS core
000715r 3                       ; """https://forth-standard.org/standard/core/BL"""
000715r 3               
000715r 3               xt_bl:
000715r 3  CA                           dex
000716r 3  CA                           dex
000717r 3  A9 20                        lda #AscSP
000719r 3  95 00                        sta 0,x
00071Br 3  74 01                        stz 1,x
00071Dr 3               
00071Dr 3  60           z_bl:           rts
00071Er 3               
00071Er 3               
00071Er 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
00071Er 3               ; ## "block"  auto  ANS block
00071Er 3                       ; """https://forth-standard.org/standard/block/BLK"""
00071Er 3               xt_blk:
00071Er 3                               ; BLK is at UP + blk_offset
00071Er 3  CA                           dex
00071Fr 3  CA                           dex
000720r 3  18                           clc
000721r 3  A5 rr                        lda up
000723r 3  69 00                        adc #blk_offset ; Add offset
000725r 3  95 00                        sta 0,x
000727r 3  A5 rr                        lda up+1
000729r 3  69 00                        adc #0          ; Adding carry
00072Br 3  95 01                        sta 1,x
00072Dr 3               
00072Dr 3  60           z_blk:          rts
00072Er 3               
00072Er 3               
00072Er 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
00072Er 3               ; ## "blkbuffer"  auto  Tali block
00072Er 3               xt_blkbuffer:
00072Er 3                               ; blkbuffer address is at UP + blkbuffer_offset.
00072Er 3                               ; Unlike some of the other user variables, we actually
00072Er 3                               ; want to push the address stored here, which will
00072Er 3                               ; point to somewhere outside of the user variables.
00072Er 3  CA                           dex
00072Fr 3  CA                           dex
000730r 3                               ; Put the address on the stack.
000730r 3  A0 28                        ldy #blkbuffer_offset
000732r 3  B1 rr                        lda (up),y
000734r 3  95 00                        sta 0,x
000736r 3  C8                           iny             ; Move along to the next byte
000737r 3  B1 rr                        lda (up),y
000739r 3  95 01                        sta 1,x
00073Br 3               
00073Br 3  60           z_blkbuffer:    rts
00073Cr 3               
00073Cr 3               
00073Cr 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
00073Cr 3               ; ## "block"  auto  ANS block
00073Cr 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
00073Cr 3               
00073Cr 3               xt_block:
00073Cr 3               
00073Cr 3                               ; See if the block requested is the same as the one we
00073Cr 3                               ; currently have in the buffer. Check the LSB.
00073Cr 3  A0 2A                        ldy #buffblocknum_offset
00073Er 3  B1 rr                        lda (up),y
000740r 3  D5 00                        cmp 0,x
000742r 3  D0 0F                        bne @not_in_buffer
000744r 3               
000744r 3                               ; Check the MSB.
000744r 3  C8                           iny
000745r 3  B1 rr                        lda (up),y
000747r 3  D5 01                        cmp 1,x
000749r 3  D0 08                        bne @not_in_buffer
00074Br 3               
00074Br 3                               ; The block is in the buffer. See if the buffer is in use.
00074Br 3  A0 2C                        ldy #buffstatus_offset
00074Dr 3  B1 rr                        lda (up),y
00074Fr 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000751r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000753r 3                                               ; @done will replace the block# with the
000753r 3                                               ; buffer address.
000753r 3               @not_in_buffer:
000753r 3                               ; Check the buffer status
000753r 3  A0 2C                        ldy #buffstatus_offset
000755r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000757r 3  C9 03                        cmp #3          ; LSB is needed.
000759r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
00075Br 3               
00075Br 3                               ; We need to save the block.
00075Br 3  20 rr rr                     jsr xt_blkbuffer
00075Er 3  20 rr rr                     jsr xt_buffblocknum
000761r 3  20 rr rr                     jsr xt_fetch
000764r 3  20 rr rr                     jsr xt_block_write
000767r 3               
000767r 3               @buffer_available:
000767r 3                               ; Save the block number.
000767r 3  A0 2A                        ldy #buffblocknum_offset
000769r 3  B5 00                        lda 0,x
00076Br 3  91 rr                        sta (up),y
00076Dr 3  C8                           iny
00076Er 3  B5 01                        lda 1,x
000770r 3  91 rr                        sta (up),y
000772r 3               
000772r 3                               ; Get the requested block.
000772r 3  20 rr rr                     jsr xt_blkbuffer
000775r 3  20 rr rr                     jsr xt_swap
000778r 3  20 rr rr                     jsr xt_block_read
00077Br 3               
00077Br 3                               ; Mark the buffer as clean and in-use.
00077Br 3  A9 01                        lda #1
00077Dr 3  A0 2C                        ldy #buffstatus_offset
00077Fr 3  91 rr                        sta (up),y
000781r 3               
000781r 3                               ; Make room on the stack for the return address.
000781r 3  CA                           dex
000782r 3  CA                           dex
000783r 3               
000783r 3               @done:
000783r 3                               ; It's in the buffer. Return the buffer address.
000783r 3  A0 28                        ldy #blkbuffer_offset
000785r 3  B1 rr                        lda (up),y
000787r 3  95 00                        sta 0,x
000789r 3  C8                           iny
00078Ar 3  B1 rr                        lda (up),y
00078Cr 3  95 01                        sta 1,x
00078Er 3               
00078Er 3  60           z_block:        rts
00078Fr 3               
00078Fr 3               
00078Fr 3               
00078Fr 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
00078Fr 3               ; ## "block-ramdrive-init"  auto  Tali block
00078Fr 3                       ; """Create a RAM drive, with the given number of
00078Fr 3                       ; blocks, in the dictionary along with setting up the block words to
00078Fr 3                       ; use it.  The read/write routines do not provide bounds checking.
00078Fr 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
00078Fr 3                       ; """
00078Fr 3               
00078Fr 3               xt_block_ramdrive_init:
00078Fr 3  20 rr rr                     jsr underflow_1
000792r 3               
000792r 3                               ; Store the string to run here as a string literal.
000792r 3                               ; See SLITERAL for the format information. This way, we
000792r 3                               ; don't have the words defined below in the Dictionary until
000792r 3                               ; we really use them.
000792r 3  4C rr rr                     jmp @after_ramdrive_code
000795r 3               
000795r 3               @ramdrive_code:
000795r 3  62 61 73 65          .byte "base @ swap decimal"
000799r 3  20 40 20 73  
00079Dr 3  77 61 70 20  
0007A8r 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
0007ACr 3  34 20 2A     
0007AFr 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
0007B3r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
0007B7r 3  66 65 72 3A  
0007BBr 3  20 72 61 6D  
0007C4r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
0007C4r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
0007C8r 3  6C 6F 63 6B  
0007CCr 3  2D 72 65 61  
0007DAr 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
0007DEr 3  64 72 69 76  
0007E2r 3  65 20 73 77  
000802r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000806r 3  6C 6F 63 6B  
00080Ar 3  2D 77 72 69  
000819r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
00081Dr 3  64 72 69 76  
000821r 3  65 20 73 77  
00083Cr 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000840r 3  6C 6F 63 6B  
000844r 3  2D 72 65 61  
000866r 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
00086Ar 3  6C 6F 63 6B  
00086Er 3  2D 77 72 69  
000892r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000896r 3  64 72 69 76  
00089Ar 3  65 20 73 77  
0008ADr 3               
0008ADr 3               @after_ramdrive_code:
0008ADr 3  20 rr rr                     jsr sliteral_runtime
0008B0r 3               
0008B0r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
0008B4r 3               
0008B4r 3                               ; The address and length of the ramdrive code is now on the
0008B4r 3                               ; stack. Call EVALUATE to run it.
0008B4r 3  20 rr rr                     jsr xt_evaluate
0008B7r 3               
0008B7r 3               z_block_ramdrive_init:
0008B7r 3  60                           rts
0008B8r 3               
0008B8r 3               
0008B8r 3               
0008B8r 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
0008B8r 3               ; ## "block-read"  auto  Tali block
0008B8r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
0008B8r 3                       ; with their own version to read a block from storage.
0008B8r 3                       ; The stack parameters are ( buffer_address block# -- ).
0008B8r 3                       ; """
0008B8r 3               xt_block_read:
0008B8r 3                               ; Execute the BLOCK-READ-VECTOR
0008B8r 3  A0 2E                        ldy #blockread_offset
0008BAr 3  B1 rr                        lda (up),y
0008BCr 3  85 rr                        sta tmp1
0008BEr 3  C8                           iny
0008BFr 3  B1 rr                        lda (up),y
0008C1r 3  85 rr                        sta tmp1+1
0008C3r 3               
0008C3r 3  6C rr rr                     jmp (tmp1)
0008C6r 3               
0008C6r 3               z_block_read:   ; No RTS needed
0008C6r 3               
0008C6r 3               
0008C6r 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
0008C6r 3               ; ## "block-read-vector"  auto  Tali block
0008C6r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
0008C6r 3                       ; with their own version to read a block from storage.
0008C6r 3                       ; This word gives the address of the vector so it can be replaced.
0008C6r 3                       ; """
0008C6r 3               xt_block_read_vector:
0008C6r 3                               ; Get the BLOCK-READ-VECTOR address
0008C6r 3  CA                           dex
0008C7r 3  CA                           dex
0008C8r 3  18                           clc
0008C9r 3  A5 rr                        lda up
0008CBr 3  69 2E                        adc #blockread_offset
0008CDr 3  95 00                        sta 0,x
0008CFr 3  A5 rr                        lda up+1
0008D1r 3  69 00                        adc #0          ; Add carry
0008D3r 3  95 01                        sta 1,x
0008D5r 3               
0008D5r 3               z_block_read_vector:
0008D5r 3  60                           rts
0008D6r 3               
0008D6r 3               
0008D6r 3               ; This is the default error message the vectored words BLOCK-READ and
0008D6r 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
0008D6r 3               xt_block_word_error:
0008D6r 3  A9 0C                        lda #err_blockwords
0008D8r 3  4C rr rr                     jmp error       ; no RTS needed
0008DBr 3               z_block_word_error:
0008DBr 3               
0008DBr 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
0008DBr 3               ; ## "block-write"  auto  Tali block
0008DBr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
0008DBr 3                       ; with their own version to write a block to storage.
0008DBr 3                       ; The stack parameters are ( buffer_address block# -- ).
0008DBr 3                       ; """
0008DBr 3               xt_block_write:
0008DBr 3                               ; Execute the BLOCK-READ-VECTOR
0008DBr 3  A0 30                        ldy #blockwrite_offset
0008DDr 3  B1 rr                        lda (up),y
0008DFr 3  85 rr                        sta tmp1
0008E1r 3  C8                           iny
0008E2r 3  B1 rr                        lda (up),y
0008E4r 3  85 rr                        sta tmp1+1
0008E6r 3  6C rr rr                     jmp (tmp1)
0008E9r 3               
0008E9r 3               z_block_write:  ; No RTS needed
0008E9r 3               
0008E9r 3               
0008E9r 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
0008E9r 3               ; ## "block-write-vector"  auto  Tali block
0008E9r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
0008E9r 3                       ; with their own version to write a block to storage.
0008E9r 3                       ; This word gives the address of the vector so it can be replaced.
0008E9r 3                       ; """
0008E9r 3               xt_block_write_vector:
0008E9r 3                               ; Get the BLOCK-WRITE-VECTOR address
0008E9r 3  CA                           dex
0008EAr 3  CA                           dex
0008EBr 3  18                           clc
0008ECr 3  A5 rr                        lda up
0008EEr 3  69 30                        adc #blockwrite_offset
0008F0r 3  95 00                        sta 0,x
0008F2r 3  A5 rr                        lda up+1
0008F4r 3  69 00                        adc #0          ; Add carry
0008F6r 3  95 01                        sta 1,x
0008F8r 3               
0008F8r 3               z_block_write_vector:
0008F8r 3  60                           rts
0008F9r 3               
0008F9r 3               
0008F9r 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
0008F9r 3               ; ## "bounds"  auto  Gforth
0008F9r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
0008F9r 3                       ; Given a string, return the correct Data Stack parameters for
0008F9r 3                       ; a DO/LOOP loop over its characters. This is realized as
0008F9r 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
0008F9r 3                       ; """
0008F9r 3               xt_bounds:
0008F9r 3  20 rr rr                     jsr underflow_2
0008FCr 3               
0008FCr 3  18                           clc
0008FDr 3  B5 00                        lda 0,x                 ; LSB u
0008FFr 3  B4 02                        ldy 2,x                 ; LSB addr
000901r 3  75 02                        adc 2,x
000903r 3  95 02                        sta 2,x                 ; LSB addr+u
000905r 3  94 00                        sty 0,x
000907r 3               
000907r 3  B5 01                        lda 1,x                 ; MSB u
000909r 3  B4 03                        ldy 3,x                 ; MSB addr
00090Br 3  75 03                        adc 3,x
00090Dr 3  95 03                        sta 3,x                 ; MSB addr+u
00090Fr 3  94 01                        sty 1,x
000911r 3               
000911r 3  60           z_bounds:       rts
000912r 3               
000912r 3               
000912r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000912r 3               ; ## "[char]"  auto  ANS core
000912r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000912r 3                       ; Compile the ASCII value of a character as a literal. This is an
000912r 3                       ; immediate, compile-only word.
000912r 3                       ;
000912r 3                       ; A definition given in
000912r 3                       ; http://forth-standard.org/standard/implement is
000912r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000912r 3                       ; """
000912r 3               xt_bracket_char:
000912r 3  20 rr rr                     jsr xt_char
000915r 3  20 rr rr                     jsr xt_literal
000918r 3  60           z_bracket_char: rts
000919r 3               
000919r 3               
000919r 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000919r 3               ; ## "[']"  auto  ANS core
000919r 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000919r 3               xt_bracket_tick:
000919r 3  20 rr rr                     jsr xt_tick
00091Cr 3  20 rr rr                     jsr xt_literal
00091Fr 3  60           z_bracket_tick: rts
000920r 3               
000920r 3               
000920r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000920r 3               ; ## "buffblocknum"  auto  Tali block
000920r 3               xt_buffblocknum:
000920r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000920r 3  CA                           dex
000921r 3  CA                           dex
000922r 3  18                           clc
000923r 3  A5 rr                        lda up
000925r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000927r 3  95 00                        sta 0,x
000929r 3  A5 rr                        lda up+1
00092Br 3  69 00                        adc #0                          ; Adding carry
00092Dr 3  95 01                        sta 1,x
00092Fr 3               
00092Fr 3  60           z_buffblocknum: rts
000930r 3               
000930r 3               
000930r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000930r 3               ; ## "buffer"  auto  ANS block
000930r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000930r 3               
000930r 3               xt_buffer:
000930r 3                               ; Check the buffer status
000930r 3  A0 2C                        ldy #buffstatus_offset
000932r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000934r 3  C9 03                        cmp #3          ; LSB is needed.
000936r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000938r 3               
000938r 3                               ; We need to save the block.
000938r 3  20 rr rr                     jsr xt_blkbuffer
00093Br 3  20 rr rr                     jsr xt_buffblocknum
00093Er 3  20 rr rr                     jsr xt_fetch
000941r 3  20 rr rr                     jsr xt_block_write
000944r 3               
000944r 3               @buffer_available:
000944r 3                               ; Save the block number.
000944r 3  A0 2A                        ldy #buffblocknum_offset
000946r 3  B5 00                        lda 0,x
000948r 3  91 rr                        sta (up),y
00094Ar 3  C8                           iny
00094Br 3  B5 01                        lda 1,x
00094Dr 3  91 rr                        sta (up),y
00094Fr 3               
00094Fr 3                               ; Mark the buffer as clean and in-use.
00094Fr 3  A9 01                        lda #1
000951r 3  A0 2C                        ldy #buffstatus_offset
000953r 3  91 rr                        sta (up),y
000955r 3               
000955r 3               @done:
000955r 3                               ; Return the buffer address.
000955r 3  A0 28                        ldy #blkbuffer_offset
000957r 3  B1 rr                        lda (up),y
000959r 3  95 00                        sta 0,x
00095Br 3  C8                           iny
00095Cr 3  B1 rr                        lda (up),y
00095Er 3  95 01                        sta 1,x
000960r 3               
000960r 3  60           z_buffer:       rts
000961r 3               
000961r 3               
000961r 3               
000961r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
000961r 3               ; ## "buffer:"  auto  ANS core ext
000961r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
000961r 3                               ; Create a buffer of size u that puts its address on the stack
000961r 3                               ; when its name is used.
000961r 3                               ; """
000961r 3               xt_buffer_colon:
000961r 3  20 rr rr                     jsr xt_create
000964r 3  20 rr rr                     jsr xt_allot
000967r 3  60           z_buffer_colon: rts
000968r 3               
000968r 3               
000968r 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
000968r 3               ; ## "buffstatus"  auto  Tali block
000968r 3               xt_buffstatus:
000968r 3                               ; BUFFSTATUS is at UP + buffstatus_offset
000968r 3  CA                           dex
000969r 3  CA                           dex
00096Ar 3  18                           clc
00096Br 3  A5 rr                        lda up
00096Dr 3  69 2C                        adc #buffstatus_offset  ; Add offset
00096Fr 3  95 00                        sta 0,x
000971r 3  A5 rr                        lda up+1
000973r 3  69 00                        adc #0                  ; Adding carry
000975r 3  95 01                        sta 1,x
000977r 3               
000977r 3  60           z_buffstatus:   rts
000978r 3               
000978r 3               
000978r 3               ; ## BYE ( -- ) "Break"
000978r 3               ; ## "bye"  tested  ANS tools ext
000978r 3                       ; """https://forth-standard.org/standard/tools/BYE"""
000978r 3               
000978r 3               xt_bye:
000978r 3                               ;brk
000978r 3  4C rr rr                     jmp platform_bye
00097Br 3               z_bye:          ;rts             ; never reached
00097Br 3               
00097Br 3               
00097Br 3               
00097Br 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
00097Br 3               ; ## "c,"  auto  ANS core
00097Br 3                       ; """https://forth-standard.org/standard/core/CComma"""
00097Br 3               
00097Br 3               xt_c_comma:
00097Br 3  20 rr rr                     jsr underflow_1
00097Er 3               
00097Er 3  B5 00                        lda 0,x
000980r 3  20 rr rr                     jsr cmpl_a
000983r 3               
000983r 3  E8                           inx
000984r 3  E8                           inx
000985r 3               
000985r 3  60           z_c_comma:      rts
000986r 3               
000986r 3               
000986r 3               
000986r 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
000986r 3               ; ## "c@"  auto  ANS core
000986r 3                       ; """https://forth-standard.org/standard/core/CFetch"""
000986r 3               xt_c_fetch:
000986r 3  20 rr rr                     jsr underflow_1
000989r 3               
000989r 3  A1 00                        lda (0,x)
00098Br 3  95 00                        sta 0,x
00098Dr 3  74 01                        stz 1,x         ; Ignore LSB
00098Fr 3               
00098Fr 3  60           z_c_fetch:      rts
000990r 3               
000990r 3               
000990r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000990r 3               ; ## "c!"  auto  ANS core
000990r 3                       ; """https://forth-standard.org/standard/core/CStore"""
000990r 3               xt_c_store:
000990r 3  20 rr rr                     jsr underflow_2
000993r 3               
000993r 3  B5 02                        lda 2,x
000995r 3  81 00                        sta (0,x)
000997r 3               
000997r 3  E8                           inx
000998r 3  E8                           inx
000999r 3  E8                           inx
00099Ar 3  E8                           inx
00099Br 3               
00099Br 3  60           z_c_store:      rts
00099Cr 3               
00099Cr 3               
00099Cr 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
00099Cr 3               ; ## "case"  auto  ANS core ext
00099Cr 3                       ; """http://forth-standard.org/standard/core/CASE
00099Cr 3                       ;
00099Cr 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
00099Cr 3                       ; """
00099Cr 3               
00099Cr 3               
00099Cr 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
00099Cr 3               ; ## "cell+"  auto  ANS core
00099Cr 3                       ; """https://forth-standard.org/standard/core/CELLPlus
00099Cr 3                       ; Add the number of bytes ("address units") that one cell needs.
00099Cr 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
00099Cr 3                       ; """
00099Cr 3               
00099Cr 3               xt_cell_plus:
00099Cr 3  20 rr rr                     jsr underflow_1
00099Fr 3               
00099Fr 3  F6 00                        inc 0,x
0009A1r 3  D0 02                        bne @1
0009A3r 3  F6 01                        inc 1,x
0009A5r 3               @1:
0009A5r 3  F6 00                        inc 0,x
0009A7r 3  D0 02                        bne @done
0009A9r 3  F6 01                        inc 1,x
0009ABr 3               @done:
0009ABr 3  60           z_cell_plus:    rts
0009ACr 3               
0009ACr 3               
0009ACr 3               
0009ACr 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
0009ACr 3               ; ## "cells"  auto  ANS core
0009ACr 3                       ; """https://forth-standard.org/standard/core/CELLS
0009ACr 3                       ;
0009ACr 3                       ; Dummy entry for the CELLS word, the code is the same as for
0009ACr 3                       ; 2*, which is where the header directs us to
0009ACr 3                       ; """
0009ACr 3               
0009ACr 3               
0009ACr 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
0009ACr 3               ; ## "char"  auto  ANS core
0009ACr 3                       ; """https://forth-standard.org/standard/core/CHAR"""
0009ACr 3               
0009ACr 3               xt_char:
0009ACr 3                               ; get character from string, returns ( addr u )
0009ACr 3  20 rr rr                     jsr xt_parse_name
0009AFr 3               
0009AFr 3                               ; if we got back a zero, we have a problem
0009AFr 3  B5 00                        lda 0,x
0009B1r 3  15 01                        ora 1,x
0009B3r 3  D0 05                        bne @not_empty
0009B5r 3               
0009B5r 3  A9 05                        lda #err_noname
0009B7r 3  4C rr rr                     jmp error
0009BAr 3               
0009BAr 3               @not_empty:
0009BAr 3  E8                           inx             ; drop number of characters, leave addr
0009BBr 3  E8                           inx
0009BCr 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
0009BEr 3  95 00                        sta 0,x
0009C0r 3  74 01                        stz 1,x         ; MSB is always zero
0009C2r 3               
0009C2r 3  60           z_char:         rts
0009C3r 3               
0009C3r 3               
0009C3r 3               
0009C3r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
0009C3r 3               ; ## "char+"  auto  ANS core
0009C3r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
0009C3r 3                       ;
0009C3r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
0009C3r 3                       ; """
0009C3r 3               
0009C3r 3               
0009C3r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
0009C3r 3               ; ## "chars"  auto  ANS core
0009C3r 3                       ; """https://forth-standard.org/standard/core/CHARS
0009C3r 3                       ; Return how many address units n chars are. Since this is an 8 bit
0009C3r 3                       ; machine, this does absolutely nothing and is included for
0009C3r 3                       ; compatibility with other Forth versions
0009C3r 3                       ; """
0009C3r 3               
0009C3r 3               xt_chars:
0009C3r 3                               ; Checking for underflow seems a bit stupid because this
0009C3r 3                               ; routine does nothing on this machine. However, the user
0009C3r 3                               ; should be warned that there is something wrong with the
0009C3r 3                               ; code if this occurs.
0009C3r 3  20 rr rr                     jsr underflow_1
0009C6r 3               
0009C6r 3  60           z_chars:        rts
0009C7r 3               
0009C7r 3               
0009C7r 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
0009C7r 3               ; ## "cleave"  auto  Tali Forth
0009C7r 3               
0009C7r 3                       ; """Given a range of memory with words delimited by whitespace,return
0009C7r 3                       ; the first word at the top of the stack and the rest of the word
0009C7r 3                       ; following it.
0009C7r 3                       ;
0009C7r 3                       ; Example:
0009C7r 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
0009C7r 3                       ; s" w1" cleave        -> "" "w1"
0009C7r 3                       ;
0009C7r 3                       ; Since it will be used in loops a lot, we want it to work in pure
0009C7r 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
0009C7r 3                       ; strip leading delimiters.
0009C7r 3                       ; """
0009C7r 3               
0009C7r 3               xt_cleave:
0009C7r 3  20 rr rr                     jsr underflow_2
0009CAr 3               
0009CAr 3                               ; We arrive here with ( addr u ). We need to strip any leading
0009CAr 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
0009CAr 3                               ; remember how many spaces were stripped. This means we can't
0009CAr 3                               ; calculate the length of the remainder. Fortunately, Tali
0009CAr 3                               ; Forth has just the word we need for this:
0009CAr 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
0009CDr 3               
0009CDr 3                               ; The main part we can turn over to PARSE-NAME, except that we
0009CDr 3                               ; have a string ( addr u ) and not stuff in the input buffer.
0009CDr 3                               ; We get around this by cheating: We place ( addr u ) in the
0009CDr 3                               ; input buffer and then call PARSE-NAME.
0009CDr 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
0009D0r 3               
0009D0r 3  B5 00                        lda 0,x         ; u is new ciblen
0009D2r 3  85 rr                        sta ciblen
0009D4r 3  B5 01                        lda 1,x
0009D6r 3  85 rr                        sta ciblen+1
0009D8r 3               
0009D8r 3  B5 02                        lda 2,x         ; addr is new cib
0009DAr 3  85 rr                        sta cib
0009DCr 3  B5 03                        lda 3,x
0009DEr 3  85 rr                        sta cib+1
0009E0r 3               
0009E0r 3  64 rr                        stz toin        ; >IN pointer is zero
0009E2r 3  64 rr                        stz toin+1
0009E4r 3               
0009E4r 3                               ; PARSE-NAME gives us back the substring of the first word
0009E4r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
0009E7r 3               
0009E7r 3                               ; If we were given an empty string, then we're done. It's the
0009E7r 3                               ; resposibility of the user to catch this as a sign to end the
0009E7r 3                               ; any loop
0009E7r 3  B5 00                        lda 0,x
0009E9r 3  15 01                        ora 1,x
0009EBr 3  F0 23                        beq @done
0009EDr 3               
0009EDr 3                               ; Now we have to adjust the original string
0009EDr 3  B5 04                        lda 4,x         ; LSB of original u
0009EFr 3  38                           sec
0009F0r 3  F5 00                        sbc 0,x
0009F2r 3  95 04                        sta 4,x
0009F4r 3               
0009F4r 3  B5 05                        lda 5,x         ; MSB of original u
0009F6r 3  F5 01                        sbc 1,x
0009F8r 3  95 05                        sta 5,x
0009FAr 3               
0009FAr 3  B5 06                        lda 6,x         ; LSB of original addr
0009FCr 3  18                           clc
0009FDr 3  75 00                        adc 0,x
0009FFr 3  95 06                        sta 6,x
000A01r 3               
000A01r 3  B5 07                        lda 7,x         ; MSB of original addr
000A03r 3  75 01                        adc 1,x
000A05r 3  95 07                        sta 7,x
000A07r 3               
000A07r 3                               ; There is one small problem: PARSE-NAME will probably have
000A07r 3                               ; left the string with the rest of the words with leading
000A07r 3                               ; delimiters. We use our magic -LEADING again
000A07r 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
000A0Ar 3  20 rr rr                     jsr xt_minus_leading
000A0Dr 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000A10r 3               @done:
000A10r 3                               ; Restore input
000A10r 3  20 rr rr                     jsr xt_r_to_input
000A13r 3               
000A13r 3  60           z_cleave:       rts
000A14r 3               
000A14r 3               
000A14r 3               
000A14r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000A14r 3               ; ## "cmove"  auto  ANS string
000A14r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000A14r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000A14r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000A14r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000A14r 3                       ; "move left".
000A14r 3                       ;
000A14r 3                       ; There are no official tests for this word.
000A14r 3                       ; """
000A14r 3               
000A14r 3               xt_cmove:
000A14r 3  20 rr rr                     jsr underflow_3
000A17r 3               
000A17r 3                               ; move destination address to where we can work with it
000A17r 3  B5 02                        lda 2,x
000A19r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000A1Br 3  B5 03                        lda 3,x
000A1Dr 3  85 rr                        sta tmp2+1
000A1Fr 3               
000A1Fr 3                               ; move source address to where we can work with it
000A1Fr 3  B5 04                        lda 4,x
000A21r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000A23r 3  B5 05                        lda 5,x
000A25r 3  85 rr                        sta tmp1+1
000A27r 3               
000A27r 3  A0 00                        ldy #0
000A29r 3  B5 01                        lda 1,x         ; number of whole pages to move
000A2Br 3  F0 0F                        beq @dopartial
000A2Dr 3               
000A2Dr 3               @page:
000A2Dr 3  B1 rr                        lda (tmp1),y
000A2Fr 3  91 rr                        sta (tmp2),y
000A31r 3  C8                           iny
000A32r 3  D0 F9                        bne @page
000A34r 3               
000A34r 3  E6 rr                        inc tmp1+1
000A36r 3  E6 rr                        inc tmp2+1
000A38r 3  D6 01                        dec 1,x
000A3Ar 3  D0 F1                        bne @page
000A3Cr 3               
000A3Cr 3               @dopartial:
000A3Cr 3  B5 00                        lda 0,x         ; length of last page
000A3Er 3  F0 09                        beq @done
000A40r 3               
000A40r 3               @partial:
000A40r 3  B1 rr                        lda (tmp1),y
000A42r 3  91 rr                        sta (tmp2),y
000A44r 3  C8                           iny
000A45r 3               
000A45r 3  D6 00                        dec 0,x
000A47r 3  D0 F7                        bne @partial
000A49r 3               
000A49r 3               @done:          ; clear the stack
000A49r 3  8A                           txa
000A4Ar 3  18                           clc
000A4Br 3  69 06                        adc #6
000A4Dr 3  AA                           tax
000A4Er 3               
000A4Er 3  60           z_cmove:        rts
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
000A4Fr 3               ; ## "cmove>"  auto  ANS string
000A4Fr 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
000A4Fr 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
000A4Fr 3                       ; Routines", p. 201, where it is called "move right".
000A4Fr 3                       ;
000A4Fr 3                       ; There are no official tests for this word.
000A4Fr 3                       ; """
000A4Fr 3               
000A4Fr 3               xt_cmove_up:
000A4Fr 3  20 rr rr                     jsr underflow_3
000A52r 3               
000A52r 3                               ; Move destination address to where we can work with it
000A52r 3  B5 02                        lda 2,x
000A54r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000A56r 3  B5 03                        lda 3,x
000A58r 3  18                           clc
000A59r 3  75 01                        adc 1,x
000A5Br 3  85 rr                        sta tmp2+1      ; point to last page of destination
000A5Dr 3               
000A5Dr 3                               ; Move source address to where we can work with it
000A5Dr 3  B5 04                        lda 4,x
000A5Fr 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000A61r 3  B5 05                        lda 5,x
000A63r 3  18                           clc
000A64r 3  75 01                        adc 1,x
000A66r 3  85 rr                        sta tmp1+1      ; point to last page of source
000A68r 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
000A6Ar 3               
000A6Ar 3                               ; Move the last partial page first
000A6Ar 3  B4 00                        ldy 0,x         ; length of last page
000A6Cr 3  F0 0E                        beq @nopartial
000A6Er 3               
000A6Er 3               @outerloop:
000A6Er 3  88                           dey
000A6Fr 3  F0 07                        beq @finishpage
000A71r 3               
000A71r 3               @innerloop:
000A71r 3  B1 rr                        lda (tmp1),y
000A73r 3  91 rr                        sta (tmp2),y
000A75r 3  88                           dey
000A76r 3  D0 F9                        bne @innerloop
000A78r 3               
000A78r 3               @finishpage:
000A78r 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
000A7Ar 3  92 rr                        sta (tmp2)
000A7Cr 3               
000A7Cr 3               @nopartial:
000A7Cr 3  C6 rr                        dec tmp1+1      ; back up to previous pages
000A7Er 3  C6 rr                        dec tmp2+1
000A80r 3  D6 01                        dec 1,x
000A82r 3  D0 EA                        bne @outerloop
000A84r 3               @done:
000A84r 3                               ; clear up the stack and leave
000A84r 3  8A                           txa
000A85r 3  18                           clc
000A86r 3  69 06                        adc #6
000A88r 3  AA                           tax
000A89r 3               
000A89r 3  60           z_cmove_up:     rts
000A8Ar 3               
000A8Ar 3               
000A8Ar 3               
000A8Ar 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
000A8Ar 3               ; ## ":"  auto  ANS core
000A8Ar 3                       ; """https://forth-standard.org/standard/core/Colon
000A8Ar 3                       ;
000A8Ar 3                       ; Use the CREATE routine and fill in the rest by hand.
000A8Ar 3                       ; """
000A8Ar 3               
000A8Ar 3               xt_colon:
000A8Ar 3                               ; If we're already in the compile state, complain
000A8Ar 3                               ; and quit
000A8Ar 3  A5 rr                        lda state
000A8Cr 3  05 rr                        ora state+1
000A8Er 3  F0 05                        beq @1
000A90r 3               
000A90r 3  A9 07                        lda #err_state
000A92r 3  4C rr rr                     jmp error
000A95r 3               @1:
000A95r 3                               ; switch to compile state
000A95r 3  C6 rr                        dec state
000A97r 3  C6 rr                        dec state+1
000A99r 3               
000A99r 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
000A99r 3                               ; word
000A99r 3  A9 40                        lda #%01000000
000A9Br 3  04 rr                        tsb status
000A9Dr 3               
000A9Dr 3                               ; CREATE is going to change the DP to point to the new word's
000A9Dr 3                               ; header. While this is fine for (say) variables, it would mean
000A9Dr 3                               ; that FIND-NAME etc would find a half-finished word when
000A9Dr 3                               ; looking in the Dictionary. To prevent this, we save the old
000A9Dr 3                               ; version of DP and restore it later. The new DP is placed in
000A9Dr 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000A9Dr 3  20 rr rr                     jsr current_to_dp
000AA0r 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
000AA2r 3  48                           pha
000AA3r 3  A5 rr                        lda dp
000AA5r 3  48                           pha
000AA6r 3               
000AA6r 3                               ; Tell create not to print warning for duplicate name.
000AA6r 3  A9 80                        lda #%10000000
000AA8r 3  04 rr                        tsb status
000AAAr 3               
000AAAr 3  20 rr rr                     jsr xt_create
000AADr 3               
000AADr 3                               ; Get the nt (not the xt!) of the new word as described above.
000AADr 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000AADr 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000AB0r 3  A5 rr                        lda dp
000AB2r 3  85 rr                        sta workword
000AB4r 3  A5 rr                        lda dp+1
000AB6r 3  85 rr                        sta workword+1
000AB8r 3               
000AB8r 3                               ; Restore original DP
000AB8r 3  68                           pla
000AB9r 3  85 rr                        sta dp
000ABBr 3  68                           pla
000ABCr 3  85 rr                        sta dp+1
000ABEr 3  20 rr rr                     jsr dp_to_current
000AC1r 3               
000AC1r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000AC1r 3                               ; back up three bytes and overwrite that.
000AC1r 3  A5 rr                        lda cp
000AC3r 3  38                           sec
000AC4r 3  E9 03                        sbc #3
000AC6r 3  85 rr                        sta cp
000AC8r 3  B0 02                        bcs @done
000ACAr 3  C6 rr                        dec cp+1
000ACCr 3               @done:
000ACCr 3  60           z_colon:        rts
000ACDr 3               
000ACDr 3               
000ACDr 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000ACDr 3               ; ## ":NONAME"  auto  ANS core
000ACDr 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000ACDr 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000ACDr 3                       ; """
000ACDr 3               
000ACDr 3               xt_colon_noname:
000ACDr 3                               ; If we're already in the compile state, complain
000ACDr 3                               ; and quit
000ACDr 3  A5 rr                        lda state
000ACFr 3  05 rr                        ora state+1
000AD1r 3  F0 05                        beq @1
000AD3r 3               
000AD3r 3  A9 07                        lda #err_state
000AD5r 3  4C rr rr                     jmp error
000AD8r 3               @1:
000AD8r 3                               ; switch to compile state
000AD8r 3  C6 rr                        dec state
000ADAr 3  C6 rr                        dec state+1
000ADCr 3               
000ADCr 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000ADCr 3                               ; a :NONAME word.
000ADCr 3  A9 40                        lda #%01000000
000ADEr 3  14 rr                        trb status
000AE0r 3               
000AE0r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000AE0r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000AE0r 3                               ; nt and they will modify their behavior.
000AE0r 3  A5 rr                        lda cp
000AE2r 3  85 rr                        sta workword
000AE4r 3  A5 rr                        lda cp+1
000AE6r 3  85 rr                        sta workword+1
000AE8r 3               @done:
000AE8r 3  60           z_colon_noname:        rts
000AE9r 3               
000AE9r 3               
000AE9r 3               
000AE9r 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
000AE9r 3               ; ## ","  auto  ANS core
000AE9r 3                       ; """https://forth-standard.org/standard/core/Comma
000AE9r 3                       ; Store TOS at current place in memory.
000AE9r 3                       ;
000AE9r 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
000AE9r 3                       ; """
000AE9r 3               
000AE9r 3               xt_comma:
000AE9r 3  20 rr rr                     jsr underflow_1
000AECr 3               
000AECr 3  B5 00                        lda 0,x
000AEEr 3  92 rr                        sta (cp)
000AF0r 3               
000AF0r 3  E6 rr                        inc cp
000AF2r 3  D0 02                        bne @1
000AF4r 3  E6 rr                        inc cp+1
000AF6r 3               @1:
000AF6r 3  B5 01                        lda 1,x
000AF8r 3  92 rr                        sta (cp)
000AFAr 3               
000AFAr 3  E6 rr                        inc cp
000AFCr 3  D0 02                        bne @done
000AFEr 3  E6 rr                        inc cp+1
000B00r 3               @done:
000B00r 3  E8                           inx
000B01r 3  E8                           inx
000B02r 3               
000B02r 3  60           z_comma:        rts
000B03r 3               
000B03r 3               
000B03r 3               
000B03r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000B03r 3               ; ## "compare"   auto  ANS string
000B03r 3                       ; """https://forth-standard.org/standard/string/COMPARE
000B03r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000B03r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000B03r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000B03r 3                       ; that entirely matches the beginning of the other string, but is
000B03r 3                       ; shorter, is considered less than the longer string.
000B03r 3                       ; """
000B03r 3               
000B03r 3               xt_compare:
000B03r 3  20 rr rr                     jsr underflow_4
000B06r 3               
000B06r 3                               ; Load the two string addresses into tmp1 and tmp2.
000B06r 3  B5 02                        lda 2,x
000B08r 3  85 rr                        sta tmp2
000B0Ar 3  B5 03                        lda 3,x
000B0Cr 3  85 rr                        sta tmp2+1
000B0Er 3  B5 06                        lda 6,x
000B10r 3  85 rr                        sta tmp1
000B12r 3  B5 07                        lda 7,x
000B14r 3  85 rr                        sta tmp1+1
000B16r 3                               ; The counts will be used in-place on the stack.
000B16r 3               
000B16r 3               @compare_loop:
000B16r 3                               ; Check to see if we are out of letters.
000B16r 3               
000B16r 3                               ; Check string1
000B16r 3  B5 04                        lda 4,x
000B18r 3  15 05                        ora 5,x
000B1Ar 3  F0 2C                        beq @str1_done
000B1Cr 3               
000B1Cr 3                               ; Check string2
000B1Cr 3  B5 00                        lda 0,x
000B1Er 3  15 01                        ora 1,x
000B20r 3  F0 3A                        beq @greater    ; Str2 empty first
000B22r 3               
000B22r 3               @check_letter:
000B22r 3                               ; Both strings have at least one letter left.
000B22r 3                               ; Check the letters against each other.
000B22r 3  B2 rr                        lda (tmp1)
000B24r 3  D2 rr                        cmp (tmp2)
000B26r 3  90 26                        bcc @less
000B28r 3  D0 32                        bne @greater
000B2Ar 3               @next_letter:
000B2Ar 3                               ; Move both tmp pointers and decrement the counts
000B2Ar 3                               ; on the stack.
000B2Ar 3                               ; Increment tmp1
000B2Ar 3  E6 rr                        inc tmp1
000B2Cr 3  D0 02                        bne @1
000B2Er 3  E6 rr                        inc tmp1+1
000B30r 3               @1:
000B30r 3                               ; Increment tmp2
000B30r 3  E6 rr                        inc tmp2
000B32r 3  D0 02                        bne @2
000B34r 3  E6 rr                        inc tmp2+1
000B36r 3               @2:
000B36r 3                               ; Decrement count1 on the stack.
000B36r 3  B5 04                        lda 4,x
000B38r 3  D0 02                        bne @3
000B3Ar 3  D6 05                        dec 5,x
000B3Cr 3               @3:
000B3Cr 3  D6 04                        dec 4,x
000B3Er 3               
000B3Er 3                               ; Decrement count2 on the stack.
000B3Er 3  B5 00                        lda 0,x
000B40r 3  D0 02                        bne @4
000B42r 3  D6 01                        dec 1,x
000B44r 3               @4:
000B44r 3  D6 00                        dec 0,x
000B46r 3               
000B46r 3                               ; Loop around and check again.
000B46r 3  80 CE                        bra @compare_loop
000B48r 3               
000B48r 3               @str1_done:
000B48r 3                               ; String 1 is out of letters. Check string 2.
000B48r 3  B5 00                        lda 0,x
000B4Ar 3  15 01                        ora 1,x
000B4Cr 3  F0 08                        beq @equal      ; Both out of letters
000B4Er 3               
000B4Er 3                               ; Falls into less (str1 is out but str2 has more)
000B4Er 3               @less:
000B4Er 3                               ; Return -1
000B4Er 3  A9 FF                        lda #$FF
000B50r 3  95 06                        sta 6,x
000B52r 3  95 07                        sta 7,x
000B54r 3  80 0C                        bra @done
000B56r 3               @equal:
000B56r 3                               ; Return 0
000B56r 3  74 06                        stz 6,x
000B58r 3  74 07                        stz 7,x
000B5Ar 3  80 06                        bra @done
000B5Cr 3               @greater:
000B5Cr 3                               ; Return 1
000B5Cr 3  A9 01                        lda #1
000B5Er 3  95 06                        sta 6,x
000B60r 3  74 07                        stz 7,x
000B62r 3                               ; Falls into @done
000B62r 3               @done:
000B62r 3                               ; Remove all but the result from the stack.
000B62r 3  8A                           txa
000B63r 3  18                           clc
000B64r 3  69 06                        adc #6
000B66r 3  AA                           tax
000B67r 3               
000B67r 3  60           z_compare:      rts
000B68r 3               
000B68r 3               
000B68r 3               
000B68r 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
000B68r 3               ; ## "compile,"  auto  ANS core ext
000B68r 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
000B68r 3                       ; Compile the given xt in the current word definition. It is an
000B68r 3                       ; error if we are not in the compile state. Because we are using
000B68r 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
000B68r 3                       ; the traditional way. By default, native compiled is allowed, unless
000B68r 3                       ; there is a NN (Never Native) flag associated. If not, we use the
000B68r 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
000B68r 3                       ; is too large to be natively coded: If the size is larger than
000B68r 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
000B68r 3                       ; Native) flag is set, the word is always natively compiled.
000B68r 3                       ; """
000B68r 3               
000B68r 3               xt_compile_comma:
000B68r 3  20 rr rr                     jsr underflow_1
000B6Br 3               
000B6Br 3                               ; See if this is an Always Native (AN) word by checking the
000B6Br 3                               ; AN flag. We need nt for this. First, save a copy of xt to
000B6Br 3                               ; the Return Stack
000B6Br 3  B5 01                        lda 1,x                 ; MSB
000B6Dr 3  48                           pha
000B6Er 3  B5 00                        lda 0,x
000B70r 3  48                           pha                     ; LSB
000B71r 3               
000B71r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
000B74r 3               
000B74r 3                               ; See if this xt even has an nt.
000B74r 3  B5 00                        lda 0,x
000B76r 3  15 01                        ora 1,x
000B78r 3  D0 03                        bne @check_nt
000B7Ar 3               
000B7Ar 3                               ; No nt in dictionary. Just compile as a JSR.
000B7Ar 3  4C rr rr                     jmp @compile_as_jump
000B7Dr 3               
000B7Dr 3               @check_nt:
000B7Dr 3                               ; put nt away for safe keeping
000B7Dr 3  B5 00                        lda 0,x
000B7Fr 3  85 rr                        sta tmptos
000B81r 3  B5 01                        lda 1,x
000B83r 3  85 rr                        sta tmptos+1
000B85r 3               
000B85r 3                               ; status byte is one further down
000B85r 3  F6 00                        inc 0,x
000B87r 3  D0 02                        bne @1
000B89r 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
000B8Br 3               @1:
000B8Br 3  A1 00                        lda (0,x)
000B8Dr 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
000B8Fr 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
000B91r 3  F0 0D                        beq @compile_check
000B93r 3               
000B93r 3                               ; We're natively compiling no matter what. Get length and
000B93r 3                               ; compile in code. Get the original nt back
000B93r 3  A5 rr                        lda tmptos
000B95r 3  95 00                        sta 0,x
000B97r 3  A5 rr                        lda tmptos+1
000B99r 3  95 01                        sta 1,x
000B9Br 3               
000B9Br 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000B9Er 3               
000B9Er 3  80 27                        bra @compile_as_code
000BA0r 3               
000BA0r 3               @compile_check:
000BA0r 3                               ; See if Native Compile is even alowed by checking the NN
000BA0r 3                               ; flag
000BA0r 3  A5 rr                        lda tmp3
000BA2r 3  29 08                        and #NN
000BA4r 3  F0 03                        beq @check_size_limit
000BA6r 3               
000BA6r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000BA9r 3               
000BA9r 3               @check_size_limit:
000BA9r 3                               ; Native compile is a legal option, but we need to see what
000BA9r 3                               ; limit the user set for size (in nc_limit)
000BA9r 3  A5 rr                        lda tmptos
000BABr 3  95 00                        sta 0,x
000BADr 3  A5 rr                        lda tmptos+1
000BAFr 3  95 01                        sta 1,x
000BB1r 3               
000BB1r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000BB4r 3               
000BB4r 3                               ; Check the wordsize MSB against the user-defined limit.
000BB4r 3  B5 01                        lda 1,x
000BB6r 3  C5 rr                        cmp nc_limit+1
000BB8r 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
000BBAr 3  D0 08                        bne @jumpto_compile_as_jump
000BBCr 3               
000BBCr 3                               ; Check the wordsize LSB against the user-defined limit.
000BBCr 3  B5 00                        lda 0,x
000BBEr 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
000BC0r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
000BC2r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
000BC4r 3               
000BC4r 3               @jumpto_compile_as_jump:
000BC4r 3                               ; If the wordsize is greater than the user-defined
000BC4r 3                               ; limit, it will be compiled as a subroutine jump.
000BC4r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000BC7r 3               
000BC7r 3               @compile_as_code:
000BC7r 3                               ; We arrive here with the length of the word's code TOS and
000BC7r 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
000BC7r 3                               ; on the data stack
000BC7r 3  CA                           dex
000BC8r 3  CA                           dex                     ; ( -- u ? )
000BC9r 3  CA                           dex
000BCAr 3  CA                           dex                     ; ( -- u ? ? )
000BCBr 3               
000BCBr 3  B5 04                        lda 4,x
000BCDr 3  95 00                        sta 0,x                 ; LSB of u
000BCFr 3  B5 05                        lda 5,x
000BD1r 3  95 01                        sta 1,x                 ; ( -- u ? u )
000BD3r 3               
000BD3r 3  68                           pla
000BD4r 3  95 04                        sta 4,x                 ; LSB of xt
000BD6r 3  68                           pla
000BD7r 3  95 05                        sta 5,x                 ; ( -- xt ? u )
000BD9r 3               
000BD9r 3  A5 rr                        lda cp                  ; LSB of cp
000BDBr 3  95 02                        sta 2,x
000BDDr 3  A5 rr                        lda cp+1
000BDFr 3  95 03                        sta 3,x                 ; ( -- xt cp u )
000BE1r 3               
000BE1r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
000BE1r 3               
000BE1r 3                               ; Native compiling allows us to strip the stack antics off
000BE1r 3                               ; a number of words that use the Return Stack such as >R, R>,
000BE1r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
000BE1r 3                               ; xt with the contents of the table
000BE1r 3  A0 00                        ldy #0
000BE3r 3               
000BE3r 3               @strip_loop:
000BE3r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
000BE6r 3  D5 04                        cmp 4,x                 ; LSB of xt
000BE8r 3  D0 07                        bne @next_entry
000BEAr 3               
000BEAr 3                               ; LSB is the same, test MSB
000BEAr 3  B9 rr rr                     lda @strip_table+1,y
000BEDr 3  D5 05                        cmp 5,x
000BEFr 3  F0 0C                        beq @found_entry
000BF1r 3               
000BF1r 3                               ; MSB is not equal. Pretend though that we've come from LSB
000BF1r 3                               ; so we can use the next step for both cases
000BF1r 3               @next_entry:
000BF1r 3                               ; Not a word that needs stripping, so check next entry in table
000BF1r 3                               ; Let's see if we're done with the table (marked by zero entry)
000BF1r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
000BF4r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
000BF7r 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
000BF9r 3               
000BF9r 3  C8                           iny
000BFAr 3  C8                           iny
000BFBr 3  80 E6                        bra @strip_loop
000BFDr 3               @found_entry:
000BFDr 3                               ; This word is one of the ones that needs to have its size
000BFDr 3                               ; adjusted during native compile. We find the values in the
000BFDr 3                               ; next table with the same index, which is Y. However, Y is
000BFDr 3                               ; pointing to the MSB, so we need to go back to the LSB and
000BFDr 3                               ; halve the index before we can use it.
000BFDr 3  98                           tya
000BFEr 3  4A                           lsr
000BFFr 3  A8                           tay
000C00r 3               
000C00r 3                               ; Get the adjustment out of the size table. We were clever
000C00r 3                               ; enough to make sure the cut on both ends of the code is
000C00r 3                               ; is the same size.
000C00r 3  B9 rr rr                     lda @strip_size,y
000C03r 3  85 rr                        sta tmptos              ; save a copy
000C05r 3               
000C05r 3                               ; Adjust xt: Start later
000C05r 3  18                           clc
000C06r 3  75 04                        adc 4,x
000C08r 3  95 04                        sta 4,x
000C0Ar 3  90 02                        bcc @2
000C0Cr 3  F6 05                        inc 5,x                 ; we just care about the carry
000C0Er 3               @2:
000C0Er 3               
000C0Er 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
000C0Er 3                               ; bottom of the code, we have to double the value
000C0Er 3  06 rr                        asl tmptos
000C10r 3               
000C10r 3  38                           sec
000C11r 3  B5 00                        lda 0,x
000C13r 3  E5 rr                        sbc tmptos
000C15r 3  95 00                        sta 0,x
000C17r 3  B0 02                        bcs @3
000C19r 3  D6 01                        dec 1,x                 ; we just care about the borrow
000C1Br 3               @3:
000C1Br 3                               ; drop through to underflow check stripping
000C1Br 3               
000C1Br 3               @underflow_strip:
000C1Br 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
000C1Br 3               
000C1Br 3                               ; The user can choose to remove the unterflow testing in those
000C1Br 3                               ; words that have the UF flag. This shortens the word by
000C1Br 3                               ; 3 bytes if there is no underflow.
000C1Br 3               
000C1Br 3                               ; See if the user wants underflow stripping turned on
000C1Br 3  A5 rr                        lda uf_strip
000C1Dr 3  05 rr                        ora uf_strip+1
000C1Fr 3  F0 1C                        beq @specials_done
000C21r 3               
000C21r 3                               ; See if this word even contains underflow checking
000C21r 3  A5 rr                        lda tmp3
000C23r 3  29 10                        and #UF
000C25r 3  F0 16                        beq @specials_done
000C27r 3               
000C27r 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
000C27r 3                               ; long. Note hat PICK is a special case.
000C27r 3               
000C27r 3                               ; Adjust xt: Start later
000C27r 3  18                           clc
000C28r 3  B5 04                        lda 4,x
000C2Ar 3  69 03                        adc #3
000C2Cr 3  95 04                        sta 4,x
000C2Er 3  90 02                        bcc @4
000C30r 3  F6 05                        inc 5,x                  ; we just care about the carry
000C32r 3               @4:
000C32r 3                               ; Adjust u: End earlier
000C32r 3  38                           sec
000C33r 3  B5 00                        lda 0,x
000C35r 3  E9 03                        sbc #3
000C37r 3  95 00                        sta 0,x
000C39r 3  B0 02                        bcs @5
000C3Br 3  D6 01                        dec 1,x                  ; we just care about the borrow
000C3Dr 3               @5:
000C3Dr 3               
000C3Dr 3                               ; --- END OF SPECIAL CASES ---
000C3Dr 3               @specials_done:
000C3Dr 3                               ; Store size of area to be copied for calculation of
000C3Dr 3                               ; new CP. We have to do this after all of the special cases
000C3Dr 3                               ; because they might change the size
000C3Dr 3  B5 01                        lda 1,x                 ; MSB
000C3Fr 3  48                           pha
000C40r 3  B5 00                        lda 0,x                 ; LSB
000C42r 3  48                           pha
000C43r 3               
000C43r 3                               ; Enough of this, let's move those bytes already! We have
000C43r 3                               ; ( xt cp u ) on the stack at this point
000C43r 3  20 rr rr                     jsr xt_move
000C46r 3               
000C46r 3                               ; Update CP
000C46r 3  18                           clc
000C47r 3  68                           pla                     ; LSB
000C48r 3  65 rr                        adc cp
000C4Ar 3  85 rr                        sta cp
000C4Cr 3               
000C4Cr 3  68                           pla                     ; MSB
000C4Dr 3  65 rr                        adc cp+1
000C4Fr 3  85 rr                        sta cp+1
000C51r 3               
000C51r 3  80 2C                        bra @done
000C53r 3               
000C53r 3               @strip_table:
000C53r 3                              ; List of words we strip the Return Stack antics from
000C53r 3                              ; during native compile, zero terminated. The index here
000C53r 3                              ; must be the same as for the sizes
000C53r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
000C57r 3  rr rr        
000C59r 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
000C5Dr 3  00 00        
000C5Fr 3               
000C5Fr 3               @strip_size:
000C5Fr 3                               ; List of bytes to be stripped from the words that get their
000C5Fr 3                               ; Return Stack antics removed during native compile. Index must
000C5Fr 3                               ; be the same as for the xts. Zero terminated.
000C5Fr 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
000C63r 3  06 00        
000C65r 3               
000C65r 3               @compile_as_jump:
000C65r 3                               ; Compile xt as a subroutine jump
000C65r 3  A9 20                        lda #$20
000C67r 3  92 rr                        sta (cp)
000C69r 3               
000C69r 3  A0 01                        ldy #1
000C6Br 3  68                           pla             ; LSB
000C6Cr 3  91 rr                        sta (cp),y
000C6Er 3  C8                           iny
000C6Fr 3  68                           pla             ; MSB
000C70r 3  91 rr                        sta (cp),y
000C72r 3               
000C72r 3                               ; allot space we just used
000C72r 3  A9 03                        lda #3
000C74r 3  18                           clc
000C75r 3  65 rr                        adc cp
000C77r 3  85 rr                        sta cp
000C79r 3  90 02                        bcc @6
000C7Br 3  E6 rr                        inc cp+1
000C7Dr 3               @6:
000C7Dr 3  E8                           inx             ; drop xt
000C7Er 3  E8                           inx
000C7Fr 3               @done:
000C7Fr 3               z_compile_comma:
000C7Fr 3  60                           rts
000C80r 3               
000C80r 3               
000C80r 3               
000C80r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
000C80r 3               ; ## "compile-only"  tested  Tali Forth
000C80r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
000C80r 3                       ; word.
000C80r 3                       ;
000C80r 3                       ; The alternative way to do this is to define a word
000C80r 3                       ; ?COMPILE that makes sure  we're in compile mode
000C80r 3                       ; """
000C80r 3               
000C80r 3               xt_compile_only:
000C80r 3  20 rr rr                     jsr current_to_dp
000C83r 3  A0 01                        ldy #1          ; offset for status byte
000C85r 3  B1 rr                        lda (dp),y
000C87r 3  09 01                        ora #CO        ; make sure bit 7 is set
000C89r 3  91 rr                        sta (dp),y
000C8Br 3               
000C8Br 3  60           z_compile_only: rts
000C8Cr 3               
000C8Cr 3               
000C8Cr 3               
000C8Cr 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
000C8Cr 3               ; ## "constant"  auto  ANS core
000C8Cr 3                       ; """https://forth-standard.org/standard/core/CONSTANT
000C8Cr 3                       ;
000C8Cr 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
000C8Cr 3                       ; more in assembler and let CREATE do the heavy lifting.
000C8Cr 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
000C8Cr 3                       ; a primer on how this works in various Forths. This is the
000C8Cr 3                       ; same code as VALUE in our case.
000C8Cr 3                       ; """
000C8Cr 3               xt_value:
000C8Cr 3               xt_constant:
000C8Cr 3  20 rr rr                     jsr underflow_1
000C8Fr 3               
000C8Fr 3  20 rr rr                     jsr xt_create
000C92r 3               
000C92r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
000C92r 3                               ; but we want DOCONST for constants. Go back two bytes and
000C92r 3                               ; replace the subroutine jump target
000C92r 3  38                           sec
000C93r 3  A5 rr                        lda cp
000C95r 3  E9 02                        sbc #2
000C97r 3  85 rr                        sta tmp1
000C99r 3  A5 rr                        lda cp+1
000C9Br 3  E9 00                        sbc #0
000C9Dr 3  85 rr                        sta tmp1+1
000C9Fr 3               
000C9Fr 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
000CA1r 3  92 rr                        sta (tmp1)
000CA3r 3  A0 01                        ldy #1
000CA5r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
000CA7r 3  91 rr                        sta (tmp1),y
000CA9r 3               
000CA9r 3                               ; Now we save the constant number itself in the next cell
000CA9r 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
000CACr 3               
000CACr 3               adjust_z:
000CACr 3                               ; Now the length of the complete word (z_word) has increased by
000CACr 3                               ; two. We need to update that number or else words such as SEE
000CACr 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
000CACr 3                               ; VALUE and DEFER
000CACr 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
000CAFr 3               
000CAFr 3                               ; z_word is six bytes further down
000CAFr 3  B5 00                        lda 0,x
000CB1r 3  85 rr                        sta tmp1
000CB3r 3  B5 01                        lda 1,x
000CB5r 3  85 rr                        sta tmp1+1
000CB7r 3               
000CB7r 3  A0 06                        ldy #6
000CB9r 3  B1 rr                        lda (tmp1),y
000CBBr 3  18                           clc
000CBCr 3  69 02                        adc #2
000CBEr 3  91 rr                        sta (tmp1),y
000CC0r 3  C8                           iny
000CC1r 3  B1 rr                        lda (tmp1),y
000CC3r 3  69 00                        adc #0                  ; only need carry
000CC5r 3  91 rr                        sta (tmp1),y
000CC7r 3               
000CC7r 3  E8                           inx
000CC8r 3  E8                           inx
000CC9r 3               
000CC9r 3               z_value:
000CC9r 3  60           z_constant:     rts
000CCAr 3               
000CCAr 3               
000CCAr 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
000CCAr 3               ; ## "count"  auto  ANS core
000CCAr 3                       ; """https://forth-standard.org/standard/core/COUNT
000CCAr 3                       ; Convert old-style character string to address-length pair. Note
000CCAr 3                       ; that the length of the string c-addr is stored in character length
000CCAr 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
000CCAr 3                       ; though COUNT can also be used to step through a string character by
000CCAr 3                       ; character.
000CCAr 3                       ; """
000CCAr 3               xt_count:
000CCAr 3  20 rr rr                     jsr underflow_1
000CCDr 3               
000CCDr 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
000CCFr 3  A8                           tay
000CD0r 3               
000CD0r 3                               ; move start address up by one
000CD0r 3  F6 00                        inc 0,x         ; LSB
000CD2r 3  D0 02                        bne @1
000CD4r 3  F6 01                        inc 1,x         ; MSB
000CD6r 3               
000CD6r 3                               ; save number of characters to stack
000CD6r 3               @1:
000CD6r 3  98                           tya
000CD7r 3  CA                           dex
000CD8r 3  CA                           dex
000CD9r 3  95 00                        sta 0,x         ; LSB
000CDBr 3  74 01                        stz 1,x         ; MSB, always zero
000CDDr 3               
000CDDr 3  60           z_count:        rts
000CDEr 3               
000CDEr 3               
000CDEr 3               ; ## CR ( -- ) "Print a line feed"
000CDEr 3               ; ## "cr"  auto  ANS core
000CDEr 3                       ; """https://forth-standard.org/standard/core/CR"""
000CDEr 3               xt_cr:
000CDEr 3  A9 0A                        lda #AscLF
000CE0r 3  20 rr rr                     jsr emit_a
000CE3r 3  60           z_cr:           rts
000CE4r 3               
000CE4r 3               
000CE4r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
000CE4r 3               ; ## "create"  auto  ANS core
000CE4r 3                       ; """https://forth-standard.org/standard/core/CREATE
000CE4r 3                       ;
000CE4r 3                       ; See the drawing in headers.asm for details on the header
000CE4r 3                       ; """
000CE4r 3               
000CE4r 3               xt_create:
000CE4r 3                               ; get string
000CE4r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
000CE7r 3               
000CE7r 3                               ; if we were given an empty string, we complain and quit
000CE7r 3  B5 00                        lda 0,x
000CE9r 3  15 01                        ora 1,x
000CEBr 3  D0 05                        bne @got_name
000CEDr 3               
000CEDr 3  A9 05                        lda #err_noname
000CEFr 3  4C rr rr                     jmp error
000CF2r 3               
000CF2r 3               @got_name:
000CF2r 3                               ; Enforce maximal length of string by overwriting the MSB of
000CF2r 3                               ; the length. There is a possible error here: If the string
000CF2r 3                               ; is exactly 255 chars long, then a lot of the following
000CF2r 3                               ; additions will fail because of wrapping
000CF2r 3  74 01                        stz 1,x
000CF4r 3               
000CF4r 3                               ; Check to see if this name already exists.
000CF4r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
000CF7r 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
000CFAr 3               
000CFAr 3  B5 00                        lda 0,x
000CFCr 3  15 01                        ora 1,x
000CFEr 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
000D00r 3               
000D00r 3                               ; This name already exists.  See if we are supposed to print
000D00r 3                               ; the message for it.
000D00r 3  E8                           inx                     ; Drop flag (nt) from find-name.
000D01r 3  E8                           inx
000D02r 3               
000D02r 3                               ; Check bit 7
000D02r 3  24 rr                        bit status
000D04r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
000D06r 3               
000D06r 3                               ; We aren't supposed to print the redefined message ourselves,
000D06r 3                               ; but we should indicate that it is redefined (for ; to print
000D06r 3                               ; later).
000D06r 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
000D08r 3  05 rr                        ora status
000D0Ar 3  85 rr                        sta status
000D0Cr 3  80 18                        bra @process_name
000D0Er 3               
000D0Er 3               @redefined_name:
000D0Er 3                               ; Print the message that the name is redefined.
000D0Er 3  A9 02                        lda #str_redefined
000D10r 3  20 rr rr                     jsr print_string_no_lf
000D13r 3               
000D13r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
000D16r 3  20 rr rr                     jsr xt_type
000D19r 3  20 rr rr                     jsr xt_space
000D1Cr 3               
000D1Cr 3  80 08                        bra @process_name
000D1Er 3               
000D1Er 3               @new_name:
000D1Er 3  E8                           inx                     ; Drop flag (0) from find-name.
000D1Fr 3  E8                           inx
000D20r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
000D22r 3  25 rr                        and status
000D24r 3  85 rr                        sta status
000D26r 3               
000D26r 3               @process_name:
000D26r 3  B5 00                        lda 0,x
000D28r 3  85 rr                        sta tmp2                ; store length of string in tmp2
000D2Ar 3               
000D2Ar 3                               ; remember the first free byte of memory as the start of
000D2Ar 3                               ; the new word
000D2Ar 3  A5 rr                        lda cp
000D2Cr 3  85 rr                        sta tmp1
000D2Er 3  A5 rr                        lda cp+1
000D30r 3  85 rr                        sta tmp1+1
000D32r 3               
000D32r 3                               ; We need 8 bytes plus the length of the string for our new header.
000D32r 3                               ; This is also the offset for the start of the code field (the
000D32r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
000D32r 3                               ; just allot the space afterwards
000D32r 3  B5 00                        lda 0,x
000D34r 3  18                           clc
000D35r 3  69 08                        adc #8
000D37r 3  85 rr                        sta tmp3                ; total header length
000D39r 3               
000D39r 3                               ; We need three more bytes for for the hardcoded code field
000D39r 3                               ; area (CFA), the "payload" of the word which by default will
000D39r 3                               ; be a subroutine jump to DOVAR
000D39r 3  18                           clc
000D3Ar 3  69 03                        adc #3
000D3Cr 3               
000D3Cr 3                               ; We overwrite the length of the string returned by PARSE-NAME
000D3Cr 3                               ; and then call ALLOT
000D3Cr 3  95 00                        sta 0,x
000D3Er 3  74 01                        stz 1,x         ; max header size is 255 chars
000D40r 3  20 rr rr                     jsr xt_allot    ; ( addr )
000D43r 3               
000D43r 3                               ; Get the CURRENT dictionary pointer.
000D43r 3  20 rr rr                     jsr current_to_dp
000D46r 3               
000D46r 3                               ; Now we walk through the header with Y as the index, adding
000D46r 3                               ; information byte-by-byte
000D46r 3  A0 00                        ldy #0
000D48r 3               
000D48r 3                               ; HEADER BYTE 0: Length of string
000D48r 3  A5 rr                        lda tmp2
000D4Ar 3  91 rr                        sta (tmp1),y
000D4Cr 3               
000D4Cr 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
000D4Cr 3                               ; to "never native", user will have to decide if they should
000D4Cr 3                               ; be inlined
000D4Cr 3  A9 08                        lda #NN
000D4Er 3               
000D4Er 3                               ; Also, words defined by CREATE are marked in the header has
000D4Er 3                               ; having a Code Field Area (CFA), which is a bit tricky for
000D4Er 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
000D4Er 3                               ; correctly with DOES> and CREATE. See the discussion at
000D4Er 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
000D4Er 3  09 20                        ora #HC
000D50r 3  C8                           iny
000D51r 3  91 rr                        sta (tmp1),y
000D53r 3  C8                           iny
000D54r 3               
000D54r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
000D54r 3                               ; in the Dictionary
000D54r 3  A5 rr                        lda dp
000D56r 3  91 rr                        sta (tmp1),y
000D58r 3  C8                           iny
000D59r 3  A5 rr                        lda dp+1
000D5Br 3  91 rr                        sta (tmp1),y
000D5Dr 3  C8                           iny
000D5Er 3               
000D5Er 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
000D5Er 3  A5 rr                        lda tmp1+1
000D60r 3  85 rr                        sta dp+1
000D62r 3  A5 rr                        lda tmp1
000D64r 3  85 rr                        sta dp
000D66r 3               
000D66r 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
000D66r 3                               ; This begins after the header so we take the length of the
000D66r 3                               ; header, which we cleverly saved in tmp3, and use it as an
000D66r 3                               ; offset to the address of the start of the word. We come here
000D66r 3                               ; with tmp1 in A
000D66r 3  18                           clc
000D67r 3  65 rr                        adc tmp3        ; add total header length
000D69r 3  91 rr                        sta (tmp1),y
000D6Br 3  48                           pha             ; we need this in the next step
000D6Cr 3  C8                           iny
000D6Dr 3               
000D6Dr 3  A5 rr                        lda tmp1+1
000D6Fr 3  69 00                        adc #0          ; only need the carry
000D71r 3  91 rr                        sta (tmp1),y
000D73r 3  C8                           iny
000D74r 3               
000D74r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
000D74r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
000D74r 3                               ; bytes down, and then one more byte so that the z_ label points
000D74r 3                               ; to the (still fictional) RTS instruction for correct compilation
000D74r 3  68                           pla             ; LSB of "z_" address
000D75r 3  18                           clc
000D76r 3  69 03                        adc #3
000D78r 3  91 rr                        sta (tmp1),y
000D7Ar 3               
000D7Ar 3  88                           dey             ; get the MSB of xt back
000D7Br 3  B1 rr                        lda (tmp1),y
000D7Dr 3  69 00                        adc #0          ; only need the carry
000D7Fr 3  C8                           iny
000D80r 3  C8                           iny
000D81r 3  91 rr                        sta (tmp1),y
000D83r 3  C8                           iny
000D84r 3               
000D84r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
000D84r 3                               ; length in tmp2. We subtract 8 from the address so we can
000D84r 3                               ; use the same loop index, which is already 8 byte ahead at
000D84r 3                               ; this point
000D84r 3  B5 00                        lda 0,x
000D86r 3  38                           sec
000D87r 3  E9 08                        sbc #8
000D89r 3  85 rr                        sta tmptos
000D8Br 3               
000D8Br 3  B5 01                        lda 1,x
000D8Dr 3  E9 00                        sbc #0          ; only need carry
000D8Fr 3  85 rr                        sta tmptos+1
000D91r 3               
000D91r 3               @name_loop:
000D91r 3  B1 rr                        lda (tmptos),y
000D93r 3               
000D93r 3                               ; Make sure it goes into the dictionary in lower case.
000D93r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
000D95r 3  B0 07                        bcs @store_name
000D97r 3  C9 41                        cmp #$41        ; ASCII 'A'
000D99r 3  90 03                        bcc @store_name
000D9Br 3               
000D9Br 3                               ; An uppercase letter has been located. Make it
000D9Br 3                               ; lowercase.
000D9Br 3  18                           clc
000D9Cr 3  69 20                        adc #$20
000D9Er 3               
000D9Er 3                               ; Fall into @store_name.
000D9Er 3               
000D9Er 3               @store_name:
000D9Er 3  91 rr                        sta (tmp1),y
000DA0r 3  C8                           iny
000DA1r 3  C6 rr                        dec tmp2
000DA3r 3  D0 EC                        bne @name_loop
000DA5r 3               
000DA5r 3                               ; After thename string comes the code field, starting at the
000DA5r 3                               ; current xt of this word, which is initially a jump to the
000DA5r 3                               ; subroutine to DOVAR. We code this jump by hand
000DA5r 3  A9 20                        lda #$20        ; opcode of JSR
000DA7r 3  91 rr                        sta (tmp1),y
000DA9r 3  C8                           iny
000DAAr 3  A9 rr                        lda #<dovar
000DACr 3  91 rr                        sta (tmp1),y
000DAEr 3  C8                           iny
000DAFr 3  A9 rr                        lda #>dovar
000DB1r 3  91 rr                        sta (tmp1),y
000DB3r 3               
000DB3r 3                               ; Update the CURRENT wordlist with the new DP.
000DB3r 3                               ; We do this down here because this routine uses Y.
000DB3r 3  20 rr rr                     jsr dp_to_current
000DB6r 3               
000DB6r 3                               ; And we're done. Restore stack
000DB6r 3  E8                           inx
000DB7r 3  E8                           inx
000DB8r 3               
000DB8r 3  60           z_create:       rts
000DB9r 3               
000DB9r 3               
000DB9r 3               
000DB9r 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
000DB9r 3               ; ## "d-"  auto  ANS double
000DB9r 3                       ; """https://forth-standard.org/standard/double/DMinus"""
000DB9r 3               
000DB9r 3               xt_d_minus:
000DB9r 3  20 rr rr                     jsr underflow_4 ; two double numbers
000DBCr 3               
000DBCr 3  38                           sec
000DBDr 3               
000DBDr 3  B5 06                        lda 6,x         ; LSB of lower word
000DBFr 3  F5 02                        sbc 2,x
000DC1r 3  95 06                        sta 6,x
000DC3r 3               
000DC3r 3  B5 07                        lda 7,x         ; MSB of lower word
000DC5r 3  F5 03                        sbc 3,x
000DC7r 3  95 07                        sta 7,x
000DC9r 3               
000DC9r 3  B5 04                        lda 4,x         ; LSB of upper word
000DCBr 3  F5 00                        sbc 0,x
000DCDr 3  95 04                        sta 4,x
000DCFr 3               
000DCFr 3  B5 05                        lda 5,x         ; MSB of upper word
000DD1r 3  F5 01                        sbc 1,x
000DD3r 3  95 05                        sta 5,x
000DD5r 3               
000DD5r 3  E8                           inx
000DD6r 3  E8                           inx
000DD7r 3  E8                           inx
000DD8r 3  E8                           inx
000DD9r 3               
000DD9r 3  60           z_d_minus:      rts
000DDAr 3               
000DDAr 3               
000DDAr 3               
000DDAr 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
000DDAr 3               ; ## "d+"  auto  ANS double
000DDAr 3                       ; """https://forth-standard.org/standard/double/DPlus"""
000DDAr 3               
000DDAr 3               xt_d_plus:
000DDAr 3  20 rr rr                     jsr underflow_4 ; two double numbers
000DDDr 3               
000DDDr 3  18                           clc
000DDEr 3  B5 02                        lda 2,x         ; LSB of lower word
000DE0r 3  75 06                        adc 6,x
000DE2r 3  95 06                        sta 6,x
000DE4r 3               
000DE4r 3  B5 03                        lda 3,x         ; MSB of lower word
000DE6r 3  75 07                        adc 7,x
000DE8r 3  95 07                        sta 7,x
000DEAr 3               
000DEAr 3  B5 00                        lda 0,x         ; LSB of upper word
000DECr 3  75 04                        adc 4,x
000DEEr 3  95 04                        sta 4,x
000DF0r 3               
000DF0r 3  B5 01                        lda 1,x         ; MSB of upper word
000DF2r 3  75 05                        adc 5,x
000DF4r 3  95 05                        sta 5,x
000DF6r 3               
000DF6r 3  E8                           inx
000DF7r 3  E8                           inx
000DF8r 3  E8                           inx
000DF9r 3  E8                           inx
000DFAr 3               
000DFAr 3  60           z_d_plus:       rts
000DFBr 3               
000DFBr 3               
000DFBr 3               
000DFBr 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
000DFBr 3               ; ## "d>s"  auto  ANS double
000DFBr 3                       ; """https://forth-standard.org/standard/double/DtoS
000DFBr 3                       ; Though this is basically just DROP, we keep it
000DFBr 3                       ; separate so we can test for underflow
000DFBr 3                       ; """
000DFBr 3               
000DFBr 3               xt_d_to_s:
000DFBr 3  20 rr rr                     jsr underflow_2
000DFEr 3               
000DFEr 3  E8                           inx
000DFFr 3  E8                           inx
000E00r 3               
000E00r 3  60           z_d_to_s:       rts
000E01r 3               
000E01r 3               
000E01r 3               
000E01r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
000E01r 3               ; ## "dabs"  auto  ANS double
000E01r 3                       ; """https://forth-standard.org/standard/double/DABS"""
000E01r 3               
000E01r 3               xt_dabs:
000E01r 3  20 rr rr                     jsr underflow_2 ; double number
000E04r 3               
000E04r 3  B5 01                        lda 1,x         ; MSB of high cell
000E06r 3  10 17                        bpl @done       ; positive, we get off light
000E08r 3               
000E08r 3                               ; negative, calculate 0 - d
000E08r 3  A0 00                        ldy #0
000E0Ar 3  38                           sec
000E0Br 3               
000E0Br 3  98                           tya
000E0Cr 3  F5 02                        sbc 2,x         ; LSB of low cell
000E0Er 3  95 02                        sta 2,x
000E10r 3               
000E10r 3  98                           tya
000E11r 3  F5 03                        sbc 3,x         ; MSB of low cell
000E13r 3  95 03                        sta 3,x
000E15r 3               
000E15r 3  98                           tya
000E16r 3  F5 00                        sbc 0,x         ; LSB of high cell
000E18r 3  95 00                        sta 0,x
000E1Ar 3               
000E1Ar 3  98                           tya
000E1Br 3  F5 01                        sbc 1,x         ; MSB of high cell
000E1Dr 3  95 01                        sta 1,x
000E1Fr 3               @done:
000E1Fr 3  60           z_dabs:         rts
000E20r 3               
000E20r 3               
000E20r 3               
000E20r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
000E20r 3               ; ## "decimal"  auto  ANS core
000E20r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
000E20r 3               xt_decimal:
000E20r 3  A9 0A                        lda #10
000E22r 3  85 rr                        sta base
000E24r 3  64 rr                        stz base+1              ; paranoid
000E26r 3               
000E26r 3  60           z_decimal:      rts
000E27r 3               
000E27r 3               
000E27r 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
000E27r 3               ; ## "defer"  auto  ANS core ext
000E27r 3                       ; """https://forth-standard.org/standard/core/DEFER
000E27r 3                       ; Reserve an name that can be linked to various xt by IS.
000E27r 3                       ;
000E27r 3                       ; The ANS reference implementation is
000E27r 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
000E27r 3                       ; But we use this routine as a low-level word so things go faster
000E27r 3               
000E27r 3               xt_defer:
000E27r 3  20 rr rr                     jsr xt_create
000E2Ar 3               
000E2Ar 3                               ; CREATE by default installs a subroutine jump to DOVAR,
000E2Ar 3                               ; but we actually want DODEFER this time. Go back two
000E2Ar 3                               ; bytes and repace the subroutine jump target
000E2Ar 3  A5 rr                        lda cp          ; LSB
000E2Cr 3  38                           sec
000E2Dr 3  E9 02                        sbc #2
000E2Fr 3  85 rr                        sta tmp1
000E31r 3               
000E31r 3  A5 rr                        lda cp+1        ; MSB
000E33r 3  E9 00                        sbc #0          ; we only care about the borrow
000E35r 3  85 rr                        sta tmp1+1
000E37r 3               
000E37r 3                               ; Save the target address
000E37r 3  A0 00                        ldy #0
000E39r 3  A9 rr                        lda #<dodefer   ; LSB
000E3Br 3  91 rr                        sta (tmp1),y
000E3Dr 3  C8                           iny
000E3Er 3  A9 rr                        lda #>dodefer   ; MSB
000E40r 3  91 rr                        sta (tmp1),y
000E42r 3               
000E42r 3               
000E42r 3                               ; DODEFER executes the next address it finds after
000E42r 3                               ; its call. As default, we include the error
000E42r 3                               ; "Defer not defined"
000E42r 3  A9 rr                        lda #<defer_error
000E44r 3  92 rr                        sta (cp)
000E46r 3  E6 rr                        inc cp
000E48r 3  D0 02                        bne @1
000E4Ar 3  E6 rr                        inc cp+1
000E4Cr 3               @1:
000E4Cr 3  A9 rr                        lda #>defer_error
000E4Er 3  92 rr                        sta (cp)
000E50r 3  E6 rr                        inc cp
000E52r 3  D0 02                        bne @2
000E54r 3  E6 rr                        inc cp+1
000E56r 3               @2:
000E56r 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
000E59r 3               
000E59r 3  60           z_defer:        rts
000E5Ar 3               
000E5Ar 3               
000E5Ar 3               
000E5Ar 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
000E5Ar 3               ; ## "defer@"  auto  ANS core ext
000E5Ar 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
000E5Ar 3               
000E5Ar 3               xt_defer_fetch:
000E5Ar 3                               ; No underflow checking as >BODY does it.
000E5Ar 3  20 rr rr                     jsr xt_to_body
000E5Dr 3  20 rr rr                     jsr xt_fetch
000E60r 3  60           z_defer_fetch:  rts
000E61r 3               
000E61r 3               
000E61r 3               
000E61r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
000E61r 3               ; ## "defer!"  auto  ANS core ext
000E61r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
000E61r 3               
000E61r 3               xt_defer_store:
000E61r 3                               ; No underflow checking as >BODY and ! do it.
000E61r 3  20 rr rr                     jsr xt_to_body
000E64r 3  20 rr rr                     jsr xt_store
000E67r 3  60           z_defer_store:  rts
000E68r 3               
000E68r 3               
000E68r 3               
000E68r 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
000E68r 3               ; ## "definitions" auto ANS search
000E68r 3               xt_definitions:
000E68r 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
000E6Ar 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
000E6Cr 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
000E6Er 3  91 rr                        sta (up),y
000E70r 3  60           z_definitions:  rts
000E71r 3               
000E71r 3               
000E71r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
000E71r 3               ; ## "depth"  auto  ANS core
000E71r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
000E71r 3               xt_depth:
000E71r 3  A9 rr                        lda #dsp0
000E73r 3  86 rr                        stx tmpdsp
000E75r 3  38                           sec
000E76r 3  E5 rr                        sbc tmpdsp
000E78r 3               
000E78r 3                               ; divide by two because each cell is two bytes
000E78r 3  4A                           lsr
000E79r 3               
000E79r 3  CA                           dex
000E7Ar 3  CA                           dex
000E7Br 3  95 00                        sta 0,x
000E7Dr 3  74 01                        stz 1,x
000E7Fr 3               
000E7Fr 3  60           z_depth:        rts
000E80r 3               
000E80r 3               
000E80r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
000E80r 3               ; ## "digit?"  auto  Tali Forth
000E80r 3                       ; """Inspired by the pForth instruction DIGIT, see
000E80r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
000E80r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
000E80r 3                       ; pForth, we get the base (radix) ourselves instead of having the
000E80r 3                       ; user provide it. There is no standard name for this routine, which
000E80r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
000E80r 3                       ; """
000E80r 3               
000E80r 3               xt_digit_question:
000E80r 3  20 rr rr                     jsr underflow_1
000E83r 3               
000E83r 3                               ; one way or another, we're going to need room for the
000E83r 3                               ; flag on the stack
000E83r 3  CA                           dex
000E84r 3  CA                           dex
000E85r 3  74 00                        stz 0,x                 ; default flag is failure
000E87r 3  74 01                        stz 1,x
000E89r 3  74 03                        stz 3,x                 ; paranoid
000E8Br 3               
000E8Br 3                               ; Check the character, now in the LSB of NOS. First, make
000E8Br 3                               ; sure we're not below the ASCII code for "0"
000E8Br 3  B5 02                        lda 2,x
000E8Dr 3  C9 30                        cmp #'0'
000E8Fr 3  90 23                        bcc @done               ; failure flag already set
000E91r 3               
000E91r 3                               ; Next, see if we are below "9", because that would make
000E91r 3                               ; this a normal number
000E91r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
000E93r 3  90 12                        bcc @checkbase
000E95r 3               
000E95r 3                               ; Well, then let's see if this is the gap between "9" and "A"
000E95r 3                               ; so we can treat the whole range as a number
000E95r 3  C9 41                        cmp #'A'
000E97r 3  90 1B                        bcc @done               ; failure flag is already set
000E99r 3               
000E99r 3                               ; probably a letter, so we make sure it is uppercase
000E99r 3  C9 61                        cmp #'a'
000E9Br 3  90 07                        bcc @case_done          ; not lower case, too low
000E9Dr 3  C9 7B                        cmp #'z'+1
000E9Fr 3  B0 03                        bcs @case_done          ; not lower case, too high
000EA1r 3               
000EA1r 3  18                           clc                     ; just right
000EA2r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
000EA4r 3               
000EA4r 3               @case_done:
000EA4r 3                               ; get rid of the gap between "9" and "A" so we can treat
000EA4r 3                               ; the whole range as one number
000EA4r 3  38                           sec
000EA5r 3  E9 07                        sbc #7                  ; fall through to @checkbase
000EA7r 3               
000EA7r 3               @checkbase:
000EA7r 3                               ; we have a number, now see if it falls inside the range
000EA7r 3                               ; provided by BASE
000EA7r 3  38                           sec
000EA8r 3  E9 30                        sbc #'0'                 ; this is also the conversion step
000EAAr 3  C5 rr                        cmp base
000EACr 3  B0 06                        bcs @done               ; already have false flag
000EAEr 3               
000EAEr 3                               ; Found a legal number
000EAEr 3  95 02                        sta 2,x                 ; put number in NOS
000EB0r 3  D6 00                        dec 0,x                 ; set success flag
000EB2r 3  D6 01                        dec 1,x
000EB4r 3               
000EB4r 3               @done:
000EB4r 3               z_digit_question:
000EB4r 3  60                           rts
000EB5r 3               
000EB5r 3               
000EB5r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
000EB5r 3               ; ## "disasm"  tested  Tali Forth
000EB5r 3                       ; """Convert a segment of memory to assembler output. This
000EB5r 3                       ; word is vectored so people can add their own disassembler.
000EB5r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
000EB5r 3                       ; code, see the section on The Disassembler in the manual and
000EB5r 3                       ; the file disassembler.asm for more details.
000EB5r 3                       ; """
000EB5r 3               xt_disasm:
000EB5r 3  20 rr rr                     jsr underflow_2
000EB8r 3                           .ifdef disassembler
000EB8r 3                               jsr disassembler
000EB8r 3                           .endif
000EB8r 3               
000EB8r 3  60           z_disasm:       rts
000EB9r 3               
000EB9r 3               
000EB9r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
000EB9r 3               ; ## "dnegate"  auto  ANS double
000EB9r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
000EB9r 3               xt_dnegate:
000EB9r 3  20 rr rr                     jsr underflow_2 ; double number
000EBCr 3               
000EBCr 3  A0 00             		ldy #0
000EBEr 3  38                           sec
000EBFr 3               
000EBFr 3  98                           tya
000EC0r 3  F5 02                        sbc 2,x         ; LSB of low cell
000EC2r 3  95 02                        sta 2,x
000EC4r 3               
000EC4r 3  98                           tya
000EC5r 3  F5 03                        sbc 3,x         ; MSB of low cell
000EC7r 3  95 03                        sta 3,x
000EC9r 3               
000EC9r 3  98                           tya
000ECAr 3  F5 00                        sbc 0,x         ; LSB of high cell
000ECCr 3  95 00                        sta 0,x
000ECEr 3               
000ECEr 3  98                           tya
000ECFr 3  F5 01                        sbc 1,x         ; MSB of high cell
000ED1r 3  95 01                        sta 1,x
000ED3r 3               
000ED3r 3  60           z_dnegate:      rts
000ED4r 3               
000ED4r 3               
000ED4r 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
000ED4r 3               ; ## "?do"  auto  ANS core ext
000ED4r 3                       ; """https://forth-standard.org/standard/core/qDO"""
000ED4r 3               xt_question_do:
000ED4r 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
000ED4r 3                               ; to mark which is which
000ED4r 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
000ED6r 3  85 rr                        sta tmp1
000ED8r 3  80 02                        bra do_common           ; skip flag for DO
000EDAr 3               
000EDAr 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
000EDAr 3               ; ## "do"  auto  ANS core
000EDAr 3                       ; """https://forth-standard.org/standard/core/DO
000EDAr 3                       ;
000EDAr 3                       ; Compile-time part of DO. Could be realized in Forth as
000EDAr 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
000EDAr 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
000EDAr 3                       ; a routine that pushes the end address to the Return Stack at run
000EDAr 3                       ; time. This is based on a suggestion by Garth Wilson, see
000EDAr 3                       ; the Control Flow section of the manual for details.
000EDAr 3                       ;
000EDAr 3                       ; This may not be native compile. Don't check for a stack underflow
000EDAr 3                       ; """
000EDAr 3               
000EDAr 3               xt_do:
000EDAr 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
000EDAr 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
000EDCr 3               do_common:
000EDCr 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
000EDCr 3                               ; compile the address we need to LDA at runtime
000EDCr 3  CA                           dex
000EDDr 3  CA                           dex
000EDEr 3  A5 rr                        lda cp
000EE0r 3  95 00                        sta 0,x                 ; LSB
000EE2r 3  A5 rr                        lda cp+1
000EE4r 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
000EE6r 3               
000EE6r 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
000EE6r 3                               ; replace by the actual LDA/PHA instructions
000EE6r 3  A9 05                        lda #5                  ; we don't really care about the value,
000EE8r 3  A8                           tay                     ; so we use 5 to be tricky
000EE9r 3               @loop:
000EE9r 3  91 rr                        sta (cp),y
000EEBr 3  88                           dey
000EECr 3  10 FB                        bpl @loop
000EEEr 3               
000EEEr 3                               ; update CP
000EEEr 3  1A                           inc             ; we used 5 as a dummy value, this is why
000EEFr 3  18                           clc
000EF0r 3  65 rr                        adc cp
000EF2r 3  85 rr                        sta cp
000EF4r 3  90 02                        bcc @1
000EF6r 3  E6 rr                        inc cp+1
000EF8r 3               @1:
000EF8r 3                               ; compile the (?DO) portion of ?DO if appropriate
000EF8r 3  A5 rr                        lda tmp1
000EFAr 3  F0 17                        beq @compile_do
000EFCr 3               
000EFCr 3                               ; We came from ?DO, so compile its runtime first. We do
000EFCr 3                               ; this with a quick loop because we know it has to be
000EFCr 3                               ; Always Native anyway
000EFCr 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
000EFEr 3  5A                           phy             ; save counter to calculate new CP
000EFFr 3               @2:
000EFFr 3  B9 rr rr                     lda question_do_runtime,y
000F02r 3  91 rr                        sta (cp),y
000F04r 3  88                           dey
000F05r 3  10 F8                        bpl @2
000F07r 3               
000F07r 3                               ; adjust CP
000F07r 3  68                           pla             ; retrieve counter
000F08r 3  18                           clc
000F09r 3  65 rr                        adc cp
000F0Br 3  85 rr                        sta cp
000F0Dr 3  A5 rr                        lda cp+1
000F0Fr 3  69 00                        adc #0          ; only care about carry
000F11r 3  85 rr                        sta cp+1        ; fall through to @compile_do
000F13r 3               
000F13r 3               @compile_do:
000F13r 3                               ; compile runtime part of DO.
000F13r 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
000F15r 3  5A                           phy             ; save counter to calculate new CP
000F16r 3               @3:
000F16r 3  B9 rr rr                     lda do_runtime,y
000F19r 3  91 rr                        sta (cp),y
000F1Br 3  88                           dey
000F1Cr 3  10 F8                        bpl @3
000F1Er 3               
000F1Er 3                               ; adjust CP
000F1Er 3  68                           pla             ; retrieve counter
000F1Fr 3  18                           clc
000F20r 3  65 rr                        adc cp
000F22r 3  85 rr                        sta cp
000F24r 3  A5 rr                        lda cp+1
000F26r 3  69 00                        adc #0          ; only care about carry
000F28r 3  85 rr                        sta cp+1
000F2Ar 3               
000F2Ar 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
000F2Ar 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
000F2Ar 3                               ; do with the HERE we're saving for LEAVE
000F2Ar 3  CA                           dex
000F2Br 3  CA                           dex
000F2Cr 3  A5 rr                        lda cp          ; LSB
000F2Er 3  95 00                        sta 0,x
000F30r 3  A5 rr                        lda cp+1        ; MSB
000F32r 3  95 01                        sta 1,x
000F34r 3               z_question_do:
000F34r 3  60           z_do:           rts
000F35r 3               
000F35r 3               
000F35r 3               do_runtime:
000F35r 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
000F35r 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
000F35r 3                       ; the FIG Forth loop (you can see which version you have by running
000F35r 3                       ; a loop with start and limit as the same value, for instance
000F35r 3                       ; 0 0 DO -- these will walk through the number space). We use a
000F35r 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
000F35r 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
000F35r 3                       ; for further discussion of this. The source given there for
000F35r 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
000F35r 3                       ; in some Forths. Usually, we would define this as a separate word
000F35r 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
000F35r 3                       ; However, we can do it faster if we just copy the bytes
000F35r 3                       ; of this routine with a simple loop in DO.
000F35r 3                       ; """
000F35r 3                               ; First step: create fudge factor (FUFA) by subtracting the
000F35r 3                               ; limit from $8000, the number that will trip the overflow
000F35r 3                               ; flag
000F35r 3  38                           sec
000F36r 3  A9 00                        lda #0
000F38r 3  F5 02                        sbc 2,x         ; LSB of limit
000F3Ar 3  95 02                        sta 2,x         ; save FUFA for later use
000F3Cr 3               
000F3Cr 3  A9 80                        lda #$80
000F3Er 3  F5 03                        sbc 3,x         ; MSB of limit
000F40r 3  95 03                        sta 3,x         ; save FUFA for later use
000F42r 3  48                           pha             ; FUFA replaces limit on R stack
000F43r 3  B5 02                        lda 2,x         ; LSB of limit
000F45r 3  48                           pha
000F46r 3               
000F46r 3                               ; Second step: index is FUFA plus original index
000F46r 3  18                           clc
000F47r 3  B5 00                        lda 0,x         ; LSB of original index
000F49r 3  75 02                        adc 2,x         ; add LSB of FUFA
000F4Br 3  95 00                        sta 0,x
000F4Dr 3  B5 01                        lda 1,x         ; MSB of orginal index
000F4Fr 3  75 03                        adc 3,x         ; add MSB of FUFA
000F51r 3  48                           pha
000F52r 3  B5 00                        lda 0,x         ; LSB of index
000F54r 3  48                           pha
000F55r 3               
000F55r 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
000F55r 3                               ; use it later. Clean the Data Stack
000F55r 3  E8                           inx
000F56r 3  E8                           inx
000F57r 3  E8                           inx
000F58r 3  E8                           inx             ; no RTS because this is copied into code
000F59r 3               do_runtime_end:
000F59r 3               
000F59r 3               question_do_runtime:
000F59r 3               
000F59r 3                       ; """This is called (?DO) in some Forths. See the explanation at
000F59r 3                       ; do_runtime for the background on this design
000F59r 3                       ; """
000F59r 3                               ; see if TOS and NOS are equal. Change this to assembler
000F59r 3                               ; for speed
000F59r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
000F5Cr 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
000F5Fr 3               
000F5Fr 3  B5 00                        lda 0,x
000F61r 3  15 01                        ora 1,x
000F63r 3  F0 06                        beq @do_do
000F65r 3               
000F65r 3                               ; We're equal, so dump everything and jump beyond the loop.
000F65r 3                               ; But first, dump six entries off of the Data Stack
000F65r 3  8A                           txa
000F66r 3  18                           clc
000F67r 3  69 06                        adc #6
000F69r 3  AA                           tax
000F6Ar 3               
000F6Ar 3                               ; Then abort the whole loop
000F6Ar 3  60                           rts
000F6Br 3               @do_do:
000F6Br 3  E8                           inx             ; clear flag from EQUAL off stack
000F6Cr 3  E8                           inx             ; no RTS because this is copied into code
000F6Dr 3               question_do_runtime_end:
000F6Dr 3               
000F6Dr 3               
000F6Dr 3               
000F6Dr 3               ; ## DOES ( -- ) "Add payload when defining new words"
000F6Dr 3               ; ## "does>"  auto  ANS core
000F6Dr 3                       ; """https://forth-standard.org/standard/core/DOES
000F6Dr 3                       ; Create the payload for defining new defining words. See
000F6Dr 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
000F6Dr 3                       ; the Developer Guide in the manual for a discussion of
000F6Dr 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
000F6Dr 3                       ; """
000F6Dr 3               
000F6Dr 3               xt_does:
000F6Dr 3                               ; compile a subroutine jump to runtime of DOES>
000F6Dr 3  A0 rr                        ldy #>does_runtime
000F6Fr 3  A9 rr                        lda #<does_runtime
000F71r 3  20 rr rr                     jsr cmpl_subroutine
000F74r 3               
000F74r 3                               ; compile a subroutine jump to DODOES. In traditional
000F74r 3                               ; terms, this is the Code Field Area (CFA) of the new
000F74r 3                               ; word
000F74r 3  A0 rr                        ldy #>dodoes
000F76r 3  A9 rr                        lda #<dodoes
000F78r 3  20 rr rr                     jsr cmpl_subroutine
000F7Br 3               
000F7Br 3  60           z_does:         rts
000F7Cr 3               
000F7Cr 3               
000F7Cr 3               does_runtime:
000F7Cr 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
000F7Cr 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
000F7Cr 3                       ; address that contains a subroutine jump to DODOES. We don't
000F7Cr 3                       ; jump to DODOES directly because we need to work our magic with
000F7Cr 3                       ; the return addresses. This routine is also known as "(DOES)" in
000F7Cr 3                       ; other Forths
000F7Cr 3                       ; """
000F7Cr 3               
000F7Cr 3  7A                           ply             ; LSB
000F7Dr 3  68                           pla             ; MSB
000F7Er 3               
000F7Er 3  C8                           iny
000F7Fr 3  D0 01                        bne @1
000F81r 3  1A                           inc
000F82r 3               @1:
000F82r 3  84 rr                        sty tmp1
000F84r 3  85 rr                        sta tmp1+1
000F86r 3               
000F86r 3                               ; CREATE has also already modified the DP to point to the new
000F86r 3                               ; word. We have no idea which instructions followed the CREATE
000F86r 3                               ; command if there is a DOES> so the CP could point anywhere
000F86r 3                               ; by now. The address of the word's xt is four bytes down.
000F86r 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
000F89r 3  A5 rr                        lda dp
000F8Br 3  18                           clc
000F8Cr 3  69 04                        adc #4
000F8Er 3  85 rr                        sta tmp2
000F90r 3  A5 rr                        lda dp+1
000F92r 3  69 00                        adc #0          ; we only care about the carry
000F94r 3  85 rr                        sta tmp2+1
000F96r 3               
000F96r 3                               ; Now we get that address and add one byte to skip over the JSR
000F96r 3                               ; opcode
000F96r 3  B2 rr                        lda (tmp2)
000F98r 3  18                           clc
000F99r 3  69 01                        adc #1
000F9Br 3  85 rr                        sta tmp3
000F9Dr 3  A0 01                        ldy #1
000F9Fr 3  B1 rr                        lda (tmp2),y
000FA1r 3  69 00                        adc #0          ; we only care about the carry
000FA3r 3  85 rr                        sta tmp3+1
000FA5r 3               
000FA5r 3                               ; Replace the DOVAR address with our own
000FA5r 3  A5 rr                        lda tmp1        ; LSB
000FA7r 3  92 rr                        sta (tmp3)
000FA9r 3  A5 rr                        lda tmp1+1
000FABr 3  91 rr                        sta (tmp3),y    ; Y is still 1
000FADr 3               
000FADr 3                               ; Since we removed the return address that brought us here, we
000FADr 3                               ; go back to whatever the main routine was. Otherwise, we we
000FADr 3                               ; smash into the subroutine jump to DODOES.
000FADr 3  60                           rts
000FAEr 3               
000FAEr 3               
000FAEr 3               
000FAEr 3               ; ## DOT ( u -- ) "Print TOS"
000FAEr 3               ; ## "."  auto  ANS core
000FAEr 3                       ; """https://forth-standard.org/standard/core/d"""
000FAEr 3               
000FAEr 3               xt_dot:
000FAEr 3  20 rr rr                     jsr underflow_1
000FB1r 3               
000FB1r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
000FB4r 3  20 rr rr                     jsr xt_abs                      ; ( n u )
000FB7r 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
000FBAr 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
000FBDr 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
000FC0r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
000FC3r 3  20 rr rr                     jsr xt_sign                     ; ( ud )
000FC6r 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
000FC9r 3  20 rr rr                     jsr xt_type
000FCCr 3  20 rr rr                     jsr xt_space
000FCFr 3               
000FCFr 3  60           z_dot:          rts
000FD0r 3               
000FD0r 3               
000FD0r 3               
000FD0r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
000FD0r 3               ; ## ".("  auto  ANS core
000FD0r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
000FD0r 3               
000FD0r 3               xt_dot_paren:
000FD0r 3                               ; Put a right paren on the stack.
000FD0r 3  CA                           dex
000FD1r 3  CA                           dex
000FD2r 3  A9 29                        lda #41     ; Right parenthesis
000FD4r 3  95 00                        sta 0,x
000FD6r 3  74 01                        stz 1,x
000FD8r 3               
000FD8r 3  20 rr rr                     jsr xt_parse
000FDBr 3  20 rr rr                     jsr xt_type
000FDEr 3               
000FDEr 3  60           z_dot_paren:    rts
000FDFr 3               
000FDFr 3               
000FDFr 3               
000FDFr 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
000FDFr 3               ; ## ".""  auto  ANS core ext
000FDFr 3                       ; """https://forth-standard.org/standard/core/Dotq
000FDFr 3                       ; Compile string that is printed during run time. ANS Forth wants
000FDFr 3                       ; this to be compile-only, even though everybody and their friend
000FDFr 3                       ; uses it for everything. We follow the book here, and recommend
000FDFr 3                       ; `.(` for general printing.
000FDFr 3                       ; """
000FDFr 3               
000FDFr 3               xt_dot_quote:
000FDFr 3                               ; we let S" do the heavy lifting. Since we're in
000FDFr 3                               ; compile mode, it will save the string and reproduce it
000FDFr 3                               ; during runtime
000FDFr 3  20 rr rr                     jsr xt_s_quote
000FE2r 3               
000FE2r 3                               ; We then let TYPE do the actual printing
000FE2r 3  A0 rr                        ldy #>xt_type
000FE4r 3  A9 rr                        lda #<xt_type
000FE6r 3  20 rr rr                     jsr cmpl_subroutine
000FE9r 3               
000FE9r 3  60           z_dot_quote:    rts
000FEAr 3               
000FEAr 3               
000FEAr 3               
000FEAr 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
000FEAr 3               ; ## ".r"  tested  ANS core ext
000FEAr 3                       ; """https://forth-standard.org/standard/core/DotR
000FEAr 3                       ;
000FEAr 3                       ; Based on the Forth code
000FEAr 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
000FEAr 3                       ; """
000FEAr 3               
000FEAr 3               xt_dot_r:
000FEAr 3  20 rr rr                     jsr underflow_2
000FEDr 3               
000FEDr 3  20 rr rr                     jsr xt_to_r
000FF0r 3  20 rr rr                     jsr xt_dup
000FF3r 3  20 rr rr                     jsr xt_abs
000FF6r 3  20 rr rr                     jsr xt_zero
000FF9r 3  20 rr rr                     jsr xt_less_number_sign
000FFCr 3  20 rr rr                     jsr xt_number_sign_s
000FFFr 3  20 rr rr                     jsr xt_rot
001002r 3  20 rr rr                     jsr xt_sign
001005r 3  20 rr rr                     jsr xt_number_sign_greater
001008r 3  20 rr rr                     jsr xt_r_from
00100Br 3  20 rr rr                     jsr xt_over
00100Er 3  20 rr rr                     jsr xt_minus
001011r 3  20 rr rr                     jsr xt_spaces
001014r 3  20 rr rr                     jsr xt_type
001017r 3               
001017r 3  60           z_dot_r:        rts
001018r 3               
001018r 3               
001018r 3               
001018r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
001018r 3               ; ## ".s"  tested  ANS tools
001018r 3                       ; """https://forth-standard.org/standard/tools/DotS
001018r 3                       ; Print content of Data Stack non-distructively. We follow the format
001018r 3                       ; of Gforth and print the number of elements first in brackets,
001018r 3                       ; followed by the Data Stack content (if any).
001018r 3                       ;
001018r 3                       ; Since this is for humans, we don't have to worry about speed.
001018r 3                       ; """
001018r 3               
001018r 3               xt_dot_s:
001018r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
00101Br 3               
00101Br 3                               ; Print stack depth in brackets
00101Br 3  A9 3C                        lda #$3c        ; ASCII for "<"
00101Dr 3  20 rr rr                     jsr emit_a
001020r 3               
001020r 3                               ; We keep a copy of the number of the things on the stack
001020r 3                               ; to use as a counter later down. This assumes that there
001020r 3                               ; are less than 255 elements on the stack
001020r 3  B5 00                        lda 0,x
001022r 3  48                           pha
001023r 3               
001023r 3                               ; print unsigned number without the trailing space
001023r 3  CA                           dex             ; DUP
001024r 3  CA                           dex
001025r 3  95 00                        sta 0,x
001027r 3  74 01                        stz 1,x
001029r 3               
001029r 3  20 rr rr                     jsr print_u
00102Cr 3               
00102Cr 3  A9 3E                        lda #$3e        ; ASCII for ">"
00102Er 3  20 rr rr                     jsr emit_a
001031r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
001033r 3  20 rr rr                     jsr emit_a
001036r 3               
001036r 3  E8                           inx
001037r 3  E8                           inx
001038r 3               
001038r 3                               ; There will be lots of cases where the stack is empty. If that
001038r 3                               ; is so, get out of here quickly
001038r 3  E0 rr                        cpx #dsp0
00103Ar 3  F0 1E                        beq @done
00103Cr 3               
00103Cr 3               @have_stack:
00103Cr 3                               ; We have at least one element on the stack. The depth of the
00103Cr 3                               ; stack is on the stack, we can use it as a counter. We go
00103Cr 3                               ; from bottom to top
00103Cr 3  7A                           ply
00103Dr 3               
00103Dr 3  A9 rr                        lda #dsp0-1     ; go up one to avoid garbage
00103Fr 3  85 rr                        sta tmp3
001041r 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
001043r 3               @loop:
001043r 3  CA                           dex
001044r 3  CA                           dex
001045r 3               
001045r 3  B2 rr                        lda (tmp3)
001047r 3  95 01                        sta 1,x
001049r 3  C6 rr                        dec tmp3
00104Br 3               
00104Br 3  B2 rr                        lda (tmp3)
00104Dr 3  95 00                        sta 0,x
00104Fr 3  C6 rr                        dec tmp3
001051r 3  5A                           phy
001052r 3               
001052r 3  20 rr rr                     jsr xt_dot
001055r 3               
001055r 3  7A                           ply
001056r 3  88                           dey
001057r 3  D0 EA                        bne @loop
001059r 3               
001059r 3  48                           pha             ; dummy to balance stack
00105Ar 3               @done:
00105Ar 3  68                           pla
00105Br 3  60           z_dot_s:        rts
00105Cr 3               
00105Cr 3               
00105Cr 3               
00105Cr 3               ; ## D_DOT ( d -- ) "Print double"
00105Cr 3               ; ## "d."  tested  ANS double
00105Cr 3                       ; """http://forth-standard.org/standard/double/Dd"""
00105Cr 3                       ;
00105Cr 3                       ; From the Forth code:
00105Cr 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
00105Cr 3                       ; """
00105Cr 3               
00105Cr 3               xt_d_dot:
00105Cr 3  20 rr rr                     jsr underflow_2
00105Fr 3               
00105Fr 3  20 rr rr                     jsr xt_tuck
001062r 3  20 rr rr                     jsr xt_dabs
001065r 3  20 rr rr                     jsr xt_less_number_sign
001068r 3  20 rr rr                     jsr xt_number_sign_s
00106Br 3  20 rr rr                     jsr xt_rot
00106Er 3  20 rr rr                     jsr xt_sign
001071r 3  20 rr rr                     jsr xt_number_sign_greater
001074r 3  20 rr rr                     jsr xt_type
001077r 3  20 rr rr                     jsr xt_space
00107Ar 3               
00107Ar 3  60           z_d_dot:        rts
00107Br 3               
00107Br 3               
00107Br 3               
00107Br 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
00107Br 3               ; ## "d.r"  tested  ANS double
00107Br 3                       ; """http://forth-standard.org/standard/double/DDotR"""
00107Br 3                       ; Based on the Forth code
00107Br 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
00107Br 3                       ; """
00107Br 3               
00107Br 3               xt_d_dot_r:
00107Br 3  20 rr rr                     jsr underflow_3
00107Er 3                               ; From the forth code:
00107Er 3  20 rr rr                     jsr xt_to_r
001081r 3  20 rr rr                     jsr xt_tuck
001084r 3  20 rr rr                     jsr xt_dabs
001087r 3  20 rr rr                     jsr xt_less_number_sign
00108Ar 3  20 rr rr                     jsr xt_number_sign_s
00108Dr 3  20 rr rr                     jsr xt_rot
001090r 3  20 rr rr                     jsr xt_sign
001093r 3  20 rr rr                     jsr xt_number_sign_greater
001096r 3  20 rr rr                     jsr xt_r_from
001099r 3  20 rr rr                     jsr xt_over
00109Cr 3  20 rr rr                     jsr xt_minus
00109Fr 3  20 rr rr                     jsr xt_spaces
0010A2r 3  20 rr rr                     jsr xt_type
0010A5r 3               
0010A5r 3  60           z_d_dot_r:      rts
0010A6r 3               
0010A6r 3               
0010A6r 3               
0010A6r 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
0010A6r 3               ; ## "drop"  auto  ANS core
0010A6r 3                       ; """https://forth-standard.org/standard/core/DROP"""
0010A6r 3               xt_drop:
0010A6r 3  20 rr rr                     jsr underflow_1
0010A9r 3               
0010A9r 3  E8                           inx
0010AAr 3  E8                           inx
0010ABr 3               
0010ABr 3  60           z_drop:         rts
0010ACr 3               
0010ACr 3               
0010ACr 3               ; ## DUMP ( addr u -- ) "Display a memory region"
0010ACr 3               ; ## "dump"  tested  ANS tools
0010ACr 3                       ; """https://forth-standard.org/standard/tools/DUMP
0010ACr 3                       ;
0010ACr 3                       ; DUMP's exact output is defined as "implementation dependent".
0010ACr 3                       ; This is in assembler because it is
0010ACr 3                       ; useful for testing and development, so we want to have it work
0010ACr 3                       ; as soon as possible. Uses TMP2
0010ACr 3                       ; """
0010ACr 3               
0010ACr 3               xt_dump:
0010ACr 3  20 rr rr                     jsr underflow_2
0010AFr 3               @row:
0010AFr 3                               ; start counter for 16 numbers per row
0010AFr 3  A0 10                        ldy #16
0010B1r 3               
0010B1r 3                               ; We use TMP2 as the index for the ASCII characters
0010B1r 3                               ; that we print at the and of the hex block. We
0010B1r 3                               ; start saving them at HERE (CP)
0010B1r 3  64 rr                        stz tmp2
0010B3r 3               
0010B3r 3  20 rr rr                     jsr xt_cr
0010B6r 3               
0010B6r 3                               ; print address number
0010B6r 3  B5 03                        lda 3,x
0010B8r 3  20 rr rr                     jsr byte_to_ascii
0010BBr 3  B5 02                        lda 2,x
0010BDr 3  20 rr rr                     jsr byte_to_ascii
0010C0r 3               
0010C0r 3  20 rr rr                     jsr xt_space
0010C3r 3  20 rr rr                     jsr xt_space
0010C6r 3               @loop:
0010C6r 3                               ; if there are zero bytes left to display, we're done
0010C6r 3  B5 00                        lda 0,x
0010C8r 3  15 01                        ora 1,x
0010CAr 3  F0 39                        beq @all_printed
0010CCr 3               
0010CCr 3                               ; dump the contents
0010CCr 3  A1 02                        lda (2,x)
0010CEr 3  48                           pha                     ; byte_to_ascii destroys A
0010CFr 3  20 rr rr                     jsr byte_to_ascii
0010D2r 3  20 rr rr                     jsr xt_space
0010D5r 3  68                           pla
0010D6r 3               
0010D6r 3                               ; Handle ASCII printing
0010D6r 3  20 rr rr                     jsr is_printable
0010D9r 3  B0 02                        bcs @printable
0010DBr 3  A9 2E                        lda #'.'                 ; Print dot if not printable
0010DDr 3               @printable:
0010DDr 3  5A                           phy                     ; save counter
0010DEr 3  A4 rr                        ldy tmp2
0010E0r 3  91 rr                        sta (cp),y
0010E2r 3  E6 rr                        inc tmp2
0010E4r 3  7A                           ply
0010E5r 3               
0010E5r 3                               ; extra space after eight bytes
0010E5r 3  C0 09                        cpy #9
0010E7r 3  D0 03                        bne @next_char
0010E9r 3  20 rr rr                     jsr xt_space
0010ECr 3               
0010ECr 3               @next_char:
0010ECr 3  F6 02                        inc 2,x
0010EEr 3  D0 02                        bne @counter
0010F0r 3  F6 03                        inc 3,x
0010F2r 3               
0010F2r 3               @counter:
0010F2r 3                               ; loop counter
0010F2r 3  B5 00                        lda 0,x
0010F4r 3  D0 02                        bne @1
0010F6r 3  D6 01                        dec 1,x
0010F8r 3               @1:
0010F8r 3  D6 00                        dec 0,x
0010FAr 3  88                           dey
0010FBr 3  D0 C9                        bne @loop               ; next byte
0010FDr 3               
0010FDr 3                               ; Done with one line, print the ASCII version of these
0010FDr 3                               ; characters
0010FDr 3  20 rr rr                     jsr xt_space
001100r 3  20 rr rr                     jsr print_ascii
001103r 3               
001103r 3  80 AA                        bra @row                ; new row
001105r 3               
001105r 3               @all_printed:
001105r 3                               ; See if there are any ASCII characters in the buffer
001105r 3                               ; left to print
001105r 3  A5 rr                        lda tmp2
001107r 3  F0 06                        beq @done
001109r 3               
001109r 3                               ; In theory, we could try to make the ASCII part line
001109r 3                               ; up with the line before it. But that is a hassle (we
001109r 3                               ; use three bytes for each missed hex entry, and
001109r 3                               ; then there is the gap after eight entries) and it
001109r 3                               ; makes it harder to read. We settle for one extra
001109r 3                               ; space instead for the moment
001109r 3  20 rr rr                     jsr xt_space
00110Cr 3  20 rr rr                     jsr print_ascii
00110Fr 3               @done:
00110Fr 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
001112r 3  60           z_dump:         rts
001113r 3               
001113r 3               
001113r 3               print_ascii:
001113r 3                               ; Print the ASCII characters that we have saved from
001113r 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
001113r 3                               ; is not compiled (DUMP is probably never compiled anyway)
001113r 3                               ; but we keep it inside the scope of DUMP.
001113r 3  A0 00                        ldy #0
001115r 3               @ascii_loop:
001115r 3  B1 rr                        lda (cp),y
001117r 3  20 rr rr                     jsr emit_a
00111Ar 3  C8                           iny
00111Br 3               
00111Br 3                               ; extra space after eight chars
00111Br 3  C0 08                        cpy #8
00111Dr 3  D0 03                        bne @1
00111Fr 3  20 rr rr                     jsr xt_space
001122r 3               @1:
001122r 3  C6 rr                        dec tmp2
001124r 3  D0 EF                        bne @ascii_loop
001126r 3               
001126r 3  60                           rts
001127r 3               
001127r 3               
001127r 3               
001127r 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
001127r 3               ; ## "dup"  auto  ANS core
001127r 3                       ; """https://forth-standard.org/standard/core/DUP"""
001127r 3               xt_dup:
001127r 3  20 rr rr                     jsr underflow_1
00112Ar 3               
00112Ar 3  CA                           dex
00112Br 3  CA                           dex
00112Cr 3               
00112Cr 3  B5 02                        lda 2,x         ; LSB
00112Er 3  95 00                        sta 0,x
001130r 3  B5 03                        lda 3,x         ; MSB
001132r 3  95 01                        sta 1,x
001134r 3               
001134r 3  60           z_dup:          rts
001135r 3               
001135r 3               
001135r 3               ; ## ED ( -- u ) "Line-based editor"
001135r 3               ; ## "ed"  fragment  Tali Forth
001135r 3                       ; """Start the line-based editor ed6502. See separate file
001135r 3                       ; ed.asm or the manual for details.
001135r 3                       ; """
001135r 3               xt_ed:
001135r 3               
001135r 3  20 rr rr                     jsr ed6502      ; kept in separate file
001138r 3               
001138r 3               
001138r 3  60           z_ed:           rts
001139r 3               
001139r 3               
001139r 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
001139r 3               ; ## "editor-wordlist"  tested  Tali Editor
001139r 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
001139r 3                       ; words to the search order so they can be used.  This will need
001139r 3                       ; to be done before any of the words marked "Tali Editor" can be
001139r 3                       ; used.  See the tutorial on Wordlists and the Search Order for
001139r 3                       ; more information.
001139r 3               
001139r 3                       ;
001139r 3                       ; This is a dummy entry, the code is shared with ONE
001139r 3                       ; """
001139r 3               
001139r 3               
001139r 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
001139r 3               ; ## "else"  auto  ANS core
001139r 3                       ; """http://forth-standard.org/standard/core/ELSE
001139r 3                       ;
001139r 3                       ; The code is shared with ENDOF
001139r 3                       ; """
001139r 3               
001139r 3               xt_else:
001139r 3               xt_endof:
001139r 3                               ; Put an unconditional branch.
001139r 3  A0 rr                        ldy #>branch_runtime
00113Br 3  A9 rr                        lda #<branch_runtime
00113Dr 3  20 rr rr                     jsr cmpl_subroutine
001140r 3               
001140r 3                               ; Put the address of the branch address on the stack.
001140r 3  20 rr rr                     jsr xt_here
001143r 3               
001143r 3                               ; Use zero for the branch address for now.
001143r 3                               ; THEN will fill it in later.
001143r 3  20 rr rr                     jsr xt_zero
001146r 3  20 rr rr                     jsr xt_comma
001149r 3               
001149r 3                               ; Get the address to jump to (just after the
001149r 3                               ; unconditional branch) for the IF to jump to
001149r 3                               ; when false.
001149r 3  20 rr rr                     jsr xt_here
00114Cr 3  20 rr rr                     jsr xt_rot
00114Fr 3               
00114Fr 3                               ; Update the original if 0branch address.
00114Fr 3  20 rr rr                     jsr xt_store
001152r 3               z_else:
001152r 3               z_endof:
001152r 3  60                           rts
001153r 3               
001153r 3               
001153r 3               
001153r 3               branch_runtime:
001153r 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
001153r 3                       ; formally part of a separate word BRANCH which was later removed.
001153r 3                       ; """
001153r 3               
001153r 3                               ; The address on the Return Stack points to the last byte
001153r 3                               ; of the JSR address, one byte below the branch literal
001153r 3  68                           pla
001154r 3  85 rr                        sta tmpbranch
001156r 3  68                           pla
001157r 3  85 rr                        sta tmpbranch+1
001159r 3               
001159r 3                               ; Keep in mind: the address we just popped points one byte
001159r 3                               ; lower than the branch literal we want to grab
001159r 3  A0 01                        ldy #1
00115Br 3  B1 rr                        lda (tmpbranch),y  ; LSB
00115Dr 3  85 rr                        sta tmp1
00115Fr 3  C8                           iny
001160r 3  B1 rr                        lda (tmpbranch),y  ; MSB
001162r 3  85 rr                        sta tmp1+1
001164r 3               
001164r 3  6C rr rr                     jmp (tmp1)
001167r 3               
001167r 3               
001167r 3               
001167r 3               ; ## EMIT ( char -- ) "Print character to current output"
001167r 3               ; ## "emit"  auto  ANS core
001167r 3                       ; """https://forth-standard.org/standard/core/EMIT
001167r 3                       ; Run-time default for EMIT. The user can revector this by changing
001167r 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
001167r 3                       ; do not check to see if we have been given a valid ASCII character.
001167r 3                       ; Don't make this native compile.
001167r 3                       ; """
001167r 3               
001167r 3               xt_emit:
001167r 3  20 rr rr                     jsr underflow_1
00116Ar 3               
00116Ar 3  B5 00                        lda 0,x
00116Cr 3  E8                           inx
00116Dr 3  E8                           inx
00116Er 3               
00116Er 3               emit_a:
00116Er 3                       ; We frequently want to print the character in A without fooling
00116Er 3                       ; around with the Data Stack. This is emit_a's job, which still
00116Er 3                       ; allows the output to be vectored. Call it with JSR as you
00116Er 3                       ; would XT_EMIT
00116Er 3  6C rr rr                     jmp (output)            ; JSR/RTS
001171r 3               
001171r 3               z_emit:         ; never reached
001171r 3               
001171r 3               
001171r 3               
001171r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
001171r 3               ; ## "empty-buffers"  tested  ANS block ext
001171r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
001171r 3               xt_empty_buffers:
001171r 3                               ; Set the buffer status to empty.
001171r 3  A0 2C                        ldy #buffstatus_offset
001173r 3  A9 00                        lda #0
001175r 3  91 rr                        sta (up),y      ; Only LSB is used.
001177r 3               z_empty_buffers:
001177r 3  60                           rts
001178r 3               
001178r 3               
001178r 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
001178r 3               ; ## "endcase"  auto  ANS core ext
001178r 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
001178r 3               
001178r 3               xt_endcase:
001178r 3                               ; Postpone DROP to remove the item
001178r 3                               ; being checked.
001178r 3  A0 rr                        ldy #>xt_drop
00117Ar 3  A9 rr                        lda #<xt_drop
00117Cr 3  20 rr rr                     jsr cmpl_subroutine
00117Fr 3               
00117Fr 3                               ; There are a number of address (of branches that need their
00117Fr 3                               ; jump addressed filled in with the address of right here).
00117Fr 3                               ; Keep calling THEN to deal with them until we reach the
00117Fr 3                               ; 0 that CASE put on the stack at the beginning.
00117Fr 3               @endcase_loop:
00117Fr 3                               ; Check for 0 on the stack.
00117Fr 3  B5 00                        lda 0,x
001181r 3  15 01                        ora 1,x
001183r 3  F0 05                        beq @done
001185r 3               
001185r 3  20 rr rr                     jsr xt_then
001188r 3  80 F5                        bra @endcase_loop
00118Ar 3               @done:
00118Ar 3                               ; Remove the 0 from the stack.
00118Ar 3  E8                           inx
00118Br 3  E8                           inx
00118Cr 3  60           z_endcase:      rts
00118Dr 3               
00118Dr 3               
00118Dr 3               
00118Dr 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
00118Dr 3               ; ## "endof"  auto  ANS core ext
00118Dr 3                       ; """http://forth-standard.org/standard/core/ENDOF
00118Dr 3                       ; This is a dummy entry, the code is shared with ELSE
00118Dr 3                       ; """
00118Dr 3               
00118Dr 3               
00118Dr 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
00118Dr 3               ; ## "environment?"  auto  ANS core
00118Dr 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
00118Dr 3                       ;
00118Dr 3                       ; By ANS definition, we use upper-case strings here, see the
00118Dr 3                       ; string file for details. This can be realized as a high-level
00118Dr 3                       ; Forth word as
00118Dr 3                       ;
00118Dr 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
00118Dr 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
00118Dr 3                       ; HEX
00118Dr 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
00118Dr 3                       ; CASE
00118Dr 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
00118Dr 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
00118Dr 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
00118Dr 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
00118Dr 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
00118Dr 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
00118Dr 3                       ; S" MAX-D"              STRING_OF
00118Dr 3                                                    ; 7FFFFFFF. TRUE ENDOF
00118Dr 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
00118Dr 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
00118Dr 3                       ; S" MAX-UD"             STRING_OF
00118Dr 3                                                    ; FFFFFFFF. TRUE ENDOF
00118Dr 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
00118Dr 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
00118Dr 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
00118Dr 3                       ; ENDCASE ;
00118Dr 3                       ;
00118Dr 3                       ; but that uses lots of memory and increases the start up time. This
00118Dr 3                       ; word is rarely used so we can try to keep it short at the expense
00118Dr 3                       ; of speed.
00118Dr 3                       ; """
00118Dr 3               
00118Dr 3               xt_environment_q:
00118Dr 3  20 rr rr                     jsr underflow_1
001190r 3               
001190r 3                               ; This code is table-driven: We walk through the list of
001190r 3                               ; strings until we find one that matches, and then we take
001190r 3                               ; the equivalent data from the results table. This is made
001190r 3                               ; a bit harder by the fact that some of these return a
001190r 3                               ; double-cell number and some a single-cell one.
001190r 3               
001190r 3                               ; We will walk through the table with variables that return
001190r 3                               ; a single-cell result
001190r 3  A0 00                        ldy #00                 ; counter for table
001192r 3               
001192r 3                               ; We use a flag on the the stack to signal if we have a single-cell
001192r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
001192r 3                               ; double-cell.
001192r 3  5A                           phy
001193r 3               @table_loop:
001193r 3                               ; We arrived here with the address of the string to be checked
001193r 3                               ; on the stack. We make a copy. Index is in Y
001193r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
001196r 3               
001196r 3                               ; We do our work on the TOS to speed things up
001196r 3  CA                           dex
001197r 3  CA                           dex                     ; ( addr u addr u ? )
001198r 3               
001198r 3                               ; Get address of string to check from table
001198r 3  B9 rr rr                     lda env_table_single,y
00119Br 3  95 00                        sta 0,x
00119Dr 3  C8                           iny
00119Er 3  B9 rr rr                     lda env_table_single,y
0011A1r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
0011A3r 3  C8                           iny
0011A4r 3               
0011A4r 3                               ; See if this is the last entry. The LSB is still in A
0011A4r 3  15 00                        ora 0,x
0011A6r 3  F0 4D                        beq @table_done
0011A8r 3               
0011A8r 3                               ; We have a string entry. The address there is stored in
0011A8r 3                               ; old-style address format, that is, the first byte is the
0011A8r 3                               ; length of the string
0011A8r 3  5A                           phy                     ; save Y, which is used by COUNT
0011A9r 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
0011ACr 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
0011AFr 3  7A                           ply
0011B0r 3               
0011B0r 3                               ; If we found a match (flag is zero -- COMPARE is weird
0011B0r 3                               ; that way), return the result
0011B0r 3  B5 00                        lda 0,x
0011B2r 3  15 01                        ora 1,x
0011B4r 3  F0 04                        beq @got_result
0011B6r 3               
0011B6r 3                               ; Flag is not zero, so not a perfect match, so try next
0011B6r 3                               ; word
0011B6r 3  E8                           inx                     ; DROP, now ( addr u )
0011B7r 3  E8                           inx
0011B8r 3               
0011B8r 3  80 D9                        bra @table_loop
0011BAr 3               
0011BAr 3               @got_result:
0011BAr 3                               ; We arrive here with ( addr u -1 ) and know that we've found
0011BAr 3                               ; a match. The index of the match+2 is in Y.
0011BAr 3  E8                           inx                     ; drop flag, now ( addr u )
0011BBr 3  E8                           inx
0011BCr 3  88                           dey                     ; go back to index we had
0011BDr 3  88                           dey
0011BEr 3               
0011BEr 3                               ; See if this is a single-cell word.
0011BEr 3  68                           pla
0011BFr 3  D0 0D                        bne @double_result
0011C1r 3               
0011C1r 3                               ; Single-cell result
0011C1r 3  B9 rr rr                     lda env_results_single,y
0011C4r 3  95 02                        sta 2,x
0011C6r 3  C8                           iny
0011C7r 3  B9 rr rr                     lda env_results_single,y
0011CAr 3  95 03                        sta 3,x                 ; ( res u )
0011CCr 3               
0011CCr 3  80 1F                        bra @set_flag
0011CEr 3               
0011CEr 3               @double_result:
0011CEr 3                               ; This is a double-celled result, which means we have to
0011CEr 3                               ; fool around with the index some more. We also need a
0011CEr 3                               ; further cell on the stack
0011CEr 3  CA                           dex                     ; ( addr u ? )
0011CFr 3  CA                           dex
0011D0r 3               
0011D0r 3                               ; We have 11 single-cell words we check, plus the 0000 as
0011D0r 3                               ; a marker for the end of the table, so we arrive here
0011D0r 3                               ; with Y as 22 or more. To get the index for the double-
0011D0r 3                               ; cell words, we move the result
0011D0r 3  98                           tya
0011D1r 3  38                           sec
0011D2r 3  E9 18                        sbc #24
0011D4r 3               
0011D4r 3                               ; We have four bytes per entry in the table, but the index
0011D4r 3                               ; keeps increasing by two, so we only have to multiply by
0011D4r 3                               ; two (shift left once) to get the right result
0011D4r 3  0A                           asl
0011D5r 3  A8                           tay
0011D6r 3               
0011D6r 3  B9 rr rr                     lda env_results_double,y
0011D9r 3  95 02                        sta 2,x
0011DBr 3  C8                           iny
0011DCr 3  B9 rr rr                     lda env_results_double,y
0011DFr 3  95 03                        sta 3,x                 ; ( res u ? )
0011E1r 3  C8                           iny
0011E2r 3               
0011E2r 3  B9 rr rr                     lda env_results_double,y
0011E5r 3  95 04                        sta 4,x
0011E7r 3  C8                           iny
0011E8r 3  B9 rr rr                     lda env_results_double,y
0011EBr 3  95 05                        sta 5,x                 ; ( res res ? )
0011EDr 3               
0011EDr 3                               ; fall through to @set_flag
0011EDr 3               @set_flag:
0011EDr 3  A9 FF                        lda #$ff
0011EFr 3  95 00                        sta 0,x
0011F1r 3  95 01                        sta 1,x                 ; ( res f )
0011F3r 3               
0011F3r 3  80 14                        bra @done
0011F5r 3               @table_done:
0011F5r 3                               ; We're done with a table, because the entry was a zero.
0011F5r 3                               ; We arrive here with ( addr u addr u 0 )
0011F5r 3               
0011F5r 3                               ; We take the flag from stack and increase it by one. If the
0011F5r 3                               ; flag is zero, we have just completed the single-cell number
0011F5r 3                               ; strings, so we in increase the flag and try again. Otherwise,
0011F5r 3                               ; we're done with the double-cell table without having found
0011F5r 3                               ; a match, and we're done
0011F5r 3  68                           pla
0011F6r 3  D0 09                        bne @no_match
0011F8r 3               
0011F8r 3                               ; Flag is zero, increase it to one and start over to check
0011F8r 3                               ; double-cell values
0011F8r 3  1A                           inc
0011F9r 3  48                           pha
0011FAr 3               
0011FAr 3  8A                           txa
0011FBr 3  18                           clc
0011FCr 3  69 06                        adc #6                  ; skip six bytes
0011FEr 3  AA                           tax                     ; ( addr u )
0011FFr 3               
0011FFr 3  80 92                        bra @table_loop
001201r 3               @no_match:
001201r 3                               ; Bummer, not found. We arrive here with
001201r 3                               ; ( addr u addr u 0 ) and need to return just a zero
001201r 3  8A                           txa
001202r 3  18                           clc
001203r 3  69 0A                        adc #10
001205r 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
001206r 3               
001206r 3  20 rr rr                     jsr xt_false
001209r 3               @done:
001209r 3               z_environment_q:
001209r 3  60                           rts
00120Ar 3               
00120Ar 3               
00120Ar 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
00120Ar 3               ; results and one for the double-celled results. The zero cell at the
00120Ar 3               ; end of each table marks its, uh, end. The strings themselves are defined
00120Ar 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
00120Ar 3               ; have to adapt the result code for double printout, where we subtract 22
00120Ar 3               ; (two bytes each single-cell string and two bytes for the end-of-table
00120Ar 3               ; marker 0000
00120Ar 3               env_table_single:
00120Ar 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
00120Er 3  rr rr rr rr  
001212r 3  rr rr        
001214r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
001218r 3  rr rr rr rr  
00121Cr 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
001220r 3  00 00        
001222r 3               
001222r 3               env_table_double:
001222r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
001226r 3  00 00        
001228r 3               
001228r 3               env_results_single:
001228r 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
00122Ar 3  FF 00                .word $00FF     ; /HOLD
00122Cr 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
00122Er 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
001230r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
001232r 3  FF 00                .word $00FF     ; MAX-CHAR
001234r 3  FF 7F                .word $7FFF     ; MAX-N
001236r 3  FF FF                .word $FFFF     ; MAX-U
001238r 3  80 00                .word $0080     ; RETURN-STACK-CELLS
00123Ar 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
00123Cr 3  09 00                .word $0009     ; WORDLISTS
00123Er 3               
00123Er 3               env_results_double:
00123Er 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
001242r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
001246r 3               
001246r 3               
001246r 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
001246r 3               ; ## "="  auto  ANS core
001246r 3                       ; """https://forth-standard.org/standard/core/Equal"""
001246r 3               
001246r 3               xt_equal:
001246r 3  20 rr rr                     jsr underflow_2
001249r 3               
001249r 3  B5 00                        lda 0,x                 ; LSB
00124Br 3  D5 02                        cmp 2,x
00124Dr 3  D0 0A                        bne @false
00124Fr 3               
00124Fr 3  B5 01                        lda 1,x                 ; MSB
001251r 3  D5 03                        cmp 3,x
001253r 3  D0 04                        bne @false
001255r 3               
001255r 3  A9 FF                        lda #$ff
001257r 3  80 02                        bra @done
001259r 3               
001259r 3  A9 00        @false:         lda #0                  ; drop thru to done
00125Br 3               
00125Br 3  95 02        @done:          sta 2,x
00125Dr 3  95 03                        sta 3,x
00125Fr 3               
00125Fr 3  E8                           inx
001260r 3  E8                           inx
001261r 3               
001261r 3  60           z_equal:        rts
001262r 3               
001262r 3               
001262r 3               
001262r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
001262r 3               ; ## "blank"  auto  ANS string
001262r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
001262r 3               xt_blank:
001262r 3                               ; We don't check for underflow here because
001262r 3                               ; we deal with that in FILL
001262r 3  CA                           dex
001263r 3  CA                           dex
001264r 3  A9 20                        lda #AscSP
001266r 3  95 00                        sta 0,x
001268r 3  74 01                        stz 1,x
00126Ar 3               
00126Ar 3  80 06                        bra xt_fill     ; skip over code for ERASE
00126Cr 3               
00126Cr 3               
00126Cr 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
00126Cr 3               ; ## "erase"  auto  ANS core ext
00126Cr 3                       ; """https://forth-standard.org/standard/core/ERASE
00126Cr 3                       ; Note that ERASE works with "address" units
00126Cr 3                       ; (bytes), not cells.
00126Cr 3                       ; """
00126Cr 3               
00126Cr 3               xt_erase:
00126Cr 3                               ; We don't check for underflow here because
00126Cr 3                               ; we deal with that in FILL
00126Cr 3  CA                           dex
00126Dr 3  CA                           dex
00126Er 3  74 00                        stz 0,x
001270r 3  74 01                        stz 1,x
001272r 3               
001272r 3                               ; fall through to FILL
001272r 3               
001272r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
001272r 3               ; ## "fill"  auto  ANS core
001272r 3                       ; """https://forth-standard.org/standard/core/FILL
001272r 3                       ; Fill u bytes of memory with char starting at addr. Note that
001272r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
001272r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
001272r 3                       ; happens when we reach the end of the address space
001272r 3                       ; """
001272r 3               xt_fill:
001272r 3  20 rr rr                     jsr underflow_3
001275r 3               
001275r 3                               ; We use tmp1 to hold the address
001275r 3  B5 04                        lda 4,x         ; LSB
001277r 3  85 rr                        sta tmp1
001279r 3  B5 05                        lda 5,x
00127Br 3  85 rr                        sta tmp1+1
00127Dr 3               
00127Dr 3                               ; We use tmp2 to hold the counter
00127Dr 3  B5 02                        lda 2,x
00127Fr 3  85 rr                        sta tmp2
001281r 3  B5 03                        lda 3,x
001283r 3  85 rr                        sta tmp2+1
001285r 3               
001285r 3                               ; We use Y to hold the character
001285r 3  B5 00                        lda 0,x
001287r 3  A8                           tay
001288r 3               @loop:
001288r 3                               ; Unfortunately, we also need to make sure that we don't
001288r 3                               ; write further than the end of the RAM. So RAM_END must
001288r 3                               ; be larger or equal to the current address
001288r 3  A9 80                        lda #>ram_end           ; MSB
00128Ar 3  C5 rr                        cmp tmp1+1
00128Cr 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
00128Er 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
001290r 3               
001290r 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
001292r 3  C5 rr                        cmp tmp1
001294r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
001296r 3               
001296r 3               @check_counter:
001296r 3                               ; See if our counter has reached zero
001296r 3  A5 rr                        lda tmp2
001298r 3  05 rr                        ora tmp2+1
00129Ar 3  F0 13                        beq @done
00129Cr 3               
00129Cr 3                               ; We're not in ROM and we still have stuff on the counter, so
00129Cr 3                               ; let's actually do what we came here to do
00129Cr 3  98                           tya
00129Dr 3  92 rr                        sta (tmp1)
00129Fr 3               
00129Fr 3                               ; Adjust the counter
00129Fr 3  A5 rr                        lda tmp2
0012A1r 3  D0 02                        bne @1
0012A3r 3  C6 rr                        dec tmp2+1
0012A5r 3  C6 rr        @1:               dec tmp2
0012A7r 3               
0012A7r 3                               ; Next address
0012A7r 3  E6 rr                        inc tmp1
0012A9r 3  D0 DD                        bne @loop
0012ABr 3  E6 rr                        inc tmp1+1
0012ADr 3               
0012ADr 3  80 D9                        bra @loop
0012AFr 3               
0012AFr 3               @done:
0012AFr 3                               ; Drop three cells off the Data Stack. This uses one byte
0012AFr 3                               ; less than six times INX
0012AFr 3  8A                           txa
0012B0r 3  18                           clc
0012B1r 3  69 06                        adc #6
0012B3r 3  AA                           tax
0012B4r 3               z_blank:
0012B4r 3               z_erase:
0012B4r 3  60           z_fill:         rts
0012B5r 3               
0012B5r 3               
0012B5r 3               
0012B5r 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
0012B5r 3               ; ## "execute"  auto  ANS core
0012B5r 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
0012B5r 3               xt_execute:
0012B5r 3  20 rr rr                     jsr underflow_1
0012B8r 3               
0012B8r 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
0012BBr 3               
0012BBr 3  60           z_execute:      rts
0012BCr 3               
0012BCr 3               doexecute:
0012BCr 3  B5 00                        lda 0,x
0012BEr 3  85 rr                        sta ip
0012C0r 3  B5 01                        lda 1,x
0012C2r 3  85 rr                        sta ip+1
0012C4r 3               
0012C4r 3  E8                           inx
0012C5r 3  E8                           inx
0012C6r 3               
0012C6r 3                               ; we don't need a RTS here because we highjack the RTS of
0012C6r 3                               ; the word we're calling to get back to xt_execute
0012C6r 3  6C rr rr                     jmp (ip)
0012C9r 3               
0012C9r 3               ; end of doexecute
0012C9r 3               
0012C9r 3               
0012C9r 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
0012C9r 3               ; ## "execute-parsing"  auto  Gforth
0012C9r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
0012C9r 3                       ; Execute the parsing word defined by the execution token (xt) on the
0012C9r 3                       ; string as if it were passed on the command line. See the file
0012C9r 3                       ; tests/tali.fs for examples.
0012C9r 3                       ;
0012C9r 3                       ; Note that this word is coded completely
0012C9r 3                       ; different in its Gforth version, see the file execute-parsing.fs
0012C9r 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
0012C9r 3                       ; """
0012C9r 3               xt_execute_parsing:
0012C9r 3  20 rr rr                     jsr underflow_3
0012CCr 3               
0012CCr 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
0012CFr 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
0012D2r 3               
0012D2r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
0012D4r 3  85 rr                        sta ciblen
0012D6r 3  B5 01                        lda 1,x
0012D8r 3  85 rr                        sta ciblen+1
0012DAr 3               
0012DAr 3  B5 02                        lda 2,x                 ; NOS is new cib
0012DCr 3  85 rr                        sta cib
0012DEr 3  B5 03                        lda 3,x
0012E0r 3  85 rr                        sta cib+1
0012E2r 3               
0012E2r 3  64 rr                        stz toin                ; Set >IN to zero
0012E4r 3  64 rr                        stz toin+1
0012E6r 3               
0012E6r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
0012E9r 3  20 rr rr                     jsr xt_execute
0012ECr 3               
0012ECr 3  20 rr rr                     jsr xt_r_to_input
0012EFr 3               
0012EFr 3               z_execute_parsing:
0012EFr 3  60                           rts
0012F0r 3               
0012F0r 3               
0012F0r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
0012F0r 3               ; ## "exit"  auto  ANS core
0012F0r 3                       ; """https://forth-standard.org/standard/core/EXIT
0012F0r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
0012F0r 3                       ; we we might have put on the Return Stack off as well. This should
0012F0r 3                       ; be natively compiled.
0012F0r 3                       ; """
0012F0r 3               
0012F0r 3               xt_exit:
0012F0r 3  60                           rts             ; keep before z_exit
0012F1r 3               z_exit:                         ; never reached
0012F1r 3               
0012F1r 3               
0012F1r 3               
0012F1r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
0012F1r 3               ; ## "false"  auto  ANS core ext
0012F1r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
0012F1r 3               xt_false:
0012F1r 3  CA                           dex
0012F2r 3  CA                           dex
0012F3r 3  74 00                        stz 0,x
0012F5r 3  74 01                        stz 1,x
0012F7r 3               
0012F7r 3  60           z_false:        rts
0012F8r 3               
0012F8r 3               
0012F8r 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
0012F8r 3               ; ## "@"  auto  ANS core
0012F8r 3                       ; """https://forth-standard.org/standard/core/Fetch"""
0012F8r 3               xt_fetch:
0012F8r 3  20 rr rr                     jsr underflow_1
0012FBr 3               
0012FBr 3  A1 00                        lda (0,x)               ; LSB
0012FDr 3  A8                           tay
0012FEr 3  F6 00                        inc 0,x
001300r 3  D0 02                        bne @1
001302r 3  F6 01                        inc 1,x
001304r 3               @1:
001304r 3  A1 00                        lda (0,x)               ; MSB
001306r 3  95 01                        sta 1,x
001308r 3  94 00                        sty 0,x
00130Ar 3               
00130Ar 3  60           z_fetch:        rts
00130Br 3               
00130Br 3               
00130Br 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
00130Br 3               ; ## "find"  auto  ANS core
00130Br 3                       ; """https://forth-standard.org/standard/core/FIND
00130Br 3                       ; Included for backwards compatibility only, because it still
00130Br 3                       ; can be found in so may examples. It should, however, be replaced
00130Br 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
00130Br 3                       ; flag if not found in the Dictionary, or the xt with a flag to
00130Br 3                       ; indicate if this is immediate or not. FIND is a wrapper around
00130Br 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
00130Br 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
00130Br 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00130Br 3                       ; """
00130Br 3               
00130Br 3               xt_find:
00130Br 3  20 rr rr                     jsr underflow_1
00130Er 3               
00130Er 3                               ; Save address in case conversion fails. We use the
00130Er 3                               ; Return Stack instead of temporary variables like TMP1
00130Er 3                               ; because this is shorter and anybody still using FIND
00130Er 3                               ; can't be worried about speed anyway
00130Er 3  B5 01                        lda 1,x                 ; MSB
001310r 3  48                           pha
001311r 3  B5 00                        lda 0,x                 ; LSB
001313r 3  48                           pha
001314r 3               
001314r 3                               ; Convert ancient-type counted string address to
001314r 3                               ; modern format
001314r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
001317r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
00131Ar 3               
00131Ar 3  B5 00                        lda 0,x
00131Cr 3  15 01                        ora 1,x
00131Er 3  D0 0B                        bne @found_word
001320r 3               
001320r 3                               ; No word found. Return address of the string and a false
001320r 3                               ; flag
001320r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
001323r 3               
001323r 3                               ; The address needs to be restored.
001323r 3  68                           pla                     ; LSB of address
001324r 3  95 02                        sta 2,x
001326r 3  68                           pla
001327r 3  95 03                        sta 3,x                 ; MSB of address
001329r 3               
001329r 3  80 27                        bra @done               ; ( addr 0 )
00132Br 3               
00132Br 3               @found_word:
00132Br 3                               ; We don't need the address after all, dump it
00132Br 3  68                           pla
00132Cr 3  68                           pla
00132Dr 3               
00132Dr 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
00132Dr 3                               ; convert the return values to FIND's format
00132Dr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001330r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001333r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001336r 3               
001336r 3  A0 00                        ldy #0                  ; Prepare flag
001338r 3               
001338r 3                               ; The flags are in the second byte of the header
001338r 3  F6 00                        inc 0,x
00133Ar 3  D0 02                        bne @1
00133Cr 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
00133Er 3               @1:
00133Er 3  A1 00                        lda (0,x)               ; ( xt char )
001340r 3  29 04                        and #IM
001342r 3  D0 08                        bne @immediate          ; bit set, we're immediate
001344r 3               
001344r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001346r 3  95 00                        sta 0,x
001348r 3  95 01                        sta 1,x
00134Ar 3  80 06                        bra @done
00134Cr 3               
00134Cr 3               @immediate:
00134Cr 3  A9 01                        lda #1                  ; We're immediate, return 1
00134Er 3  95 00                        sta 0,x
001350r 3  74 01                        stz 1,x
001352r 3               @done:
001352r 3  60           z_find:         rts
001353r 3               
001353r 3               
001353r 3               
001353r 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
001353r 3               ; ## "find-name"  auto  Gforth
001353r 3               
001353r 3               xt_find_name:
001353r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001353r 3                       ; Given a string, find the Name Token (nt) of a word or return
001353r 3                       ; zero if the word is not in the dictionary. We use this instead of
001353r 3                       ; ancient FIND to look up words in the Dictionary passed by
001353r 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
001353r 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
001353r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001353r 3                       ; FIND calls this word
001353r 3                       ; """
001353r 3  20 rr rr                     jsr underflow_2
001356r 3               
001356r 3                               ; check for special case of an empty string (length zero)
001356r 3  B5 00                        lda 0,x
001358r 3  15 01                        ora 1,x
00135Ar 3  D0 03                        bne @nonempty
00135Cr 3               
00135Cr 3  4C rr rr                     jmp @fail_done
00135Fr 3               
00135Fr 3               @nonempty:
00135Fr 3                               ; Set up for traversing the wordlist search order.
00135Fr 3  64 rr                        stz tmp3                ; Start at the beginning
001361r 3               
001361r 3               @wordlist_loop:
001361r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
001363r 3  A5 rr                        lda tmp3
001365r 3  D1 rr                        cmp (up),y              ; Check to see if we are done
001367r 3  D0 03                        bne @have_string
001369r 3               
001369r 3                               ; We ran out of wordlists to search.
001369r 3  4C rr rr                     jmp @fail_done
00136Cr 3               
00136Cr 3               @have_string:
00136Cr 3                               ; set up first loop iteration
00136Cr 3               
00136Cr 3                               ; Get the current wordlist id
00136Cr 3  18                           clc             ; SEARCH-ORDER is array of bytes.
00136Dr 3  69 1F                        adc #search_order_offset
00136Fr 3  A8                           tay
001370r 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
001372r 3                                               ; into the cell array WORDLISTS
001372r 3               
001372r 3                               ; Get the DP for that wordlist.
001372r 3  0A                           asl                     ; Turn offset into cells offset.
001373r 3  18                           clc
001374r 3  69 06                        adc #wordlists_offset
001376r 3  A8                           tay
001377r 3  B1 rr                        lda (up),y
001379r 3  85 rr                        sta tmp1
00137Br 3  C8                           iny
00137Cr 3  B1 rr                        lda (up),y
00137Er 3  85 rr                        sta tmp1+1
001380r 3               
001380r 3  B5 02                        lda 2,x                 ; Address of mystery string
001382r 3  85 rr                        sta tmp2
001384r 3  B5 03                        lda 3,x
001386r 3  85 rr                        sta tmp2+1
001388r 3               
001388r 3               @loop:
001388r 3                               ; first quick test: Are strings the same length?
001388r 3  B2 rr                        lda (tmp1)
00138Ar 3  D5 00                        cmp 0,x
00138Cr 3  D0 54                        bne @next_entry
00138Er 3               
00138Er 3               @compare_string:
00138Er 3                               ; are the same length, so we now have to compare each
00138Er 3                               ; character
00138Er 3               
00138Er 3                               ; second quick test: Is the first character the same?
00138Er 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001390r 3               
001390r 3                               ; Lowercase the incoming charcter.
001390r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001392r 3  B0 07                        bcs @compare_first
001394r 3  C9 41                        cmp #$41        ; ASCII 'A'
001396r 3  90 03                        bcc @compare_first
001398r 3               
001398r 3                               ; An uppercase letter has been located.  Make it
001398r 3                               ; lowercase.
001398r 3  18                           clc
001399r 3  69 20                        adc #$20
00139Br 3               
00139Br 3               @compare_first:
00139Br 3  A0 08                        ldy #8          ; Offset in nt to name
00139Dr 3  D1 rr                        cmp (tmp1),y    ; first character of current word
00139Fr 3  D0 41                        bne @next_entry
0013A1r 3               
0013A1r 3                               ; String length is the same and the first character is the
0013A1r 3                               ; same. If the length of the string is 1, we're already done
0013A1r 3  B5 00                        lda 0,x
0013A3r 3  3A                           dec
0013A4r 3  F0 2C                        beq @success
0013A6r 3               
0013A6r 3                               ; No such luck: The strings are the same length and the first
0013A6r 3                               ; char is the same, but the word is more than one char long.
0013A6r 3                               ; So we suck it up and compare every single character. We go
0013A6r 3                               ; from back to front, because words like CELLS and CELL+ would
0013A6r 3                               ; take longer otherwise. We can also shorten the loop by one
0013A6r 3                               ; because we've already compared the first char.
0013A6r 3               
0013A6r 3                               ; The string of the word we're testing against is 8 bytes down
0013A6r 3  A5 rr                        lda tmp1
0013A8r 3  48                           pha             ; Preserve tmp1 on the return stack.
0013A9r 3  18                           clc
0013AAr 3  69 08                        adc #8
0013ACr 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
0013AEr 3  A5 rr                        lda tmp1+1
0013B0r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
0013B1r 3  69 00                        adc #0          ; we only need the carry
0013B3r 3  85 rr                        sta tmp1+1
0013B5r 3               
0013B5r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0013B7r 3  88                           dey
0013B8r 3               
0013B8r 3               @string_loop:
0013B8r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
0013BAr 3               
0013BAr 3                               ; Lowercase the incoming charcter.
0013BAr 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0013BCr 3  B0 07                        bcs @check_char
0013BEr 3  C9 41                        cmp #$41        ; ASCII 'A'
0013C0r 3  90 03                        bcc @check_char
0013C2r 3               
0013C2r 3                               ; An uppercase letter has been located.  Make it
0013C2r 3                               ; lowercase.
0013C2r 3  18                           clc
0013C3r 3  69 20                        adc #$20
0013C5r 3               
0013C5r 3               @check_char:
0013C5r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
0013C7r 3  D0 13                        bne @next_entry_tmp1
0013C9r 3               
0013C9r 3  88                           dey
0013CAr 3  D0 EC                        bne @string_loop
0013CCr 3               
0013CCr 3               @success_tmp1:
0013CCr 3  68                           pla             ; Restore tmp1 from the return stack.
0013CDr 3  85 rr                        sta tmp1+1
0013CFr 3  68                           pla
0013D0r 3  85 rr                        sta tmp1
0013D2r 3               
0013D2r 3               @success:
0013D2r 3                               ; The strings match. Put correct nt NOS, because we'll drop
0013D2r 3                               ; TOS before we leave
0013D2r 3  A5 rr                        lda tmp1
0013D4r 3  95 02                        sta 2,x
0013D6r 3  A5 rr                        lda tmp1+1
0013D8r 3  95 03                        sta 3,x
0013DAr 3               
0013DAr 3  80 20                        bra @done
0013DCr 3               
0013DCr 3               @next_entry_tmp1:
0013DCr 3  68                           pla             ; Restore tmp1 from the return stack.
0013DDr 3  85 rr                        sta tmp1+1
0013DFr 3  68                           pla
0013E0r 3  85 rr                        sta tmp1
0013E2r 3               
0013E2r 3               @next_entry:
0013E2r 3                               ; Not the same, so we get the next word. Next header
0013E2r 3                               ; address is two bytes down
0013E2r 3  A0 02                        ldy #2
0013E4r 3  B1 rr                        lda (tmp1),y
0013E6r 3  48                           pha
0013E7r 3  C8                           iny
0013E8r 3  B1 rr                        lda (tmp1),y
0013EAr 3  85 rr                        sta tmp1+1
0013ECr 3  68                           pla
0013EDr 3  85 rr                        sta tmp1
0013EFr 3               
0013EFr 3                               ; If we got a zero, we've walked the whole Dictionary and
0013EFr 3                               ; return as a failure, otherwise try again
0013EFr 3  05 rr                        ora tmp1+1
0013F1r 3  D0 95                        bne @loop
0013F3r 3               
0013F3r 3                               ; Move on to the next wordlist in the search order.
0013F3r 3  E6 rr                        inc tmp3
0013F5r 3  4C rr rr                     jmp @wordlist_loop
0013F8r 3               
0013F8r 3               @fail_done:
0013F8r 3  74 02                        stz 2,x         ; failure flag
0013FAr 3  74 03                        stz 3,x
0013FCr 3               @done:
0013FCr 3  E8                           inx
0013FDr 3  E8                           inx
0013FEr 3               
0013FEr 3  60           z_find_name:    rts
0013FFr 3               
0013FFr 3               
0013FFr 3               
0013FFr 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
0013FFr 3               ; ## "flush"  auto  ANS block
0013FFr 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
0013FFr 3               xt_flush:
0013FFr 3  20 rr rr                     jsr xt_save_buffers
001402r 3               
001402r 3                               ; Set the buffer status to empty.
001402r 3  A0 2C                        ldy #buffstatus_offset
001404r 3  A9 00                        lda #0
001406r 3  91 rr                        sta (up),y      ; Only LSB is used.
001408r 3               z_flush:
001408r 3  60                           rts
001409r 3               
001409r 3               
001409r 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001409r 3               ; ## "fm/mod"  auto  ANS core
001409r 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001409r 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001409r 3                       ;
001409r 3                       ; There are various ways to realize this. We follow EForth with
001409r 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001409r 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001409r 3                       ; See (http://www.forth.org/eforth.html). However you can also
001409r 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001409r 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001409r 3                       ; """
001409r 3               
001409r 3               xt_fm_slash_mod:
001409r 3  20 rr rr                     jsr underflow_3
00140Cr 3               
00140Cr 3                               ; if sign of n1 is negative, negate both n1 and d
00140Cr 3  64 rr                        stz tmp2        ; default: n is positive
00140Er 3  B5 01                        lda 1,x         ; MSB of n1
001410r 3  10 0E                        bpl @check_d
001412r 3               
001412r 3  E6 rr                        inc tmp2        ; set flag to negative for n1
001414r 3  20 rr rr                     jsr xt_negate   ; NEGATE
001417r 3  20 rr rr                     jsr xt_to_r     ; >R
00141Ar 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
00141Dr 3  20 rr rr                     jsr xt_r_from   ; R>
001420r 3               
001420r 3               @check_d:
001420r 3                               ; If d is negative, add n1 to high cell of d
001420r 3  B5 03                        lda 3,x         ; MSB of high word of d
001422r 3  10 0D                        bpl @multiply
001424r 3               
001424r 3  18                           clc
001425r 3  B5 00                        lda 0,x         ; LSB of n1
001427r 3  75 02                        adc 2,x         ; LSB of dh
001429r 3  95 02                        sta 2,x
00142Br 3               
00142Br 3  B5 01                        lda 1,x         ; MSB of n1
00142Dr 3  75 03                        adc 3,x         ; MSB of dh
00142Fr 3  95 03                        sta 3,x
001431r 3               
001431r 3               @multiply:
001431r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
001434r 3               
001434r 3                               ; if n was negative, negate the result
001434r 3  A5 rr                        lda tmp2
001436r 3  F0 07                        beq @done
001438r 3               
001438r 3  E8                           inx             ; pretend that we SWAP
001439r 3  E8                           inx
00143Ar 3  20 rr rr                     jsr xt_negate
00143Dr 3  CA                           dex
00143Er 3  CA                           dex
00143Fr 3               @done:
00143Fr 3  60           z_fm_slash_mod: rts
001440r 3               
001440r 3               
001440r 3               
001440r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
001440r 3               ; ## "forth"  auto  ANS search ext
001440r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
001440r 3               xt_forth:
001440r 3  A0 1F                        ldy #search_order_offset
001442r 3  A9 00                        lda #0          ; The WID for Forth is 0.
001444r 3               
001444r 3  91 rr                        sta (up),y
001446r 3               z_forth:
001446r 3  60                           rts
001447r 3               
001447r 3               
001447r 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
001447r 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
001447r 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
001447r 3               load_evaluate:
001447r 3                               ; Set a flag (using tmp1) to not zero BLK
001447r 3  A9 FF                        lda #$FF
001449r 3  85 rr                        sta tmp1
00144Br 3  80 11                        bra load_evaluate_start
00144Dr 3               
00144Dr 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
00144Dr 3               ; ## "evaluate"  auto  ANS core
00144Dr 3                       ; """https://forth-standard.org/standard/core/EVALUATE
00144Dr 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
00144Dr 3                       ; After processing the line, revert to old input source. We use this
00144Dr 3                       ; to compile high-level Forth words and user-defined words during
00144Dr 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
00144Dr 3                       ; accept more than 255 characters here, even though it's a pain in
00144Dr 3                       ; the 8-bit.
00144Dr 3                       ; """
00144Dr 3               
00144Dr 3               xt_evaluate:
00144Dr 3  20 rr rr                     jsr underflow_2
001450r 3               
001450r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
001450r 3                               ; and will set the block number.
001450r 3  64 rr                        stz tmp1
001452r 3               
001452r 3                               ; If u is zero (which can happen a lot for the user-defined
001452r 3                               ; words), just leave again
001452r 3  B5 00                        lda 0,x
001454r 3  15 01                        ora 1,x
001456r 3  D0 06                        bne _eval_got_work
001458r 3               
001458r 3  E8                           inx
001459r 3  E8                           inx
00145Ar 3  E8                           inx
00145Br 3  E8                           inx
00145Cr 3               
00145Cr 3  80 42                        bra _eval_done
00145Er 3               
00145Er 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
00145Er 3               load_evaluate_start:
00145Er 3               _eval_got_work:
00145Er 3                               ; Save the current value of BLK on the return stack.
00145Er 3  A0 01                        ldy #blk_offset+1
001460r 3  B1 rr                        lda (up),y
001462r 3  48                           pha
001463r 3  88                           dey
001464r 3  B1 rr                        lda (up),y
001466r 3  48                           pha
001467r 3               
001467r 3                               ; See if we should zero BLK.
001467r 3  A5 rr                        lda tmp1
001469r 3  D0 05                        bne @nozero
00146Br 3               
00146Br 3                               ; Set BLK to zero.
00146Br 3                               ; lda #0        ; A is already zero from loading tmp1
00146Br 3  91 rr                        sta (up),y
00146Dr 3  C8                           iny
00146Er 3  91 rr                        sta (up),y
001470r 3               
001470r 3               @nozero:
001470r 3                               ; Save the input state to the Return Stack
001470r 3  20 rr rr                     jsr xt_input_to_r
001473r 3               
001473r 3                               ; set SOURCE-ID to -1
001473r 3  A9 FF                        lda #$ff
001475r 3  85 rr                        sta insrc
001477r 3  85 rr                        sta insrc+1
001479r 3               
001479r 3                               ; set >IN to zero
001479r 3  64 rr                        stz toin
00147Br 3  64 rr                        stz toin+1
00147Dr 3               
00147Dr 3                               ; move TOS and NOS to input buffers
00147Dr 3  B5 00                        lda 0,x
00147Fr 3  85 rr                        sta ciblen
001481r 3  B5 01                        lda 1,x
001483r 3  85 rr                        sta ciblen+1
001485r 3               
001485r 3  B5 02                        lda 2,x
001487r 3  85 rr                        sta cib
001489r 3  B5 03                        lda 3,x
00148Br 3  85 rr                        sta cib+1
00148Dr 3               
00148Dr 3  E8                           inx             ; A clean stack is a clean mind
00148Er 3  E8                           inx
00148Fr 3  E8                           inx
001490r 3  E8                           inx
001491r 3               
001491r 3  20 rr rr                     jsr interpret   ; ( -- )
001494r 3               
001494r 3                               ; restore variables
001494r 3  20 rr rr                     jsr xt_r_to_input
001497r 3               
001497r 3                               ; Restore BLK from the return stack.
001497r 3  A0 00                        ldy #blk_offset
001499r 3  68                           pla
00149Ar 3  91 rr                        sta (up),y
00149Cr 3  C8                           iny
00149Dr 3  68                           pla
00149Er 3  91 rr                        sta (up),y
0014A0r 3               
0014A0r 3               _eval_done:
0014A0r 3  60           z_evaluate:     rts
0014A1r 3               
0014A1r 3               
0014A1r 3               
0014A1r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
0014A1r 3               ; ## "forth-wordlist"  auto  ANS search
0014A1r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
0014A1r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
0014A1r 3               
0014A1r 3               
0014A1r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
0014A1r 3               ; ## "get-current" auto ANS search
0014A1r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
0014A1r 3               
0014A1r 3               xt_get_current:
0014A1r 3                               ; This is a little different than some of the variables
0014A1r 3                               ; in the user area as we want the value rather than
0014A1r 3                               ; the address.
0014A1r 3  CA                           dex
0014A2r 3  CA                           dex
0014A3r 3  A0 04                        ldy #current_offset
0014A5r 3  B1 rr                        lda (up),y
0014A7r 3  95 00                        sta 0,x         ; CURRENT is a byte variable
0014A9r 3  74 01                        stz 1,x         ; so the MSB is zero.
0014ABr 3               
0014ABr 3  60           z_get_current:  rts
0014ACr 3               
0014ACr 3               
0014ACr 3               
0014ACr 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
0014ACr 3               ; ## "get-order" auto ANS search
0014ACr 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
0014ACr 3               
0014ACr 3               xt_get_order:
0014ACr 3                               ; Get #ORDER - the number of wordlists in the search order.
0014ACr 3  A0 1E                        ldy #num_order_offset
0014AEr 3  B1 rr                        lda (up),y
0014B0r 3  85 rr                        sta tmp1
0014B2r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
0014B4r 3               
0014B4r 3               @loop:
0014B4r 3                               ; Count down towards the front of the list.
0014B4r 3                               ; By decrementing first, we also turn the length into an offset.
0014B4r 3  C6 rr                        dec tmp1        ; Count down by bytes.
0014B6r 3               
0014B6r 3                               ; Get a pointer to the current wordlist, working back to front.
0014B6r 3  A9 1F                        lda #search_order_offset
0014B8r 3  18                           clc
0014B9r 3  65 rr                        adc tmp1
0014BBr 3  A8                           tay
0014BCr 3               
0014BCr 3                               ; Put that wordlist id on the stack.
0014BCr 3  CA                           dex
0014BDr 3  CA                           dex
0014BEr 3  B1 rr                        lda (up),y
0014C0r 3  95 00                        sta 0,x         ; Search order array is bytes, so
0014C2r 3  74 01                        stz 1,x         ; put a zero in the high byte.
0014C4r 3               
0014C4r 3                               ; See if that was the last one to process (first in the list).
0014C4r 3  A9 00                        lda #0
0014C6r 3  C5 rr                        cmp tmp1
0014C8r 3  D0 EA                        bne @loop
0014CAr 3               
0014CAr 3               @done:
0014CAr 3                               ; Put the number of items on the stack.
0014CAr 3  CA                           dex
0014CBr 3  CA                           dex
0014CCr 3  A0 1E                        ldy #num_order_offset
0014CEr 3  B1 rr                        lda (up),y
0014D0r 3  95 00                        sta 0,x
0014D2r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
0014D4r 3               
0014D4r 3  60           z_get_order:    rts
0014D5r 3               
0014D5r 3               
0014D5r 3               
0014D5r 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
0014D5r 3               ; ## ">"  auto  ANS core
0014D5r 3                       ; """https://forth-standard.org/standard/core/more"""
0014D5r 3               
0014D5r 3               xt_greater_than:
0014D5r 3  20 rr rr                     jsr underflow_2
0014D8r 3               
0014D8r 3  A0 00                        ldy #0          ; default false
0014DAr 3  20 rr rr                     jsr compare_16bit
0014DDr 3               
0014DDr 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
0014DDr 3  F0 03                        beq @false
0014DFr 3  10 01                        bpl @false
0014E1r 3               
0014E1r 3                               ; true
0014E1r 3  88                           dey
0014E2r 3               @false:
0014E2r 3  98                           tya
0014E3r 3               
0014E3r 3  E8                           inx
0014E4r 3  E8                           inx
0014E5r 3  95 00                        sta 0,x
0014E7r 3  95 01                        sta 1,x
0014E9r 3               
0014E9r 3  60           z_greater_than: rts
0014EAr 3               
0014EAr 3               
0014EAr 3               
0014EAr 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
0014EAr 3               ; ## "here"  auto  ANS core
0014EAr 3                       ; """https://forth-standard.org/standard/core/HERE
0014EAr 3                       ; This code is also used by the assembler directive ARROW
0014EAr 3                       ; ("->") though as immediate"""
0014EAr 3               xt_here:
0014EAr 3               xt_asm_arrow:
0014EAr 3  CA                           dex
0014EBr 3  CA                           dex
0014ECr 3  A5 rr                        lda cp
0014EEr 3  95 00                        sta 0,x
0014F0r 3  A5 rr                        lda cp+1
0014F2r 3  95 01                        sta 1,x
0014F4r 3               
0014F4r 3               z_asm_arrow:
0014F4r 3  60           z_here:         rts
0014F5r 3               
0014F5r 3               
0014F5r 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
0014F5r 3               ; ## "hex"  auto  ANS core ext
0014F5r 3                       ; """https://forth-standard.org/standard/core/HEX"""
0014F5r 3               xt_hex:
0014F5r 3  A9 10                        lda #16
0014F7r 3  85 rr                        sta base
0014F9r 3  64 rr                        stz base+1              ; paranoid
0014FBr 3               
0014FBr 3  60           z_hex:          rts
0014FCr 3               
0014FCr 3               
0014FCr 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
0014FCr 3               ; ## "hexstore"  auto  Tali
0014FCr 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
0014FCr 3                       ; by spaces, store the numbers at the address addr2, returning the
0014FCr 3                       ; number of elements. Non-number elements are skipped, an zero-length
0014FCr 3                       ; string produces a zero output.
0014FCr 3                       ; """
0014FCr 3               
0014FCr 3               xt_hexstore:
0014FCr 3  20 rr rr                     jsr underflow_3
0014FFr 3               
0014FFr 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
001502r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
001505r 3               
001505r 3               @loop:
001505r 3                               ; Loop until string is totally consumed
001505r 3  B5 00                        lda 0,x
001507r 3  15 01                        ora 1,x
001509r 3  F0 36                        beq @done
00150Br 3               
00150Br 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
00150Er 3               
00150Er 3                               ; Prepare the conversion of the number.
00150Er 3  20 rr rr                     jsr xt_two_to_r
001511r 3  20 rr rr                     jsr xt_zero
001514r 3  20 rr rr                     jsr xt_zero
001517r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
00151Ar 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
00151Dr 3               
00151Dr 3                               ; If u4 is not zero, we have leftover chars and have to do
00151Dr 3                               ; things differently
00151Dr 3  B5 00                        lda 0,x
00151Fr 3  15 01                        ora 1,x
001521r 3  D0 17                        bne @have_chars_left
001523r 3               
001523r 3                               ; Normal case, this number is all done
001523r 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001526r 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001529r 3               
001529r 3                               ; Store the new value
001529r 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
00152Cr 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
00152Fr 3               
00152Fr 3                               ; Increase counter
00152Fr 3  20 rr rr                     jsr xt_r_from           ; R>
001532r 3  20 rr rr                     jsr xt_one_plus         ; 1+
001535r 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001538r 3  80 CB                        bra @loop
00153Ar 3               
00153Ar 3               @have_chars_left:
00153Ar 3                               ; Pathological case: Drop the rest of this number off the stack
00153Ar 3                               ; and continue with the next word. Doesn't print a warning. We
00153Ar 3                               ; need to drop four cells, that is, eight bytes
00153Ar 3  8A                           txa
00153Br 3  18                           clc
00153Cr 3  69 08                        adc #8
00153Er 3  AA                           tax
00153Fr 3  80 C4                        bra @loop
001541r 3               
001541r 3               @done:
001541r 3                               ; Clean up return stack and calculate number of chars stored
001541r 3  E8                           inx
001542r 3  E8                           inx
001543r 3  E8                           inx
001544r 3  E8                           inx                     ; 2DROP
001545r 3               
001545r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001548r 3  20 rr rr                     jsr xt_swap
00154Br 3  20 rr rr                     jsr xt_minus            ; ( n )
00154Er 3               
00154Er 3  60           z_hexstore:     rts
00154Fr 3               
00154Fr 3               
00154Fr 3               
00154Fr 3               ; ## HOLD ( char -- ) "Insert character at current output"
00154Fr 3               ; ## "hold"  auto  ANS core
00154Fr 3                       ; """https://forth-standard.org/standard/core/HOLD
00154Fr 3                       ; Insert a character at the current position of a pictured numeric
00154Fr 3                       ; output string on
00154Fr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00154Fr 3                       ;
00154Fr 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
00154Fr 3                       ; variable tohold instead of HLD.
00154Fr 3                       ; """
00154Fr 3               xt_hold:
00154Fr 3  20 rr rr                     jsr underflow_1
001552r 3               
001552r 3  A5 rr                        lda tohold
001554r 3  D0 02                        bne @1
001556r 3  C6 rr                        dec tohold+1
001558r 3               @1:
001558r 3  C6 rr                        dec tohold
00155Ar 3               
00155Ar 3  B5 00                        lda 0,x
00155Cr 3  92 rr                        sta (tohold)
00155Er 3  E8                           inx
00155Fr 3  E8                           inx
001560r 3               
001560r 3  60           z_hold:         rts
001561r 3               
001561r 3               
001561r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
001561r 3               ; ## "i"  auto  ANS core
001561r 3                       ; """https://forth-standard.org/standard/core/I
001561r 3                       ; Note that this is not the same as R@ because we use a fudge
001561r 3                       ; factor for loop control; see the Control Flow section of the
001561r 3                       ; manual for details.
001561r 3                       ;
001561r 3                       ; We should make this native compile for speed.
001561r 3                       ; """
001561r 3               
001561r 3               xt_i:
001561r 3  CA                           dex
001562r 3  CA                           dex
001563r 3               
001563r 3                               ; Get the fudged index off of the top of the stack. It's
001563r 3                               ; easier to do math on the stack directly than to pop and
001563r 3                               ; push stuff around
001563r 3  86 rr                        stx tmpdsp
001565r 3  BA                           tsx
001566r 3               
001566r 3  38                           sec
001567r 3  BD 01 01                     lda $0101,x     ; LSB
00156Ar 3  FD 03 01                     sbc $0103,x
00156Dr 3  A8                           tay
00156Er 3               
00156Er 3  BD 02 01                     lda $0102,x     ; MSB
001571r 3  FD 04 01                     sbc $0104,x
001574r 3               
001574r 3  A6 rr                        ldx tmpdsp
001576r 3               
001576r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001578r 3  94 00                        sty 0,x         ; LSB of de-fudged index
00157Ar 3               
00157Ar 3  60           z_i:            rts
00157Br 3               
00157Br 3               
00157Br 3               
00157Br 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
00157Br 3               ; ## "if"  auto  ANS core
00157Br 3                       ; """http://forth-standard.org/standard/core/IF"""
00157Br 3               
00157Br 3               xt_if:
00157Br 3                               ; Compile a 0BRANCH
00157Br 3  A0 rr                        ldy #>zero_branch_runtime
00157Dr 3  A9 rr                        lda #<zero_branch_runtime
00157Fr 3  20 rr rr                     jsr cmpl_subroutine
001582r 3               
001582r 3                               ; Put the origination address on the stack for else/then
001582r 3  20 rr rr                     jsr xt_here
001585r 3               
001585r 3                               ; Stuff zero in for the branch address right now.
001585r 3                               ; THEN or ELSE will fix it later.
001585r 3  20 rr rr                     jsr xt_zero
001588r 3  20 rr rr                     jsr xt_comma
00158Br 3  60           z_if:           rts
00158Cr 3               
00158Cr 3               
00158Cr 3               zero_branch_runtime:
00158Cr 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
00158Cr 3                       ; included 0BRANCH as a high-level word that inserted this code at
00158Cr 3                       ; runtime.
00158Cr 3                       ; """
00158Cr 3               
00158Cr 3                               ; We use the return value on the 65c02 stack to determine
00158Cr 3                               ; where we want to return to.
00158Cr 3  68                           pla
00158Dr 3  85 rr                        sta tmpbranch
00158Fr 3  68                           pla
001590r 3  85 rr                        sta tmpbranch+1
001592r 3               
001592r 3                               ; See if the flag is zero, which is the whole purpose of
001592r 3                               ; this all
001592r 3  B5 00                        lda 0,x
001594r 3  15 01                        ora 1,x
001596r 3  F0 0F                        beq @zero
001598r 3               
001598r 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001598r 3                               ; the part between IF and THEN
001598r 3  A5 rr                        lda tmpbranch   ; LSB
00159Ar 3  18                           clc
00159Br 3  69 02                        adc #2
00159Dr 3  85 rr                        sta tmp1
00159Fr 3  A5 rr                        lda tmpbranch+1 ; MSB
0015A1r 3  69 00                        adc #0          ; For carry
0015A3r 3  85 rr                        sta tmp1+1
0015A5r 3               
0015A5r 3  80 13                        bra @done
0015A7r 3               
0015A7r 3               @zero:
0015A7r 3                               ; Flag is FALSE (0) so we take the jump to the address given in
0015A7r 3                               ; the next two bytes. However, the address points to the last
0015A7r 3                               ; byte of the JSR instruction, not to the next byte afterwards
0015A7r 3  A0 01                        ldy #1
0015A9r 3  B1 rr                        lda (tmpbranch),y
0015ABr 3  85 rr                        sta tmp1
0015ADr 3  C8                           iny
0015AEr 3  B1 rr                        lda (tmpbranch),y
0015B0r 3  85 rr                        sta tmp1+1
0015B2r 3               
0015B2r 3                               ; Now we have to subtract one byte from the address
0015B2r 3                               ; given because of the way the 6502 calculates RTS
0015B2r 3  A5 rr                        lda tmp1
0015B4r 3  D0 02                        bne @1
0015B6r 3  C6 rr                        dec tmp1+1
0015B8r 3               @1:
0015B8r 3  C6 rr                        dec tmp1
0015BAr 3               
0015BAr 3               @done:
0015BAr 3                               ; However we got here, tmp1 has the value we push to jump
0015BAr 3                               ; to
0015BAr 3  A5 rr                        lda tmp1+1
0015BCr 3  48                           pha             ; MSB first
0015BDr 3  A5 rr                        lda tmp1
0015BFr 3  48                           pha
0015C0r 3               
0015C0r 3                               ; clean up the stack and jump
0015C0r 3  E8                           inx
0015C1r 3  E8                           inx
0015C2r 3               
0015C2r 3  60                           rts
0015C3r 3               
0015C3r 3               
0015C3r 3               
0015C3r 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
0015C3r 3               ; ## "immediate"  auto  ANS core
0015C3r 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
0015C3r 3                       ; Make sure the most recently defined word is immediate. Will only
0015C3r 3                       ; affect the last word in the dictionary. Note that if the word is
0015C3r 3                       ; defined in ROM, this will have no affect, but will not produce an
0015C3r 3                       ; error message.
0015C3r 3                       ; """
0015C3r 3               xt_immediate:
0015C3r 3  20 rr rr                     jsr current_to_dp
0015C6r 3  A0 01                        ldy #1          ; offset for status byte
0015C8r 3  B1 rr                        lda (dp),y
0015CAr 3  09 04                        ora #IM        ; make sure bit 7 is set
0015CCr 3  91 rr                        sta (dp),y
0015CEr 3               
0015CEr 3  60           z_immediate:    rts
0015CFr 3               
0015CFr 3               
0015CFr 3               ; ## INPUT ( -- addr ) "Return address of input vector"
0015CFr 3               ; ## "input" tested Tali Forth
0015CFr 3               
0015CFr 3               xt_input:
0015CFr 3  CA                           dex
0015D0r 3  CA                           dex
0015D1r 3  A9 rr                        lda #<input
0015D3r 3  95 00                        sta 0,x
0015D5r 3  A9 rr                        lda #>input
0015D7r 3  95 01                        sta 1,x
0015D9r 3               
0015D9r 3  60           z_input:        rts
0015DAr 3               
0015DAr 3               
0015DAr 3               
0015DAr 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
0015DAr 3               ; ## "input>r"  tested  Tali Forth
0015DAr 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
0015DAr 3                       ; toin to the Return Stack. Used by EVALUTE.
0015DAr 3                       ;
0015DAr 3                       ; The naive way of doing
0015DAr 3                       ; this is to push each two-byte variable to the stack in the form of
0015DAr 3                       ;
0015DAr 3                       ;       lda insrc
0015DAr 3                       ;       pha
0015DAr 3                       ;       lda insrc+1
0015DAr 3                       ;       pha
0015DAr 3                       ;
0015DAr 3                       ; for a total of 24 byte of instruction in one direction and later
0015DAr 3                       ; a further 24 bytes to reverse the process. We shorten this at the
0015DAr 3                       ; cost of some speed by assuming the four variables are grouped
0015DAr 3                       ; together on the Zero Page and start with insrc (see definitions.asm
0015DAr 3                       ; for details). The reverse operation is r_to_input. These words must
0015DAr 3                       ; be flagged as Never Native. Uses tmp1
0015DAr 3                       ; """
0015DAr 3               
0015DAr 3               xt_input_to_r:
0015DAr 3                               ; We arrive here with the return address on the top of the
0015DAr 3                               ; 65c02's stack. We need to move it out of the way first
0015DAr 3  68                           pla
0015DBr 3  85 rr                        sta tmp1
0015DDr 3  68                           pla
0015DEr 3  85 rr                        sta tmp1+1
0015E0r 3               
0015E0r 3                               ; This assumes that insrc is the first of eight bytes and
0015E0r 3                               ; toin+1 the last in the sequence we want to save from the Zero
0015E0r 3                               ; Page.
0015E0r 3  A0 07                        ldy #7
0015E2r 3               @loop:
0015E2r 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
0015E5r 3  48                           pha
0015E6r 3  88                           dey
0015E7r 3  10 F9                        bpl @loop
0015E9r 3               
0015E9r 3                               ; Restore address for return jump
0015E9r 3  A5 rr                        lda tmp1+1
0015EBr 3  48                           pha
0015ECr 3  A5 rr                        lda tmp1
0015EEr 3  48                           pha
0015EFr 3               
0015EFr 3  60           z_input_to_r: 	rts
0015F0r 3               
0015F0r 3               
0015F0r 3               
0015F0r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
0015F0r 3               ; ## "int>name"  auto  Tali Forth
0015F0r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0015F0r 3                       ; This is called >NAME in Gforth, but we change it to
0015F0r 3                       ; INT>NAME to match NAME>INT
0015F0r 3                       ; """
0015F0r 3               
0015F0r 3               xt_int_to_name:
0015F0r 3  20 rr rr                     jsr underflow_1
0015F3r 3               
0015F3r 3                               ; Unfortunately, to find the header, we have to walk through
0015F3r 3                               ; all of the wordlists. We are running out of tmp variables.
0015F3r 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
0015F3r 3                               ; hold the current wordlist on the data stack. This searches
0015F3r 3                               ; all of the wordlists in id order.
0015F3r 3  CA                           dex
0015F4r 3  CA                           dex
0015F5r 3  74 00                        stz 0,x
0015F7r 3  74 01                        stz 1,x
0015F9r 3               
0015F9r 3               @wordlist_loop:
0015F9r 3                               ; A needs to have the current wordlist id in it at
0015F9r 3                               ; the top of this loop.
0015F9r 3  B5 00                        lda 0,x                 ; Get the current wordlist.
0015FBr 3               
0015FBr 3                               ; Get the DP for that wordlist.
0015FBr 3  0A                           asl                     ; Turn offset into cells offset.
0015FCr 3  18                           clc
0015FDr 3  69 06                        adc #wordlists_offset
0015FFr 3  A8                           tay
001600r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
001602r 3  85 rr                        sta tmp2                ; into tmp2
001604r 3  C8                           iny
001605r 3  B1 rr                        lda (up),y
001607r 3  85 rr                        sta tmp2+1
001609r 3               
001609r 3                               ; Check for an empty wordlist (DP will be 0)
001609r 3  A5 rr                        lda tmp2
00160Br 3  05 rr                        ora tmp2+1
00160Dr 3  F0 38                        beq @next_wordlist
00160Fr 3               
00160Fr 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001611r 3  85 rr                        sta tmp3        ; Save target xt in tmp3
001613r 3  B5 03                        lda 3,x
001615r 3  85 rr                        sta tmp3+1
001617r 3               
001617r 3               @loop:
001617r 3  A0 04                        ldy #4          ; xt is four bytes down
001619r 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
00161Br 3  C5 rr                        cmp tmp3
00161Dr 3  D0 07                        bne @no_match
00161Fr 3               
00161Fr 3                               ; LSB is the same, now check MSB
00161Fr 3  C8                           iny
001620r 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
001622r 3  C5 rr                        cmp tmp3+1
001624r 3  F0 32                        beq @match
001626r 3               
001626r 3               @no_match:
001626r 3                               ; no match, so we need to get the next word. Next nt is two
001626r 3                               ; bytes down
001626r 3  18                           clc
001627r 3  A5 rr                        lda tmp2
001629r 3  69 02                        adc #2
00162Br 3  85 rr                        sta tmp2
00162Dr 3  A5 rr                        lda tmp2+1
00162Fr 3  69 00                        adc #0          ; only care about carry
001631r 3  85 rr                        sta tmp2+1
001633r 3               
001633r 3  A0 00                        ldy #0
001635r 3  B1 rr                        lda (tmp2),y
001637r 3  48                           pha
001638r 3  C8                           iny
001639r 3  11 rr                        ora (tmp2),y
00163Br 3  F0 09                        beq @zero
00163Dr 3               
00163Dr 3                               ; Not zero continue
00163Dr 3  B1 rr                        lda (tmp2),y
00163Fr 3  85 rr                        sta tmp2+1
001641r 3  68                           pla
001642r 3  85 rr                        sta tmp2
001644r 3  80 D1                        bra @loop
001646r 3               
001646r 3               @zero:
001646r 3                               ; if next word is zero, the xt has no nt in this wordlist
001646r 3  68                           pla             ; Leftover from above loop
001647r 3               
001647r 3               @next_wordlist:
001647r 3                               ; Move on to the next wordlist.
001647r 3  B5 00                        lda 0,x
001649r 3  1A                           inc
00164Ar 3  95 00                        sta 0,x
00164Cr 3  C9 0C                        cmp #max_wordlists
00164Er 3  D0 A9                        bne @wordlist_loop
001650r 3               
001650r 3                               ; We didn't find it in any of the wordlists.
001650r 3                               ; Remove the wordlist id from the stack.
001650r 3  E8                           inx
001651r 3  E8                           inx
001652r 3               
001652r 3                               ; We return a zero to indicate that we didn't find it.
001652r 3  74 00                        stz 0,x
001654r 3  74 01                        stz 1,x
001656r 3  80 0A                        bra z_int_to_name
001658r 3               
001658r 3               @match:
001658r 3                               ; We found it. Remove wordlist id from stack.
001658r 3  E8                           inx
001659r 3  E8                           inx
00165Ar 3               
00165Ar 3                               ; It's a match! Replace TOS with nt
00165Ar 3  A5 rr                        lda tmp2
00165Cr 3  95 00                        sta 0,x
00165Er 3  A5 rr                        lda tmp2+1
001660r 3  95 01                        sta 1,x
001662r 3               
001662r 3  60           z_int_to_name:  rts
001663r 3               
001663r 3               
001663r 3               
001663r 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001663r 3               ; ## "invert"  auto  ANS core
001663r 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001663r 3               xt_invert:
001663r 3  20 rr rr                     jsr underflow_1
001666r 3               
001666r 3  A9 FF                        lda #$FF
001668r 3  55 00                        eor 0,x         ; LSB
00166Ar 3  95 00                        sta 0,x
00166Cr 3               
00166Cr 3  A9 FF                        lda #$FF
00166Er 3  55 01                        eor 1,x         ; MSB
001670r 3  95 01                        sta 1,x
001672r 3               
001672r 3  60           z_invert:       rts
001673r 3               
001673r 3               
001673r 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001673r 3               ; ## "is"  auto  ANS core ext
001673r 3                       ; """http://forth-standard.org/standard/core/IS"""
001673r 3               
001673r 3               xt_is:
001673r 3                               ; This is a state aware word with differet behavior
001673r 3                               ; when used while compiling vs interpreting.
001673r 3                               ; Check STATE
001673r 3  A5 rr                        lda state
001675r 3  05 rr                        ora state+1
001677r 3  F0 0C                        beq @interpreting
001679r 3               
001679r 3               @compiling:
001679r 3                               ; Run ['] to compile the xt of the next word as a literal.
001679r 3  20 rr rr                     jsr xt_bracket_tick
00167Cr 3               
00167Cr 3                               ; Postpone DEFER! by compiling a JSR to it.
00167Cr 3  A0 rr                        ldy #>xt_defer_store
00167Er 3  A9 rr                        lda #<xt_defer_store
001680r 3  20 rr rr                     jsr cmpl_subroutine
001683r 3               
001683r 3  80 06                        bra @done
001685r 3               
001685r 3               @interpreting:
001685r 3  20 rr rr                     jsr xt_tick
001688r 3  20 rr rr                     jsr xt_defer_store
00168Br 3               @done:
00168Br 3  60           z_is:           rts
00168Cr 3               
00168Cr 3               
00168Cr 3               
00168Cr 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
00168Cr 3               ; ## "j"  auto  ANS core
00168Cr 3                       ; """https://forth-standard.org/standard/core/J
00168Cr 3                       ; Copy second loop counter from Return Stack to stack. Note we use
00168Cr 3                       ; a fudge factor for loop control; see the Control Flow section of
00168Cr 3                       ; the manual for more details.
00168Cr 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
00168Cr 3                       ; on the stack above this (three entries), whereas the ideal Forth
00168Cr 3                       ; implementation would just have two.
00168Cr 3                       ;
00168Cr 3                       ; Make this native compiled for speed
00168Cr 3                       ; """
00168Cr 3               
00168Cr 3               xt_j:
00168Cr 3  CA                           dex
00168Dr 3  CA                           dex
00168Er 3               
00168Er 3                               ; Get the fudged index off from the stack. It's easier to
00168Er 3                               ; do math on the stack directly than to pop and push stuff
00168Er 3                               ; around
00168Er 3  86 rr                        stx tmpdsp
001690r 3  BA                           tsx
001691r 3               
001691r 3  38                           sec
001692r 3  BD 07 01                     lda $0107,x     ; LSB
001695r 3  FD 09 01                     sbc $0109,x
001698r 3  A8                           tay
001699r 3               
001699r 3  BD 08 01                     lda $0108,x     ; MSB
00169Cr 3  FD 0A 01                     sbc $010A,x
00169Fr 3               
00169Fr 3  A6 rr                        ldx tmpdsp
0016A1r 3               
0016A1r 3  95 01                        sta 1,x         ; MSB of de-fudged index
0016A3r 3  94 00                        sty 0,x         ; LSB of de-fudged index
0016A5r 3               
0016A5r 3  60           z_j:            rts
0016A6r 3               
0016A6r 3               
0016A6r 3               
0016A6r 3               ; ## KEY ( -- char ) "Get one character from the input"
0016A6r 3               ; ## "key"  tested  ANS core
0016A6r 3               xt_key:
0016A6r 3                       ; """https://forth-standard.org/standard/core/KEY
0016A6r 3                       ; Get a single character of input from the vectored
0016A6r 3                       ; input without echoing.
0016A6r 3                       ; """
0016A6r 3  20 rr rr                     jsr key_a               ; returns char in A
0016A9r 3               
0016A9r 3  CA                           dex
0016AAr 3  CA                           dex
0016ABr 3  95 00                        sta 0,x
0016ADr 3  74 01                        stz 1,x
0016AFr 3               
0016AFr 3  60           z_key:          rts
0016B0r 3               
0016B0r 3               key_a:
0016B0r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
0016B0r 3                       ; 65816, so we have to fake the indirect jump to vector it.
0016B0r 3                       ; This is depressingly slow. We use this routine internally
0016B0r 3                       ; to avoid manipulating the Data Stack when we just want a
0016B0r 3                       ; character
0016B0r 3  6C rr rr                     jmp (input)             ; JSR/RTS
0016B3r 3               
0016B3r 3               
0016B3r 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
0016B3r 3               ; ## "latestnt"  auto  Tali Forth
0016B3r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0016B3r 3                       ; The Gforth version of this word is called LATEST
0016B3r 3                       ; """
0016B3r 3               xt_latestnt:
0016B3r 3  CA                           dex
0016B4r 3  CA                           dex
0016B5r 3               
0016B5r 3  20 rr rr                     jsr current_to_dp
0016B8r 3               
0016B8r 3  A5 rr                        lda dp
0016BAr 3  95 00                        sta 0,x
0016BCr 3  A5 rr                        lda dp+1
0016BEr 3  95 01                        sta 1,x
0016C0r 3               
0016C0r 3  60           z_latestnt:     rts
0016C1r 3               
0016C1r 3               
0016C1r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
0016C1r 3               ; ## "latestxt"  auto  Gforth
0016C1r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
0016C1r 3               xt_latestxt:
0016C1r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
0016C4r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
0016C7r 3               
0016C7r 3  60           z_latestxt:     rts
0016C8r 3               
0016C8r 3               
0016C8r 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
0016C8r 3               ; ## "leave"  auto  ANS core
0016C8r 3                       ; """https://forth-standard.org/standard/core/LEAVE
0016C8r 3                       ; Note that this does not work with anything but a DO/LOOP in
0016C8r 3                       ; contrast to other versions such as discussed at
0016C8r 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
0016C8r 3                       ;
0016C8r 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
0016C8r 3                       ; See the Control Flow section in the manual for details of how this works.
0016C8r 3                       ; This must be native compile and not IMMEDIATE
0016C8r 3                       ; """
0016C8r 3               
0016C8r 3               xt_leave:
0016C8r 3                               ; We dump the limit/start entries off the Return Stack
0016C8r 3                               ; (four bytes)
0016C8r 3  68                           pla
0016C9r 3  68                           pla
0016CAr 3  68                           pla
0016CBr 3  68                           pla
0016CCr 3               
0016CCr 3  60                           rts             ; this must be compiled, so keep before z_leave
0016CDr 3               z_leave:                        ; not reached, not compiled
0016CDr 3               
0016CDr 3               
0016CDr 3               
0016CDr 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
0016CDr 3               ; ## "["  auto  ANS core
0016CDr 3                       ; """https://forth-standard.org/standard/core/Bracket
0016CDr 3                       ; This is an immediate and compile-only word
0016CDr 3                       ; """
0016CDr 3               xt_left_bracket:
0016CDr 3  64 rr                        stz state
0016CFr 3  64 rr                        stz state+1
0016D1r 3               
0016D1r 3  60           z_left_bracket: rts
0016D2r 3               
0016D2r 3               
0016D2r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
0016D2r 3               ; ## "<#"  auto  ANS core
0016D2r 3                       ; """https://forth-standard.org/standard/core/num-start
0016D2r 3                       ; Start the process to create pictured numeric output.
0016D2r 3                       ;
0016D2r 3                       ; The new
0016D2r 3                       ; string is constructed from back to front, saving the new character
0016D2r 3                       ; at the beginning of the output string. Since we use PAD as a
0016D2r 3                       ; starting address and work backward (!), the string is constructed
0016D2r 3                       ; in the space between the end of the Dictionary (as defined by CP)
0016D2r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
0016D2r 3                       ; programs don't fool around with the PAD but still use its address.
0016D2r 3                       ; Based on pForth
0016D2r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0016D2r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
0016D2r 3                       ; internal variable tohold instead of HLD.
0016D2r 3                       ; """
0016D2r 3               xt_less_number_sign:
0016D2r 3  20 rr rr                     jsr xt_pad      ; ( addr )
0016D5r 3               
0016D5r 3  B5 00                        lda 0,x
0016D7r 3  85 rr                        sta tohold
0016D9r 3  B5 01                        lda 1,x
0016DBr 3  85 rr                        sta tohold+1
0016DDr 3               
0016DDr 3  E8                           inx
0016DEr 3  E8                           inx
0016DFr 3               
0016DFr 3               z_less_number_sign:
0016DFr 3  60                           rts
0016E0r 3               
0016E0r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
0016E0r 3               ; ## "<"  auto  ANS core
0016E0r 3                       ; """https://forth-standard.org/standard/core/less"""
0016E0r 3               
0016E0r 3               xt_less_than:
0016E0r 3  20 rr rr                     jsr underflow_2
0016E3r 3               
0016E3r 3  A0 00                        ldy #0          ; default false
0016E5r 3  20 rr rr                     jsr compare_16bit
0016E8r 3               
0016E8r 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
0016E8r 3  F0 03                        beq @false
0016EAr 3  30 01                        bmi @false
0016ECr 3               
0016ECr 3                               ; true
0016ECr 3  88                           dey
0016EDr 3               @false:
0016EDr 3  98                           tya
0016EEr 3               
0016EEr 3  E8                           inx
0016EFr 3  E8                           inx
0016F0r 3  95 00                        sta 0,x
0016F2r 3  95 01                        sta 1,x
0016F4r 3               
0016F4r 3  60           z_less_than:    rts
0016F5r 3               
0016F5r 3               
0016F5r 3               
0016F5r 3               ; ## LIST ( scr# -- ) "List the given screen"
0016F5r 3               ; ## "list"  tested  ANS block ext
0016F5r 3                       ; """https://forth-standard.org/standard/block/LIST"""
0016F5r 3               
0016F5r 3               xt_list:
0016F5r 3  20 rr rr                     jsr underflow_1
0016F8r 3               
0016F8r 3                               ; Save the screen number in SCR
0016F8r 3  20 rr rr                     jsr xt_scr
0016FBr 3  20 rr rr                     jsr xt_store
0016FEr 3               
0016FEr 3                               ; Use L from the editor-wordlist to display the screen.
0016FEr 3  20 rr rr                     jsr xt_editor_l
001701r 3               
001701r 3  60           z_list:         rts
001702r 3               
001702r 3               
001702r 3               
001702r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001702r 3               ; ## "literal"  auto  ANS core
001702r 3                       ; """https://forth-standard.org/standard/core/LITERAL
001702r 3                       ; Compile-only word to store TOS so that it is pushed on stack
001702r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001702r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001702r 3                       ;
001702r 3                       ; Note the cmpl_ routines use TMPTOS
001702r 3                       ; """
001702r 3               xt_literal:
001702r 3  20 rr rr                     jsr underflow_1
001705r 3               
001705r 3  A0 rr                        ldy #>literal_runtime
001707r 3  A9 rr                        lda #<literal_runtime
001709r 3  20 rr rr                     jsr cmpl_subroutine
00170Cr 3               
00170Cr 3                               ; Compile the value that is to be pushed on the Stack during
00170Cr 3                               ; runtime
00170Cr 3  20 rr rr                     jsr xt_comma
00170Fr 3               
00170Fr 3  60           z_literal:      rts
001710r 3               
001710r 3               literal_runtime:
001710r 3               
001710r 3                               ; During runtime, we push the value following this word back
001710r 3                               ; on the Data Stack. The subroutine jump that brought us
001710r 3                               ; here put the address to return to on the Return Stack -
001710r 3                               ; this points to the data we need to get. This routine is
001710r 3                               ; also called (LITERAL) in some Forths
001710r 3  CA                           dex
001711r 3  CA                           dex
001712r 3               
001712r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001712r 3                               ; so we are actually popping the address-1 of the literal
001712r 3  68                           pla             ; LSB
001713r 3  85 rr                        sta tmp1
001715r 3  68                           pla             ; MSB
001716r 3  85 rr                        sta tmp1+1
001718r 3               
001718r 3                               ; Fetch the actual literal value and push it on Data stack
001718r 3  A0 01                        ldy #1
00171Ar 3  B1 rr                        lda (tmp1),y    ; LSB
00171Cr 3  95 00                        sta 0,x
00171Er 3  C8                           iny
00171Fr 3  B1 rr                        lda (tmp1),y    ; MSB
001721r 3  95 01                        sta 1,x
001723r 3               
001723r 3                               ; Adjust return address and push back on the Return Stack
001723r 3  98                           tya
001724r 3  18                           clc
001725r 3  65 rr                        adc tmp1
001727r 3  A8                           tay
001728r 3  A5 rr                        lda tmp1+1
00172Ar 3  69 00                        adc #0
00172Cr 3  48                           pha
00172Dr 3  5A                           phy
00172Er 3               
00172Er 3  60                           rts
00172Fr 3               
00172Fr 3               
00172Fr 3               
00172Fr 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
00172Fr 3               ; ## "load"  auto  ANS block
00172Fr 3                       ; """https://forth-standard.org/standard/block/LOAD
00172Fr 3                       ;
00172Fr 3                       ; Note: LOAD current works because there is only one buffer.
00172Fr 3                       ; If/when multiple buffers are supported, we'll have to deal
00172Fr 3                       ; with the fact that it might re-load the old block into a
00172Fr 3                       ; different buffer.
00172Fr 3                       ; """
00172Fr 3               
00172Fr 3               xt_load:
00172Fr 3  20 rr rr                     jsr underflow_1
001732r 3               
001732r 3                               ; Save the current value of BLK on the return stack.
001732r 3  A0 01                        ldy #blk_offset+1
001734r 3  B1 rr                        lda (up),y
001736r 3  48                           pha
001737r 3  88                           dey
001738r 3  B1 rr                        lda (up),y
00173Ar 3  48                           pha
00173Br 3               
00173Br 3                               ; Set BLK to the given block/screen number.
00173Br 3  B5 00                        lda 0,x
00173Dr 3  91 rr                        sta (up),y
00173Fr 3  C8                           iny
001740r 3  B5 01                        lda 1,x
001742r 3  91 rr                        sta (up),y
001744r 3               
001744r 3                               ; Load that block into a buffer
001744r 3  20 rr rr                     jsr xt_block
001747r 3               
001747r 3                               ; Put 1024 on the stack for the screen length.
001747r 3  CA                           dex
001748r 3  CA                           dex
001749r 3  A9 04                        lda #4
00174Br 3  95 01                        sta 1,x
00174Dr 3  74 00                        stz 0,x
00174Fr 3               
00174Fr 3                               ; Jump to a special evluate target. This bypasses the underflow
00174Fr 3                               ; check and skips the zeroing of BLK.
00174Fr 3  20 rr rr                     jsr load_evaluate
001752r 3               
001752r 3                               ; Restore the value of BLK from before the LOAD command.
001752r 3  A0 00                        ldy #blk_offset
001754r 3  68                           pla
001755r 3  91 rr                        sta (up),y
001757r 3  C8                           iny
001758r 3  68                           pla
001759r 3  91 rr                        sta (up),y
00175Br 3               
00175Br 3                               ; If BLK is not zero, read it back into the buffer.
00175Br 3                               ; A still has MSB
00175Br 3  88                           dey
00175Cr 3  11 rr                        ora (up),y
00175Er 3  F0 12                        beq @done
001760r 3               
001760r 3                               ; The block needs to be read back into the buffer.
001760r 3  CA                           dex
001761r 3  CA                           dex
001762r 3  A0 00                        ldy #blk_offset
001764r 3  B1 rr                        lda (up),y
001766r 3  95 00                        sta 0,x
001768r 3  C8                           iny
001769r 3  B1 rr                        lda (up),y
00176Br 3  95 01                        sta 1,x
00176Dr 3  20 rr rr                     jsr xt_block
001770r 3               
001770r 3                               ; Drop the buffer address.
001770r 3  E8                           inx
001771r 3  E8                           inx
001772r 3               
001772r 3               @done:
001772r 3  60           z_load:         rts
001773r 3               
001773r 3               
001773r 3               
001773r 3               ; ## LOOP ( -- ) "Finish loop construct"
001773r 3               ; ## "loop"  auto  ANS core
001773r 3                       ; """https://forth-standard.org/standard/core/LOOP
001773r 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001773r 3                       ; the stack and then call +LOOP.
001773r 3                       ;
001773r 3                       ; In Forth, this is
001773r 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001773r 3                       ;       IMMEDIATE ; COMPILE-ONLY
001773r 3                       ; """
001773r 3               xt_loop:
001773r 3                               ; Have the finished word push 1 on the stack
001773r 3  A0 rr                        ldy #>xt_one
001775r 3  A9 rr                        lda #<xt_one
001777r 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
00177Ar 3               
00177Ar 3               
00177Ar 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
00177Ar 3               ; ## "+loop"  auto  ANS core
00177Ar 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
00177Ar 3                       ;
00177Ar 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
00177Ar 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
00177Ar 3                       ;       COMPILE-ONLY
00177Ar 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
00177Ar 3                       ; address for looping as TOS and the address for aborting the loop
00177Ar 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
00177Ar 3                       ; DO and the Control Flow section of the manual for details).
00177Ar 3                       ; """
00177Ar 3               
00177Ar 3               xt_plus_loop:
00177Ar 3                               ; Compile the run-time part. We do this with a short loop
00177Ar 3                               ; and not a call to COMPILE, because it has to be natively
00177Ar 3                               ; coded anyway.
00177Ar 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
00177Cr 3  5A                           phy             ; save counter to adjust CP
00177Dr 3               @1:
00177Dr 3  B9 rr rr                     lda plus_loop_runtime,y
001780r 3  91 rr                        sta (cp),y
001782r 3  88                           dey
001783r 3  10 F8                        bpl @1
001785r 3               
001785r 3                               ; Adjust CP
001785r 3  68                           pla
001786r 3  18                           clc
001787r 3  65 rr                        adc cp
001789r 3  85 rr                        sta cp
00178Br 3  A5 rr                        lda cp+1
00178Dr 3  69 00                        adc #0          ; only need carry
00178Fr 3  85 rr                        sta cp+1
001791r 3               
001791r 3                               ; The address we need to loop back to is TOS. Store it so
001791r 3                               ; the runtime part of +LOOP jumps back up there
001791r 3  20 rr rr                     jsr xt_comma
001794r 3               
001794r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001794r 3                               ; of six PLA, so we just do it here instead jumping around
001794r 3                               ; all over the place
001794r 3  A9 68                        lda #$68                ; opcode for PLA
001796r 3  A0 06                        ldy #6
001798r 3               @2:
001798r 3  91 rr                        sta (cp),y
00179Ar 3  88                           dey
00179Br 3  10 FB                        bpl @2
00179Dr 3               
00179Dr 3                               ; Adjust CP
00179Dr 3  A9 06                        lda #6
00179Fr 3  18                           clc
0017A0r 3  65 rr                        adc cp
0017A2r 3  85 rr                        sta cp
0017A4r 3  A5 rr                        lda cp+1
0017A6r 3  69 00                        adc #0                  ; only need carry
0017A8r 3  85 rr                        sta cp+1
0017AAr 3               
0017AAr 3                               ; Complete compile of DO/?DO by replacing the six
0017AAr 3                               ; dummy bytes by PHA instructions. The address where
0017AAr 3                               ; they are located is on the Data Stack
0017AAr 3  B5 00                        lda 0,x
0017ACr 3  85 rr                        sta tmp1
0017AEr 3  B5 01                        lda 1,x
0017B0r 3  85 rr                        sta tmp1+1
0017B2r 3  E8                           inx
0017B3r 3  E8                           inx
0017B4r 3               
0017B4r 3                               ; Because of the way that CP works, we don't have to save
0017B4r 3                               ; CP, but CP-1
0017B4r 3  A5 rr                        lda cp
0017B6r 3  38                           sec
0017B7r 3  E9 01                        sbc #1
0017B9r 3  85 rr                        sta tmp2
0017BBr 3  A5 rr                        lda cp+1
0017BDr 3  E9 00                        sbc #0
0017BFr 3  85 rr                        sta tmp2+1
0017C1r 3               
0017C1r 3                               ; now compile this in the DO/?DO routine
0017C1r 3  A0 00                        ldy #0
0017C3r 3               
0017C3r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
0017C5r 3  91 rr                        sta (tmp1),y
0017C7r 3  C8                           iny
0017C8r 3  A5 rr                        lda tmp2+1      ; MSB
0017CAr 3  91 rr                        sta (tmp1),y
0017CCr 3  C8                           iny
0017CDr 3  A9 48                        lda #$48        ; Opcode for PHA
0017CFr 3  91 rr                        sta (tmp1),y
0017D1r 3  C8                           iny
0017D2r 3               
0017D2r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
0017D4r 3  91 rr                        sta (tmp1),y
0017D6r 3  C8                           iny
0017D7r 3  A5 rr                        lda tmp2        ; LSB
0017D9r 3  91 rr                        sta (tmp1),y
0017DBr 3  C8                           iny
0017DCr 3  A9 48                        lda #$48        ; Opcode for PHA
0017DEr 3  91 rr                        sta (tmp1),y
0017E0r 3               z_loop:
0017E0r 3  60           z_plus_loop:    rts
0017E1r 3               
0017E1r 3               
0017E1r 3               plus_loop_runtime:
0017E1r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
0017E1r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
0017E1r 3                       ; loop control so we can test with the Overflow Flag. See
0017E1r 3                       ; the Control Flow section of the manual for details.
0017E1r 3                       ; The step value is TOS in the loop. This
0017E1r 3                       ; must always be native compiled. In some Forths, this is a separate
0017E1r 3                       ; word called (+LOOP) or (LOOP)
0017E1r 3                       ; """
0017E1r 3               
0017E1r 3  18                           clc
0017E2r 3  68                           pla             ; LSB of index
0017E3r 3  75 00                        adc 0,x         ; LSB of step
0017E5r 3  A8                           tay             ; temporary storage of LSB
0017E6r 3               
0017E6r 3  B8                           clv
0017E7r 3  68                           pla             ; MSB of index
0017E8r 3  75 01                        adc 1,x         ; MSB of step
0017EAr 3  48                           pha             ; put MSB of index back on stack
0017EBr 3               
0017EBr 3  98                           tya             ; put LSB of index back on stack
0017ECr 3  48                           pha
0017EDr 3               
0017EDr 3  E8                           inx             ; dump step from TOS
0017EEr 3  E8                           inx
0017EFr 3               
0017EFr 3                               ; If V flag is set, we're done looping and continue
0017EFr 3                               ; after the +LOOP instruction
0017EFr 3  70 03                        bvs @hack+3     ; skip over JMP instruction
0017F1r 3               
0017F1r 3               @hack:          ; This is why this routine must be natively compiled: We
0017F1r 3                               ; compile the opcode for JMP here without an address to
0017F1r 3                               ; go to, which is added by the next next instruction of
0017F1r 3                               ; LOOP/+LOOP during compile time
0017F1r 3  4C                           .byte $4C
0017F2r 3               
0017F2r 3               plus_loop_runtime_end:
0017F2r 3               
0017F2r 3               
0017F2r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
0017F2r 3               ; ## "lshift"  auto  ANS core
0017F2r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
0017F2r 3               
0017F2r 3               xt_lshift:
0017F2r 3  20 rr rr                     jsr underflow_2
0017F5r 3               
0017F5r 3                               ; max shift 16 times
0017F5r 3  B5 00                        lda 0,x
0017F7r 3  29 0F                        and #%00001111
0017F9r 3  F0 08                        beq @done
0017FBr 3               
0017FBr 3  A8                           tay
0017FCr 3               
0017FCr 3               @loop:
0017FCr 3  16 02                        asl 2,x
0017FEr 3  36 03                        rol 3,x
001800r 3  88                           dey
001801r 3  D0 F9                        bne @loop
001803r 3               
001803r 3               @done:
001803r 3  E8                           inx
001804r 3  E8                           inx
001805r 3               
001805r 3  60           z_lshift:       rts
001806r 3               
001806r 3               
001806r 3               
001806r 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001806r 3               ; ## "m*"  auto  ANS core
001806r 3                       ; """https://forth-standard.org/standard/core/MTimes
001806r 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001806r 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001806r 3                       ;
001806r 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001806r 3                       ; with  : D+- O< IF DNEGATE THEN ;
001806r 3                       ; """
001806r 3               
001806r 3               xt_m_star:
001806r 3  20 rr rr                     jsr underflow_2
001809r 3               
001809r 3                               ; figure out the sign
001809r 3  B5 01                        lda 1,x         ; MSB of n1
00180Br 3  55 03                        eor 3,x         ; MSB of n2
00180Dr 3               
00180Dr 3                               ; UM* uses all kinds of temporary variables so we don't
00180Dr 3                               ; risk a conflict but just take the cycle hit and push
00180Dr 3                               ; this to the stack
00180Dr 3  48                           pha
00180Er 3               
00180Er 3                               ; get the absolute value of both numbers so we can feed
00180Er 3                               ; them to UM*, which does the real work
00180Er 3  20 rr rr                     jsr xt_abs
001811r 3  20 rr rr                     jsr xt_swap
001814r 3  20 rr rr                     jsr xt_abs
001817r 3               
001817r 3  20 rr rr                     jsr xt_um_star          ; ( d )
00181Ar 3               
00181Ar 3                               ; handle the sign
00181Ar 3  68                           pla
00181Br 3  10 03                        bpl @done
00181Dr 3               
00181Dr 3  20 rr rr                     jsr xt_dnegate
001820r 3               @done:
001820r 3  60           z_m_star:       rts
001821r 3               
001821r 3               
001821r 3               
001821r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001821r 3               ; ## "marker"  auto  ANS core ext
001821r 3                       ; """https://forth-standard.org/standard/core/MARKER
001821r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001821r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001821r 3                       ; Run the named word at a later time to restore all of the wordlists
001821r 3                       ; to their state when the word was created with marker.  Any words
001821r 3                       ; created after the marker (including the marker) will be forgotten.
001821r 3                       ;
001821r 3                       ; To do this, we want to end up with something that jumps to a
001821r 3                       ; run-time component with a link to the original CP and DP values:
001821r 3                       ;
001821r 3                       ;       jsr marker_runtime
001821r 3                       ;       <Original CP MSB>
001821r 3                       ;       <Original CP LSB>
001821r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001821r 3                       ;       <Original DP LSB>
001821r 3                       ;       < USER variables from offset 4 to 39 >
001821r 3                       ;
001821r 3                       ;       The user variables include:
001821r 3                       ;       CURRENT (byte variable)
001821r 3                       ;       <All wordlists> (currently 12) (cell array)
001821r 3                       ;       <#ORDER> (byte variable)
001821r 3                       ;       <All search order> (currently 9) (byte array)
001821r 3                       ;
001821r 3                       ; This code uses tmp1 and tmp2
001821r 3                       ; """
001821r 3               
001821r 3               xt_marker:
001821r 3                               ; Before we do anything, we need to save CP, which
001821r 3                               ; after all is the whole point of this operation. CREATE
001821r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001821r 3                               ; to the stack
001821r 3  20 rr rr                     jsr current_to_dp
001824r 3               
001824r 3  A5 rr                        lda dp
001826r 3  48                           pha
001827r 3  A5 rr                        lda dp+1
001829r 3  48                           pha
00182Ar 3               
00182Ar 3  A5 rr                        lda cp
00182Cr 3  48                           pha
00182Dr 3  A5 rr                        lda cp+1
00182Fr 3  48                           pha
001830r 3               
001830r 3  20 rr rr                     jsr xt_create
001833r 3               
001833r 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001833r 3                               ; we have to replace by a jump to marker_runtime. We back up
001833r 3                               ; two bytes and then overwrite the address
001833r 3  A5 rr                        lda cp          ; LSB
001835r 3  38                           sec
001836r 3  E9 02                        sbc #2
001838r 3  85 rr                        sta cp
00183Ar 3               
00183Ar 3  A5 rr                        lda cp+1        ; MSB
00183Cr 3  E9 00                        sbc #0          ; we only care about the borrow
00183Er 3  85 rr                        sta cp+1
001840r 3               
001840r 3                               ; Add the address of the runtime component
001840r 3  A0 rr                        ldy #>marker_runtime
001842r 3  A9 rr                        lda #<marker_runtime
001844r 3  20 rr rr                     jsr cmpl_word
001847r 3               
001847r 3                               ; Add original CP as payload
001847r 3  7A                           ply                     ; MSB
001848r 3  68                           pla                     ; LSB
001849r 3  20 rr rr                     jsr cmpl_word
00184Cr 3               
00184Cr 3                               ; Add original DP as payload
00184Cr 3  7A                           ply                     ; MSB
00184Dr 3  68                           pla                     ; LSB
00184Er 3  20 rr rr                     jsr cmpl_word
001851r 3               
001851r 3                               ; Add the user variables for the wordlists and search order.
001851r 3                               ; We're compiling them in byte order.
001851r 3  A0 04                        ldy #4                  ; Start at CURRENT
001853r 3               @marker_loop:
001853r 3  B1 rr                        lda (up),y
001855r 3  20 rr rr                     jsr cmpl_a
001858r 3  C8                           iny
001859r 3  98                           tya
00185Ar 3  C9 28                        cmp #40                 ; One past the end of the search order.
00185Cr 3  D0 F5                        bne @marker_loop
00185Er 3               
00185Er 3  60           z_marker:       rts
00185Fr 3               
00185Fr 3               
00185Fr 3               
00185Fr 3               marker_runtime:
00185Fr 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
00185Fr 3                       ; when this marker was defined. We arrive here with the return
00185Fr 3                       ; address on the Return Stack in the usual 65c02 format
00185Fr 3                       ; """
00185Fr 3               
00185Fr 3                               ; Get the address of the string address off the stack and
00185Fr 3                               ; increase by one because of the RTS mechanics
00185Fr 3  68                           pla
001860r 3  85 rr                        sta tmp1        ; LSB of address
001862r 3  68                           pla
001863r 3  85 rr                        sta tmp1+1      ; MSB of address
001865r 3               
001865r 3  E6 rr                        inc tmp1
001867r 3  D0 02                        bne @1
001869r 3  E6 rr                        inc tmp1+1
00186Br 3               @1:
00186Br 3  A0 00                        ldy #0
00186Dr 3               
00186Dr 3                               ; CP was stored first
00186Dr 3  B1 rr                        lda (tmp1),y
00186Fr 3  85 rr                        sta cp
001871r 3  C8                           iny
001872r 3  B1 rr                        lda (tmp1),y
001874r 3  85 rr                        sta cp+1
001876r 3               
001876r 3                               ; Next was DP
001876r 3  C8                           iny
001877r 3  B1 rr                        lda (tmp1),y
001879r 3  85 rr                        sta dp
00187Br 3  C8                           iny
00187Cr 3  B1 rr                        lda (tmp1),y
00187Er 3  85 rr                        sta dp+1
001880r 3               
001880r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001880r 3                               ; to start restoring the wordlists and search order.
001880r 3  A0 04                        ldy #4
001882r 3               
001882r 3               @marker_restore_loop:
001882r 3                               ; Copy from the dictionary back on top of the wordlists
001882r 3                               ; and search order.
001882r 3  B1 rr                        lda (tmp1), y
001884r 3  91 rr                        sta (up), y
001886r 3  C8                           iny
001887r 3  98                           tya
001888r 3  C9 28                        cmp #40                 ; One past the end of the search order.
00188Ar 3  D0 F6                        bne @marker_restore_loop
00188Cr 3               
00188Cr 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
00188Fr 3               
00188Fr 3                               ; The return instruction takes us back to the original caller
00188Fr 3  60                           rts
001890r 3               
001890r 3               
001890r 3               
001890r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001890r 3               ; ## "max"  auto  ANS core
001890r 3                       ; """https://forth-standard.org/standard/core/MAX
001890r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001890r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001890r 3                       ; Flag indicates which number is larger. See also
001890r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001890r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001890r 3                       ; """
001890r 3               
001890r 3               xt_max:
001890r 3  20 rr rr                     jsr underflow_2
001893r 3               
001893r 3                               ; Compare LSB. We do this first to set the carry flag
001893r 3  B5 00                        lda 0,x         ; LSB of TOS
001895r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001897r 3               
001897r 3  B5 01                        lda 1,x         ; MSB of TOS
001899r 3  F5 03                        sbc 3,x         ; MSB of NOS
00189Br 3  50 02                        bvc @no_overflow
00189Dr 3               
00189Dr 3                               ; handle overflow, because we use signed numbers
00189Dr 3  49 80                        eor #$80        ; complement negative flag
00189Fr 3               
00189Fr 3               @no_overflow:
00189Fr 3                               ; if negative, NOS is larger and needs to be kept
00189Fr 3  30 08                        bmi @keep_nos
0018A1r 3               
0018A1r 3                               ; move TOS to NOS
0018A1r 3  B5 00                        lda 0,x
0018A3r 3  95 02                        sta 2,x
0018A5r 3  B5 01                        lda 1,x
0018A7r 3  95 03                        sta 3,x
0018A9r 3               
0018A9r 3               @keep_nos:
0018A9r 3  E8                           inx
0018AAr 3  E8                           inx
0018ABr 3               
0018ABr 3  60           z_max:          rts
0018ACr 3               
0018ACr 3               
0018ACr 3               
0018ACr 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
0018ACr 3               ; ## "min"  auto  ANS core
0018ACr 3                       ; """https://forth-standard.org/standard/core/MIN
0018ACr 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
0018ACr 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
0018ACr 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
0018ACr 3                       ; """
0018ACr 3               
0018ACr 3               xt_min:
0018ACr 3  20 rr rr                     jsr underflow_2
0018AFr 3               
0018AFr 3                               ; compare LSB. We do this first to set the carry flag
0018AFr 3  B5 00                        lda 0,x         ; LSB of TOS
0018B1r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
0018B3r 3               
0018B3r 3  B5 01                        lda 1,x         ; MSB of TOS
0018B5r 3  F5 03                        sbc 3,x         ; MSB of NOS
0018B7r 3  50 02                        bvc @no_overflow
0018B9r 3               
0018B9r 3                               ; handle overflow because we use signed numbers
0018B9r 3  49 80                        eor #$80
0018BBr 3               
0018BBr 3               @no_overflow:
0018BBr 3                               ; if negative, NOS is larger and needs to be dumped
0018BBr 3  10 08                        bpl @keep_nos
0018BDr 3               
0018BDr 3                               ; move TOS to NOS
0018BDr 3  B5 00                        lda 0,x
0018BFr 3  95 02                        sta 2,x
0018C1r 3  B5 01                        lda 1,x
0018C3r 3  95 03                        sta 3,x
0018C5r 3               
0018C5r 3               @keep_nos:
0018C5r 3  E8                           inx
0018C6r 3  E8                           inx
0018C7r 3               
0018C7r 3  60           z_min:          rts
0018C8r 3               
0018C8r 3               
0018C8r 3               
0018C8r 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
0018C8r 3               ; ## "-"  auto  ANS core
0018C8r 3                       ; """https://forth-standard.org/standard/core/Minus"""
0018C8r 3               xt_minus:
0018C8r 3  20 rr rr                     jsr underflow_2
0018CBr 3               
0018CBr 3  38                           sec
0018CCr 3  B5 02                        lda 2,x         ; LSB
0018CEr 3  F5 00                        sbc 0,x
0018D0r 3  95 02                        sta 2,x
0018D2r 3               
0018D2r 3  B5 03                        lda 3,x         ; MSB
0018D4r 3  F5 01                        sbc 1,x
0018D6r 3  95 03                        sta 3,x
0018D8r 3               
0018D8r 3  E8                           inx
0018D9r 3  E8                           inx
0018DAr 3               
0018DAr 3  60           z_minus:        rts
0018DBr 3               
0018DBr 3               
0018DBr 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
0018DBr 3               ; ## "-leading"  auto  Tali String
0018DBr 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
0018DBr 3                       ; """
0018DBr 3               
0018DBr 3               xt_minus_leading:
0018DBr 3  20 rr rr                     jsr underflow_2
0018DEr 3               
0018DEr 3               @loop:
0018DEr 3                               ; Quit if we were given an empty string. This also terminates
0018DEr 3                               ; the main loop
0018DEr 3  B5 00                        lda 0,x
0018E0r 3  15 01                        ora 1,x
0018E2r 3  F0 0F                        beq @done
0018E4r 3               
0018E4r 3  A1 02                        lda (2,x)               ; get first character
0018E6r 3  20 rr rr                     jsr is_whitespace
0018E9r 3  90 08                        bcc @done
0018EBr 3               
0018EBr 3                               ; It's whitespace, move one down
0018EBr 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
0018EEr 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
0018F1r 3               
0018F1r 3  80 EB                        bra @loop
0018F3r 3               @done:
0018F3r 3               z_minus_leading:
0018F3r 3  60                           rts
0018F4r 3               
0018F4r 3               
0018F4r 3               
0018F4r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
0018F4r 3               ; ## "-trailing"  auto  ANS string
0018F4r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
0018F4r 3                       ; Remove trailing spaces
0018F4r 3                       ; """
0018F4r 3               
0018F4r 3               xt_minus_trailing:
0018F4r 3  20 rr rr                     jsr underflow_2
0018F7r 3               
0018F7r 3                               ; if length entry is zero, return a zero and leave the
0018F7r 3                               ; address part untouched
0018F7r 3  B5 00                        lda 0,x         ; LSB of n
0018F9r 3  15 01                        ora 1,x         ; MSB of n
0018FBr 3  F0 33                        beq @done
0018FDr 3               
0018FDr 3                               ; Compute address of last char in tmp1 as
0018FDr 3                               ; addr + u1 - 1
0018FDr 3               
0018FDr 3                               ; addr + u1
0018FDr 3  18                           clc
0018FEr 3  B5 02                        lda 2,x         ; LSB of addr
001900r 3  75 00                        adc 0,x
001902r 3  85 rr                        sta tmp1
001904r 3  B5 03                        lda 3,x         ; MSB of addr
001906r 3  75 01                        adc 1,x
001908r 3  85 rr                        sta tmp1+1
00190Ar 3               
00190Ar 3                               ; - 1
00190Ar 3  A5 rr                        lda tmp1
00190Cr 3  D0 02                        bne @1
00190Er 3  C6 rr                        dec tmp1+1
001910r 3               @1:
001910r 3  C6 rr                        dec tmp1
001912r 3               
001912r 3               @loop:
001912r 3                               ; While spaces are found, move tmp1 backwards and
001912r 3                               ; decrease the count on the data stack.
001912r 3  B2 rr                        lda (tmp1)
001914r 3  C9 20                        cmp #AscSP
001916r 3  D0 18                        bne @done
001918r 3               
001918r 3                               ; Move back one address.
001918r 3  A5 rr                        lda tmp1
00191Ar 3  D0 02                        bne @2
00191Cr 3  C6 rr                        dec tmp1+1
00191Er 3               @2:
00191Er 3  C6 rr                        dec tmp1
001920r 3               
001920r 3                               ; Decrement count by one.
001920r 3  B5 00                        lda 0,x
001922r 3  D0 02                        bne @3
001924r 3  D6 01                        dec 1,x
001926r 3               @3:
001926r 3  D6 00                        dec 0,x
001928r 3               
001928r 3                               ; Check if there are any characters left.
001928r 3  B5 00                        lda 0,x
00192Ar 3  15 01                        ora 1,x
00192Cr 3  F0 02                        beq @done       ; Count has reached zero - we're done!
00192Er 3               
00192Er 3  80 E2                        bra @loop
001930r 3               
001930r 3               @done:
001930r 3               z_minus_trailing:
001930r 3  60                           rts
001931r 3               
001931r 3               
001931r 3               
001931r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001931r 3               ; ## "mod"  auto  ANS core
001931r 3                       ; """https://forth-standard.org/standard/core/MOD
001931r 3                       ;
001931r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001931r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001931r 3                       ; """
001931r 3               xt_mod:
001931r 3  20 rr rr                     jsr underflow_2
001934r 3               
001934r 3  20 rr rr                     jsr xt_slash_mod
001937r 3               
001937r 3  E8                           inx             ; DROP
001938r 3  E8                           inx
001939r 3               z_mod:
001939r 3  60                           rts
00193Ar 3               
00193Ar 3               
00193Ar 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
00193Ar 3               ; ## "move"  auto  ANS core
00193Ar 3                       ; """https://forth-standard.org/standard/core/MOVE
00193Ar 3                       ; Copy u "address units" from addr1 to addr2. Since our address
00193Ar 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
00193Ar 3                       ; is actually the only one of these three words that is in the CORE
00193Ar 3                       ; set.
00193Ar 3                       ;
00193Ar 3                       ; This word must not be natively compiled.
00193Ar 3                       ; """
00193Ar 3               
00193Ar 3               xt_move:
00193Ar 3                               ; We let CMOVE and CMOVE> check if there is underflow or
00193Ar 3                               ; we've been told to copy zero bytes
00193Ar 3               
00193Ar 3                               ; compare MSB first
00193Ar 3  B5 03                        lda 3,x                 ; MSB of addr2
00193Cr 3  D5 05                        cmp 5,x                 ; MSB of addr1
00193Er 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001940r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001942r 3               
001942r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001945r 3               
001945r 3               @lsb:
001945r 3                               ; MSB were equal, so do the whole thing over with LSB
001945r 3  B5 02                        lda 2,x                 ; LSB of addr2
001947r 3  D5 04                        cmp 4,x                 ; LSB of addr1
001949r 3  F0 08                        beq @equal              ; LSB is equal as well
00194Br 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
00194Dr 3               
00194Dr 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001950r 3               
001950r 3               @to_move_up:
001950r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
001953r 3               @equal:
001953r 3                               ; drop three entries from Data Stack
001953r 3  8A                           txa
001954r 3  18                           clc
001955r 3  69 06                        adc #6
001957r 3  AA                           tax
001958r 3               
001958r 3  60           z_move:         rts
001959r 3               
001959r 3               
001959r 3               
001959r 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
001959r 3               ; ## "name>int"  tested  Gforth
001959r 3                       ; """See
001959r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001959r 3                       ; """
001959r 3               
001959r 3               xt_name_to_int:
001959r 3  20 rr rr                     jsr underflow_1
00195Cr 3               
00195Cr 3                               ; The xt starts four bytes down from the nt
00195Cr 3  B5 00                        lda 0,x
00195Er 3  18                           clc
00195Fr 3  69 04                        adc #4
001961r 3  85 rr                        sta tmp3
001963r 3               
001963r 3  B5 01                        lda 1,x
001965r 3  90 01                        bcc @done
001967r 3  1A                           inc
001968r 3               @done:
001968r 3  85 rr                        sta tmp3+1
00196Ar 3               
00196Ar 3  A0 00                        ldy #0
00196Cr 3  B1 rr                        lda (tmp3),y
00196Er 3  95 00                        sta 0,x
001970r 3  C8                           iny
001971r 3  B1 rr                        lda (tmp3),y
001973r 3  95 01                        sta 1,x
001975r 3               
001975r 3  60           z_name_to_int:  rts
001976r 3               
001976r 3               
001976r 3               
001976r 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
001976r 3               ; ## "name>string"  tested  Gforth
001976r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
001976r 3               
001976r 3               xt_name_to_string:
001976r 3  20 rr rr                     jsr underflow_1
001979r 3               
001979r 3  CA                           dex
00197Ar 3  CA                           dex
00197Br 3               
00197Br 3                               ; the length of the string is the first byte of the
00197Br 3                               ; header pointed to by nt
00197Br 3  A1 02                        lda (2,x)
00197Dr 3  95 00                        sta 0,x
00197Fr 3  74 01                        stz 1,x
001981r 3               
001981r 3                               ; the string itself always starts eight bytes down
001981r 3  B5 02                        lda 2,x         ; LSB
001983r 3  18                           clc
001984r 3  69 08                        adc #8
001986r 3  A8                           tay
001987r 3  B5 03                        lda 3,x         ; MSB
001989r 3  69 00                        adc #0          ; just need carry
00198Br 3  95 03                        sta 3,x
00198Dr 3  94 02                        sty 2,x
00198Fr 3               
00198Fr 3               z_name_to_string:
00198Fr 3  60                           rts
001990r 3               
001990r 3               
001990r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001990r 3               ; ## "nc-limit"  tested  Tali Forth
001990r 3               
001990r 3               xt_nc_limit:
001990r 3  CA                           dex
001991r 3  CA                           dex
001992r 3  A9 rr                        lda #<nc_limit
001994r 3  95 00                        sta 0,x
001996r 3  A9 rr                        lda #>nc_limit
001998r 3  95 01                        sta 1,x
00199Ar 3               
00199Ar 3  60           z_nc_limit:     rts
00199Br 3               
00199Br 3               
00199Br 3               
00199Br 3               ; ## NEGATE ( n -- n ) "Two's complement"
00199Br 3               ; ## "negate"  auto  ANS core
00199Br 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
00199Br 3               xt_negate:
00199Br 3  20 rr rr                     jsr underflow_1
00199Er 3               
00199Er 3  A9 00                	lda #0
0019A0r 3  38                           sec
0019A1r 3  F5 00                        sbc 0,x         ; LSB
0019A3r 3  95 00                        sta 0,x
0019A5r 3               
0019A5r 3  A9 00                        lda #0
0019A7r 3  F5 01                        sbc 1,x         ; MSB
0019A9r 3  95 01                        sta 1,x
0019ABr 3               
0019ABr 3  60           z_negate:       rts
0019ACr 3               
0019ACr 3               
0019ACr 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
0019ACr 3               ; ## "never-native"  auto  Tali Forth
0019ACr 3               xt_never_native:
0019ACr 3  20 rr rr                     jsr current_to_dp
0019AFr 3  A0 01                        ldy #1          ; offset for status byte
0019B1r 3  B1 rr                        lda (dp),y
0019B3r 3  09 08                        ora #NN         ; Make sure NN flag is set
0019B5r 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
0019B7r 3  91 rr                        sta (dp),y
0019B9r 3               z_never_native:
0019B9r 3  60                           rts
0019BAr 3               
0019BAr 3               
0019BAr 3               ; ## NIP ( b a -- a ) "Delete NOS"
0019BAr 3               ; ## "nip"  auto  ANS core ext
0019BAr 3                       ; """https://forth-standard.org/standard/core/NIP"""
0019BAr 3               xt_nip:
0019BAr 3  20 rr rr                     jsr underflow_2
0019BDr 3               
0019BDr 3  B5 00                        lda 0,x         ; LSB
0019BFr 3  95 02                        sta 2,x
0019C1r 3  B5 01                        lda 1,x         ; MSB
0019C3r 3  95 03                        sta 3,x
0019C5r 3               
0019C5r 3  E8                           inx
0019C6r 3  E8                           inx
0019C7r 3               
0019C7r 3  60           z_nip:          rts
0019C8r 3               
0019C8r 3               
0019C8r 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
0019C8r 3               ; ## "<>"  auto  ANS core ext
0019C8r 3                       ; """https://forth-standard.org/standard/core/ne
0019C8r 3                       ;
0019C8r 3                       ; This is just a variant of EQUAL, we code it separately
0019C8r 3                       ; for speed.
0019C8r 3                       ; """
0019C8r 3               
0019C8r 3               xt_not_equals:
0019C8r 3  20 rr rr                     jsr underflow_2
0019CBr 3               
0019CBr 3  A0 00                        ldy #0                  ; default is true
0019CDr 3               
0019CDr 3  B5 00                        lda 0,x                 ; LSB
0019CFr 3  D5 02                        cmp 2,x
0019D1r 3  D0 0A                        bne @not_equal
0019D3r 3               
0019D3r 3                               ; LSB is equal
0019D3r 3  B5 01                        lda 1,x                 ; MSB
0019D5r 3  D5 03                        cmp 3,x
0019D7r 3  D0 04                        bne @not_equal
0019D9r 3               
0019D9r 3  A9 FF                        lda #$FF
0019DBr 3  80 01                        bra @done
0019DDr 3               
0019DDr 3               @not_equal:
0019DDr 3  88                           dey                     ; drop thru to done
0019DEr 3               
0019DEr 3               @done:
0019DEr 3  98                           tya
0019DFr 3  E8                           inx
0019E0r 3  E8                           inx
0019E1r 3  95 00                        sta 0,x
0019E3r 3  95 01                        sta 1,x
0019E5r 3               
0019E5r 3  60           z_not_equals:   rts
0019E6r 3               
0019E6r 3               
0019E6r 3               
0019E6r 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
0019E6r 3               ; ## "-rot"  auto  Gforth
0019E6r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
0019E6r 3               
0019E6r 3               xt_not_rote:
0019E6r 3  20 rr rr                     jsr underflow_3
0019E9r 3               
0019E9r 3  B4 01                        ldy 1,x         ; MSB first
0019EBr 3  B5 03                        lda 3,x
0019EDr 3  95 01                        sta 1,x
0019EFr 3               
0019EFr 3  B5 05                        lda 5,x
0019F1r 3  95 03                        sta 3,x
0019F3r 3  94 05                        sty 5,x
0019F5r 3               
0019F5r 3  B4 00                        ldy 0,x         ; LSB second
0019F7r 3  B5 02                        lda 2,x
0019F9r 3  95 00                        sta 0,x
0019FBr 3               
0019FBr 3  B5 04                        lda 4,x
0019FDr 3  95 02                        sta 2,x
0019FFr 3  94 04                        sty 4,x
001A01r 3               
001A01r 3  60           z_not_rote:     rts
001A02r 3               
001A02r 3               
001A02r 3               
001A02r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001A02r 3               ; ## "number"  auto  Tali Forth
001A02r 3                       ; """Convert a number string to a double or single cell number. This
001A02r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001A02r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001A02r 3                       ; Based in part on the "Starting Forth" code
001A02r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001A02r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001A02r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001A02r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001A02r 3                       ; dot to signal a double cell number is required to be the last
001A02r 3                       ; character of the string.
001A02r 3                       ;
001A02r 3                       ; Number calls >NUMBER which in turn calls UM*,
001A02r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001A02r 3                       ; a pain.
001A02r 3                       ;"""
001A02r 3               
001A02r 3               xt_number:
001A02r 3  20 rr rr                     jsr underflow_2
001A05r 3               
001A05r 3                               ; we keep the flags for sign and double in tmpdsp because
001A05r 3                               ; we've run out of temporary variables
001A05r 3  64 rr                        stz tmpdsp      ; flag for double
001A07r 3  64 rr                        stz tmpdsp+1    ; flag for minus
001A09r 3               
001A09r 3                               ; If the first character is a minus, strip it off and set
001A09r 3                               ; the flag
001A09r 3  A1 02                        lda (2,x)
001A0Br 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001A0Dr 3  D0 0A                        bne @check_dot
001A0Fr 3               
001A0Fr 3                               ; It's a minus
001A0Fr 3  C6 rr                        dec tmpdsp+1
001A11r 3  F6 02                        inc 2,x         ; start one character later
001A13r 3  D0 02                        bne @1
001A15r 3  F6 03                        inc 3,x
001A17r 3               @1:
001A17r 3  D6 00                        dec 0,x         ; decrease string length by one
001A19r 3               
001A19r 3               @check_dot:
001A19r 3                               ; If the last character is a dot, strip it off and set a
001A19r 3                               ; flag. We can use tmptos as a temporary variable
001A19r 3  B5 02                        lda 2,x         ; LSB of address
001A1Br 3  18                           clc
001A1Cr 3  75 00                        adc 0,x         ; length of string
001A1Er 3  85 rr                        sta tmptos
001A20r 3  B5 03                        lda 3,x
001A22r 3  69 00                        adc #0          ; only need carry
001A24r 3  85 rr                        sta tmptos+1
001A26r 3               
001A26r 3                               ; tmptos now points to the first character after the string,
001A26r 3                               ; but we need the last character
001A26r 3  A5 rr                        lda tmptos
001A28r 3  D0 02                        bne @2
001A2Ar 3  C6 rr                        dec tmptos+1
001A2Cr 3               @2:
001A2Cr 3  C6 rr                        dec tmptos
001A2Er 3               
001A2Er 3  B2 rr                        lda (tmptos)
001A30r 3  C9 2E                        cmp #'.'
001A32r 3  D0 04                        bne @main
001A34r 3               
001A34r 3                               ; We have a dot, which means this is a double number. Flag
001A34r 3                               ; the fact and reduce string length by one
001A34r 3  C6 rr                        dec tmpdsp
001A36r 3  D6 00                        dec 0,x
001A38r 3               
001A38r 3               @main:
001A38r 3                               ; Set up stack for subroutine jump to >NUMBER, which means
001A38r 3                               ; we have to go ( addr u --> ud addr u )
001A38r 3  CA                           dex
001A39r 3  CA                           dex
001A3Ar 3  CA                           dex
001A3Br 3  CA                           dex
001A3Cr 3               
001A3Cr 3  B5 04                        lda 4,x         ; LSB of length
001A3Er 3  95 00                        sta 0,x
001A40r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
001A42r 3               
001A42r 3  B5 06                        lda 6,x         ; LSB of address
001A44r 3  95 02                        sta 2,x
001A46r 3  B5 07                        lda 7,x         ; MSB of address
001A48r 3  95 03                        sta 3,x
001A4Ar 3               
001A4Ar 3  74 04                        stz 4,x         ; clear space for ud
001A4Cr 3  74 05                        stz 5,x
001A4Er 3  74 06                        stz 6,x
001A50r 3  74 07                        stz 7,x
001A52r 3               
001A52r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
001A55r 3               
001A55r 3                               ; test length of returned string, which should be zero
001A55r 3  B5 00                        lda 0,x
001A57r 3  F0 15                        beq @all_converted
001A59r 3               
001A59r 3                               ; Something went wrong, we still have characters left over,
001A59r 3                               ; so we print an error and abort. If the NUMBER was called
001A59r 3                               ; by INTERPRET, we've already checked for Forth words, so
001A59r 3                               ; we're in deep trouble one way or another
001A59r 3  A9 3E                        lda #$3E        ; ASCII for ">"
001A5Br 3  20 rr rr                     jsr emit_a
001A5Er 3  20 rr rr                     jsr xt_type
001A61r 3  A9 3C                        lda #$3C        ; ASCII for "<"
001A63r 3  20 rr rr                     jsr emit_a
001A66r 3  20 rr rr                     jsr xt_space
001A69r 3               
001A69r 3  A9 08                        lda #err_syntax
001A6Br 3  4C rr rr                     jmp error
001A6Er 3               
001A6Er 3               @all_converted:
001A6Er 3                               ; We can drop the string info
001A6Er 3  E8                           inx
001A6Fr 3  E8                           inx
001A70r 3  E8                           inx
001A71r 3  E8                           inx
001A72r 3               
001A72r 3                               ; We have a double-cell number on the Data Stack that might
001A72r 3                               ; actually have a minus and might actually be single-cell
001A72r 3  A5 rr                        lda tmpdsp      ; flag for double
001A74r 3  F0 0D                        beq @single
001A76r 3               
001A76r 3                               ; Set status bit 5 to indicate this is a double number
001A76r 3  A9 20                        lda #%00100000
001A78r 3  04 rr                        tsb status
001A7Ar 3               
001A7Ar 3                               ; This is a double cell number. If it had a minus, we'll have
001A7Ar 3                               ; to negate it
001A7Ar 3  A5 rr                        lda tmpdsp+1
001A7Cr 3  F0 12                        beq @done       ; no minus, all done
001A7Er 3               
001A7Er 3  20 rr rr                     jsr xt_dnegate
001A81r 3               
001A81r 3  80 0D                        bra @done
001A83r 3               
001A83r 3               @single:
001A83r 3                               ; This is a single number, so we just drop the top cell
001A83r 3  E8                           inx
001A84r 3  E8                           inx
001A85r 3               
001A85r 3                               ; Clear status bit 5 to indicate this is a single number
001A85r 3  A9 20                        lda #%00100000
001A87r 3  14 rr                        trb status
001A89r 3               
001A89r 3                               ; If we had a minus, we'll have to negate it
001A89r 3  A5 rr                        lda tmpdsp+1
001A8Br 3  F0 03                        beq @done       ; no minus, all done
001A8Dr 3               
001A8Dr 3  20 rr rr                     jsr xt_negate
001A90r 3               @done:
001A90r 3  60           z_number:       rts
001A91r 3               
001A91r 3               
001A91r 3               
001A91r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001A91r 3               ; ## "#"  auto  ANS core
001A91r 3                       ; """https://forth-standard.org/standard/core/num
001A91r 3                       ; Add one char to the beginning of the pictured output string.
001A91r 3                       ;
001A91r 3                       ; Based on
001A91r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001A91r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001A91r 3                       ; """
001A91r 3               xt_number_sign:
001A91r 3  20 rr rr                     jsr underflow_2         ; double number
001A94r 3               
001A94r 3  20 rr rr                     jsr xt_base
001A97r 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
001A9Ar 3               
001A9Ar 3                               ; The following code is the ancient Forth word UD/MOD, which in
001A9Ar 3                               ; various Forths (including Gforth) lives on under the hood,
001A9Ar 3                               ; even though it's not an ANS standard word, it doesn't appear
001A9Ar 3                               ; in the docs, it's only used here, and there are no tests for
001A9Ar 3                               ; it. This is why we got rid of it. We'll be converting this
001A9Ar 3                               ; mess to something more sane in the long run.
001A9Ar 3  20 rr rr                     jsr xt_to_r             ; >r
001A9Dr 3  20 rr rr                     jsr xt_zero             ; 0
001AA0r 3  20 rr rr                     jsr xt_r_fetch          ; r@
001AA3r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001AA6r 3  20 rr rr                     jsr xt_rot              ; rot
001AA9r 3  20 rr rr                     jsr xt_rot              ; rot
001AACr 3  20 rr rr                     jsr xt_r_from           ; r>
001AAFr 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001AB2r 3  20 rr rr                     jsr xt_rot              ; rot
001AB5r 3                               ; end of UD/MOD ( rem ud )
001AB5r 3               
001AB5r 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
001AB8r 3               
001AB8r 3                               ; Convert the number that is left over to an ASCII character. We
001AB8r 3                               ; use a string lookup for speed. Use either abc_str_lower for
001AB8r 3                               ; lower case or abc_str_upper for upper case (prefered)
001AB8r 3  B5 00                        lda 0,x
001ABAr 3  A8                           tay
001ABBr 3  B9 rr rr                     lda s_abc_upper,y
001ABEr 3  95 00                        sta 0,x
001AC0r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
001AC2r 3               
001AC2r 3  20 rr rr                     jsr xt_hold
001AC5r 3               
001AC5r 3               z_number_sign:
001AC5r 3  60                           rts
001AC6r 3               
001AC6r 3               
001AC6r 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
001AC6r 3               ; ## "#>"  auto  ANS core
001AC6r 3                       ; """https://forth-standard.org/standard/core/num-end
001AC6r 3                       ; Finish conversion of pictured number string, putting address and
001AC6r 3                       ; length on the Data Stack.
001AC6r 3                       ;
001AC6r 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
001AC6r 3                       ; Based on
001AC6r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001AC6r 3                       ; """
001AC6r 3               xt_number_sign_greater:
001AC6r 3               
001AC6r 3  20 rr rr                     jsr underflow_2         ; double number
001AC9r 3               
001AC9r 3                               ; The start address lives in tohold
001AC9r 3  A5 rr                        lda tohold
001ACBr 3  95 00                        sta 0,x         ; LSB of tohold
001ACDr 3  95 02                        sta 2,x
001ACFr 3  A5 rr                        lda tohold+1
001AD1r 3  95 01                        sta 1,x         ; MSB of addr
001AD3r 3  95 03                        sta 3,x         ; ( addr addr )
001AD5r 3               
001AD5r 3                               ; The length of the string is pad - addr
001AD5r 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
001AD8r 3               
001AD8r 3  38                           sec
001AD9r 3  B5 00                        lda 0,x         ; LSB of pad address
001ADBr 3  F5 02                        sbc 2,x
001ADDr 3  95 02                        sta 2,x
001ADFr 3               
001ADFr 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001AE1r 3  F5 03                        sbc 3,x
001AE3r 3  95 03                        sta 3,x         ; ( addr u pad )
001AE5r 3               
001AE5r 3  E8                           inx
001AE6r 3  E8                           inx
001AE7r 3               
001AE7r 3               z_number_sign_greater:
001AE7r 3  60                           rts
001AE8r 3               
001AE8r 3               
001AE8r 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
001AE8r 3               ; ## "#s"  auto  ANS core
001AE8r 3                       ; """https://forth-standard.org/standard/core/numS
001AE8r 3                       ; Completely convert number for pictured numerical output.
001AE8r 3                       ;
001AE8r 3                       ; Based on
001AE8r 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
001AE8r 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
001AE8r 3                       ; """
001AE8r 3               
001AE8r 3               xt_number_sign_s:
001AE8r 3  20 rr rr                     jsr underflow_2
001AEBr 3               @loop:
001AEBr 3                               ; convert a single number ("#")
001AEBr 3  20 rr rr                     jsr xt_number_sign
001AEEr 3               
001AEEr 3                               ; stop when double-celled number in TOS is zero:
001AEEr 3  B5 00                        lda 0,x
001AF0r 3  15 01                        ora 1,x
001AF2r 3  15 02                        ora 2,x
001AF4r 3  15 03                        ora 3,x
001AF6r 3  D0 F3                        bne @loop
001AF8r 3               
001AF8r 3               z_number_sign_s:
001AF8r 3  60                           rts
001AF9r 3               
001AF9r 3               
001AF9r 3               
001AF9r 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
001AF9r 3               ; ## "of"  auto  ANS core ext
001AF9r 3                       ; """http://forth-standard.org/standard/core/OF"""
001AF9r 3               
001AF9r 3               xt_of:
001AF9r 3                               ; Check if value is equal to this case.
001AF9r 3                               ; Postpone over (eg. compile a jsr to it)
001AF9r 3  A0 rr                        ldy #>xt_over
001AFBr 3  A9 rr                        lda #<xt_over
001AFDr 3  20 rr rr                     jsr cmpl_subroutine
001B00r 3               
001B00r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001B00r 3  A0 rr                        ldy #>xt_equal
001B02r 3  A9 rr                        lda #<xt_equal
001B04r 3  20 rr rr                     jsr cmpl_subroutine
001B07r 3               
001B07r 3  20 rr rr                     jsr xt_if
001B0Ar 3               
001B0Ar 3                               ; If it's true, consume the original value.
001B0Ar 3                               ; Postpone DROP (eg. compile a jsr to it)
001B0Ar 3  A0 rr                        ldy #>xt_drop
001B0Cr 3  A9 rr                        lda #<xt_drop
001B0Er 3  20 rr rr                     jsr cmpl_subroutine
001B11r 3               
001B11r 3  60           z_of:           rts
001B12r 3               
001B12r 3               
001B12r 3               
001B12r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
001B12r 3               ; ## "1"  auto  Tali Forth
001B12r 3                       ; """This is also the code for EDITOR-WORDLIST"""
001B12r 3               xt_editor_wordlist:
001B12r 3               xt_one:
001B12r 3  CA                           dex
001B13r 3  CA                           dex
001B14r 3  A9 01                        lda #1
001B16r 3  95 00                        sta 0,x
001B18r 3  74 01                        stz 1,x
001B1Ar 3               
001B1Ar 3               z_editor_wordlist:
001B1Ar 3               z_one:
001B1Ar 3  60                           rts
001B1Br 3               
001B1Br 3               
001B1Br 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001B1Br 3               ; ## "1-"  auto  ANS core
001B1Br 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001B1Br 3               
001B1Br 3               xt_one_minus:
001B1Br 3  20 rr rr                     jsr underflow_1
001B1Er 3               
001B1Er 3  B5 00                        lda 0,x
001B20r 3  D0 02                        bne @1
001B22r 3  D6 01                        dec 1,x
001B24r 3               @1:
001B24r 3  D6 00                        dec 0,x
001B26r 3               
001B26r 3  60           z_one_minus:    rts
001B27r 3               
001B27r 3               
001B27r 3               
001B27r 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
001B27r 3               ; ## "1+"  auto  ANS core
001B27r 3                       ; """https://forth-standard.org/standard/core/OnePlus
001B27r 3                       ;
001B27r 3                       ; Code is shared with CHAR-PLUS
001B27r 3                       ; """
001B27r 3               
001B27r 3               xt_char_plus:
001B27r 3               xt_one_plus:
001B27r 3  20 rr rr                     jsr underflow_1
001B2Ar 3               
001B2Ar 3  F6 00                        inc 0,x
001B2Cr 3  D0 02                        bne @done
001B2Er 3  F6 01                        inc 1,x
001B30r 3               
001B30r 3               @done:
001B30r 3               z_char_plus:
001B30r 3  60           z_one_plus:     rts
001B31r 3               
001B31r 3               
001B31r 3               
001B31r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
001B31r 3               ; ## "only"  auto  ANS search ext
001B31r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
001B31r 3               
001B31r 3               xt_only:
001B31r 3                               ; Put -1 on data stack.
001B31r 3  CA                           dex
001B32r 3  CA                           dex
001B33r 3  A9 FF                        lda #$FF
001B35r 3  95 00                        sta 0,x
001B37r 3  95 01                        sta 1,x
001B39r 3               
001B39r 3                               ; Invoke set-order to set the minimum search order.
001B39r 3  20 rr rr                     jsr xt_set_order
001B3Cr 3               
001B3Cr 3  60           z_only:         rts
001B3Dr 3               
001B3Dr 3               
001B3Dr 3               
001B3Dr 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
001B3Dr 3               ; ## "or"  auto  ANS core
001B3Dr 3                       ; """https://forth-standard.org/standard/core/OR"
001B3Dr 3               xt_or:
001B3Dr 3  20 rr rr                     jsr underflow_2
001B40r 3               
001B40r 3  B5 00                        lda 0,x
001B42r 3  15 02                        ora 2,x
001B44r 3  95 02                        sta 2,x
001B46r 3               
001B46r 3  B5 01                        lda 1,x
001B48r 3  15 03                        ora 3,x
001B4Ar 3  95 03                        sta 3,x
001B4Cr 3               
001B4Cr 3  E8                           inx
001B4Dr 3  E8                           inx
001B4Er 3               
001B4Er 3  60           z_or:           rts
001B4Fr 3               
001B4Fr 3               
001B4Fr 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
001B4Fr 3               ; ## "order"  auto  ANS core
001B4Fr 3                       ; """https://forth-standard.org/standard/search/ORDER
001B4Fr 3                       ; Note the search order is displayed from first search to last
001B4Fr 3                       ; searched and is therefore exactly the reverse of the order in which
001B4Fr 3                       ; Forth stacks are displayed.
001B4Fr 3                       ;
001B4Fr 3                       ; A Forth implementation of this word is:
001B4Fr 3                       ;
001B4Fr 3                       ; 	: .wid ( wid -- )
001B4Fr 3                       ; 	dup 0=  if ." Forth "  drop    else
001B4Fr 3                       ; 	dup 1 = if ." Editor " drop    else
001B4Fr 3                       ; 	dup 2 = if ." Assembler " drop else
001B4Fr 3                       ; 	dup 3 = if ." Root " drop      else
001B4Fr 3                       ; 	           . ( just print the number )
001B4Fr 3                       ; 	then then then then ;
001B4Fr 3                       ;
001B4Fr 3                       ; : ORDER ( -- )
001B4Fr 3                       ; 	cr get-order 0 ?do .wid loop
001B4Fr 3                       ; 	space space get-current .wid ;
001B4Fr 3                       ;
001B4Fr 3                       ; This is an interactive program, so speed
001B4Fr 3                       ; is not as important as size. We assume we do not have more than 255
001B4Fr 3                       ; wordlists.
001B4Fr 3                       ; """
001B4Fr 3               
001B4Fr 3               xt_order:
001B4Fr 3  20 rr rr                     jsr xt_cr
001B52r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
001B55r 3               
001B55r 3                               ; Paranoid: Check if there are no wordlists, a rather
001B55r 3                               ; pathological case. this would mean ( 0 ) on the stack. In
001B55r 3                               ; that case, we just drop n and run
001B55r 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
001B57r 3  F0 1E                        beq @drop_done
001B59r 3               
001B59r 3               @have_wordlists:
001B59r 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
001B59r 3                               ; on the stack
001B59r 3  A8                           tay
001B5Ar 3               @loop:
001B5Ar 3  E8                           inx
001B5Br 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
001B5Cr 3  B5 00                        lda 0,x
001B5Er 3               
001B5Er 3  5A                           phy
001B5Fr 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
001B62r 3  7A                           ply
001B63r 3               
001B63r 3  88                           dey
001B64r 3  D0 F4                        bne @loop
001B66r 3               
001B66r 3                               ; We've printed the wordlists, now we add the current wordlist.
001B66r 3                               ; This follows the convention of Gforth
001B66r 3  20 rr rr                     jsr xt_space
001B69r 3  20 rr rr                     jsr xt_space
001B6Cr 3  20 rr rr                     jsr xt_get_current      ; ( wid )
001B6Fr 3               
001B6Fr 3  B5 00                        lda 0,x
001B71r 3  20 rr rr                     jsr _print_wid_string
001B74r 3  20 rr rr                     jsr xt_cr
001B77r 3               
001B77r 3               @drop_done:
001B77r 3  E8                           inx
001B78r 3  E8                           inx
001B79r 3               z_order:
001B79r 3  60                           rts
001B7Ar 3               
001B7Ar 3               _print_wid_string:
001B7Ar 3                       ; """Helper function for ORDER: Given a WID in A, print the
001B7Ar 3                       ; corresponding string. If there is no such word list defined, just
001B7Ar 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
001B7Ar 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
001B7Ar 3                       ; theory, we could speed this up by having the WID be the same as the
001B7Ar 3                       ; number of the strings. However, ORDER is used rather infrequently and
001B7Ar 3                       ; this would make changes to the strings.asm file very dangerous, so we
001B7Ar 3                       ; follow the slightly more complicated route with a translation table.
001B7Ar 3                       ; """
001B7Ar 3                               ; If the WID is larger than 3, we have no string avaliable and
001B7Ar 3                               ; just print the number.
001B7Ar 3                               ; See http://6502.org/tutorials/compare_instructions.html
001B7Ar 3                               ; for details
001B7Ar 3  C9 04                        cmp #4
001B7Cr 3  90 09                        bcc @output_string      ; less than 4, print a real string
001B7Er 3               
001B7Er 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
001B7Er 3                               ; print the number
001B7Er 3  CA                           dex
001B7Fr 3  CA                           dex
001B80r 3  95 00                        sta 0,x
001B82r 3  74 01                        stz 1,x
001B84r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
001B87r 3               
001B87r 3               @output_string:
001B87r 3                               ; Get the string number based on WID 0 to 3
001B87r 3  A8                           tay
001B88r 3  B9 rr rr                     lda @wid_data,y
001B8Br 3               
001B8Br 3                               ; Print without a line feed
001B8Br 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
001B8Er 3               
001B8Er 3               @wid_data:
001B8Er 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
001B8Er 3                       ; less than 4.
001B8Er 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
001B8Fr 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
001B90r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
001B91r 3  08                   .byte str_wid_root             ; WID 3: "Root"
001B92r 3               
001B92r 3               
001B92r 3               
001B92r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
001B92r 3               ; ## "output"  tested  Tali Forth
001B92r 3               xt_output:
001B92r 3                       ; """Return the address where the jump target for EMIT is stored (but
001B92r 3                       ; not the vector itself). By default, this will hold the value of
001B92r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
001B92r 3                       ; routine.
001B92r 3                       ; """
001B92r 3  CA                           dex
001B93r 3  CA                           dex
001B94r 3  A9 rr                        lda #<output
001B96r 3  95 00                        sta 0,x
001B98r 3  A9 rr                        lda #>output
001B9Ar 3  95 01                        sta 1,x
001B9Cr 3               
001B9Cr 3  60           z_output:       rts
001B9Dr 3               
001B9Dr 3               
001B9Dr 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
001B9Dr 3               ; ## "over"  auto  ANS core
001B9Dr 3                       ; """https://forth-standard.org/standard/core/OVER"""
001B9Dr 3               xt_over:
001B9Dr 3  20 rr rr                     jsr underflow_2
001BA0r 3               
001BA0r 3  CA                           dex
001BA1r 3  CA                           dex
001BA2r 3               
001BA2r 3  B5 04                        lda 4,x         ; LSB
001BA4r 3  95 00                        sta 0,x
001BA6r 3  B5 05                        lda 5,x         ; MSB
001BA8r 3  95 01                        sta 1,x
001BAAr 3               
001BAAr 3  60           z_over:         rts
001BABr 3               
001BABr 3               
001BABr 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
001BABr 3               ; ## "pad"  auto  ANS core ext
001BABr 3                       ; """https://forth-standard.org/standard/core/PAD
001BABr 3                       ; Return address to a temporary area in free memory for user. Must
001BABr 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
001BABr 3                       ; the compile area pointer (CP) and therefore varies in position.
001BABr 3                       ; This area is reserved for the user and not used by the system
001BABr 3                       ; """
001BABr 3               xt_pad:
001BABr 3  CA                           dex
001BACr 3  CA                           dex
001BADr 3               
001BADr 3  A5 rr                        lda cp
001BAFr 3  18                           clc
001BB0r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
001BB2r 3  95 00                        sta 0,x
001BB4r 3               
001BB4r 3  A5 rr                        lda cp+1
001BB6r 3  69 00                        adc #0          ; only need carry
001BB8r 3  95 01                        sta 1,x
001BBAr 3               
001BBAr 3  60           z_pad:          rts
001BBBr 3               
001BBBr 3               
001BBBr 3               ; ## PAGE ( -- ) "Clear the screen"
001BBBr 3               ; ## "page"  tested  ANS facility
001BBBr 3                       ; """https://forth-standard.org/standard/facility/PAGE
001BBBr 3                       ; Clears a page if supported by ANS terminal codes. This is
001BBBr 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
001BBBr 3                       ; left of the screen
001BBBr 3                       ; """
001BBBr 3               xt_page:
001BBBr 3  A9 1B                        lda #AscESC
001BBDr 3  20 rr rr                     jsr emit_a
001BC0r 3  A9 5B                        lda #$5B        ; ASCII for "["
001BC2r 3  20 rr rr                     jsr emit_a
001BC5r 3  A9 32                        lda #'2'
001BC7r 3  20 rr rr                     jsr emit_a
001BCAr 3  A9 4A                        lda #'J'
001BCCr 3  20 rr rr                     jsr emit_a
001BCFr 3               
001BCFr 3                               ; move cursor to top left of screen
001BCFr 3  20 rr rr                     jsr xt_zero
001BD2r 3  20 rr rr                     jsr xt_zero
001BD5r 3  20 rr rr                     jsr xt_at_xy
001BD8r 3               
001BD8r 3  60           z_page:         rts
001BD9r 3               
001BD9r 3               
001BD9r 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
001BD9r 3               ; ## "("  auto  ANS core
001BD9r 3                       ; """http://forth-standard.org/standard/core/p"""
001BD9r 3               
001BD9r 3               xt_paren:
001BD9r 3                               ; Put a right paren on the stack.
001BD9r 3  CA                           dex
001BDAr 3  CA                           dex
001BDBr 3  A9 29                        lda #41     ; Right parenthesis
001BDDr 3  95 00                        sta 0,x
001BDFr 3  74 01                        stz 1,x
001BE1r 3               
001BE1r 3                               ; Call parse.
001BE1r 3  20 rr rr                     jsr xt_parse
001BE4r 3               
001BE4r 3                               ; Throw away the result.
001BE4r 3  E8                           inx
001BE5r 3  E8                           inx
001BE6r 3  E8                           inx
001BE7r 3  E8                           inx
001BE8r 3               
001BE8r 3  60           z_paren:        rts
001BE9r 3               
001BE9r 3               
001BE9r 3               
001BE9r 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
001BE9r 3               ; ## "parse-name"  auto  ANS core ext
001BE9r 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
001BE9r 3                       ; Find next word in input string, skipping leading whitespace. This is
001BE9r 3                       ; a special form of PARSE and drops through to that word. See PARSE
001BE9r 3                       ; for more detail. We use this word internally for the interpreter
001BE9r 3                       ; because it is a lot easier to use. Reference implementations at
001BE9r 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
001BE9r 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
001BE9r 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
001BE9r 3                       ; though the ANS standard talks about skipping "spaces", whitespace
001BE9r 3                       ; is actually perfectly legal (see for example
001BE9r 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
001BE9r 3                       ; Otherwise, PARSE-NAME chokes on tabs.
001BE9r 3                       ; """
001BE9r 3               
001BE9r 3               xt_parse_name:
001BE9r 3                               ; To enable the compilation of the high-level Forth words
001BE9r 3                               ; in forth-words.asm and user-words.asm at boot time,
001BE9r 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
001BE9r 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
001BE9r 3                               ; to the current location is in toin (>IN). We need to check,
001BE9r 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
001BE9r 3                               ; we can't just use Y as an index.
001BE9r 3               
001BE9r 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
001BE9r 3  A5 rr                        lda ciblen              ; LSB of counter
001BEBr 3  38                           sec
001BECr 3  E5 rr                        sbc toin
001BEEr 3  85 rr                        sta tmp1
001BF0r 3  A5 rr                        lda ciblen+1            ; MSB
001BF2r 3  E5 rr                        sbc toin+1
001BF4r 3  85 rr                        sta tmp1+1
001BF6r 3               
001BF6r 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
001BF6r 3  A5 rr                        lda tmp1
001BF8r 3  05 rr                        ora tmp1+1
001BFAr 3  F0 28                        beq @empty_line
001BFCr 3               
001BFCr 3                               ; We walk through the characters starting at CIB+TOIN, so we
001BFCr 3                               ; save a temp version of that in tmp2
001BFCr 3  A5 rr                        lda cib
001BFEr 3  18                           clc
001BFFr 3  65 rr                        adc toin
001C01r 3  85 rr                        sta tmp2                ; LSB of first character
001C03r 3  A5 rr                        lda cib+1
001C05r 3  65 rr                        adc toin+1
001C07r 3  85 rr                        sta tmp2+1              ; MSB
001C09r 3               
001C09r 3               @skip_loop:
001C09r 3  B2 rr                        lda (tmp2)              ; work copy of cib
001C0Br 3  20 rr rr                     jsr is_whitespace
001C0Er 3  90 1F                        bcc @char_found
001C10r 3               
001C10r 3                               ; Char is still whitespace, continue
001C10r 3  E6 rr                        inc tmp2
001C12r 3  D0 02                        bne @2
001C14r 3  E6 rr                        inc tmp2+1
001C16r 3               @2:
001C16r 3                               ; Adjust counter
001C16r 3  A5 rr                        lda tmp1
001C18r 3  D0 02                        bne @3
001C1Ar 3  C6 rr                        dec tmp1+1
001C1Cr 3               @3:
001C1Cr 3  C6 rr                        dec tmp1
001C1Er 3               
001C1Er 3  A5 rr                        lda tmp1
001C20r 3  05 rr                        ora tmp1+1
001C22r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
001C24r 3               
001C24r 3               @empty_line:
001C24r 3                               ; Neither the ANS Forth nor the Gforth documentation say
001C24r 3                               ; what to return as an address if a string with only
001C24r 3                               ; spaces is given. For speed reasons, we just return junk
001C24r 3                               ; NOS, with the TOS zero as per standard
001C24r 3  CA                           dex
001C25r 3  CA                           dex
001C26r 3  CA                           dex
001C27r 3  CA                           dex
001C28r 3               
001C28r 3  74 00                        stz 0,x                 ; TOS is zero
001C2Ar 3  74 01                        stz 1,x
001C2Cr 3               
001C2Cr 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
001C2Fr 3               
001C2Fr 3               @char_found:
001C2Fr 3                               ; We arrive here with tmp2 pointing to the first non-space
001C2Fr 3                               ; character. This is where the word really starts, so
001C2Fr 3                               ; we use it to calculate the new >IN by subtracting
001C2Fr 3  A5 rr                        lda tmp2
001C31r 3  38                           sec
001C32r 3  E5 rr                        sbc cib
001C34r 3  85 rr                        sta toin
001C36r 3  A5 rr                        lda tmp2+1
001C38r 3  E5 rr                        sbc cib+1
001C3Ar 3  85 rr                        sta toin+1
001C3Cr 3               
001C3Cr 3                               ; prepare Data Stack for PARSE by adding space
001C3Cr 3                               ; as the delimiter
001C3Cr 3  CA                           dex
001C3Dr 3  CA                           dex
001C3Er 3               
001C3Er 3  A9 20                        lda #AscSP
001C40r 3  95 00                        sta 0,x
001C42r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
001C44r 3               
001C44r 3               
001C44r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
001C44r 3               ; ## "parse"  tested  ANS core ext
001C44r 3                       ; """https://forth-standard.org/standard/core/PARSE
001C44r 3                       ; Find word in input string delimited by character given. Do not
001C44r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
001C44r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
001C44r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
001C44r 3                       ;
001C44r 3                       ;
001C44r 3                       ;     cib  cib+toin   cib+ciblen
001C44r 3                       ;      v      v            v
001C44r 3                       ;     |###################|
001C44r 3                       ;
001C44r 3                       ;     |------>|  toin (>IN)
001C44r 3                       ;     |------------------->|  ciblen
001C44r 3                       ;
001C44r 3                       ; The input string is stored starting at the address in the Current
001C44r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
001C44r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
001C44r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
001C44r 3                       ; useful string if there are any characters at all. As with
001C44r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
001C44r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
001C44r 3                       ; """
001C44r 3               
001C44r 3               xt_parse:
001C44r 3  20 rr rr                     jsr underflow_1
001C47r 3               
001C47r 3                               ; If the input buffer is empty, we just return
001C47r 3  A5 rr                        lda ciblen
001C49r 3  05 rr                        ora ciblen+1
001C4Br 3  F0 0C                        beq @abort_parse
001C4Dr 3               
001C4Dr 3                               ; If the pointer >IN is larger or equal to the length of
001C4Dr 3                               ; the input buffer (CIBLEN), the line is done. Put
001C4Dr 3                               ; differently, we only continue if >IN is smaller than
001C4Dr 3                               ; CIBLEN
001C4Dr 3  A5 rr                        lda toin+1              ; MSB
001C4Fr 3  C5 rr                        cmp ciblen+1
001C51r 3  90 0E                        bcc @go_parse           ; unsigned comparison
001C53r 3               
001C53r 3  A5 rr                        lda toin                ; LSB
001C55r 3  C5 rr                        cmp ciblen
001C57r 3  90 08                        bcc @go_parse
001C59r 3               
001C59r 3               @abort_parse:
001C59r 3                               ; Sorry, this line is over
001C59r 3  CA                           dex
001C5Ar 3  CA                           dex
001C5Br 3  74 00                        stz 0,x
001C5Dr 3  74 01                        stz 1,x
001C5Fr 3               
001C5Fr 3  80 7A                        bra @done
001C61r 3               @go_parse:
001C61r 3                               ; We actually have work to do. Save the delimiter in
001C61r 3                               ; tmptos.
001C61r 3  B5 00                        lda 0,x
001C63r 3  85 rr                        sta tmptos
001C65r 3               
001C65r 3                               ; We can now prepare the Data Stack for the return value
001C65r 3  CA                           dex
001C66r 3  CA                           dex
001C67r 3               
001C67r 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
001C67r 3                               ; tmp2 is initially the same as tmp1, then the work index
001C67r 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
001C67r 3               
001C67r 3                               ; Calculate the beginning of the string, which is also the
001C67r 3                               ; address to return
001C67r 3  A5 rr                        lda cib
001C69r 3  18                           clc
001C6Ar 3  65 rr                        adc toin        ; LSB
001C6Cr 3  85 rr                        sta tmp1
001C6Er 3  85 rr                        sta tmp2
001C70r 3  95 02                        sta 2,x
001C72r 3               
001C72r 3  A5 rr                        lda cib+1
001C74r 3  65 rr                        adc toin+1      ; MSB
001C76r 3  85 rr                        sta tmp1+1
001C78r 3  85 rr                        sta tmp2+1
001C7Ar 3  95 03                        sta 3,x
001C7Cr 3               
001C7Cr 3                               ; Calculate the address where the input buffer ends plus 1, so
001C7Cr 3                               ; we can compare it with TOIN, which is an index
001C7Cr 3  A5 rr                        lda cib
001C7Er 3  18                           clc
001C7Fr 3  65 rr                        adc ciblen
001C81r 3  85 rr                        sta tmp3
001C83r 3  A5 rr                        lda cib+1
001C85r 3  65 rr                        adc ciblen+1
001C87r 3  85 rr                        sta tmp3+1
001C89r 3               
001C89r 3                               ; Initialize the offset we use to adjust EOL or found delimiter
001C89r 3  64 rr                        stz tmptos+1
001C8Br 3               @loop:
001C8Br 3                               ; If we are at the end of the string, quit
001C8Br 3  A5 rr                        lda tmp2
001C8Dr 3  C5 rr                        cmp tmp3
001C8Fr 3  D0 06                        bne @not_empty
001C91r 3               
001C91r 3  A5 rr                        lda tmp2+1
001C93r 3  C5 rr                        cmp tmp3+1
001C95r 3  F0 1D                        beq @eol
001C97r 3               @not_empty:
001C97r 3                               ; We have to do this the hard way. In fact, it's really
001C97r 3                               ; hard since if we are dealing with a SPACE, the standard
001C97r 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
001C97r 3                               ; Tali would choke on tabs between words. For details, see
001C97r 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
001C97r 3                               ; In theory, we could make this faster by defining a delimiter
001C97r 3                               ; that is 00 as the sign that we skip all whitespace, thereby
001C97r 3                               ; avoiding having to test every time. However, somebody,
001C97r 3                               ; somewhere might want to parse a zero-delimited list. Since
001C97r 3                               ; any byte value could be chosen for that, we just test for
001C97r 3                               ; a space every single time for the moment.
001C97r 3  B2 rr                        lda (tmp2)
001C99r 3               
001C99r 3  A4 rr                        ldy tmptos
001C9Br 3  C0 20                        cpy #AscSP
001C9Dr 3  D0 07                        bne @not_whitespace
001C9Fr 3               
001C9Fr 3                               ; The delimiter is a space, so we're looking for all
001C9Fr 3                               ; whitespace
001C9Fr 3  20 rr rr                     jsr is_whitespace
001CA2r 3  90 02                        bcc @not_whitespace
001CA4r 3  80 0C                        bra @found_delimiter
001CA6r 3               
001CA6r 3               @not_whitespace:
001CA6r 3                               ; The delimiter is not a space, so we're looking for
001CA6r 3                               ; whatever it is
001CA6r 3  C5 rr                        cmp tmptos
001CA8r 3  F0 08                        beq @found_delimiter
001CAAr 3               
001CAAr 3                               ; Not a delimiter, next character
001CAAr 3  E6 rr                        inc tmp2
001CACr 3  D0 DD                        bne @loop
001CAEr 3  E6 rr                        inc tmp2+1
001CB0r 3  80 D9                        bra @loop
001CB2r 3               
001CB2r 3               @found_delimiter:
001CB2r 3                               ; Increase the offset: If we've found a delimiter, we want
001CB2r 3                               ; TOIN to point to the character after it, not the delimiter
001CB2r 3                               ; itself
001CB2r 3  E6 rr                        inc tmptos+1
001CB4r 3               @eol:
001CB4r 3                               ; The length of the new string is tmp2-tmp1
001CB4r 3  A5 rr                        lda tmp2
001CB6r 3  38                           sec
001CB7r 3  E5 rr                        sbc tmp1
001CB9r 3  95 00                        sta 0,x
001CBBr 3               
001CBBr 3  A5 rr                        lda tmp2+1
001CBDr 3  E5 rr                        sbc tmp1+1
001CBFr 3  95 01                        sta 1,x
001CC1r 3               
001CC1r 3                               ; The new offset is tmp2-cib
001CC1r 3  A5 rr                        lda tmp2
001CC3r 3  38                           sec
001CC4r 3  E5 rr                        sbc cib
001CC6r 3  85 rr                        sta toin
001CC8r 3  A5 rr                        lda tmp2+1
001CCAr 3  E5 rr                        sbc cib+1
001CCCr 3  85 rr                        sta toin+1
001CCEr 3               
001CCEr 3                               ; Add in the delimiter
001CCEr 3  A5 rr                        lda toin
001CD0r 3  18                           clc
001CD1r 3  65 rr                        adc tmptos+1
001CD3r 3  85 rr                        sta toin
001CD5r 3  A5 rr                        lda toin+1
001CD7r 3  69 00                        adc #0          ; we only need the carry
001CD9r 3  85 rr                        sta toin+1
001CDBr 3               @done:
001CDBr 3               z_parse_name:
001CDBr 3  60           z_parse:        rts
001CDCr 3               
001CDCr 3               
001CDCr 3               
001CDCr 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
001CDCr 3               ; ## "pick"  auto  ANS core ext
001CDCr 3                       ; """https://forth-standard.org/standard/core/PICK
001CDCr 3                       ; Take the u-th element out of the stack and put it on TOS,
001CDCr 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
001CDCr 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
001CDCr 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
001CDCr 3                       ; """
001CDCr 3               
001CDCr 3               xt_pick:
001CDCr 3                               ; Checking for underflow is difficult because it depends on
001CDCr 3                               ; which element we want to grab. We could probably figure
001CDCr 3                               ; something out, but it wouldn't work with underflow stripping
001CDCr 3                               ; Since using PICK is considered poor form anyway, we just
001CDCr 3                               ; leave it as it is
001CDCr 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
001CDEr 3  8A                           txa
001CDFr 3  75 00                        adc 0,x
001CE1r 3  A8                           tay
001CE2r 3               
001CE2r 3  B9 02 00                     lda 0002,y
001CE5r 3  95 00                        sta 0,x
001CE7r 3  B9 03 00                     lda 0003,y
001CEAr 3  95 01                        sta 1,x
001CECr 3               
001CECr 3  60           z_pick:         rts
001CEDr 3               
001CEDr 3               
001CEDr 3               
001CEDr 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
001CEDr 3               ; ## "+"  auto  ANS core
001CEDr 3                       ; """https://forth-standard.org/standard/core/Plus"""
001CEDr 3               xt_plus:
001CEDr 3  20 rr rr                     jsr underflow_2
001CF0r 3               
001CF0r 3  18                           clc
001CF1r 3  B5 00                        lda 0,x         ; LSB
001CF3r 3  75 02                        adc 2,x
001CF5r 3  95 02                        sta 2,x
001CF7r 3               
001CF7r 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
001CF9r 3  75 03                        adc 3,x
001CFBr 3  95 03                        sta 3,x
001CFDr 3               
001CFDr 3  E8                           inx
001CFEr 3  E8                           inx
001CFFr 3               
001CFFr 3  60           z_plus:         rts
001D00r 3               
001D00r 3               
001D00r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
001D00r 3               ; ## "+!"  auto  ANS core
001D00r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
001D00r 3               xt_plus_store:
001D00r 3  20 rr rr                     jsr underflow_2
001D03r 3               
001D03r 3                               ; move address to tmp1 so we can work with it
001D03r 3  B5 00                        lda 0,x
001D05r 3  85 rr                        sta tmp1
001D07r 3  B5 01                        lda 1,x
001D09r 3  85 rr                        sta tmp1+1
001D0Br 3               
001D0Br 3  A0 00                        ldy #0          ; LSB
001D0Dr 3  B1 rr                        lda (tmp1),y
001D0Fr 3  18                           clc
001D10r 3  75 02                        adc 2,x
001D12r 3  91 rr                        sta (tmp1),y
001D14r 3               
001D14r 3  C8                           iny             ; MSB
001D15r 3  B1 rr                        lda (tmp1),y
001D17r 3  75 03                        adc 3,x
001D19r 3  91 rr                        sta (tmp1),y
001D1Br 3               
001D1Br 3  E8                           inx
001D1Cr 3  E8                           inx
001D1Dr 3  E8                           inx
001D1Er 3  E8                           inx
001D1Fr 3               
001D1Fr 3  60           z_plus_store:   rts
001D20r 3               
001D20r 3               
001D20r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
001D20r 3               ; ## "postpone"  auto   ANS core
001D20r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
001D20r 3                       ; Add the compilation behavior of a word to a new word at
001D20r 3                       ; compile time. If the word that follows it is immediate, include
001D20r 3                       ; it so that it will be compiled when the word being defined is
001D20r 3                       ; itself used for a new word. Tricky, but very useful.
001D20r 3                       ;
001D20r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
001D20r 3                       ; on the Data Stack). This means we cannot build words with
001D20r 3                       ; "jsr xt_postpone, jsr <word>" directly.
001D20r 3                       ; """
001D20r 3               
001D20r 3               xt_postpone:
001D20r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
001D23r 3               
001D23r 3                               ; if there was no word provided, complain and quit
001D23r 3  B5 00                        lda 0,x
001D25r 3  15 01                        ora 1,x
001D27r 3  D0 05                        bne @1
001D29r 3               
001D29r 3  A9 05                        lda #err_noname
001D2Br 3  4C rr rr                     jmp error
001D2Er 3               @1:
001D2Er 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
001D31r 3               
001D31r 3                               ; if word not in Dictionary, complain and quit
001D31r 3  D0 05                        bne @2
001D33r 3  A9 05                        lda #err_noname
001D35r 3  4C rr rr                     jmp error
001D38r 3               
001D38r 3               @2:
001D38r 3                               ; keep a copy of nt for later
001D38r 3  B5 00                        lda 0,x
001D3Ar 3  85 rr                        sta tmp1
001D3Cr 3  B5 01                        lda 1,x
001D3Er 3  85 rr                        sta tmp1+1
001D40r 3               
001D40r 3                               ; We need the xt instead of the nt
001D40r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
001D43r 3               
001D43r 3                               ; See if this is an immediate word. This is easier
001D43r 3                               ; with nt than with xt. The status byte of the word
001D43r 3                               ; is nt+1
001D43r 3  E6 rr                        inc tmp1
001D45r 3  D0 02                        bne @3
001D47r 3  E6 rr                        inc tmp1+1
001D49r 3               @3:
001D49r 3  B2 rr                        lda (tmp1)
001D4Br 3  29 04                        and #IM         ; mask all but Intermediate flag
001D4Dr 3  F0 05                        beq @not_immediate
001D4Fr 3               
001D4Fr 3                               ; We're immediate, so instead of executing it right now, we
001D4Fr 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
001D4Fr 3                               ; takes us back to the original caller
001D4Fr 3  20 rr rr                     jsr xt_compile_comma
001D52r 3  80 0A                        bra @done
001D54r 3               
001D54r 3               @not_immediate:
001D54r 3                               ; This is not an immediate word, so we enact "deferred
001D54r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
001D54r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
001D54r 3                               ; a subroutine jump to COMPILE,
001D54r 3  20 rr rr                     jsr xt_literal
001D57r 3               
001D57r 3                               ; Last, compile COMPILE,
001D57r 3  A0 rr                        ldy #>xt_compile_comma
001D59r 3  A9 rr                        lda #<xt_compile_comma
001D5Br 3  20 rr rr                     jsr cmpl_subroutine
001D5Er 3               @done:
001D5Er 3  60           z_postpone:     rts
001D5Fr 3               
001D5Fr 3               
001D5Fr 3               
001D5Fr 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
001D5Fr 3               ; ## "previous"  auto  ANS search ext
001D5Fr 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
001D5Fr 3               
001D5Fr 3               xt_previous:
001D5Fr 3  20 rr rr                     jsr xt_get_order
001D62r 3  20 rr rr                     jsr xt_nip
001D65r 3  20 rr rr                     jsr xt_one_minus
001D68r 3  20 rr rr                     jsr xt_set_order
001D6Br 3               
001D6Br 3  60           z_previous:     rts
001D6Cr 3               
001D6Cr 3               
001D6Cr 3               
001D6Cr 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
001D6Cr 3               ; ## "?"  tested  ANS tools
001D6Cr 3                       ; """https://forth-standard.org/standard/tools/q
001D6Cr 3                       ;
001D6Cr 3                       ; Only used interactively. Since humans are so slow, we
001D6Cr 3                       ; save size and just go for the subroutine jumps
001D6Cr 3                       ; """
001D6Cr 3               xt_question:
001D6Cr 3                               ; FETCH takes care of underflow check
001D6Cr 3  20 rr rr                     jsr xt_fetch
001D6Fr 3  20 rr rr                     jsr xt_dot
001D72r 3               
001D72r 3  60           z_question:     rts
001D73r 3               
001D73r 3               
001D73r 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
001D73r 3               ; ## "?dup"  auto  ANS core
001D73r 3                       ; """https://forth-standard.org/standard/core/qDUP"""
001D73r 3               
001D73r 3               xt_question_dup:
001D73r 3  20 rr rr                     jsr underflow_1
001D76r 3               
001D76r 3                               ; Check if TOS is zero
001D76r 3  B5 00                        lda 0,x
001D78r 3  15 01                        ora 1,x
001D7Ar 3  F0 0A                        beq @done
001D7Cr 3               
001D7Cr 3                               ; not zero, duplicate
001D7Cr 3  CA                           dex
001D7Dr 3  CA                           dex
001D7Er 3  B5 02                        lda 2,x
001D80r 3  95 00                        sta 0,x
001D82r 3  B5 03                        lda 3,x
001D84r 3  95 01                        sta 1,x
001D86r 3               @done:
001D86r 3  60           z_question_dup: rts
001D87r 3               
001D87r 3               
001D87r 3               
001D87r 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
001D87r 3               ; ## "r@"  auto  ANS core
001D87r 3                       ; """https://forth-standard.org/standard/core/RFetch
001D87r 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
001D87r 3                       ; work normally as well
001D87r 3                       ;
001D87r 3                       ; An alternative way to write this word
001D87r 3                       ; would be to access the elements on the stack directly like 2R@
001D87r 3                       ; does, these versions should be compared at some point.
001D87r 3                       ; """
001D87r 3               xt_r_fetch:
001D87r 3                               ; get the return address
001D87r 3  7A                           ply             ; LSB
001D88r 3  84 rr                        sty tmp1
001D8Ar 3  7A                           ply             ; MSB
001D8Br 3               
001D8Br 3                               ; --- CUT FOR NATIVE COMPILE ---
001D8Br 3               
001D8Br 3                               ; get the actual top of Return Stack
001D8Br 3  CA                           dex
001D8Cr 3  CA                           dex
001D8Dr 3               
001D8Dr 3  68                           pla             ; LSB
001D8Er 3  95 00                        sta 0,x
001D90r 3  68                           pla             ; MSB
001D91r 3  95 01                        sta 1,x
001D93r 3               
001D93r 3                               ; now we have to put that value back
001D93r 3  48                           pha
001D94r 3  B5 00                        lda 0,x
001D96r 3  48                           pha
001D97r 3               
001D97r 3                               ; --- CUT FOR NATIVE COMPILE ---
001D97r 3               
001D97r 3                               ; restore return value
001D97r 3  5A                           phy             ; MSB
001D98r 3  A4 rr                        ldy tmp1
001D9Ar 3  5A                           phy             ; LSB
001D9Br 3               
001D9Br 3  60           z_r_fetch:      rts
001D9Cr 3               
001D9Cr 3               
001D9Cr 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
001D9Cr 3               ; ## "r>"  auto  ANS core
001D9Cr 3                       ; """https://forth-standard.org/standard/core/Rfrom
001D9Cr 3                       ; Move Top of Return Stack to Top of Data Stack.
001D9Cr 3                       ;
001D9Cr 3                       ; We have to move
001D9Cr 3                       ; the RTS address out of the way first. This word is handled
001D9Cr 3                       ; differently for native and and subroutine compilation, see COMPILE,
001D9Cr 3                       ; This is a compile-only word
001D9Cr 3                       ; """
001D9Cr 3               
001D9Cr 3               xt_r_from:
001D9Cr 3                               ; Rescue the address of the return jump that is currently
001D9Cr 3                               ; on top of the Return Stack. If this word is natively
001D9Cr 3                               ; compiled, this is a total waste of time
001D9Cr 3  68                           pla             ; LSB
001D9Dr 3  85 rr                        sta tmptos
001D9Fr 3  7A                           ply             ; MSB
001DA0r 3               
001DA0r 3                               ; --- CUT FOR NATIVE CODING ---
001DA0r 3               
001DA0r 3  CA                           dex
001DA1r 3  CA                           dex
001DA2r 3               
001DA2r 3                               ; now we can access the actual data
001DA2r 3               
001DA2r 3  68                           pla             ; LSB
001DA3r 3  95 00                        sta 0,x
001DA5r 3  68                           pla             ; MSB
001DA6r 3  95 01                        sta 1,x
001DA8r 3               
001DA8r 3                               ; --- CUT FOR NATIVE CODING ---
001DA8r 3               
001DA8r 3                               ; restore the return address
001DA8r 3  5A                           phy             ; MSB
001DA9r 3  A5 rr                        lda tmptos
001DABr 3  48                           pha             ; LSB
001DACr 3               
001DACr 3  60           z_r_from:       rts
001DADr 3               
001DADr 3               
001DADr 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
001DADr 3               ; ## "r>input"  tested  Tali Forth
001DADr 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
001DADr 3                       ; and toin from the Return Stack.
001DADr 3                       ;
001DADr 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
001DADr 3                       ; """
001DADr 3               
001DADr 3               xt_r_to_input:
001DADr 3               
001DADr 3                               ; We arrive here with the return address on the top of the
001DADr 3                               ; 65c02's stack. We need to move it out of the way first
001DADr 3  68                           pla
001DAEr 3  85 rr                        sta tmp1
001DB0r 3  68                           pla
001DB1r 3  85 rr                        sta tmp1+1
001DB3r 3               
001DB3r 3                               ; This assumes that insrc is the first of eight bytes and
001DB3r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001DB3r 3                               ; Page. Since we went in reverse order, insrc is now on the top
001DB3r 3                               ; of the Return Stack.
001DB3r 3  A0 00                        ldy #0
001DB5r 3               @loop:
001DB5r 3  68                           pla
001DB6r 3  99 rr rr                     sta insrc,y
001DB9r 3  C8                           iny
001DBAr 3  C0 08                        cpy #8
001DBCr 3  D0 F7                        bne @loop
001DBEr 3               
001DBEr 3                               ; Restore address for return jump
001DBEr 3  A5 rr                        lda tmp1+1
001DC0r 3  48                           pha
001DC1r 3  A5 rr                        lda tmp1
001DC3r 3  48                           pha
001DC4r 3               
001DC4r 3  60           z_r_to_input: 	rts
001DC5r 3               
001DC5r 3               
001DC5r 3               
001DC5r 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
001DC5r 3               ; ## "recurse"  auto  ANS core
001DC5r 3                       ; """https://forth-standard.org/standard/core/RECURSE
001DC5r 3                       ;
001DC5r 3                       ; This word may not be natively compiled
001DC5r 3                       ; """
001DC5r 3               
001DC5r 3               xt_recurse:
001DC5r 3                               ; The whole routine amounts to compiling a reference to
001DC5r 3                               ; the word that is being compiled. First, we save the JSR
001DC5r 3                               ; instruction
001DC5r 3  A0 00                        ldy #0
001DC7r 3               
001DC7r 3  A9 20                        lda #$20        ; opcode for JSR
001DC9r 3  91 rr                        sta (cp),y
001DCBr 3  C8                           iny
001DCCr 3               
001DCCr 3                               ; Next, we save the LSB and MSB of the xt of the word
001DCCr 3                               ; we are currently working on. We first need to see if
001DCCr 3                               ; WORKWORD has the nt (: started the word) or the
001DCCr 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
001DCCr 3  24 rr                        bit status
001DCEr 3  70 0C                        bvs @nt_in_workword
001DD0r 3               
001DD0r 3                               ; This is a special :NONAME word. Just copy the xt
001DD0r 3                               ; from WORKWORD into the dictionary.
001DD0r 3  A5 rr                        lda workword
001DD2r 3  91 rr                        sta (cp),y
001DD4r 3  C8                           iny
001DD5r 3  A5 rr                        lda workword+1
001DD7r 3  91 rr                        sta (cp),y
001DD9r 3  C8                           iny
001DDAr 3  80 1B                        bra @update_cp
001DDCr 3               
001DDCr 3               @nt_in_workword:
001DDCr 3                               ; This is a regular : word, so the xt is four bytes down
001DDCr 3                               ; from the nt which we saved in WORKWORD. We could probably
001DDCr 3                               ; use NAME>INT here but this is going to be faster, and
001DDCr 3                               ; fast counts with recursion
001DDCr 3  A5 rr                        lda workword            ; LSB
001DDEr 3  18                           clc
001DDFr 3  69 04                        adc #4
001DE1r 3  85 rr                        sta tmp1
001DE3r 3  A5 rr                        lda workword+1          ; MSB
001DE5r 3  69 00                        adc #0
001DE7r 3  85 rr                        sta tmp1+1
001DE9r 3               
001DE9r 3  B2 rr                        lda (tmp1)
001DEBr 3  91 rr                        sta (cp),y
001DEDr 3  5A                           phy
001DEEr 3  A0 01                        ldy #1
001DF0r 3  B1 rr                        lda (tmp1),y
001DF2r 3  7A                           ply
001DF3r 3  C8                           iny
001DF4r 3  91 rr                        sta (cp),y
001DF6r 3  C8                           iny
001DF7r 3               
001DF7r 3               @update_cp:
001DF7r 3  98                           tya
001DF8r 3  18                           clc
001DF9r 3  65 rr                        adc cp
001DFBr 3  85 rr                        sta cp
001DFDr 3  90 02                        bcc @done
001DFFr 3  E6 rr                        inc cp+1
001E01r 3               @done:
001E01r 3  60           z_recurse:      rts
001E02r 3               
001E02r 3               
001E02r 3               
001E02r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
001E02r 3               ; ## "refill"  tested  ANS core ext
001E02r 3                       ; """https://forth-standard.org/standard/core/REFILL
001E02r 3                       ; Attempt to fill the input buffer from the input source, returning
001E02r 3                       ; a true flag if successful. When the input source is the user input
001E02r 3                       ; device, attempt to receive input into the terminal input buffer. If
001E02r 3                       ; successful, make the result the input buffer, set >IN to zero, and
001E02r 3                       ; return true. Receipt of a line containing no characters is considered
001E02r 3                       ; successful. If there is no input available from the current input
001E02r 3                       ; source, return false. When the input source is a string from EVALUATE,
001E02r 3                       ; return false and perform no other action." See
001E02r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
001E02r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
001E02r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
001E02r 3                       ; entire block as a 1024 byte string.
001E02r 3                       ; """"
001E02r 3               
001E02r 3               xt_refill:
001E02r 3                               ; Get input source from SOURCE-ID. This is an
001E02r 3                               ; optimized version of a subroutine jump to SOURCE-ID
001E02r 3  A5 rr                        lda insrc               ; cheat: We only check LSB
001E04r 3  D0 2D                        bne @src_not_kbd
001E06r 3               
001E06r 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
001E06r 3                               ; with ACCEPT, which wants the address of the current input
001E06r 3                               ; buffer NOS and the max number of characters to accept TOS
001E06r 3  CA                           dex
001E07r 3  CA                           dex
001E08r 3  CA                           dex
001E09r 3  CA                           dex
001E0Ar 3               
001E0Ar 3  A5 rr                        lda cib                 ; address of CIB is NOS
001E0Cr 3  95 02                        sta 2,x
001E0Er 3  A5 rr                        lda cib+1
001E10r 3  95 03                        sta 3,x
001E12r 3               
001E12r 3  64 rr                        stz ciblen              ; go in with empty buffer
001E14r 3  64 rr                        stz ciblen+1
001E16r 3               
001E16r 3  A9 FF                        lda #bsize              ; max number of chars is TOS
001E18r 3  95 00                        sta 0,x
001E1Ar 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
001E1Cr 3               
001E1Cr 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
001E1Fr 3               
001E1Fr 3                               ; ACCEPT returns the number of characters accepted, which
001E1Fr 3                               ; belong in CIBLEN
001E1Fr 3  B5 00                        lda 0,x
001E21r 3  85 rr                        sta ciblen
001E23r 3  B5 01                        lda 1,x
001E25r 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
001E27r 3               
001E27r 3                               ; make >IN point to beginning of buffer
001E27r 3  64 rr                        stz toin
001E29r 3  64 rr                        stz toin+1
001E2Br 3               
001E2Br 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
001E2Dr 3  95 00                        sta 0,x
001E2Fr 3  95 01                        sta 1,x
001E31r 3               
001E31r 3  80 10                        bra @done
001E33r 3               
001E33r 3               @src_not_kbd:
001E33r 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
001E33r 3                               ; memory or a file (remember, no blocks in this version).
001E33r 3                               ; If source is a string, we were given the flag -1 ($FFFF)
001E33r 3  1A                           inc
001E34r 3  D0 08                        bne @src_not_string
001E36r 3               
001E36r 3                               ; Simply return FALSE flag as per specification
001E36r 3  CA                           dex
001E37r 3  CA                           dex
001E38r 3  74 00                        stz 0,x
001E3Ar 3  74 01                        stz 1,x
001E3Cr 3               
001E3Cr 3  80 05                        bra z_refill
001E3Er 3               
001E3Er 3               @src_not_string:
001E3Er 3                               ; Since we don't have blocks, this must mean that we are trying
001E3Er 3                               ; to read from a file. However, we don't have files yet, so we
001E3Er 3                               ; report an error and jump to ABORT.
001E3Er 3  A9 01                        lda #err_badsource
001E40r 3  4C rr rr                     jmp error
001E43r 3               @done:
001E43r 3  60           z_refill:       rts
001E44r 3               
001E44r 3               
001E44r 3               
001E44r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
001E44r 3               ; ## "repeat"  auto  ANS core
001E44r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
001E44r 3               
001E44r 3               xt_repeat:
001E44r 3                               ; Run again first
001E44r 3  20 rr rr                     jsr xt_again
001E47r 3               
001E47r 3                               ; Stuff HERE in for the branch address
001E47r 3                               ; to get out of the loop
001E47r 3  20 rr rr                     jsr xt_here
001E4Ar 3  20 rr rr                     jsr xt_swap
001E4Dr 3  20 rr rr                     jsr xt_store
001E50r 3               
001E50r 3  60           z_repeat:       rts
001E51r 3               
001E51r 3               
001E51r 3               
001E51r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
001E51r 3               ; ## "]"  auto  ANS core
001E51r 3                       ; """https://forth-standard.org/standard/right-bracket
001E51r 3                       ; This is an immediate word.
001E51r 3                       ; """
001E51r 3               xt_right_bracket:
001E51r 3  A9 FF                        lda #$FF
001E53r 3  85 rr                        sta state
001E55r 3  85 rr                        sta state+1
001E57r 3               z_right_bracket:
001E57r 3  60                           rts
001E58r 3               
001E58r 3               
001E58r 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
001E58r 3               ; ## "root-wordlist"  tested  Tali Editor
001E58r 3               xt_root_wordlist:
001E58r 3  CA                           dex             ; The WID for the Root wordlist is 3.
001E59r 3  CA                           dex
001E5Ar 3  A9 03                        lda #3
001E5Cr 3  95 00                        sta 0,x
001E5Er 3  74 01                        stz 1,x
001E60r 3               
001E60r 3               z_root_wordlist:
001E60r 3  60                           rts
001E61r 3               
001E61r 3               
001E61r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
001E61r 3               ; ## "rot"  auto  ANS core
001E61r 3                       ; """https://forth-standard.org/standard/core/ROT
001E61r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
001E61r 3                       ; on top!
001E61r 3                       ; """
001E61r 3               
001E61r 3               xt_rot:
001E61r 3  20 rr rr                     jsr underflow_3
001E64r 3               
001E64r 3  B4 05                        ldy 5,x         ; MSB first
001E66r 3  B5 03                        lda 3,x
001E68r 3  95 05                        sta 5,x
001E6Ar 3  B5 01                        lda 1,x
001E6Cr 3  95 03                        sta 3,x
001E6Er 3  94 01                        sty 1,x
001E70r 3               
001E70r 3  B4 04                        ldy 4,x         ; LSB next
001E72r 3  B5 02                        lda 2,x
001E74r 3  95 04                        sta 4,x
001E76r 3  B5 00                        lda 0,x
001E78r 3  95 02                        sta 2,x
001E7Ar 3  94 00                        sty 0,x
001E7Cr 3               
001E7Cr 3  60           z_rot:          rts
001E7Dr 3               
001E7Dr 3               
001E7Dr 3               
001E7Dr 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
001E7Dr 3               ; ## "rshift"  auto  ANS core
001E7Dr 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
001E7Dr 3               xt_rshift:
001E7Dr 3  20 rr rr                     jsr underflow_2
001E80r 3               
001E80r 3                               ; We shift maximal by 16 bits, mask everything else
001E80r 3  B5 00                        lda 0,x
001E82r 3  29 0F                        and #%00001111
001E84r 3  F0 08                        beq @done               ; if 0 shifts, quit
001E86r 3               
001E86r 3  A8                           tay
001E87r 3               @loop:
001E87r 3  56 03                        lsr 3,x
001E89r 3  76 02                        ror 2,x
001E8Br 3  88                           dey
001E8Cr 3  D0 F9                        bne @loop
001E8Er 3               @done:
001E8Er 3  E8                           inx
001E8Fr 3  E8                           inx
001E90r 3               
001E90r 3  60           z_rshift:       rts
001E91r 3               
001E91r 3               
001E91r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
001E91r 3               ; ## "s\""  auto  ANS core
001E91r 3                       ; """https://forth-standard.org/standard/core/Seq
001E91r 3                       ; Store address and length of string given, returning ( addr u ).
001E91r 3                       ; ANS core claims this is compile-only, but the file set expands it
001E91r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
001E91r 3                       ; are evil. We follow general usage. This is just like S" except
001E91r 3                       ; that it allows for some special escaped characters.
001E91r 3                       ; """
001E91r 3               
001E91r 3               xt_s_backslash_quote:
001E91r 3                               ; tmp2 will be used to determine if we are handling
001E91r 3                               ; escaped characters or not. In this case, we are,
001E91r 3                               ; so set it to $FF (the upper byte will be used to
001E91r 3                               ; determine if we just had a \ and the next character
001E91r 3                               ; needs to be modifed as an escaped character).
001E91r 3  A9 FF                        lda #$FF
001E93r 3  85 rr                        sta tmp2
001E95r 3  64 rr                        stz tmp2+1
001E97r 3               
001E97r 3                               ; Now that the flag is set, jump into s_quote to process
001E97r 3                               ; the string.
001E97r 3  20 rr rr                     jsr s_quote_start
001E9Ar 3               @done:
001E9Ar 3               z_s_backslash_quote:
001E9Ar 3  60                           rts
001E9Br 3               
001E9Br 3               
001E9Br 3               ; This is a helper function for s_backslash_quote to convert a character
001E9Br 3               ; from ASCII to the corresponding hex value, eg 'F'->15
001E9Br 3               convert_hex_value:
001E9Br 3               
001E9Br 3  C9 41                cmp #'A'
001E9Dr 3  90 07                bcc @digit
001E9Fr 3               
001E9Fr 3                       ; It's A-F
001E9Fr 3  29 DF                and #$DF                ; Make it uppercase.
001EA1r 3  38                   sec
001EA2r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
001EA4r 3  80 03                bra @done
001EA6r 3               
001EA6r 3               @digit:
001EA6r 3                       ; It's 0-9
001EA6r 3  38                   sec
001EA7r 3  E9 30                sbc #'0'
001EA9r 3               
001EA9r 3               @done:
001EA9r 3  60                   rts
001EAAr 3               
001EAAr 3               
001EAAr 3               
001EAAr 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
001EAAr 3               ; ## "search-wordlist" auto ANS search
001EAAr 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
001EAAr 3               
001EAAr 3               xt_search_wordlist:
001EAAr 3  20 rr rr                     jsr underflow_3
001EADr 3               
001EADr 3                               ; Set up tmp1 with the wordlist indicated by wid
001EADr 3                               ; on the stack. Start by putting the base address
001EADr 3                               ; of the wordlists in tmp2.
001EADr 3  A5 rr                        lda up
001EAFr 3  18                           clc
001EB0r 3  69 06                        adc #wordlists_offset
001EB2r 3  85 rr                        sta tmp2
001EB4r 3  A5 rr                        lda up+1
001EB6r 3  69 00                        adc #0          ; Adding carry
001EB8r 3  85 rr                        sta tmp2+1
001EBAr 3               
001EBAr 3                               ; Add the wid (in cells) to the base address.
001EBAr 3  B5 00                        lda 0,x
001EBCr 3  0A                           asl             ; Convert wid to offset in cells (x2)
001EBDr 3  65 rr                        adc tmp2
001EBFr 3  85 rr                        sta tmp2
001EC1r 3  90 02                        bcc @1
001EC3r 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
001EC5r 3               
001EC5r 3                               ; tmp2 now holds the address of the dictionary pointer
001EC5r 3                               ; for the given wordlist.
001EC5r 3               @1:
001EC5r 3                               ; Remove the wid from the stack.
001EC5r 3  E8                           inx
001EC6r 3  E8                           inx
001EC7r 3               
001EC7r 3                               ; check for special case of an empty string (length zero)
001EC7r 3  B5 00                        lda 0,x
001EC9r 3  15 01                        ora 1,x
001ECBr 3  D0 03                        bne @check_wordlist
001ECDr 3  4C rr rr                     jmp @done
001ED0r 3               
001ED0r 3               @check_wordlist:
001ED0r 3                               ; Check for special case of empty wordlist
001ED0r 3                               ; (dictionary pointer, in tmp2, is 0)
001ED0r 3  A5 rr                        lda tmp2
001ED2r 3  05 rr                        ora tmp2+1
001ED4r 3  D0 03                        bne @have_string
001ED6r 3  4C rr rr                     jmp @done
001ED9r 3               
001ED9r 3               @have_string:
001ED9r 3                               ; set up first loop iteration
001ED9r 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
001EDBr 3  85 rr                        sta tmp1
001EDDr 3               
001EDDr 3  E6 rr                        inc tmp2                ; Move to the upper byte
001EDFr 3  D0 02                        bne @2
001EE1r 3  E6 rr                        inc tmp2+1
001EE3r 3               @2:
001EE3r 3  B2 rr                        lda (tmp2)
001EE5r 3  85 rr                        sta tmp1+1
001EE7r 3               
001EE7r 3                               ; Reuse tmp2 to hold the address of the mystery string.
001EE7r 3  B5 02                        lda 2,x                 ; Address of mystery string
001EE9r 3  85 rr                        sta tmp2
001EEBr 3  B5 03                        lda 3,x
001EEDr 3  85 rr                        sta tmp2+1
001EEFr 3               
001EEFr 3               @loop:
001EEFr 3                               ; first quick test: Are strings the same length?
001EEFr 3  B2 rr                        lda (tmp1)
001EF1r 3  D5 00                        cmp 0,x
001EF3r 3  D0 7B                        bne @next_entry
001EF5r 3               
001EF5r 3               @compare_string:
001EF5r 3                               ; are the same length, so we now have to compare each
001EF5r 3                               ; character
001EF5r 3               
001EF5r 3                               ; second quick test: Is the first character the same?
001EF5r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001EF7r 3               
001EF7r 3                               ; Lowercase the incoming charcter.
001EF7r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001EF9r 3  B0 07                        bcs @compare_first
001EFBr 3  C9 41                        cmp #$41        ; ASCII 'A'
001EFDr 3  90 03                        bcc @compare_first
001EFFr 3               
001EFFr 3                               ; An uppercase letter has been located.  Make it
001EFFr 3                               ; lowercase.
001EFFr 3  18                           clc
001F00r 3  69 20                        adc #$20
001F02r 3               
001F02r 3               @compare_first:
001F02r 3  A0 08                        ldy #8          ; Offset in nt to name
001F04r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
001F06r 3  D0 68                        bne @next_entry
001F08r 3               
001F08r 3                               ; string length are the same and the first character is the
001F08r 3                               ; same. If the length of the string is 1, we're already done
001F08r 3  B5 00                        lda 0,x
001F0Ar 3  3A                           dec
001F0Br 3  F0 2C                        beq @success
001F0Dr 3               
001F0Dr 3                               ; No such luck: The strings are the same length and the first
001F0Dr 3                               ; char is the same, but the word is more than one char long.
001F0Dr 3                               ; So we suck it up and compare every single character. We go
001F0Dr 3                               ; from back to front, because words like CELLS and CELL+ would
001F0Dr 3                               ; take longer otherwise. We can also shorten the loop by one
001F0Dr 3                               ; because we've already compared the first char.
001F0Dr 3               
001F0Dr 3                               ; The string of the word we're testing against is 8 bytes down
001F0Dr 3  A5 rr                        lda tmp1
001F0Fr 3  48                           pha             ; Preserve tmp1 on the return stack.
001F10r 3  18                           clc
001F11r 3  69 08                        adc #8
001F13r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001F15r 3  A5 rr                        lda tmp1+1
001F17r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001F18r 3  69 00                        adc #0          ; we only need the carry
001F1Ar 3  85 rr                        sta tmp1+1
001F1Cr 3               
001F1Cr 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001F1Er 3  88                           dey
001F1Fr 3               
001F1Fr 3               @string_loop:
001F1Fr 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
001F21r 3               
001F21r 3                               ; Lowercase the incoming charcter.
001F21r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001F23r 3  B0 07                        bcs @check_char
001F25r 3  C9 41                        cmp #$41        ; ASCII 'A'
001F27r 3  90 03                        bcc @check_char
001F29r 3               
001F29r 3                               ; An uppercase letter has been located.  Make it
001F29r 3                               ; lowercase.
001F29r 3  18                           clc
001F2Ar 3  69 20                        adc #$20
001F2Cr 3               @check_char:
001F2Cr 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
001F2Er 3  D0 3A                        bne @next_entry_tmp1
001F30r 3               
001F30r 3  88                           dey
001F31r 3  D0 EC                        bne @string_loop
001F33r 3               
001F33r 3               @success_tmp1:
001F33r 3  68                           pla             ; Restore tmp1 from the return stack.
001F34r 3  85 rr                        sta tmp1+1
001F36r 3  68                           pla
001F37r 3  85 rr                        sta tmp1
001F39r 3               
001F39r 3               @success:
001F39r 3                               ; The strings match. Drop the count and put correct nt TOS
001F39r 3  E8                           inx
001F3Ar 3  E8                           inx
001F3Br 3  A5 rr                        lda tmp1
001F3Dr 3  95 00                        sta 0,x
001F3Fr 3  A5 rr                        lda tmp1+1
001F41r 3  95 01                        sta 1,x
001F43r 3               
001F43r 3                               ; Change the nt into an xt, but save a copy of the nt
001F43r 3                               ; to look up whether the word is immediate or not.
001F43r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001F46r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001F49r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001F4Cr 3               
001F4Cr 3  A0 00                        ldy #0                  ; Prepare flag
001F4Er 3               
001F4Er 3                               ; The flags are in the second byte of the header
001F4Er 3  F6 00                        inc 0,x
001F50r 3  D0 02                        bne @3
001F52r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
001F54r 3               @3:
001F54r 3  A1 00                        lda (0,x)               ; ( xt char )
001F56r 3  29 04                        and #IM
001F58r 3  D0 08                        bne @immediate          ; bit set, we're immediate
001F5Ar 3               
001F5Ar 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001F5Cr 3  95 00                        sta 0,x
001F5Er 3  95 01                        sta 1,x
001F60r 3  80 28                        bra @done_nodrop
001F62r 3               
001F62r 3               @immediate:
001F62r 3  A9 01                        lda #1                  ; We're immediate, return 1
001F64r 3  95 00                        sta 0,x
001F66r 3  74 01                        stz 1,x
001F68r 3               
001F68r 3  80 20                        bra @done_nodrop
001F6Ar 3               
001F6Ar 3               @next_entry_tmp1:
001F6Ar 3  68                           pla             ; Restore tmp1 from the return stack.
001F6Br 3  85 rr                        sta tmp1+1
001F6Dr 3  68                           pla
001F6Er 3  85 rr                        sta tmp1
001F70r 3               @next_entry:
001F70r 3                               ; Not the same, so we get the next word. Next header
001F70r 3                               ; address is two bytes down
001F70r 3  A0 02                        ldy #2
001F72r 3  B1 rr                        lda (tmp1),y
001F74r 3  48                           pha
001F75r 3  C8                           iny
001F76r 3  B1 rr                        lda (tmp1),y
001F78r 3  85 rr                        sta tmp1+1
001F7Ar 3  68                           pla
001F7Br 3  85 rr                        sta tmp1
001F7Dr 3               
001F7Dr 3                               ; If we got a zero, we've walked the whole Dictionary and
001F7Dr 3                               ; return as a failure, otherwise try again
001F7Dr 3  05 rr                        ora tmp1+1
001F7Fr 3  F0 03                        beq @fail_done
001F81r 3  4C rr rr                     jmp @loop
001F84r 3               
001F84r 3               @fail_done:
001F84r 3  74 02                        stz 2,x         ; failure flag
001F86r 3  74 03                        stz 3,x
001F88r 3               @done:
001F88r 3  E8                           inx
001F89r 3  E8                           inx
001F8Ar 3               @done_nodrop:
001F8Ar 3               z_search_wordlist:
001F8Ar 3  60                           rts
001F8Br 3               
001F8Br 3               
001F8Br 3               
001F8Br 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
001F8Br 3               ; ## "see" tested  ANS tools
001F8Br 3                       ; """https://forth-standard.org/standard/tools/SEE
001F8Br 3                       ; SEE takes the name of a word and prints its name token (nt),
001F8Br 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
001F8Br 3                       ; code and disassembles it.
001F8Br 3                       ; """
001F8Br 3               
001F8Br 3               xt_see:
001F8Br 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
001F8Er 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
001F91r 3               
001F91r 3                               ; If we got back a zero we don't know that word and so we quit
001F91r 3                               ; with an error
001F91r 3  B5 00                        lda 0,x
001F93r 3  15 01                        ora 1,x
001F95r 3  D0 05                        bne @1
001F97r 3               
001F97r 3  A9 05                        lda #err_noname
001F99r 3  4C rr rr                     jmp error
001F9Cr 3               @1:
001F9Cr 3  20 rr rr                     jsr xt_cr
001F9Fr 3               
001F9Fr 3                               ; We have a legal word, so let's get serious. Save the current
001F9Fr 3                               ; number base and use hexadecimal instead.
001F9Fr 3  A5 rr                        lda base
001FA1r 3  48                           pha
001FA2r 3  20 rr rr                     jsr xt_hex
001FA5r 3               
001FA5r 3  A9 0A                        lda #str_see_nt
001FA7r 3  20 rr rr                     jsr print_string_no_lf
001FAAr 3               
001FAAr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001FADr 3  20 rr rr                     jsr xt_u_dot
001FB0r 3  20 rr rr                     jsr xt_space            ; ( nt )
001FB3r 3               
001FB3r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001FB6r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001FB9r 3               
001FB9r 3  A9 0B                        lda #str_see_xt
001FBBr 3  20 rr rr                     jsr print_string_no_lf
001FBEr 3               
001FBEr 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
001FC1r 3  20 rr rr                     jsr xt_u_dot
001FC4r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
001FC7r 3               
001FC7r 3                               ; We print letters for flags and then later follow it with 1 or
001FC7r 3                               ; 0 to mark if which flag is set
001FC7r 3  A9 09                        lda #str_see_flags
001FC9r 3  20 rr rr                     jsr print_string_no_lf
001FCCr 3               
001FCCr 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
001FCFr 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
001FD2r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
001FD5r 3               
001FD5r 3  B5 00                        lda 0,x
001FD7r 3               
001FD7r 3                               ; This is crude, but for the moment it is good enough
001FD7r 3  A0 06                        ldy #6                  ; Not all bits are used
001FD9r 3               @flag_loop:
001FD9r 3  48                           pha
001FDAr 3  29 01                        and #%00000001
001FDCr 3  18                           clc
001FDDr 3  69 30                        adc #$30                ; ASCII "0"
001FDFr 3  20 rr rr                     jsr emit_a
001FE2r 3  20 rr rr                     jsr xt_space
001FE5r 3               
001FE5r 3  68                           pla
001FE6r 3  6A                           ror                     ; Next flag
001FE7r 3               
001FE7r 3  88                           dey
001FE8r 3  D0 EF                        bne @flag_loop
001FEAr 3               
001FEAr 3  20 rr rr                     jsr xt_cr
001FEDr 3               
001FEDr 3  E8                           inx
001FEEr 3  E8                           inx                     ; ( nt xt )
001FEFr 3               
001FEFr 3                               ; Figure out the size
001FEFr 3  A9 0C                        lda #str_see_size
001FF1r 3  20 rr rr                     jsr print_string_no_lf
001FF4r 3               
001FF4r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001FF7r 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
001FFAr 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
001FFDr 3  20 rr rr                     jsr xt_decimal
002000r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
002003r 3  20 rr rr                     jsr xt_hex
002006r 3  20 rr rr                     jsr xt_cr
002009r 3               
002009r 3                               ; Dump hex and disassemble
002009r 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
00200Cr 3  20 rr rr                     jsr xt_dump
00200Fr 3  20 rr rr                     jsr xt_cr
002012r 3  20 rr rr                     jsr xt_disasm
002015r 3               
002015r 3  68                           pla
002016r 3  85 rr                        sta base
002018r 3               
002018r 3  60           z_see:          rts
002019r 3               
002019r 3               
002019r 3               
002019r 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
002019r 3               ; ## "set-current" auto ANS search
002019r 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
002019r 3               
002019r 3               xt_set_current:
002019r 3  20 rr rr                     jsr underflow_1
00201Cr 3               
00201Cr 3                               ; Save the value from the data stack.
00201Cr 3  A0 04                        ldy #current_offset
00201Er 3  B5 00                        lda 0,x         ; CURRENT is byte variable
002020r 3  91 rr                        sta (up),y      ; so only the LSB is used.
002022r 3               
002022r 3  E8                           inx
002023r 3  E8                           inx
002024r 3               
002024r 3  60           z_set_current:  rts
002025r 3               
002025r 3               
002025r 3               
002025r 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
002025r 3               ; ## "set-order" auto ANS search
002025r 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
002025r 3               
002025r 3               xt_set_order:
002025r 3                               ; Test for -1 TOS
002025r 3  A9 FF                        lda #$FF
002027r 3  D5 01                        cmp 1,x
002029r 3  D0 12                        bne @start
00202Br 3  D5 00                        cmp 0,x
00202Dr 3  D0 0E                        bne @start
00202Fr 3               
00202Fr 3                               ; There is a -1 TOS.  Replace it with the default
00202Fr 3                               ; search order, which is just the FORTH-WORDLIST.
00202Fr 3  CA                           dex             ; Make room for the count.
002030r 3  CA                           dex
002031r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
002033r 3  A9 03                        lda #3
002035r 3  95 02                        sta 2,x
002037r 3  74 01                        stz 1,x         ; Count is 1.
002039r 3  A9 01                        lda #1
00203Br 3  95 00                        sta 0,x
00203Dr 3               
00203Dr 3                               ; Continue processing with ( forth-wordlist 1 -- )
00203Dr 3               @start:
00203Dr 3                               ; Set #ORDER - the number of wordlists in the search order.
00203Dr 3  A0 1E                        ldy #num_order_offset
00203Fr 3  B5 00                        lda 0,x
002041r 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
002043r 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
002045r 3                                               ; Only the low byte is saved in tmp1 as
002045r 3                                               ; only 8 wordlists are allowed.
002045r 3               
002045r 3  E8                           inx             ; Drop the count off the data stack.
002046r 3  E8                           inx
002047r 3               
002047r 3                               ; Check if there are zero wordlists.
002047r 3  A5 rr                        lda tmp1
002049r 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
00204Br 3               
00204Br 3                               ; Move the wordlist ids from the data stack to the search order.
00204Br 3  A0 1F                        ldy #search_order_offset
00204Dr 3               @loop:
00204Dr 3                               ; Move one wordlist id over into the search order.
00204Dr 3  B5 00                        lda 0,x         ; The search order is a byte array
00204Fr 3  91 rr                        sta (up),y      ; so only save the LSB
002051r 3  C8                           iny
002052r 3               
002052r 3                               ; Remove it from the data stack.
002052r 3  E8                           inx
002053r 3  E8                           inx
002054r 3               
002054r 3                               ; See if that was the last one to process (first in the list).
002054r 3  C6 rr                        dec tmp1
002056r 3  D0 F5                        bne @loop
002058r 3               
002058r 3               @done:
002058r 3  60           z_set_order:    rts
002059r 3               
002059r 3               
002059r 3               
002059r 3               
002059r 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002059r 3               ; ## "s""  auto  ANS core
002059r 3                       ; """https://forth-standard.org/standard/core/Sq
002059r 3                       ; Store address and length of string given, returning ( addr u ).
002059r 3                       ; ANS core claims this is compile-only, but the file set expands it
002059r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002059r 3                       ; are evil. We follow general usage.
002059r 3                       ;
002059r 3                       ; Can also be realized as
002059r 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
002059r 3                       ; but it is used so much we want it in code.
002059r 3                       ; """
002059r 3               
002059r 3               xt_s_quote:
002059r 3                               ; tmp2 will be used to determine if we are handling
002059r 3                               ; escaped characters or not.  In this case, we are
002059r 3                               ; not, so set it to zero.
002059r 3  64 rr                        stz tmp2
00205Br 3  64 rr                        stz tmp2+1
00205Dr 3               
00205Dr 3               s_quote_start:
00205Dr 3                               ; Make room on the data stack for the address.
00205Dr 3  CA                           dex
00205Er 3  CA                           dex
00205Fr 3                               ; Make room on the data stack for the count.
00205Fr 3  CA                           dex
002060r 3  CA                           dex
002061r 3               
002061r 3                               ; Put a jmp over the string data with address to be filled
002061r 3                               ; in later.
002061r 3  A9 4C                        lda #$4C
002063r 3  20 rr rr                     jsr cmpl_a
002066r 3               
002066r 3                               ; Address to be filled in later, just use $4C for the moment
002066r 3  20 rr rr                     jsr cmpl_a
002069r 3  20 rr rr                     jsr cmpl_a
00206Cr 3               
00206Cr 3                               ; Save the current value of HERE on the data stack for the
00206Cr 3                               ; address of the string.
00206Cr 3  A5 rr                        lda cp
00206Er 3  95 02                        sta 2,x
002070r 3  A5 rr                        lda cp+1
002072r 3  95 03                        sta 3,x
002074r 3               
002074r 3               @savechars_loop:
002074r 3                               ; Start saving the string into the dictionary up to the
002074r 3                               ; ending double quote. First, check to see if the input
002074r 3                               ; buffer is empty.
002074r 3  A5 rr                        lda toin+1              ; MSB
002076r 3  C5 rr                        cmp ciblen+1
002078r 3  90 2A                        bcc @input_fine         ; unsigned comparison
00207Ar 3               
00207Ar 3  A5 rr                        lda toin                ; LSB
00207Cr 3  C5 rr                        cmp ciblen
00207Er 3  90 24                        bcc @input_fine
002080r 3               
002080r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
002080r 3                               ; which uses tmp2 and tmp3. Save and restore them.
002080r 3  A5 rr                        lda tmp2
002082r 3  48                           pha
002083r 3  A5 rr                        lda tmp2+1
002085r 3  48                           pha
002086r 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
002088r 3  48                           pha
002089r 3               
002089r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00208Cr 3               
00208Cr 3  68                           pla
00208Dr 3  85 rr                        sta tmp3
00208Fr 3  68                           pla
002090r 3  85 rr                        sta tmp2+1
002092r 3  68                           pla
002093r 3  85 rr                        sta tmp2
002095r 3               
002095r 3                               ; Check result of refill.
002095r 3  B5 00                        lda 0,x
002097r 3  15 01                        ora 1,x
002099r 3  D0 05                        bne @refill_ok
00209Br 3               
00209Br 3                               ; Something when wrong with refill.
00209Br 3  A9 06                        lda #err_refill
00209Dr 3  4C rr rr                     jmp error
0020A0r 3               
0020A0r 3               @refill_ok:
0020A0r 3                               ; Remove the refill flag from the data stack.
0020A0r 3  E8                           inx
0020A1r 3  E8                           inx
0020A2r 3               
0020A2r 3                               ; For refill success, jump back up to the empty check, just in
0020A2r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
0020A2r 3                               ; input)
0020A2r 3  80 D0                        bra @savechars_loop
0020A4r 3               
0020A4r 3               @input_fine:
0020A4r 3                               ; There should be at least one valid char to use.
0020A4r 3                               ; Calculate it's address at CIB+TOIN into tmp1
0020A4r 3  A5 rr                        lda cib
0020A6r 3  18                           clc
0020A7r 3  65 rr                        adc toin        ; LSB
0020A9r 3  85 rr                        sta tmp1
0020ABr 3  A5 rr                        lda cib+1
0020ADr 3  65 rr                        adc toin+1      ; MSB
0020AFr 3  85 rr                        sta tmp1+1
0020B1r 3               
0020B1r 3                               ; Get the character
0020B1r 3  B2 rr                        lda (tmp1)
0020B3r 3               
0020B3r 3                               ; Check to see if we are handling escaped characters.
0020B3r 3  24 rr                        bit tmp2
0020B5r 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
0020B7r 3  4C rr rr                     jmp @regular_char
0020BAr 3               
0020BAr 3               @handle_escapes:
0020BAr 3                               ; We are handling escaped characters.  See if we have
0020BAr 3                               ; already seen the backslash.
0020BAr 3  24 rr                        bit tmp2+1
0020BCr 3  30 03                        bmi @escaped
0020BEr 3  4C rr rr                     jmp @not_escaped
0020C1r 3               
0020C1r 3               @escaped:
0020C1r 3               
0020C1r 3                               ; We have seen a backslash (previous character). Check to see if
0020C1r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
0020C1r 3                               ; be clear in that case )
0020C1r 3  70 22                        bvs @check_esc_chars
0020C3r 3               
0020C3r 3                               ; We are in the middle of a \x sequence. Check to see if we
0020C3r 3                               ; are on the first or second digit.
0020C3r 3  A9 01                        lda #1
0020C5r 3  24 rr                        bit tmp2+1
0020C7r 3  D0 10                        bne @esc_x_second_digit
0020C9r 3               
0020C9r 3                               ; First digit.
0020C9r 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
0020CBr 3  B2 rr                        lda (tmp1)  ; Get the char again.
0020CDr 3               
0020CDr 3                               ; Convert to hex
0020CDr 3  20 rr rr                     jsr convert_hex_value
0020D0r 3               
0020D0r 3                               ; This is the upper nybble, so move it up.
0020D0r 3  0A                           asl
0020D1r 3  0A                           asl
0020D2r 3  0A                           asl
0020D3r 3  0A                           asl
0020D4r 3  85 rr                        sta tmp3    ; Save it for later.
0020D6r 3  4C rr rr                     jmp @next_character
0020D9r 3               
0020D9r 3               @esc_x_second_digit:
0020D9r 3               
0020D9r 3                               ; We are on the second hex digit of a \x sequence. Clear the
0020D9r 3                               ; escaped character flag (because we are handling it right
0020D9r 3                               ; here)
0020D9r 3  64 rr                        stz tmp2+1
0020DBr 3  B2 rr                        lda (tmp1)
0020DDr 3               
0020DDr 3                               ; Convert to hex, combine with value in tmp3
0020DDr 3  20 rr rr                     jsr convert_hex_value
0020E0r 3  05 rr                        ora tmp3
0020E2r 3               
0020E2r 3  4C rr rr                     jmp @save_character
0020E5r 3               
0020E5r 3               @check_esc_chars:
0020E5r 3                               ; Clear the escaped character flag (because we are
0020E5r 3                               ; handling it right here)
0020E5r 3  64 rr                        stz tmp2+1
0020E7r 3               
0020E7r 3                               ; Process the escaped character
0020E7r 3               @check_esc_a:
0020E7r 3  C9 61                        cmp #'a'
0020E9r 3  D0 05                        bne @check_esc_b
0020EBr 3               
0020EBr 3                               ; BEL (ASCII value 7)
0020EBr 3  A9 07                        lda #7
0020EDr 3  4C rr rr                     jmp @save_character
0020F0r 3               
0020F0r 3               @check_esc_b:
0020F0r 3  C9 62                        cmp #'b'
0020F2r 3  D0 05                        bne @check_esc_e
0020F4r 3               
0020F4r 3                               ; Backspace (ASCII value 8)
0020F4r 3  A9 08                        lda #8
0020F6r 3  4C rr rr                     jmp @save_character
0020F9r 3               
0020F9r 3               @check_esc_e:
0020F9r 3  C9 65                        cmp #'e'
0020FBr 3  D0 04                        bne @check_esc_f
0020FDr 3               
0020FDr 3                               ; ESC (ASCII value 27)
0020FDr 3  A9 1B                        lda #27
0020FFr 3  80 75                        bra @save_character
002101r 3               
002101r 3               @check_esc_f:
002101r 3  C9 66                        cmp #'f'
002103r 3  D0 04                        bne @check_esc_l
002105r 3               
002105r 3                               ; FF (ASCII value 12)
002105r 3  A9 0C                        lda #12
002107r 3  80 6D                        bra @save_character
002109r 3               
002109r 3               @check_esc_l:
002109r 3  C9 6C                        cmp #'l'
00210Br 3  D0 04                        bne @check_esc_m
00210Dr 3               
00210Dr 3                               ; LF (ASCII value 10)
00210Dr 3  A9 0A                        lda #10
00210Fr 3  80 65                        bra @save_character
002111r 3               
002111r 3               @check_esc_m:
002111r 3                               ; This one is not like the others because we save two
002111r 3                               ; characters
002111r 3  C9 6D                        cmp #'m'
002113r 3  D0 09                        bne @check_esc_n
002115r 3               
002115r 3                               ; CR/LF pair (ASCII values 13, 10)
002115r 3  A9 0D                        lda #13
002117r 3  20 rr rr                     jsr cmpl_a
00211Ar 3  A9 0A                        lda #10
00211Cr 3  80 58                        bra @save_character
00211Er 3               
00211Er 3               @check_esc_n:
00211Er 3  C9 6E                        cmp #'n'
002120r 3  D0 04                        bne @check_esc_q
002122r 3               
002122r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
002122r 3  A9 0A                        lda #10
002124r 3  80 50                        bra @save_character
002126r 3               
002126r 3               @check_esc_q:
002126r 3  C9 71                        cmp #'q'
002128r 3  D0 04                        bne @check_esc_r
00212Ar 3               
00212Ar 3                               ; Double quote (ASCII value 34)
00212Ar 3  A9 22                        lda #34
00212Cr 3  80 48                        bra @save_character
00212Er 3               
00212Er 3               @check_esc_r:
00212Er 3  C9 72                        cmp #'r'
002130r 3  D0 04                        bne @check_esc_t
002132r 3               
002132r 3                               ; CR (ASCII value 13)
002132r 3  A9 0D                        lda #13
002134r 3  80 40                        bra @save_character
002136r 3               
002136r 3               @check_esc_t:
002136r 3  C9 74                        cmp #'t'
002138r 3  D0 04                        bne @check_esc_v
00213Ar 3               
00213Ar 3                               ; Horizontal TAB (ASCII value 9)
00213Ar 3  A9 09                        lda #9
00213Cr 3  80 38                        bra @save_character
00213Er 3               
00213Er 3               @check_esc_v:
00213Er 3  C9 76                        cmp #'v'
002140r 3  D0 04                        bne @check_esc_z
002142r 3               
002142r 3                               ; Vertical TAB (ASCII value 11)
002142r 3  A9 0B                        lda #11
002144r 3  80 30                        bra @save_character
002146r 3               
002146r 3               @check_esc_z:
002146r 3  C9 7A                        cmp #'z'
002148r 3  D0 04                        bne @check_esc_quote
00214Ar 3               
00214Ar 3                               ; NULL (ASCII value 0)
00214Ar 3  A9 00                        lda #0
00214Cr 3  80 28                        bra @save_character
00214Er 3               
00214Er 3               @check_esc_quote:
00214Er 3  C9 22                        cmp #$22
002150r 3  D0 04                        bne @check_esc_x
002152r 3               
002152r 3                               ; Double quote (ASCII value 34)
002152r 3  A9 22                        lda #34
002154r 3  80 20                        bra @save_character
002156r 3               
002156r 3               @check_esc_x:
002156r 3  C9 78                        cmp #'x'
002158r 3  D0 06                        bne @check_esc_backslash
00215Ar 3               
00215Ar 3                               ; This one is difficult. We need to get the next TWO
00215Ar 3                               ; characters (which might require a refill in the middle)
00215Ar 3                               ; and combine them as two hex digits. We do this by
00215Ar 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
00215Ar 3                               ; and using bit 0 to keep track of which digit we are on.
00215Ar 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
00215Cr 3  85 rr                        sta tmp2+1
00215Er 3  80 19                        bra @next_character
002160r 3               
002160r 3               @check_esc_backslash:
002160r 3  C9 5C                        cmp #$5C
002162r 3  D0 04                        bne @not_escaped
002164r 3               
002164r 3                               ; Backslash (ASCII value 92)
002164r 3  A9 5C                        lda #92
002166r 3  80 0E                        bra @save_character
002168r 3               
002168r 3               @not_escaped:
002168r 3                               ; Check for the backslash to see if we should escape
002168r 3                               ; the next char.
002168r 3  C9 5C                        cmp #$5C        ; The backslash char
00216Ar 3  D0 06                        bne @regular_char
00216Cr 3               
00216Cr 3                               ; We found a backslash.  Don't save anyhing, but set
00216Cr 3                               ; a flag (in tmp2+1) to handle the next char. We don't
00216Cr 3                               ; try to get the next char here as it may require a
00216Cr 3                               ; refill of the input buffer.
00216Cr 3  A9 FF                        lda #$FF
00216Er 3  85 rr                        sta tmp2+1
002170r 3  80 07                        bra @next_character
002172r 3               
002172r 3               @regular_char:
002172r 3                               ; Check if the current character is the end of the string.
002172r 3  C9 22                        cmp #$22        ; ASCII for "
002174r 3  F0 0C                        beq @found_string_end
002176r 3               
002176r 3               @save_character:
002176r 3                               ; If we didn't reach the end of the string, compile this
002176r 3                               ; character into the dictionary
002176r 3  20 rr rr                     jsr cmpl_a
002179r 3               
002179r 3               @next_character:
002179r 3                               ; Move on to the next character.
002179r 3  E6 rr                        inc toin
00217Br 3  D0 02                        bne @savechars_loop_longjump
00217Dr 3  E6 rr                        inc toin+1
00217Fr 3               
00217Fr 3               @savechars_loop_longjump:
00217Fr 3  4C rr rr                     jmp @savechars_loop
002182r 3               
002182r 3               @found_string_end:
002182r 3                               ; Use up the delimiter.
002182r 3  E6 rr                        inc toin
002184r 3  D0 02                        bne @1
002186r 3  E6 rr                        inc toin+1
002188r 3               @1:
002188r 3                               ; Calculate the length of the string, which is the
002188r 3                               ; difference between cp and the address of the start
002188r 3                               ; of the string (currently saved on the stack).
002188r 3  A5 rr                        lda cp
00218Ar 3  38                           sec
00218Br 3  F5 02                        sbc 2,x
00218Dr 3  95 00                        sta 0,x         ; LSB
00218Fr 3  A5 rr                        lda cp+1
002191r 3  F5 03                        sbc 3,x
002193r 3  95 01                        sta 1,x         ; MSB
002195r 3               
002195r 3                               ; Update the address of the jump-over jmp instruction.
002195r 3                               ; First determine location of jmp instructions address.
002195r 3                               ; It should be 2 bytes before the start of the string.
002195r 3                               ; Compute it into tmp1, which is no longer being used.
002195r 3  B5 02                        lda 2,x
002197r 3  38                           sec
002198r 3  E9 02                        sbc #2
00219Ar 3  85 rr                        sta tmp1
00219Cr 3  B5 03                        lda 3,x
00219Er 3  E9 00                        sbc #0          ; Propagate borrow
0021A0r 3  85 rr                        sta tmp1+1
0021A2r 3               
0021A2r 3                               ; Update the address of the jump to HERE.
0021A2r 3  A5 rr                        lda cp
0021A4r 3  92 rr                        sta (tmp1)
0021A6r 3  A0 01                        ldy #1
0021A8r 3  A5 rr                        lda cp+1
0021AAr 3  91 rr                        sta (tmp1),y
0021ACr 3               
0021ACr 3                               ; What happens next depends on the state (which is bad, but
0021ACr 3                               ; that's the way it works at the moment). If we are
0021ACr 3                               ; interpretating, we save the string to a transient buffer
0021ACr 3                               ; and return that address (used for file calls, see
0021ACr 3                               ; https://forth-standard.org/standard/file/Sq . If we're
0021ACr 3                               ; compiling, we just need SLITERAL
0021ACr 3  A5 rr                        lda state
0021AEr 3  05 rr                        ora state+1             ; paranoid
0021B0r 3  F0 03                        beq @done
0021B2r 3               
0021B2r 3                               ; Jump into the middle of the sliteral word, after the
0021B2r 3                               ; string data has been compiled into the dictionary,
0021B2r 3                               ; because we've already done that step.
0021B2r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
0021B5r 3               
0021B5r 3               @done:
0021B5r 3  60           z_s_quote:      rts
0021B6r 3               
0021B6r 3               
0021B6r 3               
0021B6r 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
0021B6r 3               ; ## "s>d"  auto  ANS core
0021B6r 3                       ; """https://forth-standard.org/standard/core/StoD"""
0021B6r 3               
0021B6r 3               xt_s_to_d:
0021B6r 3  20 rr rr                     jsr underflow_1
0021B9r 3               
0021B9r 3  CA                           dex
0021BAr 3  CA                           dex
0021BBr 3  74 00                        stz 0,x
0021BDr 3  74 01                        stz 1,x
0021BFr 3               
0021BFr 3  B5 03                        lda 3,x
0021C1r 3  10 04                        bpl @done
0021C3r 3               
0021C3r 3                               ; negative, extend sign
0021C3r 3  D6 00                        dec 0,x
0021C5r 3  D6 01                        dec 1,x
0021C7r 3               @done:
0021C7r 3  60           z_s_to_d:       rts
0021C8r 3               
0021C8r 3               
0021C8r 3               
0021C8r 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
0021C8r 3               ; ## "save-buffers"  tested  ANS block
0021C8r 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
0021C8r 3               
0021C8r 3               xt_save_buffers:
0021C8r 3                               ; Check the buffer status
0021C8r 3  A0 2C                        ldy #buffstatus_offset
0021CAr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
0021CCr 3  C9 03                        cmp #3          ; LSB is needed.
0021CEr 3  D0 12                        bne @done       ; Either not used or not dirty = done!
0021D0r 3               
0021D0r 3                               ; We need to save the block.
0021D0r 3  20 rr rr                     jsr xt_blkbuffer
0021D3r 3  20 rr rr                     jsr xt_buffblocknum
0021D6r 3  20 rr rr                     jsr xt_fetch
0021D9r 3  20 rr rr                     jsr xt_block_write
0021DCr 3               
0021DCr 3                               ; Mark the buffer as clean now.
0021DCr 3  A9 01                        lda #1
0021DEr 3  A0 2C                        ldy #buffstatus_offset
0021E0r 3  91 rr                        sta (up),y
0021E2r 3               
0021E2r 3               @done:
0021E2r 3  60           z_save_buffers: rts
0021E3r 3               
0021E3r 3               
0021E3r 3               
0021E3r 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
0021E3r 3               ; ## "scr"  auto  ANS block ext
0021E3r 3                       ; """https://forth-standard.org/standard/block/SCR"""
0021E3r 3               xt_scr:
0021E3r 3                               ; SCR is at UP + scr_offset
0021E3r 3  CA                           dex
0021E4r 3  CA                           dex
0021E5r 3  18                           clc
0021E6r 3  A5 rr                        lda up
0021E8r 3  69 02                        adc #scr_offset ; Add offset
0021EAr 3  95 00                        sta 0,x
0021ECr 3  A5 rr                        lda up+1
0021EEr 3  69 00                        adc #0          ; Adding carry
0021F0r 3  95 01                        sta 1,x
0021F2r 3               
0021F2r 3  60           z_scr:          rts
0021F3r 3               
0021F3r 3               
0021F3r 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
0021F3r 3               ; ## "search"   auto  ANS string
0021F3r 3                       ; """https://forth-standard.org/standard/string/SEARCH
0021F3r 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
0021F3r 3                       ; addr1 u1). If a match is found the flag will be true and
0021F3r 3                       ; addr3 will have the address of the start of the match and u3 will have
0021F3r 3                       ; the number of characters remaining from the match point to the end
0021F3r 3                       ; of the original string1. If a match is not found, the flag will be
0021F3r 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
0021F3r 3                       ; """
0021F3r 3               
0021F3r 3               xt_search:
0021F3r 3  20 rr rr                     jsr underflow_4
0021F6r 3               
0021F6r 3                               ; ANS says if the second string is a zero-length string it
0021F6r 3                               ; automatically matches.
0021F6r 3  B5 00                        lda 0,x
0021F8r 3  15 01                        ora 1,x
0021FAr 3  D0 0B                        bne @start_search
0021FCr 3               
0021FCr 3                               ; The second string is a zero length string.  Just remove
0021FCr 3                               ; the second string and put a true flag.
0021FCr 3  E8                           inx             ; Remove u2
0021FDr 3  E8                           inx
0021FEr 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
002200r 3  95 00                        sta 0,x
002202r 3  95 01                        sta 1,x
002204r 3  4C rr rr                     jmp z_search
002207r 3               
002207r 3               @start_search:
002207r 3                               ; Put an offset (starting at zero) on the stack.
002207r 3  20 rr rr                     jsr xt_zero
00220Ar 3               
00220Ar 3               @search_loop:
00220Ar 3                               ; We stop (not found) when u2 + offset > u1
00220Ar 3                               ; Calculate u2+offset into tmp1
00220Ar 3  18                           clc
00220Br 3  B5 00                        lda 0,x
00220Dr 3  75 02                        adc 2,x
00220Fr 3  85 rr                        sta tmp1
002211r 3  B5 01                        lda 1,x
002213r 3  75 03                        adc 3,x
002215r 3               
002215r 3               
002215r 3                               ; Compare to u1. Start with the high byte
002215r 3  D5 07                        cmp 7,x
002217r 3  90 12                        bcc @init_comparison ; Obviously less
002219r 3  D0 06                        bne @not_found
00221Br 3               
00221Br 3                               ; The upper address byte matched - check the lower byte
00221Br 3                               ; Load u1 first so we can use just a carry to check.
00221Br 3  B5 06                        lda 6,x
00221Dr 3  C5 rr                        cmp tmp1
00221Fr 3  B0 0A                        bcs @init_comparison
002221r 3               
002221r 3               @not_found:
002221r 3                               ; The substring isn't in the main string.
002221r 3                               ; Return just the main string and a false flag.
002221r 3  E8                           inx             ; Remove offset
002222r 3  E8                           inx
002223r 3  E8                           inx             ; Remove u2
002224r 3  E8                           inx
002225r 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
002227r 3  74 01                        stz 1,x
002229r 3  80 66                        bra z_search
00222Br 3               
00222Br 3               @init_comparison:
00222Br 3                               ; Use tmp1 to hold address in string 1.
00222Br 3                               ; Use tmp2 to hold address in string 2.
00222Br 3                               ; Use tmp3 to hold the number of characters left to check.
00222Br 3               
00222Br 3                               ; Compute the starting address in string 1
00222Br 3                               ; as addr1 + offset
00222Br 3  18                           clc
00222Cr 3  B5 08                        lda 8,x
00222Er 3  75 00                        adc 0,x
002230r 3  85 rr                        sta tmp1
002232r 3  B5 09                        lda 9,x
002234r 3  75 01                        adc 1,x
002236r 3  85 rr                        sta tmp1+1
002238r 3               
002238r 3                               ; The starting address in string 2 is just addr2.
002238r 3  B5 04                        lda 4,x
00223Ar 3  85 rr                        sta tmp2
00223Cr 3  B5 05                        lda 5,x
00223Er 3  85 rr                        sta tmp2+1
002240r 3               
002240r 3                               ; The number of characters to check is u2.
002240r 3  B5 02                        lda 2,x
002242r 3  85 rr                        sta tmp3
002244r 3  B5 03                        lda 3,x
002246r 3  85 rr                        sta tmp3+1
002248r 3               
002248r 3               @comparison_loop:
002248r 3                               ; Check to see if the current characters match.
002248r 3  B2 rr                        lda (tmp1)
00224Ar 3  D2 rr                        cmp (tmp2)
00224Cr 3  F0 05                        beq @letters_match
00224Er 3               
00224Er 3                               ; One of the letters didn't match.
00224Er 3                               ; Increment the offset and try again.
00224Er 3  20 rr rr                     jsr xt_one_plus
002251r 3  80 B7                        bra @search_loop
002253r 3               
002253r 3               @letters_match:
002253r 3                               ; The letters match.  Advance the pointers until the
002253r 3                               ; count reaches zero.
002253r 3  E6 rr                        inc tmp1
002255r 3  D0 02                        bne @1
002257r 3  E6 rr                        inc tmp1+1
002259r 3               @1:
002259r 3  E6 rr                        inc tmp2
00225Br 3  D0 02                        bne @2
00225Dr 3  E6 rr                        inc tmp2+1
00225Fr 3               @2:
00225Fr 3                               ; Decrement the count of remaining letters to check.
00225Fr 3  A5 rr                        lda tmp3
002261r 3  D0 02                        bne @3
002263r 3  C6 rr                        dec tmp3+1
002265r 3               @3:
002265r 3  C6 rr                        dec tmp3
002267r 3               
002267r 3                               ; Check if we've reached zero.
002267r 3  A5 rr                        lda tmp3
002269r 3  05 rr                        ora tmp3+1
00226Br 3  D0 DB                        bne @comparison_loop ; Check the next letter
00226Dr 3               
00226Dr 3                               ; We've run out of letters and they all match!
00226Dr 3                               ; Return (addr1+offset) (u1-offset) true
00226Dr 3                               ; Add offset to addr1.
00226Dr 3  18                           clc
00226Er 3  B5 00                        lda 0,x
002270r 3  75 08                        adc 8,x
002272r 3  95 08                        sta 8,x
002274r 3  B5 01                        lda 1,x
002276r 3  75 09                        adc 9,x
002278r 3  95 09                        sta 9,x
00227Ar 3               
00227Ar 3                               ; Subtract offset from u1.
00227Ar 3  38                           sec
00227Br 3  B5 06                        lda 6,x
00227Dr 3  F5 00                        sbc 0,x
00227Fr 3  95 06                        sta 6,x
002281r 3  B5 07                        lda 7,x
002283r 3  F5 01                        sbc 1,x
002285r 3  95 07                        sta 7,x
002287r 3               
002287r 3                               ; Replace addr2, u2, and offset with a true flag.
002287r 3  E8                           inx             ; drop offset
002288r 3  E8                           inx
002289r 3  E8                           inx             ; drop u2
00228Ar 3  E8                           inx
00228Br 3  A9 FF                        lda #$FF
00228Dr 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
00228Fr 3  95 01                        sta 1,x
002291r 3               
002291r 3  60           z_search:       rts
002292r 3               
002292r 3               
002292r 3               
002292r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
002292r 3               ; ## ";"  auto  ANS core
002292r 3                       ; """https://forth-standard.org/standard/core/Semi
002292r 3                       ; End the compilation of a new word into the Dictionary.
002292r 3                       ;
002292r 3                       ; When we
002292r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
002292r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
002292r 3                       ; A Forth definition would be (see "Starting Forth"):
002292r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
002292r 3                       ; practice of Gforth, we warn here if a word has been redefined.
002292r 3                       ; """
002292r 3               
002292r 3               xt_semicolon:
002292r 3                               ; Check if this is a : word or a :NONAME word.
002292r 3  24 rr                        bit status
002294r 3  70 11                        bvs @colonword
002296r 3               
002296r 3                               ; This is a :NONAME word - just put an RTS on the end and
002296r 3                               ; the address (held in workword) on the stack.
002296r 3  A9 60                        lda #$60                ; opcode for RTS
002298r 3  20 rr rr                     jsr cmpl_a
00229Br 3               
00229Br 3  CA                           dex
00229Cr 3  CA                           dex
00229Dr 3  A5 rr                        lda workword
00229Fr 3  95 00                        sta 0,x
0022A1r 3  A5 rr                        lda workword+1
0022A3r 3  95 01                        sta 1,x
0022A5r 3  80 45                        bra @semicolon_done
0022A7r 3               
0022A7r 3               @colonword:
0022A7r 3                               ; CP is the byte that will be the address we use in the
0022A7r 3                               ; header as the end-of-compile address (z_word). This is
0022A7r 3                               ; six bytes down from the header
0022A7r 3  A0 06                        ldy #6
0022A9r 3  A5 rr                        lda cp
0022ABr 3  91 rr                        sta (workword),y
0022ADr 3  C8                           iny
0022AEr 3  A5 rr                        lda cp+1
0022B0r 3  91 rr                        sta (workword),y
0022B2r 3               
0022B2r 3                               ; Allocate one further byte and save the RTS instruction
0022B2r 3                               ; there
0022B2r 3  A9 60                        lda #$60                ; opcode for RTS
0022B4r 3  20 rr rr                     jsr cmpl_a
0022B7r 3               
0022B7r 3                               ; Before we formally add the word to the Dictionary, we
0022B7r 3                               ; check to see if it is already present, and if yes, we
0022B7r 3                               ; warn the user.
0022B7r 3               
0022B7r 3                               ; See if word already in Dictionary.
0022B7r 3                               ; (STATUS bit 7 will be high as CREATE already
0022B7r 3                               ;  checked for us.)
0022B7r 3  24 rr                        bit status
0022B9r 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
0022BBr 3               
0022BBr 3                               ; We start by putting the string of the
0022BBr 3                               ; word we're defining on the stack
0022BBr 3  CA                           dex
0022BCr 3  CA                           dex
0022BDr 3  CA                           dex
0022BEr 3  CA                           dex
0022BFr 3               
0022BFr 3                               ; WORKWORD points to the beginning of the head of our new
0022BFr 3                               ; word, where the first byte is the length of the string
0022BFr 3                               ; We can't use LATESTNT because we haven't added the new
0022BFr 3                               ; word to the Dictionary yet
0022BFr 3  B2 rr                        lda (workword)
0022C1r 3  95 00                        sta 0,x
0022C3r 3  74 01                        stz 1,x
0022C5r 3               
0022C5r 3                               ; Eight bytes below WORKWORD is the actual beginning of
0022C5r 3                               ; the string
0022C5r 3  A5 rr                        lda workword
0022C7r 3  18                           clc
0022C8r 3  69 08                        adc #8
0022CAr 3  95 02                        sta 2,x
0022CCr 3  A5 rr                        lda workword+1
0022CEr 3  69 00                        adc #0                  ; only want carry
0022D0r 3  95 03                        sta 3,x
0022D2r 3               
0022D2r 3                               ; This word is already in the Dictionary, so we print a
0022D2r 3                               ; warning to the user.
0022D2r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
0022D4r 3  20 rr rr                     jsr print_string_no_lf
0022D7r 3               
0022D7r 3                               ; Now we print the offending word.
0022D7r 3  20 rr rr                     jsr xt_type
0022DAr 3  20 rr rr                     jsr xt_space
0022DDr 3               
0022DDr 3                               ; Clear bit 7 of status (so future words will print message
0022DDr 3                               ; by defaut)
0022DDr 3  A9 80                        lda #%10000000
0022DFr 3  14 rr                        trb status
0022E1r 3               
0022E1r 3               @new_word:
0022E1r 3                               ; Let's get this over with. Save beginning of our word
0022E1r 3                               ; as new last word in the Dictionary
0022E1r 3  A5 rr                        lda workword
0022E3r 3  85 rr                        sta dp
0022E5r 3  A5 rr                        lda workword+1
0022E7r 3  85 rr                        sta dp+1
0022E9r 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
0022ECr 3                                                       ; CURRENT wordlist.
0022ECr 3               @semicolon_done:
0022ECr 3                               ; Word definition complete. Return compile flag to zero
0022ECr 3                               ; to return to interpret mode
0022ECr 3  64 rr                        stz state
0022EEr 3  64 rr                        stz state+1
0022F0r 3               
0022F0r 3  60           z_semicolon:    rts
0022F1r 3               
0022F1r 3               
0022F1r 3               
0022F1r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
0022F1r 3               ; ## "sign"  auto  ANS core
0022F1r 3                       ; """https://forth-standard.org/standard/core/SIGN
0022F1r 3                       ;
0022F1r 3                       ; Code based on
0022F1r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0022F1r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
0022F1r 3                       ; """
0022F1r 3               
0022F1r 3               xt_sign:
0022F1r 3  20 rr rr                     jsr underflow_1
0022F4r 3               
0022F4r 3  B5 01                        lda 1,x         ; check MSB of TOS
0022F6r 3  30 04                        bmi @minus
0022F8r 3               
0022F8r 3  E8                           inx
0022F9r 3  E8                           inx
0022FAr 3  80 09                        bra @done
0022FCr 3               @minus:
0022FCr 3  A9 2D                        lda #$2D        ; ASCII for "-"
0022FEr 3  95 00                        sta 0,x         ; overwrite TOS
002300r 3  74 01                        stz 1,x         ; paranoid
002302r 3               
002302r 3  20 rr rr                     jsr xt_hold
002305r 3               @done:
002305r 3  60           z_sign:         rts
002306r 3               
002306r 3               
002306r 3               
002306r 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
002306r 3               ; ## "/"  auto  ANS core
002306r 3                       ; """https://forth-standard.org/standard/core/Div
002306r 3                       ;
002306r 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
002306r 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
002306r 3                       ; This code is currently unoptimized. This code without the SLASH
002306r 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
002306r 3                       ; """
002306r 3               
002306r 3               xt_slash:
002306r 3                               ; With all the multiplication going on, it would be hard to
002306r 3                               ; make sure that one of our temporary variables is not
002306r 3                               ; overwritten. We make sure that doesn't happen by taking the
002306r 3                               ; hit of pushing the flag to the 65c02's stack
002306r 3  A9 00                        lda #0
002308r 3  48                           pha
002309r 3  80 03                        bra _common
00230Br 3               
00230Br 3               xt_slash_mod:
00230Br 3                               ; Note that /MOD accesses this code
00230Br 3  A9 FF                        lda #$FF
00230Dr 3  48                           pha             ; falls through to _common
00230Er 3               
00230Er 3               _common:
00230Er 3  20 rr rr                     jsr xt_to_r             ; >R
002311r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
002314r 3  20 rr rr                     jsr xt_r_from           ; R>
002317r 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
00231Ar 3               
00231Ar 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
00231Ar 3                               ; $FF is SLASH MOD
00231Ar 3  68                           pla
00231Br 3  D0 05                        bne @done
00231Dr 3               
00231Dr 3                               ; The following code is for SLASH only
00231Dr 3  20 rr rr                     jsr xt_swap
002320r 3  E8                           inx             ; DROP
002321r 3  E8                           inx
002322r 3               @done:
002322r 3               z_slash_mod:
002322r 3  60           z_slash:        rts
002323r 3               
002323r 3               
002323r 3               
002323r 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
002323r 3               ; ## "/mod"  auto  ANS core
002323r 3                       ; """https://forth-standard.org/standard/core/DivMOD
002323r 3                       ;
002323r 3                       ; This is a dummy entry, the actual code is shared with SLASH
002323r 3                       ; """
002323r 3               
002323r 3               
002323r 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
002323r 3               ; ## "/string"  auto  ANS string
002323r 3                       ; """https://forth-standard.org/standard/string/DivSTRING
002323r 3                       ;
002323r 3                       ; Forth code is
002323r 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
002323r 3                       ; Put differently, we need to add TOS and 3OS, and subtract
002323r 3                       ; TOS from NOS, and then drop TOS
002323r 3                       ; """
002323r 3               
002323r 3               xt_slash_string:
002323r 3  20 rr rr                     jsr underflow_3
002326r 3               
002326r 3  18                           clc             ; 3OS+TOS
002327r 3  B5 00                        lda 0,x
002329r 3  75 04                        adc 4,x
00232Br 3  95 04                        sta 4,x
00232Dr 3               
00232Dr 3  B5 01                        lda 1,x
00232Fr 3  75 05                        adc 5,x
002331r 3  95 05                        sta 5,x
002333r 3               
002333r 3  38                           sec             ; NOS-TOS
002334r 3  B5 02                        lda 2,x
002336r 3  F5 00                        sbc 0,x
002338r 3  95 02                        sta 2,x
00233Ar 3               
00233Ar 3  B5 03                        lda 3,x
00233Cr 3  F5 01                        sbc 1,x
00233Er 3  95 03                        sta 3,x
002340r 3               
002340r 3  E8                           inx
002341r 3  E8                           inx
002342r 3               
002342r 3  60           z_slash_string: rts
002343r 3               
002343r 3               
002343r 3               
002343r 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
002343r 3               ; ## "sliteral" auto  ANS string
002343r 3                       ; """https://forth-standard.org/standard/string/SLITERAL
002343r 3                       ; Add the runtime for an existing string.
002343r 3                       ; """
002343r 3               
002343r 3               xt_sliteral:
002343r 3  20 rr rr                     jsr underflow_2
002346r 3               
002346r 3                               ; We can't assume that ( addr u ) of the current string is in
002346r 3                               ; a stable area (eg. already in the dictionary.) Copy the
002346r 3                               ; string data into the dictionary using move.
002346r 3               
002346r 3                               ; Put a jmp over the string data with address to be filled
002346r 3                               ; in later.
002346r 3  A9 4C                        lda #$4C
002348r 3  20 rr rr                     jsr cmpl_a
00234Br 3               
00234Br 3                               ; Address to be filled in later.
00234Br 3  20 rr rr                     jsr cmpl_a
00234Er 3  20 rr rr                     jsr cmpl_a
002351r 3               
002351r 3                               ; Turn the data stack from ( addr u ) into
002351r 3                               ; ( here u addr here u ) so move can be called with
002351r 3                               ; the remaining items on the stack ready for processing.
002351r 3                               ; Reserve three extra words on the stack.
002351r 3  8A                           txa
002352r 3  38                           sec
002353r 3  E9 06                        sbc #6
002355r 3  AA                           tax
002356r 3               
002356r 3                               ; Move addr down from TOS-4 to TOS-2
002356r 3  B5 08                        lda 8,x
002358r 3  95 04                        sta 4,x
00235Ar 3  B5 09                        lda 9,x
00235Cr 3  95 05                        sta 5,x
00235Er 3               
00235Er 3                               ; Copy u from TOS-3 to TOS
00235Er 3  B5 06                        lda 6,x
002360r 3  95 00                        sta 0,x
002362r 3  B5 07                        lda 7,x
002364r 3  95 01                        sta 1,x
002366r 3               
002366r 3                               ; Put HERE into TOS-1 and TOS-4
002366r 3  A5 rr                        lda cp
002368r 3  95 08                        sta 8,x
00236Ar 3  95 02                        sta 2,x
00236Cr 3  A5 rr                        lda cp+1
00236Er 3  95 09                        sta 9,x
002370r 3  95 03                        sta 3,x
002372r 3               
002372r 3                               ; Copy the string into the dictionary.
002372r 3  20 rr rr                     jsr xt_move
002375r 3               
002375r 3                               ; Update cp.
002375r 3  18                           clc
002376r 3  A5 rr                        lda cp
002378r 3  75 00                        adc 0,x
00237Ar 3  85 rr                        sta cp
00237Cr 3  A5 rr                        lda cp+1
00237Er 3  75 01                        adc 1,x
002380r 3  85 rr                        sta cp+1
002382r 3               
002382r 3                               ; Update the address of the jump-over jmp instruction.
002382r 3                               ; First determine location of jmp instructions address.
002382r 3                               ; It should be 2 bytes before the start of the string.
002382r 3               
002382r 3                               ; Compute it into tmp1, which is no longer being used.
002382r 3  B5 02                        lda 2,x
002384r 3  38                           sec
002385r 3  E9 02                        sbc #2
002387r 3  85 rr                        sta tmp1
002389r 3  B5 03                        lda 3,x
00238Br 3  E9 00                        sbc #0          ; Propagate borrow
00238Dr 3  85 rr                        sta tmp1+1
00238Fr 3               
00238Fr 3                               ; Update the address of the jump to HERE.
00238Fr 3  A5 rr                        lda cp
002391r 3  92 rr                        sta (tmp1)
002393r 3  A0 01                        ldy #1
002395r 3  A5 rr                        lda cp+1
002397r 3  91 rr                        sta (tmp1),y
002399r 3               
002399r 3                               ; Stack is now ( addr2 u ) where addr2 is the new
002399r 3                               ; location in the dictionary.
002399r 3               
002399r 3               sliteral_const_str:
002399r 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
002399r 3                               ; pushes the new ( addr u ) pair to the Data Stack.
002399r 3                               ; When we're done, the code will look like this:
002399r 3               
002399r 3                               ; xt -->    jmp a
002399r 3                               ;           <string data bytes>
002399r 3                               ;  a -->    jsr sliteral_runtime
002399r 3                               ;           <string address>
002399r 3                               ;           <string length>
002399r 3                               ; rts -->
002399r 3               
002399r 3                               ; This means we'll have to adjust the return address for two
002399r 3                               ; cells, not just one
002399r 3  A0 rr                        ldy #>sliteral_runtime
00239Br 3  A9 rr                        lda #<sliteral_runtime
00239Dr 3  20 rr rr                     jsr cmpl_subroutine
0023A0r 3               
0023A0r 3                               ; We want to have the address end up as NOS and the length
0023A0r 3                               ; as TOS, so we store the address first
0023A0r 3  B4 03                        ldy 3,x                ; address MSB
0023A2r 3  B5 02                        lda 2,x                ; address LSB
0023A4r 3  20 rr rr                     jsr cmpl_word
0023A7r 3               
0023A7r 3  B4 01                        ldy 1,x                ; length MSB
0023A9r 3  B5 00                        lda 0,x                ; length LSB
0023ABr 3  20 rr rr                     jsr cmpl_word
0023AEr 3               
0023AEr 3                               ; clean up and leave
0023AEr 3  E8                           inx
0023AFr 3  E8                           inx
0023B0r 3  E8                           inx
0023B1r 3  E8                           inx
0023B2r 3               
0023B2r 3  60           z_sliteral:     rts
0023B3r 3               
0023B3r 3               
0023B3r 3               sliteral_runtime:
0023B3r 3               
0023B3r 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
0023B3r 3                       ; the Data Stack. We arrive here with the return address as the
0023B3r 3                       ; top of Return Stack, which points to the address of the string
0023B3r 3                       ; """
0023B3r 3  CA                           dex
0023B4r 3  CA                           dex
0023B5r 3  CA                           dex
0023B6r 3  CA                           dex
0023B7r 3               
0023B7r 3                               ; Get the address of the string address off the stack and
0023B7r 3                               ; increase by one because of the RTS mechanics
0023B7r 3  68                           pla
0023B8r 3  85 rr                        sta tmp1        ; LSB of address
0023BAr 3  68                           pla
0023BBr 3  85 rr                        sta tmp1+1      ; MSB of address
0023BDr 3               
0023BDr 3                               ; Walk through both and save them
0023BDr 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
0023BFr 3  B1 rr                        lda (tmp1),y
0023C1r 3  95 02                        sta 2,x         ; LSB of address
0023C3r 3  C8                           iny
0023C4r 3               
0023C4r 3  B1 rr                        lda (tmp1),y
0023C6r 3  95 03                        sta 3,x         ; MSB of address
0023C8r 3  C8                           iny
0023C9r 3               
0023C9r 3  B1 rr                        lda (tmp1),y
0023CBr 3  95 00                        sta 0,x         ; LSB of length
0023CDr 3  C8                           iny
0023CEr 3               
0023CEr 3  B1 rr                        lda (tmp1),y
0023D0r 3  95 01                        sta 1,x         ; MSB of length
0023D2r 3               
0023D2r 3                               ; restore return address
0023D2r 3  18                           clc
0023D3r 3  A5 rr                        lda tmp1
0023D5r 3  69 04                        adc #4
0023D7r 3  A8                           tay             ; LSB
0023D8r 3  A5 rr                        lda tmp1+1
0023DAr 3  69 00                        adc #0          ; we only need carry
0023DCr 3  48                           pha             ; MSB
0023DDr 3  5A                           phy
0023DEr 3               
0023DEr 3  60                           rts
0023DFr 3               
0023DFr 3               
0023DFr 3               
0023DFr 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
0023DFr 3               ; ## "sm/rem"  auto  ANS core
0023DFr 3                       ; """https://forth-standard.org/standard/core/SMDivREM
0023DFr 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
0023DFr 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
0023DFr 3                       ;
0023DFr 3                       ; Forth:
0023DFr 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
0023DFr 3                       ; R> ?NEGATE SWAP
0023DFr 3                       ; """
0023DFr 3               
0023DFr 3               xt_sm_slash_rem:
0023DFr 3  20 rr rr                     jsr underflow_3 ; contains double number
0023E2r 3               
0023E2r 3                               ; push MSB of high cell of d to Data Stack so we can check
0023E2r 3                               ; its sign later
0023E2r 3  B5 03                        lda 3,x
0023E4r 3  48                           pha
0023E5r 3               
0023E5r 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
0023E5r 3                               ; its sign later as well
0023E5r 3  B5 01                        lda 1,x
0023E7r 3  55 03                        eor 3,x
0023E9r 3  48                           pha
0023EAr 3               
0023EAr 3                               ; Prepare division by getting absolute of n1 and d
0023EAr 3  20 rr rr                     jsr xt_abs
0023EDr 3  E8                           inx             ; pretend we pushed n1 to R
0023EEr 3  E8                           inx
0023EFr 3               
0023EFr 3  20 rr rr                     jsr xt_dabs
0023F2r 3  CA                           dex
0023F3r 3  CA                           dex
0023F4r 3               
0023F4r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
0023F7r 3               
0023F7r 3                               ; if the XOR compiled above is negative, negate the
0023F7r 3                               ; quotient (n3)
0023F7r 3  68                           pla
0023F8r 3  10 03                        bpl @1
0023FAr 3  20 rr rr                     jsr xt_negate
0023FDr 3               @1:
0023FDr 3                               ; if d was negative, negate the remainder (n2)
0023FDr 3  68                           pla
0023FEr 3  10 07                        bpl @done
002400r 3               
002400r 3  E8                           inx             ; pretend we pushed quotient to R
002401r 3  E8                           inx
002402r 3  20 rr rr                     jsr xt_negate
002405r 3  CA                           dex
002406r 3  CA                           dex
002407r 3               
002407r 3               @done:
002407r 3  60           z_sm_slash_rem: rts
002408r 3               
002408r 3               
002408r 3               
002408r 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002408r 3               ; ## "source"  auto  ANS core
002408r 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002408r 3               xt_source:
002408r 3                               ; add address
002408r 3  CA                           dex
002409r 3  CA                           dex
00240Ar 3  A5 rr                        lda cib
00240Cr 3  95 00                        sta 0,x
00240Er 3  A5 rr                        lda cib+1
002410r 3  95 01                        sta 1,x
002412r 3               
002412r 3                               ; add size
002412r 3  CA                           dex
002413r 3  CA                           dex
002414r 3  A5 rr                        lda ciblen
002416r 3  95 00                        sta 0,x
002418r 3  A5 rr                        lda ciblen+1
00241Ar 3  95 01                        sta 1,x
00241Cr 3               
00241Cr 3  60           z_source:       rts
00241Dr 3               
00241Dr 3               
00241Dr 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
00241Dr 3               ; ## "source-id"  tested  ANS core ext
00241Dr 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
00241Dr 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
00241Dr 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
00241Dr 3                       ; string, and a text file gives the fileid.
00241Dr 3                       ; """
00241Dr 3               xt_source_id:
00241Dr 3  CA                           dex
00241Er 3  CA                           dex
00241Fr 3               
00241Fr 3  A5 rr                        lda insrc
002421r 3  95 00                        sta 0,x
002423r 3  A5 rr                        lda insrc+1
002425r 3  95 01                        sta 1,x
002427r 3               
002427r 3  60           z_source_id:    rts
002428r 3               
002428r 3               
002428r 3               ; ## SPACE ( -- ) "Print a single space"
002428r 3               ; ## "space"  auto  ANS core
002428r 3                       ; """https://forth-standard.org/standard/core/SPACE"""
002428r 3               xt_space:
002428r 3  A9 20                        lda #AscSP
00242Ar 3  20 rr rr                     jsr emit_a
00242Dr 3               
00242Dr 3  60           z_space:        rts
00242Er 3               
00242Er 3               
00242Er 3               ; ## SPACES ( u -- ) "Print a number of spaces"
00242Er 3               ; ## "spaces"  auto  ANS core
00242Er 3                       ; """https://forth-standard.org/standard/core/SPACES"""
00242Er 3               
00242Er 3               xt_spaces:
00242Er 3  20 rr rr                     jsr underflow_1
002431r 3               
002431r 3                               ; catch any zero in TOS fast
002431r 3  B5 00                        lda 0,x
002433r 3  15 01                        ora 1,x
002435r 3  F0 2A                        beq @done
002437r 3               
002437r 3                               ; Usually we're only going to print far less than 256 spaces,
002437r 3                               ; so we create a quick loop for that. Short loop could be realized
002437r 3                               ; as a separate subroutine, but unless we're really pressed for
002437r 3                               ; memory at some point, this is faster
002437r 3  B4 01                        ldy 1,x
002439r 3  D0 0C                        bne @lots_of_spaces
00243Br 3               
00243Br 3  B4 00                        ldy 0,x
00243Dr 3               @quick_loop:
00243Dr 3                               ; we reach here knowing that there must be a number that is not
00243Dr 3                               ; zero in the TOS
00243Dr 3  A9 20                        lda #AscSP
00243Fr 3  20 rr rr                     jsr emit_a
002442r 3  88                           dey
002443r 3  F0 1C                        beq @done
002445r 3  80 F6                        bra @quick_loop
002447r 3               
002447r 3               @lots_of_spaces:
002447r 3                               ; We go through the first loop once to get rid of the lower
002447r 3                               ; counter byte. This could be zero
002447r 3  B4 00                        ldy 0,x
002449r 3               
002449r 3               @first_slow_loop:
002449r 3  F0 08                        beq @slow_outer_loop
00244Br 3  A9 20                        lda #AscSP
00244Dr 3  20 rr rr                     jsr emit_a
002450r 3  88                           dey
002451r 3  80 F6                        bra @first_slow_loop
002453r 3               
002453r 3               @slow_outer_loop:
002453r 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
002453r 3  A0 00                        ldy #00
002455r 3               
002455r 3               @slow_inner_loop:
002455r 3  A9 20                        lda #AscSP
002457r 3  20 rr rr                     jsr emit_a
00245Ar 3  88                           dey
00245Br 3  D0 F8                        bne @slow_inner_loop
00245Dr 3               
00245Dr 3  D6 01                        dec 1,x
00245Fr 3  D0 F2                        bne @slow_outer_loop
002461r 3               
002461r 3               @done:
002461r 3  E8                           inx             ; drop
002462r 3  E8                           inx
002463r 3               
002463r 3  60           z_spaces:       rts
002464r 3               
002464r 3               
002464r 3               
002464r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
002464r 3               ; ## "*"  auto  ANS core
002464r 3                       ; """https://forth-standard.org/standard/core/Times
002464r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
002464r 3                       ;
002464r 3                       ; This is nothing  more than UM* DROP
002464r 3                       ; """
002464r 3               
002464r 3               xt_star:
002464r 3  20 rr rr                     jsr underflow_2
002467r 3               
002467r 3  20 rr rr                     jsr xt_um_star
00246Ar 3  E8                           inx
00246Br 3  E8                           inx
00246Cr 3               
00246Cr 3  60           z_star:         rts
00246Dr 3               
00246Dr 3               
00246Dr 3               
00246Dr 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
00246Dr 3               ; ## "*/"  auto  ANS core
00246Dr 3                       ; """https://forth-standard.org/standard/core/TimesDiv
00246Dr 3                       ; Multiply n1 by n2 and divide by n3, returning the result
00246Dr 3                       ; without a remainder. This is */MOD without the mod.
00246Dr 3                       ;
00246Dr 3                       ; This word
00246Dr 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
00246Dr 3                       ; pretty much what we do here
00246Dr 3                       ; """
00246Dr 3               xt_star_slash:
00246Dr 3                               ; We let */MOD check for underflow
00246Dr 3  20 rr rr                     jsr xt_star_slash_mod
002470r 3  20 rr rr                     jsr xt_swap
002473r 3  E8                           inx
002474r 3  E8                           inx
002475r 3               z_star_slash:
002475r 3  60                           rts
002476r 3               
002476r 3               
002476r 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
002476r 3               ; ## "*/mod"  auto  ANS core
002476r 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
002476r 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
002476r 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
002476r 3                       ; single-cell quotient n5.
002476r 3                       ;
002476r 3                       ; In Forth, this is
002476r 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
002476r 3                       ; """
002476r 3               xt_star_slash_mod:
002476r 3  20 rr rr                     jsr underflow_3
002479r 3               
002479r 3  20 rr rr                     jsr xt_to_r
00247Cr 3  20 rr rr                     jsr xt_m_star
00247Fr 3  20 rr rr                     jsr xt_r_from
002482r 3  20 rr rr                     jsr xt_sm_slash_rem
002485r 3               
002485r 3               z_star_slash_mod:
002485r 3  60                           rts
002486r 3               
002486r 3               
002486r 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002486r 3               ; ## "state"  auto  ANS core
002486r 3                       ; """https://forth-standard.org/standard/core/STATE
002486r 3                       ; STATE is true when in compilation state, false otherwise. Note
002486r 3                       ; we do not return the state itself, but only the address where
002486r 3                       ; it lives. The state should not be changed directly by the user; see
002486r 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002486r 3                       ; """
002486r 3               xt_state:
002486r 3  CA                           dex
002487r 3  CA                           dex
002488r 3  A9 rr                        lda #<state
00248Ar 3  95 00                        sta 0,x
00248Cr 3  A9 rr                        lda #>state
00248Er 3  95 01                        sta 1,x
002490r 3               
002490r 3  60           z_state:        rts
002491r 3               
002491r 3               
002491r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002491r 3               ; ## "!"  auto  ANS core
002491r 3                       ; """https://forth-standard.org/standard/core/Store"""
002491r 3               xt_store:
002491r 3  20 rr rr                     jsr underflow_2
002494r 3               
002494r 3  B5 02                        lda 2,x         ; LSB
002496r 3  81 00                        sta (0,x)
002498r 3               
002498r 3  F6 00                        inc 0,x
00249Ar 3  D0 02                        bne @1
00249Cr 3  F6 01                        inc 1,x
00249Er 3               @1:
00249Er 3  B5 03                        lda 3,x         ; MSB
0024A0r 3  81 00                        sta (0,x)
0024A2r 3               
0024A2r 3  E8                           inx             ; 2DROP
0024A3r 3  E8                           inx
0024A4r 3  E8                           inx
0024A5r 3  E8                           inx
0024A6r 3               
0024A6r 3  60           z_store:        rts
0024A7r 3               
0024A7r 3               
0024A7r 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
0024A7r 3               ; ## "strip-underflow"  tested  Tali Forth
0024A7r 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
0024A7r 3                       ; checking should be removed during the compilation of new words.
0024A7r 3                       ; Default is false.
0024A7r 3                       ; """
0024A7r 3               xt_strip_underflow:
0024A7r 3  CA                           dex
0024A8r 3  CA                           dex
0024A9r 3               
0024A9r 3  A9 rr                        lda #<uf_strip
0024ABr 3  95 00                        sta 0,x
0024ADr 3  A9 rr                        lda #>uf_strip
0024AFr 3  95 01                        sta 1,x
0024B1r 3               
0024B1r 3               z_strip_underflow:
0024B1r 3  60                           rts
0024B2r 3               
0024B2r 3               
0024B2r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
0024B2r 3               ; ## "swap"  auto  ANS core
0024B2r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
0024B2r 3               xt_swap:
0024B2r 3  20 rr rr                     jsr underflow_2
0024B5r 3               
0024B5r 3  B5 00                        lda 0,x         ; LSB
0024B7r 3  B4 02                        ldy 2,x
0024B9r 3  95 02                        sta 2,x
0024BBr 3  94 00                        sty 0,x
0024BDr 3               
0024BDr 3  B5 01                        lda 1,x         ; MSB
0024BFr 3  B4 03                        ldy 3,x
0024C1r 3  95 03                        sta 3,x
0024C3r 3  94 01                        sty 1,x
0024C5r 3               
0024C5r 3  60           z_swap:         rts
0024C6r 3               
0024C6r 3               
0024C6r 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
0024C6r 3               ; ## "then"  auto  ANS core
0024C6r 3                       ; """http://forth-standard.org/standard/core/THEN"""
0024C6r 3               xt_then:
0024C6r 3                               ; Get the address to jump to.
0024C6r 3  20 rr rr                     jsr xt_here
0024C9r 3               
0024C9r 3                               ; Stuff HERE in for the branch address back
0024C9r 3                               ; at the IF or ELSE (origination address is on stack).
0024C9r 3  20 rr rr                     jsr xt_swap
0024CCr 3  20 rr rr                     jsr xt_store
0024CFr 3               
0024CFr 3  60           z_then:         rts
0024D0r 3               
0024D0r 3               
0024D0r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
0024D0r 3               ; ## "thru"  tested  ANS block ext
0024D0r 3                       ; """https://forth-standard.org/standard/block/THRU"""
0024D0r 3               
0024D0r 3               xt_thru:
0024D0r 3  20 rr rr                     jsr underflow_2
0024D3r 3               
0024D3r 3                               ; We need to loop here, and can't use the data stack
0024D3r 3                               ; because the LOADed screens might use it.  We'll
0024D3r 3                               ; need to use the same trick that DO loops use, holding
0024D3r 3                               ; the limit and current index on the return stack.
0024D3r 3               
0024D3r 3                               ; Put the ending screen number on the return stack
0024D3r 3  B5 01                        lda 1,x
0024D5r 3  48                           pha
0024D6r 3  B5 00                        lda 0,x
0024D8r 3  48                           pha
0024D9r 3  E8                           inx
0024DAr 3  E8                           inx
0024DBr 3               @thru_loop:
0024DBr 3                               ; Put the starting screen number on the stack,
0024DBr 3                               ; but keep a copy
0024DBr 3  B5 01                        lda 1,x
0024DDr 3  48                           pha
0024DEr 3  B5 00                        lda 0,x
0024E0r 3  48                           pha
0024E1r 3               
0024E1r 3                               ; Load this screen.
0024E1r 3  20 rr rr                     jsr xt_load
0024E4r 3               
0024E4r 3                               ; Get the number and limit back off the stack.  Rather than
0024E4r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
0024E4r 3               
0024E4r 3                               ; Get the screen we just loaded.
0024E4r 3  68                           pla
0024E5r 3  85 rr                        sta tmp1
0024E7r 3  68                           pla
0024E8r 3  85 rr                        sta tmp1+1
0024EAr 3               
0024EAr 3                               ; Get the ending screen.
0024EAr 3  68                           pla
0024EBr 3  85 rr                        sta tmp2
0024EDr 3  68                           pla
0024EEr 3  85 rr                        sta tmp2+1
0024F0r 3               
0024F0r 3                               ; See if we just loaded the last screen.
0024F0r 3                               ; A already has the MSB of the last screen in it.
0024F0r 3  C5 rr                        cmp tmp1+1
0024F2r 3  D0 08                        bne @next_screen
0024F4r 3  A5 rr                        lda tmp2        ; Compare the LSB
0024F6r 3  C5 rr                        cmp tmp1
0024F8r 3  D0 02                        bne @next_screen
0024FAr 3  80 18                        bra @done       ; We just did the last screen.
0024FCr 3               
0024FCr 3               @next_screen:
0024FCr 3                               ; Put the ending screen back on the data stack.
0024FCr 3  A5 rr                        lda tmp2+1
0024FEr 3  48                           pha
0024FFr 3  A5 rr                        lda tmp2
002501r 3  48                           pha
002502r 3               
002502r 3                               ; Increment the current screen.
002502r 3  E6 rr                        inc tmp1
002504r 3  D0 02                        bne @1
002506r 3  E6 rr                        inc tmp1+1
002508r 3               @1:
002508r 3                               ; Put the current screen on the stack to prepare for
002508r 3                               ; the next loop.
002508r 3  CA                           dex
002509r 3  CA                           dex
00250Ar 3  A5 rr                        lda tmp1
00250Cr 3  95 00                        sta 0,x
00250Er 3  A5 rr                        lda tmp1+1
002510r 3  95 01                        sta 1,x
002512r 3  80 C7                        bra @thru_loop
002514r 3               @done:
002514r 3  60           z_thru:         rts
002515r 3               
002515r 3               
002515r 3               
002515r 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
002515r 3               ; ## "'"  auto  ANS core
002515r 3                       ; """https://forth-standard.org/standard/core/Tick"""
002515r 3               
002515r 3               xt_tick:
002515r 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002518r 3               
002518r 3                               ; if we got a zero, there was a problem getting the
002518r 3                               ; name of the word
002518r 3  B5 00                        lda 0,x
00251Ar 3  15 01                        ora 1,x
00251Cr 3  D0 05                        bne @1
00251Er 3               
00251Er 3  A9 05                        lda #err_noname
002520r 3  4C rr rr                     jmp error
002523r 3               @1:
002523r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002526r 3               
002526r 3                               ; If we didn't find the word in the Dictionary, abort
002526r 3  B5 00                        lda 0,x
002528r 3  15 01                        ora 1,x
00252Ar 3  D0 05                        bne @2
00252Cr 3               
00252Cr 3  A9 08                        lda #err_syntax
00252Er 3  4C rr rr                     jmp error
002531r 3               @2:
002531r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
002534r 3               
002534r 3  60           z_tick:         rts
002535r 3               
002535r 3               
002535r 3               
002535r 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
002535r 3               ; ## "to"  auto  ANS core ext
002535r 3                       ; """https://forth-standard.org/standard/core/TO
002535r 3                       ; Gives a new value to a, uh, VALUE.
002535r 3                       ;
002535r 3                       ; One possible Forth
002535r 3                       ; implementation is  ' >BODY !  but given the problems we have
002535r 3                       ; with >BODY on STC Forths, we do this the hard way. Since
002535r 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
002535r 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
002535r 3                       ;
002535r 3                       ; Note that the standard has different behaviors for TO depending
002535r 3                       ; on the state (https://forth-standard.org/standard/core/TO).
002535r 3                       ; This makes TO state-dependent (which is bad) and also rather
002535r 3                       ; complex (see the Gforth implementation for comparison). This
002535r 3                       ; word may not be natively compiled and must be immediate. Frankly,
002535r 3                       ; it would have made more sense to have two words for this.
002535r 3                       ; """
002535r 3               
002535r 3               xt_to:
002535r 3                               ; One way or the other, we need the xt of the word after this
002535r 3                               ; one. At this point, we don't know if we are interpreted or
002535r 3                               ; compile, so we don't know if there is a value n on the stack,
002535r 3                               ; so we can't do an underflow check yet
002535r 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002538r 3               
002538r 3                               ; The PFA (DFA in this case) is three bytes down,
002538r 3                               ; after the jump to DOCONST
002538r 3  B5 00                        lda 0,x                 ; LSB
00253Ar 3  18                           clc
00253Br 3  69 03                        adc #3
00253Dr 3  85 rr                        sta tmp1
00253Fr 3  B5 01                        lda 1,x                 ; MSB
002541r 3  69 00                        adc #0                  ; we just want the carry
002543r 3  85 rr                        sta tmp1+1
002545r 3               
002545r 3  E8                           inx
002546r 3  E8                           inx                     ; ( [n] )
002547r 3               
002547r 3                               ; Now it gets ugly. See which state we are in
002547r 3  A5 rr                        lda state
002549r 3  05 rr                        ora state+1
00254Br 3  F0 34                        beq @interpret
00254Dr 3               
00254Dr 3                               ; Well, we're compiling. We want to end up with simple
00254Dr 3                               ; code that just takes the number that is TOS and saves
00254Dr 3                               ; it in the address of the xt we were just given. So we
00254Dr 3                               ; want to compile this routine:
00254Dr 3                               ;
00254Dr 3                               ;       lda 0,x                 - B5 00
00254Dr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
00254Dr 3                               ;       lda 1,x                 - B5 01
00254Dr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
00254Dr 3                               ;       inx                     - E8
00254Dr 3                               ;       inx                     - E8
00254Dr 3                               ;
00254Dr 3                               ; which at least is nice and short. Other than that, we pretty
00254Dr 3                               ; much have to do this the hard and long way, because with the
00254Dr 3                               ; LSBs and MSBs, we can't really put the numbers in a data
00254Dr 3                               ; range and store them with a loop. Sigh.
00254Dr 3               
00254Dr 3  A0 00                        ldy #$00                ; Code for LDA 0,X
00254Fr 3  A9 B5                        lda #$B5
002551r 3  20 rr rr                     jsr cmpl_word
002554r 3               
002554r 3  A9 8D                        lda #$8D                ; Code for STA abs
002556r 3  20 rr rr                     jsr cmpl_a
002559r 3               
002559r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
00255Br 3  A5 rr                        lda tmp1
00255Dr 3  20 rr rr                     jsr cmpl_word
002560r 3               
002560r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
002562r 3  A9 B5                        lda #$B5
002564r 3  20 rr rr                     jsr cmpl_word
002567r 3               
002567r 3  A9 8D                        lda #$8D                ; Code for STA abs
002569r 3  20 rr rr                     jsr cmpl_a
00256Cr 3               
00256Cr 3  E6 rr                        inc tmp1                ; Calculate MSB
00256Er 3  D0 02                        bne @1
002570r 3  E6 rr                        inc tmp1+1
002572r 3               @1:
002572r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002574r 3  A5 rr                        lda tmp1
002576r 3  20 rr rr                     jsr cmpl_word
002579r 3               
002579r 3  A0 E8                        ldy #$E8                ; Code for INX
00257Br 3  98                           tya
00257Cr 3  20 rr rr                     jsr cmpl_word
00257Fr 3               
00257Fr 3  80 0F                        bra @done
002581r 3               
002581r 3               @interpret:
002581r 3                               ; We're interpreting, so we arrive here with n
002581r 3                               ; on the stack. This is an annoying place to put
002581r 3                               ; the underflow check because we can't
002581r 3                               ; automatically strip it out
002581r 3  20 rr rr                     jsr underflow_1
002584r 3               
002584r 3                               ; We skip over the jump to DOCONST and store the number
002584r 3                               ; in the Program Field Area (PDF, in this case more a
002584r 3                               ; Data Field Area
002584r 3  B5 00                        lda 0,x
002586r 3  92 rr                        sta (tmp1)              ; LSB
002588r 3               
002588r 3  A0 01                        ldy #1
00258Ar 3  B5 01                        lda 1,x                 ; MSB
00258Cr 3  91 rr                        sta (tmp1),y            ; fall through to common
00258Er 3               
00258Er 3  E8                           inx                     ; DROP
00258Fr 3  E8                           inx
002590r 3               @done:
002590r 3  60           z_to:           rts
002591r 3               
002591r 3               
002591r 3               
002591r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002591r 3               ; ## ">body"  auto  ANS core
002591r 3                       ; """https://forth-standard.org/standard/core/toBODY
002591r 3                       ; Given a word's execution token (xt), return the address of the
002591r 3                       ; start of that word's parameter field (PFA). This is defined as the
002591r 3                       ; address that HERE would return right after CREATE.
002591r 3                       ;
002591r 3                       ; This is a
002591r 3                       ; difficult word for STC Forths, because most words don't actually
002591r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002591r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002591r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002591r 3                       ; """
002591r 3               
002591r 3               xt_to_body:
002591r 3  20 rr rr                     jsr underflow_1
002594r 3               
002594r 3                               ; Ideally, xt already points to the CFA. We just need to check
002594r 3                               ; the HC flag for special cases
002594r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
002597r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
00259Ar 3               
00259Ar 3                               ; The status byte is nt+1
00259Ar 3  F6 00                        inc 0,x
00259Cr 3  D0 02                        bne @1
00259Er 3  F6 01                        inc 1,x
0025A0r 3               @1:
0025A0r 3  A1 00                        lda (0,x)               ; get status byte
0025A2r 3  29 20                        and #HC
0025A4r 3  F0 0D                        beq @no_cfa
0025A6r 3               
0025A6r 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
0025A6r 3                               ; so we add three to xt, which is NOS
0025A6r 3  18                           clc
0025A7r 3  B5 02                        lda 2,x         ; LSB
0025A9r 3  69 03                        adc #3
0025ABr 3  95 02                        sta 2,x
0025ADr 3  B5 03                        lda 3,x         ; MSB
0025AFr 3  69 00                        adc #0          ; we conly care about the carry
0025B1r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
0025B3r 3               @no_cfa:
0025B3r 3  E8                           inx             ; get rid of the nt
0025B4r 3  E8                           inx
0025B5r 3               @done:
0025B5r 3  60           z_to_body:      rts
0025B6r 3               
0025B6r 3               
0025B6r 3               
0025B6r 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
0025B6r 3               ; ## ">in"  auto  ANS core
0025B6r 3               xt_to_in:
0025B6r 3  CA                           dex
0025B7r 3  CA                           dex
0025B8r 3               
0025B8r 3  A9 rr                        lda #<toin
0025BAr 3  95 00                        sta 0,x
0025BCr 3  A9 rr                        lda #>toin      ; paranoid, should be zero
0025BEr 3  95 01                        sta 1,x
0025C0r 3               
0025C0r 3  60           z_to_in:        rts
0025C1r 3               
0025C1r 3               
0025C1r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
0025C1r 3               ; ## ">number"  auto  ANS core
0025C1r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
0025C1r 3                       ; Convert a string to a double number. Logic here is based on the
0025C1r 3                       ; routine by Phil Burk of the same name in pForth, see
0025C1r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0025C1r 3                       ; for the original Forth code. We arrive here from NUMBER which has
0025C1r 3                       ; made sure that we don't have to deal with a sign and we don't have
0025C1r 3                       ; to deal with a dot as a last character that signalizes double -
0025C1r 3                       ; this should be a pure number string.
0025C1r 3                       ;
0025C1r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
0025C1r 3                       ; cannot access any of those.
0025C1r 3                       ;
0025C1r 3                       ; For the math routine, we move the inputs to the scratchpad to
0025C1r 3                       ; avoid having to fool around with the Data Stack.
0025C1r 3                       ;
0025C1r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0025C1r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
0025C1r 3                       ;     |           |           |           |           |
0025C1r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
0025C1r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0025C1r 3                       ;
0025C1r 3                       ; The math routine works by converting one character to its
0025C1r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
0025C1r 3                       ; the moment. We then multiply the UD-HI value with the radix
0025C1r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
0025C1r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
0025C1r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
0025C1r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
0025C1r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
0025C1r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
0025C1r 3                       ; storing the result back in S and S+2, before we start another
0025C1r 3                       ; round with it as the new UD-LO and UD-HI.
0025C1r 3                       ; """
0025C1r 3               
0025C1r 3               
0025C1r 3               xt_to_number:
0025C1r 3  20 rr rr                     jsr underflow_4
0025C4r 3               
0025C4r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
0025C4r 3                               ; After this step, the original ud-lo and ud-hi will still be on
0025C4r 3                               ; the Data Stack, but will be ignored and later overwritten
0025C4r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
0025C4r 3  B5 06                        lda 6,x         ; ud-lo LSB
0025C6r 3  85 rr                        sta scratch
0025C8r 3  B5 07                        lda 7,x         ; ud-lo MSB
0025CAr 3  85 rr                        sta scratch+1
0025CCr 3               
0025CCr 3  B5 04                        lda 4,x         ; ud-hi LSB
0025CEr 3  85 rr                        sta scratch+2
0025D0r 3  B5 05                        lda 5,x         ; ud-hi MSB
0025D2r 3  85 rr                        sta scratch+3
0025D4r 3               
0025D4r 3                               ; Push down one on the Data Stack to use TOS for character
0025D4r 3                               ; conversion ( ud-lo ud-hi addr u x )
0025D4r 3  CA                           dex
0025D5r 3  CA                           dex
0025D6r 3               
0025D6r 3               @loop:
0025D6r 3                               ; Get one character based on address
0025D6r 3  A1 04                        lda (4,x)
0025D8r 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
0025DAr 3  74 01                        stz 1,x                 ; paranoid
0025DCr 3               
0025DCr 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
0025DFr 3               
0025DFr 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
0025DFr 3                               ; check the flag. If it is zero, we return what we have and
0025DFr 3                               ; let the caller (usually NUMBER) complain
0025DFr 3  B5 00                        lda 0,x
0025E1r 3  D0 04                        bne @digit_ok
0025E3r 3               
0025E3r 3  E8                           inx
0025E4r 3  E8                           inx
0025E5r 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
0025E7r 3               
0025E7r 3               @digit_ok:
0025E7r 3                               ; Conversion was successful. We arrive here with
0025E7r 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
0025E7r 3                               ; math routine
0025E7r 3               
0025E7r 3                               ; Save n so we don't have to fool around with the
0025E7r 3                               ; Data Stack
0025E7r 3  B5 02                        lda 2,x
0025E9r 3  85 rr                        sta scratch+4
0025EBr 3  B5 03                        lda 3,x
0025EDr 3  85 rr                        sta scratch+5
0025EFr 3               
0025EFr 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
0025EFr 3                               ; original one on the Data Stack) with the radix from BASE.
0025EFr 3                               ; We can clobber TOS and NOS because we saved n
0025EFr 3  A5 rr                        lda scratch+2
0025F1r 3  95 02                        sta 2,x         ; NOS
0025F3r 3  A5 rr                        lda scratch+3
0025F5r 3  95 03                        sta 3,x
0025F7r 3               
0025F7r 3  A5 rr                        lda base
0025F9r 3  95 00                        sta 0,x         ; TOS
0025FBr 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
0025FDr 3               
0025FDr 3                               ; UM* returns a double-celled number
0025FDr 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002600r 3               
002600r 3                               ; Move ud-hi-lo to safety
002600r 3  B5 02                        lda 2,x         ; ud-hi-lo
002602r 3  85 rr                        sta scratch+6
002604r 3  B5 03                        lda 3,x
002606r 3  85 rr                        sta scratch+7
002608r 3               
002608r 3                               ; Now we multiply ud-lo, overwriting the stack entries
002608r 3  A5 rr                        lda scratch
00260Ar 3  95 02                        sta 2,x
00260Cr 3  A5 rr                        lda scratch+1
00260Er 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002610r 3               
002610r 3  A5 rr                        lda base
002612r 3  95 00                        sta 0,x
002614r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002616r 3               
002616r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002619r 3               
002619r 3  B5 00                        lda 0,x
00261Br 3  85 rr                        sta scratch+2
00261Dr 3  B5 01                        lda 1,x
00261Fr 3  85 rr                        sta scratch+3
002621r 3               
002621r 3  B5 02                        lda 2,x
002623r 3  85 rr                        sta scratch
002625r 3  B5 03                        lda 3,x
002627r 3  85 rr                        sta scratch+1
002629r 3               
002629r 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002629r 3                               ; both in the scratch pad
002629r 3  18                           clc
00262Ar 3  A5 rr                        lda scratch     ; ud-lo LSB
00262Cr 3  65 rr                        adc scratch+4   ; n LSB
00262Er 3  85 rr                        sta scratch     ; this is the new ud-lo
002630r 3  A5 rr                        lda scratch+1   ; ud-lo MSB
002632r 3  65 rr                        adc scratch+5   ; n MSB
002634r 3  85 rr                        sta scratch+1
002636r 3               
002636r 3  A5 rr                        lda scratch+2   ; LSB
002638r 3  65 rr                        adc scratch+6
00263Ar 3  85 rr                        sta scratch+2   ; this is the new ud-hi
00263Cr 3  A5 rr                        lda scratch+3   ; MSB
00263Er 3  65 rr                        adc scratch+7
002640r 3  85 rr                        sta scratch+3
002642r 3               
002642r 3                               ; Clean up: Get rid of one of the two top elements on
002642r 3                               ; the Data Stack. We don't really care which one
002642r 3  E8                           inx
002643r 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002644r 3               
002644r 3                               ; One character down. Move address up
002644r 3  F6 04                        inc 4,x
002646r 3  D0 02                        bne @1
002648r 3  F6 05                        inc 5,x
00264Ar 3               @1:
00264Ar 3                               ; Decrease counter
00264Ar 3  D6 02                        dec 2,x
00264Cr 3  D0 88                        bne @loop
00264Er 3               
00264Er 3               @done:
00264Er 3                               ; Counter has reached zero or we have an error. In both
00264Er 3                               ; cases, we clean up the Data Stack and return. Error gives
00264Er 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
00264Er 3                               ; ( ud-lo ud-hi addr u ud-lo )
00264Er 3  E8                           inx
00264Fr 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002650r 3               
002650r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002650r 3  A5 rr                        lda scratch     ; new ud-lo
002652r 3  95 06                        sta 6,x
002654r 3  A5 rr                        lda scratch+1
002656r 3  95 07                        sta 7,x
002658r 3               
002658r 3  A5 rr                        lda scratch+2
00265Ar 3  95 04                        sta 4,x
00265Cr 3  A5 rr                        lda scratch+3
00265Er 3  95 05                        sta 5,x
002660r 3               
002660r 3  60           z_to_number:    rts
002661r 3               
002661r 3               
002661r 3               
002661r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002661r 3               ; ## ">order"  tested  Gforth search
002661r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002661r 3               
002661r 3               xt_to_order:
002661r 3                               ; Put the wid on the return stack for now.
002661r 3  20 rr rr                     jsr xt_to_r
002664r 3               
002664r 3                               ; Get the current search order.
002664r 3  20 rr rr                     jsr xt_get_order
002667r 3               
002667r 3                               ; Get back the wid and add it to the list.
002667r 3  20 rr rr                     jsr xt_r_from
00266Ar 3  20 rr rr                     jsr xt_swap
00266Dr 3  20 rr rr                     jsr xt_one_plus
002670r 3               
002670r 3                               ; Set the search order with the new list.
002670r 3  20 rr rr                     jsr xt_set_order
002673r 3               
002673r 3  60           z_to_order:     rts
002674r 3               
002674r 3               
002674r 3               
002674r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002674r 3               ; ## ">r"  auto  ANS core
002674r 3                       ; """https://forth-standard.org/standard/core/toR
002674r 3                       ; This word is handled differently for native and for
002674r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002674r 3                       ; word.
002674r 3                       ; """
002674r 3               xt_to_r:
002674r 3                               ; Save the return address. If this word is natively
002674r 3                               ; coded, this is a complete waste of cycles, but
002674r 3                               ; required for subroutine coding
002674r 3  68                           pla             ; LSB
002675r 3  85 rr                        sta tmptos
002677r 3  7A                           ply             ; MSB
002678r 3               
002678r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002678r 3               
002678r 3                               ; We check for underflow in the second step, so we can
002678r 3                               ; strip off the stack thrashing for native compiling first
002678r 3  20 rr rr                     jsr underflow_1
00267Br 3               
00267Br 3                               ; now we can do the actual work
00267Br 3  B5 01                        lda 1,x         ; MSB
00267Dr 3  48                           pha
00267Er 3  B5 00                        lda 0,x         ; LSB
002680r 3  48                           pha
002681r 3               
002681r 3  E8                           inx
002682r 3  E8                           inx
002683r 3               
002683r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002683r 3               
002683r 3                               ; restore return address
002683r 3  5A                           phy             ; MSB
002684r 3  A5 rr                        lda tmptos
002686r 3  48                           pha             ; LSB
002687r 3               
002687r 3  60           z_to_r:         rts
002688r 3               
002688r 3               
002688r 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002688r 3               ; ## "true"  auto  ANS core ext
002688r 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002688r 3               xt_true:
002688r 3  CA                           dex
002689r 3  CA                           dex
00268Ar 3  A9 FF                        lda #$FF
00268Cr 3  95 00                        sta 0,x
00268Er 3  95 01                        sta 1,x
002690r 3               
002690r 3  60           z_true:         rts
002691r 3               
002691r 3               
002691r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002691r 3               ; ## "tuck"  auto  ANS core ext
002691r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002691r 3               xt_tuck:
002691r 3  20 rr rr                     jsr underflow_2
002694r 3               
002694r 3  CA                           dex
002695r 3  CA                           dex
002696r 3               
002696r 3  B4 04                        ldy 4,x         ; LSB
002698r 3  B5 02                        lda 2,x
00269Ar 3  95 04                        sta 4,x
00269Cr 3  94 02                        sty 2,x
00269Er 3  95 00                        sta 0,x
0026A0r 3               
0026A0r 3  B4 05                        ldy 5,x         ; MSB
0026A2r 3  B5 03                        lda 3,x
0026A4r 3  95 05                        sta 5,x
0026A6r 3  94 03                        sty 3,x         ; bba
0026A8r 3  95 01                        sta 1,x         ; baa
0026AAr 3               
0026AAr 3  60           z_tuck:         rts
0026ABr 3               
0026ABr 3               
0026ABr 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
0026ABr 3               ; ## "2"  auto  Tali Forth
0026ABr 3                       ;
0026ABr 3                       ; This code is shared with ASSEMBLER-WORDLIST
0026ABr 3               xt_assembler_wordlist:
0026ABr 3               xt_two:
0026ABr 3  CA                           dex
0026ACr 3  CA                           dex
0026ADr 3  A9 02                        lda #2
0026AFr 3  95 00                        sta 0,x
0026B1r 3  74 01                        stz 1,x
0026B3r 3               
0026B3r 3               z_assembler_wordlist:
0026B3r 3  60           z_two:          rts
0026B4r 3               
0026B4r 3               
0026B4r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
0026B4r 3               ; ## "2drop"  auto  ANS core
0026B4r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
0026B4r 3               xt_two_drop:
0026B4r 3  20 rr rr                     jsr underflow_2
0026B7r 3               
0026B7r 3  E8                           inx
0026B8r 3  E8                           inx
0026B9r 3  E8                           inx
0026BAr 3  E8                           inx
0026BBr 3               
0026BBr 3  60           z_two_drop:     rts
0026BCr 3               
0026BCr 3               
0026BCr 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
0026BCr 3               ; ## "2dup"  auto  ANS core
0026BCr 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
0026BCr 3               xt_two_dup:
0026BCr 3  20 rr rr                     jsr underflow_2
0026BFr 3               
0026BFr 3  CA                           dex
0026C0r 3  CA                           dex
0026C1r 3  CA                           dex
0026C2r 3  CA                           dex
0026C3r 3               
0026C3r 3  B5 04                        lda 4,x         ; TOS
0026C5r 3  95 00                        sta 0,x
0026C7r 3  B5 05                        lda 5,x
0026C9r 3  95 01                        sta 1,x
0026CBr 3               
0026CBr 3  B5 06                        lda 6,x         ; NOS
0026CDr 3  95 02                        sta 2,x
0026CFr 3  B5 07                        lda 7,x
0026D1r 3  95 03                        sta 3,x
0026D3r 3               
0026D3r 3  60           z_two_dup:      rts
0026D4r 3               
0026D4r 3               
0026D4r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
0026D4r 3               ; ## "2@"  auto  ANS core
0026D4r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
0026D4r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
0026D4r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
0026D4r 3                       ; """
0026D4r 3               xt_two_fetch:
0026D4r 3  20 rr rr                     jsr underflow_1
0026D7r 3               
0026D7r 3  B5 00                        lda 0,x
0026D9r 3  85 rr                        sta tmp1
0026DBr 3  B4 01                        ldy 1,x
0026DDr 3  84 rr                        sty tmp1+1
0026DFr 3               
0026DFr 3  CA                           dex             ; reuse one stack element
0026E0r 3  CA                           dex
0026E1r 3               
0026E1r 3  B2 rr                        lda (tmp1)      ; copy LSB
0026E3r 3  95 00                        sta 0,x
0026E5r 3  A0 01                        ldy #1          ; copy next
0026E7r 3  B1 rr                        lda (tmp1),y
0026E9r 3  95 01                        sta 1,x
0026EBr 3  C8                           iny             ; copy next
0026ECr 3  B1 rr                        lda (tmp1),y
0026EEr 3  95 02                        sta 2,x
0026F0r 3  C8                           iny             ; copy next
0026F1r 3  B1 rr                        lda (tmp1),y
0026F3r 3  95 03                        sta 3,x
0026F5r 3               
0026F5r 3  60           z_two_fetch:    rts
0026F6r 3               
0026F6r 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
0026F6r 3               ; ## "2over"  auto  ANS core
0026F6r 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
0026F6r 3               xt_two_over:
0026F6r 3  20 rr rr                     jsr underflow_4
0026F9r 3               
0026F9r 3  CA                           dex
0026FAr 3  CA                           dex
0026FBr 3  CA                           dex
0026FCr 3  CA                           dex
0026FDr 3               
0026FDr 3  B5 08                        lda 8,x
0026FFr 3  95 00                        sta 0,x
002701r 3               
002701r 3  B5 09                        lda 9,x
002703r 3  95 01                        sta 1,x
002705r 3               
002705r 3  B5 0A                        lda 10,x
002707r 3  95 02                        sta 2,x
002709r 3               
002709r 3  B5 0B                        lda 11,x
00270Br 3  95 03                        sta 3,x
00270Dr 3               
00270Dr 3  60           z_two_over:     rts
00270Er 3               
00270Er 3               
00270Er 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
00270Er 3               ; ## "2r@"  auto  ANS core ext
00270Er 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
00270Er 3                       ;
00270Er 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
00270Er 3                       ; assembler. We use trickery to access the elements on the Return
00270Er 3                       ; Stack instead of pulling the return address first and storing
00270Er 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
00270Er 3                       ; it as Never Native; at some point, we should compare versions to
00270Er 3                       ; see if an Always Native version would be better
00270Er 3                       ; """
00270Er 3               xt_two_r_fetch:
00270Er 3               		; make room on the Data Stack
00270Er 3  CA                           dex
00270Fr 3  CA                           dex
002710r 3  CA                           dex
002711r 3  CA                           dex
002712r 3               
002712r 3                               ; Get four bytes off of Return Stack. This assumes that
002712r 3                               ; we took a subroutine jump here so the first two entries
002712r 3                               ; are the return address
002712r 3  8A                           txa
002713r 3  BA                           tsx
002714r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002715r 3  7A                           ply
002716r 3  AA                           tax
002717r 3               
002717r 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002717r 3                               ; the return address for this word. This is a whole lot
002717r 3                               ; easier on the 65816
002717r 3  B9 03 01                     lda $0103,y     ; LSB of top entry
00271Ar 3  95 00                        sta 0,x
00271Cr 3  B9 04 01                     lda $0104,y     ; MSB of top entry
00271Fr 3  95 01                        sta 1,x
002721r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002724r 3  95 02                        sta 2,x
002726r 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002729r 3  95 03                        sta 3,x
00272Br 3               
00272Br 3  60           z_two_r_fetch:  rts
00272Cr 3               
00272Cr 3               
00272Cr 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
00272Cr 3               ; ## "2r>"  auto  ANS core ext
00272Cr 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
00272Cr 3                       ; Pull top two entries from Return Stack.
00272Cr 3                       ;
00272Cr 3                       ; Is the same as
00272Cr 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
00272Cr 3                       ; the top value on the ReturnStack for a STC Forth is the
00272Cr 3                       ; return address, which we need to get out of the way first.
00272Cr 3                       ; Native compile needs to be handled as a special case.
00272Cr 3                       ; """
00272Cr 3               xt_two_r_from:
00272Cr 3                               ; save the return address
00272Cr 3  68                           pla                     ; LSB
00272Dr 3  85 rr                        sta tmp1
00272Fr 3  68                           pla                     ; MSB
002730r 3  85 rr                        sta tmp1+1
002732r 3               
002732r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002732r 3               
002732r 3               		; make room on stack
002732r 3  CA                           dex
002733r 3  CA                           dex
002734r 3  CA                           dex
002735r 3  CA                           dex
002736r 3               
002736r 3                               ; In theory, we should test for underflow on the Return
002736r 3                               ; Stack. However, given the traffic there with an STC
002736r 3                               ; Forth, that's probably not really useful
002736r 3               
002736r 3                               ; now we can access the data
002736r 3  68                           pla                     ; LSB
002737r 3  95 00                        sta 0,x
002739r 3  68                           pla                     ; MSB
00273Ar 3  95 01                        sta 1,x
00273Cr 3               
00273Cr 3  68                           pla                     ; LSB
00273Dr 3  95 02                        sta 2,x
00273Fr 3  68                           pla                     ; MSB
002740r 3  95 03                        sta 3,x
002742r 3               
002742r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002742r 3               
002742r 3                               ; restore return address
002742r 3  A5 rr                        lda tmp1+1              ; MSB
002744r 3  48                           pha
002745r 3  A5 rr                        lda tmp1                ; LSB
002747r 3  48                           pha
002748r 3               
002748r 3  60           z_two_r_from:   rts
002749r 3               
002749r 3               
002749r 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002749r 3               ; ## "2/"  auto  ANS core
002749r 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002749r 3               xt_two_slash:
002749r 3  20 rr rr                     jsr underflow_1
00274Cr 3               
00274Cr 3                               ; We can't just LSR the LSB and ROR the MSB because that
00274Cr 3                               ; would do bad things to the sign
00274Cr 3  B5 01                        lda 1,x
00274Er 3  0A                           asl                     ; save the sign
00274Fr 3  76 01                        ror 1,x
002751r 3  76 00                        ror 0,x
002753r 3               
002753r 3  60           z_two_slash:    rts
002754r 3               
002754r 3               
002754r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002754r 3               ; ## "2*"  auto  ANS core
002754r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002754r 3                       ;
002754r 3                       ; Also used for CELLS
002754r 3                       ; """
002754r 3               xt_two_star:
002754r 3               xt_cells:
002754r 3  20 rr rr                     jsr underflow_1
002757r 3               
002757r 3  16 00                        asl 0,x
002759r 3  36 01                        rol 1,x
00275Br 3               z_cells:
00275Br 3  60           z_two_star:     rts
00275Cr 3               
00275Cr 3               
00275Cr 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
00275Cr 3               ; ## "2!"  auto  ANS core
00275Cr 3                       ; """https://forth-standard.org/standard/core/TwoStore
00275Cr 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
00275Cr 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
00275Cr 3                       ; """
00275Cr 3               xt_two_store:
00275Cr 3  20 rr rr                     jsr underflow_3
00275Fr 3               
00275Fr 3  B5 00                        lda 0,x
002761r 3  85 rr                        sta tmp1
002763r 3  B4 01                        ldy 1,x
002765r 3  84 rr                        sty tmp1+1
002767r 3               
002767r 3  E8                           inx
002768r 3  E8                           inx
002769r 3               
002769r 3  B5 00                        lda 0,x         ; copy MSB
00276Br 3  92 rr                        sta (tmp1)
00276Dr 3  B5 01                        lda 1,x         ; copy next
00276Fr 3  A0 01                        ldy #1
002771r 3  91 rr                        sta (tmp1),y
002773r 3  B5 02                        lda 2,x         ; copy next
002775r 3  C8                           iny
002776r 3  91 rr                        sta (tmp1),y
002778r 3  B5 03                        lda 3,x         ; copy MSB
00277Ar 3  C8                           iny
00277Br 3  91 rr                        sta (tmp1),y
00277Dr 3               
00277Dr 3  E8                           inx             ; 2DROP
00277Er 3  E8                           inx
00277Fr 3  E8                           inx
002780r 3  E8                           inx
002781r 3               
002781r 3  60           z_two_store:    rts
002782r 3               
002782r 3               
002782r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002782r 3               ; ## "2swap"  auto  ANS core
002782r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002782r 3               xt_two_swap:
002782r 3  20 rr rr                     jsr underflow_4
002785r 3               
002785r 3                               ; 0 <-> 4
002785r 3  B5 00                        lda 0,x
002787r 3  B4 04                        ldy 4,x
002789r 3  95 04                        sta 4,x
00278Br 3  94 00                        sty 0,x
00278Dr 3               
00278Dr 3                               ; 1 <-> 5
00278Dr 3  B5 01                        lda 1,x
00278Fr 3  B4 05                        ldy 5,x
002791r 3  95 05                        sta 5,x
002793r 3  94 01                        sty 1,x
002795r 3               
002795r 3                               ; 2 <-> 6
002795r 3  B5 02                        lda 2,x
002797r 3  B4 06                        ldy 6,x
002799r 3  95 06                        sta 6,x
00279Br 3  94 02                        sty 2,x
00279Dr 3               
00279Dr 3                               ; 3 <-> 7
00279Dr 3  B5 03                        lda 3,x
00279Fr 3  B4 07                        ldy 7,x
0027A1r 3  95 07                        sta 7,x
0027A3r 3  94 03                        sty 3,x
0027A5r 3               
0027A5r 3  60           z_two_swap:     rts
0027A6r 3               
0027A6r 3               
0027A6r 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
0027A6r 3               ; ## "2>r"  auto  ANS core ext
0027A6r 3                       ; """https://forth-standard.org/standard/core/TwotoR
0027A6r 3                       ; Push top two entries to Return Stack.
0027A6r 3                       ;
0027A6r 3                       ; The same as SWAP >R >R
0027A6r 3                       ; except that if we jumped here, the return address will be in the
0027A6r 3                       ; way. May not be natively compiled unless we're clever and use
0027A6r 3                       ; special routines.
0027A6r 3                       ; """
0027A6r 3               xt_two_to_r:
0027A6r 3                               ; save the return address
0027A6r 3  68                           pla             ; LSB
0027A7r 3  85 rr                        sta tmp1
0027A9r 3  68                           pla             ; MSB
0027AAr 3  85 rr                        sta tmp1+1
0027ACr 3               
0027ACr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0027ACr 3               
0027ACr 3  20 rr rr                     jsr underflow_2
0027AFr 3               
0027AFr 3                               ; now we can move the data
0027AFr 3  B5 03                        lda 3,x         ; MSB
0027B1r 3  48                           pha
0027B2r 3  B5 02                        lda 2,x         ; LSB
0027B4r 3  48                           pha
0027B5r 3               
0027B5r 3                               ; now we can move the data
0027B5r 3  B5 01                        lda 1,x         ; MSB
0027B7r 3  48                           pha
0027B8r 3  B5 00                        lda 0,x         ; LSB
0027BAr 3  48                           pha
0027BBr 3               
0027BBr 3  E8                           inx
0027BCr 3  E8                           inx
0027BDr 3  E8                           inx
0027BEr 3  E8                           inx
0027BFr 3               
0027BFr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0027BFr 3               
0027BFr 3                               ; restore return address
0027BFr 3  A5 rr                        lda tmp1+1      ; MSB
0027C1r 3  48                           pha
0027C2r 3  A5 rr                        lda tmp1        ; LSB
0027C4r 3  48                           pha
0027C5r 3               
0027C5r 3  60           z_two_to_r:     rts
0027C6r 3               
0027C6r 3               
0027C6r 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
0027C6r 3               ; ## "2constant"  auto  ANS double
0027C6r 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
0027C6r 3                       ;
0027C6r 3                       ; Based on the Forth code
0027C6r 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
0027C6r 3                       ; """
0027C6r 3               xt_two_constant:
0027C6r 3  20 rr rr                     jsr underflow_2
0027C9r 3               
0027C9r 3  20 rr rr                     jsr xt_create
0027CCr 3  20 rr rr                     jsr xt_swap
0027CFr 3  20 rr rr                     jsr xt_comma
0027D2r 3  20 rr rr                     jsr xt_comma
0027D5r 3               
0027D5r 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
0027D8r 3  20 rr rr                     jsr dodoes
0027DBr 3               
0027DBr 3  20 rr rr                     jsr xt_dup
0027DEr 3  20 rr rr                     jsr xt_fetch
0027E1r 3  20 rr rr                     jsr xt_swap
0027E4r 3  20 rr rr                     jsr xt_cell_plus
0027E7r 3  20 rr rr                     jsr xt_fetch
0027EAr 3               
0027EAr 3  60           z_two_constant: rts
0027EBr 3               
0027EBr 3               
0027EBr 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
0027EBr 3               ; ## "2literal"  auto  ANS double
0027EBr 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
0027EBr 3                       ; Based on the Forth code
0027EBr 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
0027EBr 3                       ; """
0027EBr 3               xt_two_literal:
0027EBr 3  20 rr rr                     jsr underflow_2 ; double number
0027EEr 3               
0027EEr 3  20 rr rr                     jsr xt_swap
0027F1r 3  20 rr rr                     jsr xt_literal
0027F4r 3  20 rr rr                     jsr xt_literal
0027F7r 3               
0027F7r 3  60           z_two_literal:  rts
0027F8r 3               
0027F8r 3               
0027F8r 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
0027F8r 3               ; ## "2variable"  auto  ANS double
0027F8r 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
0027F8r 3                       ; The variable is not initialized to zero.
0027F8r 3                       ;
0027F8r 3                       ; This can be realized in Forth as either
0027F8r 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
0027F8r 3                       ; """
0027F8r 3               xt_two_variable:
0027F8r 3                               ; We just let CRATE and ALLOT do the heavy lifting
0027F8r 3  20 rr rr                     jsr xt_create
0027FBr 3               
0027FBr 3  CA                           dex
0027FCr 3  CA                           dex
0027FDr 3  A9 04                        lda #4
0027FFr 3  95 00                        sta 0,x
002801r 3  74 01                        stz 1,x
002803r 3               
002803r 3  20 rr rr                     jsr xt_allot
002806r 3               
002806r 3  60           z_two_variable: rts
002807r 3               
002807r 3               
002807r 3               ; ## TYPE ( addr u -- ) "Print string"
002807r 3               ; ## "type"  auto  ANS core
002807r 3                       ; """https://forth-standard.org/standard/core/TYPE
002807r 3                       ; Works through EMIT to allow OUTPUT revectoring.
002807r 3                       ; """
002807r 3               
002807r 3               xt_type:
002807r 3  20 rr rr                     jsr underflow_2
00280Ar 3               
00280Ar 3                               ; Save the starting address into tmp1
00280Ar 3  B5 02                        lda 2,x
00280Cr 3  85 rr                        sta tmp1
00280Er 3  B5 03                        lda 3,x
002810r 3  85 rr                        sta tmp1+1
002812r 3               @loop:
002812r 3                               ; done if length is zero
002812r 3  B5 00                        lda 0,x
002814r 3  15 01                        ora 1,x
002816r 3  F0 15                        beq @done
002818r 3               
002818r 3                               ; Send the current character
002818r 3  B2 rr                        lda (tmp1)
00281Ar 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
00281Dr 3               
00281Dr 3                               ; Move the address along (in tmp1)
00281Dr 3  E6 rr                        inc tmp1
00281Fr 3  D0 02                        bne @1
002821r 3  E6 rr                        inc tmp1+1
002823r 3               @1:
002823r 3                               ; Reduce the count (on the data stack)
002823r 3  B5 00                        lda 0,x
002825r 3  D0 02                        bne @2
002827r 3  D6 01                        dec 1,x
002829r 3               @2:
002829r 3  D6 00                        dec 0,x
00282Br 3               
00282Br 3  80 E5                        bra @loop
00282Dr 3               @done:
00282Dr 3  E8                           inx
00282Er 3  E8                           inx
00282Fr 3  E8                           inx
002830r 3  E8                           inx
002831r 3               
002831r 3  60           z_type:         rts
002832r 3               
002832r 3               
002832r 3               
002832r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002832r 3               ; ## "u."  tested  ANS core
002832r 3                       ; """https://forth-standard.org/standard/core/Ud
002832r 3                       ;
002832r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002832r 3                       ; We use the internal assembler function print_u followed
002832r 3                       ; by a single space
002832r 3                       ; """
002832r 3               xt_u_dot:
002832r 3  20 rr rr                     jsr underflow_1
002835r 3               
002835r 3  20 rr rr                     jsr print_u
002838r 3  A9 20                        lda #AscSP
00283Ar 3  20 rr rr                     jsr emit_a
00283Dr 3               
00283Dr 3  60           z_u_dot:        rts
00283Er 3               
00283Er 3               
00283Er 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
00283Er 3               ; ## "u.r"  tested  ANS core ext
00283Er 3                       ; """https://forth-standard.org/standard/core/UDotR"""
00283Er 3               xt_u_dot_r:
00283Er 3  20 rr rr                     jsr underflow_2
002841r 3               
002841r 3  20 rr rr                     jsr xt_to_r
002844r 3  20 rr rr                     jsr xt_zero
002847r 3  20 rr rr                     jsr xt_less_number_sign
00284Ar 3  20 rr rr                     jsr xt_number_sign_s
00284Dr 3  20 rr rr                     jsr xt_number_sign_greater
002850r 3  20 rr rr                     jsr xt_r_from
002853r 3  20 rr rr                     jsr xt_over
002856r 3  20 rr rr                     jsr xt_minus
002859r 3  20 rr rr                     jsr xt_spaces
00285Cr 3  20 rr rr                     jsr xt_type
00285Fr 3               
00285Fr 3  60           z_u_dot_r:      rts
002860r 3               
002860r 3               
002860r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002860r 3               ; ## "u>"  auto  ANS core ext
002860r 3                       ; """https://forth-standard.org/standard/core/Umore"""
002860r 3               xt_u_greater_than:
002860r 3  20 rr rr                     jsr underflow_2
002863r 3               
002863r 3  B5 00                        lda 0,x
002865r 3  D5 02                        cmp 2,x
002867r 3  B5 01                        lda 1,x
002869r 3  F5 03                        sbc 3,x
00286Br 3  E8                           inx
00286Cr 3  E8                           inx
00286Dr 3               
00286Dr 3  A9 00                        lda #0
00286Fr 3  69 FF                        adc #$ff
002871r 3  95 00                        sta 0,x         ; store flag
002873r 3  95 01                        sta 1,x
002875r 3               
002875r 3  60           z_u_greater_than:    rts
002876r 3               
002876r 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002876r 3               ; ## "u<"  auto  ANS core
002876r 3                       ; """https://forth-standard.org/standard/core/Uless"""
002876r 3               xt_u_less_than:
002876r 3  20 rr rr                     jsr underflow_2
002879r 3               
002879r 3  B5 02                        lda 2,x
00287Br 3  D5 00                        cmp 0,x
00287Dr 3  B5 03                        lda 3,x
00287Fr 3  F5 01                        sbc 1,x
002881r 3  E8                           inx
002882r 3  E8                           inx
002883r 3               
002883r 3  A9 00                        lda #0
002885r 3  69 FF                        adc #$ff
002887r 3  95 00                        sta 0,x         ; store flag
002889r 3  95 01                        sta 1,x
00288Br 3               
00288Br 3  60           z_u_less_than:    rts
00288Cr 3               
00288Cr 3               
00288Cr 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
00288Cr 3               ; ## "ud."  auto  Tali double
00288Cr 3                       ;
00288Cr 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
00288Cr 3                       ; """
00288Cr 3               xt_ud_dot:
00288Cr 3  20 rr rr                     jsr underflow_2 ; double number
00288Fr 3               
00288Fr 3  20 rr rr                     jsr xt_less_number_sign
002892r 3  20 rr rr                     jsr xt_number_sign_s
002895r 3  20 rr rr                     jsr xt_number_sign_greater
002898r 3  20 rr rr                     jsr xt_type
00289Br 3  20 rr rr                     jsr xt_space
00289Er 3               
00289Er 3  60           z_ud_dot:        rts
00289Fr 3               
00289Fr 3               
00289Fr 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
00289Fr 3               ; ## "ud.r"  auto  Tali double
00289Fr 3                       ;
00289Fr 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
00289Fr 3                       ; """
00289Fr 3               xt_ud_dot_r:
00289Fr 3  20 rr rr                     jsr underflow_3
0028A2r 3               
0028A2r 3  20 rr rr                     jsr xt_to_r
0028A5r 3  20 rr rr                     jsr xt_less_number_sign
0028A8r 3  20 rr rr                     jsr xt_number_sign_s
0028ABr 3  20 rr rr                     jsr xt_number_sign_greater
0028AEr 3  20 rr rr                     jsr xt_r_from
0028B1r 3  20 rr rr                     jsr xt_over
0028B4r 3  20 rr rr                     jsr xt_minus
0028B7r 3  20 rr rr                     jsr xt_spaces
0028BAr 3  20 rr rr                     jsr xt_type
0028BDr 3               
0028BDr 3  60           z_ud_dot_r:      rts
0028BEr 3               
0028BEr 3               
0028BEr 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
0028BEr 3               ; ## "um/mod"  auto  ANS core
0028BEr 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
0028BEr 3                       ; Divide double cell number by single cell number, returning the
0028BEr 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
0028BEr 3                       ; This is the basic division operation all others use. Based on FIG
0028BEr 3                       ; Forth code, modified by Garth Wilson, see
0028BEr 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
0028BEr 3                       ;
0028BEr 3                       ; This uses tmp1, tmp1+1, and tmptos
0028BEr 3                       ; """
0028BEr 3               
0028BEr 3               xt_um_slash_mod:
0028BEr 3  20 rr rr                     jsr underflow_3
0028C1r 3               
0028C1r 3                               ; catch division by zero
0028C1r 3  B5 00                        lda 0,x
0028C3r 3  15 01                        ora 1,x
0028C5r 3  D0 05                        bne @not_zero
0028C7r 3               
0028C7r 3  A9 04                        lda #err_divzero
0028C9r 3  4C rr rr                     jmp error
0028CCr 3               
0028CCr 3               @not_zero:
0028CCr 3                               ; We loop 17 times
0028CCr 3  A9 11                        lda #17
0028CEr 3  85 rr                        sta tmptos
0028D0r 3               
0028D0r 3               @loop:
0028D0r 3                               ; rotate low cell of dividend one bit left (LSB)
0028D0r 3  36 04                        rol 4,x
0028D2r 3  36 05                        rol 5,x
0028D4r 3               
0028D4r 3                               ; loop control
0028D4r 3  C6 rr                        dec tmptos
0028D6r 3  F0 22                        beq @done
0028D8r 3               
0028D8r 3                               ; rotate high cell of dividend one bit left (MSB)
0028D8r 3  36 02                        rol 2,x
0028DAr 3  36 03                        rol 3,x
0028DCr 3               
0028DCr 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
0028DEr 3  26 rr                        rol tmp1
0028E0r 3               
0028E0r 3                               ; subtract dividend hi cell minus divisor
0028E0r 3  38                           sec
0028E1r 3  B5 02                        lda 2,x
0028E3r 3  F5 00                        sbc 0,x
0028E5r 3  85 rr                        sta tmp1+1
0028E7r 3  B5 03                        lda 3,x
0028E9r 3  F5 01                        sbc 1,x
0028EBr 3               
0028EBr 3  A8                           tay
0028ECr 3  A5 rr                        lda tmp1
0028EEr 3  E9 00                        sbc #0
0028F0r 3  90 DE                        bcc @loop
0028F2r 3               
0028F2r 3                               ; make result new dividend high cell
0028F2r 3  A5 rr                        lda tmp1+1
0028F4r 3  95 02                        sta 2,x
0028F6r 3  94 03                        sty 3,x         ; used as temp storage
0028F8r 3               
0028F8r 3  80 D6                        bra @loop
0028FAr 3               @done:
0028FAr 3  E8                           inx
0028FBr 3  E8                           inx
0028FCr 3               
0028FCr 3  20 rr rr                     jsr xt_swap
0028FFr 3               
0028FFr 3  60           z_um_slash_mod: rts
002900r 3               
002900r 3               
002900r 3               
002900r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002900r 3               ; ## "um*"  auto  ANS core
002900r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002900r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002900r 3                       ; Old Forth versions such as FIG Forth call this U*
002900r 3                       ;
002900r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002900r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002900r 3                       ; discussion.
002900r 3                       ;
002900r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002900r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002900r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002900r 3                       ;
002900r 3                       ; Consider switching to a table-supported version based on
002900r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002900r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002900r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002900r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002900r 3                       ; """
002900r 3               
002900r 3               xt_um_star:
002900r 3  20 rr rr                     jsr underflow_2
002903r 3               
002903r 3                               ; to eliminate clc inside the loop, the value at
002903r 3                               ; tmp1 is reduced by 1 in advance
002903r 3  18                           clc
002904r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002906r 3  E9 00                        sbc #0
002908r 3  85 rr                        sta tmp2
00290Ar 3               
00290Ar 3  B5 01                        lda 1,x
00290Cr 3  E9 00                        sbc #0
00290Er 3  90 31                        bcc @zero       ; is TOS zero?
002910r 3  85 rr                        sta tmp2+1
002912r 3               
002912r 3  A9 00                        lda #0
002914r 3  85 rr                        sta tmp1
002916r 3  86 rr                        stx tmp3        ; tested for exit from outer loop
002918r 3  CA                           dex
002919r 3  CA                           dex
00291Ar 3               
00291Ar 3               @outer_loop:
00291Ar 3  A0 08                        ldy #8          ; counter inner loop
00291Cr 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
00291Er 3               
00291Er 3               @inner_loop:
00291Er 3  90 0C                        bcc @no_add
002920r 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002922r 3  A5 rr                        lda tmp1
002924r 3  65 rr                        adc tmp2
002926r 3  85 rr                        sta tmp1
002928r 3  A5 rr                        lda tmp1+1
00292Ar 3  65 rr                        adc tmp2+1
00292Cr 3               
00292Cr 3               @no_add:
00292Cr 3  6A                           ror
00292Dr 3  66 rr                        ror tmp1
00292Fr 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002931r 3               
002931r 3  88                           dey
002932r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002934r 3               
002934r 3  E8                           inx
002935r 3  E4 rr                        cpx tmp3
002937r 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002939r 3               
002939r 3                               ; all done, store high word of result
002939r 3  95 01                        sta 1,x
00293Br 3  A5 rr                        lda tmp1
00293Dr 3  95 00                        sta 0,x
00293Fr 3  80 04                        bra @done
002941r 3               
002941r 3               @zero:
002941r 3  74 02                        stz 2,x
002943r 3  74 03                        stz 3,x
002945r 3               @done:
002945r 3  60           z_um_star:      rts
002946r 3               
002946r 3               
002946r 3               
002946r 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002946r 3               ; ## "unloop"  auto  ANS core
002946r 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002946r 3                       ;
002946r 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002946r 3                       ; """
002946r 3               xt_unloop:
002946r 3                               ; Drop fudge number (limit/start from DO/?DO off the
002946r 3                               ; return stack
002946r 3  68                           pla
002947r 3  68                           pla
002948r 3  68                           pla
002949r 3  68                           pla
00294Ar 3               
00294Ar 3                               ; Now drop the LEAVE address that was below them off
00294Ar 3                               ; the Return Stack as well
00294Ar 3  68                           pla
00294Br 3  68                           pla
00294Cr 3               
00294Cr 3  60           z_unloop:       rts
00294Dr 3               
00294Dr 3               
00294Dr 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
00294Dr 3               ; ## "until"  auto  ANS core
00294Dr 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
00294Dr 3               xt_until:
00294Dr 3                               ; Compile a 0BRANCH
00294Dr 3  A0 rr                        ldy #>zero_branch_runtime
00294Fr 3  A9 rr                        lda #<zero_branch_runtime
002951r 3  20 rr rr                     jsr cmpl_subroutine
002954r 3               
002954r 3                               ; The address to loop back to is on the stack.
002954r 3                               ; Just compile it as the destination for the
002954r 3                               ; 0branch.
002954r 3  20 rr rr                     jsr xt_comma
002957r 3               
002957r 3  60           z_until:        rts
002958r 3               
002958r 3               
002958r 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
002958r 3               ; ## "unused"  auto  ANS core ext
002958r 3                       ; """https://forth-standard.org/standard/core/UNUSED
002958r 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
002958r 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
002958r 3                       ; defaults to $400
002958r 3                       ; """
002958r 3               xt_unused:
002958r 3  CA                           dex
002959r 3  CA                           dex
00295Ar 3               
00295Ar 3  A9 FF                        lda #<cp_end
00295Cr 3  38                           sec
00295Dr 3  E5 rr                        sbc cp
00295Fr 3  95 00                        sta 0,x
002961r 3               
002961r 3  A9 7F                        lda #>cp_end
002963r 3  E5 rr                        sbc cp+1
002965r 3  95 01                        sta 1,x
002967r 3               
002967r 3  60           z_unused:       rts
002968r 3               
002968r 3               
002968r 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
002968r 3               ; ## "update"  auto  ANS block
002968r 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
002968r 3               xt_update:
002968r 3                               ; Turn on the dirty bit. We can't use TSB here because it only
002968r 3                               ; has Absolute and Direct Pages addressing modes
002968r 3  A0 2C                        ldy #buffstatus_offset
00296Ar 3  B1 rr                        lda (up),y
00296Cr 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
00296Er 3  91 rr                        sta (up),y
002970r 3               
002970r 3  60           z_update:       rts
002971r 3               
002971r 3               
002971r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
002971r 3               ; ## "useraddr"  tested  Tali Forth
002971r 3               xt_useraddr:
002971r 3  CA                           dex
002972r 3  CA                           dex
002973r 3  A9 rr                        lda #<up
002975r 3  95 00                        sta 0,x
002977r 3  A9 rr                        lda #>up
002979r 3  95 01                        sta 1,x
00297Br 3               
00297Br 3  60           z_useraddr:     rts
00297Cr 3               
00297Cr 3               
00297Cr 3               ; ## VALUE ( n "name" -- ) "Define a value"
00297Cr 3               ; ## "value"  auto  ANS core
00297Cr 3                       ; """https://forth-standard.org/standard/core/VALUE
00297Cr 3                       ;
00297Cr 3                       ; This is a dummy header for the WORDLIST. The actual code is
00297Cr 3                       ; identical to that of CONSTANT
00297Cr 3                       ; """
00297Cr 3               
00297Cr 3               
00297Cr 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
00297Cr 3               ; ## "variable"  auto  ANS core
00297Cr 3                       ; """https://forth-standard.org/standard/core/VARIABLE
00297Cr 3                       ; There are various Forth definitions for this word, such as
00297Cr 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
00297Cr 3                       ; second one so the variable is initialized to zero
00297Cr 3                       ; """
00297Cr 3               xt_variable:
00297Cr 3                               ; we let CREATE do the heavy lifting
00297Cr 3  20 rr rr                     jsr xt_create
00297Fr 3               
00297Fr 3                               ; there is no "STZ (CP)" so we have to do this the hard
00297Fr 3                               ; way
00297Fr 3  A9 00                        lda #0
002981r 3               
002981r 3  92 rr                        sta (cp)
002983r 3  E6 rr                        inc cp
002985r 3  D0 02                        bne @1
002987r 3  E6 rr                        inc cp+1
002989r 3               @1:
002989r 3  92 rr                        sta (cp)
00298Br 3  E6 rr                        inc cp
00298Dr 3  D0 02                        bne @2
00298Fr 3  E6 rr                        inc cp+1
002991r 3               @2:
002991r 3                               ; Now we need to adjust the length of the complete word by two
002991r 3  20 rr rr                     jsr adjust_z
002994r 3               
002994r 3  60           z_variable:     rts
002995r 3               
002995r 3               
002995r 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
002995r 3               ; ## "while"  auto  ANS core
002995r 3                       ; """http://forth-standard.org/standard/core/WHILE"""
002995r 3               xt_while:
002995r 3                               ; Compile a 0branch
002995r 3  A0 rr                        ldy #>zero_branch_runtime
002997r 3  A9 rr                        lda #<zero_branch_runtime
002999r 3  20 rr rr                     jsr cmpl_subroutine
00299Cr 3               
00299Cr 3                               ; Put the address (here) where the destination
00299Cr 3                               ; address needs to go so it can be put there later.
00299Cr 3  20 rr rr                     jsr xt_here
00299Fr 3               
00299Fr 3                               ; Fill in the destination address with 0 for now.
00299Fr 3  20 rr rr                     jsr xt_zero
0029A2r 3  20 rr rr                     jsr xt_comma
0029A5r 3               
0029A5r 3                               ; Swap the two addresses on the stack.
0029A5r 3  20 rr rr                     jsr xt_swap
0029A8r 3               
0029A8r 3  60           z_while:        rts
0029A9r 3               
0029A9r 3               
0029A9r 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
0029A9r 3               ; ## "within"  auto  ANS core ext
0029A9r 3                       ; """https://forth-standard.org/standard/core/WITHIN
0029A9r 3                       ;
0029A9r 3                       ; This an assembler version of the ANS Forth implementation
0029A9r 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
0029A9r 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
0029A9r 3                       ; ROT TUCK > -ROT > INVERT AND
0029A9r 3                       ; """"
0029A9r 3               xt_within:
0029A9r 3  20 rr rr                     jsr underflow_3
0029ACr 3               
0029ACr 3  20 rr rr                     jsr xt_over
0029AFr 3  20 rr rr                     jsr xt_minus
0029B2r 3  20 rr rr                     jsr xt_to_r
0029B5r 3  20 rr rr                     jsr xt_minus
0029B8r 3  20 rr rr                     jsr xt_r_from
0029BBr 3  20 rr rr                     jsr xt_u_less_than
0029BEr 3               
0029BEr 3  60           z_within:       rts
0029BFr 3               
0029BFr 3               
0029BFr 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
0029BFr 3               ; ## "word"  auto  ANS core
0029BFr 3                       ; """https://forth-standard.org/standard/core/WORD
0029BFr 3                       ; Obsolete parsing word included for backwards compatibility only.
0029BFr 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
0029BFr 3                       ; and copies word to storage area for a maximum size of 255 bytes.
0029BFr 3                       ; Returns the result as a counted string (requires COUNT to convert
0029BFr 3                       ; to modern format), and inserts a space after the string. See "Forth
0029BFr 3                       ; Programmer's Handbook" 3rd edition p. 159 and
0029BFr 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
0029BFr 3                       ; for discussions of why you shouldn't be using WORD anymore.
0029BFr 3                       ;
0029BFr 3                       ; Forth
0029BFr 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
0029BFr 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
0029BFr 3                       ; """
0029BFr 3               
0029BFr 3               xt_word:
0029BFr 3  20 rr rr                     jsr underflow_1
0029C2r 3               
0029C2r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
0029C2r 3                               ; but unlike PARSE
0029C2r 3  A4 rr                        ldy toin                ; >IN
0029C4r 3               @loop:
0029C4r 3  C4 rr                        cpy ciblen              ; quit if end of input
0029C6r 3  F0 09                        beq @found_char
0029C8r 3  B1 rr                        lda (cib),y
0029CAr 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
0029CCr 3  D0 03                        bne @found_char
0029CEr 3               
0029CEr 3  C8                           iny
0029CFr 3  80 F3                        bra @loop
0029D1r 3               @found_char:
0029D1r 3                               ; Save index of where word starts
0029D1r 3  84 rr                        sty toin
0029D3r 3               
0029D3r 3                               ; The real work is done by parse
0029D3r 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
0029D6r 3               
0029D6r 3                               ; Convert the modern ( addr u ) string format to obsolete
0029D6r 3                               ; ( caddr ) format. We just do this in the Dictionary
0029D6r 3  B5 00                        lda 0,x
0029D8r 3  92 rr                        sta (cp)                ; Save length of string
0029DAr 3  48                           pha                     ; Keep copy of length for later
0029DBr 3               
0029DBr 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
0029DEr 3  A5 rr                        lda cp
0029E0r 3  18                           clc
0029E1r 3  69 01                        adc #1
0029E3r 3  95 02                        sta 2,x                 ; LSB of CP
0029E5r 3  A5 rr                        lda cp+1
0029E7r 3  69 00                        adc #0
0029E9r 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
0029EBr 3               
0029EBr 3  20 rr rr                     jsr xt_move
0029EEr 3               
0029EEr 3                               ; Return caddr
0029EEr 3  CA                           dex
0029EFr 3  CA                           dex
0029F0r 3  A5 rr                        lda cp
0029F2r 3  95 00                        sta 0,x
0029F4r 3  A5 rr                        lda cp+1
0029F6r 3  95 01                        sta 1,x
0029F8r 3               
0029F8r 3                               ; Adjust CP
0029F8r 3  68                           pla                     ; length of string
0029F9r 3  18                           clc
0029FAr 3  65 rr                        adc cp
0029FCr 3  85 rr                        sta cp
0029FEr 3  A5 rr                        lda cp+1
002A00r 3  69 00                        adc #0                  ; we only need the carry
002A02r 3  85 rr                        sta cp+1
002A04r 3  60           z_word:         rts
002A05r 3               
002A05r 3               
002A05r 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
002A05r 3               ; ## "wordlist" auto ANS search
002A05r 3                       ; """https://forth-standard.org/standard/search/WORDLIST
002A05r 3                       ; See the tutorial on Wordlists and the Search Order for
002A05r 3                       ; more information.
002A05r 3                       ; """
002A05r 3               
002A05r 3               xt_wordlist:
002A05r 3                               ; Get the current number of wordlists
002A05r 3  A0 05                        ldy #num_wordlists_offset
002A07r 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
002A09r 3                                               ; the LSB needs to be checked.
002A09r 3               
002A09r 3                               ; See if we are already at the max.
002A09r 3  C9 0C                        cmp #max_wordlists
002A0Br 3  D0 05                        bne @ok
002A0Dr 3               
002A0Dr 3                               ; Print an error message if all wordlists used.
002A0Dr 3  A9 0B                        lda #err_wordlist
002A0Fr 3  4C rr rr                     jmp error
002A12r 3               
002A12r 3               @ok:
002A12r 3  1A                           inc             ; Increment the wordlist#
002A13r 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
002A15r 3  CA                           dex             ; and put it on the stack.
002A16r 3  CA                           dex
002A17r 3  95 00                        sta 0,x
002A19r 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002A1Br 3               
002A1Br 3  60           z_wordlist:     rts
002A1Cr 3               
002A1Cr 3               
002A1Cr 3               
002A1Cr 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002A1Cr 3               ; ## "words"  tested  ANS tools
002A1Cr 3                       ; """https://forth-standard.org/standard/tools/WORDS
002A1Cr 3                       ; This is pretty much only used at the command line so we can
002A1Cr 3                       ; be slow and try to save space.
002A1Cr 3                       ; """
002A1Cr 3               
002A1Cr 3               xt_words:
002A1Cr 3                               ; we follow Gforth by starting on the next
002A1Cr 3                               ; line
002A1Cr 3  20 rr rr                     jsr xt_cr
002A1Fr 3               
002A1Fr 3                               ; We pretty-format the output by inserting a line break
002A1Fr 3                               ; before the end of the line. We can get away with pushing
002A1Fr 3                               ; the counter to the stack because this is usually an
002A1Fr 3                               ; interactive word and speed is not that important
002A1Fr 3  A9 00                        lda #0
002A21r 3  48                           pha
002A22r 3               
002A22r 3                               ; Set up for traversing the wordlist search order.
002A22r 3  CA                           dex                     ; Make room on the stack for
002A23r 3  CA                           dex                     ; a dictionary pointer.
002A24r 3  64 rr                        stz tmp3                ; Start at the beginning of
002A26r 3                                                       ; the search order.
002A26r 3               @wordlist_loop:
002A26r 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
002A28r 3  A5 rr                        lda tmp3
002A2Ar 3  D1 rr                        cmp (up),y              ; See if we are done.
002A2Cr 3  D0 02                        bne @have_wordlist
002A2Er 3               
002A2Er 3                               ; We ran out of wordlists to search.
002A2Er 3  80 44                        bra @words_done
002A30r 3               
002A30r 3               @have_wordlist:
002A30r 3                               ; start with last word in Dictionary
002A30r 3                               ; Get the current wordlist id
002A30r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
002A31r 3  69 1F                        adc #search_order_offset
002A33r 3  A8                           tay
002A34r 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
002A36r 3               
002A36r 3                               ; Get the DP for that wordlist.
002A36r 3  0A                           asl                     ; Turn offset into cells offset.
002A37r 3  18                           clc
002A38r 3  69 06                        adc #wordlists_offset
002A3Ar 3  A8                           tay
002A3Br 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
002A3Dr 3  95 00                        sta 0,x                 ; on the stack. ( nt )
002A3Fr 3  C8                           iny
002A40r 3  B1 rr                        lda (up),y
002A42r 3  95 01                        sta 1,x
002A44r 3               
002A44r 3               @loop:
002A44r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002A47r 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
002A4Ar 3               
002A4Ar 3                               ; Insert line break if we're about to go past the end of the
002A4Ar 3                               ; line
002A4Ar 3  68                           pla
002A4Br 3  18                           clc
002A4Cr 3  75 00                        adc 0,x
002A4Er 3  1A                           inc                     ; don't forget the space between words
002A4Fr 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
002A51r 3  90 05                        bcc @1
002A53r 3               
002A53r 3  20 rr rr                     jsr xt_cr
002A56r 3  A9 00                        lda #0
002A58r 3               @1:
002A58r 3  48                           pha
002A59r 3  20 rr rr                     jsr xt_type             ; ( nt )
002A5Cr 3               
002A5Cr 3  A9 20                        lda #AscSP
002A5Er 3  20 rr rr                     jsr emit_a
002A61r 3               
002A61r 3                               ; get next word, which begins two down
002A61r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002A64r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002A67r 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
002A6Ar 3               
002A6Ar 3                               ; if next address is zero, we're done
002A6Ar 3  B5 00                        lda 0,x
002A6Cr 3  15 01                        ora 1,x
002A6Er 3  D0 D4                        bne @loop
002A70r 3               
002A70r 3                               ; Move on to the next wordlist in the search order.
002A70r 3  E6 rr                        inc tmp3
002A72r 3  80 B2                        bra @wordlist_loop
002A74r 3               
002A74r 3               @words_done:
002A74r 3  68                           pla                     ; dump counter
002A75r 3               
002A75r 3  E8                           inx
002A76r 3  E8                           inx
002A77r 3               
002A77r 3  60           z_words:        rts
002A78r 3               
002A78r 3               
002A78r 3               
002A78r 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
002A78r 3               ; ## "wordsize"  auto  Tali Forth
002A78r 3                       ; """Given an word's name token (nt), return the size of the
002A78r 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
002A78r 3                       ; count the final RTS.
002A78r 3                       ; """
002A78r 3               xt_wordsize:
002A78r 3  20 rr rr                     jsr underflow_1
002A7Br 3               
002A7Br 3                               ; We get the start address of the word from its header entry
002A7Br 3                               ; for the start of the actual code (execution token, xt)
002A7Br 3                               ; which is four bytes down, and the pointer to the end of the
002A7Br 3                               ; code (z_word, six bytes down)
002A7Br 3  B5 00                        lda 0,x
002A7Dr 3  85 rr                        sta tmp1
002A7Fr 3  B5 01                        lda 1,x
002A81r 3  85 rr                        sta tmp1+1
002A83r 3               
002A83r 3  A0 06                        ldy #6
002A85r 3  B1 rr                        lda (tmp1),y    ; LSB of z
002A87r 3  88                           dey
002A88r 3  88                           dey
002A89r 3               
002A89r 3  38                           sec
002A8Ar 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
002A8Cr 3  95 00                        sta 0,x
002A8Er 3               
002A8Er 3  A0 07                        ldy #7
002A90r 3  B1 rr                        lda (tmp1),y    ; MSB of z
002A92r 3  88                           dey
002A93r 3  88                           dey
002A94r 3               
002A94r 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
002A96r 3  95 01                        sta 1,x
002A98r 3               
002A98r 3  60           z_wordsize:     rts
002A99r 3               
002A99r 3               
002A99r 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
002A99r 3               ; ## "xor"  auto  ANS core
002A99r 3                       ; """https://forth-standard.org/standard/core/XOR"""
002A99r 3               xt_xor:
002A99r 3  20 rr rr                     jsr underflow_2
002A9Cr 3               
002A9Cr 3  B5 00                        lda 0,x
002A9Er 3  55 02                        eor 2,x
002AA0r 3  95 02                        sta 2,x
002AA2r 3               
002AA2r 3  B5 01                        lda 1,x
002AA4r 3  55 03                        eor 3,x
002AA6r 3  95 03                        sta 3,x
002AA8r 3               
002AA8r 3  E8                           inx
002AA9r 3  E8                           inx
002AAAr 3               
002AAAr 3  60           z_xor:          rts
002AABr 3               
002AABr 3               
002AABr 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002AABr 3               ; ## "0"  auto  Tali Forth
002AABr 3                       ; """The disassembler assumes that this routine does not use Y. Note
002AABr 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002AABr 3                       ; is 0."""
002AABr 3               xt_case:
002AABr 3               xt_forth_wordlist:
002AABr 3               xt_zero:
002AABr 3  CA                           dex             ; push
002AACr 3  CA                           dex
002AADr 3  74 00                        stz 0,x
002AAFr 3  74 01                        stz 1,x
002AB1r 3               z_case:
002AB1r 3               z_forth_wordlist:
002AB1r 3               z_zero:
002AB1r 3  60                           rts
002AB2r 3               
002AB2r 3               
002AB2r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
002AB2r 3               ; ## "0="  auto  ANS core
002AB2r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
002AB2r 3               
002AB2r 3               xt_zero_equal:
002AB2r 3  20 rr rr                     jsr underflow_1
002AB5r 3               
002AB5r 3  B5 00                        lda 0,x
002AB7r 3  15 01                        ora 1,x
002AB9r 3  F0 04                        beq @zero
002ABBr 3               
002ABBr 3                               ; not a zero, so we need a FALSE flag (0)
002ABBr 3  A9 00                        lda #0
002ABDr 3  80 02                        bra @store
002ABFr 3               @zero:
002ABFr 3                               ; We have a zero, so we need a TRUE flag (-1)
002ABFr 3  A9 FF                        lda #$ff
002AC1r 3               @store:
002AC1r 3  95 00                        sta 0,x
002AC3r 3  95 01                        sta 1,x
002AC5r 3               
002AC5r 3  60           z_zero_equal:   rts
002AC6r 3               
002AC6r 3               
002AC6r 3               
002AC6r 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
002AC6r 3               ; ## "0>"  auto  ANS core ext
002AC6r 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
002AC6r 3               
002AC6r 3               xt_zero_greater:
002AC6r 3  20 rr rr                     jsr underflow_1
002AC9r 3               
002AC9r 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002ACBr 3               
002ACBr 3  B5 01                        lda 1,x         ; MSB
002ACDr 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002ACFr 3  15 00                        ora 0,x
002AD1r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
002AD3r 3               
002AD3r 3  88                           dey             ; TOS is postive, make true
002AD4r 3               @done:
002AD4r 3  98                           tya
002AD5r 3  95 00                        sta 0,x
002AD7r 3  95 01                        sta 1,x
002AD9r 3               
002AD9r 3  60           z_zero_greater: rts
002ADAr 3               
002ADAr 3               
002ADAr 3               
002ADAr 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
002ADAr 3               ; ## "0<"  auto  ANS core
002ADAr 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
002ADAr 3               
002ADAr 3               xt_zero_less:
002ADAr 3  20 rr rr                     jsr underflow_1
002ADDr 3               
002ADDr 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002ADFr 3               
002ADFr 3  B5 01                        lda 1,x         ; MSB
002AE1r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
002AE3r 3               
002AE3r 3  88                           dey             ; TOS is negative, make TRUE
002AE4r 3               @done:
002AE4r 3  98                           tya
002AE5r 3  95 00                        sta 0,x
002AE7r 3  95 01                        sta 1,x
002AE9r 3               
002AE9r 3  60           z_zero_less:    rts
002AEAr 3               
002AEAr 3               
002AEAr 3               
002AEAr 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
002AEAr 3               ; ## "0<>"  auto  ANS core ext
002AEAr 3                       ; """https://forth-standard.org/standard/core/Zerone"""
002AEAr 3               
002AEAr 3               xt_zero_unequal:
002AEAr 3  20 rr rr                     jsr underflow_1
002AEDr 3               
002AEDr 3  A0 00                        ldy #0          ; default false
002AEFr 3               
002AEFr 3  B5 00                        lda 0,x
002AF1r 3  15 01                        ora 1,x
002AF3r 3  F0 01                        beq @got_zero
002AF5r 3               
002AF5r 3  88                           dey
002AF6r 3               @got_zero:
002AF6r 3  98                           tya
002AF7r 3  95 00                        sta 0,x
002AF9r 3  95 01                        sta 1,x
002AFBr 3               
002AFBr 3  60           z_zero_unequal: rts
002AFCr 3               
002AFCr 3               
002AFCr 3               
002AFCr 3               ; ==========================================================
002AFCr 3               ; EDITOR words
002AFCr 3               
002AFCr 3               ; This routine is used by both enter-screen and erase-screen
002AFCr 3               ; to get a buffer for the given screen number and set SCR to
002AFCr 3               ; the given screen number.  This word is not in the dictionary.
002AFCr 3               xt_editor_screen_helper:
002AFCr 3  20 rr rr                     jsr xt_dup
002AFFr 3  20 rr rr                     jsr xt_scr
002B02r 3  20 rr rr                     jsr xt_store
002B05r 3  20 rr rr                     jsr xt_buffer
002B08r 3               z_editor_screen_helper:
002B08r 3  60                           rts
002B09r 3               
002B09r 3               
002B09r 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
002B09r 3               ; ## "enter-screen"  auto  Tali Editor
002B09r 3               
002B09r 3               xt_editor_enter_screen:
002B09r 3                               ; Set the variable SCR and get a buffer for the
002B09r 3                               ; given screen number.
002B09r 3  20 rr rr                     jsr xt_editor_screen_helper
002B0Cr 3               
002B0Cr 3                               ; Drop the buffer address.
002B0Cr 3  20 rr rr                     jsr xt_drop
002B0Fr 3               
002B0Fr 3                               ; Overwrite the lines one at a time.
002B0Fr 3  64 rr                        stz editor1
002B11r 3               @prompt_loop:
002B11r 3                               ; Put the current line number on the stack.
002B11r 3  CA                           dex
002B12r 3  CA                           dex
002B13r 3  A5 rr                        lda editor1
002B15r 3  95 00                        sta 0,x
002B17r 3  74 01                        stz 1,x
002B19r 3               
002B19r 3                               ; Use the O word to prompt for overwrite.
002B19r 3  20 rr rr                     jsr xt_editor_o
002B1Cr 3               
002B1Cr 3                               ; Move on to the next line.
002B1Cr 3  E6 rr                        inc editor1
002B1Er 3  A9 10                        lda #16
002B20r 3  C5 rr                        cmp editor1
002B22r 3  D0 ED                        bne @prompt_loop
002B24r 3               
002B24r 3               z_editor_enter_screen:
002B24r 3  60                           rts
002B25r 3               
002B25r 3               
002B25r 3               
002B25r 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
002B25r 3               ; ## "erase-screen"  tested  Tali Editor
002B25r 3               xt_editor_erase_screen:
002B25r 3                               ; Set the variable SCR and get a buffer for the
002B25r 3                               ; given screen number.
002B25r 3  20 rr rr                     jsr xt_editor_screen_helper
002B28r 3               
002B28r 3                               ; Put 1024 (chars/screen) on stack.
002B28r 3  CA                           dex
002B29r 3  CA                           dex
002B2Ar 3  74 00                        stz 0,x
002B2Cr 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
002B2Er 3  95 01                        sta 1,x
002B30r 3               
002B30r 3                               ; Erase the entire block (fill with spaces).
002B30r 3  20 rr rr                     jsr xt_blank
002B33r 3               
002B33r 3                               ; Mark buffer as updated.
002B33r 3  20 rr rr                     jsr xt_update
002B36r 3               
002B36r 3               z_editor_erase_screen:
002B36r 3  60                           rts
002B37r 3               
002B37r 3               
002B37r 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
002B37r 3               ; ## "el"  tested  Tali Editor
002B37r 3               xt_editor_el:
002B37r 3                               ; Turn the line number into buffer offset.
002B37r 3                               ; This also loads the block into the buffer if it's
002B37r 3                               ; not there for some reason.
002B37r 3  20 rr rr                     jsr xt_editor_line
002B3Ar 3               
002B3Ar 3                               ; Put 64 (# of chars/line) on the stack.
002B3Ar 3  CA                           dex
002B3Br 3  CA                           dex
002B3Cr 3  A9 40                        lda #64
002B3Er 3  95 00                        sta 0,x
002B40r 3  74 01                        stz 1,x
002B42r 3               
002B42r 3                               ; Fill with spaces.
002B42r 3  20 rr rr                     jsr xt_blank
002B45r 3               
002B45r 3                               ; Mark buffer as updated.
002B45r 3  20 rr rr                     jsr xt_update
002B48r 3               
002B48r 3  60           z_editor_el:    rts
002B49r 3               
002B49r 3               
002B49r 3               ; ## EDITOR_L ( -- ) "List the current screen"
002B49r 3               ; ## "l"  tested  Tali Editor
002B49r 3               
002B49r 3               xt_editor_l:
002B49r 3                               ; Load the current screen
002B49r 3  CA                           dex             ; Put SCR on the stack.
002B4Ar 3  CA                           dex
002B4Br 3  A0 02                        ldy #scr_offset
002B4Dr 3  B1 rr                        lda (up),y
002B4Fr 3  95 00                        sta 0,x
002B51r 3  C8                           iny
002B52r 3  B1 rr                        lda (up),y
002B54r 3  95 01                        sta 1,x
002B56r 3  20 rr rr                     jsr xt_block    ; Get the current screen.
002B59r 3               
002B59r 3  20 rr rr                     jsr xt_cr
002B5Cr 3               
002B5Cr 3                               ; Print the screen number.
002B5Cr 3                               ; We're using sliteral, so we need to set up the
002B5Cr 3                               ; appropriate data structure (see sliteral)
002B5Cr 3  80 08                        bra @after_screen_msg
002B5Er 3               
002B5Er 3               @screen_msg:
002B5Er 3  53 63 72 65                  .byte "Screen #"
002B62r 3  65 6E 20 23  
002B66r 3               
002B66r 3               @after_screen_msg:
002B66r 3  20 rr rr                     jsr sliteral_runtime
002B69r 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
002B6Dr 3               
002B6Dr 3  20 rr rr                     jsr xt_type
002B70r 3               
002B70r 3                               ; Put the screen number and printed size for u.r on the stack.
002B70r 3  20 rr rr                     jsr xt_scr
002B73r 3  20 rr rr                     jsr xt_fetch
002B76r 3  CA                           dex
002B77r 3  CA                           dex
002B78r 3  A9 04                        lda #4          ; four spaces
002B7Ar 3  95 00                        sta 0,x
002B7Cr 3  74 01                        stz 1,x
002B7Er 3  20 rr rr                     jsr xt_u_dot_r
002B81r 3               
002B81r 3                               ; The address of the buffer is currently on the stack.
002B81r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
002B81r 3                               ; keep track of the line number in tmp3.
002B81r 3  64 rr                        stz tmp3
002B83r 3               
002B83r 3               @line_loop:
002B83r 3  20 rr rr                     jsr xt_cr
002B86r 3               
002B86r 3                               ; Print the line number (2-space fixed width)
002B86r 3  CA                           dex
002B87r 3  CA                           dex
002B88r 3  CA                           dex
002B89r 3  CA                           dex
002B8Ar 3  74 03                        stz 3,x
002B8Cr 3  A5 rr                        lda tmp3
002B8Er 3  95 02                        sta 2,x
002B90r 3  74 01                        stz 1,x
002B92r 3  A9 02                        lda #2
002B94r 3  95 00                        sta 0,x
002B96r 3  20 rr rr                     jsr xt_u_dot_r
002B99r 3  20 rr rr                     jsr xt_space
002B9Cr 3               
002B9Cr 3                               ; Print one line using the address on the stack.
002B9Cr 3  20 rr rr                     jsr xt_dup
002B9Fr 3  CA                           dex
002BA0r 3  CA                           dex
002BA1r 3  A9 40                        lda #64
002BA3r 3  95 00                        sta 0,x
002BA5r 3  74 01                        stz 1,x
002BA7r 3  20 rr rr                     jsr xt_type
002BAAr 3               
002BAAr 3                               ; Add 64 to the address on the stack to move to the next line.
002BAAr 3  18                           clc
002BABr 3  A9 40                        lda #64
002BADr 3  75 00                        adc 0,x
002BAFr 3  95 00                        sta 0,x
002BB1r 3  B5 01                        lda 1,x
002BB3r 3  69 00                        adc #0      ; Add carry
002BB5r 3  95 01                        sta 1,x
002BB7r 3               
002BB7r 3                               ; Increment the line number (held in tmp3)
002BB7r 3  E6 rr                        inc tmp3
002BB9r 3               
002BB9r 3                               ; See if we are done.
002BB9r 3  A5 rr                        lda tmp3
002BBBr 3  C9 10                        cmp #16
002BBDr 3  D0 C4                        bne @line_loop
002BBFr 3               
002BBFr 3  20 rr rr                     jsr xt_cr
002BC2r 3                               ; Drop the address on the stack.
002BC2r 3  E8                           inx
002BC3r 3  E8                           inx
002BC4r 3               
002BC4r 3  60           z_editor_l:            rts
002BC5r 3               
002BC5r 3               
002BC5r 3               
002BC5r 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
002BC5r 3               ; ## "line"  tested  Tali Editor
002BC5r 3               
002BC5r 3               xt_editor_line:
002BC5r 3  20 rr rr                     jsr underflow_1
002BC8r 3               
002BC8r 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
002BC8r 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
002BCAr 3               @shift_tos_left:
002BCAr 3  16 00                        asl 0,x         ; Shift TOS to the left
002BCCr 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
002BCEr 3  88                           dey
002BCFr 3  D0 F9                        bne @shift_tos_left
002BD1r 3                               ; Load the current screen into a buffer
002BD1r 3                               ; and get the buffer address
002BD1r 3  20 rr rr                     jsr xt_scr
002BD4r 3  20 rr rr                     jsr xt_fetch
002BD7r 3  20 rr rr                     jsr xt_block
002BDAr 3               
002BDAr 3                               ; Add the offset to the buffer base address.
002BDAr 3  20 rr rr                     jsr xt_plus
002BDDr 3               
002BDDr 3  60           z_editor_line:  rts
002BDEr 3               
002BDEr 3               
002BDEr 3               
002BDEr 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
002BDEr 3               ; ## "o"  tested  Tali Editor
002BDEr 3               xt_editor_o:
002BDEr 3                               ; Print prompt
002BDEr 3  20 rr rr                     jsr xt_cr
002BE1r 3  20 rr rr                     jsr xt_dup
002BE4r 3  20 rr rr                     jsr xt_two
002BE7r 3  20 rr rr                     jsr xt_u_dot_r
002BEAr 3  20 rr rr                     jsr xt_space
002BEDr 3  A9 2A                        lda #42         ; ASCII for *
002BEFr 3  20 rr rr                     jsr emit_a
002BF2r 3  20 rr rr                     jsr xt_space
002BF5r 3               
002BF5r 3                               ; Accept new input (directly into the buffer)
002BF5r 3  20 rr rr                     jsr xt_editor_line
002BF8r 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
002BFBr 3  CA                           dex
002BFCr 3  CA                           dex
002BFDr 3  A9 40                        lda #64         ; chars/line
002BFFr 3  95 00                        sta 0,x
002C01r 3  74 01                        stz 1,x
002C03r 3  20 rr rr                     jsr xt_accept
002C06r 3               
002C06r 3                               ; Fill the rest with spaces.
002C06r 3                               ; Stack is currently ( line_address numchars_from_accept )
002C06r 3  20 rr rr                     jsr xt_dup
002C09r 3  20 rr rr                     jsr xt_not_rote ; -rot
002C0Cr 3  20 rr rr                     jsr xt_plus
002C0Fr 3  CA                           dex
002C10r 3  CA                           dex
002C11r 3  A9 40                        lda #64         ; chars/line
002C13r 3  95 00                        sta 0,x
002C15r 3  74 01                        stz 1,x
002C17r 3  20 rr rr                     jsr xt_rot
002C1Ar 3  20 rr rr                     jsr xt_minus
002C1Dr 3  20 rr rr                     jsr xt_blank
002C20r 3               
002C20r 3                               ; Mark buffer as updated.
002C20r 3  20 rr rr                     jsr xt_update
002C23r 3               
002C23r 3  60           z_editor_o:     rts
002C24r 3               
002C24r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
002C24r 3               ; ## "lcdput" coded Custom
002C24r 3               xt_lcdput:
002C24r 3  20 rr rr                     jsr underflow_1
002C27r 3               
002C27r 3  B5 00                        lda 0,x
002C29r 3                       .ifdef lcd_print
002C29r 3                               jsr lcd_print
002C29r 3                       .endif
002C29r 3  E8                           inx
002C2Ar 3  E8                           inx
002C2Br 3  60           z_lcdput: rts
002C2Cr 3               
002C2Cr 3               
002C2Cr 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
002C2Cr 3               ; ## "lcdprint"  coded Custom
002C2Cr 3               
002C2Cr 3               xt_lcdprint:
002C2Cr 3  20 rr rr                     jsr underflow_2
002C2Fr 3               
002C2Fr 3                               ; Save the starting address into tmp1
002C2Fr 3  B5 02                        lda 2,x
002C31r 3  85 rr                        sta tmp1
002C33r 3  B5 03                        lda 3,x
002C35r 3  85 rr                        sta tmp1+1
002C37r 3               @loop:
002C37r 3                               ; done if length is zero
002C37r 3  B5 00                        lda 0,x
002C39r 3  15 01                        ora 1,x
002C3Br 3  F0 12                        beq @done
002C3Dr 3               
002C3Dr 3                               ; Send the current character
002C3Dr 3  B2 rr                        lda (tmp1)
002C3Fr 3                       .ifdef lcd_print
002C3Fr 3                               jsr lcd_print      ; avoids stack foolery
002C3Fr 3                       .endif
002C3Fr 3                               ; Move the address along (in tmp1)
002C3Fr 3  E6 rr                        inc tmp1
002C41r 3  D0 02                        bne @1
002C43r 3  E6 rr                        inc tmp1+1
002C45r 3               @1:
002C45r 3                               ; Reduce the count (on the data stack)
002C45r 3  B5 00                        lda 0,x
002C47r 3  D0 02                        bne @2
002C49r 3  D6 01                        dec 1,x
002C4Br 3               @2:
002C4Br 3  D6 00                        dec 0,x
002C4Dr 3               
002C4Dr 3  80 E8                        bra @loop
002C4Fr 3               @done:
002C4Fr 3  E8                           inx
002C50r 3  E8                           inx
002C51r 3  E8                           inx
002C52r 3  E8                           inx
002C53r 3               
002C53r 3  60           z_lcdprint:         rts
002C54r 3               
002C54r 3               
002C54r 3               
002C54r 3               ; ## CLS ( -- ) "clea VGA screen"
002C54r 3               ; ## "cls" coded Custom
002C54r 3               xt_cls:
002C54r 3                       .ifdef vga_clear
002C54r 3                               jsr vga_clear
002C54r 3                       .endif
002C54r 3               
002C54r 3  60           z_cls: rts
002C55r 3               
002C55r 3               
002C55r 3               ; ## SPI_INIT ( -- ) "Init SPI system"
002C55r 3               ; ## "spi_init" coded Custom
002C55r 3               xt_spi_init:
002C55r 3               .ifdef VIA1_BASE
002C55r 3  20 rr rr                     jsr spi_init
002C58r 3               .endif
002C58r 3  60           z_spi_init: rts
002C59r 3               
002C59r 3               
002C59r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
002C59r 3               ; ## "spi_clk_toggle" coded Custom
002C59r 3               xt_spi_clk_toggle:
002C59r 3               .ifdef VIA1_BASE
002C59r 3  20 rr rr                     jsr spi_clk_toggle
002C5Cr 3               .endif
002C5Cr 3  60           z_spi_clk_toggle: rts
002C5Dr 3               
002C5Dr 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
002C5Dr 3               ; ## "spi_select" coded Custom
002C5Dr 3               xt_spi_select:
002C5Dr 3               .ifdef VIA1_BASE
002C5Dr 3  20 rr rr                     jsr underflow_1
002C60r 3               
002C60r 3  B5 00                        lda 0,x
002C62r 3               
002C62r 3  20 rr rr                     jsr spi_select
002C65r 3               
002C65r 3  E8                           inx
002C66r 3  E8                           inx
002C67r 3               .endif
002C67r 3  60           z_spi_select: rts
002C68r 3               
002C68r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
002C68r 3               ; ## "spi_transceive" coded Custom
002C68r 3               xt_spi_transceive:
002C68r 3               .ifdef VIA1_BASE
002C68r 3  20 rr rr                     jsr underflow_1
002C6Br 3               
002C6Br 3  B5 00                        lda 0,x
002C6Dr 3               
002C6Dr 3  20 rr rr                     jsr spi_transceive
002C70r 3               
002C70r 3  95 00                        sta 0,x         ; put return value in TOS
002C72r 3  74 01                        stz 1,X         ;reset value there
002C74r 3               .endif
002C74r 3  60           z_spi_transceive: rts
002C75r 3               
002C75r 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
002C75r 3               ; ## "sd_init" coded Custom
002C75r 3               xt_sd_init:
002C75r 3               .ifdef SD
002C75r 3                               jsr underflow_1
002C75r 3               
002C75r 3                               lda 0,x
002C75r 3                               jsr sd_init
002C75r 3                               beq @ok
002C75r 3                               pha
002C75r 3                               printascii sd_init_error_message
002C75r 3                               pla
002C75r 3               @ok:
002C75r 3                               sta 0,x         ; put return value in TOS
002C75r 3                               stz 1,X         ;reset value there
002C75r 3               .endif
002C75r 3  60           z_sd_init: rts
002C76r 3               
002C76r 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
002C76r 3               ; ## "sd_readsector" coded Custom
002C76r 3               xt_sd_readsector:
002C76r 3               
002C76r 3               .ifdef SD
002C76r 3                               jsr underflow_2
002C76r 3                               ; get and save sector number (32 bit number, double)
002C76r 3                               ; most significant part is TOS
002C76r 3                               lda 0, x
002C76r 3                               sta IO_SECTOR + 2
002C76r 3                               lda 1, x
002C76r 3                               sta IO_SECTOR + 3
002C76r 3                               ; least significant part is NOS
002C76r 3                               lda 2, x
002C76r 3                               sta IO_SECTOR + 0
002C76r 3                               lda 3, x
002C76r 3                               sta IO_SECTOR + 1
002C76r 3                               lda #1
002C76r 3                               sta SD_CRC
002C76r 3               
002C76r 3                               jsr sd_readsector
002C76r 3                               sta 0,x         ; put return value in TOS
002C76r 3                               stz 1,X         ;reset value there
002C76r 3               
002C76r 3                               inx
002C76r 3                               inx
002C76r 3               .endif
002C76r 3  60           z_sd_readsector: rts
002C77r 3               
002C77r 3               
002C77r 3               ; ## time ( -- addr ) "get time storage address"
002C77r 3               ; ## "time" coded Custom
002C77r 3               xt_time:
002C77r 3                       .ifdef time
002C77r 3  A9 rr                lda #time
002C79r 3                       .else
002C79r 3                       lda #0
002C79r 3                       .endif
002C79r 3  CA                   dex
002C7Ar 3  CA                   dex
002C7Br 3  95 00                sta 0,x
002C7Dr 3  74 01                stz 1,x
002C7Fr 3               
002C7Fr 3               
002C7Fr 3  60           z_time: rts
002C80r 3               
002C80r 3               xt_cf_init:
002C80r 3               .ifdef CF_ADDRESS
002C80r 3                       ; jsr underflow_1
002C80r 3                       ; save CF card address
002C80r 3                       ; lda 0, x
002C80r 3                       ; sta CF_ADDRESS
002C80r 3                       ; lda 1, x
002C80r 3                       ; sta CF_ADDRESS + 1
002C80r 3  20 rr rr             jsr cf_init
002C83r 3                       ; inx
002C83r 3                       ; inx
002C83r 3               .endif
002C83r 3               z_cf_init:
002C83r 3  60                   rts
002C84r 3               
002C84r 3               ; ## fat ( addr -- ) "Initialize FAT16 on CF or SD card at specified address"
002C84r 3               ; ## "fat" coded Custom
002C84r 3               xt_fat_init:
002C84r 3               .ifdef CF_ADDRESS
002C84r 3                       ; initialize CF card
002C84r 3  20 rr rr             jsr cf_init
002C87r 3               .endif
002C87r 3               .ifdef SD
002C87r 3                       lda #7
002C87r 3                       jsr sd_init
002C87r 3               .endif
002C87r 3               .ifdef IO_BUFFER
002C87r 3               .ifdef fat_init
002C87r 3                       jsr fat_init
002C87r 3               .endif
002C87r 3  AD rr rr 20          printstr IO_BUFFER + 43, 11
002C8Br 3  rr rr AD rr  
002C8Fr 3  rr 20 rr rr  
002CC9r 3                       ; printascii cf_fat_mounted_message
002CC9r 3                       ; jsr xt_cr
002CC9r 3               fat_init_exit:
002CC9r 3  CA                   dex
002CCAr 3  CA                   dex
002CCBr 3  A9 rr                lda #<IO_BUFFER
002CCDr 3  95 00                sta 0, x
002CCFr 3  A9 rr                lda #>IO_BUFFER
002CD1r 3  95 01                sta 1, x
002CD3r 3               .endif
002CD3r 3               z_fat_init:
002CD3r 3  60                   rts
002CD4r 3               
002CD4r 3               
002CD4r 3               ls_header:
002CD4r 3  4E 41 4D 45          .asciiz "NAME     EXT  TYPE  SIZE"
002CD8r 3  20 20 20 20  
002CDCr 3  20 45 58 54  
002CEDr 3               xt_cf_ls:
002CEDr 3               .ifdef fat_convert_filename
002CEDr 3                       ; read the current directory entry
002CEDr 3                       ; and save the contents to be displayed later
002CEDr 3               
002CEDr 3                       ; check if fat is inited
002CEDr 3                       lda FAT_SEC_PER_CLUS
002CEDr 3                       bne @fatok
002CEDr 3                       jsr xt_fat_init
002CEDr 3                       inx     ; drop fat_init return value
002CEDr 3                       inx
002CEDr 3                       jsr xt_cr
002CEDr 3               
002CEDr 3               @fatok:
002CEDr 3                       cp16 FAT_CURRENT_DIR_SEC, IO_SECTOR
002CEDr 3                       cp16 FAT_CURRENT_DIR_SEC + 2, IO_SECTOR + 2
002CEDr 3               
002CEDr 3                       jsr io_read_sector
002CEDr 3               
002CEDr 3                       ; current directory first sector is now in buffer
002CEDr 3                       ; display file names
002CEDr 3                       jsr xt_cr
002CEDr 3                       printascii ls_header
002CEDr 3                       jsr xt_cr
002CEDr 3               
002CEDr 3                       lda #<IO_BUFFER
002CEDr 3                       sta FAT_PTR2
002CEDr 3                       lda #>IO_BUFFER
002CEDr 3                       sta FAT_PTR2 + 1
002CEDr 3               
002CEDr 3                       phy
002CEDr 3               @outerloop:
002CEDr 3                       ldy #11
002CEDr 3                       lda (FAT_PTR2), y
002CEDr 3                       cmp #$0F                ; ignore long filenames
002CEDr 3                       beq @next_entry
002CEDr 3                       ldy #0
002CEDr 3                       lda (FAT_PTR2), Y
002CEDr 3                       beq @exit               ; if zero, it means we reached the end of the list
002CEDr 3                       cmp #$E5                ; if $E5, it means the entry is deleted, so go to next entry
002CEDr 3                       beq @next_entry
002CEDr 3               @loop:
002CEDr 3                       lda (FAT_PTR2), y
002CEDr 3                       jsr emit_a
002CEDr 3                       iny
002CEDr 3                       cpy #8
002CEDr 3                       bne @check_end          ; print space after name and before extension
002CEDr 3                       lda #' '
002CEDr 3                       jsr emit_a
002CEDr 3               @check_end:
002CEDr 3                       cpy #11
002CEDr 3                       bcc @loop
002CEDr 3                       ; read entry type
002CEDr 3                       lda (FAT_PTR2), y
002CEDr 3                       jsr print_entry_type
002CEDr 3               
002CEDr 3                       jsr print_entry_size
002CEDr 3                       lda #$0D
002CEDr 3                       jsr emit_a
002CEDr 3               @next_entry:
002CEDr 3                       add16 FAT_PTR2, fat_entry_size, FAT_PTR2
002CEDr 3                       bra @outerloop
002CEDr 3               @exit:
002CEDr 3                       ply
002CEDr 3               .endif
002CEDr 3               
002CEDr 3                       ; dex
002CEDr 3                       ; dex
002CEDr 3                       ; lda #<IO_BUFFER
002CEDr 3                       ; sta 0, x
002CEDr 3                       ; lda #>IO_BUFFER
002CEDr 3                       ; sta 1, x
002CEDr 3               
002CEDr 3               z_cf_ls:
002CEDr 3  60                   rts
002CEEr 3               .ifdef fat_convert_filename
002CEEr 3               print_entry_size:
002CEEr 3                       phy
002CEEr 3               
002CEEr 3                       dex
002CEEr 3                       dex
002CEEr 3                       dex
002CEEr 3                       dex
002CEEr 3               
002CEEr 3                       ldy #28
002CEEr 3                       lda (FAT_PTR2), y
002CEEr 3                       sta 2,x
002CEEr 3                       ldy #29
002CEEr 3                       lda (FAT_PTR2), y
002CEEr 3                       sta 3,x
002CEEr 3               
002CEEr 3                       ldy #30
002CEEr 3                       lda (FAT_PTR2), y
002CEEr 3                       sta 0,x
002CEEr 3               
002CEEr 3                       ldy #31
002CEEr 3                       lda (FAT_PTR2), y
002CEEr 3                       sta 1,x
002CEEr 3                       jsr xt_ud_dot
002CEEr 3                       ply
002CEEr 3                       rts
002CEEr 3               
002CEEr 3               print_entry_type:
002CEEr 3                       and #$10
002CEEr 3                       bne @is_dir
002CEEr 3                       bra @is_file
002CEEr 3               @is_dir:
002CEEr 3                       printascii entry_type_dir
002CEEr 3                       bra @exit
002CEEr 3               @is_file:
002CEEr 3                       printascii entry_type_file
002CEEr 3               @exit:
002CEEr 3                       rts
002CEEr 3               
002CEEr 3               entry_type_dir: .asciiz "   D    "
002CEEr 3               entry_type_file: .asciiz "   F    "
002CEEr 3               .endif
002CEEr 3               xt_cf_info:
002CEEr 3               .ifdef CF_ADDRESS
002CEEr 3  20 rr rr             jsr cf_info
002CF1r 3  20 rr rr             jsr xt_cr
002CF4r 3  20 rr rr             jsr cf_print_id
002CF7r 3  20 rr rr             jsr cf_print_capacity
002CFAr 3               .endif
002CFAr 3               z_cf_info:
002CFAr 3  60                   rts
002CFBr 3               
002CFBr 3               xt_cf_cd:
002CFBr 3               .ifdef fat_convert_filename
002CFBr 3                       phy
002CFBr 3                       ; check if fat is inited
002CFBr 3               	lda FAT_SEC_PER_CLUS
002CFBr 3               	bne @fatok
002CFBr 3               	jsr xt_fat_init
002CFBr 3               	inx     ; drop fat_init return value
002CFBr 3               	inx
002CFBr 3               @fatok:
002CFBr 3                       lda 0, x
002CFBr 3                       sta FAT_PTR1
002CFBr 3                       lda 1, x
002CFBr 3                       sta FAT_PTR1 + 1
002CFBr 3                       lda 2, x
002CFBr 3                       sta FAT_PTR2
002CFBr 3                       lda 3, x
002CFBr 3                       sta FAT_PTR2+1
002CFBr 3               
002CFBr 3                       jsr fat_convert_filename
002CFBr 3               
002CFBr 3                       jsr fat_find_file               ; after this, the pointer to the entry in IO_BUFFER is in FAT_PTR1
002CFBr 3                       bcs @found
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       jsr xt_cr
002CFBr 3                       printstr FAT_FILE_NAME_TMP, 11
002CFBr 3                       printascii not_found_error        ; directory not found, abort
002CFBr 3                       jsr xt_cr
002CFBr 3                       ply
002CFBr 3                       jsr xt_abort
002CFBr 3               @found:
002CFBr 3                       ; check if entry is a directory
002CFBr 3                       ldy #11
002CFBr 3                       lda (FAT_PTR1), y
002CFBr 3                       and #$10
002CFBr 3                       bne @is_dir
002CFBr 3                       jsr xt_cr
002CFBr 3                       printascii not_dir_error        ; Not a directory, abort
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       ply
002CFBr 3                       jsr xt_cr
002CFBr 3                       jsr xt_abort
002CFBr 3               @is_dir:
002CFBr 3                       ; load cluster number from dir entry
002CFBr 3                       ldy #26
002CFBr 3                       lda (FAT_PTR1), y
002CFBr 3                       sta FAT_CURRENT_CLUSTER
002CFBr 3                       iny
002CFBr 3                       lda (FAT_PTR1), y
002CFBr 3                       sta FAT_CURRENT_CLUSTER + 1
002CFBr 3                       ; convert cluster number to sector
002CFBr 3                       jsr fat_get_sector_for_cluster
002CFBr 3                       ; save sector number to CF_CURRENT_DIR_SEC
002CFBr 3               
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       inx
002CFBr 3                       ply
002CFBr 3               .endif
002CFBr 3               z_cf_cd:
002CFBr 3               
002CFBr 3  60                   rts
002CFCr 3               .ifdef fat_convert_filename
002CFCr 3               not_dir_error: .asciiz "Not a directory"
002CFCr 3               not_found_error: .asciiz " not found"
002CFCr 3               .endif
002CFCr 3               
002CFCr 3               
002CFCr 3               xt_cf_cat:
002CFCr 3               .ifdef fat_convert_filename
002CFCr 3                       phy
002CFCr 3                       ; check if fat is inited
002CFCr 3               	lda FAT_SEC_PER_CLUS
002CFCr 3               	bne @fatok
002CFCr 3               	jsr xt_fat_init
002CFCr 3               	inx     ; drop fat_init return value
002CFCr 3               	inx
002CFCr 3               @fatok:
002CFCr 3                       lda 0, x
002CFCr 3                       sta FAT_PTR1
002CFCr 3                       lda 1, x
002CFCr 3                       sta FAT_PTR1 + 1
002CFCr 3                       lda 2, x
002CFCr 3                       sta FAT_PTR2
002CFCr 3                       lda 3, x
002CFCr 3                       sta FAT_PTR2+1
002CFCr 3               
002CFCr 3                       jsr fat_convert_filename
002CFCr 3               
002CFCr 3                       jsr fat_find_file               ; after this, the pointer to the entry in IO_BUFFER is in FAT_PTR1
002CFCr 3                       bcs @found
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       jsr xt_cr
002CFCr 3                       printstr FAT_FILE_NAME_TMP, 11
002CFCr 3                       printascii not_found_error        ; Not a directory, abort
002CFCr 3                       jsr xt_cr
002CFCr 3                       jsr xt_abort
002CFCr 3               @found:
002CFCr 3                       ; check if entry is a directory
002CFCr 3                       ldy #11
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       and #$10
002CFCr 3                       beq @is_file
002CFCr 3                       jsr xt_cr
002CFCr 3                       printascii not_file_error        ; Not a directory, abort
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       jsr xt_cr
002CFCr 3                       jsr xt_abort
002CFCr 3               @is_file:
002CFCr 3                       ; load cluster number from dir entry
002CFCr 3                       ldy #26
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_CLUSTER
002CFCr 3                       iny
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_CLUSTER + 1
002CFCr 3                       iny
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_FILE_SIZE
002CFCr 3                       iny
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_FILE_SIZE + 1
002CFCr 3                       iny
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_FILE_SIZE + 2
002CFCr 3                       iny
002CFCr 3                       lda (FAT_PTR1), y
002CFCr 3                       sta FAT_CURRENT_FILE_SIZE + 3
002CFCr 3                       ; convert cluster number to sector
002CFCr 3                       cp16 FAT_CURRENT_DIR_SEC, FAT_TMP
002CFCr 3                       cp16 FAT_CURRENT_DIR_SEC + 2, FAT_TMP + 2
002CFCr 3                       jsr fat_get_sector_for_cluster
002CFCr 3                       ; save sector number to CF_LBA
002CFCr 3                       cp16 FAT_CURRENT_DIR_SEC, IO_SECTOR
002CFCr 3                       cp16 FAT_CURRENT_DIR_SEC + 2, IO_SECTOR + 2
002CFCr 3                       cp16 FAT_TMP, FAT_CURRENT_DIR_SEC
002CFCr 3                       cp16 FAT_TMP + 2, FAT_CURRENT_DIR_SEC + 2
002CFCr 3               
002CFCr 3                       ; file sector number is in CF_CURRENT_FILE_SEC
002CFCr 3               @read_next_file_sector:
002CFCr 3                       jsr io_read_sector
002CFCr 3                       jsr xt_cr
002CFCr 3                       jsr output_sector
002CFCr 3               
002CFCr 3                       ; jsr reduce_filesize_by_one_sector
002CFCr 3               
002CFCr 3                       ; ; check if filesize is zero
002CFCr 3                       ; lda CF_CURRENT_FILE_SIZE + 3
002CFCr 3                       ; bne @read_next_file_sector
002CFCr 3                       ; lda CF_CURRENT_FILE_SIZE + 2
002CFCr 3                       ; bne @read_next_file_sector
002CFCr 3                       ; lda CF_CURRENT_FILE_SIZE + 1
002CFCr 3                       ; bne @read_next_file_sector
002CFCr 3               
002CFCr 3                       ; lda CF_CURRENT_FILE_SIZE
002CFCr 3                       ; bne @read_next_file_sector
002CFCr 3               
002CFCr 3               
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       inx
002CFCr 3                       ; lda #<CF_CURRENT_FILE_SIZE
002CFCr 3                       ; sta 0, x
002CFCr 3                       ; lda #>CF_CURRENT_FILE_SIZE
002CFCr 3                       ; sta 1, x
002CFCr 3               
002CFCr 3                       ply
002CFCr 3               .endif
002CFCr 3               z_cf_cat:
002CFCr 3  60                   rts
002CFDr 3               
002CFDr 3               .ifdef fat_convert_filename
002CFDr 3               not_file_error: .asciiz "Not a file"
002CFDr 3               .endif
002CFDr 3               
002CFDr 3               ; ## cf_readsector ( double -- addr ) "Set LBA block and read to buffer"
002CFDr 3               ; ## "cf_readsector" coded Custom
002CFDr 3               xt_cf_readsector:
002CFDr 3               .ifdef CF_ADDRESS
002CFDr 3  20 rr rr             jsr underflow_2
002D00r 3                       ; most significant part is TOS
002D00r 3  B5 00                lda 0, x
002D02r 3  8D rr rr             sta IO_SECTOR + 2
002D05r 3  B5 01                lda 1, x
002D07r 3  8D rr rr             sta IO_SECTOR + 3
002D0Ar 3                       ; least significant part is NOS
002D0Ar 3  B5 02                lda 2, x
002D0Cr 3  8D rr rr             sta IO_SECTOR + 0
002D0Fr 3  B5 03                lda 3, x
002D11r 3  8D rr rr             sta IO_SECTOR + 1
002D14r 3                       ; LBA is set, now read sector
002D14r 3  20 rr rr             jsr cf_init
002D17r 3               
002D17r 3  A9 rr                lda #<IO_BUFFER
002D19r 3  85 rr                sta io_buffer_ptr
002D1Br 3  A9 rr                lda #>IO_BUFFER
002D1Dr 3  85 rr                sta io_buffer_ptr + 1
002D1Fr 3  20 rr rr             jsr cf_read_sector
002D22r 3               
002D22r 3                       ; return buffer address
002D22r 3  E8                   inx
002D23r 3  E8                   inx
002D24r 3  A9 rr                lda #<IO_BUFFER
002D26r 3  95 00                sta 0, x
002D28r 3               
002D28r 3  A9 rr                lda #>IO_BUFFER
002D2Ar 3               
002D2Ar 3  95 01                sta 1, x
002D2Cr 3               .endif
002D2Cr 3               z_cf_readsector:
002D2Cr 3  60                   rts
002D2Dr 3               
002D2Dr 3               xt_cf_rsptr:
002D2Dr 3               .ifdef CF_ADDRESS
002D2Dr 3  CA                   dex
002D2Er 3  CA                   dex
002D2Fr 3  A9 rr                lda #<cf_read_sector
002D31r 3  95 00                sta 0, x
002D33r 3  A9 rr                lda #>cf_read_sector
002D35r 3  95 01                sta 1, x
002D37r 3                       .endif
002D37r 3               z_cf_rsptr:
002D37r 3  60                   rts
002D38r 3               
002D38r 3               xt_sd_rsptr:
002D38r 3               .ifdef SD
002D38r 3                       dex
002D38r 3                       dex
002D38r 3                       lda #<sd_readsector
002D38r 3                       sta 0, x
002D38r 3                       lda #>sd_readsector
002D38r 3                       sta 1, x
002D38r 3               .endif
002D38r 3               z_sd_rsptr:
002D38r 3  60                   rts
002D39r 3               
002D39r 3               xt_io_readsector:
002D39r 3               .ifdef IO_BUFFER
002D39r 3  CA                   dex
002D3Ar 3  CA                   dex
002D3Br 3  A9 rr                lda #<io_read_sector_address
002D3Dr 3  95 00                sta 0, x
002D3Fr 3  A9 rr                lda #>io_read_sector_address
002D41r 3  95 01                sta 1, x
002D43r 3               .endif
002D43r 3               z_io_readsector:
002D43r 3  60                   rts
002D44r 3               
002D44r 3               xt_io_readblock:
002D44r 3               .ifdef IO_BUFFER
002D44r 3                       ; block-read ( addr blk# -- )
002D44r 3  B5 02                lda 2, x
002D46r 3  85 rr                sta io_buffer_ptr
002D48r 3  B5 03                lda 3, x
002D4Ar 3  85 rr                sta io_buffer_ptr + 1
002D4Cr 3  B5 00                lda 0, x
002D4Er 3  8D rr rr             sta IO_SECTOR
002D51r 3  B5 01                lda 1, x
002D53r 3  8D rr rr             sta IO_SECTOR + 1
002D56r 3  9C rr rr             stz IO_SECTOR + 2
002D59r 3  9C rr rr             stz IO_SECTOR + 3
002D5Cr 3               
002D5Cr 3  0E rr rr             asl IO_SECTOR                   ; multiply by two to get first sector number
002D5Fr 3  2E rr rr             rol IO_SECTOR + 1
002D62r 3  2E rr rr             rol IO_SECTOR + 2
002D65r 3               
002D65r 3                       ; lda io_buffer_ptr
002D65r 3                       ; sta 0, x
002D65r 3                       ; lda io_buffer_ptr + 1
002D65r 3                       ; sta 1, x
002D65r 3                       ; jsr xt_dot
002D65r 3               
002D65r 3  20 rr rr             jsr io_read_sector
002D68r 3  EE rr rr D0          inc32 IO_SECTOR
002D6Cr 3  0D EE rr rr  
002D70r 3  D0 08 EE rr  
002D7Ar 3  E6 rr                inc io_buffer_ptr + 1
002D7Cr 3  E6 rr                inc io_buffer_ptr + 1
002D7Er 3  20 rr rr             jsr io_read_sector
002D81r 3                       ; lda io_buffer_ptr
002D81r 3                       ; sta 0, x
002D81r 3                       ; lda io_buffer_ptr + 1
002D81r 3                       ; sta 1, x
002D81r 3                       ; jsr xt_dot
002D81r 3               
002D81r 3  E8                   inx
002D82r 3  E8                   inx
002D83r 3               
002D83r 3               .endif
002D83r 3               z_io_readblock:
002D83r 3  60                   rts
002D84r 3               
002D84r 3               xt_io_writeblock:
002D84r 3               .ifdef IO_BUFFER
002D84r 3                       ; block-write ( addr blk# -- )
002D84r 3  B5 02                lda 2, x
002D86r 3  85 rr                sta io_buffer_ptr
002D88r 3  B5 03                lda 3, x
002D8Ar 3  85 rr                sta io_buffer_ptr + 1
002D8Cr 3  B5 00                lda 0, x
002D8Er 3  8D rr rr             sta IO_SECTOR
002D91r 3  B5 01                lda 1, x
002D93r 3  8D rr rr             sta IO_SECTOR + 1
002D96r 3  9C rr rr             stz IO_SECTOR + 2
002D99r 3  9C rr rr             stz IO_SECTOR + 3
002D9Cr 3               
002D9Cr 3  0E rr rr             asl IO_SECTOR                   ; multiply by two to get first sector number
002D9Fr 3  2E rr rr             rol IO_SECTOR + 1
002DA2r 3  2E rr rr             rol IO_SECTOR + 2
002DA5r 3               
002DA5r 3  20 rr rr             jsr io_write_sector
002DA8r 3  EE rr rr D0          inc32 IO_SECTOR
002DACr 3  0D EE rr rr  
002DB0r 3  D0 08 EE rr  
002DBAr 3  E6 rr                inc io_buffer_ptr + 1
002DBCr 3  E6 rr                inc io_buffer_ptr + 1
002DBEr 3  20 rr rr             jsr io_write_sector
002DC1r 3               
002DC1r 3               
002DC1r 3                       ; inc io_buffer_ptr + 1           ; jump two pages forward
002DC1r 3                       ; inc io_buffer_ptr + 1
002DC1r 3                       ; jsr io_write_sector
002DC1r 3  E8                   inx
002DC2r 3  E8                   inx
002DC3r 3                       ; inx
002DC3r 3                       ; inx
002DC3r 3               .endif
002DC3r 3               z_io_writeblock:
002DC3r 3  60                   rts
002DC4r 3               ; END
002DC4r 3               
002DC4r 3               
002DC4r 2                   .include "headers.s"          ; Headers of native words
002DC4r 3               ; Dictionary Headers for Tali Forth 2
002DC4r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
002DC4r 3               ; First version: 05. Dec 2016 (Liara Forth)
002DC4r 3               ; This version: 29. Dec 2018
002DC4r 3               
002DC4r 3               ; Dictionary headers are kept separately from the code, which allows various
002DC4r 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
002DC4r 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
002DC4r 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
002DC4r 3               ; header in the Dictionary. There the link to the next word in the Dictionary
002DC4r 3               ; is always one cell down from the current word's own nt. In the code itself,
002DC4r 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
002DC4r 3               
002DC4r 3               ; This gives us the following header structure:
002DC4r 3               
002DC4r 3               ;              8 bit     8 bit
002DC4r 3               ;               LSB       MSB
002DC4r 3               ; nt_word ->  +--------+--------+
002DC4r 3               ;          +0 | Length | Status |
002DC4r 3               ;             +--------+--------+
002DC4r 3               ;          +2 | Next Header     | -> nt_next_word
002DC4r 3               ;             +-----------------+
002DC4r 3               ;          +4 | Start of Code   | -> xt_word
002DC4r 3               ;             +-----------------+
002DC4r 3               ;          +6 | End of Code     | -> z_word
002DC4r 3               ;             +--------+--------+
002DC4r 3               ;          +8 | Name   |        |
002DC4r 3               ;             +--------+--------+
002DC4r 3               ;             |        |        |
002DC4r 3               ;             +--------+--------+
002DC4r 3               ;             |        |  ...   | (name string does not end with a zero)
002DC4r 3               ;          +n +--------+--------+
002DC4r 3               
002DC4r 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
002DC4r 3               ; which are:
002DC4r 3               
002DC4r 3               ;       CO - Compile Only
002DC4r 3               ;       IM - Immediate Word
002DC4r 3               ;       NN - Never Native Compile (must always be called by JSR)
002DC4r 3               ;       AN - Always Native Compile (may not be called by JSR)
002DC4r 3               ;       UF - Contains underflow check
002DC4r 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
002DC4r 3               
002DC4r 3               ; Note there are currently two bits unused.
002DC4r 3               
002DC4r 3               ; By default, all existing words can be natively compiled (compiled inline) or
002DC4r 3               ; as a subroutine jump target; the system decides which variant to use based on
002DC4r 3               ; a threshold the user can set. By default, all user-created words are flagged
002DC4r 3               ; never-native. The user can override this by using the always-native word
002DC4r 3               ; just after defining their new word.  The NN flag forbids native compiling,
002DC4r 3               ; the AN flag forces it.
002DC4r 3               
002DC4r 3               ; The last word (top word in code) is always BYE. It is marked as the last word
002DC4r 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
002DC4r 3               ; more common ones first (further down in code) so they are found earlier.
002DC4r 3               ; Anything to do with output comes later (further up) because things will
002DC4r 3               ; always be slow if there is a human involved.
002DC4r 3               
002DC4r 3               ; The initial skeleton of this list was automatically generated by a script
002DC4r 3               ; in the tools folder and then sorted by hand.
002DC4r 3               
002DC4r 3               nt_bye:
002DC4r 3  03                   .byte 3         ; length of word strings
002DC5r 3  00                   .byte 0         ; status byte
002DC6r 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
002DC8r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
002DCAr 3  rr rr                .word z_bye     ; end of code (RTS)
002DCCr 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
002DCFr 3               
002DCFr 3               
002DCFr 3               nt_cold:
002DCFr 3  04 00                .byte 4, 0
002DD1r 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
002DD5r 3  rr rr        
002DD7r 3  63 6F 6C 64          .byte "cold"
002DDBr 3               
002DDBr 3               nt_lcdput:
002DDBr 3  06 10                .byte 6, UF
002DDDr 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
002DE1r 3  rr rr        
002DE3r 3  6C 63 64 70          .byte "lcdput"
002DE7r 3  75 74        
002DE9r 3               
002DE9r 3               nt_lcdprint:
002DE9r 3  08 10                .byte 8, UF
002DEBr 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
002DEFr 3  rr rr        
002DF1r 3  6C 63 64 70          .byte "lcdprint"
002DF5r 3  72 69 6E 74  
002DF9r 3               
002DF9r 3               nt_cls:
002DF9r 3  03 00                .byte 3, 0
002DFBr 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
002DFFr 3  rr rr        
002E01r 3  63 6C 73             .byte "cls"
002E04r 3               
002E04r 3               .ifdef VIA1_BASE
002E04r 3               nt_spi_init:
002E04r 3  08 00                .byte 8, 0
002E06r 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
002E0Ar 3  rr rr        
002E0Cr 3  73 70 69 5F          .byte "spi_init"
002E10r 3  69 6E 69 74  
002E14r 3               
002E14r 3               
002E14r 3               nt_spi_clk_toggle:
002E14r 3  0E 00                .byte 14, 0
002E16r 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
002E1Ar 3  rr rr        
002E1Cr 3  73 70 69 5F          .byte "spi_clk_toggle"
002E20r 3  63 6C 6B 5F  
002E24r 3  74 6F 67 67  
002E2Ar 3               
002E2Ar 3               nt_spi_select:
002E2Ar 3  0A 00                .byte 10, 0
002E2Cr 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
002E30r 3  rr rr        
002E32r 3  73 70 69 5F          .byte "spi_select"
002E36r 3  73 65 6C 65  
002E3Ar 3  63 74        
002E3Cr 3               
002E3Cr 3               nt_spi_transceive:
002E3Cr 3  0E 00                .byte 14, 0
002E3Er 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
002E42r 3  rr rr        
002E44r 3  73 70 69 5F          .byte "spi_transceive"
002E48r 3  74 72 61 6E  
002E4Cr 3  73 63 65 69  
002E52r 3               .endif
002E52r 3               .ifdef SD
002E52r 3               nt_sd_init:
002E52r 3                       .byte 7, 0
002E52r 3                       .ifdef VIA1_BASE
002E52r 3                       .word nt_spi_transceive, xt_sd_init, z_sd_init
002E52r 3                       .else
002E52r 3                       .word nt_cls, xt_sd_init, z_sd_init
002E52r 3                       .endif
002E52r 3                       .byte "sd_init"
002E52r 3               nt_sd_rsptr:
002E52r 3                       .byte 7, 0
002E52r 3                       .word nt_sd_init, xt_sd_rsptr, z_sd_rsptr
002E52r 3                       .byte "sdrsptr"
002E52r 3               nt_sd_readsector:
002E52r 3                       .byte 13, 0
002E52r 3                       .word nt_sd_rsptr, xt_sd_readsector, z_sd_readsector
002E52r 3                       .byte "sd_readsector"
002E52r 3               
002E52r 3               .endif
002E52r 3               
002E52r 3               .ifdef CF_ADDRESS
002E52r 3               nt_cf_rs:
002E52r 3  02 00                .byte 2, 0
002E54r 3                       .ifdef SD
002E54r 3                       .word nt_sd_readsector, xt_cf_readsector, z_cf_readsector
002E54r 3                       .elseif .def(VIA1_BASE)
002E54r 3  rr rr rr rr          .word nt_spi_transceive, xt_cf_readsector, z_cf_readsector
002E58r 3  rr rr        
002E5Ar 3                       .else
002E5Ar 3                       .word nt_cls, xt_cf_readsector, z_cf_readsector
002E5Ar 3                       .endif
002E5Ar 3  72 73                .byte "rs"
002E5Cr 3               
002E5Cr 3               
002E5Cr 3               nt_cf_info:
002E5Cr 3  04 00                .byte 4, 0
002E5Er 3  rr rr rr rr          .word nt_cf_rs, xt_cf_info, z_cf_info
002E62r 3  rr rr        
002E64r 3  69 6E 66 6F          .byte "info"
002E68r 3               nt_cf_ls:
002E68r 3  02 00                .byte 2, 0
002E6Ar 3  rr rr rr rr          .word nt_cf_info, xt_cf_ls, z_cf_ls
002E6Er 3  rr rr        
002E70r 3  6C 73                .byte "ls"
002E72r 3               
002E72r 3               nt_cf_cd:
002E72r 3  02 00                .byte 2, 0
002E74r 3  rr rr rr rr          .word nt_cf_ls, xt_cf_cd, z_cf_cd
002E78r 3  rr rr        
002E7Ar 3  63 64                .byte "cd"
002E7Cr 3               
002E7Cr 3               nt_cf_rsptr:
002E7Cr 3  07 00                .byte 7, 0
002E7Er 3  rr rr rr rr          .word nt_cf_cd, xt_cf_rsptr, z_cf_rsptr
002E82r 3  rr rr        
002E84r 3  63 66 72 73          .byte "cfrsptr"
002E88r 3  70 74 72     
002E8Br 3               
002E8Br 3               nt_cf_cat:
002E8Br 3  03 00                .byte 3, 0
002E8Dr 3  rr rr rr rr          .word nt_cf_rsptr, xt_cf_cat, z_cf_cat
002E91r 3  rr rr        
002E93r 3  63 61 74             .byte "cat"
002E96r 3               .endif
002E96r 3               .ifdef IO_BUFFER
002E96r 3               nt_fat_init:
002E96r 3  03 00                .byte 3, 0
002E98r 3                       .ifdef CF_ADDRESS
002E98r 3  rr rr rr rr          .word nt_cf_cat, xt_fat_init, z_fat_init
002E9Cr 3  rr rr        
002E9Er 3                       .elseif .def(SD)
002E9Er 3                       .word nt_sd_readsector, xt_fat_init, z_fat_init
002E9Er 3                       .elseif .def(VIA1_BASE)
002E9Er 3                       .word nt_spi_transceive, xt_fat_init, z_fat_init
002E9Er 3                       .else
002E9Er 3                       .word nt_cls, xt_fat_init, z_fat_init
002E9Er 3                       .endif
002E9Er 3  66 61 74             .byte "fat"
002EA1r 3               
002EA1r 3               nt_rsptr:
002EA1r 3  05 00                .byte 5, 0
002EA3r 3  rr rr rr rr          .word nt_fat_init, xt_io_readsector, z_io_readsector
002EA7r 3  rr rr        
002EA9r 3  72 73 70 74          .byte "rsptr"
002EADr 3  72           
002EAEr 3               nt_io_readblock:
002EAEr 3  02 00                .byte 2, 0
002EB0r 3  rr rr rr rr          .word nt_rsptr, xt_io_readblock, z_io_readblock
002EB4r 3  rr rr        
002EB6r 3  72 62                .byte "rb"
002EB8r 3               nt_io_writeblock:
002EB8r 3  02 00                .byte 2, 0
002EBAr 3  rr rr rr rr          .word nt_io_readblock, xt_io_writeblock, z_io_writeblock
002EBEr 3  rr rr        
002EC0r 3  77 62                .byte "wb"
002EC2r 3               .endif
002EC2r 3               nt_time:
002EC2r 3  04 00                .byte 4, 0
002EC4r 3               .ifdef IO_BUFFER
002EC4r 3  rr rr rr rr          .word nt_io_writeblock, xt_time, z_time
002EC8r 3  rr rr        
002ECAr 3               .elseif .def(CF_ADDRESS)
002ECAr 3                       .word nt_cf_cat, xt_time, z_time
002ECAr 3               .elseif .def(SD)
002ECAr 3                       .word nt_sd_readsector, xt_time, z_time
002ECAr 3               .elseif .def(VIA1_BASE)
002ECAr 3                       .word nt_spi_transceive, xt_time, z_time
002ECAr 3               .else
002ECAr 3                       .word nt_cls, xt_time, z_time
002ECAr 3               .endif
002ECAr 3  74 69 6D 65          .byte "time"
002ECEr 3               
002ECEr 3               nt_ed:                  ; ed6502
002ECEr 3  02 08                .byte 2, NN
002ED0r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
002ED4r 3  rr rr        
002ED6r 3  65 64                .byte "ed"
002ED8r 3               
002ED8r 3  03 08        nt_see: .byte 3, NN
002EDAr 3  rr rr rr rr          .word nt_ed, xt_see, z_see
002EDEr 3  rr rr        
002EE0r 3  73 65 65             .byte "see"
002EE3r 3               
002EE3r 3               nt_forth:
002EE3r 3  05 00                .byte 5, 0
002EE5r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
002EE9r 3  rr rr        
002EEBr 3  66 6F 72 74          .byte "forth"
002EEFr 3  68           
002EF0r 3               
002EF0r 3               nt_order:
002EF0r 3  05 00                .byte 5, 0
002EF2r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
002EF6r 3  rr rr        
002EF8r 3  6F 72 64 65          .byte "order"
002EFCr 3  72           
002EFDr 3               
002EFDr 3               nt_to_order:
002EFDr 3  06 00                .byte 6, 0
002EFFr 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
002F03r 3  rr rr        
002F05r 3  3E 6F 72 64          .byte ">order"
002F09r 3  65 72        
002F0Br 3               
002F0Br 3               nt_previous:
002F0Br 3  08 00                .byte 8, 0
002F0Dr 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
002F11r 3  rr rr        
002F13r 3  70 72 65 76          .byte "previous"
002F17r 3  69 6F 75 73  
002F1Br 3               
002F1Br 3               nt_also:
002F1Br 3  04 00                .byte 4, 0
002F1Dr 3  rr rr rr rr          .word nt_previous, xt_also, z_also
002F21r 3  rr rr        
002F23r 3  61 6C 73 6F          .byte "also"
002F27r 3               
002F27r 3               nt_only:
002F27r 3  04 00                .byte 4, 0
002F29r 3  rr rr rr rr          .word nt_also, xt_only, z_only
002F2Dr 3  rr rr        
002F2Fr 3  6F 6E 6C 79          .byte "only"
002F33r 3               
002F33r 3               nt_forth_wordlist:      ; shares code with ZERO
002F33r 3  0E 00                .byte 14, 0
002F35r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
002F39r 3  rr rr        
002F3Br 3  66 6F 72 74          .byte "forth-wordlist"
002F3Fr 3  68 2D 77 6F  
002F43r 3  72 64 6C 69  
002F49r 3               
002F49r 3               nt_editor_wordlist:     ; shares code with ONE
002F49r 3  0F 00                .byte 15, 0
002F4Br 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
002F4Fr 3  rr rr        
002F51r 3  65 64 69 74          .byte "editor-wordlist"
002F55r 3  6F 72 2D 77  
002F59r 3  6F 72 64 6C  
002F60r 3               
002F60r 3               nt_assembler_wordlist:  ; shares code with TWO
002F60r 3  12 00                .byte 18, 0
002F62r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
002F66r 3  rr rr        
002F68r 3  61 73 73 65          .byte "assembler-wordlist"
002F6Cr 3  6D 62 6C 65  
002F70r 3  72 2D 77 6F  
002F7Ar 3               
002F7Ar 3               nt_root_wordlist:
002F7Ar 3  0D 00                .byte 13, 0
002F7Cr 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
002F80r 3  rr rr        
002F82r 3  72 6F 6F 74          .byte "root-wordlist"
002F86r 3  2D 77 6F 72  
002F8Ar 3  64 6C 69 73  
002F8Fr 3               
002F8Fr 3               nt_get_order:
002F8Fr 3  09 00                .byte 9, 0
002F91r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
002F95r 3  rr rr        
002F97r 3  67 65 74 2D          .byte "get-order"
002F9Br 3  6F 72 64 65  
002F9Fr 3  72           
002FA0r 3               
002FA0r 3               nt_set_order:
002FA0r 3  09 00                .byte 9, 0
002FA2r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
002FA6r 3  rr rr        
002FA8r 3  73 65 74 2D          .byte "set-order"
002FACr 3  6F 72 64 65  
002FB0r 3  72           
002FB1r 3               
002FB1r 3               nt_get_current:
002FB1r 3  0B 00                .byte 11, 0
002FB3r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
002FB7r 3  rr rr        
002FB9r 3  67 65 74 2D          .byte "get-current"
002FBDr 3  63 75 72 72  
002FC1r 3  65 6E 74     
002FC4r 3               
002FC4r 3               nt_set_current:
002FC4r 3  0B 10                .byte 11, UF
002FC6r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
002FCAr 3  rr rr        
002FCCr 3  73 65 74 2D          .byte "set-current"
002FD0r 3  63 75 72 72  
002FD4r 3  65 6E 74     
002FD7r 3               
002FD7r 3               nt_search_wordlist:
002FD7r 3  0F 10                .byte 15, UF
002FD9r 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
002FDDr 3  rr rr        
002FDFr 3  73 65 61 72          .byte "search-wordlist"
002FE3r 3  63 68 2D 77  
002FE7r 3  6F 72 64 6C  
002FEEr 3               
002FEEr 3               nt_wordlist:
002FEEr 3  08 00                .byte 8, 0
002FF0r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
002FF4r 3  rr rr        
002FF6r 3  77 6F 72 64          .byte "wordlist"
002FFAr 3  6C 69 73 74  
002FFEr 3               
002FFEr 3               nt_definitions:
002FFEr 3  0B 00                .byte 11, 0
003000r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
003004r 3  rr rr        
003006r 3  64 65 66 69          .byte "definitions"
00300Ar 3  6E 69 74 69  
00300Er 3  6F 6E 73     
003011r 3               
003011r 3               nt_block_ramdrive_init:
003011r 3  13 10                .byte 19, UF
003013r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
003017r 3  rr rr        
003019r 3  62 6C 6F 63          .byte "block-ramdrive-init"
00301Dr 3  6B 2D 72 61  
003021r 3  6D 64 72 69  
00302Cr 3               
00302Cr 3               nt_list:
00302Cr 3  04 10                .byte 4, UF
00302Er 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
003032r 3  rr rr        
003034r 3  6C 69 73 74          .byte "list"
003038r 3               
003038r 3               nt_thru:
003038r 3  04 10                .byte 4, UF
00303Ar 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
00303Er 3  rr rr        
003040r 3  74 68 72 75          .byte "thru"
003044r 3               
003044r 3               nt_load:
003044r 3  04 10                .byte 4, UF
003046r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
00304Ar 3  rr rr        
00304Cr 3  6C 6F 61 64          .byte "load"
003050r 3               
003050r 3               nt_flush:
003050r 3  05 00                .byte 5, 0
003052r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
003056r 3  rr rr        
003058r 3  66 6C 75 73          .byte "flush"
00305Cr 3  68           
00305Dr 3               
00305Dr 3               nt_empty_buffers:
00305Dr 3  0D 00                .byte 13, 0
00305Fr 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
003063r 3  rr rr        
003065r 3  65 6D 70 74          .byte "empty-buffers"
003069r 3  79 2D 62 75  
00306Dr 3  66 66 65 72  
003072r 3               
003072r 3               nt_buffer:
003072r 3  06 00                .byte 6, 0
003074r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
003078r 3  rr rr        
00307Ar 3  62 75 66 66          .byte "buffer"
00307Er 3  65 72        
003080r 3               
003080r 3               nt_update:
003080r 3  06 00                .byte 6, 0
003082r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
003086r 3  rr rr        
003088r 3  75 70 64 61          .byte "update"
00308Cr 3  74 65        
00308Er 3               
00308Er 3               nt_block:
00308Er 3  05 00                .byte 5, 0
003090r 3  rr rr rr rr          .word nt_update, xt_block, z_block
003094r 3  rr rr        
003096r 3  62 6C 6F 63          .byte "block"
00309Ar 3  6B           
00309Br 3               
00309Br 3               nt_save_buffers:
00309Br 3  0C 00                .byte 12, 0
00309Dr 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
0030A1r 3  rr rr        
0030A3r 3  73 61 76 65          .byte "save-buffers"
0030A7r 3  2D 62 75 66  
0030ABr 3  66 65 72 73  
0030AFr 3               
0030AFr 3               nt_block_read_vector:
0030AFr 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
0030B1r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
0030B5r 3  rr rr        
0030B7r 3  62 6C 6F 63          .byte "block-read-vector"
0030BBr 3  6B 2D 72 65  
0030BFr 3  61 64 2D 76  
0030C8r 3               
0030C8r 3               nt_block_read:
0030C8r 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
0030CAr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
0030CEr 3  rr rr        
0030D0r 3  62 6C 6F 63          .byte "block-read"
0030D4r 3  6B 2D 72 65  
0030D8r 3  61 64        
0030DAr 3               
0030DAr 3               nt_block_write_vector:
0030DAr 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
0030DCr 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
0030E0r 3  rr rr        
0030E2r 3  62 6C 6F 63          .byte "block-write-vector"
0030E6r 3  6B 2D 77 72  
0030EAr 3  69 74 65 2D  
0030F4r 3               
0030F4r 3               nt_block_write:
0030F4r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
0030F6r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
0030FAr 3  rr rr        
0030FCr 3  62 6C 6F 63          .byte "block-write"
003100r 3  6B 2D 77 72  
003104r 3  69 74 65     
003107r 3               
003107r 3               nt_blk:
003107r 3  03 00                .byte 3, 0
003109r 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
00310Dr 3  rr rr        
00310Fr 3  62 6C 6B             .byte "blk"
003112r 3               
003112r 3               nt_scr:
003112r 3  03 00                .byte 3, 0
003114r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
003118r 3  rr rr        
00311Ar 3  73 63 72             .byte "scr"
00311Dr 3               
00311Dr 3               nt_blkbuffer:
00311Dr 3  09 00                .byte 9, 0
00311Fr 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
003123r 3  rr rr        
003125r 3  62 6C 6B 62          .byte "blkbuffer"
003129r 3  75 66 66 65  
00312Dr 3  72           
00312Er 3               
00312Er 3               nt_buffblocknum:
00312Er 3  0C 00                .byte 12, 0
003130r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
003134r 3  rr rr        
003136r 3  62 75 66 66          .byte "buffblocknum"
00313Ar 3  62 6C 6F 63  
00313Er 3  6B 6E 75 6D  
003142r 3               
003142r 3               nt_buffstatus:
003142r 3  0A 00                .byte 10, 0
003144r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
003148r 3  rr rr        
00314Ar 3  62 75 66 66          .byte "buffstatus"
00314Er 3  73 74 61 74  
003152r 3  75 73        
003154r 3               
003154r 3               nt_buffer_colon:
003154r 3  07 00                .byte 7, 0
003156r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
00315Ar 3  rr rr        
00315Cr 3  62 75 66 66          .byte "buffer:"
003160r 3  65 72 3A     
003163r 3               
003163r 3               nt_useraddr:
003163r 3  08 00                .byte 8, 0
003165r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
003169r 3  rr rr        
00316Br 3  75 73 65 72          .byte "useraddr"
00316Fr 3  61 64 64 72  
003173r 3               
003173r 3               nt_action_of:
003173r 3  09 04                .byte 9, IM
003175r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
003179r 3  rr rr        
00317Br 3  61 63 74 69          .byte "action-of"
00317Fr 3  6F 6E 2D 6F  
003183r 3  66           
003184r 3               
003184r 3               nt_is:
003184r 3  02 04                .byte 2, IM
003186r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
00318Ar 3  rr rr        
00318Cr 3  69 73                .byte "is"
00318Er 3               
00318Er 3               nt_defer_store:
00318Er 3  06 00                .byte 6, 0
003190r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
003194r 3  rr rr        
003196r 3  64 65 66 65          .byte "defer!"
00319Ar 3  72 21        
00319Cr 3               
00319Cr 3               nt_defer_fetch:
00319Cr 3  06 00                .byte 6, 0
00319Er 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
0031A2r 3  rr rr        
0031A4r 3  64 65 66 65          .byte "defer@"
0031A8r 3  72 40        
0031AAr 3               
0031AAr 3               nt_endcase:
0031AAr 3  07 0D                .byte 7, IM+CO+NN
0031ACr 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
0031B0r 3  rr rr        
0031B2r 3  65 6E 64 63          .byte "endcase"
0031B6r 3  61 73 65     
0031B9r 3               
0031B9r 3               nt_endof:
0031B9r 3  05 0D                .byte 5, IM+CO+NN
0031BBr 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
0031BFr 3  rr rr        
0031C1r 3  65 6E 64 6F          .byte "endof"
0031C5r 3  66           
0031C6r 3               
0031C6r 3               nt_of:
0031C6r 3  02 0D                .byte 2, IM+CO+NN
0031C8r 3  rr rr rr rr          .word nt_endof, xt_of, z_of
0031CCr 3  rr rr        
0031CEr 3  6F 66                .byte "of"
0031D0r 3               
0031D0r 3               nt_case:
0031D0r 3  04 0D                .byte 4, IM+CO+NN
0031D2r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
0031D6r 3  rr rr        
0031D8r 3  63 61 73 65          .byte "case"
0031DCr 3               
0031DCr 3               nt_while:
0031DCr 3  05 0D                .byte 5, IM+CO+NN
0031DEr 3  rr rr rr rr          .word nt_case, xt_while, z_while
0031E2r 3  rr rr        
0031E4r 3  77 68 69 6C          .byte "while"
0031E8r 3  65           
0031E9r 3               
0031E9r 3               nt_until:
0031E9r 3  05 0D                .byte 5, IM+CO+NN
0031EBr 3  rr rr rr rr          .word nt_while, xt_until, z_until
0031EFr 3  rr rr        
0031F1r 3  75 6E 74 69          .byte "until"
0031F5r 3  6C           
0031F6r 3               
0031F6r 3               nt_repeat:
0031F6r 3  06 0D                .byte 6, IM+CO+NN
0031F8r 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
0031FCr 3  rr rr        
0031FEr 3  72 65 70 65          .byte "repeat"
003202r 3  61 74        
003204r 3               
003204r 3               nt_else:
003204r 3  04 0D                .byte 4, IM+CO+NN
003206r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
00320Ar 3  rr rr        
00320Cr 3  65 6C 73 65          .byte "else"
003210r 3               
003210r 3               nt_then:
003210r 3  04 0D                .byte 4, IM+CO+NN
003212r 3  rr rr rr rr          .word nt_else, xt_then, z_then
003216r 3  rr rr        
003218r 3  74 68 65 6E          .byte "then"
00321Cr 3               
00321Cr 3               nt_if:
00321Cr 3  02 0D                .byte 2, IM+CO+NN
00321Er 3  rr rr rr rr          .word nt_then, xt_if, z_if
003222r 3  rr rr        
003224r 3  69 66                .byte "if"
003226r 3               
003226r 3               nt_dot_paren:
003226r 3  02 04                .byte 2, IM
003228r 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
00322Cr 3  rr rr        
00322Er 3  2E 28                .byte ".("
003230r 3               
003230r 3               nt_paren:
003230r 3  01 04                .byte 1, IM
003232r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
003236r 3  rr rr        
003238r 3  28                   .byte "("
003239r 3               
003239r 3               nt_word:
003239r 3  04 10                .byte 4, UF
00323Br 3  rr rr rr rr          .word nt_paren, xt_word, z_word
00323Fr 3  rr rr        
003241r 3  77 6F 72 64          .byte "word"
003245r 3               
003245r 3               nt_find:
003245r 3  04 10                .byte 4, UF
003247r 3  rr rr rr rr          .word nt_word, xt_find, z_find
00324Br 3  rr rr        
00324Dr 3  66 69 6E 64          .byte "find"
003251r 3               
003251r 3               nt_environment_q:
003251r 3  0C 10                .byte 12, UF
003253r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
003257r 3  rr rr        
003259r 3  65 6E 76 69          .byte "environment?"
00325Dr 3  72 6F 6E 6D  
003261r 3  65 6E 74 3F  
003265r 3               
003265r 3               nt_search:
003265r 3  06 18                .byte 6, UF+NN
003267r 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
00326Br 3  rr rr        
00326Dr 3  73 65 61 72          .byte "search"
003271r 3  63 68        
003273r 3               
003273r 3               nt_compare:
003273r 3  07 10                .byte 7, UF
003275r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
003279r 3  rr rr        
00327Br 3  63 6F 6D 70          .byte "compare"
00327Fr 3  61 72 65     
003282r 3               
003282r 3               nt_disasm:
003282r 3  06 10                .byte 6, UF
003284r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
003288r 3  rr rr        
00328Ar 3  64 69 73 61          .byte "disasm"
00328Er 3  73 6D        
003290r 3               
003290r 3               nt_dot_s:
003290r 3  02 00                .byte 2, 0
003292r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
003296r 3  rr rr        
003298r 3  2E 73                .byte ".s"
00329Ar 3               
00329Ar 3               nt_dump:
00329Ar 3  04 10                .byte 4, UF
00329Cr 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
0032A0r 3  rr rr        
0032A2r 3  64 75 6D 70          .byte "dump"
0032A6r 3               
0032A6r 3               nt_bell:
0032A6r 3  04 00                .byte 4, 0
0032A8r 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
0032ACr 3  rr rr        
0032AEr 3  62 65 6C 6C          .byte "bell"
0032B2r 3               
0032B2r 3               nt_align:
0032B2r 3  05 00                .byte 5, 0
0032B4r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
0032B8r 3  rr rr        
0032BAr 3  61 6C 69 67          .byte "align"
0032BEr 3  6E           
0032BFr 3               
0032BFr 3               nt_aligned:             ; same code as ALIGN
0032BFr 3  07 00                .byte 7, 0
0032C1r 3  rr rr rr rr          .word nt_align, xt_align, z_align
0032C5r 3  rr rr        
0032C7r 3  61 6C 69 67          .byte "aligned"
0032CBr 3  6E 65 64     
0032CEr 3               
0032CEr 3               nt_wordsize:
0032CEr 3  08 10                .byte 8, UF
0032D0r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
0032D4r 3  rr rr        
0032D6r 3  77 6F 72 64          .byte "wordsize"
0032DAr 3  73 69 7A 65  
0032DEr 3               
0032DEr 3               nt_words:
0032DEr 3  05 00                .byte 5, 0
0032E0r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
0032E4r 3  rr rr        
0032E6r 3  77 6F 72 64          .byte "words"
0032EAr 3  73           
0032EBr 3               
0032EBr 3               nt_marker:
0032EBr 3  06 04                .byte 6, IM
0032EDr 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
0032F1r 3  rr rr        
0032F3r 3  6D 61 72 6B          .byte "marker"
0032F7r 3  65 72        
0032F9r 3               
0032F9r 3               nt_at_xy:
0032F9r 3  05 10                .byte 5, UF
0032FBr 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
0032FFr 3  rr rr        
003301r 3  61 74 2D 78          .byte "at-xy"
003305r 3  79           
003306r 3               
003306r 3               nt_page:
003306r 3  04 00                .byte 4, 0
003308r 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
00330Cr 3  rr rr        
00330Er 3  70 61 67 65          .byte "page"
003312r 3               
003312r 3               nt_cr:
003312r 3  02 00                .byte 2, 0
003314r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
003318r 3  rr rr        
00331Ar 3  63 72                .byte "cr"
00331Cr 3               
00331Cr 3               nt_input:
00331Cr 3  05 00                .byte 5, 0
00331Er 3  rr rr rr rr          .word nt_cr, xt_input, z_input
003322r 3  rr rr        
003324r 3  69 6E 70 75          .byte "input"
003328r 3  74           
003329r 3               
003329r 3               nt_output:
003329r 3  06 00                .byte 6, 0
00332Br 3  rr rr rr rr          .word nt_input, xt_output, z_output
00332Fr 3  rr rr        
003331r 3  6F 75 74 70          .byte "output"
003335r 3  75 74        
003337r 3               
003337r 3               nt_sign:
003337r 3  04 10                .byte 4, UF
003339r 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
00333Dr 3  rr rr        
00333Fr 3  73 69 67 6E          .byte "sign"
003343r 3               
003343r 3               nt_hold:
003343r 3  04 10                .byte 4, UF
003345r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
003349r 3  rr rr        
00334Br 3  68 6F 6C 64          .byte "hold"
00334Fr 3               
00334Fr 3               nt_number_sign_greater:
00334Fr 3  02 10                .byte 2, UF
003351r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
003355r 3  rr rr        
003357r 3  23 3E                .byte "#>"
003359r 3               
003359r 3               nt_number_sign_s:
003359r 3  02 10                .byte 2, UF
00335Br 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
00335Fr 3  rr rr        
003361r 3  23 73                .byte "#s"
003363r 3               
003363r 3               nt_number_sign:
003363r 3  01 10                .byte 1, UF
003365r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
003369r 3  rr rr        
00336Br 3  23                   .byte "#"
00336Cr 3               
00336Cr 3               nt_less_number_sign:
00336Cr 3  02 00                .byte 2, 0
00336Er 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
003372r 3  rr rr        
003374r 3  3C 23                .byte "<#"
003376r 3               
003376r 3               nt_to_in:
003376r 3  03 00                .byte 3, 0
003378r 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
00337Cr 3  rr rr        
00337Er 3  3E 69 6E             .byte ">in"
003381r 3               
003381r 3               nt_within:
003381r 3  06 10                .byte 6, UF
003383r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
003387r 3  rr rr        
003389r 3  77 69 74 68          .byte "within"
00338Dr 3  69 6E        
00338Fr 3               
00338Fr 3               nt_hexstore:
00338Fr 3  08 10                .byte 8, UF
003391r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
003395r 3  rr rr        
003397r 3  68 65 78 73          .byte "hexstore"
00339Br 3  74 6F 72 65  
00339Fr 3               
00339Fr 3               nt_cleave:
00339Fr 3  06 10                .byte 6, UF
0033A1r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
0033A5r 3  rr rr        
0033A7r 3  63 6C 65 61          .byte "cleave"
0033ABr 3  76 65        
0033ADr 3               
0033ADr 3               nt_pad:
0033ADr 3  03 00                .byte 3, 0
0033AFr 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
0033B3r 3  rr rr        
0033B5r 3  70 61 64             .byte "pad"
0033B8r 3               
0033B8r 3               nt_cmove:
0033B8r 3  05 10                .byte 5, UF
0033BAr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
0033BEr 3  rr rr        
0033C0r 3  63 6D 6F 76          .byte "cmove"
0033C4r 3  65           
0033C5r 3               
0033C5r 3               nt_cmove_up:
0033C5r 3  06 10                .byte 6, UF
0033C7r 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
0033CBr 3  rr rr        
0033CDr 3  63 6D 6F 76          .byte "cmove>"
0033D1r 3  65 3E        
0033D3r 3               
0033D3r 3               nt_move:
0033D3r 3  04 18                .byte 4, NN+UF
0033D5r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
0033D9r 3  rr rr        
0033DBr 3  6D 6F 76 65          .byte "move"
0033DFr 3               
0033DFr 3               nt_backslash:
0033DFr 3  01 04                .byte 1, IM
0033E1r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
0033E5r 3  rr rr        
0033E7r 3  5C                   .byte $5c
0033E8r 3               
0033E8r 3               nt_star_slash:
0033E8r 3  02 10                .byte 2, UF
0033EAr 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
0033EEr 3  rr rr        
0033F0r 3  2A 2F                .byte "*/"
0033F2r 3               
0033F2r 3               nt_star_slash_mod:
0033F2r 3  05 10                .byte 5, UF
0033F4r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
0033F8r 3  rr rr        
0033FAr 3  2A 2F 6D 6F          .byte "*/mod"
0033FEr 3  64           
0033FFr 3               
0033FFr 3               nt_mod:
0033FFr 3  03 10                .byte 3, UF
003401r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
003405r 3  rr rr        
003407r 3  6D 6F 64             .byte "mod"
00340Ar 3               
00340Ar 3               nt_slash_mod:
00340Ar 3  04 10                .byte 4, UF
00340Cr 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
003410r 3  rr rr        
003412r 3  2F 6D 6F 64          .byte "/mod"
003416r 3               
003416r 3               nt_slash:
003416r 3  01 10                .byte 1, UF
003418r 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
00341Cr 3  rr rr        
00341Er 3  2F                   .byte "/"
00341Fr 3               
00341Fr 3               nt_fm_slash_mod:
00341Fr 3  06 10                .byte 6, UF
003421r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
003425r 3  rr rr        
003427r 3  66 6D 2F 6D          .byte "fm/mod"
00342Br 3  6F 64        
00342Dr 3               
00342Dr 3               nt_sm_slash_rem:
00342Dr 3  06 10                .byte 6, UF
00342Fr 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
003433r 3  rr rr        
003435r 3  73 6D 2F 72          .byte "sm/rem"
003439r 3  65 6D        
00343Br 3               
00343Br 3               nt_um_slash_mod:
00343Br 3  06 10                .byte 6, UF
00343Dr 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
003441r 3  rr rr        
003443r 3  75 6D 2F 6D          .byte "um/mod"
003447r 3  6F 64        
003449r 3               
003449r 3               nt_star:
003449r 3  01 10                .byte 1, UF
00344Br 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
00344Fr 3  rr rr        
003451r 3  2A                   .byte "*"
003452r 3               
003452r 3               nt_um_star:
003452r 3  03 10                .byte 3, UF
003454r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
003458r 3  rr rr        
00345Ar 3  75 6D 2A             .byte "um*"
00345Dr 3               
00345Dr 3               nt_m_star:
00345Dr 3  02 10                .byte 2, UF
00345Fr 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
003463r 3  rr rr        
003465r 3  6D 2A                .byte "m*"
003467r 3               
003467r 3               nt_count:
003467r 3  05 10                .byte 5, UF
003469r 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
00346Dr 3  rr rr        
00346Fr 3  63 6F 75 6E          .byte "count"
003473r 3  74           
003474r 3               
003474r 3               nt_decimal:
003474r 3  07 00                .byte 7, 0
003476r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
00347Ar 3  rr rr        
00347Cr 3  64 65 63 69          .byte "decimal"
003480r 3  6D 61 6C     
003483r 3               
003483r 3               nt_hex:
003483r 3  03 00                .byte 3, 0
003485r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
003489r 3  rr rr        
00348Br 3  68 65 78             .byte "hex"
00348Er 3               
00348Er 3               nt_to_number:
00348Er 3  07 10                .byte 7, UF
003490r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
003494r 3  rr rr        
003496r 3  3E 6E 75 6D          .byte ">number"
00349Ar 3  62 65 72     
00349Dr 3               
00349Dr 3               nt_number:
00349Dr 3  06 10                .byte 6, UF
00349Fr 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
0034A3r 3  rr rr        
0034A5r 3  6E 75 6D 62          .byte "number"
0034A9r 3  65 72        
0034ABr 3               
0034ABr 3               nt_digit_question:
0034ABr 3  06 10                .byte 6, UF
0034ADr 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
0034B1r 3  rr rr        
0034B3r 3  64 69 67 69          .byte "digit?"
0034B7r 3  74 3F        
0034B9r 3               
0034B9r 3               nt_base:
0034B9r 3  04 00                .byte 4, 0
0034BBr 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
0034BFr 3  rr rr        
0034C1r 3  62 61 73 65          .byte "base"
0034C5r 3               
0034C5r 3               nt_evaluate:
0034C5r 3  08 10                .byte 8, UF
0034C7r 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
0034CBr 3  rr rr        
0034CDr 3  65 76 61 6C          .byte "evaluate"
0034D1r 3  75 61 74 65  
0034D5r 3               
0034D5r 3               nt_state:
0034D5r 3  05 00                .byte 5, 0
0034D7r 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
0034DBr 3  rr rr        
0034DDr 3  73 74 61 74          .byte "state"
0034E1r 3  65           
0034E2r 3               
0034E2r 3               nt_again:
0034E2r 3  05 17                .byte 5, AN+CO+IM+UF
0034E4r 3  rr rr rr rr          .word nt_state, xt_again, z_again
0034E8r 3  rr rr        
0034EAr 3  61 67 61 69          .byte "again"
0034EEr 3  6E           
0034EFr 3               
0034EFr 3               nt_begin:
0034EFr 3  05 07                .byte 5, AN+CO+IM
0034F1r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
0034F5r 3  rr rr        
0034F7r 3  62 65 67 69          .byte "begin"
0034FBr 3  6E           
0034FCr 3               
0034FCr 3               nt_quit:
0034FCr 3  04 00                .byte 4, 0
0034FEr 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
003502r 3  rr rr        
003504r 3  71 75 69 74          .byte "quit"
003508r 3               
003508r 3               nt_recurse:
003508r 3  07 0D                .byte 7, CO+IM+NN
00350Ar 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
00350Er 3  rr rr        
003510r 3  72 65 63 75          .byte "recurse"
003514r 3  72 73 65     
003517r 3               
003517r 3               nt_leave:
003517r 3  05 03                .byte 5, AN+CO
003519r 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
00351Dr 3  rr rr        
00351Fr 3  6C 65 61 76          .byte "leave"
003523r 3  65           
003524r 3               
003524r 3               nt_unloop:
003524r 3  06 03                .byte 6, AN+CO
003526r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
00352Ar 3  rr rr        
00352Cr 3  75 6E 6C 6F          .byte "unloop"
003530r 3  6F 70        
003532r 3               
003532r 3               nt_exit:
003532r 3  04 03                .byte 4, AN+CO
003534r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
003538r 3  rr rr        
00353Ar 3  65 78 69 74          .byte "exit"
00353Er 3               
00353Er 3               nt_plus_loop:
00353Er 3  05 05                .byte 5, CO+IM
003540r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
003544r 3  rr rr        
003546r 3  2B 6C 6F 6F          .byte "+loop"
00354Ar 3  70           
00354Br 3               
00354Br 3               nt_loop:
00354Br 3  04 05                .byte 4, CO+IM
00354Dr 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
003551r 3  rr rr        
003553r 3  6C 6F 6F 70          .byte "loop"
003557r 3               
003557r 3               nt_j:
003557r 3  01 03                .byte 1, AN+CO
003559r 3  rr rr rr rr          .word nt_loop, xt_j, z_j
00355Dr 3  rr rr        
00355Fr 3  6A                   .byte "j"
003560r 3               
003560r 3               nt_i:
003560r 3  01 03                .byte 1, AN+CO
003562r 3  rr rr rr rr          .word nt_j, xt_i, z_i
003566r 3  rr rr        
003568r 3  69                   .byte "i"
003569r 3               
003569r 3               nt_question_do:
003569r 3  03 0D                .byte 3, CO+IM+NN
00356Br 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
00356Fr 3  rr rr        
003571r 3  3F 64 6F             .byte "?do"
003574r 3               
003574r 3               nt_do:
003574r 3  02 0D                .byte 2, CO+IM+NN
003576r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
00357Ar 3  rr rr        
00357Cr 3  64 6F                .byte "do"
00357Er 3               
00357Er 3               nt_abort_quote:
00357Er 3  06 0D                .byte 6, CO+IM+NN
003580r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
003584r 3  rr rr        
003586r 3  61 62 6F 72          .byte "abort", $22
00358Ar 3  74 22        
00358Cr 3               
00358Cr 3               nt_abort:
00358Cr 3  05 00                .byte 5, 0
00358Er 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
003592r 3  rr rr        
003594r 3  61 62 6F 72          .byte "abort"
003598r 3  74           
003599r 3               
003599r 3               nt_strip_underflow:
003599r 3  0F 00                .byte 15, 0
00359Br 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
00359Fr 3  rr rr        
0035A1r 3  73 74 72 69          .byte "strip-underflow"
0035A5r 3  70 2D 75 6E  
0035A9r 3  64 65 72 66  
0035B0r 3               
0035B0r 3               nt_nc_limit:
0035B0r 3  08 00                .byte 8, 0
0035B2r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
0035B6r 3  rr rr        
0035B8r 3  6E 63 2D 6C          .byte "nc-limit"
0035BCr 3  69 6D 69 74  
0035C0r 3               
0035C0r 3               nt_allow_native:
0035C0r 3  0C 00                .byte 12, 0
0035C2r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
0035C6r 3  rr rr        
0035C8r 3  61 6C 6C 6F          .byte "allow-native"
0035CCr 3  77 2D 6E 61  
0035D0r 3  74 69 76 65  
0035D4r 3               
0035D4r 3               nt_always_native:
0035D4r 3  0D 00                .byte 13, 0
0035D6r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
0035DAr 3  rr rr        
0035DCr 3  61 6C 77 61          .byte "always-native"
0035E0r 3  79 73 2D 6E  
0035E4r 3  61 74 69 76  
0035E9r 3               
0035E9r 3               nt_never_native:
0035E9r 3  0C 00                .byte 12, 0
0035EBr 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
0035EFr 3  rr rr        
0035F1r 3  6E 65 76 65          .byte "never-native"
0035F5r 3  72 2D 6E 61  
0035F9r 3  74 69 76 65  
0035FDr 3               
0035FDr 3               nt_compile_only:
0035FDr 3  0C 00                .byte 12, 0
0035FFr 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003603r 3  rr rr        
003605r 3  63 6F 6D 70          .byte "compile-only"
003609r 3  69 6C 65 2D  
00360Dr 3  6F 6E 6C 79  
003611r 3               
003611r 3               nt_immediate:
003611r 3  09 00                .byte 9, 0
003613r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
003617r 3  rr rr        
003619r 3  69 6D 6D 65          .byte "immediate"
00361Dr 3  64 69 61 74  
003621r 3  65           
003622r 3               
003622r 3               nt_postpone:
003622r 3  08 05                .byte 8, IM+CO
003624r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
003628r 3  rr rr        
00362Ar 3  70 6F 73 74          .byte "postpone"
00362Er 3  70 6F 6E 65  
003632r 3               
003632r 3               nt_s_backslash_quote:
003632r 3  03 04                .byte 3, IM
003634r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
003638r 3  rr rr        
00363Ar 3  73 5C 22             .byte "s", $5C, $22
00363Dr 3               
00363Dr 3               nt_s_quote:
00363Dr 3  02 0C                .byte 2, IM+NN
00363Fr 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
003643r 3  rr rr        
003645r 3  73 22                .byte "s", $22
003647r 3               
003647r 3               nt_dot_quote:
003647r 3  02 05                .byte 2, CO+IM
003649r 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
00364Dr 3  rr rr        
00364Fr 3  2E 22                .byte ".", $22
003651r 3               
003651r 3               nt_sliteral:
003651r 3  08 15                .byte 8, CO+IM+UF
003653r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
003657r 3  rr rr        
003659r 3  73 6C 69 74          .byte "sliteral"
00365Dr 3  65 72 61 6C  
003661r 3               
003661r 3               nt_literal:
003661r 3  07 15                .byte 7, IM+CO+UF
003663r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
003667r 3  rr rr        
003669r 3  6C 69 74 65          .byte "literal"
00366Dr 3  72 61 6C     
003670r 3               
003670r 3               nt_right_bracket:
003670r 3  01 04                .byte 1, IM
003672r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
003676r 3  rr rr        
003678r 3  5D                   .byte "]"
003679r 3               
003679r 3               nt_left_bracket:
003679r 3  01 05                .byte 1, IM+CO
00367Br 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
00367Fr 3  rr rr        
003681r 3  5B                   .byte "["
003682r 3               
003682r 3               nt_compile_comma:
003682r 3  08 18                .byte 8, UF+NN
003684r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
003688r 3  rr rr        
00368Ar 3  63 6F 6D 70          .byte "compile,"
00368Er 3  69 6C 65 2C  
003692r 3               
003692r 3               nt_colon_noname:
003692r 3  07 00                .byte 7, 0
003694r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
003698r 3  rr rr        
00369Ar 3  3A 6E 6F 6E          .byte ":noname"
00369Er 3  61 6D 65     
0036A1r 3               
0036A1r 3               nt_semicolon:
0036A1r 3  01 05                .byte 1, CO+IM
0036A3r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
0036A7r 3  rr rr        
0036A9r 3  3B                   .byte ";"
0036AAr 3               
0036AAr 3               nt_colon:
0036AAr 3  01 00                .byte 1, 0
0036ACr 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
0036B0r 3  rr rr        
0036B2r 3  3A                   .byte ":"
0036B3r 3               
0036B3r 3               nt_source_id:
0036B3r 3  09 00                .byte 9, 0
0036B5r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
0036B9r 3  rr rr        
0036BBr 3  73 6F 75 72          .byte "source-id"
0036BFr 3  63 65 2D 69  
0036C3r 3  64           
0036C4r 3               
0036C4r 3               nt_source:
0036C4r 3  06 00                .byte 6, 0
0036C6r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
0036CAr 3  rr rr        
0036CCr 3  73 6F 75 72          .byte "source"
0036D0r 3  63 65        
0036D2r 3               
0036D2r 3               nt_execute_parsing:
0036D2r 3  0F 10                .byte 15, UF
0036D4r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
0036D8r 3  rr rr        
0036DAr 3  65 78 65 63          .byte "execute-parsing"
0036DEr 3  75 74 65 2D  
0036E2r 3  70 61 72 73  
0036E9r 3               
0036E9r 3               nt_parse:
0036E9r 3  05 10                .byte 5, UF
0036EBr 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
0036EFr 3  rr rr        
0036F1r 3  70 61 72 73          .byte "parse"
0036F5r 3  65           
0036F6r 3               
0036F6r 3               nt_parse_name:
0036F6r 3  0A 08                .byte 10, NN
0036F8r 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
0036FCr 3  rr rr        
0036FEr 3  70 61 72 73          .byte "parse-name"
003702r 3  65 2D 6E 61  
003706r 3  6D 65        
003708r 3               
003708r 3               nt_latestnt:
003708r 3  08 00                .byte 8, 0
00370Ar 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
00370Er 3  rr rr        
003710r 3  6C 61 74 65          .byte "latestnt"
003714r 3  73 74 6E 74  
003718r 3               
003718r 3               nt_latestxt:
003718r 3  08 00                .byte 8, 0
00371Ar 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
00371Er 3  rr rr        
003720r 3  6C 61 74 65          .byte "latestxt"
003724r 3  73 74 78 74  
003728r 3               
003728r 3               nt_defer:
003728r 3  05 00                .byte 5, 0
00372Ar 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
00372Er 3  rr rr        
003730r 3  64 65 66 65          .byte "defer"
003734r 3  72           
003735r 3               
003735r 3               nt_to_body:
003735r 3  05 10                .byte 5, UF
003737r 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
00373Br 3  rr rr        
00373Dr 3  3E 62 6F 64          .byte ">body"
003741r 3  79           
003742r 3               
003742r 3               nt_name_to_string:
003742r 3  0B 10                .byte 11, UF
003744r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
003748r 3  rr rr        
00374Ar 3  6E 61 6D 65          .byte "name>string"
00374Er 3  3E 73 74 72  
003752r 3  69 6E 67     
003755r 3               
003755r 3               nt_int_to_name:
003755r 3  08 10                .byte 8, UF
003757r 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
00375Br 3  rr rr        
00375Dr 3  69 6E 74 3E          .byte "int>name"
003761r 3  6E 61 6D 65  
003765r 3               
003765r 3               nt_name_to_int:
003765r 3  08 10                .byte 8, UF
003767r 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
00376Br 3  rr rr        
00376Dr 3  6E 61 6D 65          .byte "name>int"
003771r 3  3E 69 6E 74  
003775r 3               
003775r 3               nt_bracket_tick:
003775r 3  03 05                .byte 3, CO+IM
003777r 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
00377Br 3  rr rr        
00377Dr 3  5B 27 5D             .byte "[']"
003780r 3               
003780r 3               nt_tick:
003780r 3  01 00                .byte 1, 0
003782r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
003786r 3  rr rr        
003788r 3  27                   .byte "'"
003789r 3               
003789r 3               nt_find_name:
003789r 3  09 10                .byte 9, UF
00378Br 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
00378Fr 3  rr rr        
003791r 3  66 69 6E 64          .byte "find-name"
003795r 3  2D 6E 61 6D  
003799r 3  65           
00379Ar 3               
00379Ar 3               nt_fill:
00379Ar 3  04 10                .byte 4, UF
00379Cr 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
0037A0r 3  rr rr        
0037A2r 3  66 69 6C 6C          .byte "fill"
0037A6r 3               
0037A6r 3               nt_blank:
0037A6r 3  05 00                .byte 5, 0     ; underflow checked by FILL
0037A8r 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
0037ACr 3  rr rr        
0037AEr 3  62 6C 61 6E          .byte "blank"
0037B2r 3  6B           
0037B3r 3               
0037B3r 3               nt_erase:
0037B3r 3  05 00                .byte 5, 0      ; underflow checked by FILL
0037B5r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
0037B9r 3  rr rr        
0037BBr 3  65 72 61 73          .byte "erase"
0037BFr 3  65           
0037C0r 3               
0037C0r 3               nt_d_plus:
0037C0r 3  02 10                .byte 2, UF
0037C2r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
0037C6r 3  rr rr        
0037C8r 3  64 2B                .byte "d+"
0037CAr 3               
0037CAr 3               nt_d_minus:
0037CAr 3  02 10                .byte 2, UF
0037CCr 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
0037D0r 3  rr rr        
0037D2r 3  64 2D                .byte "d-"
0037D4r 3               
0037D4r 3               nt_d_to_s:
0037D4r 3  03 10                .byte 3, UF
0037D6r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
0037DAr 3  rr rr        
0037DCr 3  64 3E 73             .byte "d>s"
0037DFr 3               
0037DFr 3               nt_s_to_d:
0037DFr 3  03 10                .byte 3, UF
0037E1r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
0037E5r 3  rr rr        
0037E7r 3  73 3E 64             .byte "s>d"
0037EAr 3               
0037EAr 3               nt_to:
0037EAr 3  02 0C                .byte 2, NN+IM
0037ECr 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
0037F0r 3  rr rr        
0037F2r 3  74 6F                .byte "to"
0037F4r 3               
0037F4r 3               nt_value:               ; same code as CONSTANT
0037F4r 3  05 10                .byte 5, UF
0037F6r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
0037FAr 3  rr rr        
0037FCr 3  76 61 6C 75          .byte "value"
003800r 3  65           
003801r 3               
003801r 3               nt_constant:
003801r 3  08 10                .byte 8, UF
003803r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
003807r 3  rr rr        
003809r 3  63 6F 6E 73          .byte "constant"
00380Dr 3  74 61 6E 74  
003811r 3               
003811r 3               nt_variable:
003811r 3  08 00                .byte 8, 0
003813r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
003817r 3  rr rr        
003819r 3  76 61 72 69          .byte "variable"
00381Dr 3  61 62 6C 65  
003821r 3               
003821r 3               nt_does:
003821r 3  05 05                .byte 5, CO+IM
003823r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
003827r 3  rr rr        
003829r 3  64 6F 65 73          .byte "does>"
00382Dr 3  3E           
00382Er 3               
00382Er 3               nt_create:
00382Er 3  06 00                .byte 6, 0
003830r 3  rr rr rr rr          .word nt_does, xt_create, z_create
003834r 3  rr rr        
003836r 3  63 72 65 61          .byte "create"
00383Ar 3  74 65        
00383Cr 3               
00383Cr 3               nt_allot:
00383Cr 3  05 10                .byte 5, UF
00383Er 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
003842r 3  rr rr        
003844r 3  61 6C 6C 6F          .byte "allot"
003848r 3  74           
003849r 3               
003849r 3               nt_key:
003849r 3  03 00                .byte 3, 0
00384Br 3  rr rr rr rr          .word nt_allot, xt_key, z_key
00384Fr 3  rr rr        
003851r 3  6B 65 79             .byte "key"
003854r 3               
003854r 3               nt_depth:
003854r 3  05 00                .byte 5, 0
003856r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
00385Ar 3  rr rr        
00385Cr 3  64 65 70 74          .byte "depth"
003860r 3  68           
003861r 3               
003861r 3               nt_unused:
003861r 3  06 00                .byte 6, 0
003863r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
003867r 3  rr rr        
003869r 3  75 6E 75 73          .byte "unused"
00386Dr 3  65 64        
00386Fr 3               
00386Fr 3               nt_r_to_input:
00386Fr 3  07 08                .byte 7, NN
003871r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
003875r 3  rr rr        
003877r 3  72 3E 69 6E          .byte "r>input"
00387Br 3  70 75 74     
00387Er 3               
00387Er 3               nt_input_to_r:
00387Er 3  07 08                .byte 7, NN
003880r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
003884r 3  rr rr        
003886r 3  69 6E 70 75          .byte "input>r"
00388Ar 3  74 3E 72     
00388Dr 3               
00388Dr 3               nt_accept:
00388Dr 3  06 18                .byte 6, UF+NN
00388Fr 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
003893r 3  rr rr        
003895r 3  61 63 63 65          .byte "accept"
003899r 3  70 74        
00389Br 3               
00389Br 3               nt_refill:
00389Br 3  06 00                .byte 6, 0
00389Dr 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
0038A1r 3  rr rr        
0038A3r 3  72 65 66 69          .byte "refill"
0038A7r 3  6C 6C        
0038A9r 3               
0038A9r 3               nt_slash_string:
0038A9r 3  07 10                .byte 7, UF
0038ABr 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
0038AFr 3  rr rr        
0038B1r 3  2F 73 74 72          .byte "/string"
0038B5r 3  69 6E 67     
0038B8r 3               
0038B8r 3               nt_minus_leading:
0038B8r 3  08 10                .byte 8, UF
0038BAr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
0038BEr 3  rr rr        
0038C0r 3  2D 6C 65 61          .byte "-leading"
0038C4r 3  64 69 6E 67  
0038C8r 3               
0038C8r 3               nt_minus_trailing:
0038C8r 3  09 10                .byte 9, UF
0038CAr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
0038CEr 3  rr rr        
0038D0r 3  2D 74 72 61          .byte "-trailing"
0038D4r 3  69 6C 69 6E  
0038D8r 3  67           
0038D9r 3               
0038D9r 3               nt_bl:
0038D9r 3  02 00                .byte 2, 0
0038DBr 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
0038DFr 3  rr rr        
0038E1r 3  62 6C                .byte "bl"
0038E3r 3               
0038E3r 3               nt_spaces:
0038E3r 3  06 10                .byte 6, UF
0038E5r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
0038E9r 3  rr rr        
0038EBr 3  73 70 61 63          .byte "spaces"
0038EFr 3  65 73        
0038F1r 3               
0038F1r 3               nt_bounds:
0038F1r 3  06 10                .byte 6, UF
0038F3r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
0038F7r 3  rr rr        
0038F9r 3  62 6F 75 6E          .byte "bounds"
0038FDr 3  64 73        
0038FFr 3               
0038FFr 3               nt_c_comma:
0038FFr 3  02 10                .byte 2, UF
003901r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
003905r 3  rr rr        
003907r 3  63 2C                .byte "c,"
003909r 3               
003909r 3               nt_dnegate:
003909r 3  07 10                .byte 7, UF
00390Br 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
00390Fr 3  rr rr        
003911r 3  64 6E 65 67          .byte "dnegate"
003915r 3  61 74 65     
003918r 3               
003918r 3               nt_negate:
003918r 3  06 10                .byte 6, UF
00391Ar 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
00391Er 3  rr rr        
003920r 3  6E 65 67 61          .byte "negate"
003924r 3  74 65        
003926r 3               
003926r 3               nt_invert:
003926r 3  06 10                .byte 6, UF
003928r 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
00392Cr 3  rr rr        
00392Er 3  69 6E 76 65          .byte "invert"
003932r 3  72 74        
003934r 3               
003934r 3               nt_two_to_r:
003934r 3  03 11                .byte 3, CO+UF          ; native is special case
003936r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
00393Ar 3  rr rr        
00393Cr 3  32 3E 72             .byte "2>r"
00393Fr 3               
00393Fr 3               nt_two_r_from:
00393Fr 3  03 01                .byte 3, CO             ; native is special case
003941r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
003945r 3  rr rr        
003947r 3  32 72 3E             .byte "2r>"
00394Ar 3               
00394Ar 3               nt_two_r_fetch:
00394Ar 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
00394Cr 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
003950r 3  rr rr        
003952r 3  32 72 40             .byte "2r@"
003955r 3               
003955r 3               nt_two_literal:
003955r 3  08 14                .byte 8, UF+IM
003957r 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
00395Br 3  rr rr        
00395Dr 3  32 6C 69 74          .byte "2literal"
003961r 3  65 72 61 6C  
003965r 3               
003965r 3               nt_two_constant:
003965r 3  09 10                .byte 9, UF
003967r 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
00396Br 3  rr rr        
00396Dr 3  32 63 6F 6E          .byte "2constant"
003971r 3  73 74 61 6E  
003975r 3  74           
003976r 3               
003976r 3               nt_two_variable:
003976r 3  09 00                .byte 9, 0
003978r 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
00397Cr 3  rr rr        
00397Er 3  32 76 61 72          .byte "2variable"
003982r 3  69 61 62 6C  
003986r 3  65           
003987r 3               
003987r 3               nt_two_fetch:
003987r 3  02 10                .byte 2, UF
003989r 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
00398Dr 3  rr rr        
00398Fr 3  32 40                .byte "2@"
003991r 3               
003991r 3               nt_two_store:
003991r 3  02 10                .byte 2, UF
003993r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
003997r 3  rr rr        
003999r 3  32 21                .byte "2!"
00399Br 3               
00399Br 3               nt_two_over:
00399Br 3  05 10                .byte 5, UF
00399Dr 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
0039A1r 3  rr rr        
0039A3r 3  32 6F 76 65          .byte "2over"
0039A7r 3  72           
0039A8r 3               
0039A8r 3               nt_two_swap:
0039A8r 3  05 10                .byte 5, UF
0039AAr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
0039AEr 3  rr rr        
0039B0r 3  32 73 77 61          .byte "2swap"
0039B4r 3  70           
0039B5r 3               
0039B5r 3               nt_two_drop:
0039B5r 3  05 10                .byte 5, UF
0039B7r 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
0039BBr 3  rr rr        
0039BDr 3  32 64 72 6F          .byte "2drop"
0039C1r 3  70           
0039C2r 3               
0039C2r 3               nt_max:
0039C2r 3  03 10                .byte 3, UF
0039C4r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
0039C8r 3  rr rr        
0039CAr 3  6D 61 78             .byte "max"
0039CDr 3               
0039CDr 3               nt_min:
0039CDr 3  03 10                .byte 3, UF
0039CFr 3  rr rr rr rr          .word nt_max, xt_min, z_min
0039D3r 3  rr rr        
0039D5r 3  6D 69 6E             .byte "min"
0039D8r 3               
0039D8r 3               nt_zero_less:
0039D8r 3  02 10                .byte 2, UF
0039DAr 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
0039DEr 3  rr rr        
0039E0r 3  30 3C                .byte "0<"
0039E2r 3               
0039E2r 3               nt_zero_greater:
0039E2r 3  02 10                .byte 2, UF
0039E4r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
0039E8r 3  rr rr        
0039EAr 3  30 3E                .byte "0>"
0039ECr 3               
0039ECr 3               nt_zero_unequal:
0039ECr 3  03 10                .byte 3, UF
0039EEr 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
0039F2r 3  rr rr        
0039F4r 3  30 3C 3E             .byte "0<>"
0039F7r 3               
0039F7r 3               nt_zero_equal:
0039F7r 3  02 10                .byte 2, UF
0039F9r 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
0039FDr 3  rr rr        
0039FFr 3  30 3D                .byte "0="
003A01r 3               
003A01r 3               nt_greater_than:
003A01r 3  01 10                .byte 1, UF
003A03r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
003A07r 3  rr rr        
003A09r 3  3E                   .byte ">"
003A0Ar 3               
003A0Ar 3               nt_u_greater_than:
003A0Ar 3  02 10                .byte 2, UF
003A0Cr 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
003A10r 3  rr rr        
003A12r 3  75 3E                .byte "u>"
003A14r 3               
003A14r 3               nt_u_less_than:
003A14r 3  02 10                .byte 2, UF
003A16r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
003A1Ar 3  rr rr        
003A1Cr 3  75 3C                .byte "u<"
003A1Er 3               
003A1Er 3               nt_less_than:
003A1Er 3  01 10                .byte 1, UF
003A20r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
003A24r 3  rr rr        
003A26r 3  3C                   .byte "<"
003A27r 3               
003A27r 3               nt_not_equals:
003A27r 3  02 10                .byte 2, UF
003A29r 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
003A2Dr 3  rr rr        
003A2Fr 3  3C 3E                .byte "<>"
003A31r 3               
003A31r 3               nt_equal:
003A31r 3  01 10                .byte 1, UF
003A33r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
003A37r 3  rr rr        
003A39r 3  3D                   .byte "="
003A3Ar 3               
003A3Ar 3               nt_two_slash:
003A3Ar 3  02 10                .byte 2, UF
003A3Cr 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
003A40r 3  rr rr        
003A42r 3  32 2F                .byte "2/"
003A44r 3               
003A44r 3               nt_two_star:
003A44r 3  02 10                .byte 2, UF
003A46r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
003A4Ar 3  rr rr        
003A4Cr 3  32 2A                .byte "2*"
003A4Er 3               
003A4Er 3               nt_one_plus:
003A4Er 3  02 10                .byte 2, UF
003A50r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
003A54r 3  rr rr        
003A56r 3  31 2B                .byte "1+"
003A58r 3               
003A58r 3               nt_one_minus:
003A58r 3  02 10                .byte 2, UF
003A5Ar 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
003A5Er 3  rr rr        
003A60r 3  31 2D                .byte "1-"
003A62r 3               
003A62r 3               nt_here:
003A62r 3  04 00                .byte 4, 0
003A64r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
003A68r 3  rr rr        
003A6Ar 3  68 65 72 65          .byte "here"
003A6Er 3               
003A6Er 3               nt_cell_plus:
003A6Er 3  05 10                .byte 5, UF
003A70r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
003A74r 3  rr rr        
003A76r 3  63 65 6C 6C          .byte "cell+"
003A7Ar 3  2B           
003A7Br 3               
003A7Br 3               nt_cells:
003A7Br 3  05 00                .byte 5, 0
003A7Dr 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
003A81r 3  rr rr        
003A83r 3  63 65 6C 6C          .byte "cells"
003A87r 3  73           
003A88r 3               
003A88r 3               nt_chars:
003A88r 3  05 12                .byte 5, AN+UF   ; deleted during compile
003A8Ar 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
003A8Er 3  rr rr        
003A90r 3  63 68 61 72          .byte "chars"
003A94r 3  73           
003A95r 3               
003A95r 3               nt_char_plus:
003A95r 3  05 00                .byte 5, 0
003A97r 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
003A9Br 3  rr rr        
003A9Dr 3  63 68 61 72          .byte "char+"
003AA1r 3  2B           
003AA2r 3               
003AA2r 3               nt_bracket_char:
003AA2r 3  06 05                .byte 6, CO+IM
003AA4r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
003AA8r 3  rr rr        
003AAAr 3  5B 63 68 61          .byte "[char]"
003AAEr 3  72 5D        
003AB0r 3               
003AB0r 3               nt_char:
003AB0r 3  04 00                .byte 4, 0
003AB2r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
003AB6r 3  rr rr        
003AB8r 3  63 68 61 72          .byte "char"
003ABCr 3               
003ABCr 3               nt_pick:
003ABCr 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
003ABEr 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
003AC2r 3  rr rr        
003AC4r 3  70 69 63 6B          .byte "pick"
003AC8r 3               
003AC8r 3               nt_lshift:
003AC8r 3  06 10                .byte 6, UF
003ACAr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
003ACEr 3  rr rr        
003AD0r 3  6C 73 68 69          .byte "lshift"
003AD4r 3  66 74        
003AD6r 3               
003AD6r 3               nt_rshift:
003AD6r 3  06 10                .byte 6, UF
003AD8r 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
003ADCr 3  rr rr        
003ADEr 3  72 73 68 69          .byte "rshift"
003AE2r 3  66 74        
003AE4r 3               
003AE4r 3               nt_xor:
003AE4r 3  03 10                .byte 3, UF
003AE6r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
003AEAr 3  rr rr        
003AECr 3  78 6F 72             .byte "xor"
003AEFr 3               
003AEFr 3               nt_or:
003AEFr 3  02 10                .byte 2, UF
003AF1r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
003AF5r 3  rr rr        
003AF7r 3  6F 72                .byte "or"
003AF9r 3               
003AF9r 3               nt_and:
003AF9r 3  03 10                .byte 3, UF
003AFBr 3  rr rr rr rr          .word nt_or, xt_and, z_and
003AFFr 3  rr rr        
003B01r 3  61 6E 64             .byte "and"
003B04r 3               
003B04r 3               nt_dabs:
003B04r 3  04 10                .byte 4, UF
003B06r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
003B0Ar 3  rr rr        
003B0Cr 3  64 61 62 73          .byte "dabs"
003B10r 3               
003B10r 3               nt_abs:
003B10r 3  03 10                .byte 3, UF
003B12r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
003B16r 3  rr rr        
003B18r 3  61 62 73             .byte "abs"
003B1Br 3               
003B1Br 3               nt_minus:
003B1Br 3  01 10                .byte 1, UF
003B1Dr 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
003B21r 3  rr rr        
003B23r 3  2D                   .byte "-"
003B24r 3               
003B24r 3               nt_plus:
003B24r 3  01 10                .byte 1, UF
003B26r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
003B2Ar 3  rr rr        
003B2Cr 3  2B                   .byte "+"
003B2Dr 3               
003B2Dr 3               nt_question_dup:
003B2Dr 3  04 10                .byte 4, UF
003B2Fr 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
003B33r 3  rr rr        
003B35r 3  3F 64 75 70          .byte "?dup"
003B39r 3               
003B39r 3               nt_two_dup:
003B39r 3  04 10                .byte 4, UF
003B3Br 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
003B3Fr 3  rr rr        
003B41r 3  32 64 75 70          .byte "2dup"
003B45r 3               
003B45r 3               nt_two:
003B45r 3  01 00                .byte 1, 0
003B47r 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
003B4Br 3  rr rr        
003B4Dr 3  32                   .byte "2"
003B4Er 3               
003B4Er 3               nt_one:
003B4Er 3  01 00                .byte 1, 0
003B50r 3  rr rr rr rr          .word nt_two, xt_one, z_one
003B54r 3  rr rr        
003B56r 3  31                   .byte "1"
003B57r 3               
003B57r 3               nt_zero:
003B57r 3  01 00                .byte 1, 0
003B59r 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
003B5Dr 3  rr rr        
003B5Fr 3  30                   .byte "0"
003B60r 3               
003B60r 3               nt_space:
003B60r 3  05 00                .byte 5, 0
003B62r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
003B66r 3  rr rr        
003B68r 3  73 70 61 63          .byte "space"
003B6Cr 3  65           
003B6Dr 3               
003B6Dr 3               nt_true:
003B6Dr 3  04 00                .byte 4, 0
003B6Fr 3  rr rr rr rr          .word nt_space, xt_true, z_true
003B73r 3  rr rr        
003B75r 3  74 72 75 65          .byte "true"
003B79r 3               
003B79r 3               nt_false:
003B79r 3  05 00                .byte 5, 0
003B7Br 3  rr rr rr rr          .word nt_true, xt_false, z_false
003B7Fr 3  rr rr        
003B81r 3  66 61 6C 73          .byte "false"
003B85r 3  65           
003B86r 3               
003B86r 3               nt_question:
003B86r 3  01 00                .byte 1, 0
003B88r 3  rr rr rr rr          .word nt_false, xt_question, z_question
003B8Cr 3  rr rr        
003B8Er 3  3F                   .byte "?"
003B8Fr 3               
003B8Fr 3               nt_ud_dot_r:
003B8Fr 3  04 10                .byte 4, UF
003B91r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
003B95r 3  rr rr        
003B97r 3  75 64 2E 72          .byte "ud.r"
003B9Br 3               
003B9Br 3               nt_ud_dot:
003B9Br 3  03 10                .byte 3, UF
003B9Dr 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
003BA1r 3  rr rr        
003BA3r 3  75 64 2E             .byte "ud."
003BA6r 3               
003BA6r 3               nt_d_dot_r:
003BA6r 3  03 10                .byte 3, UF
003BA8r 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
003BACr 3  rr rr        
003BAEr 3  64 2E 72             .byte "d.r"
003BB1r 3               
003BB1r 3               nt_d_dot:
003BB1r 3  02 10                .byte 2, UF
003BB3r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
003BB7r 3  rr rr        
003BB9r 3  64 2E                .byte "d."
003BBBr 3               
003BBBr 3               nt_dot_r:
003BBBr 3  02 10                .byte 2, UF
003BBDr 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
003BC1r 3  rr rr        
003BC3r 3  2E 72                .byte ".r"
003BC5r 3               
003BC5r 3               nt_u_dot_r:
003BC5r 3  03 10                .byte 3, UF
003BC7r 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
003BCBr 3  rr rr        
003BCDr 3  75 2E 72             .byte "u.r"
003BD0r 3               
003BD0r 3               nt_u_dot:
003BD0r 3  02 10                .byte 2, UF
003BD2r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
003BD6r 3  rr rr        
003BD8r 3  75 2E                .byte "u."
003BDAr 3               
003BDAr 3               nt_dot:
003BDAr 3  01 10                .byte 1, UF
003BDCr 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
003BE0r 3  rr rr        
003BE2r 3  2E                   .byte "."
003BE3r 3               
003BE3r 3               nt_type:
003BE3r 3  04 10                .byte 4, UF
003BE5r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
003BE9r 3  rr rr        
003BEBr 3  74 79 70 65          .byte "type"
003BEFr 3               
003BEFr 3               nt_emit:
003BEFr 3  04 18                .byte 4, NN+UF
003BF1r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
003BF5r 3  rr rr        
003BF7r 3  65 6D 69 74          .byte "emit"
003BFBr 3               
003BFBr 3               nt_execute:
003BFBr 3  07 10                .byte 7, UF
003BFDr 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
003C01r 3  rr rr        
003C03r 3  65 78 65 63          .byte "execute"
003C07r 3  75 74 65     
003C0Ar 3               
003C0Ar 3               nt_plus_store:
003C0Ar 3  02 10                .byte 2, UF
003C0Cr 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
003C10r 3  rr rr        
003C12r 3  2B 21                .byte "+!"
003C14r 3               
003C14r 3               nt_c_store:
003C14r 3  02 10                .byte 2, UF
003C16r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
003C1Ar 3  rr rr        
003C1Cr 3  63 21                .byte "c!"
003C1Er 3               
003C1Er 3               nt_c_fetch:
003C1Er 3  02 10                .byte 2, UF
003C20r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
003C24r 3  rr rr        
003C26r 3  63 40                .byte "c@"
003C28r 3               
003C28r 3               nt_comma:
003C28r 3  01 10                .byte 1, UF
003C2Ar 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
003C2Er 3  rr rr        
003C30r 3  2C                   .byte ","
003C31r 3               
003C31r 3               nt_tuck:
003C31r 3  04 10                .byte 4, UF
003C33r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
003C37r 3  rr rr        
003C39r 3  74 75 63 6B          .byte "tuck"
003C3Dr 3               
003C3Dr 3               nt_not_rote:
003C3Dr 3  04 10                .byte 4, UF
003C3Fr 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
003C43r 3  rr rr        
003C45r 3  2D 72 6F 74          .byte "-rot"
003C49r 3               
003C49r 3               nt_rot:
003C49r 3  03 10                .byte 3, UF
003C4Br 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
003C4Fr 3  rr rr        
003C51r 3  72 6F 74             .byte "rot"
003C54r 3               
003C54r 3               nt_nip:
003C54r 3  03 10                .byte 3, UF
003C56r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
003C5Ar 3  rr rr        
003C5Cr 3  6E 69 70             .byte "nip"
003C5Fr 3               
003C5Fr 3               nt_r_fetch:
003C5Fr 3  02 01                .byte 2, CO    ; native is special case
003C61r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
003C65r 3  rr rr        
003C67r 3  72 40                .byte "r@"
003C69r 3               
003C69r 3               nt_r_from:
003C69r 3  02 01                .byte 2, CO    ; native is special case
003C6Br 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
003C6Fr 3  rr rr        
003C71r 3  72 3E                .byte "r>"
003C73r 3               
003C73r 3               nt_to_r:
003C73r 3  02 11                .byte 2, CO+UF ; native is special case
003C75r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
003C79r 3  rr rr        
003C7Br 3  3E 72                .byte ">r"
003C7Dr 3               
003C7Dr 3               nt_over:
003C7Dr 3  04 10                .byte 4, UF
003C7Fr 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
003C83r 3  rr rr        
003C85r 3  6F 76 65 72          .byte "over"
003C89r 3               
003C89r 3               nt_fetch:
003C89r 3  01 10                .byte 1, UF
003C8Br 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
003C8Fr 3  rr rr        
003C91r 3  40                   .byte "@"
003C92r 3               
003C92r 3               nt_store:
003C92r 3  01 10                .byte 1, UF
003C94r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
003C98r 3  rr rr        
003C9Ar 3  21                   .byte "!"
003C9Br 3               
003C9Br 3               nt_swap:
003C9Br 3  04 10                .byte 4, UF
003C9Dr 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
003CA1r 3  rr rr        
003CA3r 3  73 77 61 70          .byte "swap"
003CA7r 3               
003CA7r 3               nt_dup:
003CA7r 3  03 10                .byte 3, UF
003CA9r 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
003CADr 3  rr rr        
003CAFr 3  64 75 70             .byte "dup"
003CB2r 3               
003CB2r 3               ; DROP is always the first native word in the Dictionary
003CB2r 3               dictionary_start:
003CB2r 3               nt_drop:
003CB2r 3  04 10                .byte 4, UF
003CB4r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
003CB8r 3  rr rr        
003CBAr 3  64 72 6F 70          .byte "drop"
003CBEr 3               
003CBEr 3               ; END of FORTH-WORDLIST
003CBEr 3               
003CBEr 3               
003CBEr 3               ; ROOT-WORDLIST
003CBEr 3                       ; This is a short wordlist that has just the words needed to
003CBEr 3                       ; set the wordlists. These words are also included in the
003CBEr 3                       ; FORTH-WORDLIST as well.
003CBEr 3               
003CBEr 3               nt_root_words:
003CBEr 3  05 00                .byte 5, 0
003CC0r 3  00 00 rr rr          .word 0000, xt_words, z_words
003CC4r 3  rr rr        
003CC6r 3  77 6F 72 64          .byte "words"
003CCAr 3  73           
003CCBr 3               
003CCBr 3               nt_root_forth_wordlist: ; shares code with ZERO
003CCBr 3  0E 00                .byte 14, 0
003CCDr 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
003CD1r 3  rr rr        
003CD3r 3  66 6F 72 74          .byte "forth-wordlist"
003CD7r 3  68 2D 77 6F  
003CDBr 3  72 64 6C 69  
003CE1r 3               
003CE1r 3               nt_root_forth:
003CE1r 3  05 00                .byte 5, 0
003CE3r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
003CE7r 3  rr rr        
003CE9r 3  66 6F 72 74          .byte "forth"
003CEDr 3  68           
003CEEr 3               
003CEEr 3               root_dictionary_start:
003CEEr 3               nt_root_set_order:
003CEEr 3  09 00                .byte 9, 0
003CF0r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
003CF4r 3  rr rr        
003CF6r 3  73 65 74 2D          .byte "set-order"
003CFAr 3  6F 72 64 65  
003CFEr 3  72           
003CFFr 3               
003CFFr 3               ; END of ROOT-WORDLIST
003CFFr 3               
003CFFr 3               
003CFFr 3               ; EDITOR-WORDLIST
003CFFr 3               
003CFFr 3               nt_editor_enter_screen:
003CFFr 3  0C 00                .byte 12, 0
003D01r 3  00 00 rr rr          .word 0000, xt_editor_enter_screen, z_editor_enter_screen
003D05r 3  rr rr        
003D07r 3  65 6E 74 65          .byte "enter-screen"
003D0Br 3  72 2D 73 63  
003D0Fr 3  72 65 65 6E  
003D13r 3               
003D13r 3               nt_editor_erase_screen:
003D13r 3  0C 00                .byte 12, 0
003D15r 3  rr rr rr rr          .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
003D19r 3  rr rr        
003D1Br 3  65 72 61 73          .byte "erase-screen"
003D1Fr 3  65 2D 73 63  
003D23r 3  72 65 65 6E  
003D27r 3               
003D27r 3               nt_editor_el:
003D27r 3  02 00                .byte 2, 0
003D29r 3  rr rr rr rr          .word nt_editor_erase_screen, xt_editor_el, z_editor_el
003D2Dr 3  rr rr        
003D2Fr 3  65 6C                .byte "el"
003D31r 3               
003D31r 3               nt_editor_l:
003D31r 3  01 00                .byte 1, 0
003D33r 3  rr rr rr rr          .word nt_editor_el, xt_editor_l, z_editor_l
003D37r 3  rr rr        
003D39r 3  6C                   .byte "l"
003D3Ar 3               
003D3Ar 3               nt_editor_line:
003D3Ar 3  04 10                .byte 4, UF
003D3Cr 3  rr rr rr rr          .word nt_editor_l, xt_editor_line, z_editor_line
003D40r 3  rr rr        
003D42r 3  6C 69 6E 65          .byte "line"
003D46r 3               
003D46r 3               editor_dictionary_start:
003D46r 3               nt_editor_o:
003D46r 3  01 00                .byte 1, 0
003D48r 3  rr rr rr rr          .word nt_editor_line, xt_editor_o, z_editor_o
003D4Cr 3  rr rr        
003D4Er 3  6F                   .byte "o"
003D4Fr 3               
003D4Fr 3               ; END of EDITOR-WORDLIST
003D4Fr 3               
003D4Fr 3               
003D4Fr 3               ; ; ASSEMBLER-WORDLIST
003D4Fr 3               
003D4Fr 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
003D4Fr 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
003D4Fr 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
003D4Fr 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
003D4Fr 3               assembler_dictionary_start:
003D4Fr 3               ; nt_asm_adc_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_adc_x
003D4Fr 3               ; 		.word xt_asm_adc_h, z_asm_adc_h
003D4Fr 3               ; 		.byte "adc.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_adc_y
003D4Fr 3               ; 		.word xt_asm_adc_x, z_asm_adc_x
003D4Fr 3               ; 		.byte "adc.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_adc_z
003D4Fr 3               ; 		.word xt_asm_adc_y, z_asm_adc_y
003D4Fr 3               ; 		.byte "adc.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_adc_zi
003D4Fr 3               ; 		.word xt_asm_adc_z, z_asm_adc_z
003D4Fr 3               ; 		.byte "adc.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_adc_ziy
003D4Fr 3               ; 		.word xt_asm_adc_zi, z_asm_adc_zi
003D4Fr 3               ; 		.byte "adc.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_adc_zx
003D4Fr 3               ; 		.word xt_asm_adc_ziy, z_asm_adc_ziy
003D4Fr 3               ; 		.byte "adc.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_adc_zxi
003D4Fr 3               ; 		.word xt_asm_adc_zx, z_asm_adc_zx
003D4Fr 3               ; 		.byte "adc.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_adc_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_and
003D4Fr 3               ; 		.word xt_asm_adc_zxi, z_asm_adc_zxi
003D4Fr 3               ; 		.byte "adc.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and:     ; not "and" because of conflicts with Forth word
003D4Fr 3               ; 		.byte 4, IM
003D4Fr 3               ;                 .word nt_asm_and_h
003D4Fr 3               ; 		.word xt_asm_and, z_asm_and
003D4Fr 3               ; 		.byte "and."
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_and_x
003D4Fr 3               ; 		.word xt_asm_and_h, z_asm_and_h
003D4Fr 3               ; 		.byte "and.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_and_y
003D4Fr 3               ; 		.word xt_asm_and_x, z_asm_and_x
003D4Fr 3               ; 		.byte "and.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_and_z
003D4Fr 3               ; 		.word xt_asm_and_y, z_asm_and_y
003D4Fr 3               ; 		.byte "and.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_and_zi
003D4Fr 3               ; 		.word xt_asm_and_z, z_asm_and_z
003D4Fr 3               ; 		.byte "and.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_and_ziy
003D4Fr 3               ; 		.word xt_asm_and_zi, z_asm_and_zi
003D4Fr 3               ; 		.byte "and.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_and_zx
003D4Fr 3               ; 		.word xt_asm_and_ziy, z_asm_and_ziy
003D4Fr 3               ; 		.byte "and.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_and_zxi
003D4Fr 3               ; 		.word xt_asm_and_zx, z_asm_and_zx
003D4Fr 3               ; 		.byte "and.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_and_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_asl
003D4Fr 3               ; 		.word xt_asm_and_zxi, z_asm_and_zxi
003D4Fr 3               ; 		.byte "and.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_asl:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_asl_a
003D4Fr 3               ; 		.word xt_asm_asl, z_asm_asl
003D4Fr 3               ; 		.byte "asl"
003D4Fr 3               
003D4Fr 3               ; nt_asm_asl_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_asl_x
003D4Fr 3               ; 		.word xt_asm_asl_a, z_asm_asl_a
003D4Fr 3               ; 		.byte "asl.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_asl_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_asl_z
003D4Fr 3               ; 		.word xt_asm_asl_x, z_asm_asl_x
003D4Fr 3               ; 		.byte "asl.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_asl_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_asl_zx
003D4Fr 3               ; 		.word xt_asm_asl_z, z_asm_asl_z
003D4Fr 3               ; 		.byte "asl.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_asl_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_bcc
003D4Fr 3               ; 		.word xt_asm_asl_zx, z_asm_asl_zx
003D4Fr 3               ; 		.byte "asl.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bcc:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bcs
003D4Fr 3               ; 		.word xt_asm_bcc, z_asm_bcc
003D4Fr 3               ; 		.byte "bcc"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bcs:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_beq
003D4Fr 3               ; 		.word xt_asm_bcs, z_asm_bcs
003D4Fr 3               ; 		.byte "bcs"
003D4Fr 3               
003D4Fr 3               ; nt_asm_beq:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bit
003D4Fr 3               ; 		.word xt_asm_beq, z_asm_beq
003D4Fr 3               ; 		.byte "beq"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bit:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bit_h
003D4Fr 3               ; 		.word xt_asm_bit, z_asm_bit
003D4Fr 3               ; 		.byte "bit"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bit_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_bit_x
003D4Fr 3               ; 		.word xt_asm_bit_h, z_asm_bit_h
003D4Fr 3               ; 		.byte "bit.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bit_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_bit_z
003D4Fr 3               ; 		.word xt_asm_bit_x, z_asm_bit_x
003D4Fr 3               ; 		.byte "bit.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bit_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_bit_zx
003D4Fr 3               ; 		.word xt_asm_bit_z, z_asm_bit_z
003D4Fr 3               ; 		.byte "bit.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bit_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_bmi
003D4Fr 3               ; 		.word xt_asm_bit_zx, z_asm_bit_zx
003D4Fr 3               ; 		.byte "bit.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bmi:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bne
003D4Fr 3               ; 		.word xt_asm_bmi, z_asm_bmi
003D4Fr 3               ; 		.byte "bmi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bne:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bpl
003D4Fr 3               ; 		.word xt_asm_bne, z_asm_bne
003D4Fr 3               ; 		.byte "bne"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bpl:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bra
003D4Fr 3               ; 		.word xt_asm_bpl, z_asm_bpl
003D4Fr 3               ; 		.byte "bpl"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bra:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_brk
003D4Fr 3               ; 		.word xt_asm_bra, z_asm_bra
003D4Fr 3               ; 		.byte "bra"
003D4Fr 3               
003D4Fr 3               ; nt_asm_brk:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bvc
003D4Fr 3               ; 		.word xt_asm_brk, z_asm_brk
003D4Fr 3               ; 		.byte "brk"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bvc:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_bvs
003D4Fr 3               ; 		.word xt_asm_bvc, z_asm_bvc
003D4Fr 3               ; 		.byte "bvc"
003D4Fr 3               
003D4Fr 3               ; nt_asm_bvs:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_clc
003D4Fr 3               ; 		.word xt_asm_bvs, z_asm_bvs
003D4Fr 3               ; 		.byte "bvs"
003D4Fr 3               
003D4Fr 3               ; nt_asm_clc:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cld
003D4Fr 3               ; 		.word xt_asm_clc, z_asm_clc
003D4Fr 3               ; 		.byte "clc"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cld:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cli
003D4Fr 3               ; 		.word xt_asm_cld, z_asm_cld
003D4Fr 3               ; 		.byte "cld"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cli:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_clv
003D4Fr 3               ; 		.word xt_asm_cli, z_asm_cli
003D4Fr 3               ; 		.byte "cli"
003D4Fr 3               
003D4Fr 3               ; nt_asm_clv:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cmp
003D4Fr 3               ; 		.word xt_asm_clv, z_asm_clv
003D4Fr 3               ; 		.byte "clv"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cmp_h
003D4Fr 3               ; 		.word xt_asm_cmp, z_asm_cmp
003D4Fr 3               ; 		.byte "cmp"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cmp_x
003D4Fr 3               ; 		.word xt_asm_cmp_h, z_asm_cmp_h
003D4Fr 3               ; 		.byte "cmp.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cmp_y
003D4Fr 3               ; 		.word xt_asm_cmp_x, z_asm_cmp_x
003D4Fr 3               ; 		.byte "cmp.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cmp_z
003D4Fr 3               ; 		.word xt_asm_cmp_y, z_asm_cmp_y
003D4Fr 3               ; 		.byte "cmp.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cmp_zi
003D4Fr 3               ; 		.word xt_asm_cmp_z, z_asm_cmp_z
003D4Fr 3               ; 		.byte "cmp.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_cmp_ziy
003D4Fr 3               ; 		.word xt_asm_cmp_zi, z_asm_cmp_zi
003D4Fr 3               ; 		.byte "cmp.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_cmp_zx
003D4Fr 3               ; 		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
003D4Fr 3               ; 		.byte "cmp.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_cmp_zxi
003D4Fr 3               ; 		.word xt_asm_cmp_zx, z_asm_cmp_zx
003D4Fr 3               ; 		.byte "cmp.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cmp_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_cpx
003D4Fr 3               ; 		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
003D4Fr 3               ; 		.byte "cmp.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cpx_h
003D4Fr 3               ; 		.word xt_asm_cpx, z_asm_cpx
003D4Fr 3               ; 		.byte "cpx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpx_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cpx_z
003D4Fr 3               ; 		.word xt_asm_cpx_h, z_asm_cpx_h
003D4Fr 3               ; 		.byte "cpx.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpx_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cpy
003D4Fr 3               ; 		.word xt_asm_cpx_z, z_asm_cpx_z
003D4Fr 3               ; 		.byte "cpx.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpy:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_cpy_h
003D4Fr 3               ; 		.word xt_asm_cpy, z_asm_cpy
003D4Fr 3               ; 		.byte "cpy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpy_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_cpy_z
003D4Fr 3               ; 		.word xt_asm_cpy_h, z_asm_cpy_h
003D4Fr 3               ; 		.byte "cpy.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_cpy_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_dec
003D4Fr 3               ; 		.word xt_asm_cpy_z, z_asm_cpy_z
003D4Fr 3               ; 		.byte "cpy.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dec:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_dec_a
003D4Fr 3               ; 		.word xt_asm_dec, z_asm_dec
003D4Fr 3               ; 		.byte "dec"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dec_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_dec_x
003D4Fr 3               ; 		.word xt_asm_dec_a, z_asm_dec_a
003D4Fr 3               ; 		.byte "dec.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dec_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_dec_z
003D4Fr 3               ; 		.word xt_asm_dec_x, z_asm_dec_x
003D4Fr 3               ; 		.byte "dec.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dec_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_dec_zx
003D4Fr 3               ; 		.word xt_asm_dec_z, z_asm_dec_z
003D4Fr 3               ; 		.byte "dec.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dec_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_dex
003D4Fr 3               ; 		.word xt_asm_dec_zx, z_asm_dec_zx
003D4Fr 3               ; 		.byte "dec.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dex:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_dey
003D4Fr 3               ; 		.word xt_asm_dex, z_asm_dex
003D4Fr 3               ; 		.byte "dex"
003D4Fr 3               
003D4Fr 3               ; nt_asm_dey:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_eor
003D4Fr 3               ; 		.word xt_asm_dey, z_asm_dey
003D4Fr 3               ; 		.byte "dey"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_eor_h
003D4Fr 3               ; 		.word xt_asm_eor, z_asm_eor
003D4Fr 3               ; 		.byte "eor"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_eor_x
003D4Fr 3               ; 		.word xt_asm_eor_h, z_asm_eor_h
003D4Fr 3               ; 		.byte "eor.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_eor_y
003D4Fr 3               ; 		.word xt_asm_eor_x, z_asm_eor_x
003D4Fr 3               ; 		.byte "eor.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_eor_z
003D4Fr 3               ; 		.word xt_asm_eor_y, z_asm_eor_y
003D4Fr 3               ; 		.byte "eor.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_eor_zi
003D4Fr 3               ; 		.word xt_asm_eor_z, z_asm_eor_z
003D4Fr 3               ; 		.byte "eor.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_eor_ziy
003D4Fr 3               ; 		.word xt_asm_eor_zi, z_asm_eor_zi
003D4Fr 3               ; 		.byte "eor.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_eor_zx
003D4Fr 3               ; 		.word xt_asm_eor_ziy, z_asm_eor_ziy
003D4Fr 3               ; 		.byte "eor.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_eor_zxi
003D4Fr 3               ; 		.word xt_asm_eor_zx, z_asm_eor_zx
003D4Fr 3               ; 		.byte "eor.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_eor_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_inc
003D4Fr 3               ; 		.word xt_asm_eor_zxi, z_asm_eor_zxi
003D4Fr 3               ; 		.byte "eor.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inc:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_inc_a
003D4Fr 3               ; 		.word xt_asm_inc, z_asm_inc
003D4Fr 3               ; 		.byte "inc"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inc_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_inc_x
003D4Fr 3               ; 		.word xt_asm_inc_a, z_asm_inc_a
003D4Fr 3               ; 		.byte "inc.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inc_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_inc_z
003D4Fr 3               ; 		.word xt_asm_inc_x, z_asm_inc_x
003D4Fr 3               ; 		.byte "inc.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inc_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_inc_zx
003D4Fr 3               ; 		.word xt_asm_inc_z, z_asm_inc_z
003D4Fr 3               ; 		.byte "inc.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inc_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_inx
003D4Fr 3               ; 		.word xt_asm_inc_zx, z_asm_inc_zx
003D4Fr 3               ; 		.byte "inc.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_inx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_iny
003D4Fr 3               ; 		.word xt_asm_inx, z_asm_inx
003D4Fr 3               ; 		.byte "inx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_iny:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_jmp
003D4Fr 3               ; 		.word xt_asm_iny, z_asm_iny
003D4Fr 3               ; 		.byte "iny"
003D4Fr 3               
003D4Fr 3               ; nt_asm_jmp:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_jmp_i
003D4Fr 3               ; 		.word xt_asm_jmp, z_asm_jmp
003D4Fr 3               ; 		.byte "jmp"
003D4Fr 3               
003D4Fr 3               ; nt_asm_jmp_i:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_jmp_xi
003D4Fr 3               ; 		.word xt_asm_jmp_i, z_asm_jmp_i
003D4Fr 3               ; 		.byte "jmp.i"
003D4Fr 3               
003D4Fr 3               ; nt_asm_jmp_xi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_jsr
003D4Fr 3               ; 		.word xt_asm_jmp_xi, z_asm_jmp_xi
003D4Fr 3               ; 		.byte "jmp.xi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_jsr:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_lda
003D4Fr 3               ; 		.word xt_asm_jsr, z_asm_jsr
003D4Fr 3               ; 		.byte "jsr"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_lda_h
003D4Fr 3               ; 		.word xt_asm_lda, z_asm_lda
003D4Fr 3               ; 		.byte "lda"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lda_x
003D4Fr 3               ; 		.word xt_asm_lda_h, z_asm_lda_h
003D4Fr 3               ; 		.byte "lda.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lda_y
003D4Fr 3               ; 		.word xt_asm_lda_x, z_asm_lda_x
003D4Fr 3               ; 		.byte "lda.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lda_z
003D4Fr 3               ; 		.word xt_asm_lda_y, z_asm_lda_y
003D4Fr 3               ; 		.byte "lda.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lda_zi
003D4Fr 3               ; 		.word xt_asm_lda_z, z_asm_lda_z
003D4Fr 3               ; 		.byte "lda.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_lda_ziy
003D4Fr 3               ; 		.word xt_asm_lda_zi, z_asm_lda_zi
003D4Fr 3               ; 		.byte "lda.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_lda_zx
003D4Fr 3               ; 		.word xt_asm_lda_ziy, z_asm_lda_ziy
003D4Fr 3               ; 		.byte "lda.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_lda_zxi
003D4Fr 3               ; 		.word xt_asm_lda_zx, z_asm_lda_zx
003D4Fr 3               ; 		.byte "lda.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lda_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_ldx
003D4Fr 3               ; 		.word xt_asm_lda_zxi, z_asm_lda_zxi
003D4Fr 3               ; 		.byte "lda.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ldx_h
003D4Fr 3               ; 		.word xt_asm_ldx, z_asm_ldx
003D4Fr 3               ; 		.byte "ldx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldx_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldx_y
003D4Fr 3               ; 		.word xt_asm_ldx_h, z_asm_ldx_h
003D4Fr 3               ; 		.byte "ldx.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldx_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldx_z
003D4Fr 3               ; 		.word xt_asm_ldx_y, z_asm_ldx_y
003D4Fr 3               ; 		.byte "ldx.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldx_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldx_zy
003D4Fr 3               ; 		.word xt_asm_ldx_z, z_asm_ldx_z
003D4Fr 3               ; 		.byte "ldx.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldx_zy:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_ldy
003D4Fr 3               ; 		.word xt_asm_ldx_zy, z_asm_ldx_zy
003D4Fr 3               ; 		.byte "ldx.zy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldy:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ldy_h
003D4Fr 3               ; 		.word xt_asm_ldy, z_asm_ldy
003D4Fr 3               ; 		.byte "ldy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldy_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldy_x
003D4Fr 3               ; 		.word xt_asm_ldy_h, z_asm_ldy_h
003D4Fr 3               ; 		.byte "ldy.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldy_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldy_z
003D4Fr 3               ; 		.word xt_asm_ldy_x, z_asm_ldy_x
003D4Fr 3               ; 		.byte "ldy.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldy_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ldy_zx
003D4Fr 3               ; 		.word xt_asm_ldy_z, z_asm_ldy_z
003D4Fr 3               ; 		.byte "ldy.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ldy_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_lsr
003D4Fr 3               ; 		.word xt_asm_ldy_zx, z_asm_ldy_zx
003D4Fr 3               ; 		.byte "ldy.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lsr:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_lsr_a
003D4Fr 3               ; 		.word xt_asm_lsr, z_asm_lsr
003D4Fr 3               ; 		.byte "lsr"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lsr_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lsr_x
003D4Fr 3               ; 		.word xt_asm_lsr_a, z_asm_lsr_a
003D4Fr 3               ; 		.byte "lsr.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lsr_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lsr_z
003D4Fr 3               ; 		.word xt_asm_lsr_x, z_asm_lsr_x
003D4Fr 3               ; 		.byte "lsr.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lsr_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_lsr_zx
003D4Fr 3               ; 		.word xt_asm_lsr_z, z_asm_lsr_z
003D4Fr 3               ; 		.byte "lsr.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_lsr_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_nop
003D4Fr 3               ; 		.word xt_asm_lsr_zx, z_asm_lsr_zx
003D4Fr 3               ; 		.byte "lsr.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_nop:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ora
003D4Fr 3               ; 		.word xt_asm_nop, z_asm_nop
003D4Fr 3               ; 		.byte "nop"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ora_h
003D4Fr 3               ; 		.word xt_asm_ora, z_asm_ora
003D4Fr 3               ; 		.byte "ora"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ora_x
003D4Fr 3               ; 		.word xt_asm_ora_h, z_asm_ora_h
003D4Fr 3               ; 		.byte "ora.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ora_y
003D4Fr 3               ; 		.word xt_asm_ora_x, z_asm_ora_x
003D4Fr 3               ; 		.byte "ora.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ora_z
003D4Fr 3               ; 		.word xt_asm_ora_y, z_asm_ora_y
003D4Fr 3               ; 		.byte "ora.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ora_zi
003D4Fr 3               ; 		.word xt_asm_ora_z, z_asm_ora_z
003D4Fr 3               ; 		.byte "ora.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_ora_ziy
003D4Fr 3               ; 		.word xt_asm_ora_zi, z_asm_ora_zi
003D4Fr 3               ; 		.byte "ora.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_ora_zx
003D4Fr 3               ; 		.word xt_asm_ora_ziy, z_asm_ora_ziy
003D4Fr 3               ; 		.byte "ora.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_ora_zxi
003D4Fr 3               ; 		.word xt_asm_ora_zx, z_asm_ora_zx
003D4Fr 3               ; 		.byte "ora.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ora_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_pha
003D4Fr 3               ; 		.word xt_asm_ora_zxi, z_asm_ora_zxi
003D4Fr 3               ; 		.byte "ora.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_pha:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_php
003D4Fr 3               ; 		.word xt_asm_pha, z_asm_pha
003D4Fr 3               ; 		.byte "pha"
003D4Fr 3               
003D4Fr 3               ; nt_asm_php:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_phx
003D4Fr 3               ; 		.word xt_asm_php, z_asm_php
003D4Fr 3               ; 		.byte "php"
003D4Fr 3               
003D4Fr 3               ; nt_asm_phx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_phy
003D4Fr 3               ; 		.word xt_asm_phx, z_asm_phx
003D4Fr 3               ; 		.byte "phx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_phy:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_pla
003D4Fr 3               ; 		.word xt_asm_phy, z_asm_phy
003D4Fr 3               ; 		.byte "phy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_pla:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_plp
003D4Fr 3               ; 		.word xt_asm_pla, z_asm_pla
003D4Fr 3               ; 		.byte "pla"
003D4Fr 3               
003D4Fr 3               ; nt_asm_plp:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_plx
003D4Fr 3               ; 		.word xt_asm_plp, z_asm_plp
003D4Fr 3               ; 		.byte "plp"
003D4Fr 3               
003D4Fr 3               ; nt_asm_plx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ply
003D4Fr 3               ; 		.word xt_asm_plx, z_asm_plx
003D4Fr 3               ; 		.byte "plx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ply:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_rol
003D4Fr 3               ; 		.word xt_asm_ply, z_asm_ply
003D4Fr 3               ; 		.byte "ply"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rol:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_rol_a
003D4Fr 3               ; 		.word xt_asm_rol, z_asm_rol
003D4Fr 3               ; 		.byte "rol"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rol_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_rol_x
003D4Fr 3               ; 		.word xt_asm_rol_a, z_asm_rol_a
003D4Fr 3               ; 		.byte "rol.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rol_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_rol_z
003D4Fr 3               ; 		.word xt_asm_rol_x, z_asm_rol_x
003D4Fr 3               ; 		.byte "rol.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rol_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_rol_zx
003D4Fr 3               ; 		.word xt_asm_rol_z, z_asm_rol_z
003D4Fr 3               ; 		.byte "rol.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rol_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_ror
003D4Fr 3               ; 		.word xt_asm_rol_zx, z_asm_rol_zx
003D4Fr 3               ; 		.byte "rol.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ror:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_ror_a
003D4Fr 3               ; 		.word xt_asm_ror, z_asm_ror
003D4Fr 3               ; 		.byte "ror"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ror_a:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ror_x
003D4Fr 3               ; 		.word xt_asm_ror_a, z_asm_ror_a
003D4Fr 3               ; 		.byte "ror.a"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ror_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ror_z
003D4Fr 3               ; 		.word xt_asm_ror_x, z_asm_ror_x
003D4Fr 3               ; 		.byte "ror.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ror_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_ror_zx
003D4Fr 3               ; 		.word xt_asm_ror_z, z_asm_ror_z
003D4Fr 3               ; 		.byte "ror.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_ror_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_rti
003D4Fr 3               ; 		.word xt_asm_ror_zx, z_asm_ror_zx
003D4Fr 3               ; 		.byte "ror.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rti:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_rts
003D4Fr 3               ; 		.word xt_asm_rti, z_asm_rti
003D4Fr 3               ; 		.byte "rti"
003D4Fr 3               
003D4Fr 3               ; nt_asm_rts:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sbc
003D4Fr 3               ; 		.word xt_asm_rts, z_asm_rts
003D4Fr 3               ; 		.byte "rts"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sbc_h
003D4Fr 3               ; 		.word xt_asm_sbc, z_asm_sbc
003D4Fr 3               ; 		.byte "sbc"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_h:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sbc_x
003D4Fr 3               ; 		.word xt_asm_sbc_h, z_asm_sbc_h
003D4Fr 3               ; 		.byte "sbc.#"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sbc_y
003D4Fr 3               ; 		.word xt_asm_sbc_x, z_asm_sbc_x
003D4Fr 3               ; 		.byte "sbc.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sbc_z
003D4Fr 3               ; 		.word xt_asm_sbc_y, z_asm_sbc_y
003D4Fr 3               ; 		.byte "sbc.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sbc_zi
003D4Fr 3               ; 		.word xt_asm_sbc_z, z_asm_sbc_z
003D4Fr 3               ; 		.byte "sbc.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_sbc_ziy
003D4Fr 3               ; 		.word xt_asm_sbc_zi, z_asm_sbc_zi
003D4Fr 3               ; 		.byte "sbc.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_sbc_zx
003D4Fr 3               ; 		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
003D4Fr 3               ; 		.byte "sbc.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_sbc_zxi
003D4Fr 3               ; 		.word xt_asm_sbc_zx, z_asm_sbc_zx
003D4Fr 3               ; 		.byte "sbc.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sbc_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_sec
003D4Fr 3               ; 		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
003D4Fr 3               ; 		.byte "sbc.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sec:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sed
003D4Fr 3               ; 		.word xt_asm_sec, z_asm_sec
003D4Fr 3               ; 		.byte "sec"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sed:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sei
003D4Fr 3               ; 		.word xt_asm_sed, z_asm_sed
003D4Fr 3               ; 		.byte "sed"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sei:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sta
003D4Fr 3               ; 		.word xt_asm_sei, z_asm_sei
003D4Fr 3               ; 		.byte "sei"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sta_x
003D4Fr 3               ; 		.word xt_asm_sta, z_asm_sta
003D4Fr 3               ; 		.byte "sta"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sta_y
003D4Fr 3               ; 		.word xt_asm_sta_x, z_asm_sta_x
003D4Fr 3               ; 		.byte "sta.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_y:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sta_z
003D4Fr 3               ; 		.word xt_asm_sta_y, z_asm_sta_y
003D4Fr 3               ; 		.byte "sta.y"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sta_zi
003D4Fr 3               ; 		.word xt_asm_sta_z, z_asm_sta_z
003D4Fr 3               ; 		.byte "sta.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_zi:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_sta_ziy
003D4Fr 3               ; 		.word xt_asm_sta_zi, z_asm_sta_zi
003D4Fr 3               ; 		.byte "sta.zi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_ziy:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_sta_zx
003D4Fr 3               ; 		.word xt_asm_sta_ziy, z_asm_sta_ziy
003D4Fr 3               ; 		.byte "sta.ziy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_sta_zxi
003D4Fr 3               ; 		.word xt_asm_sta_zx, z_asm_sta_zx
003D4Fr 3               ; 		.byte "sta.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sta_zxi:
003D4Fr 3               ; 		.byte 7, IM
003D4Fr 3               ;                 .word nt_asm_stx
003D4Fr 3               ; 		.word xt_asm_sta_zxi, z_asm_sta_zxi
003D4Fr 3               ; 		.byte "sta.zxi"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_stx_z
003D4Fr 3               ; 		.word xt_asm_stx, z_asm_stx
003D4Fr 3               ; 		.byte "stx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stx_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_stx_zy
003D4Fr 3               ; 		.word xt_asm_stx_z, z_asm_stx_z
003D4Fr 3               ; 		.byte "stx.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stx_zy:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_sty
003D4Fr 3               ; 		.word xt_asm_stx_zy, z_asm_stx_zy
003D4Fr 3               ; 		.byte "stx.zy"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sty:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_sty_z
003D4Fr 3               ; 		.word xt_asm_sty, z_asm_sty
003D4Fr 3               ; 		.byte "sty"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sty_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_sty_zx
003D4Fr 3               ; 		.word xt_asm_sty_z, z_asm_sty_z
003D4Fr 3               ; 		.byte "sty.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_sty_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_stz
003D4Fr 3               ; 		.word xt_asm_sty_zx, z_asm_sty_zx
003D4Fr 3               ; 		.byte "sty.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stz:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_stz_x
003D4Fr 3               ; 		.word xt_asm_stz, z_asm_stz
003D4Fr 3               ; 		.byte "stz"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stz_x:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_stz_z
003D4Fr 3               ; 		.word xt_asm_stz_x, z_asm_stz_x
003D4Fr 3               ; 		.byte "stz.x"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stz_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_stz_zx
003D4Fr 3               ; 		.word xt_asm_stz_z, z_asm_stz_z
003D4Fr 3               ; 		.byte "stz.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_stz_zx:
003D4Fr 3               ; 		.byte 6, IM
003D4Fr 3               ;                 .word nt_asm_tax
003D4Fr 3               ; 		.word xt_asm_stz_zx, z_asm_stz_zx
003D4Fr 3               ; 		.byte "stz.zx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tax:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_tay
003D4Fr 3               ; 		.word xt_asm_tax, z_asm_tax
003D4Fr 3               ; 		.byte "tax"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tay:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_trb
003D4Fr 3               ; 		.word xt_asm_tay, z_asm_tay
003D4Fr 3               ; 		.byte "tay"
003D4Fr 3               
003D4Fr 3               ; nt_asm_trb:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_trb_z
003D4Fr 3               ; 		.word xt_asm_trb, z_asm_trb
003D4Fr 3               ; 		.byte "trb"
003D4Fr 3               
003D4Fr 3               ; nt_asm_trb_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_tsb
003D4Fr 3               ; 		.word xt_asm_trb_z, z_asm_trb_z
003D4Fr 3               ; 		.byte "trb.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tsb:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_tsb_z
003D4Fr 3               ; 		.word xt_asm_tsb, z_asm_tsb
003D4Fr 3               ; 		.byte "tsb"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tsb_z:
003D4Fr 3               ; 		.byte 5, IM
003D4Fr 3               ;                 .word nt_asm_tsx
003D4Fr 3               ; 		.word xt_asm_tsb_z, z_asm_tsb_z
003D4Fr 3               ; 		.byte "tsb.z"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tsx:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_txa
003D4Fr 3               ; 		.word xt_asm_tsx, z_asm_tsx
003D4Fr 3               ; 		.byte "tsx"
003D4Fr 3               
003D4Fr 3               ; nt_asm_txa:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_txs
003D4Fr 3               ; 		.word xt_asm_txa, z_asm_txa
003D4Fr 3               ; 		.byte "txa"
003D4Fr 3               
003D4Fr 3               ; nt_asm_txs:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_tya
003D4Fr 3               ; 		.word xt_asm_txs, z_asm_txs
003D4Fr 3               ; 		.byte "txs"
003D4Fr 3               
003D4Fr 3               ; nt_asm_tya:
003D4Fr 3               ; 		.byte 3, IM
003D4Fr 3               ;                 .word nt_asm_arrow
003D4Fr 3               ; 		.word xt_asm_tya, z_asm_tya
003D4Fr 3               ; 		.byte "tya"
003D4Fr 3               
003D4Fr 3               ; ; Assembler pseudo-instructions, directives and macros
003D4Fr 3               
003D4Fr 3               ; nt_asm_arrow:   ; uses same code as HERE, but immediate
003D4Fr 3               ;                 .byte 3, IM
003D4Fr 3               ;                 .word nt_asm_back_jump
003D4Fr 3               ;                 .word xt_asm_arrow, z_asm_arrow
003D4Fr 3               ;                 .byte "-->"
003D4Fr 3               
003D4Fr 3               
003D4Fr 3               ; nt_asm_back_jump:  ; syntactic sugar, does nothing
003D4Fr 3               ;                 .byte 2, IM
003D4Fr 3               ;                 .word nt_asm_back_branch
003D4Fr 3               ;                 .word xt_asm_back_jump, z_asm_back_jump
003D4Fr 3               ;                 .byte "<j"
003D4Fr 3               
003D4Fr 3               ; nt_asm_back_branch:
003D4Fr 3               ;                 .byte 2, IM
003D4Fr 3               ;                 .word nt_asm_push_a
003D4Fr 3               ;                 .word xt_asm_back_branch, z_asm_back_branch
003D4Fr 3               ;                 .byte "<b"
003D4Fr 3               
003D4Fr 3               ; nt_asm_push_a:
003D4Fr 3               ;                 .byte 6, IM
003D4Fr 3               ;                 .word 0000
003D4Fr 3               ;                 .word xt_asm_push_a, z_asm_push_a
003D4Fr 3               ;                 .byte "push-a"
003D4Fr 3               
003D4Fr 3               
003D4Fr 3               
003D4Fr 3               ; END of ASSEMBLER-WORDLIST
003D4Fr 3               
003D4Fr 3               ; END
003D4Fr 3               
003D4Fr 2                   .include "strings.s"          ; Headers of native words
003D4Fr 3               ; List of Strings for Tali Forth 2
003D4Fr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
003D4Fr 3               ; First version: 01. Apr 2016 (for Liara Forth)
003D4Fr 3               ; This version: 28. Dec 2018
003D4Fr 3               
003D4Fr 3               ; This file is included by taliforth.asm
003D4Fr 3               
003D4Fr 3               ; ## GENERAL STRINGS
003D4Fr 3               
003D4Fr 3               ; All general strings must be zero-terminated, names start with "s_",
003D4Fr 3               ; aliases with "str_"
003D4Fr 3               
003D4Fr 3               str_ok =              0
003D4Fr 3               str_compile =         1
003D4Fr 3               str_redefined =       2
003D4Fr 3               str_wid_forth =       3
003D4Fr 3               str_abc_lower =       4
003D4Fr 3               str_abc_upper =       5
003D4Fr 3               str_wid_editor =      6
003D4Fr 3               str_wid_assembler =   7
003D4Fr 3               str_wid_root =        8
003D4Fr 3               str_see_flags =       9
003D4Fr 3               str_see_nt =         10
003D4Fr 3               str_see_xt =         11
003D4Fr 3               str_see_size =       12
003D4Fr 3               
003D4Fr 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
003D4Fr 3               ; to tables as error and string numbers.
003D4Fr 3               string_table:
003D4Fr 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
003D53r 3  rr rr rr rr  
003D57r 3  rr rr        
003D59r 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
003D5Dr 3  rr rr rr rr  
003D61r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
003D65r 3  rr rr rr rr  
003D69r 3               
003D69r 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
003D6Dr 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
003D71r 3  70 69 6C 65  
003D75r 3  64 00        
003D77r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
003D7Br 3  66 69 6E 65  
003D7Fr 3  64 20 00     
003D82r 3               
003D82r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
003D86r 3  34 35 36 37  
003D8Ar 3  38 39 61 62  
003DA6r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
003DAAr 3  34 35 36 37  
003DAEr 3  38 39 41 42  
003DCAr 3               
003DCAr 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
003DCEr 3  6D 62 6C 65  
003DD2r 3  72 20 00     
003DD5r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
003DD9r 3  6F 72 20 00  
003DDDr 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
003DE1r 3  68 20 00     
003DE4r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
003DE8r 3  20 00        
003DEAr 3               
003DEAr 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
003DEEr 3  73 20 28 43  
003DF2r 3  4F 20 41 4E  
003E06r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
003E0Ar 3  00           
003E0Br 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
003E0Fr 3  00           
003E10r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
003E14r 3  20 28 64 65  
003E18r 3  63 69 6D 61  
003E21r 3               
003E21r 3               
003E21r 3               ; ## ERROR STRINGS
003E21r 3               
003E21r 3               ; All error strings must be zero-terminated, all names start with "es_",
003E21r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
003E21r 3               ; as well
003E21r 3               
003E21r 3               err_allot =        0
003E21r 3               err_badsource =    1
003E21r 3               err_compileonly =  2
003E21r 3               err_defer =        3
003E21r 3               err_divzero =      4
003E21r 3               err_noname =       5
003E21r 3               err_refill =       6
003E21r 3               err_state =        7
003E21r 3               err_syntax =       8
003E21r 3               err_underflow =    9
003E21r 3               err_negallot =     10
003E21r 3               err_wordlist =     11
003E21r 3               err_blockwords =   12
003E21r 3               
003E21r 3               error_table:
003E21r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
003E25r 3  rr rr rr rr  
003E29r 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
003E2Dr 3  rr rr rr rr  
003E31r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
003E35r 3  rr rr rr rr  
003E39r 3  rr rr                .word es_blockwords                                    ; 12
003E3Br 3               
003E3Br 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
003E3Fr 3  54 20 75 73  
003E43r 3  69 6E 67 20  
003E5Cr 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
003E60r 3  67 61 6C 20  
003E64r 3  53 4F 55 52  
003E7Cr 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
003E80r 3  72 70 72 65  
003E84r 3  74 69 6E 67  
003E9Dr 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
003EA1r 3  52 65 64 20  
003EA5r 3  77 6F 72 64  
003EBAr 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
003EBEr 3  73 69 6F 6E  
003EC2r 3  20 62 79 20  
003ECBr 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
003ECFr 3  69 6E 67 20  
003ED3r 3  66 61 69 6C  
003EDBr 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
003EDFr 3  20 63 6F 75  
003EE3r 3  6C 64 20 6E  
003F09r 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
003F0Dr 3  61 64 79 20  
003F11r 3  69 6E 20 63  
003F21r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
003F25r 3  66 69 6E 65  
003F29r 3  64 20 77 6F  
003F30r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
003F34r 3  6B 20 75 6E  
003F38r 3  64 65 72 66  
003F40r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
003F44r 3  6D 65 6D 6F  
003F48r 3  72 79 20 66  
003F5Cr 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
003F60r 3  6F 72 64 6C  
003F64r 3  69 73 74 73  
003F73r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
003F77r 3  73 65 20 61  
003F7Br 3  73 73 69 67  
003FB2r 3               
003FB2r 3               ; ## ENVIRONMENT STRINGS
003FB2r 3               
003FB2r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
003FB2r 3               ; Length byte first, then the string itself that is not rpt. not
003FB2r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
003FB2r 3               ; "envs_".
003FB2r 3               
003FB2r 3               ; These return a single-cell number
003FB2r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
003FB6r 3  55 4E 54 45  
003FBAr 3  44 2D 53 54  
003FC2r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
003FC6r 3  4C 44        
003FC8r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
003FCCr 3  44           
003FCDr 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
003FD1r 3  52 45 53 53  
003FD5r 3  2D 55 4E 49  
003FDFr 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
003FE3r 3  4F 52 45 44  
003FE7r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
003FEBr 3  2D 43 48 41  
003FEFr 3  52           
003FF0r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
003FF4r 3  2D 4E        
003FF6r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
003FFAr 3  2D 55        
003FFCr 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
004000r 3  55 52 4E 2D  
004004r 3  53 54 41 43  
00400Fr 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
004013r 3  43 4B 2D 43  
004017r 3  45 4C 4C 53  
00401Br 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
00401Fr 3  44 4C 49 53  
004023r 3  54 53        
004025r 3               
004025r 3               ; These return a double-cell number
004025r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
004029r 3  2D 44        
00402Br 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
00402Fr 3  2D 55 44     
004032r 3               
004032r 3               ; END
004032r 3               
004032r 2               
004032r 2               ; High-level Forth words, see forth_code/README.md
004032r 2               forth_words_start:
004032r 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
004036r 2  2E 28 20 52  
00403Ar 2  65 61 64 79  
004044r 2               forth_words_end:
004044r 2               
004044r 2               ; User-defined Forth words, see forth_code/README.md
004044r 2               user_words_start:
004044r 2  20 32 30 20  .incbin "forth_code/user_words.asc"
004048r 2  63 6F 6E 73  
00404Cr 2  74 61 6E 74  
0046E2r 2               user_words_end:
0046E2r 2               
0046E2r 2               
0046E2r 2               ; =====================================================================
0046E2r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
0046E2r 2               
0046E2r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
0046E2r 2               ; at compile time so they are available at run time. Words that use this
0046E2r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
0046E2r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
0046E2r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
0046E2r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
0046E2r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
0046E2r 2               ; Bowie.
0046E2r 2               
0046E2r 2               ;               ldy #>addr      ; MSB   ; "Young"
0046E2r 2               ;               lda #<addr      ; LSB   ; "Americans"
0046E2r 2               ;               jsr cmpl_subroutine
0046E2r 2               
0046E2r 2               ; Also, we keep a routine here to compile a single byte passed through A.
0046E2r 2               
0046E2r 2               cmpl_subroutine:
0046E2r 2                   ; This is the entry point to compile JSR <ADDR>
0046E2r 2  48               pha             ; save LSB of address
0046E3r 2  A9 20            lda #$20        ; load opcode for JSR
0046E5r 2  80 03            bra cmpl_common
0046E7r 2               cmpl_jump:
0046E7r 2                   ; This is the entry point to compile JMP <ADDR>
0046E7r 2  48               pha             ; save LSB of address
0046E8r 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
0046EAr 2               cmpl_common:
0046EAr 2                   ; At this point, A contains the opcode to be compiled,
0046EAr 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
0046EAr 2                   ; the address is in Y
0046EAr 2  20 rr rr         jsr cmpl_a      ; compile opcode
0046EDr 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
0046EEr 2               cmpl_word:
0046EEr 2                   ; This is the entry point to compile a word (little-endian)
0046EEr 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
0046F1r 2  98               tya             ; fall thru for MSB
0046F2r 2               cmpl_a:
0046F2r 2                   ; This is the entry point to compile a single byte which
0046F2r 2                   ; is passed in A. The built-in assembler assumes that this
0046F2r 2                   ; routine does not modify Y.
0046F2r 2  92 rr            sta (cp)
0046F4r 2  E6 rr            inc cp
0046F6r 2  D0 02            bne _done
0046F8r 2  E6 rr            inc cp+1
0046FAr 2               _done:
0046FAr 2  60               rts
0046FBr 2               
0046FBr 2               
0046FBr 2               
0046FBr 2               ; =====================================================================
0046FBr 2               ; CODE FIELD ROUTINES
0046FBr 2               
0046FBr 2               doconst:
0046FBr 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
0046FBr 2               ; the Data Field onto the Data Stack
0046FBr 2               ; """
0046FBr 2  CA               dex             ; make room for constant
0046FCr 2  CA               dex
0046FDr 2               
0046FDr 2                   ; The value we need is stored in the two bytes after the
0046FDr 2                   ; JSR return address, which in turn is what is on top of
0046FDr 2                   ; the Return Stack
0046FDr 2  68               pla             ; LSB of return address
0046FEr 2  85 rr            sta tmp1
004700r 2  68               pla             ; MSB of return address
004701r 2  85 rr            sta tmp1+1
004703r 2               
004703r 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
004703r 2                   ; the return address on the 65c02
004703r 2  A0 01            ldy #1
004705r 2  B1 rr            lda (tmp1),y
004707r 2  95 00            sta 0,x
004709r 2  C8               iny
00470Ar 2  B1 rr            lda (tmp1),y
00470Cr 2  95 01            sta 1,x
00470Er 2               
00470Er 2                   ; This takes us back to the original caller, not the
00470Er 2                   ; DOCONST caller
00470Er 2  60               rts
00470Fr 2               
00470Fr 2               
00470Fr 2               dodefer:
00470Fr 2               ; """Execute a DEFER statement at runtime: Execute the address we
00470Fr 2               ; find after the caller in the Data Field
00470Fr 2               ; """
00470Fr 2                   ; The xt we need is stored in the two bytes after the JSR
00470Fr 2                   ; return address, which is what is on top of the Return
00470Fr 2                   ; Stack. So all we have to do is replace our return jump
00470Fr 2                   ; with what we find there
00470Fr 2  68               pla             ; LSB
004710r 2  85 rr            sta tmp1
004712r 2  68               pla             ; MSB
004713r 2  85 rr            sta tmp1+1
004715r 2               
004715r 2  A0 01            ldy #1
004717r 2  B1 rr            lda (tmp1),y
004719r 2  85 rr            sta tmp2
00471Br 2  C8               iny
00471Cr 2  B1 rr            lda (tmp1),y
00471Er 2  85 rr            sta tmp2+1
004720r 2               
004720r 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004723r 2               
004723r 2               defer_error:
004723r 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004723r 2  A9 03            lda #err_defer
004725r 2  4C rr rr         jmp error
004728r 2               
004728r 2               dodoes:
004728r 2               ; """Execute the runtime portion of DOES>. See DOES> and
004728r 2               ; docs/create-does.txt for details and
004728r 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004728r 2               ; """
004728r 2                   ; Assumes the address of the CFA of the original defining word
004728r 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004728r 2                   ; for a later jump, adding one byte because of the way the
004728r 2                   ; 6502 works
004728r 2  7A               ply             ; LSB
004729r 2  68               pla             ; MSB
00472Ar 2  C8               iny
00472Br 2  D0 01            bne @1
00472Dr 2  1A               inc
00472Er 2               @1:
00472Er 2  84 rr            sty tmp2
004730r 2  85 rr            sta tmp2+1
004732r 2               
004732r 2                   ; Next on the Return Stack should be the address of the PFA of
004732r 2                   ; the calling defined word (say, the name of whatever constant we
004732r 2                   ; just defined). Move this to the Data Stack, again adding one.
004732r 2  CA               dex
004733r 2  CA               dex
004734r 2               
004734r 2  7A               ply
004735r 2  68               pla
004736r 2  C8               iny
004737r 2  D0 01            bne @2
004739r 2  1A               inc
00473Ar 2               @2:
00473Ar 2  94 00            sty 0,x         ; LSB
00473Cr 2  95 01            sta 1,x         ; MSB
00473Er 2               
00473Er 2                   ; This leaves the return address from the original main routine
00473Er 2                   ; on top of the Return Stack. We leave that untouched and jump
00473Er 2                   ; to the special code of the defining word. It's RTS instruction
00473Er 2                   ; will take us back to the main routine
00473Er 2  6C rr rr         jmp (tmp2)
004741r 2               
004741r 2               
004741r 2               dovar:
004741r 2               ; """Execute a variable: Push the address of the first bytes of
004741r 2               ; the Data Field onto the stack. This is called with JSR so we
004741r 2               ; can pick up the address of the calling variable off the 65c02's
004741r 2               ; stack. The final RTS takes us to the original caller of the
004741r 2               ; routine that itself called DOVAR. This is the default
004741r 2               ; routine installed with CREATE.
004741r 2               ; """
004741r 2                   ; Pull the return address off the machine's stack, adding
004741r 2                   ; one because of the way the 65c02 handles subroutines
004741r 2  7A               ply             ; LSB
004742r 2  68               pla             ; MSB
004743r 2  C8               iny
004744r 2  D0 01            bne @1
004746r 2  1A               inc
004747r 2               @1:
004747r 2  CA               dex
004748r 2  CA               dex
004749r 2               
004749r 2  95 01            sta 1,x
00474Br 2  98               tya
00474Cr 2  95 00            sta 0,x
00474Er 2               
00474Er 2  60               rts
00474Fr 2               
00474Fr 2               ; =====================================================================
00474Fr 2               ; LOW LEVEL HELPER FUNCTIONS
00474Fr 2               
00474Fr 2               byte_to_ascii:
00474Fr 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
00474Fr 2               .scope
00474Fr 2  48               pha
004750r 2  4A               lsr             ; convert high nibble first
004751r 2  4A               lsr
004752r 2  4A               lsr
004753r 2  4A               lsr
004754r 2  20 rr rr         jsr _nibble_to_ascii
004757r 2  68               pla
004758r 2               
004758r 2                   ; fall through to _nibble_to_ascii
004758r 2               
004758r 2               _nibble_to_ascii:
004758r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004758r 2               ; of A and and EMIT it. This does the actual work.
004758r 2               ; """
004758r 2  29 0F            and #$0F
00475Ar 2  09 30            ora #'0'
00475Cr 2  C9 3A            cmp #$3A        ; '9+1
00475Er 2  90 02            bcc @1
004760r 2  69 06            adc #$06
004762r 2               
004762r 2  4C rr rr     @1:               jmp emit_a
004765r 2               
004765r 2  60               rts
004766r 2               .endscope
004766r 2               
004766r 2               compare_16bit:
004766r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004766r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004766r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004766r 2               ; For signed numbers, Z signals equality and N which number is larger:
004766r 2               ;       if TOS = NOS: Z=1 and N=0
004766r 2               ;       if TOS > NOS: Z=0 and N=0
004766r 2               ;       if TOS < NOS: Z=0 and N=1
004766r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004766r 2               ;       if TOS = NOS: Z=1 and N=0
004766r 2               ;       if TOS > NOS: Z=0 and C=1
004766r 2               ;       if TOS < NOS: Z=0 and C=0
004766r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004766r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004766r 2               ; """
004766r 2               .scope
004766r 2                   ; Compare LSB first to set the carry flag
004766r 2  B5 00            lda 0,x                 ; LSB of TOS
004768r 2  D5 02            cmp 2,x                 ; LSB of NOS
00476Ar 2  F0 0A            beq _equal
00476Cr 2               
00476Cr 2                   ; LSBs are not equal, compare MSB
00476Cr 2  B5 01            lda 1,x                 ; MSB of TOS
00476Er 2  F5 03            sbc 3,x                 ; MSB of NOS
004770r 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004772r 2  70 08            bvs _overflow
004774r 2  80 08            bra _not_equal
004776r 2               _equal:
004776r 2                   ; Low bytes are equal, so we compare high bytes
004776r 2  B5 01            lda 1,x                 ; MSB of TOS
004778r 2  F5 03            sbc 3,x                 ; MSB of NOS
00477Ar 2  50 04            bvc _done
00477Cr 2               _overflow:
00477Cr 2                   ; Handle overflow because we use signed numbers
00477Cr 2  49 80            eor #$80                ; complement negative flag
00477Er 2               _not_equal:
00477Er 2  09 01            ora #1                  ; if overflow, we can't be eqal
004780r 2               _done:
004780r 2  60               rts
004781r 2               .endscope
004781r 2               
004781r 2               current_to_dp:
004781r 2               ; """Look up the current (compilation) dictionary pointer
004781r 2               ; in the wordlist set and put it into the dp zero-page
004781r 2               ; variable. Uses A and Y.
004781r 2               ; """
004781r 2                   ; Determine which wordlist is current
004781r 2  A0 04            ldy #current_offset
004783r 2  B1 rr            lda (up),y      ; current is a byte variable
004785r 2  0A               asl             ; turn it into an offset (in cells)
004786r 2               
004786r 2                   ; Get the dictionary pointer for that wordlist.
004786r 2  18               clc
004787r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004789r 2  A8               tay
00478Ar 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
00478Cr 2  85 rr            sta dp
00478Er 2  C8               iny
00478Fr 2  B1 rr            lda (up),y
004791r 2  85 rr            sta dp+1
004793r 2               
004793r 2  60               rts
004794r 2               
004794r 2               
004794r 2               dp_to_current:
004794r 2               ; """Look up which wordlist is current and update its pointer
004794r 2               ; with the value in dp. Uses A and Y.
004794r 2               ; """
004794r 2                   ; Determine which wordlist is current
004794r 2  A0 04            ldy #current_offset
004796r 2  B1 rr            lda (up),y      ; current is a byte variable
004798r 2  0A               asl             ; turn it into an offset (in cells)
004799r 2               
004799r 2                   ; Get the dictionary pointer for that wordlist.
004799r 2  18               clc
00479Ar 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
00479Cr 2  A8               tay
00479Dr 2  A5 rr            lda dp
00479Fr 2  91 rr            sta (up),y              ; get the dp for that wordlist.
0047A1r 2  C8               iny
0047A2r 2  A5 rr            lda dp+1
0047A4r 2  91 rr            sta (up),y
0047A6r 2               
0047A6r 2  60               rts
0047A7r 2               
0047A7r 2               interpret:
0047A7r 2               .scope
0047A7r 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
0047A7r 2               ; Process one line only. Assumes that the address of name is in
0047A7r 2               ; cib and the length of the whole input line string is in ciblen
0047A7r 2               ; """
0047A7r 2                   ; Normally we would use PARSE here with the SPACE character as
0047A7r 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
0047A7r 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
0047A7r 2                   ; delimiters per default and skips any leading spaces, which
0047A7r 2                   ; PARSE doesn't
0047A7r 2               _loop:
0047A7r 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
0047AAr 2               
0047AAr 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
0047AAr 2                   ; in the line and we need to go get a new line
0047AAr 2  B5 00            lda 0,x
0047ACr 2  15 01            ora 1,x
0047AEr 2  F0 70            beq _line_done
0047B0r 2               
0047B0r 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
0047B0r 2                   ; make a copy of the address in case it isn't a word we know and
0047B0r 2                   ; we have to go see if it is a number
0047B0r 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
0047B3r 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
0047B6r 2               
0047B6r 2                   ; A zero signals that we didn't find a word in the Dictionary
0047B6r 2  B5 00            lda 0,x
0047B8r 2  15 01            ora 1,x
0047BAr 2  D0 28            bne _got_name_token
0047BCr 2               
0047BCr 2                   ; We didn't get any nt we know of, so let's see if this is
0047BCr 2                   ; a number.
0047BCr 2  E8               inx                     ; ( addr u 0 -- addr u )
0047BDr 2  E8               inx
0047BEr 2               
0047BEr 2                   ; If the number conversion doesn't work, NUMBER will do the
0047BEr 2                   ; complaining for us
0047BEr 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
0047C1r 2               
0047C1r 2                   ; Otherweise, if we're interpreting, we're done
0047C1r 2  A5 rr            lda state
0047C3r 2  F0 E2            beq _loop
0047C5r 2               
0047C5r 2                   ; We're compiling, so there is a bit more work.  Check
0047C5r 2                   ; status bit 5 to see if it's a single or double-cell
0047C5r 2                   ; number.
0047C5r 2  A9 20            lda #$20
0047C7r 2  24 rr            bit status
0047C9r 2  F0 0D            beq _single_number
0047CBr 2               
0047CBr 2                   ; It's a double cell number.  If we swap the
0047CBr 2                   ; upper and lower half, we can use the literal_runtime twice
0047CBr 2                   ; to compile it into the dictionary.
0047CBr 2  20 rr rr         jsr xt_swap
0047CEr 2  A0 rr            ldy #>literal_runtime
0047D0r 2  A9 rr            lda #<literal_runtime
0047D2r 2  20 rr rr         jsr cmpl_subroutine
0047D5r 2               
0047D5r 2                   ; compile our number
0047D5r 2  20 rr rr         jsr xt_comma
0047D8r 2               
0047D8r 2                   ; Fall into _single_number to process the other half.
0047D8r 2               _single_number:
0047D8r 2  A0 rr            ldy #>literal_runtime
0047DAr 2  A9 rr            lda #<literal_runtime
0047DCr 2  20 rr rr         jsr cmpl_subroutine
0047DFr 2               
0047DFr 2                   ; compile our number
0047DFr 2  20 rr rr         jsr xt_comma
0047E2r 2               
0047E2r 2                   ; That was so much fun, let's do it again!
0047E2r 2  80 C3            bra _loop
0047E4r 2               
0047E4r 2               _got_name_token:
0047E4r 2                   ; We have a known word's nt TOS. We're going to need its xt
0047E4r 2                   ; though, which is four bytes father down.
0047E4r 2               
0047E4r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
0047E4r 2  B5 00            lda 0,x
0047E6r 2  95 04            sta 4,x
0047E8r 2  B5 01            lda 1,x
0047EAr 2  95 05            sta 5,x
0047ECr 2               
0047ECr 2  E8               inx
0047EDr 2  E8               inx
0047EEr 2  E8               inx
0047EFr 2  E8               inx                     ; ( nt )
0047F0r 2               
0047F0r 2                   ; Save a version of nt for error handling and compilation stuff
0047F0r 2  B5 00            lda 0,x
0047F2r 2  85 rr            sta tmpbranch
0047F4r 2  B5 01            lda 1,x
0047F6r 2  85 rr            sta tmpbranch+1
0047F8r 2               
0047F8r 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
0047FBr 2               
0047FBr 2                   ; See if we are in interpret or compile mode, 0 is interpret
0047FBr 2  A5 rr            lda state
0047FDr 2  D0 13            bne _compile
0047FFr 2               
0047FFr 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
0047FFr 2                   ; though, see if this isn't a compile-only word, which would be
0047FFr 2                   ; illegal. The status byte is the second one of the header.
0047FFr 2  A0 01            ldy #1
004801r 2  B1 rr            lda (tmpbranch),y
004803r 2  29 01            and #CO                 ; mask everything but Compile Only bit
004805r 2  F0 05            beq _interpret
004807r 2               
004807r 2  A9 02            lda #err_compileonly
004809r 2  4C rr rr         jmp error
00480Cr 2               
00480Cr 2               _interpret:
00480Cr 2                   ; We JSR to EXECUTE instead of calling the xt directly because
00480Cr 2                   ; the RTS of the word we're executing will bring us back here,
00480Cr 2                   ; skipping EXECUTE completely during RTS. If we were to execute
00480Cr 2                   ; xt directly, we have to fool around with the Return Stack
00480Cr 2                   ; instead, which is actually slightly slower
00480Cr 2  20 rr rr         jsr xt_execute
00480Fr 2               
00480Fr 2                   ; That's quite enough for this word, let's get the next one
00480Fr 2  4C rr rr         jmp _loop
004812r 2               
004812r 2               _compile:
004812r 2                   ; We're compiling! However, we need to see if this is an
004812r 2                   ; IMMEDIATE word, which would mean we execute it right now even
004812r 2                   ; during compilation mode. Fortunately, we saved the nt so life
004812r 2                   ; is easier. The flags are in the second byte of the header
004812r 2  A0 01            ldy #1
004814r 2  B1 rr            lda (tmpbranch),y
004816r 2  29 04            and #IM                 ; Mask all but IM bit
004818r 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
00481Ar 2               
00481Ar 2                   ; Compile the xt into the Dictionary with COMPILE,
00481Ar 2  20 rr rr         jsr xt_compile_comma
00481Dr 2  4C rr rr         jmp _loop
004820r 2               
004820r 2               _line_done:
004820r 2                   ; drop stuff from PARSE_NAME
004820r 2  E8               inx
004821r 2  E8               inx
004822r 2  E8               inx
004823r 2  E8               inx
004824r 2               
004824r 2  60               rts
004825r 2               .endscope
004825r 2               
004825r 2               
004825r 2               is_printable:
004825r 2               .scope
004825r 2               ; """Given a character in A, check if it is a printable ASCII
004825r 2               ; character in the range from $20 to $7E inclusive. Returns the
004825r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004825r 2               ; is printable. Keeps A. See
004825r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004825r 2               ; discussion of various ways to do this
004825r 2  C9 20            cmp #AscSP              ; $20
004827r 2  90 08            bcc _done
004829r 2  C9 7F            cmp #'~' + 1             ; $7E
00482Br 2  B0 03            bcs _failed
00482Dr 2               
00482Dr 2  38               sec
00482Er 2  80 01            bra _done
004830r 2               _failed:
004830r 2  18               clc
004831r 2               _done:
004831r 2  60               rts
004832r 2               .endscope
004832r 2               
004832r 2               
004832r 2               is_whitespace:
004832r 2               .scope
004832r 2               ; """Given a character in A, check if it is a whitespace
004832r 2               ; character, that is, an ASCII value from 0 to 32 (where
004832r 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004832r 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004832r 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004832r 2               ; a discussion of the uses. Does not change A or Y.
004832r 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004834r 2  90 08            bcc _done
004836r 2               
004836r 2  C9 21            cmp #AscSP+1
004838r 2  B0 03            bcs _failed
00483Ar 2               
00483Ar 2  38               sec
00483Br 2  80 01            bra _done
00483Dr 2               _failed:
00483Dr 2  18               clc
00483Er 2               _done:
00483Er 2  60               rts
00483Fr 2               .endscope
00483Fr 2               
00483Fr 2               
00483Fr 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
00483Fr 2               ; required for the word. This routine flows into the generic error handling
00483Fr 2               ; code
00483Fr 2               underflow_1:
00483Fr 2               ; """Make sure we have at least one cell on the Data Stack"""
00483Fr 2  E0 rr            cpx #dsp0-1
004841r 2  10 10            bpl underflow_error
004843r 2  60               rts
004844r 2               underflow_2:
004844r 2               ; """Make sure we have at least two cells on the Data Stack"""
004844r 2  E0 rr            cpx #dsp0-3
004846r 2  10 0B            bpl underflow_error
004848r 2  60               rts
004849r 2               underflow_3:
004849r 2               ; """Make sure we have at least three cells on the Data Stack"""
004849r 2  E0 rr            cpx #dsp0-5
00484Br 2  10 06            bpl underflow_error
00484Dr 2  60               rts
00484Er 2               underflow_4:
00484Er 2               ; """Make sure we have at least four cells on the Data Stack"""
00484Er 2  E0 rr            cpx #dsp0-7
004850r 2  10 01            bpl underflow_error
004852r 2  60               rts
004853r 2               
004853r 2               underflow_error:
004853r 2                   ; Entry for COLD/ABORT/QUIT
004853r 2  A9 09            lda #err_underflow      ; fall through to error
004855r 2               
004855r 2               error:
004855r 2               ; """Given the error number in a, print the associated error string and
004855r 2               ; call abort. Uses tmp3.
004855r 2               ; """
004855r 2  0A               asl
004856r 2  A8               tay
004857r 2  B9 rr rr         lda error_table,y
00485Ar 2  85 rr            sta tmp3                ; LSB
00485Cr 2  C8               iny
00485Dr 2  B9 rr rr         lda error_table,y
004860r 2  85 rr            sta tmp3+1              ; MSB
004862r 2               
004862r 2  20 rr rr         jsr print_common
004865r 2  20 rr rr         jsr xt_cr
004868r 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
00486Br 2               
00486Br 2               
00486Br 2               ; =====================================================================
00486Br 2               ; PRINTING ROUTINES
00486Br 2               
00486Br 2               ; We distinguish two types of print calls, both of which take the string number
00486Br 2               ; (see strings.asm) in A:
00486Br 2               
00486Br 2               ;       print_string       - with a line feed
00486Br 2               ;       print_string_no_lf - without a line feed
00486Br 2               
00486Br 2               ; In addition, print_common provides a lower-level alternative for error
00486Br 2               ; handling and anything else that provides the address of the
00486Br 2               ; zero-terminated string directly in tmp3. All of those routines assume that
00486Br 2               ; printing should be more concerned with size than speed, because anything to
00486Br 2               ; do with humans reading text is going to be slow.
00486Br 2               
00486Br 2               print_string_no_lf:
00486Br 2               ; """Given the number of a zero-terminated string in A, print it to the
00486Br 2               ; current output without adding a LF. Uses Y and tmp3 by falling
00486Br 2               ; through to print_common
00486Br 2               ; """
00486Br 2                   ; Get the entry from the string table
00486Br 2  0A               asl
00486Cr 2  A8               tay
00486Dr 2  B9 rr rr         lda string_table,y
004870r 2  85 rr            sta tmp3                ; LSB
004872r 2  C8               iny
004873r 2  B9 rr rr         lda string_table,y
004876r 2  85 rr            sta tmp3+1              ; MSB
004878r 2               
004878r 2                   ; fall through to print_common
004878r 2               print_common:
004878r 2               ; """Common print routine used by both the print functions and
004878r 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004878r 2               ; Y.
004878r 2               ; """
004878r 2               .scope
004878r 2  A0 00            ldy #0
00487Ar 2               _loop:
00487Ar 2  B1 rr            lda (tmp3),y
00487Cr 2  F0 06            beq _done               ; strings are zero-terminated
00487Er 2               
00487Er 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004881r 2  C8               iny
004882r 2  80 F6            bra _loop
004884r 2               _done:
004884r 2  60               rts
004885r 2               .endscope
004885r 2               
004885r 2               print_string:
004885r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004885r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004885r 2               ; """
004885r 2  20 rr rr         jsr print_string_no_lf
004888r 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
00488Br 2               
00488Br 2               
00488Br 2               print_u:
00488Br 2               ; """basic printing routine used by higher-level constructs,
00488Br 2               ; the equivalent of the forth word  0 <# #s #> type  which is
00488Br 2               ; basically u. without the space at the end. used for various
00488Br 2               ; outputs
00488Br 2               ; """
00488Br 2  20 rr rr         jsr xt_zero                     ; 0
00488Er 2  20 rr rr         jsr xt_less_number_sign         ; <#
004891r 2  20 rr rr         jsr xt_number_sign_s            ; #S
004894r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004897r 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
00489Ar 2               
00489Ar 2               ; END
00489Ar 2               
00489Ar 1               
00489Ar 1               .segment "DATA"
00489Ar 1               
00489Ar 1               .include "../../ed.s"
00489Ar 2               ; ed6502 - Ed-like line-based editor for Tali Forth 2
00489Ar 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00489Ar 2               ; First version: 13. Okt 2018
00489Ar 2               ; This version: 28. Dec 2018
00489Ar 2               
00489Ar 2               ; Ed is a line-orientated editor for Tali Forth 2 based on the classic Unix
00489Ar 2               ; editor of the same name. It is included because a) I like line editors and
00489Ar 2               ; this is my project, so there, and b) as a very simple editor that will work
00489Ar 2               ; even if there is no vt100 terminal support, just with ASCII if needs be. For
00489Ar 2               ; further information on ed, see
00489Ar 2               
00489Ar 2               ;   https://en.wikipedia.org/wiki/Ed_(text_editor)
00489Ar 2               ;   https://www.gnu.org/software/ed/ed.html
00489Ar 2               ;   https://www.gnu.org/software/ed/manual/ed_manual.html
00489Ar 2               ;   https://sanctum.geek.nz/arabesque/actually-using-ed/
00489Ar 2               ;   http://www.psue.uni-hannover.de/wise2017_2018/material/ed.pdf
00489Ar 2               
00489Ar 2               ; We start editor from Forth with
00489Ar 2               ;
00489Ar 2               ;       ed ( -- addr u )
00489Ar 2               ;
00489Ar 2               ; The return values ( addr u ) are the address and length of the text written.
00489Ar 2               ; If no text was written, u is zero and addr is undefined.
00489Ar 2               
00489Ar 2               ; In the working memory, the text is stored as a simple linked list of lines.
00489Ar 2               ; Each node consists of three 16-bit entries:
00489Ar 2               
00489Ar 2               ;       - pointer to next entry (0 for end of list)
00489Ar 2               ;       - pointer to beginning of string ( addr )
00489Ar 2               ;       - length of string ( u )
00489Ar 2               
00489Ar 2               ; The editor only works in interaction with slow humans, so speed is not
00489Ar 2               ; a primary concern. We try to keep the size down instead.
00489Ar 2               
00489Ar 2               ; Where to put variables is a bit of a problem. To convert the numbers, we need
00489Ar 2               ; UM/MOD, which uses the scratchpad, and ACCEPT uses tmp1, tmp2, and tmp3 at
00489Ar 2               ; some point, so we either have to pay very close attention, or we do something
00489Ar 2               ; else. After some experimenting, it seems that the easiest way for this sort
00489Ar 2               ; of hybrid Forth/assembler system is to keep the parameters for the commands
00489Ar 2               ; on the Data Stack in the form of ( para1 para2 ):
00489Ar 2               
00489Ar 2               ;       TOS: parameter 2 (after the comma)
00489Ar 2               ;       NOS: parameter 1 (before the comma)
00489Ar 2               
00489Ar 2               ; The third and fourth entries on the stack are the ( addr-t u-t ) entries the
00489Ar 2               ; text will be/has been written to, or u as 0 if nothing was defined.
00489Ar 2               
00489Ar 2               ; We also need a pointer to the beginning of the text (first node of the list),
00489Ar 2               ; the number of the current line, and a flag to mark if the text has been
00489Ar 2               ; changed. We have six bytes of zero page reserved for any editor to use. Note
00489Ar 2               ; that this means that we can't use two editors at the same time, which won't
00489Ar 2               ; be a problem until we can multitask.
00489Ar 2               
00489Ar 2               ed_head =  editor1  ; pointer to first list element (addr) (2 bytes)
00489Ar 2               ed_cur =   editor2  ; current line number (1 is first line) (2 bytes)
00489Ar 2               ed_flags = editor3  ; Flags used by ed, where
00489Ar 2               ;       bit 7 parameters - 0: none, 1: have at least one parameter
00489Ar 2               ;       bit 6 changed    - 0: text not changed, 1: text was changed
00489Ar 2               ;       bit 0 printing   - 0: no line numbers (p), 1: with line numbers (n)
00489Ar 2               
00489Ar 2               ;  Byte editor3+1 is currently unused
00489Ar 2               
00489Ar 2               
00489Ar 2               ed6502:
00489Ar 2                               ; Start a new empty linked list at HERE. This is also
00489Ar 2                               ; the current line
00489Ar 2  64 rr                        stz ed_head
00489Cr 2  64 rr                        stz ed_head+1
00489Er 2               
00489Er 2                               ; The current line is 0, because we start counting at
00489Er 2                               ; line 1 for the humans
00489Er 2  64 rr                        stz ed_cur
0048A0r 2  64 rr                        stz ed_cur+1
0048A2r 2               
0048A2r 2                               ; At the beginning, we have no parameters (bit 7), no line
0048A2r 2                               ; numbers (bit 0), and nothing was changed (bit 6)
0048A2r 2  64 rr                        stz ed_flags
0048A4r 2               
0048A4r 2                               ; We put zeros as placeholders for the text we've written to
0048A4r 2                               ; (the "target") on the stack. Because the stack picture is
0048A4r 2                               ; going to get very confusing very fast, we'll mark them
0048A4r 2                               ; specially with "-t" suffixes in the stack comments.
0048A4r 2  20 rr rr                     jsr xt_zero
0048A7r 2  20 rr rr                     jsr xt_zero             ; ( addr-t u-t )
0048AAr 2               
0048AAr 2  20 rr rr                     jsr xt_cr
0048ADr 2               
0048ADr 2               _input_loop:
0048ADr 2                               ; Set parameter flag to none (bit 7); default printing is
0048ADr 2                               ; without line numbers (bit 0). We leave the changed flag (bit
0048ADr 2                               ; 6) because we might be coming from a previous add
0048ADr 2  A9 81                        lda #%10000001
0048AFr 2  14 rr                        trb ed_flags
0048B1r 2               
0048B1r 2                               ; We really don't want to have to write a complete
0048B1r 2                               ; parser for such a simple editor, so we walk through the
0048B1r 2                               ; possibilities the hard way. Get input from the user. This
0048B1r 2                               ; routine handles any errors from REFILL
0048B1r 2  20 rr rr                     jsr _get_input
0048B4r 2               
0048B4r 2                               ; If we were not given an empty line, see what we were given
0048B4r 2  A5 rr                        lda ciblen
0048B6r 2  D0 1F                        bne _command_mode
0048B8r 2               
0048B8r 2                               ; We were given an empty line. Advance one line, print it, and
0048B8r 2                               ; make it the new current line
0048B8r 2  CA                           dex
0048B9r 2  CA                           dex                     ; ( addr-t u-t ? )
0048BAr 2               
0048BAr 2  A5 rr                        lda ed_cur
0048BCr 2  95 00                        sta 0,x
0048BEr 2  A5 rr                        lda ed_cur+1
0048C0r 2  95 01                        sta 1,x                 ; ( addr-t u-t u )
0048C2r 2               
0048C2r 2                               ; This counts as having a parameter
0048C2r 2  A9 80                        lda #%10000000
0048C4r 2  04 rr                        tsb ed_flags
0048C6r 2               
0048C6r 2  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t u+1 )
0048C9r 2  20 rr rr                     jsr _is_valid_line
0048CCr 2  B0 03                        bcs @next
0048CEr 2               
0048CEr 2                               ; New line number is not legal, abort
0048CEr 2  4C rr rr                     jmp _error_1drop
0048D1r 2               @next:
0048D1r 2                               ; We have a legal line number, but we need two entries on
0048D1r 2                               ; the parameter list (four if you count the target
0048D1r 2                               ; address) to be able to work with the rest of the program.
0048D1r 2  20 rr rr                     jsr xt_zero             ; ( addr-t u-t u+1 0 )
0048D4r 2               
0048D4r 2  4C rr rr                     jmp _line_number_only_from_external
0048D7r 2               
0048D7r 2               _command_mode:
0048D7r 2               
0048D7r 2                               ; We were given something other than an empty line. Set the
0048D7r 2                               ; parameter variables to zero as the default. There is no line
0048D7r 2                               ; zero, because we're coding for normal, sane humans, not weird
0048D7r 2                               ; computer people. Some commands like "a" will take a "line 0",
0048D7r 2                               ; however. We use the ed_flags bit 7 to signal if we are
0048D7r 2                               ; without parameters.
0048D7r 2  20 rr rr                     jsr xt_zero             ; parameter 1 is NOS ( addr-t u-t 0 )
0048DAr 2  20 rr rr                     jsr xt_zero             ; parameter 2 is TOS ( addr-t u-t 0 0 )
0048DDr 2               
0048DDr 2                               ; We start off by taking care of any parameters. These can be
0048DDr 2                               ; '%' for the complete text, '$' for the last line, a line
0048DDr 2                               ; number, or a line number followed by a ',' and then either
0048DDr 2                               ; the '$' for the last line or another number. (The original
0048DDr 2                               ; Unix ed has more options, but we're ignoring them for the
0048DDr 2                               ; moment.) In pseudocode, what we are doing in this stage looks
0048DDr 2                               ; something like this:
0048DDr 2               
0048DDr 2                               ;        case char = '.':
0048DDr 2                               ;              para1 = current line
0048DDr 2                               ;
0048DDr 2                               ;        case char = '$':
0048DDr 2                               ;              para1 = last line
0048DDr 2                               ;
0048DDr 2                               ;        case char = '%' or ',':
0048DDr 2                               ;              para1 = 1
0048DDr 2                               ;              para2 = last line
0048DDr 2                               ;
0048DDr 2                               ;        case char = ';':
0048DDr 2                               ;              para1 = current line
0048DDr 2                               ;              para2 = last line
0048DDr 2                               ;
0048DDr 2                               ;        case number:
0048DDr 2                               ;              para1 = number
0048DDr 2                               ;              get next char
0048DDr 2                               ;
0048DDr 2                               ;              if char = ',':
0048DDr 2                               ;                      get next char
0048DDr 2                               ;
0048DDr 2                               ;                      case char = '$':
0048DDr 2                               ;                              para2 = last line
0048DDr 2                               ;
0048DDr 2                               ;                      case number:
0048DDr 2                               ;                              para2 = number
0048DDr 2                               ;
0048DDr 2                               ;                      else error
0048DDr 2                               ;
0048DDr 2                               ;              else get previous char
0048DDr 2                               ;
0048DDr 2                               ;        else error
0048DDr 2                               ;
0048DDr 2                               ;        get next char
0048DDr 2                               ;        process command char
0048DDr 2               
0048DDr 2                               ; We use the Y register as an offset to the beginning of the
0048DDr 2                               ; character input buffer (cib) because we're never going to
0048DDr 2                               ; have more than 255 characters of input with ed and we don't
0048DDr 2                               ; want to have to duplicate the complete machinery required for
0048DDr 2                               ; >IN. In other words, >IN has no meaning for ed. This means
0048DDr 2                               ; that every jmp to _check_command must have Y in a defined
0048DDr 2                               ; state, which is different from the rest of Tali Forth.
0048DDr 2               
0048DDr 2                               ; Parameter processing could probably be handled more
0048DDr 2                               ; efficiently with a loop construct similar to the way the
0048DDr 2                               ; commands are taken care of below. We'll revisit this once ed
0048DDr 2                               ; is feature complete, because of the evils of premature
0048DDr 2                               ; optimization.
0048DDr 2               
0048DDr 2               _prefix_dot:
0048DDr 2                               ; --- . --- Designate current line for further operations
0048DDr 2  B2 rr                        lda (cib)
0048DFr 2  C9 2E                        cmp #$2e                ; ASCII '.'
0048E1r 2  D0 3A                        bne _prefix_dollar
0048E3r 2               
0048E3r 2  20 rr rr                     jsr _have_text
0048E6r 2               
0048E6r 2  A5 rr                        lda ed_cur
0048E8r 2  95 02                        sta 2,x
0048EAr 2  A5 rr                        lda ed_cur+1
0048ECr 2  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
0048EEr 2               
0048EEr 2                               ; We have a parameter
0048EEr 2  A9 80                        lda #%10000000
0048F0r 2  04 rr                        tsb ed_flags
0048F2r 2               
0048F2r 2                               ; If we were only given a '.', we print the current line and are
0048F2r 2                               ; done
0048F2r 2  A5 rr                        lda ciblen
0048F4r 2  3A                           dec                     ; sets Z if A was 1
0048F5r 2  D0 03                        bne @next
0048F7r 2               
0048F7r 2                               ; We know that we have some text and the number of the last
0048F7r 2                               ; line was provided by _last_line, so in theory we don't have
0048F7r 2                               ; to check if this is a legal line number. However, we keep one
0048F7r 2                               ; entry point, so the check is repeated further down. Call it
0048F7r 2                               ; paranoia.
0048F7r 2  4C rr rr                     jmp _line_number_only_from_external
0048FAr 2               @next:
0048FAr 2                               ; We have processed the first parameter, and know that we have
0048FAr 2                               ; more than just a dot here. We now need to see if the next
0048FAr 2                               ; character is a comma or a command character. To do this, we
0048FAr 2                               ; need to modify the stack to ( addr-t u-t para1 0 addr u )
0048FAr 2  CA                           dex
0048FBr 2  CA                           dex
0048FCr 2  CA                           dex
0048FDr 2  CA                           dex
0048FEr 2               
0048FEr 2  A5 rr                        lda cib
004900r 2  95 02                        sta 2,x
004902r 2  A5 rr                        lda cib+1
004904r 2  95 03                        sta 3,x
004906r 2               
004906r 2  A5 rr                        lda ciblen
004908r 2  95 00                        sta 0,x
00490Ar 2  A5 rr                        lda ciblen+1
00490Cr 2  95 01                        sta 1,x
00490Er 2               
00490Er 2  20 rr rr                     jsr xt_one_minus        ; ( addr-t u-t para1 0 addr u-1 )
004911r 2  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 u-1 addr )
004914r 2  20 rr rr                     jsr xt_one_plus         ; ( addr-t u-t para1 0 u-1 addr+1 )
004917r 2  20 rr rr                     jsr xt_swap             ; ( addr-t u-t para1 0 addr+1 u-1 )
00491Ar 2               
00491Ar 2  4C rr rr                     jmp _check_for_para2
00491Dr 2               
00491Dr 2               _prefix_dollar:
00491Dr 2                               ; --- $ --- Designate last line for further operations
00491Dr 2  B2 rr                        lda (cib)
00491Fr 2  C9 24                        cmp #'$'
004921r 2  D0 1C                        bne _prefix_percent
004923r 2               
004923r 2  20 rr rr                     jsr _have_text
004926r 2               
004926r 2  E8                           inx
004927r 2  E8                           inx                     ; ( addr-t u-t 0 )
004928r 2               
004928r 2  20 rr rr                     jsr _last_line          ; ( addr-t u-t 0 para1 )
00492Br 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t para1 0 )
00492Er 2               
00492Er 2                               ; We have a parameter
00492Er 2  A9 80                        lda #%10000000
004930r 2  04 rr                        tsb ed_flags
004932r 2               
004932r 2                               ; If we were only given a '$', we print the last line and are
004932r 2                               ; done
004932r 2  A5 rr                        lda ciblen
004934r 2  3A                           dec                     ; sets Z if A was 1
004935r 2  D0 03                        bne @next
004937r 2               
004937r 2                               ; We know that we have some text and the number of the last
004937r 2                               ; line was provided by _last_line, so in theory we don't have
004937r 2                               ; to check if this is a legal line number. However, we keep one
004937r 2                               ; entry point for the moment and repeat the check further down
004937r 2                               ; out of paranoia
004937r 2  4C rr rr                     jmp _line_number_only_from_external
00493Ar 2               @next:
00493Ar 2                               ; We are one character into the input buffer cib, so we advance
00493Ar 2                               ; Y as the index accordingly
00493Ar 2  A0 01                        ldy #01
00493Cr 2               
00493Cr 2  4C rr rr                     jmp _check_command
00493Fr 2               
00493Fr 2               _prefix_percent:
00493Fr 2                               ; --- % and , --- Designate whole text for futher operations
00493Fr 2  B2 rr                        lda (cib)
004941r 2  C9 25                        cmp #$25                ; ASCII '%'
004943r 2  F0 04                        beq _whole_text
004945r 2  C9 2C                        cmp #$2c                ; ASCII ','
004947r 2  D0 17                        bne _prefix_semicolon
004949r 2               
004949r 2               _whole_text:
004949r 2                               ; If there is no text yet, print an error
004949r 2  20 rr rr                     jsr _have_text
00494Cr 2               
00494Cr 2                               ; We have at least one line of text. The first parameter
00494Cr 2                               ; is therefore line one, the second the last line
00494Cr 2  A9 01                        lda #01
00494Er 2  95 02                        sta 2,x                 ; LSB of NOS is para 1
004950r 2  74 03                        stz 3,x                 ; ( addr-t u-t para1 0 )
004952r 2               
004952r 2               _semicolon_entry:
004952r 2                               ; Get the number (not the address) of the last line and
004952r 2                               ; store it as the second parameter
004952r 2  E8                           inx
004953r 2  E8                           inx                     ; DROP ( addr-t u-t para1 )
004954r 2  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
004957r 2               
004957r 2                               ; We have a parameter
004957r 2  A9 80                        lda #%10000000
004959r 2  04 rr                        tsb ed_flags
00495Br 2               
00495Br 2                               ; We are one character into the input buffer cib, so we advance
00495Br 2                               ; Y as the index accordingly
00495Br 2  A0 01                        ldy #01
00495Dr 2               
00495Dr 2  4C rr rr                     jmp _check_command
004960r 2               
004960r 2               _prefix_semicolon:
004960r 2                               ; --- ; --- Designate from current line to end of text
004960r 2  B2 rr                        lda (cib)
004962r 2  C9 3B                        cmp #$3b                ; ASCII ';'
004964r 2  D0 0D                        bne _prefix_number
004966r 2               
004966r 2  20 rr rr                     jsr _have_text
004969r 2               
004969r 2                               ; The first parameter is the current line
004969r 2  A5 rr                        lda ed_cur
00496Br 2  95 02                        sta 2,x
00496Dr 2  A5 rr                        lda ed_cur+1
00496Fr 2  95 03                        sta 3,x                 ; ( addr-t u-t cur 0 )
004971r 2               
004971r 2                               ; The second parameter is the last line. We've done this part
004971r 2                               ; before for the '%' and ',' parameters, so we reuse that code
004971r 2  80 DF                        bra _semicolon_entry
004973r 2               
004973r 2               _prefix_number:
004973r 2                               ; --- <NUM> --- Check if we have been given a number
004973r 2               
004973r 2                               ; We use the built-in Forth routines for this, which involves
004973r 2                               ; calling >NUMBER, which calls UM*, which uses tmp1, tmp2, and
004973r 2                               ; tmp3. So we can't use any of those temporary variables. We
004973r 2                               ; arrive here with ( addr-t u-t 0 0 ), which doesn't help us at
004973r 2                               ; all because the string we are looking at is in ( cib ciblen )
004973r 2               
004973r 2                               ; Set up >NUMBER using CIB and CIBLEN as the location of the
004973r 2                               ; string to check. First, though, add the "accumulator" of
004973r 2                               ; >NUMBER as a double number, that is, to single-cell numbers
004973r 2  20 rr rr                     jsr xt_zero
004976r 2  20 rr rr                     jsr xt_zero             ; ( addr-t u-t 0 0 0 0 )
004979r 2               
004979r 2  CA                           dex
00497Ar 2  CA                           dex
00497Br 2  CA                           dex
00497Cr 2  CA                           dex                     ; ( addr-t u-t 0 0 0 0 ? ? )
00497Dr 2               
00497Dr 2  A5 rr                        lda cib
00497Fr 2  95 02                        sta 2,x
004981r 2  A5 rr                        lda cib+1
004983r 2  95 03                        sta 3,x                 ; ( addr-t u-t 0 0 0 0 cib ? )
004985r 2               
004985r 2  A5 rr                        lda ciblen
004987r 2  95 00                        sta 0,x
004989r 2  A5 rr                        lda ciblen+1
00498Br 2  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 0 0 cib ciblen )
00498Dr 2               
00498Dr 2  20 rr rr                     jsr xt_to_number        ; ( addr-t u-t 0 0 ud addr2 u2 )
004990r 2               
004990r 2                               ; If we converted all the characters in the string (u2 is
004990r 2                               ; zero), then the user just gave us a line number to
004990r 2                               ; jump to and nothing else. Otherwise, take another look
004990r 2  B5 00                        lda 0,x
004992r 2  15 01                        ora 1,x
004994r 2  D0 24                        bne _have_unconverted_chars
004996r 2               
004996r 2                               ; We must have a line number and nothing else. Make this
004996r 2                               ; the current line number and print the line. Remember
004996r 2                               ; that at this point, the line number still could be a zero
004996r 2  E8                           inx
004997r 2  E8                           inx
004998r 2  E8                           inx
004999r 2  E8                           inx                     ; 2DROP ( addr-t u-t 0 0 ud )
00499Ar 2               
00499Ar 2  20 rr rr                     jsr xt_d_to_s           ; D>S ( addr-t u-t 0 0 u )
00499Dr 2  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t u 0 0 )
0049A0r 2               
0049A0r 2  E8                           inx
0049A1r 2  E8                           inx                     ; ( addr-t u-t u 0 ) drop through
0049A2r 2               
0049A2r 2               _line_number_only_from_external:
0049A2r 2  20 rr rr                     jsr xt_swap             ; ( addr-t u-t 0 u )
0049A5r 2               
0049A5r 2  20 rr rr                     jsr _is_valid_line
0049A8r 2  B0 03                        bcs @next
0049AAr 2               
0049AAr 2                               ; This is not a valid line number, so we bail
0049AAr 2  4C rr rr                     jmp _error_2drop
0049ADr 2               @next:
0049ADr 2                               ; Legal line number, so make it the current number
0049ADr 2  20 rr rr                     jsr xt_swap             ; ( addr-t u-t u 0 )
0049B0r 2  20 rr rr                     jsr _para1_to_cur
0049B3r 2               
0049B3r 2                               ; We have a parameter
0049B3r 2  A9 80                        lda #%10000000
0049B5r 2  04 rr                        tsb ed_flags
0049B7r 2               
0049B7r 2  4C rr rr                     jmp _cmd_p_from_external
0049BAr 2               
0049BAr 2               _have_unconverted_chars:
0049BAr 2                               ; We have some unconverted characters left. If none of the
0049BAr 2                               ; characters were converted, we probably just got a
0049BAr 2                               ; command character and need to skip the rest of the prefix
0049BAr 2                               ; processing. In this case, the number of unconverted
0049BAr 2                               ; characters is equal to the length of the string.
0049BAr 2  20 rr rr                     jsr xt_dup              ; ( addr-t u-t 0 0 ud addr2 u2 u2 )
0049BDr 2               
0049BDr 2  CA                           dex
0049BEr 2  CA                           dex                     ; ( addr-t u-t 0 0 ud addr2 u2 u2 ? )
0049BFr 2               
0049BFr 2  A5 rr                        lda ciblen
0049C1r 2  95 00                        sta 0,x
0049C3r 2  A5 rr                        lda ciblen+1
0049C5r 2  95 01                        sta 1,x                 ; ( addr-t u-t 0 0 ud addr2 u2 u2 ciblen )
0049C7r 2               
0049C7r 2  20 rr rr                     jsr xt_equal            ; ( addr-t u-t 0 0 ud addr2 u2 f )
0049CAr 2               
0049CAr 2  B5 00                        lda 0,x
0049CCr 2  15 01                        ora 1,x
0049CEr 2  F0 0E                        beq _no_command_yet
0049D0r 2               
0049D0r 2                               ; The length of the input string is equal to the length of the
0049D0r 2                               ; unprocessed string that >NUMBER returned. Put differently,
0049D0r 2                               ; the first character isn't a number. We know that it isn't '$'
0049D0r 2                               ; or '%' either, so we assume that it's a command character.
0049D0r 2               
0049D0r 2                               ; Clear up the stack and process that command character
0049D0r 2  8A                           txa
0049D1r 2  18                           clc
0049D2r 2  69 0A                        adc #10
0049D4r 2  AA                           tax                     ; ( addr-t u-t 0 0 )
0049D5r 2               
0049D5r 2                               ; If we weren't given a number, this means we didn't explicitly
0049D5r 2                               ; get a 0 either. So we don't have a parameter. This is the
0049D5r 2                               ; default case, but out of paranoia we explicity clear the flag
0049D5r 2  A9 80                        lda #%10000000
0049D7r 2  14 rr                        trb ed_flags
0049D9r 2               
0049D9r 2                               ; We don't have any offset, so we go with Y as zero
0049D9r 2  A0 00                        ldy #00
0049DBr 2               
0049DBr 2  4C rr rr                     jmp _check_command
0049DEr 2               
0049DEr 2               _no_command_yet:
0049DEr 2                               ; There actually seems to be a parameter number present.
0049DEr 2                               ; Save the number we converted as the first parameter. We
0049DEr 2                               ; arrive here with ( addr-t u-t 0 0 ud addr2 u2 f ) from
0049DEr 2                               ; >NUMBER. To avoid too long stack comments, we leave the
0049DEr 2                               ; target addresses out in this next code segment.
0049DEr 2  E8                           inx
0049DFr 2  E8                           inx                     ; ( ... 0 0 ud addr2 u2 )
0049E0r 2               
0049E0r 2  20 rr rr                     jsr xt_to_r             ; >R ( ... 0 0 ud addr2 ) (R: u2)
0049E3r 2  20 rr rr                     jsr xt_not_rote         ; -ROT ( ... 0 0 addr2 ud ) (R: u2)
0049E6r 2  20 rr rr                     jsr xt_d_to_s           ; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
0049E9r 2               
0049E9r 2  B5 00                        lda 0,x                 ; LSB
0049EBr 2  95 06                        sta 6,x
0049EDr 2  B5 01                        lda 1,x                 ; MSB
0049EFr 2  95 07                        sta 7,x                 ; ( ... para1 0 addr2 para1 ) (R: u2)
0049F1r 2               
0049F1r 2  E8                           inx
0049F2r 2  E8                           inx                     ; ( addr-t u-t para1 0 addr2 ) (R: u2)
0049F3r 2  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
0049F6r 2               
0049F6r 2                               ; We have a parameter
0049F6r 2  A9 80                        lda #%10000000
0049F8r 2  04 rr                        tsb ed_flags
0049FAr 2               
0049FAr 2               _check_for_para2:
0049FAr 2                               ; That was the first parameter. If the next character is
0049FAr 2                               ; a comma, then there is a second parameter (another number
0049FAr 2                               ; or '$'). Otherwise we expect a command. This is the entry
0049FAr 2                               ; point if the first character was a dot (eg '.,3p')
0049FAr 2  A1 02                        lda (2,x)
0049FCr 2               
0049FCr 2  C9 2C                        cmp #$2c                ; ASCII code for ',' (comma)
0049FEr 2  F0 0D                        beq _got_comma
004A00r 2               
004A00r 2                               ; It's not a comma, so it's going to be a command character.
004A00r 2                               ; We need to figure out how many digits our number has so
004A00r 2                               ; we can adjust Y as the offset. We don't have to do this with
004A00r 2                               ; 16 bit because no input string is going to be that long
004A00r 2  38                           sec
004A01r 2  A5 rr                        lda ciblen
004A03r 2  F5 00                        sbc 0,x
004A05r 2  A8                           tay
004A06r 2               
004A06r 2                               ; Remove the leftover stuff from >NUMBER
004A06r 2  E8                           inx
004A07r 2  E8                           inx
004A08r 2  E8                           inx
004A09r 2  E8                           inx                     ; 2DROP ( addr-t u-t para1 0 )
004A0Ar 2               
004A0Ar 2  4C rr rr                     jmp _check_command
004A0Dr 2               
004A0Dr 2               _got_comma:
004A0Dr 2                               ; It's a comma, so we have a second parameter. The next
004A0Dr 2                               ; character can either be '$' to signal the end of the text
004A0Dr 2                               ; or another number. First, though, move to that next char
004A0Dr 2  F6 02                        inc 2,x
004A0Fr 2  D0 02                        bne @next1
004A11r 2  F6 03                        inc 3,x                 ; ( addr-t u-t para1 0 addr2+1 u2 )
004A13r 2               @next1:
004A13r 2  B5 01                        lda 1,x
004A15r 2  F0 02                        beq @next2
004A17r 2  D6 01                        dec 1,x
004A19r 2               @next2:
004A19r 2  D6 00                        dec 0,x                 ; ( addr-t u-t para1 0 addr2+1 u2-1 )
004A1Br 2               
004A1Br 2                               ; See if this is an end-of-line '$'
004A1Br 2  A1 02                        lda (2,x)
004A1Dr 2  C9 24                        cmp #$24                ; ASCII for '$'
004A1Fr 2  D0 14                        bne _para2_not_dollar
004A21r 2               
004A21r 2                               ; It's a dollar sign, which means para2 is the number of the
004A21r 2                               ; last line of the text. We need to adjust Y as the offset. We
004A21r 2                               ; assume that no command line will be longer than 255
004A21r 2                               ; characters in ed so we can get away with just looking at
004A21r 2                               ; the LSB
004A21r 2  38                           sec
004A22r 2  A5 rr                        lda ciblen
004A24r 2  F5 02                        sbc 2,x
004A26r 2  A8                           tay
004A27r 2               
004A27r 2                               ; However, we need to move Y up by one because we were on the
004A27r 2                               ; '$' and not on the character after that
004A27r 2  C8                           iny
004A28r 2  5A                           phy
004A29r 2               
004A29r 2                               ; Dump all the stuff from >NUMBER off the stack. This saves
004A29r 2                               ; one byte compared to six INX instructions, and a byte saved
004A29r 2                               ; is a byte earned.
004A29r 2  8A                           txa
004A2Ar 2  18                           clc
004A2Br 2  69 06                        adc #06
004A2Dr 2  AA                           tax                     ; ( addr-t u-t para1 )
004A2Er 2               
004A2Er 2  20 rr rr                     jsr _last_line          ; ( addr-t u-t para1 para2 )
004A31r 2               
004A31r 2  7A                           ply
004A32r 2  4C rr rr                     jmp _check_command
004A35r 2               
004A35r 2               _para2_not_dollar:
004A35r 2                               ; It's not a dollar sign, so it is either another number or an
004A35r 2                               ; error. We try for a number first. We arrive here with ( para1
004A35r 2                               ; 0 addr2+1 u2-1 ), which u2-1 pointing to the first mystery
004A35r 2                               ; character after the comma. Again, we skip the ( addr-t u-t )
004A35r 2                               ; at the beginning of the stack comment here.
004A35r 2  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 addr2+1 ) (R: u2-1)
004A38r 2  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
004A3Br 2  20 rr rr                     jsr xt_zero             ; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
004A3Er 2  20 rr rr                     jsr xt_rot              ; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
004A41r 2  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 0 0 addr2+1 u2-1)
004A44r 2               
004A44r 2                               ; We'll need a copy of the length of the rest of the string to
004A44r 2                               ; see if we've actually done any work
004A44r 2  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
004A47r 2  20 rr rr                     jsr xt_to_r             ; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
004A4Ar 2               
004A4Ar 2  20 rr rr                     jsr xt_to_number        ; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
004A4Dr 2               
004A4Dr 2                               ; If the original string and the leftover string have the same
004A4Dr 2                               ; length, then nothing was converted and we have an error
004A4Dr 2  20 rr rr                     jsr xt_dup              ; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
004A50r 2  20 rr rr                     jsr xt_r_from           ; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
004A53r 2  20 rr rr                     jsr xt_equal            ; = ( ... para1 0 ud addr3 u3 f )
004A56r 2               
004A56r 2  B5 00                        lda 0,x
004A58r 2  15 01                        ora 1,x
004A5Ar 2  F0 08                        beq _second_number
004A5Cr 2               
004A5Cr 2                               ; The strings are the same length, so nothing was converted, so
004A5Cr 2                               ; we have an error. We have to get all that stuff off the
004A5Cr 2                               ; stack first
004A5Cr 2  8A                           txa
004A5Dr 2  18                           clc
004A5Er 2  69 0C                        adc #12
004A60r 2  AA                           tax                     ; back to ( addr-t u-t )
004A61r 2               
004A61r 2  4C rr rr                     jmp _error
004A64r 2               
004A64r 2               _second_number:
004A64r 2                               ; We have a second number, so we add it to para2. We arrive here
004A64r 2                               ; with ( para1 0 ud addr3 u3 f )
004A64r 2  E8                           inx
004A65r 2  E8                           inx                     ; ( addr-t u-t para1 0 ud addr3 u3 )
004A66r 2               
004A66r 2                               ; Calculate the offset for Y
004A66r 2  38                           sec
004A67r 2  A5 rr                        lda ciblen
004A69r 2  F5 00                        sbc 0,x
004A6Br 2  48                           pha
004A6Cr 2               
004A6Cr 2                               ; Clean up the stack
004A6Cr 2  20 rr rr                     jsr xt_two_drop         ; 2DROP ( addr-t u-t para1 0 ud )
004A6Fr 2  20 rr rr                     jsr xt_d_to_s           ; D>S  ( addr-t u-t para1 0 para2 )
004A72r 2  20 rr rr                     jsr xt_nip              ; NIP ( addr-t u-t para1 para2 )
004A75r 2               
004A75r 2  7A                           ply
004A76r 2               
004A76r 2                               ; fall through to _check_command
004A76r 2               
004A76r 2               _check_command:
004A76r 2                               ; At this point, we assume that we have handled any parameters
004A76r 2                               ; which are now in their place on the stack, which must have
004A76r 2                               ; the format ( addr-t u-t para1 para2 ). Also, any offset to CIB
004A76r 2                               ; is going to be in Y. Bit 7 in ed_flags signals if we have
004A76r 2                               ; a parameter or not.
004A76r 2               
004A76r 2                               ; Command character checking works by comparing the char we
004A76r 2                               ; have at CIB+Y with a list of legal characters. The index in
004A76r 2                               ; the list is the index of the command's routine in a jump
004A76r 2                               ; table. The list itself is zero-terminated, which is okay
004A76r 2                               ; because we've taken care of any legal parameters.
004A76r 2  B1 rr                        lda (cib),y             ; get mystery char from input
004A78r 2  85 rr                        sta tmp1
004A7Ar 2               
004A7Ar 2                               ; We're going to need X for the jump table, so it has to
004A7Ar 2                               ; take a break from being the Data Stack Pointer (DSP). Pushing
004A7Ar 2                               ; X to the stack uses less space than storing in the reserved
004A7Ar 2                               ; space on the Zero Page
004A7Ar 2  DA                           phx
004A7Br 2  A2 00                        ldx #00
004A7Dr 2               _cmd_loop:
004A7Dr 2  BD rr rr                     lda ed_cmd_list,x
004A80r 2  F0 07                        beq _illegal_command    ; zero marks end of list
004A82r 2               
004A82r 2  C5 rr                        cmp tmp1
004A84r 2  F0 07                        beq _found_cmd
004A86r 2               
004A86r 2                               ; No match, next char
004A86r 2  E8                           inx
004A87r 2  80 F4                        bra _cmd_loop
004A89r 2               
004A89r 2               _illegal_command:
004A89r 2                               ; Whatever the user gave us, we don't recognize it
004A89r 2  FA                           plx
004A8Ar 2               
004A8Ar 2  4C rr rr                     jmp _error_2drop
004A8Dr 2               
004A8Dr 2               _found_cmd:
004A8Dr 2                               ; We have a command match. Because this is the 65c02 and not
004A8Dr 2                               ; the 65816, we can only use JMP (addr,x) and not a subroutine
004A8Dr 2                               ; jump. That sucks.
004A8Dr 2  8A                           txa
004A8Er 2  0A                           asl
004A8Fr 2  AA                           tax                     ; X * 2 for table
004A90r 2               
004A90r 2                               ; Note we're jumping with the DSP still on the stack, so each
004A90r 2                               ; command routine has to pull it into X the very first thing
004A90r 2                               ; with its very own PLX. There doesn't seem to be a sane way to
004A90r 2                               ; avoid this.
004A90r 2  7C rr rr                     jmp (ed_cmd_table,x)
004A93r 2               
004A93r 2               _next_command:
004A93r 2                               ; Clean up the stack and return to the input loop. We
004A93r 2                               ; arrive here with ( addr-t u-t para1 para2 ). The called
004A93r 2                               ; command routines have taken care of putting the DSP (that's
004A93r 2                               ; X) back the way it should be
004A93r 2  E8                           inx
004A94r 2  E8                           inx
004A95r 2  E8                           inx
004A96r 2  E8                           inx                     ; ( addr-t u-t ) Fall through
004A97r 2               
004A97r 2               _next_command_empty:
004A97r 2                               ; The beginning of the input loop takes care of resetting the
004A97r 2                               ; parameter flag
004A97r 2  4C rr rr                     jmp _input_loop
004A9Ar 2               
004A9Ar 2               _all_done:
004A9Ar 2                               ; That's enough for ed today. We have to clear out the input
004A9Ar 2                               ; buffer or else the Forth main main loop will react to the
004A9Ar 2                               ; last input command
004A9Ar 2  64 rr                        stz ciblen
004A9Cr 2  64 rr                        stz ciblen+1
004A9Er 2               
004A9Er 2                               ; Clean up the stack
004A9Er 2  20 rr rr                     jsr xt_two_drop                 ; 2DROP ( addr-t u-t )
004AA1r 2               
004AA1r 2  60                           rts
004AA2r 2               
004AA2r 2               
004AA2r 2               ; === COMMAND ROUTINES ====
004AA2r 2               
004AA2r 2               ; We enter all command subroutines with ( addr-t u-t para1 para2 ) and the DSP
004AA2r 2               ; still on the Return Stack. This means that the first oder of business is to
004AA2r 2               ; restore the DSP with PLX -- remember this when you add new commands. At this
004AA2r 2               ; point, we don't need the offset in Y anymore so we are free to use it as we
004AA2r 2               ; please.
004AA2r 2               
004AA2r 2               ; There is potential to rewrite many of the command routines with an abstract
004AA2r 2               ; construct in the form of (pseudocode):
004AA2r 2               
004AA2r 2               ;       f = cmd         ; command such as d, p, n, as a function
004AA2r 2               ;       map f range(para1, para2)
004AA2r 2               
004AA2r 2               ; That is, have one routine with a looping structure and pass the actual work
004AA2r 2               ; as a function. However, this is 8-bit assembler and not, say, Haskell, so
004AA2r 2               ; that abstraction will wait for a future round of refracturing when we have
004AA2r 2               ; everything complete and working.
004AA2r 2               
004AA2r 2               ; -------------------------
004AA2r 2               _cmd_a:
004AA2r 2                       ; a -- Add text after current/given line. If no line is given, we use
004AA2r 2                       ; the current line. We accept the number '0' and then start adding at
004AA2r 2                       ; the very beginning. The second parameter is always ignored. This
004AA2r 2                       ; routine is used by i as well.
004AA2r 2  FA                           plx
004AA3r 2               
004AA3r 2                               ; We don't care about para2, because a just adds stuff starting
004AA3r 2                               ; the line we were given
004AA3r 2  E8                           inx
004AA4r 2  E8                           inx                     ;  DROP ( addr-t u-t para1 )
004AA5r 2               
004AA5r 2                               ; If we weren't given a parameter, make the current line the
004AA5r 2                               ; parameter
004AA5r 2  24 rr                        bit ed_flags
004AA7r 2  30 08                        bmi _cmd_a_have_para
004AA9r 2               
004AA9r 2  A5 rr                        lda ed_cur
004AABr 2  95 00                        sta 0,x
004AADr 2  A5 rr                        lda ed_cur+1
004AAFr 2  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
004AB1r 2               
004AB1r 2               _entry_cmd_i:
004AB1r 2                               ; This is where i enters with a parameter that is calculated to
004AB1r 2                               ; be one before the current line, or given line, or so that we
004AB1r 2                               ; accept 0. We are ( addr-t u-t num )
004AB1r 2               
004AB1r 2               _cmd_a_have_para:
004AB1r 2  20 rr rr                     jsr _num_to_addr        ;  ( addr-t u-t addr1 )
004AB4r 2  20 rr rr                     jsr xt_cr
004AB7r 2               
004AB7r 2               _next_string_loop:
004AB7r 2                               ; This is where we land when we are continuing in with another
004AB7r 2                               ; string after the first one. ( addr-t u-t addr1 )
004AB7r 2  20 rr rr                     jsr _get_input
004ABAr 2               
004ABAr 2                               ; If there is only one character and that character is a
004ABAr 2                               ; dot, we're done with adding text and switch back to command
004ABAr 2                               ; mode
004ABAr 2  B2 rr                        lda (cib)
004ABCr 2  C9 2E                        cmp #$2e                ; ASCII for '.'
004ABEr 2  D0 16                        bne _add_line
004AC0r 2               
004AC0r 2                               ; So it's a dot, but that the only character in the line?
004AC0r 2                               ; We want the length to be one character exactly
004AC0r 2  A4 rr                        ldy ciblen
004AC2r 2  C0 01                        cpy #01
004AC4r 2  D0 10                        bne _add_line
004AC6r 2               
004AC6r 2  A4 rr                        ldy ciblen+1
004AC8r 2  D0 0C                        bne _add_line
004ACAr 2               
004ACAr 2                               ; Yes, it is a dot, so we're done adding lines.
004ACAr 2  E8                           inx
004ACBr 2  E8                           inx
004ACCr 2               
004ACCr 2                               ; The string is stored and the new node is full. Time to set the
004ACCr 2                               ; changed flag
004ACCr 2  A9 40                        lda #%01000000
004ACEr 2  04 rr                        tsb ed_flags
004AD0r 2               
004AD0r 2  20 rr rr                     jsr xt_cr
004AD3r 2  4C rr rr                     jmp _input_loop
004AD6r 2               
004AD6r 2               _add_line:
004AD6r 2                               ; Break the linked list so we can insert another node
004AD6r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t addr1 addr1 )
004AD9r 2  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t addr1 addr1 here )
004ADCr 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 here addr1 )
004ADFr 2  20 rr rr                     jsr xt_fetch            ; @  ( addr-t u-t addr1 here addr2 )
004AE2r 2  20 rr rr                     jsr xt_comma            ; ,  ( addr-t u-t addr1 here )
004AE5r 2               
004AE5r 2                               ; We're going to need that HERE for the next line if more
004AE5r 2                               ; than one line is added. This is a good time to save it on
004AE5r 2                               ; the stack
004AE5r 2  20 rr rr                     jsr xt_tuck             ; TUCK ( addr-t u-t here addr1 here )
004AE8r 2               
004AE8r 2                               ; We have now saved the link to the next node at HERE, which is
004AE8r 2                               ; where the CP was pointing. CP has been advanced by one cell,
004AE8r 2                               ; but we still have the original as HERE on the stack. That
004AE8r 2                               ; address now has to go where addr2 was before.
004AE8r 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t here here addr1 )
004AEBr 2  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
004AEEr 2               
004AEEr 2                               ; Thus concludes the mucking about with node links. Now we have
004AEEr 2                               ; to create a new header. The CP we access with HERE points to
004AEEr 2                               ; the cell after the new node address, which is where we want
004AEEr 2                               ; to put ( ) for the new string
004AEEr 2  20 rr rr                     jsr xt_here             ; HERE ( addr-t u-t here here2)
004AF1r 2               
004AF1r 2                               ; Reserve two cells (four bytes on the 65c02) for the ( addr u )
004AF1r 2                               ; of the new string
004AF1r 2  A5 rr                        lda cp
004AF3r 2  18                           clc
004AF4r 2  69 04                        adc #04
004AF6r 2  85 rr                        sta cp
004AF8r 2  90 02                        bcc @next1
004AFAr 2  E6 rr                        inc cp+1
004AFCr 2               @next1:
004AFCr 2                               ; HERE now points to after the new header. Since we're really
004AFCr 2                               ; going to add something, we can increase the current line
004AFCr 2                               ; number
004AFCr 2  E6 rr                        inc ed_cur
004AFEr 2  D0 02                        bne @next2
004B00r 2  E6 rr                        inc ed_cur+1
004B02r 2               @next2:
004B02r 2                               ; We have the new line sitting in ( cib ciblen ) and need to
004B02r 2                               ; a) move it somewhere safe and b) get ready for the next
004B02r 2                               ; line. We arrive here with ( addr-t u-t here here2 ), where here2
004B02r 2                               ; is where the new string needs to be. The MOVE command we're
004B02r 2                               ; going to use has the format ( addr1 addr2 u )
004B02r 2               
004B02r 2  20 rr rr                     jsr xt_here     ; HERE ( addr-t u-t here here2 here3 )
004B05r 2  20 rr rr                     jsr xt_dup      ; DUP ( addr-t u-t here here2 here3 here3 )
004B08r 2               
004B08r 2  CA                           dex
004B09r 2  CA                           dex             ; ( addr-t u-t here here2 here3 here3 ? )
004B0Ar 2  A5 rr                        lda cib
004B0Cr 2  95 00                        sta 0,x
004B0Er 2  A5 rr                        lda cib+1
004B10r 2  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 here3 cib )
004B12r 2               
004B12r 2  20 rr rr                     jsr xt_swap     ; SWAP ( addr-t u-t here here2 here3 cib here3 )
004B15r 2               
004B15r 2  CA                           dex
004B16r 2  CA                           dex             ; ( addr-t u-t here here2 here3 cib here3 ? )
004B17r 2  A5 rr                        lda ciblen
004B19r 2  95 00                        sta 0,x
004B1Br 2  A5 rr                        lda ciblen+1
004B1Dr 2  95 01                        sta 1,x         ; ( addr-t u-t here here2 here3 cib here3 ciblen )
004B1Fr 2               
004B1Fr 2  20 rr rr                     jsr xt_move     ; ( addr-t u-t here here2 here3 )
004B22r 2               
004B22r 2                               ; We need to adjust CP be the length of the string
004B22r 2  18                           clc
004B23r 2  A5 rr                        lda cp
004B25r 2  65 rr                        adc ciblen
004B27r 2  85 rr                        sta cp
004B29r 2  90 06                        bcc @next3
004B2Br 2  A5 rr                        lda cp+1
004B2Dr 2  65 rr                        adc ciblen+1
004B2Fr 2  85 rr                        sta cp+1
004B31r 2               @next3:
004B31r 2                               ; The string is now moved safely out of the input buffer to the
004B31r 2                               ; main memory at ( here3 ciblin ). Now we have to fix that
004B31r 2                               ; fact in the header. We start with the address.
004B31r 2  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t here here2 here3 here2 )
004B34r 2  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here here2 )
004B37r 2               
004B37r 2  20 rr rr                     jsr xt_one_plus         ; 1+
004B3Ar 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t u-t here here2+2 )
004B3Dr 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t here here2+2 here2+2 )
004B40r 2               
004B40r 2  A5 rr                        lda ciblen
004B42r 2  95 02                        sta 2,x
004B44r 2  A5 rr                        lda ciblen+1
004B46r 2  95 03                        sta 3,x                 ; ( addr-t u-t here ciblen here2+2 )
004B48r 2               
004B48r 2  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t here )
004B4Br 2               
004B4Br 2                               ; Add a line feed for visuals
004B4Br 2  20 rr rr                     jsr xt_cr
004B4Er 2               
004B4Er 2                               ; Remeber that original HERE we've been dragging along all the
004B4Er 2                               ; time? Now we find out why. We return to the loop to pick up
004B4Er 2                               ; the next input
004B4Er 2  4C rr rr                     jmp _next_string_loop
004B51r 2               
004B51r 2               ; -------------------------
004B51r 2               _cmd_d:
004B51r 2                       ; d -- Delete one or more lines. This might have to be coded as
004B51r 2                       ; a subroutine because other commands such as 'c' might be easier to
004B51r 2                       ; implement that way. Note that a lot of this code is very similar to
004B51r 2                       ; the loop for 'p'. We arrive here with ( addr-t u-t para1 para2 )
004B51r 2  FA                           plx
004B52r 2               
004B52r 2  20 rr rr                     jsr _have_text
004B55r 2  20 rr rr                     jsr _no_line_zero
004B58r 2               
004B58r 2                               ; At least the first line is valid. Most common case is one
004B58r 2                               ; line, so we check to see if we even have a second parameter.
004B58r 2  B5 00                        lda 0,x
004B5Ar 2  15 01                        ora 1,x
004B5Cr 2  D0 08                        bne @next
004B5Er 2               
004B5Er 2                               ; The second parameter is a zero, so delete one line
004B5Er 2  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 0 para1 )
004B61r 2  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 0 )
004B64r 2  80 33                        bra _cmd_d_done
004B66r 2               @next:
004B66r 2                               ; We have been given a range. Make sure that the second
004B66r 2                               ; parameter is legal. We arrive here with ( addr-t u-t para1 para2 )
004B66r 2  20 rr rr                     jsr _is_valid_line      ; result is in C flag
004B69r 2  B0 03                        bcs _cmd_d_loop
004B6Br 2               
004B6Br 2                               ; para2 is not valid. Complain and abort
004B6Br 2  4C rr rr                     jmp _error_2drop
004B6Er 2               
004B6Er 2               _cmd_d_loop:
004B6Er 2                               ; Seems to be a legal range. Walk through and delete If para1
004B6Er 2                               ; is larger than para2, we're done. Note that Unix ed throws an
004B6Er 2                               ; error if we start out that way, we might do that in future as
004B6Er 2                               ; well. This is not the same code as for 'p', because we have
004B6Er 2                               ; to delete from the back
004B6Er 2  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
004B71r 2  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
004B74r 2               
004B74r 2  B5 00                        lda 0,x
004B76r 2  15 01                        ora 1,x
004B78r 2  D0 0D                        bne _cmd_d_done_with_flag
004B7Ar 2               
004B7Ar 2                               ; Para2 is still larger or the same size as para1, so we
004B7Ar 2                               ; continue
004B7Ar 2  E8                           inx
004B7Br 2  E8                           inx                     ; Get rid of the flag from >
004B7Cr 2               
004B7Cr 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para2 para2 )
004B7Fr 2  20 rr rr                     jsr _cmd_d_common       ; ( addr-t u-t para1 para2 )
004B82r 2  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t para1 para2-1 )
004B85r 2               
004B85r 2  80 E7                        bra _cmd_d_loop
004B87r 2               
004B87r 2               _cmd_d_done_with_flag:
004B87r 2  E8                           inx                     ; ( addr-t u-t para1 para2 )
004B88r 2  E8                           inx
004B89r 2               
004B89r 2                               ; The current line is set to the first line minus
004B89r 2                               ; one. Since we don't accept '0d', this at least
004B89r 2                               ; hast to be one
004B89r 2  B5 02                        lda 2,x
004B8Br 2  D0 02                        bne @next
004B8Dr 2  D6 03                        dec 3,x
004B8Fr 2               @next:
004B8Fr 2  D6 02                        dec 2,x
004B91r 2               
004B91r 2  B5 02                        lda 2,x
004B93r 2  85 rr                        sta ed_cur
004B95r 2  B5 03                        lda 3,x
004B97r 2  85 rr                        sta ed_cur+1            ; drop through to _cmd_d_done
004B99r 2               
004B99r 2               _cmd_d_done:
004B99r 2                               ; Text has changed, set flag
004B99r 2  A9 40                        lda #%01000000
004B9Br 2  04 rr                        tsb ed_flags
004B9Dr 2               
004B9Dr 2  20 rr rr                     jsr xt_cr
004BA0r 2               
004BA0r 2  4C rr rr                     jmp _next_command
004BA3r 2               
004BA3r 2               _cmd_d_common:
004BA3r 2                       ; Internal subroutine to delete a single line when given the line
004BA3r 2                       ; number TOS. Consumes TOS. What we do is take the link to the next
004BA3r 2                       ; node and put it in the previous node. The caller is responsible
004BA3r 2                       ; for setting ed_changed. We arrive here with ( u )
004BA3r 2               
004BA3r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t u u )
004BA6r 2  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t u addr )
004BA9r 2  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t u addr1 )
004BACr 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr1 u )
004BAFr 2  20 rr rr                     jsr xt_one_minus        ; 1- ( addr-t u-t addr1 u-1 )
004BB2r 2  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr1 addr-1 )
004BB5r 2  20 rr rr                     jsr xt_store            ; ! ( addr-t u-t )
004BB8r 2               
004BB8r 2  60                           rts
004BB9r 2               
004BB9r 2               ; -------------------------
004BB9r 2               _cmd_equ:
004BB9r 2                       ; = --- Print the given line number or the current line number if no
004BB9r 2                       ; value is given. This is useful if you want to know what the number of
004BB9r 2                       ; the last line is ("$=")
004BB9r 2  FA                           plx
004BBAr 2               
004BBAr 2                               ; If we don't have a text, we follow Unix ed's example and
004BBAr 2                               ; print a zero. It would seem to make more sense to throw an
004BBAr 2                               ; error, but who are we to argue with Unix.
004BBAr 2  A5 rr                        lda ed_head
004BBCr 2  05 rr                        ora ed_head+1
004BBEr 2  D0 08                        bne _cmd_equ_have_text
004BC0r 2               
004BC0r 2                               ; Fake it: load 0 as para2 and then print. The 0 goes in a new
004BC0r 2                               ; line just like with Unix ed
004BC0r 2  CA                           dex
004BC1r 2  CA                           dex
004BC2r 2  74 00                        stz 0,x
004BC4r 2  74 01                        stz 1,x                 ; ( addr-t u-t para1 para2 0 )
004BC6r 2  80 21                        bra _cmd_equ_done
004BC8r 2               
004BC8r 2               _cmd_equ_have_text:
004BC8r 2                               ; We have taken care of the case where we don't have a text. If
004BC8r 2                               ; we have a line zero, it is explicit, and we don't do that
004BC8r 2  20 rr rr                     jsr _no_line_zero
004BCBr 2               
004BCBr 2                               ; If we have no parameters, just print the current line number
004BCBr 2  24 rr                        bit ed_flags
004BCDr 2  30 0C                        bmi _cmd_equ_have_para
004BCFr 2               
004BCFr 2  CA                           dex
004BD0r 2  CA                           dex                     ; ( addr-t u-t para1 para2 ? )
004BD1r 2  A5 rr                        lda ed_cur
004BD3r 2  95 00                        sta 0,x
004BD5r 2  A5 rr                        lda ed_cur+1
004BD7r 2  95 01                        sta 1,x
004BD9r 2               
004BD9r 2  80 0E                        bra _cmd_equ_done       ; ( addr-t u-t para1 para2 cur )
004BDBr 2               
004BDBr 2               _cmd_equ_have_para:
004BDBr 2                               ; We have at least one parameter, and we know it is not zero.
004BDBr 2                               ; We follow the behavior of Unix ed here: If there is one
004BDBr 2                               ; parameter, we print its line number. If there are two
004BDBr 2                               ; separated by a comma (etc), we print the second line number
004BDBr 2                               ; of the range
004BDBr 2  B5 00                        lda 0,x
004BDDr 2  15 01                        ora 1,x
004BDFr 2  D0 05                        bne _cmd_equ_two_paras
004BE1r 2               
004BE1r 2                               ; We've got one parameter
004BE1r 2  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1)
004BE4r 2  80 03                        bra _cmd_equ_done
004BE6r 2               
004BE6r 2               _cmd_equ_two_paras:
004BE6r 2  20 rr rr                     jsr xt_dup              ; ( addr-t u-t para1 para2 para2) drop through
004BE9r 2               
004BE9r 2               _cmd_equ_done:
004BE9r 2  20 rr rr                     jsr xt_cr               ; number goes on new line
004BECr 2  20 rr rr                     jsr xt_u_dot            ; ( addr-t u-t para1 para2 )
004BEFr 2  20 rr rr                     jsr xt_cr
004BF2r 2               
004BF2r 2  4C rr rr                     jmp _next_command
004BF5r 2               
004BF5r 2               
004BF5r 2               ; -------------------------
004BF5r 2               _cmd_f:
004BF5r 2                       ; f -- Print the address that a write command ("w") will go to or set
004BF5r 2                       ; it. If no parameter was passed, we print the address we have on hand,
004BF5r 2                       ; with a parameter, we set that to the new address. We accept a zero,
004BF5r 2                       ; though that would be a weird place to write, but we do need a text
004BF5r 2  FA                           plx
004BF6r 2               
004BF6r 2  24 rr                        bit ed_flags
004BF8r 2  30 17                        bmi _cmd_f_have_para
004BFAr 2               
004BFAr 2  20 rr rr                     jsr xt_cr
004BFDr 2               
004BFDr 2                               ; No parameters, just a naked "f", so print the address buried
004BFDr 2                               ; at the fourth position of the stack: We arrive here with
004BFDr 2                               ; ( addr-t u-t 0 0 )
004BFDr 2  20 rr rr                     jsr xt_to_r             ; >R   ( addr-t u-t 0 ) ( R: 0 )
004C00r 2  20 rr rr                     jsr xt_rot              ; ROT  ( u-t 0 addr-t ) ( R: 0 )
004C03r 2  20 rr rr                     jsr xt_dup              ; DUP  ( u-t 0 addr-t addr-t ) ( R: 0 )
004C06r 2  20 rr rr                     jsr xt_u_dot            ; U.   ( u-t 0 addr-t ) ( R: 0 )
004C09r 2  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-t u-t 0 ) ( R: 0 )
004C0Cr 2  20 rr rr                     jsr xt_r_from           ; R>   ( addr-t u-t 0 0 )
004C0Fr 2               
004C0Fr 2  80 11                        bra _cmd_f_done
004C11r 2               
004C11r 2               _cmd_f_have_para:
004C11r 2                               ; We do no sanity tests at all. This is Forth, if the user
004C11r 2                               ; wants to blow up the Zero Page and the Stack, sure, go right
004C11r 2                               ; ahead, whatever.
004C11r 2  20 rr rr                     jsr xt_over
004C14r 2  20 rr rr                     jsr xt_cr
004C17r 2  20 rr rr                     jsr xt_u_dot
004C1Ar 2               
004C1Ar 2  B5 02                        lda 2,x
004C1Cr 2  95 06                        sta 6,x
004C1Er 2  B5 03                        lda 3,x
004C20r 2  95 07                        sta 7,x                 ; fall through to _cmd_f_done
004C22r 2               
004C22r 2               _cmd_f_done:
004C22r 2  20 rr rr                     jsr xt_cr
004C25r 2               
004C25r 2  4C rr rr                     jmp _next_command
004C28r 2               
004C28r 2               
004C28r 2               ; -------------------------
004C28r 2               _cmd_i:
004C28r 2                       ; i --- Add text before current line. We allow '0i' and 'i' just like
004C28r 2                       ; the Unix ed. Note that this routine just prepares the line numbers so
004C28r 2                       ; we can reuse most of the code from a.
004C28r 2  FA                           plx
004C29r 2               
004C29r 2                               ; We don't care about para2, because i just adds stuff before
004C29r 2                               ; the line we were given.
004C29r 2  E8                           inx
004C2Ar 2  E8                           inx                     ;  DROP ( addr-t u-t para1 )
004C2Br 2               
004C2Br 2                               ; If we weren't given a parameter, make the current line the
004C2Br 2                               ; parameter
004C2Br 2  24 rr                        bit ed_flags
004C2Dr 2  30 08                        bmi _cmd_i_have_para
004C2Fr 2               
004C2Fr 2                               ; No parameter, take current line
004C2Fr 2  A5 rr                        lda ed_cur
004C31r 2  95 00                        sta 0,x
004C33r 2  A5 rr                        lda ed_cur+1
004C35r 2  95 01                        sta 1,x                 ;  ( addr-t u-t cur ) drop through
004C37r 2               
004C37r 2               _cmd_i_have_para:
004C37r 2                               ; If the parameter is zero, we skip the next part and behave
004C37r 2                               ; completely like the "a" command
004C37r 2  B5 00                        lda 0,x
004C39r 2  15 01                        ora 1,x
004C3Br 2  F0 09                        beq _cmd_i_done
004C3Dr 2               
004C3Dr 2                               ; We have some other line number, so we start one above it
004C3Dr 2  20 rr rr                     jsr xt_one_minus        ; 1-  ( addr-t u-t para1-1 )
004C40r 2  20 rr rr                     jsr xt_zero             ; 0   ( addr-t u-t para1-1 0 )
004C43r 2  20 rr rr                     jsr xt_max              ; MAX ( addr-t u-t para1-1 | 0 )
004C46r 2               _cmd_i_done:
004C46r 2  4C rr rr                     jmp _entry_cmd_i
004C49r 2               
004C49r 2               
004C49r 2               ; -------------------------
004C49r 2               _cmd_n:
004C49r 2                       ; n -- Print lines with a line number. We just set a flag here and
004C49r 2                       ; let p do all the heavy work.
004C49r 2               
004C49r 2  FA                           plx
004C4Ar 2               
004C4Ar 2  A9 01                        lda #%00000001
004C4Cr 2  04 rr                        tsb ed_flags
004C4Er 2               
004C4Er 2  80 05                        bra _cmd_p_entry_for_cmd_n
004C50r 2               
004C50r 2               
004C50r 2               ; -------------------------
004C50r 2               _cmd_p:
004C50r 2                       ; p -- Print lines without line numbers. This routine is also used
004C50r 2                       ; by n, the difference is in a flag. Note that this routine is
004C50r 2                       ; able to handle line numbers greater than 255 even though it's
004C50r 2                       ; hard to believe somebody would actually use this editor for anything
004C50r 2                       ; that long. I'm really sure Leo Tolstoy would not have created "War
004C50r 2                       ; and Peace" on a 65c02.
004C50r 2               
004C50r 2  FA                           plx
004C51r 2               
004C51r 2               _cmd_p_from_external:
004C51r 2                               ; This is coming from p, the variant without line numbers. We
004C51r 2                               ; set the ed_flags' bit 0 to zero to mark this
004C51r 2  A9 01                        lda #%00000001
004C53r 2  14 rr                        trb ed_flags
004C55r 2               
004C55r 2               _cmd_p_entry_for_cmd_n:
004C55r 2  20 rr rr                     jsr _have_text
004C58r 2  20 rr rr                     jsr _no_line_zero
004C5Br 2               
004C5Br 2  20 rr rr                     jsr xt_cr
004C5Er 2               
004C5Er 2                               ; We now know that there is some number in para1. The most
004C5Er 2                               ; common case is that para2 is zero and we're being asked to
004C5Er 2                               ; print a single line
004C5Er 2  B5 00                        lda 0,x
004C60r 2  15 01                        ora 1,x
004C62r 2  D0 08                        bne _cmd_p_loop
004C64r 2               
004C64r 2                               ; Print a single line and be done with it. We could use
004C64r 2                               ; DROP here and leave immediately but we want this routine
004C64r 2                               ; to have a single exit at the bottom.
004C64r 2  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t para1 para2 para1 )
004C67r 2  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
004C6Ar 2               
004C6Ar 2  80 1E                        bra _cmd_p_all_done
004C6Cr 2               
004C6Cr 2               _cmd_p_loop:
004C6Cr 2                               ; We are being asked to print more than one line, which
004C6Cr 2                               ; is a bit trickier. If para1 is larger than para2, we're
004C6Cr 2                               ; done. Note that Unix ed throws an error if we start out
004C6Cr 2                               ; that way, we might do that in future as well
004C6Cr 2  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t u-t para1 para2 para1 para2 )
004C6Fr 2  20 rr rr                     jsr xt_greater_than     ; > ( addr-t u-t para1 para2 f )
004C72r 2               
004C72r 2  B5 00                        lda 0,x
004C74r 2  15 01                        ora 1,x
004C76r 2  D0 10                        bne _cmd_p_done
004C78r 2               
004C78r 2                               ; Para2 is still larger or the same size as para1, so we
004C78r 2                               ; continue
004C78r 2  E8                           inx
004C79r 2  E8                           inx                     ; Get rid of the flag from >
004C7Ar 2  20 rr rr                     jsr xt_over             ; ( addr-t u-t para1 para2 para1 )
004C7Dr 2  20 rr rr                     jsr _cmd_p_common       ; ( addr-t u-t para1 para2 )
004C80r 2               
004C80r 2  F6 02                        inc 2,x
004C82r 2  D0 02                        bne @next
004C84r 2  F6 03                        inc 3,x
004C86r 2               @next:
004C86r 2  80 E4                        bra _cmd_p_loop
004C88r 2               
004C88r 2               _cmd_p_done:
004C88r 2                               ; We arrive here with ( addr-t u-t para1 para2 f )
004C88r 2  E8                           inx
004C89r 2  E8                           inx                     ; fall through to _cmp_p_all_done
004C8Ar 2               _cmd_p_all_done:
004C8Ar 2  4C rr rr                     jmp _next_command
004C8Dr 2               
004C8Dr 2               
004C8Dr 2               _cmd_p_common:
004C8Dr 2                       ; Internal subroutine to print a single line when given the line number
004C8Dr 2                       ; TOS. Consumes TOS. Used by both n and p. We arrive here with
004C8Dr 2                       ; ( addr-t u-t para1 ) as the line number
004C8Dr 2               
004C8Dr 2                               ; See if we're coming from p (no line numbers, ed_flag is zero)
004C8Dr 2                               ; or from n (line numbers and a TAB, ed_flag is $FF)
004C8Dr 2  A5 rr                        lda ed_flags
004C8Fr 2  4A                           lsr                     ; bit 0 now in carry
004C90r 2  90 0B                        bcc _cmd_p_common_no_num
004C92r 2               
004C92r 2                               ; Bit 0 is set, this is coming from n. Print the line number
004C92r 2                               ; followed by a tab
004C92r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u-t para1 para1 )
004C95r 2  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u-t para1 )
004C98r 2               
004C98r 2  A9 09                        lda #$09                 ; ASCII for Tab
004C9Ar 2  20 rr rr                     jsr emit_a
004C9Dr 2               
004C9Dr 2               _cmd_p_common_no_num:
004C9Dr 2                               ; One way or the other, print the the node's string
004C9Dr 2  20 rr rr                     jsr _num_to_addr        ; ( addr-t u-t addr )
004CA0r 2  20 rr rr                     jsr _print_addr
004CA3r 2               
004CA3r 2  60                           rts
004CA4r 2               
004CA4r 2               
004CA4r 2               ; -------------------------
004CA4r 2               _cmd_q:
004CA4r 2                       ; q -- Quit if all work as been saved, complain otherwise
004CA4r 2               
004CA4r 2  FA                           plx
004CA5r 2               
004CA5r 2  24 rr                        bit ed_flags            ; bit 6 is change flag
004CA7r 2  50 03                        bvc @next
004CA9r 2  4C rr rr                     jmp _error_2drop
004CACr 2               @next:
004CACr 2  4C rr rr                     jmp _all_done            ; can't fall thru because of PLX
004CAFr 2               
004CAFr 2               
004CAFr 2               ; -------------------------
004CAFr 2               _cmd_qq:
004CAFr 2                       ; Q -- Quit unconditionally, dumping any work that is unsaved
004CAFr 2                       ; without any warning. We can't just jump to all done because
004CAFr 2                       ; of the PLX
004CAFr 2  FA                           plx
004CB0r 2               
004CB0r 2  4C rr rr                     jmp _all_done
004CB3r 2               
004CB3r 2               
004CB3r 2               ; -------------------------
004CB3r 2               _cmd_w:
004CB3r 2                       ; w --- Write text to system memory. In contrast to the Unix ed word,
004CB3r 2                       ; we provide the address before the command, such as "8000w". If no
004CB3r 2                       ; address is given -- just 'w' -- we write to whatever was fixed with
004CB3r 2                       ; 'f'. To prevent a common, but potentially common error, we do not
004CB3r 2                       ; allow writing to the first page ($0000 to $00FF) unless the address
004CB3r 2                       ; was specificially passed as a parameter. Currently, we can only enter
004CB3r 2                       ; the address in decimal.
004CB3r 2  FA                           plx
004CB4r 2               
004CB4r 2  20 rr rr                     jsr _have_text
004CB7r 2               
004CB7r 2  24 rr                        bit ed_flags
004CB9r 2  30 13                        bmi _cmd_w_have_para
004CBBr 2               
004CBBr 2                               ; If we don't have a parameter, we check what is stored on the
004CBBr 2                               ; stack and use that address -- UNLESS IT IS 0000, which is
004CBBr 2                               ; what it would be if the user wasn't thinking and just pressed
004CBBr 2                               ; 'w' at the beginning. We arrive here with ( addr-t u-t 0 0 )
004CBBr 2  B5 06                        lda 6,x
004CBDr 2  15 07                        ora 7,x
004CBFr 2  D0 03                        bne @next
004CC1r 2               
004CC1r 2                               ; It's a zero, generate an error to protect the users from
004CC1r 2                               ; themselves
004CC1r 2  4C rr rr                     jmp _error_2drop
004CC4r 2               @next:
004CC4r 2                               ; Not a zero, we assume user knows what they are doing. Get the
004CC4r 2                               ; address.
004CC4r 2  B5 06                        lda 6,x
004CC6r 2  95 02                        sta 2,x
004CC8r 2  B5 07                        lda 7,x
004CCAr 2  95 03                        sta 3,x                 ; ( addr-t u-t addr-t ? )
004CCCr 2               
004CCCr 2  80 08                        bra _cmd_w_para_ready
004CCEr 2               
004CCEr 2               _cmd_w_have_para:
004CCEr 2                               ; We were given a parameter, which we now make the new
004CCEr 2                               ; default parameter. This is different from Unix w, where
004CCEr 2                               ; the filename set by f is not changed by w
004CCEr 2  B5 02                        lda 2,x
004CD0r 2  95 06                        sta 6,x
004CD2r 2  B5 03                        lda 3,x
004CD4r 2  95 07                        sta 7,x                 ; drop through to _cmd_w_para_ready
004CD6r 2               
004CD6r 2               _cmd_w_para_ready:
004CD6r 2                               ; We don't care about the second parameter, the first one must
004CD6r 2                               ; be an address. There is actually no way to test if this is an
004CD6r 2                               ; address because any number could be a 16-bit address. Anyway,
004CD6r 2                               ; we overwrite para2 with the address where the pointer to the
004CD6r 2                               ; first entry in the list is kept.
004CD6r 2  A9 rr                        lda #<ed_head
004CD8r 2  95 00                        sta 0,x
004CDAr 2  A9 rr                        lda #>ed_head
004CDCr 2  95 01                        sta 1,x                 ; ( addr-t u-t addr-t addr-h )
004CDEr 2               
004CDEr 2                               ; We need to keep a copy of the original target address to
004CDEr 2                               ; calculate how many chars (including carriage returns) we
004CDEr 2                               ; saved at the end of this routine
004CDEr 2  20 rr rr                     jsr xt_over             ; OVER ( addr-t u-t addr-t addr-h addr-t )
004CE1r 2  20 rr rr                     jsr xt_to_r             ; >R ( addr-t u-t addr-t addr-h ) ( R: addr-t )
004CE4r 2               
004CE4r 2               _cmd_w_loop:
004CE4r 2  20 rr rr                     jsr xt_fetch            ; @ ( addr-t u-t addr-t addr1 ) ( R: addr-t )
004CE7r 2               
004CE7r 2                               ; If we're at the end of the list, quit. For the next block of
004CE7r 2                               ; text, we ignore the ( addr-t u-t ) at the beginning
004CE7r 2  B5 00                        lda 0,x
004CE9r 2  15 01                        ora 1,x
004CEBr 2  F0 55                        beq _cmd_w_eol
004CEDr 2               
004CEDr 2  20 rr rr                     jsr xt_two_dup          ; 2DUP ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
004CF0r 2  20 rr rr                     jsr xt_two_to_r         ; 2>R  ( addr-t addr-1 ) (R: ... )
004CF3r 2               
004CF3r 2                               ; Get the address and length of the string from the header
004CF3r 2                               ; of this node
004CF3r 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+1 ) (R: ... )
004CF6r 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr1+2 ) (R: ... )
004CF9r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t addr1+2 addr1+2 ) ( R: ... )
004CFCr 2  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr1+2 addr-s ) ( R: ... )
004CFFr 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t addr-s addr1+2 ) ( R: ... )
004D02r 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+1 ) (R: ... )
004D05r 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-t addr-s addr1+2 ) (R: ... )
004D08r 2  20 rr rr                     jsr xt_fetch            ; @ ( addr-t addr-s u-s ) ( R: ... )
004D0Br 2  20 rr rr                     jsr xt_not_rote         ; -ROT ( u-s addr-t addr-s ) ( R: ... )
004D0Er 2  20 rr rr                     jsr xt_swap             ; SWAP ( u-s addr-s addr-t ) ( R: ... )
004D11r 2  20 rr rr                     jsr xt_rot              ; ROT (addr-s addr-t u-s ) ( R: ... )
004D14r 2               
004D14r 2                               ; We need a copy of the string length u-s to adjust the pointer
004D14r 2                               ; to the store area later
004D14r 2  20 rr rr                     jsr xt_dup              ; DUP (addr-s addr-t u-s u-s ) ( R: ... )
004D17r 2  20 rr rr                     jsr xt_to_r             ; >R (addr-s addr-t u-s ) ( R: ... u-s )
004D1Ar 2               
004D1Ar 2  20 rr rr                     jsr xt_move             ; MOVE ( )( R: addr-t addr-1 addr-t )
004D1Dr 2               
004D1Dr 2                               ; Calculate the position of the next string in the save area.
004D1Dr 2                               ; What we don't do is remember the length of the individual
004D1Dr 2                               ; strings; instead at the end we will subtract addresses to
004D1Dr 2                               ; get the length of the string
004D1Dr 2  20 rr rr                     jsr xt_r_from           ; R> ( u-s )  ( R: addr-t addr-h addr-t )
004D20r 2  20 rr rr                     jsr xt_two_r_from       ; 2R> ( u-s addr-t addr-h ) ( R: addr-t )
004D23r 2  20 rr rr                     jsr xt_not_rote         ; -ROT ( addr-h u-s addr-t ) ( R: addr-t )
004D26r 2  20 rr rr                     jsr xt_plus             ; + ( addr-h addr-t1 ) ( R: addr-t )
004D29r 2               
004D29r 2                               ; But wait, our strings are terminated by Line Feeds in
004D29r 2                               ; memory, so we need to add one
004D29r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
004D2Cr 2               
004D2Cr 2  CA                           dex
004D2Dr 2  CA                           dex                     ; ( addr-h addr-t1 addr-t1 ? ) ( R: addr-t )
004D2Er 2  A9 0A                        lda #AscLF              ; ASCII for LF
004D30r 2  95 00                        sta 0,x
004D32r 2  74 01                        stz 1,x                 ; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
004D34r 2               
004D34r 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
004D37r 2  20 rr rr                     jsr xt_store            ; ! ( addr-h addr-t1 ) ( R: addr-t )
004D3Ar 2  20 rr rr                     jsr xt_one_plus         ; 1+ ( addr-h addr-t1+1 ) ( R: addr-t )
004D3Dr 2               
004D3Dr 2                               ; Now we can handle the next line
004D3Dr 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t1+1 addr-h ) ( R: addr-t )
004D40r 2               
004D40r 2  80 A2                        bra _cmd_w_loop
004D42r 2               
004D42r 2               _cmd_w_eol:
004D42r 2                               ; We're at the end of the text buffer and arrive here with
004D42r 2                               ; ( addr-tn addr-n ) ( R: addr-t ) What we do now is calculate
004D42r 2                               ; the number of characters saved and put that value in the 3OS
004D42r 2                               ; position
004D42r 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
004D45r 2  20 rr rr                     jsr xt_r_from           ; R> ( addr-t u-t addr-n addr-tn addr-t )
004D48r 2  20 rr rr                     jsr xt_minus            ; - ( addr-t u-t addr-n u )
004D4Br 2               
004D4Br 2  B5 00                        lda 0,x
004D4Dr 2  95 04                        sta 4,x
004D4Fr 2  B5 01                        lda 1,x
004D51r 2  95 05                        sta 5,x                 ; ( addr-t u addr-n u )
004D53r 2               
004D53r 2                               ; Unix ed puts the number of characters on a new line, so we
004D53r 2                               ; do as well
004D53r 2  20 rr rr                     jsr xt_cr
004D56r 2  20 rr rr                     jsr xt_dup              ; DUP ( addr-t u addr-n u u )
004D59r 2  20 rr rr                     jsr xt_u_dot            ; U. ( addr-t u addr-n u )
004D5Cr 2  20 rr rr                     jsr xt_cr
004D5Fr 2               
004D5Fr 2                               ; Reset the changed flag
004D5Fr 2  A9 40                        lda #%01000000
004D61r 2  14 rr                        trb ed_flags
004D63r 2               
004D63r 2  4C rr rr                     jmp _next_command
004D66r 2               
004D66r 2               
004D66r 2               ; === ERROR HANDLING ===
004D66r 2               
004D66r 2               _error_2drop:
004D66r 2                               ; Lots of times we'll have para1 and para2 on the stack when an
004D66r 2                               ; error occurs, so we drop stuff here
004D66r 2  E8                           inx
004D67r 2  E8                           inx                     ; drop through to _error_1drop
004D68r 2               _error_1drop:
004D68r 2  E8                           inx
004D69r 2  E8                           inx                     ; drop through to _error
004D6Ar 2               _error:
004D6Ar 2                               ; Error handling with ed is really primitive: We print a question
004D6Ar 2                               ; mark and go back to the loop. Any code calling this routine must
004D6Ar 2                               ; clean up the stack itself: We expect it to be empty. Note that
004D6Ar 2                               ; ed currently does not support reporting the type of error on
004D6Ar 2                               ; demand like Unix ed does
004D6Ar 2  20 rr rr                     jsr xt_cr
004D6Dr 2               
004D6Dr 2  A9 3F                        lda #'?'
004D6Fr 2  20 rr rr                     jsr emit_a
004D72r 2               
004D72r 2  20 rr rr                     jsr xt_cr
004D75r 2               
004D75r 2  4C rr rr                     jmp _input_loop
004D78r 2               
004D78r 2               
004D78r 2               ; === HELPER FUNCTIONS ===
004D78r 2               
004D78r 2               _get_input:
004D78r 2                       ; Use REFILL to get input from the user, which is left in
004D78r 2                       ; ( cib ciblen ) as usual.
004D78r 2  20 rr rr                     jsr xt_refill           ;  ( addr-t u-t f )
004D7Br 2               
004D7Br 2                               ; If something went wrong while getting the user input, print
004D7Br 2                               ; a question mark and try again. No fancy error messages
004D7Br 2                               ; for ed!
004D7Br 2  B5 00                        lda 0,x
004D7Dr 2  15 01                        ora 1,x
004D7Fr 2  D0 05                        bne @next
004D81r 2               
004D81r 2                               ; Whatever went wrong, we can't handle it here anyway. We
004D81r 2                               ; clear the return stack, dump the error flag and call
004D81r 2                               ; a normal error
004D81r 2  7A                           ply
004D82r 2  7A                           ply
004D83r 2               
004D83r 2  4C rr rr                     jmp _error_1drop
004D86r 2               @next:
004D86r 2                               ; Drop the flag
004D86r 2  E8                           inx
004D87r 2  E8                           inx
004D88r 2               
004D88r 2  60                           rts
004D89r 2               
004D89r 2               ; -----------------------------
004D89r 2               _have_text:
004D89r 2                       ; See if we have any lines at all. If not, abort with an error. We
004D89r 2                       ; could in theory set a flag every time we add a text, but this is
004D89r 2                       ; more robust, if somewhat longer
004D89r 2  A5 rr                        lda ed_head
004D8Br 2  05 rr                        ora ed_head+1
004D8Dr 2  D0 04                        bne @next
004D8Fr 2               
004D8Fr 2                               ; We don't have any lines. Clean up the return stack and throw
004D8Fr 2                               ; an error
004D8Fr 2  7A                           ply
004D90r 2  7A                           ply
004D91r 2  80 D7                        bra _error
004D93r 2               @next:
004D93r 2  60                           rts
004D94r 2               
004D94r 2               ; -----------------------------
004D94r 2               _is_valid_line:
004D94r 2                       ; See if the line number in TOS is valid. If yes, returns the carry
004D94r 2                       ; flag set ("true"), otherwise cleared ("false"). Does not change
004D94r 2                       ; the value of TOS. Line numbers must be 0 < number <= last_line.
004D94r 2                       ; This routine calls _last_line.
004D94r 2  38                           sec                             ; default is legal line number
004D95r 2               
004D95r 2                               ; First see if we have a zero
004D95r 2  B5 00                        lda 0,x
004D97r 2  15 01                        ora 1,x
004D99r 2  F0 19                        beq _is_valid_line_nope_zero    ; ( n )
004D9Br 2               
004D9Br 2                               ; Not a zero. Now see if we're beyond the last line
004D9Br 2  20 rr rr                     jsr xt_dup                      ; DUP ( n n )
004D9Er 2  20 rr rr                     jsr _last_line                  ; ( n n last )
004DA1r 2  20 rr rr                     jsr xt_swap                     ; SWAP ( n last n )
004DA4r 2  20 rr rr                     jsr xt_less_than                ; < ( n f )
004DA7r 2               
004DA7r 2  B5 00                        lda 0,x                         ; 0 flag is good
004DA9r 2  15 01                        ora 1,x
004DABr 2  D0 05                        bne _is_valid_line_too_small
004DADr 2               
004DADr 2                               ; We're good, clean up and leave
004DADr 2  E8                           inx
004DAEr 2  E8                           inx                     ; DROP flag ( n )
004DAFr 2               
004DAFr 2  38                           sec                     ; Who knows what's happened to C by now
004DB0r 2  80 03                        bra _is_valid_line_done ; only one exit from this routine
004DB2r 2               
004DB2r 2               _is_valid_line_too_small:
004DB2r 2  E8                           inx
004DB3r 2  E8                           inx                     ; drop through to _is_valid_line_zero
004DB4r 2               
004DB4r 2               _is_valid_line_nope_zero:
004DB4r 2  18                           clc                     ; drop through to _is_valid_line_done
004DB5r 2               
004DB5r 2               _is_valid_line_done:
004DB5r 2  60                           rts
004DB6r 2               
004DB6r 2               
004DB6r 2               ; -----------------------------
004DB6r 2               _last_line:
004DB6r 2                       ; Calculate the number of the last line (not its address) and return
004DB6r 2                       ; it TOS. Note this shares code with _num_to_addr. Assumes that user
004DB6r 2                       ; has made sure there are any lines at all
004DB6r 2               
004DB6r 2                               ; Set counter to zero
004DB6r 2  64 rr                        stz tmp1
004DB8r 2  64 rr                        stz tmp1+1
004DBAr 2               
004DBAr 2  CA                           dex
004DBBr 2  CA                           dex                     ; ( ? )
004DBCr 2  A9 rr                        lda #<ed_head
004DBEr 2  95 00                        sta 0,x
004DC0r 2  A9 rr                        lda #>ed_head
004DC2r 2  95 01                        sta 1,x                 ; ( addr )
004DC4r 2               
004DC4r 2               _last_line_loop:
004DC4r 2  20 rr rr                     jsr xt_fetch            ; ( addr | 0 )
004DC7r 2               
004DC7r 2                               ; If that's over, we're at the end of the list and we're done
004DC7r 2  B5 00                        lda 0,x
004DC9r 2  15 01                        ora 1,x
004DCBr 2  F0 08                        beq _last_line_done
004DCDr 2               
004DCDr 2                               ; Not done. Increase counter and continue
004DCDr 2  E6 rr                        inc tmp1
004DCFr 2  D0 02                        bne @next
004DD1r 2  E6 rr                        inc tmp1+1
004DD3r 2               @next:
004DD3r 2  80 EF                        bra _last_line_loop
004DD5r 2               
004DD5r 2               _last_line_done:
004DD5r 2  A5 rr                        lda tmp1
004DD7r 2  95 00                        sta 0,x
004DD9r 2  A5 rr                        lda tmp1+1
004DDBr 2  95 01                        sta 1,x                 ; ( u )
004DDDr 2               
004DDDr 2  60                           rts
004DDEr 2               
004DDEr 2               
004DDEr 2               ; -----------------------------
004DDEr 2               _no_line_zero:
004DDEr 2                       ; Make sure we weren't given an explicit zero as the line number with
004DDEr 2                       ; commands that don't accept it (that is, pretty much everybody except
004DDEr 2                       ; a). If para1 is a zero and we have parameters (bit 7 of ed_flag set),
004DDEr 2                       ; throw an error
004DDEr 2               
004DDEr 2                               ; See if para1 is zero
004DDEr 2  B5 02                        lda 2,x
004DE0r 2  15 03                        ora 3,x
004DE2r 2  D0 07                        bne _no_line_zero_done
004DE4r 2               
004DE4r 2                               ; It's zero. If bit 7 of ed_flag is set, this is an explicit
004DE4r 2                               ; parameter
004DE4r 2  24 rr                        bit ed_flags
004DE6r 2  10 03                        bpl _no_line_zero_done
004DE8r 2               
004DE8r 2  4C rr rr                     jmp _error_2drop
004DEBr 2               
004DEBr 2               _no_line_zero_done:
004DEBr 2                               ; All is well, we can continue
004DEBr 2  60                           rts
004DECr 2               
004DECr 2               ; -----------------------------
004DECr 2               _num_to_addr:
004DECr 2                       ; Given a line number as TOS, replace it by the address of the node.
004DECr 2                       ; If the line number is zero, we return the address of the header
004DECr 2                       ; node. If the line number is beyond the last line, we return a
004DECr 2                       ; zero, though we're assuming the user will check for a legal
004DECr 2                       ; line number before calling this routine. Assumes we have checked that
004DECr 2                       ; we have any text at all.
004DECr 2               
004DECr 2                               ; One way or another we're going to start with the
004DECr 2                               ; address of the pointer to the head of the list
004DECr 2  CA                           dex
004DEDr 2  CA                           dex                     ; ( u ? )
004DEEr 2  A9 rr                        lda #<ed_head
004DF0r 2  95 00                        sta 0,x
004DF2r 2  A9 rr                        lda #>ed_head
004DF4r 2  95 01                        sta 1,x                 ; ( u addr-h )
004DF6r 2               
004DF6r 2                               ; Handle the case where the line number is zero
004DF6r 2  B5 02                        lda 2,x
004DF8r 2  15 03                        ora 3,x
004DFAr 2  D0 05                        bne _num_to_addr_loop
004DFCr 2               
004DFCr 2                               ; It's zero, so we're already done
004DFCr 2  20 rr rr                     jsr xt_nip              ; ( addr-h )
004DFFr 2  80 21                        bra _num_to_addr_done
004E01r 2               
004E01r 2               _num_to_addr_loop:
004E01r 2                               ; Get the first line
004E01r 2  20 rr rr                     jsr xt_fetch            ; @ ( u addr1 )
004E04r 2               
004E04r 2                               ; If that's zero, we're at the end of the list and it's over
004E04r 2  B5 00                        lda 0,x
004E06r 2  15 01                        ora 1,x
004E08r 2  D0 05                        bne @next
004E0Ar 2               
004E0Ar 2  20 rr rr                     jsr xt_nip              ; NIP ( addr1 )
004E0Dr 2  80 13                        bra _num_to_addr_done
004E0Fr 2               @next:
004E0Fr 2                               ; It's not zero. See if this is the nth element we're looking
004E0Fr 2                               ; for
004E0Fr 2  20 rr rr                     jsr xt_swap             ; SWAP ( addr1 u )
004E12r 2  20 rr rr                     jsr xt_one_minus        ; 1- ( addr1 u-1 )
004E15r 2               
004E15r 2  B5 00                        lda 0,x
004E17r 2  15 01                        ora 1,x
004E19r 2  F0 05                        beq _num_to_addr_finished
004E1Br 2               
004E1Br 2                               ; Not zero yet, try again
004E1Br 2  20 rr rr                     jsr xt_swap             ; SWAP ( u-1 addr1 )
004E1Er 2               
004E1Er 2  80 E1                        bra _num_to_addr_loop
004E20r 2               
004E20r 2               _num_to_addr_finished:
004E20r 2                               ; We arrive here with ( addr u )
004E20r 2  E8                           inx
004E21r 2  E8                           inx                     ; ( addr )
004E22r 2               
004E22r 2               _num_to_addr_done:
004E22r 2  60                           rts
004E23r 2               
004E23r 2               
004E23r 2               ; -----------------------------
004E23r 2               _para1_to_cur:
004E23r 2                       ; Switch the current line number to whatever the first parameter
004E23r 2                       ; is. We do this a lot so this routine saves a few bytes
004E23r 2  B5 02                        lda 2,x
004E25r 2  85 rr                        sta ed_cur
004E27r 2  B5 03                        lda 3,x
004E29r 2  85 rr                        sta ed_cur+1
004E2Br 2               
004E2Br 2  60                           rts
004E2Cr 2               
004E2Cr 2               
004E2Cr 2               ; -----------------------------
004E2Cr 2               _print_addr:
004E2Cr 2                       ; Given the address of a node TOS, print the string it comes with.
004E2Cr 2                       ; Assumes we have made sure that this address exists. It would be
004E2Cr 2                       ; nice to put the CR at the beginning, but that doesn't work with
004E2Cr 2                       ; the n commands, so at the end it goes. Consumes TOS.
004E2Cr 2  20 rr rr                     jsr xt_one_plus
004E2Fr 2  20 rr rr                     jsr xt_one_plus         ; ( addr+2 )
004E32r 2               
004E32r 2  20 rr rr                     jsr xt_dup              ; ( addr+2 addr+2 )
004E35r 2               
004E35r 2  20 rr rr                     jsr xt_one_plus
004E38r 2  20 rr rr                     jsr xt_one_plus         ; ( addr+2 addr+4 )
004E3Br 2               
004E3Br 2  20 rr rr                     jsr xt_fetch            ; ( addr+2 u-s )
004E3Er 2  20 rr rr                     jsr xt_swap             ; ( u-s addr+2 )
004E41r 2  20 rr rr                     jsr xt_fetch            ; ( u-s addr-s )
004E44r 2               
004E44r 2  20 rr rr                     jsr xt_swap             ; ( addr-s u-s )
004E47r 2  20 rr rr                     jsr xt_type
004E4Ar 2  20 rr rr                     jsr xt_cr
004E4Dr 2               
004E4Dr 2  60                           rts
004E4Er 2               
004E4Er 2               
004E4Er 2               ; === COMMAND TABLES ===
004E4Er 2               
004E4Er 2               ; The commands are all one character and kept in a 0-terminated string that is
004E4Er 2               ; walked by a loop. Their index corresponds to the index of their routine's
004E4Er 2               ; address in the jump table. To create a new command, add it's letter at the
004E4Er 2               ; correct position in the command list and the routine's address in the command
004E4Er 2               ; jump table. Oh, and write the routine as well. Capital letters such as 'Q' are
004E4Er 2               ; coded in their routine's address as double letters ('_cmd_qq').
004E4Er 2               
004E4Er 2  61 66 69 64  ed_cmd_list:    .byte "afidpn=wqQ", 0
004E52r 2  70 6E 3D 77  
004E56r 2  71 51 00     
004E59r 2               
004E59r 2               ed_cmd_table:
004E59r 2  rr rr rr rr                  .word _cmd_a, _cmd_f, _cmd_i, _cmd_d, _cmd_p, _cmd_n
004E5Dr 2  rr rr rr rr  
004E61r 2  rr rr rr rr  
004E65r 2  rr rr rr rr                  .word _cmd_equ, _cmd_w, _cmd_q, _cmd_qq
004E69r 2  rr rr rr rr  
004E6Dr 2               
004E6Dr 2               
004E6Dr 2               ed6502_end:     ; Used to calculate size of editor code
004E6Dr 2               
004E6Dr 1               
004E6Dr 1               
004E6Dr 1               platform_bye:
004E6Dr 1               kernel_init:
004E6Dr 1               .ifdef VIA1_BASE
004E6Dr 1  A9 FF            lda #$FF
004E6Fr 1  8D 82 FF         sta DDRB
004E72r 1  8D 83 FF         sta DDRA
004E75r 1  A9 01            lda #1
004E77r 1  8D 80 FF         sta PORTB
004E7Ar 1  9C 81 FF         stz PORTA
004E7Dr 1               .endif
004E7Dr 1               
004E7Dr 1  20 rr rr     jsr acia_init
004E80r 1               .ifdef timer_init
004E80r 1  20 rr rr         jsr timer_init
004E83r 1               .endif
004E83r 1               .ifdef video_init
004E83r 1                   jsr video_init
004E83r 1               .endif
004E83r 1               .ifdef ps2_init
004E83r 1                   jsr ps2_init
004E83r 1               .endif
004E83r 1               .ifdef cf_init
004E83r 1  20 rr rr         jsr cf_init
004E86r 1               .endif
004E86r 1               .ifdef lcd_init
004E86r 1                   jsr lcd_init
004E86r 1               .endif
004E86r 1               .ifdef spi_init
004E86r 1  20 rr rr         jsr spi_init
004E89r 1               .endif
004E89r 1               .ifdef kb_init
004E89r 1                   jsr kb_init
004E89r 1               .endif
004E89r 1               
004E89r 1  DA A2 00 BD      printascii welcome_message
004E8Dr 1  rr rr F0 06  
004E91r 1  20 rr rr E8  
004E98r 1               
004E98r 1  A9 rr            lda #<dictionary
004E9Ar 1  85 rr            sta util_tmp
004E9Cr 1  A9 rr            lda #>dictionary
004E9Er 1  85 rr            sta util_tmp + 1
004EA0r 1               
004EA0r 1  20 rr rr         jsr calculate_free_mem
004EA3r 1  A5 rr            lda tmp_var + 1
004EA5r 1  A6 rr            ldx tmp_var
004EA7r 1  20 rr rr         jsr print16
004EAAr 1               
004EAAr 1  DA A2 00 BD      printascii free_message
004EAEr 1  rr rr F0 06  
004EB2r 1  20 rr rr E8  
004EB9r 1               
004EB9r 1               
004EB9r 1  4C rr rr         jmp forth
004EBCr 1               
004EBCr 1               v_nmi:
004EBCr 1               
004EBCr 1                   ; jsr calculate_free_mem
004EBCr 1                   ; lda tmp_var + 1
004EBCr 1                   ; ldx tmp_var
004EBCr 1                   ; jsr print16
004EBCr 1               
004EBCr 1                   ; printascii free_message
004EBCr 1  DA A2 00 BD      printascii ready_message
004EC0r 1  rr rr F0 06  
004EC4r 1  20 rr rr E8  
004ECBr 1               
004ECBr 1  4C rr rr         jmp xt_abort
004ECEr 1               
004ECEr 1               
004ECEr 1               
004ECEr 1               
004ECEr 1               io_read_sector:
004ECEr 1  4C rr rr         jmp io_read_sector_address        ; jump to read sector routine
004ED1r 1               
004ED1r 1               io_write_sector:
004ED1r 1  4C rr rr         jmp io_write_sector_address        ; jump to read sector routine
004ED4r 1               
004ED4r 1               
004ED4r 1               
004ED4r 1               kernel_putc:
004ED4r 1                   ; """Print a single character to the console. """
004ED4r 1                   ;; Send_Char - send character in A out serial port.
004ED4r 1                   ;; Uses: A (original value restored)
004ED4r 1               send_char:
004ED4r 1  48               pha
004ED5r 1                   .ifdef char_out
004ED5r 1                   jsr char_out
004ED5r 1                   .endif
004ED5r 1                   .ifdef acia_out
004ED5r 1  20 rr rr         jsr acia_out
004ED8r 1                   .endif
004ED8r 1               send_char_exit:
004ED8r 1               .ifdef lcd_print
004ED8r 1                   ; jsr lcd_print
004ED8r 1               .endif
004ED8r 1  68               pla
004ED9r 1  60               rts
004EDAr 1               
004EDAr 1               
004EDAr 1                       ;; Get_Char - get a character from the serial port into A.
004EDAr 1                       ;; Set the carry flag if char is valid.
004EDAr 1                       ;; Return immediately with carry flag clear if no char available.
004EDAr 1                       ;; Uses: A (return value)
004EDAr 1               
004EDAr 1               Get_Char:
004EDAr 1  20 rr rr         jsr acia_getc
004EDDr 1  90 02            bcc get_ps2_char                ; check keyboard buffer if nothing from ACIA
004EDFr 1  38               sec                             ; Set Carry to show we got a character
004EE0r 1  60               rts                             ; Return
004EE1r 1               
004EE1r 1               get_ps2_char:                       ; no ACIA char available, try to get from KB buffer
004EE1r 1               .ifdef ps2_get_char
004EE1r 1                   jsr ps2_get_char
004EE1r 1               .endif
004EE1r 1  90 02            bcc get_kb_char
004EE3r 1  38               sec
004EE4r 1               
004EE4r 1  60               rts
004EE5r 1               get_kb_char:
004EE5r 1                   .ifdef kb_get_char
004EE5r 1               
004EE5r 1                   ; ldy #5
004EE5r 1                   ; jsr delay_short
004EE5r 1                   ; ply
004EE5r 1                       jsr kb_get_char
004EE5r 1               
004EE5r 1                   .endif
004EE5r 1               exit:                         ; Indicate no char available.
004EE5r 1  60               rts                             ; return
004EE6r 1               
004EE6r 1               kernel_getc:
004EE6r 1                   ; """Get a single character from the keyboard (waits for key).
004EE6r 1                   ; """
004EE6r 1                   ;; Get_Char_Wait - same as Get_Char only blocking.
004EE6r 1                   ;; Uses: A (return value)
004EE6r 1               Get_Char_Wait:
004EE6r 1  20 rr rr         jsr Get_Char
004EE9r 1  90 FB            bcc Get_Char_Wait
004EEBr 1  60               rts
004EECr 1               
004EECr 1               
004EECr 1               v_irq:                          ; IRQ handler
004EECr 1  48                   pha
004EEDr 1  5A                   phy
004EEEr 1                       ; lda #'.'
004EEEr 1                       ; jsr kernel_putc
004EEEr 1                       ; check if bit 7 of IFR is set
004EEEr 1               .ifdef IFR
004EEEr 1  AD 8D FF             lda IFR
004EF1r 1  10 0B                bpl irq_not_from_via  ; Interrupt not from VIA, exit
004EF3r 1               
004EF3r 1  29 08                and #$08        ; ps2 has priority
004EF5r 1  D0 07                bne v_irq_ps2
004EF7r 1  AD 8D FF             lda IFR
004EFAr 1  29 40                and #$40
004EFCr 1  D0 02                bne v_irq_timer
004EFEr 1               irq_not_from_via:
004EFEr 1               .endif
004EFEr 1               .ifdef KB_IFR
004EFEr 1               v_kb_irq:
004EFEr 1                       lda KB_IFR
004EFEr 1                       bpl v_irq_exit
004EFEr 1                       and #$40
004EFEr 1                       bne v_kb_irq_timer
004EFEr 1                       bra v_irq_exit
004EFEr 1               .endif
004EFEr 1               
004EFEr 1               v_irq_ps2:
004EFEr 1                   .ifdef ps2_irq
004EFEr 1                       lda time
004EFEr 1                       sta last_ps2_time
004EFEr 1                       lda time+1
004EFEr 1                       sta last_ps2_time+1
004EFEr 1                       lda time+2
004EFEr 1                       sta last_ps2_time+2
004EFEr 1                       lda time+3
004EFEr 1                       sta last_ps2_time+3
004EFEr 1               
004EFEr 1                       jsr ps2_irq
004EFEr 1               
004EFEr 1                   .endif
004EFEr 1  80 27                bra v_irq_exit
004F00r 1               
004F00r 1               .ifdef T1CL
004F00r 1               v_irq_timer:
004F00r 1  AD 84 FF             lda T1CL
004F03r 1                       ; clear timer interrupt
004F03r 1                   .ifdef timer_irq
004F03r 1  20 rr rr             jsr timer_irq
004F06r 1                   .endif
004F06r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
004F09r 1                       ; check if there is a char waiting to be printed to the lcd
004F09r 1                       ; lda lcd_char
004F09r 1                       ; beq v_exit
004F09r 1                       ; jsr lcd_print
004F09r 1                       ; stz lcd_char
004F09r 1               
004F09r 1               
004F09r 1  90 1C                bcc v_irq_exit      ; no character waiting, exit normally
004F0Br 1  C9 03                cmp #$03            ; check if CTRL-C
004F0Dr 1  D0 18                bne v_irq_exit      ; not CTRL-C, exit normally
004F0Fr 1  DA A2 00 BD          printascii abort_message    ; was a CTRL_C
004F13r 1  rr rr F0 06  
004F17r 1  20 rr rr E8  
004F1Er 1  7A                   ply                         ; pull what the ISR pushed
004F1Fr 1  68                   pla
004F20r 1  28                   plp                         ; pull status register
004F21r 1  68                   pla                         ; pull return address
004F22r 1  68                   pla
004F23r 1               
004F23r 1  58                   cli                         ; clear interrupt diabled bit
004F24r 1  4C rr rr             jmp xt_abort
004F27r 1               
004F27r 1               .endif
004F27r 1               v_kb_irq_timer:
004F27r 1               .ifdef kb_time
004F27r 1                   lda KB_T1CL ; clear timer interrupt
004F27r 1                   inc kb_time
004F27r 1                   bne v_irq_exit
004F27r 1               .endif
004F27r 1                   ;jsr kb_scan
004F27r 1               v_irq_exit:
004F27r 1  7A               ply
004F28r 1  68               pla
004F29r 1  40               rti
004F2Ar 1               
004F2Ar 1  20 62 79 74  free_message: .byte " bytes free", $0D, 0
004F2Er 1  65 73 20 66  
004F32r 1  72 65 65 0D  
004F37r 1  52 65 61 64  ready_message: .byte "Ready", $0D, 0
004F3Br 1  79 0D 00     
004F3Er 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", $0D, "Type 'words' for available words", $0D, 0
004F42r 1  6F 6D 65 20  
004F46r 1  74 6F 20 50  
004F77r 1  0D 0A 00     abort_message: .byte AscCR, AscLF, 0
004F7Ar 1               
004F7Ar 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
