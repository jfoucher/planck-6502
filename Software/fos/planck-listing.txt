ca65 V2.18 - N/A
Main file   : platform/planck/main.s
Current file: platform/planck/main.s

000000r 1               CLOCK_SPEED = 24000000
000000r 1               
000000r 1               ram_end = $8000
000000r 1               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/via.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               VIA1_BASE   = $FF80
000000r 2               PORTB = VIA1_BASE
000000r 2               PORTA  = VIA1_BASE+1
000000r 2               DDRB = VIA1_BASE+2
000000r 2               DDRA = VIA1_BASE+3
000000r 2               
000000r 2               
000000r 2               T1CL = VIA1_BASE + 4
000000r 2               T1CH = VIA1_BASE + 5
000000r 2               T1LL = VIA1_BASE + 6
000000r 2               T1LH = VIA1_BASE + 7
000000r 2               ACR = VIA1_BASE + 11
000000r 2               PCR = VIA1_BASE + 12
000000r 2               IFR = VIA1_BASE + 13
000000r 2               IER = VIA1_BASE + 14
000000r 2               
000000r 1               .include "drivers/ps2.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               DATA = $80   ; Data is in bit 7 of PORTA
000000r 2               ; clock is on CA2
000000r 2               SHIFT = $1
000000r 2               ALT = $2
000000r 2               
000000r 2               KB_STATE_START = $0
000000r 2               KB_STATE_DATA = $1
000000r 2               KB_STATE_PARITY = $2
000000r 2               KB_STATE_STOP = $3
000000r 2               
000000r 2               KB_INIT_STATE_RESET = $0
000000r 2               KB_INIT_STATE_RESET_ACK = $1
000000r 2               KB_INIT_STATE_LEDS = $2
000000r 2               KB_INIT_STATE_LEDS_ACK = $3
000000r 2               KB_INIT_STATE_LEDS_DATA = $4
000000r 2               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 2               
000000r 2               LSHIFT_KEY = $12
000000r 2               RSHIFT_KEY = $59
000000r 2               
000000r 2               TIMER_DELAY = $C4
000000r 2               
000000r 2               
000000r 1               .include "drivers/lcd.inc"
000000r 2               
000000r 2               ; HD 44780 driver
000000r 2               ; all pins on VIA PORTA, 4 bit mode
000000r 2               
000000r 2               ; PORTA0 is free
000000r 2               LCD_BASE = $FFC0
000000r 2               LCD_ADDR_DISABLED = LCD_BASE
000000r 2               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 2               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 2               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 2               
000000r 2               
000000r 2               ; A0: RS
000000r 2               ; A1: E
000000r 2               
000000r 1               .include "drivers/vga.inc"
000000r 2               VIDEO_BASE = $FFB0
000000r 2               
000000r 2               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 2               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;// also contains the increment ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 2               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 2               VIDEO_DATA = VIDEO_BASE + 3
000000r 2               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 2               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 2               
000000r 2               VIDEO_HIRES_HCHARS = 80
000000r 2               VIDEO_HIRES_VCHARS = 60
000000r 2               
000000r 1               .include "drivers/keyboard.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               KB_VIA_BASE   = $FF90
000000r 2               KB_PORTB = KB_VIA_BASE
000000r 2               KB_PORTA  = KB_VIA_BASE+1
000000r 2               KB_DDRB = KB_VIA_BASE+2
000000r 2               KB_DDRA = KB_VIA_BASE+3
000000r 2               
000000r 2               
000000r 2               KB_T1CL = KB_VIA_BASE + 4
000000r 2               KB_T1CH = KB_VIA_BASE + 5
000000r 2               KB_T1LL = KB_VIA_BASE + 6
000000r 2               KB_T1LH = KB_VIA_BASE + 7
000000r 2               KB_ACR = KB_VIA_BASE + 11
000000r 2               KB_PCR = KB_VIA_BASE + 12
000000r 2               KB_IFR = KB_VIA_BASE + 13
000000r 2               KB_IER = KB_VIA_BASE + 14
000000r 2               
000000r 1               
000000r 1               .include "drivers/zp.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               ; next_addr: .res 1
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               .segment "ZEROPAGE": zeropage
000000r 2               
000000r 2  xx xx        stack_p: .res 2
000002r 2               
000002r 2               
000002r 1               
000002r 1               .segment "BSS"
000000r 1               
000000r 1  xx           lcd_absent: .res 1
000001r 1               
000001r 1  xx           has_acia: .res 1
000002r 1               
000002r 1               
000002r 1               .segment "RODATA"
000000r 1               
000000r 1               .import    copydata
000000r 1               
000000r 1               .segment "STARTUP"
000000r 1               
000000r 1               v_reset:
000000r 1  20 rr rr         JSR     copydata
000003r 1  4C rr rr         jmp kernel_init
000006r 1               
000006r 1               .segment "DATA"
000000r 1               
000000r 1               .include "drivers/acia.s"
000000r 2               acia_init:
000000r 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
000003r 2                                           ; set specific modes and functions
000003r 2  9C rr rr         stz has_acia
000006r 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000008r 2                   ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
000008r 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
00000Br 2  AD E2 FF         lda ACIA_CMD        ; load command register again
00000Er 2  C9 0B            cmp #$0B                ; if not the same
000010r 2  D0 11            bne acia_absent         ; then it means the ACIA is not connected
000012r 2  AD E1 FF         lda ACIA_STATUS         ; Read the ACAI status to
000015r 2  29 60            and #$60                ; check if present or absent
000017r 2  D0 0A            bne acia_absent
000019r 2  A9 01            lda #1
00001Br 2  8D rr rr         sta has_acia           ; remember that ACIA is here
00001Er 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000020r 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000020r 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
000023r 2               
000023r 2               acia_absent:
000023r 2  A0 14                ldy #20
000025r 2               aa_loop:
000025r 2  20 rr rr             jsr delay_short
000028r 2  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
00002Br 2  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
00002Er 2  88                   dey
00002Fr 2  D0 F4                bne aa_loop
000031r 2               aa_end:
000031r 2  60                   rts
000032r 2               
000032r 2               acia_out:
000032r 2  48               pha
000033r 2  5A               phy
000034r 2  8D E0 FF         sta ACIA_DATA
000037r 2  A0 40            ldy #$40            ;minimal delay is $02
000039r 2  20 rr rr         jsr delay_short
00003Cr 2  7A               ply
00003Dr 2  68               pla
00003Er 2  60               rts
00003Fr 2               
00003Fr 2               acia_getc:
00003Fr 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
000042r 2  29 08            and #$08                        ; Check if there is character in the receiver
000044r 2  F0 05            beq @no_char      ; Exit now if we don't get one.
000046r 2  AD E0 FF         lda ACIA_DATA
000049r 2  38               sec
00004Ar 2  60               rts
00004Br 2               @no_char:
00004Br 2  18               clc
00004Cr 2  60               rts
00004Dr 2               
00004Dr 1               .include "drivers/timer.s"
00004Dr 2               
00004Dr 2               
00004Dr 2               COUNTER = CLOCK_SPEED/400        ; n/s
00004Dr 2               
00004Dr 2               .segment "ZEROPAGE": zeropage
000002r 2  xx xx xx xx  time: .res 4
000006r 2               
000006r 2               .segment "DATA"
00004Dr 2               
00004Dr 2               timer_init:
00004Dr 2  AD 8E FF         lda IER
000050r 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000052r 2  8D 8E FF         sta IER
000055r 2  A9 40            lda #$40        ; timer one free run mode
000057r 2  8D 8B FF         sta ACR
00005Ar 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
00005Cr 2  8D 84 FF         sta T1CL
00005Fr 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
000061r 2               
000061r 2  8D 85 FF         sta T1CH
000064r 2  A9 00            lda #0              ; reset time variable
000066r 2  85 rr            sta time
000068r 2  85 rr            sta time+1
00006Ar 2  85 rr            sta time+2
00006Cr 2  85 rr            sta time+3
00006Er 2  58               cli
00006Fr 2  60               rts
000070r 2               
000070r 2               
000070r 2               timer_irq:
000070r 2  E6 rr            inc time
000072r 2  F0 01            beq @inc1
000074r 2               @exit1:
000074r 2                   ; this resets the PS/2 temp variables
000074r 2                   ;jsr reset_ps2
000074r 2  60               rts
000075r 2               @inc1:
000075r 2  E6 rr            inc time+1
000077r 2  F0 02            beq @inc2
000079r 2  80 F9            bra @exit1
00007Br 2               @inc2:
00007Br 2  E6 rr            inc time+2
00007Dr 2  F0 02            beq @inc3
00007Fr 2  80 F3            bra @exit1
000081r 2               @inc3:
000081r 2  E6 rr            inc time+3
000083r 2  80 EF            bra @exit1
000085r 2  60               rts
000086r 2               
000086r 1               .include "drivers/keyboard.s"
000086r 2               ; Copyright 2020 Jonathan Foucher
000086r 2               
000086r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000086r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000086r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000086r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000086r 2               ; is furnished to do so, subject to the following conditions:
000086r 2               
000086r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000086r 2               ; substantial portions of the Software.
000086r 2               
000086r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000086r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000086r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000086r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000086r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000086r 2               ; DEALINGS IN THE SOFTWARE.
000086r 2               
000086r 2               K_NO = 0;
000086r 2               K_GUI = 1;
000086r 2               K_SFT = 2;
000086r 2               K_CTL = 3;
000086r 2               K_ALT = 4;
000086r 2               K_CAPS = 5;
000086r 2               K_BSPC = $08;
000086r 2               K_TAB = 9;
000086r 2               K_ENT = $0A
000086r 2               K_ESC = $1B;
000086r 2               K_SCLN = $3B
000086r 2               
000086r 2               
000086r 2               KB_COUNTER = CLOCK_SPEED/2048
000086r 2               
000086r 2               
000086r 2               max_key_rollover = 4
000086r 2               
000086r 2               .segment "ZEROPAGE": zeropage
000006r 2  00 00 00 00  new_keys: .byte 0, 0, 0, 0, 0, 0, 0, 0
00000Ar 2  00 00 00 00  
00000Er 2  xx           kb_time: .res 1
00000Fr 2  00 00 00 00  keys: .byte 0, 0, 0, 0, 0, 0, 0, 0
000013r 2  00 00 00 00  
000017r 2               
000017r 2               .segment "BSS"
000002r 2  xx           key_quantity: .res 1
000003r 2  FF           buffer_quantity: .byte $ff
000004r 2  00 00 00 00  old_keys: .byte 0, 0, 0, 0, 0, 0, 0, 0
000008r 2  00 00 00 00  
00000Cr 2               
00000Cr 2               
00000Cr 2  xx xx xx xx  scan_result: .res 8
000010r 2  xx xx xx xx  
000014r 2  xx           too_many_keys: .res 1
000015r 2  xx           simultaneous_keys: .res 1
000016r 2  xx           kb_control_keys_mask: .res 1
000017r 2               
000017r 2               .segment "RODATA"
000000r 2               
000000r 2               keymap:
000000r 2                         ; SHIFT                             CTRL
000000r 2  00 00 09 34  .byte K_NO, K_NO,  K_TAB, '4', 'r', 'f', 'c', K_NO  ; COL 1
000004r 2  72 66 63 00  
000008r 2                         ; CAPS
000008r 2  00 00 1B 38  .byte K_NO, K_NO, K_ESC, '8', 'i', 'k', 'm', K_NO   ; COL 2
00000Cr 2  69 6B 6D 00  
000010r 2               ; $10                                     WIN
000010r 2  00 60 71 35  .byte K_NO, '`', 'q', '5', 't', 'g', 'v', K_NO   ; COL 3
000014r 2  74 67 76 00  
000018r 2               ; $18                                      ALT
000018r 2  00 61 31 39  .byte K_NO, 'a', '1', '9', 'o', 'l', ',',  K_NO   ; COL 4
00001Cr 2  6F 6C 2C 00  
000020r 2               ; $20
000020r 2  00 78 65 36  .byte K_NO, 'x', 'e', '6', 'y', 'h', 'b', ' '   ; COL 5
000024r 2  79 68 62 20  
000028r 2               ;$28
000028r 2  00 73 32 30  .byte K_NO, 's', '2', '0', 'p', K_SCLN, '.', '/'   ; COL 6
00002Cr 2  70 3B 2E 2F  
000030r 2               ; $30                                      RSHIFT FN
000030r 2  00 64 33 08  .byte K_NO, 'd', '3', K_BSPC, K_ENT, K_NO, K_NO, K_NO   ; COL 7
000034r 2  0A 00 00 00  
000038r 2               ; $38
000038r 2  00 7A 77 37  .byte K_NO, 'z', 'w', '7', 'u', 'j', 'n', K_NO   ; COL 8
00003Cr 2  75 6A 6E 00  
000040r 2               
000040r 2               shifted_keymap:
000040r 2                         ; SHIFT                             CTRL
000040r 2  00 00 09 24  .byte K_NO, K_NO,  K_TAB, '$', 'R', 'F', 'C', K_NO  ; COL 1
000044r 2  52 46 43 00  
000048r 2                         ; CAPS
000048r 2  00 00 1B 2A  .byte K_NO, K_NO, K_ESC, '*', 'I', 'K', 'M', K_NO   ; COL 2
00004Cr 2  49 4B 4D 00  
000050r 2               ; $10                                     WIN
000050r 2  00 7E 51 25  .byte K_NO, '~', 'Q', '%', 'T', 'G', 'V', K_NO   ; COL 3
000054r 2  54 47 56 00  
000058r 2               ; $18                                      ALT
000058r 2  00 41 21 28  .byte K_NO, 'A', '!', '(', 'O', 'L', '<',  K_NO   ; COL 4
00005Cr 2  4F 4C 3C 00  
000060r 2               ; $20
000060r 2  00 58 45 5E  .byte K_NO, 'X', 'E', '^', 'Y', 'H', 'B', ' '   ; COL 5
000064r 2  59 48 42 20  
000068r 2               ;$28
000068r 2  00 53 40 29  .byte K_NO, 'S', '@', ')', 'P', K_SCLN, '>', '?'   ; COL 6
00006Cr 2  50 3B 3E 3F  
000070r 2               ; $30                                      RSHIFT FN
000070r 2  00 44 23 08  .byte K_NO, 'D', '#', K_BSPC, K_ENT, K_NO, K_NO, K_NO   ; COL 7
000074r 2  0A 00 00 00  
000078r 2               ; $38
000078r 2  00 5A 57 26  .byte K_NO, 'Z', 'W', '&', 'U', 'J', 'N', K_NO   ; COL 8
00007Cr 2  55 4A 4E 00  
000080r 2               
000080r 2               .segment "DATA"
000086r 2               
000086r 2               ;Initialize the VIA for keyboard scanning
000086r 2               kb_init:
000086r 2  78             sei
000087r 2                 ; Set PORTA as ouput for cols
000087r 2  A9 FF          lda #$FF
000089r 2  8D 93 FF       sta KB_DDRA
00008Cr 2                 ; Set PORTB as input for rows
00008Cr 2  9C 92 FF       stz KB_DDRB
00008Fr 2                 ; reset key buffer
00008Fr 2  64 rr          stz new_keys
000091r 2  64 rr          stz new_keys+1
000093r 2  64 rr          stz new_keys+2
000095r 2  64 rr          stz new_keys+3
000097r 2  64 rr          stz new_keys+4
000099r 2  64 rr          stz new_keys+5
00009Br 2  64 rr          stz new_keys+6
00009Dr 2  64 rr          stz new_keys+7
00009Fr 2               
00009Fr 2  64 rr          stz keys
0000A1r 2  64 rr          stz keys+1
0000A3r 2  64 rr          stz keys+2
0000A5r 2  64 rr          stz keys+3
0000A7r 2  64 rr          stz keys+4
0000A9r 2  64 rr          stz keys+5
0000ABr 2  64 rr          stz keys+6
0000ADr 2  64 rr          stz keys+7
0000AFr 2               
0000AFr 2               
0000AFr 2               
0000AFr 2                 ; set timer
0000AFr 2  AD 9E FF       lda KB_IER
0000B2r 2  09 C0          ora #$C0        ;enable interrupt on timer1 timeout
0000B4r 2  8D 9E FF       sta KB_IER
0000B7r 2  A9 40          lda #$40        ; timer one free run mode
0000B9r 2  8D 9B FF       sta KB_ACR
0000BCr 2  A9 C6          lda #<KB_COUNTER     ; set timer to low byte to calculated value from defined clock speed
0000BEr 2  8D 94 FF       sta KB_T1CL
0000C1r 2  A9 2D          lda #>KB_COUNTER       ; set timer to high byte to calculated value from defined clock speed
0000C3r 2  8D 95 FF       sta KB_T1CH
0000C6r 2  58             cli
0000C7r 2               
0000C7r 2               
0000C7r 2  60             rts
0000C8r 2               
0000C8r 2               
0000C8r 2               
0000C8r 2               nothing_pressed:
0000C8r 2                 ;stz PORTA
0000C8r 2  9C rr rr       stz old_keys
0000CBr 2  9C rr rr       stz old_keys+1
0000CEr 2  9C rr rr       stz old_keys+2
0000D1r 2  9C rr rr       stz old_keys+3
0000D4r 2  9C rr rr       stz too_many_keys
0000D7r 2  A9 00          lda #0
0000D9r 2  7A             ply
0000DAr 2  FA             plx
0000DBr 2  18             clc
0000DCr 2  60             rts
0000DDr 2               
0000DDr 2               kb_get_char_2:
0000DDr 2  DA             phx
0000DEr 2  5A             phy
0000DFr 2                 ; ldy #$40
0000DFr 2                 ; jsr delay_short
0000DFr 2                 ; check if anything is pressed
0000DFr 2  A9 FF          lda #$FF
0000E1r 2  8D 91 FF       sta KB_PORTA
0000E4r 2  AD 90 FF       lda KB_PORTB
0000E7r 2  F0 DF          beq nothing_pressed
0000E9r 2                 ;sta PORTA
0000E9r 2                 ; make sure we don't have too many keys pressed at once
0000E9r 2  AD rr rr       lda too_many_keys
0000ECr 2  F0 06          beq @go
0000EEr 2  A9 00          lda #0
0000F0r 2  7A             ply
0000F1r 2  FA             plx
0000F2r 2  18             clc
0000F3r 2  60             rts
0000F4r 2               @go:
0000F4r 2                 ; scan matrix
0000F4r 2                 SCAN_DELAY = $10
0000F4r 2  A9 01          lda #1
0000F6r 2               @u1:
0000F6r 2  A0 10          ldy #SCAN_DELAY
0000F8r 2  20 rr rr       jsr delay_short
0000FBr 2  8D 91 FF       sta KB_PORTA
0000FEr 2  AC 90 FF       ldy KB_PORTB
000101r 2  8C rr rr       sty scan_result+7
000104r 2  AC 90 FF       ldy KB_PORTB
000107r 2  CC rr rr       cpy scan_result+7
00010Ar 2  D0 EA          bne @u1
00010Cr 2  0A             asl
00010Dr 2               @u2:
00010Dr 2  A0 10          ldy #SCAN_DELAY
00010Fr 2  20 rr rr       jsr delay_short
000112r 2  8D 91 FF       sta KB_PORTA
000115r 2  AC 90 FF       ldy KB_PORTB
000118r 2  8C rr rr       sty scan_result+6
00011Br 2  AC 90 FF       ldy KB_PORTB
00011Er 2  CC rr rr       cpy scan_result+6
000121r 2  D0 EA          bne @u2
000123r 2  0A             asl
000124r 2               @u3:
000124r 2  A0 10          ldy #SCAN_DELAY
000126r 2  20 rr rr       jsr delay_short
000129r 2  8D 91 FF       sta KB_PORTA
00012Cr 2  AC 90 FF       ldy KB_PORTB
00012Fr 2  8C rr rr       sty scan_result+5
000132r 2  AC 90 FF       ldy KB_PORTB
000135r 2  CC rr rr       cpy scan_result+5
000138r 2  D0 EA          bne @u3
00013Ar 2  0A             asl
00013Br 2               @u4:
00013Br 2  A0 10          ldy #SCAN_DELAY
00013Dr 2  20 rr rr       jsr delay_short
000140r 2  8D 91 FF       sta KB_PORTA
000143r 2  AC 90 FF       ldy KB_PORTB
000146r 2  8C rr rr       sty scan_result+4
000149r 2  AC 90 FF       ldy KB_PORTB
00014Cr 2  CC rr rr       cpy scan_result+4
00014Fr 2  D0 EA          bne @u4
000151r 2  0A             asl
000152r 2               @u5:
000152r 2  A0 10          ldy #SCAN_DELAY
000154r 2  20 rr rr       jsr delay_short
000157r 2  8D 91 FF       sta KB_PORTA
00015Ar 2  AC 90 FF       ldy KB_PORTB
00015Dr 2  8C rr rr       sty scan_result+3
000160r 2  AC 90 FF       ldy KB_PORTB
000163r 2  CC rr rr       cpy scan_result+3
000166r 2  D0 EA          bne @u5
000168r 2  0A             asl
000169r 2               @u6:
000169r 2  A0 10          ldy #SCAN_DELAY
00016Br 2  20 rr rr       jsr delay_short
00016Er 2  8D 91 FF       sta KB_PORTA
000171r 2  AC 90 FF       ldy KB_PORTB
000174r 2  8C rr rr       sty scan_result+2
000177r 2  AC 90 FF       ldy KB_PORTB
00017Ar 2  CC rr rr       cpy scan_result+2
00017Dr 2  D0 EA          bne @u6
00017Fr 2  0A             asl
000180r 2               @u7:
000180r 2  A0 10          ldy #SCAN_DELAY
000182r 2  20 rr rr       jsr delay_short
000185r 2  8D 91 FF       sta KB_PORTA
000188r 2  AC 90 FF       ldy KB_PORTB
00018Br 2  8C rr rr       sty scan_result+1
00018Er 2  AC 90 FF       ldy KB_PORTB
000191r 2  CC rr rr       cpy scan_result+1
000194r 2  D0 EA          bne @u7
000196r 2  0A             asl
000197r 2               @u8:
000197r 2  A0 10          ldy #SCAN_DELAY
000199r 2  20 rr rr       jsr delay_short
00019Cr 2  8D 91 FF       sta KB_PORTA
00019Fr 2  AC 90 FF       ldy KB_PORTB
0001A2r 2  8C rr rr       sty scan_result
0001A5r 2  AC 90 FF       ldy KB_PORTB
0001A8r 2  CC rr rr       cpy scan_result
0001ABr 2  D0 EA          bne @u8
0001ADr 2                 ;reset read buffer
0001ADr 2  64 rr          stz new_keys
0001AFr 2  64 rr          stz new_keys+1
0001B1r 2  64 rr          stz new_keys+2
0001B3r 2  64 rr          stz new_keys+3
0001B5r 2                 ; set max allowed keys presses
0001B5r 2  A9 04          lda #max_key_rollover
0001B7r 2  8D rr rr       sta key_quantity
0001BAr 2               
0001BAr 2  9C rr rr       stz kb_control_keys_mask
0001BDr 2               
0001BDr 2  A9 FC          lda #($FF - (max_key_rollover-1))
0001BFr 2  8D rr rr       sta simultaneous_keys
0001C2r 2                 ; Scan complete
0001C2r 2                 ; TODO check for control keys
0001C2r 2                 ; left shift
0001C2r 2  AD rr rr       lda scan_result+7
0001C5r 2  29 40          and #$40
0001C7r 2  D0 07          bne @shift
0001C9r 2  AD rr rr       lda scan_result+1
0001CCr 2  29 02          and #$02
0001CEr 2  F0 03          beq @no_shift
0001D0r 2               @shift:
0001D0r 2  8D rr rr       sta kb_control_keys_mask
0001D3r 2               
0001D3r 2               @no_shift:
0001D3r 2                 ;
0001D3r 2               
0001D3r 2  AD rr rr       lda scan_result+7
0001D6r 2  F0 05          beq @1
0001D8r 2  A2 00          ldx #0
0001DAr 2  20 rr rr       jsr keys_in_row
0001DDr 2               @1:
0001DDr 2  AD rr rr       lda scan_result+6
0001E0r 2  F0 05          beq @2
0001E2r 2  A2 08          ldx #8
0001E4r 2  20 rr rr       jsr keys_in_row
0001E7r 2               @2:
0001E7r 2  AD rr rr       lda scan_result+5
0001EAr 2  F0 05          beq @3
0001ECr 2  A2 10          ldx #16
0001EEr 2  20 rr rr       jsr keys_in_row
0001F1r 2               @3:
0001F1r 2  AD rr rr       lda scan_result+4
0001F4r 2  F0 05          beq @4
0001F6r 2  A2 18          ldx #24
0001F8r 2  20 rr rr       jsr keys_in_row
0001FBr 2               @4:
0001FBr 2  AD rr rr       lda scan_result+3
0001FEr 2  F0 05          beq @5
000200r 2  A2 20          ldx #32
000202r 2  20 rr rr       jsr keys_in_row
000205r 2               @5:
000205r 2  AD rr rr       lda scan_result+2
000208r 2  F0 05          beq @6
00020Ar 2  A2 28          ldx #40
00020Cr 2  20 rr rr       jsr keys_in_row
00020Fr 2               @6:
00020Fr 2  AD rr rr       lda scan_result+1
000212r 2  F0 05          beq @7
000214r 2  A2 30          ldx #48
000216r 2  20 rr rr       jsr keys_in_row
000219r 2               @7:
000219r 2  AD rr rr       lda scan_result
00021Cr 2  F0 05          beq @8
00021Er 2  A2 38          ldx #56
000220r 2  20 rr rr       jsr keys_in_row
000223r 2               @8:
000223r 2               
000223r 2               
000223r 2               
000223r 2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
000223r 2               ; Key Scan Completed
000223r 2               
000223r 2               ; Put any new key (not in old scan) into buffer
000223r 2  A2 03          ldx #max_key_rollover-1
000225r 2               next_key:
000225r 2  B5 rr          lda new_keys, x
000227r 2  F0 36          beq @exist        ; Handle 'null' values
000229r 2  CD rr rr       cmp old_keys
00022Cr 2  F0 31          beq @exist
00022Er 2  CD rr rr       cmp old_keys+1
000231r 2  F0 2C          beq @exist
000233r 2  CD rr rr       cmp old_keys+2
000236r 2  F0 27          beq @exist
000238r 2  CD rr rr       cmp old_keys+3
00023Br 2  F0 22          beq @exist
00023Dr 2  CD rr rr       cmp old_keys+4
000240r 2  F0 1D          beq @exist
000242r 2  CD rr rr       cmp old_keys+5
000245r 2  F0 18          beq @exist
000247r 2  CD rr rr       cmp old_keys+6
00024Ar 2  F0 13          beq @exist
00024Cr 2  CD rr rr       cmp old_keys+7
00024Fr 2  F0 0E          beq @exist
000251r 2                 ; New Key Detected
000251r 2  EE rr rr       inc buffer_quantity
000254r 2  AC rr rr       ldy buffer_quantity
000257r 2  99 rr rr       sta keys,y
00025Ar 2                 ; Keep track of how many new Alphanumeric keys are detected
00025Ar 2  EE rr rr       inc simultaneous_keys
00025Dr 2  F0 5C          beq too_many_new_keys
00025Fr 2               @exist:
00025Fr 2  CA             dex
000260r 2  10 C3          bpl next_key
000262r 2               
000262r 2                 ; Anything in Buffer?
000262r 2  AC rr rr       ldy buffer_quantity
000265r 2  30 26          bmi buffer_empty
000267r 2                 ; Yes: Then return it and tidy up the buffer
000267r 2  CE rr rr       dec buffer_quantity
00026Ar 2  A5 rr          lda keys
00026Cr 2  A6 rr          ldx keys+1
00026Er 2  86 rr          stx keys
000270r 2  A6 rr          ldx keys+2
000272r 2  86 rr          stx keys+1
000274r 2  A6 rr          ldx keys+3
000276r 2  86 rr          stx keys+2
000278r 2  A6 rr          ldx keys+4
00027Ar 2  86 rr          stx keys+3
00027Cr 2  A6 rr          ldx keys+5
00027Er 2  86 rr          stx keys+4
000280r 2  A6 rr          ldx keys+6
000282r 2  86 rr          stx keys+5
000284r 2  A6 rr          ldx keys+7
000286r 2  86 rr          stx keys+6
000288r 2  64 rr          stz keys+7
00028Ar 2                 ; cmp kb_prev_char
00028Ar 2                 ; beq buffer_empty
00028Ar 2  38             sec
00028Br 2  80 03          bra return
00028Dr 2               
00028Dr 2               
00028Dr 2               buffer_empty:  ;No new Alphanumeric keys to handle.
00028Dr 2  A9 00          lda #0
00028Fr 2  18             clc
000290r 2               
000290r 2               return:
000290r 2                 ; sta kb_prev_char
000290r 2               ; Copy BufferNew to BufferOld
000290r 2  A6 rr          ldx new_keys
000292r 2  8E rr rr       stx old_keys
000295r 2  A6 rr          ldx new_keys+1
000297r 2  8E rr rr       stx old_keys+1
00029Ar 2  A6 rr          ldx new_keys+2
00029Cr 2  8E rr rr       stx old_keys+2
00029Fr 2  A6 rr          ldx new_keys+3
0002A1r 2  8E rr rr       stx old_keys+3
0002A4r 2  A6 rr          ldx new_keys+4
0002A6r 2  8E rr rr       stx old_keys+4
0002A9r 2  A6 rr          ldx new_keys+5
0002ABr 2  8E rr rr       stx old_keys+5
0002AEr 2  A6 rr          ldx new_keys+6
0002B0r 2  8E rr rr       stx old_keys+6
0002B3r 2  A6 rr          ldx new_keys+7
0002B5r 2  8E rr rr       stx old_keys+7
0002B8r 2  7A             ply
0002B9r 2  FA             plx
0002BAr 2  60             rts
0002BBr 2               
0002BBr 2               too_many_new_keys:
0002BBr 2  18               clc
0002BCr 2  A9 FF            lda #$ff
0002BEr 2  8D rr rr         sta buffer_quantity
0002C1r 2  8D rr rr         sta simultaneous_keys
0002C4r 2  A9 00            lda #$0
0002C6r 2  7A               ply
0002C7r 2  FA               plx
0002C8r 2  60               rts
0002C9r 2               
0002C9r 2               keys_in_row:
0002C9r 2  0A             asl
0002CAr 2  90 03          bcc @1
0002CCr 2  20 rr rr       jsr key_found
0002CFr 2               @1:
0002CFr 2  E8             inx
0002D0r 2  0A             asl
0002D1r 2  90 03          bcc @2
0002D3r 2  20 rr rr       jsr key_found
0002D6r 2               @2:
0002D6r 2  E8             inx
0002D7r 2  0A             asl
0002D8r 2  90 03          bcc @3
0002DAr 2  20 rr rr       jsr key_found
0002DDr 2               @3:
0002DDr 2  E8             inx
0002DEr 2  0A             asl
0002DFr 2  90 03          bcc @4
0002E1r 2  20 rr rr       jsr key_found
0002E4r 2               @4:
0002E4r 2  E8             inx
0002E5r 2  0A             asl
0002E6r 2  90 03          bcc @5
0002E8r 2  20 rr rr       jsr key_found
0002EBr 2               @5:
0002EBr 2  E8             inx
0002ECr 2  0A             asl
0002EDr 2  90 03          bcc @6
0002EFr 2  20 rr rr       jsr key_found
0002F2r 2               @6:
0002F2r 2  E8             inx
0002F3r 2  0A             asl
0002F4r 2  90 03          bcc @7
0002F6r 2  20 rr rr       jsr key_found
0002F9r 2               @7:
0002F9r 2  E8             inx
0002FAr 2  0A             asl
0002FBr 2  90 03          bcc @8
0002FDr 2  20 rr rr       jsr key_found
000300r 2               @8:
000300r 2               
000300r 2  60             rts
000301r 2               
000301r 2               key_found:
000301r 2  DA             phx
000302r 2  8E 81 FF       stx PORTA
000305r 2  CE rr rr       dec key_quantity
000308r 2  30 14          bmi overflow
00030Ar 2                 ; pha
00030Ar 2                 ; txa
00030Ar 2  AC rr rr       ldy kb_control_keys_mask
00030Dr 2  D0 05          bne @shifted
00030Fr 2               
00030Fr 2  BC rr rr       ldy keymap,x
000312r 2  80 03          bra @unshifted
000314r 2               @shifted:
000314r 2  BC rr rr       ldy shifted_keymap,x
000317r 2               @unshifted:
000317r 2  AE rr rr       ldx key_quantity
00031Ar 2  94 rr          sty new_keys,x
00031Cr 2                 ; sta new_keys,x
00031Cr 2                 ; pla
00031Cr 2  FA             plx
00031Dr 2  60             rts
00031Er 2               
00031Er 2               overflow:
00031Er 2  FA             plx
00031Fr 2  68             pla  ; Dirty hack to handle 2 layers of JSR
000320r 2  68             pla
000321r 2  68             pla
000322r 2  68             pla
000323r 2  7A             ply
000324r 2  FA             plx
000325r 2  A9 00          lda #0
000327r 2  18             clc
000328r 2  60             rts
000329r 2               
000329r 1               ; .include "drivers/ps2.s"
000329r 1               .include "drivers/delayroutines.s"
000329r 2               ; Copyright 2020 Jonathan Foucher
000329r 2               
000329r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000329r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000329r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000329r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000329r 2               ; is furnished to do so, subject to the following conditions:
000329r 2               
000329r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000329r 2               ; substantial portions of the Software.
000329r 2               
000329r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000329r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000329r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000329r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000329r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000329r 2               ; DEALINGS IN THE SOFTWARE.
000329r 2               
000329r 2               
000329r 2               ; this routine delays by 2304 * y + 23 cycles
000329r 2               delay:
000329r 2  DA             phx       ; 3 cycles
00032Ar 2  5A             phy       ; 3 cycles
00032Br 2               two:
00032Br 2  A2 FF          ldx #$ff  ; 2 cycles
00032Dr 2               one:
00032Dr 2  EA             nop       ; 2 cycles
00032Er 2  EA             nop       ; 2 cycles
00032Fr 2  CA             dex       ; 2 cycles
000330r 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
000332r 2  88             dey       ; 2 cycles
000333r 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
000335r 2  7A             ply       ; 4 cycles
000336r 2  FA             plx       ; 4 cycles
000337r 2  60             rts       ; 6 cycles
000338r 2               
000338r 2               ; delay is in Y register
000338r 2               delay_long:
000338r 2  48             pha
000339r 2  5A             phy
00033Ar 2  DA             phx
00033Br 2  98             tya
00033Cr 2  AA             tax
00033Dr 2               delay_long_loop:
00033Dr 2  A0 FF          ldy #$ff
00033Fr 2  20 rr rr       jsr delay
000342r 2  CA             dex
000343r 2  D0 F8          bne delay_long_loop
000345r 2  FA             plx
000346r 2  7A             ply
000347r 2  68             pla
000348r 2  60             rts
000349r 2               
000349r 2               delay_short:        ; delay Y * 19 cycles
000349r 2  5A             phy
00034Ar 2               delay_short_loop:
00034Ar 2  EA             nop               ; 2 cycles
00034Br 2  EA             nop               ; 2 cycles
00034Cr 2  EA             nop               ; 2 cycles
00034Dr 2  EA             nop               ; 2 cycles
00034Er 2  EA             nop               ; 2 cycles
00034Fr 2  EA             nop               ; 2 cycles
000350r 2  EA             nop               ; 2 cycles
000351r 2               
000351r 2               
000351r 2  88             dey               ; 2 cycles
000352r 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
000354r 2  7A             ply
000355r 2  60             rts
000356r 2               
000356r 1               .include "drivers/lcd.s"
000356r 2               .segment "ZEROPAGE": zeropage
000017r 2  xx           LCD_BUF_W_PTR: .res 1
000018r 2  xx           LCD_BUF_R_PTR: .res 1
000019r 2  xx           lcd_pos: .res 1
00001Ar 2               
00001Ar 2               .segment "BSS"
000017r 2  xx xx xx xx  LCD_BUF: .res 128
00001Br 2  xx xx xx xx  
00001Fr 2  xx xx xx xx  
000097r 2               
000097r 2               .segment "DATA"
000356r 2               
000356r 2               ; initialize the LCD in 8 bit mode
000356r 2               lcd_init:
000356r 2  20 rr rr         jsr buf_clr
000359r 2  A9 00            lda #0
00035Br 2  8D rr rr         sta lcd_absent
00035Er 2  85 rr            sta LCD_BUF_W_PTR
000360r 2  85 rr            sta LCD_BUF_R_PTR
000362r 2  85 rr            sta lcd_pos
000364r 2               
000364r 2               
000364r 2  A0 FF            ldy #$FF
000366r 2  20 rr rr         jsr delay
000369r 2               
000369r 2  A9 38            LDA #$38            ;function set: 8 bit
00036Br 2  20 rr rr         jsr lcd_inst
00036Er 2               
00036Er 2               
00036Er 2  A0 FF            ldy #$FF
000370r 2  20 rr rr         jsr delay
000373r 2               
000373r 2  A9 0F            LDA #$0F            ;display on, cursor on, blink on
000375r 2  20 rr rr         jsr lcd_inst
000378r 2               
000378r 2                   ;entry mode set
000378r 2  A9 06            LDA #$06
00037Ar 2  20 rr rr         jsr lcd_inst
00037Dr 2               
00037Dr 2                   ;clear display
00037Dr 2  A9 01            LDA #$01
00037Fr 2  20 rr rr         jsr lcd_inst
000382r 2               
000382r 2  A0 FF            ldy #$ff            ; wait a while
000384r 2  20 rr rr         jsr delay
000387r 2                   ;set dram address to start of screen
000387r 2  A9 80            LDA #$80
000389r 2  20 rr rr         jsr lcd_inst
00038Cr 2               
00038Cr 2  A0 FF            ldy #$ff            ; wait a while
00038Er 2  20 rr rr         jsr delay
000391r 2               
000391r 2               
000391r 2  60               RTS
000392r 2               
000392r 2               ; Send an instruction in 8 bit mode
000392r 2               lcd_inst:
000392r 2  5A               phy
000393r 2  8D C1 FF         sta LCD_ADDR_ENABLED
000396r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
000398r 2  20 rr rr         jsr delay_short
00039Br 2  8D C0 FF         sta LCD_ADDR_DISABLED
00039Er 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
0003A0r 2  20 rr rr         jsr delay_short
0003A3r 2  7A               ply
0003A4r 2  60               rts
0003A5r 2               
0003A5r 2               lcd_send:
0003A5r 2  8D C3 FF         sta LCD_DATA_ENABLED
0003A8r 2  A0 02            ldy #$2                    ; Delay 38 clock cycles - 3 us at 12.5 MHz
0003AAr 2  20 rr rr         jsr delay_short
0003ADr 2  8D C2 FF         sta LCD_DATA_DISABLED
0003B0r 2  A0 20            ldy #$20                     ; Delay 608 clock cycles - 48 us at 12.5 MHz
0003B2r 2  20 rr rr         jsr delay_short
0003B5r 2  60               rts
0003B6r 2               
0003B6r 2               ; Sends the character in A to the display
0003B6r 2               lcd_print:               ; 8 bit data in A
0003B6r 2  5A               phy
0003B7r 2  DA               phx
0003B8r 2  48               pha
0003B9r 2  C9 0A            cmp #$0A
0003BBr 2  F0 67            beq @next_line
0003BDr 2  C9 0D            cmp #$0D
0003BFr 2  F0 63            beq @next_line
0003C1r 2  C9 08            cmp #$08            ;backspace
0003C3r 2  F0 1F            beq @backspace
0003C5r 2               
0003C5r 2  20 rr rr         jsr lcd_send
0003C8r 2  A6 rr            ldx lcd_pos
0003CAr 2  9D rr rr         sta LCD_BUF, x
0003CDr 2               
0003CDr 2  E8               inx
0003CEr 2                   ; Check at which position we are and change line if necessary
0003CEr 2  86 rr            stx lcd_pos
0003D0r 2               
0003D0r 2  E0 14            cpx #20
0003D2r 2  F0 2A            beq @line_2
0003D4r 2  E0 28            cpx #40
0003D6r 2  F0 31            beq @line_3
0003D8r 2  E0 3C            cpx #60
0003DAr 2  F0 38            beq @line_4
0003DCr 2  E0 50            cpx #80
0003DEr 2  F0 3F            beq @clr
0003E0r 2               
0003E0r 2               @continue:
0003E0r 2  68               pla
0003E1r 2  FA               plx
0003E2r 2  7A               ply
0003E3r 2  60               rts
0003E4r 2               
0003E4r 2               ; LCD adressing http://web.alfredstate.edu/faculty/weimandn/lcd/lcd_addressing/lcd_addressing_index.html
0003E4r 2               @backspace:
0003E4r 2  A9 10            lda #$10            ; shift cursor left
0003E6r 2  20 rr rr         jsr lcd_inst
0003E9r 2  A9 20            lda #$20            ; print a space to erase previous char
0003EBr 2  20 rr rr         jsr lcd_send
0003EEr 2               
0003EEr 2  A9 10            lda #$10            ; shift cursor left
0003F0r 2  20 rr rr         jsr lcd_inst
0003F3r 2  C6 rr            dec lcd_pos
0003F5r 2  A6 rr            ldx lcd_pos         ; save in buffer
0003F7r 2  A9 20            lda #$20
0003F9r 2  9D rr rr         sta LCD_BUF,x
0003FCr 2  80 E2            bra @continue
0003FEr 2               @line_2:
0003FEr 2  A9 14            lda #20
000400r 2  85 rr            sta lcd_pos
000402r 2  A9 C0            lda #$C0
000404r 2  20 rr rr         jsr lcd_inst
000407r 2  80 D7            bra @continue
000409r 2               
000409r 2               @line_3:
000409r 2  A9 28            lda #40
00040Br 2  85 rr            sta lcd_pos
00040Dr 2  A9 94            lda #$94
00040Fr 2  20 rr rr         jsr lcd_inst
000412r 2  80 CC            bra @continue
000414r 2               
000414r 2               @line_4:
000414r 2  A9 3C            lda #60
000416r 2  85 rr            sta lcd_pos
000418r 2  A9 D4            lda #$D4
00041Ar 2  20 rr rr         jsr lcd_inst
00041Dr 2  80 C1            bra @continue
00041Fr 2               @clr:
00041Fr 2                   ; lda #0
00041Fr 2                   ; sta lcd_pos
00041Fr 2                   ; lda #$80
00041Fr 2                   ; jsr lcd_inst
00041Fr 2  20 rr rr         jsr lcd_scroll_up
000422r 2  80 BC            bra @continue
000424r 2               
000424r 2               @next_line:
000424r 2  A6 rr            ldx lcd_pos            ;get current position
000426r 2  E0 50            cpx #80
000428r 2  F0 F5            beq @clr
00042Ar 2  E0 3C            cpx #60
00042Cr 2  F0 E6            beq @line_4
00042Er 2  E0 28            cpx #40
000430r 2  F0 D7            beq @line_3
000432r 2  E0 14            cpx #20
000434r 2  F0 C8            beq @line_2
000436r 2  E8               inx
000437r 2  86 rr            stx lcd_pos
000439r 2  A9 20            lda #$20
00043Br 2  20 rr rr         jsr lcd_send
00043Er 2  9D rr rr         sta LCD_BUF, x
000441r 2  80 E1            bra @next_line
000443r 2               
000443r 2               lcd_scroll_up:
000443r 2  48               pha                     ; save registers
000444r 2  5A               phy
000445r 2  DA               phx
000446r 2  A9 80            lda #$80                ; set LCD address to start
000448r 2  20 rr rr         jsr lcd_inst
00044Br 2               
00044Br 2  A2 14            ldx #20                 ; start getting characters at the start of the second line
00044Dr 2               @scroll_loop:
00044Dr 2  BD rr rr         lda LCD_BUF, X          ; load from buffer
000450r 2  20 rr rr         jsr lcd_send            ; send to display
000453r 2  A8               tay                     ; save current character in Y
000454r 2  E0 4F            cpx #79                 ; update LCD address if necessary
000456r 2  F0 4A            beq @scline_4
000458r 2  E0 3B            cpx #59
00045Ar 2  F0 3F            beq @scline_3
00045Cr 2  E0 27            cpx #39
00045Er 2  F0 34            beq @scline_2
000460r 2               @sccontinue:                ; return from updating LCD address
000460r 2  8A               txa                     ; copy X to A to be able to subtract from it
000461r 2  38               sec                     ; set carry before subtraction
000462r 2  E9 14            sbc #20                 ; subtract 20 to get where to put this character
000464r 2  AA               tax                     ; put the result in X
000465r 2  98               tya                     ; restore character from Y
000466r 2  9D rr rr         sta LCD_BUF, X          ; store char in buffer
000469r 2  8A               txa                     ; copy X to A to be able to add to it
00046Ar 2  18               clc
00046Br 2  69 14            adc #20                 ; add 20 to restore X
00046Dr 2  AA               tax                     ; put the result back in X
00046Er 2  E8               inx                     ; increment X to prepare to get next char
00046Fr 2  E0 50            cpx #80                 ; if not at end of buffer
000471r 2  90 DA            bcc @scroll_loop        ; do next char
000473r 2                   ; fill the last line with spaces
000473r 2  A9 D4            lda #$D4                ; set address to last line
000475r 2  20 rr rr         jsr lcd_inst
000478r 2  A9 20            lda #$20
00047Ar 2  A2 3C            ldx #60
00047Cr 2               @last_line_loop:
00047Cr 2  9D rr rr         sta LCD_BUF, x
00047Fr 2  20 rr rr         jsr lcd_send
000482r 2  E8               inx
000483r 2  E0 50            cpx #80                 ; if not at end of buffer
000485r 2  90 F5            bcc @last_line_loop     ; do next char
000487r 2               
000487r 2                   ;finally, place the cursor at the start of the last line
000487r 2  A9 3C            lda #60
000489r 2  85 rr            sta lcd_pos
00048Br 2  A9 D4            lda #$D4
00048Dr 2  20 rr rr         jsr lcd_inst
000490r 2  FA               plx                     ; restore everything as it was
000491r 2  7A               ply
000492r 2  68               pla
000493r 2  60               rts
000494r 2               
000494r 2               @scline_2:
000494r 2  A9 C0            lda #$C0
000496r 2  20 rr rr         jsr lcd_inst
000499r 2  80 C5            bra @sccontinue
00049Br 2               
00049Br 2               @scline_3:
00049Br 2  A9 94            lda #$94
00049Dr 2  20 rr rr         jsr lcd_inst
0004A0r 2  80 BE            bra @sccontinue
0004A2r 2               
0004A2r 2               @scline_4:
0004A2r 2  A9 D4            lda #$D4
0004A4r 2  20 rr rr         jsr lcd_inst
0004A7r 2  80 B7            bra @sccontinue
0004A9r 2               
0004A9r 2               lcd_clear:
0004A9r 2  48               PHA
0004AAr 2                   ;clear display
0004AAr 2  A9 01            LDA #$01
0004ACr 2  20 rr rr         jsr lcd_inst
0004AFr 2                   ;set dram address
0004AFr 2  A9 80            LDA #$80
0004B1r 2  20 rr rr         jsr lcd_inst
0004B4r 2  68               PLA
0004B5r 2  60               RTS
0004B6r 2               
0004B6r 2               
0004B6r 2               buf_clr:
0004B6r 2  48               pha
0004B7r 2  DA               phx
0004B8r 2  A2 80            ldx #$80
0004BAr 2  A9 20            lda #$20
0004BCr 2               buf_clr_loop:
0004BCr 2  9D rr rr         sta LCD_BUF,X
0004BFr 2  CA               dex
0004C0r 2  D0 FA            bne buf_clr_loop
0004C2r 2  FA               plx
0004C3r 2  68               pla
0004C4r 2  60               rts
0004C5r 2               
0004C5r 1               .include "drivers/spi.s"
0004C5r 2               ; SPI defines
0004C5r 2               
0004C5r 2               SS = $07   ; Slave Select with lowest 3 bits
0004C5r 2               SCK = $08   ; Clock on bit 3
0004C5r 2               MISO = $10  ; MISO on bit 4
0004C5r 2               MOSI = $20  ; MOSI on bit 5
0004C5r 2               CONF = $40  ; CONF on bit 6
0004C5r 2               
0004C5r 2               .segment "BSS"
000097r 2  xx           spi_tmp: .res 1
000098r 2  xx           spi_tmp2: .res 1
000099r 2  xx           spi_slave: .res 1
00009Ar 2               
00009Ar 2               .segment "DATA"
0004C5r 2               
0004C5r 2               spi_init:
0004C5r 2  AD 80 FF         lda PORTB               ; load current port B
0004C8r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
0004CAr 2  09 40            ora #CONF               ; set CONF high
0004CCr 2  8D 80 FF         sta PORTB               ; save to PORTB
0004CFr 2  AD 82 FF         lda DDRB                ; get current direction register
0004D2r 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
0004D4r 2  29 EF            and #($FF^MISO)                 ; set MISO as input
0004D6r 2  8D 82 FF         sta DDRB
0004D9r 2  A9 FF            lda #$FF
0004DBr 2  8D 83 FF         sta DDRA
0004DEr 2  8D 81 FF         sta PORTA
0004E1r 2               
0004E1r 2  60               rts
0004E2r 2               
0004E2r 2               spi_select:
0004E2r 2                   ; selected slave in A
0004E2r 2  29 07            and #SS                 ; mask slave select bits
0004E4r 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
0004E7r 2  8D 81 FF         sta PORTA
0004EAr 2  8D rr rr         sta spi_slave
0004EDr 2  5A               phy
0004EEr 2  A0 01            ldy #$1
0004F0r 2  20 rr rr         jsr delay_short         ; slight delay
0004F3r 2  09 40            ora #CONF               ; set CONF high to latch address
0004F5r 2  8D 80 FF         sta PORTB               ; save to PORTB
0004F8r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
0004F9r 2  60               rts
0004FAr 2               
0004FAr 2               spi_clk_toggle:
0004FAr 2  60               rts
0004FBr 2               
0004FBr 2               spi_transceive:
0004FBr 2                   ; send data in A, received data will be in A
0004FBr 2  5A               phy
0004FCr 2                   ; save data in RAM
0004FCr 2  8D rr rr         sta spi_tmp
0004FFr 2                   ; reset X
0004FFr 2  DA               phx
000500r 2  A2 08            ldx #8
000502r 2                   ; reset result
000502r 2  9C rr rr         stz spi_tmp2
000505r 2               spi_send_loop:
000505r 2  0E rr rr         asl spi_tmp
000508r 2  90 08            bcc bit_unset
00050Ar 2               bit_set:
00050Ar 2  AD 80 FF         lda PORTB
00050Dr 2  09 60            ora #(MOSI | CONF)
00050Fr 2  4C rr rr         jmp clock_on
000512r 2               bit_unset:
000512r 2  AD 80 FF         lda PORTB
000515r 2  29 DF            and #(($FF^MOSI) | CONF)
000517r 2               clock_on:
000517r 2                   ; set data bit
000517r 2  0D rr rr         ora spi_slave
00051Ar 2  8D 80 FF         sta PORTB
00051Dr 2               
00051Dr 2                   ; set clock on
00051Dr 2  09 48            ora #(SCK | CONF)
00051Fr 2  0D rr rr         ora spi_slave
000522r 2  8D 80 FF         sta PORTB
000525r 2               
000525r 2                   ; read bit from slave, maybe add slight delay here ?
000525r 2  AD 80 FF         lda PORTB
000528r 2  29 10            and #MISO           ; mask miso bit
00052Ar 2  D0 07            bne spi_bit_set      ; bit is set
00052Cr 2                   ; bit is unset
00052Cr 2  18               clc
00052Dr 2  2E rr rr         rol spi_tmp2
000530r 2  4C rr rr         jmp clock_off
000533r 2               
000533r 2               spi_bit_set:
000533r 2  38               sec
000534r 2  2E rr rr         rol spi_tmp2
000537r 2               
000537r 2               
000537r 2               clock_off:
000537r 2  AD 80 FF         lda PORTB
00053Ar 2  29 F7            and #(($FF^SCK) | CONF)
00053Cr 2  0D rr rr         ora spi_slave
00053Fr 2  8D 80 FF         sta PORTB
000542r 2               end_loop:
000542r 2  CA               dex
000543r 2  D0 C0            bne spi_send_loop
000545r 2                   ; set data low
000545r 2  A0 01            ldy #$1
000547r 2  20 rr rr         jsr delay_short
00054Ar 2  AD 80 FF         lda PORTB
00054Dr 2  0D rr rr         ora spi_slave
000550r 2  29 DF            and #(($FF^MOSI) | CONF)
000552r 2  8D 80 FF         sta PORTB
000555r 2  FA               plx
000556r 2  7A               ply
000557r 2  AD rr rr         lda spi_tmp2
00055Ar 2  60               rts
00055Br 2               
00055Br 1               .include "drivers/sd.s"
00055Br 2               ; SD card driver
00055Br 2               
00055Br 2               ; SD card initialization routine
00055Br 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
00055Br 2               
00055Br 2               .segment "ZEROPAGE": zeropage
00001Ar 2  xx xx        sd_buffer_address: .res 2
00001Cr 2               
00001Cr 2               .segment "BSS"
00009Ar 2  xx           sd_sector: .res 1
00009Br 2  xx xx        SD_TMP: .res 2
00009Dr 2               
00009Dr 2  xx           SD_CRC: .res 1
00009Er 2  xx           SD_SLAVE: .res 1
00009Fr 2  xx xx xx xx  SD_ARG: .res 4
0000A3r 2  xx xx xx xx  SD_BUF: .res $800
0000A7r 2  xx xx xx xx  
0000ABr 2  xx xx xx xx  
0008A3r 2               
0008A3r 2               .segment "DATA"
00055Br 2               
00055Br 2               sd_init:                    ; slave address in A
00055Br 2  8D rr rr         sta SD_SLAVE             ; save slave address for later use
00055Er 2  DA               phx
00055Fr 2  20 rr rr         jsr spi_init                ; init SPI system
000562r 2  A9 00            lda #0
000564r 2  20 rr rr         jsr spi_select          ; DEselect slave
000567r 2  8D rr rr         sta SD_ARG
00056Ar 2  8D rr rr         sta SD_ARG+1            ; clear command argument
00056Dr 2  8D rr rr         sta SD_ARG+2
000570r 2  8D rr rr         sta SD_ARG+3
000573r 2  A9 95            lda #$95
000575r 2  8D rr rr         sta SD_CRC              ; set CRC for CMD0
000578r 2                   ; clear SD buffer
000578r 2  A2 FF            ldx #$FF
00057Ar 2               clear_sd_buf_loop1:
00057Ar 2  9E rr rr         stz SD_BUF, X
00057Dr 2  CA               dex
00057Er 2  D0 FA            bne clear_sd_buf_loop1
000580r 2               
000580r 2  CA               dex
000581r 2               clear_sd_buf_loop2:
000581r 2  9E rr rr         stz SD_BUF+256, x
000584r 2  CA               dex
000585r 2  D0 FA            bne clear_sd_buf_loop2
000587r 2               
000587r 2                   ; send 10 bytes of $FF With SD card deselected
000587r 2               
000587r 2  A2 0A            ldx #10
000589r 2               init_loop:
000589r 2  A9 FF            lda #$FF
00058Br 2  20 rr rr         jsr spi_transceive
00058Er 2  CA               dex
00058Fr 2  D0 F8            bne init_loop
000591r 2               
000591r 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
000594r 2  C9 01            cmp #$01                ; Check for idle state
000596r 2  D0 55            bne sd_error
000598r 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
00059Br 2  C9 01            cmp #$01                ; Check for idle state
00059Dr 2  D0 4E            bne sd_error
00059Fr 2                   ; TODO check if long response is $01AA
00059Fr 2               
00059Fr 2                   ; wait for card to be initialized
00059Fr 2  A2 FF            ldx #$ff    ; Max times to loop
0005A1r 2  9C rr rr         stz SD_ARG
0005A4r 2  9C rr rr         stz SD_ARG+1
0005A7r 2  9C rr rr         stz SD_ARG+2
0005AAr 2  9C rr rr         stz SD_ARG+3
0005ADr 2               sd_init_loop2:
0005ADr 2  CA               dex
0005AEr 2  F0 3D            beq sd_error
0005B0r 2  9C rr rr         stz SD_ARG+3
0005B3r 2  A9 37            lda #55
0005B5r 2  20 rr rr         jsr sd_command
0005B8r 2  A9 40            lda #$40
0005BAr 2  8D rr rr         sta SD_ARG+3
0005BDr 2  A9 29            lda #41
0005BFr 2  20 rr rr         jsr sd_command
0005C2r 2               
0005C2r 2  D0 E9            bne sd_init_loop2
0005C4r 2               
0005C4r 2  A9 3A            lda #58
0005C6r 2  20 rr rr         jsr sd_command
0005C9r 2  AD rr rr         lda SD_BUF
0005CCr 2  29 40            and #$40
0005CEr 2  F0 07            beq force_block_size    ; CCS bit is unset, force block addressing
0005D0r 2               sd_init_exit_success:
0005D0r 2  FA               plx
0005D1r 2  9C rr rr         stz SD_CRC              ; reset CRC to zero
0005D4r 2  A9 00            lda #0
0005D6r 2               
0005D6r 2  60               rts
0005D7r 2               
0005D7r 2               force_block_size:
0005D7r 2  9C rr rr         stz SD_ARG
0005DAr 2  9C rr rr         stz SD_ARG+1
0005DDr 2  A9 02            lda #$2
0005DFr 2  8D rr rr         sta SD_ARG+2
0005E2r 2  9C rr rr         stz SD_ARG+3    ; set block size to $200 (512 bytes)
0005E5r 2  A9 10            lda #$10
0005E7r 2  20 rr rr         jsr sd_command
0005EAr 2  4C rr rr         jmp sd_init_exit_success
0005EDr 2               
0005EDr 2               sd_error:
0005EDr 2  FA               plx
0005EEr 2  A9 01            lda #1
0005F0r 2  60               rts
0005F1r 2               
0005F1r 2               sd_command:         ; command index is in A
0005F1r 2  29 3F            and #$3F        ; only keep low 6 bits
0005F3r 2  8D rr rr         sta SD_TMP
0005F6r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
0005F8r 2               
0005F8r 2                   ; Select chip
0005F8r 2  20 rr rr         jsr sd_command_start
0005FBr 2               
0005FBr 2  20 rr rr         jsr spi_transceive  ; send command index
0005FEr 2                   ; command argument is in SD_ARG
0005FEr 2                   ; SPI is big endian, so reverse argument order
0005FEr 2  AD rr rr         lda SD_ARG + 3
000601r 2  20 rr rr         jsr spi_transceive
000604r 2  AD rr rr         lda SD_ARG+2
000607r 2  20 rr rr         jsr spi_transceive
00060Ar 2  AD rr rr         lda SD_ARG+1
00060Dr 2  20 rr rr         jsr spi_transceive
000610r 2  AD rr rr         lda SD_ARG
000613r 2  20 rr rr         jsr spi_transceive
000616r 2  AD rr rr         lda SD_CRC          ; send hardcoded CRC if available
000619r 2  20 rr rr         jsr spi_transceive
00061Cr 2               
00061Cr 2                   ; wait for a zero to be received in the top bit of the response
00061Cr 2               sd_response_wait_loop:
00061Cr 2  A9 FF            lda #$FF
00061Er 2  20 rr rr         jsr spi_transceive
000621r 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
000623r 2               
000623r 2  48               pha
000624r 2               
000624r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
000624r 2               
000624r 2                   ; get 32 bits of response for CMD 8 and CMD 58
000624r 2  AD rr rr         lda SD_TMP
000627r 2  C9 08            cmp #8
000629r 2  F0 0D            beq long_response
00062Br 2  C9 3A            cmp #58
00062Dr 2  F0 09            beq long_response
00062Fr 2  C9 11            cmp #$11
000631r 2  F0 03            beq sd_command_exit_no_end
000633r 2               
000633r 2               sd_command_exit:
000633r 2  20 rr rr         jsr sd_command_end
000636r 2               sd_command_exit_no_end:
000636r 2  68               pla
000637r 2                   ; return the response
000637r 2  60               rts
000638r 2               
000638r 2               long_response:
000638r 2  A9 FF            lda #$FF
00063Ar 2  20 rr rr         jsr spi_transceive
00063Dr 2  8D rr rr         sta SD_BUF
000640r 2  A9 FF            lda #$FF
000642r 2  20 rr rr         jsr spi_transceive
000645r 2  8D rr rr         sta SD_BUF+1
000648r 2  A9 FF            lda #$FF
00064Ar 2  20 rr rr         jsr spi_transceive
00064Dr 2  8D rr rr         sta SD_BUF+2
000650r 2  A9 FF            lda #$FF
000652r 2  20 rr rr         jsr spi_transceive
000655r 2  8D rr rr         sta SD_BUF+3
000658r 2  4C rr rr         jmp sd_command_exit
00065Br 2               
00065Br 2               ; send SD card CMD0
00065Br 2               sd_cmd_0:
00065Br 2  A9 95            lda #$95
00065Dr 2  8D rr rr         sta SD_CRC
000660r 2  9C rr rr         stz SD_ARG
000663r 2  9C rr rr         stz SD_ARG+1
000666r 2  9C rr rr         stz SD_ARG+2
000669r 2  9C rr rr         stz SD_ARG+3
00066Cr 2  A9 00            lda #0
00066Er 2  20 rr rr         jsr sd_command
000671r 2  60               rts
000672r 2               
000672r 2               ; send SD card CMD8
000672r 2               sd_cmd_8:
000672r 2  A9 87            lda #$87
000674r 2  8D rr rr         sta SD_CRC
000677r 2                   ; store in little endian
000677r 2                   ; will be converted to big endian when sending command
000677r 2  9C rr rr         stz SD_ARG+3
00067Ar 2  9C rr rr         stz SD_ARG+2
00067Dr 2  A9 01            lda #1
00067Fr 2  8D rr rr         sta SD_ARG+1
000682r 2  A9 AA            lda #$AA
000684r 2  8D rr rr         sta SD_ARG
000687r 2  A9 48            lda #$48
000689r 2  20 rr rr         jsr sd_command
00068Cr 2               
00068Cr 2  60               rts
00068Dr 2               
00068Dr 2               sd_command_start:
00068Dr 2  48               pha                         ; Save A
00068Er 2  AD rr rr         lda SD_SLAVE
000691r 2  20 rr rr         jsr spi_select
000694r 2  68               pla                         ; Restore A
000695r 2  60               rts
000696r 2               
000696r 2               sd_command_end:
000696r 2  48               pha
000697r 2  A9 00            lda #0
000699r 2  20 rr rr         jsr spi_select
00069Cr 2  A9 FF            lda #$FF
00069Er 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
0006A1r 2  68               pla
0006A2r 2  60               rts
0006A3r 2               
0006A3r 2               
0006A3r 2               sd_readsector:
0006A3r 2                   ; Read a sector from the SD card.  A sector is 512 bytes.
0006A3r 2                   ;
0006A3r 2                   ; Parameters:
0006A3r 2                   ;    sd_sector   32-bit sector number
0006A3r 2                   ;    sd_buffer_address     address of buffer to receive data
0006A3r 2  DA               phx
0006A4r 2  20 rr rr         jsr sd_command_start
0006A7r 2                   ; Command 17, arg is sector number, crc not checked
0006A7r 2  A9 11            lda #$11                    ; CMD17 - READ_SINGLE_BLOCK
0006A9r 2  20 rr rr         jsr sd_command
0006ACr 2               
0006ACr 2  C9 00            cmp #0              ; Check if command accepted by card
0006AEr 2  D0 29            bne @fail
0006B0r 2  A2 FF            ldx #$FF
0006B2r 2               @feloop:
0006B2r 2  CA               dex
0006B3r 2  F0 24            beq @fail           ; the card took too long to get ready
0006B5r 2  A9 FF            lda #$FF
0006B7r 2  20 rr rr         jsr spi_transceive
0006BAr 2  C9 FE            cmp #$FE            ; are we about to receive data ?
0006BCr 2  D0 F4            bne @feloop
0006BEr 2               
0006BEr 2                   ; Read page by page
0006BEr 2  20 rr rr         jsr readpage
0006C1r 2  E6 rr            inc sd_buffer_address+1
0006C3r 2  20 rr rr         jsr readpage
0006C6r 2  C6 rr            dec sd_buffer_address+1
0006C8r 2               
0006C8r 2  A9 FF            lda #$FF
0006CAr 2  20 rr rr         jsr spi_transceive      ; read and discard CRC
0006CDr 2  A9 FF            lda #$FF
0006CFr 2  20 rr rr         jsr spi_transceive
0006D2r 2  20 rr rr         jsr sd_command_end
0006D5r 2  FA               plx
0006D6r 2  A9 00            lda #0
0006D8r 2  60               rts
0006D9r 2               
0006D9r 2               @fail:
0006D9r 2                   ; return 1 means fail
0006D9r 2  20 rr rr         jsr sd_command_end
0006DCr 2  FA               plx
0006DDr 2  A9 01            lda #1
0006DFr 2  60               rts
0006E0r 2               
0006E0r 2               readpage:
0006E0r 2                   ; Read 256 bytes to the address at zp_sd_address
0006E0r 2  5A               phy
0006E1r 2  A0 00            ldy #0
0006E3r 2               @readloop:
0006E3r 2  A9 FF            lda #$FF
0006E5r 2  20 rr rr         jsr spi_transceive
0006E8r 2  91 rr            sta (sd_buffer_address),y
0006EAr 2  C8               iny
0006EBr 2  D0 F6            bne @readloop
0006EDr 2  7A               ply
0006EEr 2  60               rts
0006EFr 2               
0006EFr 2               sd_init_success_message:
0006EFr 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
0006F3r 2  69 6E 69 74  
0006F7r 2  20 4F 4B 0D  
0006FCr 2               
0006FCr 2               sd_init_error_message:
0006FCr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
000700r 2  69 6E 69 74  
000704r 2  20 46 41 49  
00070Cr 2               
00070Cr 2               sd_read_error_message:
00070Cr 2  0D 53 44 20      .byte $0D,"SD read FAIL", $0D, 7, 0
000710r 2  72 65 61 64  
000714r 2  20 46 41 49  
00071Cr 2               
00071Cr 1               ; .include "drivers/vga.s"
00071Cr 1               .include "drivers/fat32.s"
00071Cr 2               
00071Cr 2               ; PARTITION TYPE
00071Cr 2               ; 00h 	Unknown or Nothing
00071Cr 2               ; 01h 	12-bit FAT
00071Cr 2               ; 04h 	16-bit FAT (Partition Smallerthan 32MB)
00071Cr 2               ; 05h 	Extended MS-DOS Partition
00071Cr 2               ; 06h 	16-bit FAT (Partition Largerthan 32MB)
00071Cr 2               ; 0Bh 	32-bit FAT (Partition Up to2048GB)
00071Cr 2               ; 0Ch 	Same as 0BH, but uses LBA1 13h Extensions
00071Cr 2               ; 0Eh 	Same as 06H, but uses LBA1 13h Extensions
00071Cr 2               ; 0Fh 	Same as 05H, but uses LBA1 13h Extensions
00071Cr 2               FSTYPE_FAT32 = $0B
00071Cr 2               FSTYPE_FAT32_1 = $0C
00071Cr 2               fat32_readbuffer = SD_BUF
00071Cr 2               
00071Cr 2               
00071Cr 2               
00071Cr 2               .segment "ZEROPAGE": zeropage
00001Cr 2  xx xx        fat32_filenamepointer: .res 2
00001Er 2               
00001Er 2               
00001Er 2  xx xx xx xx  fat32_fatstart: .res 4
000022r 2  xx xx xx xx  fat32_datastart: .res 4
000026r 2  xx xx xx xx  fat32_rootcluster: .res 4
00002Ar 2  xx           fat32_sectorspercluster: .res 1
00002Br 2  xx           fat32_pendingsectors: .res 1
00002Cr 2  xx xx        fat32_address: .res 2
00002Er 2  xx           fat32_nextcluster: .res 1
00002Fr 2  xx           fat32_bytesremaining: .res 1
000030r 2               
000030r 2               
000030r 2               .segment "DATA"
00071Cr 2               
00071Cr 2               fat32_init:
00071Cr 2                   ; Initialize the module - read the MBR etc, find the partition,
00071Cr 2                   ; and set up the variables ready for navigating the filesystem
00071Cr 2               
00071Cr 2                   ; Read the MBR and extract pertinent information
00071Cr 2  DA               phx
00071Dr 2               
00071Dr 2                   ; Sector 0
00071Dr 2  A9 00            lda #0
00071Fr 2  8D rr rr         sta SD_ARG
000722r 2  8D rr rr         sta SD_ARG+1
000725r 2  8D rr rr         sta SD_ARG+2
000728r 2  8D rr rr         sta SD_ARG+3
00072Br 2               
00072Br 2                   ; Target buffer
00072Br 2  A9 rr            lda #<fat32_readbuffer
00072Dr 2  85 rr            sta sd_buffer_address
00072Fr 2  A9 rr            lda #>fat32_readbuffer
000731r 2  85 rr            sta sd_buffer_address+1
000733r 2               
000733r 2                   ; Do the read
000733r 2  20 rr rr         jsr sd_readsector
000736r 2               
000736r 2                   ; Check some things
000736r 2  AD rr rr         lda fat32_readbuffer+510 ; Boot sector signature 55
000739r 2  C9 55            cmp #$55
00073Br 2  D0 3B            bne @fail
00073Dr 2  AD rr rr         lda fat32_readbuffer+511 ; Boot sector signature aa
000740r 2  C9 AA            cmp #$aa
000742r 2  D0 34            bne @fail
000744r 2               
000744r 2                   ; Find a FAT32 partition
000744r 2  A2 00            ldx #0
000746r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000749r 2  C9 0B            cmp #FSTYPE_FAT32
00074Br 2  F0 2E            beq @foundpart
00074Dr 2  C9 0C            cmp #FSTYPE_FAT32_1
00074Fr 2  F0 2A            beq @foundpart
000751r 2  A2 10            ldx #$10
000753r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000756r 2  C9 0B            cmp #FSTYPE_FAT32
000758r 2  F0 21            beq @foundpart
00075Ar 2  C9 0C            cmp #FSTYPE_FAT32_1
00075Cr 2  F0 1D            beq @foundpart
00075Er 2               
00075Er 2  A2 20            ldx #$20
000760r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000763r 2  C9 0B            cmp #FSTYPE_FAT32
000765r 2  F0 14            beq @foundpart
000767r 2  C9 0C            cmp #FSTYPE_FAT32_1
000769r 2  F0 10            beq @foundpart
00076Br 2               
00076Br 2  A2 30            ldx #$30
00076Dr 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000770r 2  C9 0B            cmp #FSTYPE_FAT32
000772r 2  F0 07            beq @foundpart
000774r 2  C9 0C            cmp #FSTYPE_FAT32_1
000776r 2  F0 03            beq @foundpart
000778r 2               
000778r 2               
000778r 2               @fail:
000778r 2  4C rr rr         jmp @error
00077Br 2               
00077Br 2               @foundpart:
00077Br 2                   ; Read the FAT32 LBA BEGIN
00077Br 2               
00077Br 2  BD rr rr         lda fat32_readbuffer + $1C6,x
00077Er 2  8D rr rr         sta SD_ARG
000781r 2  BD rr rr         lda fat32_readbuffer+$1C7,x
000784r 2  8D rr rr         sta SD_ARG+1
000787r 2  BD rr rr         lda fat32_readbuffer+$1C8,x
00078Ar 2  8D rr rr         sta SD_ARG+2
00078Dr 2  BD rr rr         lda fat32_readbuffer+$1C9,x
000790r 2  8D rr rr         sta SD_ARG+3
000793r 2               
000793r 2  20 rr rr         jsr sd_readsector   ; read FAT32 Volume ID block
000796r 2  C9 01            cmp #1              ; readsector returns 1 on failure
000798r 2  F0 DE            beq @fail
00079Ar 2               
00079Ar 2                   ; Check some things
00079Ar 2  AD rr rr         lda fat32_readbuffer+510 ; FAT32 Volume ID sector signature 55
00079Dr 2  C9 55            cmp #$55
00079Fr 2  D0 D7            bne @fail
0007A1r 2  AD rr rr         lda fat32_readbuffer+511 ; FAT32 Volume ID sector signature aa
0007A4r 2  C9 AA            cmp #$aa
0007A6r 2  D0 D0            bne @fail
0007A8r 2               
0007A8r 2  AD rr rr         lda fat32_readbuffer+$11 ; RootEntCnt should be 0 for FAT32
0007ABr 2  0D rr rr         ora fat32_readbuffer+$12
0007AEr 2  D0 C8            bne @fail
0007B0r 2               
0007B0r 2  AD rr rr         lda fat32_readbuffer+$13 ; TotSec16 should be 0 for FAT32
0007B3r 2  0D rr rr         ora fat32_readbuffer+$14
0007B6r 2  D0 C0            bne @fail
0007B8r 2               
0007B8r 2                   ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
0007B8r 2  AD rr rr         lda fat32_readbuffer+$0B ; low byte should be zero
0007BBr 2  D0 BB            bne @fail
0007BDr 2  AD rr rr         lda fat32_readbuffer+$0C ; high byte is 2 (512), 4, 8, or 16
0007C0r 2  C9 02            cmp #2
0007C2r 2  D0 B4            bne @fail
0007C4r 2               
0007C4r 2                   ; Calculate the starting sector of the FAT
0007C4r 2  18               clc
0007C5r 2  AD rr rr         lda SD_ARG
0007C8r 2  6D rr rr         adc fat32_readbuffer+$0E    ; reserved sectors lo
0007CBr 2  85 rr            sta fat32_fatstart
0007CDr 2  85 rr            sta fat32_datastart
0007CFr 2  AD rr rr         lda SD_ARG+1
0007D2r 2  6D rr rr         adc fat32_readbuffer+$0F    ; reserved sectors hi
0007D5r 2  85 rr            sta fat32_fatstart+1
0007D7r 2  85 rr            sta fat32_datastart+1
0007D9r 2  AD rr rr         lda SD_ARG+2
0007DCr 2  69 00            adc #0
0007DEr 2  85 rr            sta fat32_fatstart+2
0007E0r 2  85 rr            sta fat32_datastart+2
0007E2r 2  AD rr rr         lda SD_ARG+3
0007E5r 2  69 00            adc #0
0007E7r 2  85 rr            sta fat32_fatstart+3
0007E9r 2  85 rr            sta fat32_datastart+3
0007EBr 2               
0007EBr 2                   ; Calculate the starting sector of the data area
0007EBr 2  AE rr rr         ldx fat32_readbuffer+16   ; number of FATs
0007EEr 2               @skipfatsloop:
0007EEr 2  18               clc
0007EFr 2  A5 rr            lda fat32_datastart
0007F1r 2  6D rr rr         adc fat32_readbuffer+36 ; fatsize 0
0007F4r 2  85 rr            sta fat32_datastart
0007F6r 2  A5 rr            lda fat32_datastart+1
0007F8r 2  6D rr rr         adc fat32_readbuffer+37 ; fatsize 1
0007FBr 2  85 rr            sta fat32_datastart+1
0007FDr 2  A5 rr            lda fat32_datastart+2
0007FFr 2  6D rr rr         adc fat32_readbuffer+38 ; fatsize 2
000802r 2  85 rr            sta fat32_datastart+2
000804r 2  A5 rr            lda fat32_datastart+3
000806r 2  6D rr rr         adc fat32_readbuffer+39 ; fatsize 3
000809r 2  85 rr            sta fat32_datastart+3
00080Br 2  CA               dex
00080Cr 2  D0 E0            bne @skipfatsloop
00080Er 2               
00080Er 2                   ; Sectors-per-cluster is a power of two from 1 to 128
00080Er 2  AD rr rr         lda fat32_readbuffer+13
000811r 2  85 rr            sta fat32_sectorspercluster
000813r 2               
000813r 2                   ; Remember the root cluster
000813r 2  AD rr rr         lda fat32_readbuffer+44
000816r 2  85 rr            sta fat32_rootcluster
000818r 2  AD rr rr         lda fat32_readbuffer+45
00081Br 2  85 rr            sta fat32_rootcluster+1
00081Dr 2  AD rr rr         lda fat32_readbuffer+46
000820r 2  85 rr            sta fat32_rootcluster+2
000822r 2  AD rr rr         lda fat32_readbuffer+47
000825r 2  85 rr            sta fat32_rootcluster+3
000827r 2               
000827r 2  FA               plx
000828r 2  A9 00            lda #0
00082Ar 2  60               rts
00082Br 2               
00082Br 2               @error:
00082Br 2  FA               plx
00082Cr 2  A9 01            lda #1
00082Er 2  60               rts
00082Fr 2               
00082Fr 2               
00082Fr 2               fat32_seekcluster:
00082Fr 2  5A               phy
000830r 2                   ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
000830r 2               
000830r 2                   ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
000830r 2  A5 rr            lda fat32_nextcluster
000832r 2  0A               asl
000833r 2  A5 rr            lda fat32_nextcluster+1
000835r 2  2A               rol
000836r 2  8D rr rr         sta SD_ARG
000839r 2  A5 rr            lda fat32_nextcluster+2
00083Br 2  2A               rol
00083Cr 2  8D rr rr         sta SD_ARG+1
00083Fr 2  A5 rr            lda fat32_nextcluster+3
000841r 2  2A               rol
000842r 2  8D rr rr         sta SD_ARG+2
000845r 2                   ; note: cluster numbers never have the top bit set, so no carry can occur
000845r 2                   ; Add FAT starting sector
000845r 2  AD rr rr         lda SD_ARG
000848r 2  65 rr            adc fat32_fatstart
00084Ar 2  8D rr rr         sta SD_ARG
00084Dr 2  AD rr rr         lda SD_ARG+1
000850r 2  65 rr            adc fat32_fatstart+1
000852r 2  8D rr rr         sta SD_ARG+1
000855r 2  AD rr rr         lda SD_ARG+2
000858r 2  65 rr            adc fat32_fatstart+2
00085Ar 2  8D rr rr         sta SD_ARG+2
00085Dr 2  A9 00            lda #0
00085Fr 2  65 rr            adc fat32_fatstart+3
000861r 2  8D rr rr         sta SD_ARG+3
000864r 2                   ; Target buffer
000864r 2  A9 rr            lda #<fat32_readbuffer
000866r 2  85 rr            sta sd_buffer_address
000868r 2  A9 rr            lda #>fat32_readbuffer
00086Ar 2  85 rr            sta sd_buffer_address+1
00086Cr 2                   ; Read the sector from the FAT
00086Cr 2  20 rr rr         jsr sd_readsector
00086Fr 2               
00086Fr 2                   ; Before using this FAT data, set currentsector ready to read the cluster itself
00086Fr 2                   ; We need to multiply the cluster number minus two by the number of sectors per
00086Fr 2                   ; cluster, then add the data region start sector
00086Fr 2               
00086Fr 2                   ; Subtract two from cluster number
00086Fr 2  38               sec
000870r 2  A5 rr            lda fat32_nextcluster
000872r 2  E9 02            sbc #2
000874r 2  8D rr rr         sta SD_ARG
000877r 2  A5 rr            lda fat32_nextcluster+1
000879r 2  E9 00            sbc #0
00087Br 2  8D rr rr         sta SD_ARG+1
00087Er 2  A5 rr            lda fat32_nextcluster+2
000880r 2  E9 00            sbc #0
000882r 2  8D rr rr         sta SD_ARG+2
000885r 2  A5 rr            lda fat32_nextcluster+3
000887r 2  E9 00            sbc #0
000889r 2  8D rr rr         sta SD_ARG+3
00088Cr 2               
00088Cr 2                   ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
00088Cr 2  A5 rr            lda fat32_sectorspercluster
00088Er 2               @spcshiftloop:
00088Er 2  4A               lsr
00088Fr 2  B0 0F            bcs @spcshiftloopdone
000891r 2  0E rr rr         asl SD_ARG
000894r 2  2E rr rr         rol SD_ARG+1
000897r 2  2E rr rr         rol SD_ARG+2
00089Ar 2  2E rr rr         rol SD_ARG+3
00089Dr 2  4C rr rr         jmp @spcshiftloop
0008A0r 2               @spcshiftloopdone:
0008A0r 2               
0008A0r 2                   ; Add the data region start sector
0008A0r 2  18               clc
0008A1r 2  AD rr rr         lda SD_ARG
0008A4r 2  65 rr            adc fat32_datastart
0008A6r 2  8D rr rr         sta SD_ARG
0008A9r 2  AD rr rr         lda SD_ARG+1
0008ACr 2  65 rr            adc fat32_datastart+1
0008AEr 2  8D rr rr         sta SD_ARG+1
0008B1r 2  AD rr rr         lda SD_ARG+2
0008B4r 2  65 rr            adc fat32_datastart+2
0008B6r 2  8D rr rr         sta SD_ARG+2
0008B9r 2  AD rr rr         lda SD_ARG+3
0008BCr 2  65 rr            adc fat32_datastart+3
0008BEr 2  8D rr rr         sta SD_ARG+3
0008C1r 2               
0008C1r 2                   ; That's now ready for later code to read this sector in - tell it how many consecutive
0008C1r 2                   ; sectors it can now read
0008C1r 2  A5 rr            lda fat32_sectorspercluster
0008C3r 2  85 rr            sta fat32_pendingsectors
0008C5r 2               
0008C5r 2                   ; Now go back to looking up the next cluster in the chain
0008C5r 2                   ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
0008C5r 2               
0008C5r 2                   ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
0008C5r 2  A5 rr            lda fat32_nextcluster
0008C7r 2  29 7F            and #$7f
0008C9r 2  0A               asl
0008CAr 2  0A               asl
0008CBr 2  A8               tay ; Y = low byte of offset
0008CCr 2                   ; Add the potentially carried bit to the high byte of the address
0008CCr 2  A5 rr            lda sd_buffer_address+1
0008CEr 2  69 00            adc #0
0008D0r 2  85 rr            sta sd_buffer_address+1
0008D2r 2               
0008D2r 2                   ; Copy out the next cluster in the chain for later use
0008D2r 2  B1 rr            lda (sd_buffer_address),y
0008D4r 2  85 rr            sta fat32_nextcluster
0008D6r 2  C8               iny
0008D7r 2  B1 rr            lda (sd_buffer_address),y
0008D9r 2  85 rr            sta fat32_nextcluster+1
0008DBr 2  C8               iny
0008DCr 2  B1 rr            lda (sd_buffer_address),y
0008DEr 2  85 rr            sta fat32_nextcluster+2
0008E0r 2  C8               iny
0008E1r 2  B1 rr            lda (sd_buffer_address),y
0008E3r 2  29 0F            and #$0f
0008E5r 2  85 rr            sta fat32_nextcluster+3
0008E7r 2               
0008E7r 2                   ; See if it's the end of the chain
0008E7r 2  09 F0            ora #$f0
0008E9r 2  25 rr            and fat32_nextcluster+2
0008EBr 2  25 rr            and fat32_nextcluster+1
0008EDr 2  C9 FF            cmp #$ff
0008EFr 2  D0 08            bne @notendofchain
0008F1r 2  A5 rr            lda fat32_nextcluster
0008F3r 2  C9 F8            cmp #$f8
0008F5r 2  90 02            bcc @notendofchain
0008F7r 2               
0008F7r 2                   ; It's the end of the chain, set the top bits so that we can tell this later on
0008F7r 2  85 rr            sta fat32_nextcluster+3
0008F9r 2               @notendofchain:
0008F9r 2  7A               ply
0008FAr 2  60               rts
0008FBr 2               
0008FBr 2               
0008FBr 2               fat32_readnextsector:
0008FBr 2                   ; Reads the next sector from a cluster chain into the buffer at fat32_address.
0008FBr 2                   ;
0008FBr 2                   ; Advances the current sector ready for the next read and looks up the next cluster
0008FBr 2                   ; in the chain when necessary.
0008FBr 2                   ;
0008FBr 2                   ; On return, carry is clear if data was read, or set if the cluster chain has ended.
0008FBr 2               
0008FBr 2                   ; Maybe there are pending sectors in the current cluster
0008FBr 2  A5 rr            lda fat32_pendingsectors
0008FDr 2  D0 07            bne @readsector
0008FFr 2               
0008FFr 2                   ; No pending sectors, check for end of cluster chain
0008FFr 2  A5 rr            lda fat32_nextcluster+3
000901r 2  30 24            bmi @endofchain
000903r 2               
000903r 2                   ; Prepare to read the next cluster
000903r 2  20 rr rr         jsr fat32_seekcluster
000906r 2               
000906r 2               @readsector:
000906r 2  C6 rr            dec fat32_pendingsectors
000908r 2               
000908r 2                   ; Set up target address
000908r 2  A5 rr            lda fat32_address
00090Ar 2  85 rr            sta sd_buffer_address
00090Cr 2  A5 rr            lda fat32_address+1
00090Er 2  85 rr            sta sd_buffer_address+1
000910r 2               
000910r 2                   ; Read the sector
000910r 2  20 rr rr         jsr sd_readsector
000913r 2               
000913r 2                   ; Advance to next sector
000913r 2  EE rr rr         inc SD_ARG
000916r 2  D0 0D            bne @sectorincrementdone
000918r 2  EE rr rr         inc SD_ARG+1
00091Br 2  D0 08            bne @sectorincrementdone
00091Dr 2  EE rr rr         inc SD_ARG+2
000920r 2  D0 03            bne @sectorincrementdone
000922r 2  EE rr rr         inc SD_ARG+3
000925r 2               @sectorincrementdone:
000925r 2               
000925r 2                   ; Success - clear carry and return
000925r 2  18               clc
000926r 2  60               rts
000927r 2               
000927r 2               @endofchain:
000927r 2                   ; End of chain - set carry and return
000927r 2  38               sec
000928r 2  60               rts
000929r 2               
000929r 2               
000929r 2               fat32_openroot:
000929r 2                   ; Prepare to read the root directory
000929r 2               
000929r 2  A5 rr            lda fat32_rootcluster
00092Br 2  85 rr            sta fat32_nextcluster
00092Dr 2  A5 rr            lda fat32_rootcluster+1
00092Fr 2  85 rr            sta fat32_nextcluster+1
000931r 2  A5 rr            lda fat32_rootcluster+2
000933r 2  85 rr            sta fat32_nextcluster+2
000935r 2  A5 rr            lda fat32_rootcluster+3
000937r 2  85 rr            sta fat32_nextcluster+3
000939r 2               
000939r 2  20 rr rr         jsr fat32_seekcluster
00093Cr 2               
00093Cr 2                   ; Set the pointer to a large value so we always read a sector the first time through
00093Cr 2                   ; lda #$ff
00093Cr 2                   ; sta sd_buffer_address+1
00093Cr 2  A9 00            lda #0   ; return success
00093Er 2  60               rts
00093Fr 2               
00093Fr 2               
00093Fr 2               fat32_opendirent:
00093Fr 2  5A               phy
000940r 2                   ; Prepare to read from a file or directory based on a dirent
000940r 2                   ;
000940r 2                   ; Point sd_buffer_address at the dirent
000940r 2               
000940r 2                   ; Remember file size in bytes remaining
000940r 2  A0 1C            ldy #28
000942r 2  B1 rr            lda (sd_buffer_address),y
000944r 2  85 rr            sta fat32_bytesremaining
000946r 2  C8               iny
000947r 2  B1 rr            lda (sd_buffer_address),y
000949r 2  85 rr            sta fat32_bytesremaining+1
00094Br 2  C8               iny
00094Cr 2  B1 rr            lda (sd_buffer_address),y
00094Er 2  85 rr            sta fat32_bytesremaining+2
000950r 2  C8               iny
000951r 2  B1 rr            lda (sd_buffer_address),y
000953r 2  85 rr            sta fat32_bytesremaining+3
000955r 2               
000955r 2                   ; Seek to first cluster
000955r 2  A0 1A            ldy #26
000957r 2  B1 rr            lda (sd_buffer_address),y
000959r 2  85 rr            sta fat32_nextcluster
00095Br 2  C8               iny
00095Cr 2  B1 rr            lda (sd_buffer_address),y
00095Er 2  85 rr            sta fat32_nextcluster+1
000960r 2  A0 14            ldy #20
000962r 2  B1 rr            lda (sd_buffer_address),y
000964r 2  85 rr            sta fat32_nextcluster+2
000966r 2  C8               iny
000967r 2  B1 rr            lda (sd_buffer_address),y
000969r 2  85 rr            sta fat32_nextcluster+3
00096Br 2               
00096Br 2  20 rr rr         jsr fat32_seekcluster
00096Er 2               
00096Er 2                   ; Set the pointer to a large value so we always read a sector the first time through
00096Er 2                   ; lda #$ff
00096Er 2                   ; sta sd_buffer_address+1
00096Er 2  7A               ply
00096Fr 2  60               rts
000970r 2               
000970r 2               
000970r 2               fat32_readdirent:
000970r 2                   ; Read a directory entry from the open directory
000970r 2                   ;
000970r 2                   ; On exit the carry is set if there were no more directory entries.
000970r 2                   ;
000970r 2                   ; Otherwise, A is set to the file's attribute byte and
000970r 2                   ; sd_buffer_address points at the returned directory entry.
000970r 2                   ; LFNs and empty entries are ignored automatically.
000970r 2               
000970r 2                   ; Increment pointer by 32 to point to next entry
000970r 2  A9 31            lda #'1'
000972r 2  20 rr rr         jsr kernel_putc
000975r 2  5A               phy
000976r 2  18               clc
000977r 2  A5 rr            lda sd_buffer_address
000979r 2  69 20            adc #32
00097Br 2  85 rr            sta sd_buffer_address
00097Dr 2  A5 rr            lda sd_buffer_address+1
00097Fr 2  69 00            adc #0
000981r 2  85 rr            sta sd_buffer_address+1
000983r 2  8D 81 FF         sta PORTA
000986r 2               
000986r 2                   ; If it's not at the end of the buffer, we have data already
000986r 2  C9 rr            cmp #>(fat32_readbuffer+$200)
000988r 2  90 10            bcc @gotdata
00098Ar 2               
00098Ar 2                   ; Read another sector
00098Ar 2  A9 rr            lda #<fat32_readbuffer
00098Cr 2  85 rr            sta fat32_address
00098Er 2  A9 rr            lda #>fat32_readbuffer
000990r 2  85 rr            sta fat32_address+1
000992r 2  20 rr rr         jsr fat32_readnextsector
000995r 2  90 03            bcc @gotdata
000997r 2               
000997r 2               @endofdirectory:
000997r 2  7A               ply
000998r 2  38               sec
000999r 2  60               rts
00099Ar 2               
00099Ar 2               @gotdata:
00099Ar 2                   ; Check first character
00099Ar 2  A0 00            ldy #0
00099Cr 2  B1 rr            lda (sd_buffer_address),y
00099Er 2               
00099Er 2                   ; End of directory => abort
00099Er 2  F0 F7            beq @endofdirectory
0009A0r 2               
0009A0r 2                   ; Empty entry => start again
0009A0r 2  C9 E5            cmp #$e5
0009A2r 2  F0 CC            beq fat32_readdirent
0009A4r 2               
0009A4r 2  A9 35            lda #'5'
0009A6r 2  20 rr rr         jsr kernel_putc
0009A9r 2               
0009A9r 2                   ; Check attributes
0009A9r 2  A0 0B            ldy #11
0009ABr 2  B1 rr            lda (sd_buffer_address),y
0009ADr 2  29 3F            and #$3f
0009AFr 2  C9 0F            cmp #$0f ; LFN => start again
0009B1r 2  F0 BD            beq fat32_readdirent
0009B3r 2               
0009B3r 2  A9 36            lda #'6'
0009B5r 2  20 rr rr         jsr kernel_putc
0009B8r 2                   ; Yield this result
0009B8r 2  7A               ply
0009B9r 2  18               clc
0009BAr 2  60               rts
0009BBr 2               
0009BBr 2               
0009BBr 2               fat32_finddirent:
0009BBr 2                   ; The directory should already be open for iteration.
0009BBr 2                   ; Pointer to filename is in fat32_filenamepointer and fat32_filenamepointer + 1
0009BBr 2               
0009BBr 2                   ; Iterate until name is found or end of directory
0009BBr 2  5A               phy
0009BCr 2               @direntloop:
0009BCr 2  20 rr rr         jsr fat32_readdirent
0009BFr 2  A0 0A            ldy #10
0009C1r 2  90 04            bcc @comparenameloop
0009C3r 2  7A               ply
0009C4r 2  A9 01            lda #1
0009C6r 2  60               rts ; return not found
0009C7r 2               
0009C7r 2               @comparenameloop:
0009C7r 2  B1 rr            lda (sd_buffer_address),y
0009C9r 2  D1 rr            cmp (fat32_filenamepointer),y
0009CBr 2  D0 EF            bne @direntloop ; no match
0009CDr 2  88               dey
0009CEr 2  10 F7            bpl @comparenameloop
0009D0r 2               
0009D0r 2                   ; Found it
0009D0r 2  7A               ply
0009D1r 2  A9 00            lda #0
0009D3r 2  60               rts
0009D4r 2               
0009D4r 2               
0009D4r 2               fat32_file_readbyte:
0009D4r 2                   ; Read a byte from an open file
0009D4r 2                   ;
0009D4r 2                   ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
0009D4r 2               
0009D4r 2  38               sec
0009D5r 2               
0009D5r 2                   ; Is there any data to read at all?
0009D5r 2  A5 rr            lda fat32_bytesremaining
0009D7r 2  05 rr            ora fat32_bytesremaining+1
0009D9r 2  05 rr            ora fat32_bytesremaining+2
0009DBr 2  05 rr            ora fat32_bytesremaining+3
0009DDr 2  F0 3F            beq @rts
0009DFr 2               
0009DFr 2                   ; Decrement the remaining byte count
0009DFr 2  A5 rr            lda fat32_bytesremaining
0009E1r 2  E9 01            sbc #1
0009E3r 2  85 rr            sta fat32_bytesremaining
0009E5r 2  A5 rr            lda fat32_bytesremaining+1
0009E7r 2  E9 00            sbc #0
0009E9r 2  85 rr            sta fat32_bytesremaining+1
0009EBr 2  A5 rr            lda fat32_bytesremaining+2
0009EDr 2  E9 00            sbc #0
0009EFr 2  85 rr            sta fat32_bytesremaining+2
0009F1r 2  A5 rr            lda fat32_bytesremaining+3
0009F3r 2  E9 00            sbc #0
0009F5r 2  85 rr            sta fat32_bytesremaining+3
0009F7r 2               
0009F7r 2                   ; Need to read a new sector?
0009F7r 2  A5 rr            lda sd_buffer_address+1
0009F9r 2  C9 rr            cmp #>(fat32_readbuffer+$200)
0009FBr 2  90 0D            bcc @gotdata
0009FDr 2               
0009FDr 2                   ; Read another sector
0009FDr 2  A9 rr            lda #<fat32_readbuffer
0009FFr 2  85 rr            sta fat32_address
000A01r 2  A9 rr            lda #>fat32_readbuffer
000A03r 2  85 rr            sta fat32_address+1
000A05r 2               
000A05r 2  20 rr rr         jsr fat32_readnextsector
000A08r 2  B0 14            bcs @rts                    ; this shouldn't happen
000A0Ar 2               
000A0Ar 2               @gotdata:
000A0Ar 2  5A               phy
000A0Br 2  A0 00            ldy #0
000A0Dr 2  B1 rr            lda (sd_buffer_address),y
000A0Fr 2  7A               ply
000A10r 2  E6 rr            inc sd_buffer_address
000A12r 2  D0 0A            bne @rts
000A14r 2  E6 rr            inc sd_buffer_address+1
000A16r 2  D0 06            bne @rts
000A18r 2  E6 rr            inc sd_buffer_address+2
000A1Ar 2  D0 02            bne @rts
000A1Cr 2  E6 rr            inc sd_buffer_address+3
000A1Er 2               
000A1Er 2               @rts:
000A1Er 2  60               rts
000A1Fr 2               
000A1Fr 2               
000A1Fr 2               fat32_file_read:
000A1Fr 2                   ; Read a whole file into memory.  It's assumed the file has just been opened
000A1Fr 2                   ; and no data has been read yet.
000A1Fr 2                   ;
000A1Fr 2                   ; Also we read whole sectors, so data in the target region beyond the end of the
000A1Fr 2                   ; file may get overwritten, up to the next 512-byte boundary.
000A1Fr 2                   ;
000A1Fr 2                   ; And we don't properly support 64k+ files, as it's unnecessary complication given
000A1Fr 2                   ; the 6502's small address space
000A1Fr 2               
000A1Fr 2                   ; Round the size up to the next whole sector
000A1Fr 2  A5 rr            lda fat32_bytesremaining
000A21r 2  C9 01            cmp #1                      ; set carry if bottom 8 bits not zero
000A23r 2  A5 rr            lda fat32_bytesremaining+1
000A25r 2  69 00            adc #0                      ; add carry, if any
000A27r 2  4A               lsr                         ; divide by 2
000A28r 2  69 00            adc #0                      ; round up
000A2Ar 2               
000A2Ar 2                   ; No data?
000A2Ar 2  F0 12            beq @done
000A2Cr 2               
000A2Cr 2                   ; Store sector count - not a byte count any more
000A2Cr 2  85 rr            sta fat32_bytesremaining
000A2Er 2               
000A2Er 2                   ; Read entire sectors to the user-supplied buffer
000A2Er 2               @wholesectorreadloop:
000A2Er 2                   ; Read a sector to fat32_address
000A2Er 2  20 rr rr         jsr fat32_readnextsector
000A31r 2               
000A31r 2                   ; Advance fat32_address by 512 bytes
000A31r 2  A5 rr            lda fat32_address+1
000A33r 2  69 02            adc #2                      ; carry already clear
000A35r 2  85 rr            sta fat32_address+1
000A37r 2               
000A37r 2  A6 rr            ldx fat32_bytesremaining    ; note - actually loads sectors remaining
000A39r 2  CA               dex
000A3Ar 2  86 rr            stx fat32_bytesremaining    ; note - actually stores sectors remaining
000A3Cr 2               
000A3Cr 2  D0 F0            bne @wholesectorreadloop
000A3Er 2               
000A3Er 2               @done:
000A3Er 2  60               rts
000A3Fr 2               
000A3Fr 2               
000A3Fr 1               
000A3Fr 1               .include "../../forth.s"
000A3Fr 2               .include "../../macros.s"
000A3Fr 3               .macro  printascii   addr
000A3Fr 3                   ldx #0
000A3Fr 3               @loop:
000A3Fr 3                   lda addr,x
000A3Fr 3                   beq @done
000A3Fr 3                   jsr kernel_putc
000A3Fr 3                   inx
000A3Fr 3                   bra @loop
000A3Fr 3               @done:
000A3Fr 3               .endmacro
000A3Fr 3               
000A3Fr 3               
000A3Fr 2               
000A3Fr 2               
000A3Fr 2               ; Definitions for Tali Forth 2
000A3Fr 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000A3Fr 2               ; First version: 01. Apr 2016 (Liara Forth)
000A3Fr 2               ; This version: 29. Jan 2020
000A3Fr 2               
000A3Fr 2               ; This file is included by taliforth.asm. These are the general
000A3Fr 2               ; definitions; platform-specific definitions such as the
000A3Fr 2               ; memory map are kept in the platform folder.
000A3Fr 2               
000A3Fr 2               
000A3Fr 2               ; User Variables:
000A3Fr 2               ; Block variables
000A3Fr 2               blk_offset =  0        ; BLK : UP + 0
000A3Fr 2               scr_offset =  2        ; SCR : UP + 2
000A3Fr 2               
000A3Fr 2               ; Wordlists
000A3Fr 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000A3Fr 2               num_wordlists_offset =  5
000A3Fr 2                                          ; #WORDLISTS (byte) : UP + 5
000A3Fr 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000A3Fr 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000A3Fr 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000A3Fr 2                                          ;          (Number of wordlists in search order)
000A3Fr 2               search_order_offset =  31
000A3Fr 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000A3Fr 2                                          ; Allowing for 9 to keep offsets even.
000A3Fr 2               max_wordlists =  12    ; Maximum number of wordlists supported
000A3Fr 2                                          ; 4 Tali built-ins + 8 user wordlists
000A3Fr 2               
000A3Fr 2               ; Buffer variables
000A3Fr 2               blkbuffer_offset =     40   ; Address of buffer
000A3Fr 2               buffblocknum_offset =  42   ; Block number current in buffer
000A3Fr 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000A3Fr 2               
000A3Fr 2               ; Block I/O vectors
000A3Fr 2               blockread_offset =     46   ; Vector to block reading routine
000A3Fr 2               blockwrite_offset =    48   ; Vector to block writing routine
000A3Fr 2               
000A3Fr 2               
000A3Fr 2               ; ASCII CHARACTERS
000A3Fr 2               AscCC =   $03  ; break (CTRL-c)
000A3Fr 2               AscBELL = $07  ; bell sound
000A3Fr 2               AscBS =   $08  ; backspace
000A3Fr 2               AscLF =   $0a  ; line feed
000A3Fr 2               AscCR =   $0d  ; carriage return
000A3Fr 2               AscESC =  $1b  ; escape
000A3Fr 2               AscSP =   $20  ; space
000A3Fr 2               AscDEL =  $7f  ; delete (CTRL-h)
000A3Fr 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000A3Fr 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000A3Fr 2               
000A3Fr 2               ; DICTIONARY FLAGS
000A3Fr 2               ; The first three bits are currently unused
000A3Fr 2               CO = 1  ; Compile Only
000A3Fr 2               AN = 2  ; Always Native Compile
000A3Fr 2               IM = 4  ; Immediate Word
000A3Fr 2               NN = 8  ; Never Native Compile
000A3Fr 2               UF = 16 ; Includes Underflow Check (RESERVED)
000A3Fr 2               HC = 32 ; Word has Code Field Area (CFA)
000A3Fr 2               
000A3Fr 2               
000A3Fr 2               ; VARIOUS
000A3Fr 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000A3Fr 2               
000A3Fr 2               ; END
000A3Fr 2               
000A3Fr 2               .segment "ZEROPAGE": zeropage
000030r 2               ; ZERO PAGE ADDRESSES/VARIABLES
000030r 2               
000030r 2               ; These are kept at the top of Zero Page, with the most important variables at
000030r 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
000030r 2               ; an overflow, the lower, less important variables will be clobbered first,
000030r 2               ; giving the system a chance to recover. In other words, they are part of the
000030r 2               ; floodplain.
000030r 2               
000030r 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000030r 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000030r 2               
000030r 2  xx xx        cp: .res 2   ; Compiler Pointer
000032r 2  xx xx        dp: .res 2   ; Dictionary Pointer
000034r 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
000036r 2                                          ; a :NONAME declared word (see status)
000036r 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
000038r 2  xx xx        cib: .res 2   ; address of current input buffer
00003Ar 2  xx xx        ciblen: .res 2  ; length of current input buffer
00003Cr 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
00003Er 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
000040r 2  xx xx        output: .res 2  ; vector for EMIT
000042r 2  xx xx        input: .res 2  ; vector for KEY
000044r 2  xx xx        havekey: .res 2  ; vector for KEY?
000046r 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
000048r 2  xx xx        base: .res 2  ; number radix, default decimal
00004Ar 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
00004Cr 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
00004Er 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
000050r 2  xx xx        status: .res 2  ; internal status information
000052r 2                                          ; (used by : :NONAME ; ACCEPT)
000052r 2                                          ; Bit 7 = Redefined word message postpone
000052r 2                                          ;         When set before calling CREATE, it will
000052r 2                                          ;         not print the "redefined xxxx" message if
000052r 2                                          ;         the word exists. Instead, this bit will
000052r 2                                          ;         be reused and after CREATE has run, it will
000052r 2                                          ;         be set if the word was redefined and 0 if
000052r 2                                          ;         not. This bit should be 0 when not in use.
000052r 2                                          ; Bit 6 = 1 for normal ":" definitions
000052r 2                                          ;         WORKWORD contains nt of word being compiled
000052r 2                                          ;       = 0 for :NONAME definitions
000052r 2                                          ;         WORKWORD contains xt of word being compiled
000052r 2                                          ; Bit 5 = 1 for NUMBER returning a double word
000052r 2                                          ;       = 0 for NUMBER returning a single word
000052r 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
000052r 2                                          ;       = 0 CTRL-n recalls previous history
000052r 2                                          ; Bit 2 = Current history buffer msb
000052r 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
000052r 2                                          ; Bit 0 = Current history buffer lsb
000052r 2                                          ; status+1 is used by ACCEPT to hold history lengths.
000052r 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
000054r 2  xx xx        tmp1: .res 2  ; temporary storage
000056r 2  xx xx        tmp2: .res 2  ; temporary storage
000058r 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
00005Ar 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
00005Cr 2  xx xx        tmptos: .res 2  ; temporary TOS storage
00005Er 2  xx xx        editor1: .res 2  ; temporary for editors
000060r 2  xx xx        editor2: .res 2  ; temporary for editors
000062r 2  xx xx        editor3: .res 2  ; temporary for editors
000064r 2  xx xx        tohold: .res 2  ; pointer for formatted output
000066r 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
00006Ar 2  xx xx xx xx  
00006Er 2  xx xx xx xx  dsp_start: .res 128 ; reserve 128 bytes for data stack (64 16 bit cells)
000072r 2  xx xx xx xx  
000076r 2  xx xx xx xx  
0000EEr 2               dsp0 = $FF          ; first data stack location. Data stack grows down
0000EEr 2               rsp0 =      $FF     ; starting stack pointer
0000EEr 2               stack0 =    $0100   ; location of the stack
0000EEr 2               
0000EEr 2               
0000EEr 2               .segment "BSS"
0008A3r 2  xx xx xx xx  hist_buff: .res $400
0008A7r 2  xx xx xx xx  
0008ABr 2  xx xx xx xx  
000CA3r 2  xx xx xx xx  buffer0: .res $100
000CA7r 2  xx xx xx xx  
000CABr 2  xx xx xx xx  
000DA3r 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
000A3Fr 2               
000A3Fr 2               forth:
000A3Fr 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
000A3Fr 3               ; Low-level Forth word routines
000A3Fr 3               ; Tali Forth 2 for the 65c02
000A3Fr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000A3Fr 3               ; First version: 19. Jan 2014
000A3Fr 3               ; This version: 03. Jan 2018
000A3Fr 3               
000A3Fr 3               ; This list is ordered alphabetically by the names of the words, not their
000A3Fr 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000A3Fr 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000A3Fr 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000A3Fr 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000A3Fr 3               
000A3Fr 3               ;       TBA --> fragment --> coded --> tested --> auto
000A3Fr 3               
000A3Fr 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000A3Fr 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000A3Fr 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000A3Fr 3               
000A3Fr 3               ; ## COLD ( -- ) "Reset the Forth system"
000A3Fr 3               ; ## "cold"  tested  Tali Forth
000A3Fr 3               ;       """Reset the Forth system. Does not restart the kernel,
000A3Fr 3               ;       use the 65c02 reset for that. Flows into ABORT.
000A3Fr 3               ;       """
000A3Fr 3               xt_cold:
000A3Fr 3  D8                           cld
000A40r 3               
000A40r 3                               ; Set the OUTPUT vector to the default kernel_putc
000A40r 3                               ; We do this really early so we can print error messages
000A40r 3                               ; during debugging
000A40r 3  A9 rr                        lda #<kernel_putc
000A42r 3  85 rr                        sta output
000A44r 3  A9 rr                        lda #>kernel_putc
000A46r 3  85 rr                        sta output+1
000A48r 3               
000A48r 3                               ; Load all of the important zero page variables from ROM
000A48r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
000A4Ar 3               
000A4Ar 3               @load_zp_loop:
000A4Ar 3                               ; This loop loads them back to front. We can use X here
000A4Ar 3                               ; because Tali hasn't started using the stack yet.
000A4Ar 3  BD rr rr                     lda cold_zp_table,x
000A4Dr 3  95 rr                        sta cp,x
000A4Fr 3  CA                           dex
000A50r 3  D0 F8                        bne @load_zp_loop
000A52r 3               
000A52r 3                               ; Copy the 0th element.
000A52r 3  AD rr rr                     lda cold_zp_table
000A55r 3  85 rr                        sta cp
000A57r 3                               ; Initialize 65c02 stack (Return Stack)
000A57r 3  A2 FF                        ldx #rsp0
000A59r 3  9A                           txs
000A5Ar 3               
000A5Ar 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
000A5Ar 3                               ; can load high-level words with EVALUATE
000A5Ar 3  A2 FF                        ldx #dsp0
000A5Cr 3               
000A5Cr 3               
000A5Cr 3                               ; Initialize the user variables.
000A5Cr 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
000A5Er 3  A9 00                        lda #0
000A60r 3               
000A60r 3               @load_user_vars_loop:
000A60r 3                               ; Like the zero page variables, these are initialized
000A60r 3                               ; back to front.
000A60r 3  B9 rr rr                     lda cold_user_table,y
000A63r 3  91 rr                        sta (up),y
000A65r 3  88                           dey
000A66r 3  D0 F8                        bne @load_user_vars_loop
000A68r 3               
000A68r 3                               ; Copy the 0th element.
000A68r 3  AD rr rr                     lda cold_user_table
000A6Br 3  92 rr                        sta (up)
000A6Dr 3  20 rr rr                     jsr xt_cr
000A70r 3               
000A70r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
000A70r 3                               ; you do not have any high-level words, this part can be
000A70r 3                               ; commented out.
000A70r 3  CA                           dex
000A71r 3  CA                           dex
000A72r 3  CA                           dex
000A73r 3  CA                           dex
000A74r 3               
000A74r 3               
000A74r 3                               ; start address goes NOS
000A74r 3  A9 rr                        lda #<forth_words_start
000A76r 3  95 02                        sta 2,x
000A78r 3  A9 rr                        lda #>forth_words_start
000A7Ar 3  95 03                        sta 3,x
000A7Cr 3               
000A7Cr 3                               ; length goes TOS
000A7Cr 3  A9 rr                        lda #<forth_words_end
000A7Er 3  38                           sec
000A7Fr 3  E9 rr                        sbc #<forth_words_start
000A81r 3  95 00                        sta 0,x
000A83r 3               
000A83r 3  A9 rr                        lda #>forth_words_end
000A85r 3  E9 rr                        sbc #>forth_words_start
000A87r 3  95 01                        sta 1,x
000A89r 3               
000A89r 3               
000A89r 3  20 rr rr                     jsr xt_evaluate
000A8Cr 3               
000A8Cr 3                               ; Now define any user words via EVALUATE. If you do not have
000A8Cr 3                               ; any user-defined words, this part can be commented out as
000A8Cr 3                               ; well.
000A8Cr 3  CA                           dex
000A8Dr 3  CA                           dex
000A8Er 3  CA                           dex
000A8Fr 3  CA                           dex
000A90r 3               
000A90r 3               
000A90r 3                               ; start address goes NOS
000A90r 3  A9 rr                        lda #<user_words_start
000A92r 3  95 02                        sta 2,x
000A94r 3  A9 rr                        lda #>user_words_start
000A96r 3  95 03                        sta 3,x
000A98r 3               
000A98r 3                               ; length goes TOS
000A98r 3  A9 rr                        lda #<user_words_end
000A9Ar 3  38                           sec
000A9Br 3  E9 rr                        sbc #<user_words_start
000A9Dr 3  95 00                        sta 0,x
000A9Fr 3               
000A9Fr 3  A9 rr                        lda #>user_words_end
000AA1r 3  E9 rr                        sbc #>user_words_start
000AA3r 3  95 01                        sta 1,x
000AA5r 3               
000AA5r 3  20 rr rr                     jsr xt_evaluate
000AA8r 3               
000AA8r 3                               ; Initialize all of the history buffers by putting a zero in
000AA8r 3                               ; each length byte.
000AA8r 3  9C rr rr                     stz hist_buff
000AABr 3  9C rr rr                     stz hist_buff+$80
000AAEr 3  9C rr rr                     stz hist_buff+$100
000AB1r 3  9C rr rr                     stz hist_buff+$180
000AB4r 3  9C rr rr                     stz hist_buff+$200
000AB7r 3  9C rr rr                     stz hist_buff+$280
000ABAr 3  9C rr rr                     stz hist_buff+$300
000ABDr 3  9C rr rr                     stz hist_buff+$380
000AC0r 3               
000AC0r 3               
000AC0r 3                               ; fall through to ABORT
000AC0r 3               
000AC0r 3               
000AC0r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
000AC0r 3               ; ## "abort"  tested  ANS core
000AC0r 3                       ; """https://forth-standard.org/standard/core/ABORT
000AC0r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
000AC0r 3                       ; subroutine if we want to because we are going to reset the 65c02's
000AC0r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
000AC0r 3                       ; actually delete the stuff on the Data Stack.
000AC0r 3                       ; """
000AC0r 3               xt_abort:
000AC0r 3  A2 FF                        ldx #dsp0
000AC2r 3               
000AC2r 3                               ; fall through to QUIT
000AC2r 3               
000AC2r 3               
000AC2r 3               ; ## QUIT ( -- ) "Reset the input and get new input"
000AC2r 3               ; ## "quit"  tested  ANS core
000AC2r 3                       ; """https://forth-standard.org/standard/core/QUIT
000AC2r 3                       ; Rest the input and start command loop
000AC2r 3                       ; """
000AC2r 3               
000AC2r 3               xt_quit:
000AC2r 3                               ; Clear the Return Stack. This is a little screwed up
000AC2r 3                               ; because the 65c02 can only set the Return Stack via X,
000AC2r 3                               ; which is our Data Stack pointer. The ANS specification
000AC2r 3                               ; demands, however, that ABORT reset the Data Stack pointer
000AC2r 3  8A                           txa             ; Save the DSP that we just defined
000AC3r 3  A2 FF                        ldx #rsp0
000AC5r 3  9A                           txs
000AC6r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000AC7r 3               
000AC7r 3                               ; make sure instruction pointer is empty
000AC7r 3  64 rr                        stz ip
000AC9r 3  64 rr                        stz ip+1
000ACBr 3               
000ACBr 3                               ; SOURCE-ID is zero (keyboard input)
000ACBr 3  64 rr                        stz insrc
000ACDr 3  64 rr                        stz insrc+1
000ACFr 3               
000ACFr 3                               ; STATE is zero (interpret, not compile)
000ACFr 3  64 rr                        stz state
000AD1r 3  64 rr                        stz state+1
000AD3r 3               @get_line:
000AD3r 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
000AD5r 3  85 rr                        sta cib
000AD7r 3  A9 rr                        lda #>buffer0
000AD9r 3  85 rr                        sta cib+1
000ADBr 3               
000ADBr 3                               ; Size of current input buffer (CIB) is zero
000ADBr 3  64 rr                        stz ciblen
000ADDr 3  64 rr                        stz ciblen+1
000ADFr 3               
000ADFr 3                               ; Accept a line from the current import source. This is how
000ADFr 3                               ; modern Forths to it.
000ADFr 3  20 rr rr                     jsr xt_refill           ; ( -- f )
000AE2r 3               
000AE2r 3                               ; Test flag: LSB of TOS
000AE2r 3  B5 00                        lda 0,x
000AE4r 3  D0 05                        bne @success
000AE6r 3               
000AE6r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
000AE6r 3                               ; need to print an error message and reset the machine. We
000AE6r 3                               ; don't need to save TOS because we're going to clobber it
000AE6r 3                               ; anyway when we go back to ABORT.
000AE6r 3  A9 06                        lda #err_refill
000AE8r 3  4C rr rr                     jmp error
000AEBr 3               
000AEBr 3               @success:
000AEBr 3                               ; Assume we have successfully accepted a string of input from
000AEBr 3                               ; a source, with address cib and length of input in ciblen. We
000AEBr 3                               ; arrive here still with the TRUE flag from REFILL as TOS
000AEBr 3  E8                           inx                     ; drop
000AECr 3  E8                           inx
000AEDr 3               
000AEDr 3                               ; Main compile/execute routine
000AEDr 3  20 rr rr                     jsr interpret
000AF0r 3               
000AF0r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
000AF0r 3                               ; overflow because it is so rare
000AF0r 3  E0 FF                        cpx #dsp0
000AF2r 3  F0 05                        beq @stack_ok
000AF4r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
000AF6r 3               
000AF6r 3  4C rr rr                     jmp underflow_error
000AF9r 3               
000AF9r 3               @stack_ok:
000AF9r 3                               ; Display system prompt if all went well. If we're interpreting,
000AF9r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
000AF9r 3                               ; space at beginning of the string.
000AF9r 3  A5 rr                        lda state
000AFBr 3  F0 02                        beq @print
000AFDr 3               
000AFDr 3  A9 01                        lda #1                  ; number for "compile" string
000AFFr 3               @print:
000AFFr 3  20 rr rr                     jsr print_string
000B02r 3               
000B02r 3                               ; Awesome line, everybody! Now get the next one.
000B02r 3  80 CF                        bra @get_line
000B04r 3               
000B04r 3               z_cold:
000B04r 3               z_abort:
000B04r 3               z_quit:         ; no RTS required
000B04r 3               
000B04r 3               
000B04r 3               
000B04r 3               ; This table holds all of the initial values for the variables in zero page.
000B04r 3               ; This table is used by COLD.
000B04r 3               cold_zp_table:
000B04r 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
000B06r 3                                               ; block buffer
000B06r 3  rr rr                .word dictionary_start  ; dp
000B08r 3  00 00                .word 0                 ; workword
000B0Ar 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000B0Cr 3  rr rr                .word buffer0           ; cib
000B0Er 3  00 00                .word 0                 ; ciblen
000B10r 3  00 00                .word 0                 ; toin
000B12r 3  00 00                .word 0                 ; ip
000B14r 3  rr rr                .word kernel_putc       ; output
000B16r 3  rr rr                .word kernel_getc       ; input
000B18r 3  00 00                .word 0                 ; havekey
000B1Ar 3  00 00                .word 0                 ; state (0 = interpret)
000B1Cr 3  0A 00                .word 10                ; base
000B1Er 3  14 00                .word 20                ; nc-limit
000B20r 3  00 00                .word 0                 ; uf_strip (off by default)
000B22r 3  rr rr                .word cp0               ; up (user vars put right at beginning of
000B24r 3                                               ; available RAM)
000B24r 3  00 00                .word 0                 ; status
000B26r 3               cold_zp_table_end:
000B26r 3               
000B26r 3               ; No further ZP variables are initialized. The variables past this point are
000B26r 3               ; all temporaries.
000B26r 3               
000B26r 3               ; This table holds the inital values for the user variables. This table is
000B26r 3               ; used by COLD.
000B26r 3               cold_user_table:
000B26r 3  00 00                .word 0                         ; BLK
000B28r 3  00 00                .word 0                         ; SCR
000B2Ar 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
000B2Br 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000B2Cr 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
000B2Er 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
000B30r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
000B32r 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
000B34r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000B38r 3  00 00 00 00  
000B3Cr 3  00 00 00 00  
000B44r 3  01                   .byte 1                         ; #ORDER
000B45r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
000B49r 3  00 00 00 00  
000B4Dr 3  00           
000B4Er 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
000B50r 3  00 00                .word 0                         ; block in buffer
000B52r 3  00 00                .word 0                         ; buffer status (not in use)
000B54r 3  rr rr                .word xt_block_word_error       ; block-read vector
000B56r 3  rr rr                .word xt_block_word_error       ; block-write vector
000B58r 3               cold_user_table_end:
000B58r 3               
000B58r 3               
000B58r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
000B58r 3               ; ## "abort""  tested  ANS core
000B58r 3                       ; """https://forth-standard.org/standard/core/ABORTq
000B58r 3                       ; Abort and print a string.
000B58r 3                       ; """
000B58r 3               
000B58r 3               xt_abort_quote:
000B58r 3                               ; save the string
000B58r 3  20 rr rr                     jsr xt_s_quote          ; S"
000B5Br 3               
000B5Br 3                               ; compile run-time part
000B5Br 3  A0 rr                        ldy #>abort_quote_runtime
000B5Dr 3  A9 rr                        lda #<abort_quote_runtime
000B5Fr 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000B62r 3               
000B62r 3  60           z_abort_quote:  rts
000B63r 3               
000B63r 3               
000B63r 3               abort_quote_runtime:
000B63r 3                       ; """Runtime aspect of ABORT_QUOTE"""
000B63r 3               
000B63r 3                               ; We arrive here with ( f addr u )
000B63r 3  B5 04                        lda 4,x
000B65r 3  15 05                        ora 5,x
000B67r 3  F0 09                        beq @done       ; if FALSE, we're done
000B69r 3               
000B69r 3                               ; We're true, so print string and ABORT. We follow Gforth
000B69r 3                               ; in going to a new line after the string
000B69r 3  20 rr rr                     jsr xt_type
000B6Cr 3  20 rr rr                     jsr xt_cr
000B6Fr 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000B72r 3               @done:
000B72r 3                               ; Drop three entries from the Data Stack
000B72r 3  8A                           txa
000B73r 3  18                           clc
000B74r 3  69 06                        adc #6
000B76r 3  AA                           tax
000B77r 3               
000B77r 3  60                           rts
000B78r 3               
000B78r 3               
000B78r 3               
000B78r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
000B78r 3               ; ## "abs"  auto  ANS core
000B78r 3                       ; """https://forth-standard.org/standard/core/ABS
000B78r 3                       ; Return the absolute value of a number.
000B78r 3                       ; """
000B78r 3               
000B78r 3               xt_abs:
000B78r 3  20 rr rr                     jsr underflow_1
000B7Br 3               
000B7Br 3  B5 01                        lda 1,x
000B7Dr 3  10 0D                        bpl @done       ; positive number, easy money!
000B7Fr 3               
000B7Fr 3                               ; negative: calculate 0 - n
000B7Fr 3  38                           sec
000B80r 3  A9 00                        lda #0
000B82r 3  F5 00                        sbc 0,x         ; LSB
000B84r 3  95 00                        sta 0,x
000B86r 3               
000B86r 3  A9 00                        lda #0          ; MSB
000B88r 3  F5 01                        sbc 1,x
000B8Ar 3  95 01                        sta 1,x
000B8Cr 3               
000B8Cr 3               @done:
000B8Cr 3  60           z_abs:          rts
000B8Dr 3               
000B8Dr 3               
000B8Dr 3               
000B8Dr 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
000B8Dr 3               ; ## "accept"  auto  ANS core
000B8Dr 3                       ; """https://forth-standard.org/standard/core/ACCEPT
000B8Dr 3                       ; Receive a string of at most n1 characters, placing them at
000B8Dr 3                       ; addr. Return the actual number of characters as n2. Characters
000B8Dr 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
000B8Dr 3                       ; modern Forths.
000B8Dr 3                       ; """
000B8Dr 3               
000B8Dr 3               xt_accept:
000B8Dr 3  20 rr rr                     jsr underflow_2
000B90r 3               
000B90r 3                               ; Abort if we were asked to receive 0 chars
000B90r 3  B5 00                        lda 0,x
000B92r 3  15 01                        ora 1,x
000B94r 3  D0 09                        bne @not_zero
000B96r 3               
000B96r 3  E8                           inx
000B97r 3  E8                           inx
000B98r 3  74 00                        stz 0,x
000B9Ar 3  74 01                        stz 1,x
000B9Cr 3               
000B9Cr 3  4C rr rr                     jmp accept_done
000B9Fr 3               
000B9Fr 3               @not_zero:
000B9Fr 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000BA1r 3  85 rr                        sta tmp2
000BA3r 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
000BA5r 3               
000BA5r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000BA7r 3  85 rr                        sta tmp1
000BA9r 3  B5 03                        lda 3,x
000BABr 3  85 rr                        sta tmp1+1
000BADr 3               
000BADr 3  E8                           inx
000BAEr 3  E8                           inx
000BAFr 3               
000BAFr 3  A0 00                        ldy #0
000BB1r 3               
000BB1r 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
000BB1r 3                               ; from bit 2 to 3 is OK)
000BB1r 3  A5 rr                        lda status
000BB3r 3  29 F7                        and #$f7
000BB5r 3               
000BB5r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000BB5r 3  1A                           inc
000BB6r 3               
000BB6r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000BB6r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000BB6r 3                               ; received and won't be used to calculate the history buffer
000BB6r 3                               ; offset.
000BB6r 3  09 08                        ora #$08
000BB8r 3  85 rr                        sta status
000BBAr 3               
000BBAr 3               accept_loop:
000BBAr 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000BBAr 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000BBAr 3                               ; vt100 terminal clears the screen automatically.
000BBAr 3               
000BBAr 3                               ; This is the internal version of KEY without all the mucking
000BBAr 3                               ; about with the Data Stack while still using the input vector
000BBAr 3  20 rr rr                     jsr key_a
000BBDr 3               
000BBDr 3                               ; We quit on both line feed and carriage return
000BBDr 3  C9 0A                        cmp #AscLF
000BBFr 3  F0 20                        beq @eol
000BC1r 3  C9 0D                        cmp #AscCR
000BC3r 3  F0 1C                        beq @eol
000BC5r 3               
000BC5r 3                               ; BACKSPACE and DEL do the same thing for the moment
000BC5r 3  C9 08                        cmp #AscBS
000BC7r 3  F0 22                        beq @backspace
000BC9r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000BCBr 3  F0 1E                        beq @backspace
000BCDr 3               
000BCDr 3                               ; Check for CTRL-p and CTRL-n to recall input history
000BCDr 3  C9 10                        cmp #AscCP
000BCFr 3  F0 36                        beq @ctrl_p
000BD1r 3  C9 0E                        cmp #AscCN
000BD3r 3  F0 44                        beq @ctrl_n
000BD5r 3               
000BD5r 3                               ; That's enough for now. Save and echo character.
000BD5r 3  91 rr                        sta (tmp1),y
000BD7r 3  C8                           iny
000BD8r 3               
000BD8r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000BD8r 3  20 rr rr                     jsr emit_a
000BDBr 3               
000BDBr 3  C4 rr                        cpy tmp2        ; reached character limit?
000BDDr 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
000BDFr 3  80 03                        bra @buffer_full
000BE1r 3               
000BE1r 3               @eol:
000BE1r 3  20 rr rr                     jsr xt_space    ; print final space
000BE4r 3               
000BE4r 3               @buffer_full:
000BE4r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
000BE4r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
000BE6r 3  74 01                        stz 1,x         ; we only accept 256 chars
000BE8r 3               
000BE8r 3  4C rr rr                     jmp accept_done
000BEBr 3               
000BEBr 3               @backspace:
000BEBr 3                               ; Handle backspace and delete kex, which currently do the same
000BEBr 3                               ; thing
000BEBr 3  C0 00                        cpy #0          ; buffer empty?
000BEDr 3  D0 06                        bne @1
000BEFr 3               
000BEFr 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
000BF1r 3  20 rr rr                     jsr emit_a
000BF4r 3  C8                           iny
000BF5r 3               @1:
000BF5r 3  88                           dey
000BF6r 3  A9 08                        lda #AscBS      ; move back one
000BF8r 3  20 rr rr                     jsr emit_a
000BFBr 3  A9 20                        lda #AscSP      ; print a space (rubout)
000BFDr 3  20 rr rr                     jsr emit_a
000C00r 3  A9 08                        lda #AscBS      ; move back over space
000C02r 3  20 rr rr                     jsr emit_a
000C05r 3               
000C05r 3  80 B3                        bra accept_loop
000C07r 3               
000C07r 3               @ctrl_p:
000C07r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000C07r 3               
000C07r 3                               ; Select the previous buffer
000C07r 3  A5 rr                        lda status
000C09r 3               
000C09r 3                               ; Check for 0 (need to wrap back to 7)
000C09r 3  29 07                        and #7
000C0Br 3  D0 08                        bne @ctrl_p_dec
000C0Dr 3               
000C0Dr 3                               ; We need to wrap back to 7.
000C0Dr 3  A5 rr                        lda status
000C0Fr 3  09 07                        ora #7
000C11r 3  85 rr                        sta status
000C13r 3  80 11                        bra @recall_history
000C15r 3               
000C15r 3               @ctrl_p_dec:
000C15r 3                               ; It's safe to decrement the buffer index directly.
000C15r 3  C6 rr                        dec status
000C17r 3  80 0D                        bra @recall_history
000C19r 3               
000C19r 3               @ctrl_n:
000C19r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000C19r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000C19r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000C19r 3                               ; history buffer.
000C19r 3  A9 08                        lda #$8
000C1Br 3  24 rr                        bit status
000C1Dr 3  D0 07                        bne @recall_history
000C1Fr 3               
000C1Fr 3                               ; This isn't the first time CTRL-n has been pressed, select the
000C1Fr 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
000C1Fr 3  A5 rr                        lda status
000C21r 3  29 F7                        and #$f7
000C23r 3               
000C23r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000C23r 3  1A                           inc
000C24r 3               
000C24r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
000C24r 3                               ; be cleared below.
000C24r 3  85 rr                        sta status
000C26r 3               
000C26r 3                               ; Falls through to @recall_history
000C26r 3               
000C26r 3               @recall_history:
000C26r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000C26r 3  A9 08                        lda #%00001000
000C28r 3  14 rr                        trb status
000C2Ar 3               
000C2Ar 3  20 rr rr                     jsr total_recall
000C2Dr 3               
000C2Dr 3                               ; tmp3 now has the address of the previous history buffer.
000C2Dr 3                               ; First byte of buffer is length. Clear the line by sending
000C2Dr 3                               ; CR, Y spaces, then CR.
000C2Dr 3  A9 0D                        lda #AscCR
000C2Fr 3  20 rr rr                     jsr emit_a
000C32r 3               
000C32r 3               input_clear:
000C32r 3  C0 00                        cpy #0
000C34r 3  F0 08                        beq input_cleared
000C36r 3               
000C36r 3  A9 20                        lda #AscSP
000C38r 3  20 rr rr                     jsr emit_a
000C3Br 3  88                           dey
000C3Cr 3  80 F4                        bra input_clear
000C3Er 3               
000C3Er 3               input_cleared:
000C3Er 3  A9 0D                        lda #AscCR
000C40r 3  20 rr rr                     jsr emit_a
000C43r 3               
000C43r 3                               ; Save the history length byte into histinfo+1
000C43r 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000C43r 3  B1 rr                        lda (tmp3),y
000C45r 3  85 rr                        sta status+1
000C47r 3               
000C47r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000C47r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000C47r 3                               ; buffer)
000C47r 3  E6 rr                        inc tmp3
000C49r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
000C4Br 3  E6 rr                        inc tmp3+1
000C4Dr 3               @2:
000C4Dr 3                               ; Copy the history buffer into the input buffer,
000C4Dr 3                               ; sending the characters to the output as we go.
000C4Dr 3  A9 0D                        lda #AscCR
000C4Fr 3  20 rr rr                     jsr emit_a
000C52r 3               
000C52r 3               @history_loop:
000C52r 3                               ; See if we have reached the end of the history buffer.
000C52r 3  C4 rr                        cpy status+1
000C54r 3  D0 03                        bne @3
000C56r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
000C59r 3               @3:
000C59r 3                               ; See if we have reached the end of the input buffer.
000C59r 3                               ; (only comparing to lower byte as we currently limit
000C59r 3                               ; to 255 characters max)
000C59r 3  C4 rr                        cpy tmp2
000C5Br 3  F0 0A                        beq @hist_filled_buffer
000C5Dr 3               
000C5Dr 3                               ; Copy a character and echo.
000C5Dr 3  B1 rr                        lda (tmp3),y
000C5Fr 3  91 rr                        sta (tmp1),y
000C61r 3  20 rr rr                     jsr emit_a
000C64r 3               
000C64r 3                               ; Move to the next character.
000C64r 3  C8                           iny
000C65r 3  80 EB                        bra @history_loop
000C67r 3               
000C67r 3               @hist_filled_buffer:
000C67r 3                               ; We don't want a history recall to EOL our buffer,
000C67r 3                               ; so back up one character and return to editing.
000C67r 3  88                           dey
000C68r 3  4C rr rr                     jmp accept_loop
000C6Br 3               accept_done:
000C6Br 3               @done:
000C6Br 3                               ; Copy the input buffer into the currently
000C6Br 3                               ; selected history buffer.
000C6Br 3  20 rr rr                     jsr total_recall
000C6Er 3  85 rr                        sta status+1
000C70r 3               
000C70r 3                               ; Also save it in the first buffer byte.
000C70r 3  A0 00                        ldy #0
000C72r 3  91 rr                        sta (tmp3),y
000C74r 3               
000C74r 3                               ; Move path the count to the data bytes
000C74r 3  E6 rr                        inc tmp3
000C76r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000C78r 3  E6 rr                        inc tmp3+1
000C7Ar 3               @4:
000C7Ar 3                               ; Copy the characters from the input buffer to the
000C7Ar 3                               ; history buffer.
000C7Ar 3               
000C7Ar 3               @save_history_loop:
000C7Ar 3  C4 rr                        cpy status+1
000C7Cr 3  F0 07                        beq @save_history_done
000C7Er 3               
000C7Er 3  B1 rr                        lda (tmp1),y
000C80r 3  91 rr                        sta (tmp3),y
000C82r 3  C8                           iny
000C83r 3  80 F5                        bra @save_history_loop
000C85r 3               
000C85r 3               @save_history_done:
000C85r 3               z_accept:
000C85r 3  60                           rts
000C86r 3               
000C86r 3               total_recall:
000C86r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000C86r 3               
000C86r 3                               ; Generate the address of the buffer in tmp3. Start with the
000C86r 3                               ; base address.
000C86r 3  A9 rr                        lda #<hist_buff
000C88r 3  85 rr                        sta tmp3
000C8Ar 3  A9 rr                        lda #>hist_buff
000C8Cr 3  85 rr                        sta tmp3+1
000C8Er 3               
000C8Er 3                               ; This is a bit annoying as some bits go into each byte.
000C8Er 3                               ; .....xxx gets put into address like ......xx x.......
000C8Er 3  A5 rr                        lda status
000C90r 3  6A                           ror
000C91r 3  29 03                        and #3
000C93r 3  18                           clc
000C94r 3  65 rr                        adc tmp3+1
000C96r 3  85 rr                        sta tmp3+1
000C98r 3               
000C98r 3  A5 rr                        lda status
000C9Ar 3  6A                           ror             ; Rotate through carry into msb.
000C9Br 3  6A                           ror
000C9Cr 3  29 80                        and #$80
000C9Er 3  18                           clc
000C9Fr 3  65 rr                        adc tmp3
000CA1r 3  85 rr                        sta tmp3
000CA3r 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000CA5r 3  E6 rr                        inc tmp3+1
000CA7r 3               @1:
000CA7r 3                               ; Save the current length of the input buffer in
000CA7r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000CA7r 3  98                           tya
000CA8r 3  C9 80                        cmp #$80
000CAAr 3  90 02                        bcc @2
000CACr 3  A9 7F                        lda #$7F
000CAEr 3               @2:
000CAEr 3  60                           rts
000CAFr 3               
000CAFr 3               
000CAFr 3               
000CAFr 3               
000CAFr 3               
000CAFr 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000CAFr 3               ; ## "action-of"  auto  ANS core ext
000CAFr 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000CAFr 3               
000CAFr 3               xt_action_of:
000CAFr 3                               ; This is a state aware word with differet behavior
000CAFr 3                               ; when used while compiling vs interpreting.
000CAFr 3                               ; Check STATE
000CAFr 3  A5 rr                        lda state
000CB1r 3  05 rr                        ora state+1
000CB3r 3  F0 0C                        beq @interpreting
000CB5r 3               
000CB5r 3               @compiling:
000CB5r 3                               ; Run ['] to compile the xt of the next word
000CB5r 3                               ; as a literal.
000CB5r 3  20 rr rr                     jsr xt_bracket_tick
000CB8r 3               
000CB8r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000CB8r 3  A0 rr                        ldy #>xt_defer_fetch
000CBAr 3  A9 rr                        lda #<xt_defer_fetch
000CBCr 3  20 rr rr                     jsr cmpl_subroutine
000CBFr 3  80 06                        bra @done
000CC1r 3               
000CC1r 3               @interpreting:
000CC1r 3  20 rr rr                     jsr xt_tick
000CC4r 3  20 rr rr                     jsr xt_defer_fetch
000CC7r 3               
000CC7r 3               @done:
000CC7r 3  60           z_action_of:           rts
000CC8r 3               
000CC8r 3               
000CC8r 3               
000CC8r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000CC8r 3               ; ## "again"  tested  ANS core ext
000CC8r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000CC8r 3               
000CC8r 3               xt_again:
000CC8r 3  20 rr rr                     jsr underflow_1
000CCBr 3               
000CCBr 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000CCBr 3                               ; so we have the range and don't have to calculate the
000CCBr 3                               ; offset.
000CCBr 3  A0 00                        ldy #0
000CCDr 3  A9 4C                        lda #$4C        ; JMP
000CCFr 3  91 rr                        sta (cp),y
000CD1r 3  C8                           iny
000CD2r 3               
000CD2r 3  B5 00                        lda 0,x         ; LSB of address
000CD4r 3  91 rr                        sta (cp),y
000CD6r 3  C8                           iny
000CD7r 3               
000CD7r 3  B5 01                        lda 1,x         ; MSB of address
000CD9r 3  91 rr                        sta (cp),y
000CDBr 3  C8                           iny
000CDCr 3               
000CDCr 3                               ; Allot the space we just used
000CDCr 3  98                           tya
000CDDr 3  18                           clc
000CDEr 3  65 rr                        adc cp
000CE0r 3  85 rr                        sta cp
000CE2r 3  90 02                        bcc @done
000CE4r 3  E6 rr                        inc cp+1
000CE6r 3               @done:
000CE6r 3  E8                           inx
000CE7r 3  E8                           inx
000CE8r 3               
000CE8r 3  60           z_again:        rts
000CE9r 3               
000CE9r 3               
000CE9r 3               
000CE9r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000CE9r 3               ; ## "align"  auto  ANS core
000CE9r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000CE9r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000CE9r 3                       ; routine as well, and also does nothing
000CE9r 3                       ; """
000CE9r 3               
000CE9r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000CE9r 3               ; ## "aligned"  auto  ANS core
000CE9r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000CE9r 3               
000CE9r 3               xt_align:
000CE9r 3               xt_aligned:
000CE9r 3               z_align:
000CE9r 3  60           z_aligned:      rts             ; stripped out during native compile
000CEAr 3               
000CEAr 3               
000CEAr 3               
000CEAr 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000CEAr 3               ; ## "allot"  auto  ANS core
000CEAr 3                       ; """https://forth-standard.org/standard/core/ALLOT
000CEAr 3                       ; Reserve a certain number of bytes (not cells) or release them.
000CEAr 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000CEAr 3                       ; to the beginning of the Dictionary. If n is positive (the most
000CEAr 3                       ; common case), reserve n bytes, but not past the end of the
000CEAr 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000CEAr 3                       ; """
000CEAr 3               
000CEAr 3               xt_allot:
000CEAr 3  20 rr rr                     jsr underflow_1
000CEDr 3               
000CEDr 3                               ; Releasing memory is going to be a very rare operation,
000CEDr 3                               ; so we check for it at the beginning and try to make
000CEDr 3                               ; the most common case as fast as possible
000CEDr 3  B5 01                        lda 1,x
000CEFr 3  30 22                        bmi @release
000CF1r 3               
000CF1r 3                               ; Common case: We are reserving memory, not releasing it
000CF1r 3  18                           clc
000CF2r 3  A5 rr                        lda cp
000CF4r 3  75 00                        adc 0,x
000CF6r 3  85 rr                        sta cp
000CF8r 3               
000CF8r 3  A5 rr                        lda cp+1
000CFAr 3  75 01                        adc 1,x
000CFCr 3  85 rr                        sta cp+1
000CFEr 3               
000CFEr 3                               ; Wait, did we just grant more space than we have? This is
000CFEr 3                               ; a check we only do here, not for other situations like cmpl_a
000CFEr 3                               ; where smaller amounts are reserved.
000CFEr 3  A0 FF                        ldy #<cp_end
000D00r 3  C4 rr                        cpy cp
000D02r 3  A9 7F                        lda #>cp_end
000D04r 3  E5 rr                        sbc cp+1
000D06r 3  B0 48                        bcs @done               ; we're fine.
000D08r 3               
000D08r 3                               ; Oops, that was too much, we're beyond the end of
000D08r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000D08r 3                               ; an error
000D08r 3  84 rr                        sty cp                  ; still #<cp_end
000D0Ar 3  A9 7F                        lda #>cp_end
000D0Cr 3  85 rr                        sta cp+1
000D0Er 3               
000D0Er 3  A9 00                        lda #err_allot
000D10r 3  4C rr rr                     jmp error
000D13r 3               
000D13r 3               @release:
000D13r 3                  		; The ANS standard doesn't really say what to do if too much
000D13r 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
000D13r 3                               ; even an official test. Gforth is little help either. The good
000D13r 3                               ; news is, this is going to be a rare case. We want to use as
000D13r 3                               ; few bytes as possible.
000D13r 3               
000D13r 3                               ; What we do is let the user free anything up to the beginning
000D13r 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
000D13r 3                               ; their own risk. This means that the Dictionary pointer DP
000D13r 3                               ; might end up pointing to garbage. However, an attempt to
000D13r 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
000D13r 3                               ; the DP pointing to the last word in RAM (should be DROP) and
000D13r 3                               ; an error message.
000D13r 3               
000D13r 3                               ; We arrive here with ( n ) which is negative. First step,
000D13r 3                               ; subtract the number TOS from the CP for a new CP
000D13r 3  CA                           dex
000D14r 3  CA                           dex
000D15r 3  A5 rr                        lda cp
000D17r 3  95 00                        sta 0,x
000D19r 3  A5 rr                        lda cp+1
000D1Br 3  95 01                        sta 1,x
000D1Dr 3               
000D1Dr 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000D20r 3               
000D20r 3                               ; Second step, see if we've gone too far. We compare the new
000D20r 3                               ; CP on TOS (which, if we've really screwed up, might be
000D20r 3                               ; negative) with CP0. This is a signed comparison
000D20r 3  CA                           dex
000D21r 3  CA                           dex                             ; new CP now NOS
000D22r 3  A9 rr                        lda #<cp0
000D24r 3  95 00                        sta 0,x
000D26r 3  A9 rr                        lda #>cp0
000D28r 3  95 01                        sta 1,x                         ; CP0 is TOS
000D2Ar 3               
000D2Ar 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000D2Dr 3               
000D2Dr 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000D2Dr 3                               ; This means we want Z=1 or N=1
000D2Dr 3  F0 17                        beq @nega_done
000D2Fr 3  30 15                        bmi @nega_done
000D31r 3               
000D31r 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
000D31r 3                               ; word in ROM (should be DROP), and abort with an error
000D31r 3  A9 rr                        lda #<cp0
000D33r 3  85 rr                        sta cp
000D35r 3  A9 rr                        lda #>cp0
000D37r 3  85 rr                        sta cp+1
000D39r 3               
000D39r 3  A9 rr                        lda #<dictionary_start
000D3Br 3  85 rr                        sta dp
000D3Dr 3  A9 rr                        lda #>dictionary_start
000D3Fr 3  85 rr                        sta dp+1
000D41r 3               
000D41r 3  A9 0A                        lda #err_negallot
000D43r 3  4C rr rr                     jmp error
000D46r 3               
000D46r 3               @nega_done:
000D46r 3                               ; Save new CP, which is NOS
000D46r 3  B5 02                        lda 2,x
000D48r 3  85 rr                        sta cp
000D4Ar 3  B5 03                        lda 3,x
000D4Cr 3  85 rr                        sta cp+1
000D4Er 3               
000D4Er 3  E8                           inx
000D4Fr 3  E8                           inx                     ; drop through to @done
000D50r 3               @done:
000D50r 3  E8                           inx
000D51r 3  E8                           inx
000D52r 3               z_allot:
000D52r 3  60                           rts
000D53r 3               
000D53r 3               
000D53r 3               
000D53r 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000D53r 3               ; ## "allow-native"  auto  Tali Forth
000D53r 3               xt_allow_native:
000D53r 3  20 rr rr                     jsr current_to_dp
000D56r 3  A0 01                        ldy #1          ; offset for status byte
000D58r 3  B1 rr                        lda (dp),y
000D5Ar 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
000D5Cr 3  91 rr                        sta (dp),y
000D5Er 3               z_allow_native:
000D5Er 3  60                           rts
000D5Fr 3               
000D5Fr 3               
000D5Fr 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000D5Fr 3               ; ## "also"  auto  ANS search ext
000D5Fr 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000D5Fr 3               xt_also:
000D5Fr 3  20 rr rr                     jsr xt_get_order
000D62r 3  20 rr rr                     jsr xt_over
000D65r 3  20 rr rr                     jsr xt_swap
000D68r 3  20 rr rr                     jsr xt_one_plus
000D6Br 3  20 rr rr                     jsr xt_set_order
000D6Er 3               
000D6Er 3  60           z_also:         rts
000D6Fr 3               
000D6Fr 3               
000D6Fr 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000D6Fr 3               ; ## "always-native"  auto  Tali Forth
000D6Fr 3               xt_always_native:
000D6Fr 3  20 rr rr                     jsr current_to_dp
000D72r 3  A0 01                        ldy #1          ; offset for status byte
000D74r 3  B1 rr                        lda (dp),y
000D76r 3  09 02                        ora #AN         ; Make sure AN flag is set
000D78r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
000D7Ar 3  91 rr                        sta (dp),y
000D7Cr 3               z_always_native:
000D7Cr 3  60                           rts
000D7Dr 3               
000D7Dr 3               
000D7Dr 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
000D7Dr 3               ; ## "and"  auto  ANS core
000D7Dr 3                       ; """https://forth-standard.org/standard/core/AND"""
000D7Dr 3               xt_and:
000D7Dr 3  20 rr rr                     jsr underflow_2
000D80r 3               
000D80r 3  B5 00                        lda 0,x
000D82r 3  35 02                        and 2,x
000D84r 3  95 02                        sta 2,x
000D86r 3               
000D86r 3  B5 01                        lda 1,x
000D88r 3  35 03                        and 3,x
000D8Ar 3  95 03                        sta 3,x
000D8Cr 3               
000D8Cr 3  E8                           inx
000D8Dr 3  E8                           inx
000D8Er 3               
000D8Er 3  60           z_and:          rts
000D8Fr 3               
000D8Fr 3               
000D8Fr 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000D8Fr 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000D8Fr 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000D8Fr 3                       ; assembler words to the search order so they can be used.
000D8Fr 3                       ; See the tutorial on Wordlists and the Search Order for
000D8Fr 3                       ; more information.
000D8Fr 3                       ;
000D8Fr 3                       ; This is a dummy entry, the code is shared with TWO
000D8Fr 3                       ; """
000D8Fr 3               
000D8Fr 3               
000D8Fr 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000D8Fr 3               ; ## "at-xy"  tested  ANS facility
000D8Fr 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000D8Fr 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000D8Fr 3                       ; ANSI code is ESC[<n>;<m>H
000D8Fr 3                       ;
000D8Fr 3                       ; Do not use U. to print the numbers because the
000D8Fr 3                       ; trailing space will not work with xterm
000D8Fr 3                       ; """
000D8Fr 3               xt_at_xy:
000D8Fr 3  20 rr rr                     jsr underflow_2
000D92r 3               
000D92r 3  A9 1B                        lda #AscESC
000D94r 3  20 rr rr                     jsr emit_a
000D97r 3  A9 5B                        lda #$5B        ; ASCII for "["
000D99r 3  20 rr rr                     jsr emit_a
000D9Cr 3  20 rr rr                     jsr print_u
000D9Fr 3  A9 3B                        lda #$3B        ; ASCII for ";"
000DA1r 3  20 rr rr                     jsr emit_a
000DA4r 3  20 rr rr                     jsr print_u
000DA7r 3  A9 48                        lda #'H'
000DA9r 3  20 rr rr                     jsr emit_a
000DACr 3               
000DACr 3  60           z_at_xy:        rts
000DADr 3               
000DADr 3               
000DADr 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
000DADr 3               ; ## "\"  auto  ANS core ext
000DADr 3                       ; """https://forth-standard.org/standard/core/bs"""
000DADr 3               xt_backslash:
000DADr 3  A5 rr                        lda ciblen
000DAFr 3  85 rr                        sta toin
000DB1r 3  A5 rr                        lda ciblen+1
000DB3r 3  85 rr                        sta toin+1
000DB5r 3               
000DB5r 3  60           z_backslash:    rts
000DB6r 3               
000DB6r 3               
000DB6r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000DB6r 3               ; ## "base"  auto  ANS core
000DB6r 3                       ; """https://forth-standard.org/standard/core/BASE
000DB6r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000DB6r 3                       ; ingore the MSB
000DB6r 3                       ; """
000DB6r 3               xt_base:
000DB6r 3  CA                           dex
000DB7r 3  CA                           dex
000DB8r 3  A9 rr                        lda #<base
000DBAr 3  95 00                        sta 0,x         ; LSB
000DBCr 3  74 01                        stz 1,x         ; MSB is always 0
000DBEr 3               
000DBEr 3  60           z_base:         rts
000DBFr 3               
000DBFr 3               
000DBFr 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000DBFr 3               ; ## "begin"  auto  ANS core
000DBFr 3                       ; """https://forth-standard.org/standard/core/BEGIN
000DBFr 3                       ;
000DBFr 3                       ; This is just an immediate version of here which could just
000DBFr 3                       ; as well be coded in Forth as
000DBFr 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000DBFr 3                       ; Since this is a compiling word, we don't care that much about
000DBFr 3                       ; about speed
000DBFr 3                       ; """
000DBFr 3               
000DBFr 3               xt_begin:
000DBFr 3  20 rr rr                     jsr xt_here
000DC2r 3  60           z_begin:        rts
000DC3r 3               
000DC3r 3               
000DC3r 3               
000DC3r 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000DC3r 3               ; ## "bell"  tested  Tali Forth
000DC3r 3               xt_bell:
000DC3r 3  A9 07                        lda #7          ; ASCII value for BELl
000DC5r 3  20 rr rr                     jsr emit_a
000DC8r 3               
000DC8r 3  60           z_bell:         rts
000DC9r 3               
000DC9r 3               
000DC9r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000DC9r 3               ; ## "bl"  auto  ANS core
000DC9r 3                       ; """https://forth-standard.org/standard/core/BL"""
000DC9r 3               
000DC9r 3               xt_bl:
000DC9r 3  CA                           dex
000DCAr 3  CA                           dex
000DCBr 3  A9 20                        lda #AscSP
000DCDr 3  95 00                        sta 0,x
000DCFr 3  74 01                        stz 1,x
000DD1r 3               
000DD1r 3  60           z_bl:           rts
000DD2r 3               
000DD2r 3               
000DD2r 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000DD2r 3               ; ## "block"  auto  ANS block
000DD2r 3                       ; """https://forth-standard.org/standard/block/BLK"""
000DD2r 3               xt_blk:
000DD2r 3                               ; BLK is at UP + blk_offset
000DD2r 3  CA                           dex
000DD3r 3  CA                           dex
000DD4r 3  18                           clc
000DD5r 3  A5 rr                        lda up
000DD7r 3  69 00                        adc #blk_offset ; Add offset
000DD9r 3  95 00                        sta 0,x
000DDBr 3  A5 rr                        lda up+1
000DDDr 3  69 00                        adc #0          ; Adding carry
000DDFr 3  95 01                        sta 1,x
000DE1r 3               
000DE1r 3  60           z_blk:          rts
000DE2r 3               
000DE2r 3               
000DE2r 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
000DE2r 3               ; ## "blkbuffer"  auto  Tali block
000DE2r 3               xt_blkbuffer:
000DE2r 3                               ; blkbuffer address is at UP + blkbuffer_offset.
000DE2r 3                               ; Unlike some of the other user variables, we actually
000DE2r 3                               ; want to push the address stored here, which will
000DE2r 3                               ; point to somewhere outside of the user variables.
000DE2r 3  CA                           dex
000DE3r 3  CA                           dex
000DE4r 3                               ; Put the address on the stack.
000DE4r 3  A0 28                        ldy #blkbuffer_offset
000DE6r 3  B1 rr                        lda (up),y
000DE8r 3  95 00                        sta 0,x
000DEAr 3  C8                           iny             ; Move along to the next byte
000DEBr 3  B1 rr                        lda (up),y
000DEDr 3  95 01                        sta 1,x
000DEFr 3               
000DEFr 3  60           z_blkbuffer:    rts
000DF0r 3               
000DF0r 3               
000DF0r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
000DF0r 3               ; ## "block"  auto  ANS block
000DF0r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
000DF0r 3               
000DF0r 3               xt_block:
000DF0r 3               
000DF0r 3                               ; See if the block requested is the same as the one we
000DF0r 3                               ; currently have in the buffer. Check the LSB.
000DF0r 3  A0 2A                        ldy #buffblocknum_offset
000DF2r 3  B1 rr                        lda (up),y
000DF4r 3  D5 00                        cmp 0,x
000DF6r 3  D0 0F                        bne @not_in_buffer
000DF8r 3               
000DF8r 3                               ; Check the MSB.
000DF8r 3  C8                           iny
000DF9r 3  B1 rr                        lda (up),y
000DFBr 3  D5 01                        cmp 1,x
000DFDr 3  D0 08                        bne @not_in_buffer
000DFFr 3               
000DFFr 3                               ; The block is in the buffer. See if the buffer is in use.
000DFFr 3  A0 2C                        ldy #buffstatus_offset
000E01r 3  B1 rr                        lda (up),y
000E03r 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000E05r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000E07r 3                                               ; @done will replace the block# with the
000E07r 3                                               ; buffer address.
000E07r 3               @not_in_buffer:
000E07r 3                               ; Check the buffer status
000E07r 3  A0 2C                        ldy #buffstatus_offset
000E09r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000E0Br 3  C9 03                        cmp #3          ; LSB is needed.
000E0Dr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000E0Fr 3               
000E0Fr 3                               ; We need to save the block.
000E0Fr 3  20 rr rr                     jsr xt_blkbuffer
000E12r 3  20 rr rr                     jsr xt_buffblocknum
000E15r 3  20 rr rr                     jsr xt_fetch
000E18r 3  20 rr rr                     jsr xt_block_write
000E1Br 3               
000E1Br 3               @buffer_available:
000E1Br 3                               ; Save the block number.
000E1Br 3  A0 2A                        ldy #buffblocknum_offset
000E1Dr 3  B5 00                        lda 0,x
000E1Fr 3  91 rr                        sta (up),y
000E21r 3  C8                           iny
000E22r 3  B5 01                        lda 1,x
000E24r 3  91 rr                        sta (up),y
000E26r 3               
000E26r 3                               ; Get the requested block.
000E26r 3  20 rr rr                     jsr xt_blkbuffer
000E29r 3  20 rr rr                     jsr xt_swap
000E2Cr 3  20 rr rr                     jsr xt_block_read
000E2Fr 3               
000E2Fr 3                               ; Mark the buffer as clean and in-use.
000E2Fr 3  A9 01                        lda #1
000E31r 3  A0 2C                        ldy #buffstatus_offset
000E33r 3  91 rr                        sta (up),y
000E35r 3               
000E35r 3                               ; Make room on the stack for the return address.
000E35r 3  CA                           dex
000E36r 3  CA                           dex
000E37r 3               
000E37r 3               @done:
000E37r 3                               ; It's in the buffer. Return the buffer address.
000E37r 3  A0 28                        ldy #blkbuffer_offset
000E39r 3  B1 rr                        lda (up),y
000E3Br 3  95 00                        sta 0,x
000E3Dr 3  C8                           iny
000E3Er 3  B1 rr                        lda (up),y
000E40r 3  95 01                        sta 1,x
000E42r 3               
000E42r 3  60           z_block:        rts
000E43r 3               
000E43r 3               
000E43r 3               
000E43r 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000E43r 3               ; ## "block-ramdrive-init"  auto  Tali block
000E43r 3                       ; """Create a RAM drive, with the given number of
000E43r 3                       ; blocks, in the dictionary along with setting up the block words to
000E43r 3                       ; use it.  The read/write routines do not provide bounds checking.
000E43r 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000E43r 3                       ; """
000E43r 3               
000E43r 3               xt_block_ramdrive_init:
000E43r 3  20 rr rr                     jsr underflow_1
000E46r 3               
000E46r 3                               ; Store the string to run here as a string literal.
000E46r 3                               ; See SLITERAL for the format information. This way, we
000E46r 3                               ; don't have the words defined below in the Dictionary until
000E46r 3                               ; we really use them.
000E46r 3  4C rr rr                     jmp @after_ramdrive_code
000E49r 3               
000E49r 3               @ramdrive_code:
000E49r 3  62 61 73 65          .byte "base @ swap decimal"
000E4Dr 3  20 40 20 73  
000E51r 3  77 61 70 20  
000E5Cr 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000E60r 3  34 20 2A     
000E63r 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000E67r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
000E6Br 3  66 65 72 3A  
000E6Fr 3  20 72 61 6D  
000E78r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000E78r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
000E7Cr 3  6C 6F 63 6B  
000E80r 3  2D 72 65 61  
000E8Er 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000E92r 3  64 72 69 76  
000E96r 3  65 20 73 77  
000EB6r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000EBAr 3  6C 6F 63 6B  
000EBEr 3  2D 77 72 69  
000ECDr 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000ED1r 3  64 72 69 76  
000ED5r 3  65 20 73 77  
000EF0r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000EF4r 3  6C 6F 63 6B  
000EF8r 3  2D 72 65 61  
000F1Ar 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
000F1Er 3  6C 6F 63 6B  
000F22r 3  2D 77 72 69  
000F46r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000F4Ar 3  64 72 69 76  
000F4Er 3  65 20 73 77  
000F61r 3               
000F61r 3               @after_ramdrive_code:
000F61r 3  20 rr rr                     jsr sliteral_runtime
000F64r 3               
000F64r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000F68r 3               
000F68r 3                               ; The address and length of the ramdrive code is now on the
000F68r 3                               ; stack. Call EVALUATE to run it.
000F68r 3  20 rr rr                     jsr xt_evaluate
000F6Br 3               
000F6Br 3               z_block_ramdrive_init:
000F6Br 3  60                           rts
000F6Cr 3               
000F6Cr 3               
000F6Cr 3               
000F6Cr 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
000F6Cr 3               ; ## "block-read"  auto  Tali block
000F6Cr 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000F6Cr 3                       ; with their own version to read a block from storage.
000F6Cr 3                       ; The stack parameters are ( buffer_address block# -- ).
000F6Cr 3                       ; """
000F6Cr 3               xt_block_read:
000F6Cr 3                               ; Execute the BLOCK-READ-VECTOR
000F6Cr 3  A0 2E                        ldy #blockread_offset
000F6Er 3  B1 rr                        lda (up),y
000F70r 3  85 rr                        sta tmp1
000F72r 3  C8                           iny
000F73r 3  B1 rr                        lda (up),y
000F75r 3  85 rr                        sta tmp1+1
000F77r 3               
000F77r 3  6C rr rr                     jmp (tmp1)
000F7Ar 3               
000F7Ar 3               z_block_read:   ; No RTS needed
000F7Ar 3               
000F7Ar 3               
000F7Ar 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
000F7Ar 3               ; ## "block-read-vector"  auto  Tali block
000F7Ar 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000F7Ar 3                       ; with their own version to read a block from storage.
000F7Ar 3                       ; This word gives the address of the vector so it can be replaced.
000F7Ar 3                       ; """
000F7Ar 3               xt_block_read_vector:
000F7Ar 3                               ; Get the BLOCK-READ-VECTOR address
000F7Ar 3  CA                           dex
000F7Br 3  CA                           dex
000F7Cr 3  18                           clc
000F7Dr 3  A5 rr                        lda up
000F7Fr 3  69 2E                        adc #blockread_offset
000F81r 3  95 00                        sta 0,x
000F83r 3  A5 rr                        lda up+1
000F85r 3  69 00                        adc #0          ; Add carry
000F87r 3  95 01                        sta 1,x
000F89r 3               
000F89r 3               z_block_read_vector:
000F89r 3  60                           rts
000F8Ar 3               
000F8Ar 3               
000F8Ar 3               ; This is the default error message the vectored words BLOCK-READ and
000F8Ar 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
000F8Ar 3               xt_block_word_error:
000F8Ar 3  A9 0C                        lda #err_blockwords
000F8Cr 3  4C rr rr                     jmp error       ; no RTS needed
000F8Fr 3               z_block_word_error:
000F8Fr 3               
000F8Fr 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000F8Fr 3               ; ## "block-write"  auto  Tali block
000F8Fr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000F8Fr 3                       ; with their own version to write a block to storage.
000F8Fr 3                       ; The stack parameters are ( buffer_address block# -- ).
000F8Fr 3                       ; """
000F8Fr 3               xt_block_write:
000F8Fr 3                               ; Execute the BLOCK-READ-VECTOR
000F8Fr 3  A0 30                        ldy #blockwrite_offset
000F91r 3  B1 rr                        lda (up),y
000F93r 3  85 rr                        sta tmp1
000F95r 3  C8                           iny
000F96r 3  B1 rr                        lda (up),y
000F98r 3  85 rr                        sta tmp1+1
000F9Ar 3  6C rr rr                     jmp (tmp1)
000F9Dr 3               
000F9Dr 3               z_block_write:  ; No RTS needed
000F9Dr 3               
000F9Dr 3               
000F9Dr 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
000F9Dr 3               ; ## "block-write-vector"  auto  Tali block
000F9Dr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000F9Dr 3                       ; with their own version to write a block to storage.
000F9Dr 3                       ; This word gives the address of the vector so it can be replaced.
000F9Dr 3                       ; """
000F9Dr 3               xt_block_write_vector:
000F9Dr 3                               ; Get the BLOCK-WRITE-VECTOR address
000F9Dr 3  CA                           dex
000F9Er 3  CA                           dex
000F9Fr 3  18                           clc
000FA0r 3  A5 rr                        lda up
000FA2r 3  69 30                        adc #blockwrite_offset
000FA4r 3  95 00                        sta 0,x
000FA6r 3  A5 rr                        lda up+1
000FA8r 3  69 00                        adc #0          ; Add carry
000FAAr 3  95 01                        sta 1,x
000FACr 3               
000FACr 3               z_block_write_vector:
000FACr 3  60                           rts
000FADr 3               
000FADr 3               
000FADr 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
000FADr 3               ; ## "bounds"  auto  Gforth
000FADr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
000FADr 3                       ; Given a string, return the correct Data Stack parameters for
000FADr 3                       ; a DO/LOOP loop over its characters. This is realized as
000FADr 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
000FADr 3                       ; """
000FADr 3               xt_bounds:
000FADr 3  20 rr rr                     jsr underflow_2
000FB0r 3               
000FB0r 3  18                           clc
000FB1r 3  B5 00                        lda 0,x                 ; LSB u
000FB3r 3  B4 02                        ldy 2,x                 ; LSB addr
000FB5r 3  75 02                        adc 2,x
000FB7r 3  95 02                        sta 2,x                 ; LSB addr+u
000FB9r 3  94 00                        sty 0,x
000FBBr 3               
000FBBr 3  B5 01                        lda 1,x                 ; MSB u
000FBDr 3  B4 03                        ldy 3,x                 ; MSB addr
000FBFr 3  75 03                        adc 3,x
000FC1r 3  95 03                        sta 3,x                 ; MSB addr+u
000FC3r 3  94 01                        sty 1,x
000FC5r 3               
000FC5r 3  60           z_bounds:       rts
000FC6r 3               
000FC6r 3               
000FC6r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000FC6r 3               ; ## "[char]"  auto  ANS core
000FC6r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000FC6r 3                       ; Compile the ASCII value of a character as a literal. This is an
000FC6r 3                       ; immediate, compile-only word.
000FC6r 3                       ;
000FC6r 3                       ; A definition given in
000FC6r 3                       ; http://forth-standard.org/standard/implement is
000FC6r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000FC6r 3                       ; """
000FC6r 3               xt_bracket_char:
000FC6r 3  20 rr rr                     jsr xt_char
000FC9r 3  20 rr rr                     jsr xt_literal
000FCCr 3  60           z_bracket_char: rts
000FCDr 3               
000FCDr 3               
000FCDr 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000FCDr 3               ; ## "[']"  auto  ANS core
000FCDr 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000FCDr 3               xt_bracket_tick:
000FCDr 3  20 rr rr                     jsr xt_tick
000FD0r 3  20 rr rr                     jsr xt_literal
000FD3r 3  60           z_bracket_tick: rts
000FD4r 3               
000FD4r 3               
000FD4r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000FD4r 3               ; ## "buffblocknum"  auto  Tali block
000FD4r 3               xt_buffblocknum:
000FD4r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000FD4r 3  CA                           dex
000FD5r 3  CA                           dex
000FD6r 3  18                           clc
000FD7r 3  A5 rr                        lda up
000FD9r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000FDBr 3  95 00                        sta 0,x
000FDDr 3  A5 rr                        lda up+1
000FDFr 3  69 00                        adc #0                          ; Adding carry
000FE1r 3  95 01                        sta 1,x
000FE3r 3               
000FE3r 3  60           z_buffblocknum: rts
000FE4r 3               
000FE4r 3               
000FE4r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000FE4r 3               ; ## "buffer"  auto  ANS block
000FE4r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000FE4r 3               
000FE4r 3               xt_buffer:
000FE4r 3                               ; Check the buffer status
000FE4r 3  A0 2C                        ldy #buffstatus_offset
000FE6r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000FE8r 3  C9 03                        cmp #3          ; LSB is needed.
000FEAr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000FECr 3               
000FECr 3                               ; We need to save the block.
000FECr 3  20 rr rr                     jsr xt_blkbuffer
000FEFr 3  20 rr rr                     jsr xt_buffblocknum
000FF2r 3  20 rr rr                     jsr xt_fetch
000FF5r 3  20 rr rr                     jsr xt_block_write
000FF8r 3               
000FF8r 3               @buffer_available:
000FF8r 3                               ; Save the block number.
000FF8r 3  A0 2A                        ldy #buffblocknum_offset
000FFAr 3  B5 00                        lda 0,x
000FFCr 3  91 rr                        sta (up),y
000FFEr 3  C8                           iny
000FFFr 3  B5 01                        lda 1,x
001001r 3  91 rr                        sta (up),y
001003r 3               
001003r 3                               ; Mark the buffer as clean and in-use.
001003r 3  A9 01                        lda #1
001005r 3  A0 2C                        ldy #buffstatus_offset
001007r 3  91 rr                        sta (up),y
001009r 3               
001009r 3               @done:
001009r 3                               ; Return the buffer address.
001009r 3  A0 28                        ldy #blkbuffer_offset
00100Br 3  B1 rr                        lda (up),y
00100Dr 3  95 00                        sta 0,x
00100Fr 3  C8                           iny
001010r 3  B1 rr                        lda (up),y
001012r 3  95 01                        sta 1,x
001014r 3               
001014r 3  60           z_buffer:       rts
001015r 3               
001015r 3               
001015r 3               
001015r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
001015r 3               ; ## "buffer:"  auto  ANS core ext
001015r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
001015r 3                               ; Create a buffer of size u that puts its address on the stack
001015r 3                               ; when its name is used.
001015r 3                               ; """
001015r 3               xt_buffer_colon:
001015r 3  20 rr rr                     jsr xt_create
001018r 3  20 rr rr                     jsr xt_allot
00101Br 3  60           z_buffer_colon: rts
00101Cr 3               
00101Cr 3               
00101Cr 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
00101Cr 3               ; ## "buffstatus"  auto  Tali block
00101Cr 3               xt_buffstatus:
00101Cr 3                               ; BUFFSTATUS is at UP + buffstatus_offset
00101Cr 3  CA                           dex
00101Dr 3  CA                           dex
00101Er 3  18                           clc
00101Fr 3  A5 rr                        lda up
001021r 3  69 2C                        adc #buffstatus_offset  ; Add offset
001023r 3  95 00                        sta 0,x
001025r 3  A5 rr                        lda up+1
001027r 3  69 00                        adc #0                  ; Adding carry
001029r 3  95 01                        sta 1,x
00102Br 3               
00102Br 3  60           z_buffstatus:   rts
00102Cr 3               
00102Cr 3               
00102Cr 3               ; ## BYE ( -- ) "Break"
00102Cr 3               ; ## "bye"  tested  ANS tools ext
00102Cr 3                       ; """https://forth-standard.org/standard/tools/BYE"""
00102Cr 3               
00102Cr 3               xt_bye:
00102Cr 3                               ;brk
00102Cr 3  4C rr rr                     jmp platform_bye
00102Fr 3               z_bye:          ;rts             ; never reached
00102Fr 3               
00102Fr 3               
00102Fr 3               
00102Fr 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
00102Fr 3               ; ## "c,"  auto  ANS core
00102Fr 3                       ; """https://forth-standard.org/standard/core/CComma"""
00102Fr 3               
00102Fr 3               xt_c_comma:
00102Fr 3  20 rr rr                     jsr underflow_1
001032r 3               
001032r 3  B5 00                        lda 0,x
001034r 3  20 rr rr                     jsr cmpl_a
001037r 3               
001037r 3  E8                           inx
001038r 3  E8                           inx
001039r 3               
001039r 3  60           z_c_comma:      rts
00103Ar 3               
00103Ar 3               
00103Ar 3               
00103Ar 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
00103Ar 3               ; ## "c@"  auto  ANS core
00103Ar 3                       ; """https://forth-standard.org/standard/core/CFetch"""
00103Ar 3               xt_c_fetch:
00103Ar 3  20 rr rr                     jsr underflow_1
00103Dr 3               
00103Dr 3  A1 00                        lda (0,x)
00103Fr 3  95 00                        sta 0,x
001041r 3  74 01                        stz 1,x         ; Ignore LSB
001043r 3               
001043r 3  60           z_c_fetch:      rts
001044r 3               
001044r 3               
001044r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
001044r 3               ; ## "c!"  auto  ANS core
001044r 3                       ; """https://forth-standard.org/standard/core/CStore"""
001044r 3               xt_c_store:
001044r 3  20 rr rr                     jsr underflow_2
001047r 3               
001047r 3  B5 02                        lda 2,x
001049r 3  81 00                        sta (0,x)
00104Br 3               
00104Br 3  E8                           inx
00104Cr 3  E8                           inx
00104Dr 3  E8                           inx
00104Er 3  E8                           inx
00104Fr 3               
00104Fr 3  60           z_c_store:      rts
001050r 3               
001050r 3               
001050r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
001050r 3               ; ## "case"  auto  ANS core ext
001050r 3                       ; """http://forth-standard.org/standard/core/CASE
001050r 3                       ;
001050r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
001050r 3                       ; """
001050r 3               
001050r 3               
001050r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
001050r 3               ; ## "cell+"  auto  ANS core
001050r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
001050r 3                       ; Add the number of bytes ("address units") that one cell needs.
001050r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
001050r 3                       ; """
001050r 3               
001050r 3               xt_cell_plus:
001050r 3  20 rr rr                     jsr underflow_1
001053r 3               
001053r 3  F6 00                        inc 0,x
001055r 3  D0 02                        bne @1
001057r 3  F6 01                        inc 1,x
001059r 3               @1:
001059r 3  F6 00                        inc 0,x
00105Br 3  D0 02                        bne @done
00105Dr 3  F6 01                        inc 1,x
00105Fr 3               @done:
00105Fr 3  60           z_cell_plus:    rts
001060r 3               
001060r 3               
001060r 3               
001060r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
001060r 3               ; ## "cells"  auto  ANS core
001060r 3                       ; """https://forth-standard.org/standard/core/CELLS
001060r 3                       ;
001060r 3                       ; Dummy entry for the CELLS word, the code is the same as for
001060r 3                       ; 2*, which is where the header directs us to
001060r 3                       ; """
001060r 3               
001060r 3               
001060r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
001060r 3               ; ## "char"  auto  ANS core
001060r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
001060r 3               
001060r 3               xt_char:
001060r 3                               ; get character from string, returns ( addr u )
001060r 3  20 rr rr                     jsr xt_parse_name
001063r 3               
001063r 3                               ; if we got back a zero, we have a problem
001063r 3  B5 00                        lda 0,x
001065r 3  15 01                        ora 1,x
001067r 3  D0 05                        bne @not_empty
001069r 3               
001069r 3  A9 05                        lda #err_noname
00106Br 3  4C rr rr                     jmp error
00106Er 3               
00106Er 3               @not_empty:
00106Er 3  E8                           inx             ; drop number of characters, leave addr
00106Fr 3  E8                           inx
001070r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
001072r 3  95 00                        sta 0,x
001074r 3  74 01                        stz 1,x         ; MSB is always zero
001076r 3               
001076r 3  60           z_char:         rts
001077r 3               
001077r 3               
001077r 3               
001077r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
001077r 3               ; ## "char+"  auto  ANS core
001077r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
001077r 3                       ;
001077r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
001077r 3                       ; """
001077r 3               
001077r 3               
001077r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
001077r 3               ; ## "chars"  auto  ANS core
001077r 3                       ; """https://forth-standard.org/standard/core/CHARS
001077r 3                       ; Return how many address units n chars are. Since this is an 8 bit
001077r 3                       ; machine, this does absolutely nothing and is included for
001077r 3                       ; compatibility with other Forth versions
001077r 3                       ; """
001077r 3               
001077r 3               xt_chars:
001077r 3                               ; Checking for underflow seems a bit stupid because this
001077r 3                               ; routine does nothing on this machine. However, the user
001077r 3                               ; should be warned that there is something wrong with the
001077r 3                               ; code if this occurs.
001077r 3  20 rr rr                     jsr underflow_1
00107Ar 3               
00107Ar 3  60           z_chars:        rts
00107Br 3               
00107Br 3               
00107Br 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
00107Br 3               ; ## "cleave"  auto  Tali Forth
00107Br 3               
00107Br 3                       ; """Given a range of memory with words delimited by whitespace,return
00107Br 3                       ; the first word at the top of the stack and the rest of the word
00107Br 3                       ; following it.
00107Br 3                       ;
00107Br 3                       ; Example:
00107Br 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
00107Br 3                       ; s" w1" cleave        -> "" "w1"
00107Br 3                       ;
00107Br 3                       ; Since it will be used in loops a lot, we want it to work in pure
00107Br 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
00107Br 3                       ; strip leading delimiters.
00107Br 3                       ; """
00107Br 3               
00107Br 3               xt_cleave:
00107Br 3  20 rr rr                     jsr underflow_2
00107Er 3               
00107Er 3                               ; We arrive here with ( addr u ). We need to strip any leading
00107Er 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
00107Er 3                               ; remember how many spaces were stripped. This means we can't
00107Er 3                               ; calculate the length of the remainder. Fortunately, Tali
00107Er 3                               ; Forth has just the word we need for this:
00107Er 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
001081r 3               
001081r 3                               ; The main part we can turn over to PARSE-NAME, except that we
001081r 3                               ; have a string ( addr u ) and not stuff in the input buffer.
001081r 3                               ; We get around this by cheating: We place ( addr u ) in the
001081r 3                               ; input buffer and then call PARSE-NAME.
001081r 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
001084r 3               
001084r 3  B5 00                        lda 0,x         ; u is new ciblen
001086r 3  85 rr                        sta ciblen
001088r 3  B5 01                        lda 1,x
00108Ar 3  85 rr                        sta ciblen+1
00108Cr 3               
00108Cr 3  B5 02                        lda 2,x         ; addr is new cib
00108Er 3  85 rr                        sta cib
001090r 3  B5 03                        lda 3,x
001092r 3  85 rr                        sta cib+1
001094r 3               
001094r 3  64 rr                        stz toin        ; >IN pointer is zero
001096r 3  64 rr                        stz toin+1
001098r 3               
001098r 3                               ; PARSE-NAME gives us back the substring of the first word
001098r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
00109Br 3               
00109Br 3                               ; If we were given an empty string, then we're done. It's the
00109Br 3                               ; resposibility of the user to catch this as a sign to end the
00109Br 3                               ; any loop
00109Br 3  B5 00                        lda 0,x
00109Dr 3  15 01                        ora 1,x
00109Fr 3  F0 23                        beq @done
0010A1r 3               
0010A1r 3                               ; Now we have to adjust the original string
0010A1r 3  B5 04                        lda 4,x         ; LSB of original u
0010A3r 3  38                           sec
0010A4r 3  F5 00                        sbc 0,x
0010A6r 3  95 04                        sta 4,x
0010A8r 3               
0010A8r 3  B5 05                        lda 5,x         ; MSB of original u
0010AAr 3  F5 01                        sbc 1,x
0010ACr 3  95 05                        sta 5,x
0010AEr 3               
0010AEr 3  B5 06                        lda 6,x         ; LSB of original addr
0010B0r 3  18                           clc
0010B1r 3  75 00                        adc 0,x
0010B3r 3  95 06                        sta 6,x
0010B5r 3               
0010B5r 3  B5 07                        lda 7,x         ; MSB of original addr
0010B7r 3  75 01                        adc 1,x
0010B9r 3  95 07                        sta 7,x
0010BBr 3               
0010BBr 3                               ; There is one small problem: PARSE-NAME will probably have
0010BBr 3                               ; left the string with the rest of the words with leading
0010BBr 3                               ; delimiters. We use our magic -LEADING again
0010BBr 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
0010BEr 3  20 rr rr                     jsr xt_minus_leading
0010C1r 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
0010C4r 3               @done:
0010C4r 3                               ; Restore input
0010C4r 3  20 rr rr                     jsr xt_r_to_input
0010C7r 3               
0010C7r 3  60           z_cleave:       rts
0010C8r 3               
0010C8r 3               
0010C8r 3               
0010C8r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
0010C8r 3               ; ## "cmove"  auto  ANS string
0010C8r 3                       ; """https://forth-standard.org/standard/string/CMOVE
0010C8r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
0010C8r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
0010C8r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
0010C8r 3                       ; "move left".
0010C8r 3                       ;
0010C8r 3                       ; There are no official tests for this word.
0010C8r 3                       ; """
0010C8r 3               
0010C8r 3               xt_cmove:
0010C8r 3  20 rr rr                     jsr underflow_3
0010CBr 3               
0010CBr 3                               ; move destination address to where we can work with it
0010CBr 3  B5 02                        lda 2,x
0010CDr 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
0010CFr 3  B5 03                        lda 3,x
0010D1r 3  85 rr                        sta tmp2+1
0010D3r 3               
0010D3r 3                               ; move source address to where we can work with it
0010D3r 3  B5 04                        lda 4,x
0010D5r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
0010D7r 3  B5 05                        lda 5,x
0010D9r 3  85 rr                        sta tmp1+1
0010DBr 3               
0010DBr 3  A0 00                        ldy #0
0010DDr 3  B5 01                        lda 1,x         ; number of whole pages to move
0010DFr 3  F0 0F                        beq @dopartial
0010E1r 3               
0010E1r 3               @page:
0010E1r 3  B1 rr                        lda (tmp1),y
0010E3r 3  91 rr                        sta (tmp2),y
0010E5r 3  C8                           iny
0010E6r 3  D0 F9                        bne @page
0010E8r 3               
0010E8r 3  E6 rr                        inc tmp1+1
0010EAr 3  E6 rr                        inc tmp2+1
0010ECr 3  D6 01                        dec 1,x
0010EEr 3  D0 F1                        bne @page
0010F0r 3               
0010F0r 3               @dopartial:
0010F0r 3  B5 00                        lda 0,x         ; length of last page
0010F2r 3  F0 09                        beq @done
0010F4r 3               
0010F4r 3               @partial:
0010F4r 3  B1 rr                        lda (tmp1),y
0010F6r 3  91 rr                        sta (tmp2),y
0010F8r 3  C8                           iny
0010F9r 3               
0010F9r 3  D6 00                        dec 0,x
0010FBr 3  D0 F7                        bne @partial
0010FDr 3               
0010FDr 3               @done:          ; clear the stack
0010FDr 3  8A                           txa
0010FEr 3  18                           clc
0010FFr 3  69 06                        adc #6
001101r 3  AA                           tax
001102r 3               
001102r 3  60           z_cmove:        rts
001103r 3               
001103r 3               
001103r 3               
001103r 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
001103r 3               ; ## "cmove>"  auto  ANS string
001103r 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
001103r 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
001103r 3                       ; Routines", p. 201, where it is called "move right".
001103r 3                       ;
001103r 3                       ; There are no official tests for this word.
001103r 3                       ; """
001103r 3               
001103r 3               xt_cmove_up:
001103r 3  20 rr rr                     jsr underflow_3
001106r 3               
001106r 3                               ; Move destination address to where we can work with it
001106r 3  B5 02                        lda 2,x
001108r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
00110Ar 3  B5 03                        lda 3,x
00110Cr 3  18                           clc
00110Dr 3  75 01                        adc 1,x
00110Fr 3  85 rr                        sta tmp2+1      ; point to last page of destination
001111r 3               
001111r 3                               ; Move source address to where we can work with it
001111r 3  B5 04                        lda 4,x
001113r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
001115r 3  B5 05                        lda 5,x
001117r 3  18                           clc
001118r 3  75 01                        adc 1,x
00111Ar 3  85 rr                        sta tmp1+1      ; point to last page of source
00111Cr 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
00111Er 3               
00111Er 3                               ; Move the last partial page first
00111Er 3  B4 00                        ldy 0,x         ; length of last page
001120r 3  F0 0E                        beq @nopartial
001122r 3               
001122r 3               @outerloop:
001122r 3  88                           dey
001123r 3  F0 07                        beq @finishpage
001125r 3               
001125r 3               @innerloop:
001125r 3  B1 rr                        lda (tmp1),y
001127r 3  91 rr                        sta (tmp2),y
001129r 3  88                           dey
00112Ar 3  D0 F9                        bne @innerloop
00112Cr 3               
00112Cr 3               @finishpage:
00112Cr 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
00112Er 3  92 rr                        sta (tmp2)
001130r 3               
001130r 3               @nopartial:
001130r 3  C6 rr                        dec tmp1+1      ; back up to previous pages
001132r 3  C6 rr                        dec tmp2+1
001134r 3  D6 01                        dec 1,x
001136r 3  D0 EA                        bne @outerloop
001138r 3               @done:
001138r 3                               ; clear up the stack and leave
001138r 3  8A                           txa
001139r 3  18                           clc
00113Ar 3  69 06                        adc #6
00113Cr 3  AA                           tax
00113Dr 3               
00113Dr 3  60           z_cmove_up:     rts
00113Er 3               
00113Er 3               
00113Er 3               
00113Er 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
00113Er 3               ; ## ":"  auto  ANS core
00113Er 3                       ; """https://forth-standard.org/standard/core/Colon
00113Er 3                       ;
00113Er 3                       ; Use the CREATE routine and fill in the rest by hand.
00113Er 3                       ; """
00113Er 3               
00113Er 3               xt_colon:
00113Er 3                               ; If we're already in the compile state, complain
00113Er 3                               ; and quit
00113Er 3  A5 rr                        lda state
001140r 3  05 rr                        ora state+1
001142r 3  F0 05                        beq @1
001144r 3               
001144r 3  A9 07                        lda #err_state
001146r 3  4C rr rr                     jmp error
001149r 3               @1:
001149r 3                               ; switch to compile state
001149r 3  C6 rr                        dec state
00114Br 3  C6 rr                        dec state+1
00114Dr 3               
00114Dr 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
00114Dr 3                               ; word
00114Dr 3  A9 40                        lda #%01000000
00114Fr 3  04 rr                        tsb status
001151r 3               
001151r 3                               ; CREATE is going to change the DP to point to the new word's
001151r 3                               ; header. While this is fine for (say) variables, it would mean
001151r 3                               ; that FIND-NAME etc would find a half-finished word when
001151r 3                               ; looking in the Dictionary. To prevent this, we save the old
001151r 3                               ; version of DP and restore it later. The new DP is placed in
001151r 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
001151r 3  20 rr rr                     jsr current_to_dp
001154r 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
001156r 3  48                           pha
001157r 3  A5 rr                        lda dp
001159r 3  48                           pha
00115Ar 3               
00115Ar 3                               ; Tell create not to print warning for duplicate name.
00115Ar 3  A9 80                        lda #%10000000
00115Cr 3  04 rr                        tsb status
00115Er 3               
00115Er 3  20 rr rr                     jsr xt_create
001161r 3               
001161r 3                               ; Get the nt (not the xt!) of the new word as described above.
001161r 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
001161r 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
001164r 3  A5 rr                        lda dp
001166r 3  85 rr                        sta workword
001168r 3  A5 rr                        lda dp+1
00116Ar 3  85 rr                        sta workword+1
00116Cr 3               
00116Cr 3                               ; Restore original DP
00116Cr 3  68                           pla
00116Dr 3  85 rr                        sta dp
00116Fr 3  68                           pla
001170r 3  85 rr                        sta dp+1
001172r 3  20 rr rr                     jsr dp_to_current
001175r 3               
001175r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
001175r 3                               ; back up three bytes and overwrite that.
001175r 3  A5 rr                        lda cp
001177r 3  38                           sec
001178r 3  E9 03                        sbc #3
00117Ar 3  85 rr                        sta cp
00117Cr 3  B0 02                        bcs @done
00117Er 3  C6 rr                        dec cp+1
001180r 3               @done:
001180r 3  60           z_colon:        rts
001181r 3               
001181r 3               
001181r 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
001181r 3               ; ## ":NONAME"  auto  ANS core
001181r 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
001181r 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
001181r 3                       ; """
001181r 3               
001181r 3               xt_colon_noname:
001181r 3                               ; If we're already in the compile state, complain
001181r 3                               ; and quit
001181r 3  A5 rr                        lda state
001183r 3  05 rr                        ora state+1
001185r 3  F0 05                        beq @1
001187r 3               
001187r 3  A9 07                        lda #err_state
001189r 3  4C rr rr                     jmp error
00118Cr 3               @1:
00118Cr 3                               ; switch to compile state
00118Cr 3  C6 rr                        dec state
00118Er 3  C6 rr                        dec state+1
001190r 3               
001190r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
001190r 3                               ; a :NONAME word.
001190r 3  A9 40                        lda #%01000000
001192r 3  14 rr                        trb status
001194r 3               
001194r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
001194r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
001194r 3                               ; nt and they will modify their behavior.
001194r 3  A5 rr                        lda cp
001196r 3  85 rr                        sta workword
001198r 3  A5 rr                        lda cp+1
00119Ar 3  85 rr                        sta workword+1
00119Cr 3               @done:
00119Cr 3  60           z_colon_noname:        rts
00119Dr 3               
00119Dr 3               
00119Dr 3               
00119Dr 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
00119Dr 3               ; ## ","  auto  ANS core
00119Dr 3                       ; """https://forth-standard.org/standard/core/Comma
00119Dr 3                       ; Store TOS at current place in memory.
00119Dr 3                       ;
00119Dr 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
00119Dr 3                       ; """
00119Dr 3               
00119Dr 3               xt_comma:
00119Dr 3  20 rr rr                     jsr underflow_1
0011A0r 3               
0011A0r 3  B5 00                        lda 0,x
0011A2r 3  92 rr                        sta (cp)
0011A4r 3               
0011A4r 3  E6 rr                        inc cp
0011A6r 3  D0 02                        bne @1
0011A8r 3  E6 rr                        inc cp+1
0011AAr 3               @1:
0011AAr 3  B5 01                        lda 1,x
0011ACr 3  92 rr                        sta (cp)
0011AEr 3               
0011AEr 3  E6 rr                        inc cp
0011B0r 3  D0 02                        bne @done
0011B2r 3  E6 rr                        inc cp+1
0011B4r 3               @done:
0011B4r 3  E8                           inx
0011B5r 3  E8                           inx
0011B6r 3               
0011B6r 3  60           z_comma:        rts
0011B7r 3               
0011B7r 3               
0011B7r 3               
0011B7r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
0011B7r 3               ; ## "compare"   auto  ANS string
0011B7r 3                       ; """https://forth-standard.org/standard/string/COMPARE
0011B7r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
0011B7r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
0011B7r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
0011B7r 3                       ; that entirely matches the beginning of the other string, but is
0011B7r 3                       ; shorter, is considered less than the longer string.
0011B7r 3                       ; """
0011B7r 3               
0011B7r 3               xt_compare:
0011B7r 3  20 rr rr                     jsr underflow_4
0011BAr 3               
0011BAr 3                               ; Load the two string addresses into tmp1 and tmp2.
0011BAr 3  B5 02                        lda 2,x
0011BCr 3  85 rr                        sta tmp2
0011BEr 3  B5 03                        lda 3,x
0011C0r 3  85 rr                        sta tmp2+1
0011C2r 3  B5 06                        lda 6,x
0011C4r 3  85 rr                        sta tmp1
0011C6r 3  B5 07                        lda 7,x
0011C8r 3  85 rr                        sta tmp1+1
0011CAr 3                               ; The counts will be used in-place on the stack.
0011CAr 3               
0011CAr 3               @compare_loop:
0011CAr 3                               ; Check to see if we are out of letters.
0011CAr 3               
0011CAr 3                               ; Check string1
0011CAr 3  B5 04                        lda 4,x
0011CCr 3  15 05                        ora 5,x
0011CEr 3  F0 2C                        beq @str1_done
0011D0r 3               
0011D0r 3                               ; Check string2
0011D0r 3  B5 00                        lda 0,x
0011D2r 3  15 01                        ora 1,x
0011D4r 3  F0 3A                        beq @greater    ; Str2 empty first
0011D6r 3               
0011D6r 3               @check_letter:
0011D6r 3                               ; Both strings have at least one letter left.
0011D6r 3                               ; Check the letters against each other.
0011D6r 3  B2 rr                        lda (tmp1)
0011D8r 3  D2 rr                        cmp (tmp2)
0011DAr 3  90 26                        bcc @less
0011DCr 3  D0 32                        bne @greater
0011DEr 3               @next_letter:
0011DEr 3                               ; Move both tmp pointers and decrement the counts
0011DEr 3                               ; on the stack.
0011DEr 3                               ; Increment tmp1
0011DEr 3  E6 rr                        inc tmp1
0011E0r 3  D0 02                        bne @1
0011E2r 3  E6 rr                        inc tmp1+1
0011E4r 3               @1:
0011E4r 3                               ; Increment tmp2
0011E4r 3  E6 rr                        inc tmp2
0011E6r 3  D0 02                        bne @2
0011E8r 3  E6 rr                        inc tmp2+1
0011EAr 3               @2:
0011EAr 3                               ; Decrement count1 on the stack.
0011EAr 3  B5 04                        lda 4,x
0011ECr 3  D0 02                        bne @3
0011EEr 3  D6 05                        dec 5,x
0011F0r 3               @3:
0011F0r 3  D6 04                        dec 4,x
0011F2r 3               
0011F2r 3                               ; Decrement count2 on the stack.
0011F2r 3  B5 00                        lda 0,x
0011F4r 3  D0 02                        bne @4
0011F6r 3  D6 01                        dec 1,x
0011F8r 3               @4:
0011F8r 3  D6 00                        dec 0,x
0011FAr 3               
0011FAr 3                               ; Loop around and check again.
0011FAr 3  80 CE                        bra @compare_loop
0011FCr 3               
0011FCr 3               @str1_done:
0011FCr 3                               ; String 1 is out of letters. Check string 2.
0011FCr 3  B5 00                        lda 0,x
0011FEr 3  15 01                        ora 1,x
001200r 3  F0 08                        beq @equal      ; Both out of letters
001202r 3               
001202r 3                               ; Falls into less (str1 is out but str2 has more)
001202r 3               @less:
001202r 3                               ; Return -1
001202r 3  A9 FF                        lda #$FF
001204r 3  95 06                        sta 6,x
001206r 3  95 07                        sta 7,x
001208r 3  80 0C                        bra @done
00120Ar 3               @equal:
00120Ar 3                               ; Return 0
00120Ar 3  74 06                        stz 6,x
00120Cr 3  74 07                        stz 7,x
00120Er 3  80 06                        bra @done
001210r 3               @greater:
001210r 3                               ; Return 1
001210r 3  A9 01                        lda #1
001212r 3  95 06                        sta 6,x
001214r 3  74 07                        stz 7,x
001216r 3                               ; Falls into @done
001216r 3               @done:
001216r 3                               ; Remove all but the result from the stack.
001216r 3  8A                           txa
001217r 3  18                           clc
001218r 3  69 06                        adc #6
00121Ar 3  AA                           tax
00121Br 3               
00121Br 3  60           z_compare:      rts
00121Cr 3               
00121Cr 3               
00121Cr 3               
00121Cr 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
00121Cr 3               ; ## "compile,"  auto  ANS core ext
00121Cr 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
00121Cr 3                       ; Compile the given xt in the current word definition. It is an
00121Cr 3                       ; error if we are not in the compile state. Because we are using
00121Cr 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
00121Cr 3                       ; the traditional way. By default, native compiled is allowed, unless
00121Cr 3                       ; there is a NN (Never Native) flag associated. If not, we use the
00121Cr 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
00121Cr 3                       ; is too large to be natively coded: If the size is larger than
00121Cr 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
00121Cr 3                       ; Native) flag is set, the word is always natively compiled.
00121Cr 3                       ; """
00121Cr 3               
00121Cr 3               xt_compile_comma:
00121Cr 3  20 rr rr                     jsr underflow_1
00121Fr 3               
00121Fr 3                               ; See if this is an Always Native (AN) word by checking the
00121Fr 3                               ; AN flag. We need nt for this. First, save a copy of xt to
00121Fr 3                               ; the Return Stack
00121Fr 3  B5 01                        lda 1,x                 ; MSB
001221r 3  48                           pha
001222r 3  B5 00                        lda 0,x
001224r 3  48                           pha                     ; LSB
001225r 3               
001225r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
001228r 3               
001228r 3                               ; See if this xt even has an nt.
001228r 3  B5 00                        lda 0,x
00122Ar 3  15 01                        ora 1,x
00122Cr 3  D0 03                        bne @check_nt
00122Er 3               
00122Er 3                               ; No nt in dictionary. Just compile as a JSR.
00122Er 3  4C rr rr                     jmp @compile_as_jump
001231r 3               
001231r 3               @check_nt:
001231r 3                               ; put nt away for safe keeping
001231r 3  B5 00                        lda 0,x
001233r 3  85 rr                        sta tmptos
001235r 3  B5 01                        lda 1,x
001237r 3  85 rr                        sta tmptos+1
001239r 3               
001239r 3                               ; status byte is one further down
001239r 3  F6 00                        inc 0,x
00123Br 3  D0 02                        bne @1
00123Dr 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
00123Fr 3               @1:
00123Fr 3  A1 00                        lda (0,x)
001241r 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
001243r 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
001245r 3  F0 0D                        beq @compile_check
001247r 3               
001247r 3                               ; We're natively compiling no matter what. Get length and
001247r 3                               ; compile in code. Get the original nt back
001247r 3  A5 rr                        lda tmptos
001249r 3  95 00                        sta 0,x
00124Br 3  A5 rr                        lda tmptos+1
00124Dr 3  95 01                        sta 1,x
00124Fr 3               
00124Fr 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
001252r 3               
001252r 3  80 27                        bra @compile_as_code
001254r 3               
001254r 3               @compile_check:
001254r 3                               ; See if Native Compile is even alowed by checking the NN
001254r 3                               ; flag
001254r 3  A5 rr                        lda tmp3
001256r 3  29 08                        and #NN
001258r 3  F0 03                        beq @check_size_limit
00125Ar 3               
00125Ar 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00125Dr 3               
00125Dr 3               @check_size_limit:
00125Dr 3                               ; Native compile is a legal option, but we need to see what
00125Dr 3                               ; limit the user set for size (in nc_limit)
00125Dr 3  A5 rr                        lda tmptos
00125Fr 3  95 00                        sta 0,x
001261r 3  A5 rr                        lda tmptos+1
001263r 3  95 01                        sta 1,x
001265r 3               
001265r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
001268r 3               
001268r 3                               ; Check the wordsize MSB against the user-defined limit.
001268r 3  B5 01                        lda 1,x
00126Ar 3  C5 rr                        cmp nc_limit+1
00126Cr 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
00126Er 3  D0 08                        bne @jumpto_compile_as_jump
001270r 3               
001270r 3                               ; Check the wordsize LSB against the user-defined limit.
001270r 3  B5 00                        lda 0,x
001272r 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
001274r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
001276r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
001278r 3               
001278r 3               @jumpto_compile_as_jump:
001278r 3                               ; If the wordsize is greater than the user-defined
001278r 3                               ; limit, it will be compiled as a subroutine jump.
001278r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00127Br 3               
00127Br 3               @compile_as_code:
00127Br 3                               ; We arrive here with the length of the word's code TOS and
00127Br 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
00127Br 3                               ; on the data stack
00127Br 3  CA                           dex
00127Cr 3  CA                           dex                     ; ( -- u ? )
00127Dr 3  CA                           dex
00127Er 3  CA                           dex                     ; ( -- u ? ? )
00127Fr 3               
00127Fr 3  B5 04                        lda 4,x
001281r 3  95 00                        sta 0,x                 ; LSB of u
001283r 3  B5 05                        lda 5,x
001285r 3  95 01                        sta 1,x                 ; ( -- u ? u )
001287r 3               
001287r 3  68                           pla
001288r 3  95 04                        sta 4,x                 ; LSB of xt
00128Ar 3  68                           pla
00128Br 3  95 05                        sta 5,x                 ; ( -- xt ? u )
00128Dr 3               
00128Dr 3  A5 rr                        lda cp                  ; LSB of cp
00128Fr 3  95 02                        sta 2,x
001291r 3  A5 rr                        lda cp+1
001293r 3  95 03                        sta 3,x                 ; ( -- xt cp u )
001295r 3               
001295r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
001295r 3               
001295r 3                               ; Native compiling allows us to strip the stack antics off
001295r 3                               ; a number of words that use the Return Stack such as >R, R>,
001295r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
001295r 3                               ; xt with the contents of the table
001295r 3  A0 00                        ldy #0
001297r 3               
001297r 3               @strip_loop:
001297r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
00129Ar 3  D5 04                        cmp 4,x                 ; LSB of xt
00129Cr 3  D0 07                        bne @next_entry
00129Er 3               
00129Er 3                               ; LSB is the same, test MSB
00129Er 3  B9 rr rr                     lda @strip_table+1,y
0012A1r 3  D5 05                        cmp 5,x
0012A3r 3  F0 0C                        beq @found_entry
0012A5r 3               
0012A5r 3                               ; MSB is not equal. Pretend though that we've come from LSB
0012A5r 3                               ; so we can use the next step for both cases
0012A5r 3               @next_entry:
0012A5r 3                               ; Not a word that needs stripping, so check next entry in table
0012A5r 3                               ; Let's see if we're done with the table (marked by zero entry)
0012A5r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
0012A8r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
0012ABr 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
0012ADr 3               
0012ADr 3  C8                           iny
0012AEr 3  C8                           iny
0012AFr 3  80 E6                        bra @strip_loop
0012B1r 3               @found_entry:
0012B1r 3                               ; This word is one of the ones that needs to have its size
0012B1r 3                               ; adjusted during native compile. We find the values in the
0012B1r 3                               ; next table with the same index, which is Y. However, Y is
0012B1r 3                               ; pointing to the MSB, so we need to go back to the LSB and
0012B1r 3                               ; halve the index before we can use it.
0012B1r 3  98                           tya
0012B2r 3  4A                           lsr
0012B3r 3  A8                           tay
0012B4r 3               
0012B4r 3                               ; Get the adjustment out of the size table. We were clever
0012B4r 3                               ; enough to make sure the cut on both ends of the code is
0012B4r 3                               ; is the same size.
0012B4r 3  B9 rr rr                     lda @strip_size,y
0012B7r 3  85 rr                        sta tmptos              ; save a copy
0012B9r 3               
0012B9r 3                               ; Adjust xt: Start later
0012B9r 3  18                           clc
0012BAr 3  75 04                        adc 4,x
0012BCr 3  95 04                        sta 4,x
0012BEr 3  90 02                        bcc @2
0012C0r 3  F6 05                        inc 5,x                 ; we just care about the carry
0012C2r 3               @2:
0012C2r 3               
0012C2r 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
0012C2r 3                               ; bottom of the code, we have to double the value
0012C2r 3  06 rr                        asl tmptos
0012C4r 3               
0012C4r 3  38                           sec
0012C5r 3  B5 00                        lda 0,x
0012C7r 3  E5 rr                        sbc tmptos
0012C9r 3  95 00                        sta 0,x
0012CBr 3  B0 02                        bcs @3
0012CDr 3  D6 01                        dec 1,x                 ; we just care about the borrow
0012CFr 3               @3:
0012CFr 3                               ; drop through to underflow check stripping
0012CFr 3               
0012CFr 3               @underflow_strip:
0012CFr 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
0012CFr 3               
0012CFr 3                               ; The user can choose to remove the unterflow testing in those
0012CFr 3                               ; words that have the UF flag. This shortens the word by
0012CFr 3                               ; 3 bytes if there is no underflow.
0012CFr 3               
0012CFr 3                               ; See if the user wants underflow stripping turned on
0012CFr 3  A5 rr                        lda uf_strip
0012D1r 3  05 rr                        ora uf_strip+1
0012D3r 3  F0 1C                        beq @specials_done
0012D5r 3               
0012D5r 3                               ; See if this word even contains underflow checking
0012D5r 3  A5 rr                        lda tmp3
0012D7r 3  29 10                        and #UF
0012D9r 3  F0 16                        beq @specials_done
0012DBr 3               
0012DBr 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
0012DBr 3                               ; long. Note hat PICK is a special case.
0012DBr 3               
0012DBr 3                               ; Adjust xt: Start later
0012DBr 3  18                           clc
0012DCr 3  B5 04                        lda 4,x
0012DEr 3  69 03                        adc #3
0012E0r 3  95 04                        sta 4,x
0012E2r 3  90 02                        bcc @4
0012E4r 3  F6 05                        inc 5,x                  ; we just care about the carry
0012E6r 3               @4:
0012E6r 3                               ; Adjust u: End earlier
0012E6r 3  38                           sec
0012E7r 3  B5 00                        lda 0,x
0012E9r 3  E9 03                        sbc #3
0012EBr 3  95 00                        sta 0,x
0012EDr 3  B0 02                        bcs @5
0012EFr 3  D6 01                        dec 1,x                  ; we just care about the borrow
0012F1r 3               @5:
0012F1r 3               
0012F1r 3                               ; --- END OF SPECIAL CASES ---
0012F1r 3               @specials_done:
0012F1r 3                               ; Store size of area to be copied for calculation of
0012F1r 3                               ; new CP. We have to do this after all of the special cases
0012F1r 3                               ; because they might change the size
0012F1r 3  B5 01                        lda 1,x                 ; MSB
0012F3r 3  48                           pha
0012F4r 3  B5 00                        lda 0,x                 ; LSB
0012F6r 3  48                           pha
0012F7r 3               
0012F7r 3                               ; Enough of this, let's move those bytes already! We have
0012F7r 3                               ; ( xt cp u ) on the stack at this point
0012F7r 3  20 rr rr                     jsr xt_move
0012FAr 3               
0012FAr 3                               ; Update CP
0012FAr 3  18                           clc
0012FBr 3  68                           pla                     ; LSB
0012FCr 3  65 rr                        adc cp
0012FEr 3  85 rr                        sta cp
001300r 3               
001300r 3  68                           pla                     ; MSB
001301r 3  65 rr                        adc cp+1
001303r 3  85 rr                        sta cp+1
001305r 3               
001305r 3  80 2C                        bra @done
001307r 3               
001307r 3               @strip_table:
001307r 3                              ; List of words we strip the Return Stack antics from
001307r 3                              ; during native compile, zero terminated. The index here
001307r 3                              ; must be the same as for the sizes
001307r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
00130Br 3  rr rr        
00130Dr 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
001311r 3  00 00        
001313r 3               
001313r 3               @strip_size:
001313r 3                               ; List of bytes to be stripped from the words that get their
001313r 3                               ; Return Stack antics removed during native compile. Index must
001313r 3                               ; be the same as for the xts. Zero terminated.
001313r 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
001317r 3  06 00        
001319r 3               
001319r 3               @compile_as_jump:
001319r 3                               ; Compile xt as a subroutine jump
001319r 3  A9 20                        lda #$20
00131Br 3  92 rr                        sta (cp)
00131Dr 3               
00131Dr 3  A0 01                        ldy #1
00131Fr 3  68                           pla             ; LSB
001320r 3  91 rr                        sta (cp),y
001322r 3  C8                           iny
001323r 3  68                           pla             ; MSB
001324r 3  91 rr                        sta (cp),y
001326r 3               
001326r 3                               ; allot space we just used
001326r 3  A9 03                        lda #3
001328r 3  18                           clc
001329r 3  65 rr                        adc cp
00132Br 3  85 rr                        sta cp
00132Dr 3  90 02                        bcc @6
00132Fr 3  E6 rr                        inc cp+1
001331r 3               @6:
001331r 3  E8                           inx             ; drop xt
001332r 3  E8                           inx
001333r 3               @done:
001333r 3               z_compile_comma:
001333r 3  60                           rts
001334r 3               
001334r 3               
001334r 3               
001334r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
001334r 3               ; ## "compile-only"  tested  Tali Forth
001334r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
001334r 3                       ; word.
001334r 3                       ;
001334r 3                       ; The alternative way to do this is to define a word
001334r 3                       ; ?COMPILE that makes sure  we're in compile mode
001334r 3                       ; """
001334r 3               
001334r 3               xt_compile_only:
001334r 3  20 rr rr                     jsr current_to_dp
001337r 3  A0 01                        ldy #1          ; offset for status byte
001339r 3  B1 rr                        lda (dp),y
00133Br 3  09 01                        ora #CO        ; make sure bit 7 is set
00133Dr 3  91 rr                        sta (dp),y
00133Fr 3               
00133Fr 3  60           z_compile_only: rts
001340r 3               
001340r 3               
001340r 3               
001340r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
001340r 3               ; ## "constant"  auto  ANS core
001340r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
001340r 3                       ;
001340r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
001340r 3                       ; more in assembler and let CREATE do the heavy lifting.
001340r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
001340r 3                       ; a primer on how this works in various Forths. This is the
001340r 3                       ; same code as VALUE in our case.
001340r 3                       ; """
001340r 3               xt_value:
001340r 3               xt_constant:
001340r 3  20 rr rr                     jsr underflow_1
001343r 3               
001343r 3  20 rr rr                     jsr xt_create
001346r 3               
001346r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
001346r 3                               ; but we want DOCONST for constants. Go back two bytes and
001346r 3                               ; replace the subroutine jump target
001346r 3  38                           sec
001347r 3  A5 rr                        lda cp
001349r 3  E9 02                        sbc #2
00134Br 3  85 rr                        sta tmp1
00134Dr 3  A5 rr                        lda cp+1
00134Fr 3  E9 00                        sbc #0
001351r 3  85 rr                        sta tmp1+1
001353r 3               
001353r 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
001355r 3  92 rr                        sta (tmp1)
001357r 3  A0 01                        ldy #1
001359r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
00135Br 3  91 rr                        sta (tmp1),y
00135Dr 3               
00135Dr 3                               ; Now we save the constant number itself in the next cell
00135Dr 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
001360r 3               
001360r 3               adjust_z:
001360r 3                               ; Now the length of the complete word (z_word) has increased by
001360r 3                               ; two. We need to update that number or else words such as SEE
001360r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
001360r 3                               ; VALUE and DEFER
001360r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
001363r 3               
001363r 3                               ; z_word is six bytes further down
001363r 3  B5 00                        lda 0,x
001365r 3  85 rr                        sta tmp1
001367r 3  B5 01                        lda 1,x
001369r 3  85 rr                        sta tmp1+1
00136Br 3               
00136Br 3  A0 06                        ldy #6
00136Dr 3  B1 rr                        lda (tmp1),y
00136Fr 3  18                           clc
001370r 3  69 02                        adc #2
001372r 3  91 rr                        sta (tmp1),y
001374r 3  C8                           iny
001375r 3  B1 rr                        lda (tmp1),y
001377r 3  69 00                        adc #0                  ; only need carry
001379r 3  91 rr                        sta (tmp1),y
00137Br 3               
00137Br 3  E8                           inx
00137Cr 3  E8                           inx
00137Dr 3               
00137Dr 3               z_value:
00137Dr 3  60           z_constant:     rts
00137Er 3               
00137Er 3               
00137Er 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
00137Er 3               ; ## "count"  auto  ANS core
00137Er 3                       ; """https://forth-standard.org/standard/core/COUNT
00137Er 3                       ; Convert old-style character string to address-length pair. Note
00137Er 3                       ; that the length of the string c-addr is stored in character length
00137Er 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
00137Er 3                       ; though COUNT can also be used to step through a string character by
00137Er 3                       ; character.
00137Er 3                       ; """
00137Er 3               xt_count:
00137Er 3  20 rr rr                     jsr underflow_1
001381r 3               
001381r 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
001383r 3  A8                           tay
001384r 3               
001384r 3                               ; move start address up by one
001384r 3  F6 00                        inc 0,x         ; LSB
001386r 3  D0 02                        bne @1
001388r 3  F6 01                        inc 1,x         ; MSB
00138Ar 3               
00138Ar 3                               ; save number of characters to stack
00138Ar 3               @1:
00138Ar 3  98                           tya
00138Br 3  CA                           dex
00138Cr 3  CA                           dex
00138Dr 3  95 00                        sta 0,x         ; LSB
00138Fr 3  74 01                        stz 1,x         ; MSB, always zero
001391r 3               
001391r 3  60           z_count:        rts
001392r 3               
001392r 3               
001392r 3               ; ## CR ( -- ) "Print a line feed"
001392r 3               ; ## "cr"  auto  ANS core
001392r 3                       ; """https://forth-standard.org/standard/core/CR"""
001392r 3               xt_cr:
001392r 3  A9 0A                        lda #AscLF
001394r 3  20 rr rr                     jsr emit_a
001397r 3  60           z_cr:           rts
001398r 3               
001398r 3               
001398r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
001398r 3               ; ## "create"  auto  ANS core
001398r 3                       ; """https://forth-standard.org/standard/core/CREATE
001398r 3                       ;
001398r 3                       ; See the drawing in headers.asm for details on the header
001398r 3                       ; """
001398r 3               
001398r 3               xt_create:
001398r 3                               ; get string
001398r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00139Br 3               
00139Br 3                               ; if we were given an empty string, we complain and quit
00139Br 3  B5 00                        lda 0,x
00139Dr 3  15 01                        ora 1,x
00139Fr 3  D0 05                        bne @got_name
0013A1r 3               
0013A1r 3  A9 05                        lda #err_noname
0013A3r 3  4C rr rr                     jmp error
0013A6r 3               
0013A6r 3               @got_name:
0013A6r 3                               ; Enforce maximal length of string by overwriting the MSB of
0013A6r 3                               ; the length. There is a possible error here: If the string
0013A6r 3                               ; is exactly 255 chars long, then a lot of the following
0013A6r 3                               ; additions will fail because of wrapping
0013A6r 3  74 01                        stz 1,x
0013A8r 3               
0013A8r 3                               ; Check to see if this name already exists.
0013A8r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
0013ABr 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
0013AEr 3               
0013AEr 3  B5 00                        lda 0,x
0013B0r 3  15 01                        ora 1,x
0013B2r 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
0013B4r 3               
0013B4r 3                               ; This name already exists.  See if we are supposed to print
0013B4r 3                               ; the message for it.
0013B4r 3  E8                           inx                     ; Drop flag (nt) from find-name.
0013B5r 3  E8                           inx
0013B6r 3               
0013B6r 3                               ; Check bit 7
0013B6r 3  24 rr                        bit status
0013B8r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
0013BAr 3               
0013BAr 3                               ; We aren't supposed to print the redefined message ourselves,
0013BAr 3                               ; but we should indicate that it is redefined (for ; to print
0013BAr 3                               ; later).
0013BAr 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
0013BCr 3  05 rr                        ora status
0013BEr 3  85 rr                        sta status
0013C0r 3  80 18                        bra @process_name
0013C2r 3               
0013C2r 3               @redefined_name:
0013C2r 3                               ; Print the message that the name is redefined.
0013C2r 3  A9 02                        lda #str_redefined
0013C4r 3  20 rr rr                     jsr print_string_no_lf
0013C7r 3               
0013C7r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
0013CAr 3  20 rr rr                     jsr xt_type
0013CDr 3  20 rr rr                     jsr xt_space
0013D0r 3               
0013D0r 3  80 08                        bra @process_name
0013D2r 3               
0013D2r 3               @new_name:
0013D2r 3  E8                           inx                     ; Drop flag (0) from find-name.
0013D3r 3  E8                           inx
0013D4r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
0013D6r 3  25 rr                        and status
0013D8r 3  85 rr                        sta status
0013DAr 3               
0013DAr 3               @process_name:
0013DAr 3  B5 00                        lda 0,x
0013DCr 3  85 rr                        sta tmp2                ; store length of string in tmp2
0013DEr 3               
0013DEr 3                               ; remember the first free byte of memory as the start of
0013DEr 3                               ; the new word
0013DEr 3  A5 rr                        lda cp
0013E0r 3  85 rr                        sta tmp1
0013E2r 3  A5 rr                        lda cp+1
0013E4r 3  85 rr                        sta tmp1+1
0013E6r 3               
0013E6r 3                               ; We need 8 bytes plus the length of the string for our new header.
0013E6r 3                               ; This is also the offset for the start of the code field (the
0013E6r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
0013E6r 3                               ; just allot the space afterwards
0013E6r 3  B5 00                        lda 0,x
0013E8r 3  18                           clc
0013E9r 3  69 08                        adc #8
0013EBr 3  85 rr                        sta tmp3                ; total header length
0013EDr 3               
0013EDr 3                               ; We need three more bytes for for the hardcoded code field
0013EDr 3                               ; area (CFA), the "payload" of the word which by default will
0013EDr 3                               ; be a subroutine jump to DOVAR
0013EDr 3  18                           clc
0013EEr 3  69 03                        adc #3
0013F0r 3               
0013F0r 3                               ; We overwrite the length of the string returned by PARSE-NAME
0013F0r 3                               ; and then call ALLOT
0013F0r 3  95 00                        sta 0,x
0013F2r 3  74 01                        stz 1,x         ; max header size is 255 chars
0013F4r 3  20 rr rr                     jsr xt_allot    ; ( addr )
0013F7r 3               
0013F7r 3                               ; Get the CURRENT dictionary pointer.
0013F7r 3  20 rr rr                     jsr current_to_dp
0013FAr 3               
0013FAr 3                               ; Now we walk through the header with Y as the index, adding
0013FAr 3                               ; information byte-by-byte
0013FAr 3  A0 00                        ldy #0
0013FCr 3               
0013FCr 3                               ; HEADER BYTE 0: Length of string
0013FCr 3  A5 rr                        lda tmp2
0013FEr 3  91 rr                        sta (tmp1),y
001400r 3               
001400r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
001400r 3                               ; to "never native", user will have to decide if they should
001400r 3                               ; be inlined
001400r 3  A9 08                        lda #NN
001402r 3               
001402r 3                               ; Also, words defined by CREATE are marked in the header has
001402r 3                               ; having a Code Field Area (CFA), which is a bit tricky for
001402r 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
001402r 3                               ; correctly with DOES> and CREATE. See the discussion at
001402r 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
001402r 3  09 20                        ora #HC
001404r 3  C8                           iny
001405r 3  91 rr                        sta (tmp1),y
001407r 3  C8                           iny
001408r 3               
001408r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
001408r 3                               ; in the Dictionary
001408r 3  A5 rr                        lda dp
00140Ar 3  91 rr                        sta (tmp1),y
00140Cr 3  C8                           iny
00140Dr 3  A5 rr                        lda dp+1
00140Fr 3  91 rr                        sta (tmp1),y
001411r 3  C8                           iny
001412r 3               
001412r 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
001412r 3  A5 rr                        lda tmp1+1
001414r 3  85 rr                        sta dp+1
001416r 3  A5 rr                        lda tmp1
001418r 3  85 rr                        sta dp
00141Ar 3               
00141Ar 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
00141Ar 3                               ; This begins after the header so we take the length of the
00141Ar 3                               ; header, which we cleverly saved in tmp3, and use it as an
00141Ar 3                               ; offset to the address of the start of the word. We come here
00141Ar 3                               ; with tmp1 in A
00141Ar 3  18                           clc
00141Br 3  65 rr                        adc tmp3        ; add total header length
00141Dr 3  91 rr                        sta (tmp1),y
00141Fr 3  48                           pha             ; we need this in the next step
001420r 3  C8                           iny
001421r 3               
001421r 3  A5 rr                        lda tmp1+1
001423r 3  69 00                        adc #0          ; only need the carry
001425r 3  91 rr                        sta (tmp1),y
001427r 3  C8                           iny
001428r 3               
001428r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
001428r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
001428r 3                               ; bytes down, and then one more byte so that the z_ label points
001428r 3                               ; to the (still fictional) RTS instruction for correct compilation
001428r 3  68                           pla             ; LSB of "z_" address
001429r 3  18                           clc
00142Ar 3  69 03                        adc #3
00142Cr 3  91 rr                        sta (tmp1),y
00142Er 3               
00142Er 3  88                           dey             ; get the MSB of xt back
00142Fr 3  B1 rr                        lda (tmp1),y
001431r 3  69 00                        adc #0          ; only need the carry
001433r 3  C8                           iny
001434r 3  C8                           iny
001435r 3  91 rr                        sta (tmp1),y
001437r 3  C8                           iny
001438r 3               
001438r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
001438r 3                               ; length in tmp2. We subtract 8 from the address so we can
001438r 3                               ; use the same loop index, which is already 8 byte ahead at
001438r 3                               ; this point
001438r 3  B5 00                        lda 0,x
00143Ar 3  38                           sec
00143Br 3  E9 08                        sbc #8
00143Dr 3  85 rr                        sta tmptos
00143Fr 3               
00143Fr 3  B5 01                        lda 1,x
001441r 3  E9 00                        sbc #0          ; only need carry
001443r 3  85 rr                        sta tmptos+1
001445r 3               
001445r 3               @name_loop:
001445r 3  B1 rr                        lda (tmptos),y
001447r 3               
001447r 3                               ; Make sure it goes into the dictionary in lower case.
001447r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001449r 3  B0 07                        bcs @store_name
00144Br 3  C9 41                        cmp #$41        ; ASCII 'A'
00144Dr 3  90 03                        bcc @store_name
00144Fr 3               
00144Fr 3                               ; An uppercase letter has been located. Make it
00144Fr 3                               ; lowercase.
00144Fr 3  18                           clc
001450r 3  69 20                        adc #$20
001452r 3               
001452r 3                               ; Fall into @store_name.
001452r 3               
001452r 3               @store_name:
001452r 3  91 rr                        sta (tmp1),y
001454r 3  C8                           iny
001455r 3  C6 rr                        dec tmp2
001457r 3  D0 EC                        bne @name_loop
001459r 3               
001459r 3                               ; After thename string comes the code field, starting at the
001459r 3                               ; current xt of this word, which is initially a jump to the
001459r 3                               ; subroutine to DOVAR. We code this jump by hand
001459r 3  A9 20                        lda #$20        ; opcode of JSR
00145Br 3  91 rr                        sta (tmp1),y
00145Dr 3  C8                           iny
00145Er 3  A9 rr                        lda #<dovar
001460r 3  91 rr                        sta (tmp1),y
001462r 3  C8                           iny
001463r 3  A9 rr                        lda #>dovar
001465r 3  91 rr                        sta (tmp1),y
001467r 3               
001467r 3                               ; Update the CURRENT wordlist with the new DP.
001467r 3                               ; We do this down here because this routine uses Y.
001467r 3  20 rr rr                     jsr dp_to_current
00146Ar 3               
00146Ar 3                               ; And we're done. Restore stack
00146Ar 3  E8                           inx
00146Br 3  E8                           inx
00146Cr 3               
00146Cr 3  60           z_create:       rts
00146Dr 3               
00146Dr 3               
00146Dr 3               
00146Dr 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
00146Dr 3               ; ## "d-"  auto  ANS double
00146Dr 3                       ; """https://forth-standard.org/standard/double/DMinus"""
00146Dr 3               
00146Dr 3               xt_d_minus:
00146Dr 3  20 rr rr                     jsr underflow_4 ; two double numbers
001470r 3               
001470r 3  38                           sec
001471r 3               
001471r 3  B5 06                        lda 6,x         ; LSB of lower word
001473r 3  F5 02                        sbc 2,x
001475r 3  95 06                        sta 6,x
001477r 3               
001477r 3  B5 07                        lda 7,x         ; MSB of lower word
001479r 3  F5 03                        sbc 3,x
00147Br 3  95 07                        sta 7,x
00147Dr 3               
00147Dr 3  B5 04                        lda 4,x         ; LSB of upper word
00147Fr 3  F5 00                        sbc 0,x
001481r 3  95 04                        sta 4,x
001483r 3               
001483r 3  B5 05                        lda 5,x         ; MSB of upper word
001485r 3  F5 01                        sbc 1,x
001487r 3  95 05                        sta 5,x
001489r 3               
001489r 3  E8                           inx
00148Ar 3  E8                           inx
00148Br 3  E8                           inx
00148Cr 3  E8                           inx
00148Dr 3               
00148Dr 3  60           z_d_minus:      rts
00148Er 3               
00148Er 3               
00148Er 3               
00148Er 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
00148Er 3               ; ## "d+"  auto  ANS double
00148Er 3                       ; """https://forth-standard.org/standard/double/DPlus"""
00148Er 3               
00148Er 3               xt_d_plus:
00148Er 3  20 rr rr                     jsr underflow_4 ; two double numbers
001491r 3               
001491r 3  18                           clc
001492r 3  B5 02                        lda 2,x         ; LSB of lower word
001494r 3  75 06                        adc 6,x
001496r 3  95 06                        sta 6,x
001498r 3               
001498r 3  B5 03                        lda 3,x         ; MSB of lower word
00149Ar 3  75 07                        adc 7,x
00149Cr 3  95 07                        sta 7,x
00149Er 3               
00149Er 3  B5 00                        lda 0,x         ; LSB of upper word
0014A0r 3  75 04                        adc 4,x
0014A2r 3  95 04                        sta 4,x
0014A4r 3               
0014A4r 3  B5 01                        lda 1,x         ; MSB of upper word
0014A6r 3  75 05                        adc 5,x
0014A8r 3  95 05                        sta 5,x
0014AAr 3               
0014AAr 3  E8                           inx
0014ABr 3  E8                           inx
0014ACr 3  E8                           inx
0014ADr 3  E8                           inx
0014AEr 3               
0014AEr 3  60           z_d_plus:       rts
0014AFr 3               
0014AFr 3               
0014AFr 3               
0014AFr 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
0014AFr 3               ; ## "d>s"  auto  ANS double
0014AFr 3                       ; """https://forth-standard.org/standard/double/DtoS
0014AFr 3                       ; Though this is basically just DROP, we keep it
0014AFr 3                       ; separate so we can test for underflow
0014AFr 3                       ; """
0014AFr 3               
0014AFr 3               xt_d_to_s:
0014AFr 3  20 rr rr                     jsr underflow_2
0014B2r 3               
0014B2r 3  E8                           inx
0014B3r 3  E8                           inx
0014B4r 3               
0014B4r 3  60           z_d_to_s:       rts
0014B5r 3               
0014B5r 3               
0014B5r 3               
0014B5r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
0014B5r 3               ; ## "dabs"  auto  ANS double
0014B5r 3                       ; """https://forth-standard.org/standard/double/DABS"""
0014B5r 3               
0014B5r 3               xt_dabs:
0014B5r 3  20 rr rr                     jsr underflow_2 ; double number
0014B8r 3               
0014B8r 3  B5 01                        lda 1,x         ; MSB of high cell
0014BAr 3  10 17                        bpl @done       ; positive, we get off light
0014BCr 3               
0014BCr 3                               ; negative, calculate 0 - d
0014BCr 3  A0 00                        ldy #0
0014BEr 3  38                           sec
0014BFr 3               
0014BFr 3  98                           tya
0014C0r 3  F5 02                        sbc 2,x         ; LSB of low cell
0014C2r 3  95 02                        sta 2,x
0014C4r 3               
0014C4r 3  98                           tya
0014C5r 3  F5 03                        sbc 3,x         ; MSB of low cell
0014C7r 3  95 03                        sta 3,x
0014C9r 3               
0014C9r 3  98                           tya
0014CAr 3  F5 00                        sbc 0,x         ; LSB of high cell
0014CCr 3  95 00                        sta 0,x
0014CEr 3               
0014CEr 3  98                           tya
0014CFr 3  F5 01                        sbc 1,x         ; MSB of high cell
0014D1r 3  95 01                        sta 1,x
0014D3r 3               @done:
0014D3r 3  60           z_dabs:         rts
0014D4r 3               
0014D4r 3               
0014D4r 3               
0014D4r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
0014D4r 3               ; ## "decimal"  auto  ANS core
0014D4r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
0014D4r 3               xt_decimal:
0014D4r 3  A9 0A                        lda #10
0014D6r 3  85 rr                        sta base
0014D8r 3  64 rr                        stz base+1              ; paranoid
0014DAr 3               
0014DAr 3  60           z_decimal:      rts
0014DBr 3               
0014DBr 3               
0014DBr 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
0014DBr 3               ; ## "defer"  auto  ANS core ext
0014DBr 3                       ; """https://forth-standard.org/standard/core/DEFER
0014DBr 3                       ; Reserve an name that can be linked to various xt by IS.
0014DBr 3                       ;
0014DBr 3                       ; The ANS reference implementation is
0014DBr 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
0014DBr 3                       ; But we use this routine as a low-level word so things go faster
0014DBr 3               
0014DBr 3               xt_defer:
0014DBr 3  20 rr rr                     jsr xt_create
0014DEr 3               
0014DEr 3                               ; CREATE by default installs a subroutine jump to DOVAR,
0014DEr 3                               ; but we actually want DODEFER this time. Go back two
0014DEr 3                               ; bytes and repace the subroutine jump target
0014DEr 3  A5 rr                        lda cp          ; LSB
0014E0r 3  38                           sec
0014E1r 3  E9 02                        sbc #2
0014E3r 3  85 rr                        sta tmp1
0014E5r 3               
0014E5r 3  A5 rr                        lda cp+1        ; MSB
0014E7r 3  E9 00                        sbc #0          ; we only care about the borrow
0014E9r 3  85 rr                        sta tmp1+1
0014EBr 3               
0014EBr 3                               ; Save the target address
0014EBr 3  A0 00                        ldy #0
0014EDr 3  A9 rr                        lda #<dodefer   ; LSB
0014EFr 3  91 rr                        sta (tmp1),y
0014F1r 3  C8                           iny
0014F2r 3  A9 rr                        lda #>dodefer   ; MSB
0014F4r 3  91 rr                        sta (tmp1),y
0014F6r 3               
0014F6r 3               
0014F6r 3                               ; DODEFER executes the next address it finds after
0014F6r 3                               ; its call. As default, we include the error
0014F6r 3                               ; "Defer not defined"
0014F6r 3  A9 rr                        lda #<defer_error
0014F8r 3  92 rr                        sta (cp)
0014FAr 3  E6 rr                        inc cp
0014FCr 3  D0 02                        bne @1
0014FEr 3  E6 rr                        inc cp+1
001500r 3               @1:
001500r 3  A9 rr                        lda #>defer_error
001502r 3  92 rr                        sta (cp)
001504r 3  E6 rr                        inc cp
001506r 3  D0 02                        bne @2
001508r 3  E6 rr                        inc cp+1
00150Ar 3               @2:
00150Ar 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
00150Dr 3               
00150Dr 3  60           z_defer:        rts
00150Er 3               
00150Er 3               
00150Er 3               
00150Er 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
00150Er 3               ; ## "defer@"  auto  ANS core ext
00150Er 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
00150Er 3               
00150Er 3               xt_defer_fetch:
00150Er 3                               ; No underflow checking as >BODY does it.
00150Er 3  20 rr rr                     jsr xt_to_body
001511r 3  20 rr rr                     jsr xt_fetch
001514r 3  60           z_defer_fetch:  rts
001515r 3               
001515r 3               
001515r 3               
001515r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
001515r 3               ; ## "defer!"  auto  ANS core ext
001515r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
001515r 3               
001515r 3               xt_defer_store:
001515r 3                               ; No underflow checking as >BODY and ! do it.
001515r 3  20 rr rr                     jsr xt_to_body
001518r 3  20 rr rr                     jsr xt_store
00151Br 3  60           z_defer_store:  rts
00151Cr 3               
00151Cr 3               
00151Cr 3               
00151Cr 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
00151Cr 3               ; ## "definitions" auto ANS search
00151Cr 3               xt_definitions:
00151Cr 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
00151Er 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
001520r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
001522r 3  91 rr                        sta (up),y
001524r 3  60           z_definitions:  rts
001525r 3               
001525r 3               
001525r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
001525r 3               ; ## "depth"  auto  ANS core
001525r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
001525r 3               xt_depth:
001525r 3  A9 FF                        lda #dsp0
001527r 3  86 rr                        stx tmpdsp
001529r 3  38                           sec
00152Ar 3  E5 rr                        sbc tmpdsp
00152Cr 3               
00152Cr 3                               ; divide by two because each cell is two bytes
00152Cr 3  4A                           lsr
00152Dr 3               
00152Dr 3  CA                           dex
00152Er 3  CA                           dex
00152Fr 3  95 00                        sta 0,x
001531r 3  74 01                        stz 1,x
001533r 3               
001533r 3  60           z_depth:        rts
001534r 3               
001534r 3               
001534r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
001534r 3               ; ## "digit?"  auto  Tali Forth
001534r 3                       ; """Inspired by the pForth instruction DIGIT, see
001534r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001534r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
001534r 3                       ; pForth, we get the base (radix) ourselves instead of having the
001534r 3                       ; user provide it. There is no standard name for this routine, which
001534r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
001534r 3                       ; """
001534r 3               
001534r 3               xt_digit_question:
001534r 3  20 rr rr                     jsr underflow_1
001537r 3               
001537r 3                               ; one way or another, we're going to need room for the
001537r 3                               ; flag on the stack
001537r 3  CA                           dex
001538r 3  CA                           dex
001539r 3  74 00                        stz 0,x                 ; default flag is failure
00153Br 3  74 01                        stz 1,x
00153Dr 3  74 03                        stz 3,x                 ; paranoid
00153Fr 3               
00153Fr 3                               ; Check the character, now in the LSB of NOS. First, make
00153Fr 3                               ; sure we're not below the ASCII code for "0"
00153Fr 3  B5 02                        lda 2,x
001541r 3  C9 30                        cmp #'0'
001543r 3  90 23                        bcc @done               ; failure flag already set
001545r 3               
001545r 3                               ; Next, see if we are below "9", because that would make
001545r 3                               ; this a normal number
001545r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
001547r 3  90 12                        bcc @checkbase
001549r 3               
001549r 3                               ; Well, then let's see if this is the gap between "9" and "A"
001549r 3                               ; so we can treat the whole range as a number
001549r 3  C9 41                        cmp #'A'
00154Br 3  90 1B                        bcc @done               ; failure flag is already set
00154Dr 3               
00154Dr 3                               ; probably a letter, so we make sure it is uppercase
00154Dr 3  C9 61                        cmp #'a'
00154Fr 3  90 07                        bcc @case_done          ; not lower case, too low
001551r 3  C9 7B                        cmp #'z'+1
001553r 3  B0 03                        bcs @case_done          ; not lower case, too high
001555r 3               
001555r 3  18                           clc                     ; just right
001556r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
001558r 3               
001558r 3               @case_done:
001558r 3                               ; get rid of the gap between "9" and "A" so we can treat
001558r 3                               ; the whole range as one number
001558r 3  38                           sec
001559r 3  E9 07                        sbc #7                  ; fall through to @checkbase
00155Br 3               
00155Br 3               @checkbase:
00155Br 3                               ; we have a number, now see if it falls inside the range
00155Br 3                               ; provided by BASE
00155Br 3  38                           sec
00155Cr 3  E9 30                        sbc #'0'                 ; this is also the conversion step
00155Er 3  C5 rr                        cmp base
001560r 3  B0 06                        bcs @done               ; already have false flag
001562r 3               
001562r 3                               ; Found a legal number
001562r 3  95 02                        sta 2,x                 ; put number in NOS
001564r 3  D6 00                        dec 0,x                 ; set success flag
001566r 3  D6 01                        dec 1,x
001568r 3               
001568r 3               @done:
001568r 3               z_digit_question:
001568r 3  60                           rts
001569r 3               
001569r 3               
001569r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
001569r 3               ; ## "disasm"  tested  Tali Forth
001569r 3                       ; """Convert a segment of memory to assembler output. This
001569r 3                       ; word is vectored so people can add their own disassembler.
001569r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
001569r 3                       ; code, see the section on The Disassembler in the manual and
001569r 3                       ; the file disassembler.asm for more details.
001569r 3                       ; """
001569r 3               xt_disasm:
001569r 3  20 rr rr                     jsr underflow_2
00156Cr 3                           .ifdef disassembler
00156Cr 3                               jsr disassembler
00156Cr 3                           .endif
00156Cr 3               
00156Cr 3  60           z_disasm:       rts
00156Dr 3               
00156Dr 3               
00156Dr 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
00156Dr 3               ; ## "dnegate"  auto  ANS double
00156Dr 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
00156Dr 3               xt_dnegate:
00156Dr 3  20 rr rr                     jsr underflow_2 ; double number
001570r 3               
001570r 3  A0 00             		ldy #0
001572r 3  38                           sec
001573r 3               
001573r 3  98                           tya
001574r 3  F5 02                        sbc 2,x         ; LSB of low cell
001576r 3  95 02                        sta 2,x
001578r 3               
001578r 3  98                           tya
001579r 3  F5 03                        sbc 3,x         ; MSB of low cell
00157Br 3  95 03                        sta 3,x
00157Dr 3               
00157Dr 3  98                           tya
00157Er 3  F5 00                        sbc 0,x         ; LSB of high cell
001580r 3  95 00                        sta 0,x
001582r 3               
001582r 3  98                           tya
001583r 3  F5 01                        sbc 1,x         ; MSB of high cell
001585r 3  95 01                        sta 1,x
001587r 3               
001587r 3  60           z_dnegate:      rts
001588r 3               
001588r 3               
001588r 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
001588r 3               ; ## "?do"  auto  ANS core ext
001588r 3                       ; """https://forth-standard.org/standard/core/qDO"""
001588r 3               xt_question_do:
001588r 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
001588r 3                               ; to mark which is which
001588r 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
00158Ar 3  85 rr                        sta tmp1
00158Cr 3  80 02                        bra do_common           ; skip flag for DO
00158Er 3               
00158Er 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
00158Er 3               ; ## "do"  auto  ANS core
00158Er 3                       ; """https://forth-standard.org/standard/core/DO
00158Er 3                       ;
00158Er 3                       ; Compile-time part of DO. Could be realized in Forth as
00158Er 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
00158Er 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
00158Er 3                       ; a routine that pushes the end address to the Return Stack at run
00158Er 3                       ; time. This is based on a suggestion by Garth Wilson, see
00158Er 3                       ; the Control Flow section of the manual for details.
00158Er 3                       ;
00158Er 3                       ; This may not be native compile. Don't check for a stack underflow
00158Er 3                       ; """
00158Er 3               
00158Er 3               xt_do:
00158Er 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
00158Er 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
001590r 3               do_common:
001590r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
001590r 3                               ; compile the address we need to LDA at runtime
001590r 3  CA                           dex
001591r 3  CA                           dex
001592r 3  A5 rr                        lda cp
001594r 3  95 00                        sta 0,x                 ; LSB
001596r 3  A5 rr                        lda cp+1
001598r 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
00159Ar 3               
00159Ar 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
00159Ar 3                               ; replace by the actual LDA/PHA instructions
00159Ar 3  A9 05                        lda #5                  ; we don't really care about the value,
00159Cr 3  A8                           tay                     ; so we use 5 to be tricky
00159Dr 3               @loop:
00159Dr 3  91 rr                        sta (cp),y
00159Fr 3  88                           dey
0015A0r 3  10 FB                        bpl @loop
0015A2r 3               
0015A2r 3                               ; update CP
0015A2r 3  1A                           inc             ; we used 5 as a dummy value, this is why
0015A3r 3  18                           clc
0015A4r 3  65 rr                        adc cp
0015A6r 3  85 rr                        sta cp
0015A8r 3  90 02                        bcc @1
0015AAr 3  E6 rr                        inc cp+1
0015ACr 3               @1:
0015ACr 3                               ; compile the (?DO) portion of ?DO if appropriate
0015ACr 3  A5 rr                        lda tmp1
0015AEr 3  F0 17                        beq @compile_do
0015B0r 3               
0015B0r 3                               ; We came from ?DO, so compile its runtime first. We do
0015B0r 3                               ; this with a quick loop because we know it has to be
0015B0r 3                               ; Always Native anyway
0015B0r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
0015B2r 3  5A                           phy             ; save counter to calculate new CP
0015B3r 3               @2:
0015B3r 3  B9 rr rr                     lda question_do_runtime,y
0015B6r 3  91 rr                        sta (cp),y
0015B8r 3  88                           dey
0015B9r 3  10 F8                        bpl @2
0015BBr 3               
0015BBr 3                               ; adjust CP
0015BBr 3  68                           pla             ; retrieve counter
0015BCr 3  18                           clc
0015BDr 3  65 rr                        adc cp
0015BFr 3  85 rr                        sta cp
0015C1r 3  A5 rr                        lda cp+1
0015C3r 3  69 00                        adc #0          ; only care about carry
0015C5r 3  85 rr                        sta cp+1        ; fall through to @compile_do
0015C7r 3               
0015C7r 3               @compile_do:
0015C7r 3                               ; compile runtime part of DO.
0015C7r 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
0015C9r 3  5A                           phy             ; save counter to calculate new CP
0015CAr 3               @3:
0015CAr 3  B9 rr rr                     lda do_runtime,y
0015CDr 3  91 rr                        sta (cp),y
0015CFr 3  88                           dey
0015D0r 3  10 F8                        bpl @3
0015D2r 3               
0015D2r 3                               ; adjust CP
0015D2r 3  68                           pla             ; retrieve counter
0015D3r 3  18                           clc
0015D4r 3  65 rr                        adc cp
0015D6r 3  85 rr                        sta cp
0015D8r 3  A5 rr                        lda cp+1
0015DAr 3  69 00                        adc #0          ; only care about carry
0015DCr 3  85 rr                        sta cp+1
0015DEr 3               
0015DEr 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
0015DEr 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
0015DEr 3                               ; do with the HERE we're saving for LEAVE
0015DEr 3  CA                           dex
0015DFr 3  CA                           dex
0015E0r 3  A5 rr                        lda cp          ; LSB
0015E2r 3  95 00                        sta 0,x
0015E4r 3  A5 rr                        lda cp+1        ; MSB
0015E6r 3  95 01                        sta 1,x
0015E8r 3               z_question_do:
0015E8r 3  60           z_do:           rts
0015E9r 3               
0015E9r 3               
0015E9r 3               do_runtime:
0015E9r 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
0015E9r 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
0015E9r 3                       ; the FIG Forth loop (you can see which version you have by running
0015E9r 3                       ; a loop with start and limit as the same value, for instance
0015E9r 3                       ; 0 0 DO -- these will walk through the number space). We use a
0015E9r 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
0015E9r 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
0015E9r 3                       ; for further discussion of this. The source given there for
0015E9r 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
0015E9r 3                       ; in some Forths. Usually, we would define this as a separate word
0015E9r 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
0015E9r 3                       ; However, we can do it faster if we just copy the bytes
0015E9r 3                       ; of this routine with a simple loop in DO.
0015E9r 3                       ; """
0015E9r 3                               ; First step: create fudge factor (FUFA) by subtracting the
0015E9r 3                               ; limit from $8000, the number that will trip the overflow
0015E9r 3                               ; flag
0015E9r 3  38                           sec
0015EAr 3  A9 00                        lda #0
0015ECr 3  F5 02                        sbc 2,x         ; LSB of limit
0015EEr 3  95 02                        sta 2,x         ; save FUFA for later use
0015F0r 3               
0015F0r 3  A9 80                        lda #$80
0015F2r 3  F5 03                        sbc 3,x         ; MSB of limit
0015F4r 3  95 03                        sta 3,x         ; save FUFA for later use
0015F6r 3  48                           pha             ; FUFA replaces limit on R stack
0015F7r 3  B5 02                        lda 2,x         ; LSB of limit
0015F9r 3  48                           pha
0015FAr 3               
0015FAr 3                               ; Second step: index is FUFA plus original index
0015FAr 3  18                           clc
0015FBr 3  B5 00                        lda 0,x         ; LSB of original index
0015FDr 3  75 02                        adc 2,x         ; add LSB of FUFA
0015FFr 3  95 00                        sta 0,x
001601r 3  B5 01                        lda 1,x         ; MSB of orginal index
001603r 3  75 03                        adc 3,x         ; add MSB of FUFA
001605r 3  48                           pha
001606r 3  B5 00                        lda 0,x         ; LSB of index
001608r 3  48                           pha
001609r 3               
001609r 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
001609r 3                               ; use it later. Clean the Data Stack
001609r 3  E8                           inx
00160Ar 3  E8                           inx
00160Br 3  E8                           inx
00160Cr 3  E8                           inx             ; no RTS because this is copied into code
00160Dr 3               do_runtime_end:
00160Dr 3               
00160Dr 3               question_do_runtime:
00160Dr 3               
00160Dr 3                       ; """This is called (?DO) in some Forths. See the explanation at
00160Dr 3                       ; do_runtime for the background on this design
00160Dr 3                       ; """
00160Dr 3                               ; see if TOS and NOS are equal. Change this to assembler
00160Dr 3                               ; for speed
00160Dr 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
001610r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
001613r 3               
001613r 3  B5 00                        lda 0,x
001615r 3  15 01                        ora 1,x
001617r 3  F0 06                        beq @do_do
001619r 3               
001619r 3                               ; We're equal, so dump everything and jump beyond the loop.
001619r 3                               ; But first, dump six entries off of the Data Stack
001619r 3  8A                           txa
00161Ar 3  18                           clc
00161Br 3  69 06                        adc #6
00161Dr 3  AA                           tax
00161Er 3               
00161Er 3                               ; Then abort the whole loop
00161Er 3  60                           rts
00161Fr 3               @do_do:
00161Fr 3  E8                           inx             ; clear flag from EQUAL off stack
001620r 3  E8                           inx             ; no RTS because this is copied into code
001621r 3               question_do_runtime_end:
001621r 3               
001621r 3               
001621r 3               
001621r 3               ; ## DOES ( -- ) "Add payload when defining new words"
001621r 3               ; ## "does>"  auto  ANS core
001621r 3                       ; """https://forth-standard.org/standard/core/DOES
001621r 3                       ; Create the payload for defining new defining words. See
001621r 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
001621r 3                       ; the Developer Guide in the manual for a discussion of
001621r 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
001621r 3                       ; """
001621r 3               
001621r 3               xt_does:
001621r 3                               ; compile a subroutine jump to runtime of DOES>
001621r 3  A0 rr                        ldy #>does_runtime
001623r 3  A9 rr                        lda #<does_runtime
001625r 3  20 rr rr                     jsr cmpl_subroutine
001628r 3               
001628r 3                               ; compile a subroutine jump to DODOES. In traditional
001628r 3                               ; terms, this is the Code Field Area (CFA) of the new
001628r 3                               ; word
001628r 3  A0 rr                        ldy #>dodoes
00162Ar 3  A9 rr                        lda #<dodoes
00162Cr 3  20 rr rr                     jsr cmpl_subroutine
00162Fr 3               
00162Fr 3  60           z_does:         rts
001630r 3               
001630r 3               
001630r 3               does_runtime:
001630r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
001630r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
001630r 3                       ; address that contains a subroutine jump to DODOES. We don't
001630r 3                       ; jump to DODOES directly because we need to work our magic with
001630r 3                       ; the return addresses. This routine is also known as "(DOES)" in
001630r 3                       ; other Forths
001630r 3                       ; """
001630r 3               
001630r 3  7A                           ply             ; LSB
001631r 3  68                           pla             ; MSB
001632r 3               
001632r 3  C8                           iny
001633r 3  D0 01                        bne @1
001635r 3  1A                           inc
001636r 3               @1:
001636r 3  84 rr                        sty tmp1
001638r 3  85 rr                        sta tmp1+1
00163Ar 3               
00163Ar 3                               ; CREATE has also already modified the DP to point to the new
00163Ar 3                               ; word. We have no idea which instructions followed the CREATE
00163Ar 3                               ; command if there is a DOES> so the CP could point anywhere
00163Ar 3                               ; by now. The address of the word's xt is four bytes down.
00163Ar 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
00163Dr 3  A5 rr                        lda dp
00163Fr 3  18                           clc
001640r 3  69 04                        adc #4
001642r 3  85 rr                        sta tmp2
001644r 3  A5 rr                        lda dp+1
001646r 3  69 00                        adc #0          ; we only care about the carry
001648r 3  85 rr                        sta tmp2+1
00164Ar 3               
00164Ar 3                               ; Now we get that address and add one byte to skip over the JSR
00164Ar 3                               ; opcode
00164Ar 3  B2 rr                        lda (tmp2)
00164Cr 3  18                           clc
00164Dr 3  69 01                        adc #1
00164Fr 3  85 rr                        sta tmp3
001651r 3  A0 01                        ldy #1
001653r 3  B1 rr                        lda (tmp2),y
001655r 3  69 00                        adc #0          ; we only care about the carry
001657r 3  85 rr                        sta tmp3+1
001659r 3               
001659r 3                               ; Replace the DOVAR address with our own
001659r 3  A5 rr                        lda tmp1        ; LSB
00165Br 3  92 rr                        sta (tmp3)
00165Dr 3  A5 rr                        lda tmp1+1
00165Fr 3  91 rr                        sta (tmp3),y    ; Y is still 1
001661r 3               
001661r 3                               ; Since we removed the return address that brought us here, we
001661r 3                               ; go back to whatever the main routine was. Otherwise, we we
001661r 3                               ; smash into the subroutine jump to DODOES.
001661r 3  60                           rts
001662r 3               
001662r 3               
001662r 3               
001662r 3               ; ## DOT ( u -- ) "Print TOS"
001662r 3               ; ## "."  auto  ANS core
001662r 3                       ; """https://forth-standard.org/standard/core/d"""
001662r 3               
001662r 3               xt_dot:
001662r 3  20 rr rr                     jsr underflow_1
001665r 3               
001665r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
001668r 3  20 rr rr                     jsr xt_abs                      ; ( n u )
00166Br 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
00166Er 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
001671r 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
001674r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
001677r 3  20 rr rr                     jsr xt_sign                     ; ( ud )
00167Ar 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
00167Dr 3  20 rr rr                     jsr xt_type
001680r 3  20 rr rr                     jsr xt_space
001683r 3               
001683r 3  60           z_dot:          rts
001684r 3               
001684r 3               
001684r 3               
001684r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
001684r 3               ; ## ".("  auto  ANS core
001684r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
001684r 3               
001684r 3               xt_dot_paren:
001684r 3                               ; Put a right paren on the stack.
001684r 3  CA                           dex
001685r 3  CA                           dex
001686r 3  A9 29                        lda #41     ; Right parenthesis
001688r 3  95 00                        sta 0,x
00168Ar 3  74 01                        stz 1,x
00168Cr 3               
00168Cr 3  20 rr rr                     jsr xt_parse
00168Fr 3  20 rr rr                     jsr xt_type
001692r 3               
001692r 3  60           z_dot_paren:    rts
001693r 3               
001693r 3               
001693r 3               
001693r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
001693r 3               ; ## ".""  auto  ANS core ext
001693r 3                       ; """https://forth-standard.org/standard/core/Dotq
001693r 3                       ; Compile string that is printed during run time. ANS Forth wants
001693r 3                       ; this to be compile-only, even though everybody and their friend
001693r 3                       ; uses it for everything. We follow the book here, and recommend
001693r 3                       ; `.(` for general printing.
001693r 3                       ; """
001693r 3               
001693r 3               xt_dot_quote:
001693r 3                               ; we let S" do the heavy lifting. Since we're in
001693r 3                               ; compile mode, it will save the string and reproduce it
001693r 3                               ; during runtime
001693r 3  20 rr rr                     jsr xt_s_quote
001696r 3               
001696r 3                               ; We then let TYPE do the actual printing
001696r 3  A0 rr                        ldy #>xt_type
001698r 3  A9 rr                        lda #<xt_type
00169Ar 3  20 rr rr                     jsr cmpl_subroutine
00169Dr 3               
00169Dr 3  60           z_dot_quote:    rts
00169Er 3               
00169Er 3               
00169Er 3               
00169Er 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
00169Er 3               ; ## ".r"  tested  ANS core ext
00169Er 3                       ; """https://forth-standard.org/standard/core/DotR
00169Er 3                       ;
00169Er 3                       ; Based on the Forth code
00169Er 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
00169Er 3                       ; """
00169Er 3               
00169Er 3               xt_dot_r:
00169Er 3  20 rr rr                     jsr underflow_2
0016A1r 3               
0016A1r 3  20 rr rr                     jsr xt_to_r
0016A4r 3  20 rr rr                     jsr xt_dup
0016A7r 3  20 rr rr                     jsr xt_abs
0016AAr 3  20 rr rr                     jsr xt_zero
0016ADr 3  20 rr rr                     jsr xt_less_number_sign
0016B0r 3  20 rr rr                     jsr xt_number_sign_s
0016B3r 3  20 rr rr                     jsr xt_rot
0016B6r 3  20 rr rr                     jsr xt_sign
0016B9r 3  20 rr rr                     jsr xt_number_sign_greater
0016BCr 3  20 rr rr                     jsr xt_r_from
0016BFr 3  20 rr rr                     jsr xt_over
0016C2r 3  20 rr rr                     jsr xt_minus
0016C5r 3  20 rr rr                     jsr xt_spaces
0016C8r 3  20 rr rr                     jsr xt_type
0016CBr 3               
0016CBr 3  60           z_dot_r:        rts
0016CCr 3               
0016CCr 3               
0016CCr 3               
0016CCr 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
0016CCr 3               ; ## ".s"  tested  ANS tools
0016CCr 3                       ; """https://forth-standard.org/standard/tools/DotS
0016CCr 3                       ; Print content of Data Stack non-distructively. We follow the format
0016CCr 3                       ; of Gforth and print the number of elements first in brackets,
0016CCr 3                       ; followed by the Data Stack content (if any).
0016CCr 3                       ;
0016CCr 3                       ; Since this is for humans, we don't have to worry about speed.
0016CCr 3                       ; """
0016CCr 3               
0016CCr 3               xt_dot_s:
0016CCr 3  20 rr rr                     jsr xt_depth    ; ( -- u )
0016CFr 3               
0016CFr 3                               ; Print stack depth in brackets
0016CFr 3  A9 3C                        lda #$3c        ; ASCII for "<"
0016D1r 3  20 rr rr                     jsr emit_a
0016D4r 3               
0016D4r 3                               ; We keep a copy of the number of the things on the stack
0016D4r 3                               ; to use as a counter later down. This assumes that there
0016D4r 3                               ; are less than 255 elements on the stack
0016D4r 3  B5 00                        lda 0,x
0016D6r 3  48                           pha
0016D7r 3               
0016D7r 3                               ; print unsigned number without the trailing space
0016D7r 3  CA                           dex             ; DUP
0016D8r 3  CA                           dex
0016D9r 3  95 00                        sta 0,x
0016DBr 3  74 01                        stz 1,x
0016DDr 3               
0016DDr 3  20 rr rr                     jsr print_u
0016E0r 3               
0016E0r 3  A9 3E                        lda #$3e        ; ASCII for ">"
0016E2r 3  20 rr rr                     jsr emit_a
0016E5r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
0016E7r 3  20 rr rr                     jsr emit_a
0016EAr 3               
0016EAr 3  E8                           inx
0016EBr 3  E8                           inx
0016ECr 3               
0016ECr 3                               ; There will be lots of cases where the stack is empty. If that
0016ECr 3                               ; is so, get out of here quickly
0016ECr 3  E0 FF                        cpx #dsp0
0016EEr 3  F0 1E                        beq @done
0016F0r 3               
0016F0r 3               @have_stack:
0016F0r 3                               ; We have at least one element on the stack. The depth of the
0016F0r 3                               ; stack is on the stack, we can use it as a counter. We go
0016F0r 3                               ; from bottom to top
0016F0r 3  7A                           ply
0016F1r 3               
0016F1r 3  A9 FE                        lda #dsp0-1     ; go up one to avoid garbage
0016F3r 3  85 rr                        sta tmp3
0016F5r 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
0016F7r 3               @loop:
0016F7r 3  CA                           dex
0016F8r 3  CA                           dex
0016F9r 3               
0016F9r 3  B2 rr                        lda (tmp3)
0016FBr 3  95 01                        sta 1,x
0016FDr 3  C6 rr                        dec tmp3
0016FFr 3               
0016FFr 3  B2 rr                        lda (tmp3)
001701r 3  95 00                        sta 0,x
001703r 3  C6 rr                        dec tmp3
001705r 3  5A                           phy
001706r 3               
001706r 3  20 rr rr                     jsr xt_dot
001709r 3               
001709r 3  7A                           ply
00170Ar 3  88                           dey
00170Br 3  D0 EA                        bne @loop
00170Dr 3               
00170Dr 3  48                           pha             ; dummy to balance stack
00170Er 3               @done:
00170Er 3  68                           pla
00170Fr 3  60           z_dot_s:        rts
001710r 3               
001710r 3               
001710r 3               
001710r 3               ; ## D_DOT ( d -- ) "Print double"
001710r 3               ; ## "d."  tested  ANS double
001710r 3                       ; """http://forth-standard.org/standard/double/Dd"""
001710r 3                       ;
001710r 3                       ; From the Forth code:
001710r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
001710r 3                       ; """
001710r 3               
001710r 3               xt_d_dot:
001710r 3  20 rr rr                     jsr underflow_2
001713r 3               
001713r 3  20 rr rr                     jsr xt_tuck
001716r 3  20 rr rr                     jsr xt_dabs
001719r 3  20 rr rr                     jsr xt_less_number_sign
00171Cr 3  20 rr rr                     jsr xt_number_sign_s
00171Fr 3  20 rr rr                     jsr xt_rot
001722r 3  20 rr rr                     jsr xt_sign
001725r 3  20 rr rr                     jsr xt_number_sign_greater
001728r 3  20 rr rr                     jsr xt_type
00172Br 3  20 rr rr                     jsr xt_space
00172Er 3               
00172Er 3  60           z_d_dot:        rts
00172Fr 3               
00172Fr 3               
00172Fr 3               
00172Fr 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
00172Fr 3               ; ## "d.r"  tested  ANS double
00172Fr 3                       ; """http://forth-standard.org/standard/double/DDotR"""
00172Fr 3                       ; Based on the Forth code
00172Fr 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
00172Fr 3                       ; """
00172Fr 3               
00172Fr 3               xt_d_dot_r:
00172Fr 3  20 rr rr                     jsr underflow_3
001732r 3                               ; From the forth code:
001732r 3  20 rr rr                     jsr xt_to_r
001735r 3  20 rr rr                     jsr xt_tuck
001738r 3  20 rr rr                     jsr xt_dabs
00173Br 3  20 rr rr                     jsr xt_less_number_sign
00173Er 3  20 rr rr                     jsr xt_number_sign_s
001741r 3  20 rr rr                     jsr xt_rot
001744r 3  20 rr rr                     jsr xt_sign
001747r 3  20 rr rr                     jsr xt_number_sign_greater
00174Ar 3  20 rr rr                     jsr xt_r_from
00174Dr 3  20 rr rr                     jsr xt_over
001750r 3  20 rr rr                     jsr xt_minus
001753r 3  20 rr rr                     jsr xt_spaces
001756r 3  20 rr rr                     jsr xt_type
001759r 3               
001759r 3  60           z_d_dot_r:      rts
00175Ar 3               
00175Ar 3               
00175Ar 3               
00175Ar 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
00175Ar 3               ; ## "drop"  auto  ANS core
00175Ar 3                       ; """https://forth-standard.org/standard/core/DROP"""
00175Ar 3               xt_drop:
00175Ar 3  20 rr rr                     jsr underflow_1
00175Dr 3               
00175Dr 3  E8                           inx
00175Er 3  E8                           inx
00175Fr 3               
00175Fr 3  60           z_drop:         rts
001760r 3               
001760r 3               
001760r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
001760r 3               ; ## "dump"  tested  ANS tools
001760r 3                       ; """https://forth-standard.org/standard/tools/DUMP
001760r 3                       ;
001760r 3                       ; DUMP's exact output is defined as "implementation dependent".
001760r 3                       ; This is in assembler because it is
001760r 3                       ; useful for testing and development, so we want to have it work
001760r 3                       ; as soon as possible. Uses TMP2
001760r 3                       ; """
001760r 3               
001760r 3               xt_dump:
001760r 3  20 rr rr                     jsr underflow_2
001763r 3               @row:
001763r 3                               ; start counter for 16 numbers per row
001763r 3  A0 10                        ldy #16
001765r 3               
001765r 3                               ; We use TMP2 as the index for the ASCII characters
001765r 3                               ; that we print at the and of the hex block. We
001765r 3                               ; start saving them at HERE (CP)
001765r 3  64 rr                        stz tmp2
001767r 3               
001767r 3  20 rr rr                     jsr xt_cr
00176Ar 3               
00176Ar 3                               ; print address number
00176Ar 3  B5 03                        lda 3,x
00176Cr 3  20 rr rr                     jsr byte_to_ascii
00176Fr 3  B5 02                        lda 2,x
001771r 3  20 rr rr                     jsr byte_to_ascii
001774r 3               
001774r 3  20 rr rr                     jsr xt_space
001777r 3  20 rr rr                     jsr xt_space
00177Ar 3               @loop:
00177Ar 3                               ; if there are zero bytes left to display, we're done
00177Ar 3  B5 00                        lda 0,x
00177Cr 3  15 01                        ora 1,x
00177Er 3  F0 39                        beq @all_printed
001780r 3               
001780r 3                               ; dump the contents
001780r 3  A1 02                        lda (2,x)
001782r 3  48                           pha                     ; byte_to_ascii destroys A
001783r 3  20 rr rr                     jsr byte_to_ascii
001786r 3  20 rr rr                     jsr xt_space
001789r 3  68                           pla
00178Ar 3               
00178Ar 3                               ; Handle ASCII printing
00178Ar 3  20 rr rr                     jsr is_printable
00178Dr 3  B0 02                        bcs @printable
00178Fr 3  A9 2E                        lda #'.'                 ; Print dot if not printable
001791r 3               @printable:
001791r 3  5A                           phy                     ; save counter
001792r 3  A4 rr                        ldy tmp2
001794r 3  91 rr                        sta (cp),y
001796r 3  E6 rr                        inc tmp2
001798r 3  7A                           ply
001799r 3               
001799r 3                               ; extra space after eight bytes
001799r 3  C0 09                        cpy #9
00179Br 3  D0 03                        bne @next_char
00179Dr 3  20 rr rr                     jsr xt_space
0017A0r 3               
0017A0r 3               @next_char:
0017A0r 3  F6 02                        inc 2,x
0017A2r 3  D0 02                        bne @counter
0017A4r 3  F6 03                        inc 3,x
0017A6r 3               
0017A6r 3               @counter:
0017A6r 3                               ; loop counter
0017A6r 3  B5 00                        lda 0,x
0017A8r 3  D0 02                        bne @1
0017AAr 3  D6 01                        dec 1,x
0017ACr 3               @1:
0017ACr 3  D6 00                        dec 0,x
0017AEr 3  88                           dey
0017AFr 3  D0 C9                        bne @loop               ; next byte
0017B1r 3               
0017B1r 3                               ; Done with one line, print the ASCII version of these
0017B1r 3                               ; characters
0017B1r 3  20 rr rr                     jsr xt_space
0017B4r 3  20 rr rr                     jsr print_ascii
0017B7r 3               
0017B7r 3  80 AA                        bra @row                ; new row
0017B9r 3               
0017B9r 3               @all_printed:
0017B9r 3                               ; See if there are any ASCII characters in the buffer
0017B9r 3                               ; left to print
0017B9r 3  A5 rr                        lda tmp2
0017BBr 3  F0 06                        beq @done
0017BDr 3               
0017BDr 3                               ; In theory, we could try to make the ASCII part line
0017BDr 3                               ; up with the line before it. But that is a hassle (we
0017BDr 3                               ; use three bytes for each missed hex entry, and
0017BDr 3                               ; then there is the gap after eight entries) and it
0017BDr 3                               ; makes it harder to read. We settle for one extra
0017BDr 3                               ; space instead for the moment
0017BDr 3  20 rr rr                     jsr xt_space
0017C0r 3  20 rr rr                     jsr print_ascii
0017C3r 3               @done:
0017C3r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
0017C6r 3  60           z_dump:         rts
0017C7r 3               
0017C7r 3               
0017C7r 3               print_ascii:
0017C7r 3                               ; Print the ASCII characters that we have saved from
0017C7r 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
0017C7r 3                               ; is not compiled (DUMP is probably never compiled anyway)
0017C7r 3                               ; but we keep it inside the scope of DUMP.
0017C7r 3  A0 00                        ldy #0
0017C9r 3               @ascii_loop:
0017C9r 3  B1 rr                        lda (cp),y
0017CBr 3  20 rr rr                     jsr emit_a
0017CEr 3  C8                           iny
0017CFr 3               
0017CFr 3                               ; extra space after eight chars
0017CFr 3  C0 08                        cpy #8
0017D1r 3  D0 03                        bne @1
0017D3r 3  20 rr rr                     jsr xt_space
0017D6r 3               @1:
0017D6r 3  C6 rr                        dec tmp2
0017D8r 3  D0 EF                        bne @ascii_loop
0017DAr 3               
0017DAr 3  60                           rts
0017DBr 3               
0017DBr 3               
0017DBr 3               
0017DBr 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
0017DBr 3               ; ## "dup"  auto  ANS core
0017DBr 3                       ; """https://forth-standard.org/standard/core/DUP"""
0017DBr 3               xt_dup:
0017DBr 3  20 rr rr                     jsr underflow_1
0017DEr 3               
0017DEr 3  CA                           dex
0017DFr 3  CA                           dex
0017E0r 3               
0017E0r 3  B5 02                        lda 2,x         ; LSB
0017E2r 3  95 00                        sta 0,x
0017E4r 3  B5 03                        lda 3,x         ; MSB
0017E6r 3  95 01                        sta 1,x
0017E8r 3               
0017E8r 3  60           z_dup:          rts
0017E9r 3               
0017E9r 3               
0017E9r 3               ; ## ED ( -- u ) "Line-based editor"
0017E9r 3               ; ## "ed"  fragment  Tali Forth
0017E9r 3                       ; """Start the line-based editor ed6502. See separate file
0017E9r 3                       ; ed.asm or the manual for details.
0017E9r 3                       ; """
0017E9r 3               xt_ed:
0017E9r 3                           .ifdef ed6502
0017E9r 3                               jsr ed6502      ; kept in separate file
0017E9r 3                           .endif
0017E9r 3               
0017E9r 3  60           z_ed:           rts
0017EAr 3               
0017EAr 3               
0017EAr 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
0017EAr 3               ; ## "editor-wordlist"  tested  Tali Editor
0017EAr 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
0017EAr 3                       ; words to the search order so they can be used.  This will need
0017EAr 3                       ; to be done before any of the words marked "Tali Editor" can be
0017EAr 3                       ; used.  See the tutorial on Wordlists and the Search Order for
0017EAr 3                       ; more information.
0017EAr 3               
0017EAr 3                       ;
0017EAr 3                       ; This is a dummy entry, the code is shared with ONE
0017EAr 3                       ; """
0017EAr 3               
0017EAr 3               
0017EAr 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
0017EAr 3               ; ## "else"  auto  ANS core
0017EAr 3                       ; """http://forth-standard.org/standard/core/ELSE
0017EAr 3                       ;
0017EAr 3                       ; The code is shared with ENDOF
0017EAr 3                       ; """
0017EAr 3               
0017EAr 3               xt_else:
0017EAr 3               xt_endof:
0017EAr 3                               ; Put an unconditional branch.
0017EAr 3  A0 rr                        ldy #>branch_runtime
0017ECr 3  A9 rr                        lda #<branch_runtime
0017EEr 3  20 rr rr                     jsr cmpl_subroutine
0017F1r 3               
0017F1r 3                               ; Put the address of the branch address on the stack.
0017F1r 3  20 rr rr                     jsr xt_here
0017F4r 3               
0017F4r 3                               ; Use zero for the branch address for now.
0017F4r 3                               ; THEN will fill it in later.
0017F4r 3  20 rr rr                     jsr xt_zero
0017F7r 3  20 rr rr                     jsr xt_comma
0017FAr 3               
0017FAr 3                               ; Get the address to jump to (just after the
0017FAr 3                               ; unconditional branch) for the IF to jump to
0017FAr 3                               ; when false.
0017FAr 3  20 rr rr                     jsr xt_here
0017FDr 3  20 rr rr                     jsr xt_rot
001800r 3               
001800r 3                               ; Update the original if 0branch address.
001800r 3  20 rr rr                     jsr xt_store
001803r 3               z_else:
001803r 3               z_endof:
001803r 3  60                           rts
001804r 3               
001804r 3               
001804r 3               
001804r 3               branch_runtime:
001804r 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
001804r 3                       ; formally part of a separate word BRANCH which was later removed.
001804r 3                       ; """
001804r 3               
001804r 3                               ; The address on the Return Stack points to the last byte
001804r 3                               ; of the JSR address, one byte below the branch literal
001804r 3  68                           pla
001805r 3  85 rr                        sta tmpbranch
001807r 3  68                           pla
001808r 3  85 rr                        sta tmpbranch+1
00180Ar 3               
00180Ar 3                               ; Keep in mind: the address we just popped points one byte
00180Ar 3                               ; lower than the branch literal we want to grab
00180Ar 3  A0 01                        ldy #1
00180Cr 3  B1 rr                        lda (tmpbranch),y  ; LSB
00180Er 3  85 rr                        sta tmp1
001810r 3  C8                           iny
001811r 3  B1 rr                        lda (tmpbranch),y  ; MSB
001813r 3  85 rr                        sta tmp1+1
001815r 3               
001815r 3  6C rr rr                     jmp (tmp1)
001818r 3               
001818r 3               
001818r 3               
001818r 3               ; ## EMIT ( char -- ) "Print character to current output"
001818r 3               ; ## "emit"  auto  ANS core
001818r 3                       ; """https://forth-standard.org/standard/core/EMIT
001818r 3                       ; Run-time default for EMIT. The user can revector this by changing
001818r 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
001818r 3                       ; do not check to see if we have been given a valid ASCII character.
001818r 3                       ; Don't make this native compile.
001818r 3                       ; """
001818r 3               
001818r 3               xt_emit:
001818r 3  20 rr rr                     jsr underflow_1
00181Br 3               
00181Br 3  B5 00                        lda 0,x
00181Dr 3  E8                           inx
00181Er 3  E8                           inx
00181Fr 3               
00181Fr 3               emit_a:
00181Fr 3                       ; We frequently want to print the character in A without fooling
00181Fr 3                       ; around with the Data Stack. This is emit_a's job, which still
00181Fr 3                       ; allows the output to be vectored. Call it with JSR as you
00181Fr 3                       ; would XT_EMIT
00181Fr 3  6C rr rr                     jmp (output)            ; JSR/RTS
001822r 3               
001822r 3               z_emit:         ; never reached
001822r 3               
001822r 3               
001822r 3               
001822r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
001822r 3               ; ## "empty-buffers"  tested  ANS block ext
001822r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
001822r 3               xt_empty_buffers:
001822r 3                               ; Set the buffer status to empty.
001822r 3  A0 2C                        ldy #buffstatus_offset
001824r 3  A9 00                        lda #0
001826r 3  91 rr                        sta (up),y      ; Only LSB is used.
001828r 3               z_empty_buffers:
001828r 3  60                           rts
001829r 3               
001829r 3               
001829r 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
001829r 3               ; ## "endcase"  auto  ANS core ext
001829r 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
001829r 3               
001829r 3               xt_endcase:
001829r 3                               ; Postpone DROP to remove the item
001829r 3                               ; being checked.
001829r 3  A0 rr                        ldy #>xt_drop
00182Br 3  A9 rr                        lda #<xt_drop
00182Dr 3  20 rr rr                     jsr cmpl_subroutine
001830r 3               
001830r 3                               ; There are a number of address (of branches that need their
001830r 3                               ; jump addressed filled in with the address of right here).
001830r 3                               ; Keep calling THEN to deal with them until we reach the
001830r 3                               ; 0 that CASE put on the stack at the beginning.
001830r 3               @endcase_loop:
001830r 3                               ; Check for 0 on the stack.
001830r 3  B5 00                        lda 0,x
001832r 3  15 01                        ora 1,x
001834r 3  F0 05                        beq @done
001836r 3               
001836r 3  20 rr rr                     jsr xt_then
001839r 3  80 F5                        bra @endcase_loop
00183Br 3               @done:
00183Br 3                               ; Remove the 0 from the stack.
00183Br 3  E8                           inx
00183Cr 3  E8                           inx
00183Dr 3  60           z_endcase:      rts
00183Er 3               
00183Er 3               
00183Er 3               
00183Er 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
00183Er 3               ; ## "endof"  auto  ANS core ext
00183Er 3                       ; """http://forth-standard.org/standard/core/ENDOF
00183Er 3                       ; This is a dummy entry, the code is shared with ELSE
00183Er 3                       ; """
00183Er 3               
00183Er 3               
00183Er 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
00183Er 3               ; ## "environment?"  auto  ANS core
00183Er 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
00183Er 3                       ;
00183Er 3                       ; By ANS definition, we use upper-case strings here, see the
00183Er 3                       ; string file for details. This can be realized as a high-level
00183Er 3                       ; Forth word as
00183Er 3                       ;
00183Er 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
00183Er 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
00183Er 3                       ; HEX
00183Er 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
00183Er 3                       ; CASE
00183Er 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
00183Er 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
00183Er 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
00183Er 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
00183Er 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
00183Er 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
00183Er 3                       ; S" MAX-D"              STRING_OF
00183Er 3                                                    ; 7FFFFFFF. TRUE ENDOF
00183Er 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
00183Er 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
00183Er 3                       ; S" MAX-UD"             STRING_OF
00183Er 3                                                    ; FFFFFFFF. TRUE ENDOF
00183Er 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
00183Er 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
00183Er 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
00183Er 3                       ; ENDCASE ;
00183Er 3                       ;
00183Er 3                       ; but that uses lots of memory and increases the start up time. This
00183Er 3                       ; word is rarely used so we can try to keep it short at the expense
00183Er 3                       ; of speed.
00183Er 3                       ; """
00183Er 3               
00183Er 3               xt_environment_q:
00183Er 3  20 rr rr                     jsr underflow_1
001841r 3               
001841r 3                               ; This code is table-driven: We walk through the list of
001841r 3                               ; strings until we find one that matches, and then we take
001841r 3                               ; the equivalent data from the results table. This is made
001841r 3                               ; a bit harder by the fact that some of these return a
001841r 3                               ; double-cell number and some a single-cell one.
001841r 3               
001841r 3                               ; We will walk through the table with variables that return
001841r 3                               ; a single-cell result
001841r 3  A0 00                        ldy #00                 ; counter for table
001843r 3               
001843r 3                               ; We use a flag on the the stack to signal if we have a single-cell
001843r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
001843r 3                               ; double-cell.
001843r 3  5A                           phy
001844r 3               @table_loop:
001844r 3                               ; We arrived here with the address of the string to be checked
001844r 3                               ; on the stack. We make a copy. Index is in Y
001844r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
001847r 3               
001847r 3                               ; We do our work on the TOS to speed things up
001847r 3  CA                           dex
001848r 3  CA                           dex                     ; ( addr u addr u ? )
001849r 3               
001849r 3                               ; Get address of string to check from table
001849r 3  B9 rr rr                     lda env_table_single,y
00184Cr 3  95 00                        sta 0,x
00184Er 3  C8                           iny
00184Fr 3  B9 rr rr                     lda env_table_single,y
001852r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
001854r 3  C8                           iny
001855r 3               
001855r 3                               ; See if this is the last entry. The LSB is still in A
001855r 3  15 00                        ora 0,x
001857r 3  F0 4D                        beq @table_done
001859r 3               
001859r 3                               ; We have a string entry. The address there is stored in
001859r 3                               ; old-style address format, that is, the first byte is the
001859r 3                               ; length of the string
001859r 3  5A                           phy                     ; save Y, which is used by COUNT
00185Ar 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
00185Dr 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
001860r 3  7A                           ply
001861r 3               
001861r 3                               ; If we found a match (flag is zero -- COMPARE is weird
001861r 3                               ; that way), return the result
001861r 3  B5 00                        lda 0,x
001863r 3  15 01                        ora 1,x
001865r 3  F0 04                        beq @got_result
001867r 3               
001867r 3                               ; Flag is not zero, so not a perfect match, so try next
001867r 3                               ; word
001867r 3  E8                           inx                     ; DROP, now ( addr u )
001868r 3  E8                           inx
001869r 3               
001869r 3  80 D9                        bra @table_loop
00186Br 3               
00186Br 3               @got_result:
00186Br 3                               ; We arrive here with ( addr u -1 ) and know that we've found
00186Br 3                               ; a match. The index of the match+2 is in Y.
00186Br 3  E8                           inx                     ; drop flag, now ( addr u )
00186Cr 3  E8                           inx
00186Dr 3  88                           dey                     ; go back to index we had
00186Er 3  88                           dey
00186Fr 3               
00186Fr 3                               ; See if this is a single-cell word.
00186Fr 3  68                           pla
001870r 3  D0 0D                        bne @double_result
001872r 3               
001872r 3                               ; Single-cell result
001872r 3  B9 rr rr                     lda env_results_single,y
001875r 3  95 02                        sta 2,x
001877r 3  C8                           iny
001878r 3  B9 rr rr                     lda env_results_single,y
00187Br 3  95 03                        sta 3,x                 ; ( res u )
00187Dr 3               
00187Dr 3  80 1F                        bra @set_flag
00187Fr 3               
00187Fr 3               @double_result:
00187Fr 3                               ; This is a double-celled result, which means we have to
00187Fr 3                               ; fool around with the index some more. We also need a
00187Fr 3                               ; further cell on the stack
00187Fr 3  CA                           dex                     ; ( addr u ? )
001880r 3  CA                           dex
001881r 3               
001881r 3                               ; We have 11 single-cell words we check, plus the 0000 as
001881r 3                               ; a marker for the end of the table, so we arrive here
001881r 3                               ; with Y as 22 or more. To get the index for the double-
001881r 3                               ; cell words, we move the result
001881r 3  98                           tya
001882r 3  38                           sec
001883r 3  E9 18                        sbc #24
001885r 3               
001885r 3                               ; We have four bytes per entry in the table, but the index
001885r 3                               ; keeps increasing by two, so we only have to multiply by
001885r 3                               ; two (shift left once) to get the right result
001885r 3  0A                           asl
001886r 3  A8                           tay
001887r 3               
001887r 3  B9 rr rr                     lda env_results_double,y
00188Ar 3  95 02                        sta 2,x
00188Cr 3  C8                           iny
00188Dr 3  B9 rr rr                     lda env_results_double,y
001890r 3  95 03                        sta 3,x                 ; ( res u ? )
001892r 3  C8                           iny
001893r 3               
001893r 3  B9 rr rr                     lda env_results_double,y
001896r 3  95 04                        sta 4,x
001898r 3  C8                           iny
001899r 3  B9 rr rr                     lda env_results_double,y
00189Cr 3  95 05                        sta 5,x                 ; ( res res ? )
00189Er 3               
00189Er 3                               ; fall through to @set_flag
00189Er 3               @set_flag:
00189Er 3  A9 FF                        lda #$ff
0018A0r 3  95 00                        sta 0,x
0018A2r 3  95 01                        sta 1,x                 ; ( res f )
0018A4r 3               
0018A4r 3  80 14                        bra @done
0018A6r 3               @table_done:
0018A6r 3                               ; We're done with a table, because the entry was a zero.
0018A6r 3                               ; We arrive here with ( addr u addr u 0 )
0018A6r 3               
0018A6r 3                               ; We take the flag from stack and increase it by one. If the
0018A6r 3                               ; flag is zero, we have just completed the single-cell number
0018A6r 3                               ; strings, so we in increase the flag and try again. Otherwise,
0018A6r 3                               ; we're done with the double-cell table without having found
0018A6r 3                               ; a match, and we're done
0018A6r 3  68                           pla
0018A7r 3  D0 09                        bne @no_match
0018A9r 3               
0018A9r 3                               ; Flag is zero, increase it to one and start over to check
0018A9r 3                               ; double-cell values
0018A9r 3  1A                           inc
0018AAr 3  48                           pha
0018ABr 3               
0018ABr 3  8A                           txa
0018ACr 3  18                           clc
0018ADr 3  69 06                        adc #6                  ; skip six bytes
0018AFr 3  AA                           tax                     ; ( addr u )
0018B0r 3               
0018B0r 3  80 92                        bra @table_loop
0018B2r 3               @no_match:
0018B2r 3                               ; Bummer, not found. We arrive here with
0018B2r 3                               ; ( addr u addr u 0 ) and need to return just a zero
0018B2r 3  8A                           txa
0018B3r 3  18                           clc
0018B4r 3  69 0A                        adc #10
0018B6r 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
0018B7r 3               
0018B7r 3  20 rr rr                     jsr xt_false
0018BAr 3               @done:
0018BAr 3               z_environment_q:
0018BAr 3  60                           rts
0018BBr 3               
0018BBr 3               
0018BBr 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
0018BBr 3               ; results and one for the double-celled results. The zero cell at the
0018BBr 3               ; end of each table marks its, uh, end. The strings themselves are defined
0018BBr 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
0018BBr 3               ; have to adapt the result code for double printout, where we subtract 22
0018BBr 3               ; (two bytes each single-cell string and two bytes for the end-of-table
0018BBr 3               ; marker 0000
0018BBr 3               env_table_single:
0018BBr 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
0018BFr 3  rr rr rr rr  
0018C3r 3  rr rr        
0018C5r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
0018C9r 3  rr rr rr rr  
0018CDr 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
0018D1r 3  00 00        
0018D3r 3               
0018D3r 3               env_table_double:
0018D3r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
0018D7r 3  00 00        
0018D9r 3               
0018D9r 3               env_results_single:
0018D9r 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
0018DBr 3  FF 00                .word $00FF     ; /HOLD
0018DDr 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
0018DFr 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
0018E1r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
0018E3r 3  FF 00                .word $00FF     ; MAX-CHAR
0018E5r 3  FF 7F                .word $7FFF     ; MAX-N
0018E7r 3  FF FF                .word $FFFF     ; MAX-U
0018E9r 3  80 00                .word $0080     ; RETURN-STACK-CELLS
0018EBr 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
0018EDr 3  09 00                .word $0009     ; WORDLISTS
0018EFr 3               
0018EFr 3               env_results_double:
0018EFr 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
0018F3r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
0018F7r 3               
0018F7r 3               
0018F7r 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
0018F7r 3               ; ## "="  auto  ANS core
0018F7r 3                       ; """https://forth-standard.org/standard/core/Equal"""
0018F7r 3               
0018F7r 3               xt_equal:
0018F7r 3  20 rr rr                     jsr underflow_2
0018FAr 3               
0018FAr 3  B5 00                        lda 0,x                 ; LSB
0018FCr 3  D5 02                        cmp 2,x
0018FEr 3  D0 0A                        bne @false
001900r 3               
001900r 3  B5 01                        lda 1,x                 ; MSB
001902r 3  D5 03                        cmp 3,x
001904r 3  D0 04                        bne @false
001906r 3               
001906r 3  A9 FF                        lda #$ff
001908r 3  80 02                        bra @done
00190Ar 3               
00190Ar 3  A9 00        @false:         lda #0                  ; drop thru to done
00190Cr 3               
00190Cr 3  95 02        @done:          sta 2,x
00190Er 3  95 03                        sta 3,x
001910r 3               
001910r 3  E8                           inx
001911r 3  E8                           inx
001912r 3               
001912r 3  60           z_equal:        rts
001913r 3               
001913r 3               
001913r 3               
001913r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
001913r 3               ; ## "blank"  auto  ANS string
001913r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
001913r 3               xt_blank:
001913r 3                               ; We don't check for underflow here because
001913r 3                               ; we deal with that in FILL
001913r 3  CA                           dex
001914r 3  CA                           dex
001915r 3  A9 20                        lda #AscSP
001917r 3  95 00                        sta 0,x
001919r 3  74 01                        stz 1,x
00191Br 3               
00191Br 3  80 06                        bra xt_fill     ; skip over code for ERASE
00191Dr 3               
00191Dr 3               
00191Dr 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
00191Dr 3               ; ## "erase"  auto  ANS core ext
00191Dr 3                       ; """https://forth-standard.org/standard/core/ERASE
00191Dr 3                       ; Note that ERASE works with "address" units
00191Dr 3                       ; (bytes), not cells.
00191Dr 3                       ; """
00191Dr 3               
00191Dr 3               xt_erase:
00191Dr 3                               ; We don't check for underflow here because
00191Dr 3                               ; we deal with that in FILL
00191Dr 3  CA                           dex
00191Er 3  CA                           dex
00191Fr 3  74 00                        stz 0,x
001921r 3  74 01                        stz 1,x
001923r 3               
001923r 3                               ; fall through to FILL
001923r 3               
001923r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
001923r 3               ; ## "fill"  auto  ANS core
001923r 3                       ; """https://forth-standard.org/standard/core/FILL
001923r 3                       ; Fill u bytes of memory with char starting at addr. Note that
001923r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
001923r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
001923r 3                       ; happens when we reach the end of the address space
001923r 3                       ; """
001923r 3               xt_fill:
001923r 3  20 rr rr                     jsr underflow_3
001926r 3               
001926r 3                               ; We use tmp1 to hold the address
001926r 3  B5 04                        lda 4,x         ; LSB
001928r 3  85 rr                        sta tmp1
00192Ar 3  B5 05                        lda 5,x
00192Cr 3  85 rr                        sta tmp1+1
00192Er 3               
00192Er 3                               ; We use tmp2 to hold the counter
00192Er 3  B5 02                        lda 2,x
001930r 3  85 rr                        sta tmp2
001932r 3  B5 03                        lda 3,x
001934r 3  85 rr                        sta tmp2+1
001936r 3               
001936r 3                               ; We use Y to hold the character
001936r 3  B5 00                        lda 0,x
001938r 3  A8                           tay
001939r 3               @loop:
001939r 3                               ; Unfortunately, we also need to make sure that we don't
001939r 3                               ; write further than the end of the RAM. So RAM_END must
001939r 3                               ; be larger or equal to the current address
001939r 3  A9 80                        lda #>ram_end           ; MSB
00193Br 3  C5 rr                        cmp tmp1+1
00193Dr 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
00193Fr 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
001941r 3               
001941r 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
001943r 3  C5 rr                        cmp tmp1
001945r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
001947r 3               
001947r 3               @check_counter:
001947r 3                               ; See if our counter has reached zero
001947r 3  A5 rr                        lda tmp2
001949r 3  05 rr                        ora tmp2+1
00194Br 3  F0 13                        beq @done
00194Dr 3               
00194Dr 3                               ; We're not in ROM and we still have stuff on the counter, so
00194Dr 3                               ; let's actually do what we came here to do
00194Dr 3  98                           tya
00194Er 3  92 rr                        sta (tmp1)
001950r 3               
001950r 3                               ; Adjust the counter
001950r 3  A5 rr                        lda tmp2
001952r 3  D0 02                        bne @1
001954r 3  C6 rr                        dec tmp2+1
001956r 3  C6 rr        @1:               dec tmp2
001958r 3               
001958r 3                               ; Next address
001958r 3  E6 rr                        inc tmp1
00195Ar 3  D0 DD                        bne @loop
00195Cr 3  E6 rr                        inc tmp1+1
00195Er 3               
00195Er 3  80 D9                        bra @loop
001960r 3               
001960r 3               @done:
001960r 3                               ; Drop three cells off the Data Stack. This uses one byte
001960r 3                               ; less than six times INX
001960r 3  8A                           txa
001961r 3  18                           clc
001962r 3  69 06                        adc #6
001964r 3  AA                           tax
001965r 3               z_blank:
001965r 3               z_erase:
001965r 3  60           z_fill:         rts
001966r 3               
001966r 3               
001966r 3               
001966r 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
001966r 3               ; ## "execute"  auto  ANS core
001966r 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
001966r 3               xt_execute:
001966r 3  20 rr rr                     jsr underflow_1
001969r 3               
001969r 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
00196Cr 3               
00196Cr 3  60           z_execute:      rts
00196Dr 3               
00196Dr 3               doexecute:
00196Dr 3  B5 00                        lda 0,x
00196Fr 3  85 rr                        sta ip
001971r 3  B5 01                        lda 1,x
001973r 3  85 rr                        sta ip+1
001975r 3               
001975r 3  E8                           inx
001976r 3  E8                           inx
001977r 3               
001977r 3                               ; we don't need a RTS here because we highjack the RTS of
001977r 3                               ; the word we're calling to get back to xt_execute
001977r 3  6C rr rr                     jmp (ip)
00197Ar 3               
00197Ar 3               ; end of doexecute
00197Ar 3               
00197Ar 3               
00197Ar 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
00197Ar 3               ; ## "execute-parsing"  auto  Gforth
00197Ar 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
00197Ar 3                       ; Execute the parsing word defined by the execution token (xt) on the
00197Ar 3                       ; string as if it were passed on the command line. See the file
00197Ar 3                       ; tests/tali.fs for examples.
00197Ar 3                       ;
00197Ar 3                       ; Note that this word is coded completely
00197Ar 3                       ; different in its Gforth version, see the file execute-parsing.fs
00197Ar 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
00197Ar 3                       ; """
00197Ar 3               xt_execute_parsing:
00197Ar 3  20 rr rr                     jsr underflow_3
00197Dr 3               
00197Dr 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
001980r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
001983r 3               
001983r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
001985r 3  85 rr                        sta ciblen
001987r 3  B5 01                        lda 1,x
001989r 3  85 rr                        sta ciblen+1
00198Br 3               
00198Br 3  B5 02                        lda 2,x                 ; NOS is new cib
00198Dr 3  85 rr                        sta cib
00198Fr 3  B5 03                        lda 3,x
001991r 3  85 rr                        sta cib+1
001993r 3               
001993r 3  64 rr                        stz toin                ; Set >IN to zero
001995r 3  64 rr                        stz toin+1
001997r 3               
001997r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
00199Ar 3  20 rr rr                     jsr xt_execute
00199Dr 3               
00199Dr 3  20 rr rr                     jsr xt_r_to_input
0019A0r 3               
0019A0r 3               z_execute_parsing:
0019A0r 3  60                           rts
0019A1r 3               
0019A1r 3               
0019A1r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
0019A1r 3               ; ## "exit"  auto  ANS core
0019A1r 3                       ; """https://forth-standard.org/standard/core/EXIT
0019A1r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
0019A1r 3                       ; we we might have put on the Return Stack off as well. This should
0019A1r 3                       ; be natively compiled.
0019A1r 3                       ; """
0019A1r 3               
0019A1r 3               xt_exit:
0019A1r 3  60                           rts             ; keep before z_exit
0019A2r 3               z_exit:                         ; never reached
0019A2r 3               
0019A2r 3               
0019A2r 3               
0019A2r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
0019A2r 3               ; ## "false"  auto  ANS core ext
0019A2r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
0019A2r 3               xt_false:
0019A2r 3  CA                           dex
0019A3r 3  CA                           dex
0019A4r 3  74 00                        stz 0,x
0019A6r 3  74 01                        stz 1,x
0019A8r 3               
0019A8r 3  60           z_false:        rts
0019A9r 3               
0019A9r 3               
0019A9r 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
0019A9r 3               ; ## "@"  auto  ANS core
0019A9r 3                       ; """https://forth-standard.org/standard/core/Fetch"""
0019A9r 3               xt_fetch:
0019A9r 3  20 rr rr                     jsr underflow_1
0019ACr 3               
0019ACr 3  A1 00                        lda (0,x)               ; LSB
0019AEr 3  A8                           tay
0019AFr 3  F6 00                        inc 0,x
0019B1r 3  D0 02                        bne @1
0019B3r 3  F6 01                        inc 1,x
0019B5r 3               @1:
0019B5r 3  A1 00                        lda (0,x)               ; MSB
0019B7r 3  95 01                        sta 1,x
0019B9r 3  94 00                        sty 0,x
0019BBr 3               
0019BBr 3  60           z_fetch:        rts
0019BCr 3               
0019BCr 3               
0019BCr 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
0019BCr 3               ; ## "find"  auto  ANS core
0019BCr 3                       ; """https://forth-standard.org/standard/core/FIND
0019BCr 3                       ; Included for backwards compatibility only, because it still
0019BCr 3                       ; can be found in so may examples. It should, however, be replaced
0019BCr 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
0019BCr 3                       ; flag if not found in the Dictionary, or the xt with a flag to
0019BCr 3                       ; indicate if this is immediate or not. FIND is a wrapper around
0019BCr 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
0019BCr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
0019BCr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0019BCr 3                       ; """
0019BCr 3               
0019BCr 3               xt_find:
0019BCr 3  20 rr rr                     jsr underflow_1
0019BFr 3               
0019BFr 3                               ; Save address in case conversion fails. We use the
0019BFr 3                               ; Return Stack instead of temporary variables like TMP1
0019BFr 3                               ; because this is shorter and anybody still using FIND
0019BFr 3                               ; can't be worried about speed anyway
0019BFr 3  B5 01                        lda 1,x                 ; MSB
0019C1r 3  48                           pha
0019C2r 3  B5 00                        lda 0,x                 ; LSB
0019C4r 3  48                           pha
0019C5r 3               
0019C5r 3                               ; Convert ancient-type counted string address to
0019C5r 3                               ; modern format
0019C5r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
0019C8r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
0019CBr 3               
0019CBr 3  B5 00                        lda 0,x
0019CDr 3  15 01                        ora 1,x
0019CFr 3  D0 0B                        bne @found_word
0019D1r 3               
0019D1r 3                               ; No word found. Return address of the string and a false
0019D1r 3                               ; flag
0019D1r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
0019D4r 3               
0019D4r 3                               ; The address needs to be restored.
0019D4r 3  68                           pla                     ; LSB of address
0019D5r 3  95 02                        sta 2,x
0019D7r 3  68                           pla
0019D8r 3  95 03                        sta 3,x                 ; MSB of address
0019DAr 3               
0019DAr 3  80 27                        bra @done               ; ( addr 0 )
0019DCr 3               
0019DCr 3               @found_word:
0019DCr 3                               ; We don't need the address after all, dump it
0019DCr 3  68                           pla
0019DDr 3  68                           pla
0019DEr 3               
0019DEr 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
0019DEr 3                               ; convert the return values to FIND's format
0019DEr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0019E1r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0019E4r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0019E7r 3               
0019E7r 3  A0 00                        ldy #0                  ; Prepare flag
0019E9r 3               
0019E9r 3                               ; The flags are in the second byte of the header
0019E9r 3  F6 00                        inc 0,x
0019EBr 3  D0 02                        bne @1
0019EDr 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
0019EFr 3               @1:
0019EFr 3  A1 00                        lda (0,x)               ; ( xt char )
0019F1r 3  29 04                        and #IM
0019F3r 3  D0 08                        bne @immediate          ; bit set, we're immediate
0019F5r 3               
0019F5r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
0019F7r 3  95 00                        sta 0,x
0019F9r 3  95 01                        sta 1,x
0019FBr 3  80 06                        bra @done
0019FDr 3               
0019FDr 3               @immediate:
0019FDr 3  A9 01                        lda #1                  ; We're immediate, return 1
0019FFr 3  95 00                        sta 0,x
001A01r 3  74 01                        stz 1,x
001A03r 3               @done:
001A03r 3  60           z_find:         rts
001A04r 3               
001A04r 3               
001A04r 3               
001A04r 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
001A04r 3               ; ## "find-name"  auto  Gforth
001A04r 3               
001A04r 3               xt_find_name:
001A04r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001A04r 3                       ; Given a string, find the Name Token (nt) of a word or return
001A04r 3                       ; zero if the word is not in the dictionary. We use this instead of
001A04r 3                       ; ancient FIND to look up words in the Dictionary passed by
001A04r 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
001A04r 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
001A04r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001A04r 3                       ; FIND calls this word
001A04r 3                       ; """
001A04r 3  20 rr rr                     jsr underflow_2
001A07r 3               
001A07r 3                               ; check for special case of an empty string (length zero)
001A07r 3  B5 00                        lda 0,x
001A09r 3  15 01                        ora 1,x
001A0Br 3  D0 03                        bne @nonempty
001A0Dr 3               
001A0Dr 3  4C rr rr                     jmp @fail_done
001A10r 3               
001A10r 3               @nonempty:
001A10r 3                               ; Set up for traversing the wordlist search order.
001A10r 3  64 rr                        stz tmp3                ; Start at the beginning
001A12r 3               
001A12r 3               @wordlist_loop:
001A12r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
001A14r 3  A5 rr                        lda tmp3
001A16r 3  D1 rr                        cmp (up),y              ; Check to see if we are done
001A18r 3  D0 03                        bne @have_string
001A1Ar 3               
001A1Ar 3                               ; We ran out of wordlists to search.
001A1Ar 3  4C rr rr                     jmp @fail_done
001A1Dr 3               
001A1Dr 3               @have_string:
001A1Dr 3                               ; set up first loop iteration
001A1Dr 3               
001A1Dr 3                               ; Get the current wordlist id
001A1Dr 3  18                           clc             ; SEARCH-ORDER is array of bytes.
001A1Er 3  69 1F                        adc #search_order_offset
001A20r 3  A8                           tay
001A21r 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
001A23r 3                                               ; into the cell array WORDLISTS
001A23r 3               
001A23r 3                               ; Get the DP for that wordlist.
001A23r 3  0A                           asl                     ; Turn offset into cells offset.
001A24r 3  18                           clc
001A25r 3  69 06                        adc #wordlists_offset
001A27r 3  A8                           tay
001A28r 3  B1 rr                        lda (up),y
001A2Ar 3  85 rr                        sta tmp1
001A2Cr 3  C8                           iny
001A2Dr 3  B1 rr                        lda (up),y
001A2Fr 3  85 rr                        sta tmp1+1
001A31r 3               
001A31r 3  B5 02                        lda 2,x                 ; Address of mystery string
001A33r 3  85 rr                        sta tmp2
001A35r 3  B5 03                        lda 3,x
001A37r 3  85 rr                        sta tmp2+1
001A39r 3               
001A39r 3               @loop:
001A39r 3                               ; first quick test: Are strings the same length?
001A39r 3  B2 rr                        lda (tmp1)
001A3Br 3  D5 00                        cmp 0,x
001A3Dr 3  D0 54                        bne @next_entry
001A3Fr 3               
001A3Fr 3               @compare_string:
001A3Fr 3                               ; are the same length, so we now have to compare each
001A3Fr 3                               ; character
001A3Fr 3               
001A3Fr 3                               ; second quick test: Is the first character the same?
001A3Fr 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001A41r 3               
001A41r 3                               ; Lowercase the incoming charcter.
001A41r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001A43r 3  B0 07                        bcs @compare_first
001A45r 3  C9 41                        cmp #$41        ; ASCII 'A'
001A47r 3  90 03                        bcc @compare_first
001A49r 3               
001A49r 3                               ; An uppercase letter has been located.  Make it
001A49r 3                               ; lowercase.
001A49r 3  18                           clc
001A4Ar 3  69 20                        adc #$20
001A4Cr 3               
001A4Cr 3               @compare_first:
001A4Cr 3  A0 08                        ldy #8          ; Offset in nt to name
001A4Er 3  D1 rr                        cmp (tmp1),y    ; first character of current word
001A50r 3  D0 41                        bne @next_entry
001A52r 3               
001A52r 3                               ; String length is the same and the first character is the
001A52r 3                               ; same. If the length of the string is 1, we're already done
001A52r 3  B5 00                        lda 0,x
001A54r 3  3A                           dec
001A55r 3  F0 2C                        beq @success
001A57r 3               
001A57r 3                               ; No such luck: The strings are the same length and the first
001A57r 3                               ; char is the same, but the word is more than one char long.
001A57r 3                               ; So we suck it up and compare every single character. We go
001A57r 3                               ; from back to front, because words like CELLS and CELL+ would
001A57r 3                               ; take longer otherwise. We can also shorten the loop by one
001A57r 3                               ; because we've already compared the first char.
001A57r 3               
001A57r 3                               ; The string of the word we're testing against is 8 bytes down
001A57r 3  A5 rr                        lda tmp1
001A59r 3  48                           pha             ; Preserve tmp1 on the return stack.
001A5Ar 3  18                           clc
001A5Br 3  69 08                        adc #8
001A5Dr 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001A5Fr 3  A5 rr                        lda tmp1+1
001A61r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001A62r 3  69 00                        adc #0          ; we only need the carry
001A64r 3  85 rr                        sta tmp1+1
001A66r 3               
001A66r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001A68r 3  88                           dey
001A69r 3               
001A69r 3               @string_loop:
001A69r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
001A6Br 3               
001A6Br 3                               ; Lowercase the incoming charcter.
001A6Br 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001A6Dr 3  B0 07                        bcs @check_char
001A6Fr 3  C9 41                        cmp #$41        ; ASCII 'A'
001A71r 3  90 03                        bcc @check_char
001A73r 3               
001A73r 3                               ; An uppercase letter has been located.  Make it
001A73r 3                               ; lowercase.
001A73r 3  18                           clc
001A74r 3  69 20                        adc #$20
001A76r 3               
001A76r 3               @check_char:
001A76r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
001A78r 3  D0 13                        bne @next_entry_tmp1
001A7Ar 3               
001A7Ar 3  88                           dey
001A7Br 3  D0 EC                        bne @string_loop
001A7Dr 3               
001A7Dr 3               @success_tmp1:
001A7Dr 3  68                           pla             ; Restore tmp1 from the return stack.
001A7Er 3  85 rr                        sta tmp1+1
001A80r 3  68                           pla
001A81r 3  85 rr                        sta tmp1
001A83r 3               
001A83r 3               @success:
001A83r 3                               ; The strings match. Put correct nt NOS, because we'll drop
001A83r 3                               ; TOS before we leave
001A83r 3  A5 rr                        lda tmp1
001A85r 3  95 02                        sta 2,x
001A87r 3  A5 rr                        lda tmp1+1
001A89r 3  95 03                        sta 3,x
001A8Br 3               
001A8Br 3  80 20                        bra @done
001A8Dr 3               
001A8Dr 3               @next_entry_tmp1:
001A8Dr 3  68                           pla             ; Restore tmp1 from the return stack.
001A8Er 3  85 rr                        sta tmp1+1
001A90r 3  68                           pla
001A91r 3  85 rr                        sta tmp1
001A93r 3               
001A93r 3               @next_entry:
001A93r 3                               ; Not the same, so we get the next word. Next header
001A93r 3                               ; address is two bytes down
001A93r 3  A0 02                        ldy #2
001A95r 3  B1 rr                        lda (tmp1),y
001A97r 3  48                           pha
001A98r 3  C8                           iny
001A99r 3  B1 rr                        lda (tmp1),y
001A9Br 3  85 rr                        sta tmp1+1
001A9Dr 3  68                           pla
001A9Er 3  85 rr                        sta tmp1
001AA0r 3               
001AA0r 3                               ; If we got a zero, we've walked the whole Dictionary and
001AA0r 3                               ; return as a failure, otherwise try again
001AA0r 3  05 rr                        ora tmp1+1
001AA2r 3  D0 95                        bne @loop
001AA4r 3               
001AA4r 3                               ; Move on to the next wordlist in the search order.
001AA4r 3  E6 rr                        inc tmp3
001AA6r 3  4C rr rr                     jmp @wordlist_loop
001AA9r 3               
001AA9r 3               @fail_done:
001AA9r 3  74 02                        stz 2,x         ; failure flag
001AABr 3  74 03                        stz 3,x
001AADr 3               @done:
001AADr 3  E8                           inx
001AAEr 3  E8                           inx
001AAFr 3               
001AAFr 3  60           z_find_name:    rts
001AB0r 3               
001AB0r 3               
001AB0r 3               
001AB0r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001AB0r 3               ; ## "flush"  auto  ANS block
001AB0r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001AB0r 3               xt_flush:
001AB0r 3  20 rr rr                     jsr xt_save_buffers
001AB3r 3               
001AB3r 3                               ; Set the buffer status to empty.
001AB3r 3  A0 2C                        ldy #buffstatus_offset
001AB5r 3  A9 00                        lda #0
001AB7r 3  91 rr                        sta (up),y      ; Only LSB is used.
001AB9r 3               z_flush:
001AB9r 3  60                           rts
001ABAr 3               
001ABAr 3               
001ABAr 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001ABAr 3               ; ## "fm/mod"  auto  ANS core
001ABAr 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001ABAr 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001ABAr 3                       ;
001ABAr 3                       ; There are various ways to realize this. We follow EForth with
001ABAr 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001ABAr 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001ABAr 3                       ; See (http://www.forth.org/eforth.html). However you can also
001ABAr 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001ABAr 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001ABAr 3                       ; """
001ABAr 3               
001ABAr 3               xt_fm_slash_mod:
001ABAr 3  20 rr rr                     jsr underflow_3
001ABDr 3               
001ABDr 3                               ; if sign of n1 is negative, negate both n1 and d
001ABDr 3  64 rr                        stz tmp2        ; default: n is positive
001ABFr 3  B5 01                        lda 1,x         ; MSB of n1
001AC1r 3  10 0E                        bpl @check_d
001AC3r 3               
001AC3r 3  E6 rr                        inc tmp2        ; set flag to negative for n1
001AC5r 3  20 rr rr                     jsr xt_negate   ; NEGATE
001AC8r 3  20 rr rr                     jsr xt_to_r     ; >R
001ACBr 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001ACEr 3  20 rr rr                     jsr xt_r_from   ; R>
001AD1r 3               
001AD1r 3               @check_d:
001AD1r 3                               ; If d is negative, add n1 to high cell of d
001AD1r 3  B5 03                        lda 3,x         ; MSB of high word of d
001AD3r 3  10 0D                        bpl @multiply
001AD5r 3               
001AD5r 3  18                           clc
001AD6r 3  B5 00                        lda 0,x         ; LSB of n1
001AD8r 3  75 02                        adc 2,x         ; LSB of dh
001ADAr 3  95 02                        sta 2,x
001ADCr 3               
001ADCr 3  B5 01                        lda 1,x         ; MSB of n1
001ADEr 3  75 03                        adc 3,x         ; MSB of dh
001AE0r 3  95 03                        sta 3,x
001AE2r 3               
001AE2r 3               @multiply:
001AE2r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
001AE5r 3               
001AE5r 3                               ; if n was negative, negate the result
001AE5r 3  A5 rr                        lda tmp2
001AE7r 3  F0 07                        beq @done
001AE9r 3               
001AE9r 3  E8                           inx             ; pretend that we SWAP
001AEAr 3  E8                           inx
001AEBr 3  20 rr rr                     jsr xt_negate
001AEEr 3  CA                           dex
001AEFr 3  CA                           dex
001AF0r 3               @done:
001AF0r 3  60           z_fm_slash_mod: rts
001AF1r 3               
001AF1r 3               
001AF1r 3               
001AF1r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
001AF1r 3               ; ## "forth"  auto  ANS search ext
001AF1r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
001AF1r 3               xt_forth:
001AF1r 3  A0 1F                        ldy #search_order_offset
001AF3r 3  A9 00                        lda #0          ; The WID for Forth is 0.
001AF5r 3               
001AF5r 3  91 rr                        sta (up),y
001AF7r 3               z_forth:
001AF7r 3  60                           rts
001AF8r 3               
001AF8r 3               
001AF8r 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
001AF8r 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
001AF8r 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
001AF8r 3               load_evaluate:
001AF8r 3                               ; Set a flag (using tmp1) to not zero BLK
001AF8r 3  A9 FF                        lda #$FF
001AFAr 3  85 rr                        sta tmp1
001AFCr 3  80 11                        bra load_evaluate_start
001AFEr 3               
001AFEr 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
001AFEr 3               ; ## "evaluate"  auto  ANS core
001AFEr 3                       ; """https://forth-standard.org/standard/core/EVALUATE
001AFEr 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
001AFEr 3                       ; After processing the line, revert to old input source. We use this
001AFEr 3                       ; to compile high-level Forth words and user-defined words during
001AFEr 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
001AFEr 3                       ; accept more than 255 characters here, even though it's a pain in
001AFEr 3                       ; the 8-bit.
001AFEr 3                       ; """
001AFEr 3               
001AFEr 3               xt_evaluate:
001AFEr 3  20 rr rr                     jsr underflow_2
001B01r 3               
001B01r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
001B01r 3                               ; and will set the block number.
001B01r 3  64 rr                        stz tmp1
001B03r 3               
001B03r 3                               ; If u is zero (which can happen a lot for the user-defined
001B03r 3                               ; words), just leave again
001B03r 3  B5 00                        lda 0,x
001B05r 3  15 01                        ora 1,x
001B07r 3  D0 06                        bne _eval_got_work
001B09r 3               
001B09r 3  E8                           inx
001B0Ar 3  E8                           inx
001B0Br 3  E8                           inx
001B0Cr 3  E8                           inx
001B0Dr 3               
001B0Dr 3  80 42                        bra _eval_done
001B0Fr 3               
001B0Fr 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
001B0Fr 3               load_evaluate_start:
001B0Fr 3               _eval_got_work:
001B0Fr 3                               ; Save the current value of BLK on the return stack.
001B0Fr 3  A0 01                        ldy #blk_offset+1
001B11r 3  B1 rr                        lda (up),y
001B13r 3  48                           pha
001B14r 3  88                           dey
001B15r 3  B1 rr                        lda (up),y
001B17r 3  48                           pha
001B18r 3               
001B18r 3                               ; See if we should zero BLK.
001B18r 3  A5 rr                        lda tmp1
001B1Ar 3  D0 05                        bne @nozero
001B1Cr 3               
001B1Cr 3                               ; Set BLK to zero.
001B1Cr 3                               ; lda #0        ; A is already zero from loading tmp1
001B1Cr 3  91 rr                        sta (up),y
001B1Er 3  C8                           iny
001B1Fr 3  91 rr                        sta (up),y
001B21r 3               
001B21r 3               @nozero:
001B21r 3                               ; Save the input state to the Return Stack
001B21r 3  20 rr rr                     jsr xt_input_to_r
001B24r 3               
001B24r 3                               ; set SOURCE-ID to -1
001B24r 3  A9 FF                        lda #$ff
001B26r 3  85 rr                        sta insrc
001B28r 3  85 rr                        sta insrc+1
001B2Ar 3               
001B2Ar 3                               ; set >IN to zero
001B2Ar 3  64 rr                        stz toin
001B2Cr 3  64 rr                        stz toin+1
001B2Er 3               
001B2Er 3                               ; move TOS and NOS to input buffers
001B2Er 3  B5 00                        lda 0,x
001B30r 3  85 rr                        sta ciblen
001B32r 3  B5 01                        lda 1,x
001B34r 3  85 rr                        sta ciblen+1
001B36r 3               
001B36r 3  B5 02                        lda 2,x
001B38r 3  85 rr                        sta cib
001B3Ar 3  B5 03                        lda 3,x
001B3Cr 3  85 rr                        sta cib+1
001B3Er 3               
001B3Er 3  E8                           inx             ; A clean stack is a clean mind
001B3Fr 3  E8                           inx
001B40r 3  E8                           inx
001B41r 3  E8                           inx
001B42r 3               
001B42r 3  20 rr rr                     jsr interpret   ; ( -- )
001B45r 3               
001B45r 3                               ; restore variables
001B45r 3  20 rr rr                     jsr xt_r_to_input
001B48r 3               
001B48r 3                               ; Restore BLK from the return stack.
001B48r 3  A0 00                        ldy #blk_offset
001B4Ar 3  68                           pla
001B4Br 3  91 rr                        sta (up),y
001B4Dr 3  C8                           iny
001B4Er 3  68                           pla
001B4Fr 3  91 rr                        sta (up),y
001B51r 3               
001B51r 3               _eval_done:
001B51r 3  60           z_evaluate:     rts
001B52r 3               
001B52r 3               
001B52r 3               
001B52r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001B52r 3               ; ## "forth-wordlist"  auto  ANS search
001B52r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001B52r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001B52r 3               
001B52r 3               
001B52r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001B52r 3               ; ## "get-current" auto ANS search
001B52r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001B52r 3               
001B52r 3               xt_get_current:
001B52r 3                               ; This is a little different than some of the variables
001B52r 3                               ; in the user area as we want the value rather than
001B52r 3                               ; the address.
001B52r 3  CA                           dex
001B53r 3  CA                           dex
001B54r 3  A0 04                        ldy #current_offset
001B56r 3  B1 rr                        lda (up),y
001B58r 3  95 00                        sta 0,x         ; CURRENT is a byte variable
001B5Ar 3  74 01                        stz 1,x         ; so the MSB is zero.
001B5Cr 3               
001B5Cr 3  60           z_get_current:  rts
001B5Dr 3               
001B5Dr 3               
001B5Dr 3               
001B5Dr 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001B5Dr 3               ; ## "get-order" auto ANS search
001B5Dr 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001B5Dr 3               
001B5Dr 3               xt_get_order:
001B5Dr 3                               ; Get #ORDER - the number of wordlists in the search order.
001B5Dr 3  A0 1E                        ldy #num_order_offset
001B5Fr 3  B1 rr                        lda (up),y
001B61r 3  85 rr                        sta tmp1
001B63r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
001B65r 3               
001B65r 3               @loop:
001B65r 3                               ; Count down towards the front of the list.
001B65r 3                               ; By decrementing first, we also turn the length into an offset.
001B65r 3  C6 rr                        dec tmp1        ; Count down by bytes.
001B67r 3               
001B67r 3                               ; Get a pointer to the current wordlist, working back to front.
001B67r 3  A9 1F                        lda #search_order_offset
001B69r 3  18                           clc
001B6Ar 3  65 rr                        adc tmp1
001B6Cr 3  A8                           tay
001B6Dr 3               
001B6Dr 3                               ; Put that wordlist id on the stack.
001B6Dr 3  CA                           dex
001B6Er 3  CA                           dex
001B6Fr 3  B1 rr                        lda (up),y
001B71r 3  95 00                        sta 0,x         ; Search order array is bytes, so
001B73r 3  74 01                        stz 1,x         ; put a zero in the high byte.
001B75r 3               
001B75r 3                               ; See if that was the last one to process (first in the list).
001B75r 3  A9 00                        lda #0
001B77r 3  C5 rr                        cmp tmp1
001B79r 3  D0 EA                        bne @loop
001B7Br 3               
001B7Br 3               @done:
001B7Br 3                               ; Put the number of items on the stack.
001B7Br 3  CA                           dex
001B7Cr 3  CA                           dex
001B7Dr 3  A0 1E                        ldy #num_order_offset
001B7Fr 3  B1 rr                        lda (up),y
001B81r 3  95 00                        sta 0,x
001B83r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
001B85r 3               
001B85r 3  60           z_get_order:    rts
001B86r 3               
001B86r 3               
001B86r 3               
001B86r 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
001B86r 3               ; ## ">"  auto  ANS core
001B86r 3                       ; """https://forth-standard.org/standard/core/more"""
001B86r 3               
001B86r 3               xt_greater_than:
001B86r 3  20 rr rr                     jsr underflow_2
001B89r 3               
001B89r 3  A0 00                        ldy #0          ; default false
001B8Br 3  20 rr rr                     jsr compare_16bit
001B8Er 3               
001B8Er 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001B8Er 3  F0 03                        beq @false
001B90r 3  10 01                        bpl @false
001B92r 3               
001B92r 3                               ; true
001B92r 3  88                           dey
001B93r 3               @false:
001B93r 3  98                           tya
001B94r 3               
001B94r 3  E8                           inx
001B95r 3  E8                           inx
001B96r 3  95 00                        sta 0,x
001B98r 3  95 01                        sta 1,x
001B9Ar 3               
001B9Ar 3  60           z_greater_than: rts
001B9Br 3               
001B9Br 3               
001B9Br 3               
001B9Br 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
001B9Br 3               ; ## "here"  auto  ANS core
001B9Br 3                       ; """https://forth-standard.org/standard/core/HERE
001B9Br 3                       ; This code is also used by the assembler directive ARROW
001B9Br 3                       ; ("->") though as immediate"""
001B9Br 3               xt_here:
001B9Br 3               xt_asm_arrow:
001B9Br 3  CA                           dex
001B9Cr 3  CA                           dex
001B9Dr 3  A5 rr                        lda cp
001B9Fr 3  95 00                        sta 0,x
001BA1r 3  A5 rr                        lda cp+1
001BA3r 3  95 01                        sta 1,x
001BA5r 3               
001BA5r 3               z_asm_arrow:
001BA5r 3  60           z_here:         rts
001BA6r 3               
001BA6r 3               
001BA6r 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
001BA6r 3               ; ## "hex"  auto  ANS core ext
001BA6r 3                       ; """https://forth-standard.org/standard/core/HEX"""
001BA6r 3               xt_hex:
001BA6r 3  A9 10                        lda #16
001BA8r 3  85 rr                        sta base
001BAAr 3  64 rr                        stz base+1              ; paranoid
001BACr 3               
001BACr 3  60           z_hex:          rts
001BADr 3               
001BADr 3               
001BADr 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001BADr 3               ; ## "hexstore"  auto  Tali
001BADr 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001BADr 3                       ; by spaces, store the numbers at the address addr2, returning the
001BADr 3                       ; number of elements. Non-number elements are skipped, an zero-length
001BADr 3                       ; string produces a zero output.
001BADr 3                       ; """
001BADr 3               
001BADr 3               xt_hexstore:
001BADr 3  20 rr rr                     jsr underflow_3
001BB0r 3               
001BB0r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
001BB3r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
001BB6r 3               
001BB6r 3               @loop:
001BB6r 3                               ; Loop until string is totally consumed
001BB6r 3  B5 00                        lda 0,x
001BB8r 3  15 01                        ora 1,x
001BBAr 3  F0 36                        beq @done
001BBCr 3               
001BBCr 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001BBFr 3               
001BBFr 3                               ; Prepare the conversion of the number.
001BBFr 3  20 rr rr                     jsr xt_two_to_r
001BC2r 3  20 rr rr                     jsr xt_zero
001BC5r 3  20 rr rr                     jsr xt_zero
001BC8r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001BCBr 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001BCEr 3               
001BCEr 3                               ; If u4 is not zero, we have leftover chars and have to do
001BCEr 3                               ; things differently
001BCEr 3  B5 00                        lda 0,x
001BD0r 3  15 01                        ora 1,x
001BD2r 3  D0 17                        bne @have_chars_left
001BD4r 3               
001BD4r 3                               ; Normal case, this number is all done
001BD4r 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001BD7r 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001BDAr 3               
001BDAr 3                               ; Store the new value
001BDAr 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
001BDDr 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
001BE0r 3               
001BE0r 3                               ; Increase counter
001BE0r 3  20 rr rr                     jsr xt_r_from           ; R>
001BE3r 3  20 rr rr                     jsr xt_one_plus         ; 1+
001BE6r 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001BE9r 3  80 CB                        bra @loop
001BEBr 3               
001BEBr 3               @have_chars_left:
001BEBr 3                               ; Pathological case: Drop the rest of this number off the stack
001BEBr 3                               ; and continue with the next word. Doesn't print a warning. We
001BEBr 3                               ; need to drop four cells, that is, eight bytes
001BEBr 3  8A                           txa
001BECr 3  18                           clc
001BEDr 3  69 08                        adc #8
001BEFr 3  AA                           tax
001BF0r 3  80 C4                        bra @loop
001BF2r 3               
001BF2r 3               @done:
001BF2r 3                               ; Clean up return stack and calculate number of chars stored
001BF2r 3  E8                           inx
001BF3r 3  E8                           inx
001BF4r 3  E8                           inx
001BF5r 3  E8                           inx                     ; 2DROP
001BF6r 3               
001BF6r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001BF9r 3  20 rr rr                     jsr xt_swap
001BFCr 3  20 rr rr                     jsr xt_minus            ; ( n )
001BFFr 3               
001BFFr 3  60           z_hexstore:     rts
001C00r 3               
001C00r 3               
001C00r 3               
001C00r 3               ; ## HOLD ( char -- ) "Insert character at current output"
001C00r 3               ; ## "hold"  auto  ANS core
001C00r 3                       ; """https://forth-standard.org/standard/core/HOLD
001C00r 3                       ; Insert a character at the current position of a pictured numeric
001C00r 3                       ; output string on
001C00r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001C00r 3                       ;
001C00r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
001C00r 3                       ; variable tohold instead of HLD.
001C00r 3                       ; """
001C00r 3               xt_hold:
001C00r 3  20 rr rr                     jsr underflow_1
001C03r 3               
001C03r 3  A5 rr                        lda tohold
001C05r 3  D0 02                        bne @1
001C07r 3  C6 rr                        dec tohold+1
001C09r 3               @1:
001C09r 3  C6 rr                        dec tohold
001C0Br 3               
001C0Br 3  B5 00                        lda 0,x
001C0Dr 3  92 rr                        sta (tohold)
001C0Fr 3  E8                           inx
001C10r 3  E8                           inx
001C11r 3               
001C11r 3  60           z_hold:         rts
001C12r 3               
001C12r 3               
001C12r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
001C12r 3               ; ## "i"  auto  ANS core
001C12r 3                       ; """https://forth-standard.org/standard/core/I
001C12r 3                       ; Note that this is not the same as R@ because we use a fudge
001C12r 3                       ; factor for loop control; see the Control Flow section of the
001C12r 3                       ; manual for details.
001C12r 3                       ;
001C12r 3                       ; We should make this native compile for speed.
001C12r 3                       ; """
001C12r 3               
001C12r 3               xt_i:
001C12r 3  CA                           dex
001C13r 3  CA                           dex
001C14r 3               
001C14r 3                               ; Get the fudged index off of the top of the stack. It's
001C14r 3                               ; easier to do math on the stack directly than to pop and
001C14r 3                               ; push stuff around
001C14r 3  86 rr                        stx tmpdsp
001C16r 3  BA                           tsx
001C17r 3               
001C17r 3  38                           sec
001C18r 3  BD 01 01                     lda $0101,x     ; LSB
001C1Br 3  FD 03 01                     sbc $0103,x
001C1Er 3  A8                           tay
001C1Fr 3               
001C1Fr 3  BD 02 01                     lda $0102,x     ; MSB
001C22r 3  FD 04 01                     sbc $0104,x
001C25r 3               
001C25r 3  A6 rr                        ldx tmpdsp
001C27r 3               
001C27r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001C29r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001C2Br 3               
001C2Br 3  60           z_i:            rts
001C2Cr 3               
001C2Cr 3               
001C2Cr 3               
001C2Cr 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001C2Cr 3               ; ## "if"  auto  ANS core
001C2Cr 3                       ; """http://forth-standard.org/standard/core/IF"""
001C2Cr 3               
001C2Cr 3               xt_if:
001C2Cr 3                               ; Compile a 0BRANCH
001C2Cr 3  A0 rr                        ldy #>zero_branch_runtime
001C2Er 3  A9 rr                        lda #<zero_branch_runtime
001C30r 3  20 rr rr                     jsr cmpl_subroutine
001C33r 3               
001C33r 3                               ; Put the origination address on the stack for else/then
001C33r 3  20 rr rr                     jsr xt_here
001C36r 3               
001C36r 3                               ; Stuff zero in for the branch address right now.
001C36r 3                               ; THEN or ELSE will fix it later.
001C36r 3  20 rr rr                     jsr xt_zero
001C39r 3  20 rr rr                     jsr xt_comma
001C3Cr 3  60           z_if:           rts
001C3Dr 3               
001C3Dr 3               
001C3Dr 3               zero_branch_runtime:
001C3Dr 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001C3Dr 3                       ; included 0BRANCH as a high-level word that inserted this code at
001C3Dr 3                       ; runtime.
001C3Dr 3                       ; """
001C3Dr 3               
001C3Dr 3                               ; We use the return value on the 65c02 stack to determine
001C3Dr 3                               ; where we want to return to.
001C3Dr 3  68                           pla
001C3Er 3  85 rr                        sta tmpbranch
001C40r 3  68                           pla
001C41r 3  85 rr                        sta tmpbranch+1
001C43r 3               
001C43r 3                               ; See if the flag is zero, which is the whole purpose of
001C43r 3                               ; this all
001C43r 3  B5 00                        lda 0,x
001C45r 3  15 01                        ora 1,x
001C47r 3  F0 0F                        beq @zero
001C49r 3               
001C49r 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
001C49r 3                               ; the part between IF and THEN
001C49r 3  A5 rr                        lda tmpbranch   ; LSB
001C4Br 3  18                           clc
001C4Cr 3  69 02                        adc #2
001C4Er 3  85 rr                        sta tmp1
001C50r 3  A5 rr                        lda tmpbranch+1 ; MSB
001C52r 3  69 00                        adc #0          ; For carry
001C54r 3  85 rr                        sta tmp1+1
001C56r 3               
001C56r 3  80 13                        bra @done
001C58r 3               
001C58r 3               @zero:
001C58r 3                               ; Flag is FALSE (0) so we take the jump to the address given in
001C58r 3                               ; the next two bytes. However, the address points to the last
001C58r 3                               ; byte of the JSR instruction, not to the next byte afterwards
001C58r 3  A0 01                        ldy #1
001C5Ar 3  B1 rr                        lda (tmpbranch),y
001C5Cr 3  85 rr                        sta tmp1
001C5Er 3  C8                           iny
001C5Fr 3  B1 rr                        lda (tmpbranch),y
001C61r 3  85 rr                        sta tmp1+1
001C63r 3               
001C63r 3                               ; Now we have to subtract one byte from the address
001C63r 3                               ; given because of the way the 6502 calculates RTS
001C63r 3  A5 rr                        lda tmp1
001C65r 3  D0 02                        bne @1
001C67r 3  C6 rr                        dec tmp1+1
001C69r 3               @1:
001C69r 3  C6 rr                        dec tmp1
001C6Br 3               
001C6Br 3               @done:
001C6Br 3                               ; However we got here, tmp1 has the value we push to jump
001C6Br 3                               ; to
001C6Br 3  A5 rr                        lda tmp1+1
001C6Dr 3  48                           pha             ; MSB first
001C6Er 3  A5 rr                        lda tmp1
001C70r 3  48                           pha
001C71r 3               
001C71r 3                               ; clean up the stack and jump
001C71r 3  E8                           inx
001C72r 3  E8                           inx
001C73r 3               
001C73r 3  60                           rts
001C74r 3               
001C74r 3               
001C74r 3               
001C74r 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
001C74r 3               ; ## "immediate"  auto  ANS core
001C74r 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
001C74r 3                       ; Make sure the most recently defined word is immediate. Will only
001C74r 3                       ; affect the last word in the dictionary. Note that if the word is
001C74r 3                       ; defined in ROM, this will have no affect, but will not produce an
001C74r 3                       ; error message.
001C74r 3                       ; """
001C74r 3               xt_immediate:
001C74r 3  20 rr rr                     jsr current_to_dp
001C77r 3  A0 01                        ldy #1          ; offset for status byte
001C79r 3  B1 rr                        lda (dp),y
001C7Br 3  09 04                        ora #IM        ; make sure bit 7 is set
001C7Dr 3  91 rr                        sta (dp),y
001C7Fr 3               
001C7Fr 3  60           z_immediate:    rts
001C80r 3               
001C80r 3               
001C80r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001C80r 3               ; ## "input" tested Tali Forth
001C80r 3               
001C80r 3               xt_input:
001C80r 3  CA                           dex
001C81r 3  CA                           dex
001C82r 3  A9 rr                        lda #<input
001C84r 3  95 00                        sta 0,x
001C86r 3  A9 rr                        lda #>input
001C88r 3  95 01                        sta 1,x
001C8Ar 3               
001C8Ar 3  60           z_input:        rts
001C8Br 3               
001C8Br 3               
001C8Br 3               
001C8Br 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
001C8Br 3               ; ## "input>r"  tested  Tali Forth
001C8Br 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
001C8Br 3                       ; toin to the Return Stack. Used by EVALUTE.
001C8Br 3                       ;
001C8Br 3                       ; The naive way of doing
001C8Br 3                       ; this is to push each two-byte variable to the stack in the form of
001C8Br 3                       ;
001C8Br 3                       ;       lda insrc
001C8Br 3                       ;       pha
001C8Br 3                       ;       lda insrc+1
001C8Br 3                       ;       pha
001C8Br 3                       ;
001C8Br 3                       ; for a total of 24 byte of instruction in one direction and later
001C8Br 3                       ; a further 24 bytes to reverse the process. We shorten this at the
001C8Br 3                       ; cost of some speed by assuming the four variables are grouped
001C8Br 3                       ; together on the Zero Page and start with insrc (see definitions.asm
001C8Br 3                       ; for details). The reverse operation is r_to_input. These words must
001C8Br 3                       ; be flagged as Never Native. Uses tmp1
001C8Br 3                       ; """
001C8Br 3               
001C8Br 3               xt_input_to_r:
001C8Br 3                               ; We arrive here with the return address on the top of the
001C8Br 3                               ; 65c02's stack. We need to move it out of the way first
001C8Br 3  68                           pla
001C8Cr 3  85 rr                        sta tmp1
001C8Er 3  68                           pla
001C8Fr 3  85 rr                        sta tmp1+1
001C91r 3               
001C91r 3                               ; This assumes that insrc is the first of eight bytes and
001C91r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001C91r 3                               ; Page.
001C91r 3  A0 07                        ldy #7
001C93r 3               @loop:
001C93r 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
001C96r 3  48                           pha
001C97r 3  88                           dey
001C98r 3  10 F9                        bpl @loop
001C9Ar 3               
001C9Ar 3                               ; Restore address for return jump
001C9Ar 3  A5 rr                        lda tmp1+1
001C9Cr 3  48                           pha
001C9Dr 3  A5 rr                        lda tmp1
001C9Fr 3  48                           pha
001CA0r 3               
001CA0r 3  60           z_input_to_r: 	rts
001CA1r 3               
001CA1r 3               
001CA1r 3               
001CA1r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001CA1r 3               ; ## "int>name"  auto  Tali Forth
001CA1r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001CA1r 3                       ; This is called >NAME in Gforth, but we change it to
001CA1r 3                       ; INT>NAME to match NAME>INT
001CA1r 3                       ; """
001CA1r 3               
001CA1r 3               xt_int_to_name:
001CA1r 3  20 rr rr                     jsr underflow_1
001CA4r 3               
001CA4r 3                               ; Unfortunately, to find the header, we have to walk through
001CA4r 3                               ; all of the wordlists. We are running out of tmp variables.
001CA4r 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
001CA4r 3                               ; hold the current wordlist on the data stack. This searches
001CA4r 3                               ; all of the wordlists in id order.
001CA4r 3  CA                           dex
001CA5r 3  CA                           dex
001CA6r 3  74 00                        stz 0,x
001CA8r 3  74 01                        stz 1,x
001CAAr 3               
001CAAr 3               @wordlist_loop:
001CAAr 3                               ; A needs to have the current wordlist id in it at
001CAAr 3                               ; the top of this loop.
001CAAr 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001CACr 3               
001CACr 3                               ; Get the DP for that wordlist.
001CACr 3  0A                           asl                     ; Turn offset into cells offset.
001CADr 3  18                           clc
001CAEr 3  69 06                        adc #wordlists_offset
001CB0r 3  A8                           tay
001CB1r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
001CB3r 3  85 rr                        sta tmp2                ; into tmp2
001CB5r 3  C8                           iny
001CB6r 3  B1 rr                        lda (up),y
001CB8r 3  85 rr                        sta tmp2+1
001CBAr 3               
001CBAr 3                               ; Check for an empty wordlist (DP will be 0)
001CBAr 3  A5 rr                        lda tmp2
001CBCr 3  05 rr                        ora tmp2+1
001CBEr 3  F0 38                        beq @next_wordlist
001CC0r 3               
001CC0r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001CC2r 3  85 rr                        sta tmp3        ; Save target xt in tmp3
001CC4r 3  B5 03                        lda 3,x
001CC6r 3  85 rr                        sta tmp3+1
001CC8r 3               
001CC8r 3               @loop:
001CC8r 3  A0 04                        ldy #4          ; xt is four bytes down
001CCAr 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
001CCCr 3  C5 rr                        cmp tmp3
001CCEr 3  D0 07                        bne @no_match
001CD0r 3               
001CD0r 3                               ; LSB is the same, now check MSB
001CD0r 3  C8                           iny
001CD1r 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
001CD3r 3  C5 rr                        cmp tmp3+1
001CD5r 3  F0 32                        beq @match
001CD7r 3               
001CD7r 3               @no_match:
001CD7r 3                               ; no match, so we need to get the next word. Next nt is two
001CD7r 3                               ; bytes down
001CD7r 3  18                           clc
001CD8r 3  A5 rr                        lda tmp2
001CDAr 3  69 02                        adc #2
001CDCr 3  85 rr                        sta tmp2
001CDEr 3  A5 rr                        lda tmp2+1
001CE0r 3  69 00                        adc #0          ; only care about carry
001CE2r 3  85 rr                        sta tmp2+1
001CE4r 3               
001CE4r 3  A0 00                        ldy #0
001CE6r 3  B1 rr                        lda (tmp2),y
001CE8r 3  48                           pha
001CE9r 3  C8                           iny
001CEAr 3  11 rr                        ora (tmp2),y
001CECr 3  F0 09                        beq @zero
001CEEr 3               
001CEEr 3                               ; Not zero continue
001CEEr 3  B1 rr                        lda (tmp2),y
001CF0r 3  85 rr                        sta tmp2+1
001CF2r 3  68                           pla
001CF3r 3  85 rr                        sta tmp2
001CF5r 3  80 D1                        bra @loop
001CF7r 3               
001CF7r 3               @zero:
001CF7r 3                               ; if next word is zero, the xt has no nt in this wordlist
001CF7r 3  68                           pla             ; Leftover from above loop
001CF8r 3               
001CF8r 3               @next_wordlist:
001CF8r 3                               ; Move on to the next wordlist.
001CF8r 3  B5 00                        lda 0,x
001CFAr 3  1A                           inc
001CFBr 3  95 00                        sta 0,x
001CFDr 3  C9 0C                        cmp #max_wordlists
001CFFr 3  D0 A9                        bne @wordlist_loop
001D01r 3               
001D01r 3                               ; We didn't find it in any of the wordlists.
001D01r 3                               ; Remove the wordlist id from the stack.
001D01r 3  E8                           inx
001D02r 3  E8                           inx
001D03r 3               
001D03r 3                               ; We return a zero to indicate that we didn't find it.
001D03r 3  74 00                        stz 0,x
001D05r 3  74 01                        stz 1,x
001D07r 3  80 0A                        bra z_int_to_name
001D09r 3               
001D09r 3               @match:
001D09r 3                               ; We found it. Remove wordlist id from stack.
001D09r 3  E8                           inx
001D0Ar 3  E8                           inx
001D0Br 3               
001D0Br 3                               ; It's a match! Replace TOS with nt
001D0Br 3  A5 rr                        lda tmp2
001D0Dr 3  95 00                        sta 0,x
001D0Fr 3  A5 rr                        lda tmp2+1
001D11r 3  95 01                        sta 1,x
001D13r 3               
001D13r 3  60           z_int_to_name:  rts
001D14r 3               
001D14r 3               
001D14r 3               
001D14r 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001D14r 3               ; ## "invert"  auto  ANS core
001D14r 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001D14r 3               xt_invert:
001D14r 3  20 rr rr                     jsr underflow_1
001D17r 3               
001D17r 3  A9 FF                        lda #$FF
001D19r 3  55 00                        eor 0,x         ; LSB
001D1Br 3  95 00                        sta 0,x
001D1Dr 3               
001D1Dr 3  A9 FF                        lda #$FF
001D1Fr 3  55 01                        eor 1,x         ; MSB
001D21r 3  95 01                        sta 1,x
001D23r 3               
001D23r 3  60           z_invert:       rts
001D24r 3               
001D24r 3               
001D24r 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001D24r 3               ; ## "is"  auto  ANS core ext
001D24r 3                       ; """http://forth-standard.org/standard/core/IS"""
001D24r 3               
001D24r 3               xt_is:
001D24r 3                               ; This is a state aware word with differet behavior
001D24r 3                               ; when used while compiling vs interpreting.
001D24r 3                               ; Check STATE
001D24r 3  A5 rr                        lda state
001D26r 3  05 rr                        ora state+1
001D28r 3  F0 0C                        beq @interpreting
001D2Ar 3               
001D2Ar 3               @compiling:
001D2Ar 3                               ; Run ['] to compile the xt of the next word as a literal.
001D2Ar 3  20 rr rr                     jsr xt_bracket_tick
001D2Dr 3               
001D2Dr 3                               ; Postpone DEFER! by compiling a JSR to it.
001D2Dr 3  A0 rr                        ldy #>xt_defer_store
001D2Fr 3  A9 rr                        lda #<xt_defer_store
001D31r 3  20 rr rr                     jsr cmpl_subroutine
001D34r 3               
001D34r 3  80 06                        bra @done
001D36r 3               
001D36r 3               @interpreting:
001D36r 3  20 rr rr                     jsr xt_tick
001D39r 3  20 rr rr                     jsr xt_defer_store
001D3Cr 3               @done:
001D3Cr 3  60           z_is:           rts
001D3Dr 3               
001D3Dr 3               
001D3Dr 3               
001D3Dr 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001D3Dr 3               ; ## "j"  auto  ANS core
001D3Dr 3                       ; """https://forth-standard.org/standard/core/J
001D3Dr 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001D3Dr 3                       ; a fudge factor for loop control; see the Control Flow section of
001D3Dr 3                       ; the manual for more details.
001D3Dr 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001D3Dr 3                       ; on the stack above this (three entries), whereas the ideal Forth
001D3Dr 3                       ; implementation would just have two.
001D3Dr 3                       ;
001D3Dr 3                       ; Make this native compiled for speed
001D3Dr 3                       ; """
001D3Dr 3               
001D3Dr 3               xt_j:
001D3Dr 3  CA                           dex
001D3Er 3  CA                           dex
001D3Fr 3               
001D3Fr 3                               ; Get the fudged index off from the stack. It's easier to
001D3Fr 3                               ; do math on the stack directly than to pop and push stuff
001D3Fr 3                               ; around
001D3Fr 3  86 rr                        stx tmpdsp
001D41r 3  BA                           tsx
001D42r 3               
001D42r 3  38                           sec
001D43r 3  BD 07 01                     lda $0107,x     ; LSB
001D46r 3  FD 09 01                     sbc $0109,x
001D49r 3  A8                           tay
001D4Ar 3               
001D4Ar 3  BD 08 01                     lda $0108,x     ; MSB
001D4Dr 3  FD 0A 01                     sbc $010A,x
001D50r 3               
001D50r 3  A6 rr                        ldx tmpdsp
001D52r 3               
001D52r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001D54r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001D56r 3               
001D56r 3  60           z_j:            rts
001D57r 3               
001D57r 3               
001D57r 3               
001D57r 3               ; ## KEY ( -- char ) "Get one character from the input"
001D57r 3               ; ## "key"  tested  ANS core
001D57r 3               xt_key:
001D57r 3                       ; """https://forth-standard.org/standard/core/KEY
001D57r 3                       ; Get a single character of input from the vectored
001D57r 3                       ; input without echoing.
001D57r 3                       ; """
001D57r 3  20 rr rr                     jsr key_a               ; returns char in A
001D5Ar 3               
001D5Ar 3  CA                           dex
001D5Br 3  CA                           dex
001D5Cr 3  95 00                        sta 0,x
001D5Er 3  74 01                        stz 1,x
001D60r 3               
001D60r 3  60           z_key:          rts
001D61r 3               
001D61r 3               key_a:
001D61r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001D61r 3                       ; 65816, so we have to fake the indirect jump to vector it.
001D61r 3                       ; This is depressingly slow. We use this routine internally
001D61r 3                       ; to avoid manipulating the Data Stack when we just want a
001D61r 3                       ; character
001D61r 3  6C rr rr                     jmp (input)             ; JSR/RTS
001D64r 3               
001D64r 3               
001D64r 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
001D64r 3               ; ## "latestnt"  auto  Tali Forth
001D64r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001D64r 3                       ; The Gforth version of this word is called LATEST
001D64r 3                       ; """
001D64r 3               xt_latestnt:
001D64r 3  CA                           dex
001D65r 3  CA                           dex
001D66r 3               
001D66r 3  20 rr rr                     jsr current_to_dp
001D69r 3               
001D69r 3  A5 rr                        lda dp
001D6Br 3  95 00                        sta 0,x
001D6Dr 3  A5 rr                        lda dp+1
001D6Fr 3  95 01                        sta 1,x
001D71r 3               
001D71r 3  60           z_latestnt:     rts
001D72r 3               
001D72r 3               
001D72r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001D72r 3               ; ## "latestxt"  auto  Gforth
001D72r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001D72r 3               xt_latestxt:
001D72r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
001D75r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
001D78r 3               
001D78r 3  60           z_latestxt:     rts
001D79r 3               
001D79r 3               
001D79r 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
001D79r 3               ; ## "leave"  auto  ANS core
001D79r 3                       ; """https://forth-standard.org/standard/core/LEAVE
001D79r 3                       ; Note that this does not work with anything but a DO/LOOP in
001D79r 3                       ; contrast to other versions such as discussed at
001D79r 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
001D79r 3                       ;
001D79r 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
001D79r 3                       ; See the Control Flow section in the manual for details of how this works.
001D79r 3                       ; This must be native compile and not IMMEDIATE
001D79r 3                       ; """
001D79r 3               
001D79r 3               xt_leave:
001D79r 3                               ; We dump the limit/start entries off the Return Stack
001D79r 3                               ; (four bytes)
001D79r 3  68                           pla
001D7Ar 3  68                           pla
001D7Br 3  68                           pla
001D7Cr 3  68                           pla
001D7Dr 3               
001D7Dr 3  60                           rts             ; this must be compiled, so keep before z_leave
001D7Er 3               z_leave:                        ; not reached, not compiled
001D7Er 3               
001D7Er 3               
001D7Er 3               
001D7Er 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001D7Er 3               ; ## "["  auto  ANS core
001D7Er 3                       ; """https://forth-standard.org/standard/core/Bracket
001D7Er 3                       ; This is an immediate and compile-only word
001D7Er 3                       ; """
001D7Er 3               xt_left_bracket:
001D7Er 3  64 rr                        stz state
001D80r 3  64 rr                        stz state+1
001D82r 3               
001D82r 3  60           z_left_bracket: rts
001D83r 3               
001D83r 3               
001D83r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
001D83r 3               ; ## "<#"  auto  ANS core
001D83r 3                       ; """https://forth-standard.org/standard/core/num-start
001D83r 3                       ; Start the process to create pictured numeric output.
001D83r 3                       ;
001D83r 3                       ; The new
001D83r 3                       ; string is constructed from back to front, saving the new character
001D83r 3                       ; at the beginning of the output string. Since we use PAD as a
001D83r 3                       ; starting address and work backward (!), the string is constructed
001D83r 3                       ; in the space between the end of the Dictionary (as defined by CP)
001D83r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
001D83r 3                       ; programs don't fool around with the PAD but still use its address.
001D83r 3                       ; Based on pForth
001D83r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001D83r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
001D83r 3                       ; internal variable tohold instead of HLD.
001D83r 3                       ; """
001D83r 3               xt_less_number_sign:
001D83r 3  20 rr rr                     jsr xt_pad      ; ( addr )
001D86r 3               
001D86r 3  B5 00                        lda 0,x
001D88r 3  85 rr                        sta tohold
001D8Ar 3  B5 01                        lda 1,x
001D8Cr 3  85 rr                        sta tohold+1
001D8Er 3               
001D8Er 3  E8                           inx
001D8Fr 3  E8                           inx
001D90r 3               
001D90r 3               z_less_number_sign:
001D90r 3  60                           rts
001D91r 3               
001D91r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001D91r 3               ; ## "<"  auto  ANS core
001D91r 3                       ; """https://forth-standard.org/standard/core/less"""
001D91r 3               
001D91r 3               xt_less_than:
001D91r 3  20 rr rr                     jsr underflow_2
001D94r 3               
001D94r 3  A0 00                        ldy #0          ; default false
001D96r 3  20 rr rr                     jsr compare_16bit
001D99r 3               
001D99r 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
001D99r 3  F0 03                        beq @false
001D9Br 3  30 01                        bmi @false
001D9Dr 3               
001D9Dr 3                               ; true
001D9Dr 3  88                           dey
001D9Er 3               @false:
001D9Er 3  98                           tya
001D9Fr 3               
001D9Fr 3  E8                           inx
001DA0r 3  E8                           inx
001DA1r 3  95 00                        sta 0,x
001DA3r 3  95 01                        sta 1,x
001DA5r 3               
001DA5r 3  60           z_less_than:    rts
001DA6r 3               
001DA6r 3               
001DA6r 3               
001DA6r 3               ; ## LIST ( scr# -- ) "List the given screen"
001DA6r 3               ; ## "list"  tested  ANS block ext
001DA6r 3                       ; """https://forth-standard.org/standard/block/LIST"""
001DA6r 3               
001DA6r 3               xt_list:
001DA6r 3  20 rr rr                     jsr underflow_1
001DA9r 3               
001DA9r 3                               ; Save the screen number in SCR
001DA9r 3  20 rr rr                     jsr xt_scr
001DACr 3  20 rr rr                     jsr xt_store
001DAFr 3               
001DAFr 3                               ; Use L from the editor-wordlist to display the screen.
001DAFr 3  20 rr rr                     jsr xt_editor_l
001DB2r 3               
001DB2r 3  60           z_list:         rts
001DB3r 3               
001DB3r 3               
001DB3r 3               
001DB3r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001DB3r 3               ; ## "literal"  auto  ANS core
001DB3r 3                       ; """https://forth-standard.org/standard/core/LITERAL
001DB3r 3                       ; Compile-only word to store TOS so that it is pushed on stack
001DB3r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001DB3r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001DB3r 3                       ;
001DB3r 3                       ; Note the cmpl_ routines use TMPTOS
001DB3r 3                       ; """
001DB3r 3               xt_literal:
001DB3r 3  20 rr rr                     jsr underflow_1
001DB6r 3               
001DB6r 3  A0 rr                        ldy #>literal_runtime
001DB8r 3  A9 rr                        lda #<literal_runtime
001DBAr 3  20 rr rr                     jsr cmpl_subroutine
001DBDr 3               
001DBDr 3                               ; Compile the value that is to be pushed on the Stack during
001DBDr 3                               ; runtime
001DBDr 3  20 rr rr                     jsr xt_comma
001DC0r 3               
001DC0r 3  60           z_literal:      rts
001DC1r 3               
001DC1r 3               literal_runtime:
001DC1r 3               
001DC1r 3                               ; During runtime, we push the value following this word back
001DC1r 3                               ; on the Data Stack. The subroutine jump that brought us
001DC1r 3                               ; here put the address to return to on the Return Stack -
001DC1r 3                               ; this points to the data we need to get. This routine is
001DC1r 3                               ; also called (LITERAL) in some Forths
001DC1r 3  CA                           dex
001DC2r 3  CA                           dex
001DC3r 3               
001DC3r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001DC3r 3                               ; so we are actually popping the address-1 of the literal
001DC3r 3  68                           pla             ; LSB
001DC4r 3  85 rr                        sta tmp1
001DC6r 3  68                           pla             ; MSB
001DC7r 3  85 rr                        sta tmp1+1
001DC9r 3               
001DC9r 3                               ; Fetch the actual literal value and push it on Data stack
001DC9r 3  A0 01                        ldy #1
001DCBr 3  B1 rr                        lda (tmp1),y    ; LSB
001DCDr 3  95 00                        sta 0,x
001DCFr 3  C8                           iny
001DD0r 3  B1 rr                        lda (tmp1),y    ; MSB
001DD2r 3  95 01                        sta 1,x
001DD4r 3               
001DD4r 3                               ; Adjust return address and push back on the Return Stack
001DD4r 3  98                           tya
001DD5r 3  18                           clc
001DD6r 3  65 rr                        adc tmp1
001DD8r 3  A8                           tay
001DD9r 3  A5 rr                        lda tmp1+1
001DDBr 3  69 00                        adc #0
001DDDr 3  48                           pha
001DDEr 3  5A                           phy
001DDFr 3               
001DDFr 3  60                           rts
001DE0r 3               
001DE0r 3               
001DE0r 3               
001DE0r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
001DE0r 3               ; ## "load"  auto  ANS block
001DE0r 3                       ; """https://forth-standard.org/standard/block/LOAD
001DE0r 3                       ;
001DE0r 3                       ; Note: LOAD current works because there is only one buffer.
001DE0r 3                       ; If/when multiple buffers are supported, we'll have to deal
001DE0r 3                       ; with the fact that it might re-load the old block into a
001DE0r 3                       ; different buffer.
001DE0r 3                       ; """
001DE0r 3               
001DE0r 3               xt_load:
001DE0r 3  20 rr rr                     jsr underflow_1
001DE3r 3               
001DE3r 3                               ; Save the current value of BLK on the return stack.
001DE3r 3  A0 01                        ldy #blk_offset+1
001DE5r 3  B1 rr                        lda (up),y
001DE7r 3  48                           pha
001DE8r 3  88                           dey
001DE9r 3  B1 rr                        lda (up),y
001DEBr 3  48                           pha
001DECr 3               
001DECr 3                               ; Set BLK to the given block/screen number.
001DECr 3  B5 00                        lda 0,x
001DEEr 3  91 rr                        sta (up),y
001DF0r 3  C8                           iny
001DF1r 3  B5 01                        lda 1,x
001DF3r 3  91 rr                        sta (up),y
001DF5r 3               
001DF5r 3                               ; Load that block into a buffer
001DF5r 3  20 rr rr                     jsr xt_block
001DF8r 3               
001DF8r 3                               ; Put 1024 on the stack for the screen length.
001DF8r 3  CA                           dex
001DF9r 3  CA                           dex
001DFAr 3  A9 04                        lda #4
001DFCr 3  95 01                        sta 1,x
001DFEr 3  74 00                        stz 0,x
001E00r 3               
001E00r 3                               ; Jump to a special evluate target. This bypasses the underflow
001E00r 3                               ; check and skips the zeroing of BLK.
001E00r 3  20 rr rr                     jsr load_evaluate
001E03r 3               
001E03r 3                               ; Restore the value of BLK from before the LOAD command.
001E03r 3  A0 00                        ldy #blk_offset
001E05r 3  68                           pla
001E06r 3  91 rr                        sta (up),y
001E08r 3  C8                           iny
001E09r 3  68                           pla
001E0Ar 3  91 rr                        sta (up),y
001E0Cr 3               
001E0Cr 3                               ; If BLK is not zero, read it back into the buffer.
001E0Cr 3                               ; A still has MSB
001E0Cr 3  88                           dey
001E0Dr 3  11 rr                        ora (up),y
001E0Fr 3  F0 12                        beq @done
001E11r 3               
001E11r 3                               ; The block needs to be read back into the buffer.
001E11r 3  CA                           dex
001E12r 3  CA                           dex
001E13r 3  A0 00                        ldy #blk_offset
001E15r 3  B1 rr                        lda (up),y
001E17r 3  95 00                        sta 0,x
001E19r 3  C8                           iny
001E1Ar 3  B1 rr                        lda (up),y
001E1Cr 3  95 01                        sta 1,x
001E1Er 3  20 rr rr                     jsr xt_block
001E21r 3               
001E21r 3                               ; Drop the buffer address.
001E21r 3  E8                           inx
001E22r 3  E8                           inx
001E23r 3               
001E23r 3               @done:
001E23r 3  60           z_load:         rts
001E24r 3               
001E24r 3               
001E24r 3               
001E24r 3               ; ## LOOP ( -- ) "Finish loop construct"
001E24r 3               ; ## "loop"  auto  ANS core
001E24r 3                       ; """https://forth-standard.org/standard/core/LOOP
001E24r 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001E24r 3                       ; the stack and then call +LOOP.
001E24r 3                       ;
001E24r 3                       ; In Forth, this is
001E24r 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001E24r 3                       ;       IMMEDIATE ; COMPILE-ONLY
001E24r 3                       ; """
001E24r 3               xt_loop:
001E24r 3                               ; Have the finished word push 1 on the stack
001E24r 3  A0 rr                        ldy #>xt_one
001E26r 3  A9 rr                        lda #<xt_one
001E28r 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
001E2Br 3               
001E2Br 3               
001E2Br 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
001E2Br 3               ; ## "+loop"  auto  ANS core
001E2Br 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
001E2Br 3                       ;
001E2Br 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
001E2Br 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
001E2Br 3                       ;       COMPILE-ONLY
001E2Br 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
001E2Br 3                       ; address for looping as TOS and the address for aborting the loop
001E2Br 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
001E2Br 3                       ; DO and the Control Flow section of the manual for details).
001E2Br 3                       ; """
001E2Br 3               
001E2Br 3               xt_plus_loop:
001E2Br 3                               ; Compile the run-time part. We do this with a short loop
001E2Br 3                               ; and not a call to COMPILE, because it has to be natively
001E2Br 3                               ; coded anyway.
001E2Br 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
001E2Dr 3  5A                           phy             ; save counter to adjust CP
001E2Er 3               @1:
001E2Er 3  B9 rr rr                     lda plus_loop_runtime,y
001E31r 3  91 rr                        sta (cp),y
001E33r 3  88                           dey
001E34r 3  10 F8                        bpl @1
001E36r 3               
001E36r 3                               ; Adjust CP
001E36r 3  68                           pla
001E37r 3  18                           clc
001E38r 3  65 rr                        adc cp
001E3Ar 3  85 rr                        sta cp
001E3Cr 3  A5 rr                        lda cp+1
001E3Er 3  69 00                        adc #0          ; only need carry
001E40r 3  85 rr                        sta cp+1
001E42r 3               
001E42r 3                               ; The address we need to loop back to is TOS. Store it so
001E42r 3                               ; the runtime part of +LOOP jumps back up there
001E42r 3  20 rr rr                     jsr xt_comma
001E45r 3               
001E45r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001E45r 3                               ; of six PLA, so we just do it here instead jumping around
001E45r 3                               ; all over the place
001E45r 3  A9 68                        lda #$68                ; opcode for PLA
001E47r 3  A0 06                        ldy #6
001E49r 3               @2:
001E49r 3  91 rr                        sta (cp),y
001E4Br 3  88                           dey
001E4Cr 3  10 FB                        bpl @2
001E4Er 3               
001E4Er 3                               ; Adjust CP
001E4Er 3  A9 06                        lda #6
001E50r 3  18                           clc
001E51r 3  65 rr                        adc cp
001E53r 3  85 rr                        sta cp
001E55r 3  A5 rr                        lda cp+1
001E57r 3  69 00                        adc #0                  ; only need carry
001E59r 3  85 rr                        sta cp+1
001E5Br 3               
001E5Br 3                               ; Complete compile of DO/?DO by replacing the six
001E5Br 3                               ; dummy bytes by PHA instructions. The address where
001E5Br 3                               ; they are located is on the Data Stack
001E5Br 3  B5 00                        lda 0,x
001E5Dr 3  85 rr                        sta tmp1
001E5Fr 3  B5 01                        lda 1,x
001E61r 3  85 rr                        sta tmp1+1
001E63r 3  E8                           inx
001E64r 3  E8                           inx
001E65r 3               
001E65r 3                               ; Because of the way that CP works, we don't have to save
001E65r 3                               ; CP, but CP-1
001E65r 3  A5 rr                        lda cp
001E67r 3  38                           sec
001E68r 3  E9 01                        sbc #1
001E6Ar 3  85 rr                        sta tmp2
001E6Cr 3  A5 rr                        lda cp+1
001E6Er 3  E9 00                        sbc #0
001E70r 3  85 rr                        sta tmp2+1
001E72r 3               
001E72r 3                               ; now compile this in the DO/?DO routine
001E72r 3  A0 00                        ldy #0
001E74r 3               
001E74r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001E76r 3  91 rr                        sta (tmp1),y
001E78r 3  C8                           iny
001E79r 3  A5 rr                        lda tmp2+1      ; MSB
001E7Br 3  91 rr                        sta (tmp1),y
001E7Dr 3  C8                           iny
001E7Er 3  A9 48                        lda #$48        ; Opcode for PHA
001E80r 3  91 rr                        sta (tmp1),y
001E82r 3  C8                           iny
001E83r 3               
001E83r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001E85r 3  91 rr                        sta (tmp1),y
001E87r 3  C8                           iny
001E88r 3  A5 rr                        lda tmp2        ; LSB
001E8Ar 3  91 rr                        sta (tmp1),y
001E8Cr 3  C8                           iny
001E8Dr 3  A9 48                        lda #$48        ; Opcode for PHA
001E8Fr 3  91 rr                        sta (tmp1),y
001E91r 3               z_loop:
001E91r 3  60           z_plus_loop:    rts
001E92r 3               
001E92r 3               
001E92r 3               plus_loop_runtime:
001E92r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001E92r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001E92r 3                       ; loop control so we can test with the Overflow Flag. See
001E92r 3                       ; the Control Flow section of the manual for details.
001E92r 3                       ; The step value is TOS in the loop. This
001E92r 3                       ; must always be native compiled. In some Forths, this is a separate
001E92r 3                       ; word called (+LOOP) or (LOOP)
001E92r 3                       ; """
001E92r 3               
001E92r 3  18                           clc
001E93r 3  68                           pla             ; LSB of index
001E94r 3  75 00                        adc 0,x         ; LSB of step
001E96r 3  A8                           tay             ; temporary storage of LSB
001E97r 3               
001E97r 3  B8                           clv
001E98r 3  68                           pla             ; MSB of index
001E99r 3  75 01                        adc 1,x         ; MSB of step
001E9Br 3  48                           pha             ; put MSB of index back on stack
001E9Cr 3               
001E9Cr 3  98                           tya             ; put LSB of index back on stack
001E9Dr 3  48                           pha
001E9Er 3               
001E9Er 3  E8                           inx             ; dump step from TOS
001E9Fr 3  E8                           inx
001EA0r 3               
001EA0r 3                               ; If V flag is set, we're done looping and continue
001EA0r 3                               ; after the +LOOP instruction
001EA0r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001EA2r 3               
001EA2r 3               @hack:          ; This is why this routine must be natively compiled: We
001EA2r 3                               ; compile the opcode for JMP here without an address to
001EA2r 3                               ; go to, which is added by the next next instruction of
001EA2r 3                               ; LOOP/+LOOP during compile time
001EA2r 3  4C                           .byte $4C
001EA3r 3               
001EA3r 3               plus_loop_runtime_end:
001EA3r 3               
001EA3r 3               
001EA3r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001EA3r 3               ; ## "lshift"  auto  ANS core
001EA3r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001EA3r 3               
001EA3r 3               xt_lshift:
001EA3r 3  20 rr rr                     jsr underflow_2
001EA6r 3               
001EA6r 3                               ; max shift 16 times
001EA6r 3  B5 00                        lda 0,x
001EA8r 3  29 0F                        and #%00001111
001EAAr 3  F0 08                        beq @done
001EACr 3               
001EACr 3  A8                           tay
001EADr 3               
001EADr 3               @loop:
001EADr 3  16 02                        asl 2,x
001EAFr 3  36 03                        rol 3,x
001EB1r 3  88                           dey
001EB2r 3  D0 F9                        bne @loop
001EB4r 3               
001EB4r 3               @done:
001EB4r 3  E8                           inx
001EB5r 3  E8                           inx
001EB6r 3               
001EB6r 3  60           z_lshift:       rts
001EB7r 3               
001EB7r 3               
001EB7r 3               
001EB7r 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001EB7r 3               ; ## "m*"  auto  ANS core
001EB7r 3                       ; """https://forth-standard.org/standard/core/MTimes
001EB7r 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001EB7r 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001EB7r 3                       ;
001EB7r 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001EB7r 3                       ; with  : D+- O< IF DNEGATE THEN ;
001EB7r 3                       ; """
001EB7r 3               
001EB7r 3               xt_m_star:
001EB7r 3  20 rr rr                     jsr underflow_2
001EBAr 3               
001EBAr 3                               ; figure out the sign
001EBAr 3  B5 01                        lda 1,x         ; MSB of n1
001EBCr 3  55 03                        eor 3,x         ; MSB of n2
001EBEr 3               
001EBEr 3                               ; UM* uses all kinds of temporary variables so we don't
001EBEr 3                               ; risk a conflict but just take the cycle hit and push
001EBEr 3                               ; this to the stack
001EBEr 3  48                           pha
001EBFr 3               
001EBFr 3                               ; get the absolute value of both numbers so we can feed
001EBFr 3                               ; them to UM*, which does the real work
001EBFr 3  20 rr rr                     jsr xt_abs
001EC2r 3  20 rr rr                     jsr xt_swap
001EC5r 3  20 rr rr                     jsr xt_abs
001EC8r 3               
001EC8r 3  20 rr rr                     jsr xt_um_star          ; ( d )
001ECBr 3               
001ECBr 3                               ; handle the sign
001ECBr 3  68                           pla
001ECCr 3  10 03                        bpl @done
001ECEr 3               
001ECEr 3  20 rr rr                     jsr xt_dnegate
001ED1r 3               @done:
001ED1r 3  60           z_m_star:       rts
001ED2r 3               
001ED2r 3               
001ED2r 3               
001ED2r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001ED2r 3               ; ## "marker"  auto  ANS core ext
001ED2r 3                       ; """https://forth-standard.org/standard/core/MARKER
001ED2r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001ED2r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001ED2r 3                       ; Run the named word at a later time to restore all of the wordlists
001ED2r 3                       ; to their state when the word was created with marker.  Any words
001ED2r 3                       ; created after the marker (including the marker) will be forgotten.
001ED2r 3                       ;
001ED2r 3                       ; To do this, we want to end up with something that jumps to a
001ED2r 3                       ; run-time component with a link to the original CP and DP values:
001ED2r 3                       ;
001ED2r 3                       ;       jsr marker_runtime
001ED2r 3                       ;       <Original CP MSB>
001ED2r 3                       ;       <Original CP LSB>
001ED2r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001ED2r 3                       ;       <Original DP LSB>
001ED2r 3                       ;       < USER variables from offset 4 to 39 >
001ED2r 3                       ;
001ED2r 3                       ;       The user variables include:
001ED2r 3                       ;       CURRENT (byte variable)
001ED2r 3                       ;       <All wordlists> (currently 12) (cell array)
001ED2r 3                       ;       <#ORDER> (byte variable)
001ED2r 3                       ;       <All search order> (currently 9) (byte array)
001ED2r 3                       ;
001ED2r 3                       ; This code uses tmp1 and tmp2
001ED2r 3                       ; """
001ED2r 3               
001ED2r 3               xt_marker:
001ED2r 3                               ; Before we do anything, we need to save CP, which
001ED2r 3                               ; after all is the whole point of this operation. CREATE
001ED2r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001ED2r 3                               ; to the stack
001ED2r 3  20 rr rr                     jsr current_to_dp
001ED5r 3               
001ED5r 3  A5 rr                        lda dp
001ED7r 3  48                           pha
001ED8r 3  A5 rr                        lda dp+1
001EDAr 3  48                           pha
001EDBr 3               
001EDBr 3  A5 rr                        lda cp
001EDDr 3  48                           pha
001EDEr 3  A5 rr                        lda cp+1
001EE0r 3  48                           pha
001EE1r 3               
001EE1r 3  20 rr rr                     jsr xt_create
001EE4r 3               
001EE4r 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001EE4r 3                               ; we have to replace by a jump to marker_runtime. We back up
001EE4r 3                               ; two bytes and then overwrite the address
001EE4r 3  A5 rr                        lda cp          ; LSB
001EE6r 3  38                           sec
001EE7r 3  E9 02                        sbc #2
001EE9r 3  85 rr                        sta cp
001EEBr 3               
001EEBr 3  A5 rr                        lda cp+1        ; MSB
001EEDr 3  E9 00                        sbc #0          ; we only care about the borrow
001EEFr 3  85 rr                        sta cp+1
001EF1r 3               
001EF1r 3                               ; Add the address of the runtime component
001EF1r 3  A0 rr                        ldy #>marker_runtime
001EF3r 3  A9 rr                        lda #<marker_runtime
001EF5r 3  20 rr rr                     jsr cmpl_word
001EF8r 3               
001EF8r 3                               ; Add original CP as payload
001EF8r 3  7A                           ply                     ; MSB
001EF9r 3  68                           pla                     ; LSB
001EFAr 3  20 rr rr                     jsr cmpl_word
001EFDr 3               
001EFDr 3                               ; Add original DP as payload
001EFDr 3  7A                           ply                     ; MSB
001EFEr 3  68                           pla                     ; LSB
001EFFr 3  20 rr rr                     jsr cmpl_word
001F02r 3               
001F02r 3                               ; Add the user variables for the wordlists and search order.
001F02r 3                               ; We're compiling them in byte order.
001F02r 3  A0 04                        ldy #4                  ; Start at CURRENT
001F04r 3               @marker_loop:
001F04r 3  B1 rr                        lda (up),y
001F06r 3  20 rr rr                     jsr cmpl_a
001F09r 3  C8                           iny
001F0Ar 3  98                           tya
001F0Br 3  C9 28                        cmp #40                 ; One past the end of the search order.
001F0Dr 3  D0 F5                        bne @marker_loop
001F0Fr 3               
001F0Fr 3  60           z_marker:       rts
001F10r 3               
001F10r 3               
001F10r 3               
001F10r 3               marker_runtime:
001F10r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
001F10r 3                       ; when this marker was defined. We arrive here with the return
001F10r 3                       ; address on the Return Stack in the usual 65c02 format
001F10r 3                       ; """
001F10r 3               
001F10r 3                               ; Get the address of the string address off the stack and
001F10r 3                               ; increase by one because of the RTS mechanics
001F10r 3  68                           pla
001F11r 3  85 rr                        sta tmp1        ; LSB of address
001F13r 3  68                           pla
001F14r 3  85 rr                        sta tmp1+1      ; MSB of address
001F16r 3               
001F16r 3  E6 rr                        inc tmp1
001F18r 3  D0 02                        bne @1
001F1Ar 3  E6 rr                        inc tmp1+1
001F1Cr 3               @1:
001F1Cr 3  A0 00                        ldy #0
001F1Er 3               
001F1Er 3                               ; CP was stored first
001F1Er 3  B1 rr                        lda (tmp1),y
001F20r 3  85 rr                        sta cp
001F22r 3  C8                           iny
001F23r 3  B1 rr                        lda (tmp1),y
001F25r 3  85 rr                        sta cp+1
001F27r 3               
001F27r 3                               ; Next was DP
001F27r 3  C8                           iny
001F28r 3  B1 rr                        lda (tmp1),y
001F2Ar 3  85 rr                        sta dp
001F2Cr 3  C8                           iny
001F2Dr 3  B1 rr                        lda (tmp1),y
001F2Fr 3  85 rr                        sta dp+1
001F31r 3               
001F31r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001F31r 3                               ; to start restoring the wordlists and search order.
001F31r 3  A0 04                        ldy #4
001F33r 3               
001F33r 3               @marker_restore_loop:
001F33r 3                               ; Copy from the dictionary back on top of the wordlists
001F33r 3                               ; and search order.
001F33r 3  B1 rr                        lda (tmp1), y
001F35r 3  91 rr                        sta (up), y
001F37r 3  C8                           iny
001F38r 3  98                           tya
001F39r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001F3Br 3  D0 F6                        bne @marker_restore_loop
001F3Dr 3               
001F3Dr 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001F40r 3               
001F40r 3                               ; The return instruction takes us back to the original caller
001F40r 3  60                           rts
001F41r 3               
001F41r 3               
001F41r 3               
001F41r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001F41r 3               ; ## "max"  auto  ANS core
001F41r 3                       ; """https://forth-standard.org/standard/core/MAX
001F41r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001F41r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001F41r 3                       ; Flag indicates which number is larger. See also
001F41r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001F41r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001F41r 3                       ; """
001F41r 3               
001F41r 3               xt_max:
001F41r 3  20 rr rr                     jsr underflow_2
001F44r 3               
001F44r 3                               ; Compare LSB. We do this first to set the carry flag
001F44r 3  B5 00                        lda 0,x         ; LSB of TOS
001F46r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001F48r 3               
001F48r 3  B5 01                        lda 1,x         ; MSB of TOS
001F4Ar 3  F5 03                        sbc 3,x         ; MSB of NOS
001F4Cr 3  50 02                        bvc @no_overflow
001F4Er 3               
001F4Er 3                               ; handle overflow, because we use signed numbers
001F4Er 3  49 80                        eor #$80        ; complement negative flag
001F50r 3               
001F50r 3               @no_overflow:
001F50r 3                               ; if negative, NOS is larger and needs to be kept
001F50r 3  30 08                        bmi @keep_nos
001F52r 3               
001F52r 3                               ; move TOS to NOS
001F52r 3  B5 00                        lda 0,x
001F54r 3  95 02                        sta 2,x
001F56r 3  B5 01                        lda 1,x
001F58r 3  95 03                        sta 3,x
001F5Ar 3               
001F5Ar 3               @keep_nos:
001F5Ar 3  E8                           inx
001F5Br 3  E8                           inx
001F5Cr 3               
001F5Cr 3  60           z_max:          rts
001F5Dr 3               
001F5Dr 3               
001F5Dr 3               
001F5Dr 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001F5Dr 3               ; ## "min"  auto  ANS core
001F5Dr 3                       ; """https://forth-standard.org/standard/core/MIN
001F5Dr 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001F5Dr 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001F5Dr 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001F5Dr 3                       ; """
001F5Dr 3               
001F5Dr 3               xt_min:
001F5Dr 3  20 rr rr                     jsr underflow_2
001F60r 3               
001F60r 3                               ; compare LSB. We do this first to set the carry flag
001F60r 3  B5 00                        lda 0,x         ; LSB of TOS
001F62r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001F64r 3               
001F64r 3  B5 01                        lda 1,x         ; MSB of TOS
001F66r 3  F5 03                        sbc 3,x         ; MSB of NOS
001F68r 3  50 02                        bvc @no_overflow
001F6Ar 3               
001F6Ar 3                               ; handle overflow because we use signed numbers
001F6Ar 3  49 80                        eor #$80
001F6Cr 3               
001F6Cr 3               @no_overflow:
001F6Cr 3                               ; if negative, NOS is larger and needs to be dumped
001F6Cr 3  10 08                        bpl @keep_nos
001F6Er 3               
001F6Er 3                               ; move TOS to NOS
001F6Er 3  B5 00                        lda 0,x
001F70r 3  95 02                        sta 2,x
001F72r 3  B5 01                        lda 1,x
001F74r 3  95 03                        sta 3,x
001F76r 3               
001F76r 3               @keep_nos:
001F76r 3  E8                           inx
001F77r 3  E8                           inx
001F78r 3               
001F78r 3  60           z_min:          rts
001F79r 3               
001F79r 3               
001F79r 3               
001F79r 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001F79r 3               ; ## "-"  auto  ANS core
001F79r 3                       ; """https://forth-standard.org/standard/core/Minus"""
001F79r 3               xt_minus:
001F79r 3  20 rr rr                     jsr underflow_2
001F7Cr 3               
001F7Cr 3  38                           sec
001F7Dr 3  B5 02                        lda 2,x         ; LSB
001F7Fr 3  F5 00                        sbc 0,x
001F81r 3  95 02                        sta 2,x
001F83r 3               
001F83r 3  B5 03                        lda 3,x         ; MSB
001F85r 3  F5 01                        sbc 1,x
001F87r 3  95 03                        sta 3,x
001F89r 3               
001F89r 3  E8                           inx
001F8Ar 3  E8                           inx
001F8Br 3               
001F8Br 3  60           z_minus:        rts
001F8Cr 3               
001F8Cr 3               
001F8Cr 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001F8Cr 3               ; ## "-leading"  auto  Tali String
001F8Cr 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001F8Cr 3                       ; """
001F8Cr 3               
001F8Cr 3               xt_minus_leading:
001F8Cr 3  20 rr rr                     jsr underflow_2
001F8Fr 3               
001F8Fr 3               @loop:
001F8Fr 3                               ; Quit if we were given an empty string. This also terminates
001F8Fr 3                               ; the main loop
001F8Fr 3  B5 00                        lda 0,x
001F91r 3  15 01                        ora 1,x
001F93r 3  F0 0F                        beq @done
001F95r 3               
001F95r 3  A1 02                        lda (2,x)               ; get first character
001F97r 3  20 rr rr                     jsr is_whitespace
001F9Ar 3  90 08                        bcc @done
001F9Cr 3               
001F9Cr 3                               ; It's whitespace, move one down
001F9Cr 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001F9Fr 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001FA2r 3               
001FA2r 3  80 EB                        bra @loop
001FA4r 3               @done:
001FA4r 3               z_minus_leading:
001FA4r 3  60                           rts
001FA5r 3               
001FA5r 3               
001FA5r 3               
001FA5r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001FA5r 3               ; ## "-trailing"  auto  ANS string
001FA5r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001FA5r 3                       ; Remove trailing spaces
001FA5r 3                       ; """
001FA5r 3               
001FA5r 3               xt_minus_trailing:
001FA5r 3  20 rr rr                     jsr underflow_2
001FA8r 3               
001FA8r 3                               ; if length entry is zero, return a zero and leave the
001FA8r 3                               ; address part untouched
001FA8r 3  B5 00                        lda 0,x         ; LSB of n
001FAAr 3  15 01                        ora 1,x         ; MSB of n
001FACr 3  F0 33                        beq @done
001FAEr 3               
001FAEr 3                               ; Compute address of last char in tmp1 as
001FAEr 3                               ; addr + u1 - 1
001FAEr 3               
001FAEr 3                               ; addr + u1
001FAEr 3  18                           clc
001FAFr 3  B5 02                        lda 2,x         ; LSB of addr
001FB1r 3  75 00                        adc 0,x
001FB3r 3  85 rr                        sta tmp1
001FB5r 3  B5 03                        lda 3,x         ; MSB of addr
001FB7r 3  75 01                        adc 1,x
001FB9r 3  85 rr                        sta tmp1+1
001FBBr 3               
001FBBr 3                               ; - 1
001FBBr 3  A5 rr                        lda tmp1
001FBDr 3  D0 02                        bne @1
001FBFr 3  C6 rr                        dec tmp1+1
001FC1r 3               @1:
001FC1r 3  C6 rr                        dec tmp1
001FC3r 3               
001FC3r 3               @loop:
001FC3r 3                               ; While spaces are found, move tmp1 backwards and
001FC3r 3                               ; decrease the count on the data stack.
001FC3r 3  B2 rr                        lda (tmp1)
001FC5r 3  C9 20                        cmp #AscSP
001FC7r 3  D0 18                        bne @done
001FC9r 3               
001FC9r 3                               ; Move back one address.
001FC9r 3  A5 rr                        lda tmp1
001FCBr 3  D0 02                        bne @2
001FCDr 3  C6 rr                        dec tmp1+1
001FCFr 3               @2:
001FCFr 3  C6 rr                        dec tmp1
001FD1r 3               
001FD1r 3                               ; Decrement count by one.
001FD1r 3  B5 00                        lda 0,x
001FD3r 3  D0 02                        bne @3
001FD5r 3  D6 01                        dec 1,x
001FD7r 3               @3:
001FD7r 3  D6 00                        dec 0,x
001FD9r 3               
001FD9r 3                               ; Check if there are any characters left.
001FD9r 3  B5 00                        lda 0,x
001FDBr 3  15 01                        ora 1,x
001FDDr 3  F0 02                        beq @done       ; Count has reached zero - we're done!
001FDFr 3               
001FDFr 3  80 E2                        bra @loop
001FE1r 3               
001FE1r 3               @done:
001FE1r 3               z_minus_trailing:
001FE1r 3  60                           rts
001FE2r 3               
001FE2r 3               
001FE2r 3               
001FE2r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001FE2r 3               ; ## "mod"  auto  ANS core
001FE2r 3                       ; """https://forth-standard.org/standard/core/MOD
001FE2r 3                       ;
001FE2r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001FE2r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001FE2r 3                       ; """
001FE2r 3               xt_mod:
001FE2r 3  20 rr rr                     jsr underflow_2
001FE5r 3               
001FE5r 3  20 rr rr                     jsr xt_slash_mod
001FE8r 3               
001FE8r 3  E8                           inx             ; DROP
001FE9r 3  E8                           inx
001FEAr 3               z_mod:
001FEAr 3  60                           rts
001FEBr 3               
001FEBr 3               
001FEBr 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
001FEBr 3               ; ## "move"  auto  ANS core
001FEBr 3                       ; """https://forth-standard.org/standard/core/MOVE
001FEBr 3                       ; Copy u "address units" from addr1 to addr2. Since our address
001FEBr 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
001FEBr 3                       ; is actually the only one of these three words that is in the CORE
001FEBr 3                       ; set.
001FEBr 3                       ;
001FEBr 3                       ; This word must not be natively compiled.
001FEBr 3                       ; """
001FEBr 3               
001FEBr 3               xt_move:
001FEBr 3                               ; We let CMOVE and CMOVE> check if there is underflow or
001FEBr 3                               ; we've been told to copy zero bytes
001FEBr 3               
001FEBr 3                               ; compare MSB first
001FEBr 3  B5 03                        lda 3,x                 ; MSB of addr2
001FEDr 3  D5 05                        cmp 5,x                 ; MSB of addr1
001FEFr 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001FF1r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001FF3r 3               
001FF3r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001FF6r 3               
001FF6r 3               @lsb:
001FF6r 3                               ; MSB were equal, so do the whole thing over with LSB
001FF6r 3  B5 02                        lda 2,x                 ; LSB of addr2
001FF8r 3  D5 04                        cmp 4,x                 ; LSB of addr1
001FFAr 3  F0 08                        beq @equal              ; LSB is equal as well
001FFCr 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
001FFEr 3               
001FFEr 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
002001r 3               
002001r 3               @to_move_up:
002001r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
002004r 3               @equal:
002004r 3                               ; drop three entries from Data Stack
002004r 3  8A                           txa
002005r 3  18                           clc
002006r 3  69 06                        adc #6
002008r 3  AA                           tax
002009r 3               
002009r 3  60           z_move:         rts
00200Ar 3               
00200Ar 3               
00200Ar 3               
00200Ar 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
00200Ar 3               ; ## "name>int"  tested  Gforth
00200Ar 3                       ; """See
00200Ar 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00200Ar 3                       ; """
00200Ar 3               
00200Ar 3               xt_name_to_int:
00200Ar 3  20 rr rr                     jsr underflow_1
00200Dr 3               
00200Dr 3                               ; The xt starts four bytes down from the nt
00200Dr 3  B5 00                        lda 0,x
00200Fr 3  18                           clc
002010r 3  69 04                        adc #4
002012r 3  85 rr                        sta tmp3
002014r 3               
002014r 3  B5 01                        lda 1,x
002016r 3  90 01                        bcc @done
002018r 3  1A                           inc
002019r 3               @done:
002019r 3  85 rr                        sta tmp3+1
00201Br 3               
00201Br 3  A0 00                        ldy #0
00201Dr 3  B1 rr                        lda (tmp3),y
00201Fr 3  95 00                        sta 0,x
002021r 3  C8                           iny
002022r 3  B1 rr                        lda (tmp3),y
002024r 3  95 01                        sta 1,x
002026r 3               
002026r 3  60           z_name_to_int:  rts
002027r 3               
002027r 3               
002027r 3               
002027r 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
002027r 3               ; ## "name>string"  tested  Gforth
002027r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
002027r 3               
002027r 3               xt_name_to_string:
002027r 3  20 rr rr                     jsr underflow_1
00202Ar 3               
00202Ar 3  CA                           dex
00202Br 3  CA                           dex
00202Cr 3               
00202Cr 3                               ; the length of the string is the first byte of the
00202Cr 3                               ; header pointed to by nt
00202Cr 3  A1 02                        lda (2,x)
00202Er 3  95 00                        sta 0,x
002030r 3  74 01                        stz 1,x
002032r 3               
002032r 3                               ; the string itself always starts eight bytes down
002032r 3  B5 02                        lda 2,x         ; LSB
002034r 3  18                           clc
002035r 3  69 08                        adc #8
002037r 3  A8                           tay
002038r 3  B5 03                        lda 3,x         ; MSB
00203Ar 3  69 00                        adc #0          ; just need carry
00203Cr 3  95 03                        sta 3,x
00203Er 3  94 02                        sty 2,x
002040r 3               
002040r 3               z_name_to_string:
002040r 3  60                           rts
002041r 3               
002041r 3               
002041r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
002041r 3               ; ## "nc-limit"  tested  Tali Forth
002041r 3               
002041r 3               xt_nc_limit:
002041r 3  CA                           dex
002042r 3  CA                           dex
002043r 3  A9 rr                        lda #<nc_limit
002045r 3  95 00                        sta 0,x
002047r 3  A9 rr                        lda #>nc_limit
002049r 3  95 01                        sta 1,x
00204Br 3               
00204Br 3  60           z_nc_limit:     rts
00204Cr 3               
00204Cr 3               
00204Cr 3               
00204Cr 3               ; ## NEGATE ( n -- n ) "Two's complement"
00204Cr 3               ; ## "negate"  auto  ANS core
00204Cr 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
00204Cr 3               xt_negate:
00204Cr 3  20 rr rr                     jsr underflow_1
00204Fr 3               
00204Fr 3  A9 00                	lda #0
002051r 3  38                           sec
002052r 3  F5 00                        sbc 0,x         ; LSB
002054r 3  95 00                        sta 0,x
002056r 3               
002056r 3  A9 00                        lda #0
002058r 3  F5 01                        sbc 1,x         ; MSB
00205Ar 3  95 01                        sta 1,x
00205Cr 3               
00205Cr 3  60           z_negate:       rts
00205Dr 3               
00205Dr 3               
00205Dr 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
00205Dr 3               ; ## "never-native"  auto  Tali Forth
00205Dr 3               xt_never_native:
00205Dr 3  20 rr rr                     jsr current_to_dp
002060r 3  A0 01                        ldy #1          ; offset for status byte
002062r 3  B1 rr                        lda (dp),y
002064r 3  09 08                        ora #NN         ; Make sure NN flag is set
002066r 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
002068r 3  91 rr                        sta (dp),y
00206Ar 3               z_never_native:
00206Ar 3  60                           rts
00206Br 3               
00206Br 3               
00206Br 3               ; ## NIP ( b a -- a ) "Delete NOS"
00206Br 3               ; ## "nip"  auto  ANS core ext
00206Br 3                       ; """https://forth-standard.org/standard/core/NIP"""
00206Br 3               xt_nip:
00206Br 3  20 rr rr                     jsr underflow_2
00206Er 3               
00206Er 3  B5 00                        lda 0,x         ; LSB
002070r 3  95 02                        sta 2,x
002072r 3  B5 01                        lda 1,x         ; MSB
002074r 3  95 03                        sta 3,x
002076r 3               
002076r 3  E8                           inx
002077r 3  E8                           inx
002078r 3               
002078r 3  60           z_nip:          rts
002079r 3               
002079r 3               
002079r 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
002079r 3               ; ## "<>"  auto  ANS core ext
002079r 3                       ; """https://forth-standard.org/standard/core/ne
002079r 3                       ;
002079r 3                       ; This is just a variant of EQUAL, we code it separately
002079r 3                       ; for speed.
002079r 3                       ; """
002079r 3               
002079r 3               xt_not_equals:
002079r 3  20 rr rr                     jsr underflow_2
00207Cr 3               
00207Cr 3  A0 00                        ldy #0                  ; default is true
00207Er 3               
00207Er 3  B5 00                        lda 0,x                 ; LSB
002080r 3  D5 02                        cmp 2,x
002082r 3  D0 0A                        bne @not_equal
002084r 3               
002084r 3                               ; LSB is equal
002084r 3  B5 01                        lda 1,x                 ; MSB
002086r 3  D5 03                        cmp 3,x
002088r 3  D0 04                        bne @not_equal
00208Ar 3               
00208Ar 3  A9 FF                        lda #$FF
00208Cr 3  80 01                        bra @done
00208Er 3               
00208Er 3               @not_equal:
00208Er 3  88                           dey                     ; drop thru to done
00208Fr 3               
00208Fr 3               @done:
00208Fr 3  98                           tya
002090r 3  E8                           inx
002091r 3  E8                           inx
002092r 3  95 00                        sta 0,x
002094r 3  95 01                        sta 1,x
002096r 3               
002096r 3  60           z_not_equals:   rts
002097r 3               
002097r 3               
002097r 3               
002097r 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
002097r 3               ; ## "-rot"  auto  Gforth
002097r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
002097r 3               
002097r 3               xt_not_rote:
002097r 3  20 rr rr                     jsr underflow_3
00209Ar 3               
00209Ar 3  B4 01                        ldy 1,x         ; MSB first
00209Cr 3  B5 03                        lda 3,x
00209Er 3  95 01                        sta 1,x
0020A0r 3               
0020A0r 3  B5 05                        lda 5,x
0020A2r 3  95 03                        sta 3,x
0020A4r 3  94 05                        sty 5,x
0020A6r 3               
0020A6r 3  B4 00                        ldy 0,x         ; LSB second
0020A8r 3  B5 02                        lda 2,x
0020AAr 3  95 00                        sta 0,x
0020ACr 3               
0020ACr 3  B5 04                        lda 4,x
0020AEr 3  95 02                        sta 2,x
0020B0r 3  94 04                        sty 4,x
0020B2r 3               
0020B2r 3  60           z_not_rote:     rts
0020B3r 3               
0020B3r 3               
0020B3r 3               
0020B3r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
0020B3r 3               ; ## "number"  auto  Tali Forth
0020B3r 3                       ; """Convert a number string to a double or single cell number. This
0020B3r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
0020B3r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
0020B3r 3                       ; Based in part on the "Starting Forth" code
0020B3r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
0020B3r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
0020B3r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
0020B3r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
0020B3r 3                       ; dot to signal a double cell number is required to be the last
0020B3r 3                       ; character of the string.
0020B3r 3                       ;
0020B3r 3                       ; Number calls >NUMBER which in turn calls UM*,
0020B3r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
0020B3r 3                       ; a pain.
0020B3r 3                       ;"""
0020B3r 3               
0020B3r 3               xt_number:
0020B3r 3  20 rr rr                     jsr underflow_2
0020B6r 3               
0020B6r 3                               ; we keep the flags for sign and double in tmpdsp because
0020B6r 3                               ; we've run out of temporary variables
0020B6r 3  64 rr                        stz tmpdsp      ; flag for double
0020B8r 3  64 rr                        stz tmpdsp+1    ; flag for minus
0020BAr 3               
0020BAr 3                               ; If the first character is a minus, strip it off and set
0020BAr 3                               ; the flag
0020BAr 3  A1 02                        lda (2,x)
0020BCr 3  C9 2D                        cmp #$2D        ; ASCII for "-"
0020BEr 3  D0 0A                        bne @check_dot
0020C0r 3               
0020C0r 3                               ; It's a minus
0020C0r 3  C6 rr                        dec tmpdsp+1
0020C2r 3  F6 02                        inc 2,x         ; start one character later
0020C4r 3  D0 02                        bne @1
0020C6r 3  F6 03                        inc 3,x
0020C8r 3               @1:
0020C8r 3  D6 00                        dec 0,x         ; decrease string length by one
0020CAr 3               
0020CAr 3               @check_dot:
0020CAr 3                               ; If the last character is a dot, strip it off and set a
0020CAr 3                               ; flag. We can use tmptos as a temporary variable
0020CAr 3  B5 02                        lda 2,x         ; LSB of address
0020CCr 3  18                           clc
0020CDr 3  75 00                        adc 0,x         ; length of string
0020CFr 3  85 rr                        sta tmptos
0020D1r 3  B5 03                        lda 3,x
0020D3r 3  69 00                        adc #0          ; only need carry
0020D5r 3  85 rr                        sta tmptos+1
0020D7r 3               
0020D7r 3                               ; tmptos now points to the first character after the string,
0020D7r 3                               ; but we need the last character
0020D7r 3  A5 rr                        lda tmptos
0020D9r 3  D0 02                        bne @2
0020DBr 3  C6 rr                        dec tmptos+1
0020DDr 3               @2:
0020DDr 3  C6 rr                        dec tmptos
0020DFr 3               
0020DFr 3  B2 rr                        lda (tmptos)
0020E1r 3  C9 2E                        cmp #'.'
0020E3r 3  D0 04                        bne @main
0020E5r 3               
0020E5r 3                               ; We have a dot, which means this is a double number. Flag
0020E5r 3                               ; the fact and reduce string length by one
0020E5r 3  C6 rr                        dec tmpdsp
0020E7r 3  D6 00                        dec 0,x
0020E9r 3               
0020E9r 3               @main:
0020E9r 3                               ; Set up stack for subroutine jump to >NUMBER, which means
0020E9r 3                               ; we have to go ( addr u --> ud addr u )
0020E9r 3  CA                           dex
0020EAr 3  CA                           dex
0020EBr 3  CA                           dex
0020ECr 3  CA                           dex
0020EDr 3               
0020EDr 3  B5 04                        lda 4,x         ; LSB of length
0020EFr 3  95 00                        sta 0,x
0020F1r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
0020F3r 3               
0020F3r 3  B5 06                        lda 6,x         ; LSB of address
0020F5r 3  95 02                        sta 2,x
0020F7r 3  B5 07                        lda 7,x         ; MSB of address
0020F9r 3  95 03                        sta 3,x
0020FBr 3               
0020FBr 3  74 04                        stz 4,x         ; clear space for ud
0020FDr 3  74 05                        stz 5,x
0020FFr 3  74 06                        stz 6,x
002101r 3  74 07                        stz 7,x
002103r 3               
002103r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
002106r 3               
002106r 3                               ; test length of returned string, which should be zero
002106r 3  B5 00                        lda 0,x
002108r 3  F0 15                        beq @all_converted
00210Ar 3               
00210Ar 3                               ; Something went wrong, we still have characters left over,
00210Ar 3                               ; so we print an error and abort. If the NUMBER was called
00210Ar 3                               ; by INTERPRET, we've already checked for Forth words, so
00210Ar 3                               ; we're in deep trouble one way or another
00210Ar 3  A9 3E                        lda #$3E        ; ASCII for ">"
00210Cr 3  20 rr rr                     jsr emit_a
00210Fr 3  20 rr rr                     jsr xt_type
002112r 3  A9 3C                        lda #$3C        ; ASCII for "<"
002114r 3  20 rr rr                     jsr emit_a
002117r 3  20 rr rr                     jsr xt_space
00211Ar 3               
00211Ar 3  A9 08                        lda #err_syntax
00211Cr 3  4C rr rr                     jmp error
00211Fr 3               
00211Fr 3               @all_converted:
00211Fr 3                               ; We can drop the string info
00211Fr 3  E8                           inx
002120r 3  E8                           inx
002121r 3  E8                           inx
002122r 3  E8                           inx
002123r 3               
002123r 3                               ; We have a double-cell number on the Data Stack that might
002123r 3                               ; actually have a minus and might actually be single-cell
002123r 3  A5 rr                        lda tmpdsp      ; flag for double
002125r 3  F0 0D                        beq @single
002127r 3               
002127r 3                               ; Set status bit 5 to indicate this is a double number
002127r 3  A9 20                        lda #%00100000
002129r 3  04 rr                        tsb status
00212Br 3               
00212Br 3                               ; This is a double cell number. If it had a minus, we'll have
00212Br 3                               ; to negate it
00212Br 3  A5 rr                        lda tmpdsp+1
00212Dr 3  F0 12                        beq @done       ; no minus, all done
00212Fr 3               
00212Fr 3  20 rr rr                     jsr xt_dnegate
002132r 3               
002132r 3  80 0D                        bra @done
002134r 3               
002134r 3               @single:
002134r 3                               ; This is a single number, so we just drop the top cell
002134r 3  E8                           inx
002135r 3  E8                           inx
002136r 3               
002136r 3                               ; Clear status bit 5 to indicate this is a single number
002136r 3  A9 20                        lda #%00100000
002138r 3  14 rr                        trb status
00213Ar 3               
00213Ar 3                               ; If we had a minus, we'll have to negate it
00213Ar 3  A5 rr                        lda tmpdsp+1
00213Cr 3  F0 03                        beq @done       ; no minus, all done
00213Er 3               
00213Er 3  20 rr rr                     jsr xt_negate
002141r 3               @done:
002141r 3  60           z_number:       rts
002142r 3               
002142r 3               
002142r 3               
002142r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
002142r 3               ; ## "#"  auto  ANS core
002142r 3                       ; """https://forth-standard.org/standard/core/num
002142r 3                       ; Add one char to the beginning of the pictured output string.
002142r 3                       ;
002142r 3                       ; Based on
002142r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002142r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
002142r 3                       ; """
002142r 3               xt_number_sign:
002142r 3  20 rr rr                     jsr underflow_2         ; double number
002145r 3               
002145r 3  20 rr rr                     jsr xt_base
002148r 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
00214Br 3               
00214Br 3                               ; The following code is the ancient Forth word UD/MOD, which in
00214Br 3                               ; various Forths (including Gforth) lives on under the hood,
00214Br 3                               ; even though it's not an ANS standard word, it doesn't appear
00214Br 3                               ; in the docs, it's only used here, and there are no tests for
00214Br 3                               ; it. This is why we got rid of it. We'll be converting this
00214Br 3                               ; mess to something more sane in the long run.
00214Br 3  20 rr rr                     jsr xt_to_r             ; >r
00214Er 3  20 rr rr                     jsr xt_zero             ; 0
002151r 3  20 rr rr                     jsr xt_r_fetch          ; r@
002154r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
002157r 3  20 rr rr                     jsr xt_rot              ; rot
00215Ar 3  20 rr rr                     jsr xt_rot              ; rot
00215Dr 3  20 rr rr                     jsr xt_r_from           ; r>
002160r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
002163r 3  20 rr rr                     jsr xt_rot              ; rot
002166r 3                               ; end of UD/MOD ( rem ud )
002166r 3               
002166r 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
002169r 3               
002169r 3                               ; Convert the number that is left over to an ASCII character. We
002169r 3                               ; use a string lookup for speed. Use either abc_str_lower for
002169r 3                               ; lower case or abc_str_upper for upper case (prefered)
002169r 3  B5 00                        lda 0,x
00216Br 3  A8                           tay
00216Cr 3  B9 rr rr                     lda s_abc_upper,y
00216Fr 3  95 00                        sta 0,x
002171r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
002173r 3               
002173r 3  20 rr rr                     jsr xt_hold
002176r 3               
002176r 3               z_number_sign:
002176r 3  60                           rts
002177r 3               
002177r 3               
002177r 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
002177r 3               ; ## "#>"  auto  ANS core
002177r 3                       ; """https://forth-standard.org/standard/core/num-end
002177r 3                       ; Finish conversion of pictured number string, putting address and
002177r 3                       ; length on the Data Stack.
002177r 3                       ;
002177r 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
002177r 3                       ; Based on
002177r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002177r 3                       ; """
002177r 3               xt_number_sign_greater:
002177r 3               
002177r 3  20 rr rr                     jsr underflow_2         ; double number
00217Ar 3               
00217Ar 3                               ; The start address lives in tohold
00217Ar 3  A5 rr                        lda tohold
00217Cr 3  95 00                        sta 0,x         ; LSB of tohold
00217Er 3  95 02                        sta 2,x
002180r 3  A5 rr                        lda tohold+1
002182r 3  95 01                        sta 1,x         ; MSB of addr
002184r 3  95 03                        sta 3,x         ; ( addr addr )
002186r 3               
002186r 3                               ; The length of the string is pad - addr
002186r 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
002189r 3               
002189r 3  38                           sec
00218Ar 3  B5 00                        lda 0,x         ; LSB of pad address
00218Cr 3  F5 02                        sbc 2,x
00218Er 3  95 02                        sta 2,x
002190r 3               
002190r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
002192r 3  F5 03                        sbc 3,x
002194r 3  95 03                        sta 3,x         ; ( addr u pad )
002196r 3               
002196r 3  E8                           inx
002197r 3  E8                           inx
002198r 3               
002198r 3               z_number_sign_greater:
002198r 3  60                           rts
002199r 3               
002199r 3               
002199r 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
002199r 3               ; ## "#s"  auto  ANS core
002199r 3                       ; """https://forth-standard.org/standard/core/numS
002199r 3                       ; Completely convert number for pictured numerical output.
002199r 3                       ;
002199r 3                       ; Based on
002199r 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
002199r 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
002199r 3                       ; """
002199r 3               
002199r 3               xt_number_sign_s:
002199r 3  20 rr rr                     jsr underflow_2
00219Cr 3               @loop:
00219Cr 3                               ; convert a single number ("#")
00219Cr 3  20 rr rr                     jsr xt_number_sign
00219Fr 3               
00219Fr 3                               ; stop when double-celled number in TOS is zero:
00219Fr 3  B5 00                        lda 0,x
0021A1r 3  15 01                        ora 1,x
0021A3r 3  15 02                        ora 2,x
0021A5r 3  15 03                        ora 3,x
0021A7r 3  D0 F3                        bne @loop
0021A9r 3               
0021A9r 3               z_number_sign_s:
0021A9r 3  60                           rts
0021AAr 3               
0021AAr 3               
0021AAr 3               
0021AAr 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
0021AAr 3               ; ## "of"  auto  ANS core ext
0021AAr 3                       ; """http://forth-standard.org/standard/core/OF"""
0021AAr 3               
0021AAr 3               xt_of:
0021AAr 3                               ; Check if value is equal to this case.
0021AAr 3                               ; Postpone over (eg. compile a jsr to it)
0021AAr 3  A0 rr                        ldy #>xt_over
0021ACr 3  A9 rr                        lda #<xt_over
0021AEr 3  20 rr rr                     jsr cmpl_subroutine
0021B1r 3               
0021B1r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
0021B1r 3  A0 rr                        ldy #>xt_equal
0021B3r 3  A9 rr                        lda #<xt_equal
0021B5r 3  20 rr rr                     jsr cmpl_subroutine
0021B8r 3               
0021B8r 3  20 rr rr                     jsr xt_if
0021BBr 3               
0021BBr 3                               ; If it's true, consume the original value.
0021BBr 3                               ; Postpone DROP (eg. compile a jsr to it)
0021BBr 3  A0 rr                        ldy #>xt_drop
0021BDr 3  A9 rr                        lda #<xt_drop
0021BFr 3  20 rr rr                     jsr cmpl_subroutine
0021C2r 3               
0021C2r 3  60           z_of:           rts
0021C3r 3               
0021C3r 3               
0021C3r 3               
0021C3r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
0021C3r 3               ; ## "1"  auto  Tali Forth
0021C3r 3                       ; """This is also the code for EDITOR-WORDLIST"""
0021C3r 3               xt_editor_wordlist:
0021C3r 3               xt_one:
0021C3r 3  CA                           dex
0021C4r 3  CA                           dex
0021C5r 3  A9 01                        lda #1
0021C7r 3  95 00                        sta 0,x
0021C9r 3  74 01                        stz 1,x
0021CBr 3               
0021CBr 3               z_editor_wordlist:
0021CBr 3               z_one:
0021CBr 3  60                           rts
0021CCr 3               
0021CCr 3               
0021CCr 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
0021CCr 3               ; ## "1-"  auto  ANS core
0021CCr 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
0021CCr 3               
0021CCr 3               xt_one_minus:
0021CCr 3  20 rr rr                     jsr underflow_1
0021CFr 3               
0021CFr 3  B5 00                        lda 0,x
0021D1r 3  D0 02                        bne @1
0021D3r 3  D6 01                        dec 1,x
0021D5r 3               @1:
0021D5r 3  D6 00                        dec 0,x
0021D7r 3               
0021D7r 3  60           z_one_minus:    rts
0021D8r 3               
0021D8r 3               
0021D8r 3               
0021D8r 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
0021D8r 3               ; ## "1+"  auto  ANS core
0021D8r 3                       ; """https://forth-standard.org/standard/core/OnePlus
0021D8r 3                       ;
0021D8r 3                       ; Code is shared with CHAR-PLUS
0021D8r 3                       ; """
0021D8r 3               
0021D8r 3               xt_char_plus:
0021D8r 3               xt_one_plus:
0021D8r 3  20 rr rr                     jsr underflow_1
0021DBr 3               
0021DBr 3  F6 00                        inc 0,x
0021DDr 3  D0 02                        bne @done
0021DFr 3  F6 01                        inc 1,x
0021E1r 3               
0021E1r 3               @done:
0021E1r 3               z_char_plus:
0021E1r 3  60           z_one_plus:     rts
0021E2r 3               
0021E2r 3               
0021E2r 3               
0021E2r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
0021E2r 3               ; ## "only"  auto  ANS search ext
0021E2r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
0021E2r 3               
0021E2r 3               xt_only:
0021E2r 3                               ; Put -1 on data stack.
0021E2r 3  CA                           dex
0021E3r 3  CA                           dex
0021E4r 3  A9 FF                        lda #$FF
0021E6r 3  95 00                        sta 0,x
0021E8r 3  95 01                        sta 1,x
0021EAr 3               
0021EAr 3                               ; Invoke set-order to set the minimum search order.
0021EAr 3  20 rr rr                     jsr xt_set_order
0021EDr 3               
0021EDr 3  60           z_only:         rts
0021EEr 3               
0021EEr 3               
0021EEr 3               
0021EEr 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
0021EEr 3               ; ## "or"  auto  ANS core
0021EEr 3                       ; """https://forth-standard.org/standard/core/OR"
0021EEr 3               xt_or:
0021EEr 3  20 rr rr                     jsr underflow_2
0021F1r 3               
0021F1r 3  B5 00                        lda 0,x
0021F3r 3  15 02                        ora 2,x
0021F5r 3  95 02                        sta 2,x
0021F7r 3               
0021F7r 3  B5 01                        lda 1,x
0021F9r 3  15 03                        ora 3,x
0021FBr 3  95 03                        sta 3,x
0021FDr 3               
0021FDr 3  E8                           inx
0021FEr 3  E8                           inx
0021FFr 3               
0021FFr 3  60           z_or:           rts
002200r 3               
002200r 3               
002200r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
002200r 3               ; ## "order"  auto  ANS core
002200r 3                       ; """https://forth-standard.org/standard/search/ORDER
002200r 3                       ; Note the search order is displayed from first search to last
002200r 3                       ; searched and is therefore exactly the reverse of the order in which
002200r 3                       ; Forth stacks are displayed.
002200r 3                       ;
002200r 3                       ; A Forth implementation of this word is:
002200r 3                       ;
002200r 3                       ; 	: .wid ( wid -- )
002200r 3                       ; 	dup 0=  if ." Forth "  drop    else
002200r 3                       ; 	dup 1 = if ." Editor " drop    else
002200r 3                       ; 	dup 2 = if ." Assembler " drop else
002200r 3                       ; 	dup 3 = if ." Root " drop      else
002200r 3                       ; 	           . ( just print the number )
002200r 3                       ; 	then then then then ;
002200r 3                       ;
002200r 3                       ; : ORDER ( -- )
002200r 3                       ; 	cr get-order 0 ?do .wid loop
002200r 3                       ; 	space space get-current .wid ;
002200r 3                       ;
002200r 3                       ; This is an interactive program, so speed
002200r 3                       ; is not as important as size. We assume we do not have more than 255
002200r 3                       ; wordlists.
002200r 3                       ; """
002200r 3               
002200r 3               xt_order:
002200r 3  20 rr rr                     jsr xt_cr
002203r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
002206r 3               
002206r 3                               ; Paranoid: Check if there are no wordlists, a rather
002206r 3                               ; pathological case. this would mean ( 0 ) on the stack. In
002206r 3                               ; that case, we just drop n and run
002206r 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
002208r 3  F0 1E                        beq @drop_done
00220Ar 3               
00220Ar 3               @have_wordlists:
00220Ar 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
00220Ar 3                               ; on the stack
00220Ar 3  A8                           tay
00220Br 3               @loop:
00220Br 3  E8                           inx
00220Cr 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
00220Dr 3  B5 00                        lda 0,x
00220Fr 3               
00220Fr 3  5A                           phy
002210r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
002213r 3  7A                           ply
002214r 3               
002214r 3  88                           dey
002215r 3  D0 F4                        bne @loop
002217r 3               
002217r 3                               ; We've printed the wordlists, now we add the current wordlist.
002217r 3                               ; This follows the convention of Gforth
002217r 3  20 rr rr                     jsr xt_space
00221Ar 3  20 rr rr                     jsr xt_space
00221Dr 3  20 rr rr                     jsr xt_get_current      ; ( wid )
002220r 3               
002220r 3  B5 00                        lda 0,x
002222r 3  20 rr rr                     jsr _print_wid_string
002225r 3  20 rr rr                     jsr xt_cr
002228r 3               
002228r 3               @drop_done:
002228r 3  E8                           inx
002229r 3  E8                           inx
00222Ar 3               z_order:
00222Ar 3  60                           rts
00222Br 3               
00222Br 3               _print_wid_string:
00222Br 3                       ; """Helper function for ORDER: Given a WID in A, print the
00222Br 3                       ; corresponding string. If there is no such word list defined, just
00222Br 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
00222Br 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
00222Br 3                       ; theory, we could speed this up by having the WID be the same as the
00222Br 3                       ; number of the strings. However, ORDER is used rather infrequently and
00222Br 3                       ; this would make changes to the strings.asm file very dangerous, so we
00222Br 3                       ; follow the slightly more complicated route with a translation table.
00222Br 3                       ; """
00222Br 3                               ; If the WID is larger than 3, we have no string avaliable and
00222Br 3                               ; just print the number.
00222Br 3                               ; See http://6502.org/tutorials/compare_instructions.html
00222Br 3                               ; for details
00222Br 3  C9 04                        cmp #4
00222Dr 3  90 09                        bcc @output_string      ; less than 4, print a real string
00222Fr 3               
00222Fr 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
00222Fr 3                               ; print the number
00222Fr 3  CA                           dex
002230r 3  CA                           dex
002231r 3  95 00                        sta 0,x
002233r 3  74 01                        stz 1,x
002235r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
002238r 3               
002238r 3               @output_string:
002238r 3                               ; Get the string number based on WID 0 to 3
002238r 3  A8                           tay
002239r 3  B9 rr rr                     lda @wid_data,y
00223Cr 3               
00223Cr 3                               ; Print without a line feed
00223Cr 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
00223Fr 3               
00223Fr 3               @wid_data:
00223Fr 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
00223Fr 3                       ; less than 4.
00223Fr 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
002240r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
002241r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
002242r 3  08                   .byte str_wid_root             ; WID 3: "Root"
002243r 3               
002243r 3               
002243r 3               
002243r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
002243r 3               ; ## "output"  tested  Tali Forth
002243r 3               xt_output:
002243r 3                       ; """Return the address where the jump target for EMIT is stored (but
002243r 3                       ; not the vector itself). By default, this will hold the value of
002243r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
002243r 3                       ; routine.
002243r 3                       ; """
002243r 3  CA                           dex
002244r 3  CA                           dex
002245r 3  A9 rr                        lda #<output
002247r 3  95 00                        sta 0,x
002249r 3  A9 rr                        lda #>output
00224Br 3  95 01                        sta 1,x
00224Dr 3               
00224Dr 3  60           z_output:       rts
00224Er 3               
00224Er 3               
00224Er 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
00224Er 3               ; ## "over"  auto  ANS core
00224Er 3                       ; """https://forth-standard.org/standard/core/OVER"""
00224Er 3               xt_over:
00224Er 3  20 rr rr                     jsr underflow_2
002251r 3               
002251r 3  CA                           dex
002252r 3  CA                           dex
002253r 3               
002253r 3  B5 04                        lda 4,x         ; LSB
002255r 3  95 00                        sta 0,x
002257r 3  B5 05                        lda 5,x         ; MSB
002259r 3  95 01                        sta 1,x
00225Br 3               
00225Br 3  60           z_over:         rts
00225Cr 3               
00225Cr 3               
00225Cr 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
00225Cr 3               ; ## "pad"  auto  ANS core ext
00225Cr 3                       ; """https://forth-standard.org/standard/core/PAD
00225Cr 3                       ; Return address to a temporary area in free memory for user. Must
00225Cr 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
00225Cr 3                       ; the compile area pointer (CP) and therefore varies in position.
00225Cr 3                       ; This area is reserved for the user and not used by the system
00225Cr 3                       ; """
00225Cr 3               xt_pad:
00225Cr 3  CA                           dex
00225Dr 3  CA                           dex
00225Er 3               
00225Er 3  A5 rr                        lda cp
002260r 3  18                           clc
002261r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
002263r 3  95 00                        sta 0,x
002265r 3               
002265r 3  A5 rr                        lda cp+1
002267r 3  69 00                        adc #0          ; only need carry
002269r 3  95 01                        sta 1,x
00226Br 3               
00226Br 3  60           z_pad:          rts
00226Cr 3               
00226Cr 3               
00226Cr 3               ; ## PAGE ( -- ) "Clear the screen"
00226Cr 3               ; ## "page"  tested  ANS facility
00226Cr 3                       ; """https://forth-standard.org/standard/facility/PAGE
00226Cr 3                       ; Clears a page if supported by ANS terminal codes. This is
00226Cr 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
00226Cr 3                       ; left of the screen
00226Cr 3                       ; """
00226Cr 3               xt_page:
00226Cr 3  A9 1B                        lda #AscESC
00226Er 3  20 rr rr                     jsr emit_a
002271r 3  A9 5B                        lda #$5B        ; ASCII for "["
002273r 3  20 rr rr                     jsr emit_a
002276r 3  A9 32                        lda #'2'
002278r 3  20 rr rr                     jsr emit_a
00227Br 3  A9 4A                        lda #'J'
00227Dr 3  20 rr rr                     jsr emit_a
002280r 3               
002280r 3                               ; move cursor to top left of screen
002280r 3  20 rr rr                     jsr xt_zero
002283r 3  20 rr rr                     jsr xt_zero
002286r 3  20 rr rr                     jsr xt_at_xy
002289r 3               
002289r 3  60           z_page:         rts
00228Ar 3               
00228Ar 3               
00228Ar 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
00228Ar 3               ; ## "("  auto  ANS core
00228Ar 3                       ; """http://forth-standard.org/standard/core/p"""
00228Ar 3               
00228Ar 3               xt_paren:
00228Ar 3                               ; Put a right paren on the stack.
00228Ar 3  CA                           dex
00228Br 3  CA                           dex
00228Cr 3  A9 29                        lda #41     ; Right parenthesis
00228Er 3  95 00                        sta 0,x
002290r 3  74 01                        stz 1,x
002292r 3               
002292r 3                               ; Call parse.
002292r 3  20 rr rr                     jsr xt_parse
002295r 3               
002295r 3                               ; Throw away the result.
002295r 3  E8                           inx
002296r 3  E8                           inx
002297r 3  E8                           inx
002298r 3  E8                           inx
002299r 3               
002299r 3  60           z_paren:        rts
00229Ar 3               
00229Ar 3               
00229Ar 3               
00229Ar 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
00229Ar 3               ; ## "parse-name"  auto  ANS core ext
00229Ar 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
00229Ar 3                       ; Find next word in input string, skipping leading whitespace. This is
00229Ar 3                       ; a special form of PARSE and drops through to that word. See PARSE
00229Ar 3                       ; for more detail. We use this word internally for the interpreter
00229Ar 3                       ; because it is a lot easier to use. Reference implementations at
00229Ar 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
00229Ar 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
00229Ar 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
00229Ar 3                       ; though the ANS standard talks about skipping "spaces", whitespace
00229Ar 3                       ; is actually perfectly legal (see for example
00229Ar 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
00229Ar 3                       ; Otherwise, PARSE-NAME chokes on tabs.
00229Ar 3                       ; """
00229Ar 3               
00229Ar 3               xt_parse_name:
00229Ar 3                               ; To enable the compilation of the high-level Forth words
00229Ar 3                               ; in forth-words.asm and user-words.asm at boot time,
00229Ar 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
00229Ar 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
00229Ar 3                               ; to the current location is in toin (>IN). We need to check,
00229Ar 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
00229Ar 3                               ; we can't just use Y as an index.
00229Ar 3               
00229Ar 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
00229Ar 3  A5 rr                        lda ciblen              ; LSB of counter
00229Cr 3  38                           sec
00229Dr 3  E5 rr                        sbc toin
00229Fr 3  85 rr                        sta tmp1
0022A1r 3  A5 rr                        lda ciblen+1            ; MSB
0022A3r 3  E5 rr                        sbc toin+1
0022A5r 3  85 rr                        sta tmp1+1
0022A7r 3               
0022A7r 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
0022A7r 3  A5 rr                        lda tmp1
0022A9r 3  05 rr                        ora tmp1+1
0022ABr 3  F0 28                        beq @empty_line
0022ADr 3               
0022ADr 3                               ; We walk through the characters starting at CIB+TOIN, so we
0022ADr 3                               ; save a temp version of that in tmp2
0022ADr 3  A5 rr                        lda cib
0022AFr 3  18                           clc
0022B0r 3  65 rr                        adc toin
0022B2r 3  85 rr                        sta tmp2                ; LSB of first character
0022B4r 3  A5 rr                        lda cib+1
0022B6r 3  65 rr                        adc toin+1
0022B8r 3  85 rr                        sta tmp2+1              ; MSB
0022BAr 3               
0022BAr 3               @skip_loop:
0022BAr 3  B2 rr                        lda (tmp2)              ; work copy of cib
0022BCr 3  20 rr rr                     jsr is_whitespace
0022BFr 3  90 1F                        bcc @char_found
0022C1r 3               
0022C1r 3                               ; Char is still whitespace, continue
0022C1r 3  E6 rr                        inc tmp2
0022C3r 3  D0 02                        bne @2
0022C5r 3  E6 rr                        inc tmp2+1
0022C7r 3               @2:
0022C7r 3                               ; Adjust counter
0022C7r 3  A5 rr                        lda tmp1
0022C9r 3  D0 02                        bne @3
0022CBr 3  C6 rr                        dec tmp1+1
0022CDr 3               @3:
0022CDr 3  C6 rr                        dec tmp1
0022CFr 3               
0022CFr 3  A5 rr                        lda tmp1
0022D1r 3  05 rr                        ora tmp1+1
0022D3r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
0022D5r 3               
0022D5r 3               @empty_line:
0022D5r 3                               ; Neither the ANS Forth nor the Gforth documentation say
0022D5r 3                               ; what to return as an address if a string with only
0022D5r 3                               ; spaces is given. For speed reasons, we just return junk
0022D5r 3                               ; NOS, with the TOS zero as per standard
0022D5r 3  CA                           dex
0022D6r 3  CA                           dex
0022D7r 3  CA                           dex
0022D8r 3  CA                           dex
0022D9r 3               
0022D9r 3  74 00                        stz 0,x                 ; TOS is zero
0022DBr 3  74 01                        stz 1,x
0022DDr 3               
0022DDr 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
0022E0r 3               
0022E0r 3               @char_found:
0022E0r 3                               ; We arrive here with tmp2 pointing to the first non-space
0022E0r 3                               ; character. This is where the word really starts, so
0022E0r 3                               ; we use it to calculate the new >IN by subtracting
0022E0r 3  A5 rr                        lda tmp2
0022E2r 3  38                           sec
0022E3r 3  E5 rr                        sbc cib
0022E5r 3  85 rr                        sta toin
0022E7r 3  A5 rr                        lda tmp2+1
0022E9r 3  E5 rr                        sbc cib+1
0022EBr 3  85 rr                        sta toin+1
0022EDr 3               
0022EDr 3                               ; prepare Data Stack for PARSE by adding space
0022EDr 3                               ; as the delimiter
0022EDr 3  CA                           dex
0022EEr 3  CA                           dex
0022EFr 3               
0022EFr 3  A9 20                        lda #AscSP
0022F1r 3  95 00                        sta 0,x
0022F3r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
0022F5r 3               
0022F5r 3               
0022F5r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
0022F5r 3               ; ## "parse"  tested  ANS core ext
0022F5r 3                       ; """https://forth-standard.org/standard/core/PARSE
0022F5r 3                       ; Find word in input string delimited by character given. Do not
0022F5r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
0022F5r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
0022F5r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
0022F5r 3                       ;
0022F5r 3                       ;
0022F5r 3                       ;     cib  cib+toin   cib+ciblen
0022F5r 3                       ;      v      v            v
0022F5r 3                       ;     |###################|
0022F5r 3                       ;
0022F5r 3                       ;     |------>|  toin (>IN)
0022F5r 3                       ;     |------------------->|  ciblen
0022F5r 3                       ;
0022F5r 3                       ; The input string is stored starting at the address in the Current
0022F5r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
0022F5r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
0022F5r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
0022F5r 3                       ; useful string if there are any characters at all. As with
0022F5r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
0022F5r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
0022F5r 3                       ; """
0022F5r 3               
0022F5r 3               xt_parse:
0022F5r 3  20 rr rr                     jsr underflow_1
0022F8r 3               
0022F8r 3                               ; If the input buffer is empty, we just return
0022F8r 3  A5 rr                        lda ciblen
0022FAr 3  05 rr                        ora ciblen+1
0022FCr 3  F0 0C                        beq @abort_parse
0022FEr 3               
0022FEr 3                               ; If the pointer >IN is larger or equal to the length of
0022FEr 3                               ; the input buffer (CIBLEN), the line is done. Put
0022FEr 3                               ; differently, we only continue if >IN is smaller than
0022FEr 3                               ; CIBLEN
0022FEr 3  A5 rr                        lda toin+1              ; MSB
002300r 3  C5 rr                        cmp ciblen+1
002302r 3  90 0E                        bcc @go_parse           ; unsigned comparison
002304r 3               
002304r 3  A5 rr                        lda toin                ; LSB
002306r 3  C5 rr                        cmp ciblen
002308r 3  90 08                        bcc @go_parse
00230Ar 3               
00230Ar 3               @abort_parse:
00230Ar 3                               ; Sorry, this line is over
00230Ar 3  CA                           dex
00230Br 3  CA                           dex
00230Cr 3  74 00                        stz 0,x
00230Er 3  74 01                        stz 1,x
002310r 3               
002310r 3  80 7A                        bra @done
002312r 3               @go_parse:
002312r 3                               ; We actually have work to do. Save the delimiter in
002312r 3                               ; tmptos.
002312r 3  B5 00                        lda 0,x
002314r 3  85 rr                        sta tmptos
002316r 3               
002316r 3                               ; We can now prepare the Data Stack for the return value
002316r 3  CA                           dex
002317r 3  CA                           dex
002318r 3               
002318r 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
002318r 3                               ; tmp2 is initially the same as tmp1, then the work index
002318r 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
002318r 3               
002318r 3                               ; Calculate the beginning of the string, which is also the
002318r 3                               ; address to return
002318r 3  A5 rr                        lda cib
00231Ar 3  18                           clc
00231Br 3  65 rr                        adc toin        ; LSB
00231Dr 3  85 rr                        sta tmp1
00231Fr 3  85 rr                        sta tmp2
002321r 3  95 02                        sta 2,x
002323r 3               
002323r 3  A5 rr                        lda cib+1
002325r 3  65 rr                        adc toin+1      ; MSB
002327r 3  85 rr                        sta tmp1+1
002329r 3  85 rr                        sta tmp2+1
00232Br 3  95 03                        sta 3,x
00232Dr 3               
00232Dr 3                               ; Calculate the address where the input buffer ends plus 1, so
00232Dr 3                               ; we can compare it with TOIN, which is an index
00232Dr 3  A5 rr                        lda cib
00232Fr 3  18                           clc
002330r 3  65 rr                        adc ciblen
002332r 3  85 rr                        sta tmp3
002334r 3  A5 rr                        lda cib+1
002336r 3  65 rr                        adc ciblen+1
002338r 3  85 rr                        sta tmp3+1
00233Ar 3               
00233Ar 3                               ; Initialize the offset we use to adjust EOL or found delimiter
00233Ar 3  64 rr                        stz tmptos+1
00233Cr 3               @loop:
00233Cr 3                               ; If we are at the end of the string, quit
00233Cr 3  A5 rr                        lda tmp2
00233Er 3  C5 rr                        cmp tmp3
002340r 3  D0 06                        bne @not_empty
002342r 3               
002342r 3  A5 rr                        lda tmp2+1
002344r 3  C5 rr                        cmp tmp3+1
002346r 3  F0 1D                        beq @eol
002348r 3               @not_empty:
002348r 3                               ; We have to do this the hard way. In fact, it's really
002348r 3                               ; hard since if we are dealing with a SPACE, the standard
002348r 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
002348r 3                               ; Tali would choke on tabs between words. For details, see
002348r 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
002348r 3                               ; In theory, we could make this faster by defining a delimiter
002348r 3                               ; that is 00 as the sign that we skip all whitespace, thereby
002348r 3                               ; avoiding having to test every time. However, somebody,
002348r 3                               ; somewhere might want to parse a zero-delimited list. Since
002348r 3                               ; any byte value could be chosen for that, we just test for
002348r 3                               ; a space every single time for the moment.
002348r 3  B2 rr                        lda (tmp2)
00234Ar 3               
00234Ar 3  A4 rr                        ldy tmptos
00234Cr 3  C0 20                        cpy #AscSP
00234Er 3  D0 07                        bne @not_whitespace
002350r 3               
002350r 3                               ; The delimiter is a space, so we're looking for all
002350r 3                               ; whitespace
002350r 3  20 rr rr                     jsr is_whitespace
002353r 3  90 02                        bcc @not_whitespace
002355r 3  80 0C                        bra @found_delimiter
002357r 3               
002357r 3               @not_whitespace:
002357r 3                               ; The delimiter is not a space, so we're looking for
002357r 3                               ; whatever it is
002357r 3  C5 rr                        cmp tmptos
002359r 3  F0 08                        beq @found_delimiter
00235Br 3               
00235Br 3                               ; Not a delimiter, next character
00235Br 3  E6 rr                        inc tmp2
00235Dr 3  D0 DD                        bne @loop
00235Fr 3  E6 rr                        inc tmp2+1
002361r 3  80 D9                        bra @loop
002363r 3               
002363r 3               @found_delimiter:
002363r 3                               ; Increase the offset: If we've found a delimiter, we want
002363r 3                               ; TOIN to point to the character after it, not the delimiter
002363r 3                               ; itself
002363r 3  E6 rr                        inc tmptos+1
002365r 3               @eol:
002365r 3                               ; The length of the new string is tmp2-tmp1
002365r 3  A5 rr                        lda tmp2
002367r 3  38                           sec
002368r 3  E5 rr                        sbc tmp1
00236Ar 3  95 00                        sta 0,x
00236Cr 3               
00236Cr 3  A5 rr                        lda tmp2+1
00236Er 3  E5 rr                        sbc tmp1+1
002370r 3  95 01                        sta 1,x
002372r 3               
002372r 3                               ; The new offset is tmp2-cib
002372r 3  A5 rr                        lda tmp2
002374r 3  38                           sec
002375r 3  E5 rr                        sbc cib
002377r 3  85 rr                        sta toin
002379r 3  A5 rr                        lda tmp2+1
00237Br 3  E5 rr                        sbc cib+1
00237Dr 3  85 rr                        sta toin+1
00237Fr 3               
00237Fr 3                               ; Add in the delimiter
00237Fr 3  A5 rr                        lda toin
002381r 3  18                           clc
002382r 3  65 rr                        adc tmptos+1
002384r 3  85 rr                        sta toin
002386r 3  A5 rr                        lda toin+1
002388r 3  69 00                        adc #0          ; we only need the carry
00238Ar 3  85 rr                        sta toin+1
00238Cr 3               @done:
00238Cr 3               z_parse_name:
00238Cr 3  60           z_parse:        rts
00238Dr 3               
00238Dr 3               
00238Dr 3               
00238Dr 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
00238Dr 3               ; ## "pick"  auto  ANS core ext
00238Dr 3                       ; """https://forth-standard.org/standard/core/PICK
00238Dr 3                       ; Take the u-th element out of the stack and put it on TOS,
00238Dr 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
00238Dr 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
00238Dr 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
00238Dr 3                       ; """
00238Dr 3               
00238Dr 3               xt_pick:
00238Dr 3                               ; Checking for underflow is difficult because it depends on
00238Dr 3                               ; which element we want to grab. We could probably figure
00238Dr 3                               ; something out, but it wouldn't work with underflow stripping
00238Dr 3                               ; Since using PICK is considered poor form anyway, we just
00238Dr 3                               ; leave it as it is
00238Dr 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
00238Fr 3  8A                           txa
002390r 3  75 00                        adc 0,x
002392r 3  A8                           tay
002393r 3               
002393r 3  B9 02 00                     lda 0002,y
002396r 3  95 00                        sta 0,x
002398r 3  B9 03 00                     lda 0003,y
00239Br 3  95 01                        sta 1,x
00239Dr 3               
00239Dr 3  60           z_pick:         rts
00239Er 3               
00239Er 3               
00239Er 3               
00239Er 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
00239Er 3               ; ## "+"  auto  ANS core
00239Er 3                       ; """https://forth-standard.org/standard/core/Plus"""
00239Er 3               xt_plus:
00239Er 3  20 rr rr                     jsr underflow_2
0023A1r 3               
0023A1r 3  18                           clc
0023A2r 3  B5 00                        lda 0,x         ; LSB
0023A4r 3  75 02                        adc 2,x
0023A6r 3  95 02                        sta 2,x
0023A8r 3               
0023A8r 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
0023AAr 3  75 03                        adc 3,x
0023ACr 3  95 03                        sta 3,x
0023AEr 3               
0023AEr 3  E8                           inx
0023AFr 3  E8                           inx
0023B0r 3               
0023B0r 3  60           z_plus:         rts
0023B1r 3               
0023B1r 3               
0023B1r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
0023B1r 3               ; ## "+!"  auto  ANS core
0023B1r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
0023B1r 3               xt_plus_store:
0023B1r 3  20 rr rr                     jsr underflow_2
0023B4r 3               
0023B4r 3                               ; move address to tmp1 so we can work with it
0023B4r 3  B5 00                        lda 0,x
0023B6r 3  85 rr                        sta tmp1
0023B8r 3  B5 01                        lda 1,x
0023BAr 3  85 rr                        sta tmp1+1
0023BCr 3               
0023BCr 3  A0 00                        ldy #0          ; LSB
0023BEr 3  B1 rr                        lda (tmp1),y
0023C0r 3  18                           clc
0023C1r 3  75 02                        adc 2,x
0023C3r 3  91 rr                        sta (tmp1),y
0023C5r 3               
0023C5r 3  C8                           iny             ; MSB
0023C6r 3  B1 rr                        lda (tmp1),y
0023C8r 3  75 03                        adc 3,x
0023CAr 3  91 rr                        sta (tmp1),y
0023CCr 3               
0023CCr 3  E8                           inx
0023CDr 3  E8                           inx
0023CEr 3  E8                           inx
0023CFr 3  E8                           inx
0023D0r 3               
0023D0r 3  60           z_plus_store:   rts
0023D1r 3               
0023D1r 3               
0023D1r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
0023D1r 3               ; ## "postpone"  auto   ANS core
0023D1r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
0023D1r 3                       ; Add the compilation behavior of a word to a new word at
0023D1r 3                       ; compile time. If the word that follows it is immediate, include
0023D1r 3                       ; it so that it will be compiled when the word being defined is
0023D1r 3                       ; itself used for a new word. Tricky, but very useful.
0023D1r 3                       ;
0023D1r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
0023D1r 3                       ; on the Data Stack). This means we cannot build words with
0023D1r 3                       ; "jsr xt_postpone, jsr <word>" directly.
0023D1r 3                       ; """
0023D1r 3               
0023D1r 3               xt_postpone:
0023D1r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
0023D4r 3               
0023D4r 3                               ; if there was no word provided, complain and quit
0023D4r 3  B5 00                        lda 0,x
0023D6r 3  15 01                        ora 1,x
0023D8r 3  D0 05                        bne @1
0023DAr 3               
0023DAr 3  A9 05                        lda #err_noname
0023DCr 3  4C rr rr                     jmp error
0023DFr 3               @1:
0023DFr 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
0023E2r 3               
0023E2r 3                               ; if word not in Dictionary, complain and quit
0023E2r 3  D0 05                        bne @2
0023E4r 3  A9 05                        lda #err_noname
0023E6r 3  4C rr rr                     jmp error
0023E9r 3               
0023E9r 3               @2:
0023E9r 3                               ; keep a copy of nt for later
0023E9r 3  B5 00                        lda 0,x
0023EBr 3  85 rr                        sta tmp1
0023EDr 3  B5 01                        lda 1,x
0023EFr 3  85 rr                        sta tmp1+1
0023F1r 3               
0023F1r 3                               ; We need the xt instead of the nt
0023F1r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
0023F4r 3               
0023F4r 3                               ; See if this is an immediate word. This is easier
0023F4r 3                               ; with nt than with xt. The status byte of the word
0023F4r 3                               ; is nt+1
0023F4r 3  E6 rr                        inc tmp1
0023F6r 3  D0 02                        bne @3
0023F8r 3  E6 rr                        inc tmp1+1
0023FAr 3               @3:
0023FAr 3  B2 rr                        lda (tmp1)
0023FCr 3  29 04                        and #IM         ; mask all but Intermediate flag
0023FEr 3  F0 05                        beq @not_immediate
002400r 3               
002400r 3                               ; We're immediate, so instead of executing it right now, we
002400r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
002400r 3                               ; takes us back to the original caller
002400r 3  20 rr rr                     jsr xt_compile_comma
002403r 3  80 0A                        bra @done
002405r 3               
002405r 3               @not_immediate:
002405r 3                               ; This is not an immediate word, so we enact "deferred
002405r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
002405r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
002405r 3                               ; a subroutine jump to COMPILE,
002405r 3  20 rr rr                     jsr xt_literal
002408r 3               
002408r 3                               ; Last, compile COMPILE,
002408r 3  A0 rr                        ldy #>xt_compile_comma
00240Ar 3  A9 rr                        lda #<xt_compile_comma
00240Cr 3  20 rr rr                     jsr cmpl_subroutine
00240Fr 3               @done:
00240Fr 3  60           z_postpone:     rts
002410r 3               
002410r 3               
002410r 3               
002410r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
002410r 3               ; ## "previous"  auto  ANS search ext
002410r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
002410r 3               
002410r 3               xt_previous:
002410r 3  20 rr rr                     jsr xt_get_order
002413r 3  20 rr rr                     jsr xt_nip
002416r 3  20 rr rr                     jsr xt_one_minus
002419r 3  20 rr rr                     jsr xt_set_order
00241Cr 3               
00241Cr 3  60           z_previous:     rts
00241Dr 3               
00241Dr 3               
00241Dr 3               
00241Dr 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
00241Dr 3               ; ## "?"  tested  ANS tools
00241Dr 3                       ; """https://forth-standard.org/standard/tools/q
00241Dr 3                       ;
00241Dr 3                       ; Only used interactively. Since humans are so slow, we
00241Dr 3                       ; save size and just go for the subroutine jumps
00241Dr 3                       ; """
00241Dr 3               xt_question:
00241Dr 3                               ; FETCH takes care of underflow check
00241Dr 3  20 rr rr                     jsr xt_fetch
002420r 3  20 rr rr                     jsr xt_dot
002423r 3               
002423r 3  60           z_question:     rts
002424r 3               
002424r 3               
002424r 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
002424r 3               ; ## "?dup"  auto  ANS core
002424r 3                       ; """https://forth-standard.org/standard/core/qDUP"""
002424r 3               
002424r 3               xt_question_dup:
002424r 3  20 rr rr                     jsr underflow_1
002427r 3               
002427r 3                               ; Check if TOS is zero
002427r 3  B5 00                        lda 0,x
002429r 3  15 01                        ora 1,x
00242Br 3  F0 0A                        beq @done
00242Dr 3               
00242Dr 3                               ; not zero, duplicate
00242Dr 3  CA                           dex
00242Er 3  CA                           dex
00242Fr 3  B5 02                        lda 2,x
002431r 3  95 00                        sta 0,x
002433r 3  B5 03                        lda 3,x
002435r 3  95 01                        sta 1,x
002437r 3               @done:
002437r 3  60           z_question_dup: rts
002438r 3               
002438r 3               
002438r 3               
002438r 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
002438r 3               ; ## "r@"  auto  ANS core
002438r 3                       ; """https://forth-standard.org/standard/core/RFetch
002438r 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
002438r 3                       ; work normally as well
002438r 3                       ;
002438r 3                       ; An alternative way to write this word
002438r 3                       ; would be to access the elements on the stack directly like 2R@
002438r 3                       ; does, these versions should be compared at some point.
002438r 3                       ; """
002438r 3               xt_r_fetch:
002438r 3                               ; get the return address
002438r 3  7A                           ply             ; LSB
002439r 3  84 rr                        sty tmp1
00243Br 3  7A                           ply             ; MSB
00243Cr 3               
00243Cr 3                               ; --- CUT FOR NATIVE COMPILE ---
00243Cr 3               
00243Cr 3                               ; get the actual top of Return Stack
00243Cr 3  CA                           dex
00243Dr 3  CA                           dex
00243Er 3               
00243Er 3  68                           pla             ; LSB
00243Fr 3  95 00                        sta 0,x
002441r 3  68                           pla             ; MSB
002442r 3  95 01                        sta 1,x
002444r 3               
002444r 3                               ; now we have to put that value back
002444r 3  48                           pha
002445r 3  B5 00                        lda 0,x
002447r 3  48                           pha
002448r 3               
002448r 3                               ; --- CUT FOR NATIVE COMPILE ---
002448r 3               
002448r 3                               ; restore return value
002448r 3  5A                           phy             ; MSB
002449r 3  A4 rr                        ldy tmp1
00244Br 3  5A                           phy             ; LSB
00244Cr 3               
00244Cr 3  60           z_r_fetch:      rts
00244Dr 3               
00244Dr 3               
00244Dr 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
00244Dr 3               ; ## "r>"  auto  ANS core
00244Dr 3                       ; """https://forth-standard.org/standard/core/Rfrom
00244Dr 3                       ; Move Top of Return Stack to Top of Data Stack.
00244Dr 3                       ;
00244Dr 3                       ; We have to move
00244Dr 3                       ; the RTS address out of the way first. This word is handled
00244Dr 3                       ; differently for native and and subroutine compilation, see COMPILE,
00244Dr 3                       ; This is a compile-only word
00244Dr 3                       ; """
00244Dr 3               
00244Dr 3               xt_r_from:
00244Dr 3                               ; Rescue the address of the return jump that is currently
00244Dr 3                               ; on top of the Return Stack. If this word is natively
00244Dr 3                               ; compiled, this is a total waste of time
00244Dr 3  68                           pla             ; LSB
00244Er 3  85 rr                        sta tmptos
002450r 3  7A                           ply             ; MSB
002451r 3               
002451r 3                               ; --- CUT FOR NATIVE CODING ---
002451r 3               
002451r 3  CA                           dex
002452r 3  CA                           dex
002453r 3               
002453r 3                               ; now we can access the actual data
002453r 3               
002453r 3  68                           pla             ; LSB
002454r 3  95 00                        sta 0,x
002456r 3  68                           pla             ; MSB
002457r 3  95 01                        sta 1,x
002459r 3               
002459r 3                               ; --- CUT FOR NATIVE CODING ---
002459r 3               
002459r 3                               ; restore the return address
002459r 3  5A                           phy             ; MSB
00245Ar 3  A5 rr                        lda tmptos
00245Cr 3  48                           pha             ; LSB
00245Dr 3               
00245Dr 3  60           z_r_from:       rts
00245Er 3               
00245Er 3               
00245Er 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
00245Er 3               ; ## "r>input"  tested  Tali Forth
00245Er 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
00245Er 3                       ; and toin from the Return Stack.
00245Er 3                       ;
00245Er 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
00245Er 3                       ; """
00245Er 3               
00245Er 3               xt_r_to_input:
00245Er 3               
00245Er 3                               ; We arrive here with the return address on the top of the
00245Er 3                               ; 65c02's stack. We need to move it out of the way first
00245Er 3  68                           pla
00245Fr 3  85 rr                        sta tmp1
002461r 3  68                           pla
002462r 3  85 rr                        sta tmp1+1
002464r 3               
002464r 3                               ; This assumes that insrc is the first of eight bytes and
002464r 3                               ; toin+1 the last in the sequence we want to save from the Zero
002464r 3                               ; Page. Since we went in reverse order, insrc is now on the top
002464r 3                               ; of the Return Stack.
002464r 3  A0 00                        ldy #0
002466r 3               @loop:
002466r 3  68                           pla
002467r 3  99 rr rr                     sta insrc,y
00246Ar 3  C8                           iny
00246Br 3  C0 08                        cpy #8
00246Dr 3  D0 F7                        bne @loop
00246Fr 3               
00246Fr 3                               ; Restore address for return jump
00246Fr 3  A5 rr                        lda tmp1+1
002471r 3  48                           pha
002472r 3  A5 rr                        lda tmp1
002474r 3  48                           pha
002475r 3               
002475r 3  60           z_r_to_input: 	rts
002476r 3               
002476r 3               
002476r 3               
002476r 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
002476r 3               ; ## "recurse"  auto  ANS core
002476r 3                       ; """https://forth-standard.org/standard/core/RECURSE
002476r 3                       ;
002476r 3                       ; This word may not be natively compiled
002476r 3                       ; """
002476r 3               
002476r 3               xt_recurse:
002476r 3                               ; The whole routine amounts to compiling a reference to
002476r 3                               ; the word that is being compiled. First, we save the JSR
002476r 3                               ; instruction
002476r 3  A0 00                        ldy #0
002478r 3               
002478r 3  A9 20                        lda #$20        ; opcode for JSR
00247Ar 3  91 rr                        sta (cp),y
00247Cr 3  C8                           iny
00247Dr 3               
00247Dr 3                               ; Next, we save the LSB and MSB of the xt of the word
00247Dr 3                               ; we are currently working on. We first need to see if
00247Dr 3                               ; WORKWORD has the nt (: started the word) or the
00247Dr 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
00247Dr 3  24 rr                        bit status
00247Fr 3  70 0C                        bvs @nt_in_workword
002481r 3               
002481r 3                               ; This is a special :NONAME word. Just copy the xt
002481r 3                               ; from WORKWORD into the dictionary.
002481r 3  A5 rr                        lda workword
002483r 3  91 rr                        sta (cp),y
002485r 3  C8                           iny
002486r 3  A5 rr                        lda workword+1
002488r 3  91 rr                        sta (cp),y
00248Ar 3  C8                           iny
00248Br 3  80 1B                        bra @update_cp
00248Dr 3               
00248Dr 3               @nt_in_workword:
00248Dr 3                               ; This is a regular : word, so the xt is four bytes down
00248Dr 3                               ; from the nt which we saved in WORKWORD. We could probably
00248Dr 3                               ; use NAME>INT here but this is going to be faster, and
00248Dr 3                               ; fast counts with recursion
00248Dr 3  A5 rr                        lda workword            ; LSB
00248Fr 3  18                           clc
002490r 3  69 04                        adc #4
002492r 3  85 rr                        sta tmp1
002494r 3  A5 rr                        lda workword+1          ; MSB
002496r 3  69 00                        adc #0
002498r 3  85 rr                        sta tmp1+1
00249Ar 3               
00249Ar 3  B2 rr                        lda (tmp1)
00249Cr 3  91 rr                        sta (cp),y
00249Er 3  5A                           phy
00249Fr 3  A0 01                        ldy #1
0024A1r 3  B1 rr                        lda (tmp1),y
0024A3r 3  7A                           ply
0024A4r 3  C8                           iny
0024A5r 3  91 rr                        sta (cp),y
0024A7r 3  C8                           iny
0024A8r 3               
0024A8r 3               @update_cp:
0024A8r 3  98                           tya
0024A9r 3  18                           clc
0024AAr 3  65 rr                        adc cp
0024ACr 3  85 rr                        sta cp
0024AEr 3  90 02                        bcc @done
0024B0r 3  E6 rr                        inc cp+1
0024B2r 3               @done:
0024B2r 3  60           z_recurse:      rts
0024B3r 3               
0024B3r 3               
0024B3r 3               
0024B3r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
0024B3r 3               ; ## "refill"  tested  ANS core ext
0024B3r 3                       ; """https://forth-standard.org/standard/core/REFILL
0024B3r 3                       ; Attempt to fill the input buffer from the input source, returning
0024B3r 3                       ; a true flag if successful. When the input source is the user input
0024B3r 3                       ; device, attempt to receive input into the terminal input buffer. If
0024B3r 3                       ; successful, make the result the input buffer, set >IN to zero, and
0024B3r 3                       ; return true. Receipt of a line containing no characters is considered
0024B3r 3                       ; successful. If there is no input available from the current input
0024B3r 3                       ; source, return false. When the input source is a string from EVALUATE,
0024B3r 3                       ; return false and perform no other action." See
0024B3r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
0024B3r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
0024B3r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
0024B3r 3                       ; entire block as a 1024 byte string.
0024B3r 3                       ; """"
0024B3r 3               
0024B3r 3               xt_refill:
0024B3r 3                               ; Get input source from SOURCE-ID. This is an
0024B3r 3                               ; optimized version of a subroutine jump to SOURCE-ID
0024B3r 3  A5 rr                        lda insrc               ; cheat: We only check LSB
0024B5r 3  D0 2D                        bne @src_not_kbd
0024B7r 3               
0024B7r 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
0024B7r 3                               ; with ACCEPT, which wants the address of the current input
0024B7r 3                               ; buffer NOS and the max number of characters to accept TOS
0024B7r 3  CA                           dex
0024B8r 3  CA                           dex
0024B9r 3  CA                           dex
0024BAr 3  CA                           dex
0024BBr 3               
0024BBr 3  A5 rr                        lda cib                 ; address of CIB is NOS
0024BDr 3  95 02                        sta 2,x
0024BFr 3  A5 rr                        lda cib+1
0024C1r 3  95 03                        sta 3,x
0024C3r 3               
0024C3r 3  64 rr                        stz ciblen              ; go in with empty buffer
0024C5r 3  64 rr                        stz ciblen+1
0024C7r 3               
0024C7r 3  A9 FF                        lda #bsize              ; max number of chars is TOS
0024C9r 3  95 00                        sta 0,x
0024CBr 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
0024CDr 3               
0024CDr 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
0024D0r 3               
0024D0r 3                               ; ACCEPT returns the number of characters accepted, which
0024D0r 3                               ; belong in CIBLEN
0024D0r 3  B5 00                        lda 0,x
0024D2r 3  85 rr                        sta ciblen
0024D4r 3  B5 01                        lda 1,x
0024D6r 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
0024D8r 3               
0024D8r 3                               ; make >IN point to beginning of buffer
0024D8r 3  64 rr                        stz toin
0024DAr 3  64 rr                        stz toin+1
0024DCr 3               
0024DCr 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
0024DEr 3  95 00                        sta 0,x
0024E0r 3  95 01                        sta 1,x
0024E2r 3               
0024E2r 3  80 10                        bra @done
0024E4r 3               
0024E4r 3               @src_not_kbd:
0024E4r 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
0024E4r 3                               ; memory or a file (remember, no blocks in this version).
0024E4r 3                               ; If source is a string, we were given the flag -1 ($FFFF)
0024E4r 3  1A                           inc
0024E5r 3  D0 08                        bne @src_not_string
0024E7r 3               
0024E7r 3                               ; Simply return FALSE flag as per specification
0024E7r 3  CA                           dex
0024E8r 3  CA                           dex
0024E9r 3  74 00                        stz 0,x
0024EBr 3  74 01                        stz 1,x
0024EDr 3               
0024EDr 3  80 05                        bra z_refill
0024EFr 3               
0024EFr 3               @src_not_string:
0024EFr 3                               ; Since we don't have blocks, this must mean that we are trying
0024EFr 3                               ; to read from a file. However, we don't have files yet, so we
0024EFr 3                               ; report an error and jump to ABORT.
0024EFr 3  A9 01                        lda #err_badsource
0024F1r 3  4C rr rr                     jmp error
0024F4r 3               @done:
0024F4r 3  60           z_refill:       rts
0024F5r 3               
0024F5r 3               
0024F5r 3               
0024F5r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
0024F5r 3               ; ## "repeat"  auto  ANS core
0024F5r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
0024F5r 3               
0024F5r 3               xt_repeat:
0024F5r 3                               ; Run again first
0024F5r 3  20 rr rr                     jsr xt_again
0024F8r 3               
0024F8r 3                               ; Stuff HERE in for the branch address
0024F8r 3                               ; to get out of the loop
0024F8r 3  20 rr rr                     jsr xt_here
0024FBr 3  20 rr rr                     jsr xt_swap
0024FEr 3  20 rr rr                     jsr xt_store
002501r 3               
002501r 3  60           z_repeat:       rts
002502r 3               
002502r 3               
002502r 3               
002502r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
002502r 3               ; ## "]"  auto  ANS core
002502r 3                       ; """https://forth-standard.org/standard/right-bracket
002502r 3                       ; This is an immediate word.
002502r 3                       ; """
002502r 3               xt_right_bracket:
002502r 3  A9 FF                        lda #$FF
002504r 3  85 rr                        sta state
002506r 3  85 rr                        sta state+1
002508r 3               z_right_bracket:
002508r 3  60                           rts
002509r 3               
002509r 3               
002509r 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
002509r 3               ; ## "root-wordlist"  tested  Tali Editor
002509r 3               xt_root_wordlist:
002509r 3  CA                           dex             ; The WID for the Root wordlist is 3.
00250Ar 3  CA                           dex
00250Br 3  A9 03                        lda #3
00250Dr 3  95 00                        sta 0,x
00250Fr 3  74 01                        stz 1,x
002511r 3               
002511r 3               z_root_wordlist:
002511r 3  60                           rts
002512r 3               
002512r 3               
002512r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
002512r 3               ; ## "rot"  auto  ANS core
002512r 3                       ; """https://forth-standard.org/standard/core/ROT
002512r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
002512r 3                       ; on top!
002512r 3                       ; """
002512r 3               
002512r 3               xt_rot:
002512r 3  20 rr rr                     jsr underflow_3
002515r 3               
002515r 3  B4 05                        ldy 5,x         ; MSB first
002517r 3  B5 03                        lda 3,x
002519r 3  95 05                        sta 5,x
00251Br 3  B5 01                        lda 1,x
00251Dr 3  95 03                        sta 3,x
00251Fr 3  94 01                        sty 1,x
002521r 3               
002521r 3  B4 04                        ldy 4,x         ; LSB next
002523r 3  B5 02                        lda 2,x
002525r 3  95 04                        sta 4,x
002527r 3  B5 00                        lda 0,x
002529r 3  95 02                        sta 2,x
00252Br 3  94 00                        sty 0,x
00252Dr 3               
00252Dr 3  60           z_rot:          rts
00252Er 3               
00252Er 3               
00252Er 3               
00252Er 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
00252Er 3               ; ## "rshift"  auto  ANS core
00252Er 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
00252Er 3               xt_rshift:
00252Er 3  20 rr rr                     jsr underflow_2
002531r 3               
002531r 3                               ; We shift maximal by 16 bits, mask everything else
002531r 3  B5 00                        lda 0,x
002533r 3  29 0F                        and #%00001111
002535r 3  F0 08                        beq @done               ; if 0 shifts, quit
002537r 3               
002537r 3  A8                           tay
002538r 3               @loop:
002538r 3  56 03                        lsr 3,x
00253Ar 3  76 02                        ror 2,x
00253Cr 3  88                           dey
00253Dr 3  D0 F9                        bne @loop
00253Fr 3               @done:
00253Fr 3  E8                           inx
002540r 3  E8                           inx
002541r 3               
002541r 3  60           z_rshift:       rts
002542r 3               
002542r 3               
002542r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002542r 3               ; ## "s\""  auto  ANS core
002542r 3                       ; """https://forth-standard.org/standard/core/Seq
002542r 3                       ; Store address and length of string given, returning ( addr u ).
002542r 3                       ; ANS core claims this is compile-only, but the file set expands it
002542r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002542r 3                       ; are evil. We follow general usage. This is just like S" except
002542r 3                       ; that it allows for some special escaped characters.
002542r 3                       ; """
002542r 3               
002542r 3               xt_s_backslash_quote:
002542r 3                               ; tmp2 will be used to determine if we are handling
002542r 3                               ; escaped characters or not. In this case, we are,
002542r 3                               ; so set it to $FF (the upper byte will be used to
002542r 3                               ; determine if we just had a \ and the next character
002542r 3                               ; needs to be modifed as an escaped character).
002542r 3  A9 FF                        lda #$FF
002544r 3  85 rr                        sta tmp2
002546r 3  64 rr                        stz tmp2+1
002548r 3               
002548r 3                               ; Now that the flag is set, jump into s_quote to process
002548r 3                               ; the string.
002548r 3  20 rr rr                     jsr s_quote_start
00254Br 3               @done:
00254Br 3               z_s_backslash_quote:
00254Br 3  60                           rts
00254Cr 3               
00254Cr 3               
00254Cr 3               ; This is a helper function for s_backslash_quote to convert a character
00254Cr 3               ; from ASCII to the corresponding hex value, eg 'F'->15
00254Cr 3               convert_hex_value:
00254Cr 3               
00254Cr 3  C9 41                cmp #'A'
00254Er 3  90 07                bcc @digit
002550r 3               
002550r 3                       ; It's A-F
002550r 3  29 DF                and #$DF                ; Make it uppercase.
002552r 3  38                   sec
002553r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
002555r 3  80 03                bra @done
002557r 3               
002557r 3               @digit:
002557r 3                       ; It's 0-9
002557r 3  38                   sec
002558r 3  E9 30                sbc #'0'
00255Ar 3               
00255Ar 3               @done:
00255Ar 3  60                   rts
00255Br 3               
00255Br 3               
00255Br 3               
00255Br 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
00255Br 3               ; ## "search-wordlist" auto ANS search
00255Br 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
00255Br 3               
00255Br 3               xt_search_wordlist:
00255Br 3  20 rr rr                     jsr underflow_3
00255Er 3               
00255Er 3                               ; Set up tmp1 with the wordlist indicated by wid
00255Er 3                               ; on the stack. Start by putting the base address
00255Er 3                               ; of the wordlists in tmp2.
00255Er 3  A5 rr                        lda up
002560r 3  18                           clc
002561r 3  69 06                        adc #wordlists_offset
002563r 3  85 rr                        sta tmp2
002565r 3  A5 rr                        lda up+1
002567r 3  69 00                        adc #0          ; Adding carry
002569r 3  85 rr                        sta tmp2+1
00256Br 3               
00256Br 3                               ; Add the wid (in cells) to the base address.
00256Br 3  B5 00                        lda 0,x
00256Dr 3  0A                           asl             ; Convert wid to offset in cells (x2)
00256Er 3  65 rr                        adc tmp2
002570r 3  85 rr                        sta tmp2
002572r 3  90 02                        bcc @1
002574r 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
002576r 3               
002576r 3                               ; tmp2 now holds the address of the dictionary pointer
002576r 3                               ; for the given wordlist.
002576r 3               @1:
002576r 3                               ; Remove the wid from the stack.
002576r 3  E8                           inx
002577r 3  E8                           inx
002578r 3               
002578r 3                               ; check for special case of an empty string (length zero)
002578r 3  B5 00                        lda 0,x
00257Ar 3  15 01                        ora 1,x
00257Cr 3  D0 03                        bne @check_wordlist
00257Er 3  4C rr rr                     jmp @done
002581r 3               
002581r 3               @check_wordlist:
002581r 3                               ; Check for special case of empty wordlist
002581r 3                               ; (dictionary pointer, in tmp2, is 0)
002581r 3  A5 rr                        lda tmp2
002583r 3  05 rr                        ora tmp2+1
002585r 3  D0 03                        bne @have_string
002587r 3  4C rr rr                     jmp @done
00258Ar 3               
00258Ar 3               @have_string:
00258Ar 3                               ; set up first loop iteration
00258Ar 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
00258Cr 3  85 rr                        sta tmp1
00258Er 3               
00258Er 3  E6 rr                        inc tmp2                ; Move to the upper byte
002590r 3  D0 02                        bne @2
002592r 3  E6 rr                        inc tmp2+1
002594r 3               @2:
002594r 3  B2 rr                        lda (tmp2)
002596r 3  85 rr                        sta tmp1+1
002598r 3               
002598r 3                               ; Reuse tmp2 to hold the address of the mystery string.
002598r 3  B5 02                        lda 2,x                 ; Address of mystery string
00259Ar 3  85 rr                        sta tmp2
00259Cr 3  B5 03                        lda 3,x
00259Er 3  85 rr                        sta tmp2+1
0025A0r 3               
0025A0r 3               @loop:
0025A0r 3                               ; first quick test: Are strings the same length?
0025A0r 3  B2 rr                        lda (tmp1)
0025A2r 3  D5 00                        cmp 0,x
0025A4r 3  D0 7B                        bne @next_entry
0025A6r 3               
0025A6r 3               @compare_string:
0025A6r 3                               ; are the same length, so we now have to compare each
0025A6r 3                               ; character
0025A6r 3               
0025A6r 3                               ; second quick test: Is the first character the same?
0025A6r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
0025A8r 3               
0025A8r 3                               ; Lowercase the incoming charcter.
0025A8r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
0025AAr 3  B0 07                        bcs @compare_first
0025ACr 3  C9 41                        cmp #$41        ; ASCII 'A'
0025AEr 3  90 03                        bcc @compare_first
0025B0r 3               
0025B0r 3                               ; An uppercase letter has been located.  Make it
0025B0r 3                               ; lowercase.
0025B0r 3  18                           clc
0025B1r 3  69 20                        adc #$20
0025B3r 3               
0025B3r 3               @compare_first:
0025B3r 3  A0 08                        ldy #8          ; Offset in nt to name
0025B5r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
0025B7r 3  D0 68                        bne @next_entry
0025B9r 3               
0025B9r 3                               ; string length are the same and the first character is the
0025B9r 3                               ; same. If the length of the string is 1, we're already done
0025B9r 3  B5 00                        lda 0,x
0025BBr 3  3A                           dec
0025BCr 3  F0 2C                        beq @success
0025BEr 3               
0025BEr 3                               ; No such luck: The strings are the same length and the first
0025BEr 3                               ; char is the same, but the word is more than one char long.
0025BEr 3                               ; So we suck it up and compare every single character. We go
0025BEr 3                               ; from back to front, because words like CELLS and CELL+ would
0025BEr 3                               ; take longer otherwise. We can also shorten the loop by one
0025BEr 3                               ; because we've already compared the first char.
0025BEr 3               
0025BEr 3                               ; The string of the word we're testing against is 8 bytes down
0025BEr 3  A5 rr                        lda tmp1
0025C0r 3  48                           pha             ; Preserve tmp1 on the return stack.
0025C1r 3  18                           clc
0025C2r 3  69 08                        adc #8
0025C4r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
0025C6r 3  A5 rr                        lda tmp1+1
0025C8r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
0025C9r 3  69 00                        adc #0          ; we only need the carry
0025CBr 3  85 rr                        sta tmp1+1
0025CDr 3               
0025CDr 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0025CFr 3  88                           dey
0025D0r 3               
0025D0r 3               @string_loop:
0025D0r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
0025D2r 3               
0025D2r 3                               ; Lowercase the incoming charcter.
0025D2r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0025D4r 3  B0 07                        bcs @check_char
0025D6r 3  C9 41                        cmp #$41        ; ASCII 'A'
0025D8r 3  90 03                        bcc @check_char
0025DAr 3               
0025DAr 3                               ; An uppercase letter has been located.  Make it
0025DAr 3                               ; lowercase.
0025DAr 3  18                           clc
0025DBr 3  69 20                        adc #$20
0025DDr 3               @check_char:
0025DDr 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
0025DFr 3  D0 3A                        bne @next_entry_tmp1
0025E1r 3               
0025E1r 3  88                           dey
0025E2r 3  D0 EC                        bne @string_loop
0025E4r 3               
0025E4r 3               @success_tmp1:
0025E4r 3  68                           pla             ; Restore tmp1 from the return stack.
0025E5r 3  85 rr                        sta tmp1+1
0025E7r 3  68                           pla
0025E8r 3  85 rr                        sta tmp1
0025EAr 3               
0025EAr 3               @success:
0025EAr 3                               ; The strings match. Drop the count and put correct nt TOS
0025EAr 3  E8                           inx
0025EBr 3  E8                           inx
0025ECr 3  A5 rr                        lda tmp1
0025EEr 3  95 00                        sta 0,x
0025F0r 3  A5 rr                        lda tmp1+1
0025F2r 3  95 01                        sta 1,x
0025F4r 3               
0025F4r 3                               ; Change the nt into an xt, but save a copy of the nt
0025F4r 3                               ; to look up whether the word is immediate or not.
0025F4r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0025F7r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0025FAr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0025FDr 3               
0025FDr 3  A0 00                        ldy #0                  ; Prepare flag
0025FFr 3               
0025FFr 3                               ; The flags are in the second byte of the header
0025FFr 3  F6 00                        inc 0,x
002601r 3  D0 02                        bne @3
002603r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
002605r 3               @3:
002605r 3  A1 00                        lda (0,x)               ; ( xt char )
002607r 3  29 04                        and #IM
002609r 3  D0 08                        bne @immediate          ; bit set, we're immediate
00260Br 3               
00260Br 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
00260Dr 3  95 00                        sta 0,x
00260Fr 3  95 01                        sta 1,x
002611r 3  80 28                        bra @done_nodrop
002613r 3               
002613r 3               @immediate:
002613r 3  A9 01                        lda #1                  ; We're immediate, return 1
002615r 3  95 00                        sta 0,x
002617r 3  74 01                        stz 1,x
002619r 3               
002619r 3  80 20                        bra @done_nodrop
00261Br 3               
00261Br 3               @next_entry_tmp1:
00261Br 3  68                           pla             ; Restore tmp1 from the return stack.
00261Cr 3  85 rr                        sta tmp1+1
00261Er 3  68                           pla
00261Fr 3  85 rr                        sta tmp1
002621r 3               @next_entry:
002621r 3                               ; Not the same, so we get the next word. Next header
002621r 3                               ; address is two bytes down
002621r 3  A0 02                        ldy #2
002623r 3  B1 rr                        lda (tmp1),y
002625r 3  48                           pha
002626r 3  C8                           iny
002627r 3  B1 rr                        lda (tmp1),y
002629r 3  85 rr                        sta tmp1+1
00262Br 3  68                           pla
00262Cr 3  85 rr                        sta tmp1
00262Er 3               
00262Er 3                               ; If we got a zero, we've walked the whole Dictionary and
00262Er 3                               ; return as a failure, otherwise try again
00262Er 3  05 rr                        ora tmp1+1
002630r 3  F0 03                        beq @fail_done
002632r 3  4C rr rr                     jmp @loop
002635r 3               
002635r 3               @fail_done:
002635r 3  74 02                        stz 2,x         ; failure flag
002637r 3  74 03                        stz 3,x
002639r 3               @done:
002639r 3  E8                           inx
00263Ar 3  E8                           inx
00263Br 3               @done_nodrop:
00263Br 3               z_search_wordlist:
00263Br 3  60                           rts
00263Cr 3               
00263Cr 3               
00263Cr 3               
00263Cr 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
00263Cr 3               ; ## "see" tested  ANS tools
00263Cr 3                       ; """https://forth-standard.org/standard/tools/SEE
00263Cr 3                       ; SEE takes the name of a word and prints its name token (nt),
00263Cr 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
00263Cr 3                       ; code and disassembles it.
00263Cr 3                       ; """
00263Cr 3               
00263Cr 3               xt_see:
00263Cr 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00263Fr 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
002642r 3               
002642r 3                               ; If we got back a zero we don't know that word and so we quit
002642r 3                               ; with an error
002642r 3  B5 00                        lda 0,x
002644r 3  15 01                        ora 1,x
002646r 3  D0 05                        bne @1
002648r 3               
002648r 3  A9 05                        lda #err_noname
00264Ar 3  4C rr rr                     jmp error
00264Dr 3               @1:
00264Dr 3  20 rr rr                     jsr xt_cr
002650r 3               
002650r 3                               ; We have a legal word, so let's get serious. Save the current
002650r 3                               ; number base and use hexadecimal instead.
002650r 3  A5 rr                        lda base
002652r 3  48                           pha
002653r 3  20 rr rr                     jsr xt_hex
002656r 3               
002656r 3  A9 0A                        lda #str_see_nt
002658r 3  20 rr rr                     jsr print_string_no_lf
00265Br 3               
00265Br 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00265Er 3  20 rr rr                     jsr xt_u_dot
002661r 3  20 rr rr                     jsr xt_space            ; ( nt )
002664r 3               
002664r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002667r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
00266Ar 3               
00266Ar 3  A9 0B                        lda #str_see_xt
00266Cr 3  20 rr rr                     jsr print_string_no_lf
00266Fr 3               
00266Fr 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
002672r 3  20 rr rr                     jsr xt_u_dot
002675r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
002678r 3               
002678r 3                               ; We print letters for flags and then later follow it with 1 or
002678r 3                               ; 0 to mark if which flag is set
002678r 3  A9 09                        lda #str_see_flags
00267Ar 3  20 rr rr                     jsr print_string_no_lf
00267Dr 3               
00267Dr 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
002680r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
002683r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
002686r 3               
002686r 3  B5 00                        lda 0,x
002688r 3               
002688r 3                               ; This is crude, but for the moment it is good enough
002688r 3  A0 06                        ldy #6                  ; Not all bits are used
00268Ar 3               @flag_loop:
00268Ar 3  48                           pha
00268Br 3  29 01                        and #%00000001
00268Dr 3  18                           clc
00268Er 3  69 30                        adc #$30                ; ASCII "0"
002690r 3  20 rr rr                     jsr emit_a
002693r 3  20 rr rr                     jsr xt_space
002696r 3               
002696r 3  68                           pla
002697r 3  6A                           ror                     ; Next flag
002698r 3               
002698r 3  88                           dey
002699r 3  D0 EF                        bne @flag_loop
00269Br 3               
00269Br 3  20 rr rr                     jsr xt_cr
00269Er 3               
00269Er 3  E8                           inx
00269Fr 3  E8                           inx                     ; ( nt xt )
0026A0r 3               
0026A0r 3                               ; Figure out the size
0026A0r 3  A9 0C                        lda #str_see_size
0026A2r 3  20 rr rr                     jsr print_string_no_lf
0026A5r 3               
0026A5r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
0026A8r 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
0026ABr 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
0026AEr 3  20 rr rr                     jsr xt_decimal
0026B1r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
0026B4r 3  20 rr rr                     jsr xt_hex
0026B7r 3  20 rr rr                     jsr xt_cr
0026BAr 3               
0026BAr 3                               ; Dump hex and disassemble
0026BAr 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
0026BDr 3  20 rr rr                     jsr xt_dump
0026C0r 3  20 rr rr                     jsr xt_cr
0026C3r 3  20 rr rr                     jsr xt_disasm
0026C6r 3               
0026C6r 3  68                           pla
0026C7r 3  85 rr                        sta base
0026C9r 3               
0026C9r 3  60           z_see:          rts
0026CAr 3               
0026CAr 3               
0026CAr 3               
0026CAr 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
0026CAr 3               ; ## "set-current" auto ANS search
0026CAr 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
0026CAr 3               
0026CAr 3               xt_set_current:
0026CAr 3  20 rr rr                     jsr underflow_1
0026CDr 3               
0026CDr 3                               ; Save the value from the data stack.
0026CDr 3  A0 04                        ldy #current_offset
0026CFr 3  B5 00                        lda 0,x         ; CURRENT is byte variable
0026D1r 3  91 rr                        sta (up),y      ; so only the LSB is used.
0026D3r 3               
0026D3r 3  E8                           inx
0026D4r 3  E8                           inx
0026D5r 3               
0026D5r 3  60           z_set_current:  rts
0026D6r 3               
0026D6r 3               
0026D6r 3               
0026D6r 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
0026D6r 3               ; ## "set-order" auto ANS search
0026D6r 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
0026D6r 3               
0026D6r 3               xt_set_order:
0026D6r 3                               ; Test for -1 TOS
0026D6r 3  A9 FF                        lda #$FF
0026D8r 3  D5 01                        cmp 1,x
0026DAr 3  D0 12                        bne @start
0026DCr 3  D5 00                        cmp 0,x
0026DEr 3  D0 0E                        bne @start
0026E0r 3               
0026E0r 3                               ; There is a -1 TOS.  Replace it with the default
0026E0r 3                               ; search order, which is just the FORTH-WORDLIST.
0026E0r 3  CA                           dex             ; Make room for the count.
0026E1r 3  CA                           dex
0026E2r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
0026E4r 3  A9 03                        lda #3
0026E6r 3  95 02                        sta 2,x
0026E8r 3  74 01                        stz 1,x         ; Count is 1.
0026EAr 3  A9 01                        lda #1
0026ECr 3  95 00                        sta 0,x
0026EEr 3               
0026EEr 3                               ; Continue processing with ( forth-wordlist 1 -- )
0026EEr 3               @start:
0026EEr 3                               ; Set #ORDER - the number of wordlists in the search order.
0026EEr 3  A0 1E                        ldy #num_order_offset
0026F0r 3  B5 00                        lda 0,x
0026F2r 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
0026F4r 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
0026F6r 3                                               ; Only the low byte is saved in tmp1 as
0026F6r 3                                               ; only 8 wordlists are allowed.
0026F6r 3               
0026F6r 3  E8                           inx             ; Drop the count off the data stack.
0026F7r 3  E8                           inx
0026F8r 3               
0026F8r 3                               ; Check if there are zero wordlists.
0026F8r 3  A5 rr                        lda tmp1
0026FAr 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
0026FCr 3               
0026FCr 3                               ; Move the wordlist ids from the data stack to the search order.
0026FCr 3  A0 1F                        ldy #search_order_offset
0026FEr 3               @loop:
0026FEr 3                               ; Move one wordlist id over into the search order.
0026FEr 3  B5 00                        lda 0,x         ; The search order is a byte array
002700r 3  91 rr                        sta (up),y      ; so only save the LSB
002702r 3  C8                           iny
002703r 3               
002703r 3                               ; Remove it from the data stack.
002703r 3  E8                           inx
002704r 3  E8                           inx
002705r 3               
002705r 3                               ; See if that was the last one to process (first in the list).
002705r 3  C6 rr                        dec tmp1
002707r 3  D0 F5                        bne @loop
002709r 3               
002709r 3               @done:
002709r 3  60           z_set_order:    rts
00270Ar 3               
00270Ar 3               
00270Ar 3               
00270Ar 3               
00270Ar 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
00270Ar 3               ; ## "s""  auto  ANS core
00270Ar 3                       ; """https://forth-standard.org/standard/core/Sq
00270Ar 3                       ; Store address and length of string given, returning ( addr u ).
00270Ar 3                       ; ANS core claims this is compile-only, but the file set expands it
00270Ar 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
00270Ar 3                       ; are evil. We follow general usage.
00270Ar 3                       ;
00270Ar 3                       ; Can also be realized as
00270Ar 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
00270Ar 3                       ; but it is used so much we want it in code.
00270Ar 3                       ; """
00270Ar 3               
00270Ar 3               xt_s_quote:
00270Ar 3                               ; tmp2 will be used to determine if we are handling
00270Ar 3                               ; escaped characters or not.  In this case, we are
00270Ar 3                               ; not, so set it to zero.
00270Ar 3  64 rr                        stz tmp2
00270Cr 3  64 rr                        stz tmp2+1
00270Er 3               
00270Er 3               s_quote_start:
00270Er 3                               ; Make room on the data stack for the address.
00270Er 3  CA                           dex
00270Fr 3  CA                           dex
002710r 3                               ; Make room on the data stack for the count.
002710r 3  CA                           dex
002711r 3  CA                           dex
002712r 3               
002712r 3                               ; Put a jmp over the string data with address to be filled
002712r 3                               ; in later.
002712r 3  A9 4C                        lda #$4C
002714r 3  20 rr rr                     jsr cmpl_a
002717r 3               
002717r 3                               ; Address to be filled in later, just use $4C for the moment
002717r 3  20 rr rr                     jsr cmpl_a
00271Ar 3  20 rr rr                     jsr cmpl_a
00271Dr 3               
00271Dr 3                               ; Save the current value of HERE on the data stack for the
00271Dr 3                               ; address of the string.
00271Dr 3  A5 rr                        lda cp
00271Fr 3  95 02                        sta 2,x
002721r 3  A5 rr                        lda cp+1
002723r 3  95 03                        sta 3,x
002725r 3               
002725r 3               @savechars_loop:
002725r 3                               ; Start saving the string into the dictionary up to the
002725r 3                               ; ending double quote. First, check to see if the input
002725r 3                               ; buffer is empty.
002725r 3  A5 rr                        lda toin+1              ; MSB
002727r 3  C5 rr                        cmp ciblen+1
002729r 3  90 2A                        bcc @input_fine         ; unsigned comparison
00272Br 3               
00272Br 3  A5 rr                        lda toin                ; LSB
00272Dr 3  C5 rr                        cmp ciblen
00272Fr 3  90 24                        bcc @input_fine
002731r 3               
002731r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
002731r 3                               ; which uses tmp2 and tmp3. Save and restore them.
002731r 3  A5 rr                        lda tmp2
002733r 3  48                           pha
002734r 3  A5 rr                        lda tmp2+1
002736r 3  48                           pha
002737r 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
002739r 3  48                           pha
00273Ar 3               
00273Ar 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00273Dr 3               
00273Dr 3  68                           pla
00273Er 3  85 rr                        sta tmp3
002740r 3  68                           pla
002741r 3  85 rr                        sta tmp2+1
002743r 3  68                           pla
002744r 3  85 rr                        sta tmp2
002746r 3               
002746r 3                               ; Check result of refill.
002746r 3  B5 00                        lda 0,x
002748r 3  15 01                        ora 1,x
00274Ar 3  D0 05                        bne @refill_ok
00274Cr 3               
00274Cr 3                               ; Something when wrong with refill.
00274Cr 3  A9 06                        lda #err_refill
00274Er 3  4C rr rr                     jmp error
002751r 3               
002751r 3               @refill_ok:
002751r 3                               ; Remove the refill flag from the data stack.
002751r 3  E8                           inx
002752r 3  E8                           inx
002753r 3               
002753r 3                               ; For refill success, jump back up to the empty check, just in
002753r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
002753r 3                               ; input)
002753r 3  80 D0                        bra @savechars_loop
002755r 3               
002755r 3               @input_fine:
002755r 3                               ; There should be at least one valid char to use.
002755r 3                               ; Calculate it's address at CIB+TOIN into tmp1
002755r 3  A5 rr                        lda cib
002757r 3  18                           clc
002758r 3  65 rr                        adc toin        ; LSB
00275Ar 3  85 rr                        sta tmp1
00275Cr 3  A5 rr                        lda cib+1
00275Er 3  65 rr                        adc toin+1      ; MSB
002760r 3  85 rr                        sta tmp1+1
002762r 3               
002762r 3                               ; Get the character
002762r 3  B2 rr                        lda (tmp1)
002764r 3               
002764r 3                               ; Check to see if we are handling escaped characters.
002764r 3  24 rr                        bit tmp2
002766r 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
002768r 3  4C rr rr                     jmp @regular_char
00276Br 3               
00276Br 3               @handle_escapes:
00276Br 3                               ; We are handling escaped characters.  See if we have
00276Br 3                               ; already seen the backslash.
00276Br 3  24 rr                        bit tmp2+1
00276Dr 3  30 03                        bmi @escaped
00276Fr 3  4C rr rr                     jmp @not_escaped
002772r 3               
002772r 3               @escaped:
002772r 3               
002772r 3                               ; We have seen a backslash (previous character). Check to see if
002772r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
002772r 3                               ; be clear in that case )
002772r 3  70 22                        bvs @check_esc_chars
002774r 3               
002774r 3                               ; We are in the middle of a \x sequence. Check to see if we
002774r 3                               ; are on the first or second digit.
002774r 3  A9 01                        lda #1
002776r 3  24 rr                        bit tmp2+1
002778r 3  D0 10                        bne @esc_x_second_digit
00277Ar 3               
00277Ar 3                               ; First digit.
00277Ar 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
00277Cr 3  B2 rr                        lda (tmp1)  ; Get the char again.
00277Er 3               
00277Er 3                               ; Convert to hex
00277Er 3  20 rr rr                     jsr convert_hex_value
002781r 3               
002781r 3                               ; This is the upper nybble, so move it up.
002781r 3  0A                           asl
002782r 3  0A                           asl
002783r 3  0A                           asl
002784r 3  0A                           asl
002785r 3  85 rr                        sta tmp3    ; Save it for later.
002787r 3  4C rr rr                     jmp @next_character
00278Ar 3               
00278Ar 3               @esc_x_second_digit:
00278Ar 3               
00278Ar 3                               ; We are on the second hex digit of a \x sequence. Clear the
00278Ar 3                               ; escaped character flag (because we are handling it right
00278Ar 3                               ; here)
00278Ar 3  64 rr                        stz tmp2+1
00278Cr 3  B2 rr                        lda (tmp1)
00278Er 3               
00278Er 3                               ; Convert to hex, combine with value in tmp3
00278Er 3  20 rr rr                     jsr convert_hex_value
002791r 3  05 rr                        ora tmp3
002793r 3               
002793r 3  4C rr rr                     jmp @save_character
002796r 3               
002796r 3               @check_esc_chars:
002796r 3                               ; Clear the escaped character flag (because we are
002796r 3                               ; handling it right here)
002796r 3  64 rr                        stz tmp2+1
002798r 3               
002798r 3                               ; Process the escaped character
002798r 3               @check_esc_a:
002798r 3  C9 61                        cmp #'a'
00279Ar 3  D0 05                        bne @check_esc_b
00279Cr 3               
00279Cr 3                               ; BEL (ASCII value 7)
00279Cr 3  A9 07                        lda #7
00279Er 3  4C rr rr                     jmp @save_character
0027A1r 3               
0027A1r 3               @check_esc_b:
0027A1r 3  C9 62                        cmp #'b'
0027A3r 3  D0 05                        bne @check_esc_e
0027A5r 3               
0027A5r 3                               ; Backspace (ASCII value 8)
0027A5r 3  A9 08                        lda #8
0027A7r 3  4C rr rr                     jmp @save_character
0027AAr 3               
0027AAr 3               @check_esc_e:
0027AAr 3  C9 65                        cmp #'e'
0027ACr 3  D0 04                        bne @check_esc_f
0027AEr 3               
0027AEr 3                               ; ESC (ASCII value 27)
0027AEr 3  A9 1B                        lda #27
0027B0r 3  80 75                        bra @save_character
0027B2r 3               
0027B2r 3               @check_esc_f:
0027B2r 3  C9 66                        cmp #'f'
0027B4r 3  D0 04                        bne @check_esc_l
0027B6r 3               
0027B6r 3                               ; FF (ASCII value 12)
0027B6r 3  A9 0C                        lda #12
0027B8r 3  80 6D                        bra @save_character
0027BAr 3               
0027BAr 3               @check_esc_l:
0027BAr 3  C9 6C                        cmp #'l'
0027BCr 3  D0 04                        bne @check_esc_m
0027BEr 3               
0027BEr 3                               ; LF (ASCII value 10)
0027BEr 3  A9 0A                        lda #10
0027C0r 3  80 65                        bra @save_character
0027C2r 3               
0027C2r 3               @check_esc_m:
0027C2r 3                               ; This one is not like the others because we save two
0027C2r 3                               ; characters
0027C2r 3  C9 6D                        cmp #'m'
0027C4r 3  D0 09                        bne @check_esc_n
0027C6r 3               
0027C6r 3                               ; CR/LF pair (ASCII values 13, 10)
0027C6r 3  A9 0D                        lda #13
0027C8r 3  20 rr rr                     jsr cmpl_a
0027CBr 3  A9 0A                        lda #10
0027CDr 3  80 58                        bra @save_character
0027CFr 3               
0027CFr 3               @check_esc_n:
0027CFr 3  C9 6E                        cmp #'n'
0027D1r 3  D0 04                        bne @check_esc_q
0027D3r 3               
0027D3r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
0027D3r 3  A9 0A                        lda #10
0027D5r 3  80 50                        bra @save_character
0027D7r 3               
0027D7r 3               @check_esc_q:
0027D7r 3  C9 71                        cmp #'q'
0027D9r 3  D0 04                        bne @check_esc_r
0027DBr 3               
0027DBr 3                               ; Double quote (ASCII value 34)
0027DBr 3  A9 22                        lda #34
0027DDr 3  80 48                        bra @save_character
0027DFr 3               
0027DFr 3               @check_esc_r:
0027DFr 3  C9 72                        cmp #'r'
0027E1r 3  D0 04                        bne @check_esc_t
0027E3r 3               
0027E3r 3                               ; CR (ASCII value 13)
0027E3r 3  A9 0D                        lda #13
0027E5r 3  80 40                        bra @save_character
0027E7r 3               
0027E7r 3               @check_esc_t:
0027E7r 3  C9 74                        cmp #'t'
0027E9r 3  D0 04                        bne @check_esc_v
0027EBr 3               
0027EBr 3                               ; Horizontal TAB (ASCII value 9)
0027EBr 3  A9 09                        lda #9
0027EDr 3  80 38                        bra @save_character
0027EFr 3               
0027EFr 3               @check_esc_v:
0027EFr 3  C9 76                        cmp #'v'
0027F1r 3  D0 04                        bne @check_esc_z
0027F3r 3               
0027F3r 3                               ; Vertical TAB (ASCII value 11)
0027F3r 3  A9 0B                        lda #11
0027F5r 3  80 30                        bra @save_character
0027F7r 3               
0027F7r 3               @check_esc_z:
0027F7r 3  C9 7A                        cmp #'z'
0027F9r 3  D0 04                        bne @check_esc_quote
0027FBr 3               
0027FBr 3                               ; NULL (ASCII value 0)
0027FBr 3  A9 00                        lda #0
0027FDr 3  80 28                        bra @save_character
0027FFr 3               
0027FFr 3               @check_esc_quote:
0027FFr 3  C9 22                        cmp #$22
002801r 3  D0 04                        bne @check_esc_x
002803r 3               
002803r 3                               ; Double quote (ASCII value 34)
002803r 3  A9 22                        lda #34
002805r 3  80 20                        bra @save_character
002807r 3               
002807r 3               @check_esc_x:
002807r 3  C9 78                        cmp #'x'
002809r 3  D0 06                        bne @check_esc_backslash
00280Br 3               
00280Br 3                               ; This one is difficult. We need to get the next TWO
00280Br 3                               ; characters (which might require a refill in the middle)
00280Br 3                               ; and combine them as two hex digits. We do this by
00280Br 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
00280Br 3                               ; and using bit 0 to keep track of which digit we are on.
00280Br 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
00280Dr 3  85 rr                        sta tmp2+1
00280Fr 3  80 19                        bra @next_character
002811r 3               
002811r 3               @check_esc_backslash:
002811r 3  C9 5C                        cmp #$5C
002813r 3  D0 04                        bne @not_escaped
002815r 3               
002815r 3                               ; Backslash (ASCII value 92)
002815r 3  A9 5C                        lda #92
002817r 3  80 0E                        bra @save_character
002819r 3               
002819r 3               @not_escaped:
002819r 3                               ; Check for the backslash to see if we should escape
002819r 3                               ; the next char.
002819r 3  C9 5C                        cmp #$5C        ; The backslash char
00281Br 3  D0 06                        bne @regular_char
00281Dr 3               
00281Dr 3                               ; We found a backslash.  Don't save anyhing, but set
00281Dr 3                               ; a flag (in tmp2+1) to handle the next char. We don't
00281Dr 3                               ; try to get the next char here as it may require a
00281Dr 3                               ; refill of the input buffer.
00281Dr 3  A9 FF                        lda #$FF
00281Fr 3  85 rr                        sta tmp2+1
002821r 3  80 07                        bra @next_character
002823r 3               
002823r 3               @regular_char:
002823r 3                               ; Check if the current character is the end of the string.
002823r 3  C9 22                        cmp #$22        ; ASCII for "
002825r 3  F0 0C                        beq @found_string_end
002827r 3               
002827r 3               @save_character:
002827r 3                               ; If we didn't reach the end of the string, compile this
002827r 3                               ; character into the dictionary
002827r 3  20 rr rr                     jsr cmpl_a
00282Ar 3               
00282Ar 3               @next_character:
00282Ar 3                               ; Move on to the next character.
00282Ar 3  E6 rr                        inc toin
00282Cr 3  D0 02                        bne @savechars_loop_longjump
00282Er 3  E6 rr                        inc toin+1
002830r 3               
002830r 3               @savechars_loop_longjump:
002830r 3  4C rr rr                     jmp @savechars_loop
002833r 3               
002833r 3               @found_string_end:
002833r 3                               ; Use up the delimiter.
002833r 3  E6 rr                        inc toin
002835r 3  D0 02                        bne @1
002837r 3  E6 rr                        inc toin+1
002839r 3               @1:
002839r 3                               ; Calculate the length of the string, which is the
002839r 3                               ; difference between cp and the address of the start
002839r 3                               ; of the string (currently saved on the stack).
002839r 3  A5 rr                        lda cp
00283Br 3  38                           sec
00283Cr 3  F5 02                        sbc 2,x
00283Er 3  95 00                        sta 0,x         ; LSB
002840r 3  A5 rr                        lda cp+1
002842r 3  F5 03                        sbc 3,x
002844r 3  95 01                        sta 1,x         ; MSB
002846r 3               
002846r 3                               ; Update the address of the jump-over jmp instruction.
002846r 3                               ; First determine location of jmp instructions address.
002846r 3                               ; It should be 2 bytes before the start of the string.
002846r 3                               ; Compute it into tmp1, which is no longer being used.
002846r 3  B5 02                        lda 2,x
002848r 3  38                           sec
002849r 3  E9 02                        sbc #2
00284Br 3  85 rr                        sta tmp1
00284Dr 3  B5 03                        lda 3,x
00284Fr 3  E9 00                        sbc #0          ; Propagate borrow
002851r 3  85 rr                        sta tmp1+1
002853r 3               
002853r 3                               ; Update the address of the jump to HERE.
002853r 3  A5 rr                        lda cp
002855r 3  92 rr                        sta (tmp1)
002857r 3  A0 01                        ldy #1
002859r 3  A5 rr                        lda cp+1
00285Br 3  91 rr                        sta (tmp1),y
00285Dr 3               
00285Dr 3                               ; What happens next depends on the state (which is bad, but
00285Dr 3                               ; that's the way it works at the moment). If we are
00285Dr 3                               ; interpretating, we save the string to a transient buffer
00285Dr 3                               ; and return that address (used for file calls, see
00285Dr 3                               ; https://forth-standard.org/standard/file/Sq . If we're
00285Dr 3                               ; compiling, we just need SLITERAL
00285Dr 3  A5 rr                        lda state
00285Fr 3  05 rr                        ora state+1             ; paranoid
002861r 3  F0 03                        beq @done
002863r 3               
002863r 3                               ; Jump into the middle of the sliteral word, after the
002863r 3                               ; string data has been compiled into the dictionary,
002863r 3                               ; because we've already done that step.
002863r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
002866r 3               
002866r 3               @done:
002866r 3  60           z_s_quote:      rts
002867r 3               
002867r 3               
002867r 3               
002867r 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
002867r 3               ; ## "s>d"  auto  ANS core
002867r 3                       ; """https://forth-standard.org/standard/core/StoD"""
002867r 3               
002867r 3               xt_s_to_d:
002867r 3  20 rr rr                     jsr underflow_1
00286Ar 3               
00286Ar 3  CA                           dex
00286Br 3  CA                           dex
00286Cr 3  74 00                        stz 0,x
00286Er 3  74 01                        stz 1,x
002870r 3               
002870r 3  B5 03                        lda 3,x
002872r 3  10 04                        bpl @done
002874r 3               
002874r 3                               ; negative, extend sign
002874r 3  D6 00                        dec 0,x
002876r 3  D6 01                        dec 1,x
002878r 3               @done:
002878r 3  60           z_s_to_d:       rts
002879r 3               
002879r 3               
002879r 3               
002879r 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
002879r 3               ; ## "save-buffers"  tested  ANS block
002879r 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
002879r 3               
002879r 3               xt_save_buffers:
002879r 3                               ; Check the buffer status
002879r 3  A0 2C                        ldy #buffstatus_offset
00287Br 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
00287Dr 3  C9 03                        cmp #3          ; LSB is needed.
00287Fr 3  D0 12                        bne @done       ; Either not used or not dirty = done!
002881r 3               
002881r 3                               ; We need to save the block.
002881r 3  20 rr rr                     jsr xt_blkbuffer
002884r 3  20 rr rr                     jsr xt_buffblocknum
002887r 3  20 rr rr                     jsr xt_fetch
00288Ar 3  20 rr rr                     jsr xt_block_write
00288Dr 3               
00288Dr 3                               ; Mark the buffer as clean now.
00288Dr 3  A9 01                        lda #1
00288Fr 3  A0 2C                        ldy #buffstatus_offset
002891r 3  91 rr                        sta (up),y
002893r 3               
002893r 3               @done:
002893r 3  60           z_save_buffers: rts
002894r 3               
002894r 3               
002894r 3               
002894r 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
002894r 3               ; ## "scr"  auto  ANS block ext
002894r 3                       ; """https://forth-standard.org/standard/block/SCR"""
002894r 3               xt_scr:
002894r 3                               ; SCR is at UP + scr_offset
002894r 3  CA                           dex
002895r 3  CA                           dex
002896r 3  18                           clc
002897r 3  A5 rr                        lda up
002899r 3  69 02                        adc #scr_offset ; Add offset
00289Br 3  95 00                        sta 0,x
00289Dr 3  A5 rr                        lda up+1
00289Fr 3  69 00                        adc #0          ; Adding carry
0028A1r 3  95 01                        sta 1,x
0028A3r 3               
0028A3r 3  60           z_scr:          rts
0028A4r 3               
0028A4r 3               
0028A4r 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
0028A4r 3               ; ## "search"   auto  ANS string
0028A4r 3                       ; """https://forth-standard.org/standard/string/SEARCH
0028A4r 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
0028A4r 3                       ; addr1 u1). If a match is found the flag will be true and
0028A4r 3                       ; addr3 will have the address of the start of the match and u3 will have
0028A4r 3                       ; the number of characters remaining from the match point to the end
0028A4r 3                       ; of the original string1. If a match is not found, the flag will be
0028A4r 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
0028A4r 3                       ; """
0028A4r 3               
0028A4r 3               xt_search:
0028A4r 3  20 rr rr                     jsr underflow_4
0028A7r 3               
0028A7r 3                               ; ANS says if the second string is a zero-length string it
0028A7r 3                               ; automatically matches.
0028A7r 3  B5 00                        lda 0,x
0028A9r 3  15 01                        ora 1,x
0028ABr 3  D0 0B                        bne @start_search
0028ADr 3               
0028ADr 3                               ; The second string is a zero length string.  Just remove
0028ADr 3                               ; the second string and put a true flag.
0028ADr 3  E8                           inx             ; Remove u2
0028AEr 3  E8                           inx
0028AFr 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
0028B1r 3  95 00                        sta 0,x
0028B3r 3  95 01                        sta 1,x
0028B5r 3  4C rr rr                     jmp z_search
0028B8r 3               
0028B8r 3               @start_search:
0028B8r 3                               ; Put an offset (starting at zero) on the stack.
0028B8r 3  20 rr rr                     jsr xt_zero
0028BBr 3               
0028BBr 3               @search_loop:
0028BBr 3                               ; We stop (not found) when u2 + offset > u1
0028BBr 3                               ; Calculate u2+offset into tmp1
0028BBr 3  18                           clc
0028BCr 3  B5 00                        lda 0,x
0028BEr 3  75 02                        adc 2,x
0028C0r 3  85 rr                        sta tmp1
0028C2r 3  B5 01                        lda 1,x
0028C4r 3  75 03                        adc 3,x
0028C6r 3               
0028C6r 3               
0028C6r 3                               ; Compare to u1. Start with the high byte
0028C6r 3  D5 07                        cmp 7,x
0028C8r 3  90 12                        bcc @init_comparison ; Obviously less
0028CAr 3  D0 06                        bne @not_found
0028CCr 3               
0028CCr 3                               ; The upper address byte matched - check the lower byte
0028CCr 3                               ; Load u1 first so we can use just a carry to check.
0028CCr 3  B5 06                        lda 6,x
0028CEr 3  C5 rr                        cmp tmp1
0028D0r 3  B0 0A                        bcs @init_comparison
0028D2r 3               
0028D2r 3               @not_found:
0028D2r 3                               ; The substring isn't in the main string.
0028D2r 3                               ; Return just the main string and a false flag.
0028D2r 3  E8                           inx             ; Remove offset
0028D3r 3  E8                           inx
0028D4r 3  E8                           inx             ; Remove u2
0028D5r 3  E8                           inx
0028D6r 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
0028D8r 3  74 01                        stz 1,x
0028DAr 3  80 66                        bra z_search
0028DCr 3               
0028DCr 3               @init_comparison:
0028DCr 3                               ; Use tmp1 to hold address in string 1.
0028DCr 3                               ; Use tmp2 to hold address in string 2.
0028DCr 3                               ; Use tmp3 to hold the number of characters left to check.
0028DCr 3               
0028DCr 3                               ; Compute the starting address in string 1
0028DCr 3                               ; as addr1 + offset
0028DCr 3  18                           clc
0028DDr 3  B5 08                        lda 8,x
0028DFr 3  75 00                        adc 0,x
0028E1r 3  85 rr                        sta tmp1
0028E3r 3  B5 09                        lda 9,x
0028E5r 3  75 01                        adc 1,x
0028E7r 3  85 rr                        sta tmp1+1
0028E9r 3               
0028E9r 3                               ; The starting address in string 2 is just addr2.
0028E9r 3  B5 04                        lda 4,x
0028EBr 3  85 rr                        sta tmp2
0028EDr 3  B5 05                        lda 5,x
0028EFr 3  85 rr                        sta tmp2+1
0028F1r 3               
0028F1r 3                               ; The number of characters to check is u2.
0028F1r 3  B5 02                        lda 2,x
0028F3r 3  85 rr                        sta tmp3
0028F5r 3  B5 03                        lda 3,x
0028F7r 3  85 rr                        sta tmp3+1
0028F9r 3               
0028F9r 3               @comparison_loop:
0028F9r 3                               ; Check to see if the current characters match.
0028F9r 3  B2 rr                        lda (tmp1)
0028FBr 3  D2 rr                        cmp (tmp2)
0028FDr 3  F0 05                        beq @letters_match
0028FFr 3               
0028FFr 3                               ; One of the letters didn't match.
0028FFr 3                               ; Increment the offset and try again.
0028FFr 3  20 rr rr                     jsr xt_one_plus
002902r 3  80 B7                        bra @search_loop
002904r 3               
002904r 3               @letters_match:
002904r 3                               ; The letters match.  Advance the pointers until the
002904r 3                               ; count reaches zero.
002904r 3  E6 rr                        inc tmp1
002906r 3  D0 02                        bne @1
002908r 3  E6 rr                        inc tmp1+1
00290Ar 3               @1:
00290Ar 3  E6 rr                        inc tmp2
00290Cr 3  D0 02                        bne @2
00290Er 3  E6 rr                        inc tmp2+1
002910r 3               @2:
002910r 3                               ; Decrement the count of remaining letters to check.
002910r 3  A5 rr                        lda tmp3
002912r 3  D0 02                        bne @3
002914r 3  C6 rr                        dec tmp3+1
002916r 3               @3:
002916r 3  C6 rr                        dec tmp3
002918r 3               
002918r 3                               ; Check if we've reached zero.
002918r 3  A5 rr                        lda tmp3
00291Ar 3  05 rr                        ora tmp3+1
00291Cr 3  D0 DB                        bne @comparison_loop ; Check the next letter
00291Er 3               
00291Er 3                               ; We've run out of letters and they all match!
00291Er 3                               ; Return (addr1+offset) (u1-offset) true
00291Er 3                               ; Add offset to addr1.
00291Er 3  18                           clc
00291Fr 3  B5 00                        lda 0,x
002921r 3  75 08                        adc 8,x
002923r 3  95 08                        sta 8,x
002925r 3  B5 01                        lda 1,x
002927r 3  75 09                        adc 9,x
002929r 3  95 09                        sta 9,x
00292Br 3               
00292Br 3                               ; Subtract offset from u1.
00292Br 3  38                           sec
00292Cr 3  B5 06                        lda 6,x
00292Er 3  F5 00                        sbc 0,x
002930r 3  95 06                        sta 6,x
002932r 3  B5 07                        lda 7,x
002934r 3  F5 01                        sbc 1,x
002936r 3  95 07                        sta 7,x
002938r 3               
002938r 3                               ; Replace addr2, u2, and offset with a true flag.
002938r 3  E8                           inx             ; drop offset
002939r 3  E8                           inx
00293Ar 3  E8                           inx             ; drop u2
00293Br 3  E8                           inx
00293Cr 3  A9 FF                        lda #$FF
00293Er 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
002940r 3  95 01                        sta 1,x
002942r 3               
002942r 3  60           z_search:       rts
002943r 3               
002943r 3               
002943r 3               
002943r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
002943r 3               ; ## ";"  auto  ANS core
002943r 3                       ; """https://forth-standard.org/standard/core/Semi
002943r 3                       ; End the compilation of a new word into the Dictionary.
002943r 3                       ;
002943r 3                       ; When we
002943r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
002943r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
002943r 3                       ; A Forth definition would be (see "Starting Forth"):
002943r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
002943r 3                       ; practice of Gforth, we warn here if a word has been redefined.
002943r 3                       ; """
002943r 3               
002943r 3               xt_semicolon:
002943r 3                               ; Check if this is a : word or a :NONAME word.
002943r 3  24 rr                        bit status
002945r 3  70 11                        bvs @colonword
002947r 3               
002947r 3                               ; This is a :NONAME word - just put an RTS on the end and
002947r 3                               ; the address (held in workword) on the stack.
002947r 3  A9 60                        lda #$60                ; opcode for RTS
002949r 3  20 rr rr                     jsr cmpl_a
00294Cr 3               
00294Cr 3  CA                           dex
00294Dr 3  CA                           dex
00294Er 3  A5 rr                        lda workword
002950r 3  95 00                        sta 0,x
002952r 3  A5 rr                        lda workword+1
002954r 3  95 01                        sta 1,x
002956r 3  80 45                        bra @semicolon_done
002958r 3               
002958r 3               @colonword:
002958r 3                               ; CP is the byte that will be the address we use in the
002958r 3                               ; header as the end-of-compile address (z_word). This is
002958r 3                               ; six bytes down from the header
002958r 3  A0 06                        ldy #6
00295Ar 3  A5 rr                        lda cp
00295Cr 3  91 rr                        sta (workword),y
00295Er 3  C8                           iny
00295Fr 3  A5 rr                        lda cp+1
002961r 3  91 rr                        sta (workword),y
002963r 3               
002963r 3                               ; Allocate one further byte and save the RTS instruction
002963r 3                               ; there
002963r 3  A9 60                        lda #$60                ; opcode for RTS
002965r 3  20 rr rr                     jsr cmpl_a
002968r 3               
002968r 3                               ; Before we formally add the word to the Dictionary, we
002968r 3                               ; check to see if it is already present, and if yes, we
002968r 3                               ; warn the user.
002968r 3               
002968r 3                               ; See if word already in Dictionary.
002968r 3                               ; (STATUS bit 7 will be high as CREATE already
002968r 3                               ;  checked for us.)
002968r 3  24 rr                        bit status
00296Ar 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
00296Cr 3               
00296Cr 3                               ; We start by putting the string of the
00296Cr 3                               ; word we're defining on the stack
00296Cr 3  CA                           dex
00296Dr 3  CA                           dex
00296Er 3  CA                           dex
00296Fr 3  CA                           dex
002970r 3               
002970r 3                               ; WORKWORD points to the beginning of the head of our new
002970r 3                               ; word, where the first byte is the length of the string
002970r 3                               ; We can't use LATESTNT because we haven't added the new
002970r 3                               ; word to the Dictionary yet
002970r 3  B2 rr                        lda (workword)
002972r 3  95 00                        sta 0,x
002974r 3  74 01                        stz 1,x
002976r 3               
002976r 3                               ; Eight bytes below WORKWORD is the actual beginning of
002976r 3                               ; the string
002976r 3  A5 rr                        lda workword
002978r 3  18                           clc
002979r 3  69 08                        adc #8
00297Br 3  95 02                        sta 2,x
00297Dr 3  A5 rr                        lda workword+1
00297Fr 3  69 00                        adc #0                  ; only want carry
002981r 3  95 03                        sta 3,x
002983r 3               
002983r 3                               ; This word is already in the Dictionary, so we print a
002983r 3                               ; warning to the user.
002983r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
002985r 3  20 rr rr                     jsr print_string_no_lf
002988r 3               
002988r 3                               ; Now we print the offending word.
002988r 3  20 rr rr                     jsr xt_type
00298Br 3  20 rr rr                     jsr xt_space
00298Er 3               
00298Er 3                               ; Clear bit 7 of status (so future words will print message
00298Er 3                               ; by defaut)
00298Er 3  A9 80                        lda #%10000000
002990r 3  14 rr                        trb status
002992r 3               
002992r 3               @new_word:
002992r 3                               ; Let's get this over with. Save beginning of our word
002992r 3                               ; as new last word in the Dictionary
002992r 3  A5 rr                        lda workword
002994r 3  85 rr                        sta dp
002996r 3  A5 rr                        lda workword+1
002998r 3  85 rr                        sta dp+1
00299Ar 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
00299Dr 3                                                       ; CURRENT wordlist.
00299Dr 3               @semicolon_done:
00299Dr 3                               ; Word definition complete. Return compile flag to zero
00299Dr 3                               ; to return to interpret mode
00299Dr 3  64 rr                        stz state
00299Fr 3  64 rr                        stz state+1
0029A1r 3               
0029A1r 3  60           z_semicolon:    rts
0029A2r 3               
0029A2r 3               
0029A2r 3               
0029A2r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
0029A2r 3               ; ## "sign"  auto  ANS core
0029A2r 3                       ; """https://forth-standard.org/standard/core/SIGN
0029A2r 3                       ;
0029A2r 3                       ; Code based on
0029A2r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0029A2r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
0029A2r 3                       ; """
0029A2r 3               
0029A2r 3               xt_sign:
0029A2r 3  20 rr rr                     jsr underflow_1
0029A5r 3               
0029A5r 3  B5 01                        lda 1,x         ; check MSB of TOS
0029A7r 3  30 04                        bmi @minus
0029A9r 3               
0029A9r 3  E8                           inx
0029AAr 3  E8                           inx
0029ABr 3  80 09                        bra @done
0029ADr 3               @minus:
0029ADr 3  A9 2D                        lda #$2D        ; ASCII for "-"
0029AFr 3  95 00                        sta 0,x         ; overwrite TOS
0029B1r 3  74 01                        stz 1,x         ; paranoid
0029B3r 3               
0029B3r 3  20 rr rr                     jsr xt_hold
0029B6r 3               @done:
0029B6r 3  60           z_sign:         rts
0029B7r 3               
0029B7r 3               
0029B7r 3               
0029B7r 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
0029B7r 3               ; ## "/"  auto  ANS core
0029B7r 3                       ; """https://forth-standard.org/standard/core/Div
0029B7r 3                       ;
0029B7r 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
0029B7r 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
0029B7r 3                       ; This code is currently unoptimized. This code without the SLASH
0029B7r 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
0029B7r 3                       ; """
0029B7r 3               
0029B7r 3               xt_slash:
0029B7r 3                               ; With all the multiplication going on, it would be hard to
0029B7r 3                               ; make sure that one of our temporary variables is not
0029B7r 3                               ; overwritten. We make sure that doesn't happen by taking the
0029B7r 3                               ; hit of pushing the flag to the 65c02's stack
0029B7r 3  A9 00                        lda #0
0029B9r 3  48                           pha
0029BAr 3  80 03                        bra _common
0029BCr 3               
0029BCr 3               xt_slash_mod:
0029BCr 3                               ; Note that /MOD accesses this code
0029BCr 3  A9 FF                        lda #$FF
0029BEr 3  48                           pha             ; falls through to _common
0029BFr 3               
0029BFr 3               _common:
0029BFr 3  20 rr rr                     jsr xt_to_r             ; >R
0029C2r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
0029C5r 3  20 rr rr                     jsr xt_r_from           ; R>
0029C8r 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
0029CBr 3               
0029CBr 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
0029CBr 3                               ; $FF is SLASH MOD
0029CBr 3  68                           pla
0029CCr 3  D0 05                        bne @done
0029CEr 3               
0029CEr 3                               ; The following code is for SLASH only
0029CEr 3  20 rr rr                     jsr xt_swap
0029D1r 3  E8                           inx             ; DROP
0029D2r 3  E8                           inx
0029D3r 3               @done:
0029D3r 3               z_slash_mod:
0029D3r 3  60           z_slash:        rts
0029D4r 3               
0029D4r 3               
0029D4r 3               
0029D4r 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
0029D4r 3               ; ## "/mod"  auto  ANS core
0029D4r 3                       ; """https://forth-standard.org/standard/core/DivMOD
0029D4r 3                       ;
0029D4r 3                       ; This is a dummy entry, the actual code is shared with SLASH
0029D4r 3                       ; """
0029D4r 3               
0029D4r 3               
0029D4r 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
0029D4r 3               ; ## "/string"  auto  ANS string
0029D4r 3                       ; """https://forth-standard.org/standard/string/DivSTRING
0029D4r 3                       ;
0029D4r 3                       ; Forth code is
0029D4r 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
0029D4r 3                       ; Put differently, we need to add TOS and 3OS, and subtract
0029D4r 3                       ; TOS from NOS, and then drop TOS
0029D4r 3                       ; """
0029D4r 3               
0029D4r 3               xt_slash_string:
0029D4r 3  20 rr rr                     jsr underflow_3
0029D7r 3               
0029D7r 3  18                           clc             ; 3OS+TOS
0029D8r 3  B5 00                        lda 0,x
0029DAr 3  75 04                        adc 4,x
0029DCr 3  95 04                        sta 4,x
0029DEr 3               
0029DEr 3  B5 01                        lda 1,x
0029E0r 3  75 05                        adc 5,x
0029E2r 3  95 05                        sta 5,x
0029E4r 3               
0029E4r 3  38                           sec             ; NOS-TOS
0029E5r 3  B5 02                        lda 2,x
0029E7r 3  F5 00                        sbc 0,x
0029E9r 3  95 02                        sta 2,x
0029EBr 3               
0029EBr 3  B5 03                        lda 3,x
0029EDr 3  F5 01                        sbc 1,x
0029EFr 3  95 03                        sta 3,x
0029F1r 3               
0029F1r 3  E8                           inx
0029F2r 3  E8                           inx
0029F3r 3               
0029F3r 3  60           z_slash_string: rts
0029F4r 3               
0029F4r 3               
0029F4r 3               
0029F4r 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
0029F4r 3               ; ## "sliteral" auto  ANS string
0029F4r 3                       ; """https://forth-standard.org/standard/string/SLITERAL
0029F4r 3                       ; Add the runtime for an existing string.
0029F4r 3                       ; """
0029F4r 3               
0029F4r 3               xt_sliteral:
0029F4r 3  20 rr rr                     jsr underflow_2
0029F7r 3               
0029F7r 3                               ; We can't assume that ( addr u ) of the current string is in
0029F7r 3                               ; a stable area (eg. already in the dictionary.) Copy the
0029F7r 3                               ; string data into the dictionary using move.
0029F7r 3               
0029F7r 3                               ; Put a jmp over the string data with address to be filled
0029F7r 3                               ; in later.
0029F7r 3  A9 4C                        lda #$4C
0029F9r 3  20 rr rr                     jsr cmpl_a
0029FCr 3               
0029FCr 3                               ; Address to be filled in later.
0029FCr 3  20 rr rr                     jsr cmpl_a
0029FFr 3  20 rr rr                     jsr cmpl_a
002A02r 3               
002A02r 3                               ; Turn the data stack from ( addr u ) into
002A02r 3                               ; ( here u addr here u ) so move can be called with
002A02r 3                               ; the remaining items on the stack ready for processing.
002A02r 3                               ; Reserve three extra words on the stack.
002A02r 3  8A                           txa
002A03r 3  38                           sec
002A04r 3  E9 06                        sbc #6
002A06r 3  AA                           tax
002A07r 3               
002A07r 3                               ; Move addr down from TOS-4 to TOS-2
002A07r 3  B5 08                        lda 8,x
002A09r 3  95 04                        sta 4,x
002A0Br 3  B5 09                        lda 9,x
002A0Dr 3  95 05                        sta 5,x
002A0Fr 3               
002A0Fr 3                               ; Copy u from TOS-3 to TOS
002A0Fr 3  B5 06                        lda 6,x
002A11r 3  95 00                        sta 0,x
002A13r 3  B5 07                        lda 7,x
002A15r 3  95 01                        sta 1,x
002A17r 3               
002A17r 3                               ; Put HERE into TOS-1 and TOS-4
002A17r 3  A5 rr                        lda cp
002A19r 3  95 08                        sta 8,x
002A1Br 3  95 02                        sta 2,x
002A1Dr 3  A5 rr                        lda cp+1
002A1Fr 3  95 09                        sta 9,x
002A21r 3  95 03                        sta 3,x
002A23r 3               
002A23r 3                               ; Copy the string into the dictionary.
002A23r 3  20 rr rr                     jsr xt_move
002A26r 3               
002A26r 3                               ; Update cp.
002A26r 3  18                           clc
002A27r 3  A5 rr                        lda cp
002A29r 3  75 00                        adc 0,x
002A2Br 3  85 rr                        sta cp
002A2Dr 3  A5 rr                        lda cp+1
002A2Fr 3  75 01                        adc 1,x
002A31r 3  85 rr                        sta cp+1
002A33r 3               
002A33r 3                               ; Update the address of the jump-over jmp instruction.
002A33r 3                               ; First determine location of jmp instructions address.
002A33r 3                               ; It should be 2 bytes before the start of the string.
002A33r 3               
002A33r 3                               ; Compute it into tmp1, which is no longer being used.
002A33r 3  B5 02                        lda 2,x
002A35r 3  38                           sec
002A36r 3  E9 02                        sbc #2
002A38r 3  85 rr                        sta tmp1
002A3Ar 3  B5 03                        lda 3,x
002A3Cr 3  E9 00                        sbc #0          ; Propagate borrow
002A3Er 3  85 rr                        sta tmp1+1
002A40r 3               
002A40r 3                               ; Update the address of the jump to HERE.
002A40r 3  A5 rr                        lda cp
002A42r 3  92 rr                        sta (tmp1)
002A44r 3  A0 01                        ldy #1
002A46r 3  A5 rr                        lda cp+1
002A48r 3  91 rr                        sta (tmp1),y
002A4Ar 3               
002A4Ar 3                               ; Stack is now ( addr2 u ) where addr2 is the new
002A4Ar 3                               ; location in the dictionary.
002A4Ar 3               
002A4Ar 3               sliteral_const_str:
002A4Ar 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
002A4Ar 3                               ; pushes the new ( addr u ) pair to the Data Stack.
002A4Ar 3                               ; When we're done, the code will look like this:
002A4Ar 3               
002A4Ar 3                               ; xt -->    jmp a
002A4Ar 3                               ;           <string data bytes>
002A4Ar 3                               ;  a -->    jsr sliteral_runtime
002A4Ar 3                               ;           <string address>
002A4Ar 3                               ;           <string length>
002A4Ar 3                               ; rts -->
002A4Ar 3               
002A4Ar 3                               ; This means we'll have to adjust the return address for two
002A4Ar 3                               ; cells, not just one
002A4Ar 3  A0 rr                        ldy #>sliteral_runtime
002A4Cr 3  A9 rr                        lda #<sliteral_runtime
002A4Er 3  20 rr rr                     jsr cmpl_subroutine
002A51r 3               
002A51r 3                               ; We want to have the address end up as NOS and the length
002A51r 3                               ; as TOS, so we store the address first
002A51r 3  B4 03                        ldy 3,x                ; address MSB
002A53r 3  B5 02                        lda 2,x                ; address LSB
002A55r 3  20 rr rr                     jsr cmpl_word
002A58r 3               
002A58r 3  B4 01                        ldy 1,x                ; length MSB
002A5Ar 3  B5 00                        lda 0,x                ; length LSB
002A5Cr 3  20 rr rr                     jsr cmpl_word
002A5Fr 3               
002A5Fr 3                               ; clean up and leave
002A5Fr 3  E8                           inx
002A60r 3  E8                           inx
002A61r 3  E8                           inx
002A62r 3  E8                           inx
002A63r 3               
002A63r 3  60           z_sliteral:     rts
002A64r 3               
002A64r 3               
002A64r 3               sliteral_runtime:
002A64r 3               
002A64r 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
002A64r 3                       ; the Data Stack. We arrive here with the return address as the
002A64r 3                       ; top of Return Stack, which points to the address of the string
002A64r 3                       ; """
002A64r 3  CA                           dex
002A65r 3  CA                           dex
002A66r 3  CA                           dex
002A67r 3  CA                           dex
002A68r 3               
002A68r 3                               ; Get the address of the string address off the stack and
002A68r 3                               ; increase by one because of the RTS mechanics
002A68r 3  68                           pla
002A69r 3  85 rr                        sta tmp1        ; LSB of address
002A6Br 3  68                           pla
002A6Cr 3  85 rr                        sta tmp1+1      ; MSB of address
002A6Er 3               
002A6Er 3                               ; Walk through both and save them
002A6Er 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002A70r 3  B1 rr                        lda (tmp1),y
002A72r 3  95 02                        sta 2,x         ; LSB of address
002A74r 3  C8                           iny
002A75r 3               
002A75r 3  B1 rr                        lda (tmp1),y
002A77r 3  95 03                        sta 3,x         ; MSB of address
002A79r 3  C8                           iny
002A7Ar 3               
002A7Ar 3  B1 rr                        lda (tmp1),y
002A7Cr 3  95 00                        sta 0,x         ; LSB of length
002A7Er 3  C8                           iny
002A7Fr 3               
002A7Fr 3  B1 rr                        lda (tmp1),y
002A81r 3  95 01                        sta 1,x         ; MSB of length
002A83r 3               
002A83r 3                               ; restore return address
002A83r 3  18                           clc
002A84r 3  A5 rr                        lda tmp1
002A86r 3  69 04                        adc #4
002A88r 3  A8                           tay             ; LSB
002A89r 3  A5 rr                        lda tmp1+1
002A8Br 3  69 00                        adc #0          ; we only need carry
002A8Dr 3  48                           pha             ; MSB
002A8Er 3  5A                           phy
002A8Fr 3               
002A8Fr 3  60                           rts
002A90r 3               
002A90r 3               
002A90r 3               
002A90r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002A90r 3               ; ## "sm/rem"  auto  ANS core
002A90r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002A90r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002A90r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002A90r 3                       ;
002A90r 3                       ; Forth:
002A90r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002A90r 3                       ; R> ?NEGATE SWAP
002A90r 3                       ; """
002A90r 3               
002A90r 3               xt_sm_slash_rem:
002A90r 3  20 rr rr                     jsr underflow_3 ; contains double number
002A93r 3               
002A93r 3                               ; push MSB of high cell of d to Data Stack so we can check
002A93r 3                               ; its sign later
002A93r 3  B5 03                        lda 3,x
002A95r 3  48                           pha
002A96r 3               
002A96r 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
002A96r 3                               ; its sign later as well
002A96r 3  B5 01                        lda 1,x
002A98r 3  55 03                        eor 3,x
002A9Ar 3  48                           pha
002A9Br 3               
002A9Br 3                               ; Prepare division by getting absolute of n1 and d
002A9Br 3  20 rr rr                     jsr xt_abs
002A9Er 3  E8                           inx             ; pretend we pushed n1 to R
002A9Fr 3  E8                           inx
002AA0r 3               
002AA0r 3  20 rr rr                     jsr xt_dabs
002AA3r 3  CA                           dex
002AA4r 3  CA                           dex
002AA5r 3               
002AA5r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
002AA8r 3               
002AA8r 3                               ; if the XOR compiled above is negative, negate the
002AA8r 3                               ; quotient (n3)
002AA8r 3  68                           pla
002AA9r 3  10 03                        bpl @1
002AABr 3  20 rr rr                     jsr xt_negate
002AAEr 3               @1:
002AAEr 3                               ; if d was negative, negate the remainder (n2)
002AAEr 3  68                           pla
002AAFr 3  10 07                        bpl @done
002AB1r 3               
002AB1r 3  E8                           inx             ; pretend we pushed quotient to R
002AB2r 3  E8                           inx
002AB3r 3  20 rr rr                     jsr xt_negate
002AB6r 3  CA                           dex
002AB7r 3  CA                           dex
002AB8r 3               
002AB8r 3               @done:
002AB8r 3  60           z_sm_slash_rem: rts
002AB9r 3               
002AB9r 3               
002AB9r 3               
002AB9r 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002AB9r 3               ; ## "source"  auto  ANS core
002AB9r 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002AB9r 3               xt_source:
002AB9r 3                               ; add address
002AB9r 3  CA                           dex
002ABAr 3  CA                           dex
002ABBr 3  A5 rr                        lda cib
002ABDr 3  95 00                        sta 0,x
002ABFr 3  A5 rr                        lda cib+1
002AC1r 3  95 01                        sta 1,x
002AC3r 3               
002AC3r 3                               ; add size
002AC3r 3  CA                           dex
002AC4r 3  CA                           dex
002AC5r 3  A5 rr                        lda ciblen
002AC7r 3  95 00                        sta 0,x
002AC9r 3  A5 rr                        lda ciblen+1
002ACBr 3  95 01                        sta 1,x
002ACDr 3               
002ACDr 3  60           z_source:       rts
002ACEr 3               
002ACEr 3               
002ACEr 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002ACEr 3               ; ## "source-id"  tested  ANS core ext
002ACEr 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002ACEr 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002ACEr 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002ACEr 3                       ; string, and a text file gives the fileid.
002ACEr 3                       ; """
002ACEr 3               xt_source_id:
002ACEr 3  CA                           dex
002ACFr 3  CA                           dex
002AD0r 3               
002AD0r 3  A5 rr                        lda insrc
002AD2r 3  95 00                        sta 0,x
002AD4r 3  A5 rr                        lda insrc+1
002AD6r 3  95 01                        sta 1,x
002AD8r 3               
002AD8r 3  60           z_source_id:    rts
002AD9r 3               
002AD9r 3               
002AD9r 3               ; ## SPACE ( -- ) "Print a single space"
002AD9r 3               ; ## "space"  auto  ANS core
002AD9r 3                       ; """https://forth-standard.org/standard/core/SPACE"""
002AD9r 3               xt_space:
002AD9r 3  A9 20                        lda #AscSP
002ADBr 3  20 rr rr                     jsr emit_a
002ADEr 3               
002ADEr 3  60           z_space:        rts
002ADFr 3               
002ADFr 3               
002ADFr 3               ; ## SPACES ( u -- ) "Print a number of spaces"
002ADFr 3               ; ## "spaces"  auto  ANS core
002ADFr 3                       ; """https://forth-standard.org/standard/core/SPACES"""
002ADFr 3               
002ADFr 3               xt_spaces:
002ADFr 3  20 rr rr                     jsr underflow_1
002AE2r 3               
002AE2r 3                               ; catch any zero in TOS fast
002AE2r 3  B5 00                        lda 0,x
002AE4r 3  15 01                        ora 1,x
002AE6r 3  F0 2A                        beq @done
002AE8r 3               
002AE8r 3                               ; Usually we're only going to print far less than 256 spaces,
002AE8r 3                               ; so we create a quick loop for that. Short loop could be realized
002AE8r 3                               ; as a separate subroutine, but unless we're really pressed for
002AE8r 3                               ; memory at some point, this is faster
002AE8r 3  B4 01                        ldy 1,x
002AEAr 3  D0 0C                        bne @lots_of_spaces
002AECr 3               
002AECr 3  B4 00                        ldy 0,x
002AEEr 3               @quick_loop:
002AEEr 3                               ; we reach here knowing that there must be a number that is not
002AEEr 3                               ; zero in the TOS
002AEEr 3  A9 20                        lda #AscSP
002AF0r 3  20 rr rr                     jsr emit_a
002AF3r 3  88                           dey
002AF4r 3  F0 1C                        beq @done
002AF6r 3  80 F6                        bra @quick_loop
002AF8r 3               
002AF8r 3               @lots_of_spaces:
002AF8r 3                               ; We go through the first loop once to get rid of the lower
002AF8r 3                               ; counter byte. This could be zero
002AF8r 3  B4 00                        ldy 0,x
002AFAr 3               
002AFAr 3               @first_slow_loop:
002AFAr 3  F0 08                        beq @slow_outer_loop
002AFCr 3  A9 20                        lda #AscSP
002AFEr 3  20 rr rr                     jsr emit_a
002B01r 3  88                           dey
002B02r 3  80 F6                        bra @first_slow_loop
002B04r 3               
002B04r 3               @slow_outer_loop:
002B04r 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
002B04r 3  A0 00                        ldy #00
002B06r 3               
002B06r 3               @slow_inner_loop:
002B06r 3  A9 20                        lda #AscSP
002B08r 3  20 rr rr                     jsr emit_a
002B0Br 3  88                           dey
002B0Cr 3  D0 F8                        bne @slow_inner_loop
002B0Er 3               
002B0Er 3  D6 01                        dec 1,x
002B10r 3  D0 F2                        bne @slow_outer_loop
002B12r 3               
002B12r 3               @done:
002B12r 3  E8                           inx             ; drop
002B13r 3  E8                           inx
002B14r 3               
002B14r 3  60           z_spaces:       rts
002B15r 3               
002B15r 3               
002B15r 3               
002B15r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
002B15r 3               ; ## "*"  auto  ANS core
002B15r 3                       ; """https://forth-standard.org/standard/core/Times
002B15r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
002B15r 3                       ;
002B15r 3                       ; This is nothing  more than UM* DROP
002B15r 3                       ; """
002B15r 3               
002B15r 3               xt_star:
002B15r 3  20 rr rr                     jsr underflow_2
002B18r 3               
002B18r 3  20 rr rr                     jsr xt_um_star
002B1Br 3  E8                           inx
002B1Cr 3  E8                           inx
002B1Dr 3               
002B1Dr 3  60           z_star:         rts
002B1Er 3               
002B1Er 3               
002B1Er 3               
002B1Er 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
002B1Er 3               ; ## "*/"  auto  ANS core
002B1Er 3                       ; """https://forth-standard.org/standard/core/TimesDiv
002B1Er 3                       ; Multiply n1 by n2 and divide by n3, returning the result
002B1Er 3                       ; without a remainder. This is */MOD without the mod.
002B1Er 3                       ;
002B1Er 3                       ; This word
002B1Er 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
002B1Er 3                       ; pretty much what we do here
002B1Er 3                       ; """
002B1Er 3               xt_star_slash:
002B1Er 3                               ; We let */MOD check for underflow
002B1Er 3  20 rr rr                     jsr xt_star_slash_mod
002B21r 3  20 rr rr                     jsr xt_swap
002B24r 3  E8                           inx
002B25r 3  E8                           inx
002B26r 3               z_star_slash:
002B26r 3  60                           rts
002B27r 3               
002B27r 3               
002B27r 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
002B27r 3               ; ## "*/mod"  auto  ANS core
002B27r 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
002B27r 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
002B27r 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
002B27r 3                       ; single-cell quotient n5.
002B27r 3                       ;
002B27r 3                       ; In Forth, this is
002B27r 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
002B27r 3                       ; """
002B27r 3               xt_star_slash_mod:
002B27r 3  20 rr rr                     jsr underflow_3
002B2Ar 3               
002B2Ar 3  20 rr rr                     jsr xt_to_r
002B2Dr 3  20 rr rr                     jsr xt_m_star
002B30r 3  20 rr rr                     jsr xt_r_from
002B33r 3  20 rr rr                     jsr xt_sm_slash_rem
002B36r 3               
002B36r 3               z_star_slash_mod:
002B36r 3  60                           rts
002B37r 3               
002B37r 3               
002B37r 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002B37r 3               ; ## "state"  auto  ANS core
002B37r 3                       ; """https://forth-standard.org/standard/core/STATE
002B37r 3                       ; STATE is true when in compilation state, false otherwise. Note
002B37r 3                       ; we do not return the state itself, but only the address where
002B37r 3                       ; it lives. The state should not be changed directly by the user; see
002B37r 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002B37r 3                       ; """
002B37r 3               xt_state:
002B37r 3  CA                           dex
002B38r 3  CA                           dex
002B39r 3  A9 rr                        lda #<state
002B3Br 3  95 00                        sta 0,x
002B3Dr 3  A9 rr                        lda #>state
002B3Fr 3  95 01                        sta 1,x
002B41r 3               
002B41r 3  60           z_state:        rts
002B42r 3               
002B42r 3               
002B42r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002B42r 3               ; ## "!"  auto  ANS core
002B42r 3                       ; """https://forth-standard.org/standard/core/Store"""
002B42r 3               xt_store:
002B42r 3  20 rr rr                     jsr underflow_2
002B45r 3               
002B45r 3  B5 02                        lda 2,x         ; LSB
002B47r 3  81 00                        sta (0,x)
002B49r 3               
002B49r 3  F6 00                        inc 0,x
002B4Br 3  D0 02                        bne @1
002B4Dr 3  F6 01                        inc 1,x
002B4Fr 3               @1:
002B4Fr 3  B5 03                        lda 3,x         ; MSB
002B51r 3  81 00                        sta (0,x)
002B53r 3               
002B53r 3  E8                           inx             ; 2DROP
002B54r 3  E8                           inx
002B55r 3  E8                           inx
002B56r 3  E8                           inx
002B57r 3               
002B57r 3  60           z_store:        rts
002B58r 3               
002B58r 3               
002B58r 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
002B58r 3               ; ## "strip-underflow"  tested  Tali Forth
002B58r 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
002B58r 3                       ; checking should be removed during the compilation of new words.
002B58r 3                       ; Default is false.
002B58r 3                       ; """
002B58r 3               xt_strip_underflow:
002B58r 3  CA                           dex
002B59r 3  CA                           dex
002B5Ar 3               
002B5Ar 3  A9 rr                        lda #<uf_strip
002B5Cr 3  95 00                        sta 0,x
002B5Er 3  A9 rr                        lda #>uf_strip
002B60r 3  95 01                        sta 1,x
002B62r 3               
002B62r 3               z_strip_underflow:
002B62r 3  60                           rts
002B63r 3               
002B63r 3               
002B63r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
002B63r 3               ; ## "swap"  auto  ANS core
002B63r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
002B63r 3               xt_swap:
002B63r 3  20 rr rr                     jsr underflow_2
002B66r 3               
002B66r 3  B5 00                        lda 0,x         ; LSB
002B68r 3  B4 02                        ldy 2,x
002B6Ar 3  95 02                        sta 2,x
002B6Cr 3  94 00                        sty 0,x
002B6Er 3               
002B6Er 3  B5 01                        lda 1,x         ; MSB
002B70r 3  B4 03                        ldy 3,x
002B72r 3  95 03                        sta 3,x
002B74r 3  94 01                        sty 1,x
002B76r 3               
002B76r 3  60           z_swap:         rts
002B77r 3               
002B77r 3               
002B77r 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
002B77r 3               ; ## "then"  auto  ANS core
002B77r 3                       ; """http://forth-standard.org/standard/core/THEN"""
002B77r 3               xt_then:
002B77r 3                               ; Get the address to jump to.
002B77r 3  20 rr rr                     jsr xt_here
002B7Ar 3               
002B7Ar 3                               ; Stuff HERE in for the branch address back
002B7Ar 3                               ; at the IF or ELSE (origination address is on stack).
002B7Ar 3  20 rr rr                     jsr xt_swap
002B7Dr 3  20 rr rr                     jsr xt_store
002B80r 3               
002B80r 3  60           z_then:         rts
002B81r 3               
002B81r 3               
002B81r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002B81r 3               ; ## "thru"  tested  ANS block ext
002B81r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002B81r 3               
002B81r 3               xt_thru:
002B81r 3  20 rr rr                     jsr underflow_2
002B84r 3               
002B84r 3                               ; We need to loop here, and can't use the data stack
002B84r 3                               ; because the LOADed screens might use it.  We'll
002B84r 3                               ; need to use the same trick that DO loops use, holding
002B84r 3                               ; the limit and current index on the return stack.
002B84r 3               
002B84r 3                               ; Put the ending screen number on the return stack
002B84r 3  B5 01                        lda 1,x
002B86r 3  48                           pha
002B87r 3  B5 00                        lda 0,x
002B89r 3  48                           pha
002B8Ar 3  E8                           inx
002B8Br 3  E8                           inx
002B8Cr 3               @thru_loop:
002B8Cr 3                               ; Put the starting screen number on the stack,
002B8Cr 3                               ; but keep a copy
002B8Cr 3  B5 01                        lda 1,x
002B8Er 3  48                           pha
002B8Fr 3  B5 00                        lda 0,x
002B91r 3  48                           pha
002B92r 3               
002B92r 3                               ; Load this screen.
002B92r 3  20 rr rr                     jsr xt_load
002B95r 3               
002B95r 3                               ; Get the number and limit back off the stack.  Rather than
002B95r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
002B95r 3               
002B95r 3                               ; Get the screen we just loaded.
002B95r 3  68                           pla
002B96r 3  85 rr                        sta tmp1
002B98r 3  68                           pla
002B99r 3  85 rr                        sta tmp1+1
002B9Br 3               
002B9Br 3                               ; Get the ending screen.
002B9Br 3  68                           pla
002B9Cr 3  85 rr                        sta tmp2
002B9Er 3  68                           pla
002B9Fr 3  85 rr                        sta tmp2+1
002BA1r 3               
002BA1r 3                               ; See if we just loaded the last screen.
002BA1r 3                               ; A already has the MSB of the last screen in it.
002BA1r 3  C5 rr                        cmp tmp1+1
002BA3r 3  D0 08                        bne @next_screen
002BA5r 3  A5 rr                        lda tmp2        ; Compare the LSB
002BA7r 3  C5 rr                        cmp tmp1
002BA9r 3  D0 02                        bne @next_screen
002BABr 3  80 18                        bra @done       ; We just did the last screen.
002BADr 3               
002BADr 3               @next_screen:
002BADr 3                               ; Put the ending screen back on the data stack.
002BADr 3  A5 rr                        lda tmp2+1
002BAFr 3  48                           pha
002BB0r 3  A5 rr                        lda tmp2
002BB2r 3  48                           pha
002BB3r 3               
002BB3r 3                               ; Increment the current screen.
002BB3r 3  E6 rr                        inc tmp1
002BB5r 3  D0 02                        bne @1
002BB7r 3  E6 rr                        inc tmp1+1
002BB9r 3               @1:
002BB9r 3                               ; Put the current screen on the stack to prepare for
002BB9r 3                               ; the next loop.
002BB9r 3  CA                           dex
002BBAr 3  CA                           dex
002BBBr 3  A5 rr                        lda tmp1
002BBDr 3  95 00                        sta 0,x
002BBFr 3  A5 rr                        lda tmp1+1
002BC1r 3  95 01                        sta 1,x
002BC3r 3  80 C7                        bra @thru_loop
002BC5r 3               @done:
002BC5r 3  60           z_thru:         rts
002BC6r 3               
002BC6r 3               
002BC6r 3               
002BC6r 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
002BC6r 3               ; ## "'"  auto  ANS core
002BC6r 3                       ; """https://forth-standard.org/standard/core/Tick"""
002BC6r 3               
002BC6r 3               xt_tick:
002BC6r 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002BC9r 3               
002BC9r 3                               ; if we got a zero, there was a problem getting the
002BC9r 3                               ; name of the word
002BC9r 3  B5 00                        lda 0,x
002BCBr 3  15 01                        ora 1,x
002BCDr 3  D0 05                        bne @1
002BCFr 3               
002BCFr 3  A9 05                        lda #err_noname
002BD1r 3  4C rr rr                     jmp error
002BD4r 3               @1:
002BD4r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002BD7r 3               
002BD7r 3                               ; If we didn't find the word in the Dictionary, abort
002BD7r 3  B5 00                        lda 0,x
002BD9r 3  15 01                        ora 1,x
002BDBr 3  D0 05                        bne @2
002BDDr 3               
002BDDr 3  A9 08                        lda #err_syntax
002BDFr 3  4C rr rr                     jmp error
002BE2r 3               @2:
002BE2r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
002BE5r 3               
002BE5r 3  60           z_tick:         rts
002BE6r 3               
002BE6r 3               
002BE6r 3               
002BE6r 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
002BE6r 3               ; ## "to"  auto  ANS core ext
002BE6r 3                       ; """https://forth-standard.org/standard/core/TO
002BE6r 3                       ; Gives a new value to a, uh, VALUE.
002BE6r 3                       ;
002BE6r 3                       ; One possible Forth
002BE6r 3                       ; implementation is  ' >BODY !  but given the problems we have
002BE6r 3                       ; with >BODY on STC Forths, we do this the hard way. Since
002BE6r 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
002BE6r 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
002BE6r 3                       ;
002BE6r 3                       ; Note that the standard has different behaviors for TO depending
002BE6r 3                       ; on the state (https://forth-standard.org/standard/core/TO).
002BE6r 3                       ; This makes TO state-dependent (which is bad) and also rather
002BE6r 3                       ; complex (see the Gforth implementation for comparison). This
002BE6r 3                       ; word may not be natively compiled and must be immediate. Frankly,
002BE6r 3                       ; it would have made more sense to have two words for this.
002BE6r 3                       ; """
002BE6r 3               
002BE6r 3               xt_to:
002BE6r 3                               ; One way or the other, we need the xt of the word after this
002BE6r 3                               ; one. At this point, we don't know if we are interpreted or
002BE6r 3                               ; compile, so we don't know if there is a value n on the stack,
002BE6r 3                               ; so we can't do an underflow check yet
002BE6r 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002BE9r 3               
002BE9r 3                               ; The PFA (DFA in this case) is three bytes down,
002BE9r 3                               ; after the jump to DOCONST
002BE9r 3  B5 00                        lda 0,x                 ; LSB
002BEBr 3  18                           clc
002BECr 3  69 03                        adc #3
002BEEr 3  85 rr                        sta tmp1
002BF0r 3  B5 01                        lda 1,x                 ; MSB
002BF2r 3  69 00                        adc #0                  ; we just want the carry
002BF4r 3  85 rr                        sta tmp1+1
002BF6r 3               
002BF6r 3  E8                           inx
002BF7r 3  E8                           inx                     ; ( [n] )
002BF8r 3               
002BF8r 3                               ; Now it gets ugly. See which state we are in
002BF8r 3  A5 rr                        lda state
002BFAr 3  05 rr                        ora state+1
002BFCr 3  F0 34                        beq @interpret
002BFEr 3               
002BFEr 3                               ; Well, we're compiling. We want to end up with simple
002BFEr 3                               ; code that just takes the number that is TOS and saves
002BFEr 3                               ; it in the address of the xt we were just given. So we
002BFEr 3                               ; want to compile this routine:
002BFEr 3                               ;
002BFEr 3                               ;       lda 0,x                 - B5 00
002BFEr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002BFEr 3                               ;       lda 1,x                 - B5 01
002BFEr 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002BFEr 3                               ;       inx                     - E8
002BFEr 3                               ;       inx                     - E8
002BFEr 3                               ;
002BFEr 3                               ; which at least is nice and short. Other than that, we pretty
002BFEr 3                               ; much have to do this the hard and long way, because with the
002BFEr 3                               ; LSBs and MSBs, we can't really put the numbers in a data
002BFEr 3                               ; range and store them with a loop. Sigh.
002BFEr 3               
002BFEr 3  A0 00                        ldy #$00                ; Code for LDA 0,X
002C00r 3  A9 B5                        lda #$B5
002C02r 3  20 rr rr                     jsr cmpl_word
002C05r 3               
002C05r 3  A9 8D                        lda #$8D                ; Code for STA abs
002C07r 3  20 rr rr                     jsr cmpl_a
002C0Ar 3               
002C0Ar 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002C0Cr 3  A5 rr                        lda tmp1
002C0Er 3  20 rr rr                     jsr cmpl_word
002C11r 3               
002C11r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
002C13r 3  A9 B5                        lda #$B5
002C15r 3  20 rr rr                     jsr cmpl_word
002C18r 3               
002C18r 3  A9 8D                        lda #$8D                ; Code for STA abs
002C1Ar 3  20 rr rr                     jsr cmpl_a
002C1Dr 3               
002C1Dr 3  E6 rr                        inc tmp1                ; Calculate MSB
002C1Fr 3  D0 02                        bne @1
002C21r 3  E6 rr                        inc tmp1+1
002C23r 3               @1:
002C23r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002C25r 3  A5 rr                        lda tmp1
002C27r 3  20 rr rr                     jsr cmpl_word
002C2Ar 3               
002C2Ar 3  A0 E8                        ldy #$E8                ; Code for INX
002C2Cr 3  98                           tya
002C2Dr 3  20 rr rr                     jsr cmpl_word
002C30r 3               
002C30r 3  80 0F                        bra @done
002C32r 3               
002C32r 3               @interpret:
002C32r 3                               ; We're interpreting, so we arrive here with n
002C32r 3                               ; on the stack. This is an annoying place to put
002C32r 3                               ; the underflow check because we can't
002C32r 3                               ; automatically strip it out
002C32r 3  20 rr rr                     jsr underflow_1
002C35r 3               
002C35r 3                               ; We skip over the jump to DOCONST and store the number
002C35r 3                               ; in the Program Field Area (PDF, in this case more a
002C35r 3                               ; Data Field Area
002C35r 3  B5 00                        lda 0,x
002C37r 3  92 rr                        sta (tmp1)              ; LSB
002C39r 3               
002C39r 3  A0 01                        ldy #1
002C3Br 3  B5 01                        lda 1,x                 ; MSB
002C3Dr 3  91 rr                        sta (tmp1),y            ; fall through to common
002C3Fr 3               
002C3Fr 3  E8                           inx                     ; DROP
002C40r 3  E8                           inx
002C41r 3               @done:
002C41r 3  60           z_to:           rts
002C42r 3               
002C42r 3               
002C42r 3               
002C42r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002C42r 3               ; ## ">body"  auto  ANS core
002C42r 3                       ; """https://forth-standard.org/standard/core/toBODY
002C42r 3                       ; Given a word's execution token (xt), return the address of the
002C42r 3                       ; start of that word's parameter field (PFA). This is defined as the
002C42r 3                       ; address that HERE would return right after CREATE.
002C42r 3                       ;
002C42r 3                       ; This is a
002C42r 3                       ; difficult word for STC Forths, because most words don't actually
002C42r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002C42r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002C42r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002C42r 3                       ; """
002C42r 3               
002C42r 3               xt_to_body:
002C42r 3  20 rr rr                     jsr underflow_1
002C45r 3               
002C45r 3                               ; Ideally, xt already points to the CFA. We just need to check
002C45r 3                               ; the HC flag for special cases
002C45r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
002C48r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
002C4Br 3               
002C4Br 3                               ; The status byte is nt+1
002C4Br 3  F6 00                        inc 0,x
002C4Dr 3  D0 02                        bne @1
002C4Fr 3  F6 01                        inc 1,x
002C51r 3               @1:
002C51r 3  A1 00                        lda (0,x)               ; get status byte
002C53r 3  29 20                        and #HC
002C55r 3  F0 0D                        beq @no_cfa
002C57r 3               
002C57r 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
002C57r 3                               ; so we add three to xt, which is NOS
002C57r 3  18                           clc
002C58r 3  B5 02                        lda 2,x         ; LSB
002C5Ar 3  69 03                        adc #3
002C5Cr 3  95 02                        sta 2,x
002C5Er 3  B5 03                        lda 3,x         ; MSB
002C60r 3  69 00                        adc #0          ; we conly care about the carry
002C62r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
002C64r 3               @no_cfa:
002C64r 3  E8                           inx             ; get rid of the nt
002C65r 3  E8                           inx
002C66r 3               @done:
002C66r 3  60           z_to_body:      rts
002C67r 3               
002C67r 3               
002C67r 3               
002C67r 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
002C67r 3               ; ## ">in"  auto  ANS core
002C67r 3               xt_to_in:
002C67r 3  CA                           dex
002C68r 3  CA                           dex
002C69r 3               
002C69r 3  A9 rr                        lda #<toin
002C6Br 3  95 00                        sta 0,x
002C6Dr 3  A9 rr                        lda #>toin      ; paranoid, should be zero
002C6Fr 3  95 01                        sta 1,x
002C71r 3               
002C71r 3  60           z_to_in:        rts
002C72r 3               
002C72r 3               
002C72r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002C72r 3               ; ## ">number"  auto  ANS core
002C72r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002C72r 3                       ; Convert a string to a double number. Logic here is based on the
002C72r 3                       ; routine by Phil Burk of the same name in pForth, see
002C72r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002C72r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002C72r 3                       ; made sure that we don't have to deal with a sign and we don't have
002C72r 3                       ; to deal with a dot as a last character that signalizes double -
002C72r 3                       ; this should be a pure number string.
002C72r 3                       ;
002C72r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002C72r 3                       ; cannot access any of those.
002C72r 3                       ;
002C72r 3                       ; For the math routine, we move the inputs to the scratchpad to
002C72r 3                       ; avoid having to fool around with the Data Stack.
002C72r 3                       ;
002C72r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002C72r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002C72r 3                       ;     |           |           |           |           |
002C72r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002C72r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002C72r 3                       ;
002C72r 3                       ; The math routine works by converting one character to its
002C72r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002C72r 3                       ; the moment. We then multiply the UD-HI value with the radix
002C72r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002C72r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002C72r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002C72r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002C72r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002C72r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002C72r 3                       ; storing the result back in S and S+2, before we start another
002C72r 3                       ; round with it as the new UD-LO and UD-HI.
002C72r 3                       ; """
002C72r 3               
002C72r 3               
002C72r 3               xt_to_number:
002C72r 3  20 rr rr                     jsr underflow_4
002C75r 3               
002C75r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
002C75r 3                               ; After this step, the original ud-lo and ud-hi will still be on
002C75r 3                               ; the Data Stack, but will be ignored and later overwritten
002C75r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
002C75r 3  B5 06                        lda 6,x         ; ud-lo LSB
002C77r 3  85 rr                        sta scratch
002C79r 3  B5 07                        lda 7,x         ; ud-lo MSB
002C7Br 3  85 rr                        sta scratch+1
002C7Dr 3               
002C7Dr 3  B5 04                        lda 4,x         ; ud-hi LSB
002C7Fr 3  85 rr                        sta scratch+2
002C81r 3  B5 05                        lda 5,x         ; ud-hi MSB
002C83r 3  85 rr                        sta scratch+3
002C85r 3               
002C85r 3                               ; Push down one on the Data Stack to use TOS for character
002C85r 3                               ; conversion ( ud-lo ud-hi addr u x )
002C85r 3  CA                           dex
002C86r 3  CA                           dex
002C87r 3               
002C87r 3               @loop:
002C87r 3                               ; Get one character based on address
002C87r 3  A1 04                        lda (4,x)
002C89r 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
002C8Br 3  74 01                        stz 1,x                 ; paranoid
002C8Dr 3               
002C8Dr 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002C90r 3               
002C90r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002C90r 3                               ; check the flag. If it is zero, we return what we have and
002C90r 3                               ; let the caller (usually NUMBER) complain
002C90r 3  B5 00                        lda 0,x
002C92r 3  D0 04                        bne @digit_ok
002C94r 3               
002C94r 3  E8                           inx
002C95r 3  E8                           inx
002C96r 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
002C98r 3               
002C98r 3               @digit_ok:
002C98r 3                               ; Conversion was successful. We arrive here with
002C98r 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
002C98r 3                               ; math routine
002C98r 3               
002C98r 3                               ; Save n so we don't have to fool around with the
002C98r 3                               ; Data Stack
002C98r 3  B5 02                        lda 2,x
002C9Ar 3  85 rr                        sta scratch+4
002C9Cr 3  B5 03                        lda 3,x
002C9Er 3  85 rr                        sta scratch+5
002CA0r 3               
002CA0r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002CA0r 3                               ; original one on the Data Stack) with the radix from BASE.
002CA0r 3                               ; We can clobber TOS and NOS because we saved n
002CA0r 3  A5 rr                        lda scratch+2
002CA2r 3  95 02                        sta 2,x         ; NOS
002CA4r 3  A5 rr                        lda scratch+3
002CA6r 3  95 03                        sta 3,x
002CA8r 3               
002CA8r 3  A5 rr                        lda base
002CAAr 3  95 00                        sta 0,x         ; TOS
002CACr 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002CAEr 3               
002CAEr 3                               ; UM* returns a double-celled number
002CAEr 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002CB1r 3               
002CB1r 3                               ; Move ud-hi-lo to safety
002CB1r 3  B5 02                        lda 2,x         ; ud-hi-lo
002CB3r 3  85 rr                        sta scratch+6
002CB5r 3  B5 03                        lda 3,x
002CB7r 3  85 rr                        sta scratch+7
002CB9r 3               
002CB9r 3                               ; Now we multiply ud-lo, overwriting the stack entries
002CB9r 3  A5 rr                        lda scratch
002CBBr 3  95 02                        sta 2,x
002CBDr 3  A5 rr                        lda scratch+1
002CBFr 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002CC1r 3               
002CC1r 3  A5 rr                        lda base
002CC3r 3  95 00                        sta 0,x
002CC5r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002CC7r 3               
002CC7r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002CCAr 3               
002CCAr 3  B5 00                        lda 0,x
002CCCr 3  85 rr                        sta scratch+2
002CCEr 3  B5 01                        lda 1,x
002CD0r 3  85 rr                        sta scratch+3
002CD2r 3               
002CD2r 3  B5 02                        lda 2,x
002CD4r 3  85 rr                        sta scratch
002CD6r 3  B5 03                        lda 3,x
002CD8r 3  85 rr                        sta scratch+1
002CDAr 3               
002CDAr 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002CDAr 3                               ; both in the scratch pad
002CDAr 3  18                           clc
002CDBr 3  A5 rr                        lda scratch     ; ud-lo LSB
002CDDr 3  65 rr                        adc scratch+4   ; n LSB
002CDFr 3  85 rr                        sta scratch     ; this is the new ud-lo
002CE1r 3  A5 rr                        lda scratch+1   ; ud-lo MSB
002CE3r 3  65 rr                        adc scratch+5   ; n MSB
002CE5r 3  85 rr                        sta scratch+1
002CE7r 3               
002CE7r 3  A5 rr                        lda scratch+2   ; LSB
002CE9r 3  65 rr                        adc scratch+6
002CEBr 3  85 rr                        sta scratch+2   ; this is the new ud-hi
002CEDr 3  A5 rr                        lda scratch+3   ; MSB
002CEFr 3  65 rr                        adc scratch+7
002CF1r 3  85 rr                        sta scratch+3
002CF3r 3               
002CF3r 3                               ; Clean up: Get rid of one of the two top elements on
002CF3r 3                               ; the Data Stack. We don't really care which one
002CF3r 3  E8                           inx
002CF4r 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002CF5r 3               
002CF5r 3                               ; One character down. Move address up
002CF5r 3  F6 04                        inc 4,x
002CF7r 3  D0 02                        bne @1
002CF9r 3  F6 05                        inc 5,x
002CFBr 3               @1:
002CFBr 3                               ; Decrease counter
002CFBr 3  D6 02                        dec 2,x
002CFDr 3  D0 88                        bne @loop
002CFFr 3               
002CFFr 3               @done:
002CFFr 3                               ; Counter has reached zero or we have an error. In both
002CFFr 3                               ; cases, we clean up the Data Stack and return. Error gives
002CFFr 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002CFFr 3                               ; ( ud-lo ud-hi addr u ud-lo )
002CFFr 3  E8                           inx
002D00r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002D01r 3               
002D01r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002D01r 3  A5 rr                        lda scratch     ; new ud-lo
002D03r 3  95 06                        sta 6,x
002D05r 3  A5 rr                        lda scratch+1
002D07r 3  95 07                        sta 7,x
002D09r 3               
002D09r 3  A5 rr                        lda scratch+2
002D0Br 3  95 04                        sta 4,x
002D0Dr 3  A5 rr                        lda scratch+3
002D0Fr 3  95 05                        sta 5,x
002D11r 3               
002D11r 3  60           z_to_number:    rts
002D12r 3               
002D12r 3               
002D12r 3               
002D12r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002D12r 3               ; ## ">order"  tested  Gforth search
002D12r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002D12r 3               
002D12r 3               xt_to_order:
002D12r 3                               ; Put the wid on the return stack for now.
002D12r 3  20 rr rr                     jsr xt_to_r
002D15r 3               
002D15r 3                               ; Get the current search order.
002D15r 3  20 rr rr                     jsr xt_get_order
002D18r 3               
002D18r 3                               ; Get back the wid and add it to the list.
002D18r 3  20 rr rr                     jsr xt_r_from
002D1Br 3  20 rr rr                     jsr xt_swap
002D1Er 3  20 rr rr                     jsr xt_one_plus
002D21r 3               
002D21r 3                               ; Set the search order with the new list.
002D21r 3  20 rr rr                     jsr xt_set_order
002D24r 3               
002D24r 3  60           z_to_order:     rts
002D25r 3               
002D25r 3               
002D25r 3               
002D25r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002D25r 3               ; ## ">r"  auto  ANS core
002D25r 3                       ; """https://forth-standard.org/standard/core/toR
002D25r 3                       ; This word is handled differently for native and for
002D25r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002D25r 3                       ; word.
002D25r 3                       ; """
002D25r 3               xt_to_r:
002D25r 3                               ; Save the return address. If this word is natively
002D25r 3                               ; coded, this is a complete waste of cycles, but
002D25r 3                               ; required for subroutine coding
002D25r 3  68                           pla             ; LSB
002D26r 3  85 rr                        sta tmptos
002D28r 3  7A                           ply             ; MSB
002D29r 3               
002D29r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002D29r 3               
002D29r 3                               ; We check for underflow in the second step, so we can
002D29r 3                               ; strip off the stack thrashing for native compiling first
002D29r 3  20 rr rr                     jsr underflow_1
002D2Cr 3               
002D2Cr 3                               ; now we can do the actual work
002D2Cr 3  B5 01                        lda 1,x         ; MSB
002D2Er 3  48                           pha
002D2Fr 3  B5 00                        lda 0,x         ; LSB
002D31r 3  48                           pha
002D32r 3               
002D32r 3  E8                           inx
002D33r 3  E8                           inx
002D34r 3               
002D34r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002D34r 3               
002D34r 3                               ; restore return address
002D34r 3  5A                           phy             ; MSB
002D35r 3  A5 rr                        lda tmptos
002D37r 3  48                           pha             ; LSB
002D38r 3               
002D38r 3  60           z_to_r:         rts
002D39r 3               
002D39r 3               
002D39r 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002D39r 3               ; ## "true"  auto  ANS core ext
002D39r 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002D39r 3               xt_true:
002D39r 3  CA                           dex
002D3Ar 3  CA                           dex
002D3Br 3  A9 FF                        lda #$FF
002D3Dr 3  95 00                        sta 0,x
002D3Fr 3  95 01                        sta 1,x
002D41r 3               
002D41r 3  60           z_true:         rts
002D42r 3               
002D42r 3               
002D42r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002D42r 3               ; ## "tuck"  auto  ANS core ext
002D42r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002D42r 3               xt_tuck:
002D42r 3  20 rr rr                     jsr underflow_2
002D45r 3               
002D45r 3  CA                           dex
002D46r 3  CA                           dex
002D47r 3               
002D47r 3  B4 04                        ldy 4,x         ; LSB
002D49r 3  B5 02                        lda 2,x
002D4Br 3  95 04                        sta 4,x
002D4Dr 3  94 02                        sty 2,x
002D4Fr 3  95 00                        sta 0,x
002D51r 3               
002D51r 3  B4 05                        ldy 5,x         ; MSB
002D53r 3  B5 03                        lda 3,x
002D55r 3  95 05                        sta 5,x
002D57r 3  94 03                        sty 3,x         ; bba
002D59r 3  95 01                        sta 1,x         ; baa
002D5Br 3               
002D5Br 3  60           z_tuck:         rts
002D5Cr 3               
002D5Cr 3               
002D5Cr 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002D5Cr 3               ; ## "2"  auto  Tali Forth
002D5Cr 3                       ;
002D5Cr 3                       ; This code is shared with ASSEMBLER-WORDLIST
002D5Cr 3               xt_assembler_wordlist:
002D5Cr 3               xt_two:
002D5Cr 3  CA                           dex
002D5Dr 3  CA                           dex
002D5Er 3  A9 02                        lda #2
002D60r 3  95 00                        sta 0,x
002D62r 3  74 01                        stz 1,x
002D64r 3               
002D64r 3               z_assembler_wordlist:
002D64r 3  60           z_two:          rts
002D65r 3               
002D65r 3               
002D65r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
002D65r 3               ; ## "2drop"  auto  ANS core
002D65r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
002D65r 3               xt_two_drop:
002D65r 3  20 rr rr                     jsr underflow_2
002D68r 3               
002D68r 3  E8                           inx
002D69r 3  E8                           inx
002D6Ar 3  E8                           inx
002D6Br 3  E8                           inx
002D6Cr 3               
002D6Cr 3  60           z_two_drop:     rts
002D6Dr 3               
002D6Dr 3               
002D6Dr 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002D6Dr 3               ; ## "2dup"  auto  ANS core
002D6Dr 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002D6Dr 3               xt_two_dup:
002D6Dr 3  20 rr rr                     jsr underflow_2
002D70r 3               
002D70r 3  CA                           dex
002D71r 3  CA                           dex
002D72r 3  CA                           dex
002D73r 3  CA                           dex
002D74r 3               
002D74r 3  B5 04                        lda 4,x         ; TOS
002D76r 3  95 00                        sta 0,x
002D78r 3  B5 05                        lda 5,x
002D7Ar 3  95 01                        sta 1,x
002D7Cr 3               
002D7Cr 3  B5 06                        lda 6,x         ; NOS
002D7Er 3  95 02                        sta 2,x
002D80r 3  B5 07                        lda 7,x
002D82r 3  95 03                        sta 3,x
002D84r 3               
002D84r 3  60           z_two_dup:      rts
002D85r 3               
002D85r 3               
002D85r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
002D85r 3               ; ## "2@"  auto  ANS core
002D85r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
002D85r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
002D85r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
002D85r 3                       ; """
002D85r 3               xt_two_fetch:
002D85r 3  20 rr rr                     jsr underflow_1
002D88r 3               
002D88r 3  B5 00                        lda 0,x
002D8Ar 3  85 rr                        sta tmp1
002D8Cr 3  B4 01                        ldy 1,x
002D8Er 3  84 rr                        sty tmp1+1
002D90r 3               
002D90r 3  CA                           dex             ; reuse one stack element
002D91r 3  CA                           dex
002D92r 3               
002D92r 3  B2 rr                        lda (tmp1)      ; copy LSB
002D94r 3  95 00                        sta 0,x
002D96r 3  A0 01                        ldy #1          ; copy next
002D98r 3  B1 rr                        lda (tmp1),y
002D9Ar 3  95 01                        sta 1,x
002D9Cr 3  C8                           iny             ; copy next
002D9Dr 3  B1 rr                        lda (tmp1),y
002D9Fr 3  95 02                        sta 2,x
002DA1r 3  C8                           iny             ; copy next
002DA2r 3  B1 rr                        lda (tmp1),y
002DA4r 3  95 03                        sta 3,x
002DA6r 3               
002DA6r 3  60           z_two_fetch:    rts
002DA7r 3               
002DA7r 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
002DA7r 3               ; ## "2over"  auto  ANS core
002DA7r 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
002DA7r 3               xt_two_over:
002DA7r 3  20 rr rr                     jsr underflow_4
002DAAr 3               
002DAAr 3  CA                           dex
002DABr 3  CA                           dex
002DACr 3  CA                           dex
002DADr 3  CA                           dex
002DAEr 3               
002DAEr 3  B5 08                        lda 8,x
002DB0r 3  95 00                        sta 0,x
002DB2r 3               
002DB2r 3  B5 09                        lda 9,x
002DB4r 3  95 01                        sta 1,x
002DB6r 3               
002DB6r 3  B5 0A                        lda 10,x
002DB8r 3  95 02                        sta 2,x
002DBAr 3               
002DBAr 3  B5 0B                        lda 11,x
002DBCr 3  95 03                        sta 3,x
002DBEr 3               
002DBEr 3  60           z_two_over:     rts
002DBFr 3               
002DBFr 3               
002DBFr 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002DBFr 3               ; ## "2r@"  auto  ANS core ext
002DBFr 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002DBFr 3                       ;
002DBFr 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002DBFr 3                       ; assembler. We use trickery to access the elements on the Return
002DBFr 3                       ; Stack instead of pulling the return address first and storing
002DBFr 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002DBFr 3                       ; it as Never Native; at some point, we should compare versions to
002DBFr 3                       ; see if an Always Native version would be better
002DBFr 3                       ; """
002DBFr 3               xt_two_r_fetch:
002DBFr 3               		; make room on the Data Stack
002DBFr 3  CA                           dex
002DC0r 3  CA                           dex
002DC1r 3  CA                           dex
002DC2r 3  CA                           dex
002DC3r 3               
002DC3r 3                               ; Get four bytes off of Return Stack. This assumes that
002DC3r 3                               ; we took a subroutine jump here so the first two entries
002DC3r 3                               ; are the return address
002DC3r 3  8A                           txa
002DC4r 3  BA                           tsx
002DC5r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002DC6r 3  7A                           ply
002DC7r 3  AA                           tax
002DC8r 3               
002DC8r 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002DC8r 3                               ; the return address for this word. This is a whole lot
002DC8r 3                               ; easier on the 65816
002DC8r 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002DCBr 3  95 00                        sta 0,x
002DCDr 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002DD0r 3  95 01                        sta 1,x
002DD2r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002DD5r 3  95 02                        sta 2,x
002DD7r 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002DDAr 3  95 03                        sta 3,x
002DDCr 3               
002DDCr 3  60           z_two_r_fetch:  rts
002DDDr 3               
002DDDr 3               
002DDDr 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
002DDDr 3               ; ## "2r>"  auto  ANS core ext
002DDDr 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
002DDDr 3                       ; Pull top two entries from Return Stack.
002DDDr 3                       ;
002DDDr 3                       ; Is the same as
002DDDr 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
002DDDr 3                       ; the top value on the ReturnStack for a STC Forth is the
002DDDr 3                       ; return address, which we need to get out of the way first.
002DDDr 3                       ; Native compile needs to be handled as a special case.
002DDDr 3                       ; """
002DDDr 3               xt_two_r_from:
002DDDr 3                               ; save the return address
002DDDr 3  68                           pla                     ; LSB
002DDEr 3  85 rr                        sta tmp1
002DE0r 3  68                           pla                     ; MSB
002DE1r 3  85 rr                        sta tmp1+1
002DE3r 3               
002DE3r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002DE3r 3               
002DE3r 3               		; make room on stack
002DE3r 3  CA                           dex
002DE4r 3  CA                           dex
002DE5r 3  CA                           dex
002DE6r 3  CA                           dex
002DE7r 3               
002DE7r 3                               ; In theory, we should test for underflow on the Return
002DE7r 3                               ; Stack. However, given the traffic there with an STC
002DE7r 3                               ; Forth, that's probably not really useful
002DE7r 3               
002DE7r 3                               ; now we can access the data
002DE7r 3  68                           pla                     ; LSB
002DE8r 3  95 00                        sta 0,x
002DEAr 3  68                           pla                     ; MSB
002DEBr 3  95 01                        sta 1,x
002DEDr 3               
002DEDr 3  68                           pla                     ; LSB
002DEEr 3  95 02                        sta 2,x
002DF0r 3  68                           pla                     ; MSB
002DF1r 3  95 03                        sta 3,x
002DF3r 3               
002DF3r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002DF3r 3               
002DF3r 3                               ; restore return address
002DF3r 3  A5 rr                        lda tmp1+1              ; MSB
002DF5r 3  48                           pha
002DF6r 3  A5 rr                        lda tmp1                ; LSB
002DF8r 3  48                           pha
002DF9r 3               
002DF9r 3  60           z_two_r_from:   rts
002DFAr 3               
002DFAr 3               
002DFAr 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002DFAr 3               ; ## "2/"  auto  ANS core
002DFAr 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002DFAr 3               xt_two_slash:
002DFAr 3  20 rr rr                     jsr underflow_1
002DFDr 3               
002DFDr 3                               ; We can't just LSR the LSB and ROR the MSB because that
002DFDr 3                               ; would do bad things to the sign
002DFDr 3  B5 01                        lda 1,x
002DFFr 3  0A                           asl                     ; save the sign
002E00r 3  76 01                        ror 1,x
002E02r 3  76 00                        ror 0,x
002E04r 3               
002E04r 3  60           z_two_slash:    rts
002E05r 3               
002E05r 3               
002E05r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002E05r 3               ; ## "2*"  auto  ANS core
002E05r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002E05r 3                       ;
002E05r 3                       ; Also used for CELLS
002E05r 3                       ; """
002E05r 3               xt_two_star:
002E05r 3               xt_cells:
002E05r 3  20 rr rr                     jsr underflow_1
002E08r 3               
002E08r 3  16 00                        asl 0,x
002E0Ar 3  36 01                        rol 1,x
002E0Cr 3               z_cells:
002E0Cr 3  60           z_two_star:     rts
002E0Dr 3               
002E0Dr 3               
002E0Dr 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
002E0Dr 3               ; ## "2!"  auto  ANS core
002E0Dr 3                       ; """https://forth-standard.org/standard/core/TwoStore
002E0Dr 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
002E0Dr 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
002E0Dr 3                       ; """
002E0Dr 3               xt_two_store:
002E0Dr 3  20 rr rr                     jsr underflow_3
002E10r 3               
002E10r 3  B5 00                        lda 0,x
002E12r 3  85 rr                        sta tmp1
002E14r 3  B4 01                        ldy 1,x
002E16r 3  84 rr                        sty tmp1+1
002E18r 3               
002E18r 3  E8                           inx
002E19r 3  E8                           inx
002E1Ar 3               
002E1Ar 3  B5 00                        lda 0,x         ; copy MSB
002E1Cr 3  92 rr                        sta (tmp1)
002E1Er 3  B5 01                        lda 1,x         ; copy next
002E20r 3  A0 01                        ldy #1
002E22r 3  91 rr                        sta (tmp1),y
002E24r 3  B5 02                        lda 2,x         ; copy next
002E26r 3  C8                           iny
002E27r 3  91 rr                        sta (tmp1),y
002E29r 3  B5 03                        lda 3,x         ; copy MSB
002E2Br 3  C8                           iny
002E2Cr 3  91 rr                        sta (tmp1),y
002E2Er 3               
002E2Er 3  E8                           inx             ; 2DROP
002E2Fr 3  E8                           inx
002E30r 3  E8                           inx
002E31r 3  E8                           inx
002E32r 3               
002E32r 3  60           z_two_store:    rts
002E33r 3               
002E33r 3               
002E33r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002E33r 3               ; ## "2swap"  auto  ANS core
002E33r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002E33r 3               xt_two_swap:
002E33r 3  20 rr rr                     jsr underflow_4
002E36r 3               
002E36r 3                               ; 0 <-> 4
002E36r 3  B5 00                        lda 0,x
002E38r 3  B4 04                        ldy 4,x
002E3Ar 3  95 04                        sta 4,x
002E3Cr 3  94 00                        sty 0,x
002E3Er 3               
002E3Er 3                               ; 1 <-> 5
002E3Er 3  B5 01                        lda 1,x
002E40r 3  B4 05                        ldy 5,x
002E42r 3  95 05                        sta 5,x
002E44r 3  94 01                        sty 1,x
002E46r 3               
002E46r 3                               ; 2 <-> 6
002E46r 3  B5 02                        lda 2,x
002E48r 3  B4 06                        ldy 6,x
002E4Ar 3  95 06                        sta 6,x
002E4Cr 3  94 02                        sty 2,x
002E4Er 3               
002E4Er 3                               ; 3 <-> 7
002E4Er 3  B5 03                        lda 3,x
002E50r 3  B4 07                        ldy 7,x
002E52r 3  95 07                        sta 7,x
002E54r 3  94 03                        sty 3,x
002E56r 3               
002E56r 3  60           z_two_swap:     rts
002E57r 3               
002E57r 3               
002E57r 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
002E57r 3               ; ## "2>r"  auto  ANS core ext
002E57r 3                       ; """https://forth-standard.org/standard/core/TwotoR
002E57r 3                       ; Push top two entries to Return Stack.
002E57r 3                       ;
002E57r 3                       ; The same as SWAP >R >R
002E57r 3                       ; except that if we jumped here, the return address will be in the
002E57r 3                       ; way. May not be natively compiled unless we're clever and use
002E57r 3                       ; special routines.
002E57r 3                       ; """
002E57r 3               xt_two_to_r:
002E57r 3                               ; save the return address
002E57r 3  68                           pla             ; LSB
002E58r 3  85 rr                        sta tmp1
002E5Ar 3  68                           pla             ; MSB
002E5Br 3  85 rr                        sta tmp1+1
002E5Dr 3               
002E5Dr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002E5Dr 3               
002E5Dr 3  20 rr rr                     jsr underflow_2
002E60r 3               
002E60r 3                               ; now we can move the data
002E60r 3  B5 03                        lda 3,x         ; MSB
002E62r 3  48                           pha
002E63r 3  B5 02                        lda 2,x         ; LSB
002E65r 3  48                           pha
002E66r 3               
002E66r 3                               ; now we can move the data
002E66r 3  B5 01                        lda 1,x         ; MSB
002E68r 3  48                           pha
002E69r 3  B5 00                        lda 0,x         ; LSB
002E6Br 3  48                           pha
002E6Cr 3               
002E6Cr 3  E8                           inx
002E6Dr 3  E8                           inx
002E6Er 3  E8                           inx
002E6Fr 3  E8                           inx
002E70r 3               
002E70r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002E70r 3               
002E70r 3                               ; restore return address
002E70r 3  A5 rr                        lda tmp1+1      ; MSB
002E72r 3  48                           pha
002E73r 3  A5 rr                        lda tmp1        ; LSB
002E75r 3  48                           pha
002E76r 3               
002E76r 3  60           z_two_to_r:     rts
002E77r 3               
002E77r 3               
002E77r 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
002E77r 3               ; ## "2constant"  auto  ANS double
002E77r 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
002E77r 3                       ;
002E77r 3                       ; Based on the Forth code
002E77r 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
002E77r 3                       ; """
002E77r 3               xt_two_constant:
002E77r 3  20 rr rr                     jsr underflow_2
002E7Ar 3               
002E7Ar 3  20 rr rr                     jsr xt_create
002E7Dr 3  20 rr rr                     jsr xt_swap
002E80r 3  20 rr rr                     jsr xt_comma
002E83r 3  20 rr rr                     jsr xt_comma
002E86r 3               
002E86r 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002E89r 3  20 rr rr                     jsr dodoes
002E8Cr 3               
002E8Cr 3  20 rr rr                     jsr xt_dup
002E8Fr 3  20 rr rr                     jsr xt_fetch
002E92r 3  20 rr rr                     jsr xt_swap
002E95r 3  20 rr rr                     jsr xt_cell_plus
002E98r 3  20 rr rr                     jsr xt_fetch
002E9Br 3               
002E9Br 3  60           z_two_constant: rts
002E9Cr 3               
002E9Cr 3               
002E9Cr 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002E9Cr 3               ; ## "2literal"  auto  ANS double
002E9Cr 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002E9Cr 3                       ; Based on the Forth code
002E9Cr 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002E9Cr 3                       ; """
002E9Cr 3               xt_two_literal:
002E9Cr 3  20 rr rr                     jsr underflow_2 ; double number
002E9Fr 3               
002E9Fr 3  20 rr rr                     jsr xt_swap
002EA2r 3  20 rr rr                     jsr xt_literal
002EA5r 3  20 rr rr                     jsr xt_literal
002EA8r 3               
002EA8r 3  60           z_two_literal:  rts
002EA9r 3               
002EA9r 3               
002EA9r 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002EA9r 3               ; ## "2variable"  auto  ANS double
002EA9r 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002EA9r 3                       ; The variable is not initialized to zero.
002EA9r 3                       ;
002EA9r 3                       ; This can be realized in Forth as either
002EA9r 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002EA9r 3                       ; """
002EA9r 3               xt_two_variable:
002EA9r 3                               ; We just let CRATE and ALLOT do the heavy lifting
002EA9r 3  20 rr rr                     jsr xt_create
002EACr 3               
002EACr 3  CA                           dex
002EADr 3  CA                           dex
002EAEr 3  A9 04                        lda #4
002EB0r 3  95 00                        sta 0,x
002EB2r 3  74 01                        stz 1,x
002EB4r 3               
002EB4r 3  20 rr rr                     jsr xt_allot
002EB7r 3               
002EB7r 3  60           z_two_variable: rts
002EB8r 3               
002EB8r 3               
002EB8r 3               ; ## TYPE ( addr u -- ) "Print string"
002EB8r 3               ; ## "type"  auto  ANS core
002EB8r 3                       ; """https://forth-standard.org/standard/core/TYPE
002EB8r 3                       ; Works through EMIT to allow OUTPUT revectoring.
002EB8r 3                       ; """
002EB8r 3               
002EB8r 3               xt_type:
002EB8r 3  20 rr rr                     jsr underflow_2
002EBBr 3               
002EBBr 3                               ; Save the starting address into tmp1
002EBBr 3  B5 02                        lda 2,x
002EBDr 3  85 rr                        sta tmp1
002EBFr 3  B5 03                        lda 3,x
002EC1r 3  85 rr                        sta tmp1+1
002EC3r 3               @loop:
002EC3r 3                               ; done if length is zero
002EC3r 3  B5 00                        lda 0,x
002EC5r 3  15 01                        ora 1,x
002EC7r 3  F0 15                        beq @done
002EC9r 3               
002EC9r 3                               ; Send the current character
002EC9r 3  B2 rr                        lda (tmp1)
002ECBr 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002ECEr 3               
002ECEr 3                               ; Move the address along (in tmp1)
002ECEr 3  E6 rr                        inc tmp1
002ED0r 3  D0 02                        bne @1
002ED2r 3  E6 rr                        inc tmp1+1
002ED4r 3               @1:
002ED4r 3                               ; Reduce the count (on the data stack)
002ED4r 3  B5 00                        lda 0,x
002ED6r 3  D0 02                        bne @2
002ED8r 3  D6 01                        dec 1,x
002EDAr 3               @2:
002EDAr 3  D6 00                        dec 0,x
002EDCr 3               
002EDCr 3  80 E5                        bra @loop
002EDEr 3               @done:
002EDEr 3  E8                           inx
002EDFr 3  E8                           inx
002EE0r 3  E8                           inx
002EE1r 3  E8                           inx
002EE2r 3               
002EE2r 3  60           z_type:         rts
002EE3r 3               
002EE3r 3               
002EE3r 3               
002EE3r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002EE3r 3               ; ## "u."  tested  ANS core
002EE3r 3                       ; """https://forth-standard.org/standard/core/Ud
002EE3r 3                       ;
002EE3r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002EE3r 3                       ; We use the internal assembler function print_u followed
002EE3r 3                       ; by a single space
002EE3r 3                       ; """
002EE3r 3               xt_u_dot:
002EE3r 3  20 rr rr                     jsr underflow_1
002EE6r 3               
002EE6r 3  20 rr rr                     jsr print_u
002EE9r 3  A9 20                        lda #AscSP
002EEBr 3  20 rr rr                     jsr emit_a
002EEEr 3               
002EEEr 3  60           z_u_dot:        rts
002EEFr 3               
002EEFr 3               
002EEFr 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
002EEFr 3               ; ## "u.r"  tested  ANS core ext
002EEFr 3                       ; """https://forth-standard.org/standard/core/UDotR"""
002EEFr 3               xt_u_dot_r:
002EEFr 3  20 rr rr                     jsr underflow_2
002EF2r 3               
002EF2r 3  20 rr rr                     jsr xt_to_r
002EF5r 3  20 rr rr                     jsr xt_zero
002EF8r 3  20 rr rr                     jsr xt_less_number_sign
002EFBr 3  20 rr rr                     jsr xt_number_sign_s
002EFEr 3  20 rr rr                     jsr xt_number_sign_greater
002F01r 3  20 rr rr                     jsr xt_r_from
002F04r 3  20 rr rr                     jsr xt_over
002F07r 3  20 rr rr                     jsr xt_minus
002F0Ar 3  20 rr rr                     jsr xt_spaces
002F0Dr 3  20 rr rr                     jsr xt_type
002F10r 3               
002F10r 3  60           z_u_dot_r:      rts
002F11r 3               
002F11r 3               
002F11r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002F11r 3               ; ## "u>"  auto  ANS core ext
002F11r 3                       ; """https://forth-standard.org/standard/core/Umore"""
002F11r 3               xt_u_greater_than:
002F11r 3  20 rr rr                     jsr underflow_2
002F14r 3               
002F14r 3  B5 00                        lda 0,x
002F16r 3  D5 02                        cmp 2,x
002F18r 3  B5 01                        lda 1,x
002F1Ar 3  F5 03                        sbc 3,x
002F1Cr 3  E8                           inx
002F1Dr 3  E8                           inx
002F1Er 3               
002F1Er 3  A9 00                        lda #0
002F20r 3  69 FF                        adc #$ff
002F22r 3  95 00                        sta 0,x         ; store flag
002F24r 3  95 01                        sta 1,x
002F26r 3               
002F26r 3  60           z_u_greater_than:    rts
002F27r 3               
002F27r 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002F27r 3               ; ## "u<"  auto  ANS core
002F27r 3                       ; """https://forth-standard.org/standard/core/Uless"""
002F27r 3               xt_u_less_than:
002F27r 3  20 rr rr                     jsr underflow_2
002F2Ar 3               
002F2Ar 3  B5 02                        lda 2,x
002F2Cr 3  D5 00                        cmp 0,x
002F2Er 3  B5 03                        lda 3,x
002F30r 3  F5 01                        sbc 1,x
002F32r 3  E8                           inx
002F33r 3  E8                           inx
002F34r 3               
002F34r 3  A9 00                        lda #0
002F36r 3  69 FF                        adc #$ff
002F38r 3  95 00                        sta 0,x         ; store flag
002F3Ar 3  95 01                        sta 1,x
002F3Cr 3               
002F3Cr 3  60           z_u_less_than:    rts
002F3Dr 3               
002F3Dr 3               
002F3Dr 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002F3Dr 3               ; ## "ud."  auto  Tali double
002F3Dr 3                       ;
002F3Dr 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002F3Dr 3                       ; """
002F3Dr 3               xt_ud_dot:
002F3Dr 3  20 rr rr                     jsr underflow_2 ; double number
002F40r 3               
002F40r 3  20 rr rr                     jsr xt_less_number_sign
002F43r 3  20 rr rr                     jsr xt_number_sign_s
002F46r 3  20 rr rr                     jsr xt_number_sign_greater
002F49r 3  20 rr rr                     jsr xt_type
002F4Cr 3  20 rr rr                     jsr xt_space
002F4Fr 3               
002F4Fr 3  60           z_ud_dot:        rts
002F50r 3               
002F50r 3               
002F50r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002F50r 3               ; ## "ud.r"  auto  Tali double
002F50r 3                       ;
002F50r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002F50r 3                       ; """
002F50r 3               xt_ud_dot_r:
002F50r 3  20 rr rr                     jsr underflow_3
002F53r 3               
002F53r 3  20 rr rr                     jsr xt_to_r
002F56r 3  20 rr rr                     jsr xt_less_number_sign
002F59r 3  20 rr rr                     jsr xt_number_sign_s
002F5Cr 3  20 rr rr                     jsr xt_number_sign_greater
002F5Fr 3  20 rr rr                     jsr xt_r_from
002F62r 3  20 rr rr                     jsr xt_over
002F65r 3  20 rr rr                     jsr xt_minus
002F68r 3  20 rr rr                     jsr xt_spaces
002F6Br 3  20 rr rr                     jsr xt_type
002F6Er 3               
002F6Er 3  60           z_ud_dot_r:      rts
002F6Fr 3               
002F6Fr 3               
002F6Fr 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002F6Fr 3               ; ## "um/mod"  auto  ANS core
002F6Fr 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002F6Fr 3                       ; Divide double cell number by single cell number, returning the
002F6Fr 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002F6Fr 3                       ; This is the basic division operation all others use. Based on FIG
002F6Fr 3                       ; Forth code, modified by Garth Wilson, see
002F6Fr 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002F6Fr 3                       ;
002F6Fr 3                       ; This uses tmp1, tmp1+1, and tmptos
002F6Fr 3                       ; """
002F6Fr 3               
002F6Fr 3               xt_um_slash_mod:
002F6Fr 3  20 rr rr                     jsr underflow_3
002F72r 3               
002F72r 3                               ; catch division by zero
002F72r 3  B5 00                        lda 0,x
002F74r 3  15 01                        ora 1,x
002F76r 3  D0 05                        bne @not_zero
002F78r 3               
002F78r 3  A9 04                        lda #err_divzero
002F7Ar 3  4C rr rr                     jmp error
002F7Dr 3               
002F7Dr 3               @not_zero:
002F7Dr 3                               ; We loop 17 times
002F7Dr 3  A9 11                        lda #17
002F7Fr 3  85 rr                        sta tmptos
002F81r 3               
002F81r 3               @loop:
002F81r 3                               ; rotate low cell of dividend one bit left (LSB)
002F81r 3  36 04                        rol 4,x
002F83r 3  36 05                        rol 5,x
002F85r 3               
002F85r 3                               ; loop control
002F85r 3  C6 rr                        dec tmptos
002F87r 3  F0 22                        beq @done
002F89r 3               
002F89r 3                               ; rotate high cell of dividend one bit left (MSB)
002F89r 3  36 02                        rol 2,x
002F8Br 3  36 03                        rol 3,x
002F8Dr 3               
002F8Dr 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
002F8Fr 3  26 rr                        rol tmp1
002F91r 3               
002F91r 3                               ; subtract dividend hi cell minus divisor
002F91r 3  38                           sec
002F92r 3  B5 02                        lda 2,x
002F94r 3  F5 00                        sbc 0,x
002F96r 3  85 rr                        sta tmp1+1
002F98r 3  B5 03                        lda 3,x
002F9Ar 3  F5 01                        sbc 1,x
002F9Cr 3               
002F9Cr 3  A8                           tay
002F9Dr 3  A5 rr                        lda tmp1
002F9Fr 3  E9 00                        sbc #0
002FA1r 3  90 DE                        bcc @loop
002FA3r 3               
002FA3r 3                               ; make result new dividend high cell
002FA3r 3  A5 rr                        lda tmp1+1
002FA5r 3  95 02                        sta 2,x
002FA7r 3  94 03                        sty 3,x         ; used as temp storage
002FA9r 3               
002FA9r 3  80 D6                        bra @loop
002FABr 3               @done:
002FABr 3  E8                           inx
002FACr 3  E8                           inx
002FADr 3               
002FADr 3  20 rr rr                     jsr xt_swap
002FB0r 3               
002FB0r 3  60           z_um_slash_mod: rts
002FB1r 3               
002FB1r 3               
002FB1r 3               
002FB1r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002FB1r 3               ; ## "um*"  auto  ANS core
002FB1r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002FB1r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002FB1r 3                       ; Old Forth versions such as FIG Forth call this U*
002FB1r 3                       ;
002FB1r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002FB1r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002FB1r 3                       ; discussion.
002FB1r 3                       ;
002FB1r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002FB1r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002FB1r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002FB1r 3                       ;
002FB1r 3                       ; Consider switching to a table-supported version based on
002FB1r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002FB1r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002FB1r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002FB1r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002FB1r 3                       ; """
002FB1r 3               
002FB1r 3               xt_um_star:
002FB1r 3  20 rr rr                     jsr underflow_2
002FB4r 3               
002FB4r 3                               ; to eliminate clc inside the loop, the value at
002FB4r 3                               ; tmp1 is reduced by 1 in advance
002FB4r 3  18                           clc
002FB5r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002FB7r 3  E9 00                        sbc #0
002FB9r 3  85 rr                        sta tmp2
002FBBr 3               
002FBBr 3  B5 01                        lda 1,x
002FBDr 3  E9 00                        sbc #0
002FBFr 3  90 31                        bcc @zero       ; is TOS zero?
002FC1r 3  85 rr                        sta tmp2+1
002FC3r 3               
002FC3r 3  A9 00                        lda #0
002FC5r 3  85 rr                        sta tmp1
002FC7r 3  86 rr                        stx tmp3        ; tested for exit from outer loop
002FC9r 3  CA                           dex
002FCAr 3  CA                           dex
002FCBr 3               
002FCBr 3               @outer_loop:
002FCBr 3  A0 08                        ldy #8          ; counter inner loop
002FCDr 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002FCFr 3               
002FCFr 3               @inner_loop:
002FCFr 3  90 0C                        bcc @no_add
002FD1r 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002FD3r 3  A5 rr                        lda tmp1
002FD5r 3  65 rr                        adc tmp2
002FD7r 3  85 rr                        sta tmp1
002FD9r 3  A5 rr                        lda tmp1+1
002FDBr 3  65 rr                        adc tmp2+1
002FDDr 3               
002FDDr 3               @no_add:
002FDDr 3  6A                           ror
002FDEr 3  66 rr                        ror tmp1
002FE0r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002FE2r 3               
002FE2r 3  88                           dey
002FE3r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002FE5r 3               
002FE5r 3  E8                           inx
002FE6r 3  E4 rr                        cpx tmp3
002FE8r 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002FEAr 3               
002FEAr 3                               ; all done, store high word of result
002FEAr 3  95 01                        sta 1,x
002FECr 3  A5 rr                        lda tmp1
002FEEr 3  95 00                        sta 0,x
002FF0r 3  80 04                        bra @done
002FF2r 3               
002FF2r 3               @zero:
002FF2r 3  74 02                        stz 2,x
002FF4r 3  74 03                        stz 3,x
002FF6r 3               @done:
002FF6r 3  60           z_um_star:      rts
002FF7r 3               
002FF7r 3               
002FF7r 3               
002FF7r 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002FF7r 3               ; ## "unloop"  auto  ANS core
002FF7r 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002FF7r 3                       ;
002FF7r 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002FF7r 3                       ; """
002FF7r 3               xt_unloop:
002FF7r 3                               ; Drop fudge number (limit/start from DO/?DO off the
002FF7r 3                               ; return stack
002FF7r 3  68                           pla
002FF8r 3  68                           pla
002FF9r 3  68                           pla
002FFAr 3  68                           pla
002FFBr 3               
002FFBr 3                               ; Now drop the LEAVE address that was below them off
002FFBr 3                               ; the Return Stack as well
002FFBr 3  68                           pla
002FFCr 3  68                           pla
002FFDr 3               
002FFDr 3  60           z_unloop:       rts
002FFEr 3               
002FFEr 3               
002FFEr 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
002FFEr 3               ; ## "until"  auto  ANS core
002FFEr 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
002FFEr 3               xt_until:
002FFEr 3                               ; Compile a 0BRANCH
002FFEr 3  A0 rr                        ldy #>zero_branch_runtime
003000r 3  A9 rr                        lda #<zero_branch_runtime
003002r 3  20 rr rr                     jsr cmpl_subroutine
003005r 3               
003005r 3                               ; The address to loop back to is on the stack.
003005r 3                               ; Just compile it as the destination for the
003005r 3                               ; 0branch.
003005r 3  20 rr rr                     jsr xt_comma
003008r 3               
003008r 3  60           z_until:        rts
003009r 3               
003009r 3               
003009r 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
003009r 3               ; ## "unused"  auto  ANS core ext
003009r 3                       ; """https://forth-standard.org/standard/core/UNUSED
003009r 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
003009r 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
003009r 3                       ; defaults to $400
003009r 3                       ; """
003009r 3               xt_unused:
003009r 3  CA                           dex
00300Ar 3  CA                           dex
00300Br 3               
00300Br 3  A9 FF                        lda #<cp_end
00300Dr 3  38                           sec
00300Er 3  E5 rr                        sbc cp
003010r 3  95 00                        sta 0,x
003012r 3               
003012r 3  A9 7F                        lda #>cp_end
003014r 3  E5 rr                        sbc cp+1
003016r 3  95 01                        sta 1,x
003018r 3               
003018r 3  60           z_unused:       rts
003019r 3               
003019r 3               
003019r 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
003019r 3               ; ## "update"  auto  ANS block
003019r 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
003019r 3               xt_update:
003019r 3                               ; Turn on the dirty bit. We can't use TSB here because it only
003019r 3                               ; has Absolute and Direct Pages addressing modes
003019r 3  A0 2C                        ldy #buffstatus_offset
00301Br 3  B1 rr                        lda (up),y
00301Dr 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
00301Fr 3  91 rr                        sta (up),y
003021r 3               
003021r 3  60           z_update:       rts
003022r 3               
003022r 3               
003022r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
003022r 3               ; ## "useraddr"  tested  Tali Forth
003022r 3               xt_useraddr:
003022r 3  CA                           dex
003023r 3  CA                           dex
003024r 3  A9 rr                        lda #<up
003026r 3  95 00                        sta 0,x
003028r 3  A9 rr                        lda #>up
00302Ar 3  95 01                        sta 1,x
00302Cr 3               
00302Cr 3  60           z_useraddr:     rts
00302Dr 3               
00302Dr 3               
00302Dr 3               ; ## VALUE ( n "name" -- ) "Define a value"
00302Dr 3               ; ## "value"  auto  ANS core
00302Dr 3                       ; """https://forth-standard.org/standard/core/VALUE
00302Dr 3                       ;
00302Dr 3                       ; This is a dummy header for the WORDLIST. The actual code is
00302Dr 3                       ; identical to that of CONSTANT
00302Dr 3                       ; """
00302Dr 3               
00302Dr 3               
00302Dr 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
00302Dr 3               ; ## "variable"  auto  ANS core
00302Dr 3                       ; """https://forth-standard.org/standard/core/VARIABLE
00302Dr 3                       ; There are various Forth definitions for this word, such as
00302Dr 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
00302Dr 3                       ; second one so the variable is initialized to zero
00302Dr 3                       ; """
00302Dr 3               xt_variable:
00302Dr 3                               ; we let CREATE do the heavy lifting
00302Dr 3  20 rr rr                     jsr xt_create
003030r 3               
003030r 3                               ; there is no "STZ (CP)" so we have to do this the hard
003030r 3                               ; way
003030r 3  A9 00                        lda #0
003032r 3               
003032r 3  92 rr                        sta (cp)
003034r 3  E6 rr                        inc cp
003036r 3  D0 02                        bne @1
003038r 3  E6 rr                        inc cp+1
00303Ar 3               @1:
00303Ar 3  92 rr                        sta (cp)
00303Cr 3  E6 rr                        inc cp
00303Er 3  D0 02                        bne @2
003040r 3  E6 rr                        inc cp+1
003042r 3               @2:
003042r 3                               ; Now we need to adjust the length of the complete word by two
003042r 3  20 rr rr                     jsr adjust_z
003045r 3               
003045r 3  60           z_variable:     rts
003046r 3               
003046r 3               
003046r 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
003046r 3               ; ## "while"  auto  ANS core
003046r 3                       ; """http://forth-standard.org/standard/core/WHILE"""
003046r 3               xt_while:
003046r 3                               ; Compile a 0branch
003046r 3  A0 rr                        ldy #>zero_branch_runtime
003048r 3  A9 rr                        lda #<zero_branch_runtime
00304Ar 3  20 rr rr                     jsr cmpl_subroutine
00304Dr 3               
00304Dr 3                               ; Put the address (here) where the destination
00304Dr 3                               ; address needs to go so it can be put there later.
00304Dr 3  20 rr rr                     jsr xt_here
003050r 3               
003050r 3                               ; Fill in the destination address with 0 for now.
003050r 3  20 rr rr                     jsr xt_zero
003053r 3  20 rr rr                     jsr xt_comma
003056r 3               
003056r 3                               ; Swap the two addresses on the stack.
003056r 3  20 rr rr                     jsr xt_swap
003059r 3               
003059r 3  60           z_while:        rts
00305Ar 3               
00305Ar 3               
00305Ar 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
00305Ar 3               ; ## "within"  auto  ANS core ext
00305Ar 3                       ; """https://forth-standard.org/standard/core/WITHIN
00305Ar 3                       ;
00305Ar 3                       ; This an assembler version of the ANS Forth implementation
00305Ar 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
00305Ar 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
00305Ar 3                       ; ROT TUCK > -ROT > INVERT AND
00305Ar 3                       ; """"
00305Ar 3               xt_within:
00305Ar 3  20 rr rr                     jsr underflow_3
00305Dr 3               
00305Dr 3  20 rr rr                     jsr xt_over
003060r 3  20 rr rr                     jsr xt_minus
003063r 3  20 rr rr                     jsr xt_to_r
003066r 3  20 rr rr                     jsr xt_minus
003069r 3  20 rr rr                     jsr xt_r_from
00306Cr 3  20 rr rr                     jsr xt_u_less_than
00306Fr 3               
00306Fr 3  60           z_within:       rts
003070r 3               
003070r 3               
003070r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
003070r 3               ; ## "word"  auto  ANS core
003070r 3                       ; """https://forth-standard.org/standard/core/WORD
003070r 3                       ; Obsolete parsing word included for backwards compatibility only.
003070r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
003070r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
003070r 3                       ; Returns the result as a counted string (requires COUNT to convert
003070r 3                       ; to modern format), and inserts a space after the string. See "Forth
003070r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
003070r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
003070r 3                       ; for discussions of why you shouldn't be using WORD anymore.
003070r 3                       ;
003070r 3                       ; Forth
003070r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
003070r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
003070r 3                       ; """
003070r 3               
003070r 3               xt_word:
003070r 3  20 rr rr                     jsr underflow_1
003073r 3               
003073r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
003073r 3                               ; but unlike PARSE
003073r 3  A4 rr                        ldy toin                ; >IN
003075r 3               @loop:
003075r 3  C4 rr                        cpy ciblen              ; quit if end of input
003077r 3  F0 09                        beq @found_char
003079r 3  B1 rr                        lda (cib),y
00307Br 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
00307Dr 3  D0 03                        bne @found_char
00307Fr 3               
00307Fr 3  C8                           iny
003080r 3  80 F3                        bra @loop
003082r 3               @found_char:
003082r 3                               ; Save index of where word starts
003082r 3  84 rr                        sty toin
003084r 3               
003084r 3                               ; The real work is done by parse
003084r 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
003087r 3               
003087r 3                               ; Convert the modern ( addr u ) string format to obsolete
003087r 3                               ; ( caddr ) format. We just do this in the Dictionary
003087r 3  B5 00                        lda 0,x
003089r 3  92 rr                        sta (cp)                ; Save length of string
00308Br 3  48                           pha                     ; Keep copy of length for later
00308Cr 3               
00308Cr 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
00308Fr 3  A5 rr                        lda cp
003091r 3  18                           clc
003092r 3  69 01                        adc #1
003094r 3  95 02                        sta 2,x                 ; LSB of CP
003096r 3  A5 rr                        lda cp+1
003098r 3  69 00                        adc #0
00309Ar 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
00309Cr 3               
00309Cr 3  20 rr rr                     jsr xt_move
00309Fr 3               
00309Fr 3                               ; Return caddr
00309Fr 3  CA                           dex
0030A0r 3  CA                           dex
0030A1r 3  A5 rr                        lda cp
0030A3r 3  95 00                        sta 0,x
0030A5r 3  A5 rr                        lda cp+1
0030A7r 3  95 01                        sta 1,x
0030A9r 3               
0030A9r 3                               ; Adjust CP
0030A9r 3  68                           pla                     ; length of string
0030AAr 3  18                           clc
0030ABr 3  65 rr                        adc cp
0030ADr 3  85 rr                        sta cp
0030AFr 3  A5 rr                        lda cp+1
0030B1r 3  69 00                        adc #0                  ; we only need the carry
0030B3r 3  85 rr                        sta cp+1
0030B5r 3  60           z_word:         rts
0030B6r 3               
0030B6r 3               
0030B6r 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
0030B6r 3               ; ## "wordlist" auto ANS search
0030B6r 3                       ; """https://forth-standard.org/standard/search/WORDLIST
0030B6r 3                       ; See the tutorial on Wordlists and the Search Order for
0030B6r 3                       ; more information.
0030B6r 3                       ; """
0030B6r 3               
0030B6r 3               xt_wordlist:
0030B6r 3                               ; Get the current number of wordlists
0030B6r 3  A0 05                        ldy #num_wordlists_offset
0030B8r 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
0030BAr 3                                               ; the LSB needs to be checked.
0030BAr 3               
0030BAr 3                               ; See if we are already at the max.
0030BAr 3  C9 0C                        cmp #max_wordlists
0030BCr 3  D0 05                        bne @ok
0030BEr 3               
0030BEr 3                               ; Print an error message if all wordlists used.
0030BEr 3  A9 0B                        lda #err_wordlist
0030C0r 3  4C rr rr                     jmp error
0030C3r 3               
0030C3r 3               @ok:
0030C3r 3  1A                           inc             ; Increment the wordlist#
0030C4r 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
0030C6r 3  CA                           dex             ; and put it on the stack.
0030C7r 3  CA                           dex
0030C8r 3  95 00                        sta 0,x
0030CAr 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
0030CCr 3               
0030CCr 3  60           z_wordlist:     rts
0030CDr 3               
0030CDr 3               
0030CDr 3               
0030CDr 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
0030CDr 3               ; ## "words"  tested  ANS tools
0030CDr 3                       ; """https://forth-standard.org/standard/tools/WORDS
0030CDr 3                       ; This is pretty much only used at the command line so we can
0030CDr 3                       ; be slow and try to save space.
0030CDr 3                       ; """
0030CDr 3               
0030CDr 3               xt_words:
0030CDr 3                               ; we follow Gforth by starting on the next
0030CDr 3                               ; line
0030CDr 3  20 rr rr                     jsr xt_cr
0030D0r 3               
0030D0r 3                               ; We pretty-format the output by inserting a line break
0030D0r 3                               ; before the end of the line. We can get away with pushing
0030D0r 3                               ; the counter to the stack because this is usually an
0030D0r 3                               ; interactive word and speed is not that important
0030D0r 3  A9 00                        lda #0
0030D2r 3  48                           pha
0030D3r 3               
0030D3r 3                               ; Set up for traversing the wordlist search order.
0030D3r 3  CA                           dex                     ; Make room on the stack for
0030D4r 3  CA                           dex                     ; a dictionary pointer.
0030D5r 3  64 rr                        stz tmp3                ; Start at the beginning of
0030D7r 3                                                       ; the search order.
0030D7r 3               @wordlist_loop:
0030D7r 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
0030D9r 3  A5 rr                        lda tmp3
0030DBr 3  D1 rr                        cmp (up),y              ; See if we are done.
0030DDr 3  D0 02                        bne @have_wordlist
0030DFr 3               
0030DFr 3                               ; We ran out of wordlists to search.
0030DFr 3  80 44                        bra @words_done
0030E1r 3               
0030E1r 3               @have_wordlist:
0030E1r 3                               ; start with last word in Dictionary
0030E1r 3                               ; Get the current wordlist id
0030E1r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
0030E2r 3  69 1F                        adc #search_order_offset
0030E4r 3  A8                           tay
0030E5r 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
0030E7r 3               
0030E7r 3                               ; Get the DP for that wordlist.
0030E7r 3  0A                           asl                     ; Turn offset into cells offset.
0030E8r 3  18                           clc
0030E9r 3  69 06                        adc #wordlists_offset
0030EBr 3  A8                           tay
0030ECr 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
0030EEr 3  95 00                        sta 0,x                 ; on the stack. ( nt )
0030F0r 3  C8                           iny
0030F1r 3  B1 rr                        lda (up),y
0030F3r 3  95 01                        sta 1,x
0030F5r 3               
0030F5r 3               @loop:
0030F5r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0030F8r 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
0030FBr 3               
0030FBr 3                               ; Insert line break if we're about to go past the end of the
0030FBr 3                               ; line
0030FBr 3  68                           pla
0030FCr 3  18                           clc
0030FDr 3  75 00                        adc 0,x
0030FFr 3  1A                           inc                     ; don't forget the space between words
003100r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
003102r 3  90 05                        bcc @1
003104r 3               
003104r 3  20 rr rr                     jsr xt_cr
003107r 3  A9 00                        lda #0
003109r 3               @1:
003109r 3  48                           pha
00310Ar 3  20 rr rr                     jsr xt_type             ; ( nt )
00310Dr 3               
00310Dr 3  A9 20                        lda #AscSP
00310Fr 3  20 rr rr                     jsr emit_a
003112r 3               
003112r 3                               ; get next word, which begins two down
003112r 3  20 rr rr                     jsr xt_one_plus         ; 1+
003115r 3  20 rr rr                     jsr xt_one_plus         ; 1+
003118r 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
00311Br 3               
00311Br 3                               ; if next address is zero, we're done
00311Br 3  B5 00                        lda 0,x
00311Dr 3  15 01                        ora 1,x
00311Fr 3  D0 D4                        bne @loop
003121r 3               
003121r 3                               ; Move on to the next wordlist in the search order.
003121r 3  E6 rr                        inc tmp3
003123r 3  80 B2                        bra @wordlist_loop
003125r 3               
003125r 3               @words_done:
003125r 3  68                           pla                     ; dump counter
003126r 3               
003126r 3  E8                           inx
003127r 3  E8                           inx
003128r 3               
003128r 3  60           z_words:        rts
003129r 3               
003129r 3               
003129r 3               
003129r 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
003129r 3               ; ## "wordsize"  auto  Tali Forth
003129r 3                       ; """Given an word's name token (nt), return the size of the
003129r 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
003129r 3                       ; count the final RTS.
003129r 3                       ; """
003129r 3               xt_wordsize:
003129r 3  20 rr rr                     jsr underflow_1
00312Cr 3               
00312Cr 3                               ; We get the start address of the word from its header entry
00312Cr 3                               ; for the start of the actual code (execution token, xt)
00312Cr 3                               ; which is four bytes down, and the pointer to the end of the
00312Cr 3                               ; code (z_word, six bytes down)
00312Cr 3  B5 00                        lda 0,x
00312Er 3  85 rr                        sta tmp1
003130r 3  B5 01                        lda 1,x
003132r 3  85 rr                        sta tmp1+1
003134r 3               
003134r 3  A0 06                        ldy #6
003136r 3  B1 rr                        lda (tmp1),y    ; LSB of z
003138r 3  88                           dey
003139r 3  88                           dey
00313Ar 3               
00313Ar 3  38                           sec
00313Br 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
00313Dr 3  95 00                        sta 0,x
00313Fr 3               
00313Fr 3  A0 07                        ldy #7
003141r 3  B1 rr                        lda (tmp1),y    ; MSB of z
003143r 3  88                           dey
003144r 3  88                           dey
003145r 3               
003145r 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
003147r 3  95 01                        sta 1,x
003149r 3               
003149r 3  60           z_wordsize:     rts
00314Ar 3               
00314Ar 3               
00314Ar 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
00314Ar 3               ; ## "xor"  auto  ANS core
00314Ar 3                       ; """https://forth-standard.org/standard/core/XOR"""
00314Ar 3               xt_xor:
00314Ar 3  20 rr rr                     jsr underflow_2
00314Dr 3               
00314Dr 3  B5 00                        lda 0,x
00314Fr 3  55 02                        eor 2,x
003151r 3  95 02                        sta 2,x
003153r 3               
003153r 3  B5 01                        lda 1,x
003155r 3  55 03                        eor 3,x
003157r 3  95 03                        sta 3,x
003159r 3               
003159r 3  E8                           inx
00315Ar 3  E8                           inx
00315Br 3               
00315Br 3  60           z_xor:          rts
00315Cr 3               
00315Cr 3               
00315Cr 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
00315Cr 3               ; ## "0"  auto  Tali Forth
00315Cr 3                       ; """The disassembler assumes that this routine does not use Y. Note
00315Cr 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
00315Cr 3                       ; is 0."""
00315Cr 3               xt_case:
00315Cr 3               xt_forth_wordlist:
00315Cr 3               xt_zero:
00315Cr 3  CA                           dex             ; push
00315Dr 3  CA                           dex
00315Er 3  74 00                        stz 0,x
003160r 3  74 01                        stz 1,x
003162r 3               z_case:
003162r 3               z_forth_wordlist:
003162r 3               z_zero:
003162r 3  60                           rts
003163r 3               
003163r 3               
003163r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
003163r 3               ; ## "0="  auto  ANS core
003163r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
003163r 3               
003163r 3               xt_zero_equal:
003163r 3  20 rr rr                     jsr underflow_1
003166r 3               
003166r 3  B5 00                        lda 0,x
003168r 3  15 01                        ora 1,x
00316Ar 3  F0 04                        beq @zero
00316Cr 3               
00316Cr 3                               ; not a zero, so we need a FALSE flag (0)
00316Cr 3  A9 00                        lda #0
00316Er 3  80 02                        bra @store
003170r 3               @zero:
003170r 3                               ; We have a zero, so we need a TRUE flag (-1)
003170r 3  A9 FF                        lda #$ff
003172r 3               @store:
003172r 3  95 00                        sta 0,x
003174r 3  95 01                        sta 1,x
003176r 3               
003176r 3  60           z_zero_equal:   rts
003177r 3               
003177r 3               
003177r 3               
003177r 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
003177r 3               ; ## "0>"  auto  ANS core ext
003177r 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
003177r 3               
003177r 3               xt_zero_greater:
003177r 3  20 rr rr                     jsr underflow_1
00317Ar 3               
00317Ar 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
00317Cr 3               
00317Cr 3  B5 01                        lda 1,x         ; MSB
00317Er 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
003180r 3  15 00                        ora 0,x
003182r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
003184r 3               
003184r 3  88                           dey             ; TOS is postive, make true
003185r 3               @done:
003185r 3  98                           tya
003186r 3  95 00                        sta 0,x
003188r 3  95 01                        sta 1,x
00318Ar 3               
00318Ar 3  60           z_zero_greater: rts
00318Br 3               
00318Br 3               
00318Br 3               
00318Br 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
00318Br 3               ; ## "0<"  auto  ANS core
00318Br 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
00318Br 3               
00318Br 3               xt_zero_less:
00318Br 3  20 rr rr                     jsr underflow_1
00318Er 3               
00318Er 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
003190r 3               
003190r 3  B5 01                        lda 1,x         ; MSB
003192r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
003194r 3               
003194r 3  88                           dey             ; TOS is negative, make TRUE
003195r 3               @done:
003195r 3  98                           tya
003196r 3  95 00                        sta 0,x
003198r 3  95 01                        sta 1,x
00319Ar 3               
00319Ar 3  60           z_zero_less:    rts
00319Br 3               
00319Br 3               
00319Br 3               
00319Br 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
00319Br 3               ; ## "0<>"  auto  ANS core ext
00319Br 3                       ; """https://forth-standard.org/standard/core/Zerone"""
00319Br 3               
00319Br 3               xt_zero_unequal:
00319Br 3  20 rr rr                     jsr underflow_1
00319Er 3               
00319Er 3  A0 00                        ldy #0          ; default false
0031A0r 3               
0031A0r 3  B5 00                        lda 0,x
0031A2r 3  15 01                        ora 1,x
0031A4r 3  F0 01                        beq @got_zero
0031A6r 3               
0031A6r 3  88                           dey
0031A7r 3               @got_zero:
0031A7r 3  98                           tya
0031A8r 3  95 00                        sta 0,x
0031AAr 3  95 01                        sta 1,x
0031ACr 3               
0031ACr 3  60           z_zero_unequal: rts
0031ADr 3               
0031ADr 3               
0031ADr 3               
0031ADr 3               ; ==========================================================
0031ADr 3               ; EDITOR words
0031ADr 3               
0031ADr 3               ; This routine is used by both enter-screen and erase-screen
0031ADr 3               ; to get a buffer for the given screen number and set SCR to
0031ADr 3               ; the given screen number.  This word is not in the dictionary.
0031ADr 3               xt_editor_screen_helper:
0031ADr 3  20 rr rr                     jsr xt_dup
0031B0r 3  20 rr rr                     jsr xt_scr
0031B3r 3  20 rr rr                     jsr xt_store
0031B6r 3  20 rr rr                     jsr xt_buffer
0031B9r 3               z_editor_screen_helper:
0031B9r 3  60                           rts
0031BAr 3               
0031BAr 3               
0031BAr 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
0031BAr 3               ; ## "enter-screen"  auto  Tali Editor
0031BAr 3               
0031BAr 3               xt_editor_enter_screen:
0031BAr 3                               ; Set the variable SCR and get a buffer for the
0031BAr 3                               ; given screen number.
0031BAr 3  20 rr rr                     jsr xt_editor_screen_helper
0031BDr 3               
0031BDr 3                               ; Drop the buffer address.
0031BDr 3  20 rr rr                     jsr xt_drop
0031C0r 3               
0031C0r 3                               ; Overwrite the lines one at a time.
0031C0r 3  64 rr                        stz editor1
0031C2r 3               @prompt_loop:
0031C2r 3                               ; Put the current line number on the stack.
0031C2r 3  CA                           dex
0031C3r 3  CA                           dex
0031C4r 3  A5 rr                        lda editor1
0031C6r 3  95 00                        sta 0,x
0031C8r 3  74 01                        stz 1,x
0031CAr 3               
0031CAr 3                               ; Use the O word to prompt for overwrite.
0031CAr 3  20 rr rr                     jsr xt_editor_o
0031CDr 3               
0031CDr 3                               ; Move on to the next line.
0031CDr 3  E6 rr                        inc editor1
0031CFr 3  A9 10                        lda #16
0031D1r 3  C5 rr                        cmp editor1
0031D3r 3  D0 ED                        bne @prompt_loop
0031D5r 3               
0031D5r 3               z_editor_enter_screen:
0031D5r 3  60                           rts
0031D6r 3               
0031D6r 3               
0031D6r 3               
0031D6r 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
0031D6r 3               ; ## "erase-screen"  tested  Tali Editor
0031D6r 3               xt_editor_erase_screen:
0031D6r 3                               ; Set the variable SCR and get a buffer for the
0031D6r 3                               ; given screen number.
0031D6r 3  20 rr rr                     jsr xt_editor_screen_helper
0031D9r 3               
0031D9r 3                               ; Put 1024 (chars/screen) on stack.
0031D9r 3  CA                           dex
0031DAr 3  CA                           dex
0031DBr 3  74 00                        stz 0,x
0031DDr 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
0031DFr 3  95 01                        sta 1,x
0031E1r 3               
0031E1r 3                               ; Erase the entire block (fill with spaces).
0031E1r 3  20 rr rr                     jsr xt_blank
0031E4r 3               
0031E4r 3                               ; Mark buffer as updated.
0031E4r 3  20 rr rr                     jsr xt_update
0031E7r 3               
0031E7r 3               z_editor_erase_screen:
0031E7r 3  60                           rts
0031E8r 3               
0031E8r 3               
0031E8r 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
0031E8r 3               ; ## "el"  tested  Tali Editor
0031E8r 3               xt_editor_el:
0031E8r 3                               ; Turn the line number into buffer offset.
0031E8r 3                               ; This also loads the block into the buffer if it's
0031E8r 3                               ; not there for some reason.
0031E8r 3  20 rr rr                     jsr xt_editor_line
0031EBr 3               
0031EBr 3                               ; Put 64 (# of chars/line) on the stack.
0031EBr 3  CA                           dex
0031ECr 3  CA                           dex
0031EDr 3  A9 40                        lda #64
0031EFr 3  95 00                        sta 0,x
0031F1r 3  74 01                        stz 1,x
0031F3r 3               
0031F3r 3                               ; Fill with spaces.
0031F3r 3  20 rr rr                     jsr xt_blank
0031F6r 3               
0031F6r 3                               ; Mark buffer as updated.
0031F6r 3  20 rr rr                     jsr xt_update
0031F9r 3               
0031F9r 3  60           z_editor_el:    rts
0031FAr 3               
0031FAr 3               
0031FAr 3               ; ## EDITOR_L ( -- ) "List the current screen"
0031FAr 3               ; ## "l"  tested  Tali Editor
0031FAr 3               
0031FAr 3               xt_editor_l:
0031FAr 3                               ; Load the current screen
0031FAr 3  CA                           dex             ; Put SCR on the stack.
0031FBr 3  CA                           dex
0031FCr 3  A0 02                        ldy #scr_offset
0031FEr 3  B1 rr                        lda (up),y
003200r 3  95 00                        sta 0,x
003202r 3  C8                           iny
003203r 3  B1 rr                        lda (up),y
003205r 3  95 01                        sta 1,x
003207r 3  20 rr rr                     jsr xt_block    ; Get the current screen.
00320Ar 3               
00320Ar 3  20 rr rr                     jsr xt_cr
00320Dr 3               
00320Dr 3                               ; Print the screen number.
00320Dr 3                               ; We're using sliteral, so we need to set up the
00320Dr 3                               ; appropriate data structure (see sliteral)
00320Dr 3  80 08                        bra @after_screen_msg
00320Fr 3               
00320Fr 3               @screen_msg:
00320Fr 3  53 63 72 65                  .byte "Screen #"
003213r 3  65 6E 20 23  
003217r 3               
003217r 3               @after_screen_msg:
003217r 3  20 rr rr                     jsr sliteral_runtime
00321Ar 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
00321Er 3               
00321Er 3  20 rr rr                     jsr xt_type
003221r 3               
003221r 3                               ; Put the screen number and printed size for u.r on the stack.
003221r 3  20 rr rr                     jsr xt_scr
003224r 3  20 rr rr                     jsr xt_fetch
003227r 3  CA                           dex
003228r 3  CA                           dex
003229r 3  A9 04                        lda #4          ; four spaces
00322Br 3  95 00                        sta 0,x
00322Dr 3  74 01                        stz 1,x
00322Fr 3  20 rr rr                     jsr xt_u_dot_r
003232r 3               
003232r 3                               ; The address of the buffer is currently on the stack.
003232r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
003232r 3                               ; keep track of the line number in tmp3.
003232r 3  64 rr                        stz tmp3
003234r 3               
003234r 3               @line_loop:
003234r 3  20 rr rr                     jsr xt_cr
003237r 3               
003237r 3                               ; Print the line number (2-space fixed width)
003237r 3  CA                           dex
003238r 3  CA                           dex
003239r 3  CA                           dex
00323Ar 3  CA                           dex
00323Br 3  74 03                        stz 3,x
00323Dr 3  A5 rr                        lda tmp3
00323Fr 3  95 02                        sta 2,x
003241r 3  74 01                        stz 1,x
003243r 3  A9 02                        lda #2
003245r 3  95 00                        sta 0,x
003247r 3  20 rr rr                     jsr xt_u_dot_r
00324Ar 3  20 rr rr                     jsr xt_space
00324Dr 3               
00324Dr 3                               ; Print one line using the address on the stack.
00324Dr 3  20 rr rr                     jsr xt_dup
003250r 3  CA                           dex
003251r 3  CA                           dex
003252r 3  A9 40                        lda #64
003254r 3  95 00                        sta 0,x
003256r 3  74 01                        stz 1,x
003258r 3  20 rr rr                     jsr xt_type
00325Br 3               
00325Br 3                               ; Add 64 to the address on the stack to move to the next line.
00325Br 3  18                           clc
00325Cr 3  A9 40                        lda #64
00325Er 3  75 00                        adc 0,x
003260r 3  95 00                        sta 0,x
003262r 3  B5 01                        lda 1,x
003264r 3  69 00                        adc #0      ; Add carry
003266r 3  95 01                        sta 1,x
003268r 3               
003268r 3                               ; Increment the line number (held in tmp3)
003268r 3  E6 rr                        inc tmp3
00326Ar 3               
00326Ar 3                               ; See if we are done.
00326Ar 3  A5 rr                        lda tmp3
00326Cr 3  C9 10                        cmp #16
00326Er 3  D0 C4                        bne @line_loop
003270r 3               
003270r 3  20 rr rr                     jsr xt_cr
003273r 3                               ; Drop the address on the stack.
003273r 3  E8                           inx
003274r 3  E8                           inx
003275r 3               
003275r 3  60           z_editor_l:            rts
003276r 3               
003276r 3               
003276r 3               
003276r 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
003276r 3               ; ## "line"  tested  Tali Editor
003276r 3               
003276r 3               xt_editor_line:
003276r 3  20 rr rr                     jsr underflow_1
003279r 3               
003279r 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
003279r 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
00327Br 3               @shift_tos_left:
00327Br 3  16 00                        asl 0,x         ; Shift TOS to the left
00327Dr 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
00327Fr 3  88                           dey
003280r 3  D0 F9                        bne @shift_tos_left
003282r 3                               ; Load the current screen into a buffer
003282r 3                               ; and get the buffer address
003282r 3  20 rr rr                     jsr xt_scr
003285r 3  20 rr rr                     jsr xt_fetch
003288r 3  20 rr rr                     jsr xt_block
00328Br 3               
00328Br 3                               ; Add the offset to the buffer base address.
00328Br 3  20 rr rr                     jsr xt_plus
00328Er 3               
00328Er 3  60           z_editor_line:  rts
00328Fr 3               
00328Fr 3               
00328Fr 3               
00328Fr 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
00328Fr 3               ; ## "o"  tested  Tali Editor
00328Fr 3               xt_editor_o:
00328Fr 3                               ; Print prompt
00328Fr 3  20 rr rr                     jsr xt_cr
003292r 3  20 rr rr                     jsr xt_dup
003295r 3  20 rr rr                     jsr xt_two
003298r 3  20 rr rr                     jsr xt_u_dot_r
00329Br 3  20 rr rr                     jsr xt_space
00329Er 3  A9 2A                        lda #42         ; ASCII for *
0032A0r 3  20 rr rr                     jsr emit_a
0032A3r 3  20 rr rr                     jsr xt_space
0032A6r 3               
0032A6r 3                               ; Accept new input (directly into the buffer)
0032A6r 3  20 rr rr                     jsr xt_editor_line
0032A9r 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
0032ACr 3  CA                           dex
0032ADr 3  CA                           dex
0032AEr 3  A9 40                        lda #64         ; chars/line
0032B0r 3  95 00                        sta 0,x
0032B2r 3  74 01                        stz 1,x
0032B4r 3  20 rr rr                     jsr xt_accept
0032B7r 3               
0032B7r 3                               ; Fill the rest with spaces.
0032B7r 3                               ; Stack is currently ( line_address numchars_from_accept )
0032B7r 3  20 rr rr                     jsr xt_dup
0032BAr 3  20 rr rr                     jsr xt_not_rote ; -rot
0032BDr 3  20 rr rr                     jsr xt_plus
0032C0r 3  CA                           dex
0032C1r 3  CA                           dex
0032C2r 3  A9 40                        lda #64         ; chars/line
0032C4r 3  95 00                        sta 0,x
0032C6r 3  74 01                        stz 1,x
0032C8r 3  20 rr rr                     jsr xt_rot
0032CBr 3  20 rr rr                     jsr xt_minus
0032CEr 3  20 rr rr                     jsr xt_blank
0032D1r 3               
0032D1r 3                               ; Mark buffer as updated.
0032D1r 3  20 rr rr                     jsr xt_update
0032D4r 3               
0032D4r 3  60           z_editor_o:     rts
0032D5r 3               
0032D5r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
0032D5r 3               ; ## "lcdput" coded Custom
0032D5r 3               xt_lcdput:
0032D5r 3  20 rr rr                     jsr underflow_1
0032D8r 3               
0032D8r 3  B5 00                        lda 0,x
0032DAr 3                       .ifdef lcd_print
0032DAr 3  20 rr rr                     jsr lcd_print
0032DDr 3                       .endif
0032DDr 3  E8                           inx
0032DEr 3  E8                           inx
0032DFr 3  60           z_lcdput: rts
0032E0r 3               
0032E0r 3               
0032E0r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
0032E0r 3               ; ## "lcdprint"  coded Custom
0032E0r 3               
0032E0r 3               xt_lcdprint:
0032E0r 3  20 rr rr                     jsr underflow_2
0032E3r 3               
0032E3r 3                               ; Save the starting address into tmp1
0032E3r 3  B5 02                        lda 2,x
0032E5r 3  85 rr                        sta tmp1
0032E7r 3  B5 03                        lda 3,x
0032E9r 3  85 rr                        sta tmp1+1
0032EBr 3               @loop:
0032EBr 3                               ; done if length is zero
0032EBr 3  B5 00                        lda 0,x
0032EDr 3  15 01                        ora 1,x
0032EFr 3  F0 15                        beq @done
0032F1r 3               
0032F1r 3                               ; Send the current character
0032F1r 3  B2 rr                        lda (tmp1)
0032F3r 3                       .ifdef lcd_print
0032F3r 3  20 rr rr                     jsr lcd_print      ; avoids stack foolery
0032F6r 3                       .endif
0032F6r 3                               ; Move the address along (in tmp1)
0032F6r 3  E6 rr                        inc tmp1
0032F8r 3  D0 02                        bne @1
0032FAr 3  E6 rr                        inc tmp1+1
0032FCr 3               @1:
0032FCr 3                               ; Reduce the count (on the data stack)
0032FCr 3  B5 00                        lda 0,x
0032FEr 3  D0 02                        bne @2
003300r 3  D6 01                        dec 1,x
003302r 3               @2:
003302r 3  D6 00                        dec 0,x
003304r 3               
003304r 3  80 E5                        bra @loop
003306r 3               @done:
003306r 3  E8                           inx
003307r 3  E8                           inx
003308r 3  E8                           inx
003309r 3  E8                           inx
00330Ar 3               
00330Ar 3  60           z_lcdprint:         rts
00330Br 3               
00330Br 3               
00330Br 3               
00330Br 3               ; ## CLS ( -- ) "clea VGA screen"
00330Br 3               ; ## "cls" coded Custom
00330Br 3               xt_cls:
00330Br 3                       .ifdef vga_clear
00330Br 3                               jsr vga_clear
00330Br 3                       .endif
00330Br 3               
00330Br 3  60           z_cls: rts
00330Cr 3               
00330Cr 3               
00330Cr 3               ; ## SPI_INIT ( -- ) "Init SPI system"
00330Cr 3               ; ## "spi_init" coded Custom
00330Cr 3               xt_spi_init:
00330Cr 3                       .ifdef spi_init
00330Cr 3  20 rr rr                     jsr spi_init
00330Fr 3                       .endif
00330Fr 3  60           z_spi_init: rts
003310r 3               
003310r 3               
003310r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
003310r 3               ; ## "spi_clk_toggle" coded Custom
003310r 3               xt_spi_clk_toggle:
003310r 3                       .ifdef spi_clk_toggle
003310r 3  20 rr rr                     jsr spi_clk_toggle
003313r 3                       .endif
003313r 3  60           z_spi_clk_toggle: rts
003314r 3               
003314r 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
003314r 3               ; ## "spi_select" coded Custom
003314r 3               xt_spi_select:
003314r 3  20 rr rr                     jsr underflow_1
003317r 3               
003317r 3  B5 00                        lda 0,x
003319r 3                       .ifdef spi_select
003319r 3  20 rr rr                     jsr spi_select
00331Cr 3                       .endif
00331Cr 3  E8                           inx
00331Dr 3  E8                           inx
00331Er 3  60           z_spi_select: rts
00331Fr 3               
00331Fr 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
00331Fr 3               ; ## "spi_transceive" coded Custom
00331Fr 3               xt_spi_transceive:
00331Fr 3  20 rr rr                     jsr underflow_1
003322r 3               
003322r 3  B5 00                        lda 0,x
003324r 3                       .ifdef spi_transceive
003324r 3  20 rr rr                     jsr spi_transceive
003327r 3                       .endif
003327r 3  95 00                        sta 0,x         ; put return value in TOS
003329r 3  74 01                        stz 1,X         ;reset value there
00332Br 3  60           z_spi_transceive: rts
00332Cr 3               
00332Cr 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
00332Cr 3               ; ## "spi_transceive" coded Custom
00332Cr 3               xt_sd_init:
00332Cr 3  20 rr rr                     jsr underflow_1
00332Fr 3               
00332Fr 3  B5 00                        lda 0,x
003331r 3                       .ifdef sd_init
003331r 3  20 rr rr                     jsr sd_init
003334r 3                       .endif
003334r 3  95 00                        sta 0,x         ; put return value in TOS
003336r 3  74 01                        stz 1,X         ;reset value there
003338r 3  60           z_sd_init: rts
003339r 3               
003339r 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
003339r 3               ; ## "sd_readsector" coded Custom
003339r 3               xt_sd_readsector:
003339r 3  20 rr rr                     jsr underflow_3
00333Cr 3                       .ifdef sd_readsector
00333Cr 3                               ; get and save storage address
00333Cr 3  B5 00                        lda 0,x
00333Er 3  85 rr                        sta sd_buffer_address
003340r 3  B5 01                        lda 1, x
003342r 3  85 rr                        sta sd_buffer_address + 1
003344r 3                               ; get and save sector number (32 bit number, double)
003344r 3  B5 02                        lda 2, X
003346r 3  8D rr rr                     sta SD_ARG + 3
003349r 3  B5 03                        lda 3, X
00334Br 3  8D rr rr                     sta SD_ARG + 2
00334Er 3  B5 04                        lda 4, X
003350r 3  8D rr rr                     sta SD_ARG + 1
003353r 3  B5 05                        lda 5, X
003355r 3  8D rr rr                     sta SD_ARG
003358r 3  A9 01                        lda #1
00335Ar 3  8D rr rr                     sta SD_CRC
00335Dr 3               
00335Dr 3  20 rr rr                     jsr sd_readsector
003360r 3                       .endif
003360r 3  95 00                        sta 0,x         ; put return value in TOS
003362r 3  74 01                        stz 1,X         ;reset value there
003364r 3               
003364r 3  E8                           inx
003365r 3  E8                           inx
003366r 3  E8                           inx
003367r 3  E8                           inx
003368r 3               
003368r 3  60           z_sd_readsector: rts
003369r 3               
003369r 3               
003369r 3               ; ## FAT32_INIT ( u -- u ) "initialize FAT32 file system on passed spi drive address"
003369r 3               ; ## "fat32_init" coded Custom
003369r 3               xt_fat32_init:
003369r 3  20 rr rr                     jsr underflow_1
00336Cr 3               
00336Cr 3  B5 00                        lda 0,x
00336Er 3                       .ifdef sd_init
00336Er 3  20 rr rr                     jsr sd_init
003371r 3  D0 05                        bne @error
003373r 3                       .endif
003373r 3                       .ifdef fat32_init
003373r 3  20 rr rr                     jsr fat32_init
003376r 3  F0 02                        beq @end
003378r 3                       .endif
003378r 3                       .ifdef fat32_openroot
003378r 3                               ; jsr fat32_openroot
003378r 3                               ; beq @end
003378r 3                       .endif
003378r 3               @error:
003378r 3  A9 01                        lda #1
00337Ar 3               @end:
00337Ar 3  95 00                        sta 0,x         ; put return value in TOS
00337Cr 3  74 01                        stz 1,X         ;reset value there
00337Er 3  60           z_fat32_init: rts
00337Fr 3               
00337Fr 3               
00337Fr 3               ; ## FAT32_ROOT ( -- u ) "initialize FAT32 file system on passed spi drive address"
00337Fr 3               ; ## "fat32_root" coded Custom
00337Fr 3               xt_fat32_root:
00337Fr 3               
00337Fr 3  CA                   dex
003380r 3  CA                   dex
003381r 3                       .ifdef fat32_openroot
003381r 3  20 rr rr                     jsr fat32_openroot
003384r 3  F0 02                        beq @end
003386r 3                       .endif
003386r 3                       ; .ifdef fat32_readdirent
003386r 3                       ;         jsr fat32_readdirent
003386r 3                       ;         bcc @end
003386r 3                       ; .endif
003386r 3               
003386r 3               @error:
003386r 3  A9 01                lda #1
003388r 3               @end:
003388r 3               
003388r 3  95 00                sta 0,x         ; put return value in TOS
00338Ar 3  74 01                stz 1,X         ;reset value there
00338Cr 3  60           z_fat32_root: rts
00338Dr 3               
00338Dr 3               ; ## FAT32_FIND ( addr u -- u ) "Open file from initialized fat32 FS"
00338Dr 3               ; ## "fat32_find" coded Custom
00338Dr 3               xt_fat32_find:
00338Dr 3  46 49 4C 45  textfile:  .byte "FILE.TXT   ", 0
003391r 3  2E 54 58 54  
003395r 3  20 20 20 00  
003399r 3  A9 rr                        lda #<textfile
00339Br 3  85 rr                        sta fat32_filenamepointer
00339Dr 3  A9 rr                        lda #>textfile
00339Fr 3  85 rr                        sta fat32_filenamepointer+1
0033A1r 3                       .ifdef fat32_finddirent
0033A1r 3  20 rr rr                     jsr fat32_finddirent    ; find the file from its name
0033A4r 3  D0 34                        bne @error
0033A6r 3                       .endif
0033A6r 3  20 rr rr                     jsr fat32_file_read
0033A9r 3  D0 2F                        bne @error
0033ABr 3  CA                           dex
0033ACr 3  CA                           dex
0033ADr 3  A5 rr                        lda sd_buffer_address
0033AFr 3  95 00                        sta 0,x
0033B1r 3  A5 rr                        lda sd_buffer_address+1
0033B3r 3  95 01                        sta 1, x
0033B5r 3               ;                 phy
0033B5r 3               ;         ldy #0
0033B5r 3               ; @printloop:
0033B5r 3               ;         lda (sd_buffer_address),y
0033B5r 3               ;         beq @ex
0033B5r 3               ;         jsr kernel_putc
0033B5r 3               ; @ex:
0033B5r 3               ;         ply
0033B5r 3  4C rr rr             jmp @end
0033B8r 3               
0033B8r 3  4C rr rr                     jmp @end
0033BBr 3               
0033BBr 3  20 rr rr                     jsr underflow_2
0033BEr 3  5A                           phy
0033BFr 3  B4 00                        ldy 0,x ; length of string
0033C1r 3  A9 00                        lda #0
0033C3r 3               @reset_loop:
0033C3r 3                           .ifdef fat32_finddirent
0033C3r 3  91 rr                        sta (fat32_filenamepointer),y
0033C5r 3  C8                           iny
0033C6r 3  C0 0B                        cpy #11
0033C8r 3  90 F9                        bcc @reset_loop
0033CAr 3                           .endif
0033CAr 3  E8                           inx     ; get address
0033CBr 3  E8                           inx
0033CCr 3                           .ifdef fat32_finddirent
0033CCr 3  B5 00                        lda 0,x
0033CEr 3  85 rr                        sta fat32_filenamepointer
0033D0r 3  B5 01                        lda 1,x
0033D2r 3  85 rr                        sta fat32_filenamepointer+1
0033D4r 3                           .endif
0033D4r 3               
0033D4r 3  7A                           ply
0033D5r 3                           .ifdef fat32_finddirent
0033D5r 3  20 rr rr                     jsr fat32_finddirent    ; find the file from its name
0033D8r 3  F0 02                        beq @end
0033DAr 3                           .endif
0033DAr 3               
0033DAr 3               @error:
0033DAr 3  A9 01                        lda #1
0033DCr 3               @end:
0033DCr 3  95 00                        sta 0,x         ; put return value in TOS
0033DEr 3  74 01                        stz 1,X         ;reset value there
0033E0r 3  60           z_fat32_find: rts
0033E1r 3               
0033E1r 3               ; ## time ( -- addr ) "get time storage address"
0033E1r 3               ; ## "time" coded Custom
0033E1r 3               xt_time:
0033E1r 3                       .ifdef time
0033E1r 3  A9 rr                lda #time
0033E3r 3                       .else
0033E3r 3                       lda #0
0033E3r 3                       .endif
0033E3r 3  CA                   dex
0033E4r 3  CA                   dex
0033E5r 3  95 00                sta 0,x
0033E7r 3  74 01                stz 1,x
0033E9r 3               
0033E9r 3               
0033E9r 3  60           z_time: rts
0033EAr 3               
0033EAr 3               ; TODO add routine to send a block of data in memory via SPI
0033EAr 3               ; similar to lcdprint
0033EAr 3               
0033EAr 3               ; END
0033EAr 3               
0033EAr 3               
0033EAr 2                   .include "headers.s"          ; Headers of native words
0033EAr 3               ; Dictionary Headers for Tali Forth 2
0033EAr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
0033EAr 3               ; First version: 05. Dec 2016 (Liara Forth)
0033EAr 3               ; This version: 29. Dec 2018
0033EAr 3               
0033EAr 3               ; Dictionary headers are kept separately from the code, which allows various
0033EAr 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
0033EAr 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
0033EAr 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
0033EAr 3               ; header in the Dictionary. There the link to the next word in the Dictionary
0033EAr 3               ; is always one cell down from the current word's own nt. In the code itself,
0033EAr 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
0033EAr 3               
0033EAr 3               ; This gives us the following header structure:
0033EAr 3               
0033EAr 3               ;              8 bit     8 bit
0033EAr 3               ;               LSB       MSB
0033EAr 3               ; nt_word ->  +--------+--------+
0033EAr 3               ;          +0 | Length | Status |
0033EAr 3               ;             +--------+--------+
0033EAr 3               ;          +2 | Next Header     | -> nt_next_word
0033EAr 3               ;             +-----------------+
0033EAr 3               ;          +4 | Start of Code   | -> xt_word
0033EAr 3               ;             +-----------------+
0033EAr 3               ;          +6 | End of Code     | -> z_word
0033EAr 3               ;             +--------+--------+
0033EAr 3               ;          +8 | Name   |        |
0033EAr 3               ;             +--------+--------+
0033EAr 3               ;             |        |        |
0033EAr 3               ;             +--------+--------+
0033EAr 3               ;             |        |  ...   | (name string does not end with a zero)
0033EAr 3               ;          +n +--------+--------+
0033EAr 3               
0033EAr 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
0033EAr 3               ; which are:
0033EAr 3               
0033EAr 3               ;       CO - Compile Only
0033EAr 3               ;       IM - Immediate Word
0033EAr 3               ;       NN - Never Native Compile (must always be called by JSR)
0033EAr 3               ;       AN - Always Native Compile (may not be called by JSR)
0033EAr 3               ;       UF - Contains underflow check
0033EAr 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
0033EAr 3               
0033EAr 3               ; Note there are currently two bits unused.
0033EAr 3               
0033EAr 3               ; By default, all existing words can be natively compiled (compiled inline) or
0033EAr 3               ; as a subroutine jump target; the system decides which variant to use based on
0033EAr 3               ; a threshold the user can set. By default, all user-created words are flagged
0033EAr 3               ; never-native. The user can override this by using the always-native word
0033EAr 3               ; just after defining their new word.  The NN flag forbids native compiling,
0033EAr 3               ; the AN flag forces it.
0033EAr 3               
0033EAr 3               ; The last word (top word in code) is always BYE. It is marked as the last word
0033EAr 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
0033EAr 3               ; more common ones first (further down in code) so they are found earlier.
0033EAr 3               ; Anything to do with output comes later (further up) because things will
0033EAr 3               ; always be slow if there is a human involved.
0033EAr 3               
0033EAr 3               ; The initial skeleton of this list was automatically generated by a script
0033EAr 3               ; in the tools folder and then sorted by hand.
0033EAr 3               
0033EAr 3               nt_bye:
0033EAr 3  03                   .byte 3         ; length of word strings
0033EBr 3  00                   .byte 0         ; status byte
0033ECr 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
0033EEr 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
0033F0r 3  rr rr                .word z_bye     ; end of code (RTS)
0033F2r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
0033F5r 3               
0033F5r 3               
0033F5r 3               nt_cold:
0033F5r 3  04 00                .byte 4, 0
0033F7r 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
0033FBr 3  rr rr        
0033FDr 3  63 6F 6C 64          .byte "cold"
003401r 3               
003401r 3               nt_lcdput:
003401r 3  06 10                .byte 6, UF
003403r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
003407r 3  rr rr        
003409r 3  6C 63 64 70          .byte "lcdput"
00340Dr 3  75 74        
00340Fr 3               
00340Fr 3               nt_lcdprint:
00340Fr 3  08 10                .byte 8, UF
003411r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
003415r 3  rr rr        
003417r 3  6C 63 64 70          .byte "lcdprint"
00341Br 3  72 69 6E 74  
00341Fr 3               
00341Fr 3               nt_cls:
00341Fr 3  03 00                .byte 3, 0
003421r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
003425r 3  rr rr        
003427r 3  63 6C 73             .byte "cls"
00342Ar 3               
00342Ar 3               nt_spi_init:
00342Ar 3  08 00                .byte 8, 0
00342Cr 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
003430r 3  rr rr        
003432r 3  73 70 69 5F          .byte "spi_init"
003436r 3  69 6E 69 74  
00343Ar 3               
00343Ar 3               
00343Ar 3               nt_spi_clk_toggle:
00343Ar 3  0E 00                .byte 14, 0
00343Cr 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
003440r 3  rr rr        
003442r 3  73 70 69 5F          .byte "spi_clk_toggle"
003446r 3  63 6C 6B 5F  
00344Ar 3  74 6F 67 67  
003450r 3               
003450r 3               nt_spi_select:
003450r 3  0A 00                .byte 10, 0
003452r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
003456r 3  rr rr        
003458r 3  73 70 69 5F          .byte "spi_select"
00345Cr 3  73 65 6C 65  
003460r 3  63 74        
003462r 3               
003462r 3               nt_spi_transceive:
003462r 3  0E 00                .byte 14, 0
003464r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
003468r 3  rr rr        
00346Ar 3  73 70 69 5F          .byte "spi_transceive"
00346Er 3  74 72 61 6E  
003472r 3  73 63 65 69  
003478r 3               
003478r 3               nt_sd_init:
003478r 3  07 00                .byte 7, 0
00347Ar 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
00347Er 3  rr rr        
003480r 3  73 64 5F 69          .byte "sd_init"
003484r 3  6E 69 74     
003487r 3               
003487r 3               
003487r 3               nt_sd_readsector:
003487r 3  0D 00                .byte 13, 0
003489r 3  rr rr rr rr          .word nt_sd_init, xt_sd_readsector, z_sd_readsector
00348Dr 3  rr rr        
00348Fr 3  73 64 5F 72          .byte "sd_readsector"
003493r 3  65 61 64 73  
003497r 3  65 63 74 6F  
00349Cr 3               
00349Cr 3               
00349Cr 3               nt_fat32_init:
00349Cr 3  0A 00                .byte 10, 0
00349Er 3  rr rr rr rr          .word nt_sd_readsector, xt_fat32_init, z_fat32_init
0034A2r 3  rr rr        
0034A4r 3  66 61 74 33          .byte "fat32_init"
0034A8r 3  32 5F 69 6E  
0034ACr 3  69 74        
0034AEr 3               
0034AEr 3               nt_fat32_root:
0034AEr 3  0A 00                .byte 10, 0
0034B0r 3  rr rr rr rr          .word nt_fat32_init, xt_fat32_root, z_fat32_root
0034B4r 3  rr rr        
0034B6r 3  66 61 74 33          .byte "fat32_root"
0034BAr 3  32 5F 72 6F  
0034BEr 3  6F 74        
0034C0r 3               
0034C0r 3               nt_fat32_find:
0034C0r 3  0A 00                .byte 10, 0
0034C2r 3  rr rr rr rr          .word nt_fat32_root, xt_fat32_find, z_fat32_find
0034C6r 3  rr rr        
0034C8r 3  66 61 74 33          .byte "fat32_find"
0034CCr 3  32 5F 66 69  
0034D0r 3  6E 64        
0034D2r 3               
0034D2r 3               nt_time:
0034D2r 3  04 00                .byte 4, 0
0034D4r 3  rr rr rr rr          .word nt_fat32_find, xt_time, z_time
0034D8r 3  rr rr        
0034DAr 3  74 69 6D 65          .byte "time"
0034DEr 3               
0034DEr 3               nt_ed:                  ; ed6502
0034DEr 3  02 08                .byte 2, NN
0034E0r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
0034E4r 3  rr rr        
0034E6r 3  65 64                .byte "ed"
0034E8r 3               
0034E8r 3  03 08        nt_see: .byte 3, NN
0034EAr 3  rr rr rr rr          .word nt_ed, xt_see, z_see
0034EEr 3  rr rr        
0034F0r 3  73 65 65             .byte "see"
0034F3r 3               
0034F3r 3               nt_forth:
0034F3r 3  05 00                .byte 5, 0
0034F5r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
0034F9r 3  rr rr        
0034FBr 3  66 6F 72 74          .byte "forth"
0034FFr 3  68           
003500r 3               
003500r 3               nt_order:
003500r 3  05 00                .byte 5, 0
003502r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
003506r 3  rr rr        
003508r 3  6F 72 64 65          .byte "order"
00350Cr 3  72           
00350Dr 3               
00350Dr 3               nt_to_order:
00350Dr 3  06 00                .byte 6, 0
00350Fr 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
003513r 3  rr rr        
003515r 3  3E 6F 72 64          .byte ">order"
003519r 3  65 72        
00351Br 3               
00351Br 3               nt_previous:
00351Br 3  08 00                .byte 8, 0
00351Dr 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
003521r 3  rr rr        
003523r 3  70 72 65 76          .byte "previous"
003527r 3  69 6F 75 73  
00352Br 3               
00352Br 3               nt_also:
00352Br 3  04 00                .byte 4, 0
00352Dr 3  rr rr rr rr          .word nt_previous, xt_also, z_also
003531r 3  rr rr        
003533r 3  61 6C 73 6F          .byte "also"
003537r 3               
003537r 3               nt_only:
003537r 3  04 00                .byte 4, 0
003539r 3  rr rr rr rr          .word nt_also, xt_only, z_only
00353Dr 3  rr rr        
00353Fr 3  6F 6E 6C 79          .byte "only"
003543r 3               
003543r 3               nt_forth_wordlist:      ; shares code with ZERO
003543r 3  0E 00                .byte 14, 0
003545r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
003549r 3  rr rr        
00354Br 3  66 6F 72 74          .byte "forth-wordlist"
00354Fr 3  68 2D 77 6F  
003553r 3  72 64 6C 69  
003559r 3               
003559r 3               nt_editor_wordlist:     ; shares code with ONE
003559r 3  0F 00                .byte 15, 0
00355Br 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
00355Fr 3  rr rr        
003561r 3  65 64 69 74          .byte "editor-wordlist"
003565r 3  6F 72 2D 77  
003569r 3  6F 72 64 6C  
003570r 3               
003570r 3               nt_assembler_wordlist:  ; shares code with TWO
003570r 3  12 00                .byte 18, 0
003572r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
003576r 3  rr rr        
003578r 3  61 73 73 65          .byte "assembler-wordlist"
00357Cr 3  6D 62 6C 65  
003580r 3  72 2D 77 6F  
00358Ar 3               
00358Ar 3               nt_root_wordlist:
00358Ar 3  0D 00                .byte 13, 0
00358Cr 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
003590r 3  rr rr        
003592r 3  72 6F 6F 74          .byte "root-wordlist"
003596r 3  2D 77 6F 72  
00359Ar 3  64 6C 69 73  
00359Fr 3               
00359Fr 3               nt_get_order:
00359Fr 3  09 00                .byte 9, 0
0035A1r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
0035A5r 3  rr rr        
0035A7r 3  67 65 74 2D          .byte "get-order"
0035ABr 3  6F 72 64 65  
0035AFr 3  72           
0035B0r 3               
0035B0r 3               nt_set_order:
0035B0r 3  09 00                .byte 9, 0
0035B2r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
0035B6r 3  rr rr        
0035B8r 3  73 65 74 2D          .byte "set-order"
0035BCr 3  6F 72 64 65  
0035C0r 3  72           
0035C1r 3               
0035C1r 3               nt_get_current:
0035C1r 3  0B 00                .byte 11, 0
0035C3r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
0035C7r 3  rr rr        
0035C9r 3  67 65 74 2D          .byte "get-current"
0035CDr 3  63 75 72 72  
0035D1r 3  65 6E 74     
0035D4r 3               
0035D4r 3               nt_set_current:
0035D4r 3  0B 10                .byte 11, UF
0035D6r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
0035DAr 3  rr rr        
0035DCr 3  73 65 74 2D          .byte "set-current"
0035E0r 3  63 75 72 72  
0035E4r 3  65 6E 74     
0035E7r 3               
0035E7r 3               nt_search_wordlist:
0035E7r 3  0F 10                .byte 15, UF
0035E9r 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
0035EDr 3  rr rr        
0035EFr 3  73 65 61 72          .byte "search-wordlist"
0035F3r 3  63 68 2D 77  
0035F7r 3  6F 72 64 6C  
0035FEr 3               
0035FEr 3               nt_wordlist:
0035FEr 3  08 00                .byte 8, 0
003600r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
003604r 3  rr rr        
003606r 3  77 6F 72 64          .byte "wordlist"
00360Ar 3  6C 69 73 74  
00360Er 3               
00360Er 3               nt_definitions:
00360Er 3  0B 00                .byte 11, 0
003610r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
003614r 3  rr rr        
003616r 3  64 65 66 69          .byte "definitions"
00361Ar 3  6E 69 74 69  
00361Er 3  6F 6E 73     
003621r 3               
003621r 3               nt_block_ramdrive_init:
003621r 3  13 10                .byte 19, UF
003623r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
003627r 3  rr rr        
003629r 3  62 6C 6F 63          .byte "block-ramdrive-init"
00362Dr 3  6B 2D 72 61  
003631r 3  6D 64 72 69  
00363Cr 3               
00363Cr 3               nt_list:
00363Cr 3  04 10                .byte 4, UF
00363Er 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
003642r 3  rr rr        
003644r 3  6C 69 73 74          .byte "list"
003648r 3               
003648r 3               nt_thru:
003648r 3  04 10                .byte 4, UF
00364Ar 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
00364Er 3  rr rr        
003650r 3  74 68 72 75          .byte "thru"
003654r 3               
003654r 3               nt_load:
003654r 3  04 10                .byte 4, UF
003656r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
00365Ar 3  rr rr        
00365Cr 3  6C 6F 61 64          .byte "load"
003660r 3               
003660r 3               nt_flush:
003660r 3  05 00                .byte 5, 0
003662r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
003666r 3  rr rr        
003668r 3  66 6C 75 73          .byte "flush"
00366Cr 3  68           
00366Dr 3               
00366Dr 3               nt_empty_buffers:
00366Dr 3  0D 00                .byte 13, 0
00366Fr 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
003673r 3  rr rr        
003675r 3  65 6D 70 74          .byte "empty-buffers"
003679r 3  79 2D 62 75  
00367Dr 3  66 66 65 72  
003682r 3               
003682r 3               nt_buffer:
003682r 3  06 00                .byte 6, 0
003684r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
003688r 3  rr rr        
00368Ar 3  62 75 66 66          .byte "buffer"
00368Er 3  65 72        
003690r 3               
003690r 3               nt_update:
003690r 3  06 00                .byte 6, 0
003692r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
003696r 3  rr rr        
003698r 3  75 70 64 61          .byte "update"
00369Cr 3  74 65        
00369Er 3               
00369Er 3               nt_block:
00369Er 3  05 00                .byte 5, 0
0036A0r 3  rr rr rr rr          .word nt_update, xt_block, z_block
0036A4r 3  rr rr        
0036A6r 3  62 6C 6F 63          .byte "block"
0036AAr 3  6B           
0036ABr 3               
0036ABr 3               nt_save_buffers:
0036ABr 3  0C 00                .byte 12, 0
0036ADr 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
0036B1r 3  rr rr        
0036B3r 3  73 61 76 65          .byte "save-buffers"
0036B7r 3  2D 62 75 66  
0036BBr 3  66 65 72 73  
0036BFr 3               
0036BFr 3               nt_block_read_vector:
0036BFr 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
0036C1r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
0036C5r 3  rr rr        
0036C7r 3  62 6C 6F 63          .byte "block-read-vector"
0036CBr 3  6B 2D 72 65  
0036CFr 3  61 64 2D 76  
0036D8r 3               
0036D8r 3               nt_block_read:
0036D8r 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
0036DAr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
0036DEr 3  rr rr        
0036E0r 3  62 6C 6F 63          .byte "block-read"
0036E4r 3  6B 2D 72 65  
0036E8r 3  61 64        
0036EAr 3               
0036EAr 3               nt_block_write_vector:
0036EAr 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
0036ECr 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
0036F0r 3  rr rr        
0036F2r 3  62 6C 6F 63          .byte "block-write-vector"
0036F6r 3  6B 2D 77 72  
0036FAr 3  69 74 65 2D  
003704r 3               
003704r 3               nt_block_write:
003704r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
003706r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
00370Ar 3  rr rr        
00370Cr 3  62 6C 6F 63          .byte "block-write"
003710r 3  6B 2D 77 72  
003714r 3  69 74 65     
003717r 3               
003717r 3               nt_blk:
003717r 3  03 00                .byte 3, 0
003719r 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
00371Dr 3  rr rr        
00371Fr 3  62 6C 6B             .byte "blk"
003722r 3               
003722r 3               nt_scr:
003722r 3  03 00                .byte 3, 0
003724r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
003728r 3  rr rr        
00372Ar 3  73 63 72             .byte "scr"
00372Dr 3               
00372Dr 3               nt_blkbuffer:
00372Dr 3  09 00                .byte 9, 0
00372Fr 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
003733r 3  rr rr        
003735r 3  62 6C 6B 62          .byte "blkbuffer"
003739r 3  75 66 66 65  
00373Dr 3  72           
00373Er 3               
00373Er 3               nt_buffblocknum:
00373Er 3  0C 00                .byte 12, 0
003740r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
003744r 3  rr rr        
003746r 3  62 75 66 66          .byte "buffblocknum"
00374Ar 3  62 6C 6F 63  
00374Er 3  6B 6E 75 6D  
003752r 3               
003752r 3               nt_buffstatus:
003752r 3  0A 00                .byte 10, 0
003754r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
003758r 3  rr rr        
00375Ar 3  62 75 66 66          .byte "buffstatus"
00375Er 3  73 74 61 74  
003762r 3  75 73        
003764r 3               
003764r 3               nt_buffer_colon:
003764r 3  07 00                .byte 7, 0
003766r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
00376Ar 3  rr rr        
00376Cr 3  62 75 66 66          .byte "buffer:"
003770r 3  65 72 3A     
003773r 3               
003773r 3               nt_useraddr:
003773r 3  08 00                .byte 8, 0
003775r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
003779r 3  rr rr        
00377Br 3  75 73 65 72          .byte "useraddr"
00377Fr 3  61 64 64 72  
003783r 3               
003783r 3               nt_action_of:
003783r 3  09 04                .byte 9, IM
003785r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
003789r 3  rr rr        
00378Br 3  61 63 74 69          .byte "action-of"
00378Fr 3  6F 6E 2D 6F  
003793r 3  66           
003794r 3               
003794r 3               nt_is:
003794r 3  02 04                .byte 2, IM
003796r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
00379Ar 3  rr rr        
00379Cr 3  69 73                .byte "is"
00379Er 3               
00379Er 3               nt_defer_store:
00379Er 3  06 00                .byte 6, 0
0037A0r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
0037A4r 3  rr rr        
0037A6r 3  64 65 66 65          .byte "defer!"
0037AAr 3  72 21        
0037ACr 3               
0037ACr 3               nt_defer_fetch:
0037ACr 3  06 00                .byte 6, 0
0037AEr 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
0037B2r 3  rr rr        
0037B4r 3  64 65 66 65          .byte "defer@"
0037B8r 3  72 40        
0037BAr 3               
0037BAr 3               nt_endcase:
0037BAr 3  07 0D                .byte 7, IM+CO+NN
0037BCr 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
0037C0r 3  rr rr        
0037C2r 3  65 6E 64 63          .byte "endcase"
0037C6r 3  61 73 65     
0037C9r 3               
0037C9r 3               nt_endof:
0037C9r 3  05 0D                .byte 5, IM+CO+NN
0037CBr 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
0037CFr 3  rr rr        
0037D1r 3  65 6E 64 6F          .byte "endof"
0037D5r 3  66           
0037D6r 3               
0037D6r 3               nt_of:
0037D6r 3  02 0D                .byte 2, IM+CO+NN
0037D8r 3  rr rr rr rr          .word nt_endof, xt_of, z_of
0037DCr 3  rr rr        
0037DEr 3  6F 66                .byte "of"
0037E0r 3               
0037E0r 3               nt_case:
0037E0r 3  04 0D                .byte 4, IM+CO+NN
0037E2r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
0037E6r 3  rr rr        
0037E8r 3  63 61 73 65          .byte "case"
0037ECr 3               
0037ECr 3               nt_while:
0037ECr 3  05 0D                .byte 5, IM+CO+NN
0037EEr 3  rr rr rr rr          .word nt_case, xt_while, z_while
0037F2r 3  rr rr        
0037F4r 3  77 68 69 6C          .byte "while"
0037F8r 3  65           
0037F9r 3               
0037F9r 3               nt_until:
0037F9r 3  05 0D                .byte 5, IM+CO+NN
0037FBr 3  rr rr rr rr          .word nt_while, xt_until, z_until
0037FFr 3  rr rr        
003801r 3  75 6E 74 69          .byte "until"
003805r 3  6C           
003806r 3               
003806r 3               nt_repeat:
003806r 3  06 0D                .byte 6, IM+CO+NN
003808r 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
00380Cr 3  rr rr        
00380Er 3  72 65 70 65          .byte "repeat"
003812r 3  61 74        
003814r 3               
003814r 3               nt_else:
003814r 3  04 0D                .byte 4, IM+CO+NN
003816r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
00381Ar 3  rr rr        
00381Cr 3  65 6C 73 65          .byte "else"
003820r 3               
003820r 3               nt_then:
003820r 3  04 0D                .byte 4, IM+CO+NN
003822r 3  rr rr rr rr          .word nt_else, xt_then, z_then
003826r 3  rr rr        
003828r 3  74 68 65 6E          .byte "then"
00382Cr 3               
00382Cr 3               nt_if:
00382Cr 3  02 0D                .byte 2, IM+CO+NN
00382Er 3  rr rr rr rr          .word nt_then, xt_if, z_if
003832r 3  rr rr        
003834r 3  69 66                .byte "if"
003836r 3               
003836r 3               nt_dot_paren:
003836r 3  02 04                .byte 2, IM
003838r 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
00383Cr 3  rr rr        
00383Er 3  2E 28                .byte ".("
003840r 3               
003840r 3               nt_paren:
003840r 3  01 04                .byte 1, IM
003842r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
003846r 3  rr rr        
003848r 3  28                   .byte "("
003849r 3               
003849r 3               nt_word:
003849r 3  04 10                .byte 4, UF
00384Br 3  rr rr rr rr          .word nt_paren, xt_word, z_word
00384Fr 3  rr rr        
003851r 3  77 6F 72 64          .byte "word"
003855r 3               
003855r 3               nt_find:
003855r 3  04 10                .byte 4, UF
003857r 3  rr rr rr rr          .word nt_word, xt_find, z_find
00385Br 3  rr rr        
00385Dr 3  66 69 6E 64          .byte "find"
003861r 3               
003861r 3               nt_environment_q:
003861r 3  0C 10                .byte 12, UF
003863r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
003867r 3  rr rr        
003869r 3  65 6E 76 69          .byte "environment?"
00386Dr 3  72 6F 6E 6D  
003871r 3  65 6E 74 3F  
003875r 3               
003875r 3               nt_search:
003875r 3  06 18                .byte 6, UF+NN
003877r 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
00387Br 3  rr rr        
00387Dr 3  73 65 61 72          .byte "search"
003881r 3  63 68        
003883r 3               
003883r 3               nt_compare:
003883r 3  07 10                .byte 7, UF
003885r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
003889r 3  rr rr        
00388Br 3  63 6F 6D 70          .byte "compare"
00388Fr 3  61 72 65     
003892r 3               
003892r 3               nt_disasm:
003892r 3  06 10                .byte 6, UF
003894r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
003898r 3  rr rr        
00389Ar 3  64 69 73 61          .byte "disasm"
00389Er 3  73 6D        
0038A0r 3               
0038A0r 3               nt_dot_s:
0038A0r 3  02 00                .byte 2, 0
0038A2r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
0038A6r 3  rr rr        
0038A8r 3  2E 73                .byte ".s"
0038AAr 3               
0038AAr 3               nt_dump:
0038AAr 3  04 10                .byte 4, UF
0038ACr 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
0038B0r 3  rr rr        
0038B2r 3  64 75 6D 70          .byte "dump"
0038B6r 3               
0038B6r 3               nt_bell:
0038B6r 3  04 00                .byte 4, 0
0038B8r 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
0038BCr 3  rr rr        
0038BEr 3  62 65 6C 6C          .byte "bell"
0038C2r 3               
0038C2r 3               nt_align:
0038C2r 3  05 00                .byte 5, 0
0038C4r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
0038C8r 3  rr rr        
0038CAr 3  61 6C 69 67          .byte "align"
0038CEr 3  6E           
0038CFr 3               
0038CFr 3               nt_aligned:             ; same code as ALIGN
0038CFr 3  07 00                .byte 7, 0
0038D1r 3  rr rr rr rr          .word nt_align, xt_align, z_align
0038D5r 3  rr rr        
0038D7r 3  61 6C 69 67          .byte "aligned"
0038DBr 3  6E 65 64     
0038DEr 3               
0038DEr 3               nt_wordsize:
0038DEr 3  08 10                .byte 8, UF
0038E0r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
0038E4r 3  rr rr        
0038E6r 3  77 6F 72 64          .byte "wordsize"
0038EAr 3  73 69 7A 65  
0038EEr 3               
0038EEr 3               nt_words:
0038EEr 3  05 00                .byte 5, 0
0038F0r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
0038F4r 3  rr rr        
0038F6r 3  77 6F 72 64          .byte "words"
0038FAr 3  73           
0038FBr 3               
0038FBr 3               nt_marker:
0038FBr 3  06 04                .byte 6, IM
0038FDr 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
003901r 3  rr rr        
003903r 3  6D 61 72 6B          .byte "marker"
003907r 3  65 72        
003909r 3               
003909r 3               nt_at_xy:
003909r 3  05 10                .byte 5, UF
00390Br 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
00390Fr 3  rr rr        
003911r 3  61 74 2D 78          .byte "at-xy"
003915r 3  79           
003916r 3               
003916r 3               nt_page:
003916r 3  04 00                .byte 4, 0
003918r 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
00391Cr 3  rr rr        
00391Er 3  70 61 67 65          .byte "page"
003922r 3               
003922r 3               nt_cr:
003922r 3  02 00                .byte 2, 0
003924r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
003928r 3  rr rr        
00392Ar 3  63 72                .byte "cr"
00392Cr 3               
00392Cr 3               nt_input:
00392Cr 3  05 00                .byte 5, 0
00392Er 3  rr rr rr rr          .word nt_cr, xt_input, z_input
003932r 3  rr rr        
003934r 3  69 6E 70 75          .byte "input"
003938r 3  74           
003939r 3               
003939r 3               nt_output:
003939r 3  06 00                .byte 6, 0
00393Br 3  rr rr rr rr          .word nt_input, xt_output, z_output
00393Fr 3  rr rr        
003941r 3  6F 75 74 70          .byte "output"
003945r 3  75 74        
003947r 3               
003947r 3               nt_sign:
003947r 3  04 10                .byte 4, UF
003949r 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
00394Dr 3  rr rr        
00394Fr 3  73 69 67 6E          .byte "sign"
003953r 3               
003953r 3               nt_hold:
003953r 3  04 10                .byte 4, UF
003955r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
003959r 3  rr rr        
00395Br 3  68 6F 6C 64          .byte "hold"
00395Fr 3               
00395Fr 3               nt_number_sign_greater:
00395Fr 3  02 10                .byte 2, UF
003961r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
003965r 3  rr rr        
003967r 3  23 3E                .byte "#>"
003969r 3               
003969r 3               nt_number_sign_s:
003969r 3  02 10                .byte 2, UF
00396Br 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
00396Fr 3  rr rr        
003971r 3  23 73                .byte "#s"
003973r 3               
003973r 3               nt_number_sign:
003973r 3  01 10                .byte 1, UF
003975r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
003979r 3  rr rr        
00397Br 3  23                   .byte "#"
00397Cr 3               
00397Cr 3               nt_less_number_sign:
00397Cr 3  02 00                .byte 2, 0
00397Er 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
003982r 3  rr rr        
003984r 3  3C 23                .byte "<#"
003986r 3               
003986r 3               nt_to_in:
003986r 3  03 00                .byte 3, 0
003988r 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
00398Cr 3  rr rr        
00398Er 3  3E 69 6E             .byte ">in"
003991r 3               
003991r 3               nt_within:
003991r 3  06 10                .byte 6, UF
003993r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
003997r 3  rr rr        
003999r 3  77 69 74 68          .byte "within"
00399Dr 3  69 6E        
00399Fr 3               
00399Fr 3               nt_hexstore:
00399Fr 3  08 10                .byte 8, UF
0039A1r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
0039A5r 3  rr rr        
0039A7r 3  68 65 78 73          .byte "hexstore"
0039ABr 3  74 6F 72 65  
0039AFr 3               
0039AFr 3               nt_cleave:
0039AFr 3  06 10                .byte 6, UF
0039B1r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
0039B5r 3  rr rr        
0039B7r 3  63 6C 65 61          .byte "cleave"
0039BBr 3  76 65        
0039BDr 3               
0039BDr 3               nt_pad:
0039BDr 3  03 00                .byte 3, 0
0039BFr 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
0039C3r 3  rr rr        
0039C5r 3  70 61 64             .byte "pad"
0039C8r 3               
0039C8r 3               nt_cmove:
0039C8r 3  05 10                .byte 5, UF
0039CAr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
0039CEr 3  rr rr        
0039D0r 3  63 6D 6F 76          .byte "cmove"
0039D4r 3  65           
0039D5r 3               
0039D5r 3               nt_cmove_up:
0039D5r 3  06 10                .byte 6, UF
0039D7r 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
0039DBr 3  rr rr        
0039DDr 3  63 6D 6F 76          .byte "cmove>"
0039E1r 3  65 3E        
0039E3r 3               
0039E3r 3               nt_move:
0039E3r 3  04 18                .byte 4, NN+UF
0039E5r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
0039E9r 3  rr rr        
0039EBr 3  6D 6F 76 65          .byte "move"
0039EFr 3               
0039EFr 3               nt_backslash:
0039EFr 3  01 04                .byte 1, IM
0039F1r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
0039F5r 3  rr rr        
0039F7r 3  5C                   .byte $5c
0039F8r 3               
0039F8r 3               nt_star_slash:
0039F8r 3  02 10                .byte 2, UF
0039FAr 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
0039FEr 3  rr rr        
003A00r 3  2A 2F                .byte "*/"
003A02r 3               
003A02r 3               nt_star_slash_mod:
003A02r 3  05 10                .byte 5, UF
003A04r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
003A08r 3  rr rr        
003A0Ar 3  2A 2F 6D 6F          .byte "*/mod"
003A0Er 3  64           
003A0Fr 3               
003A0Fr 3               nt_mod:
003A0Fr 3  03 10                .byte 3, UF
003A11r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
003A15r 3  rr rr        
003A17r 3  6D 6F 64             .byte "mod"
003A1Ar 3               
003A1Ar 3               nt_slash_mod:
003A1Ar 3  04 10                .byte 4, UF
003A1Cr 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
003A20r 3  rr rr        
003A22r 3  2F 6D 6F 64          .byte "/mod"
003A26r 3               
003A26r 3               nt_slash:
003A26r 3  01 10                .byte 1, UF
003A28r 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
003A2Cr 3  rr rr        
003A2Er 3  2F                   .byte "/"
003A2Fr 3               
003A2Fr 3               nt_fm_slash_mod:
003A2Fr 3  06 10                .byte 6, UF
003A31r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
003A35r 3  rr rr        
003A37r 3  66 6D 2F 6D          .byte "fm/mod"
003A3Br 3  6F 64        
003A3Dr 3               
003A3Dr 3               nt_sm_slash_rem:
003A3Dr 3  06 10                .byte 6, UF
003A3Fr 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
003A43r 3  rr rr        
003A45r 3  73 6D 2F 72          .byte "sm/rem"
003A49r 3  65 6D        
003A4Br 3               
003A4Br 3               nt_um_slash_mod:
003A4Br 3  06 10                .byte 6, UF
003A4Dr 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
003A51r 3  rr rr        
003A53r 3  75 6D 2F 6D          .byte "um/mod"
003A57r 3  6F 64        
003A59r 3               
003A59r 3               nt_star:
003A59r 3  01 10                .byte 1, UF
003A5Br 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
003A5Fr 3  rr rr        
003A61r 3  2A                   .byte "*"
003A62r 3               
003A62r 3               nt_um_star:
003A62r 3  03 10                .byte 3, UF
003A64r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
003A68r 3  rr rr        
003A6Ar 3  75 6D 2A             .byte "um*"
003A6Dr 3               
003A6Dr 3               nt_m_star:
003A6Dr 3  02 10                .byte 2, UF
003A6Fr 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
003A73r 3  rr rr        
003A75r 3  6D 2A                .byte "m*"
003A77r 3               
003A77r 3               nt_count:
003A77r 3  05 10                .byte 5, UF
003A79r 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
003A7Dr 3  rr rr        
003A7Fr 3  63 6F 75 6E          .byte "count"
003A83r 3  74           
003A84r 3               
003A84r 3               nt_decimal:
003A84r 3  07 00                .byte 7, 0
003A86r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
003A8Ar 3  rr rr        
003A8Cr 3  64 65 63 69          .byte "decimal"
003A90r 3  6D 61 6C     
003A93r 3               
003A93r 3               nt_hex:
003A93r 3  03 00                .byte 3, 0
003A95r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
003A99r 3  rr rr        
003A9Br 3  68 65 78             .byte "hex"
003A9Er 3               
003A9Er 3               nt_to_number:
003A9Er 3  07 10                .byte 7, UF
003AA0r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
003AA4r 3  rr rr        
003AA6r 3  3E 6E 75 6D          .byte ">number"
003AAAr 3  62 65 72     
003AADr 3               
003AADr 3               nt_number:
003AADr 3  06 10                .byte 6, UF
003AAFr 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
003AB3r 3  rr rr        
003AB5r 3  6E 75 6D 62          .byte "number"
003AB9r 3  65 72        
003ABBr 3               
003ABBr 3               nt_digit_question:
003ABBr 3  06 10                .byte 6, UF
003ABDr 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
003AC1r 3  rr rr        
003AC3r 3  64 69 67 69          .byte "digit?"
003AC7r 3  74 3F        
003AC9r 3               
003AC9r 3               nt_base:
003AC9r 3  04 00                .byte 4, 0
003ACBr 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
003ACFr 3  rr rr        
003AD1r 3  62 61 73 65          .byte "base"
003AD5r 3               
003AD5r 3               nt_evaluate:
003AD5r 3  08 10                .byte 8, UF
003AD7r 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
003ADBr 3  rr rr        
003ADDr 3  65 76 61 6C          .byte "evaluate"
003AE1r 3  75 61 74 65  
003AE5r 3               
003AE5r 3               nt_state:
003AE5r 3  05 00                .byte 5, 0
003AE7r 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
003AEBr 3  rr rr        
003AEDr 3  73 74 61 74          .byte "state"
003AF1r 3  65           
003AF2r 3               
003AF2r 3               nt_again:
003AF2r 3  05 17                .byte 5, AN+CO+IM+UF
003AF4r 3  rr rr rr rr          .word nt_state, xt_again, z_again
003AF8r 3  rr rr        
003AFAr 3  61 67 61 69          .byte "again"
003AFEr 3  6E           
003AFFr 3               
003AFFr 3               nt_begin:
003AFFr 3  05 07                .byte 5, AN+CO+IM
003B01r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
003B05r 3  rr rr        
003B07r 3  62 65 67 69          .byte "begin"
003B0Br 3  6E           
003B0Cr 3               
003B0Cr 3               nt_quit:
003B0Cr 3  04 00                .byte 4, 0
003B0Er 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
003B12r 3  rr rr        
003B14r 3  71 75 69 74          .byte "quit"
003B18r 3               
003B18r 3               nt_recurse:
003B18r 3  07 0D                .byte 7, CO+IM+NN
003B1Ar 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
003B1Er 3  rr rr        
003B20r 3  72 65 63 75          .byte "recurse"
003B24r 3  72 73 65     
003B27r 3               
003B27r 3               nt_leave:
003B27r 3  05 03                .byte 5, AN+CO
003B29r 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
003B2Dr 3  rr rr        
003B2Fr 3  6C 65 61 76          .byte "leave"
003B33r 3  65           
003B34r 3               
003B34r 3               nt_unloop:
003B34r 3  06 03                .byte 6, AN+CO
003B36r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
003B3Ar 3  rr rr        
003B3Cr 3  75 6E 6C 6F          .byte "unloop"
003B40r 3  6F 70        
003B42r 3               
003B42r 3               nt_exit:
003B42r 3  04 03                .byte 4, AN+CO
003B44r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
003B48r 3  rr rr        
003B4Ar 3  65 78 69 74          .byte "exit"
003B4Er 3               
003B4Er 3               nt_plus_loop:
003B4Er 3  05 05                .byte 5, CO+IM
003B50r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
003B54r 3  rr rr        
003B56r 3  2B 6C 6F 6F          .byte "+loop"
003B5Ar 3  70           
003B5Br 3               
003B5Br 3               nt_loop:
003B5Br 3  04 05                .byte 4, CO+IM
003B5Dr 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
003B61r 3  rr rr        
003B63r 3  6C 6F 6F 70          .byte "loop"
003B67r 3               
003B67r 3               nt_j:
003B67r 3  01 03                .byte 1, AN+CO
003B69r 3  rr rr rr rr          .word nt_loop, xt_j, z_j
003B6Dr 3  rr rr        
003B6Fr 3  6A                   .byte "j"
003B70r 3               
003B70r 3               nt_i:
003B70r 3  01 03                .byte 1, AN+CO
003B72r 3  rr rr rr rr          .word nt_j, xt_i, z_i
003B76r 3  rr rr        
003B78r 3  69                   .byte "i"
003B79r 3               
003B79r 3               nt_question_do:
003B79r 3  03 0D                .byte 3, CO+IM+NN
003B7Br 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
003B7Fr 3  rr rr        
003B81r 3  3F 64 6F             .byte "?do"
003B84r 3               
003B84r 3               nt_do:
003B84r 3  02 0D                .byte 2, CO+IM+NN
003B86r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
003B8Ar 3  rr rr        
003B8Cr 3  64 6F                .byte "do"
003B8Er 3               
003B8Er 3               nt_abort_quote:
003B8Er 3  06 0D                .byte 6, CO+IM+NN
003B90r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
003B94r 3  rr rr        
003B96r 3  61 62 6F 72          .byte "abort", $22
003B9Ar 3  74 22        
003B9Cr 3               
003B9Cr 3               nt_abort:
003B9Cr 3  05 00                .byte 5, 0
003B9Er 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
003BA2r 3  rr rr        
003BA4r 3  61 62 6F 72          .byte "abort"
003BA8r 3  74           
003BA9r 3               
003BA9r 3               nt_strip_underflow:
003BA9r 3  0F 00                .byte 15, 0
003BABr 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
003BAFr 3  rr rr        
003BB1r 3  73 74 72 69          .byte "strip-underflow"
003BB5r 3  70 2D 75 6E  
003BB9r 3  64 65 72 66  
003BC0r 3               
003BC0r 3               nt_nc_limit:
003BC0r 3  08 00                .byte 8, 0
003BC2r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
003BC6r 3  rr rr        
003BC8r 3  6E 63 2D 6C          .byte "nc-limit"
003BCCr 3  69 6D 69 74  
003BD0r 3               
003BD0r 3               nt_allow_native:
003BD0r 3  0C 00                .byte 12, 0
003BD2r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
003BD6r 3  rr rr        
003BD8r 3  61 6C 6C 6F          .byte "allow-native"
003BDCr 3  77 2D 6E 61  
003BE0r 3  74 69 76 65  
003BE4r 3               
003BE4r 3               nt_always_native:
003BE4r 3  0D 00                .byte 13, 0
003BE6r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
003BEAr 3  rr rr        
003BECr 3  61 6C 77 61          .byte "always-native"
003BF0r 3  79 73 2D 6E  
003BF4r 3  61 74 69 76  
003BF9r 3               
003BF9r 3               nt_never_native:
003BF9r 3  0C 00                .byte 12, 0
003BFBr 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
003BFFr 3  rr rr        
003C01r 3  6E 65 76 65          .byte "never-native"
003C05r 3  72 2D 6E 61  
003C09r 3  74 69 76 65  
003C0Dr 3               
003C0Dr 3               nt_compile_only:
003C0Dr 3  0C 00                .byte 12, 0
003C0Fr 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003C13r 3  rr rr        
003C15r 3  63 6F 6D 70          .byte "compile-only"
003C19r 3  69 6C 65 2D  
003C1Dr 3  6F 6E 6C 79  
003C21r 3               
003C21r 3               nt_immediate:
003C21r 3  09 00                .byte 9, 0
003C23r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
003C27r 3  rr rr        
003C29r 3  69 6D 6D 65          .byte "immediate"
003C2Dr 3  64 69 61 74  
003C31r 3  65           
003C32r 3               
003C32r 3               nt_postpone:
003C32r 3  08 05                .byte 8, IM+CO
003C34r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
003C38r 3  rr rr        
003C3Ar 3  70 6F 73 74          .byte "postpone"
003C3Er 3  70 6F 6E 65  
003C42r 3               
003C42r 3               nt_s_backslash_quote:
003C42r 3  03 04                .byte 3, IM
003C44r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
003C48r 3  rr rr        
003C4Ar 3  73 5C 22             .byte "s", $5C, $22
003C4Dr 3               
003C4Dr 3               nt_s_quote:
003C4Dr 3  02 0C                .byte 2, IM+NN
003C4Fr 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
003C53r 3  rr rr        
003C55r 3  73 22                .byte "s", $22
003C57r 3               
003C57r 3               nt_dot_quote:
003C57r 3  02 05                .byte 2, CO+IM
003C59r 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
003C5Dr 3  rr rr        
003C5Fr 3  2E 22                .byte ".", $22
003C61r 3               
003C61r 3               nt_sliteral:
003C61r 3  08 15                .byte 8, CO+IM+UF
003C63r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
003C67r 3  rr rr        
003C69r 3  73 6C 69 74          .byte "sliteral"
003C6Dr 3  65 72 61 6C  
003C71r 3               
003C71r 3               nt_literal:
003C71r 3  07 15                .byte 7, IM+CO+UF
003C73r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
003C77r 3  rr rr        
003C79r 3  6C 69 74 65          .byte "literal"
003C7Dr 3  72 61 6C     
003C80r 3               
003C80r 3               nt_right_bracket:
003C80r 3  01 04                .byte 1, IM
003C82r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
003C86r 3  rr rr        
003C88r 3  5D                   .byte "]"
003C89r 3               
003C89r 3               nt_left_bracket:
003C89r 3  01 05                .byte 1, IM+CO
003C8Br 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
003C8Fr 3  rr rr        
003C91r 3  5B                   .byte "["
003C92r 3               
003C92r 3               nt_compile_comma:
003C92r 3  08 18                .byte 8, UF+NN
003C94r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
003C98r 3  rr rr        
003C9Ar 3  63 6F 6D 70          .byte "compile,"
003C9Er 3  69 6C 65 2C  
003CA2r 3               
003CA2r 3               nt_colon_noname:
003CA2r 3  07 00                .byte 7, 0
003CA4r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
003CA8r 3  rr rr        
003CAAr 3  3A 6E 6F 6E          .byte ":noname"
003CAEr 3  61 6D 65     
003CB1r 3               
003CB1r 3               nt_semicolon:
003CB1r 3  01 05                .byte 1, CO+IM
003CB3r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
003CB7r 3  rr rr        
003CB9r 3  3B                   .byte ";"
003CBAr 3               
003CBAr 3               nt_colon:
003CBAr 3  01 00                .byte 1, 0
003CBCr 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
003CC0r 3  rr rr        
003CC2r 3  3A                   .byte ":"
003CC3r 3               
003CC3r 3               nt_source_id:
003CC3r 3  09 00                .byte 9, 0
003CC5r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
003CC9r 3  rr rr        
003CCBr 3  73 6F 75 72          .byte "source-id"
003CCFr 3  63 65 2D 69  
003CD3r 3  64           
003CD4r 3               
003CD4r 3               nt_source:
003CD4r 3  06 00                .byte 6, 0
003CD6r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
003CDAr 3  rr rr        
003CDCr 3  73 6F 75 72          .byte "source"
003CE0r 3  63 65        
003CE2r 3               
003CE2r 3               nt_execute_parsing:
003CE2r 3  0F 10                .byte 15, UF
003CE4r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
003CE8r 3  rr rr        
003CEAr 3  65 78 65 63          .byte "execute-parsing"
003CEEr 3  75 74 65 2D  
003CF2r 3  70 61 72 73  
003CF9r 3               
003CF9r 3               nt_parse:
003CF9r 3  05 10                .byte 5, UF
003CFBr 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
003CFFr 3  rr rr        
003D01r 3  70 61 72 73          .byte "parse"
003D05r 3  65           
003D06r 3               
003D06r 3               nt_parse_name:
003D06r 3  0A 08                .byte 10, NN
003D08r 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
003D0Cr 3  rr rr        
003D0Er 3  70 61 72 73          .byte "parse-name"
003D12r 3  65 2D 6E 61  
003D16r 3  6D 65        
003D18r 3               
003D18r 3               nt_latestnt:
003D18r 3  08 00                .byte 8, 0
003D1Ar 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
003D1Er 3  rr rr        
003D20r 3  6C 61 74 65          .byte "latestnt"
003D24r 3  73 74 6E 74  
003D28r 3               
003D28r 3               nt_latestxt:
003D28r 3  08 00                .byte 8, 0
003D2Ar 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
003D2Er 3  rr rr        
003D30r 3  6C 61 74 65          .byte "latestxt"
003D34r 3  73 74 78 74  
003D38r 3               
003D38r 3               nt_defer:
003D38r 3  05 00                .byte 5, 0
003D3Ar 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
003D3Er 3  rr rr        
003D40r 3  64 65 66 65          .byte "defer"
003D44r 3  72           
003D45r 3               
003D45r 3               nt_to_body:
003D45r 3  05 10                .byte 5, UF
003D47r 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
003D4Br 3  rr rr        
003D4Dr 3  3E 62 6F 64          .byte ">body"
003D51r 3  79           
003D52r 3               
003D52r 3               nt_name_to_string:
003D52r 3  0B 10                .byte 11, UF
003D54r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
003D58r 3  rr rr        
003D5Ar 3  6E 61 6D 65          .byte "name>string"
003D5Er 3  3E 73 74 72  
003D62r 3  69 6E 67     
003D65r 3               
003D65r 3               nt_int_to_name:
003D65r 3  08 10                .byte 8, UF
003D67r 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
003D6Br 3  rr rr        
003D6Dr 3  69 6E 74 3E          .byte "int>name"
003D71r 3  6E 61 6D 65  
003D75r 3               
003D75r 3               nt_name_to_int:
003D75r 3  08 10                .byte 8, UF
003D77r 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
003D7Br 3  rr rr        
003D7Dr 3  6E 61 6D 65          .byte "name>int"
003D81r 3  3E 69 6E 74  
003D85r 3               
003D85r 3               nt_bracket_tick:
003D85r 3  03 05                .byte 3, CO+IM
003D87r 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
003D8Br 3  rr rr        
003D8Dr 3  5B 27 5D             .byte "[']"
003D90r 3               
003D90r 3               nt_tick:
003D90r 3  01 00                .byte 1, 0
003D92r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
003D96r 3  rr rr        
003D98r 3  27                   .byte "'"
003D99r 3               
003D99r 3               nt_find_name:
003D99r 3  09 10                .byte 9, UF
003D9Br 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
003D9Fr 3  rr rr        
003DA1r 3  66 69 6E 64          .byte "find-name"
003DA5r 3  2D 6E 61 6D  
003DA9r 3  65           
003DAAr 3               
003DAAr 3               nt_fill:
003DAAr 3  04 10                .byte 4, UF
003DACr 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
003DB0r 3  rr rr        
003DB2r 3  66 69 6C 6C          .byte "fill"
003DB6r 3               
003DB6r 3               nt_blank:
003DB6r 3  05 00                .byte 5, 0     ; underflow checked by FILL
003DB8r 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
003DBCr 3  rr rr        
003DBEr 3  62 6C 61 6E          .byte "blank"
003DC2r 3  6B           
003DC3r 3               
003DC3r 3               nt_erase:
003DC3r 3  05 00                .byte 5, 0      ; underflow checked by FILL
003DC5r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
003DC9r 3  rr rr        
003DCBr 3  65 72 61 73          .byte "erase"
003DCFr 3  65           
003DD0r 3               
003DD0r 3               nt_d_plus:
003DD0r 3  02 10                .byte 2, UF
003DD2r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
003DD6r 3  rr rr        
003DD8r 3  64 2B                .byte "d+"
003DDAr 3               
003DDAr 3               nt_d_minus:
003DDAr 3  02 10                .byte 2, UF
003DDCr 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
003DE0r 3  rr rr        
003DE2r 3  64 2D                .byte "d-"
003DE4r 3               
003DE4r 3               nt_d_to_s:
003DE4r 3  03 10                .byte 3, UF
003DE6r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
003DEAr 3  rr rr        
003DECr 3  64 3E 73             .byte "d>s"
003DEFr 3               
003DEFr 3               nt_s_to_d:
003DEFr 3  03 10                .byte 3, UF
003DF1r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
003DF5r 3  rr rr        
003DF7r 3  73 3E 64             .byte "s>d"
003DFAr 3               
003DFAr 3               nt_to:
003DFAr 3  02 0C                .byte 2, NN+IM
003DFCr 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
003E00r 3  rr rr        
003E02r 3  74 6F                .byte "to"
003E04r 3               
003E04r 3               nt_value:               ; same code as CONSTANT
003E04r 3  05 10                .byte 5, UF
003E06r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
003E0Ar 3  rr rr        
003E0Cr 3  76 61 6C 75          .byte "value"
003E10r 3  65           
003E11r 3               
003E11r 3               nt_constant:
003E11r 3  08 10                .byte 8, UF
003E13r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
003E17r 3  rr rr        
003E19r 3  63 6F 6E 73          .byte "constant"
003E1Dr 3  74 61 6E 74  
003E21r 3               
003E21r 3               nt_variable:
003E21r 3  08 00                .byte 8, 0
003E23r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
003E27r 3  rr rr        
003E29r 3  76 61 72 69          .byte "variable"
003E2Dr 3  61 62 6C 65  
003E31r 3               
003E31r 3               nt_does:
003E31r 3  05 05                .byte 5, CO+IM
003E33r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
003E37r 3  rr rr        
003E39r 3  64 6F 65 73          .byte "does>"
003E3Dr 3  3E           
003E3Er 3               
003E3Er 3               nt_create:
003E3Er 3  06 00                .byte 6, 0
003E40r 3  rr rr rr rr          .word nt_does, xt_create, z_create
003E44r 3  rr rr        
003E46r 3  63 72 65 61          .byte "create"
003E4Ar 3  74 65        
003E4Cr 3               
003E4Cr 3               nt_allot:
003E4Cr 3  05 10                .byte 5, UF
003E4Er 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
003E52r 3  rr rr        
003E54r 3  61 6C 6C 6F          .byte "allot"
003E58r 3  74           
003E59r 3               
003E59r 3               nt_key:
003E59r 3  03 00                .byte 3, 0
003E5Br 3  rr rr rr rr          .word nt_allot, xt_key, z_key
003E5Fr 3  rr rr        
003E61r 3  6B 65 79             .byte "key"
003E64r 3               
003E64r 3               nt_depth:
003E64r 3  05 00                .byte 5, 0
003E66r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
003E6Ar 3  rr rr        
003E6Cr 3  64 65 70 74          .byte "depth"
003E70r 3  68           
003E71r 3               
003E71r 3               nt_unused:
003E71r 3  06 00                .byte 6, 0
003E73r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
003E77r 3  rr rr        
003E79r 3  75 6E 75 73          .byte "unused"
003E7Dr 3  65 64        
003E7Fr 3               
003E7Fr 3               nt_r_to_input:
003E7Fr 3  07 08                .byte 7, NN
003E81r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
003E85r 3  rr rr        
003E87r 3  72 3E 69 6E          .byte "r>input"
003E8Br 3  70 75 74     
003E8Er 3               
003E8Er 3               nt_input_to_r:
003E8Er 3  07 08                .byte 7, NN
003E90r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
003E94r 3  rr rr        
003E96r 3  69 6E 70 75          .byte "input>r"
003E9Ar 3  74 3E 72     
003E9Dr 3               
003E9Dr 3               nt_accept:
003E9Dr 3  06 18                .byte 6, UF+NN
003E9Fr 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
003EA3r 3  rr rr        
003EA5r 3  61 63 63 65          .byte "accept"
003EA9r 3  70 74        
003EABr 3               
003EABr 3               nt_refill:
003EABr 3  06 00                .byte 6, 0
003EADr 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
003EB1r 3  rr rr        
003EB3r 3  72 65 66 69          .byte "refill"
003EB7r 3  6C 6C        
003EB9r 3               
003EB9r 3               nt_slash_string:
003EB9r 3  07 10                .byte 7, UF
003EBBr 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
003EBFr 3  rr rr        
003EC1r 3  2F 73 74 72          .byte "/string"
003EC5r 3  69 6E 67     
003EC8r 3               
003EC8r 3               nt_minus_leading:
003EC8r 3  08 10                .byte 8, UF
003ECAr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
003ECEr 3  rr rr        
003ED0r 3  2D 6C 65 61          .byte "-leading"
003ED4r 3  64 69 6E 67  
003ED8r 3               
003ED8r 3               nt_minus_trailing:
003ED8r 3  09 10                .byte 9, UF
003EDAr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
003EDEr 3  rr rr        
003EE0r 3  2D 74 72 61          .byte "-trailing"
003EE4r 3  69 6C 69 6E  
003EE8r 3  67           
003EE9r 3               
003EE9r 3               nt_bl:
003EE9r 3  02 00                .byte 2, 0
003EEBr 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
003EEFr 3  rr rr        
003EF1r 3  62 6C                .byte "bl"
003EF3r 3               
003EF3r 3               nt_spaces:
003EF3r 3  06 10                .byte 6, UF
003EF5r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
003EF9r 3  rr rr        
003EFBr 3  73 70 61 63          .byte "spaces"
003EFFr 3  65 73        
003F01r 3               
003F01r 3               nt_bounds:
003F01r 3  06 10                .byte 6, UF
003F03r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
003F07r 3  rr rr        
003F09r 3  62 6F 75 6E          .byte "bounds"
003F0Dr 3  64 73        
003F0Fr 3               
003F0Fr 3               nt_c_comma:
003F0Fr 3  02 10                .byte 2, UF
003F11r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
003F15r 3  rr rr        
003F17r 3  63 2C                .byte "c,"
003F19r 3               
003F19r 3               nt_dnegate:
003F19r 3  07 10                .byte 7, UF
003F1Br 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
003F1Fr 3  rr rr        
003F21r 3  64 6E 65 67          .byte "dnegate"
003F25r 3  61 74 65     
003F28r 3               
003F28r 3               nt_negate:
003F28r 3  06 10                .byte 6, UF
003F2Ar 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
003F2Er 3  rr rr        
003F30r 3  6E 65 67 61          .byte "negate"
003F34r 3  74 65        
003F36r 3               
003F36r 3               nt_invert:
003F36r 3  06 10                .byte 6, UF
003F38r 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
003F3Cr 3  rr rr        
003F3Er 3  69 6E 76 65          .byte "invert"
003F42r 3  72 74        
003F44r 3               
003F44r 3               nt_two_to_r:
003F44r 3  03 11                .byte 3, CO+UF          ; native is special case
003F46r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
003F4Ar 3  rr rr        
003F4Cr 3  32 3E 72             .byte "2>r"
003F4Fr 3               
003F4Fr 3               nt_two_r_from:
003F4Fr 3  03 01                .byte 3, CO             ; native is special case
003F51r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
003F55r 3  rr rr        
003F57r 3  32 72 3E             .byte "2r>"
003F5Ar 3               
003F5Ar 3               nt_two_r_fetch:
003F5Ar 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
003F5Cr 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
003F60r 3  rr rr        
003F62r 3  32 72 40             .byte "2r@"
003F65r 3               
003F65r 3               nt_two_literal:
003F65r 3  08 14                .byte 8, UF+IM
003F67r 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
003F6Br 3  rr rr        
003F6Dr 3  32 6C 69 74          .byte "2literal"
003F71r 3  65 72 61 6C  
003F75r 3               
003F75r 3               nt_two_constant:
003F75r 3  09 10                .byte 9, UF
003F77r 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
003F7Br 3  rr rr        
003F7Dr 3  32 63 6F 6E          .byte "2constant"
003F81r 3  73 74 61 6E  
003F85r 3  74           
003F86r 3               
003F86r 3               nt_two_variable:
003F86r 3  09 00                .byte 9, 0
003F88r 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
003F8Cr 3  rr rr        
003F8Er 3  32 76 61 72          .byte "2variable"
003F92r 3  69 61 62 6C  
003F96r 3  65           
003F97r 3               
003F97r 3               nt_two_fetch:
003F97r 3  02 10                .byte 2, UF
003F99r 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
003F9Dr 3  rr rr        
003F9Fr 3  32 40                .byte "2@"
003FA1r 3               
003FA1r 3               nt_two_store:
003FA1r 3  02 10                .byte 2, UF
003FA3r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
003FA7r 3  rr rr        
003FA9r 3  32 21                .byte "2!"
003FABr 3               
003FABr 3               nt_two_over:
003FABr 3  05 10                .byte 5, UF
003FADr 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
003FB1r 3  rr rr        
003FB3r 3  32 6F 76 65          .byte "2over"
003FB7r 3  72           
003FB8r 3               
003FB8r 3               nt_two_swap:
003FB8r 3  05 10                .byte 5, UF
003FBAr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
003FBEr 3  rr rr        
003FC0r 3  32 73 77 61          .byte "2swap"
003FC4r 3  70           
003FC5r 3               
003FC5r 3               nt_two_drop:
003FC5r 3  05 10                .byte 5, UF
003FC7r 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
003FCBr 3  rr rr        
003FCDr 3  32 64 72 6F          .byte "2drop"
003FD1r 3  70           
003FD2r 3               
003FD2r 3               nt_max:
003FD2r 3  03 10                .byte 3, UF
003FD4r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
003FD8r 3  rr rr        
003FDAr 3  6D 61 78             .byte "max"
003FDDr 3               
003FDDr 3               nt_min:
003FDDr 3  03 10                .byte 3, UF
003FDFr 3  rr rr rr rr          .word nt_max, xt_min, z_min
003FE3r 3  rr rr        
003FE5r 3  6D 69 6E             .byte "min"
003FE8r 3               
003FE8r 3               nt_zero_less:
003FE8r 3  02 10                .byte 2, UF
003FEAr 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
003FEEr 3  rr rr        
003FF0r 3  30 3C                .byte "0<"
003FF2r 3               
003FF2r 3               nt_zero_greater:
003FF2r 3  02 10                .byte 2, UF
003FF4r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
003FF8r 3  rr rr        
003FFAr 3  30 3E                .byte "0>"
003FFCr 3               
003FFCr 3               nt_zero_unequal:
003FFCr 3  03 10                .byte 3, UF
003FFEr 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
004002r 3  rr rr        
004004r 3  30 3C 3E             .byte "0<>"
004007r 3               
004007r 3               nt_zero_equal:
004007r 3  02 10                .byte 2, UF
004009r 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
00400Dr 3  rr rr        
00400Fr 3  30 3D                .byte "0="
004011r 3               
004011r 3               nt_greater_than:
004011r 3  01 10                .byte 1, UF
004013r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
004017r 3  rr rr        
004019r 3  3E                   .byte ">"
00401Ar 3               
00401Ar 3               nt_u_greater_than:
00401Ar 3  02 10                .byte 2, UF
00401Cr 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
004020r 3  rr rr        
004022r 3  75 3E                .byte "u>"
004024r 3               
004024r 3               nt_u_less_than:
004024r 3  02 10                .byte 2, UF
004026r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
00402Ar 3  rr rr        
00402Cr 3  75 3C                .byte "u<"
00402Er 3               
00402Er 3               nt_less_than:
00402Er 3  01 10                .byte 1, UF
004030r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
004034r 3  rr rr        
004036r 3  3C                   .byte "<"
004037r 3               
004037r 3               nt_not_equals:
004037r 3  02 10                .byte 2, UF
004039r 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
00403Dr 3  rr rr        
00403Fr 3  3C 3E                .byte "<>"
004041r 3               
004041r 3               nt_equal:
004041r 3  01 10                .byte 1, UF
004043r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
004047r 3  rr rr        
004049r 3  3D                   .byte "="
00404Ar 3               
00404Ar 3               nt_two_slash:
00404Ar 3  02 10                .byte 2, UF
00404Cr 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
004050r 3  rr rr        
004052r 3  32 2F                .byte "2/"
004054r 3               
004054r 3               nt_two_star:
004054r 3  02 10                .byte 2, UF
004056r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
00405Ar 3  rr rr        
00405Cr 3  32 2A                .byte "2*"
00405Er 3               
00405Er 3               nt_one_plus:
00405Er 3  02 10                .byte 2, UF
004060r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
004064r 3  rr rr        
004066r 3  31 2B                .byte "1+"
004068r 3               
004068r 3               nt_one_minus:
004068r 3  02 10                .byte 2, UF
00406Ar 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
00406Er 3  rr rr        
004070r 3  31 2D                .byte "1-"
004072r 3               
004072r 3               nt_here:
004072r 3  04 00                .byte 4, 0
004074r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
004078r 3  rr rr        
00407Ar 3  68 65 72 65          .byte "here"
00407Er 3               
00407Er 3               nt_cell_plus:
00407Er 3  05 10                .byte 5, UF
004080r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
004084r 3  rr rr        
004086r 3  63 65 6C 6C          .byte "cell+"
00408Ar 3  2B           
00408Br 3               
00408Br 3               nt_cells:
00408Br 3  05 00                .byte 5, 0
00408Dr 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
004091r 3  rr rr        
004093r 3  63 65 6C 6C          .byte "cells"
004097r 3  73           
004098r 3               
004098r 3               nt_chars:
004098r 3  05 12                .byte 5, AN+UF   ; deleted during compile
00409Ar 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
00409Er 3  rr rr        
0040A0r 3  63 68 61 72          .byte "chars"
0040A4r 3  73           
0040A5r 3               
0040A5r 3               nt_char_plus:
0040A5r 3  05 00                .byte 5, 0
0040A7r 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
0040ABr 3  rr rr        
0040ADr 3  63 68 61 72          .byte "char+"
0040B1r 3  2B           
0040B2r 3               
0040B2r 3               nt_bracket_char:
0040B2r 3  06 05                .byte 6, CO+IM
0040B4r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
0040B8r 3  rr rr        
0040BAr 3  5B 63 68 61          .byte "[char]"
0040BEr 3  72 5D        
0040C0r 3               
0040C0r 3               nt_char:
0040C0r 3  04 00                .byte 4, 0
0040C2r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
0040C6r 3  rr rr        
0040C8r 3  63 68 61 72          .byte "char"
0040CCr 3               
0040CCr 3               nt_pick:
0040CCr 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
0040CEr 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
0040D2r 3  rr rr        
0040D4r 3  70 69 63 6B          .byte "pick"
0040D8r 3               
0040D8r 3               nt_lshift:
0040D8r 3  06 10                .byte 6, UF
0040DAr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
0040DEr 3  rr rr        
0040E0r 3  6C 73 68 69          .byte "lshift"
0040E4r 3  66 74        
0040E6r 3               
0040E6r 3               nt_rshift:
0040E6r 3  06 10                .byte 6, UF
0040E8r 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
0040ECr 3  rr rr        
0040EEr 3  72 73 68 69          .byte "rshift"
0040F2r 3  66 74        
0040F4r 3               
0040F4r 3               nt_xor:
0040F4r 3  03 10                .byte 3, UF
0040F6r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
0040FAr 3  rr rr        
0040FCr 3  78 6F 72             .byte "xor"
0040FFr 3               
0040FFr 3               nt_or:
0040FFr 3  02 10                .byte 2, UF
004101r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
004105r 3  rr rr        
004107r 3  6F 72                .byte "or"
004109r 3               
004109r 3               nt_and:
004109r 3  03 10                .byte 3, UF
00410Br 3  rr rr rr rr          .word nt_or, xt_and, z_and
00410Fr 3  rr rr        
004111r 3  61 6E 64             .byte "and"
004114r 3               
004114r 3               nt_dabs:
004114r 3  04 10                .byte 4, UF
004116r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
00411Ar 3  rr rr        
00411Cr 3  64 61 62 73          .byte "dabs"
004120r 3               
004120r 3               nt_abs:
004120r 3  03 10                .byte 3, UF
004122r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
004126r 3  rr rr        
004128r 3  61 62 73             .byte "abs"
00412Br 3               
00412Br 3               nt_minus:
00412Br 3  01 10                .byte 1, UF
00412Dr 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
004131r 3  rr rr        
004133r 3  2D                   .byte "-"
004134r 3               
004134r 3               nt_plus:
004134r 3  01 10                .byte 1, UF
004136r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
00413Ar 3  rr rr        
00413Cr 3  2B                   .byte "+"
00413Dr 3               
00413Dr 3               nt_question_dup:
00413Dr 3  04 10                .byte 4, UF
00413Fr 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
004143r 3  rr rr        
004145r 3  3F 64 75 70          .byte "?dup"
004149r 3               
004149r 3               nt_two_dup:
004149r 3  04 10                .byte 4, UF
00414Br 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
00414Fr 3  rr rr        
004151r 3  32 64 75 70          .byte "2dup"
004155r 3               
004155r 3               nt_two:
004155r 3  01 00                .byte 1, 0
004157r 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
00415Br 3  rr rr        
00415Dr 3  32                   .byte "2"
00415Er 3               
00415Er 3               nt_one:
00415Er 3  01 00                .byte 1, 0
004160r 3  rr rr rr rr          .word nt_two, xt_one, z_one
004164r 3  rr rr        
004166r 3  31                   .byte "1"
004167r 3               
004167r 3               nt_zero:
004167r 3  01 00                .byte 1, 0
004169r 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
00416Dr 3  rr rr        
00416Fr 3  30                   .byte "0"
004170r 3               
004170r 3               nt_space:
004170r 3  05 00                .byte 5, 0
004172r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
004176r 3  rr rr        
004178r 3  73 70 61 63          .byte "space"
00417Cr 3  65           
00417Dr 3               
00417Dr 3               nt_true:
00417Dr 3  04 00                .byte 4, 0
00417Fr 3  rr rr rr rr          .word nt_space, xt_true, z_true
004183r 3  rr rr        
004185r 3  74 72 75 65          .byte "true"
004189r 3               
004189r 3               nt_false:
004189r 3  05 00                .byte 5, 0
00418Br 3  rr rr rr rr          .word nt_true, xt_false, z_false
00418Fr 3  rr rr        
004191r 3  66 61 6C 73          .byte "false"
004195r 3  65           
004196r 3               
004196r 3               nt_question:
004196r 3  01 00                .byte 1, 0
004198r 3  rr rr rr rr          .word nt_false, xt_question, z_question
00419Cr 3  rr rr        
00419Er 3  3F                   .byte "?"
00419Fr 3               
00419Fr 3               nt_ud_dot_r:
00419Fr 3  04 10                .byte 4, UF
0041A1r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
0041A5r 3  rr rr        
0041A7r 3  75 64 2E 72          .byte "ud.r"
0041ABr 3               
0041ABr 3               nt_ud_dot:
0041ABr 3  03 10                .byte 3, UF
0041ADr 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
0041B1r 3  rr rr        
0041B3r 3  75 64 2E             .byte "ud."
0041B6r 3               
0041B6r 3               nt_d_dot_r:
0041B6r 3  03 10                .byte 3, UF
0041B8r 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
0041BCr 3  rr rr        
0041BEr 3  64 2E 72             .byte "d.r"
0041C1r 3               
0041C1r 3               nt_d_dot:
0041C1r 3  02 10                .byte 2, UF
0041C3r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
0041C7r 3  rr rr        
0041C9r 3  64 2E                .byte "d."
0041CBr 3               
0041CBr 3               nt_dot_r:
0041CBr 3  02 10                .byte 2, UF
0041CDr 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
0041D1r 3  rr rr        
0041D3r 3  2E 72                .byte ".r"
0041D5r 3               
0041D5r 3               nt_u_dot_r:
0041D5r 3  03 10                .byte 3, UF
0041D7r 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
0041DBr 3  rr rr        
0041DDr 3  75 2E 72             .byte "u.r"
0041E0r 3               
0041E0r 3               nt_u_dot:
0041E0r 3  02 10                .byte 2, UF
0041E2r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
0041E6r 3  rr rr        
0041E8r 3  75 2E                .byte "u."
0041EAr 3               
0041EAr 3               nt_dot:
0041EAr 3  01 10                .byte 1, UF
0041ECr 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
0041F0r 3  rr rr        
0041F2r 3  2E                   .byte "."
0041F3r 3               
0041F3r 3               nt_type:
0041F3r 3  04 10                .byte 4, UF
0041F5r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
0041F9r 3  rr rr        
0041FBr 3  74 79 70 65          .byte "type"
0041FFr 3               
0041FFr 3               nt_emit:
0041FFr 3  04 18                .byte 4, NN+UF
004201r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
004205r 3  rr rr        
004207r 3  65 6D 69 74          .byte "emit"
00420Br 3               
00420Br 3               nt_execute:
00420Br 3  07 10                .byte 7, UF
00420Dr 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
004211r 3  rr rr        
004213r 3  65 78 65 63          .byte "execute"
004217r 3  75 74 65     
00421Ar 3               
00421Ar 3               nt_plus_store:
00421Ar 3  02 10                .byte 2, UF
00421Cr 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
004220r 3  rr rr        
004222r 3  2B 21                .byte "+!"
004224r 3               
004224r 3               nt_c_store:
004224r 3  02 10                .byte 2, UF
004226r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
00422Ar 3  rr rr        
00422Cr 3  63 21                .byte "c!"
00422Er 3               
00422Er 3               nt_c_fetch:
00422Er 3  02 10                .byte 2, UF
004230r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
004234r 3  rr rr        
004236r 3  63 40                .byte "c@"
004238r 3               
004238r 3               nt_comma:
004238r 3  01 10                .byte 1, UF
00423Ar 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
00423Er 3  rr rr        
004240r 3  2C                   .byte ","
004241r 3               
004241r 3               nt_tuck:
004241r 3  04 10                .byte 4, UF
004243r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
004247r 3  rr rr        
004249r 3  74 75 63 6B          .byte "tuck"
00424Dr 3               
00424Dr 3               nt_not_rote:
00424Dr 3  04 10                .byte 4, UF
00424Fr 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
004253r 3  rr rr        
004255r 3  2D 72 6F 74          .byte "-rot"
004259r 3               
004259r 3               nt_rot:
004259r 3  03 10                .byte 3, UF
00425Br 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
00425Fr 3  rr rr        
004261r 3  72 6F 74             .byte "rot"
004264r 3               
004264r 3               nt_nip:
004264r 3  03 10                .byte 3, UF
004266r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
00426Ar 3  rr rr        
00426Cr 3  6E 69 70             .byte "nip"
00426Fr 3               
00426Fr 3               nt_r_fetch:
00426Fr 3  02 01                .byte 2, CO    ; native is special case
004271r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
004275r 3  rr rr        
004277r 3  72 40                .byte "r@"
004279r 3               
004279r 3               nt_r_from:
004279r 3  02 01                .byte 2, CO    ; native is special case
00427Br 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
00427Fr 3  rr rr        
004281r 3  72 3E                .byte "r>"
004283r 3               
004283r 3               nt_to_r:
004283r 3  02 11                .byte 2, CO+UF ; native is special case
004285r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
004289r 3  rr rr        
00428Br 3  3E 72                .byte ">r"
00428Dr 3               
00428Dr 3               nt_over:
00428Dr 3  04 10                .byte 4, UF
00428Fr 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
004293r 3  rr rr        
004295r 3  6F 76 65 72          .byte "over"
004299r 3               
004299r 3               nt_fetch:
004299r 3  01 10                .byte 1, UF
00429Br 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
00429Fr 3  rr rr        
0042A1r 3  40                   .byte "@"
0042A2r 3               
0042A2r 3               nt_store:
0042A2r 3  01 10                .byte 1, UF
0042A4r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
0042A8r 3  rr rr        
0042AAr 3  21                   .byte "!"
0042ABr 3               
0042ABr 3               nt_swap:
0042ABr 3  04 10                .byte 4, UF
0042ADr 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
0042B1r 3  rr rr        
0042B3r 3  73 77 61 70          .byte "swap"
0042B7r 3               
0042B7r 3               nt_dup:
0042B7r 3  03 10                .byte 3, UF
0042B9r 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
0042BDr 3  rr rr        
0042BFr 3  64 75 70             .byte "dup"
0042C2r 3               
0042C2r 3               ; DROP is always the first native word in the Dictionary
0042C2r 3               dictionary_start:
0042C2r 3               nt_drop:
0042C2r 3  04 10                .byte 4, UF
0042C4r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
0042C8r 3  rr rr        
0042CAr 3  64 72 6F 70          .byte "drop"
0042CEr 3               
0042CEr 3               ; END of FORTH-WORDLIST
0042CEr 3               
0042CEr 3               
0042CEr 3               ; ROOT-WORDLIST
0042CEr 3                       ; This is a short wordlist that has just the words needed to
0042CEr 3                       ; set the wordlists. These words are also included in the
0042CEr 3                       ; FORTH-WORDLIST as well.
0042CEr 3               
0042CEr 3               nt_root_words:
0042CEr 3  05 00                .byte 5, 0
0042D0r 3  00 00 rr rr          .word 0000, xt_words, z_words
0042D4r 3  rr rr        
0042D6r 3  77 6F 72 64          .byte "words"
0042DAr 3  73           
0042DBr 3               
0042DBr 3               nt_root_forth_wordlist: ; shares code with ZERO
0042DBr 3  0E 00                .byte 14, 0
0042DDr 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
0042E1r 3  rr rr        
0042E3r 3  66 6F 72 74          .byte "forth-wordlist"
0042E7r 3  68 2D 77 6F  
0042EBr 3  72 64 6C 69  
0042F1r 3               
0042F1r 3               nt_root_forth:
0042F1r 3  05 00                .byte 5, 0
0042F3r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
0042F7r 3  rr rr        
0042F9r 3  66 6F 72 74          .byte "forth"
0042FDr 3  68           
0042FEr 3               
0042FEr 3               root_dictionary_start:
0042FEr 3               nt_root_set_order:
0042FEr 3  09 00                .byte 9, 0
004300r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
004304r 3  rr rr        
004306r 3  73 65 74 2D          .byte "set-order"
00430Ar 3  6F 72 64 65  
00430Er 3  72           
00430Fr 3               
00430Fr 3               ; END of ROOT-WORDLIST
00430Fr 3               
00430Fr 3               
00430Fr 3               ; ; EDITOR-WORDLIST
00430Fr 3               
00430Fr 3               ; nt_editor_enter_screen:
00430Fr 3               ;         .byte 12, 0
00430Fr 3               ;         .word 0000, xt_editor_enter_screen, z_editor_enter_screen
00430Fr 3               ;         .byte "enter-screen"
00430Fr 3               
00430Fr 3               ; nt_editor_erase_screen:
00430Fr 3               ;         .byte 12, 0
00430Fr 3               ;         .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
00430Fr 3               ;         .byte "erase-screen"
00430Fr 3               
00430Fr 3               ; nt_editor_el:
00430Fr 3               ;         .byte 2, 0
00430Fr 3               ;         .word nt_editor_erase_screen, xt_editor_el, z_editor_el
00430Fr 3               ;         .byte "el"
00430Fr 3               
00430Fr 3               ; nt_editor_l:
00430Fr 3               ;         .byte 1, 0
00430Fr 3               ;         .word nt_editor_el, xt_editor_l, z_editor_l
00430Fr 3               ;         .byte "l"
00430Fr 3               
00430Fr 3               ; nt_editor_line:
00430Fr 3               ;         .byte 4, UF
00430Fr 3               ;         .word nt_editor_l, xt_editor_line, z_editor_line
00430Fr 3               ;         .byte "line"
00430Fr 3               
00430Fr 3               editor_dictionary_start:
00430Fr 3               ; nt_editor_o:
00430Fr 3               ;         .byte 1, 0
00430Fr 3               ;         .word nt_editor_line, xt_editor_o, z_editor_o
00430Fr 3               ;         .byte "o"
00430Fr 3               
00430Fr 3               ; ; END of EDITOR-WORDLIST
00430Fr 3               
00430Fr 3               
00430Fr 3               ; ; ASSEMBLER-WORDLIST
00430Fr 3               
00430Fr 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
00430Fr 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
00430Fr 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
00430Fr 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
00430Fr 3               assembler_dictionary_start:
00430Fr 3               ; nt_asm_adc_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_adc_x
00430Fr 3               ; 		.word xt_asm_adc_h, z_asm_adc_h
00430Fr 3               ; 		.byte "adc.#"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_adc_y
00430Fr 3               ; 		.word xt_asm_adc_x, z_asm_adc_x
00430Fr 3               ; 		.byte "adc.x"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_adc_z
00430Fr 3               ; 		.word xt_asm_adc_y, z_asm_adc_y
00430Fr 3               ; 		.byte "adc.y"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_adc_zi
00430Fr 3               ; 		.word xt_asm_adc_z, z_asm_adc_z
00430Fr 3               ; 		.byte "adc.z"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_adc_ziy
00430Fr 3               ; 		.word xt_asm_adc_zi, z_asm_adc_zi
00430Fr 3               ; 		.byte "adc.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_adc_zx
00430Fr 3               ; 		.word xt_asm_adc_ziy, z_asm_adc_ziy
00430Fr 3               ; 		.byte "adc.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_adc_zxi
00430Fr 3               ; 		.word xt_asm_adc_zx, z_asm_adc_zx
00430Fr 3               ; 		.byte "adc.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_adc_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_and
00430Fr 3               ; 		.word xt_asm_adc_zxi, z_asm_adc_zxi
00430Fr 3               ; 		.byte "adc.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_and:     ; not "and" because of conflicts with Forth word
00430Fr 3               ; 		.byte 4, IM
00430Fr 3               ;                 .word nt_asm_and_h
00430Fr 3               ; 		.word xt_asm_and, z_asm_and
00430Fr 3               ; 		.byte "and."
00430Fr 3               
00430Fr 3               ; nt_asm_and_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_and_x
00430Fr 3               ; 		.word xt_asm_and_h, z_asm_and_h
00430Fr 3               ; 		.byte "and.#"
00430Fr 3               
00430Fr 3               ; nt_asm_and_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_and_y
00430Fr 3               ; 		.word xt_asm_and_x, z_asm_and_x
00430Fr 3               ; 		.byte "and.x"
00430Fr 3               
00430Fr 3               ; nt_asm_and_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_and_z
00430Fr 3               ; 		.word xt_asm_and_y, z_asm_and_y
00430Fr 3               ; 		.byte "and.y"
00430Fr 3               
00430Fr 3               ; nt_asm_and_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_and_zi
00430Fr 3               ; 		.word xt_asm_and_z, z_asm_and_z
00430Fr 3               ; 		.byte "and.z"
00430Fr 3               
00430Fr 3               ; nt_asm_and_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_and_ziy
00430Fr 3               ; 		.word xt_asm_and_zi, z_asm_and_zi
00430Fr 3               ; 		.byte "and.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_and_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_and_zx
00430Fr 3               ; 		.word xt_asm_and_ziy, z_asm_and_ziy
00430Fr 3               ; 		.byte "and.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_and_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_and_zxi
00430Fr 3               ; 		.word xt_asm_and_zx, z_asm_and_zx
00430Fr 3               ; 		.byte "and.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_and_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_asl
00430Fr 3               ; 		.word xt_asm_and_zxi, z_asm_and_zxi
00430Fr 3               ; 		.byte "and.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_asl:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_asl_a
00430Fr 3               ; 		.word xt_asm_asl, z_asm_asl
00430Fr 3               ; 		.byte "asl"
00430Fr 3               
00430Fr 3               ; nt_asm_asl_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_asl_x
00430Fr 3               ; 		.word xt_asm_asl_a, z_asm_asl_a
00430Fr 3               ; 		.byte "asl.a"
00430Fr 3               
00430Fr 3               ; nt_asm_asl_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_asl_z
00430Fr 3               ; 		.word xt_asm_asl_x, z_asm_asl_x
00430Fr 3               ; 		.byte "asl.x"
00430Fr 3               
00430Fr 3               ; nt_asm_asl_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_asl_zx
00430Fr 3               ; 		.word xt_asm_asl_z, z_asm_asl_z
00430Fr 3               ; 		.byte "asl.z"
00430Fr 3               
00430Fr 3               ; nt_asm_asl_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_bcc
00430Fr 3               ; 		.word xt_asm_asl_zx, z_asm_asl_zx
00430Fr 3               ; 		.byte "asl.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_bcc:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bcs
00430Fr 3               ; 		.word xt_asm_bcc, z_asm_bcc
00430Fr 3               ; 		.byte "bcc"
00430Fr 3               
00430Fr 3               ; nt_asm_bcs:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_beq
00430Fr 3               ; 		.word xt_asm_bcs, z_asm_bcs
00430Fr 3               ; 		.byte "bcs"
00430Fr 3               
00430Fr 3               ; nt_asm_beq:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bit
00430Fr 3               ; 		.word xt_asm_beq, z_asm_beq
00430Fr 3               ; 		.byte "beq"
00430Fr 3               
00430Fr 3               ; nt_asm_bit:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bit_h
00430Fr 3               ; 		.word xt_asm_bit, z_asm_bit
00430Fr 3               ; 		.byte "bit"
00430Fr 3               
00430Fr 3               ; nt_asm_bit_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_bit_x
00430Fr 3               ; 		.word xt_asm_bit_h, z_asm_bit_h
00430Fr 3               ; 		.byte "bit.#"
00430Fr 3               
00430Fr 3               ; nt_asm_bit_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_bit_z
00430Fr 3               ; 		.word xt_asm_bit_x, z_asm_bit_x
00430Fr 3               ; 		.byte "bit.x"
00430Fr 3               
00430Fr 3               ; nt_asm_bit_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_bit_zx
00430Fr 3               ; 		.word xt_asm_bit_z, z_asm_bit_z
00430Fr 3               ; 		.byte "bit.z"
00430Fr 3               
00430Fr 3               ; nt_asm_bit_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_bmi
00430Fr 3               ; 		.word xt_asm_bit_zx, z_asm_bit_zx
00430Fr 3               ; 		.byte "bit.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_bmi:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bne
00430Fr 3               ; 		.word xt_asm_bmi, z_asm_bmi
00430Fr 3               ; 		.byte "bmi"
00430Fr 3               
00430Fr 3               ; nt_asm_bne:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bpl
00430Fr 3               ; 		.word xt_asm_bne, z_asm_bne
00430Fr 3               ; 		.byte "bne"
00430Fr 3               
00430Fr 3               ; nt_asm_bpl:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bra
00430Fr 3               ; 		.word xt_asm_bpl, z_asm_bpl
00430Fr 3               ; 		.byte "bpl"
00430Fr 3               
00430Fr 3               ; nt_asm_bra:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_brk
00430Fr 3               ; 		.word xt_asm_bra, z_asm_bra
00430Fr 3               ; 		.byte "bra"
00430Fr 3               
00430Fr 3               ; nt_asm_brk:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bvc
00430Fr 3               ; 		.word xt_asm_brk, z_asm_brk
00430Fr 3               ; 		.byte "brk"
00430Fr 3               
00430Fr 3               ; nt_asm_bvc:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_bvs
00430Fr 3               ; 		.word xt_asm_bvc, z_asm_bvc
00430Fr 3               ; 		.byte "bvc"
00430Fr 3               
00430Fr 3               ; nt_asm_bvs:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_clc
00430Fr 3               ; 		.word xt_asm_bvs, z_asm_bvs
00430Fr 3               ; 		.byte "bvs"
00430Fr 3               
00430Fr 3               ; nt_asm_clc:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cld
00430Fr 3               ; 		.word xt_asm_clc, z_asm_clc
00430Fr 3               ; 		.byte "clc"
00430Fr 3               
00430Fr 3               ; nt_asm_cld:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cli
00430Fr 3               ; 		.word xt_asm_cld, z_asm_cld
00430Fr 3               ; 		.byte "cld"
00430Fr 3               
00430Fr 3               ; nt_asm_cli:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_clv
00430Fr 3               ; 		.word xt_asm_cli, z_asm_cli
00430Fr 3               ; 		.byte "cli"
00430Fr 3               
00430Fr 3               ; nt_asm_clv:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cmp
00430Fr 3               ; 		.word xt_asm_clv, z_asm_clv
00430Fr 3               ; 		.byte "clv"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cmp_h
00430Fr 3               ; 		.word xt_asm_cmp, z_asm_cmp
00430Fr 3               ; 		.byte "cmp"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cmp_x
00430Fr 3               ; 		.word xt_asm_cmp_h, z_asm_cmp_h
00430Fr 3               ; 		.byte "cmp.#"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cmp_y
00430Fr 3               ; 		.word xt_asm_cmp_x, z_asm_cmp_x
00430Fr 3               ; 		.byte "cmp.x"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cmp_z
00430Fr 3               ; 		.word xt_asm_cmp_y, z_asm_cmp_y
00430Fr 3               ; 		.byte "cmp.y"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cmp_zi
00430Fr 3               ; 		.word xt_asm_cmp_z, z_asm_cmp_z
00430Fr 3               ; 		.byte "cmp.z"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_cmp_ziy
00430Fr 3               ; 		.word xt_asm_cmp_zi, z_asm_cmp_zi
00430Fr 3               ; 		.byte "cmp.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_cmp_zx
00430Fr 3               ; 		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
00430Fr 3               ; 		.byte "cmp.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_cmp_zxi
00430Fr 3               ; 		.word xt_asm_cmp_zx, z_asm_cmp_zx
00430Fr 3               ; 		.byte "cmp.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_cmp_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_cpx
00430Fr 3               ; 		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
00430Fr 3               ; 		.byte "cmp.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_cpx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cpx_h
00430Fr 3               ; 		.word xt_asm_cpx, z_asm_cpx
00430Fr 3               ; 		.byte "cpx"
00430Fr 3               
00430Fr 3               ; nt_asm_cpx_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cpx_z
00430Fr 3               ; 		.word xt_asm_cpx_h, z_asm_cpx_h
00430Fr 3               ; 		.byte "cpx.#"
00430Fr 3               
00430Fr 3               ; nt_asm_cpx_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cpy
00430Fr 3               ; 		.word xt_asm_cpx_z, z_asm_cpx_z
00430Fr 3               ; 		.byte "cpx.z"
00430Fr 3               
00430Fr 3               ; nt_asm_cpy:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_cpy_h
00430Fr 3               ; 		.word xt_asm_cpy, z_asm_cpy
00430Fr 3               ; 		.byte "cpy"
00430Fr 3               
00430Fr 3               ; nt_asm_cpy_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_cpy_z
00430Fr 3               ; 		.word xt_asm_cpy_h, z_asm_cpy_h
00430Fr 3               ; 		.byte "cpy.#"
00430Fr 3               
00430Fr 3               ; nt_asm_cpy_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_dec
00430Fr 3               ; 		.word xt_asm_cpy_z, z_asm_cpy_z
00430Fr 3               ; 		.byte "cpy.z"
00430Fr 3               
00430Fr 3               ; nt_asm_dec:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_dec_a
00430Fr 3               ; 		.word xt_asm_dec, z_asm_dec
00430Fr 3               ; 		.byte "dec"
00430Fr 3               
00430Fr 3               ; nt_asm_dec_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_dec_x
00430Fr 3               ; 		.word xt_asm_dec_a, z_asm_dec_a
00430Fr 3               ; 		.byte "dec.a"
00430Fr 3               
00430Fr 3               ; nt_asm_dec_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_dec_z
00430Fr 3               ; 		.word xt_asm_dec_x, z_asm_dec_x
00430Fr 3               ; 		.byte "dec.x"
00430Fr 3               
00430Fr 3               ; nt_asm_dec_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_dec_zx
00430Fr 3               ; 		.word xt_asm_dec_z, z_asm_dec_z
00430Fr 3               ; 		.byte "dec.z"
00430Fr 3               
00430Fr 3               ; nt_asm_dec_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_dex
00430Fr 3               ; 		.word xt_asm_dec_zx, z_asm_dec_zx
00430Fr 3               ; 		.byte "dec.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_dex:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_dey
00430Fr 3               ; 		.word xt_asm_dex, z_asm_dex
00430Fr 3               ; 		.byte "dex"
00430Fr 3               
00430Fr 3               ; nt_asm_dey:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_eor
00430Fr 3               ; 		.word xt_asm_dey, z_asm_dey
00430Fr 3               ; 		.byte "dey"
00430Fr 3               
00430Fr 3               ; nt_asm_eor:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_eor_h
00430Fr 3               ; 		.word xt_asm_eor, z_asm_eor
00430Fr 3               ; 		.byte "eor"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_eor_x
00430Fr 3               ; 		.word xt_asm_eor_h, z_asm_eor_h
00430Fr 3               ; 		.byte "eor.#"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_eor_y
00430Fr 3               ; 		.word xt_asm_eor_x, z_asm_eor_x
00430Fr 3               ; 		.byte "eor.x"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_eor_z
00430Fr 3               ; 		.word xt_asm_eor_y, z_asm_eor_y
00430Fr 3               ; 		.byte "eor.y"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_eor_zi
00430Fr 3               ; 		.word xt_asm_eor_z, z_asm_eor_z
00430Fr 3               ; 		.byte "eor.z"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_eor_ziy
00430Fr 3               ; 		.word xt_asm_eor_zi, z_asm_eor_zi
00430Fr 3               ; 		.byte "eor.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_eor_zx
00430Fr 3               ; 		.word xt_asm_eor_ziy, z_asm_eor_ziy
00430Fr 3               ; 		.byte "eor.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_eor_zxi
00430Fr 3               ; 		.word xt_asm_eor_zx, z_asm_eor_zx
00430Fr 3               ; 		.byte "eor.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_eor_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_inc
00430Fr 3               ; 		.word xt_asm_eor_zxi, z_asm_eor_zxi
00430Fr 3               ; 		.byte "eor.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_inc:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_inc_a
00430Fr 3               ; 		.word xt_asm_inc, z_asm_inc
00430Fr 3               ; 		.byte "inc"
00430Fr 3               
00430Fr 3               ; nt_asm_inc_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_inc_x
00430Fr 3               ; 		.word xt_asm_inc_a, z_asm_inc_a
00430Fr 3               ; 		.byte "inc.a"
00430Fr 3               
00430Fr 3               ; nt_asm_inc_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_inc_z
00430Fr 3               ; 		.word xt_asm_inc_x, z_asm_inc_x
00430Fr 3               ; 		.byte "inc.x"
00430Fr 3               
00430Fr 3               ; nt_asm_inc_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_inc_zx
00430Fr 3               ; 		.word xt_asm_inc_z, z_asm_inc_z
00430Fr 3               ; 		.byte "inc.z"
00430Fr 3               
00430Fr 3               ; nt_asm_inc_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_inx
00430Fr 3               ; 		.word xt_asm_inc_zx, z_asm_inc_zx
00430Fr 3               ; 		.byte "inc.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_inx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_iny
00430Fr 3               ; 		.word xt_asm_inx, z_asm_inx
00430Fr 3               ; 		.byte "inx"
00430Fr 3               
00430Fr 3               ; nt_asm_iny:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_jmp
00430Fr 3               ; 		.word xt_asm_iny, z_asm_iny
00430Fr 3               ; 		.byte "iny"
00430Fr 3               
00430Fr 3               ; nt_asm_jmp:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_jmp_i
00430Fr 3               ; 		.word xt_asm_jmp, z_asm_jmp
00430Fr 3               ; 		.byte "jmp"
00430Fr 3               
00430Fr 3               ; nt_asm_jmp_i:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_jmp_xi
00430Fr 3               ; 		.word xt_asm_jmp_i, z_asm_jmp_i
00430Fr 3               ; 		.byte "jmp.i"
00430Fr 3               
00430Fr 3               ; nt_asm_jmp_xi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_jsr
00430Fr 3               ; 		.word xt_asm_jmp_xi, z_asm_jmp_xi
00430Fr 3               ; 		.byte "jmp.xi"
00430Fr 3               
00430Fr 3               ; nt_asm_jsr:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_lda
00430Fr 3               ; 		.word xt_asm_jsr, z_asm_jsr
00430Fr 3               ; 		.byte "jsr"
00430Fr 3               
00430Fr 3               ; nt_asm_lda:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_lda_h
00430Fr 3               ; 		.word xt_asm_lda, z_asm_lda
00430Fr 3               ; 		.byte "lda"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lda_x
00430Fr 3               ; 		.word xt_asm_lda_h, z_asm_lda_h
00430Fr 3               ; 		.byte "lda.#"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lda_y
00430Fr 3               ; 		.word xt_asm_lda_x, z_asm_lda_x
00430Fr 3               ; 		.byte "lda.x"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lda_z
00430Fr 3               ; 		.word xt_asm_lda_y, z_asm_lda_y
00430Fr 3               ; 		.byte "lda.y"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lda_zi
00430Fr 3               ; 		.word xt_asm_lda_z, z_asm_lda_z
00430Fr 3               ; 		.byte "lda.z"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_lda_ziy
00430Fr 3               ; 		.word xt_asm_lda_zi, z_asm_lda_zi
00430Fr 3               ; 		.byte "lda.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_lda_zx
00430Fr 3               ; 		.word xt_asm_lda_ziy, z_asm_lda_ziy
00430Fr 3               ; 		.byte "lda.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_lda_zxi
00430Fr 3               ; 		.word xt_asm_lda_zx, z_asm_lda_zx
00430Fr 3               ; 		.byte "lda.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_lda_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_ldx
00430Fr 3               ; 		.word xt_asm_lda_zxi, z_asm_lda_zxi
00430Fr 3               ; 		.byte "lda.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_ldx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ldx_h
00430Fr 3               ; 		.word xt_asm_ldx, z_asm_ldx
00430Fr 3               ; 		.byte "ldx"
00430Fr 3               
00430Fr 3               ; nt_asm_ldx_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldx_y
00430Fr 3               ; 		.word xt_asm_ldx_h, z_asm_ldx_h
00430Fr 3               ; 		.byte "ldx.#"
00430Fr 3               
00430Fr 3               ; nt_asm_ldx_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldx_z
00430Fr 3               ; 		.word xt_asm_ldx_y, z_asm_ldx_y
00430Fr 3               ; 		.byte "ldx.y"
00430Fr 3               
00430Fr 3               ; nt_asm_ldx_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldx_zy
00430Fr 3               ; 		.word xt_asm_ldx_z, z_asm_ldx_z
00430Fr 3               ; 		.byte "ldx.z"
00430Fr 3               
00430Fr 3               ; nt_asm_ldx_zy:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_ldy
00430Fr 3               ; 		.word xt_asm_ldx_zy, z_asm_ldx_zy
00430Fr 3               ; 		.byte "ldx.zy"
00430Fr 3               
00430Fr 3               ; nt_asm_ldy:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ldy_h
00430Fr 3               ; 		.word xt_asm_ldy, z_asm_ldy
00430Fr 3               ; 		.byte "ldy"
00430Fr 3               
00430Fr 3               ; nt_asm_ldy_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldy_x
00430Fr 3               ; 		.word xt_asm_ldy_h, z_asm_ldy_h
00430Fr 3               ; 		.byte "ldy.#"
00430Fr 3               
00430Fr 3               ; nt_asm_ldy_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldy_z
00430Fr 3               ; 		.word xt_asm_ldy_x, z_asm_ldy_x
00430Fr 3               ; 		.byte "ldy.x"
00430Fr 3               
00430Fr 3               ; nt_asm_ldy_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ldy_zx
00430Fr 3               ; 		.word xt_asm_ldy_z, z_asm_ldy_z
00430Fr 3               ; 		.byte "ldy.z"
00430Fr 3               
00430Fr 3               ; nt_asm_ldy_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_lsr
00430Fr 3               ; 		.word xt_asm_ldy_zx, z_asm_ldy_zx
00430Fr 3               ; 		.byte "ldy.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_lsr:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_lsr_a
00430Fr 3               ; 		.word xt_asm_lsr, z_asm_lsr
00430Fr 3               ; 		.byte "lsr"
00430Fr 3               
00430Fr 3               ; nt_asm_lsr_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lsr_x
00430Fr 3               ; 		.word xt_asm_lsr_a, z_asm_lsr_a
00430Fr 3               ; 		.byte "lsr.a"
00430Fr 3               
00430Fr 3               ; nt_asm_lsr_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lsr_z
00430Fr 3               ; 		.word xt_asm_lsr_x, z_asm_lsr_x
00430Fr 3               ; 		.byte "lsr.x"
00430Fr 3               
00430Fr 3               ; nt_asm_lsr_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_lsr_zx
00430Fr 3               ; 		.word xt_asm_lsr_z, z_asm_lsr_z
00430Fr 3               ; 		.byte "lsr.z"
00430Fr 3               
00430Fr 3               ; nt_asm_lsr_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_nop
00430Fr 3               ; 		.word xt_asm_lsr_zx, z_asm_lsr_zx
00430Fr 3               ; 		.byte "lsr.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_nop:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ora
00430Fr 3               ; 		.word xt_asm_nop, z_asm_nop
00430Fr 3               ; 		.byte "nop"
00430Fr 3               
00430Fr 3               ; nt_asm_ora:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ora_h
00430Fr 3               ; 		.word xt_asm_ora, z_asm_ora
00430Fr 3               ; 		.byte "ora"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ora_x
00430Fr 3               ; 		.word xt_asm_ora_h, z_asm_ora_h
00430Fr 3               ; 		.byte "ora.#"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ora_y
00430Fr 3               ; 		.word xt_asm_ora_x, z_asm_ora_x
00430Fr 3               ; 		.byte "ora.x"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ora_z
00430Fr 3               ; 		.word xt_asm_ora_y, z_asm_ora_y
00430Fr 3               ; 		.byte "ora.y"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ora_zi
00430Fr 3               ; 		.word xt_asm_ora_z, z_asm_ora_z
00430Fr 3               ; 		.byte "ora.z"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_ora_ziy
00430Fr 3               ; 		.word xt_asm_ora_zi, z_asm_ora_zi
00430Fr 3               ; 		.byte "ora.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_ora_zx
00430Fr 3               ; 		.word xt_asm_ora_ziy, z_asm_ora_ziy
00430Fr 3               ; 		.byte "ora.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_ora_zxi
00430Fr 3               ; 		.word xt_asm_ora_zx, z_asm_ora_zx
00430Fr 3               ; 		.byte "ora.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_ora_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_pha
00430Fr 3               ; 		.word xt_asm_ora_zxi, z_asm_ora_zxi
00430Fr 3               ; 		.byte "ora.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_pha:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_php
00430Fr 3               ; 		.word xt_asm_pha, z_asm_pha
00430Fr 3               ; 		.byte "pha"
00430Fr 3               
00430Fr 3               ; nt_asm_php:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_phx
00430Fr 3               ; 		.word xt_asm_php, z_asm_php
00430Fr 3               ; 		.byte "php"
00430Fr 3               
00430Fr 3               ; nt_asm_phx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_phy
00430Fr 3               ; 		.word xt_asm_phx, z_asm_phx
00430Fr 3               ; 		.byte "phx"
00430Fr 3               
00430Fr 3               ; nt_asm_phy:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_pla
00430Fr 3               ; 		.word xt_asm_phy, z_asm_phy
00430Fr 3               ; 		.byte "phy"
00430Fr 3               
00430Fr 3               ; nt_asm_pla:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_plp
00430Fr 3               ; 		.word xt_asm_pla, z_asm_pla
00430Fr 3               ; 		.byte "pla"
00430Fr 3               
00430Fr 3               ; nt_asm_plp:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_plx
00430Fr 3               ; 		.word xt_asm_plp, z_asm_plp
00430Fr 3               ; 		.byte "plp"
00430Fr 3               
00430Fr 3               ; nt_asm_plx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ply
00430Fr 3               ; 		.word xt_asm_plx, z_asm_plx
00430Fr 3               ; 		.byte "plx"
00430Fr 3               
00430Fr 3               ; nt_asm_ply:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_rol
00430Fr 3               ; 		.word xt_asm_ply, z_asm_ply
00430Fr 3               ; 		.byte "ply"
00430Fr 3               
00430Fr 3               ; nt_asm_rol:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_rol_a
00430Fr 3               ; 		.word xt_asm_rol, z_asm_rol
00430Fr 3               ; 		.byte "rol"
00430Fr 3               
00430Fr 3               ; nt_asm_rol_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_rol_x
00430Fr 3               ; 		.word xt_asm_rol_a, z_asm_rol_a
00430Fr 3               ; 		.byte "rol.a"
00430Fr 3               
00430Fr 3               ; nt_asm_rol_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_rol_z
00430Fr 3               ; 		.word xt_asm_rol_x, z_asm_rol_x
00430Fr 3               ; 		.byte "rol.x"
00430Fr 3               
00430Fr 3               ; nt_asm_rol_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_rol_zx
00430Fr 3               ; 		.word xt_asm_rol_z, z_asm_rol_z
00430Fr 3               ; 		.byte "rol.z"
00430Fr 3               
00430Fr 3               ; nt_asm_rol_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_ror
00430Fr 3               ; 		.word xt_asm_rol_zx, z_asm_rol_zx
00430Fr 3               ; 		.byte "rol.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_ror:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_ror_a
00430Fr 3               ; 		.word xt_asm_ror, z_asm_ror
00430Fr 3               ; 		.byte "ror"
00430Fr 3               
00430Fr 3               ; nt_asm_ror_a:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ror_x
00430Fr 3               ; 		.word xt_asm_ror_a, z_asm_ror_a
00430Fr 3               ; 		.byte "ror.a"
00430Fr 3               
00430Fr 3               ; nt_asm_ror_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ror_z
00430Fr 3               ; 		.word xt_asm_ror_x, z_asm_ror_x
00430Fr 3               ; 		.byte "ror.x"
00430Fr 3               
00430Fr 3               ; nt_asm_ror_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_ror_zx
00430Fr 3               ; 		.word xt_asm_ror_z, z_asm_ror_z
00430Fr 3               ; 		.byte "ror.z"
00430Fr 3               
00430Fr 3               ; nt_asm_ror_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_rti
00430Fr 3               ; 		.word xt_asm_ror_zx, z_asm_ror_zx
00430Fr 3               ; 		.byte "ror.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_rti:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_rts
00430Fr 3               ; 		.word xt_asm_rti, z_asm_rti
00430Fr 3               ; 		.byte "rti"
00430Fr 3               
00430Fr 3               ; nt_asm_rts:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sbc
00430Fr 3               ; 		.word xt_asm_rts, z_asm_rts
00430Fr 3               ; 		.byte "rts"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sbc_h
00430Fr 3               ; 		.word xt_asm_sbc, z_asm_sbc
00430Fr 3               ; 		.byte "sbc"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_h:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sbc_x
00430Fr 3               ; 		.word xt_asm_sbc_h, z_asm_sbc_h
00430Fr 3               ; 		.byte "sbc.#"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sbc_y
00430Fr 3               ; 		.word xt_asm_sbc_x, z_asm_sbc_x
00430Fr 3               ; 		.byte "sbc.x"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sbc_z
00430Fr 3               ; 		.word xt_asm_sbc_y, z_asm_sbc_y
00430Fr 3               ; 		.byte "sbc.y"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sbc_zi
00430Fr 3               ; 		.word xt_asm_sbc_z, z_asm_sbc_z
00430Fr 3               ; 		.byte "sbc.z"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_sbc_ziy
00430Fr 3               ; 		.word xt_asm_sbc_zi, z_asm_sbc_zi
00430Fr 3               ; 		.byte "sbc.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_sbc_zx
00430Fr 3               ; 		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
00430Fr 3               ; 		.byte "sbc.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_sbc_zxi
00430Fr 3               ; 		.word xt_asm_sbc_zx, z_asm_sbc_zx
00430Fr 3               ; 		.byte "sbc.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_sbc_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_sec
00430Fr 3               ; 		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
00430Fr 3               ; 		.byte "sbc.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_sec:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sed
00430Fr 3               ; 		.word xt_asm_sec, z_asm_sec
00430Fr 3               ; 		.byte "sec"
00430Fr 3               
00430Fr 3               ; nt_asm_sed:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sei
00430Fr 3               ; 		.word xt_asm_sed, z_asm_sed
00430Fr 3               ; 		.byte "sed"
00430Fr 3               
00430Fr 3               ; nt_asm_sei:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sta
00430Fr 3               ; 		.word xt_asm_sei, z_asm_sei
00430Fr 3               ; 		.byte "sei"
00430Fr 3               
00430Fr 3               ; nt_asm_sta:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sta_x
00430Fr 3               ; 		.word xt_asm_sta, z_asm_sta
00430Fr 3               ; 		.byte "sta"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sta_y
00430Fr 3               ; 		.word xt_asm_sta_x, z_asm_sta_x
00430Fr 3               ; 		.byte "sta.x"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_y:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sta_z
00430Fr 3               ; 		.word xt_asm_sta_y, z_asm_sta_y
00430Fr 3               ; 		.byte "sta.y"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sta_zi
00430Fr 3               ; 		.word xt_asm_sta_z, z_asm_sta_z
00430Fr 3               ; 		.byte "sta.z"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_zi:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_sta_ziy
00430Fr 3               ; 		.word xt_asm_sta_zi, z_asm_sta_zi
00430Fr 3               ; 		.byte "sta.zi"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_ziy:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_sta_zx
00430Fr 3               ; 		.word xt_asm_sta_ziy, z_asm_sta_ziy
00430Fr 3               ; 		.byte "sta.ziy"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_sta_zxi
00430Fr 3               ; 		.word xt_asm_sta_zx, z_asm_sta_zx
00430Fr 3               ; 		.byte "sta.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_sta_zxi:
00430Fr 3               ; 		.byte 7, IM
00430Fr 3               ;                 .word nt_asm_stx
00430Fr 3               ; 		.word xt_asm_sta_zxi, z_asm_sta_zxi
00430Fr 3               ; 		.byte "sta.zxi"
00430Fr 3               
00430Fr 3               ; nt_asm_stx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_stx_z
00430Fr 3               ; 		.word xt_asm_stx, z_asm_stx
00430Fr 3               ; 		.byte "stx"
00430Fr 3               
00430Fr 3               ; nt_asm_stx_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_stx_zy
00430Fr 3               ; 		.word xt_asm_stx_z, z_asm_stx_z
00430Fr 3               ; 		.byte "stx.z"
00430Fr 3               
00430Fr 3               ; nt_asm_stx_zy:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_sty
00430Fr 3               ; 		.word xt_asm_stx_zy, z_asm_stx_zy
00430Fr 3               ; 		.byte "stx.zy"
00430Fr 3               
00430Fr 3               ; nt_asm_sty:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_sty_z
00430Fr 3               ; 		.word xt_asm_sty, z_asm_sty
00430Fr 3               ; 		.byte "sty"
00430Fr 3               
00430Fr 3               ; nt_asm_sty_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_sty_zx
00430Fr 3               ; 		.word xt_asm_sty_z, z_asm_sty_z
00430Fr 3               ; 		.byte "sty.z"
00430Fr 3               
00430Fr 3               ; nt_asm_sty_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_stz
00430Fr 3               ; 		.word xt_asm_sty_zx, z_asm_sty_zx
00430Fr 3               ; 		.byte "sty.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_stz:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_stz_x
00430Fr 3               ; 		.word xt_asm_stz, z_asm_stz
00430Fr 3               ; 		.byte "stz"
00430Fr 3               
00430Fr 3               ; nt_asm_stz_x:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_stz_z
00430Fr 3               ; 		.word xt_asm_stz_x, z_asm_stz_x
00430Fr 3               ; 		.byte "stz.x"
00430Fr 3               
00430Fr 3               ; nt_asm_stz_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_stz_zx
00430Fr 3               ; 		.word xt_asm_stz_z, z_asm_stz_z
00430Fr 3               ; 		.byte "stz.z"
00430Fr 3               
00430Fr 3               ; nt_asm_stz_zx:
00430Fr 3               ; 		.byte 6, IM
00430Fr 3               ;                 .word nt_asm_tax
00430Fr 3               ; 		.word xt_asm_stz_zx, z_asm_stz_zx
00430Fr 3               ; 		.byte "stz.zx"
00430Fr 3               
00430Fr 3               ; nt_asm_tax:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_tay
00430Fr 3               ; 		.word xt_asm_tax, z_asm_tax
00430Fr 3               ; 		.byte "tax"
00430Fr 3               
00430Fr 3               ; nt_asm_tay:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_trb
00430Fr 3               ; 		.word xt_asm_tay, z_asm_tay
00430Fr 3               ; 		.byte "tay"
00430Fr 3               
00430Fr 3               ; nt_asm_trb:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_trb_z
00430Fr 3               ; 		.word xt_asm_trb, z_asm_trb
00430Fr 3               ; 		.byte "trb"
00430Fr 3               
00430Fr 3               ; nt_asm_trb_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_tsb
00430Fr 3               ; 		.word xt_asm_trb_z, z_asm_trb_z
00430Fr 3               ; 		.byte "trb.z"
00430Fr 3               
00430Fr 3               ; nt_asm_tsb:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_tsb_z
00430Fr 3               ; 		.word xt_asm_tsb, z_asm_tsb
00430Fr 3               ; 		.byte "tsb"
00430Fr 3               
00430Fr 3               ; nt_asm_tsb_z:
00430Fr 3               ; 		.byte 5, IM
00430Fr 3               ;                 .word nt_asm_tsx
00430Fr 3               ; 		.word xt_asm_tsb_z, z_asm_tsb_z
00430Fr 3               ; 		.byte "tsb.z"
00430Fr 3               
00430Fr 3               ; nt_asm_tsx:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_txa
00430Fr 3               ; 		.word xt_asm_tsx, z_asm_tsx
00430Fr 3               ; 		.byte "tsx"
00430Fr 3               
00430Fr 3               ; nt_asm_txa:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_txs
00430Fr 3               ; 		.word xt_asm_txa, z_asm_txa
00430Fr 3               ; 		.byte "txa"
00430Fr 3               
00430Fr 3               ; nt_asm_txs:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_tya
00430Fr 3               ; 		.word xt_asm_txs, z_asm_txs
00430Fr 3               ; 		.byte "txs"
00430Fr 3               
00430Fr 3               ; nt_asm_tya:
00430Fr 3               ; 		.byte 3, IM
00430Fr 3               ;                 .word nt_asm_arrow
00430Fr 3               ; 		.word xt_asm_tya, z_asm_tya
00430Fr 3               ; 		.byte "tya"
00430Fr 3               
00430Fr 3               ; ; Assembler pseudo-instructions, directives and macros
00430Fr 3               
00430Fr 3               ; nt_asm_arrow:   ; uses same code as HERE, but immediate
00430Fr 3               ;                 .byte 3, IM
00430Fr 3               ;                 .word nt_asm_back_jump
00430Fr 3               ;                 .word xt_asm_arrow, z_asm_arrow
00430Fr 3               ;                 .byte "-->"
00430Fr 3               
00430Fr 3               
00430Fr 3               ; nt_asm_back_jump:  ; syntactic sugar, does nothing
00430Fr 3               ;                 .byte 2, IM
00430Fr 3               ;                 .word nt_asm_back_branch
00430Fr 3               ;                 .word xt_asm_back_jump, z_asm_back_jump
00430Fr 3               ;                 .byte "<j"
00430Fr 3               
00430Fr 3               ; nt_asm_back_branch:
00430Fr 3               ;                 .byte 2, IM
00430Fr 3               ;                 .word nt_asm_push_a
00430Fr 3               ;                 .word xt_asm_back_branch, z_asm_back_branch
00430Fr 3               ;                 .byte "<b"
00430Fr 3               
00430Fr 3               ; nt_asm_push_a:
00430Fr 3               ;                 .byte 6, IM
00430Fr 3               ;                 .word 0000
00430Fr 3               ;                 .word xt_asm_push_a, z_asm_push_a
00430Fr 3               ;                 .byte "push-a"
00430Fr 3               
00430Fr 3               
00430Fr 3               
00430Fr 3               ; END of ASSEMBLER-WORDLIST
00430Fr 3               
00430Fr 3               ; END
00430Fr 3               
00430Fr 2                   .include "strings.s"          ; Headers of native words
00430Fr 3               ; List of Strings for Tali Forth 2
00430Fr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00430Fr 3               ; First version: 01. Apr 2016 (for Liara Forth)
00430Fr 3               ; This version: 28. Dec 2018
00430Fr 3               
00430Fr 3               ; This file is included by taliforth.asm
00430Fr 3               
00430Fr 3               ; ## GENERAL STRINGS
00430Fr 3               
00430Fr 3               ; All general strings must be zero-terminated, names start with "s_",
00430Fr 3               ; aliases with "str_"
00430Fr 3               
00430Fr 3               str_ok =              0
00430Fr 3               str_compile =         1
00430Fr 3               str_redefined =       2
00430Fr 3               str_wid_forth =       3
00430Fr 3               str_abc_lower =       4
00430Fr 3               str_abc_upper =       5
00430Fr 3               str_wid_editor =      6
00430Fr 3               str_wid_assembler =   7
00430Fr 3               str_wid_root =        8
00430Fr 3               str_see_flags =       9
00430Fr 3               str_see_nt =         10
00430Fr 3               str_see_xt =         11
00430Fr 3               str_see_size =       12
00430Fr 3               
00430Fr 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
00430Fr 3               ; to tables as error and string numbers.
00430Fr 3               string_table:
00430Fr 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
004313r 3  rr rr rr rr  
004317r 3  rr rr        
004319r 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
00431Dr 3  rr rr rr rr  
004321r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
004325r 3  rr rr rr rr  
004329r 3               
004329r 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
00432Dr 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
004331r 3  70 69 6C 65  
004335r 3  64 00        
004337r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
00433Br 3  66 69 6E 65  
00433Fr 3  64 20 00     
004342r 3               
004342r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
004346r 3  34 35 36 37  
00434Ar 3  38 39 61 62  
004366r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
00436Ar 3  34 35 36 37  
00436Er 3  38 39 41 42  
00438Ar 3               
00438Ar 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
00438Er 3  6D 62 6C 65  
004392r 3  72 20 00     
004395r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
004399r 3  6F 72 20 00  
00439Dr 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
0043A1r 3  68 20 00     
0043A4r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
0043A8r 3  20 00        
0043AAr 3               
0043AAr 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
0043AEr 3  73 20 28 43  
0043B2r 3  4F 20 41 4E  
0043C6r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
0043CAr 3  00           
0043CBr 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
0043CFr 3  00           
0043D0r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
0043D4r 3  20 28 64 65  
0043D8r 3  63 69 6D 61  
0043E1r 3               
0043E1r 3               
0043E1r 3               ; ## ERROR STRINGS
0043E1r 3               
0043E1r 3               ; All error strings must be zero-terminated, all names start with "es_",
0043E1r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
0043E1r 3               ; as well
0043E1r 3               
0043E1r 3               err_allot =        0
0043E1r 3               err_badsource =    1
0043E1r 3               err_compileonly =  2
0043E1r 3               err_defer =        3
0043E1r 3               err_divzero =      4
0043E1r 3               err_noname =       5
0043E1r 3               err_refill =       6
0043E1r 3               err_state =        7
0043E1r 3               err_syntax =       8
0043E1r 3               err_underflow =    9
0043E1r 3               err_negallot =     10
0043E1r 3               err_wordlist =     11
0043E1r 3               err_blockwords =   12
0043E1r 3               
0043E1r 3               error_table:
0043E1r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
0043E5r 3  rr rr rr rr  
0043E9r 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
0043EDr 3  rr rr rr rr  
0043F1r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
0043F5r 3  rr rr rr rr  
0043F9r 3  rr rr                .word es_blockwords                                    ; 12
0043FBr 3               
0043FBr 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
0043FFr 3  54 20 75 73  
004403r 3  69 6E 67 20  
00441Cr 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
004420r 3  67 61 6C 20  
004424r 3  53 4F 55 52  
00443Cr 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
004440r 3  72 70 72 65  
004444r 3  74 69 6E 67  
00445Dr 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
004461r 3  52 65 64 20  
004465r 3  77 6F 72 64  
00447Ar 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
00447Er 3  73 69 6F 6E  
004482r 3  20 62 79 20  
00448Br 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
00448Fr 3  69 6E 67 20  
004493r 3  66 61 69 6C  
00449Br 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
00449Fr 3  20 63 6F 75  
0044A3r 3  6C 64 20 6E  
0044C9r 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
0044CDr 3  61 64 79 20  
0044D1r 3  69 6E 20 63  
0044E1r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
0044E5r 3  66 69 6E 65  
0044E9r 3  64 20 77 6F  
0044F0r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
0044F4r 3  6B 20 75 6E  
0044F8r 3  64 65 72 66  
004500r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
004504r 3  6D 65 6D 6F  
004508r 3  72 79 20 66  
00451Cr 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
004520r 3  6F 72 64 6C  
004524r 3  69 73 74 73  
004533r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
004537r 3  73 65 20 61  
00453Br 3  73 73 69 67  
004572r 3               
004572r 3               ; ## ENVIRONMENT STRINGS
004572r 3               
004572r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
004572r 3               ; Length byte first, then the string itself that is not rpt. not
004572r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
004572r 3               ; "envs_".
004572r 3               
004572r 3               ; These return a single-cell number
004572r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
004576r 3  55 4E 54 45  
00457Ar 3  44 2D 53 54  
004582r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
004586r 3  4C 44        
004588r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
00458Cr 3  44           
00458Dr 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
004591r 3  52 45 53 53  
004595r 3  2D 55 4E 49  
00459Fr 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
0045A3r 3  4F 52 45 44  
0045A7r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
0045ABr 3  2D 43 48 41  
0045AFr 3  52           
0045B0r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
0045B4r 3  2D 4E        
0045B6r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
0045BAr 3  2D 55        
0045BCr 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
0045C0r 3  55 52 4E 2D  
0045C4r 3  53 54 41 43  
0045CFr 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
0045D3r 3  43 4B 2D 43  
0045D7r 3  45 4C 4C 53  
0045DBr 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
0045DFr 3  44 4C 49 53  
0045E3r 3  54 53        
0045E5r 3               
0045E5r 3               ; These return a double-cell number
0045E5r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
0045E9r 3  2D 44        
0045EBr 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
0045EFr 3  2D 55 44     
0045F2r 3               
0045F2r 3               ; END
0045F2r 3               
0045F2r 2               
0045F2r 2               ; High-level Forth words, see forth_code/README.md
0045F2r 2               forth_words_start:
0045F2r 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
0045F6r 2  2E 28 20 52  
0045FAr 2  65 61 64 79  
004604r 2               forth_words_end:
004604r 2               
004604r 2               ; User-defined Forth words, see forth_code/README.md
004604r 2               user_words_start:
004604r 2  20 32 30 20  .incbin "forth_code/user_words.asc"
004608r 2  63 6F 6E 73  
00460Cr 2  74 61 6E 74  
004CB0r 2               user_words_end:
004CB0r 2               
004CB0r 2               
004CB0r 2               ; =====================================================================
004CB0r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
004CB0r 2               
004CB0r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
004CB0r 2               ; at compile time so they are available at run time. Words that use this
004CB0r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
004CB0r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
004CB0r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
004CB0r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
004CB0r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
004CB0r 2               ; Bowie.
004CB0r 2               
004CB0r 2               ;               ldy #>addr      ; MSB   ; "Young"
004CB0r 2               ;               lda #<addr      ; LSB   ; "Americans"
004CB0r 2               ;               jsr cmpl_subroutine
004CB0r 2               
004CB0r 2               ; Also, we keep a routine here to compile a single byte passed through A.
004CB0r 2               
004CB0r 2               cmpl_subroutine:
004CB0r 2                   ; This is the entry point to compile JSR <ADDR>
004CB0r 2  48               pha             ; save LSB of address
004CB1r 2  A9 20            lda #$20        ; load opcode for JSR
004CB3r 2  80 03            bra cmpl_common
004CB5r 2               cmpl_jump:
004CB5r 2                   ; This is the entry point to compile JMP <ADDR>
004CB5r 2  48               pha             ; save LSB of address
004CB6r 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
004CB8r 2               cmpl_common:
004CB8r 2                   ; At this point, A contains the opcode to be compiled,
004CB8r 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
004CB8r 2                   ; the address is in Y
004CB8r 2  20 rr rr         jsr cmpl_a      ; compile opcode
004CBBr 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
004CBCr 2               cmpl_word:
004CBCr 2                   ; This is the entry point to compile a word (little-endian)
004CBCr 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
004CBFr 2  98               tya             ; fall thru for MSB
004CC0r 2               cmpl_a:
004CC0r 2                   ; This is the entry point to compile a single byte which
004CC0r 2                   ; is passed in A. The built-in assembler assumes that this
004CC0r 2                   ; routine does not modify Y.
004CC0r 2  92 rr            sta (cp)
004CC2r 2  E6 rr            inc cp
004CC4r 2  D0 02            bne _done
004CC6r 2  E6 rr            inc cp+1
004CC8r 2               _done:
004CC8r 2  60               rts
004CC9r 2               
004CC9r 2               
004CC9r 2               
004CC9r 2               ; =====================================================================
004CC9r 2               ; CODE FIELD ROUTINES
004CC9r 2               
004CC9r 2               doconst:
004CC9r 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
004CC9r 2               ; the Data Field onto the Data Stack
004CC9r 2               ; """
004CC9r 2  CA               dex             ; make room for constant
004CCAr 2  CA               dex
004CCBr 2               
004CCBr 2                   ; The value we need is stored in the two bytes after the
004CCBr 2                   ; JSR return address, which in turn is what is on top of
004CCBr 2                   ; the Return Stack
004CCBr 2  68               pla             ; LSB of return address
004CCCr 2  85 rr            sta tmp1
004CCEr 2  68               pla             ; MSB of return address
004CCFr 2  85 rr            sta tmp1+1
004CD1r 2               
004CD1r 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
004CD1r 2                   ; the return address on the 65c02
004CD1r 2  A0 01            ldy #1
004CD3r 2  B1 rr            lda (tmp1),y
004CD5r 2  95 00            sta 0,x
004CD7r 2  C8               iny
004CD8r 2  B1 rr            lda (tmp1),y
004CDAr 2  95 01            sta 1,x
004CDCr 2               
004CDCr 2                   ; This takes us back to the original caller, not the
004CDCr 2                   ; DOCONST caller
004CDCr 2  60               rts
004CDDr 2               
004CDDr 2               
004CDDr 2               dodefer:
004CDDr 2               ; """Execute a DEFER statement at runtime: Execute the address we
004CDDr 2               ; find after the caller in the Data Field
004CDDr 2               ; """
004CDDr 2                   ; The xt we need is stored in the two bytes after the JSR
004CDDr 2                   ; return address, which is what is on top of the Return
004CDDr 2                   ; Stack. So all we have to do is replace our return jump
004CDDr 2                   ; with what we find there
004CDDr 2  68               pla             ; LSB
004CDEr 2  85 rr            sta tmp1
004CE0r 2  68               pla             ; MSB
004CE1r 2  85 rr            sta tmp1+1
004CE3r 2               
004CE3r 2  A0 01            ldy #1
004CE5r 2  B1 rr            lda (tmp1),y
004CE7r 2  85 rr            sta tmp2
004CE9r 2  C8               iny
004CEAr 2  B1 rr            lda (tmp1),y
004CECr 2  85 rr            sta tmp2+1
004CEEr 2               
004CEEr 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004CF1r 2               
004CF1r 2               defer_error:
004CF1r 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004CF1r 2  A9 03            lda #err_defer
004CF3r 2  4C rr rr         jmp error
004CF6r 2               
004CF6r 2               dodoes:
004CF6r 2               ; """Execute the runtime portion of DOES>. See DOES> and
004CF6r 2               ; docs/create-does.txt for details and
004CF6r 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004CF6r 2               ; """
004CF6r 2                   ; Assumes the address of the CFA of the original defining word
004CF6r 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004CF6r 2                   ; for a later jump, adding one byte because of the way the
004CF6r 2                   ; 6502 works
004CF6r 2  7A               ply             ; LSB
004CF7r 2  68               pla             ; MSB
004CF8r 2  C8               iny
004CF9r 2  D0 01            bne @1
004CFBr 2  1A               inc
004CFCr 2               @1:
004CFCr 2  84 rr            sty tmp2
004CFEr 2  85 rr            sta tmp2+1
004D00r 2               
004D00r 2                   ; Next on the Return Stack should be the address of the PFA of
004D00r 2                   ; the calling defined word (say, the name of whatever constant we
004D00r 2                   ; just defined). Move this to the Data Stack, again adding one.
004D00r 2  CA               dex
004D01r 2  CA               dex
004D02r 2               
004D02r 2  7A               ply
004D03r 2  68               pla
004D04r 2  C8               iny
004D05r 2  D0 01            bne @2
004D07r 2  1A               inc
004D08r 2               @2:
004D08r 2  94 00            sty 0,x         ; LSB
004D0Ar 2  95 01            sta 1,x         ; MSB
004D0Cr 2               
004D0Cr 2                   ; This leaves the return address from the original main routine
004D0Cr 2                   ; on top of the Return Stack. We leave that untouched and jump
004D0Cr 2                   ; to the special code of the defining word. It's RTS instruction
004D0Cr 2                   ; will take us back to the main routine
004D0Cr 2  6C rr rr         jmp (tmp2)
004D0Fr 2               
004D0Fr 2               
004D0Fr 2               dovar:
004D0Fr 2               ; """Execute a variable: Push the address of the first bytes of
004D0Fr 2               ; the Data Field onto the stack. This is called with JSR so we
004D0Fr 2               ; can pick up the address of the calling variable off the 65c02's
004D0Fr 2               ; stack. The final RTS takes us to the original caller of the
004D0Fr 2               ; routine that itself called DOVAR. This is the default
004D0Fr 2               ; routine installed with CREATE.
004D0Fr 2               ; """
004D0Fr 2                   ; Pull the return address off the machine's stack, adding
004D0Fr 2                   ; one because of the way the 65c02 handles subroutines
004D0Fr 2  7A               ply             ; LSB
004D10r 2  68               pla             ; MSB
004D11r 2  C8               iny
004D12r 2  D0 01            bne @1
004D14r 2  1A               inc
004D15r 2               @1:
004D15r 2  CA               dex
004D16r 2  CA               dex
004D17r 2               
004D17r 2  95 01            sta 1,x
004D19r 2  98               tya
004D1Ar 2  95 00            sta 0,x
004D1Cr 2               
004D1Cr 2  60               rts
004D1Dr 2               
004D1Dr 2               ; =====================================================================
004D1Dr 2               ; LOW LEVEL HELPER FUNCTIONS
004D1Dr 2               
004D1Dr 2               byte_to_ascii:
004D1Dr 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
004D1Dr 2               .scope
004D1Dr 2  48               pha
004D1Er 2  4A               lsr             ; convert high nibble first
004D1Fr 2  4A               lsr
004D20r 2  4A               lsr
004D21r 2  4A               lsr
004D22r 2  20 rr rr         jsr _nibble_to_ascii
004D25r 2  68               pla
004D26r 2               
004D26r 2                   ; fall through to _nibble_to_ascii
004D26r 2               
004D26r 2               _nibble_to_ascii:
004D26r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004D26r 2               ; of A and and EMIT it. This does the actual work.
004D26r 2               ; """
004D26r 2  29 0F            and #$0F
004D28r 2  09 30            ora #'0'
004D2Ar 2  C9 3A            cmp #$3A        ; '9+1
004D2Cr 2  90 02            bcc @1
004D2Er 2  69 06            adc #$06
004D30r 2               
004D30r 2  4C rr rr     @1:               jmp emit_a
004D33r 2               
004D33r 2  60               rts
004D34r 2               .endscope
004D34r 2               
004D34r 2               compare_16bit:
004D34r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004D34r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004D34r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004D34r 2               ; For signed numbers, Z signals equality and N which number is larger:
004D34r 2               ;       if TOS = NOS: Z=1 and N=0
004D34r 2               ;       if TOS > NOS: Z=0 and N=0
004D34r 2               ;       if TOS < NOS: Z=0 and N=1
004D34r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004D34r 2               ;       if TOS = NOS: Z=1 and N=0
004D34r 2               ;       if TOS > NOS: Z=0 and C=1
004D34r 2               ;       if TOS < NOS: Z=0 and C=0
004D34r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004D34r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004D34r 2               ; """
004D34r 2               .scope
004D34r 2                   ; Compare LSB first to set the carry flag
004D34r 2  B5 00            lda 0,x                 ; LSB of TOS
004D36r 2  D5 02            cmp 2,x                 ; LSB of NOS
004D38r 2  F0 0A            beq _equal
004D3Ar 2               
004D3Ar 2                   ; LSBs are not equal, compare MSB
004D3Ar 2  B5 01            lda 1,x                 ; MSB of TOS
004D3Cr 2  F5 03            sbc 3,x                 ; MSB of NOS
004D3Er 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004D40r 2  70 08            bvs _overflow
004D42r 2  80 08            bra _not_equal
004D44r 2               _equal:
004D44r 2                   ; Low bytes are equal, so we compare high bytes
004D44r 2  B5 01            lda 1,x                 ; MSB of TOS
004D46r 2  F5 03            sbc 3,x                 ; MSB of NOS
004D48r 2  50 04            bvc _done
004D4Ar 2               _overflow:
004D4Ar 2                   ; Handle overflow because we use signed numbers
004D4Ar 2  49 80            eor #$80                ; complement negative flag
004D4Cr 2               _not_equal:
004D4Cr 2  09 01            ora #1                  ; if overflow, we can't be eqal
004D4Er 2               _done:
004D4Er 2  60               rts
004D4Fr 2               .endscope
004D4Fr 2               
004D4Fr 2               current_to_dp:
004D4Fr 2               ; """Look up the current (compilation) dictionary pointer
004D4Fr 2               ; in the wordlist set and put it into the dp zero-page
004D4Fr 2               ; variable. Uses A and Y.
004D4Fr 2               ; """
004D4Fr 2                   ; Determine which wordlist is current
004D4Fr 2  A0 04            ldy #current_offset
004D51r 2  B1 rr            lda (up),y      ; current is a byte variable
004D53r 2  0A               asl             ; turn it into an offset (in cells)
004D54r 2               
004D54r 2                   ; Get the dictionary pointer for that wordlist.
004D54r 2  18               clc
004D55r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004D57r 2  A8               tay
004D58r 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
004D5Ar 2  85 rr            sta dp
004D5Cr 2  C8               iny
004D5Dr 2  B1 rr            lda (up),y
004D5Fr 2  85 rr            sta dp+1
004D61r 2               
004D61r 2  60               rts
004D62r 2               
004D62r 2               
004D62r 2               dp_to_current:
004D62r 2               ; """Look up which wordlist is current and update its pointer
004D62r 2               ; with the value in dp. Uses A and Y.
004D62r 2               ; """
004D62r 2                   ; Determine which wordlist is current
004D62r 2  A0 04            ldy #current_offset
004D64r 2  B1 rr            lda (up),y      ; current is a byte variable
004D66r 2  0A               asl             ; turn it into an offset (in cells)
004D67r 2               
004D67r 2                   ; Get the dictionary pointer for that wordlist.
004D67r 2  18               clc
004D68r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004D6Ar 2  A8               tay
004D6Br 2  A5 rr            lda dp
004D6Dr 2  91 rr            sta (up),y              ; get the dp for that wordlist.
004D6Fr 2  C8               iny
004D70r 2  A5 rr            lda dp+1
004D72r 2  91 rr            sta (up),y
004D74r 2               
004D74r 2  60               rts
004D75r 2               
004D75r 2               interpret:
004D75r 2               .scope
004D75r 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
004D75r 2               ; Process one line only. Assumes that the address of name is in
004D75r 2               ; cib and the length of the whole input line string is in ciblen
004D75r 2               ; """
004D75r 2                   ; Normally we would use PARSE here with the SPACE character as
004D75r 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
004D75r 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
004D75r 2                   ; delimiters per default and skips any leading spaces, which
004D75r 2                   ; PARSE doesn't
004D75r 2               _loop:
004D75r 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
004D78r 2               
004D78r 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
004D78r 2                   ; in the line and we need to go get a new line
004D78r 2  B5 00            lda 0,x
004D7Ar 2  15 01            ora 1,x
004D7Cr 2  F0 70            beq _line_done
004D7Er 2               
004D7Er 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
004D7Er 2                   ; make a copy of the address in case it isn't a word we know and
004D7Er 2                   ; we have to go see if it is a number
004D7Er 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
004D81r 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
004D84r 2               
004D84r 2                   ; A zero signals that we didn't find a word in the Dictionary
004D84r 2  B5 00            lda 0,x
004D86r 2  15 01            ora 1,x
004D88r 2  D0 28            bne _got_name_token
004D8Ar 2               
004D8Ar 2                   ; We didn't get any nt we know of, so let's see if this is
004D8Ar 2                   ; a number.
004D8Ar 2  E8               inx                     ; ( addr u 0 -- addr u )
004D8Br 2  E8               inx
004D8Cr 2               
004D8Cr 2                   ; If the number conversion doesn't work, NUMBER will do the
004D8Cr 2                   ; complaining for us
004D8Cr 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
004D8Fr 2               
004D8Fr 2                   ; Otherweise, if we're interpreting, we're done
004D8Fr 2  A5 rr            lda state
004D91r 2  F0 E2            beq _loop
004D93r 2               
004D93r 2                   ; We're compiling, so there is a bit more work.  Check
004D93r 2                   ; status bit 5 to see if it's a single or double-cell
004D93r 2                   ; number.
004D93r 2  A9 20            lda #$20
004D95r 2  24 rr            bit status
004D97r 2  F0 0D            beq _single_number
004D99r 2               
004D99r 2                   ; It's a double cell number.  If we swap the
004D99r 2                   ; upper and lower half, we can use the literal_runtime twice
004D99r 2                   ; to compile it into the dictionary.
004D99r 2  20 rr rr         jsr xt_swap
004D9Cr 2  A0 rr            ldy #>literal_runtime
004D9Er 2  A9 rr            lda #<literal_runtime
004DA0r 2  20 rr rr         jsr cmpl_subroutine
004DA3r 2               
004DA3r 2                   ; compile our number
004DA3r 2  20 rr rr         jsr xt_comma
004DA6r 2               
004DA6r 2                   ; Fall into _single_number to process the other half.
004DA6r 2               _single_number:
004DA6r 2  A0 rr            ldy #>literal_runtime
004DA8r 2  A9 rr            lda #<literal_runtime
004DAAr 2  20 rr rr         jsr cmpl_subroutine
004DADr 2               
004DADr 2                   ; compile our number
004DADr 2  20 rr rr         jsr xt_comma
004DB0r 2               
004DB0r 2                   ; That was so much fun, let's do it again!
004DB0r 2  80 C3            bra _loop
004DB2r 2               
004DB2r 2               _got_name_token:
004DB2r 2                   ; We have a known word's nt TOS. We're going to need its xt
004DB2r 2                   ; though, which is four bytes father down.
004DB2r 2               
004DB2r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
004DB2r 2  B5 00            lda 0,x
004DB4r 2  95 04            sta 4,x
004DB6r 2  B5 01            lda 1,x
004DB8r 2  95 05            sta 5,x
004DBAr 2               
004DBAr 2  E8               inx
004DBBr 2  E8               inx
004DBCr 2  E8               inx
004DBDr 2  E8               inx                     ; ( nt )
004DBEr 2               
004DBEr 2                   ; Save a version of nt for error handling and compilation stuff
004DBEr 2  B5 00            lda 0,x
004DC0r 2  85 rr            sta tmpbranch
004DC2r 2  B5 01            lda 1,x
004DC4r 2  85 rr            sta tmpbranch+1
004DC6r 2               
004DC6r 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
004DC9r 2               
004DC9r 2                   ; See if we are in interpret or compile mode, 0 is interpret
004DC9r 2  A5 rr            lda state
004DCBr 2  D0 13            bne _compile
004DCDr 2               
004DCDr 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
004DCDr 2                   ; though, see if this isn't a compile-only word, which would be
004DCDr 2                   ; illegal. The status byte is the second one of the header.
004DCDr 2  A0 01            ldy #1
004DCFr 2  B1 rr            lda (tmpbranch),y
004DD1r 2  29 01            and #CO                 ; mask everything but Compile Only bit
004DD3r 2  F0 05            beq _interpret
004DD5r 2               
004DD5r 2  A9 02            lda #err_compileonly
004DD7r 2  4C rr rr         jmp error
004DDAr 2               
004DDAr 2               _interpret:
004DDAr 2                   ; We JSR to EXECUTE instead of calling the xt directly because
004DDAr 2                   ; the RTS of the word we're executing will bring us back here,
004DDAr 2                   ; skipping EXECUTE completely during RTS. If we were to execute
004DDAr 2                   ; xt directly, we have to fool around with the Return Stack
004DDAr 2                   ; instead, which is actually slightly slower
004DDAr 2  20 rr rr         jsr xt_execute
004DDDr 2               
004DDDr 2                   ; That's quite enough for this word, let's get the next one
004DDDr 2  4C rr rr         jmp _loop
004DE0r 2               
004DE0r 2               _compile:
004DE0r 2                   ; We're compiling! However, we need to see if this is an
004DE0r 2                   ; IMMEDIATE word, which would mean we execute it right now even
004DE0r 2                   ; during compilation mode. Fortunately, we saved the nt so life
004DE0r 2                   ; is easier. The flags are in the second byte of the header
004DE0r 2  A0 01            ldy #1
004DE2r 2  B1 rr            lda (tmpbranch),y
004DE4r 2  29 04            and #IM                 ; Mask all but IM bit
004DE6r 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
004DE8r 2               
004DE8r 2                   ; Compile the xt into the Dictionary with COMPILE,
004DE8r 2  20 rr rr         jsr xt_compile_comma
004DEBr 2  4C rr rr         jmp _loop
004DEEr 2               
004DEEr 2               _line_done:
004DEEr 2                   ; drop stuff from PARSE_NAME
004DEEr 2  E8               inx
004DEFr 2  E8               inx
004DF0r 2  E8               inx
004DF1r 2  E8               inx
004DF2r 2               
004DF2r 2  60               rts
004DF3r 2               .endscope
004DF3r 2               
004DF3r 2               
004DF3r 2               is_printable:
004DF3r 2               .scope
004DF3r 2               ; """Given a character in A, check if it is a printable ASCII
004DF3r 2               ; character in the range from $20 to $7E inclusive. Returns the
004DF3r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004DF3r 2               ; is printable. Keeps A. See
004DF3r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004DF3r 2               ; discussion of various ways to do this
004DF3r 2  C9 20            cmp #AscSP              ; $20
004DF5r 2  90 08            bcc _done
004DF7r 2  C9 7F            cmp #'~' + 1             ; $7E
004DF9r 2  B0 03            bcs _failed
004DFBr 2               
004DFBr 2  38               sec
004DFCr 2  80 01            bra _done
004DFEr 2               _failed:
004DFEr 2  18               clc
004DFFr 2               _done:
004DFFr 2  60               rts
004E00r 2               .endscope
004E00r 2               
004E00r 2               
004E00r 2               is_whitespace:
004E00r 2               .scope
004E00r 2               ; """Given a character in A, check if it is a whitespace
004E00r 2               ; character, that is, an ASCII value from 0 to 32 (where
004E00r 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004E00r 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004E00r 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004E00r 2               ; a discussion of the uses. Does not change A or Y.
004E00r 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004E02r 2  90 08            bcc _done
004E04r 2               
004E04r 2  C9 21            cmp #AscSP+1
004E06r 2  B0 03            bcs _failed
004E08r 2               
004E08r 2  38               sec
004E09r 2  80 01            bra _done
004E0Br 2               _failed:
004E0Br 2  18               clc
004E0Cr 2               _done:
004E0Cr 2  60               rts
004E0Dr 2               .endscope
004E0Dr 2               
004E0Dr 2               
004E0Dr 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
004E0Dr 2               ; required for the word. This routine flows into the generic error handling
004E0Dr 2               ; code
004E0Dr 2               underflow_1:
004E0Dr 2               ; """Make sure we have at least one cell on the Data Stack"""
004E0Dr 2  E0 FE            cpx #dsp0-1
004E0Fr 2  10 10            bpl underflow_error
004E11r 2  60               rts
004E12r 2               underflow_2:
004E12r 2               ; """Make sure we have at least two cells on the Data Stack"""
004E12r 2  E0 FC            cpx #dsp0-3
004E14r 2  10 0B            bpl underflow_error
004E16r 2  60               rts
004E17r 2               underflow_3:
004E17r 2               ; """Make sure we have at least three cells on the Data Stack"""
004E17r 2  E0 FA            cpx #dsp0-5
004E19r 2  10 06            bpl underflow_error
004E1Br 2  60               rts
004E1Cr 2               underflow_4:
004E1Cr 2               ; """Make sure we have at least four cells on the Data Stack"""
004E1Cr 2  E0 F8            cpx #dsp0-7
004E1Er 2  10 01            bpl underflow_error
004E20r 2  60               rts
004E21r 2               
004E21r 2               underflow_error:
004E21r 2                   ; Entry for COLD/ABORT/QUIT
004E21r 2  A9 09            lda #err_underflow      ; fall through to error
004E23r 2               
004E23r 2               error:
004E23r 2               ; """Given the error number in a, print the associated error string and
004E23r 2               ; call abort. Uses tmp3.
004E23r 2               ; """
004E23r 2  0A               asl
004E24r 2  A8               tay
004E25r 2  B9 rr rr         lda error_table,y
004E28r 2  85 rr            sta tmp3                ; LSB
004E2Ar 2  C8               iny
004E2Br 2  B9 rr rr         lda error_table,y
004E2Er 2  85 rr            sta tmp3+1              ; MSB
004E30r 2               
004E30r 2  20 rr rr         jsr print_common
004E33r 2  20 rr rr         jsr xt_cr
004E36r 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
004E39r 2               
004E39r 2               
004E39r 2               ; =====================================================================
004E39r 2               ; PRINTING ROUTINES
004E39r 2               
004E39r 2               ; We distinguish two types of print calls, both of which take the string number
004E39r 2               ; (see strings.asm) in A:
004E39r 2               
004E39r 2               ;       print_string       - with a line feed
004E39r 2               ;       print_string_no_lf - without a line feed
004E39r 2               
004E39r 2               ; In addition, print_common provides a lower-level alternative for error
004E39r 2               ; handling and anything else that provides the address of the
004E39r 2               ; zero-terminated string directly in tmp3. All of those routines assume that
004E39r 2               ; printing should be more concerned with size than speed, because anything to
004E39r 2               ; do with humans reading text is going to be slow.
004E39r 2               
004E39r 2               print_string_no_lf:
004E39r 2               ; """Given the number of a zero-terminated string in A, print it to the
004E39r 2               ; current output without adding a LF. Uses Y and tmp3 by falling
004E39r 2               ; through to print_common
004E39r 2               ; """
004E39r 2                   ; Get the entry from the string table
004E39r 2  0A               asl
004E3Ar 2  A8               tay
004E3Br 2  B9 rr rr         lda string_table,y
004E3Er 2  85 rr            sta tmp3                ; LSB
004E40r 2  C8               iny
004E41r 2  B9 rr rr         lda string_table,y
004E44r 2  85 rr            sta tmp3+1              ; MSB
004E46r 2               
004E46r 2                   ; fall through to print_common
004E46r 2               print_common:
004E46r 2               ; """Common print routine used by both the print functions and
004E46r 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004E46r 2               ; Y.
004E46r 2               ; """
004E46r 2               .scope
004E46r 2  A0 00            ldy #0
004E48r 2               _loop:
004E48r 2  B1 rr            lda (tmp3),y
004E4Ar 2  F0 06            beq _done               ; strings are zero-terminated
004E4Cr 2               
004E4Cr 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004E4Fr 2  C8               iny
004E50r 2  80 F6            bra _loop
004E52r 2               _done:
004E52r 2  60               rts
004E53r 2               .endscope
004E53r 2               
004E53r 2               print_string:
004E53r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004E53r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004E53r 2               ; """
004E53r 2  20 rr rr         jsr print_string_no_lf
004E56r 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
004E59r 2               
004E59r 2               
004E59r 2               print_u:
004E59r 2               ; """basic printing routine used by higher-level constructs,
004E59r 2               ; the equivalent of the forth word  0 <# #s #> type  which is
004E59r 2               ; basically u. without the space at the end. used for various
004E59r 2               ; outputs
004E59r 2               ; """
004E59r 2  20 rr rr         jsr xt_zero                     ; 0
004E5Cr 2  20 rr rr         jsr xt_less_number_sign         ; <#
004E5Fr 2  20 rr rr         jsr xt_number_sign_s            ; #S
004E62r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004E65r 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
004E68r 2               
004E68r 2               ; END
004E68r 2               
004E68r 1               
004E68r 1               kernel_init:
004E68r 1               v_nmi:
004E68r 1  A9 FF            lda #$FF
004E6Ar 1  8D 82 FF         sta DDRB
004E6Dr 1  8D 83 FF         sta DDRA
004E70r 1  9C 81 FF         stz PORTA
004E73r 1  9C 80 FF         stz PORTB
004E76r 1               .ifdef video_init
004E76r 1                   jsr video_init
004E76r 1               .endif
004E76r 1               .ifdef ps2_init
004E76r 1                   jsr ps2_init
004E76r 1               .endif
004E76r 1               .ifdef timer_init
004E76r 1  20 rr rr         jsr timer_init
004E79r 1               .endif
004E79r 1  20 rr rr         jsr acia_init
004E7Cr 1               .ifdef lcd_init
004E7Cr 1  20 rr rr         jsr lcd_init
004E7Fr 1               .endif
004E7Fr 1               .ifdef spi_init
004E7Fr 1  20 rr rr         jsr spi_init
004E82r 1               .endif
004E82r 1               .ifdef kb_init
004E82r 1  20 rr rr         jsr kb_init
004E85r 1               .endif
004E85r 1               
004E85r 1               
004E85r 1               
004E85r 1  A2 00 BD rr      printascii welcome_message
004E89r 1  rr F0 06 20  
004E8Dr 1  rr rr E8 80  
004E92r 1               
004E92r 1  4C rr rr         jmp forth
004E95r 1               
004E95r 1               platform_bye:
004E95r 1  4C rr rr         jmp platform_bye
004E98r 1               
004E98r 1               
004E98r 1               kernel_putc:
004E98r 1                   ; """Print a single character to the console. """
004E98r 1                   ;; Send_Char - send character in A out serial port.
004E98r 1                   ;; Uses: A (original value restored)
004E98r 1               send_char:
004E98r 1  48               pha
004E99r 1                   .ifdef char_out
004E99r 1                   jsr char_out
004E99r 1                   .endif
004E99r 1                   .ifdef acia_out
004E99r 1  20 rr rr         jsr acia_out
004E9Cr 1                   .endif
004E9Cr 1               send_char_exit:
004E9Cr 1               .ifdef lcd_print
004E9Cr 1  20 rr rr         jsr lcd_print
004E9Fr 1               .endif
004E9Fr 1  68               pla
004EA0r 1  60               rts
004EA1r 1               
004EA1r 1               
004EA1r 1                       ;; Get_Char - get a character from the serial port into A.
004EA1r 1                       ;; Set the carry flag if char is valid.
004EA1r 1                       ;; Return immediately with carry flag clear if no char available.
004EA1r 1                       ;; Uses: A (return value)
004EA1r 1               
004EA1r 1               Get_Char:
004EA1r 1  20 rr rr         jsr acia_getc
004EA4r 1  90 05            bcc get_ps2_char                ; check keyboard buffer if nothing from ACIA
004EA6r 1  20 rr rr         jsr check_ctrl_c
004EA9r 1  38               sec                             ; Set Carry to show we got a character
004EAAr 1  60               rts                             ; Return
004EABr 1               
004EABr 1               get_ps2_char:                       ; no ACIA char available, try to get from KB buffer
004EABr 1               .ifdef ps2_get_char
004EABr 1                   jsr ps2_get_char
004EABr 1               .endif
004EABr 1  90 02            bcc get_kb_char
004EADr 1  38               sec
004EAEr 1               
004EAEr 1  60               rts
004EAFr 1               get_kb_char:
004EAFr 1                   .ifdef kb_get_char
004EAFr 1               
004EAFr 1                   ; ldy #5
004EAFr 1                   ; jsr delay_short
004EAFr 1                   ; ply
004EAFr 1                       jsr kb_get_char_2
004EAFr 1               
004EAFr 1                   .endif
004EAFr 1               exit:                         ; Indicate no char available.
004EAFr 1  60               rts                             ; return
004EB0r 1               
004EB0r 1               kernel_getc:
004EB0r 1                   ; """Get a single character from the keyboard (waits for key).
004EB0r 1                   ; """
004EB0r 1                   ;; Get_Char_Wait - same as Get_Char only blocking.
004EB0r 1                   ;; Uses: A (return value)
004EB0r 1               Get_Char_Wait:
004EB0r 1  20 rr rr         jsr Get_Char
004EB3r 1  90 FB            bcc Get_Char_Wait
004EB5r 1  60               rts
004EB6r 1               
004EB6r 1               check_ctrl_c:
004EB6r 1                   ;; Check if we have ctrl-C character, if so jump to nmi
004EB6r 1  C9 03            cmp #$03
004EB8r 1  D0 10            bne exit_ctrl_c
004EBAr 1  A2 00 BD rr      printascii abort_message
004EBEr 1  rr F0 06 20  
004EC2r 1  rr rr E8 80  
004EC7r 1  4C rr rr         jmp xt_abort
004ECAr 1               
004ECAr 1               exit_ctrl_c:
004ECAr 1  60               rts
004ECBr 1               
004ECBr 1               
004ECBr 1               
004ECBr 1               v_irq:                          ; IRQ handler
004ECBr 1  48                   pha
004ECCr 1  5A                   phy
004ECDr 1                       ; check if bit 7 of IFR is set
004ECDr 1  AD 8D FF             lda IFR
004ED0r 1  10 0B                bpl v_kb_irq  ; Interrupt not from VIA, exit
004ED2r 1               
004ED2r 1  29 08                and #$08        ; ps2 has priority
004ED4r 1  D0 12                bne v_irq_ps2
004ED6r 1  AD 8D FF             lda IFR
004ED9r 1  29 40                and #$40
004EDBr 1  D0 0D                bne v_irq_timer
004EDDr 1               v_kb_irq:
004EDDr 1  AD 9D FF             lda KB_IFR
004EE0r 1  10 1A                bpl v_irq_exit
004EE2r 1  29 40                and #$40
004EE4r 1  D0 0F                bne v_kb_irq_timer
004EE6r 1  80 14                bra v_irq_exit
004EE8r 1               
004EE8r 1               
004EE8r 1               v_irq_ps2:
004EE8r 1                   .ifdef ps2_irq
004EE8r 1                       lda time
004EE8r 1                       sta last_ps2_time
004EE8r 1                       lda time+1
004EE8r 1                       sta last_ps2_time+1
004EE8r 1                       lda time+2
004EE8r 1                       sta last_ps2_time+2
004EE8r 1                       lda time+3
004EE8r 1                       sta last_ps2_time+3
004EE8r 1                       ; this delay is here to ensure we prevent desynchronization
004EE8r 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004EE8r 1                       ; jsr delay_short
004EE8r 1               
004EE8r 1               
004EE8r 1                       jsr ps2_irq
004EE8r 1               
004EE8r 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004EE8r 1                       ; jsr delay_short
004EE8r 1                   .endif
004EE8r 1  80 12                bra v_irq_exit
004EEAr 1               
004EEAr 1               v_irq_timer:
004EEAr 1  AD 84 FF             lda T1CL
004EEDr 1                       ; clear timer interrupt
004EEDr 1                   .ifdef timer_irq
004EEDr 1  20 rr rr             jsr timer_irq
004EF0r 1                   .endif
004EF0r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
004EF3r 1                       ; check if there is a char waiting to be printed to the lcd
004EF3r 1                       ; lda lcd_char
004EF3r 1                       ; beq v_exit
004EF3r 1                       ; jsr lcd_print
004EF3r 1                       ; stz lcd_char
004EF3r 1               
004EF3r 1               
004EF3r 1  80 07                bra v_irq_exit
004EF5r 1               v_kb_irq_timer:
004EF5r 1  AD 94 FF         lda KB_T1CL ; clear timer interrupt
004EF8r 1  E6 rr            inc kb_time
004EFAr 1  D0 00            bne v_irq_exit
004EFCr 1                   ;jsr kb_scan
004EFCr 1               v_irq_exit:
004EFCr 1  7A               ply
004EFDr 1  68               pla
004EFEr 1  40               rti
004EFFr 1               
004EFFr 1               .segment "RODATA"
000080r 1               
000080r 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", $0D, "Type 'words' for available words", 0
000084r 1  6F 6D 65 20  
000088r 1  74 6F 20 50  
0000B8r 1  0D 0A 00     abort_message: .byte AscCR, AscLF, 0
0000BBr 1               
0000BBr 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
