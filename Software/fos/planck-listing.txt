ca65 V2.18 - N/A
Main file   : platform/planck/main.s
Current file: platform/planck/main.s

000000r 1               CLOCK_SPEED = 24000000
000000r 1               
000000r 1               ram_end = $8000
000000r 1               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/via.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               VIA1_BASE   = $FF80
000000r 2               PORTB = VIA1_BASE
000000r 2               PORTA  = VIA1_BASE+1
000000r 2               DDRB = VIA1_BASE+2
000000r 2               DDRA = VIA1_BASE+3
000000r 2               
000000r 2               
000000r 2               T1CL = VIA1_BASE + 4
000000r 2               T1CH = VIA1_BASE + 5
000000r 2               T1LL = VIA1_BASE + 6
000000r 2               T1LH = VIA1_BASE + 7
000000r 2               ACR = VIA1_BASE + 11
000000r 2               PCR = VIA1_BASE + 12
000000r 2               IFR = VIA1_BASE + 13
000000r 2               IER = VIA1_BASE + 14
000000r 2               
000000r 1               .include "drivers/ps2.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               DATA = $80   ; Data is in bit 7 of PORTA
000000r 2               ; clock is on CA2
000000r 2               SHIFT = $1
000000r 2               ALT = $2
000000r 2               
000000r 2               KB_STATE_START = $0
000000r 2               KB_STATE_DATA = $1
000000r 2               KB_STATE_PARITY = $2
000000r 2               KB_STATE_STOP = $3
000000r 2               
000000r 2               KB_INIT_STATE_RESET = $0
000000r 2               KB_INIT_STATE_RESET_ACK = $1
000000r 2               KB_INIT_STATE_LEDS = $2
000000r 2               KB_INIT_STATE_LEDS_ACK = $3
000000r 2               KB_INIT_STATE_LEDS_DATA = $4
000000r 2               KB_INIT_STATE_LEDS_DATA_ACK = $5
000000r 2               
000000r 2               LSHIFT_KEY = $12
000000r 2               RSHIFT_KEY = $59
000000r 2               
000000r 2               TIMER_DELAY = $C4
000000r 2               
000000r 2               
000000r 1               .include "drivers/lcd.inc"
000000r 2               
000000r 2               ; HD 44780 driver
000000r 2               ; all pins on VIA PORTA, 4 bit mode
000000r 2               
000000r 2               ; PORTA0 is free
000000r 2               LCD_BASE = $FFC0
000000r 2               LCD_ADDR_DISABLED = LCD_BASE
000000r 2               LCD_ADDR_ENABLED = LCD_BASE + 1
000000r 2               LCD_DATA_DISABLED = LCD_BASE + 2
000000r 2               LCD_DATA_ENABLED = LCD_BASE + 3
000000r 2               
000000r 2               
000000r 2               ; A0: RS
000000r 2               ; A1: E
000000r 2               
000000r 1               .include "drivers/vga.inc"
000000r 2               VIDEO_BASE = $FFB0
000000r 2               
000000r 2               VIDEO_CTRL = VIDEO_BASE       ;// Formatted as follows |INCR_5|INCR_4|INCR_3|INCR_2|INCR_1|INCR_0|MODE_1|MODE_0|  default to LORES
000000r 2               VIDEO_ADDR_LOW = VIDEO_BASE + 1   ;// also contains the increment ||||ADDR4|ADDR_3|ADDR_2|ADDR_1|ADDR_0|
000000r 2               VIDEO_ADDR_HIGH = VIDEO_BASE + 2
000000r 2               VIDEO_DATA = VIDEO_BASE + 3
000000r 2               VIDEO_IEN = VIDEO_BASE + 4    ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_INTR = VIDEO_BASE + 5   ;// formatted as follows |VSYNC| | | | | | |HSYNC|
000000r 2               VIDEO_HSCROLL = VIDEO_BASE + 6
000000r 2               VIDEO_VSCROLL = VIDEO_BASE + 7
000000r 2               
000000r 2               VIDEO_HIRES_HCHARS = 80
000000r 2               VIDEO_HIRES_VCHARS = 60
000000r 2               
000000r 1               .include "drivers/keyboard.inc"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               
000000r 2               KB_VIA_BASE   = $FF90
000000r 2               KB_PORTB = KB_VIA_BASE
000000r 2               KB_PORTA  = KB_VIA_BASE+1
000000r 2               KB_DDRB = KB_VIA_BASE+2
000000r 2               KB_DDRA = KB_VIA_BASE+3
000000r 2               
000000r 2               
000000r 2               KB_T1CL = KB_VIA_BASE + 4
000000r 2               KB_T1CH = KB_VIA_BASE + 5
000000r 2               KB_T1LL = KB_VIA_BASE + 6
000000r 2               KB_T1LH = KB_VIA_BASE + 7
000000r 2               KB_ACR = KB_VIA_BASE + 11
000000r 2               KB_PCR = KB_VIA_BASE + 12
000000r 2               KB_IFR = KB_VIA_BASE + 13
000000r 2               KB_IER = KB_VIA_BASE + 14
000000r 2               
000000r 1               
000000r 1               .include "drivers/zp.s"
000000r 2               ; Copyright 2020 Jonathan Foucher
000000r 2               
000000r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000000r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000000r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000000r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000000r 2               ; is furnished to do so, subject to the following conditions:
000000r 2               
000000r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000000r 2               ; substantial portions of the Software.
000000r 2               
000000r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000000r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000000r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000000r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000000r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000000r 2               ; DEALINGS IN THE SOFTWARE.
000000r 2               
000000r 2               ; next_addr: .res 1
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               .segment "ZEROPAGE": zeropage
000000r 2               
000000r 2  xx xx        stack_p: .res 2
000002r 2  xx xx xx xx  time: .res 4
000006r 2  xx xx xx xx  last_ps2_time: .res 4
00000Ar 2               
00000Ar 2  xx           KB_BUF_W_PTR: .res 1
00000Br 2  xx           KB_BUF_R_PTR: .res 1
00000Cr 2  xx           control_keys: .res 1
00000Dr 2  xx           character: .res 1
00000Er 2  xx           debug: .res 1
00000Fr 2  xx xx        sd_buffer_address: .res 2
000011r 2  xx           temp_bits: .res 1
000012r 2  xx           LCD_BUF_W_PTR: .res 1
000013r 2  xx           LCD_BUF_R_PTR: .res 1
000014r 2  xx xx        fat32_filenamepointer: .res 2
000016r 2  xx           kb_temp_var: .res 1
000017r 2  xx           kb_temp_var2: .res 1
000018r 2               
000018r 1               
000018r 1               
000018r 1               
000018r 1               .segment "BSS"
000000r 1  xx xx xx xx  LCD_BUF: .res 128
000004r 1  xx xx xx xx  
000008r 1  xx xx xx xx  
000080r 1  xx xx xx xx  KB_BUF: .res 128
000084r 1  xx xx xx xx  
000088r 1  xx xx xx xx  
000100r 1               
000100r 1  xx xx xx xx  FAT_VARS: .res 24
000104r 1  xx xx xx xx  
000108r 1  xx xx xx xx  
000118r 1  xx xx        SD_TMP: .res 2
00011Ar 1               
00011Ar 1  xx           SD_CRC: .res 1
00011Br 1  xx           SD_SLAVE: .res 1
00011Cr 1  xx xx xx xx  SD_ARG: .res 4
000120r 1               
000120r 1  xx           line: .res 1
000121r 1  xx           char: .res 1
000122r 1  xx           lcd_absent: .res 1
000123r 1  xx           lcd_pos: .res 1
000124r 1  xx           has_acia: .res 1
000125r 1  xx           spi_tmp: .res 1
000126r 1  xx           spi_tmp2: .res 1
000127r 1  xx           spi_slave: .res 1
000128r 1  xx           sd_sector: .res 1
000129r 1               
000129r 1  xx           to_send: .res 1
00012Ar 1  xx           KB_STATE: .res 1
00012Br 1  xx           KB_TEMP: .res 1
00012Cr 1  xx           KB_PARITY: .res 1
00012Dr 1  xx           KB_BIT: .res 1
00012Er 1  xx           KB_INIT_STATE: .res 1
00012Fr 1  xx           KB_INIT_WAIT: .res 1
000130r 1               
000130r 1  xx           ready: .res 1
000131r 1               
000131r 1  xx           ignore_next: .res 1
000132r 1  xx xx xx xx  SD_BUF: .res $800
000136r 1  xx xx xx xx  
00013Ar 1  xx xx xx xx  
000932r 1               
000932r 1               .segment "RODATA"
000000r 1               
000000r 1               .include "drivers/keycodes.s"
000000r 2               
000000r 2               
000000r 2               ASCIITBL:
000000r 2  00               .byte $00               ; 00 no key pressed
000001r 2  89               .byte $89               ; 01 F9
000002r 2  87               .byte $87               ; 02 relocated F7
000003r 2  85               .byte $85               ; 03 F5
000004r 2  83               .byte $83               ; 04 F3
000005r 2  81               .byte $81               ; 05 F1
000006r 2  82               .byte $82               ; 06 F2
000007r 2  8C               .byte $8C               ; 07 F12
000008r 2  00               .byte $00               ; 08
000009r 2  8A               .byte $8A               ; 09 F10
00000Ar 2  88               .byte $88               ; 0A F8
00000Br 2  86               .byte $86               ; 0B F6
00000Cr 2  84               .byte $84               ; 0C F4
00000Dr 2  09               .byte $09               ; 0D tab
00000Er 2  60               .byte $60               ; 0E `~
00000Fr 2  8F               .byte $8F               ; 0F relocated Print Screen key
000010r 2  03               .byte $03               ; 10 relocated Pause/Break key
000011r 2  A0               .byte $A0               ; 11 left alt (right alt too)
000012r 2  00               .byte $00               ; 12 left shift
000013r 2  E0               .byte $E0               ; 13 relocated Alt release code
000014r 2  00               .byte $00               ; 14 left ctrl (right ctrl too)
000015r 2  71               .byte $71               ; 15 qQ
000016r 2  31               .byte $31               ; 16 1!
000017r 2  00               .byte $00               ; 17
000018r 2  00               .byte $00               ; 18
000019r 2  00               .byte $00               ; 19
00001Ar 2  7A               .byte $7A               ; 1A zZ
00001Br 2  73               .byte $73               ; 1B sS
00001Cr 2  61               .byte $61               ; 1C aA
00001Dr 2  77               .byte $77               ; 1D wW
00001Er 2  32               .byte $32               ; 1E 2@
00001Fr 2  A1               .byte $A1               ; 1F Windows 98 menu key (left side)
000020r 2  02               .byte $02               ; 20 relocated ctrl-break key
000021r 2  63               .byte $63               ; 21 cC
000022r 2  78               .byte $78               ; 22 xX
000023r 2  64               .byte $64               ; 23 dD
000024r 2  65               .byte $65               ; 24 eE
000025r 2  34               .byte $34               ; 25 4$
000026r 2  33               .byte $33               ; 26 3#
000027r 2  A2               .byte $A2               ; 27 Windows 98 menu key (right side)
000028r 2  00               .byte $00               ; 28
000029r 2  20               .byte $20               ; 29 space
00002Ar 2  76               .byte $76               ; 2A vV
00002Br 2  66               .byte $66               ; 2B fF
00002Cr 2  74               .byte $74               ; 2C tT
00002Dr 2  72               .byte $72               ; 2D rR
00002Er 2  35               .byte $35               ; 2E 5%
00002Fr 2  A3               .byte $A3               ; 2F Windows 98 option key (right click, right side)
000030r 2  00               .byte $00               ; 30
000031r 2  6E               .byte $6E               ; 31 nN
000032r 2  62               .byte $62               ; 32 bB
000033r 2  68               .byte $68               ; 33 hH
000034r 2  67               .byte $67               ; 34 gG
000035r 2  79               .byte $79               ; 35 yY
000036r 2  36               .byte $36               ; 36 6^
000037r 2  00               .byte $00               ; 37
000038r 2  00               .byte $00               ; 38
000039r 2  00               .byte $00               ; 39
00003Ar 2  6D               .byte $6D               ; 3A mM
00003Br 2  6A               .byte $6A               ; 3B jJ
00003Cr 2  75               .byte $75               ; 3C uU
00003Dr 2  37               .byte $37               ; 3D 7&
00003Er 2  38               .byte $38               ; 3E 8*
00003Fr 2  00               .byte $00               ; 3F
000040r 2  00               .byte $00               ; 40
000041r 2  2C               .byte $2C               ; 41 ,<
000042r 2  6B               .byte $6B               ; 42 kK
000043r 2  69               .byte $69               ; 43 iI
000044r 2  6F               .byte $6F               ; 44 oO
000045r 2  30               .byte $30               ; 45 0)
000046r 2  39               .byte $39               ; 46 9(
000047r 2  00               .byte $00               ; 47
000048r 2  00               .byte $00               ; 48
000049r 2  2E               .byte $2E               ; 49 .>
00004Ar 2  2F               .byte $2F               ; 4A /?
00004Br 2  6C               .byte $6C               ; 4B lL
00004Cr 2  3B               .byte $3B               ; 4C ;:
00004Dr 2  70               .byte $70               ; 4D pP
00004Er 2  2D               .byte $2D               ; 4E -_
00004Fr 2  00               .byte $00               ; 4F
000050r 2  00               .byte $00               ; 50
000051r 2  00               .byte $00               ; 51
000052r 2  27               .byte $27               ; 52 '"
000053r 2  00               .byte $00               ; 53
000054r 2  5B               .byte $5B               ; 54 [{
000055r 2  3D               .byte $3D               ; 55 =+
000056r 2  00               .byte $00               ; 56
000057r 2  00               .byte $00               ; 57
000058r 2  00               .byte $00               ; 58 caps
000059r 2  00               .byte $00               ; 59 r shift
00005Ar 2  0D               .byte $0D               ; 5A <Enter>
00005Br 2  5D               .byte $5D               ; 5B ]}
00005Cr 2  00               .byte $00               ; 5C
00005Dr 2  5C               .byte $5C               ; 5D \|
00005Er 2  00               .byte $00               ; 5E
00005Fr 2  00               .byte $00               ; 5F
000060r 2  00               .byte $00               ; 60
000061r 2  00               .byte $00               ; 61
000062r 2  00               .byte $00               ; 62
000063r 2  00               .byte $00               ; 63
000064r 2  00               .byte $00               ; 64
000065r 2  00               .byte $00               ; 65
000066r 2  08               .byte $08               ; 66 bkspace
000067r 2  00               .byte $00               ; 67
000068r 2  00               .byte $00               ; 68
000069r 2  31               .byte $31               ; 69 kp 1
00006Ar 2  2F               .byte $2f               ; 6A kp / converted from E04A in code
00006Br 2  34               .byte $34               ; 6B kp 4
00006Cr 2  37               .byte $37               ; 6C kp 7
00006Dr 2  00               .byte $00               ; 6D
00006Er 2  00               .byte $00               ; 6E
00006Fr 2  00               .byte $00               ; 6F
000070r 2  30               .byte $30               ; 70 kp 0
000071r 2  2E               .byte $2E               ; 71 kp .
000072r 2  32               .byte $32               ; 72 kp 2
000073r 2  35               .byte $35               ; 73 kp 5
000074r 2  36               .byte $36               ; 74 kp 6
000075r 2  38               .byte $38               ; 75 kp 8
000076r 2  1B               .byte $1B               ; 76 esc
000077r 2  00               .byte $00               ; 77 num lock
000078r 2  8B               .byte $8B               ; 78 F11
000079r 2  2B               .byte $2B               ; 79 kp +
00007Ar 2  33               .byte $33               ; 7A kp 3
00007Br 2  2D               .byte $2D               ; 7B kp -
00007Cr 2  2A               .byte $2A               ; 7C kp *
00007Dr 2  39               .byte $39               ; 7D kp 9
00007Er 2  8D               .byte $8D               ; 7E scroll lock
00007Fr 2  00               .byte $00               ; 7F
000080r 2                   ;
000080r 2                   ; Table for shifted scancodes
000080r 2                   ;
000080r 2  00               .byte $00               ; 80
000081r 2  C9               .byte $C9               ; 81 F9
000082r 2  C7               .byte $C7               ; 82 relocated F7
000083r 2  C5               .byte $C5               ; 83 F5 (F7 actual scancode=83)
000084r 2  C3               .byte $C3               ; 84 F3
000085r 2  C1               .byte $C1               ; 85 F1
000086r 2  C2               .byte $C2               ; 86 F2
000087r 2  CC               .byte $CC               ; 87 F12
000088r 2  00               .byte $00               ; 88
000089r 2  CA               .byte $CA               ; 89 F10
00008Ar 2  C8               .byte $C8               ; 8A F8
00008Br 2  C6               .byte $C6               ; 8B F6
00008Cr 2  C4               .byte $C4               ; 8C F4
00008Dr 2  09               .byte $09               ; 8D tab
00008Er 2  7E               .byte $7E               ; 8E `~
00008Fr 2  CF               .byte $CF               ; 8F relocated Print Screen key
000090r 2  03               .byte $03               ; 90 relocated Pause/Break key
000091r 2  A0               .byte $A0               ; 91 left alt (right alt)
000092r 2  00               .byte $00               ; 92 left shift
000093r 2  E0               .byte $E0               ; 93 relocated Alt release code
000094r 2  00               .byte $00               ; 94 left ctrl (and right ctrl)
000095r 2  51               .byte $51               ; 95 qQ
000096r 2  21               .byte $21               ; 96 1!
000097r 2  00               .byte $00               ; 97
000098r 2  00               .byte $00               ; 98
000099r 2  00               .byte $00               ; 99
00009Ar 2  5A               .byte $5A               ; 9A zZ
00009Br 2  53               .byte $53               ; 9B sS
00009Cr 2  41               .byte $41               ; 9C aA
00009Dr 2  57               .byte $57               ; 9D wW
00009Er 2  40               .byte $40               ; 9E 2@
00009Fr 2  E1               .byte $E1               ; 9F Windows 98 menu key (left side)
0000A0r 2  02               .byte $02               ; A0 relocated ctrl-break key
0000A1r 2  43               .byte $43               ; A1 cC
0000A2r 2  58               .byte $58               ; A2 xX
0000A3r 2  44               .byte $44               ; A3 dD
0000A4r 2  45               .byte $45               ; A4 eE
0000A5r 2  24               .byte $24               ; A5 4$
0000A6r 2  23               .byte $23               ; A6 3#
0000A7r 2  E2               .byte $E2               ; A7 Windows 98 menu key (right side)
0000A8r 2  00               .byte $00               ; A8
0000A9r 2  20               .byte $20               ; A9 space
0000AAr 2  56               .byte $56               ; AA vV
0000ABr 2  46               .byte $46               ; AB fF
0000ACr 2  54               .byte $54               ; AC tT
0000ADr 2  52               .byte $52               ; AD rR
0000AEr 2  25               .byte $25               ; AE 5%
0000AFr 2  E3               .byte $E3               ; AF Windows 98 option key (right click, right side)
0000B0r 2  00               .byte $00               ; B0
0000B1r 2  4E               .byte $4E               ; B1 nN
0000B2r 2  42               .byte $42               ; B2 bB
0000B3r 2  48               .byte $48               ; B3 hH
0000B4r 2  47               .byte $47               ; B4 gG
0000B5r 2  59               .byte $59               ; B5 yY
0000B6r 2  5E               .byte $5E               ; B6 6^
0000B7r 2  00               .byte $00               ; B7
0000B8r 2  00               .byte $00               ; B8
0000B9r 2  00               .byte $00               ; B9
0000BAr 2  4D               .byte $4D               ; BA mM
0000BBr 2  4A               .byte $4A               ; BB jJ
0000BCr 2  55               .byte $55               ; BC uU
0000BDr 2  26               .byte $26               ; BD 7&
0000BEr 2  2A               .byte $2A               ; BE 8*
0000BFr 2  00               .byte $00               ; BF
0000C0r 2  00               .byte $00               ; C0
0000C1r 2  3C               .byte $3C               ; C1 ,<
0000C2r 2  4B               .byte $4B               ; C2 kK
0000C3r 2  49               .byte $49               ; C3 iI
0000C4r 2  4F               .byte $4F               ; C4 oO
0000C5r 2  29               .byte $29               ; C5 0)
0000C6r 2  28               .byte $28               ; C6 9(
0000C7r 2  00               .byte $00               ; C7
0000C8r 2  00               .byte $00               ; C8
0000C9r 2  3E               .byte $3E               ; C9 .>
0000CAr 2  3F               .byte $3F               ; CA /?
0000CBr 2  4C               .byte $4C               ; CB lL
0000CCr 2  3A               .byte $3A               ; CC ;:
0000CDr 2  50               .byte $50               ; CD pP
0000CEr 2  5F               .byte $5F               ; CE -_
0000CFr 2  00               .byte $00               ; CF
0000D0r 2  00               .byte $00               ; D0
0000D1r 2  00               .byte $00               ; D1
0000D2r 2  22               .byte $22               ; D2 '"
0000D3r 2  00               .byte $00               ; D3
0000D4r 2  7B               .byte $7B               ; D4 [{
0000D5r 2  2B               .byte $2B               ; D5 =+
0000D6r 2  00               .byte $00               ; D6
0000D7r 2  00               .byte $00               ; D7
0000D8r 2  00               .byte $00               ; D8 caps
0000D9r 2  00               .byte $00               ; D9 r shift
0000DAr 2  0D               .byte $0D               ; DA <Enter>
0000DBr 2  7D               .byte $7D               ; DB ]}
0000DCr 2  00               .byte $00               ; DC
0000DDr 2  7C               .byte $7C               ; DD \|
0000DEr 2  00               .byte $00               ; DE
0000DFr 2  00               .byte $00               ; DF
0000E0r 2  00               .byte $00               ; E0
0000E1r 2  00               .byte $00               ; E1
0000E2r 2  00               .byte $00               ; E2
0000E3r 2  00               .byte $00               ; E3
0000E4r 2  00               .byte $00               ; E4
0000E5r 2  00               .byte $00               ; E5
0000E6r 2  08               .byte $08               ; E6 bkspace
0000E7r 2  00               .byte $00               ; E7
0000E8r 2  00               .byte $00               ; E8
0000E9r 2  91               .byte $91               ; E9 kp 1
0000EAr 2  2F               .byte $2f               ; EA kp / converted from E04A in code
0000EBr 2  94               .byte $94               ; EB kp 4
0000ECr 2  97               .byte $97               ; EC kp 7
0000EDr 2  00               .byte $00               ; ED
0000EEr 2  00               .byte $00               ; EE
0000EFr 2  00               .byte $00               ; EF
0000F0r 2  90               .byte $90               ; F0 kp 0
0000F1r 2  7F               .byte $7F               ; F1 kp .
0000F2r 2  92               .byte $92               ; F2 kp 2
0000F3r 2  95               .byte $95               ; F3 kp 5
0000F4r 2  96               .byte $96               ; F4 kp 6
0000F5r 2  98               .byte $98               ; F5 kp 8
0000F6r 2  1B               .byte $1B               ; F6 esc
0000F7r 2  00               .byte $00               ; F7 num lock
0000F8r 2  CB               .byte $CB               ; F8 F11
0000F9r 2  2B               .byte $2B               ; F9 kp +
0000FAr 2  93               .byte $93               ; FA kp 3
0000FBr 2  2D               .byte $2D               ; FB kp -
0000FCr 2  2A               .byte $2A               ; FC kp *
0000FDr 2  99               .byte $99               ; FD kp 9
0000FEr 2  CD               .byte $CD               ; FE scroll lock
0000FFr 2               
0000FFr 2               
0000FFr 2               
0000FFr 2               
0000FFr 1               
0000FFr 1               .import    copydata
0000FFr 1               
0000FFr 1               .segment "STARTUP"
000000r 1               
000000r 1               v_reset:
000000r 1  20 rr rr         JSR     copydata
000003r 1  4C rr rr         jmp kernel_init
000006r 1               
000006r 1               .segment "DATA"
000000r 1               
000000r 1               .include "drivers/acia.s"
000000r 2               acia_init:
000000r 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
000003r 2                                           ; set specific modes and functions
000003r 2  9C rr rr         stz has_acia
000006r 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000008r 2                   ;lda #$09               ; no parity, no echo, no Tx interrupt, Rx interrupt, enable Tx/Rx
000008r 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
00000Br 2  AD E2 FF         lda ACIA_CMD        ; load command register again
00000Er 2  C9 0B            cmp #$0B                ; if not the same
000010r 2  D0 11            bne acia_absent         ; then it means the ACIA is not connected
000012r 2  AD E1 FF         lda ACIA_STATUS         ; Read the ACAI status to
000015r 2  29 60            and #$60                ; check if present or absent
000017r 2  D0 0A            bne acia_absent
000019r 2  A9 01            lda #1
00001Br 2  8D rr rr         sta has_acia           ; remember that ACIA is here
00001Er 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
000020r 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
000020r 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
000023r 2               
000023r 2               acia_absent:
000023r 2  A0 14                ldy #20
000025r 2               aa_loop:
000025r 2  20 rr rr             jsr delay_short
000028r 2  AD E1 FF             lda ACIA_STATUS         ; Read ACIA data a few times
00002Br 2  AD E0 FF             lda ACIA_DATA           ; to try and prevent spurious characters
00002Er 2  88                   dey
00002Fr 2  D0 F4                bne aa_loop
000031r 2               aa_end:
000031r 2  60                   rts
000032r 2               
000032r 2               acia_out:
000032r 2  48               pha
000033r 2  5A               phy
000034r 2  8D E0 FF         sta ACIA_DATA
000037r 2  A0 40            ldy #$40            ;minimal delay is $02
000039r 2  20 rr rr         jsr delay_short
00003Cr 2  7A               ply
00003Dr 2  68               pla
00003Er 2  60               rts
00003Fr 2               
00003Fr 2               acia_getc:
00003Fr 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
000042r 2  29 08            and #$08                        ; Check if there is character in the receiver
000044r 2  F0 05            beq @no_char      ; Exit now if we don't get one.
000046r 2  AD E0 FF         lda ACIA_DATA
000049r 2  38               sec
00004Ar 2  60               rts
00004Br 2               @no_char:
00004Br 2  18               clc
00004Cr 2  60               rts
00004Dr 2               
00004Dr 2               acia_irq:
00004Dr 2  48               pha
00004Er 2  2C E1 FF         bit ACIA_STATUS
000051r 2  10 06            bpl @exit
000053r 2               @irq_receive:
000053r 2                   ; we now have the byte, we need to add it to the keyboard buffer
000053r 2  AD E0 FF         lda ACIA_DATA
000056r 2               
000056r 2  8D rr rr         sta KB_BUF
000059r 2                   ;sta ACIA1_DATA
000059r 2               
000059r 2               @exit:
000059r 2  68               pla
00005Ar 2  60               rts
00005Br 2               
00005Br 1               .include "drivers/timer.s"
00005Br 2               
00005Br 2               
00005Br 2               COUNTER = CLOCK_SPEED/400        ; n/s
00005Br 2               
00005Br 2               
00005Br 2               timer_init:
00005Br 2  AD 8E FF         lda IER
00005Er 2  09 C0            ora #$C0        ;enable interrupt on timer1 timeout
000060r 2  8D 8E FF         sta IER
000063r 2  A9 40            lda #$40        ; timer one free run mode
000065r 2  8D 8B FF         sta ACR
000068r 2  A9 60            lda #<COUNTER     ; set timer to low byte to calculated value from defined clock speed
00006Ar 2  8D 84 FF         sta T1CL
00006Dr 2  A9 EA            lda #>COUNTER       ; set timer to high byte to calculated value from defined clock speed
00006Fr 2               
00006Fr 2  8D 85 FF         sta T1CH
000072r 2  A9 00            lda #0              ; reset time variable
000074r 2  85 rr            sta time
000076r 2  85 rr            sta time+1
000078r 2  85 rr            sta time+2
00007Ar 2  85 rr            sta time+3
00007Cr 2  58               cli
00007Dr 2  60               rts
00007Er 2               
00007Er 2               
00007Er 2               timer_irq:
00007Er 2  E6 rr            inc time
000080r 2  F0 01            beq @inc1
000082r 2               @exit1:
000082r 2                   ; this resets the PS/2 temp variables
000082r 2                   ;jsr reset_ps2
000082r 2  60               rts
000083r 2               @inc1:
000083r 2  E6 rr            inc time+1
000085r 2  F0 02            beq @inc2
000087r 2  80 F9            bra @exit1
000089r 2               @inc2:
000089r 2  E6 rr            inc time+2
00008Br 2  F0 02            beq @inc3
00008Dr 2  80 F3            bra @exit1
00008Fr 2               @inc3:
00008Fr 2  E6 rr            inc time+3
000091r 2  80 EF            bra @exit1
000093r 2  60               rts
000094r 2               
000094r 1               .include "drivers/keyboard.s"
000094r 2               ; Copyright 2020 Jonathan Foucher
000094r 2               
000094r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000094r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000094r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000094r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000094r 2               ; is furnished to do so, subject to the following conditions:
000094r 2               
000094r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000094r 2               ; substantial portions of the Software.
000094r 2               
000094r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000094r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000094r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000094r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000094r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000094r 2               ; DEALINGS IN THE SOFTWARE.
000094r 2               
000094r 2               K_NO = 0;
000094r 2               K_GUI = 1;
000094r 2               K_SFT = 2;
000094r 2               K_CTL = 3;
000094r 2               K_ALT = 4;
000094r 2               K_CAPS = 5;
000094r 2               K_BSPC = $08;
000094r 2               K_GRV = $60;
000094r 2               K_COM = $2C;
000094r 2               K_SCLN = $3B;
000094r 2               K_ESC = $1B;
000094r 2               K_ENT = $0A
000094r 2               K_TAB = 9;
000094r 2               K_DOT = $2E
000094r 2               K_0 = $30;
000094r 2               K_1 = $31;
000094r 2               K_2 = $32;
000094r 2               K_3 = $33;
000094r 2               K_4 = $34;
000094r 2               K_5 = $35;
000094r 2               K_6 = $36;
000094r 2               K_7 = $37;
000094r 2               K_8 = $38;
000094r 2               K_9 = $39;
000094r 2               K_A = $61;
000094r 2               K_B = $62;
000094r 2               K_C = $63;
000094r 2               K_D = $64
000094r 2               K_E = $65
000094r 2               K_F = $66
000094r 2               K_G = $67
000094r 2               K_H = $68
000094r 2               K_I = $69
000094r 2               K_J = $6A
000094r 2               K_K = $6B
000094r 2               K_L = $6C
000094r 2               K_M = $6D
000094r 2               K_N = $6E;
000094r 2               K_O = $6F
000094r 2               K_P = $70
000094r 2               K_Q = $71
000094r 2               K_R = $72
000094r 2               K_S = $73
000094r 2               K_T = $74
000094r 2               K_U = $75
000094r 2               K_V = $76;
000094r 2               K_W = $77;
000094r 2               K_X = $78
000094r 2               K_Y = $79
000094r 2               K_Z = $7A;
000094r 2               
000094r 2               KB_COUNTER = CLOCK_SPEED/512
000094r 2               
000094r 2               keymap:
000094r 2  00 5C 3D 20  .byte K_NO, $5C, $3D,   $20, K_GUI,  K_CTL, K_NO, K_ALT
000098r 2  01 03 00 04  
00009Cr 2  6E 02 2E 62  .byte K_N, K_SFT, K_DOT, K_B, K_COM, K_V, K_M  , K_C
0000A0r 2  2C 76 6D 63  
0000A4r 2  6A 0A 3B 68  .byte K_J, K_ENT, K_SCLN, K_H, K_L, K_G, K_K, K_F
0000A8r 2  6C 67 6B 66  
0000ACr 2  75 0A 70 79  .byte K_U, K_ENT, K_P, K_Y, K_O, K_T, K_I, K_R
0000B0r 2  6F 74 69 72  
0000B4r 2  37 08 30 36  .byte K_7, K_BSPC, K_0, K_6, K_9, K_5, K_8, K_4
0000B8r 2  39 35 38 34  
0000BCr 2  77 33 32 65  .byte K_W, K_3, K_2, K_E, K_1, K_Q, K_ESC, K_TAB
0000C0r 2  31 71 1B 09  
0000C4r 2  7A 64 73 78  .byte K_Z,   K_D,   K_S, K_X, K_A, K_GRV, K_CAPS, K_SFT
0000C8r 2  61 60 05 02  
0000CCr 2               
0000CCr 2  xx xx xx xx  kb_pressed_keys: .res 8
0000D0r 2  xx xx xx xx  
0000D4r 2  xx           kb_pressed_keys_ptr: .res 1
0000D5r 2  xx           kb_control_keys: .res 1
0000D6r 2  xx           kb_time: .res 1
0000D7r 2  xx           kb_prev_char: .res 1
0000D8r 2  xx           kb_keypressed: .res 1
0000D9r 2               
0000D9r 2               ;Initialize the VIA for keyboard scanning
0000D9r 2               kb_init:
0000D9r 2  78             sei
0000DAr 2                 ; Set PORTA as ouput for cols
0000DAr 2  A9 FF          lda #$FF
0000DCr 2  8D 93 FF       sta KB_DDRA
0000DFr 2                 ; Set PORTB as input for rows
0000DFr 2  9C 92 FF       stz KB_DDRB
0000E2r 2                 ; reset key buffer
0000E2r 2  9C rr rr       stz kb_pressed_keys_ptr
0000E5r 2  9C rr rr       stz kb_pressed_keys
0000E8r 2  9C rr rr       stz kb_pressed_keys+1
0000EBr 2  9C rr rr       stz kb_pressed_keys+2
0000EEr 2  9C rr rr       stz kb_pressed_keys+3
0000F1r 2  9C rr rr       stz kb_pressed_keys+4
0000F4r 2  9C rr rr       stz kb_pressed_keys+5
0000F7r 2  9C rr rr       stz kb_pressed_keys+6
0000FAr 2  9C rr rr       stz kb_pressed_keys+7
0000FDr 2  9C rr rr       stz kb_time
000100r 2  9C rr rr       stz kb_prev_char
000103r 2  9C rr rr       stz kb_keypressed
000106r 2                 ; set timer
000106r 2  AD 9E FF       lda KB_IER
000109r 2  09 C0          ora #$C0        ;enable interrupt on timer1 timeout
00010Br 2  8D 9E FF       sta KB_IER
00010Er 2  A9 40          lda #$40        ; timer one free run mode
000110r 2  8D 9B FF       sta KB_ACR
000113r 2  A9 1B          lda #<KB_COUNTER     ; set timer to low byte to calculated value from defined clock speed
000115r 2  8D 94 FF       sta KB_T1CL
000118r 2  A9 B7          lda #>KB_COUNTER       ; set timer to high byte to calculated value from defined clock speed
00011Ar 2  8D 95 FF       sta KB_T1CH
00011Dr 2  58             cli
00011Er 2               
00011Er 2               
00011Er 2  60             rts
00011Fr 2               
00011Fr 2               ; Outputs are cols, inputs are rows
00011Fr 2               ; We have 8 cols and 7 rows
00011Fr 2               ; add pulldowns to rows
00011Fr 2               ; COLS are on PORTB
00011Fr 2               kb_scan:
00011Fr 2                 ; inc kb_time
00011Fr 2                 ; bne @rts
00011Fr 2  DA             phx
000120r 2  5A             phy
000121r 2  9C rr rr       stz kb_keypressed
000124r 2                 ; set pressed keys pointer to zero
000124r 2  9C rr rr       stz kb_pressed_keys_ptr
000127r 2  EE rr rr       inc kb_time               ; increment elasped time
00012Ar 2  10 06          bpl @repeat_not_expired
00012Cr 2                 ; if enough time has passed (kb_time > 128), erase prev char
00012Cr 2  9C rr rr       stz kb_prev_char
00012Fr 2  9C rr rr       stz kb_time
000132r 2               @repeat_not_expired:
000132r 2                 ; start with $40 in A and unset carry to be able to ROR
000132r 2  18             clc
000133r 2  A9 80          lda #$80
000135r 2  A2 00          ldx #0
000137r 2               @scan_col:
000137r 2  8D 91 FF       sta KB_PORTA
00013Ar 2  48             pha
00013Br 2  AD 90 FF       lda KB_PORTB
00013Er 2  F0 06          beq @row_empty
000140r 2  8D rr rr       sta kb_keypressed
000143r 2                 ; we have the current column in X and the row data in A
000143r 2  20 rr rr       jsr save_pressed_keys
000146r 2               @row_empty:
000146r 2  E8             inx
000147r 2  68             pla
000148r 2               
000148r 2  6A             ror
000149r 2  D0 EC          bne @scan_col
00014Br 2               
00014Br 2               @exit:
00014Br 2                 ; is no pressed key, reset prev key
00014Br 2  AD rr rr       lda kb_keypressed
00014Er 2  D0 06          bne @exit_nokey
000150r 2  9C rr rr       stz kb_prev_char
000153r 2  9C 81 FF       stz PORTA
000156r 2               @exit_nokey:
000156r 2  7A             ply
000157r 2  FA             plx
000158r 2               @rts:
000158r 2  60             rts
000159r 2               
000159r 2               
000159r 2               ;key_number = self.len_cols * row + col
000159r 2               
000159r 2               save_pressed_keys:
000159r 2                 ; current col is in X
000159r 2                 ; current row data is in A
000159r 2                 ; multiply X by 8 while ror A carry is unset
000159r 2               
000159r 2  86 rr          stx kb_temp_var ; save original column number
00015Br 2  A2 FF          ldx #$FF          ; start with row -1 so that the first time through it gets to 0
00015Dr 2               @ror_loop:
00015Dr 2  E8             inx
00015Er 2  6A             ror
00015Fr 2  90 FC          bcc @ror_loop   ; we don't have a keypress yet, keep looping
000161r 2               ; we have a key pressed on col X and row Y
000161r 2               ; multiply row by 8
000161r 2  8A             txa
000162r 2  18             clc
000163r 2  0A             asl
000164r 2  0A             asl
000165r 2  0A             asl   ; A now contains row * 8
000166r 2  18             clc
000167r 2  65 rr          adc kb_temp_var  ; add current column to it
000169r 2  AE rr rr       ldx kb_pressed_keys_ptr
00016Cr 2  9D rr rr       sta kb_pressed_keys, x  ; save current key position in keymap
00016Fr 2  EE rr rr       inc kb_pressed_keys_ptr
000172r 2  60             rts
000173r 2               
000173r 2               kb_get_char:
000173r 2  DA             phx
000174r 2                 ; for each position in kb_pressed_keys
000174r 2                 ; check if it is a control character
000174r 2               
000174r 2                 ; TEST
000174r 2                 ; if we have something in the first element of the buffer, set carry and put it in A
000174r 2  AE rr rr       ldx kb_pressed_keys
000177r 2  F0 17          beq @no_key
000179r 2  BD rr rr       lda keymap, x
00017Cr 2  CD rr rr       cmp kb_prev_char  ; if it's the same as a previous character
00017Fr 2  F0 0F          beq @no_char      ; do not output
000181r 2  8D rr rr       sta kb_prev_char
000184r 2  8D 81 FF       sta PORTA
000187r 2  9C rr rr       stz kb_pressed_keys
00018Ar 2  9C rr rr       stz kb_time
00018Dr 2  FA             plx
00018Er 2  38             sec
00018Fr 2  60             rts
000190r 2               @no_key:        ; no key is pressed, unset kb_prev_char
000190r 2               @no_char:
000190r 2  9C rr rr       stz kb_pressed_keys
000193r 2  FA             plx
000194r 2  18             clc
000195r 2  60             rts
000196r 2               
000196r 1               ; .include "drivers/ps2.s"
000196r 1               .include "drivers/delayroutines.s"
000196r 2               ; Copyright 2020 Jonathan Foucher
000196r 2               
000196r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000196r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000196r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000196r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000196r 2               ; is furnished to do so, subject to the following conditions:
000196r 2               
000196r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000196r 2               ; substantial portions of the Software.
000196r 2               
000196r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000196r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000196r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000196r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000196r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000196r 2               ; DEALINGS IN THE SOFTWARE.
000196r 2               
000196r 2               
000196r 2               ; this routine delays by 2304 * y + 23 cycles
000196r 2               delay:
000196r 2  DA             phx       ; 3 cycles
000197r 2  5A             phy       ; 3 cycles
000198r 2               two:
000198r 2  A2 FF          ldx #$ff  ; 2 cycles
00019Ar 2               one:
00019Ar 2  EA             nop       ; 2 cycles
00019Br 2  EA             nop       ; 2 cycles
00019Cr 2  CA             dex       ; 2 cycles
00019Dr 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
00019Fr 2  88             dey       ; 2 cycles
0001A0r 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
0001A2r 2  7A             ply       ; 4 cycles
0001A3r 2  FA             plx       ; 4 cycles
0001A4r 2  60             rts       ; 6 cycles
0001A5r 2               
0001A5r 2               ; delay is in Y register
0001A5r 2               delay_long:
0001A5r 2  48             pha
0001A6r 2  5A             phy
0001A7r 2  DA             phx
0001A8r 2  98             tya
0001A9r 2  AA             tax
0001AAr 2               delay_long_loop:
0001AAr 2  A0 FF          ldy #$ff
0001ACr 2  20 rr rr       jsr delay
0001AFr 2  CA             dex
0001B0r 2  D0 F8          bne delay_long_loop
0001B2r 2  FA             plx
0001B3r 2  7A             ply
0001B4r 2  68             pla
0001B5r 2  60             rts
0001B6r 2               
0001B6r 2               delay_short:        ; delay Y * 19 cycles
0001B6r 2  5A             phy
0001B7r 2               delay_short_loop:
0001B7r 2  EA             nop               ; 2 cycles
0001B8r 2  EA             nop               ; 2 cycles
0001B9r 2  EA             nop               ; 2 cycles
0001BAr 2  EA             nop               ; 2 cycles
0001BBr 2  EA             nop               ; 2 cycles
0001BCr 2  EA             nop               ; 2 cycles
0001BDr 2  EA             nop               ; 2 cycles
0001BEr 2               
0001BEr 2               
0001BEr 2  88             dey               ; 2 cycles
0001BFr 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
0001C1r 2  7A             ply
0001C2r 2  60             rts
0001C3r 2               
0001C3r 1               ; .include "drivers/lcd.s"
0001C3r 1               .include "drivers/spi.s"
0001C3r 2               ; SPI defines
0001C3r 2               
0001C3r 2               SS = $07   ; Slave Select with lowest 3 bits
0001C3r 2               SCK = $08   ; Clock on bit 3
0001C3r 2               MISO = $10  ; MISO on bit 4
0001C3r 2               MOSI = $20  ; MOSI on bit 5
0001C3r 2               CONF = $40  ; CONF on bit 6
0001C3r 2               
0001C3r 2               spi_init:
0001C3r 2  AD 80 FF         lda PORTB               ; load current port B
0001C6r 2  29 90            and #(DATA | MISO)      ; set everything to zero except for PS2 DATA and MISO
0001C8r 2  09 40            ora #CONF               ; set CONF high
0001CAr 2  8D 80 FF         sta PORTB               ; save to PORTB
0001CDr 2  AD 82 FF         lda DDRB                ; get current direction register
0001D0r 2  09 6F            ora #(MOSI | CONF | SCK | SS) ; set MOSI, CONF, SCK and SS as outputs
0001D2r 2  29 EF            and #($FF^MISO)                 ; set MISO as input
0001D4r 2  8D 82 FF         sta DDRB
0001D7r 2  A9 FF            lda #$FF
0001D9r 2  8D 83 FF         sta DDRA
0001DCr 2  8D 81 FF         sta PORTA
0001DFr 2               
0001DFr 2  60               rts
0001E0r 2               
0001E0r 2               spi_select:
0001E0r 2                   ; selected slave in A
0001E0r 2  29 07            and #SS                 ; mask slave select bits
0001E2r 2  8D 80 FF         sta PORTB               ; set everything low except for SS bits
0001E5r 2  8D 81 FF         sta PORTA
0001E8r 2  8D rr rr         sta spi_slave
0001EBr 2  5A               phy
0001ECr 2  A0 01            ldy #$1
0001EEr 2  20 rr rr         jsr delay_short         ; slight delay
0001F1r 2  09 40            ora #CONF               ; set CONF high to latch address
0001F3r 2  8D 80 FF         sta PORTB               ; save to PORTB
0001F6r 2  7A               ply                     ; CONF MUST stay high for the duration of the transfer
0001F7r 2  60               rts
0001F8r 2               
0001F8r 2               spi_clk_toggle:
0001F8r 2  60               rts
0001F9r 2               
0001F9r 2               spi_transceive:
0001F9r 2                   ; send data in A, received data will be in A
0001F9r 2  5A               phy
0001FAr 2                   ; save data in RAM
0001FAr 2  8D rr rr         sta spi_tmp
0001FDr 2                   ; reset X
0001FDr 2  DA               phx
0001FEr 2  A2 08            ldx #8
000200r 2                   ; reset result
000200r 2  9C rr rr         stz spi_tmp2
000203r 2               spi_send_loop:
000203r 2  0E rr rr         asl spi_tmp
000206r 2  90 08            bcc bit_unset
000208r 2               bit_set:
000208r 2  AD 80 FF         lda PORTB
00020Br 2  09 60            ora #(MOSI | CONF)
00020Dr 2  4C rr rr         jmp clock_on
000210r 2               bit_unset:
000210r 2  AD 80 FF         lda PORTB
000213r 2  29 DF            and #(($FF^MOSI) | CONF)
000215r 2               clock_on:
000215r 2                   ; set data bit
000215r 2  0D rr rr         ora spi_slave
000218r 2  8D 80 FF         sta PORTB
00021Br 2               
00021Br 2                   ; set clock on
00021Br 2  09 48            ora #(SCK | CONF)
00021Dr 2  0D rr rr         ora spi_slave
000220r 2  8D 80 FF         sta PORTB
000223r 2               
000223r 2                   ; read bit from slave, maybe add slight delay here ?
000223r 2  AD 80 FF         lda PORTB
000226r 2  29 10            and #MISO           ; mask miso bit
000228r 2  D0 07            bne spi_bit_set      ; bit is set
00022Ar 2                   ; bit is unset
00022Ar 2  18               clc
00022Br 2  2E rr rr         rol spi_tmp2
00022Er 2  4C rr rr         jmp clock_off
000231r 2               
000231r 2               spi_bit_set:
000231r 2  38               sec
000232r 2  2E rr rr         rol spi_tmp2
000235r 2               
000235r 2               
000235r 2               clock_off:
000235r 2  AD 80 FF         lda PORTB
000238r 2  29 F7            and #(($FF^SCK) | CONF)
00023Ar 2  0D rr rr         ora spi_slave
00023Dr 2  8D 80 FF         sta PORTB
000240r 2               end_loop:
000240r 2  CA               dex
000241r 2  D0 C0            bne spi_send_loop
000243r 2                   ; set data low
000243r 2  A0 01            ldy #$1
000245r 2  20 rr rr         jsr delay_short
000248r 2  AD 80 FF         lda PORTB
00024Br 2  0D rr rr         ora spi_slave
00024Er 2  29 DF            and #(($FF^MOSI) | CONF)
000250r 2  8D 80 FF         sta PORTB
000253r 2  FA               plx
000254r 2  7A               ply
000255r 2  AD rr rr         lda spi_tmp2
000258r 2  60               rts
000259r 2               
000259r 1               .include "drivers/sd.s"
000259r 2               ; SD card driver
000259r 2               
000259r 2               ; SD card initialization routine
000259r 2               ; http://elm-chan.org/docs/mmc/mmc_e.html#spiinit
000259r 2               
000259r 2               sd_init:                    ; slave address in A
000259r 2  8D rr rr         sta SD_SLAVE             ; save slave address for later use
00025Cr 2  DA               phx
00025Dr 2  20 rr rr         jsr spi_init                ; init SPI system
000260r 2  A9 00            lda #0
000262r 2  20 rr rr         jsr spi_select          ; DEselect slave
000265r 2  8D rr rr         sta SD_ARG
000268r 2  8D rr rr         sta SD_ARG+1            ; clear command argument
00026Br 2  8D rr rr         sta SD_ARG+2
00026Er 2  8D rr rr         sta SD_ARG+3
000271r 2  A9 95            lda #$95
000273r 2  8D rr rr         sta SD_CRC              ; set CRC for CMD0
000276r 2                   ; clear SD buffer
000276r 2  A2 FF            ldx #$FF
000278r 2               clear_sd_buf_loop1:
000278r 2  9E rr rr         stz SD_BUF, X
00027Br 2  CA               dex
00027Cr 2  D0 FA            bne clear_sd_buf_loop1
00027Er 2               
00027Er 2  CA               dex
00027Fr 2               clear_sd_buf_loop2:
00027Fr 2  9E rr rr         stz SD_BUF+256, x
000282r 2  CA               dex
000283r 2  D0 FA            bne clear_sd_buf_loop2
000285r 2               
000285r 2                   ; send 10 bytes of $FF With SD card deselected
000285r 2               
000285r 2  A2 0A            ldx #10
000287r 2               init_loop:
000287r 2  A9 FF            lda #$FF
000289r 2  20 rr rr         jsr spi_transceive
00028Cr 2  CA               dex
00028Dr 2  D0 F8            bne init_loop
00028Fr 2               
00028Fr 2  20 rr rr         jsr sd_cmd_0            ; set SD card idle state
000292r 2  C9 01            cmp #$01                ; Check for idle state
000294r 2  D0 55            bne sd_error
000296r 2  20 rr rr         jsr sd_cmd_8            ; SEND_IF_COND	For only SDC V2. Check voltage range.
000299r 2  C9 01            cmp #$01                ; Check for idle state
00029Br 2  D0 4E            bne sd_error
00029Dr 2                   ; TODO check if long response is $01AA
00029Dr 2               
00029Dr 2                   ; wait for card to be initialized
00029Dr 2  A2 FF            ldx #$ff    ; Max times to loop
00029Fr 2  9C rr rr         stz SD_ARG
0002A2r 2  9C rr rr         stz SD_ARG+1
0002A5r 2  9C rr rr         stz SD_ARG+2
0002A8r 2  9C rr rr         stz SD_ARG+3
0002ABr 2               sd_init_loop2:
0002ABr 2  CA               dex
0002ACr 2  F0 3D            beq sd_error
0002AEr 2  9C rr rr         stz SD_ARG+3
0002B1r 2  A9 37            lda #55
0002B3r 2  20 rr rr         jsr sd_command
0002B6r 2  A9 40            lda #$40
0002B8r 2  8D rr rr         sta SD_ARG+3
0002BBr 2  A9 29            lda #41
0002BDr 2  20 rr rr         jsr sd_command
0002C0r 2               
0002C0r 2  D0 E9            bne sd_init_loop2
0002C2r 2               
0002C2r 2  A9 3A            lda #58
0002C4r 2  20 rr rr         jsr sd_command
0002C7r 2  AD rr rr         lda SD_BUF
0002CAr 2  29 40            and #$40
0002CCr 2  F0 07            beq force_block_size    ; CCS bit is unset, force block addressing
0002CEr 2               sd_init_exit_success:
0002CEr 2  FA               plx
0002CFr 2  9C rr rr         stz SD_CRC              ; reset CRC to zero
0002D2r 2  A9 00            lda #0
0002D4r 2               
0002D4r 2  60               rts
0002D5r 2               
0002D5r 2               force_block_size:
0002D5r 2  9C rr rr         stz SD_ARG
0002D8r 2  9C rr rr         stz SD_ARG+1
0002DBr 2  A9 02            lda #$2
0002DDr 2  8D rr rr         sta SD_ARG+2
0002E0r 2  9C rr rr         stz SD_ARG+3    ; set block size to $200 (512 bytes)
0002E3r 2  A9 10            lda #$10
0002E5r 2  20 rr rr         jsr sd_command
0002E8r 2  4C rr rr         jmp sd_init_exit_success
0002EBr 2               
0002EBr 2               sd_error:
0002EBr 2  FA               plx
0002ECr 2  A9 01            lda #1
0002EEr 2  60               rts
0002EFr 2               
0002EFr 2               sd_command:         ; command index is in A
0002EFr 2  29 3F            and #$3F        ; only keep low 6 bits
0002F1r 2  8D rr rr         sta SD_TMP
0002F4r 2  09 40            ora #$40        ; 0 and 1 to most significant bits
0002F6r 2               
0002F6r 2                   ; Select chip
0002F6r 2  20 rr rr         jsr sd_command_start
0002F9r 2               
0002F9r 2  20 rr rr         jsr spi_transceive  ; send command index
0002FCr 2                   ; command argument is in SD_ARG
0002FCr 2                   ; SPI is big endian, so reverse argument order
0002FCr 2  AD rr rr         lda SD_ARG + 3
0002FFr 2  20 rr rr         jsr spi_transceive
000302r 2  AD rr rr         lda SD_ARG+2
000305r 2  20 rr rr         jsr spi_transceive
000308r 2  AD rr rr         lda SD_ARG+1
00030Br 2  20 rr rr         jsr spi_transceive
00030Er 2  AD rr rr         lda SD_ARG
000311r 2  20 rr rr         jsr spi_transceive
000314r 2  AD rr rr         lda SD_CRC          ; send hardcoded CRC if available
000317r 2  20 rr rr         jsr spi_transceive
00031Ar 2               
00031Ar 2                   ; wait for a zero to be received in the top bit of the response
00031Ar 2               sd_response_wait_loop:
00031Ar 2  A9 FF            lda #$FF
00031Cr 2  20 rr rr         jsr spi_transceive
00031Fr 2  30 F9            bmi sd_response_wait_loop           ; if high bit of response is 1, keep going
000321r 2               
000321r 2  48               pha
000322r 2               
000322r 2                   ; Maybe we should handle the case where the response is an R1b, i.e. "It is an R1 response followed by busy flag (DO is driven to low as long as internal process is in progress). The host controller should wait for end of the process until DO goes high (a 0xFF is received)." (only for CMD12)
000322r 2               
000322r 2                   ; get 32 bits of response for CMD 8 and CMD 58
000322r 2  AD rr rr         lda SD_TMP
000325r 2  C9 08            cmp #8
000327r 2  F0 0D            beq long_response
000329r 2  C9 3A            cmp #58
00032Br 2  F0 09            beq long_response
00032Dr 2  C9 11            cmp #$11
00032Fr 2  F0 03            beq sd_command_exit_no_end
000331r 2               
000331r 2               sd_command_exit:
000331r 2  20 rr rr         jsr sd_command_end
000334r 2               sd_command_exit_no_end:
000334r 2  68               pla
000335r 2                   ; return the response
000335r 2  60               rts
000336r 2               
000336r 2               long_response:
000336r 2  A9 FF            lda #$FF
000338r 2  20 rr rr         jsr spi_transceive
00033Br 2  8D rr rr         sta SD_BUF
00033Er 2  A9 FF            lda #$FF
000340r 2  20 rr rr         jsr spi_transceive
000343r 2  8D rr rr         sta SD_BUF+1
000346r 2  A9 FF            lda #$FF
000348r 2  20 rr rr         jsr spi_transceive
00034Br 2  8D rr rr         sta SD_BUF+2
00034Er 2  A9 FF            lda #$FF
000350r 2  20 rr rr         jsr spi_transceive
000353r 2  8D rr rr         sta SD_BUF+3
000356r 2  4C rr rr         jmp sd_command_exit
000359r 2               
000359r 2               ; send SD card CMD0
000359r 2               sd_cmd_0:
000359r 2  A9 95            lda #$95
00035Br 2  8D rr rr         sta SD_CRC
00035Er 2  9C rr rr         stz SD_ARG
000361r 2  9C rr rr         stz SD_ARG+1
000364r 2  9C rr rr         stz SD_ARG+2
000367r 2  9C rr rr         stz SD_ARG+3
00036Ar 2  A9 00            lda #0
00036Cr 2  20 rr rr         jsr sd_command
00036Fr 2  60               rts
000370r 2               
000370r 2               ; send SD card CMD8
000370r 2               sd_cmd_8:
000370r 2  A9 87            lda #$87
000372r 2  8D rr rr         sta SD_CRC
000375r 2                   ; store in little endian
000375r 2                   ; will be converted to big endian when sending command
000375r 2  9C rr rr         stz SD_ARG+3
000378r 2  9C rr rr         stz SD_ARG+2
00037Br 2  A9 01            lda #1
00037Dr 2  8D rr rr         sta SD_ARG+1
000380r 2  A9 AA            lda #$AA
000382r 2  8D rr rr         sta SD_ARG
000385r 2  A9 48            lda #$48
000387r 2  20 rr rr         jsr sd_command
00038Ar 2               
00038Ar 2  60               rts
00038Br 2               
00038Br 2               sd_command_start:
00038Br 2  48               pha                         ; Save A
00038Cr 2  AD rr rr         lda SD_SLAVE
00038Fr 2  20 rr rr         jsr spi_select
000392r 2  68               pla                         ; Restore A
000393r 2  60               rts
000394r 2               
000394r 2               sd_command_end:
000394r 2  48               pha
000395r 2  A9 00            lda #0
000397r 2  20 rr rr         jsr spi_select
00039Ar 2  A9 FF            lda #$FF
00039Cr 2  20 rr rr         jsr spi_transceive      ; Send $FF without SD selected
00039Fr 2  68               pla
0003A0r 2  60               rts
0003A1r 2               
0003A1r 2               
0003A1r 2               sd_readsector:
0003A1r 2                   ; Read a sector from the SD card.  A sector is 512 bytes.
0003A1r 2                   ;
0003A1r 2                   ; Parameters:
0003A1r 2                   ;    sd_sector   32-bit sector number
0003A1r 2                   ;    sd_buffer_address     address of buffer to receive data
0003A1r 2  DA               phx
0003A2r 2  20 rr rr         jsr sd_command_start
0003A5r 2                   ; Command 17, arg is sector number, crc not checked
0003A5r 2  A9 11            lda #$11                    ; CMD17 - READ_SINGLE_BLOCK
0003A7r 2  20 rr rr         jsr sd_command
0003AAr 2               
0003AAr 2  C9 00            cmp #0              ; Check if command accepted by card
0003ACr 2  D0 29            bne @fail
0003AEr 2  A2 FF            ldx #$FF
0003B0r 2               @feloop:
0003B0r 2  CA               dex
0003B1r 2  F0 24            beq @fail           ; the card took too long to get ready
0003B3r 2  A9 FF            lda #$FF
0003B5r 2  20 rr rr         jsr spi_transceive
0003B8r 2  C9 FE            cmp #$FE            ; are we about to receive data ?
0003BAr 2  D0 F4            bne @feloop
0003BCr 2               
0003BCr 2                   ; Read page by page
0003BCr 2  20 rr rr         jsr readpage
0003BFr 2  E6 rr            inc sd_buffer_address+1
0003C1r 2  20 rr rr         jsr readpage
0003C4r 2  C6 rr            dec sd_buffer_address+1
0003C6r 2               
0003C6r 2  A9 FF            lda #$FF
0003C8r 2  20 rr rr         jsr spi_transceive      ; read and discard CRC
0003CBr 2  A9 FF            lda #$FF
0003CDr 2  20 rr rr         jsr spi_transceive
0003D0r 2  20 rr rr         jsr sd_command_end
0003D3r 2  FA               plx
0003D4r 2  A9 00            lda #0
0003D6r 2  60               rts
0003D7r 2               
0003D7r 2               @fail:
0003D7r 2                   ; return 1 means fail
0003D7r 2  20 rr rr         jsr sd_command_end
0003DAr 2  FA               plx
0003DBr 2  A9 01            lda #1
0003DDr 2  60               rts
0003DEr 2               
0003DEr 2               readpage:
0003DEr 2                   ; Read 256 bytes to the address at zp_sd_address
0003DEr 2  5A               phy
0003DFr 2  A0 00            ldy #0
0003E1r 2               @readloop:
0003E1r 2  A9 FF            lda #$FF
0003E3r 2  20 rr rr         jsr spi_transceive
0003E6r 2  91 rr            sta (sd_buffer_address),y
0003E8r 2  C8               iny
0003E9r 2  D0 F6            bne @readloop
0003EBr 2  7A               ply
0003ECr 2  60               rts
0003EDr 2               
0003EDr 2               sd_init_success_message:
0003EDr 2  0D 53 44 20      .byte $0D,"SD init OK", $0D, 0
0003F1r 2  69 6E 69 74  
0003F5r 2  20 4F 4B 0D  
0003FAr 2               
0003FAr 2               sd_init_error_message:
0003FAr 2  0D 53 44 20      .byte $0D,"SD init FAIL", $0D, 7, 0
0003FEr 2  69 6E 69 74  
000402r 2  20 46 41 49  
00040Ar 2               
00040Ar 2               sd_read_error_message:
00040Ar 2  0D 53 44 20      .byte $0D,"SD read FAIL", $0D, 7, 0
00040Er 2  72 65 61 64  
000412r 2  20 46 41 49  
00041Ar 2               
00041Ar 1               ; .include "drivers/vga.s"
00041Ar 1               .include "drivers/fat32.s"
00041Ar 2               
00041Ar 2               ; PARTITION TYPE
00041Ar 2               ; 00h 	Unknown or Nothing
00041Ar 2               ; 01h 	12-bit FAT
00041Ar 2               ; 04h 	16-bit FAT (Partition Smallerthan 32MB)
00041Ar 2               ; 05h 	Extended MS-DOS Partition
00041Ar 2               ; 06h 	16-bit FAT (Partition Largerthan 32MB)
00041Ar 2               ; 0Bh 	32-bit FAT (Partition Up to2048GB)
00041Ar 2               ; 0Ch 	Same as 0BH, but uses LBA1 13h Extensions
00041Ar 2               ; 0Eh 	Same as 06H, but uses LBA1 13h Extensions
00041Ar 2               ; 0Fh 	Same as 05H, but uses LBA1 13h Extensions
00041Ar 2               FSTYPE_FAT32 = $0B
00041Ar 2               FSTYPE_FAT32_1 = $0C
00041Ar 2               fat32_readbuffer = SD_BUF
00041Ar 2               
00041Ar 2               fat32_fatstart          = FAT_VARS + $00  ; 4 bytes
00041Ar 2               fat32_datastart         = FAT_VARS + $04  ; 4 bytes
00041Ar 2               fat32_rootcluster       = FAT_VARS + $08  ; 4 bytes
00041Ar 2               fat32_sectorspercluster = FAT_VARS + $0c  ; 1 byte
00041Ar 2               fat32_pendingsectors    = FAT_VARS + $0d  ; 1 byte
00041Ar 2               fat32_address           = FAT_VARS + $0e  ; 2 bytes
00041Ar 2               fat32_nextcluster       = FAT_VARS + $10  ; 4 bytes
00041Ar 2               fat32_bytesremaining    = line; FAT_VARS + $14  ; 4 bytes
00041Ar 2               
00041Ar 2               
00041Ar 2               
00041Ar 2               fat32_init:
00041Ar 2                   ; Initialize the module - read the MBR etc, find the partition,
00041Ar 2                   ; and set up the variables ready for navigating the filesystem
00041Ar 2               
00041Ar 2                   ; Read the MBR and extract pertinent information
00041Ar 2  DA               phx
00041Br 2               
00041Br 2                   ; Sector 0
00041Br 2  A9 00            lda #0
00041Dr 2  8D rr rr         sta SD_ARG
000420r 2  8D rr rr         sta SD_ARG+1
000423r 2  8D rr rr         sta SD_ARG+2
000426r 2  8D rr rr         sta SD_ARG+3
000429r 2               
000429r 2                   ; Target buffer
000429r 2  A9 rr            lda #<fat32_readbuffer
00042Br 2  85 rr            sta sd_buffer_address
00042Dr 2  A9 rr            lda #>fat32_readbuffer
00042Fr 2  85 rr            sta sd_buffer_address+1
000431r 2               
000431r 2                   ; Do the read
000431r 2  20 rr rr         jsr sd_readsector
000434r 2               
000434r 2                   ; Check some things
000434r 2  AD rr rr         lda fat32_readbuffer+510 ; Boot sector signature 55
000437r 2  C9 55            cmp #$55
000439r 2  D0 3B            bne @fail
00043Br 2  AD rr rr         lda fat32_readbuffer+511 ; Boot sector signature aa
00043Er 2  C9 AA            cmp #$aa
000440r 2  D0 34            bne @fail
000442r 2               
000442r 2                   ; Find a FAT32 partition
000442r 2  A2 00            ldx #0
000444r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000447r 2  C9 0B            cmp #FSTYPE_FAT32
000449r 2  F0 2E            beq @foundpart
00044Br 2  C9 0C            cmp #FSTYPE_FAT32_1
00044Dr 2  F0 2A            beq @foundpart
00044Fr 2  A2 10            ldx #$10
000451r 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000454r 2  C9 0B            cmp #FSTYPE_FAT32
000456r 2  F0 21            beq @foundpart
000458r 2  C9 0C            cmp #FSTYPE_FAT32_1
00045Ar 2  F0 1D            beq @foundpart
00045Cr 2               
00045Cr 2  A2 20            ldx #$20
00045Er 2  BD rr rr         lda fat32_readbuffer+$1C2, x
000461r 2  C9 0B            cmp #FSTYPE_FAT32
000463r 2  F0 14            beq @foundpart
000465r 2  C9 0C            cmp #FSTYPE_FAT32_1
000467r 2  F0 10            beq @foundpart
000469r 2               
000469r 2  A2 30            ldx #$30
00046Br 2  BD rr rr         lda fat32_readbuffer+$1C2, x
00046Er 2  C9 0B            cmp #FSTYPE_FAT32
000470r 2  F0 07            beq @foundpart
000472r 2  C9 0C            cmp #FSTYPE_FAT32_1
000474r 2  F0 03            beq @foundpart
000476r 2               
000476r 2               
000476r 2               @fail:
000476r 2  4C rr rr         jmp @error
000479r 2               
000479r 2               @foundpart:
000479r 2                   ; Read the FAT32 LBA BEGIN
000479r 2               
000479r 2  BD rr rr         lda fat32_readbuffer + $1C6,x
00047Cr 2  8D rr rr         sta SD_ARG
00047Fr 2  BD rr rr         lda fat32_readbuffer+$1C7,x
000482r 2  8D rr rr         sta SD_ARG+1
000485r 2  BD rr rr         lda fat32_readbuffer+$1C8,x
000488r 2  8D rr rr         sta SD_ARG+2
00048Br 2  BD rr rr         lda fat32_readbuffer+$1C9,x
00048Er 2  8D rr rr         sta SD_ARG+3
000491r 2               
000491r 2  20 rr rr         jsr sd_readsector   ; read FAT32 Volume ID block
000494r 2  C9 01            cmp #1              ; readsector returns 1 on failure
000496r 2  F0 DE            beq @fail
000498r 2               
000498r 2                   ; Check some things
000498r 2  AD rr rr         lda fat32_readbuffer+510 ; FAT32 Volume ID sector signature 55
00049Br 2  C9 55            cmp #$55
00049Dr 2  D0 D7            bne @fail
00049Fr 2  AD rr rr         lda fat32_readbuffer+511 ; FAT32 Volume ID sector signature aa
0004A2r 2  C9 AA            cmp #$aa
0004A4r 2  D0 D0            bne @fail
0004A6r 2               
0004A6r 2  AD rr rr         lda fat32_readbuffer+$11 ; RootEntCnt should be 0 for FAT32
0004A9r 2  0D rr rr         ora fat32_readbuffer+$12
0004ACr 2  D0 C8            bne @fail
0004AEr 2               
0004AEr 2  AD rr rr         lda fat32_readbuffer+$13 ; TotSec16 should be 0 for FAT32
0004B1r 2  0D rr rr         ora fat32_readbuffer+$14
0004B4r 2  D0 C0            bne @fail
0004B6r 2               
0004B6r 2                   ; Check bytes per filesystem sector, it should be 512 for any SD card that supports FAT32
0004B6r 2  AD rr rr         lda fat32_readbuffer+$0B ; low byte should be zero
0004B9r 2  D0 BB            bne @fail
0004BBr 2  AD rr rr         lda fat32_readbuffer+$0C ; high byte is 2 (512), 4, 8, or 16
0004BEr 2  C9 02            cmp #2
0004C0r 2  D0 B4            bne @fail
0004C2r 2               
0004C2r 2                   ; Calculate the starting sector of the FAT
0004C2r 2  18               clc
0004C3r 2  AD rr rr         lda SD_ARG
0004C6r 2  6D rr rr         adc fat32_readbuffer+$0E    ; reserved sectors lo
0004C9r 2  8D rr rr         sta fat32_fatstart
0004CCr 2  8D rr rr         sta fat32_datastart
0004CFr 2  AD rr rr         lda SD_ARG+1
0004D2r 2  6D rr rr         adc fat32_readbuffer+$0F    ; reserved sectors hi
0004D5r 2  8D rr rr         sta fat32_fatstart+1
0004D8r 2  8D rr rr         sta fat32_datastart+1
0004DBr 2  AD rr rr         lda SD_ARG+2
0004DEr 2  69 00            adc #0
0004E0r 2  8D rr rr         sta fat32_fatstart+2
0004E3r 2  8D rr rr         sta fat32_datastart+2
0004E6r 2  AD rr rr         lda SD_ARG+3
0004E9r 2  69 00            adc #0
0004EBr 2  8D rr rr         sta fat32_fatstart+3
0004EEr 2  8D rr rr         sta fat32_datastart+3
0004F1r 2               
0004F1r 2                   ; Calculate the starting sector of the data area
0004F1r 2  AE rr rr         ldx fat32_readbuffer+16   ; number of FATs
0004F4r 2               @skipfatsloop:
0004F4r 2  18               clc
0004F5r 2  AD rr rr         lda fat32_datastart
0004F8r 2  6D rr rr         adc fat32_readbuffer+36 ; fatsize 0
0004FBr 2  8D rr rr         sta fat32_datastart
0004FEr 2  AD rr rr         lda fat32_datastart+1
000501r 2  6D rr rr         adc fat32_readbuffer+37 ; fatsize 1
000504r 2  8D rr rr         sta fat32_datastart+1
000507r 2  AD rr rr         lda fat32_datastart+2
00050Ar 2  6D rr rr         adc fat32_readbuffer+38 ; fatsize 2
00050Dr 2  8D rr rr         sta fat32_datastart+2
000510r 2  AD rr rr         lda fat32_datastart+3
000513r 2  6D rr rr         adc fat32_readbuffer+39 ; fatsize 3
000516r 2  8D rr rr         sta fat32_datastart+3
000519r 2  CA               dex
00051Ar 2  D0 D8            bne @skipfatsloop
00051Cr 2               
00051Cr 2                   ; Sectors-per-cluster is a power of two from 1 to 128
00051Cr 2  AD rr rr         lda fat32_readbuffer+13
00051Fr 2  8D rr rr         sta fat32_sectorspercluster
000522r 2               
000522r 2                   ; Remember the root cluster
000522r 2  AD rr rr         lda fat32_readbuffer+44
000525r 2  8D rr rr         sta fat32_rootcluster
000528r 2  AD rr rr         lda fat32_readbuffer+45
00052Br 2  8D rr rr         sta fat32_rootcluster+1
00052Er 2  AD rr rr         lda fat32_readbuffer+46
000531r 2  8D rr rr         sta fat32_rootcluster+2
000534r 2  AD rr rr         lda fat32_readbuffer+47
000537r 2  8D rr rr         sta fat32_rootcluster+3
00053Ar 2               
00053Ar 2  FA               plx
00053Br 2  A9 00            lda #0
00053Dr 2  60               rts
00053Er 2               
00053Er 2               @error:
00053Er 2  FA               plx
00053Fr 2  A9 01            lda #1
000541r 2  60               rts
000542r 2               
000542r 2               
000542r 2               fat32_seekcluster:
000542r 2  5A               phy
000543r 2                   ; Gets ready to read fat32_nextcluster, and advances it according to the FAT
000543r 2               
000543r 2                   ; FAT sector = (cluster*4) / 512 = (cluster*2) / 256
000543r 2  AD rr rr         lda fat32_nextcluster
000546r 2  0A               asl
000547r 2  AD rr rr         lda fat32_nextcluster+1
00054Ar 2  2A               rol
00054Br 2  8D rr rr         sta SD_ARG
00054Er 2  AD rr rr         lda fat32_nextcluster+2
000551r 2  2A               rol
000552r 2  8D rr rr         sta SD_ARG+1
000555r 2  AD rr rr         lda fat32_nextcluster+3
000558r 2  2A               rol
000559r 2  8D rr rr         sta SD_ARG+2
00055Cr 2                   ; note: cluster numbers never have the top bit set, so no carry can occur
00055Cr 2                   ; Add FAT starting sector
00055Cr 2  AD rr rr         lda SD_ARG
00055Fr 2  6D rr rr         adc fat32_fatstart
000562r 2  8D rr rr         sta SD_ARG
000565r 2  AD rr rr         lda SD_ARG+1
000568r 2  6D rr rr         adc fat32_fatstart+1
00056Br 2  8D rr rr         sta SD_ARG+1
00056Er 2  AD rr rr         lda SD_ARG+2
000571r 2  6D rr rr         adc fat32_fatstart+2
000574r 2  8D rr rr         sta SD_ARG+2
000577r 2  A9 00            lda #0
000579r 2  6D rr rr         adc fat32_fatstart+3
00057Cr 2  8D rr rr         sta SD_ARG+3
00057Fr 2                   ; Target buffer
00057Fr 2  A9 rr            lda #<fat32_readbuffer
000581r 2  85 rr            sta sd_buffer_address
000583r 2  A9 rr            lda #>fat32_readbuffer
000585r 2  85 rr            sta sd_buffer_address+1
000587r 2                   ; Read the sector from the FAT
000587r 2  20 rr rr         jsr sd_readsector
00058Ar 2               
00058Ar 2                   ; Before using this FAT data, set currentsector ready to read the cluster itself
00058Ar 2                   ; We need to multiply the cluster number minus two by the number of sectors per
00058Ar 2                   ; cluster, then add the data region start sector
00058Ar 2               
00058Ar 2                   ; Subtract two from cluster number
00058Ar 2  38               sec
00058Br 2  AD rr rr         lda fat32_nextcluster
00058Er 2  E9 02            sbc #2
000590r 2  8D rr rr         sta SD_ARG
000593r 2  AD rr rr         lda fat32_nextcluster+1
000596r 2  E9 00            sbc #0
000598r 2  8D rr rr         sta SD_ARG+1
00059Br 2  AD rr rr         lda fat32_nextcluster+2
00059Er 2  E9 00            sbc #0
0005A0r 2  8D rr rr         sta SD_ARG+2
0005A3r 2  AD rr rr         lda fat32_nextcluster+3
0005A6r 2  E9 00            sbc #0
0005A8r 2  8D rr rr         sta SD_ARG+3
0005ABr 2               
0005ABr 2                   ; Multiply by sectors-per-cluster which is a power of two between 1 and 128
0005ABr 2  AD rr rr         lda fat32_sectorspercluster
0005AEr 2               @spcshiftloop:
0005AEr 2  4A               lsr
0005AFr 2  B0 0F            bcs @spcshiftloopdone
0005B1r 2  0E rr rr         asl SD_ARG
0005B4r 2  2E rr rr         rol SD_ARG+1
0005B7r 2  2E rr rr         rol SD_ARG+2
0005BAr 2  2E rr rr         rol SD_ARG+3
0005BDr 2  4C rr rr         jmp @spcshiftloop
0005C0r 2               @spcshiftloopdone:
0005C0r 2               
0005C0r 2                   ; Add the data region start sector
0005C0r 2  18               clc
0005C1r 2  AD rr rr         lda SD_ARG
0005C4r 2  6D rr rr         adc fat32_datastart
0005C7r 2  8D rr rr         sta SD_ARG
0005CAr 2  AD rr rr         lda SD_ARG+1
0005CDr 2  6D rr rr         adc fat32_datastart+1
0005D0r 2  8D rr rr         sta SD_ARG+1
0005D3r 2  AD rr rr         lda SD_ARG+2
0005D6r 2  6D rr rr         adc fat32_datastart+2
0005D9r 2  8D rr rr         sta SD_ARG+2
0005DCr 2  AD rr rr         lda SD_ARG+3
0005DFr 2  6D rr rr         adc fat32_datastart+3
0005E2r 2  8D rr rr         sta SD_ARG+3
0005E5r 2               
0005E5r 2                   ; That's now ready for later code to read this sector in - tell it how many consecutive
0005E5r 2                   ; sectors it can now read
0005E5r 2  AD rr rr         lda fat32_sectorspercluster
0005E8r 2  8D rr rr         sta fat32_pendingsectors
0005EBr 2               
0005EBr 2                   ; Now go back to looking up the next cluster in the chain
0005EBr 2                   ; Find the offset to this cluster's entry in the FAT sector we loaded earlier
0005EBr 2               
0005EBr 2                   ; Offset = (cluster*4) & 511 = (cluster & 127) * 4
0005EBr 2  AD rr rr         lda fat32_nextcluster
0005EEr 2  29 7F            and #$7f
0005F0r 2  0A               asl
0005F1r 2  0A               asl
0005F2r 2  A8               tay ; Y = low byte of offset
0005F3r 2                   ; Add the potentially carried bit to the high byte of the address
0005F3r 2  A5 rr            lda sd_buffer_address+1
0005F5r 2  69 00            adc #0
0005F7r 2  85 rr            sta sd_buffer_address+1
0005F9r 2               
0005F9r 2                   ; Copy out the next cluster in the chain for later use
0005F9r 2  B1 rr            lda (sd_buffer_address),y
0005FBr 2  8D rr rr         sta fat32_nextcluster
0005FEr 2  C8               iny
0005FFr 2  B1 rr            lda (sd_buffer_address),y
000601r 2  8D rr rr         sta fat32_nextcluster+1
000604r 2  C8               iny
000605r 2  B1 rr            lda (sd_buffer_address),y
000607r 2  8D rr rr         sta fat32_nextcluster+2
00060Ar 2  C8               iny
00060Br 2  B1 rr            lda (sd_buffer_address),y
00060Dr 2  29 0F            and #$0f
00060Fr 2  8D rr rr         sta fat32_nextcluster+3
000612r 2               
000612r 2                   ; See if it's the end of the chain
000612r 2  09 F0            ora #$f0
000614r 2  2D rr rr         and fat32_nextcluster+2
000617r 2  2D rr rr         and fat32_nextcluster+1
00061Ar 2  C9 FF            cmp #$ff
00061Cr 2  D0 0A            bne @notendofchain
00061Er 2  AD rr rr         lda fat32_nextcluster
000621r 2  C9 F8            cmp #$f8
000623r 2  90 03            bcc @notendofchain
000625r 2               
000625r 2                   ; It's the end of the chain, set the top bits so that we can tell this later on
000625r 2  8D rr rr         sta fat32_nextcluster+3
000628r 2               @notendofchain:
000628r 2  7A               ply
000629r 2  60               rts
00062Ar 2               
00062Ar 2               
00062Ar 2               fat32_readnextsector:
00062Ar 2                   ; Reads the next sector from a cluster chain into the buffer at fat32_address.
00062Ar 2                   ;
00062Ar 2                   ; Advances the current sector ready for the next read and looks up the next cluster
00062Ar 2                   ; in the chain when necessary.
00062Ar 2                   ;
00062Ar 2                   ; On return, carry is clear if data was read, or set if the cluster chain has ended.
00062Ar 2               
00062Ar 2                   ; Maybe there are pending sectors in the current cluster
00062Ar 2  AD rr rr         lda fat32_pendingsectors
00062Dr 2  D0 08            bne @readsector
00062Fr 2               
00062Fr 2                   ; No pending sectors, check for end of cluster chain
00062Fr 2  AD rr rr         lda fat32_nextcluster+3
000632r 2  30 27            bmi @endofchain
000634r 2               
000634r 2                   ; Prepare to read the next cluster
000634r 2  20 rr rr         jsr fat32_seekcluster
000637r 2               
000637r 2               @readsector:
000637r 2  CE rr rr         dec fat32_pendingsectors
00063Ar 2               
00063Ar 2                   ; Set up target address
00063Ar 2  AD rr rr         lda fat32_address
00063Dr 2  85 rr            sta sd_buffer_address
00063Fr 2  AD rr rr         lda fat32_address+1
000642r 2  85 rr            sta sd_buffer_address+1
000644r 2               
000644r 2                   ; Read the sector
000644r 2  20 rr rr         jsr sd_readsector
000647r 2               
000647r 2                   ; Advance to next sector
000647r 2  EE rr rr         inc SD_ARG
00064Ar 2  D0 0D            bne @sectorincrementdone
00064Cr 2  EE rr rr         inc SD_ARG+1
00064Fr 2  D0 08            bne @sectorincrementdone
000651r 2  EE rr rr         inc SD_ARG+2
000654r 2  D0 03            bne @sectorincrementdone
000656r 2  EE rr rr         inc SD_ARG+3
000659r 2               @sectorincrementdone:
000659r 2               
000659r 2                   ; Success - clear carry and return
000659r 2  18               clc
00065Ar 2  60               rts
00065Br 2               
00065Br 2               @endofchain:
00065Br 2                   ; End of chain - set carry and return
00065Br 2  38               sec
00065Cr 2  60               rts
00065Dr 2               
00065Dr 2               
00065Dr 2               fat32_openroot:
00065Dr 2                   ; Prepare to read the root directory
00065Dr 2               
00065Dr 2  AD rr rr         lda fat32_rootcluster
000660r 2  8D rr rr         sta fat32_nextcluster
000663r 2  AD rr rr         lda fat32_rootcluster+1
000666r 2  8D rr rr         sta fat32_nextcluster+1
000669r 2  AD rr rr         lda fat32_rootcluster+2
00066Cr 2  8D rr rr         sta fat32_nextcluster+2
00066Fr 2  AD rr rr         lda fat32_rootcluster+3
000672r 2  8D rr rr         sta fat32_nextcluster+3
000675r 2               
000675r 2  20 rr rr         jsr fat32_seekcluster
000678r 2               
000678r 2                   ; Set the pointer to a large value so we always read a sector the first time through
000678r 2                   ; lda #$ff
000678r 2                   ; sta sd_buffer_address+1
000678r 2  A9 00            lda #0   ; return success
00067Ar 2  60               rts
00067Br 2               
00067Br 2               
00067Br 2               fat32_opendirent:
00067Br 2  5A               phy
00067Cr 2                   ; Prepare to read from a file or directory based on a dirent
00067Cr 2                   ;
00067Cr 2                   ; Point sd_buffer_address at the dirent
00067Cr 2               
00067Cr 2                   ; Remember file size in bytes remaining
00067Cr 2  A0 1C            ldy #28
00067Er 2  B1 rr            lda (sd_buffer_address),y
000680r 2  8D rr rr         sta fat32_bytesremaining
000683r 2  C8               iny
000684r 2  B1 rr            lda (sd_buffer_address),y
000686r 2  8D rr rr         sta fat32_bytesremaining+1
000689r 2  C8               iny
00068Ar 2  B1 rr            lda (sd_buffer_address),y
00068Cr 2  8D rr rr         sta fat32_bytesremaining+2
00068Fr 2  C8               iny
000690r 2  B1 rr            lda (sd_buffer_address),y
000692r 2  8D rr rr         sta fat32_bytesremaining+3
000695r 2               
000695r 2                   ; Seek to first cluster
000695r 2  A0 1A            ldy #26
000697r 2  B1 rr            lda (sd_buffer_address),y
000699r 2  8D rr rr         sta fat32_nextcluster
00069Cr 2  C8               iny
00069Dr 2  B1 rr            lda (sd_buffer_address),y
00069Fr 2  8D rr rr         sta fat32_nextcluster+1
0006A2r 2  A0 14            ldy #20
0006A4r 2  B1 rr            lda (sd_buffer_address),y
0006A6r 2  8D rr rr         sta fat32_nextcluster+2
0006A9r 2  C8               iny
0006AAr 2  B1 rr            lda (sd_buffer_address),y
0006ACr 2  8D rr rr         sta fat32_nextcluster+3
0006AFr 2               
0006AFr 2  20 rr rr         jsr fat32_seekcluster
0006B2r 2               
0006B2r 2                   ; Set the pointer to a large value so we always read a sector the first time through
0006B2r 2                   ; lda #$ff
0006B2r 2                   ; sta sd_buffer_address+1
0006B2r 2  7A               ply
0006B3r 2  60               rts
0006B4r 2               
0006B4r 2               
0006B4r 2               fat32_readdirent:
0006B4r 2                   ; Read a directory entry from the open directory
0006B4r 2                   ;
0006B4r 2                   ; On exit the carry is set if there were no more directory entries.
0006B4r 2                   ;
0006B4r 2                   ; Otherwise, A is set to the file's attribute byte and
0006B4r 2                   ; sd_buffer_address points at the returned directory entry.
0006B4r 2                   ; LFNs and empty entries are ignored automatically.
0006B4r 2               
0006B4r 2                   ; Increment pointer by 32 to point to next entry
0006B4r 2  A9 31            lda #'1'
0006B6r 2  20 rr rr         jsr kernel_putc
0006B9r 2  5A               phy
0006BAr 2  18               clc
0006BBr 2  A5 rr            lda sd_buffer_address
0006BDr 2  69 20            adc #32
0006BFr 2  85 rr            sta sd_buffer_address
0006C1r 2  A5 rr            lda sd_buffer_address+1
0006C3r 2  69 00            adc #0
0006C5r 2  85 rr            sta sd_buffer_address+1
0006C7r 2  8D 81 FF         sta PORTA
0006CAr 2               
0006CAr 2                   ; If it's not at the end of the buffer, we have data already
0006CAr 2  C9 rr            cmp #>(fat32_readbuffer+$200)
0006CCr 2  90 12            bcc @gotdata
0006CEr 2               
0006CEr 2                   ; Read another sector
0006CEr 2  A9 rr            lda #<fat32_readbuffer
0006D0r 2  8D rr rr         sta fat32_address
0006D3r 2  A9 rr            lda #>fat32_readbuffer
0006D5r 2  8D rr rr         sta fat32_address+1
0006D8r 2  20 rr rr         jsr fat32_readnextsector
0006DBr 2  90 03            bcc @gotdata
0006DDr 2               
0006DDr 2               @endofdirectory:
0006DDr 2  7A               ply
0006DEr 2  38               sec
0006DFr 2  60               rts
0006E0r 2               
0006E0r 2               @gotdata:
0006E0r 2                   ; Check first character
0006E0r 2  A0 00            ldy #0
0006E2r 2  B1 rr            lda (sd_buffer_address),y
0006E4r 2               
0006E4r 2                   ; End of directory => abort
0006E4r 2  F0 F7            beq @endofdirectory
0006E6r 2               
0006E6r 2                   ; Empty entry => start again
0006E6r 2  C9 E5            cmp #$e5
0006E8r 2  F0 CA            beq fat32_readdirent
0006EAr 2               
0006EAr 2  A9 35            lda #'5'
0006ECr 2  20 rr rr         jsr kernel_putc
0006EFr 2               
0006EFr 2                   ; Check attributes
0006EFr 2  A0 0B            ldy #11
0006F1r 2  B1 rr            lda (sd_buffer_address),y
0006F3r 2  29 3F            and #$3f
0006F5r 2  C9 0F            cmp #$0f ; LFN => start again
0006F7r 2  F0 BB            beq fat32_readdirent
0006F9r 2               
0006F9r 2  A9 36            lda #'6'
0006FBr 2  20 rr rr         jsr kernel_putc
0006FEr 2                   ; Yield this result
0006FEr 2  7A               ply
0006FFr 2  18               clc
000700r 2  60               rts
000701r 2               
000701r 2               
000701r 2               fat32_finddirent:
000701r 2                   ; The directory should already be open for iteration.
000701r 2                   ; Pointer to filename is in fat32_filenamepointer and fat32_filenamepointer + 1
000701r 2               
000701r 2                   ; Iterate until name is found or end of directory
000701r 2  5A               phy
000702r 2               @direntloop:
000702r 2  20 rr rr         jsr fat32_readdirent
000705r 2  A0 0A            ldy #10
000707r 2  90 04            bcc @comparenameloop
000709r 2  7A               ply
00070Ar 2  A9 01            lda #1
00070Cr 2  60               rts ; return not found
00070Dr 2               
00070Dr 2               @comparenameloop:
00070Dr 2  B1 rr            lda (sd_buffer_address),y
00070Fr 2  D1 rr            cmp (fat32_filenamepointer),y
000711r 2  D0 EF            bne @direntloop ; no match
000713r 2  88               dey
000714r 2  10 F7            bpl @comparenameloop
000716r 2               
000716r 2                   ; Found it
000716r 2  7A               ply
000717r 2  A9 00            lda #0
000719r 2  60               rts
00071Ar 2               
00071Ar 2               
00071Ar 2               fat32_file_readbyte:
00071Ar 2                   ; Read a byte from an open file
00071Ar 2                   ;
00071Ar 2                   ; The byte is returned in A with C clear; or if end-of-file was reached, C is set instead
00071Ar 2               
00071Ar 2  38               sec
00071Br 2               
00071Br 2                   ; Is there any data to read at all?
00071Br 2  AD rr rr         lda fat32_bytesremaining
00071Er 2  0D rr rr         ora fat32_bytesremaining+1
000721r 2  0D rr rr         ora fat32_bytesremaining+2
000724r 2  0D rr rr         ora fat32_bytesremaining+3
000727r 2  F0 49            beq @rts
000729r 2               
000729r 2                   ; Decrement the remaining byte count
000729r 2  AD rr rr         lda fat32_bytesremaining
00072Cr 2  E9 01            sbc #1
00072Er 2  8D rr rr         sta fat32_bytesremaining
000731r 2  AD rr rr         lda fat32_bytesremaining+1
000734r 2  E9 00            sbc #0
000736r 2  8D rr rr         sta fat32_bytesremaining+1
000739r 2  AD rr rr         lda fat32_bytesremaining+2
00073Cr 2  E9 00            sbc #0
00073Er 2  8D rr rr         sta fat32_bytesremaining+2
000741r 2  AD rr rr         lda fat32_bytesremaining+3
000744r 2  E9 00            sbc #0
000746r 2  8D rr rr         sta fat32_bytesremaining+3
000749r 2               
000749r 2                   ; Need to read a new sector?
000749r 2  A5 rr            lda sd_buffer_address+1
00074Br 2  C9 rr            cmp #>(fat32_readbuffer+$200)
00074Dr 2  90 0F            bcc @gotdata
00074Fr 2               
00074Fr 2                   ; Read another sector
00074Fr 2  A9 rr            lda #<fat32_readbuffer
000751r 2  8D rr rr         sta fat32_address
000754r 2  A9 rr            lda #>fat32_readbuffer
000756r 2  8D rr rr         sta fat32_address+1
000759r 2               
000759r 2  20 rr rr         jsr fat32_readnextsector
00075Cr 2  B0 14            bcs @rts                    ; this shouldn't happen
00075Er 2               
00075Er 2               @gotdata:
00075Er 2  5A               phy
00075Fr 2  A0 00            ldy #0
000761r 2  B1 rr            lda (sd_buffer_address),y
000763r 2  7A               ply
000764r 2  E6 rr            inc sd_buffer_address
000766r 2  D0 0A            bne @rts
000768r 2  E6 rr            inc sd_buffer_address+1
00076Ar 2  D0 06            bne @rts
00076Cr 2  E6 rr            inc sd_buffer_address+2
00076Er 2  D0 02            bne @rts
000770r 2  E6 rr            inc sd_buffer_address+3
000772r 2               
000772r 2               @rts:
000772r 2  60               rts
000773r 2               
000773r 2               
000773r 2               fat32_file_read:
000773r 2                   ; Read a whole file into memory.  It's assumed the file has just been opened
000773r 2                   ; and no data has been read yet.
000773r 2                   ;
000773r 2                   ; Also we read whole sectors, so data in the target region beyond the end of the
000773r 2                   ; file may get overwritten, up to the next 512-byte boundary.
000773r 2                   ;
000773r 2                   ; And we don't properly support 64k+ files, as it's unnecessary complication given
000773r 2                   ; the 6502's small address space
000773r 2               
000773r 2                   ; Round the size up to the next whole sector
000773r 2  AD rr rr         lda fat32_bytesremaining
000776r 2  C9 01            cmp #1                      ; set carry if bottom 8 bits not zero
000778r 2  AD rr rr         lda fat32_bytesremaining+1
00077Br 2  69 00            adc #0                      ; add carry, if any
00077Dr 2  4A               lsr                         ; divide by 2
00077Er 2  69 00            adc #0                      ; round up
000780r 2               
000780r 2                   ; No data?
000780r 2  F0 17            beq @done
000782r 2               
000782r 2                   ; Store sector count - not a byte count any more
000782r 2  8D rr rr         sta fat32_bytesremaining
000785r 2               
000785r 2                   ; Read entire sectors to the user-supplied buffer
000785r 2               @wholesectorreadloop:
000785r 2                   ; Read a sector to fat32_address
000785r 2  20 rr rr         jsr fat32_readnextsector
000788r 2               
000788r 2                   ; Advance fat32_address by 512 bytes
000788r 2  AD rr rr         lda fat32_address+1
00078Br 2  69 02            adc #2                      ; carry already clear
00078Dr 2  8D rr rr         sta fat32_address+1
000790r 2               
000790r 2  AE rr rr         ldx fat32_bytesremaining    ; note - actually loads sectors remaining
000793r 2  CA               dex
000794r 2  8E rr rr         stx fat32_bytesremaining    ; note - actually stores sectors remaining
000797r 2               
000797r 2  D0 EC            bne @wholesectorreadloop
000799r 2               
000799r 2               @done:
000799r 2  60               rts
00079Ar 2               
00079Ar 2               
00079Ar 1               
00079Ar 1               .include "../../forth.s"
00079Ar 2               .include "../../macros.s"
00079Ar 3               .macro  printascii   addr
00079Ar 3                   ldx #0
00079Ar 3               @loop:
00079Ar 3                   lda addr,x
00079Ar 3                   beq @done
00079Ar 3                   jsr kernel_putc
00079Ar 3                   inx
00079Ar 3                   bra @loop
00079Ar 3               @done:
00079Ar 3               .endmacro
00079Ar 3               
00079Ar 3               
00079Ar 2               
00079Ar 2               
00079Ar 2               ; Definitions for Tali Forth 2
00079Ar 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00079Ar 2               ; First version: 01. Apr 2016 (Liara Forth)
00079Ar 2               ; This version: 29. Jan 2020
00079Ar 2               
00079Ar 2               ; This file is included by taliforth.asm. These are the general
00079Ar 2               ; definitions; platform-specific definitions such as the
00079Ar 2               ; memory map are kept in the platform folder.
00079Ar 2               
00079Ar 2               
00079Ar 2               ; User Variables:
00079Ar 2               ; Block variables
00079Ar 2               blk_offset =  0        ; BLK : UP + 0
00079Ar 2               scr_offset =  2        ; SCR : UP + 2
00079Ar 2               
00079Ar 2               ; Wordlists
00079Ar 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
00079Ar 2               num_wordlists_offset =  5
00079Ar 2                                          ; #WORDLISTS (byte) : UP + 5
00079Ar 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
00079Ar 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
00079Ar 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
00079Ar 2                                          ;          (Number of wordlists in search order)
00079Ar 2               search_order_offset =  31
00079Ar 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
00079Ar 2                                          ; Allowing for 9 to keep offsets even.
00079Ar 2               max_wordlists =  12    ; Maximum number of wordlists supported
00079Ar 2                                          ; 4 Tali built-ins + 8 user wordlists
00079Ar 2               
00079Ar 2               ; Buffer variables
00079Ar 2               blkbuffer_offset =     40   ; Address of buffer
00079Ar 2               buffblocknum_offset =  42   ; Block number current in buffer
00079Ar 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
00079Ar 2               
00079Ar 2               ; Block I/O vectors
00079Ar 2               blockread_offset =     46   ; Vector to block reading routine
00079Ar 2               blockwrite_offset =    48   ; Vector to block writing routine
00079Ar 2               
00079Ar 2               
00079Ar 2               ; ASCII CHARACTERS
00079Ar 2               AscCC =   $03  ; break (CTRL-c)
00079Ar 2               AscBELL = $07  ; bell sound
00079Ar 2               AscBS =   $08  ; backspace
00079Ar 2               AscLF =   $0a  ; line feed
00079Ar 2               AscCR =   $0d  ; carriage return
00079Ar 2               AscESC =  $1b  ; escape
00079Ar 2               AscSP =   $20  ; space
00079Ar 2               AscDEL =  $7f  ; delete (CTRL-h)
00079Ar 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
00079Ar 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
00079Ar 2               
00079Ar 2               ; DICTIONARY FLAGS
00079Ar 2               ; The first three bits are currently unused
00079Ar 2               CO = 1  ; Compile Only
00079Ar 2               AN = 2  ; Always Native Compile
00079Ar 2               IM = 4  ; Immediate Word
00079Ar 2               NN = 8  ; Never Native Compile
00079Ar 2               UF = 16 ; Includes Underflow Check (RESERVED)
00079Ar 2               HC = 32 ; Word has Code Field Area (CFA)
00079Ar 2               
00079Ar 2               
00079Ar 2               ; VARIOUS
00079Ar 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
00079Ar 2               
00079Ar 2               ; END
00079Ar 2               
00079Ar 2               .segment "ZEROPAGE": zeropage
000018r 2               ; ZERO PAGE ADDRESSES/VARIABLES
000018r 2               
000018r 2               ; These are kept at the top of Zero Page, with the most important variables at
000018r 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
000018r 2               ; an overflow, the lower, less important variables will be clobbered first,
000018r 2               ; giving the system a chance to recover. In other words, they are part of the
000018r 2               ; floodplain.
000018r 2               
000018r 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
000018r 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
000018r 2               
000018r 2  xx xx        cp: .res 2   ; Compiler Pointer
00001Ar 2  xx xx        dp: .res 2   ; Dictionary Pointer
00001Cr 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
00001Er 2                                          ; a :NONAME declared word (see status)
00001Er 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
000020r 2  xx xx        cib: .res 2   ; address of current input buffer
000022r 2  xx xx        ciblen: .res 2  ; length of current input buffer
000024r 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
000026r 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
000028r 2  xx xx        output: .res 2  ; vector for EMIT
00002Ar 2  xx xx        input: .res 2  ; vector for KEY
00002Cr 2  xx xx        havekey: .res 2  ; vector for KEY?
00002Er 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
000030r 2  xx xx        base: .res 2  ; number radix, default decimal
000032r 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
000034r 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
000036r 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
000038r 2  xx xx        status: .res 2  ; internal status information
00003Ar 2                                          ; (used by : :NONAME ; ACCEPT)
00003Ar 2                                          ; Bit 7 = Redefined word message postpone
00003Ar 2                                          ;         When set before calling CREATE, it will
00003Ar 2                                          ;         not print the "redefined xxxx" message if
00003Ar 2                                          ;         the word exists. Instead, this bit will
00003Ar 2                                          ;         be reused and after CREATE has run, it will
00003Ar 2                                          ;         be set if the word was redefined and 0 if
00003Ar 2                                          ;         not. This bit should be 0 when not in use.
00003Ar 2                                          ; Bit 6 = 1 for normal ":" definitions
00003Ar 2                                          ;         WORKWORD contains nt of word being compiled
00003Ar 2                                          ;       = 0 for :NONAME definitions
00003Ar 2                                          ;         WORKWORD contains xt of word being compiled
00003Ar 2                                          ; Bit 5 = 1 for NUMBER returning a double word
00003Ar 2                                          ;       = 0 for NUMBER returning a single word
00003Ar 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
00003Ar 2                                          ;       = 0 CTRL-n recalls previous history
00003Ar 2                                          ; Bit 2 = Current history buffer msb
00003Ar 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
00003Ar 2                                          ; Bit 0 = Current history buffer lsb
00003Ar 2                                          ; status+1 is used by ACCEPT to hold history lengths.
00003Ar 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
00003Cr 2  xx xx        tmp1: .res 2  ; temporary storage
00003Er 2  xx xx        tmp2: .res 2  ; temporary storage
000040r 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
000042r 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
000044r 2  xx xx        tmptos: .res 2  ; temporary TOS storage
000046r 2  xx xx        editor1: .res 2  ; temporary for editors
000048r 2  xx xx        editor2: .res 2  ; temporary for editors
00004Ar 2  xx xx        editor3: .res 2  ; temporary for editors
00004Cr 2  xx xx        tohold: .res 2  ; pointer for formatted output
00004Er 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
000052r 2  xx xx xx xx  
000056r 2  xx xx xx xx  dsp_start: .res 128 ; reserve 128 bytes for data stack (64 16 bit cells)
00005Ar 2  xx xx xx xx  
00005Er 2  xx xx xx xx  
0000D6r 2               dsp0 = $FF          ; first data stack location. Data stack grows down
0000D6r 2               rsp0 =      $FF     ; starting stack pointer
0000D6r 2               stack0 =    $0100   ; location of the stack
0000D6r 2               
0000D6r 2               
0000D6r 2               .segment "BSS"
000932r 2  xx xx xx xx  hist_buff: .res $400
000936r 2  xx xx xx xx  
00093Ar 2  xx xx xx xx  
000D32r 2  xx xx xx xx  buffer0: .res $100
000D36r 2  xx xx xx xx  
000D3Ar 2  xx xx xx xx  
000E32r 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
00079Ar 2               
00079Ar 2               forth:
00079Ar 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
00079Ar 3               ; Low-level Forth word routines
00079Ar 3               ; Tali Forth 2 for the 65c02
00079Ar 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00079Ar 3               ; First version: 19. Jan 2014
00079Ar 3               ; This version: 03. Jan 2018
00079Ar 3               
00079Ar 3               ; This list is ordered alphabetically by the names of the words, not their
00079Ar 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
00079Ar 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
00079Ar 3               ; status lines that begins with "; ## ", which allows auto-generation of the
00079Ar 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
00079Ar 3               
00079Ar 3               ;       TBA --> fragment --> coded --> tested --> auto
00079Ar 3               
00079Ar 3               ; "Auto" means that the word is automatically tested by the test suite (good),
00079Ar 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
00079Ar 3               ; it hasn't been tested at all (bad). See the test suite for more details.
00079Ar 3               
00079Ar 3               ; ## COLD ( -- ) "Reset the Forth system"
00079Ar 3               ; ## "cold"  tested  Tali Forth
00079Ar 3               ;       """Reset the Forth system. Does not restart the kernel,
00079Ar 3               ;       use the 65c02 reset for that. Flows into ABORT.
00079Ar 3               ;       """
00079Ar 3               xt_cold:
00079Ar 3  D8                           cld
00079Br 3               
00079Br 3                               ; Set the OUTPUT vector to the default kernel_putc
00079Br 3                               ; We do this really early so we can print error messages
00079Br 3                               ; during debugging
00079Br 3  A9 rr                        lda #<kernel_putc
00079Dr 3  85 rr                        sta output
00079Fr 3  A9 rr                        lda #>kernel_putc
0007A1r 3  85 rr                        sta output+1
0007A3r 3               
0007A3r 3                               ; Load all of the important zero page variables from ROM
0007A3r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
0007A5r 3               
0007A5r 3               @load_zp_loop:
0007A5r 3                               ; This loop loads them back to front. We can use X here
0007A5r 3                               ; because Tali hasn't started using the stack yet.
0007A5r 3  BD rr rr                     lda cold_zp_table,x
0007A8r 3  95 rr                        sta cp,x
0007AAr 3  CA                           dex
0007ABr 3  D0 F8                        bne @load_zp_loop
0007ADr 3               
0007ADr 3                               ; Copy the 0th element.
0007ADr 3  AD rr rr                     lda cold_zp_table
0007B0r 3  85 rr                        sta cp
0007B2r 3                               ; Initialize 65c02 stack (Return Stack)
0007B2r 3  A2 FF                        ldx #rsp0
0007B4r 3  9A                           txs
0007B5r 3               
0007B5r 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
0007B5r 3                               ; can load high-level words with EVALUATE
0007B5r 3  A2 FF                        ldx #dsp0
0007B7r 3               
0007B7r 3               
0007B7r 3                               ; Initialize the user variables.
0007B7r 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
0007B9r 3  A9 00                        lda #0
0007BBr 3               
0007BBr 3               @load_user_vars_loop:
0007BBr 3                               ; Like the zero page variables, these are initialized
0007BBr 3                               ; back to front.
0007BBr 3  B9 rr rr                     lda cold_user_table,y
0007BEr 3  91 rr                        sta (up),y
0007C0r 3  88                           dey
0007C1r 3  D0 F8                        bne @load_user_vars_loop
0007C3r 3               
0007C3r 3                               ; Copy the 0th element.
0007C3r 3  AD rr rr                     lda cold_user_table
0007C6r 3  92 rr                        sta (up)
0007C8r 3  20 rr rr                     jsr xt_cr
0007CBr 3               
0007CBr 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
0007CBr 3                               ; you do not have any high-level words, this part can be
0007CBr 3                               ; commented out.
0007CBr 3  CA                           dex
0007CCr 3  CA                           dex
0007CDr 3  CA                           dex
0007CEr 3  CA                           dex
0007CFr 3               
0007CFr 3               
0007CFr 3                               ; start address goes NOS
0007CFr 3  A9 rr                        lda #<forth_words_start
0007D1r 3  95 02                        sta 2,x
0007D3r 3  A9 rr                        lda #>forth_words_start
0007D5r 3  95 03                        sta 3,x
0007D7r 3               
0007D7r 3                               ; length goes TOS
0007D7r 3  A9 rr                        lda #<forth_words_end
0007D9r 3  38                           sec
0007DAr 3  E9 rr                        sbc #<forth_words_start
0007DCr 3  95 00                        sta 0,x
0007DEr 3               
0007DEr 3  A9 rr                        lda #>forth_words_end
0007E0r 3  E9 rr                        sbc #>forth_words_start
0007E2r 3  95 01                        sta 1,x
0007E4r 3               
0007E4r 3               
0007E4r 3  20 rr rr                     jsr xt_evaluate
0007E7r 3               
0007E7r 3                               ; Now define any user words via EVALUATE. If you do not have
0007E7r 3                               ; any user-defined words, this part can be commented out as
0007E7r 3                               ; well.
0007E7r 3  CA                           dex
0007E8r 3  CA                           dex
0007E9r 3  CA                           dex
0007EAr 3  CA                           dex
0007EBr 3               
0007EBr 3               
0007EBr 3                               ; start address goes NOS
0007EBr 3  A9 rr                        lda #<user_words_start
0007EDr 3  95 02                        sta 2,x
0007EFr 3  A9 rr                        lda #>user_words_start
0007F1r 3  95 03                        sta 3,x
0007F3r 3               
0007F3r 3                               ; length goes TOS
0007F3r 3  A9 rr                        lda #<user_words_end
0007F5r 3  38                           sec
0007F6r 3  E9 rr                        sbc #<user_words_start
0007F8r 3  95 00                        sta 0,x
0007FAr 3               
0007FAr 3  A9 rr                        lda #>user_words_end
0007FCr 3  E9 rr                        sbc #>user_words_start
0007FEr 3  95 01                        sta 1,x
000800r 3               
000800r 3  20 rr rr                     jsr xt_evaluate
000803r 3               
000803r 3                               ; Initialize all of the history buffers by putting a zero in
000803r 3                               ; each length byte.
000803r 3  9C rr rr                     stz hist_buff
000806r 3  9C rr rr                     stz hist_buff+$80
000809r 3  9C rr rr                     stz hist_buff+$100
00080Cr 3  9C rr rr                     stz hist_buff+$180
00080Fr 3  9C rr rr                     stz hist_buff+$200
000812r 3  9C rr rr                     stz hist_buff+$280
000815r 3  9C rr rr                     stz hist_buff+$300
000818r 3  9C rr rr                     stz hist_buff+$380
00081Br 3               
00081Br 3               
00081Br 3                               ; fall through to ABORT
00081Br 3               
00081Br 3               
00081Br 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
00081Br 3               ; ## "abort"  tested  ANS core
00081Br 3                       ; """https://forth-standard.org/standard/core/ABORT
00081Br 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
00081Br 3                       ; subroutine if we want to because we are going to reset the 65c02's
00081Br 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
00081Br 3                       ; actually delete the stuff on the Data Stack.
00081Br 3                       ; """
00081Br 3               xt_abort:
00081Br 3  A2 FF                        ldx #dsp0
00081Dr 3               
00081Dr 3                               ; fall through to QUIT
00081Dr 3               
00081Dr 3               
00081Dr 3               ; ## QUIT ( -- ) "Reset the input and get new input"
00081Dr 3               ; ## "quit"  tested  ANS core
00081Dr 3                       ; """https://forth-standard.org/standard/core/QUIT
00081Dr 3                       ; Rest the input and start command loop
00081Dr 3                       ; """
00081Dr 3               
00081Dr 3               xt_quit:
00081Dr 3                               ; Clear the Return Stack. This is a little screwed up
00081Dr 3                               ; because the 65c02 can only set the Return Stack via X,
00081Dr 3                               ; which is our Data Stack pointer. The ANS specification
00081Dr 3                               ; demands, however, that ABORT reset the Data Stack pointer
00081Dr 3  8A                           txa             ; Save the DSP that we just defined
00081Er 3  A2 FF                        ldx #rsp0
000820r 3  9A                           txs
000821r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000822r 3               
000822r 3                               ; make sure instruction pointer is empty
000822r 3  64 rr                        stz ip
000824r 3  64 rr                        stz ip+1
000826r 3               
000826r 3                               ; SOURCE-ID is zero (keyboard input)
000826r 3  64 rr                        stz insrc
000828r 3  64 rr                        stz insrc+1
00082Ar 3               
00082Ar 3                               ; STATE is zero (interpret, not compile)
00082Ar 3  64 rr                        stz state
00082Cr 3  64 rr                        stz state+1
00082Er 3               @get_line:
00082Er 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
000830r 3  85 rr                        sta cib
000832r 3  A9 rr                        lda #>buffer0
000834r 3  85 rr                        sta cib+1
000836r 3               
000836r 3                               ; Size of current input buffer (CIB) is zero
000836r 3  64 rr                        stz ciblen
000838r 3  64 rr                        stz ciblen+1
00083Ar 3               
00083Ar 3                               ; Accept a line from the current import source. This is how
00083Ar 3                               ; modern Forths to it.
00083Ar 3  20 rr rr                     jsr xt_refill           ; ( -- f )
00083Dr 3               
00083Dr 3                               ; Test flag: LSB of TOS
00083Dr 3  B5 00                        lda 0,x
00083Fr 3  D0 05                        bne @success
000841r 3               
000841r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
000841r 3                               ; need to print an error message and reset the machine. We
000841r 3                               ; don't need to save TOS because we're going to clobber it
000841r 3                               ; anyway when we go back to ABORT.
000841r 3  A9 06                        lda #err_refill
000843r 3  4C rr rr                     jmp error
000846r 3               
000846r 3               @success:
000846r 3                               ; Assume we have successfully accepted a string of input from
000846r 3                               ; a source, with address cib and length of input in ciblen. We
000846r 3                               ; arrive here still with the TRUE flag from REFILL as TOS
000846r 3  E8                           inx                     ; drop
000847r 3  E8                           inx
000848r 3               
000848r 3                               ; Main compile/execute routine
000848r 3  20 rr rr                     jsr interpret
00084Br 3               
00084Br 3                               ; Test for Data Stack underflow. Tali Forth does not check for
00084Br 3                               ; overflow because it is so rare
00084Br 3  E0 FF                        cpx #dsp0
00084Dr 3  F0 05                        beq @stack_ok
00084Fr 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
000851r 3               
000851r 3  4C rr rr                     jmp underflow_error
000854r 3               
000854r 3               @stack_ok:
000854r 3                               ; Display system prompt if all went well. If we're interpreting,
000854r 3                               ; this is " ok", if we're compiling, it's " compiled". Note
000854r 3                               ; space at beginning of the string.
000854r 3  A5 rr                        lda state
000856r 3  F0 02                        beq @print
000858r 3               
000858r 3  A9 01                        lda #1                  ; number for "compile" string
00085Ar 3               @print:
00085Ar 3  20 rr rr                     jsr print_string
00085Dr 3               
00085Dr 3                               ; Awesome line, everybody! Now get the next one.
00085Dr 3  80 CF                        bra @get_line
00085Fr 3               
00085Fr 3               z_cold:
00085Fr 3               z_abort:
00085Fr 3               z_quit:         ; no RTS required
00085Fr 3               
00085Fr 3               
00085Fr 3               
00085Fr 3               ; This table holds all of the initial values for the variables in zero page.
00085Fr 3               ; This table is used by COLD.
00085Fr 3               cold_zp_table:
00085Fr 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
000861r 3                                               ; block buffer
000861r 3  rr rr                .word dictionary_start  ; dp
000863r 3  00 00                .word 0                 ; workword
000865r 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
000867r 3  rr rr                .word buffer0           ; cib
000869r 3  00 00                .word 0                 ; ciblen
00086Br 3  00 00                .word 0                 ; toin
00086Dr 3  00 00                .word 0                 ; ip
00086Fr 3  rr rr                .word kernel_putc       ; output
000871r 3  rr rr                .word kernel_getc       ; input
000873r 3  00 00                .word 0                 ; havekey
000875r 3  00 00                .word 0                 ; state (0 = interpret)
000877r 3  0A 00                .word 10                ; base
000879r 3  14 00                .word 20                ; nc-limit
00087Br 3  00 00                .word 0                 ; uf_strip (off by default)
00087Dr 3  rr rr                .word cp0               ; up (user vars put right at beginning of
00087Fr 3                                               ; available RAM)
00087Fr 3  00 00                .word 0                 ; status
000881r 3               cold_zp_table_end:
000881r 3               
000881r 3               ; No further ZP variables are initialized. The variables past this point are
000881r 3               ; all temporaries.
000881r 3               
000881r 3               ; This table holds the inital values for the user variables. This table is
000881r 3               ; used by COLD.
000881r 3               cold_user_table:
000881r 3  00 00                .word 0                         ; BLK
000883r 3  00 00                .word 0                         ; SCR
000885r 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
000886r 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
000887r 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
000889r 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
00088Br 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
00088Dr 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
00088Fr 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
000893r 3  00 00 00 00  
000897r 3  00 00 00 00  
00089Fr 3  01                   .byte 1                         ; #ORDER
0008A0r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
0008A4r 3  00 00 00 00  
0008A8r 3  00           
0008A9r 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
0008ABr 3  00 00                .word 0                         ; block in buffer
0008ADr 3  00 00                .word 0                         ; buffer status (not in use)
0008AFr 3  rr rr                .word xt_block_word_error       ; block-read vector
0008B1r 3  rr rr                .word xt_block_word_error       ; block-write vector
0008B3r 3               cold_user_table_end:
0008B3r 3               
0008B3r 3               
0008B3r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
0008B3r 3               ; ## "abort""  tested  ANS core
0008B3r 3                       ; """https://forth-standard.org/standard/core/ABORTq
0008B3r 3                       ; Abort and print a string.
0008B3r 3                       ; """
0008B3r 3               
0008B3r 3               xt_abort_quote:
0008B3r 3                               ; save the string
0008B3r 3  20 rr rr                     jsr xt_s_quote          ; S"
0008B6r 3               
0008B6r 3                               ; compile run-time part
0008B6r 3  A0 rr                        ldy #>abort_quote_runtime
0008B8r 3  A9 rr                        lda #<abort_quote_runtime
0008BAr 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
0008BDr 3               
0008BDr 3  60           z_abort_quote:  rts
0008BEr 3               
0008BEr 3               
0008BEr 3               abort_quote_runtime:
0008BEr 3                       ; """Runtime aspect of ABORT_QUOTE"""
0008BEr 3               
0008BEr 3                               ; We arrive here with ( f addr u )
0008BEr 3  B5 04                        lda 4,x
0008C0r 3  15 05                        ora 5,x
0008C2r 3  F0 09                        beq @done       ; if FALSE, we're done
0008C4r 3               
0008C4r 3                               ; We're true, so print string and ABORT. We follow Gforth
0008C4r 3                               ; in going to a new line after the string
0008C4r 3  20 rr rr                     jsr xt_type
0008C7r 3  20 rr rr                     jsr xt_cr
0008CAr 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
0008CDr 3               @done:
0008CDr 3                               ; Drop three entries from the Data Stack
0008CDr 3  8A                           txa
0008CEr 3  18                           clc
0008CFr 3  69 06                        adc #6
0008D1r 3  AA                           tax
0008D2r 3               
0008D2r 3  60                           rts
0008D3r 3               
0008D3r 3               
0008D3r 3               
0008D3r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
0008D3r 3               ; ## "abs"  auto  ANS core
0008D3r 3                       ; """https://forth-standard.org/standard/core/ABS
0008D3r 3                       ; Return the absolute value of a number.
0008D3r 3                       ; """
0008D3r 3               
0008D3r 3               xt_abs:
0008D3r 3  20 rr rr                     jsr underflow_1
0008D6r 3               
0008D6r 3  B5 01                        lda 1,x
0008D8r 3  10 0D                        bpl @done       ; positive number, easy money!
0008DAr 3               
0008DAr 3                               ; negative: calculate 0 - n
0008DAr 3  38                           sec
0008DBr 3  A9 00                        lda #0
0008DDr 3  F5 00                        sbc 0,x         ; LSB
0008DFr 3  95 00                        sta 0,x
0008E1r 3               
0008E1r 3  A9 00                        lda #0          ; MSB
0008E3r 3  F5 01                        sbc 1,x
0008E5r 3  95 01                        sta 1,x
0008E7r 3               
0008E7r 3               @done:
0008E7r 3  60           z_abs:          rts
0008E8r 3               
0008E8r 3               
0008E8r 3               
0008E8r 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
0008E8r 3               ; ## "accept"  auto  ANS core
0008E8r 3                       ; """https://forth-standard.org/standard/core/ACCEPT
0008E8r 3                       ; Receive a string of at most n1 characters, placing them at
0008E8r 3                       ; addr. Return the actual number of characters as n2. Characters
0008E8r 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
0008E8r 3                       ; modern Forths.
0008E8r 3                       ; """
0008E8r 3               
0008E8r 3               xt_accept:
0008E8r 3  20 rr rr                     jsr underflow_2
0008EBr 3               
0008EBr 3                               ; Abort if we were asked to receive 0 chars
0008EBr 3  B5 00                        lda 0,x
0008EDr 3  15 01                        ora 1,x
0008EFr 3  D0 09                        bne @not_zero
0008F1r 3               
0008F1r 3  E8                           inx
0008F2r 3  E8                           inx
0008F3r 3  74 00                        stz 0,x
0008F5r 3  74 01                        stz 1,x
0008F7r 3               
0008F7r 3  4C rr rr                     jmp accept_done
0008FAr 3               
0008FAr 3               @not_zero:
0008FAr 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
0008FCr 3  85 rr                        sta tmp2
0008FEr 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
000900r 3               
000900r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000902r 3  85 rr                        sta tmp1
000904r 3  B5 03                        lda 3,x
000906r 3  85 rr                        sta tmp1+1
000908r 3               
000908r 3  E8                           inx
000909r 3  E8                           inx
00090Ar 3               
00090Ar 3  A0 00                        ldy #0
00090Cr 3               
00090Cr 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
00090Cr 3                               ; from bit 2 to 3 is OK)
00090Cr 3  A5 rr                        lda status
00090Er 3  29 F7                        and #$f7
000910r 3               
000910r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000910r 3  1A                           inc
000911r 3               
000911r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000911r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000911r 3                               ; received and won't be used to calculate the history buffer
000911r 3                               ; offset.
000911r 3  09 08                        ora #$08
000913r 3  85 rr                        sta status
000915r 3               
000915r 3               accept_loop:
000915r 3                               ; Out of the box, py65mon catches some CTRL sequences such as
000915r 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
000915r 3                               ; vt100 terminal clears the screen automatically.
000915r 3               
000915r 3                               ; This is the internal version of KEY without all the mucking
000915r 3                               ; about with the Data Stack while still using the input vector
000915r 3  20 rr rr                     jsr key_a
000918r 3               
000918r 3                               ; We quit on both line feed and carriage return
000918r 3  C9 0A                        cmp #AscLF
00091Ar 3  F0 20                        beq @eol
00091Cr 3  C9 0D                        cmp #AscCR
00091Er 3  F0 1C                        beq @eol
000920r 3               
000920r 3                               ; BACKSPACE and DEL do the same thing for the moment
000920r 3  C9 08                        cmp #AscBS
000922r 3  F0 22                        beq @backspace
000924r 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
000926r 3  F0 1E                        beq @backspace
000928r 3               
000928r 3                               ; Check for CTRL-p and CTRL-n to recall input history
000928r 3  C9 10                        cmp #AscCP
00092Ar 3  F0 36                        beq @ctrl_p
00092Cr 3  C9 0E                        cmp #AscCN
00092Er 3  F0 44                        beq @ctrl_n
000930r 3               
000930r 3                               ; That's enough for now. Save and echo character.
000930r 3  91 rr                        sta (tmp1),y
000932r 3  C8                           iny
000933r 3               
000933r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000933r 3  20 rr rr                     jsr emit_a
000936r 3               
000936r 3  C4 rr                        cpy tmp2        ; reached character limit?
000938r 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
00093Ar 3  80 03                        bra @buffer_full
00093Cr 3               
00093Cr 3               @eol:
00093Cr 3  20 rr rr                     jsr xt_space    ; print final space
00093Fr 3               
00093Fr 3               @buffer_full:
00093Fr 3                               ; REFILL updates ciblen and toin, we don't need to do it here
00093Fr 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
000941r 3  74 01                        stz 1,x         ; we only accept 256 chars
000943r 3               
000943r 3  4C rr rr                     jmp accept_done
000946r 3               
000946r 3               @backspace:
000946r 3                               ; Handle backspace and delete kex, which currently do the same
000946r 3                               ; thing
000946r 3  C0 00                        cpy #0          ; buffer empty?
000948r 3  D0 06                        bne @1
00094Ar 3               
00094Ar 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
00094Cr 3  20 rr rr                     jsr emit_a
00094Fr 3  C8                           iny
000950r 3               @1:
000950r 3  88                           dey
000951r 3  A9 08                        lda #AscBS      ; move back one
000953r 3  20 rr rr                     jsr emit_a
000956r 3  A9 20                        lda #AscSP      ; print a space (rubout)
000958r 3  20 rr rr                     jsr emit_a
00095Br 3  A9 08                        lda #AscBS      ; move back over space
00095Dr 3  20 rr rr                     jsr emit_a
000960r 3               
000960r 3  80 B3                        bra accept_loop
000962r 3               
000962r 3               @ctrl_p:
000962r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
000962r 3               
000962r 3                               ; Select the previous buffer
000962r 3  A5 rr                        lda status
000964r 3               
000964r 3                               ; Check for 0 (need to wrap back to 7)
000964r 3  29 07                        and #7
000966r 3  D0 08                        bne @ctrl_p_dec
000968r 3               
000968r 3                               ; We need to wrap back to 7.
000968r 3  A5 rr                        lda status
00096Ar 3  09 07                        ora #7
00096Cr 3  85 rr                        sta status
00096Er 3  80 11                        bra @recall_history
000970r 3               
000970r 3               @ctrl_p_dec:
000970r 3                               ; It's safe to decrement the buffer index directly.
000970r 3  C6 rr                        dec status
000972r 3  80 0D                        bra @recall_history
000974r 3               
000974r 3               @ctrl_n:
000974r 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
000974r 3                               ; the next buffer Check bit 3. If it's set, this is the first
000974r 3                               ; time CTRL-n has been pressed and we should select the CURRENT
000974r 3                               ; history buffer.
000974r 3  A9 08                        lda #$8
000976r 3  24 rr                        bit status
000978r 3  D0 07                        bne @recall_history
00097Ar 3               
00097Ar 3                               ; This isn't the first time CTRL-n has been pressed, select the
00097Ar 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
00097Ar 3  A5 rr                        lda status
00097Cr 3  29 F7                        and #$f7
00097Er 3               
00097Er 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
00097Er 3  1A                           inc
00097Fr 3               
00097Fr 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
00097Fr 3                               ; be cleared below.
00097Fr 3  85 rr                        sta status
000981r 3               
000981r 3                               ; Falls through to @recall_history
000981r 3               
000981r 3               @recall_history:
000981r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
000981r 3  A9 08                        lda #%00001000
000983r 3  14 rr                        trb status
000985r 3               
000985r 3  20 rr rr                     jsr total_recall
000988r 3               
000988r 3                               ; tmp3 now has the address of the previous history buffer.
000988r 3                               ; First byte of buffer is length. Clear the line by sending
000988r 3                               ; CR, Y spaces, then CR.
000988r 3  A9 0D                        lda #AscCR
00098Ar 3  20 rr rr                     jsr emit_a
00098Dr 3               
00098Dr 3               input_clear:
00098Dr 3  C0 00                        cpy #0
00098Fr 3  F0 08                        beq input_cleared
000991r 3               
000991r 3  A9 20                        lda #AscSP
000993r 3  20 rr rr                     jsr emit_a
000996r 3  88                           dey
000997r 3  80 F4                        bra input_clear
000999r 3               
000999r 3               input_cleared:
000999r 3  A9 0D                        lda #AscCR
00099Br 3  20 rr rr                     jsr emit_a
00099Er 3               
00099Er 3                               ; Save the history length byte into histinfo+1
00099Er 3                               ; ldy #0        ; Y is already 0 by clearing the line.
00099Er 3  B1 rr                        lda (tmp3),y
0009A0r 3  85 rr                        sta status+1
0009A2r 3               
0009A2r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
0009A2r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
0009A2r 3                               ; buffer)
0009A2r 3  E6 rr                        inc tmp3
0009A4r 3  D0 02                        bne @2           ; Increment the upper byte on carry.
0009A6r 3  E6 rr                        inc tmp3+1
0009A8r 3               @2:
0009A8r 3                               ; Copy the history buffer into the input buffer,
0009A8r 3                               ; sending the characters to the output as we go.
0009A8r 3  A9 0D                        lda #AscCR
0009AAr 3  20 rr rr                     jsr emit_a
0009ADr 3               
0009ADr 3               @history_loop:
0009ADr 3                               ; See if we have reached the end of the history buffer.
0009ADr 3  C4 rr                        cpy status+1
0009AFr 3  D0 03                        bne @3
0009B1r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
0009B4r 3               @3:
0009B4r 3                               ; See if we have reached the end of the input buffer.
0009B4r 3                               ; (only comparing to lower byte as we currently limit
0009B4r 3                               ; to 255 characters max)
0009B4r 3  C4 rr                        cpy tmp2
0009B6r 3  F0 0A                        beq @hist_filled_buffer
0009B8r 3               
0009B8r 3                               ; Copy a character and echo.
0009B8r 3  B1 rr                        lda (tmp3),y
0009BAr 3  91 rr                        sta (tmp1),y
0009BCr 3  20 rr rr                     jsr emit_a
0009BFr 3               
0009BFr 3                               ; Move to the next character.
0009BFr 3  C8                           iny
0009C0r 3  80 EB                        bra @history_loop
0009C2r 3               
0009C2r 3               @hist_filled_buffer:
0009C2r 3                               ; We don't want a history recall to EOL our buffer,
0009C2r 3                               ; so back up one character and return to editing.
0009C2r 3  88                           dey
0009C3r 3  4C rr rr                     jmp accept_loop
0009C6r 3               accept_done:
0009C6r 3               @done:
0009C6r 3                               ; Copy the input buffer into the currently
0009C6r 3                               ; selected history buffer.
0009C6r 3  20 rr rr                     jsr total_recall
0009C9r 3  85 rr                        sta status+1
0009CBr 3               
0009CBr 3                               ; Also save it in the first buffer byte.
0009CBr 3  A0 00                        ldy #0
0009CDr 3  91 rr                        sta (tmp3),y
0009CFr 3               
0009CFr 3                               ; Move path the count to the data bytes
0009CFr 3  E6 rr                        inc tmp3
0009D1r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
0009D3r 3  E6 rr                        inc tmp3+1
0009D5r 3               @4:
0009D5r 3                               ; Copy the characters from the input buffer to the
0009D5r 3                               ; history buffer.
0009D5r 3               
0009D5r 3               @save_history_loop:
0009D5r 3  C4 rr                        cpy status+1
0009D7r 3  F0 07                        beq @save_history_done
0009D9r 3               
0009D9r 3  B1 rr                        lda (tmp1),y
0009DBr 3  91 rr                        sta (tmp3),y
0009DDr 3  C8                           iny
0009DEr 3  80 F5                        bra @save_history_loop
0009E0r 3               
0009E0r 3               @save_history_done:
0009E0r 3               z_accept:
0009E0r 3  60                           rts
0009E1r 3               
0009E1r 3               total_recall:
0009E1r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
0009E1r 3               
0009E1r 3                               ; Generate the address of the buffer in tmp3. Start with the
0009E1r 3                               ; base address.
0009E1r 3  A9 rr                        lda #<hist_buff
0009E3r 3  85 rr                        sta tmp3
0009E5r 3  A9 rr                        lda #>hist_buff
0009E7r 3  85 rr                        sta tmp3+1
0009E9r 3               
0009E9r 3                               ; This is a bit annoying as some bits go into each byte.
0009E9r 3                               ; .....xxx gets put into address like ......xx x.......
0009E9r 3  A5 rr                        lda status
0009EBr 3  6A                           ror
0009ECr 3  29 03                        and #3
0009EEr 3  18                           clc
0009EFr 3  65 rr                        adc tmp3+1
0009F1r 3  85 rr                        sta tmp3+1
0009F3r 3               
0009F3r 3  A5 rr                        lda status
0009F5r 3  6A                           ror             ; Rotate through carry into msb.
0009F6r 3  6A                           ror
0009F7r 3  29 80                        and #$80
0009F9r 3  18                           clc
0009FAr 3  65 rr                        adc tmp3
0009FCr 3  85 rr                        sta tmp3
0009FEr 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000A00r 3  E6 rr                        inc tmp3+1
000A02r 3               @1:
000A02r 3                               ; Save the current length of the input buffer in
000A02r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000A02r 3  98                           tya
000A03r 3  C9 80                        cmp #$80
000A05r 3  90 02                        bcc @2
000A07r 3  A9 7F                        lda #$7F
000A09r 3               @2:
000A09r 3  60                           rts
000A0Ar 3               
000A0Ar 3               
000A0Ar 3               
000A0Ar 3               
000A0Ar 3               
000A0Ar 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000A0Ar 3               ; ## "action-of"  auto  ANS core ext
000A0Ar 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000A0Ar 3               
000A0Ar 3               xt_action_of:
000A0Ar 3                               ; This is a state aware word with differet behavior
000A0Ar 3                               ; when used while compiling vs interpreting.
000A0Ar 3                               ; Check STATE
000A0Ar 3  A5 rr                        lda state
000A0Cr 3  05 rr                        ora state+1
000A0Er 3  F0 0C                        beq @interpreting
000A10r 3               
000A10r 3               @compiling:
000A10r 3                               ; Run ['] to compile the xt of the next word
000A10r 3                               ; as a literal.
000A10r 3  20 rr rr                     jsr xt_bracket_tick
000A13r 3               
000A13r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000A13r 3  A0 rr                        ldy #>xt_defer_fetch
000A15r 3  A9 rr                        lda #<xt_defer_fetch
000A17r 3  20 rr rr                     jsr cmpl_subroutine
000A1Ar 3  80 06                        bra @done
000A1Cr 3               
000A1Cr 3               @interpreting:
000A1Cr 3  20 rr rr                     jsr xt_tick
000A1Fr 3  20 rr rr                     jsr xt_defer_fetch
000A22r 3               
000A22r 3               @done:
000A22r 3  60           z_action_of:           rts
000A23r 3               
000A23r 3               
000A23r 3               
000A23r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000A23r 3               ; ## "again"  tested  ANS core ext
000A23r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000A23r 3               
000A23r 3               xt_again:
000A23r 3  20 rr rr                     jsr underflow_1
000A26r 3               
000A26r 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
000A26r 3                               ; so we have the range and don't have to calculate the
000A26r 3                               ; offset.
000A26r 3  A0 00                        ldy #0
000A28r 3  A9 4C                        lda #$4C        ; JMP
000A2Ar 3  91 rr                        sta (cp),y
000A2Cr 3  C8                           iny
000A2Dr 3               
000A2Dr 3  B5 00                        lda 0,x         ; LSB of address
000A2Fr 3  91 rr                        sta (cp),y
000A31r 3  C8                           iny
000A32r 3               
000A32r 3  B5 01                        lda 1,x         ; MSB of address
000A34r 3  91 rr                        sta (cp),y
000A36r 3  C8                           iny
000A37r 3               
000A37r 3                               ; Allot the space we just used
000A37r 3  98                           tya
000A38r 3  18                           clc
000A39r 3  65 rr                        adc cp
000A3Br 3  85 rr                        sta cp
000A3Dr 3  90 02                        bcc @done
000A3Fr 3  E6 rr                        inc cp+1
000A41r 3               @done:
000A41r 3  E8                           inx
000A42r 3  E8                           inx
000A43r 3               
000A43r 3  60           z_again:        rts
000A44r 3               
000A44r 3               
000A44r 3               
000A44r 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
000A44r 3               ; ## "align"  auto  ANS core
000A44r 3                       ; """https://forth-standard.org/standard/core/ALIGN
000A44r 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
000A44r 3                       ; routine as well, and also does nothing
000A44r 3                       ; """
000A44r 3               
000A44r 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
000A44r 3               ; ## "aligned"  auto  ANS core
000A44r 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
000A44r 3               
000A44r 3               xt_align:
000A44r 3               xt_aligned:
000A44r 3               z_align:
000A44r 3  60           z_aligned:      rts             ; stripped out during native compile
000A45r 3               
000A45r 3               
000A45r 3               
000A45r 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
000A45r 3               ; ## "allot"  auto  ANS core
000A45r 3                       ; """https://forth-standard.org/standard/core/ALLOT
000A45r 3                       ; Reserve a certain number of bytes (not cells) or release them.
000A45r 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
000A45r 3                       ; to the beginning of the Dictionary. If n is positive (the most
000A45r 3                       ; common case), reserve n bytes, but not past the end of the
000A45r 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
000A45r 3                       ; """
000A45r 3               
000A45r 3               xt_allot:
000A45r 3  20 rr rr                     jsr underflow_1
000A48r 3               
000A48r 3                               ; Releasing memory is going to be a very rare operation,
000A48r 3                               ; so we check for it at the beginning and try to make
000A48r 3                               ; the most common case as fast as possible
000A48r 3  B5 01                        lda 1,x
000A4Ar 3  30 22                        bmi @release
000A4Cr 3               
000A4Cr 3                               ; Common case: We are reserving memory, not releasing it
000A4Cr 3  18                           clc
000A4Dr 3  A5 rr                        lda cp
000A4Fr 3  75 00                        adc 0,x
000A51r 3  85 rr                        sta cp
000A53r 3               
000A53r 3  A5 rr                        lda cp+1
000A55r 3  75 01                        adc 1,x
000A57r 3  85 rr                        sta cp+1
000A59r 3               
000A59r 3                               ; Wait, did we just grant more space than we have? This is
000A59r 3                               ; a check we only do here, not for other situations like cmpl_a
000A59r 3                               ; where smaller amounts are reserved.
000A59r 3  A0 FF                        ldy #<cp_end
000A5Br 3  C4 rr                        cpy cp
000A5Dr 3  A9 7F                        lda #>cp_end
000A5Fr 3  E5 rr                        sbc cp+1
000A61r 3  B0 48                        bcs @done               ; we're fine.
000A63r 3               
000A63r 3                               ; Oops, that was too much, we're beyond the end of
000A63r 3                               ; legal Dictionary RAM. Reduce to max memory and report
000A63r 3                               ; an error
000A63r 3  84 rr                        sty cp                  ; still #<cp_end
000A65r 3  A9 7F                        lda #>cp_end
000A67r 3  85 rr                        sta cp+1
000A69r 3               
000A69r 3  A9 00                        lda #err_allot
000A6Br 3  4C rr rr                     jmp error
000A6Er 3               
000A6Er 3               @release:
000A6Er 3                  		; The ANS standard doesn't really say what to do if too much
000A6Er 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
000A6Er 3                               ; even an official test. Gforth is little help either. The good
000A6Er 3                               ; news is, this is going to be a rare case. We want to use as
000A6Er 3                               ; few bytes as possible.
000A6Er 3               
000A6Er 3                               ; What we do is let the user free anything up to the beginning
000A6Er 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
000A6Er 3                               ; their own risk. This means that the Dictionary pointer DP
000A6Er 3                               ; might end up pointing to garbage. However, an attempt to
000A6Er 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
000A6Er 3                               ; the DP pointing to the last word in RAM (should be DROP) and
000A6Er 3                               ; an error message.
000A6Er 3               
000A6Er 3                               ; We arrive here with ( n ) which is negative. First step,
000A6Er 3                               ; subtract the number TOS from the CP for a new CP
000A6Er 3  CA                           dex
000A6Fr 3  CA                           dex
000A70r 3  A5 rr                        lda cp
000A72r 3  95 00                        sta 0,x
000A74r 3  A5 rr                        lda cp+1
000A76r 3  95 01                        sta 1,x
000A78r 3               
000A78r 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
000A7Br 3               
000A7Br 3                               ; Second step, see if we've gone too far. We compare the new
000A7Br 3                               ; CP on TOS (which, if we've really screwed up, might be
000A7Br 3                               ; negative) with CP0. This is a signed comparison
000A7Br 3  CA                           dex
000A7Cr 3  CA                           dex                             ; new CP now NOS
000A7Dr 3  A9 rr                        lda #<cp0
000A7Fr 3  95 00                        sta 0,x
000A81r 3  A9 rr                        lda #>cp0
000A83r 3  95 01                        sta 1,x                         ; CP0 is TOS
000A85r 3               
000A85r 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
000A88r 3               
000A88r 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
000A88r 3                               ; This means we want Z=1 or N=1
000A88r 3  F0 17                        beq @nega_done
000A8Ar 3  30 15                        bmi @nega_done
000A8Cr 3               
000A8Cr 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
000A8Cr 3                               ; word in ROM (should be DROP), and abort with an error
000A8Cr 3  A9 rr                        lda #<cp0
000A8Er 3  85 rr                        sta cp
000A90r 3  A9 rr                        lda #>cp0
000A92r 3  85 rr                        sta cp+1
000A94r 3               
000A94r 3  A9 rr                        lda #<dictionary_start
000A96r 3  85 rr                        sta dp
000A98r 3  A9 rr                        lda #>dictionary_start
000A9Ar 3  85 rr                        sta dp+1
000A9Cr 3               
000A9Cr 3  A9 0A                        lda #err_negallot
000A9Er 3  4C rr rr                     jmp error
000AA1r 3               
000AA1r 3               @nega_done:
000AA1r 3                               ; Save new CP, which is NOS
000AA1r 3  B5 02                        lda 2,x
000AA3r 3  85 rr                        sta cp
000AA5r 3  B5 03                        lda 3,x
000AA7r 3  85 rr                        sta cp+1
000AA9r 3               
000AA9r 3  E8                           inx
000AAAr 3  E8                           inx                     ; drop through to @done
000AABr 3               @done:
000AABr 3  E8                           inx
000AACr 3  E8                           inx
000AADr 3               z_allot:
000AADr 3  60                           rts
000AAEr 3               
000AAEr 3               
000AAEr 3               
000AAEr 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000AAEr 3               ; ## "allow-native"  auto  Tali Forth
000AAEr 3               xt_allow_native:
000AAEr 3  20 rr rr                     jsr current_to_dp
000AB1r 3  A0 01                        ldy #1          ; offset for status byte
000AB3r 3  B1 rr                        lda (dp),y
000AB5r 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
000AB7r 3  91 rr                        sta (dp),y
000AB9r 3               z_allow_native:
000AB9r 3  60                           rts
000ABAr 3               
000ABAr 3               
000ABAr 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000ABAr 3               ; ## "also"  auto  ANS search ext
000ABAr 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000ABAr 3               xt_also:
000ABAr 3  20 rr rr                     jsr xt_get_order
000ABDr 3  20 rr rr                     jsr xt_over
000AC0r 3  20 rr rr                     jsr xt_swap
000AC3r 3  20 rr rr                     jsr xt_one_plus
000AC6r 3  20 rr rr                     jsr xt_set_order
000AC9r 3               
000AC9r 3  60           z_also:         rts
000ACAr 3               
000ACAr 3               
000ACAr 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000ACAr 3               ; ## "always-native"  auto  Tali Forth
000ACAr 3               xt_always_native:
000ACAr 3  20 rr rr                     jsr current_to_dp
000ACDr 3  A0 01                        ldy #1          ; offset for status byte
000ACFr 3  B1 rr                        lda (dp),y
000AD1r 3  09 02                        ora #AN         ; Make sure AN flag is set
000AD3r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
000AD5r 3  91 rr                        sta (dp),y
000AD7r 3               z_always_native:
000AD7r 3  60                           rts
000AD8r 3               
000AD8r 3               
000AD8r 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
000AD8r 3               ; ## "and"  auto  ANS core
000AD8r 3                       ; """https://forth-standard.org/standard/core/AND"""
000AD8r 3               xt_and:
000AD8r 3  20 rr rr                     jsr underflow_2
000ADBr 3               
000ADBr 3  B5 00                        lda 0,x
000ADDr 3  35 02                        and 2,x
000ADFr 3  95 02                        sta 2,x
000AE1r 3               
000AE1r 3  B5 01                        lda 1,x
000AE3r 3  35 03                        and 3,x
000AE5r 3  95 03                        sta 3,x
000AE7r 3               
000AE7r 3  E8                           inx
000AE8r 3  E8                           inx
000AE9r 3               
000AE9r 3  60           z_and:          rts
000AEAr 3               
000AEAr 3               
000AEAr 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000AEAr 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000AEAr 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000AEAr 3                       ; assembler words to the search order so they can be used.
000AEAr 3                       ; See the tutorial on Wordlists and the Search Order for
000AEAr 3                       ; more information.
000AEAr 3                       ;
000AEAr 3                       ; This is a dummy entry, the code is shared with TWO
000AEAr 3                       ; """
000AEAr 3               
000AEAr 3               
000AEAr 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000AEAr 3               ; ## "at-xy"  tested  ANS facility
000AEAr 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000AEAr 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000AEAr 3                       ; ANSI code is ESC[<n>;<m>H
000AEAr 3                       ;
000AEAr 3                       ; Do not use U. to print the numbers because the
000AEAr 3                       ; trailing space will not work with xterm
000AEAr 3                       ; """
000AEAr 3               xt_at_xy:
000AEAr 3  20 rr rr                     jsr underflow_2
000AEDr 3               
000AEDr 3  A9 1B                        lda #AscESC
000AEFr 3  20 rr rr                     jsr emit_a
000AF2r 3  A9 5B                        lda #$5B        ; ASCII for "["
000AF4r 3  20 rr rr                     jsr emit_a
000AF7r 3  20 rr rr                     jsr print_u
000AFAr 3  A9 3B                        lda #$3B        ; ASCII for ";"
000AFCr 3  20 rr rr                     jsr emit_a
000AFFr 3  20 rr rr                     jsr print_u
000B02r 3  A9 48                        lda #'H'
000B04r 3  20 rr rr                     jsr emit_a
000B07r 3               
000B07r 3  60           z_at_xy:        rts
000B08r 3               
000B08r 3               
000B08r 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
000B08r 3               ; ## "\"  auto  ANS core ext
000B08r 3                       ; """https://forth-standard.org/standard/core/bs"""
000B08r 3               xt_backslash:
000B08r 3  A5 rr                        lda ciblen
000B0Ar 3  85 rr                        sta toin
000B0Cr 3  A5 rr                        lda ciblen+1
000B0Er 3  85 rr                        sta toin+1
000B10r 3               
000B10r 3  60           z_backslash:    rts
000B11r 3               
000B11r 3               
000B11r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000B11r 3               ; ## "base"  auto  ANS core
000B11r 3                       ; """https://forth-standard.org/standard/core/BASE
000B11r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000B11r 3                       ; ingore the MSB
000B11r 3                       ; """
000B11r 3               xt_base:
000B11r 3  CA                           dex
000B12r 3  CA                           dex
000B13r 3  A9 rr                        lda #<base
000B15r 3  95 00                        sta 0,x         ; LSB
000B17r 3  74 01                        stz 1,x         ; MSB is always 0
000B19r 3               
000B19r 3  60           z_base:         rts
000B1Ar 3               
000B1Ar 3               
000B1Ar 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000B1Ar 3               ; ## "begin"  auto  ANS core
000B1Ar 3                       ; """https://forth-standard.org/standard/core/BEGIN
000B1Ar 3                       ;
000B1Ar 3                       ; This is just an immediate version of here which could just
000B1Ar 3                       ; as well be coded in Forth as
000B1Ar 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000B1Ar 3                       ; Since this is a compiling word, we don't care that much about
000B1Ar 3                       ; about speed
000B1Ar 3                       ; """
000B1Ar 3               
000B1Ar 3               xt_begin:
000B1Ar 3  20 rr rr                     jsr xt_here
000B1Dr 3  60           z_begin:        rts
000B1Er 3               
000B1Er 3               
000B1Er 3               
000B1Er 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000B1Er 3               ; ## "bell"  tested  Tali Forth
000B1Er 3               xt_bell:
000B1Er 3  A9 07                        lda #7          ; ASCII value for BELl
000B20r 3  20 rr rr                     jsr emit_a
000B23r 3               
000B23r 3  60           z_bell:         rts
000B24r 3               
000B24r 3               
000B24r 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
000B24r 3               ; ## "bl"  auto  ANS core
000B24r 3                       ; """https://forth-standard.org/standard/core/BL"""
000B24r 3               
000B24r 3               xt_bl:
000B24r 3  CA                           dex
000B25r 3  CA                           dex
000B26r 3  A9 20                        lda #AscSP
000B28r 3  95 00                        sta 0,x
000B2Ar 3  74 01                        stz 1,x
000B2Cr 3               
000B2Cr 3  60           z_bl:           rts
000B2Dr 3               
000B2Dr 3               
000B2Dr 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000B2Dr 3               ; ## "block"  auto  ANS block
000B2Dr 3                       ; """https://forth-standard.org/standard/block/BLK"""
000B2Dr 3               xt_blk:
000B2Dr 3                               ; BLK is at UP + blk_offset
000B2Dr 3  CA                           dex
000B2Er 3  CA                           dex
000B2Fr 3  18                           clc
000B30r 3  A5 rr                        lda up
000B32r 3  69 00                        adc #blk_offset ; Add offset
000B34r 3  95 00                        sta 0,x
000B36r 3  A5 rr                        lda up+1
000B38r 3  69 00                        adc #0          ; Adding carry
000B3Ar 3  95 01                        sta 1,x
000B3Cr 3               
000B3Cr 3  60           z_blk:          rts
000B3Dr 3               
000B3Dr 3               
000B3Dr 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
000B3Dr 3               ; ## "blkbuffer"  auto  Tali block
000B3Dr 3               xt_blkbuffer:
000B3Dr 3                               ; blkbuffer address is at UP + blkbuffer_offset.
000B3Dr 3                               ; Unlike some of the other user variables, we actually
000B3Dr 3                               ; want to push the address stored here, which will
000B3Dr 3                               ; point to somewhere outside of the user variables.
000B3Dr 3  CA                           dex
000B3Er 3  CA                           dex
000B3Fr 3                               ; Put the address on the stack.
000B3Fr 3  A0 28                        ldy #blkbuffer_offset
000B41r 3  B1 rr                        lda (up),y
000B43r 3  95 00                        sta 0,x
000B45r 3  C8                           iny             ; Move along to the next byte
000B46r 3  B1 rr                        lda (up),y
000B48r 3  95 01                        sta 1,x
000B4Ar 3               
000B4Ar 3  60           z_blkbuffer:    rts
000B4Br 3               
000B4Br 3               
000B4Br 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
000B4Br 3               ; ## "block"  auto  ANS block
000B4Br 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
000B4Br 3               
000B4Br 3               xt_block:
000B4Br 3               
000B4Br 3                               ; See if the block requested is the same as the one we
000B4Br 3                               ; currently have in the buffer. Check the LSB.
000B4Br 3  A0 2A                        ldy #buffblocknum_offset
000B4Dr 3  B1 rr                        lda (up),y
000B4Fr 3  D5 00                        cmp 0,x
000B51r 3  D0 0F                        bne @not_in_buffer
000B53r 3               
000B53r 3                               ; Check the MSB.
000B53r 3  C8                           iny
000B54r 3  B1 rr                        lda (up),y
000B56r 3  D5 01                        cmp 1,x
000B58r 3  D0 08                        bne @not_in_buffer
000B5Ar 3               
000B5Ar 3                               ; The block is in the buffer. See if the buffer is in use.
000B5Ar 3  A0 2C                        ldy #buffstatus_offset
000B5Cr 3  B1 rr                        lda (up),y
000B5Er 3  29 01                        and #1          ; Check the in-use flag (bit 0)
000B60r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
000B62r 3                                               ; @done will replace the block# with the
000B62r 3                                               ; buffer address.
000B62r 3               @not_in_buffer:
000B62r 3                               ; Check the buffer status
000B62r 3  A0 2C                        ldy #buffstatus_offset
000B64r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000B66r 3  C9 03                        cmp #3          ; LSB is needed.
000B68r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000B6Ar 3               
000B6Ar 3                               ; We need to save the block.
000B6Ar 3  20 rr rr                     jsr xt_blkbuffer
000B6Dr 3  20 rr rr                     jsr xt_buffblocknum
000B70r 3  20 rr rr                     jsr xt_fetch
000B73r 3  20 rr rr                     jsr xt_block_write
000B76r 3               
000B76r 3               @buffer_available:
000B76r 3                               ; Save the block number.
000B76r 3  A0 2A                        ldy #buffblocknum_offset
000B78r 3  B5 00                        lda 0,x
000B7Ar 3  91 rr                        sta (up),y
000B7Cr 3  C8                           iny
000B7Dr 3  B5 01                        lda 1,x
000B7Fr 3  91 rr                        sta (up),y
000B81r 3               
000B81r 3                               ; Get the requested block.
000B81r 3  20 rr rr                     jsr xt_blkbuffer
000B84r 3  20 rr rr                     jsr xt_swap
000B87r 3  20 rr rr                     jsr xt_block_read
000B8Ar 3               
000B8Ar 3                               ; Mark the buffer as clean and in-use.
000B8Ar 3  A9 01                        lda #1
000B8Cr 3  A0 2C                        ldy #buffstatus_offset
000B8Er 3  91 rr                        sta (up),y
000B90r 3               
000B90r 3                               ; Make room on the stack for the return address.
000B90r 3  CA                           dex
000B91r 3  CA                           dex
000B92r 3               
000B92r 3               @done:
000B92r 3                               ; It's in the buffer. Return the buffer address.
000B92r 3  A0 28                        ldy #blkbuffer_offset
000B94r 3  B1 rr                        lda (up),y
000B96r 3  95 00                        sta 0,x
000B98r 3  C8                           iny
000B99r 3  B1 rr                        lda (up),y
000B9Br 3  95 01                        sta 1,x
000B9Dr 3               
000B9Dr 3  60           z_block:        rts
000B9Er 3               
000B9Er 3               
000B9Er 3               
000B9Er 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000B9Er 3               ; ## "block-ramdrive-init"  auto  Tali block
000B9Er 3                       ; """Create a RAM drive, with the given number of
000B9Er 3                       ; blocks, in the dictionary along with setting up the block words to
000B9Er 3                       ; use it.  The read/write routines do not provide bounds checking.
000B9Er 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000B9Er 3                       ; """
000B9Er 3               
000B9Er 3               xt_block_ramdrive_init:
000B9Er 3  20 rr rr                     jsr underflow_1
000BA1r 3               
000BA1r 3                               ; Store the string to run here as a string literal.
000BA1r 3                               ; See SLITERAL for the format information. This way, we
000BA1r 3                               ; don't have the words defined below in the Dictionary until
000BA1r 3                               ; we really use them.
000BA1r 3  4C rr rr                     jmp @after_ramdrive_code
000BA4r 3               
000BA4r 3               @ramdrive_code:
000BA4r 3  62 61 73 65          .byte "base @ swap decimal"
000BA8r 3  20 40 20 73  
000BACr 3  77 61 70 20  
000BB7r 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000BBBr 3  34 20 2A     
000BBEr 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000BC2r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
000BC6r 3  66 65 72 3A  
000BCAr 3  20 72 61 6D  
000BD3r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000BD3r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
000BD7r 3  6C 6F 63 6B  
000BDBr 3  2D 72 65 61  
000BE9r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000BEDr 3  64 72 69 76  
000BF1r 3  65 20 73 77  
000C11r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
000C15r 3  6C 6F 63 6B  
000C19r 3  2D 77 72 69  
000C28r 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000C2Cr 3  64 72 69 76  
000C30r 3  65 20 73 77  
000C4Br 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
000C4Fr 3  6C 6F 63 6B  
000C53r 3  2D 72 65 61  
000C75r 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
000C79r 3  6C 6F 63 6B  
000C7Dr 3  2D 77 72 69  
000CA1r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
000CA5r 3  64 72 69 76  
000CA9r 3  65 20 73 77  
000CBCr 3               
000CBCr 3               @after_ramdrive_code:
000CBCr 3  20 rr rr                     jsr sliteral_runtime
000CBFr 3               
000CBFr 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000CC3r 3               
000CC3r 3                               ; The address and length of the ramdrive code is now on the
000CC3r 3                               ; stack. Call EVALUATE to run it.
000CC3r 3  20 rr rr                     jsr xt_evaluate
000CC6r 3               
000CC6r 3               z_block_ramdrive_init:
000CC6r 3  60                           rts
000CC7r 3               
000CC7r 3               
000CC7r 3               
000CC7r 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
000CC7r 3               ; ## "block-read"  auto  Tali block
000CC7r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000CC7r 3                       ; with their own version to read a block from storage.
000CC7r 3                       ; The stack parameters are ( buffer_address block# -- ).
000CC7r 3                       ; """
000CC7r 3               xt_block_read:
000CC7r 3                               ; Execute the BLOCK-READ-VECTOR
000CC7r 3  A0 2E                        ldy #blockread_offset
000CC9r 3  B1 rr                        lda (up),y
000CCBr 3  85 rr                        sta tmp1
000CCDr 3  C8                           iny
000CCEr 3  B1 rr                        lda (up),y
000CD0r 3  85 rr                        sta tmp1+1
000CD2r 3               
000CD2r 3  6C rr rr                     jmp (tmp1)
000CD5r 3               
000CD5r 3               z_block_read:   ; No RTS needed
000CD5r 3               
000CD5r 3               
000CD5r 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
000CD5r 3               ; ## "block-read-vector"  auto  Tali block
000CD5r 3                       ; """BLOCK-READ is a vectored word that the user needs to override
000CD5r 3                       ; with their own version to read a block from storage.
000CD5r 3                       ; This word gives the address of the vector so it can be replaced.
000CD5r 3                       ; """
000CD5r 3               xt_block_read_vector:
000CD5r 3                               ; Get the BLOCK-READ-VECTOR address
000CD5r 3  CA                           dex
000CD6r 3  CA                           dex
000CD7r 3  18                           clc
000CD8r 3  A5 rr                        lda up
000CDAr 3  69 2E                        adc #blockread_offset
000CDCr 3  95 00                        sta 0,x
000CDEr 3  A5 rr                        lda up+1
000CE0r 3  69 00                        adc #0          ; Add carry
000CE2r 3  95 01                        sta 1,x
000CE4r 3               
000CE4r 3               z_block_read_vector:
000CE4r 3  60                           rts
000CE5r 3               
000CE5r 3               
000CE5r 3               ; This is the default error message the vectored words BLOCK-READ and
000CE5r 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
000CE5r 3               xt_block_word_error:
000CE5r 3  A9 0C                        lda #err_blockwords
000CE7r 3  4C rr rr                     jmp error       ; no RTS needed
000CEAr 3               z_block_word_error:
000CEAr 3               
000CEAr 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000CEAr 3               ; ## "block-write"  auto  Tali block
000CEAr 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000CEAr 3                       ; with their own version to write a block to storage.
000CEAr 3                       ; The stack parameters are ( buffer_address block# -- ).
000CEAr 3                       ; """
000CEAr 3               xt_block_write:
000CEAr 3                               ; Execute the BLOCK-READ-VECTOR
000CEAr 3  A0 30                        ldy #blockwrite_offset
000CECr 3  B1 rr                        lda (up),y
000CEEr 3  85 rr                        sta tmp1
000CF0r 3  C8                           iny
000CF1r 3  B1 rr                        lda (up),y
000CF3r 3  85 rr                        sta tmp1+1
000CF5r 3  6C rr rr                     jmp (tmp1)
000CF8r 3               
000CF8r 3               z_block_write:  ; No RTS needed
000CF8r 3               
000CF8r 3               
000CF8r 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
000CF8r 3               ; ## "block-write-vector"  auto  Tali block
000CF8r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000CF8r 3                       ; with their own version to write a block to storage.
000CF8r 3                       ; This word gives the address of the vector so it can be replaced.
000CF8r 3                       ; """
000CF8r 3               xt_block_write_vector:
000CF8r 3                               ; Get the BLOCK-WRITE-VECTOR address
000CF8r 3  CA                           dex
000CF9r 3  CA                           dex
000CFAr 3  18                           clc
000CFBr 3  A5 rr                        lda up
000CFDr 3  69 30                        adc #blockwrite_offset
000CFFr 3  95 00                        sta 0,x
000D01r 3  A5 rr                        lda up+1
000D03r 3  69 00                        adc #0          ; Add carry
000D05r 3  95 01                        sta 1,x
000D07r 3               
000D07r 3               z_block_write_vector:
000D07r 3  60                           rts
000D08r 3               
000D08r 3               
000D08r 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
000D08r 3               ; ## "bounds"  auto  Gforth
000D08r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
000D08r 3                       ; Given a string, return the correct Data Stack parameters for
000D08r 3                       ; a DO/LOOP loop over its characters. This is realized as
000D08r 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
000D08r 3                       ; """
000D08r 3               xt_bounds:
000D08r 3  20 rr rr                     jsr underflow_2
000D0Br 3               
000D0Br 3  18                           clc
000D0Cr 3  B5 00                        lda 0,x                 ; LSB u
000D0Er 3  B4 02                        ldy 2,x                 ; LSB addr
000D10r 3  75 02                        adc 2,x
000D12r 3  95 02                        sta 2,x                 ; LSB addr+u
000D14r 3  94 00                        sty 0,x
000D16r 3               
000D16r 3  B5 01                        lda 1,x                 ; MSB u
000D18r 3  B4 03                        ldy 3,x                 ; MSB addr
000D1Ar 3  75 03                        adc 3,x
000D1Cr 3  95 03                        sta 3,x                 ; MSB addr+u
000D1Er 3  94 01                        sty 1,x
000D20r 3               
000D20r 3  60           z_bounds:       rts
000D21r 3               
000D21r 3               
000D21r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000D21r 3               ; ## "[char]"  auto  ANS core
000D21r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000D21r 3                       ; Compile the ASCII value of a character as a literal. This is an
000D21r 3                       ; immediate, compile-only word.
000D21r 3                       ;
000D21r 3                       ; A definition given in
000D21r 3                       ; http://forth-standard.org/standard/implement is
000D21r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000D21r 3                       ; """
000D21r 3               xt_bracket_char:
000D21r 3  20 rr rr                     jsr xt_char
000D24r 3  20 rr rr                     jsr xt_literal
000D27r 3  60           z_bracket_char: rts
000D28r 3               
000D28r 3               
000D28r 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
000D28r 3               ; ## "[']"  auto  ANS core
000D28r 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
000D28r 3               xt_bracket_tick:
000D28r 3  20 rr rr                     jsr xt_tick
000D2Br 3  20 rr rr                     jsr xt_literal
000D2Er 3  60           z_bracket_tick: rts
000D2Fr 3               
000D2Fr 3               
000D2Fr 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000D2Fr 3               ; ## "buffblocknum"  auto  Tali block
000D2Fr 3               xt_buffblocknum:
000D2Fr 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000D2Fr 3  CA                           dex
000D30r 3  CA                           dex
000D31r 3  18                           clc
000D32r 3  A5 rr                        lda up
000D34r 3  69 2A                        adc #buffblocknum_offset        ; Add offset
000D36r 3  95 00                        sta 0,x
000D38r 3  A5 rr                        lda up+1
000D3Ar 3  69 00                        adc #0                          ; Adding carry
000D3Cr 3  95 01                        sta 1,x
000D3Er 3               
000D3Er 3  60           z_buffblocknum: rts
000D3Fr 3               
000D3Fr 3               
000D3Fr 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
000D3Fr 3               ; ## "buffer"  auto  ANS block
000D3Fr 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
000D3Fr 3               
000D3Fr 3               xt_buffer:
000D3Fr 3                               ; Check the buffer status
000D3Fr 3  A0 2C                        ldy #buffstatus_offset
000D41r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
000D43r 3  C9 03                        cmp #3          ; LSB is needed.
000D45r 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
000D47r 3               
000D47r 3                               ; We need to save the block.
000D47r 3  20 rr rr                     jsr xt_blkbuffer
000D4Ar 3  20 rr rr                     jsr xt_buffblocknum
000D4Dr 3  20 rr rr                     jsr xt_fetch
000D50r 3  20 rr rr                     jsr xt_block_write
000D53r 3               
000D53r 3               @buffer_available:
000D53r 3                               ; Save the block number.
000D53r 3  A0 2A                        ldy #buffblocknum_offset
000D55r 3  B5 00                        lda 0,x
000D57r 3  91 rr                        sta (up),y
000D59r 3  C8                           iny
000D5Ar 3  B5 01                        lda 1,x
000D5Cr 3  91 rr                        sta (up),y
000D5Er 3               
000D5Er 3                               ; Mark the buffer as clean and in-use.
000D5Er 3  A9 01                        lda #1
000D60r 3  A0 2C                        ldy #buffstatus_offset
000D62r 3  91 rr                        sta (up),y
000D64r 3               
000D64r 3               @done:
000D64r 3                               ; Return the buffer address.
000D64r 3  A0 28                        ldy #blkbuffer_offset
000D66r 3  B1 rr                        lda (up),y
000D68r 3  95 00                        sta 0,x
000D6Ar 3  C8                           iny
000D6Br 3  B1 rr                        lda (up),y
000D6Dr 3  95 01                        sta 1,x
000D6Fr 3               
000D6Fr 3  60           z_buffer:       rts
000D70r 3               
000D70r 3               
000D70r 3               
000D70r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
000D70r 3               ; ## "buffer:"  auto  ANS core ext
000D70r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
000D70r 3                               ; Create a buffer of size u that puts its address on the stack
000D70r 3                               ; when its name is used.
000D70r 3                               ; """
000D70r 3               xt_buffer_colon:
000D70r 3  20 rr rr                     jsr xt_create
000D73r 3  20 rr rr                     jsr xt_allot
000D76r 3  60           z_buffer_colon: rts
000D77r 3               
000D77r 3               
000D77r 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
000D77r 3               ; ## "buffstatus"  auto  Tali block
000D77r 3               xt_buffstatus:
000D77r 3                               ; BUFFSTATUS is at UP + buffstatus_offset
000D77r 3  CA                           dex
000D78r 3  CA                           dex
000D79r 3  18                           clc
000D7Ar 3  A5 rr                        lda up
000D7Cr 3  69 2C                        adc #buffstatus_offset  ; Add offset
000D7Er 3  95 00                        sta 0,x
000D80r 3  A5 rr                        lda up+1
000D82r 3  69 00                        adc #0                  ; Adding carry
000D84r 3  95 01                        sta 1,x
000D86r 3               
000D86r 3  60           z_buffstatus:   rts
000D87r 3               
000D87r 3               
000D87r 3               ; ## BYE ( -- ) "Break"
000D87r 3               ; ## "bye"  tested  ANS tools ext
000D87r 3                       ; """https://forth-standard.org/standard/tools/BYE"""
000D87r 3               
000D87r 3               xt_bye:
000D87r 3                               ;brk
000D87r 3  4C rr rr                     jmp platform_bye
000D8Ar 3               z_bye:          ;rts             ; never reached
000D8Ar 3               
000D8Ar 3               
000D8Ar 3               
000D8Ar 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
000D8Ar 3               ; ## "c,"  auto  ANS core
000D8Ar 3                       ; """https://forth-standard.org/standard/core/CComma"""
000D8Ar 3               
000D8Ar 3               xt_c_comma:
000D8Ar 3  20 rr rr                     jsr underflow_1
000D8Dr 3               
000D8Dr 3  B5 00                        lda 0,x
000D8Fr 3  20 rr rr                     jsr cmpl_a
000D92r 3               
000D92r 3  E8                           inx
000D93r 3  E8                           inx
000D94r 3               
000D94r 3  60           z_c_comma:      rts
000D95r 3               
000D95r 3               
000D95r 3               
000D95r 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
000D95r 3               ; ## "c@"  auto  ANS core
000D95r 3                       ; """https://forth-standard.org/standard/core/CFetch"""
000D95r 3               xt_c_fetch:
000D95r 3  20 rr rr                     jsr underflow_1
000D98r 3               
000D98r 3  A1 00                        lda (0,x)
000D9Ar 3  95 00                        sta 0,x
000D9Cr 3  74 01                        stz 1,x         ; Ignore LSB
000D9Er 3               
000D9Er 3  60           z_c_fetch:      rts
000D9Fr 3               
000D9Fr 3               
000D9Fr 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000D9Fr 3               ; ## "c!"  auto  ANS core
000D9Fr 3                       ; """https://forth-standard.org/standard/core/CStore"""
000D9Fr 3               xt_c_store:
000D9Fr 3  20 rr rr                     jsr underflow_2
000DA2r 3               
000DA2r 3  B5 02                        lda 2,x
000DA4r 3  81 00                        sta (0,x)
000DA6r 3               
000DA6r 3  E8                           inx
000DA7r 3  E8                           inx
000DA8r 3  E8                           inx
000DA9r 3  E8                           inx
000DAAr 3               
000DAAr 3  60           z_c_store:      rts
000DABr 3               
000DABr 3               
000DABr 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000DABr 3               ; ## "case"  auto  ANS core ext
000DABr 3                       ; """http://forth-standard.org/standard/core/CASE
000DABr 3                       ;
000DABr 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000DABr 3                       ; """
000DABr 3               
000DABr 3               
000DABr 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000DABr 3               ; ## "cell+"  auto  ANS core
000DABr 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000DABr 3                       ; Add the number of bytes ("address units") that one cell needs.
000DABr 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000DABr 3                       ; """
000DABr 3               
000DABr 3               xt_cell_plus:
000DABr 3  20 rr rr                     jsr underflow_1
000DAEr 3               
000DAEr 3  F6 00                        inc 0,x
000DB0r 3  D0 02                        bne @1
000DB2r 3  F6 01                        inc 1,x
000DB4r 3               @1:
000DB4r 3  F6 00                        inc 0,x
000DB6r 3  D0 02                        bne @done
000DB8r 3  F6 01                        inc 1,x
000DBAr 3               @done:
000DBAr 3  60           z_cell_plus:    rts
000DBBr 3               
000DBBr 3               
000DBBr 3               
000DBBr 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000DBBr 3               ; ## "cells"  auto  ANS core
000DBBr 3                       ; """https://forth-standard.org/standard/core/CELLS
000DBBr 3                       ;
000DBBr 3                       ; Dummy entry for the CELLS word, the code is the same as for
000DBBr 3                       ; 2*, which is where the header directs us to
000DBBr 3                       ; """
000DBBr 3               
000DBBr 3               
000DBBr 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000DBBr 3               ; ## "char"  auto  ANS core
000DBBr 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000DBBr 3               
000DBBr 3               xt_char:
000DBBr 3                               ; get character from string, returns ( addr u )
000DBBr 3  20 rr rr                     jsr xt_parse_name
000DBEr 3               
000DBEr 3                               ; if we got back a zero, we have a problem
000DBEr 3  B5 00                        lda 0,x
000DC0r 3  15 01                        ora 1,x
000DC2r 3  D0 05                        bne @not_empty
000DC4r 3               
000DC4r 3  A9 05                        lda #err_noname
000DC6r 3  4C rr rr                     jmp error
000DC9r 3               
000DC9r 3               @not_empty:
000DC9r 3  E8                           inx             ; drop number of characters, leave addr
000DCAr 3  E8                           inx
000DCBr 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000DCDr 3  95 00                        sta 0,x
000DCFr 3  74 01                        stz 1,x         ; MSB is always zero
000DD1r 3               
000DD1r 3  60           z_char:         rts
000DD2r 3               
000DD2r 3               
000DD2r 3               
000DD2r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000DD2r 3               ; ## "char+"  auto  ANS core
000DD2r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000DD2r 3                       ;
000DD2r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000DD2r 3                       ; """
000DD2r 3               
000DD2r 3               
000DD2r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000DD2r 3               ; ## "chars"  auto  ANS core
000DD2r 3                       ; """https://forth-standard.org/standard/core/CHARS
000DD2r 3                       ; Return how many address units n chars are. Since this is an 8 bit
000DD2r 3                       ; machine, this does absolutely nothing and is included for
000DD2r 3                       ; compatibility with other Forth versions
000DD2r 3                       ; """
000DD2r 3               
000DD2r 3               xt_chars:
000DD2r 3                               ; Checking for underflow seems a bit stupid because this
000DD2r 3                               ; routine does nothing on this machine. However, the user
000DD2r 3                               ; should be warned that there is something wrong with the
000DD2r 3                               ; code if this occurs.
000DD2r 3  20 rr rr                     jsr underflow_1
000DD5r 3               
000DD5r 3  60           z_chars:        rts
000DD6r 3               
000DD6r 3               
000DD6r 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
000DD6r 3               ; ## "cleave"  auto  Tali Forth
000DD6r 3               
000DD6r 3                       ; """Given a range of memory with words delimited by whitespace,return
000DD6r 3                       ; the first word at the top of the stack and the rest of the word
000DD6r 3                       ; following it.
000DD6r 3                       ;
000DD6r 3                       ; Example:
000DD6r 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
000DD6r 3                       ; s" w1" cleave        -> "" "w1"
000DD6r 3                       ;
000DD6r 3                       ; Since it will be used in loops a lot, we want it to work in pure
000DD6r 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
000DD6r 3                       ; strip leading delimiters.
000DD6r 3                       ; """
000DD6r 3               
000DD6r 3               xt_cleave:
000DD6r 3  20 rr rr                     jsr underflow_2
000DD9r 3               
000DD9r 3                               ; We arrive here with ( addr u ). We need to strip any leading
000DD9r 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
000DD9r 3                               ; remember how many spaces were stripped. This means we can't
000DD9r 3                               ; calculate the length of the remainder. Fortunately, Tali
000DD9r 3                               ; Forth has just the word we need for this:
000DD9r 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000DDCr 3               
000DDCr 3                               ; The main part we can turn over to PARSE-NAME, except that we
000DDCr 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000DDCr 3                               ; We get around this by cheating: We place ( addr u ) in the
000DDCr 3                               ; input buffer and then call PARSE-NAME.
000DDCr 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000DDFr 3               
000DDFr 3  B5 00                        lda 0,x         ; u is new ciblen
000DE1r 3  85 rr                        sta ciblen
000DE3r 3  B5 01                        lda 1,x
000DE5r 3  85 rr                        sta ciblen+1
000DE7r 3               
000DE7r 3  B5 02                        lda 2,x         ; addr is new cib
000DE9r 3  85 rr                        sta cib
000DEBr 3  B5 03                        lda 3,x
000DEDr 3  85 rr                        sta cib+1
000DEFr 3               
000DEFr 3  64 rr                        stz toin        ; >IN pointer is zero
000DF1r 3  64 rr                        stz toin+1
000DF3r 3               
000DF3r 3                               ; PARSE-NAME gives us back the substring of the first word
000DF3r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
000DF6r 3               
000DF6r 3                               ; If we were given an empty string, then we're done. It's the
000DF6r 3                               ; resposibility of the user to catch this as a sign to end the
000DF6r 3                               ; any loop
000DF6r 3  B5 00                        lda 0,x
000DF8r 3  15 01                        ora 1,x
000DFAr 3  F0 23                        beq @done
000DFCr 3               
000DFCr 3                               ; Now we have to adjust the original string
000DFCr 3  B5 04                        lda 4,x         ; LSB of original u
000DFEr 3  38                           sec
000DFFr 3  F5 00                        sbc 0,x
000E01r 3  95 04                        sta 4,x
000E03r 3               
000E03r 3  B5 05                        lda 5,x         ; MSB of original u
000E05r 3  F5 01                        sbc 1,x
000E07r 3  95 05                        sta 5,x
000E09r 3               
000E09r 3  B5 06                        lda 6,x         ; LSB of original addr
000E0Br 3  18                           clc
000E0Cr 3  75 00                        adc 0,x
000E0Er 3  95 06                        sta 6,x
000E10r 3               
000E10r 3  B5 07                        lda 7,x         ; MSB of original addr
000E12r 3  75 01                        adc 1,x
000E14r 3  95 07                        sta 7,x
000E16r 3               
000E16r 3                               ; There is one small problem: PARSE-NAME will probably have
000E16r 3                               ; left the string with the rest of the words with leading
000E16r 3                               ; delimiters. We use our magic -LEADING again
000E16r 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
000E19r 3  20 rr rr                     jsr xt_minus_leading
000E1Cr 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000E1Fr 3               @done:
000E1Fr 3                               ; Restore input
000E1Fr 3  20 rr rr                     jsr xt_r_to_input
000E22r 3               
000E22r 3  60           z_cleave:       rts
000E23r 3               
000E23r 3               
000E23r 3               
000E23r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000E23r 3               ; ## "cmove"  auto  ANS string
000E23r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000E23r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000E23r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000E23r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000E23r 3                       ; "move left".
000E23r 3                       ;
000E23r 3                       ; There are no official tests for this word.
000E23r 3                       ; """
000E23r 3               
000E23r 3               xt_cmove:
000E23r 3  20 rr rr                     jsr underflow_3
000E26r 3               
000E26r 3                               ; move destination address to where we can work with it
000E26r 3  B5 02                        lda 2,x
000E28r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000E2Ar 3  B5 03                        lda 3,x
000E2Cr 3  85 rr                        sta tmp2+1
000E2Er 3               
000E2Er 3                               ; move source address to where we can work with it
000E2Er 3  B5 04                        lda 4,x
000E30r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000E32r 3  B5 05                        lda 5,x
000E34r 3  85 rr                        sta tmp1+1
000E36r 3               
000E36r 3  A0 00                        ldy #0
000E38r 3  B5 01                        lda 1,x         ; number of whole pages to move
000E3Ar 3  F0 0F                        beq @dopartial
000E3Cr 3               
000E3Cr 3               @page:
000E3Cr 3  B1 rr                        lda (tmp1),y
000E3Er 3  91 rr                        sta (tmp2),y
000E40r 3  C8                           iny
000E41r 3  D0 F9                        bne @page
000E43r 3               
000E43r 3  E6 rr                        inc tmp1+1
000E45r 3  E6 rr                        inc tmp2+1
000E47r 3  D6 01                        dec 1,x
000E49r 3  D0 F1                        bne @page
000E4Br 3               
000E4Br 3               @dopartial:
000E4Br 3  B5 00                        lda 0,x         ; length of last page
000E4Dr 3  F0 09                        beq @done
000E4Fr 3               
000E4Fr 3               @partial:
000E4Fr 3  B1 rr                        lda (tmp1),y
000E51r 3  91 rr                        sta (tmp2),y
000E53r 3  C8                           iny
000E54r 3               
000E54r 3  D6 00                        dec 0,x
000E56r 3  D0 F7                        bne @partial
000E58r 3               
000E58r 3               @done:          ; clear the stack
000E58r 3  8A                           txa
000E59r 3  18                           clc
000E5Ar 3  69 06                        adc #6
000E5Cr 3  AA                           tax
000E5Dr 3               
000E5Dr 3  60           z_cmove:        rts
000E5Er 3               
000E5Er 3               
000E5Er 3               
000E5Er 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
000E5Er 3               ; ## "cmove>"  auto  ANS string
000E5Er 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
000E5Er 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
000E5Er 3                       ; Routines", p. 201, where it is called "move right".
000E5Er 3                       ;
000E5Er 3                       ; There are no official tests for this word.
000E5Er 3                       ; """
000E5Er 3               
000E5Er 3               xt_cmove_up:
000E5Er 3  20 rr rr                     jsr underflow_3
000E61r 3               
000E61r 3                               ; Move destination address to where we can work with it
000E61r 3  B5 02                        lda 2,x
000E63r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000E65r 3  B5 03                        lda 3,x
000E67r 3  18                           clc
000E68r 3  75 01                        adc 1,x
000E6Ar 3  85 rr                        sta tmp2+1      ; point to last page of destination
000E6Cr 3               
000E6Cr 3                               ; Move source address to where we can work with it
000E6Cr 3  B5 04                        lda 4,x
000E6Er 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000E70r 3  B5 05                        lda 5,x
000E72r 3  18                           clc
000E73r 3  75 01                        adc 1,x
000E75r 3  85 rr                        sta tmp1+1      ; point to last page of source
000E77r 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
000E79r 3               
000E79r 3                               ; Move the last partial page first
000E79r 3  B4 00                        ldy 0,x         ; length of last page
000E7Br 3  F0 0E                        beq @nopartial
000E7Dr 3               
000E7Dr 3               @outerloop:
000E7Dr 3  88                           dey
000E7Er 3  F0 07                        beq @finishpage
000E80r 3               
000E80r 3               @innerloop:
000E80r 3  B1 rr                        lda (tmp1),y
000E82r 3  91 rr                        sta (tmp2),y
000E84r 3  88                           dey
000E85r 3  D0 F9                        bne @innerloop
000E87r 3               
000E87r 3               @finishpage:
000E87r 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
000E89r 3  92 rr                        sta (tmp2)
000E8Br 3               
000E8Br 3               @nopartial:
000E8Br 3  C6 rr                        dec tmp1+1      ; back up to previous pages
000E8Dr 3  C6 rr                        dec tmp2+1
000E8Fr 3  D6 01                        dec 1,x
000E91r 3  D0 EA                        bne @outerloop
000E93r 3               @done:
000E93r 3                               ; clear up the stack and leave
000E93r 3  8A                           txa
000E94r 3  18                           clc
000E95r 3  69 06                        adc #6
000E97r 3  AA                           tax
000E98r 3               
000E98r 3  60           z_cmove_up:     rts
000E99r 3               
000E99r 3               
000E99r 3               
000E99r 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
000E99r 3               ; ## ":"  auto  ANS core
000E99r 3                       ; """https://forth-standard.org/standard/core/Colon
000E99r 3                       ;
000E99r 3                       ; Use the CREATE routine and fill in the rest by hand.
000E99r 3                       ; """
000E99r 3               
000E99r 3               xt_colon:
000E99r 3                               ; If we're already in the compile state, complain
000E99r 3                               ; and quit
000E99r 3  A5 rr                        lda state
000E9Br 3  05 rr                        ora state+1
000E9Dr 3  F0 05                        beq @1
000E9Fr 3               
000E9Fr 3  A9 07                        lda #err_state
000EA1r 3  4C rr rr                     jmp error
000EA4r 3               @1:
000EA4r 3                               ; switch to compile state
000EA4r 3  C6 rr                        dec state
000EA6r 3  C6 rr                        dec state+1
000EA8r 3               
000EA8r 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
000EA8r 3                               ; word
000EA8r 3  A9 40                        lda #%01000000
000EAAr 3  04 rr                        tsb status
000EACr 3               
000EACr 3                               ; CREATE is going to change the DP to point to the new word's
000EACr 3                               ; header. While this is fine for (say) variables, it would mean
000EACr 3                               ; that FIND-NAME etc would find a half-finished word when
000EACr 3                               ; looking in the Dictionary. To prevent this, we save the old
000EACr 3                               ; version of DP and restore it later. The new DP is placed in
000EACr 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000EACr 3  20 rr rr                     jsr current_to_dp
000EAFr 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
000EB1r 3  48                           pha
000EB2r 3  A5 rr                        lda dp
000EB4r 3  48                           pha
000EB5r 3               
000EB5r 3                               ; Tell create not to print warning for duplicate name.
000EB5r 3  A9 80                        lda #%10000000
000EB7r 3  04 rr                        tsb status
000EB9r 3               
000EB9r 3  20 rr rr                     jsr xt_create
000EBCr 3               
000EBCr 3                               ; Get the nt (not the xt!) of the new word as described above.
000EBCr 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000EBCr 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000EBFr 3  A5 rr                        lda dp
000EC1r 3  85 rr                        sta workword
000EC3r 3  A5 rr                        lda dp+1
000EC5r 3  85 rr                        sta workword+1
000EC7r 3               
000EC7r 3                               ; Restore original DP
000EC7r 3  68                           pla
000EC8r 3  85 rr                        sta dp
000ECAr 3  68                           pla
000ECBr 3  85 rr                        sta dp+1
000ECDr 3  20 rr rr                     jsr dp_to_current
000ED0r 3               
000ED0r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000ED0r 3                               ; back up three bytes and overwrite that.
000ED0r 3  A5 rr                        lda cp
000ED2r 3  38                           sec
000ED3r 3  E9 03                        sbc #3
000ED5r 3  85 rr                        sta cp
000ED7r 3  B0 02                        bcs @done
000ED9r 3  C6 rr                        dec cp+1
000EDBr 3               @done:
000EDBr 3  60           z_colon:        rts
000EDCr 3               
000EDCr 3               
000EDCr 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000EDCr 3               ; ## ":NONAME"  auto  ANS core
000EDCr 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000EDCr 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000EDCr 3                       ; """
000EDCr 3               
000EDCr 3               xt_colon_noname:
000EDCr 3                               ; If we're already in the compile state, complain
000EDCr 3                               ; and quit
000EDCr 3  A5 rr                        lda state
000EDEr 3  05 rr                        ora state+1
000EE0r 3  F0 05                        beq @1
000EE2r 3               
000EE2r 3  A9 07                        lda #err_state
000EE4r 3  4C rr rr                     jmp error
000EE7r 3               @1:
000EE7r 3                               ; switch to compile state
000EE7r 3  C6 rr                        dec state
000EE9r 3  C6 rr                        dec state+1
000EEBr 3               
000EEBr 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000EEBr 3                               ; a :NONAME word.
000EEBr 3  A9 40                        lda #%01000000
000EEDr 3  14 rr                        trb status
000EEFr 3               
000EEFr 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000EEFr 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000EEFr 3                               ; nt and they will modify their behavior.
000EEFr 3  A5 rr                        lda cp
000EF1r 3  85 rr                        sta workword
000EF3r 3  A5 rr                        lda cp+1
000EF5r 3  85 rr                        sta workword+1
000EF7r 3               @done:
000EF7r 3  60           z_colon_noname:        rts
000EF8r 3               
000EF8r 3               
000EF8r 3               
000EF8r 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
000EF8r 3               ; ## ","  auto  ANS core
000EF8r 3                       ; """https://forth-standard.org/standard/core/Comma
000EF8r 3                       ; Store TOS at current place in memory.
000EF8r 3                       ;
000EF8r 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
000EF8r 3                       ; """
000EF8r 3               
000EF8r 3               xt_comma:
000EF8r 3  20 rr rr                     jsr underflow_1
000EFBr 3               
000EFBr 3  B5 00                        lda 0,x
000EFDr 3  92 rr                        sta (cp)
000EFFr 3               
000EFFr 3  E6 rr                        inc cp
000F01r 3  D0 02                        bne @1
000F03r 3  E6 rr                        inc cp+1
000F05r 3               @1:
000F05r 3  B5 01                        lda 1,x
000F07r 3  92 rr                        sta (cp)
000F09r 3               
000F09r 3  E6 rr                        inc cp
000F0Br 3  D0 02                        bne @done
000F0Dr 3  E6 rr                        inc cp+1
000F0Fr 3               @done:
000F0Fr 3  E8                           inx
000F10r 3  E8                           inx
000F11r 3               
000F11r 3  60           z_comma:        rts
000F12r 3               
000F12r 3               
000F12r 3               
000F12r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000F12r 3               ; ## "compare"   auto  ANS string
000F12r 3                       ; """https://forth-standard.org/standard/string/COMPARE
000F12r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000F12r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000F12r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000F12r 3                       ; that entirely matches the beginning of the other string, but is
000F12r 3                       ; shorter, is considered less than the longer string.
000F12r 3                       ; """
000F12r 3               
000F12r 3               xt_compare:
000F12r 3  20 rr rr                     jsr underflow_4
000F15r 3               
000F15r 3                               ; Load the two string addresses into tmp1 and tmp2.
000F15r 3  B5 02                        lda 2,x
000F17r 3  85 rr                        sta tmp2
000F19r 3  B5 03                        lda 3,x
000F1Br 3  85 rr                        sta tmp2+1
000F1Dr 3  B5 06                        lda 6,x
000F1Fr 3  85 rr                        sta tmp1
000F21r 3  B5 07                        lda 7,x
000F23r 3  85 rr                        sta tmp1+1
000F25r 3                               ; The counts will be used in-place on the stack.
000F25r 3               
000F25r 3               @compare_loop:
000F25r 3                               ; Check to see if we are out of letters.
000F25r 3               
000F25r 3                               ; Check string1
000F25r 3  B5 04                        lda 4,x
000F27r 3  15 05                        ora 5,x
000F29r 3  F0 2C                        beq @str1_done
000F2Br 3               
000F2Br 3                               ; Check string2
000F2Br 3  B5 00                        lda 0,x
000F2Dr 3  15 01                        ora 1,x
000F2Fr 3  F0 3A                        beq @greater    ; Str2 empty first
000F31r 3               
000F31r 3               @check_letter:
000F31r 3                               ; Both strings have at least one letter left.
000F31r 3                               ; Check the letters against each other.
000F31r 3  B2 rr                        lda (tmp1)
000F33r 3  D2 rr                        cmp (tmp2)
000F35r 3  90 26                        bcc @less
000F37r 3  D0 32                        bne @greater
000F39r 3               @next_letter:
000F39r 3                               ; Move both tmp pointers and decrement the counts
000F39r 3                               ; on the stack.
000F39r 3                               ; Increment tmp1
000F39r 3  E6 rr                        inc tmp1
000F3Br 3  D0 02                        bne @1
000F3Dr 3  E6 rr                        inc tmp1+1
000F3Fr 3               @1:
000F3Fr 3                               ; Increment tmp2
000F3Fr 3  E6 rr                        inc tmp2
000F41r 3  D0 02                        bne @2
000F43r 3  E6 rr                        inc tmp2+1
000F45r 3               @2:
000F45r 3                               ; Decrement count1 on the stack.
000F45r 3  B5 04                        lda 4,x
000F47r 3  D0 02                        bne @3
000F49r 3  D6 05                        dec 5,x
000F4Br 3               @3:
000F4Br 3  D6 04                        dec 4,x
000F4Dr 3               
000F4Dr 3                               ; Decrement count2 on the stack.
000F4Dr 3  B5 00                        lda 0,x
000F4Fr 3  D0 02                        bne @4
000F51r 3  D6 01                        dec 1,x
000F53r 3               @4:
000F53r 3  D6 00                        dec 0,x
000F55r 3               
000F55r 3                               ; Loop around and check again.
000F55r 3  80 CE                        bra @compare_loop
000F57r 3               
000F57r 3               @str1_done:
000F57r 3                               ; String 1 is out of letters. Check string 2.
000F57r 3  B5 00                        lda 0,x
000F59r 3  15 01                        ora 1,x
000F5Br 3  F0 08                        beq @equal      ; Both out of letters
000F5Dr 3               
000F5Dr 3                               ; Falls into less (str1 is out but str2 has more)
000F5Dr 3               @less:
000F5Dr 3                               ; Return -1
000F5Dr 3  A9 FF                        lda #$FF
000F5Fr 3  95 06                        sta 6,x
000F61r 3  95 07                        sta 7,x
000F63r 3  80 0C                        bra @done
000F65r 3               @equal:
000F65r 3                               ; Return 0
000F65r 3  74 06                        stz 6,x
000F67r 3  74 07                        stz 7,x
000F69r 3  80 06                        bra @done
000F6Br 3               @greater:
000F6Br 3                               ; Return 1
000F6Br 3  A9 01                        lda #1
000F6Dr 3  95 06                        sta 6,x
000F6Fr 3  74 07                        stz 7,x
000F71r 3                               ; Falls into @done
000F71r 3               @done:
000F71r 3                               ; Remove all but the result from the stack.
000F71r 3  8A                           txa
000F72r 3  18                           clc
000F73r 3  69 06                        adc #6
000F75r 3  AA                           tax
000F76r 3               
000F76r 3  60           z_compare:      rts
000F77r 3               
000F77r 3               
000F77r 3               
000F77r 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
000F77r 3               ; ## "compile,"  auto  ANS core ext
000F77r 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
000F77r 3                       ; Compile the given xt in the current word definition. It is an
000F77r 3                       ; error if we are not in the compile state. Because we are using
000F77r 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
000F77r 3                       ; the traditional way. By default, native compiled is allowed, unless
000F77r 3                       ; there is a NN (Never Native) flag associated. If not, we use the
000F77r 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
000F77r 3                       ; is too large to be natively coded: If the size is larger than
000F77r 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
000F77r 3                       ; Native) flag is set, the word is always natively compiled.
000F77r 3                       ; """
000F77r 3               
000F77r 3               xt_compile_comma:
000F77r 3  20 rr rr                     jsr underflow_1
000F7Ar 3               
000F7Ar 3                               ; See if this is an Always Native (AN) word by checking the
000F7Ar 3                               ; AN flag. We need nt for this. First, save a copy of xt to
000F7Ar 3                               ; the Return Stack
000F7Ar 3  B5 01                        lda 1,x                 ; MSB
000F7Cr 3  48                           pha
000F7Dr 3  B5 00                        lda 0,x
000F7Fr 3  48                           pha                     ; LSB
000F80r 3               
000F80r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
000F83r 3               
000F83r 3                               ; See if this xt even has an nt.
000F83r 3  B5 00                        lda 0,x
000F85r 3  15 01                        ora 1,x
000F87r 3  D0 03                        bne @check_nt
000F89r 3               
000F89r 3                               ; No nt in dictionary. Just compile as a JSR.
000F89r 3  4C rr rr                     jmp @compile_as_jump
000F8Cr 3               
000F8Cr 3               @check_nt:
000F8Cr 3                               ; put nt away for safe keeping
000F8Cr 3  B5 00                        lda 0,x
000F8Er 3  85 rr                        sta tmptos
000F90r 3  B5 01                        lda 1,x
000F92r 3  85 rr                        sta tmptos+1
000F94r 3               
000F94r 3                               ; status byte is one further down
000F94r 3  F6 00                        inc 0,x
000F96r 3  D0 02                        bne @1
000F98r 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
000F9Ar 3               @1:
000F9Ar 3  A1 00                        lda (0,x)
000F9Cr 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
000F9Er 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
000FA0r 3  F0 0D                        beq @compile_check
000FA2r 3               
000FA2r 3                               ; We're natively compiling no matter what. Get length and
000FA2r 3                               ; compile in code. Get the original nt back
000FA2r 3  A5 rr                        lda tmptos
000FA4r 3  95 00                        sta 0,x
000FA6r 3  A5 rr                        lda tmptos+1
000FA8r 3  95 01                        sta 1,x
000FAAr 3               
000FAAr 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000FADr 3               
000FADr 3  80 27                        bra @compile_as_code
000FAFr 3               
000FAFr 3               @compile_check:
000FAFr 3                               ; See if Native Compile is even alowed by checking the NN
000FAFr 3                               ; flag
000FAFr 3  A5 rr                        lda tmp3
000FB1r 3  29 08                        and #NN
000FB3r 3  F0 03                        beq @check_size_limit
000FB5r 3               
000FB5r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000FB8r 3               
000FB8r 3               @check_size_limit:
000FB8r 3                               ; Native compile is a legal option, but we need to see what
000FB8r 3                               ; limit the user set for size (in nc_limit)
000FB8r 3  A5 rr                        lda tmptos
000FBAr 3  95 00                        sta 0,x
000FBCr 3  A5 rr                        lda tmptos+1
000FBEr 3  95 01                        sta 1,x
000FC0r 3               
000FC0r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000FC3r 3               
000FC3r 3                               ; Check the wordsize MSB against the user-defined limit.
000FC3r 3  B5 01                        lda 1,x
000FC5r 3  C5 rr                        cmp nc_limit+1
000FC7r 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
000FC9r 3  D0 08                        bne @jumpto_compile_as_jump
000FCBr 3               
000FCBr 3                               ; Check the wordsize LSB against the user-defined limit.
000FCBr 3  B5 00                        lda 0,x
000FCDr 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
000FCFr 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
000FD1r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
000FD3r 3               
000FD3r 3               @jumpto_compile_as_jump:
000FD3r 3                               ; If the wordsize is greater than the user-defined
000FD3r 3                               ; limit, it will be compiled as a subroutine jump.
000FD3r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
000FD6r 3               
000FD6r 3               @compile_as_code:
000FD6r 3                               ; We arrive here with the length of the word's code TOS and
000FD6r 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
000FD6r 3                               ; on the data stack
000FD6r 3  CA                           dex
000FD7r 3  CA                           dex                     ; ( -- u ? )
000FD8r 3  CA                           dex
000FD9r 3  CA                           dex                     ; ( -- u ? ? )
000FDAr 3               
000FDAr 3  B5 04                        lda 4,x
000FDCr 3  95 00                        sta 0,x                 ; LSB of u
000FDEr 3  B5 05                        lda 5,x
000FE0r 3  95 01                        sta 1,x                 ; ( -- u ? u )
000FE2r 3               
000FE2r 3  68                           pla
000FE3r 3  95 04                        sta 4,x                 ; LSB of xt
000FE5r 3  68                           pla
000FE6r 3  95 05                        sta 5,x                 ; ( -- xt ? u )
000FE8r 3               
000FE8r 3  A5 rr                        lda cp                  ; LSB of cp
000FEAr 3  95 02                        sta 2,x
000FECr 3  A5 rr                        lda cp+1
000FEEr 3  95 03                        sta 3,x                 ; ( -- xt cp u )
000FF0r 3               
000FF0r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
000FF0r 3               
000FF0r 3                               ; Native compiling allows us to strip the stack antics off
000FF0r 3                               ; a number of words that use the Return Stack such as >R, R>,
000FF0r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
000FF0r 3                               ; xt with the contents of the table
000FF0r 3  A0 00                        ldy #0
000FF2r 3               
000FF2r 3               @strip_loop:
000FF2r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
000FF5r 3  D5 04                        cmp 4,x                 ; LSB of xt
000FF7r 3  D0 07                        bne @next_entry
000FF9r 3               
000FF9r 3                               ; LSB is the same, test MSB
000FF9r 3  B9 rr rr                     lda @strip_table+1,y
000FFCr 3  D5 05                        cmp 5,x
000FFEr 3  F0 0C                        beq @found_entry
001000r 3               
001000r 3                               ; MSB is not equal. Pretend though that we've come from LSB
001000r 3                               ; so we can use the next step for both cases
001000r 3               @next_entry:
001000r 3                               ; Not a word that needs stripping, so check next entry in table
001000r 3                               ; Let's see if we're done with the table (marked by zero entry)
001000r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
001003r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
001006r 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
001008r 3               
001008r 3  C8                           iny
001009r 3  C8                           iny
00100Ar 3  80 E6                        bra @strip_loop
00100Cr 3               @found_entry:
00100Cr 3                               ; This word is one of the ones that needs to have its size
00100Cr 3                               ; adjusted during native compile. We find the values in the
00100Cr 3                               ; next table with the same index, which is Y. However, Y is
00100Cr 3                               ; pointing to the MSB, so we need to go back to the LSB and
00100Cr 3                               ; halve the index before we can use it.
00100Cr 3  98                           tya
00100Dr 3  4A                           lsr
00100Er 3  A8                           tay
00100Fr 3               
00100Fr 3                               ; Get the adjustment out of the size table. We were clever
00100Fr 3                               ; enough to make sure the cut on both ends of the code is
00100Fr 3                               ; is the same size.
00100Fr 3  B9 rr rr                     lda @strip_size,y
001012r 3  85 rr                        sta tmptos              ; save a copy
001014r 3               
001014r 3                               ; Adjust xt: Start later
001014r 3  18                           clc
001015r 3  75 04                        adc 4,x
001017r 3  95 04                        sta 4,x
001019r 3  90 02                        bcc @2
00101Br 3  F6 05                        inc 5,x                 ; we just care about the carry
00101Dr 3               @2:
00101Dr 3               
00101Dr 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
00101Dr 3                               ; bottom of the code, we have to double the value
00101Dr 3  06 rr                        asl tmptos
00101Fr 3               
00101Fr 3  38                           sec
001020r 3  B5 00                        lda 0,x
001022r 3  E5 rr                        sbc tmptos
001024r 3  95 00                        sta 0,x
001026r 3  B0 02                        bcs @3
001028r 3  D6 01                        dec 1,x                 ; we just care about the borrow
00102Ar 3               @3:
00102Ar 3                               ; drop through to underflow check stripping
00102Ar 3               
00102Ar 3               @underflow_strip:
00102Ar 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
00102Ar 3               
00102Ar 3                               ; The user can choose to remove the unterflow testing in those
00102Ar 3                               ; words that have the UF flag. This shortens the word by
00102Ar 3                               ; 3 bytes if there is no underflow.
00102Ar 3               
00102Ar 3                               ; See if the user wants underflow stripping turned on
00102Ar 3  A5 rr                        lda uf_strip
00102Cr 3  05 rr                        ora uf_strip+1
00102Er 3  F0 1C                        beq @specials_done
001030r 3               
001030r 3                               ; See if this word even contains underflow checking
001030r 3  A5 rr                        lda tmp3
001032r 3  29 10                        and #UF
001034r 3  F0 16                        beq @specials_done
001036r 3               
001036r 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
001036r 3                               ; long. Note hat PICK is a special case.
001036r 3               
001036r 3                               ; Adjust xt: Start later
001036r 3  18                           clc
001037r 3  B5 04                        lda 4,x
001039r 3  69 03                        adc #3
00103Br 3  95 04                        sta 4,x
00103Dr 3  90 02                        bcc @4
00103Fr 3  F6 05                        inc 5,x                  ; we just care about the carry
001041r 3               @4:
001041r 3                               ; Adjust u: End earlier
001041r 3  38                           sec
001042r 3  B5 00                        lda 0,x
001044r 3  E9 03                        sbc #3
001046r 3  95 00                        sta 0,x
001048r 3  B0 02                        bcs @5
00104Ar 3  D6 01                        dec 1,x                  ; we just care about the borrow
00104Cr 3               @5:
00104Cr 3               
00104Cr 3                               ; --- END OF SPECIAL CASES ---
00104Cr 3               @specials_done:
00104Cr 3                               ; Store size of area to be copied for calculation of
00104Cr 3                               ; new CP. We have to do this after all of the special cases
00104Cr 3                               ; because they might change the size
00104Cr 3  B5 01                        lda 1,x                 ; MSB
00104Er 3  48                           pha
00104Fr 3  B5 00                        lda 0,x                 ; LSB
001051r 3  48                           pha
001052r 3               
001052r 3                               ; Enough of this, let's move those bytes already! We have
001052r 3                               ; ( xt cp u ) on the stack at this point
001052r 3  20 rr rr                     jsr xt_move
001055r 3               
001055r 3                               ; Update CP
001055r 3  18                           clc
001056r 3  68                           pla                     ; LSB
001057r 3  65 rr                        adc cp
001059r 3  85 rr                        sta cp
00105Br 3               
00105Br 3  68                           pla                     ; MSB
00105Cr 3  65 rr                        adc cp+1
00105Er 3  85 rr                        sta cp+1
001060r 3               
001060r 3  80 2C                        bra @done
001062r 3               
001062r 3               @strip_table:
001062r 3                              ; List of words we strip the Return Stack antics from
001062r 3                              ; during native compile, zero terminated. The index here
001062r 3                              ; must be the same as for the sizes
001062r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
001066r 3  rr rr        
001068r 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
00106Cr 3  00 00        
00106Er 3               
00106Er 3               @strip_size:
00106Er 3                               ; List of bytes to be stripped from the words that get their
00106Er 3                               ; Return Stack antics removed during native compile. Index must
00106Er 3                               ; be the same as for the xts. Zero terminated.
00106Er 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
001072r 3  06 00        
001074r 3               
001074r 3               @compile_as_jump:
001074r 3                               ; Compile xt as a subroutine jump
001074r 3  A9 20                        lda #$20
001076r 3  92 rr                        sta (cp)
001078r 3               
001078r 3  A0 01                        ldy #1
00107Ar 3  68                           pla             ; LSB
00107Br 3  91 rr                        sta (cp),y
00107Dr 3  C8                           iny
00107Er 3  68                           pla             ; MSB
00107Fr 3  91 rr                        sta (cp),y
001081r 3               
001081r 3                               ; allot space we just used
001081r 3  A9 03                        lda #3
001083r 3  18                           clc
001084r 3  65 rr                        adc cp
001086r 3  85 rr                        sta cp
001088r 3  90 02                        bcc @6
00108Ar 3  E6 rr                        inc cp+1
00108Cr 3               @6:
00108Cr 3  E8                           inx             ; drop xt
00108Dr 3  E8                           inx
00108Er 3               @done:
00108Er 3               z_compile_comma:
00108Er 3  60                           rts
00108Fr 3               
00108Fr 3               
00108Fr 3               
00108Fr 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
00108Fr 3               ; ## "compile-only"  tested  Tali Forth
00108Fr 3                       ; """Set the Compile Only flag (CO) of the most recently defined
00108Fr 3                       ; word.
00108Fr 3                       ;
00108Fr 3                       ; The alternative way to do this is to define a word
00108Fr 3                       ; ?COMPILE that makes sure  we're in compile mode
00108Fr 3                       ; """
00108Fr 3               
00108Fr 3               xt_compile_only:
00108Fr 3  20 rr rr                     jsr current_to_dp
001092r 3  A0 01                        ldy #1          ; offset for status byte
001094r 3  B1 rr                        lda (dp),y
001096r 3  09 01                        ora #CO        ; make sure bit 7 is set
001098r 3  91 rr                        sta (dp),y
00109Ar 3               
00109Ar 3  60           z_compile_only: rts
00109Br 3               
00109Br 3               
00109Br 3               
00109Br 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
00109Br 3               ; ## "constant"  auto  ANS core
00109Br 3                       ; """https://forth-standard.org/standard/core/CONSTANT
00109Br 3                       ;
00109Br 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
00109Br 3                       ; more in assembler and let CREATE do the heavy lifting.
00109Br 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
00109Br 3                       ; a primer on how this works in various Forths. This is the
00109Br 3                       ; same code as VALUE in our case.
00109Br 3                       ; """
00109Br 3               xt_value:
00109Br 3               xt_constant:
00109Br 3  20 rr rr                     jsr underflow_1
00109Er 3               
00109Er 3  20 rr rr                     jsr xt_create
0010A1r 3               
0010A1r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
0010A1r 3                               ; but we want DOCONST for constants. Go back two bytes and
0010A1r 3                               ; replace the subroutine jump target
0010A1r 3  38                           sec
0010A2r 3  A5 rr                        lda cp
0010A4r 3  E9 02                        sbc #2
0010A6r 3  85 rr                        sta tmp1
0010A8r 3  A5 rr                        lda cp+1
0010AAr 3  E9 00                        sbc #0
0010ACr 3  85 rr                        sta tmp1+1
0010AEr 3               
0010AEr 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
0010B0r 3  92 rr                        sta (tmp1)
0010B2r 3  A0 01                        ldy #1
0010B4r 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
0010B6r 3  91 rr                        sta (tmp1),y
0010B8r 3               
0010B8r 3                               ; Now we save the constant number itself in the next cell
0010B8r 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
0010BBr 3               
0010BBr 3               adjust_z:
0010BBr 3                               ; Now the length of the complete word (z_word) has increased by
0010BBr 3                               ; two. We need to update that number or else words such as SEE
0010BBr 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
0010BBr 3                               ; VALUE and DEFER
0010BBr 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
0010BEr 3               
0010BEr 3                               ; z_word is six bytes further down
0010BEr 3  B5 00                        lda 0,x
0010C0r 3  85 rr                        sta tmp1
0010C2r 3  B5 01                        lda 1,x
0010C4r 3  85 rr                        sta tmp1+1
0010C6r 3               
0010C6r 3  A0 06                        ldy #6
0010C8r 3  B1 rr                        lda (tmp1),y
0010CAr 3  18                           clc
0010CBr 3  69 02                        adc #2
0010CDr 3  91 rr                        sta (tmp1),y
0010CFr 3  C8                           iny
0010D0r 3  B1 rr                        lda (tmp1),y
0010D2r 3  69 00                        adc #0                  ; only need carry
0010D4r 3  91 rr                        sta (tmp1),y
0010D6r 3               
0010D6r 3  E8                           inx
0010D7r 3  E8                           inx
0010D8r 3               
0010D8r 3               z_value:
0010D8r 3  60           z_constant:     rts
0010D9r 3               
0010D9r 3               
0010D9r 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
0010D9r 3               ; ## "count"  auto  ANS core
0010D9r 3                       ; """https://forth-standard.org/standard/core/COUNT
0010D9r 3                       ; Convert old-style character string to address-length pair. Note
0010D9r 3                       ; that the length of the string c-addr is stored in character length
0010D9r 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
0010D9r 3                       ; though COUNT can also be used to step through a string character by
0010D9r 3                       ; character.
0010D9r 3                       ; """
0010D9r 3               xt_count:
0010D9r 3  20 rr rr                     jsr underflow_1
0010DCr 3               
0010DCr 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
0010DEr 3  A8                           tay
0010DFr 3               
0010DFr 3                               ; move start address up by one
0010DFr 3  F6 00                        inc 0,x         ; LSB
0010E1r 3  D0 02                        bne @1
0010E3r 3  F6 01                        inc 1,x         ; MSB
0010E5r 3               
0010E5r 3                               ; save number of characters to stack
0010E5r 3               @1:
0010E5r 3  98                           tya
0010E6r 3  CA                           dex
0010E7r 3  CA                           dex
0010E8r 3  95 00                        sta 0,x         ; LSB
0010EAr 3  74 01                        stz 1,x         ; MSB, always zero
0010ECr 3               
0010ECr 3  60           z_count:        rts
0010EDr 3               
0010EDr 3               
0010EDr 3               ; ## CR ( -- ) "Print a line feed"
0010EDr 3               ; ## "cr"  auto  ANS core
0010EDr 3                       ; """https://forth-standard.org/standard/core/CR"""
0010EDr 3               xt_cr:
0010EDr 3  A9 0A                        lda #AscLF
0010EFr 3  20 rr rr                     jsr emit_a
0010F2r 3  60           z_cr:           rts
0010F3r 3               
0010F3r 3               
0010F3r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
0010F3r 3               ; ## "create"  auto  ANS core
0010F3r 3                       ; """https://forth-standard.org/standard/core/CREATE
0010F3r 3                       ;
0010F3r 3                       ; See the drawing in headers.asm for details on the header
0010F3r 3                       ; """
0010F3r 3               
0010F3r 3               xt_create:
0010F3r 3                               ; get string
0010F3r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
0010F6r 3               
0010F6r 3                               ; if we were given an empty string, we complain and quit
0010F6r 3  B5 00                        lda 0,x
0010F8r 3  15 01                        ora 1,x
0010FAr 3  D0 05                        bne @got_name
0010FCr 3               
0010FCr 3  A9 05                        lda #err_noname
0010FEr 3  4C rr rr                     jmp error
001101r 3               
001101r 3               @got_name:
001101r 3                               ; Enforce maximal length of string by overwriting the MSB of
001101r 3                               ; the length. There is a possible error here: If the string
001101r 3                               ; is exactly 255 chars long, then a lot of the following
001101r 3                               ; additions will fail because of wrapping
001101r 3  74 01                        stz 1,x
001103r 3               
001103r 3                               ; Check to see if this name already exists.
001103r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
001106r 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
001109r 3               
001109r 3  B5 00                        lda 0,x
00110Br 3  15 01                        ora 1,x
00110Dr 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
00110Fr 3               
00110Fr 3                               ; This name already exists.  See if we are supposed to print
00110Fr 3                               ; the message for it.
00110Fr 3  E8                           inx                     ; Drop flag (nt) from find-name.
001110r 3  E8                           inx
001111r 3               
001111r 3                               ; Check bit 7
001111r 3  24 rr                        bit status
001113r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
001115r 3               
001115r 3                               ; We aren't supposed to print the redefined message ourselves,
001115r 3                               ; but we should indicate that it is redefined (for ; to print
001115r 3                               ; later).
001115r 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
001117r 3  05 rr                        ora status
001119r 3  85 rr                        sta status
00111Br 3  80 18                        bra @process_name
00111Dr 3               
00111Dr 3               @redefined_name:
00111Dr 3                               ; Print the message that the name is redefined.
00111Dr 3  A9 02                        lda #str_redefined
00111Fr 3  20 rr rr                     jsr print_string_no_lf
001122r 3               
001122r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
001125r 3  20 rr rr                     jsr xt_type
001128r 3  20 rr rr                     jsr xt_space
00112Br 3               
00112Br 3  80 08                        bra @process_name
00112Dr 3               
00112Dr 3               @new_name:
00112Dr 3  E8                           inx                     ; Drop flag (0) from find-name.
00112Er 3  E8                           inx
00112Fr 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
001131r 3  25 rr                        and status
001133r 3  85 rr                        sta status
001135r 3               
001135r 3               @process_name:
001135r 3  B5 00                        lda 0,x
001137r 3  85 rr                        sta tmp2                ; store length of string in tmp2
001139r 3               
001139r 3                               ; remember the first free byte of memory as the start of
001139r 3                               ; the new word
001139r 3  A5 rr                        lda cp
00113Br 3  85 rr                        sta tmp1
00113Dr 3  A5 rr                        lda cp+1
00113Fr 3  85 rr                        sta tmp1+1
001141r 3               
001141r 3                               ; We need 8 bytes plus the length of the string for our new header.
001141r 3                               ; This is also the offset for the start of the code field (the
001141r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
001141r 3                               ; just allot the space afterwards
001141r 3  B5 00                        lda 0,x
001143r 3  18                           clc
001144r 3  69 08                        adc #8
001146r 3  85 rr                        sta tmp3                ; total header length
001148r 3               
001148r 3                               ; We need three more bytes for for the hardcoded code field
001148r 3                               ; area (CFA), the "payload" of the word which by default will
001148r 3                               ; be a subroutine jump to DOVAR
001148r 3  18                           clc
001149r 3  69 03                        adc #3
00114Br 3               
00114Br 3                               ; We overwrite the length of the string returned by PARSE-NAME
00114Br 3                               ; and then call ALLOT
00114Br 3  95 00                        sta 0,x
00114Dr 3  74 01                        stz 1,x         ; max header size is 255 chars
00114Fr 3  20 rr rr                     jsr xt_allot    ; ( addr )
001152r 3               
001152r 3                               ; Get the CURRENT dictionary pointer.
001152r 3  20 rr rr                     jsr current_to_dp
001155r 3               
001155r 3                               ; Now we walk through the header with Y as the index, adding
001155r 3                               ; information byte-by-byte
001155r 3  A0 00                        ldy #0
001157r 3               
001157r 3                               ; HEADER BYTE 0: Length of string
001157r 3  A5 rr                        lda tmp2
001159r 3  91 rr                        sta (tmp1),y
00115Br 3               
00115Br 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
00115Br 3                               ; to "never native", user will have to decide if they should
00115Br 3                               ; be inlined
00115Br 3  A9 08                        lda #NN
00115Dr 3               
00115Dr 3                               ; Also, words defined by CREATE are marked in the header has
00115Dr 3                               ; having a Code Field Area (CFA), which is a bit tricky for
00115Dr 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
00115Dr 3                               ; correctly with DOES> and CREATE. See the discussion at
00115Dr 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
00115Dr 3  09 20                        ora #HC
00115Fr 3  C8                           iny
001160r 3  91 rr                        sta (tmp1),y
001162r 3  C8                           iny
001163r 3               
001163r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
001163r 3                               ; in the Dictionary
001163r 3  A5 rr                        lda dp
001165r 3  91 rr                        sta (tmp1),y
001167r 3  C8                           iny
001168r 3  A5 rr                        lda dp+1
00116Ar 3  91 rr                        sta (tmp1),y
00116Cr 3  C8                           iny
00116Dr 3               
00116Dr 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
00116Dr 3  A5 rr                        lda tmp1+1
00116Fr 3  85 rr                        sta dp+1
001171r 3  A5 rr                        lda tmp1
001173r 3  85 rr                        sta dp
001175r 3               
001175r 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
001175r 3                               ; This begins after the header so we take the length of the
001175r 3                               ; header, which we cleverly saved in tmp3, and use it as an
001175r 3                               ; offset to the address of the start of the word. We come here
001175r 3                               ; with tmp1 in A
001175r 3  18                           clc
001176r 3  65 rr                        adc tmp3        ; add total header length
001178r 3  91 rr                        sta (tmp1),y
00117Ar 3  48                           pha             ; we need this in the next step
00117Br 3  C8                           iny
00117Cr 3               
00117Cr 3  A5 rr                        lda tmp1+1
00117Er 3  69 00                        adc #0          ; only need the carry
001180r 3  91 rr                        sta (tmp1),y
001182r 3  C8                           iny
001183r 3               
001183r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
001183r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
001183r 3                               ; bytes down, and then one more byte so that the z_ label points
001183r 3                               ; to the (still fictional) RTS instruction for correct compilation
001183r 3  68                           pla             ; LSB of "z_" address
001184r 3  18                           clc
001185r 3  69 03                        adc #3
001187r 3  91 rr                        sta (tmp1),y
001189r 3               
001189r 3  88                           dey             ; get the MSB of xt back
00118Ar 3  B1 rr                        lda (tmp1),y
00118Cr 3  69 00                        adc #0          ; only need the carry
00118Er 3  C8                           iny
00118Fr 3  C8                           iny
001190r 3  91 rr                        sta (tmp1),y
001192r 3  C8                           iny
001193r 3               
001193r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
001193r 3                               ; length in tmp2. We subtract 8 from the address so we can
001193r 3                               ; use the same loop index, which is already 8 byte ahead at
001193r 3                               ; this point
001193r 3  B5 00                        lda 0,x
001195r 3  38                           sec
001196r 3  E9 08                        sbc #8
001198r 3  85 rr                        sta tmptos
00119Ar 3               
00119Ar 3  B5 01                        lda 1,x
00119Cr 3  E9 00                        sbc #0          ; only need carry
00119Er 3  85 rr                        sta tmptos+1
0011A0r 3               
0011A0r 3               @name_loop:
0011A0r 3  B1 rr                        lda (tmptos),y
0011A2r 3               
0011A2r 3                               ; Make sure it goes into the dictionary in lower case.
0011A2r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0011A4r 3  B0 07                        bcs @store_name
0011A6r 3  C9 41                        cmp #$41        ; ASCII 'A'
0011A8r 3  90 03                        bcc @store_name
0011AAr 3               
0011AAr 3                               ; An uppercase letter has been located. Make it
0011AAr 3                               ; lowercase.
0011AAr 3  18                           clc
0011ABr 3  69 20                        adc #$20
0011ADr 3               
0011ADr 3                               ; Fall into @store_name.
0011ADr 3               
0011ADr 3               @store_name:
0011ADr 3  91 rr                        sta (tmp1),y
0011AFr 3  C8                           iny
0011B0r 3  C6 rr                        dec tmp2
0011B2r 3  D0 EC                        bne @name_loop
0011B4r 3               
0011B4r 3                               ; After thename string comes the code field, starting at the
0011B4r 3                               ; current xt of this word, which is initially a jump to the
0011B4r 3                               ; subroutine to DOVAR. We code this jump by hand
0011B4r 3  A9 20                        lda #$20        ; opcode of JSR
0011B6r 3  91 rr                        sta (tmp1),y
0011B8r 3  C8                           iny
0011B9r 3  A9 rr                        lda #<dovar
0011BBr 3  91 rr                        sta (tmp1),y
0011BDr 3  C8                           iny
0011BEr 3  A9 rr                        lda #>dovar
0011C0r 3  91 rr                        sta (tmp1),y
0011C2r 3               
0011C2r 3                               ; Update the CURRENT wordlist with the new DP.
0011C2r 3                               ; We do this down here because this routine uses Y.
0011C2r 3  20 rr rr                     jsr dp_to_current
0011C5r 3               
0011C5r 3                               ; And we're done. Restore stack
0011C5r 3  E8                           inx
0011C6r 3  E8                           inx
0011C7r 3               
0011C7r 3  60           z_create:       rts
0011C8r 3               
0011C8r 3               
0011C8r 3               
0011C8r 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
0011C8r 3               ; ## "d-"  auto  ANS double
0011C8r 3                       ; """https://forth-standard.org/standard/double/DMinus"""
0011C8r 3               
0011C8r 3               xt_d_minus:
0011C8r 3  20 rr rr                     jsr underflow_4 ; two double numbers
0011CBr 3               
0011CBr 3  38                           sec
0011CCr 3               
0011CCr 3  B5 06                        lda 6,x         ; LSB of lower word
0011CEr 3  F5 02                        sbc 2,x
0011D0r 3  95 06                        sta 6,x
0011D2r 3               
0011D2r 3  B5 07                        lda 7,x         ; MSB of lower word
0011D4r 3  F5 03                        sbc 3,x
0011D6r 3  95 07                        sta 7,x
0011D8r 3               
0011D8r 3  B5 04                        lda 4,x         ; LSB of upper word
0011DAr 3  F5 00                        sbc 0,x
0011DCr 3  95 04                        sta 4,x
0011DEr 3               
0011DEr 3  B5 05                        lda 5,x         ; MSB of upper word
0011E0r 3  F5 01                        sbc 1,x
0011E2r 3  95 05                        sta 5,x
0011E4r 3               
0011E4r 3  E8                           inx
0011E5r 3  E8                           inx
0011E6r 3  E8                           inx
0011E7r 3  E8                           inx
0011E8r 3               
0011E8r 3  60           z_d_minus:      rts
0011E9r 3               
0011E9r 3               
0011E9r 3               
0011E9r 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
0011E9r 3               ; ## "d+"  auto  ANS double
0011E9r 3                       ; """https://forth-standard.org/standard/double/DPlus"""
0011E9r 3               
0011E9r 3               xt_d_plus:
0011E9r 3  20 rr rr                     jsr underflow_4 ; two double numbers
0011ECr 3               
0011ECr 3  18                           clc
0011EDr 3  B5 02                        lda 2,x         ; LSB of lower word
0011EFr 3  75 06                        adc 6,x
0011F1r 3  95 06                        sta 6,x
0011F3r 3               
0011F3r 3  B5 03                        lda 3,x         ; MSB of lower word
0011F5r 3  75 07                        adc 7,x
0011F7r 3  95 07                        sta 7,x
0011F9r 3               
0011F9r 3  B5 00                        lda 0,x         ; LSB of upper word
0011FBr 3  75 04                        adc 4,x
0011FDr 3  95 04                        sta 4,x
0011FFr 3               
0011FFr 3  B5 01                        lda 1,x         ; MSB of upper word
001201r 3  75 05                        adc 5,x
001203r 3  95 05                        sta 5,x
001205r 3               
001205r 3  E8                           inx
001206r 3  E8                           inx
001207r 3  E8                           inx
001208r 3  E8                           inx
001209r 3               
001209r 3  60           z_d_plus:       rts
00120Ar 3               
00120Ar 3               
00120Ar 3               
00120Ar 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
00120Ar 3               ; ## "d>s"  auto  ANS double
00120Ar 3                       ; """https://forth-standard.org/standard/double/DtoS
00120Ar 3                       ; Though this is basically just DROP, we keep it
00120Ar 3                       ; separate so we can test for underflow
00120Ar 3                       ; """
00120Ar 3               
00120Ar 3               xt_d_to_s:
00120Ar 3  20 rr rr                     jsr underflow_2
00120Dr 3               
00120Dr 3  E8                           inx
00120Er 3  E8                           inx
00120Fr 3               
00120Fr 3  60           z_d_to_s:       rts
001210r 3               
001210r 3               
001210r 3               
001210r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
001210r 3               ; ## "dabs"  auto  ANS double
001210r 3                       ; """https://forth-standard.org/standard/double/DABS"""
001210r 3               
001210r 3               xt_dabs:
001210r 3  20 rr rr                     jsr underflow_2 ; double number
001213r 3               
001213r 3  B5 01                        lda 1,x         ; MSB of high cell
001215r 3  10 17                        bpl @done       ; positive, we get off light
001217r 3               
001217r 3                               ; negative, calculate 0 - d
001217r 3  A0 00                        ldy #0
001219r 3  38                           sec
00121Ar 3               
00121Ar 3  98                           tya
00121Br 3  F5 02                        sbc 2,x         ; LSB of low cell
00121Dr 3  95 02                        sta 2,x
00121Fr 3               
00121Fr 3  98                           tya
001220r 3  F5 03                        sbc 3,x         ; MSB of low cell
001222r 3  95 03                        sta 3,x
001224r 3               
001224r 3  98                           tya
001225r 3  F5 00                        sbc 0,x         ; LSB of high cell
001227r 3  95 00                        sta 0,x
001229r 3               
001229r 3  98                           tya
00122Ar 3  F5 01                        sbc 1,x         ; MSB of high cell
00122Cr 3  95 01                        sta 1,x
00122Er 3               @done:
00122Er 3  60           z_dabs:         rts
00122Fr 3               
00122Fr 3               
00122Fr 3               
00122Fr 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
00122Fr 3               ; ## "decimal"  auto  ANS core
00122Fr 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
00122Fr 3               xt_decimal:
00122Fr 3  A9 0A                        lda #10
001231r 3  85 rr                        sta base
001233r 3  64 rr                        stz base+1              ; paranoid
001235r 3               
001235r 3  60           z_decimal:      rts
001236r 3               
001236r 3               
001236r 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
001236r 3               ; ## "defer"  auto  ANS core ext
001236r 3                       ; """https://forth-standard.org/standard/core/DEFER
001236r 3                       ; Reserve an name that can be linked to various xt by IS.
001236r 3                       ;
001236r 3                       ; The ANS reference implementation is
001236r 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
001236r 3                       ; But we use this routine as a low-level word so things go faster
001236r 3               
001236r 3               xt_defer:
001236r 3  20 rr rr                     jsr xt_create
001239r 3               
001239r 3                               ; CREATE by default installs a subroutine jump to DOVAR,
001239r 3                               ; but we actually want DODEFER this time. Go back two
001239r 3                               ; bytes and repace the subroutine jump target
001239r 3  A5 rr                        lda cp          ; LSB
00123Br 3  38                           sec
00123Cr 3  E9 02                        sbc #2
00123Er 3  85 rr                        sta tmp1
001240r 3               
001240r 3  A5 rr                        lda cp+1        ; MSB
001242r 3  E9 00                        sbc #0          ; we only care about the borrow
001244r 3  85 rr                        sta tmp1+1
001246r 3               
001246r 3                               ; Save the target address
001246r 3  A0 00                        ldy #0
001248r 3  A9 rr                        lda #<dodefer   ; LSB
00124Ar 3  91 rr                        sta (tmp1),y
00124Cr 3  C8                           iny
00124Dr 3  A9 rr                        lda #>dodefer   ; MSB
00124Fr 3  91 rr                        sta (tmp1),y
001251r 3               
001251r 3               
001251r 3                               ; DODEFER executes the next address it finds after
001251r 3                               ; its call. As default, we include the error
001251r 3                               ; "Defer not defined"
001251r 3  A9 rr                        lda #<defer_error
001253r 3  92 rr                        sta (cp)
001255r 3  E6 rr                        inc cp
001257r 3  D0 02                        bne @1
001259r 3  E6 rr                        inc cp+1
00125Br 3               @1:
00125Br 3  A9 rr                        lda #>defer_error
00125Dr 3  92 rr                        sta (cp)
00125Fr 3  E6 rr                        inc cp
001261r 3  D0 02                        bne @2
001263r 3  E6 rr                        inc cp+1
001265r 3               @2:
001265r 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
001268r 3               
001268r 3  60           z_defer:        rts
001269r 3               
001269r 3               
001269r 3               
001269r 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
001269r 3               ; ## "defer@"  auto  ANS core ext
001269r 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
001269r 3               
001269r 3               xt_defer_fetch:
001269r 3                               ; No underflow checking as >BODY does it.
001269r 3  20 rr rr                     jsr xt_to_body
00126Cr 3  20 rr rr                     jsr xt_fetch
00126Fr 3  60           z_defer_fetch:  rts
001270r 3               
001270r 3               
001270r 3               
001270r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
001270r 3               ; ## "defer!"  auto  ANS core ext
001270r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
001270r 3               
001270r 3               xt_defer_store:
001270r 3                               ; No underflow checking as >BODY and ! do it.
001270r 3  20 rr rr                     jsr xt_to_body
001273r 3  20 rr rr                     jsr xt_store
001276r 3  60           z_defer_store:  rts
001277r 3               
001277r 3               
001277r 3               
001277r 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
001277r 3               ; ## "definitions" auto ANS search
001277r 3               xt_definitions:
001277r 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
001279r 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
00127Br 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
00127Dr 3  91 rr                        sta (up),y
00127Fr 3  60           z_definitions:  rts
001280r 3               
001280r 3               
001280r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
001280r 3               ; ## "depth"  auto  ANS core
001280r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
001280r 3               xt_depth:
001280r 3  A9 FF                        lda #dsp0
001282r 3  86 rr                        stx tmpdsp
001284r 3  38                           sec
001285r 3  E5 rr                        sbc tmpdsp
001287r 3               
001287r 3                               ; divide by two because each cell is two bytes
001287r 3  4A                           lsr
001288r 3               
001288r 3  CA                           dex
001289r 3  CA                           dex
00128Ar 3  95 00                        sta 0,x
00128Cr 3  74 01                        stz 1,x
00128Er 3               
00128Er 3  60           z_depth:        rts
00128Fr 3               
00128Fr 3               
00128Fr 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
00128Fr 3               ; ## "digit?"  auto  Tali Forth
00128Fr 3                       ; """Inspired by the pForth instruction DIGIT, see
00128Fr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00128Fr 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
00128Fr 3                       ; pForth, we get the base (radix) ourselves instead of having the
00128Fr 3                       ; user provide it. There is no standard name for this routine, which
00128Fr 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
00128Fr 3                       ; """
00128Fr 3               
00128Fr 3               xt_digit_question:
00128Fr 3  20 rr rr                     jsr underflow_1
001292r 3               
001292r 3                               ; one way or another, we're going to need room for the
001292r 3                               ; flag on the stack
001292r 3  CA                           dex
001293r 3  CA                           dex
001294r 3  74 00                        stz 0,x                 ; default flag is failure
001296r 3  74 01                        stz 1,x
001298r 3  74 03                        stz 3,x                 ; paranoid
00129Ar 3               
00129Ar 3                               ; Check the character, now in the LSB of NOS. First, make
00129Ar 3                               ; sure we're not below the ASCII code for "0"
00129Ar 3  B5 02                        lda 2,x
00129Cr 3  C9 30                        cmp #'0'
00129Er 3  90 23                        bcc @done               ; failure flag already set
0012A0r 3               
0012A0r 3                               ; Next, see if we are below "9", because that would make
0012A0r 3                               ; this a normal number
0012A0r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
0012A2r 3  90 12                        bcc @checkbase
0012A4r 3               
0012A4r 3                               ; Well, then let's see if this is the gap between "9" and "A"
0012A4r 3                               ; so we can treat the whole range as a number
0012A4r 3  C9 41                        cmp #'A'
0012A6r 3  90 1B                        bcc @done               ; failure flag is already set
0012A8r 3               
0012A8r 3                               ; probably a letter, so we make sure it is uppercase
0012A8r 3  C9 61                        cmp #'a'
0012AAr 3  90 07                        bcc @case_done          ; not lower case, too low
0012ACr 3  C9 7B                        cmp #'z'+1
0012AEr 3  B0 03                        bcs @case_done          ; not lower case, too high
0012B0r 3               
0012B0r 3  18                           clc                     ; just right
0012B1r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
0012B3r 3               
0012B3r 3               @case_done:
0012B3r 3                               ; get rid of the gap between "9" and "A" so we can treat
0012B3r 3                               ; the whole range as one number
0012B3r 3  38                           sec
0012B4r 3  E9 07                        sbc #7                  ; fall through to @checkbase
0012B6r 3               
0012B6r 3               @checkbase:
0012B6r 3                               ; we have a number, now see if it falls inside the range
0012B6r 3                               ; provided by BASE
0012B6r 3  38                           sec
0012B7r 3  E9 30                        sbc #'0'                 ; this is also the conversion step
0012B9r 3  C5 rr                        cmp base
0012BBr 3  B0 06                        bcs @done               ; already have false flag
0012BDr 3               
0012BDr 3                               ; Found a legal number
0012BDr 3  95 02                        sta 2,x                 ; put number in NOS
0012BFr 3  D6 00                        dec 0,x                 ; set success flag
0012C1r 3  D6 01                        dec 1,x
0012C3r 3               
0012C3r 3               @done:
0012C3r 3               z_digit_question:
0012C3r 3  60                           rts
0012C4r 3               
0012C4r 3               
0012C4r 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
0012C4r 3               ; ## "disasm"  tested  Tali Forth
0012C4r 3                       ; """Convert a segment of memory to assembler output. This
0012C4r 3                       ; word is vectored so people can add their own disassembler.
0012C4r 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
0012C4r 3                       ; code, see the section on The Disassembler in the manual and
0012C4r 3                       ; the file disassembler.asm for more details.
0012C4r 3                       ; """
0012C4r 3               xt_disasm:
0012C4r 3  20 rr rr                     jsr underflow_2
0012C7r 3                           .ifdef disassembler
0012C7r 3                               jsr disassembler
0012C7r 3                           .endif
0012C7r 3               
0012C7r 3  60           z_disasm:       rts
0012C8r 3               
0012C8r 3               
0012C8r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
0012C8r 3               ; ## "dnegate"  auto  ANS double
0012C8r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
0012C8r 3               xt_dnegate:
0012C8r 3  20 rr rr                     jsr underflow_2 ; double number
0012CBr 3               
0012CBr 3  A0 00             		ldy #0
0012CDr 3  38                           sec
0012CEr 3               
0012CEr 3  98                           tya
0012CFr 3  F5 02                        sbc 2,x         ; LSB of low cell
0012D1r 3  95 02                        sta 2,x
0012D3r 3               
0012D3r 3  98                           tya
0012D4r 3  F5 03                        sbc 3,x         ; MSB of low cell
0012D6r 3  95 03                        sta 3,x
0012D8r 3               
0012D8r 3  98                           tya
0012D9r 3  F5 00                        sbc 0,x         ; LSB of high cell
0012DBr 3  95 00                        sta 0,x
0012DDr 3               
0012DDr 3  98                           tya
0012DEr 3  F5 01                        sbc 1,x         ; MSB of high cell
0012E0r 3  95 01                        sta 1,x
0012E2r 3               
0012E2r 3  60           z_dnegate:      rts
0012E3r 3               
0012E3r 3               
0012E3r 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
0012E3r 3               ; ## "?do"  auto  ANS core ext
0012E3r 3                       ; """https://forth-standard.org/standard/core/qDO"""
0012E3r 3               xt_question_do:
0012E3r 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
0012E3r 3                               ; to mark which is which
0012E3r 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
0012E5r 3  85 rr                        sta tmp1
0012E7r 3  80 02                        bra do_common           ; skip flag for DO
0012E9r 3               
0012E9r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
0012E9r 3               ; ## "do"  auto  ANS core
0012E9r 3                       ; """https://forth-standard.org/standard/core/DO
0012E9r 3                       ;
0012E9r 3                       ; Compile-time part of DO. Could be realized in Forth as
0012E9r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
0012E9r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
0012E9r 3                       ; a routine that pushes the end address to the Return Stack at run
0012E9r 3                       ; time. This is based on a suggestion by Garth Wilson, see
0012E9r 3                       ; the Control Flow section of the manual for details.
0012E9r 3                       ;
0012E9r 3                       ; This may not be native compile. Don't check for a stack underflow
0012E9r 3                       ; """
0012E9r 3               
0012E9r 3               xt_do:
0012E9r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
0012E9r 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
0012EBr 3               do_common:
0012EBr 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
0012EBr 3                               ; compile the address we need to LDA at runtime
0012EBr 3  CA                           dex
0012ECr 3  CA                           dex
0012EDr 3  A5 rr                        lda cp
0012EFr 3  95 00                        sta 0,x                 ; LSB
0012F1r 3  A5 rr                        lda cp+1
0012F3r 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
0012F5r 3               
0012F5r 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
0012F5r 3                               ; replace by the actual LDA/PHA instructions
0012F5r 3  A9 05                        lda #5                  ; we don't really care about the value,
0012F7r 3  A8                           tay                     ; so we use 5 to be tricky
0012F8r 3               @loop:
0012F8r 3  91 rr                        sta (cp),y
0012FAr 3  88                           dey
0012FBr 3  10 FB                        bpl @loop
0012FDr 3               
0012FDr 3                               ; update CP
0012FDr 3  1A                           inc             ; we used 5 as a dummy value, this is why
0012FEr 3  18                           clc
0012FFr 3  65 rr                        adc cp
001301r 3  85 rr                        sta cp
001303r 3  90 02                        bcc @1
001305r 3  E6 rr                        inc cp+1
001307r 3               @1:
001307r 3                               ; compile the (?DO) portion of ?DO if appropriate
001307r 3  A5 rr                        lda tmp1
001309r 3  F0 17                        beq @compile_do
00130Br 3               
00130Br 3                               ; We came from ?DO, so compile its runtime first. We do
00130Br 3                               ; this with a quick loop because we know it has to be
00130Br 3                               ; Always Native anyway
00130Br 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
00130Dr 3  5A                           phy             ; save counter to calculate new CP
00130Er 3               @2:
00130Er 3  B9 rr rr                     lda question_do_runtime,y
001311r 3  91 rr                        sta (cp),y
001313r 3  88                           dey
001314r 3  10 F8                        bpl @2
001316r 3               
001316r 3                               ; adjust CP
001316r 3  68                           pla             ; retrieve counter
001317r 3  18                           clc
001318r 3  65 rr                        adc cp
00131Ar 3  85 rr                        sta cp
00131Cr 3  A5 rr                        lda cp+1
00131Er 3  69 00                        adc #0          ; only care about carry
001320r 3  85 rr                        sta cp+1        ; fall through to @compile_do
001322r 3               
001322r 3               @compile_do:
001322r 3                               ; compile runtime part of DO.
001322r 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
001324r 3  5A                           phy             ; save counter to calculate new CP
001325r 3               @3:
001325r 3  B9 rr rr                     lda do_runtime,y
001328r 3  91 rr                        sta (cp),y
00132Ar 3  88                           dey
00132Br 3  10 F8                        bpl @3
00132Dr 3               
00132Dr 3                               ; adjust CP
00132Dr 3  68                           pla             ; retrieve counter
00132Er 3  18                           clc
00132Fr 3  65 rr                        adc cp
001331r 3  85 rr                        sta cp
001333r 3  A5 rr                        lda cp+1
001335r 3  69 00                        adc #0          ; only care about carry
001337r 3  85 rr                        sta cp+1
001339r 3               
001339r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
001339r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
001339r 3                               ; do with the HERE we're saving for LEAVE
001339r 3  CA                           dex
00133Ar 3  CA                           dex
00133Br 3  A5 rr                        lda cp          ; LSB
00133Dr 3  95 00                        sta 0,x
00133Fr 3  A5 rr                        lda cp+1        ; MSB
001341r 3  95 01                        sta 1,x
001343r 3               z_question_do:
001343r 3  60           z_do:           rts
001344r 3               
001344r 3               
001344r 3               do_runtime:
001344r 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
001344r 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
001344r 3                       ; the FIG Forth loop (you can see which version you have by running
001344r 3                       ; a loop with start and limit as the same value, for instance
001344r 3                       ; 0 0 DO -- these will walk through the number space). We use a
001344r 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
001344r 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
001344r 3                       ; for further discussion of this. The source given there for
001344r 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
001344r 3                       ; in some Forths. Usually, we would define this as a separate word
001344r 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
001344r 3                       ; However, we can do it faster if we just copy the bytes
001344r 3                       ; of this routine with a simple loop in DO.
001344r 3                       ; """
001344r 3                               ; First step: create fudge factor (FUFA) by subtracting the
001344r 3                               ; limit from $8000, the number that will trip the overflow
001344r 3                               ; flag
001344r 3  38                           sec
001345r 3  A9 00                        lda #0
001347r 3  F5 02                        sbc 2,x         ; LSB of limit
001349r 3  95 02                        sta 2,x         ; save FUFA for later use
00134Br 3               
00134Br 3  A9 80                        lda #$80
00134Dr 3  F5 03                        sbc 3,x         ; MSB of limit
00134Fr 3  95 03                        sta 3,x         ; save FUFA for later use
001351r 3  48                           pha             ; FUFA replaces limit on R stack
001352r 3  B5 02                        lda 2,x         ; LSB of limit
001354r 3  48                           pha
001355r 3               
001355r 3                               ; Second step: index is FUFA plus original index
001355r 3  18                           clc
001356r 3  B5 00                        lda 0,x         ; LSB of original index
001358r 3  75 02                        adc 2,x         ; add LSB of FUFA
00135Ar 3  95 00                        sta 0,x
00135Cr 3  B5 01                        lda 1,x         ; MSB of orginal index
00135Er 3  75 03                        adc 3,x         ; add MSB of FUFA
001360r 3  48                           pha
001361r 3  B5 00                        lda 0,x         ; LSB of index
001363r 3  48                           pha
001364r 3               
001364r 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
001364r 3                               ; use it later. Clean the Data Stack
001364r 3  E8                           inx
001365r 3  E8                           inx
001366r 3  E8                           inx
001367r 3  E8                           inx             ; no RTS because this is copied into code
001368r 3               do_runtime_end:
001368r 3               
001368r 3               question_do_runtime:
001368r 3               
001368r 3                       ; """This is called (?DO) in some Forths. See the explanation at
001368r 3                       ; do_runtime for the background on this design
001368r 3                       ; """
001368r 3                               ; see if TOS and NOS are equal. Change this to assembler
001368r 3                               ; for speed
001368r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
00136Br 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
00136Er 3               
00136Er 3  B5 00                        lda 0,x
001370r 3  15 01                        ora 1,x
001372r 3  F0 06                        beq @do_do
001374r 3               
001374r 3                               ; We're equal, so dump everything and jump beyond the loop.
001374r 3                               ; But first, dump six entries off of the Data Stack
001374r 3  8A                           txa
001375r 3  18                           clc
001376r 3  69 06                        adc #6
001378r 3  AA                           tax
001379r 3               
001379r 3                               ; Then abort the whole loop
001379r 3  60                           rts
00137Ar 3               @do_do:
00137Ar 3  E8                           inx             ; clear flag from EQUAL off stack
00137Br 3  E8                           inx             ; no RTS because this is copied into code
00137Cr 3               question_do_runtime_end:
00137Cr 3               
00137Cr 3               
00137Cr 3               
00137Cr 3               ; ## DOES ( -- ) "Add payload when defining new words"
00137Cr 3               ; ## "does>"  auto  ANS core
00137Cr 3                       ; """https://forth-standard.org/standard/core/DOES
00137Cr 3                       ; Create the payload for defining new defining words. See
00137Cr 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
00137Cr 3                       ; the Developer Guide in the manual for a discussion of
00137Cr 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
00137Cr 3                       ; """
00137Cr 3               
00137Cr 3               xt_does:
00137Cr 3                               ; compile a subroutine jump to runtime of DOES>
00137Cr 3  A0 rr                        ldy #>does_runtime
00137Er 3  A9 rr                        lda #<does_runtime
001380r 3  20 rr rr                     jsr cmpl_subroutine
001383r 3               
001383r 3                               ; compile a subroutine jump to DODOES. In traditional
001383r 3                               ; terms, this is the Code Field Area (CFA) of the new
001383r 3                               ; word
001383r 3  A0 rr                        ldy #>dodoes
001385r 3  A9 rr                        lda #<dodoes
001387r 3  20 rr rr                     jsr cmpl_subroutine
00138Ar 3               
00138Ar 3  60           z_does:         rts
00138Br 3               
00138Br 3               
00138Br 3               does_runtime:
00138Br 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
00138Br 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
00138Br 3                       ; address that contains a subroutine jump to DODOES. We don't
00138Br 3                       ; jump to DODOES directly because we need to work our magic with
00138Br 3                       ; the return addresses. This routine is also known as "(DOES)" in
00138Br 3                       ; other Forths
00138Br 3                       ; """
00138Br 3               
00138Br 3  7A                           ply             ; LSB
00138Cr 3  68                           pla             ; MSB
00138Dr 3               
00138Dr 3  C8                           iny
00138Er 3  D0 01                        bne @1
001390r 3  1A                           inc
001391r 3               @1:
001391r 3  84 rr                        sty tmp1
001393r 3  85 rr                        sta tmp1+1
001395r 3               
001395r 3                               ; CREATE has also already modified the DP to point to the new
001395r 3                               ; word. We have no idea which instructions followed the CREATE
001395r 3                               ; command if there is a DOES> so the CP could point anywhere
001395r 3                               ; by now. The address of the word's xt is four bytes down.
001395r 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
001398r 3  A5 rr                        lda dp
00139Ar 3  18                           clc
00139Br 3  69 04                        adc #4
00139Dr 3  85 rr                        sta tmp2
00139Fr 3  A5 rr                        lda dp+1
0013A1r 3  69 00                        adc #0          ; we only care about the carry
0013A3r 3  85 rr                        sta tmp2+1
0013A5r 3               
0013A5r 3                               ; Now we get that address and add one byte to skip over the JSR
0013A5r 3                               ; opcode
0013A5r 3  B2 rr                        lda (tmp2)
0013A7r 3  18                           clc
0013A8r 3  69 01                        adc #1
0013AAr 3  85 rr                        sta tmp3
0013ACr 3  A0 01                        ldy #1
0013AEr 3  B1 rr                        lda (tmp2),y
0013B0r 3  69 00                        adc #0          ; we only care about the carry
0013B2r 3  85 rr                        sta tmp3+1
0013B4r 3               
0013B4r 3                               ; Replace the DOVAR address with our own
0013B4r 3  A5 rr                        lda tmp1        ; LSB
0013B6r 3  92 rr                        sta (tmp3)
0013B8r 3  A5 rr                        lda tmp1+1
0013BAr 3  91 rr                        sta (tmp3),y    ; Y is still 1
0013BCr 3               
0013BCr 3                               ; Since we removed the return address that brought us here, we
0013BCr 3                               ; go back to whatever the main routine was. Otherwise, we we
0013BCr 3                               ; smash into the subroutine jump to DODOES.
0013BCr 3  60                           rts
0013BDr 3               
0013BDr 3               
0013BDr 3               
0013BDr 3               ; ## DOT ( u -- ) "Print TOS"
0013BDr 3               ; ## "."  auto  ANS core
0013BDr 3                       ; """https://forth-standard.org/standard/core/d"""
0013BDr 3               
0013BDr 3               xt_dot:
0013BDr 3  20 rr rr                     jsr underflow_1
0013C0r 3               
0013C0r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
0013C3r 3  20 rr rr                     jsr xt_abs                      ; ( n u )
0013C6r 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
0013C9r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
0013CCr 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
0013CFr 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
0013D2r 3  20 rr rr                     jsr xt_sign                     ; ( ud )
0013D5r 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
0013D8r 3  20 rr rr                     jsr xt_type
0013DBr 3  20 rr rr                     jsr xt_space
0013DEr 3               
0013DEr 3  60           z_dot:          rts
0013DFr 3               
0013DFr 3               
0013DFr 3               
0013DFr 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
0013DFr 3               ; ## ".("  auto  ANS core
0013DFr 3                       ; """http://forth-standard.org/standard/core/Dotp"""
0013DFr 3               
0013DFr 3               xt_dot_paren:
0013DFr 3                               ; Put a right paren on the stack.
0013DFr 3  CA                           dex
0013E0r 3  CA                           dex
0013E1r 3  A9 29                        lda #41     ; Right parenthesis
0013E3r 3  95 00                        sta 0,x
0013E5r 3  74 01                        stz 1,x
0013E7r 3               
0013E7r 3  20 rr rr                     jsr xt_parse
0013EAr 3  20 rr rr                     jsr xt_type
0013EDr 3               
0013EDr 3  60           z_dot_paren:    rts
0013EEr 3               
0013EEr 3               
0013EEr 3               
0013EEr 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
0013EEr 3               ; ## ".""  auto  ANS core ext
0013EEr 3                       ; """https://forth-standard.org/standard/core/Dotq
0013EEr 3                       ; Compile string that is printed during run time. ANS Forth wants
0013EEr 3                       ; this to be compile-only, even though everybody and their friend
0013EEr 3                       ; uses it for everything. We follow the book here, and recommend
0013EEr 3                       ; `.(` for general printing.
0013EEr 3                       ; """
0013EEr 3               
0013EEr 3               xt_dot_quote:
0013EEr 3                               ; we let S" do the heavy lifting. Since we're in
0013EEr 3                               ; compile mode, it will save the string and reproduce it
0013EEr 3                               ; during runtime
0013EEr 3  20 rr rr                     jsr xt_s_quote
0013F1r 3               
0013F1r 3                               ; We then let TYPE do the actual printing
0013F1r 3  A0 rr                        ldy #>xt_type
0013F3r 3  A9 rr                        lda #<xt_type
0013F5r 3  20 rr rr                     jsr cmpl_subroutine
0013F8r 3               
0013F8r 3  60           z_dot_quote:    rts
0013F9r 3               
0013F9r 3               
0013F9r 3               
0013F9r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
0013F9r 3               ; ## ".r"  tested  ANS core ext
0013F9r 3                       ; """https://forth-standard.org/standard/core/DotR
0013F9r 3                       ;
0013F9r 3                       ; Based on the Forth code
0013F9r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
0013F9r 3                       ; """
0013F9r 3               
0013F9r 3               xt_dot_r:
0013F9r 3  20 rr rr                     jsr underflow_2
0013FCr 3               
0013FCr 3  20 rr rr                     jsr xt_to_r
0013FFr 3  20 rr rr                     jsr xt_dup
001402r 3  20 rr rr                     jsr xt_abs
001405r 3  20 rr rr                     jsr xt_zero
001408r 3  20 rr rr                     jsr xt_less_number_sign
00140Br 3  20 rr rr                     jsr xt_number_sign_s
00140Er 3  20 rr rr                     jsr xt_rot
001411r 3  20 rr rr                     jsr xt_sign
001414r 3  20 rr rr                     jsr xt_number_sign_greater
001417r 3  20 rr rr                     jsr xt_r_from
00141Ar 3  20 rr rr                     jsr xt_over
00141Dr 3  20 rr rr                     jsr xt_minus
001420r 3  20 rr rr                     jsr xt_spaces
001423r 3  20 rr rr                     jsr xt_type
001426r 3               
001426r 3  60           z_dot_r:        rts
001427r 3               
001427r 3               
001427r 3               
001427r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
001427r 3               ; ## ".s"  tested  ANS tools
001427r 3                       ; """https://forth-standard.org/standard/tools/DotS
001427r 3                       ; Print content of Data Stack non-distructively. We follow the format
001427r 3                       ; of Gforth and print the number of elements first in brackets,
001427r 3                       ; followed by the Data Stack content (if any).
001427r 3                       ;
001427r 3                       ; Since this is for humans, we don't have to worry about speed.
001427r 3                       ; """
001427r 3               
001427r 3               xt_dot_s:
001427r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
00142Ar 3               
00142Ar 3                               ; Print stack depth in brackets
00142Ar 3  A9 3C                        lda #$3c        ; ASCII for "<"
00142Cr 3  20 rr rr                     jsr emit_a
00142Fr 3               
00142Fr 3                               ; We keep a copy of the number of the things on the stack
00142Fr 3                               ; to use as a counter later down. This assumes that there
00142Fr 3                               ; are less than 255 elements on the stack
00142Fr 3  B5 00                        lda 0,x
001431r 3  48                           pha
001432r 3               
001432r 3                               ; print unsigned number without the trailing space
001432r 3  CA                           dex             ; DUP
001433r 3  CA                           dex
001434r 3  95 00                        sta 0,x
001436r 3  74 01                        stz 1,x
001438r 3               
001438r 3  20 rr rr                     jsr print_u
00143Br 3               
00143Br 3  A9 3E                        lda #$3e        ; ASCII for ">"
00143Dr 3  20 rr rr                     jsr emit_a
001440r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
001442r 3  20 rr rr                     jsr emit_a
001445r 3               
001445r 3  E8                           inx
001446r 3  E8                           inx
001447r 3               
001447r 3                               ; There will be lots of cases where the stack is empty. If that
001447r 3                               ; is so, get out of here quickly
001447r 3  E0 FF                        cpx #dsp0
001449r 3  F0 1E                        beq @done
00144Br 3               
00144Br 3               @have_stack:
00144Br 3                               ; We have at least one element on the stack. The depth of the
00144Br 3                               ; stack is on the stack, we can use it as a counter. We go
00144Br 3                               ; from bottom to top
00144Br 3  7A                           ply
00144Cr 3               
00144Cr 3  A9 FE                        lda #dsp0-1     ; go up one to avoid garbage
00144Er 3  85 rr                        sta tmp3
001450r 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
001452r 3               @loop:
001452r 3  CA                           dex
001453r 3  CA                           dex
001454r 3               
001454r 3  B2 rr                        lda (tmp3)
001456r 3  95 01                        sta 1,x
001458r 3  C6 rr                        dec tmp3
00145Ar 3               
00145Ar 3  B2 rr                        lda (tmp3)
00145Cr 3  95 00                        sta 0,x
00145Er 3  C6 rr                        dec tmp3
001460r 3  5A                           phy
001461r 3               
001461r 3  20 rr rr                     jsr xt_dot
001464r 3               
001464r 3  7A                           ply
001465r 3  88                           dey
001466r 3  D0 EA                        bne @loop
001468r 3               
001468r 3  48                           pha             ; dummy to balance stack
001469r 3               @done:
001469r 3  68                           pla
00146Ar 3  60           z_dot_s:        rts
00146Br 3               
00146Br 3               
00146Br 3               
00146Br 3               ; ## D_DOT ( d -- ) "Print double"
00146Br 3               ; ## "d."  tested  ANS double
00146Br 3                       ; """http://forth-standard.org/standard/double/Dd"""
00146Br 3                       ;
00146Br 3                       ; From the Forth code:
00146Br 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
00146Br 3                       ; """
00146Br 3               
00146Br 3               xt_d_dot:
00146Br 3  20 rr rr                     jsr underflow_2
00146Er 3               
00146Er 3  20 rr rr                     jsr xt_tuck
001471r 3  20 rr rr                     jsr xt_dabs
001474r 3  20 rr rr                     jsr xt_less_number_sign
001477r 3  20 rr rr                     jsr xt_number_sign_s
00147Ar 3  20 rr rr                     jsr xt_rot
00147Dr 3  20 rr rr                     jsr xt_sign
001480r 3  20 rr rr                     jsr xt_number_sign_greater
001483r 3  20 rr rr                     jsr xt_type
001486r 3  20 rr rr                     jsr xt_space
001489r 3               
001489r 3  60           z_d_dot:        rts
00148Ar 3               
00148Ar 3               
00148Ar 3               
00148Ar 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
00148Ar 3               ; ## "d.r"  tested  ANS double
00148Ar 3                       ; """http://forth-standard.org/standard/double/DDotR"""
00148Ar 3                       ; Based on the Forth code
00148Ar 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
00148Ar 3                       ; """
00148Ar 3               
00148Ar 3               xt_d_dot_r:
00148Ar 3  20 rr rr                     jsr underflow_3
00148Dr 3                               ; From the forth code:
00148Dr 3  20 rr rr                     jsr xt_to_r
001490r 3  20 rr rr                     jsr xt_tuck
001493r 3  20 rr rr                     jsr xt_dabs
001496r 3  20 rr rr                     jsr xt_less_number_sign
001499r 3  20 rr rr                     jsr xt_number_sign_s
00149Cr 3  20 rr rr                     jsr xt_rot
00149Fr 3  20 rr rr                     jsr xt_sign
0014A2r 3  20 rr rr                     jsr xt_number_sign_greater
0014A5r 3  20 rr rr                     jsr xt_r_from
0014A8r 3  20 rr rr                     jsr xt_over
0014ABr 3  20 rr rr                     jsr xt_minus
0014AEr 3  20 rr rr                     jsr xt_spaces
0014B1r 3  20 rr rr                     jsr xt_type
0014B4r 3               
0014B4r 3  60           z_d_dot_r:      rts
0014B5r 3               
0014B5r 3               
0014B5r 3               
0014B5r 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
0014B5r 3               ; ## "drop"  auto  ANS core
0014B5r 3                       ; """https://forth-standard.org/standard/core/DROP"""
0014B5r 3               xt_drop:
0014B5r 3  20 rr rr                     jsr underflow_1
0014B8r 3               
0014B8r 3  E8                           inx
0014B9r 3  E8                           inx
0014BAr 3               
0014BAr 3  60           z_drop:         rts
0014BBr 3               
0014BBr 3               
0014BBr 3               ; ## DUMP ( addr u -- ) "Display a memory region"
0014BBr 3               ; ## "dump"  tested  ANS tools
0014BBr 3                       ; """https://forth-standard.org/standard/tools/DUMP
0014BBr 3                       ;
0014BBr 3                       ; DUMP's exact output is defined as "implementation dependent".
0014BBr 3                       ; This is in assembler because it is
0014BBr 3                       ; useful for testing and development, so we want to have it work
0014BBr 3                       ; as soon as possible. Uses TMP2
0014BBr 3                       ; """
0014BBr 3               
0014BBr 3               xt_dump:
0014BBr 3  20 rr rr                     jsr underflow_2
0014BEr 3               @row:
0014BEr 3                               ; start counter for 16 numbers per row
0014BEr 3  A0 10                        ldy #16
0014C0r 3               
0014C0r 3                               ; We use TMP2 as the index for the ASCII characters
0014C0r 3                               ; that we print at the and of the hex block. We
0014C0r 3                               ; start saving them at HERE (CP)
0014C0r 3  64 rr                        stz tmp2
0014C2r 3               
0014C2r 3  20 rr rr                     jsr xt_cr
0014C5r 3               
0014C5r 3                               ; print address number
0014C5r 3  B5 03                        lda 3,x
0014C7r 3  20 rr rr                     jsr byte_to_ascii
0014CAr 3  B5 02                        lda 2,x
0014CCr 3  20 rr rr                     jsr byte_to_ascii
0014CFr 3               
0014CFr 3  20 rr rr                     jsr xt_space
0014D2r 3  20 rr rr                     jsr xt_space
0014D5r 3               @loop:
0014D5r 3                               ; if there are zero bytes left to display, we're done
0014D5r 3  B5 00                        lda 0,x
0014D7r 3  15 01                        ora 1,x
0014D9r 3  F0 39                        beq @all_printed
0014DBr 3               
0014DBr 3                               ; dump the contents
0014DBr 3  A1 02                        lda (2,x)
0014DDr 3  48                           pha                     ; byte_to_ascii destroys A
0014DEr 3  20 rr rr                     jsr byte_to_ascii
0014E1r 3  20 rr rr                     jsr xt_space
0014E4r 3  68                           pla
0014E5r 3               
0014E5r 3                               ; Handle ASCII printing
0014E5r 3  20 rr rr                     jsr is_printable
0014E8r 3  B0 02                        bcs @printable
0014EAr 3  A9 2E                        lda #'.'                 ; Print dot if not printable
0014ECr 3               @printable:
0014ECr 3  5A                           phy                     ; save counter
0014EDr 3  A4 rr                        ldy tmp2
0014EFr 3  91 rr                        sta (cp),y
0014F1r 3  E6 rr                        inc tmp2
0014F3r 3  7A                           ply
0014F4r 3               
0014F4r 3                               ; extra space after eight bytes
0014F4r 3  C0 09                        cpy #9
0014F6r 3  D0 03                        bne @next_char
0014F8r 3  20 rr rr                     jsr xt_space
0014FBr 3               
0014FBr 3               @next_char:
0014FBr 3  F6 02                        inc 2,x
0014FDr 3  D0 02                        bne @counter
0014FFr 3  F6 03                        inc 3,x
001501r 3               
001501r 3               @counter:
001501r 3                               ; loop counter
001501r 3  B5 00                        lda 0,x
001503r 3  D0 02                        bne @1
001505r 3  D6 01                        dec 1,x
001507r 3               @1:
001507r 3  D6 00                        dec 0,x
001509r 3  88                           dey
00150Ar 3  D0 C9                        bne @loop               ; next byte
00150Cr 3               
00150Cr 3                               ; Done with one line, print the ASCII version of these
00150Cr 3                               ; characters
00150Cr 3  20 rr rr                     jsr xt_space
00150Fr 3  20 rr rr                     jsr print_ascii
001512r 3               
001512r 3  80 AA                        bra @row                ; new row
001514r 3               
001514r 3               @all_printed:
001514r 3                               ; See if there are any ASCII characters in the buffer
001514r 3                               ; left to print
001514r 3  A5 rr                        lda tmp2
001516r 3  F0 06                        beq @done
001518r 3               
001518r 3                               ; In theory, we could try to make the ASCII part line
001518r 3                               ; up with the line before it. But that is a hassle (we
001518r 3                               ; use three bytes for each missed hex entry, and
001518r 3                               ; then there is the gap after eight entries) and it
001518r 3                               ; makes it harder to read. We settle for one extra
001518r 3                               ; space instead for the moment
001518r 3  20 rr rr                     jsr xt_space
00151Br 3  20 rr rr                     jsr print_ascii
00151Er 3               @done:
00151Er 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
001521r 3  60           z_dump:         rts
001522r 3               
001522r 3               
001522r 3               print_ascii:
001522r 3                               ; Print the ASCII characters that we have saved from
001522r 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
001522r 3                               ; is not compiled (DUMP is probably never compiled anyway)
001522r 3                               ; but we keep it inside the scope of DUMP.
001522r 3  A0 00                        ldy #0
001524r 3               @ascii_loop:
001524r 3  B1 rr                        lda (cp),y
001526r 3  20 rr rr                     jsr emit_a
001529r 3  C8                           iny
00152Ar 3               
00152Ar 3                               ; extra space after eight chars
00152Ar 3  C0 08                        cpy #8
00152Cr 3  D0 03                        bne @1
00152Er 3  20 rr rr                     jsr xt_space
001531r 3               @1:
001531r 3  C6 rr                        dec tmp2
001533r 3  D0 EF                        bne @ascii_loop
001535r 3               
001535r 3  60                           rts
001536r 3               
001536r 3               
001536r 3               
001536r 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
001536r 3               ; ## "dup"  auto  ANS core
001536r 3                       ; """https://forth-standard.org/standard/core/DUP"""
001536r 3               xt_dup:
001536r 3  20 rr rr                     jsr underflow_1
001539r 3               
001539r 3  CA                           dex
00153Ar 3  CA                           dex
00153Br 3               
00153Br 3  B5 02                        lda 2,x         ; LSB
00153Dr 3  95 00                        sta 0,x
00153Fr 3  B5 03                        lda 3,x         ; MSB
001541r 3  95 01                        sta 1,x
001543r 3               
001543r 3  60           z_dup:          rts
001544r 3               
001544r 3               
001544r 3               ; ## ED ( -- u ) "Line-based editor"
001544r 3               ; ## "ed"  fragment  Tali Forth
001544r 3                       ; """Start the line-based editor ed6502. See separate file
001544r 3                       ; ed.asm or the manual for details.
001544r 3                       ; """
001544r 3               xt_ed:
001544r 3                           .ifdef ed6502
001544r 3                               jsr ed6502      ; kept in separate file
001544r 3                           .endif
001544r 3               
001544r 3  60           z_ed:           rts
001545r 3               
001545r 3               
001545r 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
001545r 3               ; ## "editor-wordlist"  tested  Tali Editor
001545r 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
001545r 3                       ; words to the search order so they can be used.  This will need
001545r 3                       ; to be done before any of the words marked "Tali Editor" can be
001545r 3                       ; used.  See the tutorial on Wordlists and the Search Order for
001545r 3                       ; more information.
001545r 3               
001545r 3                       ;
001545r 3                       ; This is a dummy entry, the code is shared with ONE
001545r 3                       ; """
001545r 3               
001545r 3               
001545r 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
001545r 3               ; ## "else"  auto  ANS core
001545r 3                       ; """http://forth-standard.org/standard/core/ELSE
001545r 3                       ;
001545r 3                       ; The code is shared with ENDOF
001545r 3                       ; """
001545r 3               
001545r 3               xt_else:
001545r 3               xt_endof:
001545r 3                               ; Put an unconditional branch.
001545r 3  A0 rr                        ldy #>branch_runtime
001547r 3  A9 rr                        lda #<branch_runtime
001549r 3  20 rr rr                     jsr cmpl_subroutine
00154Cr 3               
00154Cr 3                               ; Put the address of the branch address on the stack.
00154Cr 3  20 rr rr                     jsr xt_here
00154Fr 3               
00154Fr 3                               ; Use zero for the branch address for now.
00154Fr 3                               ; THEN will fill it in later.
00154Fr 3  20 rr rr                     jsr xt_zero
001552r 3  20 rr rr                     jsr xt_comma
001555r 3               
001555r 3                               ; Get the address to jump to (just after the
001555r 3                               ; unconditional branch) for the IF to jump to
001555r 3                               ; when false.
001555r 3  20 rr rr                     jsr xt_here
001558r 3  20 rr rr                     jsr xt_rot
00155Br 3               
00155Br 3                               ; Update the original if 0branch address.
00155Br 3  20 rr rr                     jsr xt_store
00155Er 3               z_else:
00155Er 3               z_endof:
00155Er 3  60                           rts
00155Fr 3               
00155Fr 3               
00155Fr 3               
00155Fr 3               branch_runtime:
00155Fr 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
00155Fr 3                       ; formally part of a separate word BRANCH which was later removed.
00155Fr 3                       ; """
00155Fr 3               
00155Fr 3                               ; The address on the Return Stack points to the last byte
00155Fr 3                               ; of the JSR address, one byte below the branch literal
00155Fr 3  68                           pla
001560r 3  85 rr                        sta tmpbranch
001562r 3  68                           pla
001563r 3  85 rr                        sta tmpbranch+1
001565r 3               
001565r 3                               ; Keep in mind: the address we just popped points one byte
001565r 3                               ; lower than the branch literal we want to grab
001565r 3  A0 01                        ldy #1
001567r 3  B1 rr                        lda (tmpbranch),y  ; LSB
001569r 3  85 rr                        sta tmp1
00156Br 3  C8                           iny
00156Cr 3  B1 rr                        lda (tmpbranch),y  ; MSB
00156Er 3  85 rr                        sta tmp1+1
001570r 3               
001570r 3  6C rr rr                     jmp (tmp1)
001573r 3               
001573r 3               
001573r 3               
001573r 3               ; ## EMIT ( char -- ) "Print character to current output"
001573r 3               ; ## "emit"  auto  ANS core
001573r 3                       ; """https://forth-standard.org/standard/core/EMIT
001573r 3                       ; Run-time default for EMIT. The user can revector this by changing
001573r 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
001573r 3                       ; do not check to see if we have been given a valid ASCII character.
001573r 3                       ; Don't make this native compile.
001573r 3                       ; """
001573r 3               
001573r 3               xt_emit:
001573r 3  20 rr rr                     jsr underflow_1
001576r 3               
001576r 3  B5 00                        lda 0,x
001578r 3  E8                           inx
001579r 3  E8                           inx
00157Ar 3               
00157Ar 3               emit_a:
00157Ar 3                       ; We frequently want to print the character in A without fooling
00157Ar 3                       ; around with the Data Stack. This is emit_a's job, which still
00157Ar 3                       ; allows the output to be vectored. Call it with JSR as you
00157Ar 3                       ; would XT_EMIT
00157Ar 3  6C rr rr                     jmp (output)            ; JSR/RTS
00157Dr 3               
00157Dr 3               z_emit:         ; never reached
00157Dr 3               
00157Dr 3               
00157Dr 3               
00157Dr 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
00157Dr 3               ; ## "empty-buffers"  tested  ANS block ext
00157Dr 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
00157Dr 3               xt_empty_buffers:
00157Dr 3                               ; Set the buffer status to empty.
00157Dr 3  A0 2C                        ldy #buffstatus_offset
00157Fr 3  A9 00                        lda #0
001581r 3  91 rr                        sta (up),y      ; Only LSB is used.
001583r 3               z_empty_buffers:
001583r 3  60                           rts
001584r 3               
001584r 3               
001584r 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
001584r 3               ; ## "endcase"  auto  ANS core ext
001584r 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
001584r 3               
001584r 3               xt_endcase:
001584r 3                               ; Postpone DROP to remove the item
001584r 3                               ; being checked.
001584r 3  A0 rr                        ldy #>xt_drop
001586r 3  A9 rr                        lda #<xt_drop
001588r 3  20 rr rr                     jsr cmpl_subroutine
00158Br 3               
00158Br 3                               ; There are a number of address (of branches that need their
00158Br 3                               ; jump addressed filled in with the address of right here).
00158Br 3                               ; Keep calling THEN to deal with them until we reach the
00158Br 3                               ; 0 that CASE put on the stack at the beginning.
00158Br 3               @endcase_loop:
00158Br 3                               ; Check for 0 on the stack.
00158Br 3  B5 00                        lda 0,x
00158Dr 3  15 01                        ora 1,x
00158Fr 3  F0 05                        beq @done
001591r 3               
001591r 3  20 rr rr                     jsr xt_then
001594r 3  80 F5                        bra @endcase_loop
001596r 3               @done:
001596r 3                               ; Remove the 0 from the stack.
001596r 3  E8                           inx
001597r 3  E8                           inx
001598r 3  60           z_endcase:      rts
001599r 3               
001599r 3               
001599r 3               
001599r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
001599r 3               ; ## "endof"  auto  ANS core ext
001599r 3                       ; """http://forth-standard.org/standard/core/ENDOF
001599r 3                       ; This is a dummy entry, the code is shared with ELSE
001599r 3                       ; """
001599r 3               
001599r 3               
001599r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
001599r 3               ; ## "environment?"  auto  ANS core
001599r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
001599r 3                       ;
001599r 3                       ; By ANS definition, we use upper-case strings here, see the
001599r 3                       ; string file for details. This can be realized as a high-level
001599r 3                       ; Forth word as
001599r 3                       ;
001599r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
001599r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
001599r 3                       ; HEX
001599r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
001599r 3                       ; CASE
001599r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
001599r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
001599r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
001599r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
001599r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
001599r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
001599r 3                       ; S" MAX-D"              STRING_OF
001599r 3                                                    ; 7FFFFFFF. TRUE ENDOF
001599r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
001599r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
001599r 3                       ; S" MAX-UD"             STRING_OF
001599r 3                                                    ; FFFFFFFF. TRUE ENDOF
001599r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
001599r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
001599r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
001599r 3                       ; ENDCASE ;
001599r 3                       ;
001599r 3                       ; but that uses lots of memory and increases the start up time. This
001599r 3                       ; word is rarely used so we can try to keep it short at the expense
001599r 3                       ; of speed.
001599r 3                       ; """
001599r 3               
001599r 3               xt_environment_q:
001599r 3  20 rr rr                     jsr underflow_1
00159Cr 3               
00159Cr 3                               ; This code is table-driven: We walk through the list of
00159Cr 3                               ; strings until we find one that matches, and then we take
00159Cr 3                               ; the equivalent data from the results table. This is made
00159Cr 3                               ; a bit harder by the fact that some of these return a
00159Cr 3                               ; double-cell number and some a single-cell one.
00159Cr 3               
00159Cr 3                               ; We will walk through the table with variables that return
00159Cr 3                               ; a single-cell result
00159Cr 3  A0 00                        ldy #00                 ; counter for table
00159Er 3               
00159Er 3                               ; We use a flag on the the stack to signal if we have a single-cell
00159Er 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
00159Er 3                               ; double-cell.
00159Er 3  5A                           phy
00159Fr 3               @table_loop:
00159Fr 3                               ; We arrived here with the address of the string to be checked
00159Fr 3                               ; on the stack. We make a copy. Index is in Y
00159Fr 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
0015A2r 3               
0015A2r 3                               ; We do our work on the TOS to speed things up
0015A2r 3  CA                           dex
0015A3r 3  CA                           dex                     ; ( addr u addr u ? )
0015A4r 3               
0015A4r 3                               ; Get address of string to check from table
0015A4r 3  B9 rr rr                     lda env_table_single,y
0015A7r 3  95 00                        sta 0,x
0015A9r 3  C8                           iny
0015AAr 3  B9 rr rr                     lda env_table_single,y
0015ADr 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
0015AFr 3  C8                           iny
0015B0r 3               
0015B0r 3                               ; See if this is the last entry. The LSB is still in A
0015B0r 3  15 00                        ora 0,x
0015B2r 3  F0 4D                        beq @table_done
0015B4r 3               
0015B4r 3                               ; We have a string entry. The address there is stored in
0015B4r 3                               ; old-style address format, that is, the first byte is the
0015B4r 3                               ; length of the string
0015B4r 3  5A                           phy                     ; save Y, which is used by COUNT
0015B5r 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
0015B8r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
0015BBr 3  7A                           ply
0015BCr 3               
0015BCr 3                               ; If we found a match (flag is zero -- COMPARE is weird
0015BCr 3                               ; that way), return the result
0015BCr 3  B5 00                        lda 0,x
0015BEr 3  15 01                        ora 1,x
0015C0r 3  F0 04                        beq @got_result
0015C2r 3               
0015C2r 3                               ; Flag is not zero, so not a perfect match, so try next
0015C2r 3                               ; word
0015C2r 3  E8                           inx                     ; DROP, now ( addr u )
0015C3r 3  E8                           inx
0015C4r 3               
0015C4r 3  80 D9                        bra @table_loop
0015C6r 3               
0015C6r 3               @got_result:
0015C6r 3                               ; We arrive here with ( addr u -1 ) and know that we've found
0015C6r 3                               ; a match. The index of the match+2 is in Y.
0015C6r 3  E8                           inx                     ; drop flag, now ( addr u )
0015C7r 3  E8                           inx
0015C8r 3  88                           dey                     ; go back to index we had
0015C9r 3  88                           dey
0015CAr 3               
0015CAr 3                               ; See if this is a single-cell word.
0015CAr 3  68                           pla
0015CBr 3  D0 0D                        bne @double_result
0015CDr 3               
0015CDr 3                               ; Single-cell result
0015CDr 3  B9 rr rr                     lda env_results_single,y
0015D0r 3  95 02                        sta 2,x
0015D2r 3  C8                           iny
0015D3r 3  B9 rr rr                     lda env_results_single,y
0015D6r 3  95 03                        sta 3,x                 ; ( res u )
0015D8r 3               
0015D8r 3  80 1F                        bra @set_flag
0015DAr 3               
0015DAr 3               @double_result:
0015DAr 3                               ; This is a double-celled result, which means we have to
0015DAr 3                               ; fool around with the index some more. We also need a
0015DAr 3                               ; further cell on the stack
0015DAr 3  CA                           dex                     ; ( addr u ? )
0015DBr 3  CA                           dex
0015DCr 3               
0015DCr 3                               ; We have 11 single-cell words we check, plus the 0000 as
0015DCr 3                               ; a marker for the end of the table, so we arrive here
0015DCr 3                               ; with Y as 22 or more. To get the index for the double-
0015DCr 3                               ; cell words, we move the result
0015DCr 3  98                           tya
0015DDr 3  38                           sec
0015DEr 3  E9 18                        sbc #24
0015E0r 3               
0015E0r 3                               ; We have four bytes per entry in the table, but the index
0015E0r 3                               ; keeps increasing by two, so we only have to multiply by
0015E0r 3                               ; two (shift left once) to get the right result
0015E0r 3  0A                           asl
0015E1r 3  A8                           tay
0015E2r 3               
0015E2r 3  B9 rr rr                     lda env_results_double,y
0015E5r 3  95 02                        sta 2,x
0015E7r 3  C8                           iny
0015E8r 3  B9 rr rr                     lda env_results_double,y
0015EBr 3  95 03                        sta 3,x                 ; ( res u ? )
0015EDr 3  C8                           iny
0015EEr 3               
0015EEr 3  B9 rr rr                     lda env_results_double,y
0015F1r 3  95 04                        sta 4,x
0015F3r 3  C8                           iny
0015F4r 3  B9 rr rr                     lda env_results_double,y
0015F7r 3  95 05                        sta 5,x                 ; ( res res ? )
0015F9r 3               
0015F9r 3                               ; fall through to @set_flag
0015F9r 3               @set_flag:
0015F9r 3  A9 FF                        lda #$ff
0015FBr 3  95 00                        sta 0,x
0015FDr 3  95 01                        sta 1,x                 ; ( res f )
0015FFr 3               
0015FFr 3  80 14                        bra @done
001601r 3               @table_done:
001601r 3                               ; We're done with a table, because the entry was a zero.
001601r 3                               ; We arrive here with ( addr u addr u 0 )
001601r 3               
001601r 3                               ; We take the flag from stack and increase it by one. If the
001601r 3                               ; flag is zero, we have just completed the single-cell number
001601r 3                               ; strings, so we in increase the flag and try again. Otherwise,
001601r 3                               ; we're done with the double-cell table without having found
001601r 3                               ; a match, and we're done
001601r 3  68                           pla
001602r 3  D0 09                        bne @no_match
001604r 3               
001604r 3                               ; Flag is zero, increase it to one and start over to check
001604r 3                               ; double-cell values
001604r 3  1A                           inc
001605r 3  48                           pha
001606r 3               
001606r 3  8A                           txa
001607r 3  18                           clc
001608r 3  69 06                        adc #6                  ; skip six bytes
00160Ar 3  AA                           tax                     ; ( addr u )
00160Br 3               
00160Br 3  80 92                        bra @table_loop
00160Dr 3               @no_match:
00160Dr 3                               ; Bummer, not found. We arrive here with
00160Dr 3                               ; ( addr u addr u 0 ) and need to return just a zero
00160Dr 3  8A                           txa
00160Er 3  18                           clc
00160Fr 3  69 0A                        adc #10
001611r 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
001612r 3               
001612r 3  20 rr rr                     jsr xt_false
001615r 3               @done:
001615r 3               z_environment_q:
001615r 3  60                           rts
001616r 3               
001616r 3               
001616r 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
001616r 3               ; results and one for the double-celled results. The zero cell at the
001616r 3               ; end of each table marks its, uh, end. The strings themselves are defined
001616r 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
001616r 3               ; have to adapt the result code for double printout, where we subtract 22
001616r 3               ; (two bytes each single-cell string and two bytes for the end-of-table
001616r 3               ; marker 0000
001616r 3               env_table_single:
001616r 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
00161Ar 3  rr rr rr rr  
00161Er 3  rr rr        
001620r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
001624r 3  rr rr rr rr  
001628r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
00162Cr 3  00 00        
00162Er 3               
00162Er 3               env_table_double:
00162Er 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
001632r 3  00 00        
001634r 3               
001634r 3               env_results_single:
001634r 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
001636r 3  FF 00                .word $00FF     ; /HOLD
001638r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
00163Ar 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
00163Cr 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
00163Er 3  FF 00                .word $00FF     ; MAX-CHAR
001640r 3  FF 7F                .word $7FFF     ; MAX-N
001642r 3  FF FF                .word $FFFF     ; MAX-U
001644r 3  80 00                .word $0080     ; RETURN-STACK-CELLS
001646r 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
001648r 3  09 00                .word $0009     ; WORDLISTS
00164Ar 3               
00164Ar 3               env_results_double:
00164Ar 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
00164Er 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
001652r 3               
001652r 3               
001652r 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
001652r 3               ; ## "="  auto  ANS core
001652r 3                       ; """https://forth-standard.org/standard/core/Equal"""
001652r 3               
001652r 3               xt_equal:
001652r 3  20 rr rr                     jsr underflow_2
001655r 3               
001655r 3  B5 00                        lda 0,x                 ; LSB
001657r 3  D5 02                        cmp 2,x
001659r 3  D0 0A                        bne @false
00165Br 3               
00165Br 3  B5 01                        lda 1,x                 ; MSB
00165Dr 3  D5 03                        cmp 3,x
00165Fr 3  D0 04                        bne @false
001661r 3               
001661r 3  A9 FF                        lda #$ff
001663r 3  80 02                        bra @done
001665r 3               
001665r 3  A9 00        @false:         lda #0                  ; drop thru to done
001667r 3               
001667r 3  95 02        @done:          sta 2,x
001669r 3  95 03                        sta 3,x
00166Br 3               
00166Br 3  E8                           inx
00166Cr 3  E8                           inx
00166Dr 3               
00166Dr 3  60           z_equal:        rts
00166Er 3               
00166Er 3               
00166Er 3               
00166Er 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
00166Er 3               ; ## "blank"  auto  ANS string
00166Er 3                       ; """https://forth-standard.org/standard/string/BLANK"""
00166Er 3               xt_blank:
00166Er 3                               ; We don't check for underflow here because
00166Er 3                               ; we deal with that in FILL
00166Er 3  CA                           dex
00166Fr 3  CA                           dex
001670r 3  A9 20                        lda #AscSP
001672r 3  95 00                        sta 0,x
001674r 3  74 01                        stz 1,x
001676r 3               
001676r 3  80 06                        bra xt_fill     ; skip over code for ERASE
001678r 3               
001678r 3               
001678r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
001678r 3               ; ## "erase"  auto  ANS core ext
001678r 3                       ; """https://forth-standard.org/standard/core/ERASE
001678r 3                       ; Note that ERASE works with "address" units
001678r 3                       ; (bytes), not cells.
001678r 3                       ; """
001678r 3               
001678r 3               xt_erase:
001678r 3                               ; We don't check for underflow here because
001678r 3                               ; we deal with that in FILL
001678r 3  CA                           dex
001679r 3  CA                           dex
00167Ar 3  74 00                        stz 0,x
00167Cr 3  74 01                        stz 1,x
00167Er 3               
00167Er 3                               ; fall through to FILL
00167Er 3               
00167Er 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
00167Er 3               ; ## "fill"  auto  ANS core
00167Er 3                       ; """https://forth-standard.org/standard/core/FILL
00167Er 3                       ; Fill u bytes of memory with char starting at addr. Note that
00167Er 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
00167Er 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
00167Er 3                       ; happens when we reach the end of the address space
00167Er 3                       ; """
00167Er 3               xt_fill:
00167Er 3  20 rr rr                     jsr underflow_3
001681r 3               
001681r 3                               ; We use tmp1 to hold the address
001681r 3  B5 04                        lda 4,x         ; LSB
001683r 3  85 rr                        sta tmp1
001685r 3  B5 05                        lda 5,x
001687r 3  85 rr                        sta tmp1+1
001689r 3               
001689r 3                               ; We use tmp2 to hold the counter
001689r 3  B5 02                        lda 2,x
00168Br 3  85 rr                        sta tmp2
00168Dr 3  B5 03                        lda 3,x
00168Fr 3  85 rr                        sta tmp2+1
001691r 3               
001691r 3                               ; We use Y to hold the character
001691r 3  B5 00                        lda 0,x
001693r 3  A8                           tay
001694r 3               @loop:
001694r 3                               ; Unfortunately, we also need to make sure that we don't
001694r 3                               ; write further than the end of the RAM. So RAM_END must
001694r 3                               ; be larger or equal to the current address
001694r 3  A9 80                        lda #>ram_end           ; MSB
001696r 3  C5 rr                        cmp tmp1+1
001698r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
00169Ar 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
00169Cr 3               
00169Cr 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
00169Er 3  C5 rr                        cmp tmp1
0016A0r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
0016A2r 3               
0016A2r 3               @check_counter:
0016A2r 3                               ; See if our counter has reached zero
0016A2r 3  A5 rr                        lda tmp2
0016A4r 3  05 rr                        ora tmp2+1
0016A6r 3  F0 13                        beq @done
0016A8r 3               
0016A8r 3                               ; We're not in ROM and we still have stuff on the counter, so
0016A8r 3                               ; let's actually do what we came here to do
0016A8r 3  98                           tya
0016A9r 3  92 rr                        sta (tmp1)
0016ABr 3               
0016ABr 3                               ; Adjust the counter
0016ABr 3  A5 rr                        lda tmp2
0016ADr 3  D0 02                        bne @1
0016AFr 3  C6 rr                        dec tmp2+1
0016B1r 3  C6 rr        @1:               dec tmp2
0016B3r 3               
0016B3r 3                               ; Next address
0016B3r 3  E6 rr                        inc tmp1
0016B5r 3  D0 DD                        bne @loop
0016B7r 3  E6 rr                        inc tmp1+1
0016B9r 3               
0016B9r 3  80 D9                        bra @loop
0016BBr 3               
0016BBr 3               @done:
0016BBr 3                               ; Drop three cells off the Data Stack. This uses one byte
0016BBr 3                               ; less than six times INX
0016BBr 3  8A                           txa
0016BCr 3  18                           clc
0016BDr 3  69 06                        adc #6
0016BFr 3  AA                           tax
0016C0r 3               z_blank:
0016C0r 3               z_erase:
0016C0r 3  60           z_fill:         rts
0016C1r 3               
0016C1r 3               
0016C1r 3               
0016C1r 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
0016C1r 3               ; ## "execute"  auto  ANS core
0016C1r 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
0016C1r 3               xt_execute:
0016C1r 3  20 rr rr                     jsr underflow_1
0016C4r 3               
0016C4r 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
0016C7r 3               
0016C7r 3  60           z_execute:      rts
0016C8r 3               
0016C8r 3               doexecute:
0016C8r 3  B5 00                        lda 0,x
0016CAr 3  85 rr                        sta ip
0016CCr 3  B5 01                        lda 1,x
0016CEr 3  85 rr                        sta ip+1
0016D0r 3               
0016D0r 3  E8                           inx
0016D1r 3  E8                           inx
0016D2r 3               
0016D2r 3                               ; we don't need a RTS here because we highjack the RTS of
0016D2r 3                               ; the word we're calling to get back to xt_execute
0016D2r 3  6C rr rr                     jmp (ip)
0016D5r 3               
0016D5r 3               ; end of doexecute
0016D5r 3               
0016D5r 3               
0016D5r 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
0016D5r 3               ; ## "execute-parsing"  auto  Gforth
0016D5r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
0016D5r 3                       ; Execute the parsing word defined by the execution token (xt) on the
0016D5r 3                       ; string as if it were passed on the command line. See the file
0016D5r 3                       ; tests/tali.fs for examples.
0016D5r 3                       ;
0016D5r 3                       ; Note that this word is coded completely
0016D5r 3                       ; different in its Gforth version, see the file execute-parsing.fs
0016D5r 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
0016D5r 3                       ; """
0016D5r 3               xt_execute_parsing:
0016D5r 3  20 rr rr                     jsr underflow_3
0016D8r 3               
0016D8r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
0016DBr 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
0016DEr 3               
0016DEr 3  B5 00                        lda 0,x                 ; TOS is new ciblen
0016E0r 3  85 rr                        sta ciblen
0016E2r 3  B5 01                        lda 1,x
0016E4r 3  85 rr                        sta ciblen+1
0016E6r 3               
0016E6r 3  B5 02                        lda 2,x                 ; NOS is new cib
0016E8r 3  85 rr                        sta cib
0016EAr 3  B5 03                        lda 3,x
0016ECr 3  85 rr                        sta cib+1
0016EEr 3               
0016EEr 3  64 rr                        stz toin                ; Set >IN to zero
0016F0r 3  64 rr                        stz toin+1
0016F2r 3               
0016F2r 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
0016F5r 3  20 rr rr                     jsr xt_execute
0016F8r 3               
0016F8r 3  20 rr rr                     jsr xt_r_to_input
0016FBr 3               
0016FBr 3               z_execute_parsing:
0016FBr 3  60                           rts
0016FCr 3               
0016FCr 3               
0016FCr 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
0016FCr 3               ; ## "exit"  auto  ANS core
0016FCr 3                       ; """https://forth-standard.org/standard/core/EXIT
0016FCr 3                       ; If we're in a loop, we need to UNLOOP first and get everything
0016FCr 3                       ; we we might have put on the Return Stack off as well. This should
0016FCr 3                       ; be natively compiled.
0016FCr 3                       ; """
0016FCr 3               
0016FCr 3               xt_exit:
0016FCr 3  60                           rts             ; keep before z_exit
0016FDr 3               z_exit:                         ; never reached
0016FDr 3               
0016FDr 3               
0016FDr 3               
0016FDr 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
0016FDr 3               ; ## "false"  auto  ANS core ext
0016FDr 3                       ; """https://forth-standard.org/standard/core/FALSE"""
0016FDr 3               xt_false:
0016FDr 3  CA                           dex
0016FEr 3  CA                           dex
0016FFr 3  74 00                        stz 0,x
001701r 3  74 01                        stz 1,x
001703r 3               
001703r 3  60           z_false:        rts
001704r 3               
001704r 3               
001704r 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
001704r 3               ; ## "@"  auto  ANS core
001704r 3                       ; """https://forth-standard.org/standard/core/Fetch"""
001704r 3               xt_fetch:
001704r 3  20 rr rr                     jsr underflow_1
001707r 3               
001707r 3  A1 00                        lda (0,x)               ; LSB
001709r 3  A8                           tay
00170Ar 3  F6 00                        inc 0,x
00170Cr 3  D0 02                        bne @1
00170Er 3  F6 01                        inc 1,x
001710r 3               @1:
001710r 3  A1 00                        lda (0,x)               ; MSB
001712r 3  95 01                        sta 1,x
001714r 3  94 00                        sty 0,x
001716r 3               
001716r 3  60           z_fetch:        rts
001717r 3               
001717r 3               
001717r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
001717r 3               ; ## "find"  auto  ANS core
001717r 3                       ; """https://forth-standard.org/standard/core/FIND
001717r 3                       ; Included for backwards compatibility only, because it still
001717r 3                       ; can be found in so may examples. It should, however, be replaced
001717r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
001717r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
001717r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
001717r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
001717r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
001717r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001717r 3                       ; """
001717r 3               
001717r 3               xt_find:
001717r 3  20 rr rr                     jsr underflow_1
00171Ar 3               
00171Ar 3                               ; Save address in case conversion fails. We use the
00171Ar 3                               ; Return Stack instead of temporary variables like TMP1
00171Ar 3                               ; because this is shorter and anybody still using FIND
00171Ar 3                               ; can't be worried about speed anyway
00171Ar 3  B5 01                        lda 1,x                 ; MSB
00171Cr 3  48                           pha
00171Dr 3  B5 00                        lda 0,x                 ; LSB
00171Fr 3  48                           pha
001720r 3               
001720r 3                               ; Convert ancient-type counted string address to
001720r 3                               ; modern format
001720r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
001723r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
001726r 3               
001726r 3  B5 00                        lda 0,x
001728r 3  15 01                        ora 1,x
00172Ar 3  D0 0B                        bne @found_word
00172Cr 3               
00172Cr 3                               ; No word found. Return address of the string and a false
00172Cr 3                               ; flag
00172Cr 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
00172Fr 3               
00172Fr 3                               ; The address needs to be restored.
00172Fr 3  68                           pla                     ; LSB of address
001730r 3  95 02                        sta 2,x
001732r 3  68                           pla
001733r 3  95 03                        sta 3,x                 ; MSB of address
001735r 3               
001735r 3  80 27                        bra @done               ; ( addr 0 )
001737r 3               
001737r 3               @found_word:
001737r 3                               ; We don't need the address after all, dump it
001737r 3  68                           pla
001738r 3  68                           pla
001739r 3               
001739r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
001739r 3                               ; convert the return values to FIND's format
001739r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
00173Cr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
00173Fr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001742r 3               
001742r 3  A0 00                        ldy #0                  ; Prepare flag
001744r 3               
001744r 3                               ; The flags are in the second byte of the header
001744r 3  F6 00                        inc 0,x
001746r 3  D0 02                        bne @1
001748r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
00174Ar 3               @1:
00174Ar 3  A1 00                        lda (0,x)               ; ( xt char )
00174Cr 3  29 04                        and #IM
00174Er 3  D0 08                        bne @immediate          ; bit set, we're immediate
001750r 3               
001750r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001752r 3  95 00                        sta 0,x
001754r 3  95 01                        sta 1,x
001756r 3  80 06                        bra @done
001758r 3               
001758r 3               @immediate:
001758r 3  A9 01                        lda #1                  ; We're immediate, return 1
00175Ar 3  95 00                        sta 0,x
00175Cr 3  74 01                        stz 1,x
00175Er 3               @done:
00175Er 3  60           z_find:         rts
00175Fr 3               
00175Fr 3               
00175Fr 3               
00175Fr 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
00175Fr 3               ; ## "find-name"  auto  Gforth
00175Fr 3               
00175Fr 3               xt_find_name:
00175Fr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00175Fr 3                       ; Given a string, find the Name Token (nt) of a word or return
00175Fr 3                       ; zero if the word is not in the dictionary. We use this instead of
00175Fr 3                       ; ancient FIND to look up words in the Dictionary passed by
00175Fr 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
00175Fr 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
00175Fr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
00175Fr 3                       ; FIND calls this word
00175Fr 3                       ; """
00175Fr 3  20 rr rr                     jsr underflow_2
001762r 3               
001762r 3                               ; check for special case of an empty string (length zero)
001762r 3  B5 00                        lda 0,x
001764r 3  15 01                        ora 1,x
001766r 3  D0 03                        bne @nonempty
001768r 3               
001768r 3  4C rr rr                     jmp @fail_done
00176Br 3               
00176Br 3               @nonempty:
00176Br 3                               ; Set up for traversing the wordlist search order.
00176Br 3  64 rr                        stz tmp3                ; Start at the beginning
00176Dr 3               
00176Dr 3               @wordlist_loop:
00176Dr 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
00176Fr 3  A5 rr                        lda tmp3
001771r 3  D1 rr                        cmp (up),y              ; Check to see if we are done
001773r 3  D0 03                        bne @have_string
001775r 3               
001775r 3                               ; We ran out of wordlists to search.
001775r 3  4C rr rr                     jmp @fail_done
001778r 3               
001778r 3               @have_string:
001778r 3                               ; set up first loop iteration
001778r 3               
001778r 3                               ; Get the current wordlist id
001778r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
001779r 3  69 1F                        adc #search_order_offset
00177Br 3  A8                           tay
00177Cr 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
00177Er 3                                               ; into the cell array WORDLISTS
00177Er 3               
00177Er 3                               ; Get the DP for that wordlist.
00177Er 3  0A                           asl                     ; Turn offset into cells offset.
00177Fr 3  18                           clc
001780r 3  69 06                        adc #wordlists_offset
001782r 3  A8                           tay
001783r 3  B1 rr                        lda (up),y
001785r 3  85 rr                        sta tmp1
001787r 3  C8                           iny
001788r 3  B1 rr                        lda (up),y
00178Ar 3  85 rr                        sta tmp1+1
00178Cr 3               
00178Cr 3  B5 02                        lda 2,x                 ; Address of mystery string
00178Er 3  85 rr                        sta tmp2
001790r 3  B5 03                        lda 3,x
001792r 3  85 rr                        sta tmp2+1
001794r 3               
001794r 3               @loop:
001794r 3                               ; first quick test: Are strings the same length?
001794r 3  B2 rr                        lda (tmp1)
001796r 3  D5 00                        cmp 0,x
001798r 3  D0 54                        bne @next_entry
00179Ar 3               
00179Ar 3               @compare_string:
00179Ar 3                               ; are the same length, so we now have to compare each
00179Ar 3                               ; character
00179Ar 3               
00179Ar 3                               ; second quick test: Is the first character the same?
00179Ar 3  B2 rr                        lda (tmp2)      ; first character of mystery string
00179Cr 3               
00179Cr 3                               ; Lowercase the incoming charcter.
00179Cr 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
00179Er 3  B0 07                        bcs @compare_first
0017A0r 3  C9 41                        cmp #$41        ; ASCII 'A'
0017A2r 3  90 03                        bcc @compare_first
0017A4r 3               
0017A4r 3                               ; An uppercase letter has been located.  Make it
0017A4r 3                               ; lowercase.
0017A4r 3  18                           clc
0017A5r 3  69 20                        adc #$20
0017A7r 3               
0017A7r 3               @compare_first:
0017A7r 3  A0 08                        ldy #8          ; Offset in nt to name
0017A9r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
0017ABr 3  D0 41                        bne @next_entry
0017ADr 3               
0017ADr 3                               ; String length is the same and the first character is the
0017ADr 3                               ; same. If the length of the string is 1, we're already done
0017ADr 3  B5 00                        lda 0,x
0017AFr 3  3A                           dec
0017B0r 3  F0 2C                        beq @success
0017B2r 3               
0017B2r 3                               ; No such luck: The strings are the same length and the first
0017B2r 3                               ; char is the same, but the word is more than one char long.
0017B2r 3                               ; So we suck it up and compare every single character. We go
0017B2r 3                               ; from back to front, because words like CELLS and CELL+ would
0017B2r 3                               ; take longer otherwise. We can also shorten the loop by one
0017B2r 3                               ; because we've already compared the first char.
0017B2r 3               
0017B2r 3                               ; The string of the word we're testing against is 8 bytes down
0017B2r 3  A5 rr                        lda tmp1
0017B4r 3  48                           pha             ; Preserve tmp1 on the return stack.
0017B5r 3  18                           clc
0017B6r 3  69 08                        adc #8
0017B8r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
0017BAr 3  A5 rr                        lda tmp1+1
0017BCr 3  48                           pha             ; Preserve tmp1+1 on the return stack.
0017BDr 3  69 00                        adc #0          ; we only need the carry
0017BFr 3  85 rr                        sta tmp1+1
0017C1r 3               
0017C1r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
0017C3r 3  88                           dey
0017C4r 3               
0017C4r 3               @string_loop:
0017C4r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
0017C6r 3               
0017C6r 3                               ; Lowercase the incoming charcter.
0017C6r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
0017C8r 3  B0 07                        bcs @check_char
0017CAr 3  C9 41                        cmp #$41        ; ASCII 'A'
0017CCr 3  90 03                        bcc @check_char
0017CEr 3               
0017CEr 3                               ; An uppercase letter has been located.  Make it
0017CEr 3                               ; lowercase.
0017CEr 3  18                           clc
0017CFr 3  69 20                        adc #$20
0017D1r 3               
0017D1r 3               @check_char:
0017D1r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
0017D3r 3  D0 13                        bne @next_entry_tmp1
0017D5r 3               
0017D5r 3  88                           dey
0017D6r 3  D0 EC                        bne @string_loop
0017D8r 3               
0017D8r 3               @success_tmp1:
0017D8r 3  68                           pla             ; Restore tmp1 from the return stack.
0017D9r 3  85 rr                        sta tmp1+1
0017DBr 3  68                           pla
0017DCr 3  85 rr                        sta tmp1
0017DEr 3               
0017DEr 3               @success:
0017DEr 3                               ; The strings match. Put correct nt NOS, because we'll drop
0017DEr 3                               ; TOS before we leave
0017DEr 3  A5 rr                        lda tmp1
0017E0r 3  95 02                        sta 2,x
0017E2r 3  A5 rr                        lda tmp1+1
0017E4r 3  95 03                        sta 3,x
0017E6r 3               
0017E6r 3  80 20                        bra @done
0017E8r 3               
0017E8r 3               @next_entry_tmp1:
0017E8r 3  68                           pla             ; Restore tmp1 from the return stack.
0017E9r 3  85 rr                        sta tmp1+1
0017EBr 3  68                           pla
0017ECr 3  85 rr                        sta tmp1
0017EEr 3               
0017EEr 3               @next_entry:
0017EEr 3                               ; Not the same, so we get the next word. Next header
0017EEr 3                               ; address is two bytes down
0017EEr 3  A0 02                        ldy #2
0017F0r 3  B1 rr                        lda (tmp1),y
0017F2r 3  48                           pha
0017F3r 3  C8                           iny
0017F4r 3  B1 rr                        lda (tmp1),y
0017F6r 3  85 rr                        sta tmp1+1
0017F8r 3  68                           pla
0017F9r 3  85 rr                        sta tmp1
0017FBr 3               
0017FBr 3                               ; If we got a zero, we've walked the whole Dictionary and
0017FBr 3                               ; return as a failure, otherwise try again
0017FBr 3  05 rr                        ora tmp1+1
0017FDr 3  D0 95                        bne @loop
0017FFr 3               
0017FFr 3                               ; Move on to the next wordlist in the search order.
0017FFr 3  E6 rr                        inc tmp3
001801r 3  4C rr rr                     jmp @wordlist_loop
001804r 3               
001804r 3               @fail_done:
001804r 3  74 02                        stz 2,x         ; failure flag
001806r 3  74 03                        stz 3,x
001808r 3               @done:
001808r 3  E8                           inx
001809r 3  E8                           inx
00180Ar 3               
00180Ar 3  60           z_find_name:    rts
00180Br 3               
00180Br 3               
00180Br 3               
00180Br 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
00180Br 3               ; ## "flush"  auto  ANS block
00180Br 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
00180Br 3               xt_flush:
00180Br 3  20 rr rr                     jsr xt_save_buffers
00180Er 3               
00180Er 3                               ; Set the buffer status to empty.
00180Er 3  A0 2C                        ldy #buffstatus_offset
001810r 3  A9 00                        lda #0
001812r 3  91 rr                        sta (up),y      ; Only LSB is used.
001814r 3               z_flush:
001814r 3  60                           rts
001815r 3               
001815r 3               
001815r 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
001815r 3               ; ## "fm/mod"  auto  ANS core
001815r 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
001815r 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
001815r 3                       ;
001815r 3                       ; There are various ways to realize this. We follow EForth with
001815r 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
001815r 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
001815r 3                       ; See (http://www.forth.org/eforth.html). However you can also
001815r 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
001815r 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
001815r 3                       ; """
001815r 3               
001815r 3               xt_fm_slash_mod:
001815r 3  20 rr rr                     jsr underflow_3
001818r 3               
001818r 3                               ; if sign of n1 is negative, negate both n1 and d
001818r 3  64 rr                        stz tmp2        ; default: n is positive
00181Ar 3  B5 01                        lda 1,x         ; MSB of n1
00181Cr 3  10 0E                        bpl @check_d
00181Er 3               
00181Er 3  E6 rr                        inc tmp2        ; set flag to negative for n1
001820r 3  20 rr rr                     jsr xt_negate   ; NEGATE
001823r 3  20 rr rr                     jsr xt_to_r     ; >R
001826r 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001829r 3  20 rr rr                     jsr xt_r_from   ; R>
00182Cr 3               
00182Cr 3               @check_d:
00182Cr 3                               ; If d is negative, add n1 to high cell of d
00182Cr 3  B5 03                        lda 3,x         ; MSB of high word of d
00182Er 3  10 0D                        bpl @multiply
001830r 3               
001830r 3  18                           clc
001831r 3  B5 00                        lda 0,x         ; LSB of n1
001833r 3  75 02                        adc 2,x         ; LSB of dh
001835r 3  95 02                        sta 2,x
001837r 3               
001837r 3  B5 01                        lda 1,x         ; MSB of n1
001839r 3  75 03                        adc 3,x         ; MSB of dh
00183Br 3  95 03                        sta 3,x
00183Dr 3               
00183Dr 3               @multiply:
00183Dr 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
001840r 3               
001840r 3                               ; if n was negative, negate the result
001840r 3  A5 rr                        lda tmp2
001842r 3  F0 07                        beq @done
001844r 3               
001844r 3  E8                           inx             ; pretend that we SWAP
001845r 3  E8                           inx
001846r 3  20 rr rr                     jsr xt_negate
001849r 3  CA                           dex
00184Ar 3  CA                           dex
00184Br 3               @done:
00184Br 3  60           z_fm_slash_mod: rts
00184Cr 3               
00184Cr 3               
00184Cr 3               
00184Cr 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
00184Cr 3               ; ## "forth"  auto  ANS search ext
00184Cr 3                       ; """https://forth-standard.org/standard/search/FORTH"""
00184Cr 3               xt_forth:
00184Cr 3  A0 1F                        ldy #search_order_offset
00184Er 3  A9 00                        lda #0          ; The WID for Forth is 0.
001850r 3               
001850r 3  91 rr                        sta (up),y
001852r 3               z_forth:
001852r 3  60                           rts
001853r 3               
001853r 3               
001853r 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
001853r 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
001853r 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
001853r 3               load_evaluate:
001853r 3                               ; Set a flag (using tmp1) to not zero BLK
001853r 3  A9 FF                        lda #$FF
001855r 3  85 rr                        sta tmp1
001857r 3  80 11                        bra load_evaluate_start
001859r 3               
001859r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
001859r 3               ; ## "evaluate"  auto  ANS core
001859r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
001859r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
001859r 3                       ; After processing the line, revert to old input source. We use this
001859r 3                       ; to compile high-level Forth words and user-defined words during
001859r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
001859r 3                       ; accept more than 255 characters here, even though it's a pain in
001859r 3                       ; the 8-bit.
001859r 3                       ; """
001859r 3               
001859r 3               xt_evaluate:
001859r 3  20 rr rr                     jsr underflow_2
00185Cr 3               
00185Cr 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
00185Cr 3                               ; and will set the block number.
00185Cr 3  64 rr                        stz tmp1
00185Er 3               
00185Er 3                               ; If u is zero (which can happen a lot for the user-defined
00185Er 3                               ; words), just leave again
00185Er 3  B5 00                        lda 0,x
001860r 3  15 01                        ora 1,x
001862r 3  D0 06                        bne _eval_got_work
001864r 3               
001864r 3  E8                           inx
001865r 3  E8                           inx
001866r 3  E8                           inx
001867r 3  E8                           inx
001868r 3               
001868r 3  80 42                        bra _eval_done
00186Ar 3               
00186Ar 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
00186Ar 3               load_evaluate_start:
00186Ar 3               _eval_got_work:
00186Ar 3                               ; Save the current value of BLK on the return stack.
00186Ar 3  A0 01                        ldy #blk_offset+1
00186Cr 3  B1 rr                        lda (up),y
00186Er 3  48                           pha
00186Fr 3  88                           dey
001870r 3  B1 rr                        lda (up),y
001872r 3  48                           pha
001873r 3               
001873r 3                               ; See if we should zero BLK.
001873r 3  A5 rr                        lda tmp1
001875r 3  D0 05                        bne @nozero
001877r 3               
001877r 3                               ; Set BLK to zero.
001877r 3                               ; lda #0        ; A is already zero from loading tmp1
001877r 3  91 rr                        sta (up),y
001879r 3  C8                           iny
00187Ar 3  91 rr                        sta (up),y
00187Cr 3               
00187Cr 3               @nozero:
00187Cr 3                               ; Save the input state to the Return Stack
00187Cr 3  20 rr rr                     jsr xt_input_to_r
00187Fr 3               
00187Fr 3                               ; set SOURCE-ID to -1
00187Fr 3  A9 FF                        lda #$ff
001881r 3  85 rr                        sta insrc
001883r 3  85 rr                        sta insrc+1
001885r 3               
001885r 3                               ; set >IN to zero
001885r 3  64 rr                        stz toin
001887r 3  64 rr                        stz toin+1
001889r 3               
001889r 3                               ; move TOS and NOS to input buffers
001889r 3  B5 00                        lda 0,x
00188Br 3  85 rr                        sta ciblen
00188Dr 3  B5 01                        lda 1,x
00188Fr 3  85 rr                        sta ciblen+1
001891r 3               
001891r 3  B5 02                        lda 2,x
001893r 3  85 rr                        sta cib
001895r 3  B5 03                        lda 3,x
001897r 3  85 rr                        sta cib+1
001899r 3               
001899r 3  E8                           inx             ; A clean stack is a clean mind
00189Ar 3  E8                           inx
00189Br 3  E8                           inx
00189Cr 3  E8                           inx
00189Dr 3               
00189Dr 3  20 rr rr                     jsr interpret   ; ( -- )
0018A0r 3               
0018A0r 3                               ; restore variables
0018A0r 3  20 rr rr                     jsr xt_r_to_input
0018A3r 3               
0018A3r 3                               ; Restore BLK from the return stack.
0018A3r 3  A0 00                        ldy #blk_offset
0018A5r 3  68                           pla
0018A6r 3  91 rr                        sta (up),y
0018A8r 3  C8                           iny
0018A9r 3  68                           pla
0018AAr 3  91 rr                        sta (up),y
0018ACr 3               
0018ACr 3               _eval_done:
0018ACr 3  60           z_evaluate:     rts
0018ADr 3               
0018ADr 3               
0018ADr 3               
0018ADr 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
0018ADr 3               ; ## "forth-wordlist"  auto  ANS search
0018ADr 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
0018ADr 3                       ; This is a dummy entry, the actual code is shared with ZERO.
0018ADr 3               
0018ADr 3               
0018ADr 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
0018ADr 3               ; ## "get-current" auto ANS search
0018ADr 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
0018ADr 3               
0018ADr 3               xt_get_current:
0018ADr 3                               ; This is a little different than some of the variables
0018ADr 3                               ; in the user area as we want the value rather than
0018ADr 3                               ; the address.
0018ADr 3  CA                           dex
0018AEr 3  CA                           dex
0018AFr 3  A0 04                        ldy #current_offset
0018B1r 3  B1 rr                        lda (up),y
0018B3r 3  95 00                        sta 0,x         ; CURRENT is a byte variable
0018B5r 3  74 01                        stz 1,x         ; so the MSB is zero.
0018B7r 3               
0018B7r 3  60           z_get_current:  rts
0018B8r 3               
0018B8r 3               
0018B8r 3               
0018B8r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
0018B8r 3               ; ## "get-order" auto ANS search
0018B8r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
0018B8r 3               
0018B8r 3               xt_get_order:
0018B8r 3                               ; Get #ORDER - the number of wordlists in the search order.
0018B8r 3  A0 1E                        ldy #num_order_offset
0018BAr 3  B1 rr                        lda (up),y
0018BCr 3  85 rr                        sta tmp1
0018BEr 3  F0 16                        beq @done       ; If zero, there are no wordlists.
0018C0r 3               
0018C0r 3               @loop:
0018C0r 3                               ; Count down towards the front of the list.
0018C0r 3                               ; By decrementing first, we also turn the length into an offset.
0018C0r 3  C6 rr                        dec tmp1        ; Count down by bytes.
0018C2r 3               
0018C2r 3                               ; Get a pointer to the current wordlist, working back to front.
0018C2r 3  A9 1F                        lda #search_order_offset
0018C4r 3  18                           clc
0018C5r 3  65 rr                        adc tmp1
0018C7r 3  A8                           tay
0018C8r 3               
0018C8r 3                               ; Put that wordlist id on the stack.
0018C8r 3  CA                           dex
0018C9r 3  CA                           dex
0018CAr 3  B1 rr                        lda (up),y
0018CCr 3  95 00                        sta 0,x         ; Search order array is bytes, so
0018CEr 3  74 01                        stz 1,x         ; put a zero in the high byte.
0018D0r 3               
0018D0r 3                               ; See if that was the last one to process (first in the list).
0018D0r 3  A9 00                        lda #0
0018D2r 3  C5 rr                        cmp tmp1
0018D4r 3  D0 EA                        bne @loop
0018D6r 3               
0018D6r 3               @done:
0018D6r 3                               ; Put the number of items on the stack.
0018D6r 3  CA                           dex
0018D7r 3  CA                           dex
0018D8r 3  A0 1E                        ldy #num_order_offset
0018DAr 3  B1 rr                        lda (up),y
0018DCr 3  95 00                        sta 0,x
0018DEr 3  74 01                        stz 1,x         ; We only support 8 wordlists.
0018E0r 3               
0018E0r 3  60           z_get_order:    rts
0018E1r 3               
0018E1r 3               
0018E1r 3               
0018E1r 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
0018E1r 3               ; ## ">"  auto  ANS core
0018E1r 3                       ; """https://forth-standard.org/standard/core/more"""
0018E1r 3               
0018E1r 3               xt_greater_than:
0018E1r 3  20 rr rr                     jsr underflow_2
0018E4r 3               
0018E4r 3  A0 00                        ldy #0          ; default false
0018E6r 3  20 rr rr                     jsr compare_16bit
0018E9r 3               
0018E9r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
0018E9r 3  F0 03                        beq @false
0018EBr 3  10 01                        bpl @false
0018EDr 3               
0018EDr 3                               ; true
0018EDr 3  88                           dey
0018EEr 3               @false:
0018EEr 3  98                           tya
0018EFr 3               
0018EFr 3  E8                           inx
0018F0r 3  E8                           inx
0018F1r 3  95 00                        sta 0,x
0018F3r 3  95 01                        sta 1,x
0018F5r 3               
0018F5r 3  60           z_greater_than: rts
0018F6r 3               
0018F6r 3               
0018F6r 3               
0018F6r 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
0018F6r 3               ; ## "here"  auto  ANS core
0018F6r 3                       ; """https://forth-standard.org/standard/core/HERE
0018F6r 3                       ; This code is also used by the assembler directive ARROW
0018F6r 3                       ; ("->") though as immediate"""
0018F6r 3               xt_here:
0018F6r 3               xt_asm_arrow:
0018F6r 3  CA                           dex
0018F7r 3  CA                           dex
0018F8r 3  A5 rr                        lda cp
0018FAr 3  95 00                        sta 0,x
0018FCr 3  A5 rr                        lda cp+1
0018FEr 3  95 01                        sta 1,x
001900r 3               
001900r 3               z_asm_arrow:
001900r 3  60           z_here:         rts
001901r 3               
001901r 3               
001901r 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
001901r 3               ; ## "hex"  auto  ANS core ext
001901r 3                       ; """https://forth-standard.org/standard/core/HEX"""
001901r 3               xt_hex:
001901r 3  A9 10                        lda #16
001903r 3  85 rr                        sta base
001905r 3  64 rr                        stz base+1              ; paranoid
001907r 3               
001907r 3  60           z_hex:          rts
001908r 3               
001908r 3               
001908r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001908r 3               ; ## "hexstore"  auto  Tali
001908r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001908r 3                       ; by spaces, store the numbers at the address addr2, returning the
001908r 3                       ; number of elements. Non-number elements are skipped, an zero-length
001908r 3                       ; string produces a zero output.
001908r 3                       ; """
001908r 3               
001908r 3               xt_hexstore:
001908r 3  20 rr rr                     jsr underflow_3
00190Br 3               
00190Br 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
00190Er 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
001911r 3               
001911r 3               @loop:
001911r 3                               ; Loop until string is totally consumed
001911r 3  B5 00                        lda 0,x
001913r 3  15 01                        ora 1,x
001915r 3  F0 36                        beq @done
001917r 3               
001917r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
00191Ar 3               
00191Ar 3                               ; Prepare the conversion of the number.
00191Ar 3  20 rr rr                     jsr xt_two_to_r
00191Dr 3  20 rr rr                     jsr xt_zero
001920r 3  20 rr rr                     jsr xt_zero
001923r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
001926r 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001929r 3               
001929r 3                               ; If u4 is not zero, we have leftover chars and have to do
001929r 3                               ; things differently
001929r 3  B5 00                        lda 0,x
00192Br 3  15 01                        ora 1,x
00192Dr 3  D0 17                        bne @have_chars_left
00192Fr 3               
00192Fr 3                               ; Normal case, this number is all done
00192Fr 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
001932r 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
001935r 3               
001935r 3                               ; Store the new value
001935r 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
001938r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
00193Br 3               
00193Br 3                               ; Increase counter
00193Br 3  20 rr rr                     jsr xt_r_from           ; R>
00193Er 3  20 rr rr                     jsr xt_one_plus         ; 1+
001941r 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
001944r 3  80 CB                        bra @loop
001946r 3               
001946r 3               @have_chars_left:
001946r 3                               ; Pathological case: Drop the rest of this number off the stack
001946r 3                               ; and continue with the next word. Doesn't print a warning. We
001946r 3                               ; need to drop four cells, that is, eight bytes
001946r 3  8A                           txa
001947r 3  18                           clc
001948r 3  69 08                        adc #8
00194Ar 3  AA                           tax
00194Br 3  80 C4                        bra @loop
00194Dr 3               
00194Dr 3               @done:
00194Dr 3                               ; Clean up return stack and calculate number of chars stored
00194Dr 3  E8                           inx
00194Er 3  E8                           inx
00194Fr 3  E8                           inx
001950r 3  E8                           inx                     ; 2DROP
001951r 3               
001951r 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
001954r 3  20 rr rr                     jsr xt_swap
001957r 3  20 rr rr                     jsr xt_minus            ; ( n )
00195Ar 3               
00195Ar 3  60           z_hexstore:     rts
00195Br 3               
00195Br 3               
00195Br 3               
00195Br 3               ; ## HOLD ( char -- ) "Insert character at current output"
00195Br 3               ; ## "hold"  auto  ANS core
00195Br 3                       ; """https://forth-standard.org/standard/core/HOLD
00195Br 3                       ; Insert a character at the current position of a pictured numeric
00195Br 3                       ; output string on
00195Br 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00195Br 3                       ;
00195Br 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
00195Br 3                       ; variable tohold instead of HLD.
00195Br 3                       ; """
00195Br 3               xt_hold:
00195Br 3  20 rr rr                     jsr underflow_1
00195Er 3               
00195Er 3  A5 rr                        lda tohold
001960r 3  D0 02                        bne @1
001962r 3  C6 rr                        dec tohold+1
001964r 3               @1:
001964r 3  C6 rr                        dec tohold
001966r 3               
001966r 3  B5 00                        lda 0,x
001968r 3  92 rr                        sta (tohold)
00196Ar 3  E8                           inx
00196Br 3  E8                           inx
00196Cr 3               
00196Cr 3  60           z_hold:         rts
00196Dr 3               
00196Dr 3               
00196Dr 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
00196Dr 3               ; ## "i"  auto  ANS core
00196Dr 3                       ; """https://forth-standard.org/standard/core/I
00196Dr 3                       ; Note that this is not the same as R@ because we use a fudge
00196Dr 3                       ; factor for loop control; see the Control Flow section of the
00196Dr 3                       ; manual for details.
00196Dr 3                       ;
00196Dr 3                       ; We should make this native compile for speed.
00196Dr 3                       ; """
00196Dr 3               
00196Dr 3               xt_i:
00196Dr 3  CA                           dex
00196Er 3  CA                           dex
00196Fr 3               
00196Fr 3                               ; Get the fudged index off of the top of the stack. It's
00196Fr 3                               ; easier to do math on the stack directly than to pop and
00196Fr 3                               ; push stuff around
00196Fr 3  86 rr                        stx tmpdsp
001971r 3  BA                           tsx
001972r 3               
001972r 3  38                           sec
001973r 3  BD 01 01                     lda $0101,x     ; LSB
001976r 3  FD 03 01                     sbc $0103,x
001979r 3  A8                           tay
00197Ar 3               
00197Ar 3  BD 02 01                     lda $0102,x     ; MSB
00197Dr 3  FD 04 01                     sbc $0104,x
001980r 3               
001980r 3  A6 rr                        ldx tmpdsp
001982r 3               
001982r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001984r 3  94 00                        sty 0,x         ; LSB of de-fudged index
001986r 3               
001986r 3  60           z_i:            rts
001987r 3               
001987r 3               
001987r 3               
001987r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
001987r 3               ; ## "if"  auto  ANS core
001987r 3                       ; """http://forth-standard.org/standard/core/IF"""
001987r 3               
001987r 3               xt_if:
001987r 3                               ; Compile a 0BRANCH
001987r 3  A0 rr                        ldy #>zero_branch_runtime
001989r 3  A9 rr                        lda #<zero_branch_runtime
00198Br 3  20 rr rr                     jsr cmpl_subroutine
00198Er 3               
00198Er 3                               ; Put the origination address on the stack for else/then
00198Er 3  20 rr rr                     jsr xt_here
001991r 3               
001991r 3                               ; Stuff zero in for the branch address right now.
001991r 3                               ; THEN or ELSE will fix it later.
001991r 3  20 rr rr                     jsr xt_zero
001994r 3  20 rr rr                     jsr xt_comma
001997r 3  60           z_if:           rts
001998r 3               
001998r 3               
001998r 3               zero_branch_runtime:
001998r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001998r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001998r 3                       ; runtime.
001998r 3                       ; """
001998r 3               
001998r 3                               ; We use the return value on the 65c02 stack to determine
001998r 3                               ; where we want to return to.
001998r 3  68                           pla
001999r 3  85 rr                        sta tmpbranch
00199Br 3  68                           pla
00199Cr 3  85 rr                        sta tmpbranch+1
00199Er 3               
00199Er 3                               ; See if the flag is zero, which is the whole purpose of
00199Er 3                               ; this all
00199Er 3  B5 00                        lda 0,x
0019A0r 3  15 01                        ora 1,x
0019A2r 3  F0 0F                        beq @zero
0019A4r 3               
0019A4r 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
0019A4r 3                               ; the part between IF and THEN
0019A4r 3  A5 rr                        lda tmpbranch   ; LSB
0019A6r 3  18                           clc
0019A7r 3  69 02                        adc #2
0019A9r 3  85 rr                        sta tmp1
0019ABr 3  A5 rr                        lda tmpbranch+1 ; MSB
0019ADr 3  69 00                        adc #0          ; For carry
0019AFr 3  85 rr                        sta tmp1+1
0019B1r 3               
0019B1r 3  80 13                        bra @done
0019B3r 3               
0019B3r 3               @zero:
0019B3r 3                               ; Flag is FALSE (0) so we take the jump to the address given in
0019B3r 3                               ; the next two bytes. However, the address points to the last
0019B3r 3                               ; byte of the JSR instruction, not to the next byte afterwards
0019B3r 3  A0 01                        ldy #1
0019B5r 3  B1 rr                        lda (tmpbranch),y
0019B7r 3  85 rr                        sta tmp1
0019B9r 3  C8                           iny
0019BAr 3  B1 rr                        lda (tmpbranch),y
0019BCr 3  85 rr                        sta tmp1+1
0019BEr 3               
0019BEr 3                               ; Now we have to subtract one byte from the address
0019BEr 3                               ; given because of the way the 6502 calculates RTS
0019BEr 3  A5 rr                        lda tmp1
0019C0r 3  D0 02                        bne @1
0019C2r 3  C6 rr                        dec tmp1+1
0019C4r 3               @1:
0019C4r 3  C6 rr                        dec tmp1
0019C6r 3               
0019C6r 3               @done:
0019C6r 3                               ; However we got here, tmp1 has the value we push to jump
0019C6r 3                               ; to
0019C6r 3  A5 rr                        lda tmp1+1
0019C8r 3  48                           pha             ; MSB first
0019C9r 3  A5 rr                        lda tmp1
0019CBr 3  48                           pha
0019CCr 3               
0019CCr 3                               ; clean up the stack and jump
0019CCr 3  E8                           inx
0019CDr 3  E8                           inx
0019CEr 3               
0019CEr 3  60                           rts
0019CFr 3               
0019CFr 3               
0019CFr 3               
0019CFr 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
0019CFr 3               ; ## "immediate"  auto  ANS core
0019CFr 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
0019CFr 3                       ; Make sure the most recently defined word is immediate. Will only
0019CFr 3                       ; affect the last word in the dictionary. Note that if the word is
0019CFr 3                       ; defined in ROM, this will have no affect, but will not produce an
0019CFr 3                       ; error message.
0019CFr 3                       ; """
0019CFr 3               xt_immediate:
0019CFr 3  20 rr rr                     jsr current_to_dp
0019D2r 3  A0 01                        ldy #1          ; offset for status byte
0019D4r 3  B1 rr                        lda (dp),y
0019D6r 3  09 04                        ora #IM        ; make sure bit 7 is set
0019D8r 3  91 rr                        sta (dp),y
0019DAr 3               
0019DAr 3  60           z_immediate:    rts
0019DBr 3               
0019DBr 3               
0019DBr 3               ; ## INPUT ( -- addr ) "Return address of input vector"
0019DBr 3               ; ## "input" tested Tali Forth
0019DBr 3               
0019DBr 3               xt_input:
0019DBr 3  CA                           dex
0019DCr 3  CA                           dex
0019DDr 3  A9 rr                        lda #<input
0019DFr 3  95 00                        sta 0,x
0019E1r 3  A9 rr                        lda #>input
0019E3r 3  95 01                        sta 1,x
0019E5r 3               
0019E5r 3  60           z_input:        rts
0019E6r 3               
0019E6r 3               
0019E6r 3               
0019E6r 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
0019E6r 3               ; ## "input>r"  tested  Tali Forth
0019E6r 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
0019E6r 3                       ; toin to the Return Stack. Used by EVALUTE.
0019E6r 3                       ;
0019E6r 3                       ; The naive way of doing
0019E6r 3                       ; this is to push each two-byte variable to the stack in the form of
0019E6r 3                       ;
0019E6r 3                       ;       lda insrc
0019E6r 3                       ;       pha
0019E6r 3                       ;       lda insrc+1
0019E6r 3                       ;       pha
0019E6r 3                       ;
0019E6r 3                       ; for a total of 24 byte of instruction in one direction and later
0019E6r 3                       ; a further 24 bytes to reverse the process. We shorten this at the
0019E6r 3                       ; cost of some speed by assuming the four variables are grouped
0019E6r 3                       ; together on the Zero Page and start with insrc (see definitions.asm
0019E6r 3                       ; for details). The reverse operation is r_to_input. These words must
0019E6r 3                       ; be flagged as Never Native. Uses tmp1
0019E6r 3                       ; """
0019E6r 3               
0019E6r 3               xt_input_to_r:
0019E6r 3                               ; We arrive here with the return address on the top of the
0019E6r 3                               ; 65c02's stack. We need to move it out of the way first
0019E6r 3  68                           pla
0019E7r 3  85 rr                        sta tmp1
0019E9r 3  68                           pla
0019EAr 3  85 rr                        sta tmp1+1
0019ECr 3               
0019ECr 3                               ; This assumes that insrc is the first of eight bytes and
0019ECr 3                               ; toin+1 the last in the sequence we want to save from the Zero
0019ECr 3                               ; Page.
0019ECr 3  A0 07                        ldy #7
0019EEr 3               @loop:
0019EEr 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
0019F1r 3  48                           pha
0019F2r 3  88                           dey
0019F3r 3  10 F9                        bpl @loop
0019F5r 3               
0019F5r 3                               ; Restore address for return jump
0019F5r 3  A5 rr                        lda tmp1+1
0019F7r 3  48                           pha
0019F8r 3  A5 rr                        lda tmp1
0019FAr 3  48                           pha
0019FBr 3               
0019FBr 3  60           z_input_to_r: 	rts
0019FCr 3               
0019FCr 3               
0019FCr 3               
0019FCr 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
0019FCr 3               ; ## "int>name"  auto  Tali Forth
0019FCr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0019FCr 3                       ; This is called >NAME in Gforth, but we change it to
0019FCr 3                       ; INT>NAME to match NAME>INT
0019FCr 3                       ; """
0019FCr 3               
0019FCr 3               xt_int_to_name:
0019FCr 3  20 rr rr                     jsr underflow_1
0019FFr 3               
0019FFr 3                               ; Unfortunately, to find the header, we have to walk through
0019FFr 3                               ; all of the wordlists. We are running out of tmp variables.
0019FFr 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
0019FFr 3                               ; hold the current wordlist on the data stack. This searches
0019FFr 3                               ; all of the wordlists in id order.
0019FFr 3  CA                           dex
001A00r 3  CA                           dex
001A01r 3  74 00                        stz 0,x
001A03r 3  74 01                        stz 1,x
001A05r 3               
001A05r 3               @wordlist_loop:
001A05r 3                               ; A needs to have the current wordlist id in it at
001A05r 3                               ; the top of this loop.
001A05r 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001A07r 3               
001A07r 3                               ; Get the DP for that wordlist.
001A07r 3  0A                           asl                     ; Turn offset into cells offset.
001A08r 3  18                           clc
001A09r 3  69 06                        adc #wordlists_offset
001A0Br 3  A8                           tay
001A0Cr 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
001A0Er 3  85 rr                        sta tmp2                ; into tmp2
001A10r 3  C8                           iny
001A11r 3  B1 rr                        lda (up),y
001A13r 3  85 rr                        sta tmp2+1
001A15r 3               
001A15r 3                               ; Check for an empty wordlist (DP will be 0)
001A15r 3  A5 rr                        lda tmp2
001A17r 3  05 rr                        ora tmp2+1
001A19r 3  F0 38                        beq @next_wordlist
001A1Br 3               
001A1Br 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001A1Dr 3  85 rr                        sta tmp3        ; Save target xt in tmp3
001A1Fr 3  B5 03                        lda 3,x
001A21r 3  85 rr                        sta tmp3+1
001A23r 3               
001A23r 3               @loop:
001A23r 3  A0 04                        ldy #4          ; xt is four bytes down
001A25r 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
001A27r 3  C5 rr                        cmp tmp3
001A29r 3  D0 07                        bne @no_match
001A2Br 3               
001A2Br 3                               ; LSB is the same, now check MSB
001A2Br 3  C8                           iny
001A2Cr 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
001A2Er 3  C5 rr                        cmp tmp3+1
001A30r 3  F0 32                        beq @match
001A32r 3               
001A32r 3               @no_match:
001A32r 3                               ; no match, so we need to get the next word. Next nt is two
001A32r 3                               ; bytes down
001A32r 3  18                           clc
001A33r 3  A5 rr                        lda tmp2
001A35r 3  69 02                        adc #2
001A37r 3  85 rr                        sta tmp2
001A39r 3  A5 rr                        lda tmp2+1
001A3Br 3  69 00                        adc #0          ; only care about carry
001A3Dr 3  85 rr                        sta tmp2+1
001A3Fr 3               
001A3Fr 3  A0 00                        ldy #0
001A41r 3  B1 rr                        lda (tmp2),y
001A43r 3  48                           pha
001A44r 3  C8                           iny
001A45r 3  11 rr                        ora (tmp2),y
001A47r 3  F0 09                        beq @zero
001A49r 3               
001A49r 3                               ; Not zero continue
001A49r 3  B1 rr                        lda (tmp2),y
001A4Br 3  85 rr                        sta tmp2+1
001A4Dr 3  68                           pla
001A4Er 3  85 rr                        sta tmp2
001A50r 3  80 D1                        bra @loop
001A52r 3               
001A52r 3               @zero:
001A52r 3                               ; if next word is zero, the xt has no nt in this wordlist
001A52r 3  68                           pla             ; Leftover from above loop
001A53r 3               
001A53r 3               @next_wordlist:
001A53r 3                               ; Move on to the next wordlist.
001A53r 3  B5 00                        lda 0,x
001A55r 3  1A                           inc
001A56r 3  95 00                        sta 0,x
001A58r 3  C9 0C                        cmp #max_wordlists
001A5Ar 3  D0 A9                        bne @wordlist_loop
001A5Cr 3               
001A5Cr 3                               ; We didn't find it in any of the wordlists.
001A5Cr 3                               ; Remove the wordlist id from the stack.
001A5Cr 3  E8                           inx
001A5Dr 3  E8                           inx
001A5Er 3               
001A5Er 3                               ; We return a zero to indicate that we didn't find it.
001A5Er 3  74 00                        stz 0,x
001A60r 3  74 01                        stz 1,x
001A62r 3  80 0A                        bra z_int_to_name
001A64r 3               
001A64r 3               @match:
001A64r 3                               ; We found it. Remove wordlist id from stack.
001A64r 3  E8                           inx
001A65r 3  E8                           inx
001A66r 3               
001A66r 3                               ; It's a match! Replace TOS with nt
001A66r 3  A5 rr                        lda tmp2
001A68r 3  95 00                        sta 0,x
001A6Ar 3  A5 rr                        lda tmp2+1
001A6Cr 3  95 01                        sta 1,x
001A6Er 3               
001A6Er 3  60           z_int_to_name:  rts
001A6Fr 3               
001A6Fr 3               
001A6Fr 3               
001A6Fr 3               ; ## INVERT ( n -- n ) "Complement of TOS"
001A6Fr 3               ; ## "invert"  auto  ANS core
001A6Fr 3                       ; """https://forth-standard.org/standard/core/INVERT"""
001A6Fr 3               xt_invert:
001A6Fr 3  20 rr rr                     jsr underflow_1
001A72r 3               
001A72r 3  A9 FF                        lda #$FF
001A74r 3  55 00                        eor 0,x         ; LSB
001A76r 3  95 00                        sta 0,x
001A78r 3               
001A78r 3  A9 FF                        lda #$FF
001A7Ar 3  55 01                        eor 1,x         ; MSB
001A7Cr 3  95 01                        sta 1,x
001A7Er 3               
001A7Er 3  60           z_invert:       rts
001A7Fr 3               
001A7Fr 3               
001A7Fr 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
001A7Fr 3               ; ## "is"  auto  ANS core ext
001A7Fr 3                       ; """http://forth-standard.org/standard/core/IS"""
001A7Fr 3               
001A7Fr 3               xt_is:
001A7Fr 3                               ; This is a state aware word with differet behavior
001A7Fr 3                               ; when used while compiling vs interpreting.
001A7Fr 3                               ; Check STATE
001A7Fr 3  A5 rr                        lda state
001A81r 3  05 rr                        ora state+1
001A83r 3  F0 0C                        beq @interpreting
001A85r 3               
001A85r 3               @compiling:
001A85r 3                               ; Run ['] to compile the xt of the next word as a literal.
001A85r 3  20 rr rr                     jsr xt_bracket_tick
001A88r 3               
001A88r 3                               ; Postpone DEFER! by compiling a JSR to it.
001A88r 3  A0 rr                        ldy #>xt_defer_store
001A8Ar 3  A9 rr                        lda #<xt_defer_store
001A8Cr 3  20 rr rr                     jsr cmpl_subroutine
001A8Fr 3               
001A8Fr 3  80 06                        bra @done
001A91r 3               
001A91r 3               @interpreting:
001A91r 3  20 rr rr                     jsr xt_tick
001A94r 3  20 rr rr                     jsr xt_defer_store
001A97r 3               @done:
001A97r 3  60           z_is:           rts
001A98r 3               
001A98r 3               
001A98r 3               
001A98r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001A98r 3               ; ## "j"  auto  ANS core
001A98r 3                       ; """https://forth-standard.org/standard/core/J
001A98r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001A98r 3                       ; a fudge factor for loop control; see the Control Flow section of
001A98r 3                       ; the manual for more details.
001A98r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001A98r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001A98r 3                       ; implementation would just have two.
001A98r 3                       ;
001A98r 3                       ; Make this native compiled for speed
001A98r 3                       ; """
001A98r 3               
001A98r 3               xt_j:
001A98r 3  CA                           dex
001A99r 3  CA                           dex
001A9Ar 3               
001A9Ar 3                               ; Get the fudged index off from the stack. It's easier to
001A9Ar 3                               ; do math on the stack directly than to pop and push stuff
001A9Ar 3                               ; around
001A9Ar 3  86 rr                        stx tmpdsp
001A9Cr 3  BA                           tsx
001A9Dr 3               
001A9Dr 3  38                           sec
001A9Er 3  BD 07 01                     lda $0107,x     ; LSB
001AA1r 3  FD 09 01                     sbc $0109,x
001AA4r 3  A8                           tay
001AA5r 3               
001AA5r 3  BD 08 01                     lda $0108,x     ; MSB
001AA8r 3  FD 0A 01                     sbc $010A,x
001AABr 3               
001AABr 3  A6 rr                        ldx tmpdsp
001AADr 3               
001AADr 3  95 01                        sta 1,x         ; MSB of de-fudged index
001AAFr 3  94 00                        sty 0,x         ; LSB of de-fudged index
001AB1r 3               
001AB1r 3  60           z_j:            rts
001AB2r 3               
001AB2r 3               
001AB2r 3               
001AB2r 3               ; ## KEY ( -- char ) "Get one character from the input"
001AB2r 3               ; ## "key"  tested  ANS core
001AB2r 3               xt_key:
001AB2r 3                       ; """https://forth-standard.org/standard/core/KEY
001AB2r 3                       ; Get a single character of input from the vectored
001AB2r 3                       ; input without echoing.
001AB2r 3                       ; """
001AB2r 3  20 rr rr                     jsr key_a               ; returns char in A
001AB5r 3               
001AB5r 3  CA                           dex
001AB6r 3  CA                           dex
001AB7r 3  95 00                        sta 0,x
001AB9r 3  74 01                        stz 1,x
001ABBr 3               
001ABBr 3  60           z_key:          rts
001ABCr 3               
001ABCr 3               key_a:
001ABCr 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001ABCr 3                       ; 65816, so we have to fake the indirect jump to vector it.
001ABCr 3                       ; This is depressingly slow. We use this routine internally
001ABCr 3                       ; to avoid manipulating the Data Stack when we just want a
001ABCr 3                       ; character
001ABCr 3  6C rr rr                     jmp (input)             ; JSR/RTS
001ABFr 3               
001ABFr 3               
001ABFr 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
001ABFr 3               ; ## "latestnt"  auto  Tali Forth
001ABFr 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001ABFr 3                       ; The Gforth version of this word is called LATEST
001ABFr 3                       ; """
001ABFr 3               xt_latestnt:
001ABFr 3  CA                           dex
001AC0r 3  CA                           dex
001AC1r 3               
001AC1r 3  20 rr rr                     jsr current_to_dp
001AC4r 3               
001AC4r 3  A5 rr                        lda dp
001AC6r 3  95 00                        sta 0,x
001AC8r 3  A5 rr                        lda dp+1
001ACAr 3  95 01                        sta 1,x
001ACCr 3               
001ACCr 3  60           z_latestnt:     rts
001ACDr 3               
001ACDr 3               
001ACDr 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001ACDr 3               ; ## "latestxt"  auto  Gforth
001ACDr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001ACDr 3               xt_latestxt:
001ACDr 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
001AD0r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
001AD3r 3               
001AD3r 3  60           z_latestxt:     rts
001AD4r 3               
001AD4r 3               
001AD4r 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
001AD4r 3               ; ## "leave"  auto  ANS core
001AD4r 3                       ; """https://forth-standard.org/standard/core/LEAVE
001AD4r 3                       ; Note that this does not work with anything but a DO/LOOP in
001AD4r 3                       ; contrast to other versions such as discussed at
001AD4r 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
001AD4r 3                       ;
001AD4r 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
001AD4r 3                       ; See the Control Flow section in the manual for details of how this works.
001AD4r 3                       ; This must be native compile and not IMMEDIATE
001AD4r 3                       ; """
001AD4r 3               
001AD4r 3               xt_leave:
001AD4r 3                               ; We dump the limit/start entries off the Return Stack
001AD4r 3                               ; (four bytes)
001AD4r 3  68                           pla
001AD5r 3  68                           pla
001AD6r 3  68                           pla
001AD7r 3  68                           pla
001AD8r 3               
001AD8r 3  60                           rts             ; this must be compiled, so keep before z_leave
001AD9r 3               z_leave:                        ; not reached, not compiled
001AD9r 3               
001AD9r 3               
001AD9r 3               
001AD9r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001AD9r 3               ; ## "["  auto  ANS core
001AD9r 3                       ; """https://forth-standard.org/standard/core/Bracket
001AD9r 3                       ; This is an immediate and compile-only word
001AD9r 3                       ; """
001AD9r 3               xt_left_bracket:
001AD9r 3  64 rr                        stz state
001ADBr 3  64 rr                        stz state+1
001ADDr 3               
001ADDr 3  60           z_left_bracket: rts
001ADEr 3               
001ADEr 3               
001ADEr 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
001ADEr 3               ; ## "<#"  auto  ANS core
001ADEr 3                       ; """https://forth-standard.org/standard/core/num-start
001ADEr 3                       ; Start the process to create pictured numeric output.
001ADEr 3                       ;
001ADEr 3                       ; The new
001ADEr 3                       ; string is constructed from back to front, saving the new character
001ADEr 3                       ; at the beginning of the output string. Since we use PAD as a
001ADEr 3                       ; starting address and work backward (!), the string is constructed
001ADEr 3                       ; in the space between the end of the Dictionary (as defined by CP)
001ADEr 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
001ADEr 3                       ; programs don't fool around with the PAD but still use its address.
001ADEr 3                       ; Based on pForth
001ADEr 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001ADEr 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
001ADEr 3                       ; internal variable tohold instead of HLD.
001ADEr 3                       ; """
001ADEr 3               xt_less_number_sign:
001ADEr 3  20 rr rr                     jsr xt_pad      ; ( addr )
001AE1r 3               
001AE1r 3  B5 00                        lda 0,x
001AE3r 3  85 rr                        sta tohold
001AE5r 3  B5 01                        lda 1,x
001AE7r 3  85 rr                        sta tohold+1
001AE9r 3               
001AE9r 3  E8                           inx
001AEAr 3  E8                           inx
001AEBr 3               
001AEBr 3               z_less_number_sign:
001AEBr 3  60                           rts
001AECr 3               
001AECr 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001AECr 3               ; ## "<"  auto  ANS core
001AECr 3                       ; """https://forth-standard.org/standard/core/less"""
001AECr 3               
001AECr 3               xt_less_than:
001AECr 3  20 rr rr                     jsr underflow_2
001AEFr 3               
001AEFr 3  A0 00                        ldy #0          ; default false
001AF1r 3  20 rr rr                     jsr compare_16bit
001AF4r 3               
001AF4r 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
001AF4r 3  F0 03                        beq @false
001AF6r 3  30 01                        bmi @false
001AF8r 3               
001AF8r 3                               ; true
001AF8r 3  88                           dey
001AF9r 3               @false:
001AF9r 3  98                           tya
001AFAr 3               
001AFAr 3  E8                           inx
001AFBr 3  E8                           inx
001AFCr 3  95 00                        sta 0,x
001AFEr 3  95 01                        sta 1,x
001B00r 3               
001B00r 3  60           z_less_than:    rts
001B01r 3               
001B01r 3               
001B01r 3               
001B01r 3               ; ## LIST ( scr# -- ) "List the given screen"
001B01r 3               ; ## "list"  tested  ANS block ext
001B01r 3                       ; """https://forth-standard.org/standard/block/LIST"""
001B01r 3               
001B01r 3               xt_list:
001B01r 3  20 rr rr                     jsr underflow_1
001B04r 3               
001B04r 3                               ; Save the screen number in SCR
001B04r 3  20 rr rr                     jsr xt_scr
001B07r 3  20 rr rr                     jsr xt_store
001B0Ar 3               
001B0Ar 3                               ; Use L from the editor-wordlist to display the screen.
001B0Ar 3  20 rr rr                     jsr xt_editor_l
001B0Dr 3               
001B0Dr 3  60           z_list:         rts
001B0Er 3               
001B0Er 3               
001B0Er 3               
001B0Er 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001B0Er 3               ; ## "literal"  auto  ANS core
001B0Er 3                       ; """https://forth-standard.org/standard/core/LITERAL
001B0Er 3                       ; Compile-only word to store TOS so that it is pushed on stack
001B0Er 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001B0Er 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001B0Er 3                       ;
001B0Er 3                       ; Note the cmpl_ routines use TMPTOS
001B0Er 3                       ; """
001B0Er 3               xt_literal:
001B0Er 3  20 rr rr                     jsr underflow_1
001B11r 3               
001B11r 3  A0 rr                        ldy #>literal_runtime
001B13r 3  A9 rr                        lda #<literal_runtime
001B15r 3  20 rr rr                     jsr cmpl_subroutine
001B18r 3               
001B18r 3                               ; Compile the value that is to be pushed on the Stack during
001B18r 3                               ; runtime
001B18r 3  20 rr rr                     jsr xt_comma
001B1Br 3               
001B1Br 3  60           z_literal:      rts
001B1Cr 3               
001B1Cr 3               literal_runtime:
001B1Cr 3               
001B1Cr 3                               ; During runtime, we push the value following this word back
001B1Cr 3                               ; on the Data Stack. The subroutine jump that brought us
001B1Cr 3                               ; here put the address to return to on the Return Stack -
001B1Cr 3                               ; this points to the data we need to get. This routine is
001B1Cr 3                               ; also called (LITERAL) in some Forths
001B1Cr 3  CA                           dex
001B1Dr 3  CA                           dex
001B1Er 3               
001B1Er 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001B1Er 3                               ; so we are actually popping the address-1 of the literal
001B1Er 3  68                           pla             ; LSB
001B1Fr 3  85 rr                        sta tmp1
001B21r 3  68                           pla             ; MSB
001B22r 3  85 rr                        sta tmp1+1
001B24r 3               
001B24r 3                               ; Fetch the actual literal value and push it on Data stack
001B24r 3  A0 01                        ldy #1
001B26r 3  B1 rr                        lda (tmp1),y    ; LSB
001B28r 3  95 00                        sta 0,x
001B2Ar 3  C8                           iny
001B2Br 3  B1 rr                        lda (tmp1),y    ; MSB
001B2Dr 3  95 01                        sta 1,x
001B2Fr 3               
001B2Fr 3                               ; Adjust return address and push back on the Return Stack
001B2Fr 3  98                           tya
001B30r 3  18                           clc
001B31r 3  65 rr                        adc tmp1
001B33r 3  A8                           tay
001B34r 3  A5 rr                        lda tmp1+1
001B36r 3  69 00                        adc #0
001B38r 3  48                           pha
001B39r 3  5A                           phy
001B3Ar 3               
001B3Ar 3  60                           rts
001B3Br 3               
001B3Br 3               
001B3Br 3               
001B3Br 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
001B3Br 3               ; ## "load"  auto  ANS block
001B3Br 3                       ; """https://forth-standard.org/standard/block/LOAD
001B3Br 3                       ;
001B3Br 3                       ; Note: LOAD current works because there is only one buffer.
001B3Br 3                       ; If/when multiple buffers are supported, we'll have to deal
001B3Br 3                       ; with the fact that it might re-load the old block into a
001B3Br 3                       ; different buffer.
001B3Br 3                       ; """
001B3Br 3               
001B3Br 3               xt_load:
001B3Br 3  20 rr rr                     jsr underflow_1
001B3Er 3               
001B3Er 3                               ; Save the current value of BLK on the return stack.
001B3Er 3  A0 01                        ldy #blk_offset+1
001B40r 3  B1 rr                        lda (up),y
001B42r 3  48                           pha
001B43r 3  88                           dey
001B44r 3  B1 rr                        lda (up),y
001B46r 3  48                           pha
001B47r 3               
001B47r 3                               ; Set BLK to the given block/screen number.
001B47r 3  B5 00                        lda 0,x
001B49r 3  91 rr                        sta (up),y
001B4Br 3  C8                           iny
001B4Cr 3  B5 01                        lda 1,x
001B4Er 3  91 rr                        sta (up),y
001B50r 3               
001B50r 3                               ; Load that block into a buffer
001B50r 3  20 rr rr                     jsr xt_block
001B53r 3               
001B53r 3                               ; Put 1024 on the stack for the screen length.
001B53r 3  CA                           dex
001B54r 3  CA                           dex
001B55r 3  A9 04                        lda #4
001B57r 3  95 01                        sta 1,x
001B59r 3  74 00                        stz 0,x
001B5Br 3               
001B5Br 3                               ; Jump to a special evluate target. This bypasses the underflow
001B5Br 3                               ; check and skips the zeroing of BLK.
001B5Br 3  20 rr rr                     jsr load_evaluate
001B5Er 3               
001B5Er 3                               ; Restore the value of BLK from before the LOAD command.
001B5Er 3  A0 00                        ldy #blk_offset
001B60r 3  68                           pla
001B61r 3  91 rr                        sta (up),y
001B63r 3  C8                           iny
001B64r 3  68                           pla
001B65r 3  91 rr                        sta (up),y
001B67r 3               
001B67r 3                               ; If BLK is not zero, read it back into the buffer.
001B67r 3                               ; A still has MSB
001B67r 3  88                           dey
001B68r 3  11 rr                        ora (up),y
001B6Ar 3  F0 12                        beq @done
001B6Cr 3               
001B6Cr 3                               ; The block needs to be read back into the buffer.
001B6Cr 3  CA                           dex
001B6Dr 3  CA                           dex
001B6Er 3  A0 00                        ldy #blk_offset
001B70r 3  B1 rr                        lda (up),y
001B72r 3  95 00                        sta 0,x
001B74r 3  C8                           iny
001B75r 3  B1 rr                        lda (up),y
001B77r 3  95 01                        sta 1,x
001B79r 3  20 rr rr                     jsr xt_block
001B7Cr 3               
001B7Cr 3                               ; Drop the buffer address.
001B7Cr 3  E8                           inx
001B7Dr 3  E8                           inx
001B7Er 3               
001B7Er 3               @done:
001B7Er 3  60           z_load:         rts
001B7Fr 3               
001B7Fr 3               
001B7Fr 3               
001B7Fr 3               ; ## LOOP ( -- ) "Finish loop construct"
001B7Fr 3               ; ## "loop"  auto  ANS core
001B7Fr 3                       ; """https://forth-standard.org/standard/core/LOOP
001B7Fr 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
001B7Fr 3                       ; the stack and then call +LOOP.
001B7Fr 3                       ;
001B7Fr 3                       ; In Forth, this is
001B7Fr 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
001B7Fr 3                       ;       IMMEDIATE ; COMPILE-ONLY
001B7Fr 3                       ; """
001B7Fr 3               xt_loop:
001B7Fr 3                               ; Have the finished word push 1 on the stack
001B7Fr 3  A0 rr                        ldy #>xt_one
001B81r 3  A9 rr                        lda #<xt_one
001B83r 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
001B86r 3               
001B86r 3               
001B86r 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
001B86r 3               ; ## "+loop"  auto  ANS core
001B86r 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
001B86r 3                       ;
001B86r 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
001B86r 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
001B86r 3                       ;       COMPILE-ONLY
001B86r 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
001B86r 3                       ; address for looping as TOS and the address for aborting the loop
001B86r 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
001B86r 3                       ; DO and the Control Flow section of the manual for details).
001B86r 3                       ; """
001B86r 3               
001B86r 3               xt_plus_loop:
001B86r 3                               ; Compile the run-time part. We do this with a short loop
001B86r 3                               ; and not a call to COMPILE, because it has to be natively
001B86r 3                               ; coded anyway.
001B86r 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
001B88r 3  5A                           phy             ; save counter to adjust CP
001B89r 3               @1:
001B89r 3  B9 rr rr                     lda plus_loop_runtime,y
001B8Cr 3  91 rr                        sta (cp),y
001B8Er 3  88                           dey
001B8Fr 3  10 F8                        bpl @1
001B91r 3               
001B91r 3                               ; Adjust CP
001B91r 3  68                           pla
001B92r 3  18                           clc
001B93r 3  65 rr                        adc cp
001B95r 3  85 rr                        sta cp
001B97r 3  A5 rr                        lda cp+1
001B99r 3  69 00                        adc #0          ; only need carry
001B9Br 3  85 rr                        sta cp+1
001B9Dr 3               
001B9Dr 3                               ; The address we need to loop back to is TOS. Store it so
001B9Dr 3                               ; the runtime part of +LOOP jumps back up there
001B9Dr 3  20 rr rr                     jsr xt_comma
001BA0r 3               
001BA0r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001BA0r 3                               ; of six PLA, so we just do it here instead jumping around
001BA0r 3                               ; all over the place
001BA0r 3  A9 68                        lda #$68                ; opcode for PLA
001BA2r 3  A0 06                        ldy #6
001BA4r 3               @2:
001BA4r 3  91 rr                        sta (cp),y
001BA6r 3  88                           dey
001BA7r 3  10 FB                        bpl @2
001BA9r 3               
001BA9r 3                               ; Adjust CP
001BA9r 3  A9 06                        lda #6
001BABr 3  18                           clc
001BACr 3  65 rr                        adc cp
001BAEr 3  85 rr                        sta cp
001BB0r 3  A5 rr                        lda cp+1
001BB2r 3  69 00                        adc #0                  ; only need carry
001BB4r 3  85 rr                        sta cp+1
001BB6r 3               
001BB6r 3                               ; Complete compile of DO/?DO by replacing the six
001BB6r 3                               ; dummy bytes by PHA instructions. The address where
001BB6r 3                               ; they are located is on the Data Stack
001BB6r 3  B5 00                        lda 0,x
001BB8r 3  85 rr                        sta tmp1
001BBAr 3  B5 01                        lda 1,x
001BBCr 3  85 rr                        sta tmp1+1
001BBEr 3  E8                           inx
001BBFr 3  E8                           inx
001BC0r 3               
001BC0r 3                               ; Because of the way that CP works, we don't have to save
001BC0r 3                               ; CP, but CP-1
001BC0r 3  A5 rr                        lda cp
001BC2r 3  38                           sec
001BC3r 3  E9 01                        sbc #1
001BC5r 3  85 rr                        sta tmp2
001BC7r 3  A5 rr                        lda cp+1
001BC9r 3  E9 00                        sbc #0
001BCBr 3  85 rr                        sta tmp2+1
001BCDr 3               
001BCDr 3                               ; now compile this in the DO/?DO routine
001BCDr 3  A0 00                        ldy #0
001BCFr 3               
001BCFr 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001BD1r 3  91 rr                        sta (tmp1),y
001BD3r 3  C8                           iny
001BD4r 3  A5 rr                        lda tmp2+1      ; MSB
001BD6r 3  91 rr                        sta (tmp1),y
001BD8r 3  C8                           iny
001BD9r 3  A9 48                        lda #$48        ; Opcode for PHA
001BDBr 3  91 rr                        sta (tmp1),y
001BDDr 3  C8                           iny
001BDEr 3               
001BDEr 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001BE0r 3  91 rr                        sta (tmp1),y
001BE2r 3  C8                           iny
001BE3r 3  A5 rr                        lda tmp2        ; LSB
001BE5r 3  91 rr                        sta (tmp1),y
001BE7r 3  C8                           iny
001BE8r 3  A9 48                        lda #$48        ; Opcode for PHA
001BEAr 3  91 rr                        sta (tmp1),y
001BECr 3               z_loop:
001BECr 3  60           z_plus_loop:    rts
001BEDr 3               
001BEDr 3               
001BEDr 3               plus_loop_runtime:
001BEDr 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001BEDr 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001BEDr 3                       ; loop control so we can test with the Overflow Flag. See
001BEDr 3                       ; the Control Flow section of the manual for details.
001BEDr 3                       ; The step value is TOS in the loop. This
001BEDr 3                       ; must always be native compiled. In some Forths, this is a separate
001BEDr 3                       ; word called (+LOOP) or (LOOP)
001BEDr 3                       ; """
001BEDr 3               
001BEDr 3  18                           clc
001BEEr 3  68                           pla             ; LSB of index
001BEFr 3  75 00                        adc 0,x         ; LSB of step
001BF1r 3  A8                           tay             ; temporary storage of LSB
001BF2r 3               
001BF2r 3  B8                           clv
001BF3r 3  68                           pla             ; MSB of index
001BF4r 3  75 01                        adc 1,x         ; MSB of step
001BF6r 3  48                           pha             ; put MSB of index back on stack
001BF7r 3               
001BF7r 3  98                           tya             ; put LSB of index back on stack
001BF8r 3  48                           pha
001BF9r 3               
001BF9r 3  E8                           inx             ; dump step from TOS
001BFAr 3  E8                           inx
001BFBr 3               
001BFBr 3                               ; If V flag is set, we're done looping and continue
001BFBr 3                               ; after the +LOOP instruction
001BFBr 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001BFDr 3               
001BFDr 3               @hack:          ; This is why this routine must be natively compiled: We
001BFDr 3                               ; compile the opcode for JMP here without an address to
001BFDr 3                               ; go to, which is added by the next next instruction of
001BFDr 3                               ; LOOP/+LOOP during compile time
001BFDr 3  4C                           .byte $4C
001BFEr 3               
001BFEr 3               plus_loop_runtime_end:
001BFEr 3               
001BFEr 3               
001BFEr 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001BFEr 3               ; ## "lshift"  auto  ANS core
001BFEr 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001BFEr 3               
001BFEr 3               xt_lshift:
001BFEr 3  20 rr rr                     jsr underflow_2
001C01r 3               
001C01r 3                               ; max shift 16 times
001C01r 3  B5 00                        lda 0,x
001C03r 3  29 0F                        and #%00001111
001C05r 3  F0 08                        beq @done
001C07r 3               
001C07r 3  A8                           tay
001C08r 3               
001C08r 3               @loop:
001C08r 3  16 02                        asl 2,x
001C0Ar 3  36 03                        rol 3,x
001C0Cr 3  88                           dey
001C0Dr 3  D0 F9                        bne @loop
001C0Fr 3               
001C0Fr 3               @done:
001C0Fr 3  E8                           inx
001C10r 3  E8                           inx
001C11r 3               
001C11r 3  60           z_lshift:       rts
001C12r 3               
001C12r 3               
001C12r 3               
001C12r 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
001C12r 3               ; ## "m*"  auto  ANS core
001C12r 3                       ; """https://forth-standard.org/standard/core/MTimes
001C12r 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
001C12r 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
001C12r 3                       ;
001C12r 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
001C12r 3                       ; with  : D+- O< IF DNEGATE THEN ;
001C12r 3                       ; """
001C12r 3               
001C12r 3               xt_m_star:
001C12r 3  20 rr rr                     jsr underflow_2
001C15r 3               
001C15r 3                               ; figure out the sign
001C15r 3  B5 01                        lda 1,x         ; MSB of n1
001C17r 3  55 03                        eor 3,x         ; MSB of n2
001C19r 3               
001C19r 3                               ; UM* uses all kinds of temporary variables so we don't
001C19r 3                               ; risk a conflict but just take the cycle hit and push
001C19r 3                               ; this to the stack
001C19r 3  48                           pha
001C1Ar 3               
001C1Ar 3                               ; get the absolute value of both numbers so we can feed
001C1Ar 3                               ; them to UM*, which does the real work
001C1Ar 3  20 rr rr                     jsr xt_abs
001C1Dr 3  20 rr rr                     jsr xt_swap
001C20r 3  20 rr rr                     jsr xt_abs
001C23r 3               
001C23r 3  20 rr rr                     jsr xt_um_star          ; ( d )
001C26r 3               
001C26r 3                               ; handle the sign
001C26r 3  68                           pla
001C27r 3  10 03                        bpl @done
001C29r 3               
001C29r 3  20 rr rr                     jsr xt_dnegate
001C2Cr 3               @done:
001C2Cr 3  60           z_m_star:       rts
001C2Dr 3               
001C2Dr 3               
001C2Dr 3               
001C2Dr 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001C2Dr 3               ; ## "marker"  auto  ANS core ext
001C2Dr 3                       ; """https://forth-standard.org/standard/core/MARKER
001C2Dr 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001C2Dr 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001C2Dr 3                       ; Run the named word at a later time to restore all of the wordlists
001C2Dr 3                       ; to their state when the word was created with marker.  Any words
001C2Dr 3                       ; created after the marker (including the marker) will be forgotten.
001C2Dr 3                       ;
001C2Dr 3                       ; To do this, we want to end up with something that jumps to a
001C2Dr 3                       ; run-time component with a link to the original CP and DP values:
001C2Dr 3                       ;
001C2Dr 3                       ;       jsr marker_runtime
001C2Dr 3                       ;       <Original CP MSB>
001C2Dr 3                       ;       <Original CP LSB>
001C2Dr 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001C2Dr 3                       ;       <Original DP LSB>
001C2Dr 3                       ;       < USER variables from offset 4 to 39 >
001C2Dr 3                       ;
001C2Dr 3                       ;       The user variables include:
001C2Dr 3                       ;       CURRENT (byte variable)
001C2Dr 3                       ;       <All wordlists> (currently 12) (cell array)
001C2Dr 3                       ;       <#ORDER> (byte variable)
001C2Dr 3                       ;       <All search order> (currently 9) (byte array)
001C2Dr 3                       ;
001C2Dr 3                       ; This code uses tmp1 and tmp2
001C2Dr 3                       ; """
001C2Dr 3               
001C2Dr 3               xt_marker:
001C2Dr 3                               ; Before we do anything, we need to save CP, which
001C2Dr 3                               ; after all is the whole point of this operation. CREATE
001C2Dr 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001C2Dr 3                               ; to the stack
001C2Dr 3  20 rr rr                     jsr current_to_dp
001C30r 3               
001C30r 3  A5 rr                        lda dp
001C32r 3  48                           pha
001C33r 3  A5 rr                        lda dp+1
001C35r 3  48                           pha
001C36r 3               
001C36r 3  A5 rr                        lda cp
001C38r 3  48                           pha
001C39r 3  A5 rr                        lda cp+1
001C3Br 3  48                           pha
001C3Cr 3               
001C3Cr 3  20 rr rr                     jsr xt_create
001C3Fr 3               
001C3Fr 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
001C3Fr 3                               ; we have to replace by a jump to marker_runtime. We back up
001C3Fr 3                               ; two bytes and then overwrite the address
001C3Fr 3  A5 rr                        lda cp          ; LSB
001C41r 3  38                           sec
001C42r 3  E9 02                        sbc #2
001C44r 3  85 rr                        sta cp
001C46r 3               
001C46r 3  A5 rr                        lda cp+1        ; MSB
001C48r 3  E9 00                        sbc #0          ; we only care about the borrow
001C4Ar 3  85 rr                        sta cp+1
001C4Cr 3               
001C4Cr 3                               ; Add the address of the runtime component
001C4Cr 3  A0 rr                        ldy #>marker_runtime
001C4Er 3  A9 rr                        lda #<marker_runtime
001C50r 3  20 rr rr                     jsr cmpl_word
001C53r 3               
001C53r 3                               ; Add original CP as payload
001C53r 3  7A                           ply                     ; MSB
001C54r 3  68                           pla                     ; LSB
001C55r 3  20 rr rr                     jsr cmpl_word
001C58r 3               
001C58r 3                               ; Add original DP as payload
001C58r 3  7A                           ply                     ; MSB
001C59r 3  68                           pla                     ; LSB
001C5Ar 3  20 rr rr                     jsr cmpl_word
001C5Dr 3               
001C5Dr 3                               ; Add the user variables for the wordlists and search order.
001C5Dr 3                               ; We're compiling them in byte order.
001C5Dr 3  A0 04                        ldy #4                  ; Start at CURRENT
001C5Fr 3               @marker_loop:
001C5Fr 3  B1 rr                        lda (up),y
001C61r 3  20 rr rr                     jsr cmpl_a
001C64r 3  C8                           iny
001C65r 3  98                           tya
001C66r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001C68r 3  D0 F5                        bne @marker_loop
001C6Ar 3               
001C6Ar 3  60           z_marker:       rts
001C6Br 3               
001C6Br 3               
001C6Br 3               
001C6Br 3               marker_runtime:
001C6Br 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
001C6Br 3                       ; when this marker was defined. We arrive here with the return
001C6Br 3                       ; address on the Return Stack in the usual 65c02 format
001C6Br 3                       ; """
001C6Br 3               
001C6Br 3                               ; Get the address of the string address off the stack and
001C6Br 3                               ; increase by one because of the RTS mechanics
001C6Br 3  68                           pla
001C6Cr 3  85 rr                        sta tmp1        ; LSB of address
001C6Er 3  68                           pla
001C6Fr 3  85 rr                        sta tmp1+1      ; MSB of address
001C71r 3               
001C71r 3  E6 rr                        inc tmp1
001C73r 3  D0 02                        bne @1
001C75r 3  E6 rr                        inc tmp1+1
001C77r 3               @1:
001C77r 3  A0 00                        ldy #0
001C79r 3               
001C79r 3                               ; CP was stored first
001C79r 3  B1 rr                        lda (tmp1),y
001C7Br 3  85 rr                        sta cp
001C7Dr 3  C8                           iny
001C7Er 3  B1 rr                        lda (tmp1),y
001C80r 3  85 rr                        sta cp+1
001C82r 3               
001C82r 3                               ; Next was DP
001C82r 3  C8                           iny
001C83r 3  B1 rr                        lda (tmp1),y
001C85r 3  85 rr                        sta dp
001C87r 3  C8                           iny
001C88r 3  B1 rr                        lda (tmp1),y
001C8Ar 3  85 rr                        sta dp+1
001C8Cr 3               
001C8Cr 3                               ; Conveniently, the offset into both tmp1 and UP is 4
001C8Cr 3                               ; to start restoring the wordlists and search order.
001C8Cr 3  A0 04                        ldy #4
001C8Er 3               
001C8Er 3               @marker_restore_loop:
001C8Er 3                               ; Copy from the dictionary back on top of the wordlists
001C8Er 3                               ; and search order.
001C8Er 3  B1 rr                        lda (tmp1), y
001C90r 3  91 rr                        sta (up), y
001C92r 3  C8                           iny
001C93r 3  98                           tya
001C94r 3  C9 28                        cmp #40                 ; One past the end of the search order.
001C96r 3  D0 F6                        bne @marker_restore_loop
001C98r 3               
001C98r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001C9Br 3               
001C9Br 3                               ; The return instruction takes us back to the original caller
001C9Br 3  60                           rts
001C9Cr 3               
001C9Cr 3               
001C9Cr 3               
001C9Cr 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001C9Cr 3               ; ## "max"  auto  ANS core
001C9Cr 3                       ; """https://forth-standard.org/standard/core/MAX
001C9Cr 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001C9Cr 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001C9Cr 3                       ; Flag indicates which number is larger. See also
001C9Cr 3                       ; http://6502.org/tutorials/compare_instructions.html and
001C9Cr 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001C9Cr 3                       ; """
001C9Cr 3               
001C9Cr 3               xt_max:
001C9Cr 3  20 rr rr                     jsr underflow_2
001C9Fr 3               
001C9Fr 3                               ; Compare LSB. We do this first to set the carry flag
001C9Fr 3  B5 00                        lda 0,x         ; LSB of TOS
001CA1r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
001CA3r 3               
001CA3r 3  B5 01                        lda 1,x         ; MSB of TOS
001CA5r 3  F5 03                        sbc 3,x         ; MSB of NOS
001CA7r 3  50 02                        bvc @no_overflow
001CA9r 3               
001CA9r 3                               ; handle overflow, because we use signed numbers
001CA9r 3  49 80                        eor #$80        ; complement negative flag
001CABr 3               
001CABr 3               @no_overflow:
001CABr 3                               ; if negative, NOS is larger and needs to be kept
001CABr 3  30 08                        bmi @keep_nos
001CADr 3               
001CADr 3                               ; move TOS to NOS
001CADr 3  B5 00                        lda 0,x
001CAFr 3  95 02                        sta 2,x
001CB1r 3  B5 01                        lda 1,x
001CB3r 3  95 03                        sta 3,x
001CB5r 3               
001CB5r 3               @keep_nos:
001CB5r 3  E8                           inx
001CB6r 3  E8                           inx
001CB7r 3               
001CB7r 3  60           z_max:          rts
001CB8r 3               
001CB8r 3               
001CB8r 3               
001CB8r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001CB8r 3               ; ## "min"  auto  ANS core
001CB8r 3                       ; """https://forth-standard.org/standard/core/MIN
001CB8r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001CB8r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001CB8r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001CB8r 3                       ; """
001CB8r 3               
001CB8r 3               xt_min:
001CB8r 3  20 rr rr                     jsr underflow_2
001CBBr 3               
001CBBr 3                               ; compare LSB. We do this first to set the carry flag
001CBBr 3  B5 00                        lda 0,x         ; LSB of TOS
001CBDr 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001CBFr 3               
001CBFr 3  B5 01                        lda 1,x         ; MSB of TOS
001CC1r 3  F5 03                        sbc 3,x         ; MSB of NOS
001CC3r 3  50 02                        bvc @no_overflow
001CC5r 3               
001CC5r 3                               ; handle overflow because we use signed numbers
001CC5r 3  49 80                        eor #$80
001CC7r 3               
001CC7r 3               @no_overflow:
001CC7r 3                               ; if negative, NOS is larger and needs to be dumped
001CC7r 3  10 08                        bpl @keep_nos
001CC9r 3               
001CC9r 3                               ; move TOS to NOS
001CC9r 3  B5 00                        lda 0,x
001CCBr 3  95 02                        sta 2,x
001CCDr 3  B5 01                        lda 1,x
001CCFr 3  95 03                        sta 3,x
001CD1r 3               
001CD1r 3               @keep_nos:
001CD1r 3  E8                           inx
001CD2r 3  E8                           inx
001CD3r 3               
001CD3r 3  60           z_min:          rts
001CD4r 3               
001CD4r 3               
001CD4r 3               
001CD4r 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
001CD4r 3               ; ## "-"  auto  ANS core
001CD4r 3                       ; """https://forth-standard.org/standard/core/Minus"""
001CD4r 3               xt_minus:
001CD4r 3  20 rr rr                     jsr underflow_2
001CD7r 3               
001CD7r 3  38                           sec
001CD8r 3  B5 02                        lda 2,x         ; LSB
001CDAr 3  F5 00                        sbc 0,x
001CDCr 3  95 02                        sta 2,x
001CDEr 3               
001CDEr 3  B5 03                        lda 3,x         ; MSB
001CE0r 3  F5 01                        sbc 1,x
001CE2r 3  95 03                        sta 3,x
001CE4r 3               
001CE4r 3  E8                           inx
001CE5r 3  E8                           inx
001CE6r 3               
001CE6r 3  60           z_minus:        rts
001CE7r 3               
001CE7r 3               
001CE7r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001CE7r 3               ; ## "-leading"  auto  Tali String
001CE7r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001CE7r 3                       ; """
001CE7r 3               
001CE7r 3               xt_minus_leading:
001CE7r 3  20 rr rr                     jsr underflow_2
001CEAr 3               
001CEAr 3               @loop:
001CEAr 3                               ; Quit if we were given an empty string. This also terminates
001CEAr 3                               ; the main loop
001CEAr 3  B5 00                        lda 0,x
001CECr 3  15 01                        ora 1,x
001CEEr 3  F0 0F                        beq @done
001CF0r 3               
001CF0r 3  A1 02                        lda (2,x)               ; get first character
001CF2r 3  20 rr rr                     jsr is_whitespace
001CF5r 3  90 08                        bcc @done
001CF7r 3               
001CF7r 3                               ; It's whitespace, move one down
001CF7r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001CFAr 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001CFDr 3               
001CFDr 3  80 EB                        bra @loop
001CFFr 3               @done:
001CFFr 3               z_minus_leading:
001CFFr 3  60                           rts
001D00r 3               
001D00r 3               
001D00r 3               
001D00r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001D00r 3               ; ## "-trailing"  auto  ANS string
001D00r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001D00r 3                       ; Remove trailing spaces
001D00r 3                       ; """
001D00r 3               
001D00r 3               xt_minus_trailing:
001D00r 3  20 rr rr                     jsr underflow_2
001D03r 3               
001D03r 3                               ; if length entry is zero, return a zero and leave the
001D03r 3                               ; address part untouched
001D03r 3  B5 00                        lda 0,x         ; LSB of n
001D05r 3  15 01                        ora 1,x         ; MSB of n
001D07r 3  F0 33                        beq @done
001D09r 3               
001D09r 3                               ; Compute address of last char in tmp1 as
001D09r 3                               ; addr + u1 - 1
001D09r 3               
001D09r 3                               ; addr + u1
001D09r 3  18                           clc
001D0Ar 3  B5 02                        lda 2,x         ; LSB of addr
001D0Cr 3  75 00                        adc 0,x
001D0Er 3  85 rr                        sta tmp1
001D10r 3  B5 03                        lda 3,x         ; MSB of addr
001D12r 3  75 01                        adc 1,x
001D14r 3  85 rr                        sta tmp1+1
001D16r 3               
001D16r 3                               ; - 1
001D16r 3  A5 rr                        lda tmp1
001D18r 3  D0 02                        bne @1
001D1Ar 3  C6 rr                        dec tmp1+1
001D1Cr 3               @1:
001D1Cr 3  C6 rr                        dec tmp1
001D1Er 3               
001D1Er 3               @loop:
001D1Er 3                               ; While spaces are found, move tmp1 backwards and
001D1Er 3                               ; decrease the count on the data stack.
001D1Er 3  B2 rr                        lda (tmp1)
001D20r 3  C9 20                        cmp #AscSP
001D22r 3  D0 18                        bne @done
001D24r 3               
001D24r 3                               ; Move back one address.
001D24r 3  A5 rr                        lda tmp1
001D26r 3  D0 02                        bne @2
001D28r 3  C6 rr                        dec tmp1+1
001D2Ar 3               @2:
001D2Ar 3  C6 rr                        dec tmp1
001D2Cr 3               
001D2Cr 3                               ; Decrement count by one.
001D2Cr 3  B5 00                        lda 0,x
001D2Er 3  D0 02                        bne @3
001D30r 3  D6 01                        dec 1,x
001D32r 3               @3:
001D32r 3  D6 00                        dec 0,x
001D34r 3               
001D34r 3                               ; Check if there are any characters left.
001D34r 3  B5 00                        lda 0,x
001D36r 3  15 01                        ora 1,x
001D38r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
001D3Ar 3               
001D3Ar 3  80 E2                        bra @loop
001D3Cr 3               
001D3Cr 3               @done:
001D3Cr 3               z_minus_trailing:
001D3Cr 3  60                           rts
001D3Dr 3               
001D3Dr 3               
001D3Dr 3               
001D3Dr 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
001D3Dr 3               ; ## "mod"  auto  ANS core
001D3Dr 3                       ; """https://forth-standard.org/standard/core/MOD
001D3Dr 3                       ;
001D3Dr 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
001D3Dr 3                       ; so we just jump to xt_slash_mod and dump the actual result.
001D3Dr 3                       ; """
001D3Dr 3               xt_mod:
001D3Dr 3  20 rr rr                     jsr underflow_2
001D40r 3               
001D40r 3  20 rr rr                     jsr xt_slash_mod
001D43r 3               
001D43r 3  E8                           inx             ; DROP
001D44r 3  E8                           inx
001D45r 3               z_mod:
001D45r 3  60                           rts
001D46r 3               
001D46r 3               
001D46r 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
001D46r 3               ; ## "move"  auto  ANS core
001D46r 3                       ; """https://forth-standard.org/standard/core/MOVE
001D46r 3                       ; Copy u "address units" from addr1 to addr2. Since our address
001D46r 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
001D46r 3                       ; is actually the only one of these three words that is in the CORE
001D46r 3                       ; set.
001D46r 3                       ;
001D46r 3                       ; This word must not be natively compiled.
001D46r 3                       ; """
001D46r 3               
001D46r 3               xt_move:
001D46r 3                               ; We let CMOVE and CMOVE> check if there is underflow or
001D46r 3                               ; we've been told to copy zero bytes
001D46r 3               
001D46r 3                               ; compare MSB first
001D46r 3  B5 03                        lda 3,x                 ; MSB of addr2
001D48r 3  D5 05                        cmp 5,x                 ; MSB of addr1
001D4Ar 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
001D4Cr 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
001D4Er 3               
001D4Er 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001D51r 3               
001D51r 3               @lsb:
001D51r 3                               ; MSB were equal, so do the whole thing over with LSB
001D51r 3  B5 02                        lda 2,x                 ; LSB of addr2
001D53r 3  D5 04                        cmp 4,x                 ; LSB of addr1
001D55r 3  F0 08                        beq @equal              ; LSB is equal as well
001D57r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
001D59r 3               
001D59r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
001D5Cr 3               
001D5Cr 3               @to_move_up:
001D5Cr 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
001D5Fr 3               @equal:
001D5Fr 3                               ; drop three entries from Data Stack
001D5Fr 3  8A                           txa
001D60r 3  18                           clc
001D61r 3  69 06                        adc #6
001D63r 3  AA                           tax
001D64r 3               
001D64r 3  60           z_move:         rts
001D65r 3               
001D65r 3               
001D65r 3               
001D65r 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
001D65r 3               ; ## "name>int"  tested  Gforth
001D65r 3                       ; """See
001D65r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001D65r 3                       ; """
001D65r 3               
001D65r 3               xt_name_to_int:
001D65r 3  20 rr rr                     jsr underflow_1
001D68r 3               
001D68r 3                               ; The xt starts four bytes down from the nt
001D68r 3  B5 00                        lda 0,x
001D6Ar 3  18                           clc
001D6Br 3  69 04                        adc #4
001D6Dr 3  85 rr                        sta tmp3
001D6Fr 3               
001D6Fr 3  B5 01                        lda 1,x
001D71r 3  90 01                        bcc @done
001D73r 3  1A                           inc
001D74r 3               @done:
001D74r 3  85 rr                        sta tmp3+1
001D76r 3               
001D76r 3  A0 00                        ldy #0
001D78r 3  B1 rr                        lda (tmp3),y
001D7Ar 3  95 00                        sta 0,x
001D7Cr 3  C8                           iny
001D7Dr 3  B1 rr                        lda (tmp3),y
001D7Fr 3  95 01                        sta 1,x
001D81r 3               
001D81r 3  60           z_name_to_int:  rts
001D82r 3               
001D82r 3               
001D82r 3               
001D82r 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
001D82r 3               ; ## "name>string"  tested  Gforth
001D82r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
001D82r 3               
001D82r 3               xt_name_to_string:
001D82r 3  20 rr rr                     jsr underflow_1
001D85r 3               
001D85r 3  CA                           dex
001D86r 3  CA                           dex
001D87r 3               
001D87r 3                               ; the length of the string is the first byte of the
001D87r 3                               ; header pointed to by nt
001D87r 3  A1 02                        lda (2,x)
001D89r 3  95 00                        sta 0,x
001D8Br 3  74 01                        stz 1,x
001D8Dr 3               
001D8Dr 3                               ; the string itself always starts eight bytes down
001D8Dr 3  B5 02                        lda 2,x         ; LSB
001D8Fr 3  18                           clc
001D90r 3  69 08                        adc #8
001D92r 3  A8                           tay
001D93r 3  B5 03                        lda 3,x         ; MSB
001D95r 3  69 00                        adc #0          ; just need carry
001D97r 3  95 03                        sta 3,x
001D99r 3  94 02                        sty 2,x
001D9Br 3               
001D9Br 3               z_name_to_string:
001D9Br 3  60                           rts
001D9Cr 3               
001D9Cr 3               
001D9Cr 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001D9Cr 3               ; ## "nc-limit"  tested  Tali Forth
001D9Cr 3               
001D9Cr 3               xt_nc_limit:
001D9Cr 3  CA                           dex
001D9Dr 3  CA                           dex
001D9Er 3  A9 rr                        lda #<nc_limit
001DA0r 3  95 00                        sta 0,x
001DA2r 3  A9 rr                        lda #>nc_limit
001DA4r 3  95 01                        sta 1,x
001DA6r 3               
001DA6r 3  60           z_nc_limit:     rts
001DA7r 3               
001DA7r 3               
001DA7r 3               
001DA7r 3               ; ## NEGATE ( n -- n ) "Two's complement"
001DA7r 3               ; ## "negate"  auto  ANS core
001DA7r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001DA7r 3               xt_negate:
001DA7r 3  20 rr rr                     jsr underflow_1
001DAAr 3               
001DAAr 3  A9 00                	lda #0
001DACr 3  38                           sec
001DADr 3  F5 00                        sbc 0,x         ; LSB
001DAFr 3  95 00                        sta 0,x
001DB1r 3               
001DB1r 3  A9 00                        lda #0
001DB3r 3  F5 01                        sbc 1,x         ; MSB
001DB5r 3  95 01                        sta 1,x
001DB7r 3               
001DB7r 3  60           z_negate:       rts
001DB8r 3               
001DB8r 3               
001DB8r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001DB8r 3               ; ## "never-native"  auto  Tali Forth
001DB8r 3               xt_never_native:
001DB8r 3  20 rr rr                     jsr current_to_dp
001DBBr 3  A0 01                        ldy #1          ; offset for status byte
001DBDr 3  B1 rr                        lda (dp),y
001DBFr 3  09 08                        ora #NN         ; Make sure NN flag is set
001DC1r 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
001DC3r 3  91 rr                        sta (dp),y
001DC5r 3               z_never_native:
001DC5r 3  60                           rts
001DC6r 3               
001DC6r 3               
001DC6r 3               ; ## NIP ( b a -- a ) "Delete NOS"
001DC6r 3               ; ## "nip"  auto  ANS core ext
001DC6r 3                       ; """https://forth-standard.org/standard/core/NIP"""
001DC6r 3               xt_nip:
001DC6r 3  20 rr rr                     jsr underflow_2
001DC9r 3               
001DC9r 3  B5 00                        lda 0,x         ; LSB
001DCBr 3  95 02                        sta 2,x
001DCDr 3  B5 01                        lda 1,x         ; MSB
001DCFr 3  95 03                        sta 3,x
001DD1r 3               
001DD1r 3  E8                           inx
001DD2r 3  E8                           inx
001DD3r 3               
001DD3r 3  60           z_nip:          rts
001DD4r 3               
001DD4r 3               
001DD4r 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
001DD4r 3               ; ## "<>"  auto  ANS core ext
001DD4r 3                       ; """https://forth-standard.org/standard/core/ne
001DD4r 3                       ;
001DD4r 3                       ; This is just a variant of EQUAL, we code it separately
001DD4r 3                       ; for speed.
001DD4r 3                       ; """
001DD4r 3               
001DD4r 3               xt_not_equals:
001DD4r 3  20 rr rr                     jsr underflow_2
001DD7r 3               
001DD7r 3  A0 00                        ldy #0                  ; default is true
001DD9r 3               
001DD9r 3  B5 00                        lda 0,x                 ; LSB
001DDBr 3  D5 02                        cmp 2,x
001DDDr 3  D0 0A                        bne @not_equal
001DDFr 3               
001DDFr 3                               ; LSB is equal
001DDFr 3  B5 01                        lda 1,x                 ; MSB
001DE1r 3  D5 03                        cmp 3,x
001DE3r 3  D0 04                        bne @not_equal
001DE5r 3               
001DE5r 3  A9 FF                        lda #$FF
001DE7r 3  80 01                        bra @done
001DE9r 3               
001DE9r 3               @not_equal:
001DE9r 3  88                           dey                     ; drop thru to done
001DEAr 3               
001DEAr 3               @done:
001DEAr 3  98                           tya
001DEBr 3  E8                           inx
001DECr 3  E8                           inx
001DEDr 3  95 00                        sta 0,x
001DEFr 3  95 01                        sta 1,x
001DF1r 3               
001DF1r 3  60           z_not_equals:   rts
001DF2r 3               
001DF2r 3               
001DF2r 3               
001DF2r 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
001DF2r 3               ; ## "-rot"  auto  Gforth
001DF2r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
001DF2r 3               
001DF2r 3               xt_not_rote:
001DF2r 3  20 rr rr                     jsr underflow_3
001DF5r 3               
001DF5r 3  B4 01                        ldy 1,x         ; MSB first
001DF7r 3  B5 03                        lda 3,x
001DF9r 3  95 01                        sta 1,x
001DFBr 3               
001DFBr 3  B5 05                        lda 5,x
001DFDr 3  95 03                        sta 3,x
001DFFr 3  94 05                        sty 5,x
001E01r 3               
001E01r 3  B4 00                        ldy 0,x         ; LSB second
001E03r 3  B5 02                        lda 2,x
001E05r 3  95 00                        sta 0,x
001E07r 3               
001E07r 3  B5 04                        lda 4,x
001E09r 3  95 02                        sta 2,x
001E0Br 3  94 04                        sty 4,x
001E0Dr 3               
001E0Dr 3  60           z_not_rote:     rts
001E0Er 3               
001E0Er 3               
001E0Er 3               
001E0Er 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001E0Er 3               ; ## "number"  auto  Tali Forth
001E0Er 3                       ; """Convert a number string to a double or single cell number. This
001E0Er 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001E0Er 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001E0Er 3                       ; Based in part on the "Starting Forth" code
001E0Er 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001E0Er 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001E0Er 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001E0Er 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001E0Er 3                       ; dot to signal a double cell number is required to be the last
001E0Er 3                       ; character of the string.
001E0Er 3                       ;
001E0Er 3                       ; Number calls >NUMBER which in turn calls UM*,
001E0Er 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001E0Er 3                       ; a pain.
001E0Er 3                       ;"""
001E0Er 3               
001E0Er 3               xt_number:
001E0Er 3  20 rr rr                     jsr underflow_2
001E11r 3               
001E11r 3                               ; we keep the flags for sign and double in tmpdsp because
001E11r 3                               ; we've run out of temporary variables
001E11r 3  64 rr                        stz tmpdsp      ; flag for double
001E13r 3  64 rr                        stz tmpdsp+1    ; flag for minus
001E15r 3               
001E15r 3                               ; If the first character is a minus, strip it off and set
001E15r 3                               ; the flag
001E15r 3  A1 02                        lda (2,x)
001E17r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001E19r 3  D0 0A                        bne @check_dot
001E1Br 3               
001E1Br 3                               ; It's a minus
001E1Br 3  C6 rr                        dec tmpdsp+1
001E1Dr 3  F6 02                        inc 2,x         ; start one character later
001E1Fr 3  D0 02                        bne @1
001E21r 3  F6 03                        inc 3,x
001E23r 3               @1:
001E23r 3  D6 00                        dec 0,x         ; decrease string length by one
001E25r 3               
001E25r 3               @check_dot:
001E25r 3                               ; If the last character is a dot, strip it off and set a
001E25r 3                               ; flag. We can use tmptos as a temporary variable
001E25r 3  B5 02                        lda 2,x         ; LSB of address
001E27r 3  18                           clc
001E28r 3  75 00                        adc 0,x         ; length of string
001E2Ar 3  85 rr                        sta tmptos
001E2Cr 3  B5 03                        lda 3,x
001E2Er 3  69 00                        adc #0          ; only need carry
001E30r 3  85 rr                        sta tmptos+1
001E32r 3               
001E32r 3                               ; tmptos now points to the first character after the string,
001E32r 3                               ; but we need the last character
001E32r 3  A5 rr                        lda tmptos
001E34r 3  D0 02                        bne @2
001E36r 3  C6 rr                        dec tmptos+1
001E38r 3               @2:
001E38r 3  C6 rr                        dec tmptos
001E3Ar 3               
001E3Ar 3  B2 rr                        lda (tmptos)
001E3Cr 3  C9 2E                        cmp #'.'
001E3Er 3  D0 04                        bne @main
001E40r 3               
001E40r 3                               ; We have a dot, which means this is a double number. Flag
001E40r 3                               ; the fact and reduce string length by one
001E40r 3  C6 rr                        dec tmpdsp
001E42r 3  D6 00                        dec 0,x
001E44r 3               
001E44r 3               @main:
001E44r 3                               ; Set up stack for subroutine jump to >NUMBER, which means
001E44r 3                               ; we have to go ( addr u --> ud addr u )
001E44r 3  CA                           dex
001E45r 3  CA                           dex
001E46r 3  CA                           dex
001E47r 3  CA                           dex
001E48r 3               
001E48r 3  B5 04                        lda 4,x         ; LSB of length
001E4Ar 3  95 00                        sta 0,x
001E4Cr 3  74 01                        stz 1,x         ; MSB, max length 255 chars
001E4Er 3               
001E4Er 3  B5 06                        lda 6,x         ; LSB of address
001E50r 3  95 02                        sta 2,x
001E52r 3  B5 07                        lda 7,x         ; MSB of address
001E54r 3  95 03                        sta 3,x
001E56r 3               
001E56r 3  74 04                        stz 4,x         ; clear space for ud
001E58r 3  74 05                        stz 5,x
001E5Ar 3  74 06                        stz 6,x
001E5Cr 3  74 07                        stz 7,x
001E5Er 3               
001E5Er 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
001E61r 3               
001E61r 3                               ; test length of returned string, which should be zero
001E61r 3  B5 00                        lda 0,x
001E63r 3  F0 15                        beq @all_converted
001E65r 3               
001E65r 3                               ; Something went wrong, we still have characters left over,
001E65r 3                               ; so we print an error and abort. If the NUMBER was called
001E65r 3                               ; by INTERPRET, we've already checked for Forth words, so
001E65r 3                               ; we're in deep trouble one way or another
001E65r 3  A9 3E                        lda #$3E        ; ASCII for ">"
001E67r 3  20 rr rr                     jsr emit_a
001E6Ar 3  20 rr rr                     jsr xt_type
001E6Dr 3  A9 3C                        lda #$3C        ; ASCII for "<"
001E6Fr 3  20 rr rr                     jsr emit_a
001E72r 3  20 rr rr                     jsr xt_space
001E75r 3               
001E75r 3  A9 08                        lda #err_syntax
001E77r 3  4C rr rr                     jmp error
001E7Ar 3               
001E7Ar 3               @all_converted:
001E7Ar 3                               ; We can drop the string info
001E7Ar 3  E8                           inx
001E7Br 3  E8                           inx
001E7Cr 3  E8                           inx
001E7Dr 3  E8                           inx
001E7Er 3               
001E7Er 3                               ; We have a double-cell number on the Data Stack that might
001E7Er 3                               ; actually have a minus and might actually be single-cell
001E7Er 3  A5 rr                        lda tmpdsp      ; flag for double
001E80r 3  F0 0D                        beq @single
001E82r 3               
001E82r 3                               ; Set status bit 5 to indicate this is a double number
001E82r 3  A9 20                        lda #%00100000
001E84r 3  04 rr                        tsb status
001E86r 3               
001E86r 3                               ; This is a double cell number. If it had a minus, we'll have
001E86r 3                               ; to negate it
001E86r 3  A5 rr                        lda tmpdsp+1
001E88r 3  F0 12                        beq @done       ; no minus, all done
001E8Ar 3               
001E8Ar 3  20 rr rr                     jsr xt_dnegate
001E8Dr 3               
001E8Dr 3  80 0D                        bra @done
001E8Fr 3               
001E8Fr 3               @single:
001E8Fr 3                               ; This is a single number, so we just drop the top cell
001E8Fr 3  E8                           inx
001E90r 3  E8                           inx
001E91r 3               
001E91r 3                               ; Clear status bit 5 to indicate this is a single number
001E91r 3  A9 20                        lda #%00100000
001E93r 3  14 rr                        trb status
001E95r 3               
001E95r 3                               ; If we had a minus, we'll have to negate it
001E95r 3  A5 rr                        lda tmpdsp+1
001E97r 3  F0 03                        beq @done       ; no minus, all done
001E99r 3               
001E99r 3  20 rr rr                     jsr xt_negate
001E9Cr 3               @done:
001E9Cr 3  60           z_number:       rts
001E9Dr 3               
001E9Dr 3               
001E9Dr 3               
001E9Dr 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001E9Dr 3               ; ## "#"  auto  ANS core
001E9Dr 3                       ; """https://forth-standard.org/standard/core/num
001E9Dr 3                       ; Add one char to the beginning of the pictured output string.
001E9Dr 3                       ;
001E9Dr 3                       ; Based on
001E9Dr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001E9Dr 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001E9Dr 3                       ; """
001E9Dr 3               xt_number_sign:
001E9Dr 3  20 rr rr                     jsr underflow_2         ; double number
001EA0r 3               
001EA0r 3  20 rr rr                     jsr xt_base
001EA3r 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
001EA6r 3               
001EA6r 3                               ; The following code is the ancient Forth word UD/MOD, which in
001EA6r 3                               ; various Forths (including Gforth) lives on under the hood,
001EA6r 3                               ; even though it's not an ANS standard word, it doesn't appear
001EA6r 3                               ; in the docs, it's only used here, and there are no tests for
001EA6r 3                               ; it. This is why we got rid of it. We'll be converting this
001EA6r 3                               ; mess to something more sane in the long run.
001EA6r 3  20 rr rr                     jsr xt_to_r             ; >r
001EA9r 3  20 rr rr                     jsr xt_zero             ; 0
001EACr 3  20 rr rr                     jsr xt_r_fetch          ; r@
001EAFr 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001EB2r 3  20 rr rr                     jsr xt_rot              ; rot
001EB5r 3  20 rr rr                     jsr xt_rot              ; rot
001EB8r 3  20 rr rr                     jsr xt_r_from           ; r>
001EBBr 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001EBEr 3  20 rr rr                     jsr xt_rot              ; rot
001EC1r 3                               ; end of UD/MOD ( rem ud )
001EC1r 3               
001EC1r 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
001EC4r 3               
001EC4r 3                               ; Convert the number that is left over to an ASCII character. We
001EC4r 3                               ; use a string lookup for speed. Use either abc_str_lower for
001EC4r 3                               ; lower case or abc_str_upper for upper case (prefered)
001EC4r 3  B5 00                        lda 0,x
001EC6r 3  A8                           tay
001EC7r 3  B9 rr rr                     lda s_abc_upper,y
001ECAr 3  95 00                        sta 0,x
001ECCr 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
001ECEr 3               
001ECEr 3  20 rr rr                     jsr xt_hold
001ED1r 3               
001ED1r 3               z_number_sign:
001ED1r 3  60                           rts
001ED2r 3               
001ED2r 3               
001ED2r 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
001ED2r 3               ; ## "#>"  auto  ANS core
001ED2r 3                       ; """https://forth-standard.org/standard/core/num-end
001ED2r 3                       ; Finish conversion of pictured number string, putting address and
001ED2r 3                       ; length on the Data Stack.
001ED2r 3                       ;
001ED2r 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
001ED2r 3                       ; Based on
001ED2r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001ED2r 3                       ; """
001ED2r 3               xt_number_sign_greater:
001ED2r 3               
001ED2r 3  20 rr rr                     jsr underflow_2         ; double number
001ED5r 3               
001ED5r 3                               ; The start address lives in tohold
001ED5r 3  A5 rr                        lda tohold
001ED7r 3  95 00                        sta 0,x         ; LSB of tohold
001ED9r 3  95 02                        sta 2,x
001EDBr 3  A5 rr                        lda tohold+1
001EDDr 3  95 01                        sta 1,x         ; MSB of addr
001EDFr 3  95 03                        sta 3,x         ; ( addr addr )
001EE1r 3               
001EE1r 3                               ; The length of the string is pad - addr
001EE1r 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
001EE4r 3               
001EE4r 3  38                           sec
001EE5r 3  B5 00                        lda 0,x         ; LSB of pad address
001EE7r 3  F5 02                        sbc 2,x
001EE9r 3  95 02                        sta 2,x
001EEBr 3               
001EEBr 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001EEDr 3  F5 03                        sbc 3,x
001EEFr 3  95 03                        sta 3,x         ; ( addr u pad )
001EF1r 3               
001EF1r 3  E8                           inx
001EF2r 3  E8                           inx
001EF3r 3               
001EF3r 3               z_number_sign_greater:
001EF3r 3  60                           rts
001EF4r 3               
001EF4r 3               
001EF4r 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
001EF4r 3               ; ## "#s"  auto  ANS core
001EF4r 3                       ; """https://forth-standard.org/standard/core/numS
001EF4r 3                       ; Completely convert number for pictured numerical output.
001EF4r 3                       ;
001EF4r 3                       ; Based on
001EF4r 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
001EF4r 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
001EF4r 3                       ; """
001EF4r 3               
001EF4r 3               xt_number_sign_s:
001EF4r 3  20 rr rr                     jsr underflow_2
001EF7r 3               @loop:
001EF7r 3                               ; convert a single number ("#")
001EF7r 3  20 rr rr                     jsr xt_number_sign
001EFAr 3               
001EFAr 3                               ; stop when double-celled number in TOS is zero:
001EFAr 3  B5 00                        lda 0,x
001EFCr 3  15 01                        ora 1,x
001EFEr 3  15 02                        ora 2,x
001F00r 3  15 03                        ora 3,x
001F02r 3  D0 F3                        bne @loop
001F04r 3               
001F04r 3               z_number_sign_s:
001F04r 3  60                           rts
001F05r 3               
001F05r 3               
001F05r 3               
001F05r 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
001F05r 3               ; ## "of"  auto  ANS core ext
001F05r 3                       ; """http://forth-standard.org/standard/core/OF"""
001F05r 3               
001F05r 3               xt_of:
001F05r 3                               ; Check if value is equal to this case.
001F05r 3                               ; Postpone over (eg. compile a jsr to it)
001F05r 3  A0 rr                        ldy #>xt_over
001F07r 3  A9 rr                        lda #<xt_over
001F09r 3  20 rr rr                     jsr cmpl_subroutine
001F0Cr 3               
001F0Cr 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001F0Cr 3  A0 rr                        ldy #>xt_equal
001F0Er 3  A9 rr                        lda #<xt_equal
001F10r 3  20 rr rr                     jsr cmpl_subroutine
001F13r 3               
001F13r 3  20 rr rr                     jsr xt_if
001F16r 3               
001F16r 3                               ; If it's true, consume the original value.
001F16r 3                               ; Postpone DROP (eg. compile a jsr to it)
001F16r 3  A0 rr                        ldy #>xt_drop
001F18r 3  A9 rr                        lda #<xt_drop
001F1Ar 3  20 rr rr                     jsr cmpl_subroutine
001F1Dr 3               
001F1Dr 3  60           z_of:           rts
001F1Er 3               
001F1Er 3               
001F1Er 3               
001F1Er 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
001F1Er 3               ; ## "1"  auto  Tali Forth
001F1Er 3                       ; """This is also the code for EDITOR-WORDLIST"""
001F1Er 3               xt_editor_wordlist:
001F1Er 3               xt_one:
001F1Er 3  CA                           dex
001F1Fr 3  CA                           dex
001F20r 3  A9 01                        lda #1
001F22r 3  95 00                        sta 0,x
001F24r 3  74 01                        stz 1,x
001F26r 3               
001F26r 3               z_editor_wordlist:
001F26r 3               z_one:
001F26r 3  60                           rts
001F27r 3               
001F27r 3               
001F27r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001F27r 3               ; ## "1-"  auto  ANS core
001F27r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001F27r 3               
001F27r 3               xt_one_minus:
001F27r 3  20 rr rr                     jsr underflow_1
001F2Ar 3               
001F2Ar 3  B5 00                        lda 0,x
001F2Cr 3  D0 02                        bne @1
001F2Er 3  D6 01                        dec 1,x
001F30r 3               @1:
001F30r 3  D6 00                        dec 0,x
001F32r 3               
001F32r 3  60           z_one_minus:    rts
001F33r 3               
001F33r 3               
001F33r 3               
001F33r 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
001F33r 3               ; ## "1+"  auto  ANS core
001F33r 3                       ; """https://forth-standard.org/standard/core/OnePlus
001F33r 3                       ;
001F33r 3                       ; Code is shared with CHAR-PLUS
001F33r 3                       ; """
001F33r 3               
001F33r 3               xt_char_plus:
001F33r 3               xt_one_plus:
001F33r 3  20 rr rr                     jsr underflow_1
001F36r 3               
001F36r 3  F6 00                        inc 0,x
001F38r 3  D0 02                        bne @done
001F3Ar 3  F6 01                        inc 1,x
001F3Cr 3               
001F3Cr 3               @done:
001F3Cr 3               z_char_plus:
001F3Cr 3  60           z_one_plus:     rts
001F3Dr 3               
001F3Dr 3               
001F3Dr 3               
001F3Dr 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
001F3Dr 3               ; ## "only"  auto  ANS search ext
001F3Dr 3                       ; """https://forth-standard.org/standard/search/ONLY"""
001F3Dr 3               
001F3Dr 3               xt_only:
001F3Dr 3                               ; Put -1 on data stack.
001F3Dr 3  CA                           dex
001F3Er 3  CA                           dex
001F3Fr 3  A9 FF                        lda #$FF
001F41r 3  95 00                        sta 0,x
001F43r 3  95 01                        sta 1,x
001F45r 3               
001F45r 3                               ; Invoke set-order to set the minimum search order.
001F45r 3  20 rr rr                     jsr xt_set_order
001F48r 3               
001F48r 3  60           z_only:         rts
001F49r 3               
001F49r 3               
001F49r 3               
001F49r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
001F49r 3               ; ## "or"  auto  ANS core
001F49r 3                       ; """https://forth-standard.org/standard/core/OR"
001F49r 3               xt_or:
001F49r 3  20 rr rr                     jsr underflow_2
001F4Cr 3               
001F4Cr 3  B5 00                        lda 0,x
001F4Er 3  15 02                        ora 2,x
001F50r 3  95 02                        sta 2,x
001F52r 3               
001F52r 3  B5 01                        lda 1,x
001F54r 3  15 03                        ora 3,x
001F56r 3  95 03                        sta 3,x
001F58r 3               
001F58r 3  E8                           inx
001F59r 3  E8                           inx
001F5Ar 3               
001F5Ar 3  60           z_or:           rts
001F5Br 3               
001F5Br 3               
001F5Br 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
001F5Br 3               ; ## "order"  auto  ANS core
001F5Br 3                       ; """https://forth-standard.org/standard/search/ORDER
001F5Br 3                       ; Note the search order is displayed from first search to last
001F5Br 3                       ; searched and is therefore exactly the reverse of the order in which
001F5Br 3                       ; Forth stacks are displayed.
001F5Br 3                       ;
001F5Br 3                       ; A Forth implementation of this word is:
001F5Br 3                       ;
001F5Br 3                       ; 	: .wid ( wid -- )
001F5Br 3                       ; 	dup 0=  if ." Forth "  drop    else
001F5Br 3                       ; 	dup 1 = if ." Editor " drop    else
001F5Br 3                       ; 	dup 2 = if ." Assembler " drop else
001F5Br 3                       ; 	dup 3 = if ." Root " drop      else
001F5Br 3                       ; 	           . ( just print the number )
001F5Br 3                       ; 	then then then then ;
001F5Br 3                       ;
001F5Br 3                       ; : ORDER ( -- )
001F5Br 3                       ; 	cr get-order 0 ?do .wid loop
001F5Br 3                       ; 	space space get-current .wid ;
001F5Br 3                       ;
001F5Br 3                       ; This is an interactive program, so speed
001F5Br 3                       ; is not as important as size. We assume we do not have more than 255
001F5Br 3                       ; wordlists.
001F5Br 3                       ; """
001F5Br 3               
001F5Br 3               xt_order:
001F5Br 3  20 rr rr                     jsr xt_cr
001F5Er 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
001F61r 3               
001F61r 3                               ; Paranoid: Check if there are no wordlists, a rather
001F61r 3                               ; pathological case. this would mean ( 0 ) on the stack. In
001F61r 3                               ; that case, we just drop n and run
001F61r 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
001F63r 3  F0 1E                        beq @drop_done
001F65r 3               
001F65r 3               @have_wordlists:
001F65r 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
001F65r 3                               ; on the stack
001F65r 3  A8                           tay
001F66r 3               @loop:
001F66r 3  E8                           inx
001F67r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
001F68r 3  B5 00                        lda 0,x
001F6Ar 3               
001F6Ar 3  5A                           phy
001F6Br 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
001F6Er 3  7A                           ply
001F6Fr 3               
001F6Fr 3  88                           dey
001F70r 3  D0 F4                        bne @loop
001F72r 3               
001F72r 3                               ; We've printed the wordlists, now we add the current wordlist.
001F72r 3                               ; This follows the convention of Gforth
001F72r 3  20 rr rr                     jsr xt_space
001F75r 3  20 rr rr                     jsr xt_space
001F78r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
001F7Br 3               
001F7Br 3  B5 00                        lda 0,x
001F7Dr 3  20 rr rr                     jsr _print_wid_string
001F80r 3  20 rr rr                     jsr xt_cr
001F83r 3               
001F83r 3               @drop_done:
001F83r 3  E8                           inx
001F84r 3  E8                           inx
001F85r 3               z_order:
001F85r 3  60                           rts
001F86r 3               
001F86r 3               _print_wid_string:
001F86r 3                       ; """Helper function for ORDER: Given a WID in A, print the
001F86r 3                       ; corresponding string. If there is no such word list defined, just
001F86r 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
001F86r 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
001F86r 3                       ; theory, we could speed this up by having the WID be the same as the
001F86r 3                       ; number of the strings. However, ORDER is used rather infrequently and
001F86r 3                       ; this would make changes to the strings.asm file very dangerous, so we
001F86r 3                       ; follow the slightly more complicated route with a translation table.
001F86r 3                       ; """
001F86r 3                               ; If the WID is larger than 3, we have no string avaliable and
001F86r 3                               ; just print the number.
001F86r 3                               ; See http://6502.org/tutorials/compare_instructions.html
001F86r 3                               ; for details
001F86r 3  C9 04                        cmp #4
001F88r 3  90 09                        bcc @output_string      ; less than 4, print a real string
001F8Ar 3               
001F8Ar 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
001F8Ar 3                               ; print the number
001F8Ar 3  CA                           dex
001F8Br 3  CA                           dex
001F8Cr 3  95 00                        sta 0,x
001F8Er 3  74 01                        stz 1,x
001F90r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
001F93r 3               
001F93r 3               @output_string:
001F93r 3                               ; Get the string number based on WID 0 to 3
001F93r 3  A8                           tay
001F94r 3  B9 rr rr                     lda @wid_data,y
001F97r 3               
001F97r 3                               ; Print without a line feed
001F97r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
001F9Ar 3               
001F9Ar 3               @wid_data:
001F9Ar 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
001F9Ar 3                       ; less than 4.
001F9Ar 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
001F9Br 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
001F9Cr 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
001F9Dr 3  08                   .byte str_wid_root             ; WID 3: "Root"
001F9Er 3               
001F9Er 3               
001F9Er 3               
001F9Er 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
001F9Er 3               ; ## "output"  tested  Tali Forth
001F9Er 3               xt_output:
001F9Er 3                       ; """Return the address where the jump target for EMIT is stored (but
001F9Er 3                       ; not the vector itself). By default, this will hold the value of
001F9Er 3                       ; kernel_putc routine, but this can be changed by the user, hence this
001F9Er 3                       ; routine.
001F9Er 3                       ; """
001F9Er 3  CA                           dex
001F9Fr 3  CA                           dex
001FA0r 3  A9 rr                        lda #<output
001FA2r 3  95 00                        sta 0,x
001FA4r 3  A9 rr                        lda #>output
001FA6r 3  95 01                        sta 1,x
001FA8r 3               
001FA8r 3  60           z_output:       rts
001FA9r 3               
001FA9r 3               
001FA9r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
001FA9r 3               ; ## "over"  auto  ANS core
001FA9r 3                       ; """https://forth-standard.org/standard/core/OVER"""
001FA9r 3               xt_over:
001FA9r 3  20 rr rr                     jsr underflow_2
001FACr 3               
001FACr 3  CA                           dex
001FADr 3  CA                           dex
001FAEr 3               
001FAEr 3  B5 04                        lda 4,x         ; LSB
001FB0r 3  95 00                        sta 0,x
001FB2r 3  B5 05                        lda 5,x         ; MSB
001FB4r 3  95 01                        sta 1,x
001FB6r 3               
001FB6r 3  60           z_over:         rts
001FB7r 3               
001FB7r 3               
001FB7r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
001FB7r 3               ; ## "pad"  auto  ANS core ext
001FB7r 3                       ; """https://forth-standard.org/standard/core/PAD
001FB7r 3                       ; Return address to a temporary area in free memory for user. Must
001FB7r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
001FB7r 3                       ; the compile area pointer (CP) and therefore varies in position.
001FB7r 3                       ; This area is reserved for the user and not used by the system
001FB7r 3                       ; """
001FB7r 3               xt_pad:
001FB7r 3  CA                           dex
001FB8r 3  CA                           dex
001FB9r 3               
001FB9r 3  A5 rr                        lda cp
001FBBr 3  18                           clc
001FBCr 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
001FBEr 3  95 00                        sta 0,x
001FC0r 3               
001FC0r 3  A5 rr                        lda cp+1
001FC2r 3  69 00                        adc #0          ; only need carry
001FC4r 3  95 01                        sta 1,x
001FC6r 3               
001FC6r 3  60           z_pad:          rts
001FC7r 3               
001FC7r 3               
001FC7r 3               ; ## PAGE ( -- ) "Clear the screen"
001FC7r 3               ; ## "page"  tested  ANS facility
001FC7r 3                       ; """https://forth-standard.org/standard/facility/PAGE
001FC7r 3                       ; Clears a page if supported by ANS terminal codes. This is
001FC7r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
001FC7r 3                       ; left of the screen
001FC7r 3                       ; """
001FC7r 3               xt_page:
001FC7r 3  A9 1B                        lda #AscESC
001FC9r 3  20 rr rr                     jsr emit_a
001FCCr 3  A9 5B                        lda #$5B        ; ASCII for "["
001FCEr 3  20 rr rr                     jsr emit_a
001FD1r 3  A9 32                        lda #'2'
001FD3r 3  20 rr rr                     jsr emit_a
001FD6r 3  A9 4A                        lda #'J'
001FD8r 3  20 rr rr                     jsr emit_a
001FDBr 3               
001FDBr 3                               ; move cursor to top left of screen
001FDBr 3  20 rr rr                     jsr xt_zero
001FDEr 3  20 rr rr                     jsr xt_zero
001FE1r 3  20 rr rr                     jsr xt_at_xy
001FE4r 3               
001FE4r 3  60           z_page:         rts
001FE5r 3               
001FE5r 3               
001FE5r 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
001FE5r 3               ; ## "("  auto  ANS core
001FE5r 3                       ; """http://forth-standard.org/standard/core/p"""
001FE5r 3               
001FE5r 3               xt_paren:
001FE5r 3                               ; Put a right paren on the stack.
001FE5r 3  CA                           dex
001FE6r 3  CA                           dex
001FE7r 3  A9 29                        lda #41     ; Right parenthesis
001FE9r 3  95 00                        sta 0,x
001FEBr 3  74 01                        stz 1,x
001FEDr 3               
001FEDr 3                               ; Call parse.
001FEDr 3  20 rr rr                     jsr xt_parse
001FF0r 3               
001FF0r 3                               ; Throw away the result.
001FF0r 3  E8                           inx
001FF1r 3  E8                           inx
001FF2r 3  E8                           inx
001FF3r 3  E8                           inx
001FF4r 3               
001FF4r 3  60           z_paren:        rts
001FF5r 3               
001FF5r 3               
001FF5r 3               
001FF5r 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
001FF5r 3               ; ## "parse-name"  auto  ANS core ext
001FF5r 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
001FF5r 3                       ; Find next word in input string, skipping leading whitespace. This is
001FF5r 3                       ; a special form of PARSE and drops through to that word. See PARSE
001FF5r 3                       ; for more detail. We use this word internally for the interpreter
001FF5r 3                       ; because it is a lot easier to use. Reference implementations at
001FF5r 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
001FF5r 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
001FF5r 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
001FF5r 3                       ; though the ANS standard talks about skipping "spaces", whitespace
001FF5r 3                       ; is actually perfectly legal (see for example
001FF5r 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
001FF5r 3                       ; Otherwise, PARSE-NAME chokes on tabs.
001FF5r 3                       ; """
001FF5r 3               
001FF5r 3               xt_parse_name:
001FF5r 3                               ; To enable the compilation of the high-level Forth words
001FF5r 3                               ; in forth-words.asm and user-words.asm at boot time,
001FF5r 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
001FF5r 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
001FF5r 3                               ; to the current location is in toin (>IN). We need to check,
001FF5r 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
001FF5r 3                               ; we can't just use Y as an index.
001FF5r 3               
001FF5r 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
001FF5r 3  A5 rr                        lda ciblen              ; LSB of counter
001FF7r 3  38                           sec
001FF8r 3  E5 rr                        sbc toin
001FFAr 3  85 rr                        sta tmp1
001FFCr 3  A5 rr                        lda ciblen+1            ; MSB
001FFEr 3  E5 rr                        sbc toin+1
002000r 3  85 rr                        sta tmp1+1
002002r 3               
002002r 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
002002r 3  A5 rr                        lda tmp1
002004r 3  05 rr                        ora tmp1+1
002006r 3  F0 28                        beq @empty_line
002008r 3               
002008r 3                               ; We walk through the characters starting at CIB+TOIN, so we
002008r 3                               ; save a temp version of that in tmp2
002008r 3  A5 rr                        lda cib
00200Ar 3  18                           clc
00200Br 3  65 rr                        adc toin
00200Dr 3  85 rr                        sta tmp2                ; LSB of first character
00200Fr 3  A5 rr                        lda cib+1
002011r 3  65 rr                        adc toin+1
002013r 3  85 rr                        sta tmp2+1              ; MSB
002015r 3               
002015r 3               @skip_loop:
002015r 3  B2 rr                        lda (tmp2)              ; work copy of cib
002017r 3  20 rr rr                     jsr is_whitespace
00201Ar 3  90 1F                        bcc @char_found
00201Cr 3               
00201Cr 3                               ; Char is still whitespace, continue
00201Cr 3  E6 rr                        inc tmp2
00201Er 3  D0 02                        bne @2
002020r 3  E6 rr                        inc tmp2+1
002022r 3               @2:
002022r 3                               ; Adjust counter
002022r 3  A5 rr                        lda tmp1
002024r 3  D0 02                        bne @3
002026r 3  C6 rr                        dec tmp1+1
002028r 3               @3:
002028r 3  C6 rr                        dec tmp1
00202Ar 3               
00202Ar 3  A5 rr                        lda tmp1
00202Cr 3  05 rr                        ora tmp1+1
00202Er 3  D0 E5                        bne @skip_loop          ; fall through if empty line
002030r 3               
002030r 3               @empty_line:
002030r 3                               ; Neither the ANS Forth nor the Gforth documentation say
002030r 3                               ; what to return as an address if a string with only
002030r 3                               ; spaces is given. For speed reasons, we just return junk
002030r 3                               ; NOS, with the TOS zero as per standard
002030r 3  CA                           dex
002031r 3  CA                           dex
002032r 3  CA                           dex
002033r 3  CA                           dex
002034r 3               
002034r 3  74 00                        stz 0,x                 ; TOS is zero
002036r 3  74 01                        stz 1,x
002038r 3               
002038r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
00203Br 3               
00203Br 3               @char_found:
00203Br 3                               ; We arrive here with tmp2 pointing to the first non-space
00203Br 3                               ; character. This is where the word really starts, so
00203Br 3                               ; we use it to calculate the new >IN by subtracting
00203Br 3  A5 rr                        lda tmp2
00203Dr 3  38                           sec
00203Er 3  E5 rr                        sbc cib
002040r 3  85 rr                        sta toin
002042r 3  A5 rr                        lda tmp2+1
002044r 3  E5 rr                        sbc cib+1
002046r 3  85 rr                        sta toin+1
002048r 3               
002048r 3                               ; prepare Data Stack for PARSE by adding space
002048r 3                               ; as the delimiter
002048r 3  CA                           dex
002049r 3  CA                           dex
00204Ar 3               
00204Ar 3  A9 20                        lda #AscSP
00204Cr 3  95 00                        sta 0,x
00204Er 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
002050r 3               
002050r 3               
002050r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
002050r 3               ; ## "parse"  tested  ANS core ext
002050r 3                       ; """https://forth-standard.org/standard/core/PARSE
002050r 3                       ; Find word in input string delimited by character given. Do not
002050r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
002050r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
002050r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
002050r 3                       ;
002050r 3                       ;
002050r 3                       ;     cib  cib+toin   cib+ciblen
002050r 3                       ;      v      v            v
002050r 3                       ;     |###################|
002050r 3                       ;
002050r 3                       ;     |------>|  toin (>IN)
002050r 3                       ;     |------------------->|  ciblen
002050r 3                       ;
002050r 3                       ; The input string is stored starting at the address in the Current
002050r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
002050r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
002050r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
002050r 3                       ; useful string if there are any characters at all. As with
002050r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
002050r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
002050r 3                       ; """
002050r 3               
002050r 3               xt_parse:
002050r 3  20 rr rr                     jsr underflow_1
002053r 3               
002053r 3                               ; If the input buffer is empty, we just return
002053r 3  A5 rr                        lda ciblen
002055r 3  05 rr                        ora ciblen+1
002057r 3  F0 0C                        beq @abort_parse
002059r 3               
002059r 3                               ; If the pointer >IN is larger or equal to the length of
002059r 3                               ; the input buffer (CIBLEN), the line is done. Put
002059r 3                               ; differently, we only continue if >IN is smaller than
002059r 3                               ; CIBLEN
002059r 3  A5 rr                        lda toin+1              ; MSB
00205Br 3  C5 rr                        cmp ciblen+1
00205Dr 3  90 0E                        bcc @go_parse           ; unsigned comparison
00205Fr 3               
00205Fr 3  A5 rr                        lda toin                ; LSB
002061r 3  C5 rr                        cmp ciblen
002063r 3  90 08                        bcc @go_parse
002065r 3               
002065r 3               @abort_parse:
002065r 3                               ; Sorry, this line is over
002065r 3  CA                           dex
002066r 3  CA                           dex
002067r 3  74 00                        stz 0,x
002069r 3  74 01                        stz 1,x
00206Br 3               
00206Br 3  80 7A                        bra @done
00206Dr 3               @go_parse:
00206Dr 3                               ; We actually have work to do. Save the delimiter in
00206Dr 3                               ; tmptos.
00206Dr 3  B5 00                        lda 0,x
00206Fr 3  85 rr                        sta tmptos
002071r 3               
002071r 3                               ; We can now prepare the Data Stack for the return value
002071r 3  CA                           dex
002072r 3  CA                           dex
002073r 3               
002073r 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
002073r 3                               ; tmp2 is initially the same as tmp1, then the work index
002073r 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
002073r 3               
002073r 3                               ; Calculate the beginning of the string, which is also the
002073r 3                               ; address to return
002073r 3  A5 rr                        lda cib
002075r 3  18                           clc
002076r 3  65 rr                        adc toin        ; LSB
002078r 3  85 rr                        sta tmp1
00207Ar 3  85 rr                        sta tmp2
00207Cr 3  95 02                        sta 2,x
00207Er 3               
00207Er 3  A5 rr                        lda cib+1
002080r 3  65 rr                        adc toin+1      ; MSB
002082r 3  85 rr                        sta tmp1+1
002084r 3  85 rr                        sta tmp2+1
002086r 3  95 03                        sta 3,x
002088r 3               
002088r 3                               ; Calculate the address where the input buffer ends plus 1, so
002088r 3                               ; we can compare it with TOIN, which is an index
002088r 3  A5 rr                        lda cib
00208Ar 3  18                           clc
00208Br 3  65 rr                        adc ciblen
00208Dr 3  85 rr                        sta tmp3
00208Fr 3  A5 rr                        lda cib+1
002091r 3  65 rr                        adc ciblen+1
002093r 3  85 rr                        sta tmp3+1
002095r 3               
002095r 3                               ; Initialize the offset we use to adjust EOL or found delimiter
002095r 3  64 rr                        stz tmptos+1
002097r 3               @loop:
002097r 3                               ; If we are at the end of the string, quit
002097r 3  A5 rr                        lda tmp2
002099r 3  C5 rr                        cmp tmp3
00209Br 3  D0 06                        bne @not_empty
00209Dr 3               
00209Dr 3  A5 rr                        lda tmp2+1
00209Fr 3  C5 rr                        cmp tmp3+1
0020A1r 3  F0 1D                        beq @eol
0020A3r 3               @not_empty:
0020A3r 3                               ; We have to do this the hard way. In fact, it's really
0020A3r 3                               ; hard since if we are dealing with a SPACE, the standard
0020A3r 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
0020A3r 3                               ; Tali would choke on tabs between words. For details, see
0020A3r 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
0020A3r 3                               ; In theory, we could make this faster by defining a delimiter
0020A3r 3                               ; that is 00 as the sign that we skip all whitespace, thereby
0020A3r 3                               ; avoiding having to test every time. However, somebody,
0020A3r 3                               ; somewhere might want to parse a zero-delimited list. Since
0020A3r 3                               ; any byte value could be chosen for that, we just test for
0020A3r 3                               ; a space every single time for the moment.
0020A3r 3  B2 rr                        lda (tmp2)
0020A5r 3               
0020A5r 3  A4 rr                        ldy tmptos
0020A7r 3  C0 20                        cpy #AscSP
0020A9r 3  D0 07                        bne @not_whitespace
0020ABr 3               
0020ABr 3                               ; The delimiter is a space, so we're looking for all
0020ABr 3                               ; whitespace
0020ABr 3  20 rr rr                     jsr is_whitespace
0020AEr 3  90 02                        bcc @not_whitespace
0020B0r 3  80 0C                        bra @found_delimiter
0020B2r 3               
0020B2r 3               @not_whitespace:
0020B2r 3                               ; The delimiter is not a space, so we're looking for
0020B2r 3                               ; whatever it is
0020B2r 3  C5 rr                        cmp tmptos
0020B4r 3  F0 08                        beq @found_delimiter
0020B6r 3               
0020B6r 3                               ; Not a delimiter, next character
0020B6r 3  E6 rr                        inc tmp2
0020B8r 3  D0 DD                        bne @loop
0020BAr 3  E6 rr                        inc tmp2+1
0020BCr 3  80 D9                        bra @loop
0020BEr 3               
0020BEr 3               @found_delimiter:
0020BEr 3                               ; Increase the offset: If we've found a delimiter, we want
0020BEr 3                               ; TOIN to point to the character after it, not the delimiter
0020BEr 3                               ; itself
0020BEr 3  E6 rr                        inc tmptos+1
0020C0r 3               @eol:
0020C0r 3                               ; The length of the new string is tmp2-tmp1
0020C0r 3  A5 rr                        lda tmp2
0020C2r 3  38                           sec
0020C3r 3  E5 rr                        sbc tmp1
0020C5r 3  95 00                        sta 0,x
0020C7r 3               
0020C7r 3  A5 rr                        lda tmp2+1
0020C9r 3  E5 rr                        sbc tmp1+1
0020CBr 3  95 01                        sta 1,x
0020CDr 3               
0020CDr 3                               ; The new offset is tmp2-cib
0020CDr 3  A5 rr                        lda tmp2
0020CFr 3  38                           sec
0020D0r 3  E5 rr                        sbc cib
0020D2r 3  85 rr                        sta toin
0020D4r 3  A5 rr                        lda tmp2+1
0020D6r 3  E5 rr                        sbc cib+1
0020D8r 3  85 rr                        sta toin+1
0020DAr 3               
0020DAr 3                               ; Add in the delimiter
0020DAr 3  A5 rr                        lda toin
0020DCr 3  18                           clc
0020DDr 3  65 rr                        adc tmptos+1
0020DFr 3  85 rr                        sta toin
0020E1r 3  A5 rr                        lda toin+1
0020E3r 3  69 00                        adc #0          ; we only need the carry
0020E5r 3  85 rr                        sta toin+1
0020E7r 3               @done:
0020E7r 3               z_parse_name:
0020E7r 3  60           z_parse:        rts
0020E8r 3               
0020E8r 3               
0020E8r 3               
0020E8r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
0020E8r 3               ; ## "pick"  auto  ANS core ext
0020E8r 3                       ; """https://forth-standard.org/standard/core/PICK
0020E8r 3                       ; Take the u-th element out of the stack and put it on TOS,
0020E8r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
0020E8r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
0020E8r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
0020E8r 3                       ; """
0020E8r 3               
0020E8r 3               xt_pick:
0020E8r 3                               ; Checking for underflow is difficult because it depends on
0020E8r 3                               ; which element we want to grab. We could probably figure
0020E8r 3                               ; something out, but it wouldn't work with underflow stripping
0020E8r 3                               ; Since using PICK is considered poor form anyway, we just
0020E8r 3                               ; leave it as it is
0020E8r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
0020EAr 3  8A                           txa
0020EBr 3  75 00                        adc 0,x
0020EDr 3  A8                           tay
0020EEr 3               
0020EEr 3  B9 02 00                     lda 0002,y
0020F1r 3  95 00                        sta 0,x
0020F3r 3  B9 03 00                     lda 0003,y
0020F6r 3  95 01                        sta 1,x
0020F8r 3               
0020F8r 3  60           z_pick:         rts
0020F9r 3               
0020F9r 3               
0020F9r 3               
0020F9r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
0020F9r 3               ; ## "+"  auto  ANS core
0020F9r 3                       ; """https://forth-standard.org/standard/core/Plus"""
0020F9r 3               xt_plus:
0020F9r 3  20 rr rr                     jsr underflow_2
0020FCr 3               
0020FCr 3  18                           clc
0020FDr 3  B5 00                        lda 0,x         ; LSB
0020FFr 3  75 02                        adc 2,x
002101r 3  95 02                        sta 2,x
002103r 3               
002103r 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
002105r 3  75 03                        adc 3,x
002107r 3  95 03                        sta 3,x
002109r 3               
002109r 3  E8                           inx
00210Ar 3  E8                           inx
00210Br 3               
00210Br 3  60           z_plus:         rts
00210Cr 3               
00210Cr 3               
00210Cr 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
00210Cr 3               ; ## "+!"  auto  ANS core
00210Cr 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
00210Cr 3               xt_plus_store:
00210Cr 3  20 rr rr                     jsr underflow_2
00210Fr 3               
00210Fr 3                               ; move address to tmp1 so we can work with it
00210Fr 3  B5 00                        lda 0,x
002111r 3  85 rr                        sta tmp1
002113r 3  B5 01                        lda 1,x
002115r 3  85 rr                        sta tmp1+1
002117r 3               
002117r 3  A0 00                        ldy #0          ; LSB
002119r 3  B1 rr                        lda (tmp1),y
00211Br 3  18                           clc
00211Cr 3  75 02                        adc 2,x
00211Er 3  91 rr                        sta (tmp1),y
002120r 3               
002120r 3  C8                           iny             ; MSB
002121r 3  B1 rr                        lda (tmp1),y
002123r 3  75 03                        adc 3,x
002125r 3  91 rr                        sta (tmp1),y
002127r 3               
002127r 3  E8                           inx
002128r 3  E8                           inx
002129r 3  E8                           inx
00212Ar 3  E8                           inx
00212Br 3               
00212Br 3  60           z_plus_store:   rts
00212Cr 3               
00212Cr 3               
00212Cr 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
00212Cr 3               ; ## "postpone"  auto   ANS core
00212Cr 3                       ; """https://forth-standard.org/standard/core/POSTPONE
00212Cr 3                       ; Add the compilation behavior of a word to a new word at
00212Cr 3                       ; compile time. If the word that follows it is immediate, include
00212Cr 3                       ; it so that it will be compiled when the word being defined is
00212Cr 3                       ; itself used for a new word. Tricky, but very useful.
00212Cr 3                       ;
00212Cr 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
00212Cr 3                       ; on the Data Stack). This means we cannot build words with
00212Cr 3                       ; "jsr xt_postpone, jsr <word>" directly.
00212Cr 3                       ; """
00212Cr 3               
00212Cr 3               xt_postpone:
00212Cr 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
00212Fr 3               
00212Fr 3                               ; if there was no word provided, complain and quit
00212Fr 3  B5 00                        lda 0,x
002131r 3  15 01                        ora 1,x
002133r 3  D0 05                        bne @1
002135r 3               
002135r 3  A9 05                        lda #err_noname
002137r 3  4C rr rr                     jmp error
00213Ar 3               @1:
00213Ar 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
00213Dr 3               
00213Dr 3                               ; if word not in Dictionary, complain and quit
00213Dr 3  D0 05                        bne @2
00213Fr 3  A9 05                        lda #err_noname
002141r 3  4C rr rr                     jmp error
002144r 3               
002144r 3               @2:
002144r 3                               ; keep a copy of nt for later
002144r 3  B5 00                        lda 0,x
002146r 3  85 rr                        sta tmp1
002148r 3  B5 01                        lda 1,x
00214Ar 3  85 rr                        sta tmp1+1
00214Cr 3               
00214Cr 3                               ; We need the xt instead of the nt
00214Cr 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
00214Fr 3               
00214Fr 3                               ; See if this is an immediate word. This is easier
00214Fr 3                               ; with nt than with xt. The status byte of the word
00214Fr 3                               ; is nt+1
00214Fr 3  E6 rr                        inc tmp1
002151r 3  D0 02                        bne @3
002153r 3  E6 rr                        inc tmp1+1
002155r 3               @3:
002155r 3  B2 rr                        lda (tmp1)
002157r 3  29 04                        and #IM         ; mask all but Intermediate flag
002159r 3  F0 05                        beq @not_immediate
00215Br 3               
00215Br 3                               ; We're immediate, so instead of executing it right now, we
00215Br 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
00215Br 3                               ; takes us back to the original caller
00215Br 3  20 rr rr                     jsr xt_compile_comma
00215Er 3  80 0A                        bra @done
002160r 3               
002160r 3               @not_immediate:
002160r 3                               ; This is not an immediate word, so we enact "deferred
002160r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
002160r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
002160r 3                               ; a subroutine jump to COMPILE,
002160r 3  20 rr rr                     jsr xt_literal
002163r 3               
002163r 3                               ; Last, compile COMPILE,
002163r 3  A0 rr                        ldy #>xt_compile_comma
002165r 3  A9 rr                        lda #<xt_compile_comma
002167r 3  20 rr rr                     jsr cmpl_subroutine
00216Ar 3               @done:
00216Ar 3  60           z_postpone:     rts
00216Br 3               
00216Br 3               
00216Br 3               
00216Br 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
00216Br 3               ; ## "previous"  auto  ANS search ext
00216Br 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
00216Br 3               
00216Br 3               xt_previous:
00216Br 3  20 rr rr                     jsr xt_get_order
00216Er 3  20 rr rr                     jsr xt_nip
002171r 3  20 rr rr                     jsr xt_one_minus
002174r 3  20 rr rr                     jsr xt_set_order
002177r 3               
002177r 3  60           z_previous:     rts
002178r 3               
002178r 3               
002178r 3               
002178r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
002178r 3               ; ## "?"  tested  ANS tools
002178r 3                       ; """https://forth-standard.org/standard/tools/q
002178r 3                       ;
002178r 3                       ; Only used interactively. Since humans are so slow, we
002178r 3                       ; save size and just go for the subroutine jumps
002178r 3                       ; """
002178r 3               xt_question:
002178r 3                               ; FETCH takes care of underflow check
002178r 3  20 rr rr                     jsr xt_fetch
00217Br 3  20 rr rr                     jsr xt_dot
00217Er 3               
00217Er 3  60           z_question:     rts
00217Fr 3               
00217Fr 3               
00217Fr 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
00217Fr 3               ; ## "?dup"  auto  ANS core
00217Fr 3                       ; """https://forth-standard.org/standard/core/qDUP"""
00217Fr 3               
00217Fr 3               xt_question_dup:
00217Fr 3  20 rr rr                     jsr underflow_1
002182r 3               
002182r 3                               ; Check if TOS is zero
002182r 3  B5 00                        lda 0,x
002184r 3  15 01                        ora 1,x
002186r 3  F0 0A                        beq @done
002188r 3               
002188r 3                               ; not zero, duplicate
002188r 3  CA                           dex
002189r 3  CA                           dex
00218Ar 3  B5 02                        lda 2,x
00218Cr 3  95 00                        sta 0,x
00218Er 3  B5 03                        lda 3,x
002190r 3  95 01                        sta 1,x
002192r 3               @done:
002192r 3  60           z_question_dup: rts
002193r 3               
002193r 3               
002193r 3               
002193r 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
002193r 3               ; ## "r@"  auto  ANS core
002193r 3                       ; """https://forth-standard.org/standard/core/RFetch
002193r 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
002193r 3                       ; work normally as well
002193r 3                       ;
002193r 3                       ; An alternative way to write this word
002193r 3                       ; would be to access the elements on the stack directly like 2R@
002193r 3                       ; does, these versions should be compared at some point.
002193r 3                       ; """
002193r 3               xt_r_fetch:
002193r 3                               ; get the return address
002193r 3  7A                           ply             ; LSB
002194r 3  84 rr                        sty tmp1
002196r 3  7A                           ply             ; MSB
002197r 3               
002197r 3                               ; --- CUT FOR NATIVE COMPILE ---
002197r 3               
002197r 3                               ; get the actual top of Return Stack
002197r 3  CA                           dex
002198r 3  CA                           dex
002199r 3               
002199r 3  68                           pla             ; LSB
00219Ar 3  95 00                        sta 0,x
00219Cr 3  68                           pla             ; MSB
00219Dr 3  95 01                        sta 1,x
00219Fr 3               
00219Fr 3                               ; now we have to put that value back
00219Fr 3  48                           pha
0021A0r 3  B5 00                        lda 0,x
0021A2r 3  48                           pha
0021A3r 3               
0021A3r 3                               ; --- CUT FOR NATIVE COMPILE ---
0021A3r 3               
0021A3r 3                               ; restore return value
0021A3r 3  5A                           phy             ; MSB
0021A4r 3  A4 rr                        ldy tmp1
0021A6r 3  5A                           phy             ; LSB
0021A7r 3               
0021A7r 3  60           z_r_fetch:      rts
0021A8r 3               
0021A8r 3               
0021A8r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
0021A8r 3               ; ## "r>"  auto  ANS core
0021A8r 3                       ; """https://forth-standard.org/standard/core/Rfrom
0021A8r 3                       ; Move Top of Return Stack to Top of Data Stack.
0021A8r 3                       ;
0021A8r 3                       ; We have to move
0021A8r 3                       ; the RTS address out of the way first. This word is handled
0021A8r 3                       ; differently for native and and subroutine compilation, see COMPILE,
0021A8r 3                       ; This is a compile-only word
0021A8r 3                       ; """
0021A8r 3               
0021A8r 3               xt_r_from:
0021A8r 3                               ; Rescue the address of the return jump that is currently
0021A8r 3                               ; on top of the Return Stack. If this word is natively
0021A8r 3                               ; compiled, this is a total waste of time
0021A8r 3  68                           pla             ; LSB
0021A9r 3  85 rr                        sta tmptos
0021ABr 3  7A                           ply             ; MSB
0021ACr 3               
0021ACr 3                               ; --- CUT FOR NATIVE CODING ---
0021ACr 3               
0021ACr 3  CA                           dex
0021ADr 3  CA                           dex
0021AEr 3               
0021AEr 3                               ; now we can access the actual data
0021AEr 3               
0021AEr 3  68                           pla             ; LSB
0021AFr 3  95 00                        sta 0,x
0021B1r 3  68                           pla             ; MSB
0021B2r 3  95 01                        sta 1,x
0021B4r 3               
0021B4r 3                               ; --- CUT FOR NATIVE CODING ---
0021B4r 3               
0021B4r 3                               ; restore the return address
0021B4r 3  5A                           phy             ; MSB
0021B5r 3  A5 rr                        lda tmptos
0021B7r 3  48                           pha             ; LSB
0021B8r 3               
0021B8r 3  60           z_r_from:       rts
0021B9r 3               
0021B9r 3               
0021B9r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
0021B9r 3               ; ## "r>input"  tested  Tali Forth
0021B9r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
0021B9r 3                       ; and toin from the Return Stack.
0021B9r 3                       ;
0021B9r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
0021B9r 3                       ; """
0021B9r 3               
0021B9r 3               xt_r_to_input:
0021B9r 3               
0021B9r 3                               ; We arrive here with the return address on the top of the
0021B9r 3                               ; 65c02's stack. We need to move it out of the way first
0021B9r 3  68                           pla
0021BAr 3  85 rr                        sta tmp1
0021BCr 3  68                           pla
0021BDr 3  85 rr                        sta tmp1+1
0021BFr 3               
0021BFr 3                               ; This assumes that insrc is the first of eight bytes and
0021BFr 3                               ; toin+1 the last in the sequence we want to save from the Zero
0021BFr 3                               ; Page. Since we went in reverse order, insrc is now on the top
0021BFr 3                               ; of the Return Stack.
0021BFr 3  A0 00                        ldy #0
0021C1r 3               @loop:
0021C1r 3  68                           pla
0021C2r 3  99 rr rr                     sta insrc,y
0021C5r 3  C8                           iny
0021C6r 3  C0 08                        cpy #8
0021C8r 3  D0 F7                        bne @loop
0021CAr 3               
0021CAr 3                               ; Restore address for return jump
0021CAr 3  A5 rr                        lda tmp1+1
0021CCr 3  48                           pha
0021CDr 3  A5 rr                        lda tmp1
0021CFr 3  48                           pha
0021D0r 3               
0021D0r 3  60           z_r_to_input: 	rts
0021D1r 3               
0021D1r 3               
0021D1r 3               
0021D1r 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
0021D1r 3               ; ## "recurse"  auto  ANS core
0021D1r 3                       ; """https://forth-standard.org/standard/core/RECURSE
0021D1r 3                       ;
0021D1r 3                       ; This word may not be natively compiled
0021D1r 3                       ; """
0021D1r 3               
0021D1r 3               xt_recurse:
0021D1r 3                               ; The whole routine amounts to compiling a reference to
0021D1r 3                               ; the word that is being compiled. First, we save the JSR
0021D1r 3                               ; instruction
0021D1r 3  A0 00                        ldy #0
0021D3r 3               
0021D3r 3  A9 20                        lda #$20        ; opcode for JSR
0021D5r 3  91 rr                        sta (cp),y
0021D7r 3  C8                           iny
0021D8r 3               
0021D8r 3                               ; Next, we save the LSB and MSB of the xt of the word
0021D8r 3                               ; we are currently working on. We first need to see if
0021D8r 3                               ; WORKWORD has the nt (: started the word) or the
0021D8r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
0021D8r 3  24 rr                        bit status
0021DAr 3  70 0C                        bvs @nt_in_workword
0021DCr 3               
0021DCr 3                               ; This is a special :NONAME word. Just copy the xt
0021DCr 3                               ; from WORKWORD into the dictionary.
0021DCr 3  A5 rr                        lda workword
0021DEr 3  91 rr                        sta (cp),y
0021E0r 3  C8                           iny
0021E1r 3  A5 rr                        lda workword+1
0021E3r 3  91 rr                        sta (cp),y
0021E5r 3  C8                           iny
0021E6r 3  80 1B                        bra @update_cp
0021E8r 3               
0021E8r 3               @nt_in_workword:
0021E8r 3                               ; This is a regular : word, so the xt is four bytes down
0021E8r 3                               ; from the nt which we saved in WORKWORD. We could probably
0021E8r 3                               ; use NAME>INT here but this is going to be faster, and
0021E8r 3                               ; fast counts with recursion
0021E8r 3  A5 rr                        lda workword            ; LSB
0021EAr 3  18                           clc
0021EBr 3  69 04                        adc #4
0021EDr 3  85 rr                        sta tmp1
0021EFr 3  A5 rr                        lda workword+1          ; MSB
0021F1r 3  69 00                        adc #0
0021F3r 3  85 rr                        sta tmp1+1
0021F5r 3               
0021F5r 3  B2 rr                        lda (tmp1)
0021F7r 3  91 rr                        sta (cp),y
0021F9r 3  5A                           phy
0021FAr 3  A0 01                        ldy #1
0021FCr 3  B1 rr                        lda (tmp1),y
0021FEr 3  7A                           ply
0021FFr 3  C8                           iny
002200r 3  91 rr                        sta (cp),y
002202r 3  C8                           iny
002203r 3               
002203r 3               @update_cp:
002203r 3  98                           tya
002204r 3  18                           clc
002205r 3  65 rr                        adc cp
002207r 3  85 rr                        sta cp
002209r 3  90 02                        bcc @done
00220Br 3  E6 rr                        inc cp+1
00220Dr 3               @done:
00220Dr 3  60           z_recurse:      rts
00220Er 3               
00220Er 3               
00220Er 3               
00220Er 3               ; ## REFILL ( -- f ) "Refill the input buffer"
00220Er 3               ; ## "refill"  tested  ANS core ext
00220Er 3                       ; """https://forth-standard.org/standard/core/REFILL
00220Er 3                       ; Attempt to fill the input buffer from the input source, returning
00220Er 3                       ; a true flag if successful. When the input source is the user input
00220Er 3                       ; device, attempt to receive input into the terminal input buffer. If
00220Er 3                       ; successful, make the result the input buffer, set >IN to zero, and
00220Er 3                       ; return true. Receipt of a line containing no characters is considered
00220Er 3                       ; successful. If there is no input available from the current input
00220Er 3                       ; source, return false. When the input source is a string from EVALUATE,
00220Er 3                       ; return false and perform no other action." See
00220Er 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
00220Er 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
00220Er 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
00220Er 3                       ; entire block as a 1024 byte string.
00220Er 3                       ; """"
00220Er 3               
00220Er 3               xt_refill:
00220Er 3                               ; Get input source from SOURCE-ID. This is an
00220Er 3                               ; optimized version of a subroutine jump to SOURCE-ID
00220Er 3  A5 rr                        lda insrc               ; cheat: We only check LSB
002210r 3  D0 2D                        bne @src_not_kbd
002212r 3               
002212r 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
002212r 3                               ; with ACCEPT, which wants the address of the current input
002212r 3                               ; buffer NOS and the max number of characters to accept TOS
002212r 3  CA                           dex
002213r 3  CA                           dex
002214r 3  CA                           dex
002215r 3  CA                           dex
002216r 3               
002216r 3  A5 rr                        lda cib                 ; address of CIB is NOS
002218r 3  95 02                        sta 2,x
00221Ar 3  A5 rr                        lda cib+1
00221Cr 3  95 03                        sta 3,x
00221Er 3               
00221Er 3  64 rr                        stz ciblen              ; go in with empty buffer
002220r 3  64 rr                        stz ciblen+1
002222r 3               
002222r 3  A9 FF                        lda #bsize              ; max number of chars is TOS
002224r 3  95 00                        sta 0,x
002226r 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
002228r 3               
002228r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
00222Br 3               
00222Br 3                               ; ACCEPT returns the number of characters accepted, which
00222Br 3                               ; belong in CIBLEN
00222Br 3  B5 00                        lda 0,x
00222Dr 3  85 rr                        sta ciblen
00222Fr 3  B5 01                        lda 1,x
002231r 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
002233r 3               
002233r 3                               ; make >IN point to beginning of buffer
002233r 3  64 rr                        stz toin
002235r 3  64 rr                        stz toin+1
002237r 3               
002237r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
002239r 3  95 00                        sta 0,x
00223Br 3  95 01                        sta 1,x
00223Dr 3               
00223Dr 3  80 10                        bra @done
00223Fr 3               
00223Fr 3               @src_not_kbd:
00223Fr 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
00223Fr 3                               ; memory or a file (remember, no blocks in this version).
00223Fr 3                               ; If source is a string, we were given the flag -1 ($FFFF)
00223Fr 3  1A                           inc
002240r 3  D0 08                        bne @src_not_string
002242r 3               
002242r 3                               ; Simply return FALSE flag as per specification
002242r 3  CA                           dex
002243r 3  CA                           dex
002244r 3  74 00                        stz 0,x
002246r 3  74 01                        stz 1,x
002248r 3               
002248r 3  80 05                        bra z_refill
00224Ar 3               
00224Ar 3               @src_not_string:
00224Ar 3                               ; Since we don't have blocks, this must mean that we are trying
00224Ar 3                               ; to read from a file. However, we don't have files yet, so we
00224Ar 3                               ; report an error and jump to ABORT.
00224Ar 3  A9 01                        lda #err_badsource
00224Cr 3  4C rr rr                     jmp error
00224Fr 3               @done:
00224Fr 3  60           z_refill:       rts
002250r 3               
002250r 3               
002250r 3               
002250r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
002250r 3               ; ## "repeat"  auto  ANS core
002250r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
002250r 3               
002250r 3               xt_repeat:
002250r 3                               ; Run again first
002250r 3  20 rr rr                     jsr xt_again
002253r 3               
002253r 3                               ; Stuff HERE in for the branch address
002253r 3                               ; to get out of the loop
002253r 3  20 rr rr                     jsr xt_here
002256r 3  20 rr rr                     jsr xt_swap
002259r 3  20 rr rr                     jsr xt_store
00225Cr 3               
00225Cr 3  60           z_repeat:       rts
00225Dr 3               
00225Dr 3               
00225Dr 3               
00225Dr 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
00225Dr 3               ; ## "]"  auto  ANS core
00225Dr 3                       ; """https://forth-standard.org/standard/right-bracket
00225Dr 3                       ; This is an immediate word.
00225Dr 3                       ; """
00225Dr 3               xt_right_bracket:
00225Dr 3  A9 FF                        lda #$FF
00225Fr 3  85 rr                        sta state
002261r 3  85 rr                        sta state+1
002263r 3               z_right_bracket:
002263r 3  60                           rts
002264r 3               
002264r 3               
002264r 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
002264r 3               ; ## "root-wordlist"  tested  Tali Editor
002264r 3               xt_root_wordlist:
002264r 3  CA                           dex             ; The WID for the Root wordlist is 3.
002265r 3  CA                           dex
002266r 3  A9 03                        lda #3
002268r 3  95 00                        sta 0,x
00226Ar 3  74 01                        stz 1,x
00226Cr 3               
00226Cr 3               z_root_wordlist:
00226Cr 3  60                           rts
00226Dr 3               
00226Dr 3               
00226Dr 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
00226Dr 3               ; ## "rot"  auto  ANS core
00226Dr 3                       ; """https://forth-standard.org/standard/core/ROT
00226Dr 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
00226Dr 3                       ; on top!
00226Dr 3                       ; """
00226Dr 3               
00226Dr 3               xt_rot:
00226Dr 3  20 rr rr                     jsr underflow_3
002270r 3               
002270r 3  B4 05                        ldy 5,x         ; MSB first
002272r 3  B5 03                        lda 3,x
002274r 3  95 05                        sta 5,x
002276r 3  B5 01                        lda 1,x
002278r 3  95 03                        sta 3,x
00227Ar 3  94 01                        sty 1,x
00227Cr 3               
00227Cr 3  B4 04                        ldy 4,x         ; LSB next
00227Er 3  B5 02                        lda 2,x
002280r 3  95 04                        sta 4,x
002282r 3  B5 00                        lda 0,x
002284r 3  95 02                        sta 2,x
002286r 3  94 00                        sty 0,x
002288r 3               
002288r 3  60           z_rot:          rts
002289r 3               
002289r 3               
002289r 3               
002289r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
002289r 3               ; ## "rshift"  auto  ANS core
002289r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
002289r 3               xt_rshift:
002289r 3  20 rr rr                     jsr underflow_2
00228Cr 3               
00228Cr 3                               ; We shift maximal by 16 bits, mask everything else
00228Cr 3  B5 00                        lda 0,x
00228Er 3  29 0F                        and #%00001111
002290r 3  F0 08                        beq @done               ; if 0 shifts, quit
002292r 3               
002292r 3  A8                           tay
002293r 3               @loop:
002293r 3  56 03                        lsr 3,x
002295r 3  76 02                        ror 2,x
002297r 3  88                           dey
002298r 3  D0 F9                        bne @loop
00229Ar 3               @done:
00229Ar 3  E8                           inx
00229Br 3  E8                           inx
00229Cr 3               
00229Cr 3  60           z_rshift:       rts
00229Dr 3               
00229Dr 3               
00229Dr 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
00229Dr 3               ; ## "s\""  auto  ANS core
00229Dr 3                       ; """https://forth-standard.org/standard/core/Seq
00229Dr 3                       ; Store address and length of string given, returning ( addr u ).
00229Dr 3                       ; ANS core claims this is compile-only, but the file set expands it
00229Dr 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
00229Dr 3                       ; are evil. We follow general usage. This is just like S" except
00229Dr 3                       ; that it allows for some special escaped characters.
00229Dr 3                       ; """
00229Dr 3               
00229Dr 3               xt_s_backslash_quote:
00229Dr 3                               ; tmp2 will be used to determine if we are handling
00229Dr 3                               ; escaped characters or not. In this case, we are,
00229Dr 3                               ; so set it to $FF (the upper byte will be used to
00229Dr 3                               ; determine if we just had a \ and the next character
00229Dr 3                               ; needs to be modifed as an escaped character).
00229Dr 3  A9 FF                        lda #$FF
00229Fr 3  85 rr                        sta tmp2
0022A1r 3  64 rr                        stz tmp2+1
0022A3r 3               
0022A3r 3                               ; Now that the flag is set, jump into s_quote to process
0022A3r 3                               ; the string.
0022A3r 3  20 rr rr                     jsr s_quote_start
0022A6r 3               @done:
0022A6r 3               z_s_backslash_quote:
0022A6r 3  60                           rts
0022A7r 3               
0022A7r 3               
0022A7r 3               ; This is a helper function for s_backslash_quote to convert a character
0022A7r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
0022A7r 3               convert_hex_value:
0022A7r 3               
0022A7r 3  C9 41                cmp #'A'
0022A9r 3  90 07                bcc @digit
0022ABr 3               
0022ABr 3                       ; It's A-F
0022ABr 3  29 DF                and #$DF                ; Make it uppercase.
0022ADr 3  38                   sec
0022AEr 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
0022B0r 3  80 03                bra @done
0022B2r 3               
0022B2r 3               @digit:
0022B2r 3                       ; It's 0-9
0022B2r 3  38                   sec
0022B3r 3  E9 30                sbc #'0'
0022B5r 3               
0022B5r 3               @done:
0022B5r 3  60                   rts
0022B6r 3               
0022B6r 3               
0022B6r 3               
0022B6r 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
0022B6r 3               ; ## "search-wordlist" auto ANS search
0022B6r 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
0022B6r 3               
0022B6r 3               xt_search_wordlist:
0022B6r 3  20 rr rr                     jsr underflow_3
0022B9r 3               
0022B9r 3                               ; Set up tmp1 with the wordlist indicated by wid
0022B9r 3                               ; on the stack. Start by putting the base address
0022B9r 3                               ; of the wordlists in tmp2.
0022B9r 3  A5 rr                        lda up
0022BBr 3  18                           clc
0022BCr 3  69 06                        adc #wordlists_offset
0022BEr 3  85 rr                        sta tmp2
0022C0r 3  A5 rr                        lda up+1
0022C2r 3  69 00                        adc #0          ; Adding carry
0022C4r 3  85 rr                        sta tmp2+1
0022C6r 3               
0022C6r 3                               ; Add the wid (in cells) to the base address.
0022C6r 3  B5 00                        lda 0,x
0022C8r 3  0A                           asl             ; Convert wid to offset in cells (x2)
0022C9r 3  65 rr                        adc tmp2
0022CBr 3  85 rr                        sta tmp2
0022CDr 3  90 02                        bcc @1
0022CFr 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
0022D1r 3               
0022D1r 3                               ; tmp2 now holds the address of the dictionary pointer
0022D1r 3                               ; for the given wordlist.
0022D1r 3               @1:
0022D1r 3                               ; Remove the wid from the stack.
0022D1r 3  E8                           inx
0022D2r 3  E8                           inx
0022D3r 3               
0022D3r 3                               ; check for special case of an empty string (length zero)
0022D3r 3  B5 00                        lda 0,x
0022D5r 3  15 01                        ora 1,x
0022D7r 3  D0 03                        bne @check_wordlist
0022D9r 3  4C rr rr                     jmp @done
0022DCr 3               
0022DCr 3               @check_wordlist:
0022DCr 3                               ; Check for special case of empty wordlist
0022DCr 3                               ; (dictionary pointer, in tmp2, is 0)
0022DCr 3  A5 rr                        lda tmp2
0022DEr 3  05 rr                        ora tmp2+1
0022E0r 3  D0 03                        bne @have_string
0022E2r 3  4C rr rr                     jmp @done
0022E5r 3               
0022E5r 3               @have_string:
0022E5r 3                               ; set up first loop iteration
0022E5r 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
0022E7r 3  85 rr                        sta tmp1
0022E9r 3               
0022E9r 3  E6 rr                        inc tmp2                ; Move to the upper byte
0022EBr 3  D0 02                        bne @2
0022EDr 3  E6 rr                        inc tmp2+1
0022EFr 3               @2:
0022EFr 3  B2 rr                        lda (tmp2)
0022F1r 3  85 rr                        sta tmp1+1
0022F3r 3               
0022F3r 3                               ; Reuse tmp2 to hold the address of the mystery string.
0022F3r 3  B5 02                        lda 2,x                 ; Address of mystery string
0022F5r 3  85 rr                        sta tmp2
0022F7r 3  B5 03                        lda 3,x
0022F9r 3  85 rr                        sta tmp2+1
0022FBr 3               
0022FBr 3               @loop:
0022FBr 3                               ; first quick test: Are strings the same length?
0022FBr 3  B2 rr                        lda (tmp1)
0022FDr 3  D5 00                        cmp 0,x
0022FFr 3  D0 7B                        bne @next_entry
002301r 3               
002301r 3               @compare_string:
002301r 3                               ; are the same length, so we now have to compare each
002301r 3                               ; character
002301r 3               
002301r 3                               ; second quick test: Is the first character the same?
002301r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
002303r 3               
002303r 3                               ; Lowercase the incoming charcter.
002303r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
002305r 3  B0 07                        bcs @compare_first
002307r 3  C9 41                        cmp #$41        ; ASCII 'A'
002309r 3  90 03                        bcc @compare_first
00230Br 3               
00230Br 3                               ; An uppercase letter has been located.  Make it
00230Br 3                               ; lowercase.
00230Br 3  18                           clc
00230Cr 3  69 20                        adc #$20
00230Er 3               
00230Er 3               @compare_first:
00230Er 3  A0 08                        ldy #8          ; Offset in nt to name
002310r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
002312r 3  D0 68                        bne @next_entry
002314r 3               
002314r 3                               ; string length are the same and the first character is the
002314r 3                               ; same. If the length of the string is 1, we're already done
002314r 3  B5 00                        lda 0,x
002316r 3  3A                           dec
002317r 3  F0 2C                        beq @success
002319r 3               
002319r 3                               ; No such luck: The strings are the same length and the first
002319r 3                               ; char is the same, but the word is more than one char long.
002319r 3                               ; So we suck it up and compare every single character. We go
002319r 3                               ; from back to front, because words like CELLS and CELL+ would
002319r 3                               ; take longer otherwise. We can also shorten the loop by one
002319r 3                               ; because we've already compared the first char.
002319r 3               
002319r 3                               ; The string of the word we're testing against is 8 bytes down
002319r 3  A5 rr                        lda tmp1
00231Br 3  48                           pha             ; Preserve tmp1 on the return stack.
00231Cr 3  18                           clc
00231Dr 3  69 08                        adc #8
00231Fr 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
002321r 3  A5 rr                        lda tmp1+1
002323r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
002324r 3  69 00                        adc #0          ; we only need the carry
002326r 3  85 rr                        sta tmp1+1
002328r 3               
002328r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
00232Ar 3  88                           dey
00232Br 3               
00232Br 3               @string_loop:
00232Br 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
00232Dr 3               
00232Dr 3                               ; Lowercase the incoming charcter.
00232Dr 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
00232Fr 3  B0 07                        bcs @check_char
002331r 3  C9 41                        cmp #$41        ; ASCII 'A'
002333r 3  90 03                        bcc @check_char
002335r 3               
002335r 3                               ; An uppercase letter has been located.  Make it
002335r 3                               ; lowercase.
002335r 3  18                           clc
002336r 3  69 20                        adc #$20
002338r 3               @check_char:
002338r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
00233Ar 3  D0 3A                        bne @next_entry_tmp1
00233Cr 3               
00233Cr 3  88                           dey
00233Dr 3  D0 EC                        bne @string_loop
00233Fr 3               
00233Fr 3               @success_tmp1:
00233Fr 3  68                           pla             ; Restore tmp1 from the return stack.
002340r 3  85 rr                        sta tmp1+1
002342r 3  68                           pla
002343r 3  85 rr                        sta tmp1
002345r 3               
002345r 3               @success:
002345r 3                               ; The strings match. Drop the count and put correct nt TOS
002345r 3  E8                           inx
002346r 3  E8                           inx
002347r 3  A5 rr                        lda tmp1
002349r 3  95 00                        sta 0,x
00234Br 3  A5 rr                        lda tmp1+1
00234Dr 3  95 01                        sta 1,x
00234Fr 3               
00234Fr 3                               ; Change the nt into an xt, but save a copy of the nt
00234Fr 3                               ; to look up whether the word is immediate or not.
00234Fr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002352r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
002355r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
002358r 3               
002358r 3  A0 00                        ldy #0                  ; Prepare flag
00235Ar 3               
00235Ar 3                               ; The flags are in the second byte of the header
00235Ar 3  F6 00                        inc 0,x
00235Cr 3  D0 02                        bne @3
00235Er 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
002360r 3               @3:
002360r 3  A1 00                        lda (0,x)               ; ( xt char )
002362r 3  29 04                        and #IM
002364r 3  D0 08                        bne @immediate          ; bit set, we're immediate
002366r 3               
002366r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
002368r 3  95 00                        sta 0,x
00236Ar 3  95 01                        sta 1,x
00236Cr 3  80 28                        bra @done_nodrop
00236Er 3               
00236Er 3               @immediate:
00236Er 3  A9 01                        lda #1                  ; We're immediate, return 1
002370r 3  95 00                        sta 0,x
002372r 3  74 01                        stz 1,x
002374r 3               
002374r 3  80 20                        bra @done_nodrop
002376r 3               
002376r 3               @next_entry_tmp1:
002376r 3  68                           pla             ; Restore tmp1 from the return stack.
002377r 3  85 rr                        sta tmp1+1
002379r 3  68                           pla
00237Ar 3  85 rr                        sta tmp1
00237Cr 3               @next_entry:
00237Cr 3                               ; Not the same, so we get the next word. Next header
00237Cr 3                               ; address is two bytes down
00237Cr 3  A0 02                        ldy #2
00237Er 3  B1 rr                        lda (tmp1),y
002380r 3  48                           pha
002381r 3  C8                           iny
002382r 3  B1 rr                        lda (tmp1),y
002384r 3  85 rr                        sta tmp1+1
002386r 3  68                           pla
002387r 3  85 rr                        sta tmp1
002389r 3               
002389r 3                               ; If we got a zero, we've walked the whole Dictionary and
002389r 3                               ; return as a failure, otherwise try again
002389r 3  05 rr                        ora tmp1+1
00238Br 3  F0 03                        beq @fail_done
00238Dr 3  4C rr rr                     jmp @loop
002390r 3               
002390r 3               @fail_done:
002390r 3  74 02                        stz 2,x         ; failure flag
002392r 3  74 03                        stz 3,x
002394r 3               @done:
002394r 3  E8                           inx
002395r 3  E8                           inx
002396r 3               @done_nodrop:
002396r 3               z_search_wordlist:
002396r 3  60                           rts
002397r 3               
002397r 3               
002397r 3               
002397r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
002397r 3               ; ## "see" tested  ANS tools
002397r 3                       ; """https://forth-standard.org/standard/tools/SEE
002397r 3                       ; SEE takes the name of a word and prints its name token (nt),
002397r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
002397r 3                       ; code and disassembles it.
002397r 3                       ; """
002397r 3               
002397r 3               xt_see:
002397r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00239Ar 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
00239Dr 3               
00239Dr 3                               ; If we got back a zero we don't know that word and so we quit
00239Dr 3                               ; with an error
00239Dr 3  B5 00                        lda 0,x
00239Fr 3  15 01                        ora 1,x
0023A1r 3  D0 05                        bne @1
0023A3r 3               
0023A3r 3  A9 05                        lda #err_noname
0023A5r 3  4C rr rr                     jmp error
0023A8r 3               @1:
0023A8r 3  20 rr rr                     jsr xt_cr
0023ABr 3               
0023ABr 3                               ; We have a legal word, so let's get serious. Save the current
0023ABr 3                               ; number base and use hexadecimal instead.
0023ABr 3  A5 rr                        lda base
0023ADr 3  48                           pha
0023AEr 3  20 rr rr                     jsr xt_hex
0023B1r 3               
0023B1r 3  A9 0A                        lda #str_see_nt
0023B3r 3  20 rr rr                     jsr print_string_no_lf
0023B6r 3               
0023B6r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0023B9r 3  20 rr rr                     jsr xt_u_dot
0023BCr 3  20 rr rr                     jsr xt_space            ; ( nt )
0023BFr 3               
0023BFr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0023C2r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
0023C5r 3               
0023C5r 3  A9 0B                        lda #str_see_xt
0023C7r 3  20 rr rr                     jsr print_string_no_lf
0023CAr 3               
0023CAr 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
0023CDr 3  20 rr rr                     jsr xt_u_dot
0023D0r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
0023D3r 3               
0023D3r 3                               ; We print letters for flags and then later follow it with 1 or
0023D3r 3                               ; 0 to mark if which flag is set
0023D3r 3  A9 09                        lda #str_see_flags
0023D5r 3  20 rr rr                     jsr print_string_no_lf
0023D8r 3               
0023D8r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
0023DBr 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
0023DEr 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
0023E1r 3               
0023E1r 3  B5 00                        lda 0,x
0023E3r 3               
0023E3r 3                               ; This is crude, but for the moment it is good enough
0023E3r 3  A0 06                        ldy #6                  ; Not all bits are used
0023E5r 3               @flag_loop:
0023E5r 3  48                           pha
0023E6r 3  29 01                        and #%00000001
0023E8r 3  18                           clc
0023E9r 3  69 30                        adc #$30                ; ASCII "0"
0023EBr 3  20 rr rr                     jsr emit_a
0023EEr 3  20 rr rr                     jsr xt_space
0023F1r 3               
0023F1r 3  68                           pla
0023F2r 3  6A                           ror                     ; Next flag
0023F3r 3               
0023F3r 3  88                           dey
0023F4r 3  D0 EF                        bne @flag_loop
0023F6r 3               
0023F6r 3  20 rr rr                     jsr xt_cr
0023F9r 3               
0023F9r 3  E8                           inx
0023FAr 3  E8                           inx                     ; ( nt xt )
0023FBr 3               
0023FBr 3                               ; Figure out the size
0023FBr 3  A9 0C                        lda #str_see_size
0023FDr 3  20 rr rr                     jsr print_string_no_lf
002400r 3               
002400r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
002403r 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
002406r 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
002409r 3  20 rr rr                     jsr xt_decimal
00240Cr 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
00240Fr 3  20 rr rr                     jsr xt_hex
002412r 3  20 rr rr                     jsr xt_cr
002415r 3               
002415r 3                               ; Dump hex and disassemble
002415r 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
002418r 3  20 rr rr                     jsr xt_dump
00241Br 3  20 rr rr                     jsr xt_cr
00241Er 3  20 rr rr                     jsr xt_disasm
002421r 3               
002421r 3  68                           pla
002422r 3  85 rr                        sta base
002424r 3               
002424r 3  60           z_see:          rts
002425r 3               
002425r 3               
002425r 3               
002425r 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
002425r 3               ; ## "set-current" auto ANS search
002425r 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
002425r 3               
002425r 3               xt_set_current:
002425r 3  20 rr rr                     jsr underflow_1
002428r 3               
002428r 3                               ; Save the value from the data stack.
002428r 3  A0 04                        ldy #current_offset
00242Ar 3  B5 00                        lda 0,x         ; CURRENT is byte variable
00242Cr 3  91 rr                        sta (up),y      ; so only the LSB is used.
00242Er 3               
00242Er 3  E8                           inx
00242Fr 3  E8                           inx
002430r 3               
002430r 3  60           z_set_current:  rts
002431r 3               
002431r 3               
002431r 3               
002431r 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
002431r 3               ; ## "set-order" auto ANS search
002431r 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
002431r 3               
002431r 3               xt_set_order:
002431r 3                               ; Test for -1 TOS
002431r 3  A9 FF                        lda #$FF
002433r 3  D5 01                        cmp 1,x
002435r 3  D0 12                        bne @start
002437r 3  D5 00                        cmp 0,x
002439r 3  D0 0E                        bne @start
00243Br 3               
00243Br 3                               ; There is a -1 TOS.  Replace it with the default
00243Br 3                               ; search order, which is just the FORTH-WORDLIST.
00243Br 3  CA                           dex             ; Make room for the count.
00243Cr 3  CA                           dex
00243Dr 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
00243Fr 3  A9 03                        lda #3
002441r 3  95 02                        sta 2,x
002443r 3  74 01                        stz 1,x         ; Count is 1.
002445r 3  A9 01                        lda #1
002447r 3  95 00                        sta 0,x
002449r 3               
002449r 3                               ; Continue processing with ( forth-wordlist 1 -- )
002449r 3               @start:
002449r 3                               ; Set #ORDER - the number of wordlists in the search order.
002449r 3  A0 1E                        ldy #num_order_offset
00244Br 3  B5 00                        lda 0,x
00244Dr 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
00244Fr 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
002451r 3                                               ; Only the low byte is saved in tmp1 as
002451r 3                                               ; only 8 wordlists are allowed.
002451r 3               
002451r 3  E8                           inx             ; Drop the count off the data stack.
002452r 3  E8                           inx
002453r 3               
002453r 3                               ; Check if there are zero wordlists.
002453r 3  A5 rr                        lda tmp1
002455r 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
002457r 3               
002457r 3                               ; Move the wordlist ids from the data stack to the search order.
002457r 3  A0 1F                        ldy #search_order_offset
002459r 3               @loop:
002459r 3                               ; Move one wordlist id over into the search order.
002459r 3  B5 00                        lda 0,x         ; The search order is a byte array
00245Br 3  91 rr                        sta (up),y      ; so only save the LSB
00245Dr 3  C8                           iny
00245Er 3               
00245Er 3                               ; Remove it from the data stack.
00245Er 3  E8                           inx
00245Fr 3  E8                           inx
002460r 3               
002460r 3                               ; See if that was the last one to process (first in the list).
002460r 3  C6 rr                        dec tmp1
002462r 3  D0 F5                        bne @loop
002464r 3               
002464r 3               @done:
002464r 3  60           z_set_order:    rts
002465r 3               
002465r 3               
002465r 3               
002465r 3               
002465r 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
002465r 3               ; ## "s""  auto  ANS core
002465r 3                       ; """https://forth-standard.org/standard/core/Sq
002465r 3                       ; Store address and length of string given, returning ( addr u ).
002465r 3                       ; ANS core claims this is compile-only, but the file set expands it
002465r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
002465r 3                       ; are evil. We follow general usage.
002465r 3                       ;
002465r 3                       ; Can also be realized as
002465r 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
002465r 3                       ; but it is used so much we want it in code.
002465r 3                       ; """
002465r 3               
002465r 3               xt_s_quote:
002465r 3                               ; tmp2 will be used to determine if we are handling
002465r 3                               ; escaped characters or not.  In this case, we are
002465r 3                               ; not, so set it to zero.
002465r 3  64 rr                        stz tmp2
002467r 3  64 rr                        stz tmp2+1
002469r 3               
002469r 3               s_quote_start:
002469r 3                               ; Make room on the data stack for the address.
002469r 3  CA                           dex
00246Ar 3  CA                           dex
00246Br 3                               ; Make room on the data stack for the count.
00246Br 3  CA                           dex
00246Cr 3  CA                           dex
00246Dr 3               
00246Dr 3                               ; Put a jmp over the string data with address to be filled
00246Dr 3                               ; in later.
00246Dr 3  A9 4C                        lda #$4C
00246Fr 3  20 rr rr                     jsr cmpl_a
002472r 3               
002472r 3                               ; Address to be filled in later, just use $4C for the moment
002472r 3  20 rr rr                     jsr cmpl_a
002475r 3  20 rr rr                     jsr cmpl_a
002478r 3               
002478r 3                               ; Save the current value of HERE on the data stack for the
002478r 3                               ; address of the string.
002478r 3  A5 rr                        lda cp
00247Ar 3  95 02                        sta 2,x
00247Cr 3  A5 rr                        lda cp+1
00247Er 3  95 03                        sta 3,x
002480r 3               
002480r 3               @savechars_loop:
002480r 3                               ; Start saving the string into the dictionary up to the
002480r 3                               ; ending double quote. First, check to see if the input
002480r 3                               ; buffer is empty.
002480r 3  A5 rr                        lda toin+1              ; MSB
002482r 3  C5 rr                        cmp ciblen+1
002484r 3  90 2A                        bcc @input_fine         ; unsigned comparison
002486r 3               
002486r 3  A5 rr                        lda toin                ; LSB
002488r 3  C5 rr                        cmp ciblen
00248Ar 3  90 24                        bcc @input_fine
00248Cr 3               
00248Cr 3                               ; Input buffer is empty. Refill it. Refill calls accept,
00248Cr 3                               ; which uses tmp2 and tmp3. Save and restore them.
00248Cr 3  A5 rr                        lda tmp2
00248Er 3  48                           pha
00248Fr 3  A5 rr                        lda tmp2+1
002491r 3  48                           pha
002492r 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
002494r 3  48                           pha
002495r 3               
002495r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
002498r 3               
002498r 3  68                           pla
002499r 3  85 rr                        sta tmp3
00249Br 3  68                           pla
00249Cr 3  85 rr                        sta tmp2+1
00249Er 3  68                           pla
00249Fr 3  85 rr                        sta tmp2
0024A1r 3               
0024A1r 3                               ; Check result of refill.
0024A1r 3  B5 00                        lda 0,x
0024A3r 3  15 01                        ora 1,x
0024A5r 3  D0 05                        bne @refill_ok
0024A7r 3               
0024A7r 3                               ; Something when wrong with refill.
0024A7r 3  A9 06                        lda #err_refill
0024A9r 3  4C rr rr                     jmp error
0024ACr 3               
0024ACr 3               @refill_ok:
0024ACr 3                               ; Remove the refill flag from the data stack.
0024ACr 3  E8                           inx
0024ADr 3  E8                           inx
0024AEr 3               
0024AEr 3                               ; For refill success, jump back up to the empty check, just in
0024AEr 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
0024AEr 3                               ; input)
0024AEr 3  80 D0                        bra @savechars_loop
0024B0r 3               
0024B0r 3               @input_fine:
0024B0r 3                               ; There should be at least one valid char to use.
0024B0r 3                               ; Calculate it's address at CIB+TOIN into tmp1
0024B0r 3  A5 rr                        lda cib
0024B2r 3  18                           clc
0024B3r 3  65 rr                        adc toin        ; LSB
0024B5r 3  85 rr                        sta tmp1
0024B7r 3  A5 rr                        lda cib+1
0024B9r 3  65 rr                        adc toin+1      ; MSB
0024BBr 3  85 rr                        sta tmp1+1
0024BDr 3               
0024BDr 3                               ; Get the character
0024BDr 3  B2 rr                        lda (tmp1)
0024BFr 3               
0024BFr 3                               ; Check to see if we are handling escaped characters.
0024BFr 3  24 rr                        bit tmp2
0024C1r 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
0024C3r 3  4C rr rr                     jmp @regular_char
0024C6r 3               
0024C6r 3               @handle_escapes:
0024C6r 3                               ; We are handling escaped characters.  See if we have
0024C6r 3                               ; already seen the backslash.
0024C6r 3  24 rr                        bit tmp2+1
0024C8r 3  30 03                        bmi @escaped
0024CAr 3  4C rr rr                     jmp @not_escaped
0024CDr 3               
0024CDr 3               @escaped:
0024CDr 3               
0024CDr 3                               ; We have seen a backslash (previous character). Check to see if
0024CDr 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
0024CDr 3                               ; be clear in that case )
0024CDr 3  70 22                        bvs @check_esc_chars
0024CFr 3               
0024CFr 3                               ; We are in the middle of a \x sequence. Check to see if we
0024CFr 3                               ; are on the first or second digit.
0024CFr 3  A9 01                        lda #1
0024D1r 3  24 rr                        bit tmp2+1
0024D3r 3  D0 10                        bne @esc_x_second_digit
0024D5r 3               
0024D5r 3                               ; First digit.
0024D5r 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
0024D7r 3  B2 rr                        lda (tmp1)  ; Get the char again.
0024D9r 3               
0024D9r 3                               ; Convert to hex
0024D9r 3  20 rr rr                     jsr convert_hex_value
0024DCr 3               
0024DCr 3                               ; This is the upper nybble, so move it up.
0024DCr 3  0A                           asl
0024DDr 3  0A                           asl
0024DEr 3  0A                           asl
0024DFr 3  0A                           asl
0024E0r 3  85 rr                        sta tmp3    ; Save it for later.
0024E2r 3  4C rr rr                     jmp @next_character
0024E5r 3               
0024E5r 3               @esc_x_second_digit:
0024E5r 3               
0024E5r 3                               ; We are on the second hex digit of a \x sequence. Clear the
0024E5r 3                               ; escaped character flag (because we are handling it right
0024E5r 3                               ; here)
0024E5r 3  64 rr                        stz tmp2+1
0024E7r 3  B2 rr                        lda (tmp1)
0024E9r 3               
0024E9r 3                               ; Convert to hex, combine with value in tmp3
0024E9r 3  20 rr rr                     jsr convert_hex_value
0024ECr 3  05 rr                        ora tmp3
0024EEr 3               
0024EEr 3  4C rr rr                     jmp @save_character
0024F1r 3               
0024F1r 3               @check_esc_chars:
0024F1r 3                               ; Clear the escaped character flag (because we are
0024F1r 3                               ; handling it right here)
0024F1r 3  64 rr                        stz tmp2+1
0024F3r 3               
0024F3r 3                               ; Process the escaped character
0024F3r 3               @check_esc_a:
0024F3r 3  C9 61                        cmp #'a'
0024F5r 3  D0 05                        bne @check_esc_b
0024F7r 3               
0024F7r 3                               ; BEL (ASCII value 7)
0024F7r 3  A9 07                        lda #7
0024F9r 3  4C rr rr                     jmp @save_character
0024FCr 3               
0024FCr 3               @check_esc_b:
0024FCr 3  C9 62                        cmp #'b'
0024FEr 3  D0 05                        bne @check_esc_e
002500r 3               
002500r 3                               ; Backspace (ASCII value 8)
002500r 3  A9 08                        lda #8
002502r 3  4C rr rr                     jmp @save_character
002505r 3               
002505r 3               @check_esc_e:
002505r 3  C9 65                        cmp #'e'
002507r 3  D0 04                        bne @check_esc_f
002509r 3               
002509r 3                               ; ESC (ASCII value 27)
002509r 3  A9 1B                        lda #27
00250Br 3  80 75                        bra @save_character
00250Dr 3               
00250Dr 3               @check_esc_f:
00250Dr 3  C9 66                        cmp #'f'
00250Fr 3  D0 04                        bne @check_esc_l
002511r 3               
002511r 3                               ; FF (ASCII value 12)
002511r 3  A9 0C                        lda #12
002513r 3  80 6D                        bra @save_character
002515r 3               
002515r 3               @check_esc_l:
002515r 3  C9 6C                        cmp #'l'
002517r 3  D0 04                        bne @check_esc_m
002519r 3               
002519r 3                               ; LF (ASCII value 10)
002519r 3  A9 0A                        lda #10
00251Br 3  80 65                        bra @save_character
00251Dr 3               
00251Dr 3               @check_esc_m:
00251Dr 3                               ; This one is not like the others because we save two
00251Dr 3                               ; characters
00251Dr 3  C9 6D                        cmp #'m'
00251Fr 3  D0 09                        bne @check_esc_n
002521r 3               
002521r 3                               ; CR/LF pair (ASCII values 13, 10)
002521r 3  A9 0D                        lda #13
002523r 3  20 rr rr                     jsr cmpl_a
002526r 3  A9 0A                        lda #10
002528r 3  80 58                        bra @save_character
00252Ar 3               
00252Ar 3               @check_esc_n:
00252Ar 3  C9 6E                        cmp #'n'
00252Cr 3  D0 04                        bne @check_esc_q
00252Er 3               
00252Er 3                               ; newline, impl. dependant, using LF (ASCII values 10)
00252Er 3  A9 0A                        lda #10
002530r 3  80 50                        bra @save_character
002532r 3               
002532r 3               @check_esc_q:
002532r 3  C9 71                        cmp #'q'
002534r 3  D0 04                        bne @check_esc_r
002536r 3               
002536r 3                               ; Double quote (ASCII value 34)
002536r 3  A9 22                        lda #34
002538r 3  80 48                        bra @save_character
00253Ar 3               
00253Ar 3               @check_esc_r:
00253Ar 3  C9 72                        cmp #'r'
00253Cr 3  D0 04                        bne @check_esc_t
00253Er 3               
00253Er 3                               ; CR (ASCII value 13)
00253Er 3  A9 0D                        lda #13
002540r 3  80 40                        bra @save_character
002542r 3               
002542r 3               @check_esc_t:
002542r 3  C9 74                        cmp #'t'
002544r 3  D0 04                        bne @check_esc_v
002546r 3               
002546r 3                               ; Horizontal TAB (ASCII value 9)
002546r 3  A9 09                        lda #9
002548r 3  80 38                        bra @save_character
00254Ar 3               
00254Ar 3               @check_esc_v:
00254Ar 3  C9 76                        cmp #'v'
00254Cr 3  D0 04                        bne @check_esc_z
00254Er 3               
00254Er 3                               ; Vertical TAB (ASCII value 11)
00254Er 3  A9 0B                        lda #11
002550r 3  80 30                        bra @save_character
002552r 3               
002552r 3               @check_esc_z:
002552r 3  C9 7A                        cmp #'z'
002554r 3  D0 04                        bne @check_esc_quote
002556r 3               
002556r 3                               ; NULL (ASCII value 0)
002556r 3  A9 00                        lda #0
002558r 3  80 28                        bra @save_character
00255Ar 3               
00255Ar 3               @check_esc_quote:
00255Ar 3  C9 22                        cmp #$22
00255Cr 3  D0 04                        bne @check_esc_x
00255Er 3               
00255Er 3                               ; Double quote (ASCII value 34)
00255Er 3  A9 22                        lda #34
002560r 3  80 20                        bra @save_character
002562r 3               
002562r 3               @check_esc_x:
002562r 3  C9 78                        cmp #'x'
002564r 3  D0 06                        bne @check_esc_backslash
002566r 3               
002566r 3                               ; This one is difficult. We need to get the next TWO
002566r 3                               ; characters (which might require a refill in the middle)
002566r 3                               ; and combine them as two hex digits. We do this by
002566r 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
002566r 3                               ; and using bit 0 to keep track of which digit we are on.
002566r 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
002568r 3  85 rr                        sta tmp2+1
00256Ar 3  80 19                        bra @next_character
00256Cr 3               
00256Cr 3               @check_esc_backslash:
00256Cr 3  C9 5C                        cmp #$5C
00256Er 3  D0 04                        bne @not_escaped
002570r 3               
002570r 3                               ; Backslash (ASCII value 92)
002570r 3  A9 5C                        lda #92
002572r 3  80 0E                        bra @save_character
002574r 3               
002574r 3               @not_escaped:
002574r 3                               ; Check for the backslash to see if we should escape
002574r 3                               ; the next char.
002574r 3  C9 5C                        cmp #$5C        ; The backslash char
002576r 3  D0 06                        bne @regular_char
002578r 3               
002578r 3                               ; We found a backslash.  Don't save anyhing, but set
002578r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
002578r 3                               ; try to get the next char here as it may require a
002578r 3                               ; refill of the input buffer.
002578r 3  A9 FF                        lda #$FF
00257Ar 3  85 rr                        sta tmp2+1
00257Cr 3  80 07                        bra @next_character
00257Er 3               
00257Er 3               @regular_char:
00257Er 3                               ; Check if the current character is the end of the string.
00257Er 3  C9 22                        cmp #$22        ; ASCII for "
002580r 3  F0 0C                        beq @found_string_end
002582r 3               
002582r 3               @save_character:
002582r 3                               ; If we didn't reach the end of the string, compile this
002582r 3                               ; character into the dictionary
002582r 3  20 rr rr                     jsr cmpl_a
002585r 3               
002585r 3               @next_character:
002585r 3                               ; Move on to the next character.
002585r 3  E6 rr                        inc toin
002587r 3  D0 02                        bne @savechars_loop_longjump
002589r 3  E6 rr                        inc toin+1
00258Br 3               
00258Br 3               @savechars_loop_longjump:
00258Br 3  4C rr rr                     jmp @savechars_loop
00258Er 3               
00258Er 3               @found_string_end:
00258Er 3                               ; Use up the delimiter.
00258Er 3  E6 rr                        inc toin
002590r 3  D0 02                        bne @1
002592r 3  E6 rr                        inc toin+1
002594r 3               @1:
002594r 3                               ; Calculate the length of the string, which is the
002594r 3                               ; difference between cp and the address of the start
002594r 3                               ; of the string (currently saved on the stack).
002594r 3  A5 rr                        lda cp
002596r 3  38                           sec
002597r 3  F5 02                        sbc 2,x
002599r 3  95 00                        sta 0,x         ; LSB
00259Br 3  A5 rr                        lda cp+1
00259Dr 3  F5 03                        sbc 3,x
00259Fr 3  95 01                        sta 1,x         ; MSB
0025A1r 3               
0025A1r 3                               ; Update the address of the jump-over jmp instruction.
0025A1r 3                               ; First determine location of jmp instructions address.
0025A1r 3                               ; It should be 2 bytes before the start of the string.
0025A1r 3                               ; Compute it into tmp1, which is no longer being used.
0025A1r 3  B5 02                        lda 2,x
0025A3r 3  38                           sec
0025A4r 3  E9 02                        sbc #2
0025A6r 3  85 rr                        sta tmp1
0025A8r 3  B5 03                        lda 3,x
0025AAr 3  E9 00                        sbc #0          ; Propagate borrow
0025ACr 3  85 rr                        sta tmp1+1
0025AEr 3               
0025AEr 3                               ; Update the address of the jump to HERE.
0025AEr 3  A5 rr                        lda cp
0025B0r 3  92 rr                        sta (tmp1)
0025B2r 3  A0 01                        ldy #1
0025B4r 3  A5 rr                        lda cp+1
0025B6r 3  91 rr                        sta (tmp1),y
0025B8r 3               
0025B8r 3                               ; What happens next depends on the state (which is bad, but
0025B8r 3                               ; that's the way it works at the moment). If we are
0025B8r 3                               ; interpretating, we save the string to a transient buffer
0025B8r 3                               ; and return that address (used for file calls, see
0025B8r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
0025B8r 3                               ; compiling, we just need SLITERAL
0025B8r 3  A5 rr                        lda state
0025BAr 3  05 rr                        ora state+1             ; paranoid
0025BCr 3  F0 03                        beq @done
0025BEr 3               
0025BEr 3                               ; Jump into the middle of the sliteral word, after the
0025BEr 3                               ; string data has been compiled into the dictionary,
0025BEr 3                               ; because we've already done that step.
0025BEr 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
0025C1r 3               
0025C1r 3               @done:
0025C1r 3  60           z_s_quote:      rts
0025C2r 3               
0025C2r 3               
0025C2r 3               
0025C2r 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
0025C2r 3               ; ## "s>d"  auto  ANS core
0025C2r 3                       ; """https://forth-standard.org/standard/core/StoD"""
0025C2r 3               
0025C2r 3               xt_s_to_d:
0025C2r 3  20 rr rr                     jsr underflow_1
0025C5r 3               
0025C5r 3  CA                           dex
0025C6r 3  CA                           dex
0025C7r 3  74 00                        stz 0,x
0025C9r 3  74 01                        stz 1,x
0025CBr 3               
0025CBr 3  B5 03                        lda 3,x
0025CDr 3  10 04                        bpl @done
0025CFr 3               
0025CFr 3                               ; negative, extend sign
0025CFr 3  D6 00                        dec 0,x
0025D1r 3  D6 01                        dec 1,x
0025D3r 3               @done:
0025D3r 3  60           z_s_to_d:       rts
0025D4r 3               
0025D4r 3               
0025D4r 3               
0025D4r 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
0025D4r 3               ; ## "save-buffers"  tested  ANS block
0025D4r 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
0025D4r 3               
0025D4r 3               xt_save_buffers:
0025D4r 3                               ; Check the buffer status
0025D4r 3  A0 2C                        ldy #buffstatus_offset
0025D6r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
0025D8r 3  C9 03                        cmp #3          ; LSB is needed.
0025DAr 3  D0 12                        bne @done       ; Either not used or not dirty = done!
0025DCr 3               
0025DCr 3                               ; We need to save the block.
0025DCr 3  20 rr rr                     jsr xt_blkbuffer
0025DFr 3  20 rr rr                     jsr xt_buffblocknum
0025E2r 3  20 rr rr                     jsr xt_fetch
0025E5r 3  20 rr rr                     jsr xt_block_write
0025E8r 3               
0025E8r 3                               ; Mark the buffer as clean now.
0025E8r 3  A9 01                        lda #1
0025EAr 3  A0 2C                        ldy #buffstatus_offset
0025ECr 3  91 rr                        sta (up),y
0025EEr 3               
0025EEr 3               @done:
0025EEr 3  60           z_save_buffers: rts
0025EFr 3               
0025EFr 3               
0025EFr 3               
0025EFr 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
0025EFr 3               ; ## "scr"  auto  ANS block ext
0025EFr 3                       ; """https://forth-standard.org/standard/block/SCR"""
0025EFr 3               xt_scr:
0025EFr 3                               ; SCR is at UP + scr_offset
0025EFr 3  CA                           dex
0025F0r 3  CA                           dex
0025F1r 3  18                           clc
0025F2r 3  A5 rr                        lda up
0025F4r 3  69 02                        adc #scr_offset ; Add offset
0025F6r 3  95 00                        sta 0,x
0025F8r 3  A5 rr                        lda up+1
0025FAr 3  69 00                        adc #0          ; Adding carry
0025FCr 3  95 01                        sta 1,x
0025FEr 3               
0025FEr 3  60           z_scr:          rts
0025FFr 3               
0025FFr 3               
0025FFr 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
0025FFr 3               ; ## "search"   auto  ANS string
0025FFr 3                       ; """https://forth-standard.org/standard/string/SEARCH
0025FFr 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
0025FFr 3                       ; addr1 u1). If a match is found the flag will be true and
0025FFr 3                       ; addr3 will have the address of the start of the match and u3 will have
0025FFr 3                       ; the number of characters remaining from the match point to the end
0025FFr 3                       ; of the original string1. If a match is not found, the flag will be
0025FFr 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
0025FFr 3                       ; """
0025FFr 3               
0025FFr 3               xt_search:
0025FFr 3  20 rr rr                     jsr underflow_4
002602r 3               
002602r 3                               ; ANS says if the second string is a zero-length string it
002602r 3                               ; automatically matches.
002602r 3  B5 00                        lda 0,x
002604r 3  15 01                        ora 1,x
002606r 3  D0 0B                        bne @start_search
002608r 3               
002608r 3                               ; The second string is a zero length string.  Just remove
002608r 3                               ; the second string and put a true flag.
002608r 3  E8                           inx             ; Remove u2
002609r 3  E8                           inx
00260Ar 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
00260Cr 3  95 00                        sta 0,x
00260Er 3  95 01                        sta 1,x
002610r 3  4C rr rr                     jmp z_search
002613r 3               
002613r 3               @start_search:
002613r 3                               ; Put an offset (starting at zero) on the stack.
002613r 3  20 rr rr                     jsr xt_zero
002616r 3               
002616r 3               @search_loop:
002616r 3                               ; We stop (not found) when u2 + offset > u1
002616r 3                               ; Calculate u2+offset into tmp1
002616r 3  18                           clc
002617r 3  B5 00                        lda 0,x
002619r 3  75 02                        adc 2,x
00261Br 3  85 rr                        sta tmp1
00261Dr 3  B5 01                        lda 1,x
00261Fr 3  75 03                        adc 3,x
002621r 3               
002621r 3               
002621r 3                               ; Compare to u1. Start with the high byte
002621r 3  D5 07                        cmp 7,x
002623r 3  90 12                        bcc @init_comparison ; Obviously less
002625r 3  D0 06                        bne @not_found
002627r 3               
002627r 3                               ; The upper address byte matched - check the lower byte
002627r 3                               ; Load u1 first so we can use just a carry to check.
002627r 3  B5 06                        lda 6,x
002629r 3  C5 rr                        cmp tmp1
00262Br 3  B0 0A                        bcs @init_comparison
00262Dr 3               
00262Dr 3               @not_found:
00262Dr 3                               ; The substring isn't in the main string.
00262Dr 3                               ; Return just the main string and a false flag.
00262Dr 3  E8                           inx             ; Remove offset
00262Er 3  E8                           inx
00262Fr 3  E8                           inx             ; Remove u2
002630r 3  E8                           inx
002631r 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
002633r 3  74 01                        stz 1,x
002635r 3  80 66                        bra z_search
002637r 3               
002637r 3               @init_comparison:
002637r 3                               ; Use tmp1 to hold address in string 1.
002637r 3                               ; Use tmp2 to hold address in string 2.
002637r 3                               ; Use tmp3 to hold the number of characters left to check.
002637r 3               
002637r 3                               ; Compute the starting address in string 1
002637r 3                               ; as addr1 + offset
002637r 3  18                           clc
002638r 3  B5 08                        lda 8,x
00263Ar 3  75 00                        adc 0,x
00263Cr 3  85 rr                        sta tmp1
00263Er 3  B5 09                        lda 9,x
002640r 3  75 01                        adc 1,x
002642r 3  85 rr                        sta tmp1+1
002644r 3               
002644r 3                               ; The starting address in string 2 is just addr2.
002644r 3  B5 04                        lda 4,x
002646r 3  85 rr                        sta tmp2
002648r 3  B5 05                        lda 5,x
00264Ar 3  85 rr                        sta tmp2+1
00264Cr 3               
00264Cr 3                               ; The number of characters to check is u2.
00264Cr 3  B5 02                        lda 2,x
00264Er 3  85 rr                        sta tmp3
002650r 3  B5 03                        lda 3,x
002652r 3  85 rr                        sta tmp3+1
002654r 3               
002654r 3               @comparison_loop:
002654r 3                               ; Check to see if the current characters match.
002654r 3  B2 rr                        lda (tmp1)
002656r 3  D2 rr                        cmp (tmp2)
002658r 3  F0 05                        beq @letters_match
00265Ar 3               
00265Ar 3                               ; One of the letters didn't match.
00265Ar 3                               ; Increment the offset and try again.
00265Ar 3  20 rr rr                     jsr xt_one_plus
00265Dr 3  80 B7                        bra @search_loop
00265Fr 3               
00265Fr 3               @letters_match:
00265Fr 3                               ; The letters match.  Advance the pointers until the
00265Fr 3                               ; count reaches zero.
00265Fr 3  E6 rr                        inc tmp1
002661r 3  D0 02                        bne @1
002663r 3  E6 rr                        inc tmp1+1
002665r 3               @1:
002665r 3  E6 rr                        inc tmp2
002667r 3  D0 02                        bne @2
002669r 3  E6 rr                        inc tmp2+1
00266Br 3               @2:
00266Br 3                               ; Decrement the count of remaining letters to check.
00266Br 3  A5 rr                        lda tmp3
00266Dr 3  D0 02                        bne @3
00266Fr 3  C6 rr                        dec tmp3+1
002671r 3               @3:
002671r 3  C6 rr                        dec tmp3
002673r 3               
002673r 3                               ; Check if we've reached zero.
002673r 3  A5 rr                        lda tmp3
002675r 3  05 rr                        ora tmp3+1
002677r 3  D0 DB                        bne @comparison_loop ; Check the next letter
002679r 3               
002679r 3                               ; We've run out of letters and they all match!
002679r 3                               ; Return (addr1+offset) (u1-offset) true
002679r 3                               ; Add offset to addr1.
002679r 3  18                           clc
00267Ar 3  B5 00                        lda 0,x
00267Cr 3  75 08                        adc 8,x
00267Er 3  95 08                        sta 8,x
002680r 3  B5 01                        lda 1,x
002682r 3  75 09                        adc 9,x
002684r 3  95 09                        sta 9,x
002686r 3               
002686r 3                               ; Subtract offset from u1.
002686r 3  38                           sec
002687r 3  B5 06                        lda 6,x
002689r 3  F5 00                        sbc 0,x
00268Br 3  95 06                        sta 6,x
00268Dr 3  B5 07                        lda 7,x
00268Fr 3  F5 01                        sbc 1,x
002691r 3  95 07                        sta 7,x
002693r 3               
002693r 3                               ; Replace addr2, u2, and offset with a true flag.
002693r 3  E8                           inx             ; drop offset
002694r 3  E8                           inx
002695r 3  E8                           inx             ; drop u2
002696r 3  E8                           inx
002697r 3  A9 FF                        lda #$FF
002699r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
00269Br 3  95 01                        sta 1,x
00269Dr 3               
00269Dr 3  60           z_search:       rts
00269Er 3               
00269Er 3               
00269Er 3               
00269Er 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
00269Er 3               ; ## ";"  auto  ANS core
00269Er 3                       ; """https://forth-standard.org/standard/core/Semi
00269Er 3                       ; End the compilation of a new word into the Dictionary.
00269Er 3                       ;
00269Er 3                       ; When we
00269Er 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
00269Er 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
00269Er 3                       ; A Forth definition would be (see "Starting Forth"):
00269Er 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
00269Er 3                       ; practice of Gforth, we warn here if a word has been redefined.
00269Er 3                       ; """
00269Er 3               
00269Er 3               xt_semicolon:
00269Er 3                               ; Check if this is a : word or a :NONAME word.
00269Er 3  24 rr                        bit status
0026A0r 3  70 11                        bvs @colonword
0026A2r 3               
0026A2r 3                               ; This is a :NONAME word - just put an RTS on the end and
0026A2r 3                               ; the address (held in workword) on the stack.
0026A2r 3  A9 60                        lda #$60                ; opcode for RTS
0026A4r 3  20 rr rr                     jsr cmpl_a
0026A7r 3               
0026A7r 3  CA                           dex
0026A8r 3  CA                           dex
0026A9r 3  A5 rr                        lda workword
0026ABr 3  95 00                        sta 0,x
0026ADr 3  A5 rr                        lda workword+1
0026AFr 3  95 01                        sta 1,x
0026B1r 3  80 45                        bra @semicolon_done
0026B3r 3               
0026B3r 3               @colonword:
0026B3r 3                               ; CP is the byte that will be the address we use in the
0026B3r 3                               ; header as the end-of-compile address (z_word). This is
0026B3r 3                               ; six bytes down from the header
0026B3r 3  A0 06                        ldy #6
0026B5r 3  A5 rr                        lda cp
0026B7r 3  91 rr                        sta (workword),y
0026B9r 3  C8                           iny
0026BAr 3  A5 rr                        lda cp+1
0026BCr 3  91 rr                        sta (workword),y
0026BEr 3               
0026BEr 3                               ; Allocate one further byte and save the RTS instruction
0026BEr 3                               ; there
0026BEr 3  A9 60                        lda #$60                ; opcode for RTS
0026C0r 3  20 rr rr                     jsr cmpl_a
0026C3r 3               
0026C3r 3                               ; Before we formally add the word to the Dictionary, we
0026C3r 3                               ; check to see if it is already present, and if yes, we
0026C3r 3                               ; warn the user.
0026C3r 3               
0026C3r 3                               ; See if word already in Dictionary.
0026C3r 3                               ; (STATUS bit 7 will be high as CREATE already
0026C3r 3                               ;  checked for us.)
0026C3r 3  24 rr                        bit status
0026C5r 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
0026C7r 3               
0026C7r 3                               ; We start by putting the string of the
0026C7r 3                               ; word we're defining on the stack
0026C7r 3  CA                           dex
0026C8r 3  CA                           dex
0026C9r 3  CA                           dex
0026CAr 3  CA                           dex
0026CBr 3               
0026CBr 3                               ; WORKWORD points to the beginning of the head of our new
0026CBr 3                               ; word, where the first byte is the length of the string
0026CBr 3                               ; We can't use LATESTNT because we haven't added the new
0026CBr 3                               ; word to the Dictionary yet
0026CBr 3  B2 rr                        lda (workword)
0026CDr 3  95 00                        sta 0,x
0026CFr 3  74 01                        stz 1,x
0026D1r 3               
0026D1r 3                               ; Eight bytes below WORKWORD is the actual beginning of
0026D1r 3                               ; the string
0026D1r 3  A5 rr                        lda workword
0026D3r 3  18                           clc
0026D4r 3  69 08                        adc #8
0026D6r 3  95 02                        sta 2,x
0026D8r 3  A5 rr                        lda workword+1
0026DAr 3  69 00                        adc #0                  ; only want carry
0026DCr 3  95 03                        sta 3,x
0026DEr 3               
0026DEr 3                               ; This word is already in the Dictionary, so we print a
0026DEr 3                               ; warning to the user.
0026DEr 3  A9 02                        lda #str_redefined       ; address of string "redefined"
0026E0r 3  20 rr rr                     jsr print_string_no_lf
0026E3r 3               
0026E3r 3                               ; Now we print the offending word.
0026E3r 3  20 rr rr                     jsr xt_type
0026E6r 3  20 rr rr                     jsr xt_space
0026E9r 3               
0026E9r 3                               ; Clear bit 7 of status (so future words will print message
0026E9r 3                               ; by defaut)
0026E9r 3  A9 80                        lda #%10000000
0026EBr 3  14 rr                        trb status
0026EDr 3               
0026EDr 3               @new_word:
0026EDr 3                               ; Let's get this over with. Save beginning of our word
0026EDr 3                               ; as new last word in the Dictionary
0026EDr 3  A5 rr                        lda workword
0026EFr 3  85 rr                        sta dp
0026F1r 3  A5 rr                        lda workword+1
0026F3r 3  85 rr                        sta dp+1
0026F5r 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
0026F8r 3                                                       ; CURRENT wordlist.
0026F8r 3               @semicolon_done:
0026F8r 3                               ; Word definition complete. Return compile flag to zero
0026F8r 3                               ; to return to interpret mode
0026F8r 3  64 rr                        stz state
0026FAr 3  64 rr                        stz state+1
0026FCr 3               
0026FCr 3  60           z_semicolon:    rts
0026FDr 3               
0026FDr 3               
0026FDr 3               
0026FDr 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
0026FDr 3               ; ## "sign"  auto  ANS core
0026FDr 3                       ; """https://forth-standard.org/standard/core/SIGN
0026FDr 3                       ;
0026FDr 3                       ; Code based on
0026FDr 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
0026FDr 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
0026FDr 3                       ; """
0026FDr 3               
0026FDr 3               xt_sign:
0026FDr 3  20 rr rr                     jsr underflow_1
002700r 3               
002700r 3  B5 01                        lda 1,x         ; check MSB of TOS
002702r 3  30 04                        bmi @minus
002704r 3               
002704r 3  E8                           inx
002705r 3  E8                           inx
002706r 3  80 09                        bra @done
002708r 3               @minus:
002708r 3  A9 2D                        lda #$2D        ; ASCII for "-"
00270Ar 3  95 00                        sta 0,x         ; overwrite TOS
00270Cr 3  74 01                        stz 1,x         ; paranoid
00270Er 3               
00270Er 3  20 rr rr                     jsr xt_hold
002711r 3               @done:
002711r 3  60           z_sign:         rts
002712r 3               
002712r 3               
002712r 3               
002712r 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
002712r 3               ; ## "/"  auto  ANS core
002712r 3                       ; """https://forth-standard.org/standard/core/Div
002712r 3                       ;
002712r 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
002712r 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
002712r 3                       ; This code is currently unoptimized. This code without the SLASH
002712r 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
002712r 3                       ; """
002712r 3               
002712r 3               xt_slash:
002712r 3                               ; With all the multiplication going on, it would be hard to
002712r 3                               ; make sure that one of our temporary variables is not
002712r 3                               ; overwritten. We make sure that doesn't happen by taking the
002712r 3                               ; hit of pushing the flag to the 65c02's stack
002712r 3  A9 00                        lda #0
002714r 3  48                           pha
002715r 3  80 03                        bra _common
002717r 3               
002717r 3               xt_slash_mod:
002717r 3                               ; Note that /MOD accesses this code
002717r 3  A9 FF                        lda #$FF
002719r 3  48                           pha             ; falls through to _common
00271Ar 3               
00271Ar 3               _common:
00271Ar 3  20 rr rr                     jsr xt_to_r             ; >R
00271Dr 3  20 rr rr                     jsr xt_s_to_d           ; S>D
002720r 3  20 rr rr                     jsr xt_r_from           ; R>
002723r 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
002726r 3               
002726r 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
002726r 3                               ; $FF is SLASH MOD
002726r 3  68                           pla
002727r 3  D0 05                        bne @done
002729r 3               
002729r 3                               ; The following code is for SLASH only
002729r 3  20 rr rr                     jsr xt_swap
00272Cr 3  E8                           inx             ; DROP
00272Dr 3  E8                           inx
00272Er 3               @done:
00272Er 3               z_slash_mod:
00272Er 3  60           z_slash:        rts
00272Fr 3               
00272Fr 3               
00272Fr 3               
00272Fr 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
00272Fr 3               ; ## "/mod"  auto  ANS core
00272Fr 3                       ; """https://forth-standard.org/standard/core/DivMOD
00272Fr 3                       ;
00272Fr 3                       ; This is a dummy entry, the actual code is shared with SLASH
00272Fr 3                       ; """
00272Fr 3               
00272Fr 3               
00272Fr 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
00272Fr 3               ; ## "/string"  auto  ANS string
00272Fr 3                       ; """https://forth-standard.org/standard/string/DivSTRING
00272Fr 3                       ;
00272Fr 3                       ; Forth code is
00272Fr 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
00272Fr 3                       ; Put differently, we need to add TOS and 3OS, and subtract
00272Fr 3                       ; TOS from NOS, and then drop TOS
00272Fr 3                       ; """
00272Fr 3               
00272Fr 3               xt_slash_string:
00272Fr 3  20 rr rr                     jsr underflow_3
002732r 3               
002732r 3  18                           clc             ; 3OS+TOS
002733r 3  B5 00                        lda 0,x
002735r 3  75 04                        adc 4,x
002737r 3  95 04                        sta 4,x
002739r 3               
002739r 3  B5 01                        lda 1,x
00273Br 3  75 05                        adc 5,x
00273Dr 3  95 05                        sta 5,x
00273Fr 3               
00273Fr 3  38                           sec             ; NOS-TOS
002740r 3  B5 02                        lda 2,x
002742r 3  F5 00                        sbc 0,x
002744r 3  95 02                        sta 2,x
002746r 3               
002746r 3  B5 03                        lda 3,x
002748r 3  F5 01                        sbc 1,x
00274Ar 3  95 03                        sta 3,x
00274Cr 3               
00274Cr 3  E8                           inx
00274Dr 3  E8                           inx
00274Er 3               
00274Er 3  60           z_slash_string: rts
00274Fr 3               
00274Fr 3               
00274Fr 3               
00274Fr 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
00274Fr 3               ; ## "sliteral" auto  ANS string
00274Fr 3                       ; """https://forth-standard.org/standard/string/SLITERAL
00274Fr 3                       ; Add the runtime for an existing string.
00274Fr 3                       ; """
00274Fr 3               
00274Fr 3               xt_sliteral:
00274Fr 3  20 rr rr                     jsr underflow_2
002752r 3               
002752r 3                               ; We can't assume that ( addr u ) of the current string is in
002752r 3                               ; a stable area (eg. already in the dictionary.) Copy the
002752r 3                               ; string data into the dictionary using move.
002752r 3               
002752r 3                               ; Put a jmp over the string data with address to be filled
002752r 3                               ; in later.
002752r 3  A9 4C                        lda #$4C
002754r 3  20 rr rr                     jsr cmpl_a
002757r 3               
002757r 3                               ; Address to be filled in later.
002757r 3  20 rr rr                     jsr cmpl_a
00275Ar 3  20 rr rr                     jsr cmpl_a
00275Dr 3               
00275Dr 3                               ; Turn the data stack from ( addr u ) into
00275Dr 3                               ; ( here u addr here u ) so move can be called with
00275Dr 3                               ; the remaining items on the stack ready for processing.
00275Dr 3                               ; Reserve three extra words on the stack.
00275Dr 3  8A                           txa
00275Er 3  38                           sec
00275Fr 3  E9 06                        sbc #6
002761r 3  AA                           tax
002762r 3               
002762r 3                               ; Move addr down from TOS-4 to TOS-2
002762r 3  B5 08                        lda 8,x
002764r 3  95 04                        sta 4,x
002766r 3  B5 09                        lda 9,x
002768r 3  95 05                        sta 5,x
00276Ar 3               
00276Ar 3                               ; Copy u from TOS-3 to TOS
00276Ar 3  B5 06                        lda 6,x
00276Cr 3  95 00                        sta 0,x
00276Er 3  B5 07                        lda 7,x
002770r 3  95 01                        sta 1,x
002772r 3               
002772r 3                               ; Put HERE into TOS-1 and TOS-4
002772r 3  A5 rr                        lda cp
002774r 3  95 08                        sta 8,x
002776r 3  95 02                        sta 2,x
002778r 3  A5 rr                        lda cp+1
00277Ar 3  95 09                        sta 9,x
00277Cr 3  95 03                        sta 3,x
00277Er 3               
00277Er 3                               ; Copy the string into the dictionary.
00277Er 3  20 rr rr                     jsr xt_move
002781r 3               
002781r 3                               ; Update cp.
002781r 3  18                           clc
002782r 3  A5 rr                        lda cp
002784r 3  75 00                        adc 0,x
002786r 3  85 rr                        sta cp
002788r 3  A5 rr                        lda cp+1
00278Ar 3  75 01                        adc 1,x
00278Cr 3  85 rr                        sta cp+1
00278Er 3               
00278Er 3                               ; Update the address of the jump-over jmp instruction.
00278Er 3                               ; First determine location of jmp instructions address.
00278Er 3                               ; It should be 2 bytes before the start of the string.
00278Er 3               
00278Er 3                               ; Compute it into tmp1, which is no longer being used.
00278Er 3  B5 02                        lda 2,x
002790r 3  38                           sec
002791r 3  E9 02                        sbc #2
002793r 3  85 rr                        sta tmp1
002795r 3  B5 03                        lda 3,x
002797r 3  E9 00                        sbc #0          ; Propagate borrow
002799r 3  85 rr                        sta tmp1+1
00279Br 3               
00279Br 3                               ; Update the address of the jump to HERE.
00279Br 3  A5 rr                        lda cp
00279Dr 3  92 rr                        sta (tmp1)
00279Fr 3  A0 01                        ldy #1
0027A1r 3  A5 rr                        lda cp+1
0027A3r 3  91 rr                        sta (tmp1),y
0027A5r 3               
0027A5r 3                               ; Stack is now ( addr2 u ) where addr2 is the new
0027A5r 3                               ; location in the dictionary.
0027A5r 3               
0027A5r 3               sliteral_const_str:
0027A5r 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
0027A5r 3                               ; pushes the new ( addr u ) pair to the Data Stack.
0027A5r 3                               ; When we're done, the code will look like this:
0027A5r 3               
0027A5r 3                               ; xt -->    jmp a
0027A5r 3                               ;           <string data bytes>
0027A5r 3                               ;  a -->    jsr sliteral_runtime
0027A5r 3                               ;           <string address>
0027A5r 3                               ;           <string length>
0027A5r 3                               ; rts -->
0027A5r 3               
0027A5r 3                               ; This means we'll have to adjust the return address for two
0027A5r 3                               ; cells, not just one
0027A5r 3  A0 rr                        ldy #>sliteral_runtime
0027A7r 3  A9 rr                        lda #<sliteral_runtime
0027A9r 3  20 rr rr                     jsr cmpl_subroutine
0027ACr 3               
0027ACr 3                               ; We want to have the address end up as NOS and the length
0027ACr 3                               ; as TOS, so we store the address first
0027ACr 3  B4 03                        ldy 3,x                ; address MSB
0027AEr 3  B5 02                        lda 2,x                ; address LSB
0027B0r 3  20 rr rr                     jsr cmpl_word
0027B3r 3               
0027B3r 3  B4 01                        ldy 1,x                ; length MSB
0027B5r 3  B5 00                        lda 0,x                ; length LSB
0027B7r 3  20 rr rr                     jsr cmpl_word
0027BAr 3               
0027BAr 3                               ; clean up and leave
0027BAr 3  E8                           inx
0027BBr 3  E8                           inx
0027BCr 3  E8                           inx
0027BDr 3  E8                           inx
0027BEr 3               
0027BEr 3  60           z_sliteral:     rts
0027BFr 3               
0027BFr 3               
0027BFr 3               sliteral_runtime:
0027BFr 3               
0027BFr 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
0027BFr 3                       ; the Data Stack. We arrive here with the return address as the
0027BFr 3                       ; top of Return Stack, which points to the address of the string
0027BFr 3                       ; """
0027BFr 3  CA                           dex
0027C0r 3  CA                           dex
0027C1r 3  CA                           dex
0027C2r 3  CA                           dex
0027C3r 3               
0027C3r 3                               ; Get the address of the string address off the stack and
0027C3r 3                               ; increase by one because of the RTS mechanics
0027C3r 3  68                           pla
0027C4r 3  85 rr                        sta tmp1        ; LSB of address
0027C6r 3  68                           pla
0027C7r 3  85 rr                        sta tmp1+1      ; MSB of address
0027C9r 3               
0027C9r 3                               ; Walk through both and save them
0027C9r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
0027CBr 3  B1 rr                        lda (tmp1),y
0027CDr 3  95 02                        sta 2,x         ; LSB of address
0027CFr 3  C8                           iny
0027D0r 3               
0027D0r 3  B1 rr                        lda (tmp1),y
0027D2r 3  95 03                        sta 3,x         ; MSB of address
0027D4r 3  C8                           iny
0027D5r 3               
0027D5r 3  B1 rr                        lda (tmp1),y
0027D7r 3  95 00                        sta 0,x         ; LSB of length
0027D9r 3  C8                           iny
0027DAr 3               
0027DAr 3  B1 rr                        lda (tmp1),y
0027DCr 3  95 01                        sta 1,x         ; MSB of length
0027DEr 3               
0027DEr 3                               ; restore return address
0027DEr 3  18                           clc
0027DFr 3  A5 rr                        lda tmp1
0027E1r 3  69 04                        adc #4
0027E3r 3  A8                           tay             ; LSB
0027E4r 3  A5 rr                        lda tmp1+1
0027E6r 3  69 00                        adc #0          ; we only need carry
0027E8r 3  48                           pha             ; MSB
0027E9r 3  5A                           phy
0027EAr 3               
0027EAr 3  60                           rts
0027EBr 3               
0027EBr 3               
0027EBr 3               
0027EBr 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
0027EBr 3               ; ## "sm/rem"  auto  ANS core
0027EBr 3                       ; """https://forth-standard.org/standard/core/SMDivREM
0027EBr 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
0027EBr 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
0027EBr 3                       ;
0027EBr 3                       ; Forth:
0027EBr 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
0027EBr 3                       ; R> ?NEGATE SWAP
0027EBr 3                       ; """
0027EBr 3               
0027EBr 3               xt_sm_slash_rem:
0027EBr 3  20 rr rr                     jsr underflow_3 ; contains double number
0027EEr 3               
0027EEr 3                               ; push MSB of high cell of d to Data Stack so we can check
0027EEr 3                               ; its sign later
0027EEr 3  B5 03                        lda 3,x
0027F0r 3  48                           pha
0027F1r 3               
0027F1r 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
0027F1r 3                               ; its sign later as well
0027F1r 3  B5 01                        lda 1,x
0027F3r 3  55 03                        eor 3,x
0027F5r 3  48                           pha
0027F6r 3               
0027F6r 3                               ; Prepare division by getting absolute of n1 and d
0027F6r 3  20 rr rr                     jsr xt_abs
0027F9r 3  E8                           inx             ; pretend we pushed n1 to R
0027FAr 3  E8                           inx
0027FBr 3               
0027FBr 3  20 rr rr                     jsr xt_dabs
0027FEr 3  CA                           dex
0027FFr 3  CA                           dex
002800r 3               
002800r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
002803r 3               
002803r 3                               ; if the XOR compiled above is negative, negate the
002803r 3                               ; quotient (n3)
002803r 3  68                           pla
002804r 3  10 03                        bpl @1
002806r 3  20 rr rr                     jsr xt_negate
002809r 3               @1:
002809r 3                               ; if d was negative, negate the remainder (n2)
002809r 3  68                           pla
00280Ar 3  10 07                        bpl @done
00280Cr 3               
00280Cr 3  E8                           inx             ; pretend we pushed quotient to R
00280Dr 3  E8                           inx
00280Er 3  20 rr rr                     jsr xt_negate
002811r 3  CA                           dex
002812r 3  CA                           dex
002813r 3               
002813r 3               @done:
002813r 3  60           z_sm_slash_rem: rts
002814r 3               
002814r 3               
002814r 3               
002814r 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
002814r 3               ; ## "source"  auto  ANS core
002814r 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
002814r 3               xt_source:
002814r 3                               ; add address
002814r 3  CA                           dex
002815r 3  CA                           dex
002816r 3  A5 rr                        lda cib
002818r 3  95 00                        sta 0,x
00281Ar 3  A5 rr                        lda cib+1
00281Cr 3  95 01                        sta 1,x
00281Er 3               
00281Er 3                               ; add size
00281Er 3  CA                           dex
00281Fr 3  CA                           dex
002820r 3  A5 rr                        lda ciblen
002822r 3  95 00                        sta 0,x
002824r 3  A5 rr                        lda ciblen+1
002826r 3  95 01                        sta 1,x
002828r 3               
002828r 3  60           z_source:       rts
002829r 3               
002829r 3               
002829r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002829r 3               ; ## "source-id"  tested  ANS core ext
002829r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002829r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002829r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002829r 3                       ; string, and a text file gives the fileid.
002829r 3                       ; """
002829r 3               xt_source_id:
002829r 3  CA                           dex
00282Ar 3  CA                           dex
00282Br 3               
00282Br 3  A5 rr                        lda insrc
00282Dr 3  95 00                        sta 0,x
00282Fr 3  A5 rr                        lda insrc+1
002831r 3  95 01                        sta 1,x
002833r 3               
002833r 3  60           z_source_id:    rts
002834r 3               
002834r 3               
002834r 3               ; ## SPACE ( -- ) "Print a single space"
002834r 3               ; ## "space"  auto  ANS core
002834r 3                       ; """https://forth-standard.org/standard/core/SPACE"""
002834r 3               xt_space:
002834r 3  A9 20                        lda #AscSP
002836r 3  20 rr rr                     jsr emit_a
002839r 3               
002839r 3  60           z_space:        rts
00283Ar 3               
00283Ar 3               
00283Ar 3               ; ## SPACES ( u -- ) "Print a number of spaces"
00283Ar 3               ; ## "spaces"  auto  ANS core
00283Ar 3                       ; """https://forth-standard.org/standard/core/SPACES"""
00283Ar 3               
00283Ar 3               xt_spaces:
00283Ar 3  20 rr rr                     jsr underflow_1
00283Dr 3               
00283Dr 3                               ; catch any zero in TOS fast
00283Dr 3  B5 00                        lda 0,x
00283Fr 3  15 01                        ora 1,x
002841r 3  F0 2A                        beq @done
002843r 3               
002843r 3                               ; Usually we're only going to print far less than 256 spaces,
002843r 3                               ; so we create a quick loop for that. Short loop could be realized
002843r 3                               ; as a separate subroutine, but unless we're really pressed for
002843r 3                               ; memory at some point, this is faster
002843r 3  B4 01                        ldy 1,x
002845r 3  D0 0C                        bne @lots_of_spaces
002847r 3               
002847r 3  B4 00                        ldy 0,x
002849r 3               @quick_loop:
002849r 3                               ; we reach here knowing that there must be a number that is not
002849r 3                               ; zero in the TOS
002849r 3  A9 20                        lda #AscSP
00284Br 3  20 rr rr                     jsr emit_a
00284Er 3  88                           dey
00284Fr 3  F0 1C                        beq @done
002851r 3  80 F6                        bra @quick_loop
002853r 3               
002853r 3               @lots_of_spaces:
002853r 3                               ; We go through the first loop once to get rid of the lower
002853r 3                               ; counter byte. This could be zero
002853r 3  B4 00                        ldy 0,x
002855r 3               
002855r 3               @first_slow_loop:
002855r 3  F0 08                        beq @slow_outer_loop
002857r 3  A9 20                        lda #AscSP
002859r 3  20 rr rr                     jsr emit_a
00285Cr 3  88                           dey
00285Dr 3  80 F6                        bra @first_slow_loop
00285Fr 3               
00285Fr 3               @slow_outer_loop:
00285Fr 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
00285Fr 3  A0 00                        ldy #00
002861r 3               
002861r 3               @slow_inner_loop:
002861r 3  A9 20                        lda #AscSP
002863r 3  20 rr rr                     jsr emit_a
002866r 3  88                           dey
002867r 3  D0 F8                        bne @slow_inner_loop
002869r 3               
002869r 3  D6 01                        dec 1,x
00286Br 3  D0 F2                        bne @slow_outer_loop
00286Dr 3               
00286Dr 3               @done:
00286Dr 3  E8                           inx             ; drop
00286Er 3  E8                           inx
00286Fr 3               
00286Fr 3  60           z_spaces:       rts
002870r 3               
002870r 3               
002870r 3               
002870r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
002870r 3               ; ## "*"  auto  ANS core
002870r 3                       ; """https://forth-standard.org/standard/core/Times
002870r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
002870r 3                       ;
002870r 3                       ; This is nothing  more than UM* DROP
002870r 3                       ; """
002870r 3               
002870r 3               xt_star:
002870r 3  20 rr rr                     jsr underflow_2
002873r 3               
002873r 3  20 rr rr                     jsr xt_um_star
002876r 3  E8                           inx
002877r 3  E8                           inx
002878r 3               
002878r 3  60           z_star:         rts
002879r 3               
002879r 3               
002879r 3               
002879r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
002879r 3               ; ## "*/"  auto  ANS core
002879r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
002879r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
002879r 3                       ; without a remainder. This is */MOD without the mod.
002879r 3                       ;
002879r 3                       ; This word
002879r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
002879r 3                       ; pretty much what we do here
002879r 3                       ; """
002879r 3               xt_star_slash:
002879r 3                               ; We let */MOD check for underflow
002879r 3  20 rr rr                     jsr xt_star_slash_mod
00287Cr 3  20 rr rr                     jsr xt_swap
00287Fr 3  E8                           inx
002880r 3  E8                           inx
002881r 3               z_star_slash:
002881r 3  60                           rts
002882r 3               
002882r 3               
002882r 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
002882r 3               ; ## "*/mod"  auto  ANS core
002882r 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
002882r 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
002882r 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
002882r 3                       ; single-cell quotient n5.
002882r 3                       ;
002882r 3                       ; In Forth, this is
002882r 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
002882r 3                       ; """
002882r 3               xt_star_slash_mod:
002882r 3  20 rr rr                     jsr underflow_3
002885r 3               
002885r 3  20 rr rr                     jsr xt_to_r
002888r 3  20 rr rr                     jsr xt_m_star
00288Br 3  20 rr rr                     jsr xt_r_from
00288Er 3  20 rr rr                     jsr xt_sm_slash_rem
002891r 3               
002891r 3               z_star_slash_mod:
002891r 3  60                           rts
002892r 3               
002892r 3               
002892r 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
002892r 3               ; ## "state"  auto  ANS core
002892r 3                       ; """https://forth-standard.org/standard/core/STATE
002892r 3                       ; STATE is true when in compilation state, false otherwise. Note
002892r 3                       ; we do not return the state itself, but only the address where
002892r 3                       ; it lives. The state should not be changed directly by the user; see
002892r 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
002892r 3                       ; """
002892r 3               xt_state:
002892r 3  CA                           dex
002893r 3  CA                           dex
002894r 3  A9 rr                        lda #<state
002896r 3  95 00                        sta 0,x
002898r 3  A9 rr                        lda #>state
00289Ar 3  95 01                        sta 1,x
00289Cr 3               
00289Cr 3  60           z_state:        rts
00289Dr 3               
00289Dr 3               
00289Dr 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
00289Dr 3               ; ## "!"  auto  ANS core
00289Dr 3                       ; """https://forth-standard.org/standard/core/Store"""
00289Dr 3               xt_store:
00289Dr 3  20 rr rr                     jsr underflow_2
0028A0r 3               
0028A0r 3  B5 02                        lda 2,x         ; LSB
0028A2r 3  81 00                        sta (0,x)
0028A4r 3               
0028A4r 3  F6 00                        inc 0,x
0028A6r 3  D0 02                        bne @1
0028A8r 3  F6 01                        inc 1,x
0028AAr 3               @1:
0028AAr 3  B5 03                        lda 3,x         ; MSB
0028ACr 3  81 00                        sta (0,x)
0028AEr 3               
0028AEr 3  E8                           inx             ; 2DROP
0028AFr 3  E8                           inx
0028B0r 3  E8                           inx
0028B1r 3  E8                           inx
0028B2r 3               
0028B2r 3  60           z_store:        rts
0028B3r 3               
0028B3r 3               
0028B3r 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
0028B3r 3               ; ## "strip-underflow"  tested  Tali Forth
0028B3r 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
0028B3r 3                       ; checking should be removed during the compilation of new words.
0028B3r 3                       ; Default is false.
0028B3r 3                       ; """
0028B3r 3               xt_strip_underflow:
0028B3r 3  CA                           dex
0028B4r 3  CA                           dex
0028B5r 3               
0028B5r 3  A9 rr                        lda #<uf_strip
0028B7r 3  95 00                        sta 0,x
0028B9r 3  A9 rr                        lda #>uf_strip
0028BBr 3  95 01                        sta 1,x
0028BDr 3               
0028BDr 3               z_strip_underflow:
0028BDr 3  60                           rts
0028BEr 3               
0028BEr 3               
0028BEr 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
0028BEr 3               ; ## "swap"  auto  ANS core
0028BEr 3                       ; """https://forth-standard.org/standard/core/SWAP"""
0028BEr 3               xt_swap:
0028BEr 3  20 rr rr                     jsr underflow_2
0028C1r 3               
0028C1r 3  B5 00                        lda 0,x         ; LSB
0028C3r 3  B4 02                        ldy 2,x
0028C5r 3  95 02                        sta 2,x
0028C7r 3  94 00                        sty 0,x
0028C9r 3               
0028C9r 3  B5 01                        lda 1,x         ; MSB
0028CBr 3  B4 03                        ldy 3,x
0028CDr 3  95 03                        sta 3,x
0028CFr 3  94 01                        sty 1,x
0028D1r 3               
0028D1r 3  60           z_swap:         rts
0028D2r 3               
0028D2r 3               
0028D2r 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
0028D2r 3               ; ## "then"  auto  ANS core
0028D2r 3                       ; """http://forth-standard.org/standard/core/THEN"""
0028D2r 3               xt_then:
0028D2r 3                               ; Get the address to jump to.
0028D2r 3  20 rr rr                     jsr xt_here
0028D5r 3               
0028D5r 3                               ; Stuff HERE in for the branch address back
0028D5r 3                               ; at the IF or ELSE (origination address is on stack).
0028D5r 3  20 rr rr                     jsr xt_swap
0028D8r 3  20 rr rr                     jsr xt_store
0028DBr 3               
0028DBr 3  60           z_then:         rts
0028DCr 3               
0028DCr 3               
0028DCr 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
0028DCr 3               ; ## "thru"  tested  ANS block ext
0028DCr 3                       ; """https://forth-standard.org/standard/block/THRU"""
0028DCr 3               
0028DCr 3               xt_thru:
0028DCr 3  20 rr rr                     jsr underflow_2
0028DFr 3               
0028DFr 3                               ; We need to loop here, and can't use the data stack
0028DFr 3                               ; because the LOADed screens might use it.  We'll
0028DFr 3                               ; need to use the same trick that DO loops use, holding
0028DFr 3                               ; the limit and current index on the return stack.
0028DFr 3               
0028DFr 3                               ; Put the ending screen number on the return stack
0028DFr 3  B5 01                        lda 1,x
0028E1r 3  48                           pha
0028E2r 3  B5 00                        lda 0,x
0028E4r 3  48                           pha
0028E5r 3  E8                           inx
0028E6r 3  E8                           inx
0028E7r 3               @thru_loop:
0028E7r 3                               ; Put the starting screen number on the stack,
0028E7r 3                               ; but keep a copy
0028E7r 3  B5 01                        lda 1,x
0028E9r 3  48                           pha
0028EAr 3  B5 00                        lda 0,x
0028ECr 3  48                           pha
0028EDr 3               
0028EDr 3                               ; Load this screen.
0028EDr 3  20 rr rr                     jsr xt_load
0028F0r 3               
0028F0r 3                               ; Get the number and limit back off the stack.  Rather than
0028F0r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
0028F0r 3               
0028F0r 3                               ; Get the screen we just loaded.
0028F0r 3  68                           pla
0028F1r 3  85 rr                        sta tmp1
0028F3r 3  68                           pla
0028F4r 3  85 rr                        sta tmp1+1
0028F6r 3               
0028F6r 3                               ; Get the ending screen.
0028F6r 3  68                           pla
0028F7r 3  85 rr                        sta tmp2
0028F9r 3  68                           pla
0028FAr 3  85 rr                        sta tmp2+1
0028FCr 3               
0028FCr 3                               ; See if we just loaded the last screen.
0028FCr 3                               ; A already has the MSB of the last screen in it.
0028FCr 3  C5 rr                        cmp tmp1+1
0028FEr 3  D0 08                        bne @next_screen
002900r 3  A5 rr                        lda tmp2        ; Compare the LSB
002902r 3  C5 rr                        cmp tmp1
002904r 3  D0 02                        bne @next_screen
002906r 3  80 18                        bra @done       ; We just did the last screen.
002908r 3               
002908r 3               @next_screen:
002908r 3                               ; Put the ending screen back on the data stack.
002908r 3  A5 rr                        lda tmp2+1
00290Ar 3  48                           pha
00290Br 3  A5 rr                        lda tmp2
00290Dr 3  48                           pha
00290Er 3               
00290Er 3                               ; Increment the current screen.
00290Er 3  E6 rr                        inc tmp1
002910r 3  D0 02                        bne @1
002912r 3  E6 rr                        inc tmp1+1
002914r 3               @1:
002914r 3                               ; Put the current screen on the stack to prepare for
002914r 3                               ; the next loop.
002914r 3  CA                           dex
002915r 3  CA                           dex
002916r 3  A5 rr                        lda tmp1
002918r 3  95 00                        sta 0,x
00291Ar 3  A5 rr                        lda tmp1+1
00291Cr 3  95 01                        sta 1,x
00291Er 3  80 C7                        bra @thru_loop
002920r 3               @done:
002920r 3  60           z_thru:         rts
002921r 3               
002921r 3               
002921r 3               
002921r 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
002921r 3               ; ## "'"  auto  ANS core
002921r 3                       ; """https://forth-standard.org/standard/core/Tick"""
002921r 3               
002921r 3               xt_tick:
002921r 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
002924r 3               
002924r 3                               ; if we got a zero, there was a problem getting the
002924r 3                               ; name of the word
002924r 3  B5 00                        lda 0,x
002926r 3  15 01                        ora 1,x
002928r 3  D0 05                        bne @1
00292Ar 3               
00292Ar 3  A9 05                        lda #err_noname
00292Cr 3  4C rr rr                     jmp error
00292Fr 3               @1:
00292Fr 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
002932r 3               
002932r 3                               ; If we didn't find the word in the Dictionary, abort
002932r 3  B5 00                        lda 0,x
002934r 3  15 01                        ora 1,x
002936r 3  D0 05                        bne @2
002938r 3               
002938r 3  A9 08                        lda #err_syntax
00293Ar 3  4C rr rr                     jmp error
00293Dr 3               @2:
00293Dr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
002940r 3               
002940r 3  60           z_tick:         rts
002941r 3               
002941r 3               
002941r 3               
002941r 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
002941r 3               ; ## "to"  auto  ANS core ext
002941r 3                       ; """https://forth-standard.org/standard/core/TO
002941r 3                       ; Gives a new value to a, uh, VALUE.
002941r 3                       ;
002941r 3                       ; One possible Forth
002941r 3                       ; implementation is  ' >BODY !  but given the problems we have
002941r 3                       ; with >BODY on STC Forths, we do this the hard way. Since
002941r 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
002941r 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
002941r 3                       ;
002941r 3                       ; Note that the standard has different behaviors for TO depending
002941r 3                       ; on the state (https://forth-standard.org/standard/core/TO).
002941r 3                       ; This makes TO state-dependent (which is bad) and also rather
002941r 3                       ; complex (see the Gforth implementation for comparison). This
002941r 3                       ; word may not be natively compiled and must be immediate. Frankly,
002941r 3                       ; it would have made more sense to have two words for this.
002941r 3                       ; """
002941r 3               
002941r 3               xt_to:
002941r 3                               ; One way or the other, we need the xt of the word after this
002941r 3                               ; one. At this point, we don't know if we are interpreted or
002941r 3                               ; compile, so we don't know if there is a value n on the stack,
002941r 3                               ; so we can't do an underflow check yet
002941r 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
002944r 3               
002944r 3                               ; The PFA (DFA in this case) is three bytes down,
002944r 3                               ; after the jump to DOCONST
002944r 3  B5 00                        lda 0,x                 ; LSB
002946r 3  18                           clc
002947r 3  69 03                        adc #3
002949r 3  85 rr                        sta tmp1
00294Br 3  B5 01                        lda 1,x                 ; MSB
00294Dr 3  69 00                        adc #0                  ; we just want the carry
00294Fr 3  85 rr                        sta tmp1+1
002951r 3               
002951r 3  E8                           inx
002952r 3  E8                           inx                     ; ( [n] )
002953r 3               
002953r 3                               ; Now it gets ugly. See which state we are in
002953r 3  A5 rr                        lda state
002955r 3  05 rr                        ora state+1
002957r 3  F0 34                        beq @interpret
002959r 3               
002959r 3                               ; Well, we're compiling. We want to end up with simple
002959r 3                               ; code that just takes the number that is TOS and saves
002959r 3                               ; it in the address of the xt we were just given. So we
002959r 3                               ; want to compile this routine:
002959r 3                               ;
002959r 3                               ;       lda 0,x                 - B5 00
002959r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002959r 3                               ;       lda 1,x                 - B5 01
002959r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
002959r 3                               ;       inx                     - E8
002959r 3                               ;       inx                     - E8
002959r 3                               ;
002959r 3                               ; which at least is nice and short. Other than that, we pretty
002959r 3                               ; much have to do this the hard and long way, because with the
002959r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
002959r 3                               ; range and store them with a loop. Sigh.
002959r 3               
002959r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
00295Br 3  A9 B5                        lda #$B5
00295Dr 3  20 rr rr                     jsr cmpl_word
002960r 3               
002960r 3  A9 8D                        lda #$8D                ; Code for STA abs
002962r 3  20 rr rr                     jsr cmpl_a
002965r 3               
002965r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002967r 3  A5 rr                        lda tmp1
002969r 3  20 rr rr                     jsr cmpl_word
00296Cr 3               
00296Cr 3  A0 01                        ldy #$01                ; Code for LDA 1,X
00296Er 3  A9 B5                        lda #$B5
002970r 3  20 rr rr                     jsr cmpl_word
002973r 3               
002973r 3  A9 8D                        lda #$8D                ; Code for STA abs
002975r 3  20 rr rr                     jsr cmpl_a
002978r 3               
002978r 3  E6 rr                        inc tmp1                ; Calculate MSB
00297Ar 3  D0 02                        bne @1
00297Cr 3  E6 rr                        inc tmp1+1
00297Er 3               @1:
00297Er 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
002980r 3  A5 rr                        lda tmp1
002982r 3  20 rr rr                     jsr cmpl_word
002985r 3               
002985r 3  A0 E8                        ldy #$E8                ; Code for INX
002987r 3  98                           tya
002988r 3  20 rr rr                     jsr cmpl_word
00298Br 3               
00298Br 3  80 0F                        bra @done
00298Dr 3               
00298Dr 3               @interpret:
00298Dr 3                               ; We're interpreting, so we arrive here with n
00298Dr 3                               ; on the stack. This is an annoying place to put
00298Dr 3                               ; the underflow check because we can't
00298Dr 3                               ; automatically strip it out
00298Dr 3  20 rr rr                     jsr underflow_1
002990r 3               
002990r 3                               ; We skip over the jump to DOCONST and store the number
002990r 3                               ; in the Program Field Area (PDF, in this case more a
002990r 3                               ; Data Field Area
002990r 3  B5 00                        lda 0,x
002992r 3  92 rr                        sta (tmp1)              ; LSB
002994r 3               
002994r 3  A0 01                        ldy #1
002996r 3  B5 01                        lda 1,x                 ; MSB
002998r 3  91 rr                        sta (tmp1),y            ; fall through to common
00299Ar 3               
00299Ar 3  E8                           inx                     ; DROP
00299Br 3  E8                           inx
00299Cr 3               @done:
00299Cr 3  60           z_to:           rts
00299Dr 3               
00299Dr 3               
00299Dr 3               
00299Dr 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
00299Dr 3               ; ## ">body"  auto  ANS core
00299Dr 3                       ; """https://forth-standard.org/standard/core/toBODY
00299Dr 3                       ; Given a word's execution token (xt), return the address of the
00299Dr 3                       ; start of that word's parameter field (PFA). This is defined as the
00299Dr 3                       ; address that HERE would return right after CREATE.
00299Dr 3                       ;
00299Dr 3                       ; This is a
00299Dr 3                       ; difficult word for STC Forths, because most words don't actually
00299Dr 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
00299Dr 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
00299Dr 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
00299Dr 3                       ; """
00299Dr 3               
00299Dr 3               xt_to_body:
00299Dr 3  20 rr rr                     jsr underflow_1
0029A0r 3               
0029A0r 3                               ; Ideally, xt already points to the CFA. We just need to check
0029A0r 3                               ; the HC flag for special cases
0029A0r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
0029A3r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
0029A6r 3               
0029A6r 3                               ; The status byte is nt+1
0029A6r 3  F6 00                        inc 0,x
0029A8r 3  D0 02                        bne @1
0029AAr 3  F6 01                        inc 1,x
0029ACr 3               @1:
0029ACr 3  A1 00                        lda (0,x)               ; get status byte
0029AEr 3  29 20                        and #HC
0029B0r 3  F0 0D                        beq @no_cfa
0029B2r 3               
0029B2r 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
0029B2r 3                               ; so we add three to xt, which is NOS
0029B2r 3  18                           clc
0029B3r 3  B5 02                        lda 2,x         ; LSB
0029B5r 3  69 03                        adc #3
0029B7r 3  95 02                        sta 2,x
0029B9r 3  B5 03                        lda 3,x         ; MSB
0029BBr 3  69 00                        adc #0          ; we conly care about the carry
0029BDr 3  95 03                        sta 3,x         ; Fall through to @no_cfa
0029BFr 3               @no_cfa:
0029BFr 3  E8                           inx             ; get rid of the nt
0029C0r 3  E8                           inx
0029C1r 3               @done:
0029C1r 3  60           z_to_body:      rts
0029C2r 3               
0029C2r 3               
0029C2r 3               
0029C2r 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
0029C2r 3               ; ## ">in"  auto  ANS core
0029C2r 3               xt_to_in:
0029C2r 3  CA                           dex
0029C3r 3  CA                           dex
0029C4r 3               
0029C4r 3  A9 rr                        lda #<toin
0029C6r 3  95 00                        sta 0,x
0029C8r 3  A9 rr                        lda #>toin      ; paranoid, should be zero
0029CAr 3  95 01                        sta 1,x
0029CCr 3               
0029CCr 3  60           z_to_in:        rts
0029CDr 3               
0029CDr 3               
0029CDr 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
0029CDr 3               ; ## ">number"  auto  ANS core
0029CDr 3                       ; """https://forth-standard.org/standard/core/toNUMBER
0029CDr 3                       ; Convert a string to a double number. Logic here is based on the
0029CDr 3                       ; routine by Phil Burk of the same name in pForth, see
0029CDr 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0029CDr 3                       ; for the original Forth code. We arrive here from NUMBER which has
0029CDr 3                       ; made sure that we don't have to deal with a sign and we don't have
0029CDr 3                       ; to deal with a dot as a last character that signalizes double -
0029CDr 3                       ; this should be a pure number string.
0029CDr 3                       ;
0029CDr 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
0029CDr 3                       ; cannot access any of those.
0029CDr 3                       ;
0029CDr 3                       ; For the math routine, we move the inputs to the scratchpad to
0029CDr 3                       ; avoid having to fool around with the Data Stack.
0029CDr 3                       ;
0029CDr 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0029CDr 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
0029CDr 3                       ;     |           |           |           |           |
0029CDr 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
0029CDr 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
0029CDr 3                       ;
0029CDr 3                       ; The math routine works by converting one character to its
0029CDr 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
0029CDr 3                       ; the moment. We then multiply the UD-HI value with the radix
0029CDr 3                       ; (from BASE) using UM*, which returns a double-cell result. We
0029CDr 3                       ; discard the high cell of that result (UD-HI-HI) and store the
0029CDr 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
0029CDr 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
0029CDr 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
0029CDr 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
0029CDr 3                       ; storing the result back in S and S+2, before we start another
0029CDr 3                       ; round with it as the new UD-LO and UD-HI.
0029CDr 3                       ; """
0029CDr 3               
0029CDr 3               
0029CDr 3               xt_to_number:
0029CDr 3  20 rr rr                     jsr underflow_4
0029D0r 3               
0029D0r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
0029D0r 3                               ; After this step, the original ud-lo and ud-hi will still be on
0029D0r 3                               ; the Data Stack, but will be ignored and later overwritten
0029D0r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
0029D0r 3  B5 06                        lda 6,x         ; ud-lo LSB
0029D2r 3  85 rr                        sta scratch
0029D4r 3  B5 07                        lda 7,x         ; ud-lo MSB
0029D6r 3  85 rr                        sta scratch+1
0029D8r 3               
0029D8r 3  B5 04                        lda 4,x         ; ud-hi LSB
0029DAr 3  85 rr                        sta scratch+2
0029DCr 3  B5 05                        lda 5,x         ; ud-hi MSB
0029DEr 3  85 rr                        sta scratch+3
0029E0r 3               
0029E0r 3                               ; Push down one on the Data Stack to use TOS for character
0029E0r 3                               ; conversion ( ud-lo ud-hi addr u x )
0029E0r 3  CA                           dex
0029E1r 3  CA                           dex
0029E2r 3               
0029E2r 3               @loop:
0029E2r 3                               ; Get one character based on address
0029E2r 3  A1 04                        lda (4,x)
0029E4r 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
0029E6r 3  74 01                        stz 1,x                 ; paranoid
0029E8r 3               
0029E8r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
0029EBr 3               
0029EBr 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
0029EBr 3                               ; check the flag. If it is zero, we return what we have and
0029EBr 3                               ; let the caller (usually NUMBER) complain
0029EBr 3  B5 00                        lda 0,x
0029EDr 3  D0 04                        bne @digit_ok
0029EFr 3               
0029EFr 3  E8                           inx
0029F0r 3  E8                           inx
0029F1r 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
0029F3r 3               
0029F3r 3               @digit_ok:
0029F3r 3                               ; Conversion was successful. We arrive here with
0029F3r 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
0029F3r 3                               ; math routine
0029F3r 3               
0029F3r 3                               ; Save n so we don't have to fool around with the
0029F3r 3                               ; Data Stack
0029F3r 3  B5 02                        lda 2,x
0029F5r 3  85 rr                        sta scratch+4
0029F7r 3  B5 03                        lda 3,x
0029F9r 3  85 rr                        sta scratch+5
0029FBr 3               
0029FBr 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
0029FBr 3                               ; original one on the Data Stack) with the radix from BASE.
0029FBr 3                               ; We can clobber TOS and NOS because we saved n
0029FBr 3  A5 rr                        lda scratch+2
0029FDr 3  95 02                        sta 2,x         ; NOS
0029FFr 3  A5 rr                        lda scratch+3
002A01r 3  95 03                        sta 3,x
002A03r 3               
002A03r 3  A5 rr                        lda base
002A05r 3  95 00                        sta 0,x         ; TOS
002A07r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002A09r 3               
002A09r 3                               ; UM* returns a double-celled number
002A09r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002A0Cr 3               
002A0Cr 3                               ; Move ud-hi-lo to safety
002A0Cr 3  B5 02                        lda 2,x         ; ud-hi-lo
002A0Er 3  85 rr                        sta scratch+6
002A10r 3  B5 03                        lda 3,x
002A12r 3  85 rr                        sta scratch+7
002A14r 3               
002A14r 3                               ; Now we multiply ud-lo, overwriting the stack entries
002A14r 3  A5 rr                        lda scratch
002A16r 3  95 02                        sta 2,x
002A18r 3  A5 rr                        lda scratch+1
002A1Ar 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002A1Cr 3               
002A1Cr 3  A5 rr                        lda base
002A1Er 3  95 00                        sta 0,x
002A20r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
002A22r 3               
002A22r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
002A25r 3               
002A25r 3  B5 00                        lda 0,x
002A27r 3  85 rr                        sta scratch+2
002A29r 3  B5 01                        lda 1,x
002A2Br 3  85 rr                        sta scratch+3
002A2Dr 3               
002A2Dr 3  B5 02                        lda 2,x
002A2Fr 3  85 rr                        sta scratch
002A31r 3  B5 03                        lda 3,x
002A33r 3  85 rr                        sta scratch+1
002A35r 3               
002A35r 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
002A35r 3                               ; both in the scratch pad
002A35r 3  18                           clc
002A36r 3  A5 rr                        lda scratch     ; ud-lo LSB
002A38r 3  65 rr                        adc scratch+4   ; n LSB
002A3Ar 3  85 rr                        sta scratch     ; this is the new ud-lo
002A3Cr 3  A5 rr                        lda scratch+1   ; ud-lo MSB
002A3Er 3  65 rr                        adc scratch+5   ; n MSB
002A40r 3  85 rr                        sta scratch+1
002A42r 3               
002A42r 3  A5 rr                        lda scratch+2   ; LSB
002A44r 3  65 rr                        adc scratch+6
002A46r 3  85 rr                        sta scratch+2   ; this is the new ud-hi
002A48r 3  A5 rr                        lda scratch+3   ; MSB
002A4Ar 3  65 rr                        adc scratch+7
002A4Cr 3  85 rr                        sta scratch+3
002A4Er 3               
002A4Er 3                               ; Clean up: Get rid of one of the two top elements on
002A4Er 3                               ; the Data Stack. We don't really care which one
002A4Er 3  E8                           inx
002A4Fr 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
002A50r 3               
002A50r 3                               ; One character down. Move address up
002A50r 3  F6 04                        inc 4,x
002A52r 3  D0 02                        bne @1
002A54r 3  F6 05                        inc 5,x
002A56r 3               @1:
002A56r 3                               ; Decrease counter
002A56r 3  D6 02                        dec 2,x
002A58r 3  D0 88                        bne @loop
002A5Ar 3               
002A5Ar 3               @done:
002A5Ar 3                               ; Counter has reached zero or we have an error. In both
002A5Ar 3                               ; cases, we clean up the Data Stack and return. Error gives
002A5Ar 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
002A5Ar 3                               ; ( ud-lo ud-hi addr u ud-lo )
002A5Ar 3  E8                           inx
002A5Br 3  E8                           inx             ; ( ud-lo ud-hi addr u )
002A5Cr 3               
002A5Cr 3                               ; The new ud-lo and ud-hi are still on the scratch pad
002A5Cr 3  A5 rr                        lda scratch     ; new ud-lo
002A5Er 3  95 06                        sta 6,x
002A60r 3  A5 rr                        lda scratch+1
002A62r 3  95 07                        sta 7,x
002A64r 3               
002A64r 3  A5 rr                        lda scratch+2
002A66r 3  95 04                        sta 4,x
002A68r 3  A5 rr                        lda scratch+3
002A6Ar 3  95 05                        sta 5,x
002A6Cr 3               
002A6Cr 3  60           z_to_number:    rts
002A6Dr 3               
002A6Dr 3               
002A6Dr 3               
002A6Dr 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
002A6Dr 3               ; ## ">order"  tested  Gforth search
002A6Dr 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
002A6Dr 3               
002A6Dr 3               xt_to_order:
002A6Dr 3                               ; Put the wid on the return stack for now.
002A6Dr 3  20 rr rr                     jsr xt_to_r
002A70r 3               
002A70r 3                               ; Get the current search order.
002A70r 3  20 rr rr                     jsr xt_get_order
002A73r 3               
002A73r 3                               ; Get back the wid and add it to the list.
002A73r 3  20 rr rr                     jsr xt_r_from
002A76r 3  20 rr rr                     jsr xt_swap
002A79r 3  20 rr rr                     jsr xt_one_plus
002A7Cr 3               
002A7Cr 3                               ; Set the search order with the new list.
002A7Cr 3  20 rr rr                     jsr xt_set_order
002A7Fr 3               
002A7Fr 3  60           z_to_order:     rts
002A80r 3               
002A80r 3               
002A80r 3               
002A80r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
002A80r 3               ; ## ">r"  auto  ANS core
002A80r 3                       ; """https://forth-standard.org/standard/core/toR
002A80r 3                       ; This word is handled differently for native and for
002A80r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
002A80r 3                       ; word.
002A80r 3                       ; """
002A80r 3               xt_to_r:
002A80r 3                               ; Save the return address. If this word is natively
002A80r 3                               ; coded, this is a complete waste of cycles, but
002A80r 3                               ; required for subroutine coding
002A80r 3  68                           pla             ; LSB
002A81r 3  85 rr                        sta tmptos
002A83r 3  7A                           ply             ; MSB
002A84r 3               
002A84r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002A84r 3               
002A84r 3                               ; We check for underflow in the second step, so we can
002A84r 3                               ; strip off the stack thrashing for native compiling first
002A84r 3  20 rr rr                     jsr underflow_1
002A87r 3               
002A87r 3                               ; now we can do the actual work
002A87r 3  B5 01                        lda 1,x         ; MSB
002A89r 3  48                           pha
002A8Ar 3  B5 00                        lda 0,x         ; LSB
002A8Cr 3  48                           pha
002A8Dr 3               
002A8Dr 3  E8                           inx
002A8Er 3  E8                           inx
002A8Fr 3               
002A8Fr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002A8Fr 3               
002A8Fr 3                               ; restore return address
002A8Fr 3  5A                           phy             ; MSB
002A90r 3  A5 rr                        lda tmptos
002A92r 3  48                           pha             ; LSB
002A93r 3               
002A93r 3  60           z_to_r:         rts
002A94r 3               
002A94r 3               
002A94r 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
002A94r 3               ; ## "true"  auto  ANS core ext
002A94r 3                       ; """https://forth-standard.org/standard/core/TRUE"""
002A94r 3               xt_true:
002A94r 3  CA                           dex
002A95r 3  CA                           dex
002A96r 3  A9 FF                        lda #$FF
002A98r 3  95 00                        sta 0,x
002A9Ar 3  95 01                        sta 1,x
002A9Cr 3               
002A9Cr 3  60           z_true:         rts
002A9Dr 3               
002A9Dr 3               
002A9Dr 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002A9Dr 3               ; ## "tuck"  auto  ANS core ext
002A9Dr 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002A9Dr 3               xt_tuck:
002A9Dr 3  20 rr rr                     jsr underflow_2
002AA0r 3               
002AA0r 3  CA                           dex
002AA1r 3  CA                           dex
002AA2r 3               
002AA2r 3  B4 04                        ldy 4,x         ; LSB
002AA4r 3  B5 02                        lda 2,x
002AA6r 3  95 04                        sta 4,x
002AA8r 3  94 02                        sty 2,x
002AAAr 3  95 00                        sta 0,x
002AACr 3               
002AACr 3  B4 05                        ldy 5,x         ; MSB
002AAEr 3  B5 03                        lda 3,x
002AB0r 3  95 05                        sta 5,x
002AB2r 3  94 03                        sty 3,x         ; bba
002AB4r 3  95 01                        sta 1,x         ; baa
002AB6r 3               
002AB6r 3  60           z_tuck:         rts
002AB7r 3               
002AB7r 3               
002AB7r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002AB7r 3               ; ## "2"  auto  Tali Forth
002AB7r 3                       ;
002AB7r 3                       ; This code is shared with ASSEMBLER-WORDLIST
002AB7r 3               xt_assembler_wordlist:
002AB7r 3               xt_two:
002AB7r 3  CA                           dex
002AB8r 3  CA                           dex
002AB9r 3  A9 02                        lda #2
002ABBr 3  95 00                        sta 0,x
002ABDr 3  74 01                        stz 1,x
002ABFr 3               
002ABFr 3               z_assembler_wordlist:
002ABFr 3  60           z_two:          rts
002AC0r 3               
002AC0r 3               
002AC0r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
002AC0r 3               ; ## "2drop"  auto  ANS core
002AC0r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
002AC0r 3               xt_two_drop:
002AC0r 3  20 rr rr                     jsr underflow_2
002AC3r 3               
002AC3r 3  E8                           inx
002AC4r 3  E8                           inx
002AC5r 3  E8                           inx
002AC6r 3  E8                           inx
002AC7r 3               
002AC7r 3  60           z_two_drop:     rts
002AC8r 3               
002AC8r 3               
002AC8r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002AC8r 3               ; ## "2dup"  auto  ANS core
002AC8r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002AC8r 3               xt_two_dup:
002AC8r 3  20 rr rr                     jsr underflow_2
002ACBr 3               
002ACBr 3  CA                           dex
002ACCr 3  CA                           dex
002ACDr 3  CA                           dex
002ACEr 3  CA                           dex
002ACFr 3               
002ACFr 3  B5 04                        lda 4,x         ; TOS
002AD1r 3  95 00                        sta 0,x
002AD3r 3  B5 05                        lda 5,x
002AD5r 3  95 01                        sta 1,x
002AD7r 3               
002AD7r 3  B5 06                        lda 6,x         ; NOS
002AD9r 3  95 02                        sta 2,x
002ADBr 3  B5 07                        lda 7,x
002ADDr 3  95 03                        sta 3,x
002ADFr 3               
002ADFr 3  60           z_two_dup:      rts
002AE0r 3               
002AE0r 3               
002AE0r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
002AE0r 3               ; ## "2@"  auto  ANS core
002AE0r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
002AE0r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
002AE0r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
002AE0r 3                       ; """
002AE0r 3               xt_two_fetch:
002AE0r 3  20 rr rr                     jsr underflow_1
002AE3r 3               
002AE3r 3  B5 00                        lda 0,x
002AE5r 3  85 rr                        sta tmp1
002AE7r 3  B4 01                        ldy 1,x
002AE9r 3  84 rr                        sty tmp1+1
002AEBr 3               
002AEBr 3  CA                           dex             ; reuse one stack element
002AECr 3  CA                           dex
002AEDr 3               
002AEDr 3  B2 rr                        lda (tmp1)      ; copy LSB
002AEFr 3  95 00                        sta 0,x
002AF1r 3  A0 01                        ldy #1          ; copy next
002AF3r 3  B1 rr                        lda (tmp1),y
002AF5r 3  95 01                        sta 1,x
002AF7r 3  C8                           iny             ; copy next
002AF8r 3  B1 rr                        lda (tmp1),y
002AFAr 3  95 02                        sta 2,x
002AFCr 3  C8                           iny             ; copy next
002AFDr 3  B1 rr                        lda (tmp1),y
002AFFr 3  95 03                        sta 3,x
002B01r 3               
002B01r 3  60           z_two_fetch:    rts
002B02r 3               
002B02r 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
002B02r 3               ; ## "2over"  auto  ANS core
002B02r 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
002B02r 3               xt_two_over:
002B02r 3  20 rr rr                     jsr underflow_4
002B05r 3               
002B05r 3  CA                           dex
002B06r 3  CA                           dex
002B07r 3  CA                           dex
002B08r 3  CA                           dex
002B09r 3               
002B09r 3  B5 08                        lda 8,x
002B0Br 3  95 00                        sta 0,x
002B0Dr 3               
002B0Dr 3  B5 09                        lda 9,x
002B0Fr 3  95 01                        sta 1,x
002B11r 3               
002B11r 3  B5 0A                        lda 10,x
002B13r 3  95 02                        sta 2,x
002B15r 3               
002B15r 3  B5 0B                        lda 11,x
002B17r 3  95 03                        sta 3,x
002B19r 3               
002B19r 3  60           z_two_over:     rts
002B1Ar 3               
002B1Ar 3               
002B1Ar 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002B1Ar 3               ; ## "2r@"  auto  ANS core ext
002B1Ar 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002B1Ar 3                       ;
002B1Ar 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002B1Ar 3                       ; assembler. We use trickery to access the elements on the Return
002B1Ar 3                       ; Stack instead of pulling the return address first and storing
002B1Ar 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002B1Ar 3                       ; it as Never Native; at some point, we should compare versions to
002B1Ar 3                       ; see if an Always Native version would be better
002B1Ar 3                       ; """
002B1Ar 3               xt_two_r_fetch:
002B1Ar 3               		; make room on the Data Stack
002B1Ar 3  CA                           dex
002B1Br 3  CA                           dex
002B1Cr 3  CA                           dex
002B1Dr 3  CA                           dex
002B1Er 3               
002B1Er 3                               ; Get four bytes off of Return Stack. This assumes that
002B1Er 3                               ; we took a subroutine jump here so the first two entries
002B1Er 3                               ; are the return address
002B1Er 3  8A                           txa
002B1Fr 3  BA                           tsx
002B20r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
002B21r 3  7A                           ply
002B22r 3  AA                           tax
002B23r 3               
002B23r 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
002B23r 3                               ; the return address for this word. This is a whole lot
002B23r 3                               ; easier on the 65816
002B23r 3  B9 03 01                     lda $0103,y     ; LSB of top entry
002B26r 3  95 00                        sta 0,x
002B28r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002B2Br 3  95 01                        sta 1,x
002B2Dr 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002B30r 3  95 02                        sta 2,x
002B32r 3  B9 06 01                     lda $0106,y     ; MSB of top entry
002B35r 3  95 03                        sta 3,x
002B37r 3               
002B37r 3  60           z_two_r_fetch:  rts
002B38r 3               
002B38r 3               
002B38r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
002B38r 3               ; ## "2r>"  auto  ANS core ext
002B38r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
002B38r 3                       ; Pull top two entries from Return Stack.
002B38r 3                       ;
002B38r 3                       ; Is the same as
002B38r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
002B38r 3                       ; the top value on the ReturnStack for a STC Forth is the
002B38r 3                       ; return address, which we need to get out of the way first.
002B38r 3                       ; Native compile needs to be handled as a special case.
002B38r 3                       ; """
002B38r 3               xt_two_r_from:
002B38r 3                               ; save the return address
002B38r 3  68                           pla                     ; LSB
002B39r 3  85 rr                        sta tmp1
002B3Br 3  68                           pla                     ; MSB
002B3Cr 3  85 rr                        sta tmp1+1
002B3Er 3               
002B3Er 3                               ; --- CUT HERE FOR NATIVE CODING ---
002B3Er 3               
002B3Er 3               		; make room on stack
002B3Er 3  CA                           dex
002B3Fr 3  CA                           dex
002B40r 3  CA                           dex
002B41r 3  CA                           dex
002B42r 3               
002B42r 3                               ; In theory, we should test for underflow on the Return
002B42r 3                               ; Stack. However, given the traffic there with an STC
002B42r 3                               ; Forth, that's probably not really useful
002B42r 3               
002B42r 3                               ; now we can access the data
002B42r 3  68                           pla                     ; LSB
002B43r 3  95 00                        sta 0,x
002B45r 3  68                           pla                     ; MSB
002B46r 3  95 01                        sta 1,x
002B48r 3               
002B48r 3  68                           pla                     ; LSB
002B49r 3  95 02                        sta 2,x
002B4Br 3  68                           pla                     ; MSB
002B4Cr 3  95 03                        sta 3,x
002B4Er 3               
002B4Er 3                               ; --- CUT HERE FOR NATIVE CODING ---
002B4Er 3               
002B4Er 3                               ; restore return address
002B4Er 3  A5 rr                        lda tmp1+1              ; MSB
002B50r 3  48                           pha
002B51r 3  A5 rr                        lda tmp1                ; LSB
002B53r 3  48                           pha
002B54r 3               
002B54r 3  60           z_two_r_from:   rts
002B55r 3               
002B55r 3               
002B55r 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
002B55r 3               ; ## "2/"  auto  ANS core
002B55r 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
002B55r 3               xt_two_slash:
002B55r 3  20 rr rr                     jsr underflow_1
002B58r 3               
002B58r 3                               ; We can't just LSR the LSB and ROR the MSB because that
002B58r 3                               ; would do bad things to the sign
002B58r 3  B5 01                        lda 1,x
002B5Ar 3  0A                           asl                     ; save the sign
002B5Br 3  76 01                        ror 1,x
002B5Dr 3  76 00                        ror 0,x
002B5Fr 3               
002B5Fr 3  60           z_two_slash:    rts
002B60r 3               
002B60r 3               
002B60r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
002B60r 3               ; ## "2*"  auto  ANS core
002B60r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
002B60r 3                       ;
002B60r 3                       ; Also used for CELLS
002B60r 3                       ; """
002B60r 3               xt_two_star:
002B60r 3               xt_cells:
002B60r 3  20 rr rr                     jsr underflow_1
002B63r 3               
002B63r 3  16 00                        asl 0,x
002B65r 3  36 01                        rol 1,x
002B67r 3               z_cells:
002B67r 3  60           z_two_star:     rts
002B68r 3               
002B68r 3               
002B68r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
002B68r 3               ; ## "2!"  auto  ANS core
002B68r 3                       ; """https://forth-standard.org/standard/core/TwoStore
002B68r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
002B68r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
002B68r 3                       ; """
002B68r 3               xt_two_store:
002B68r 3  20 rr rr                     jsr underflow_3
002B6Br 3               
002B6Br 3  B5 00                        lda 0,x
002B6Dr 3  85 rr                        sta tmp1
002B6Fr 3  B4 01                        ldy 1,x
002B71r 3  84 rr                        sty tmp1+1
002B73r 3               
002B73r 3  E8                           inx
002B74r 3  E8                           inx
002B75r 3               
002B75r 3  B5 00                        lda 0,x         ; copy MSB
002B77r 3  92 rr                        sta (tmp1)
002B79r 3  B5 01                        lda 1,x         ; copy next
002B7Br 3  A0 01                        ldy #1
002B7Dr 3  91 rr                        sta (tmp1),y
002B7Fr 3  B5 02                        lda 2,x         ; copy next
002B81r 3  C8                           iny
002B82r 3  91 rr                        sta (tmp1),y
002B84r 3  B5 03                        lda 3,x         ; copy MSB
002B86r 3  C8                           iny
002B87r 3  91 rr                        sta (tmp1),y
002B89r 3               
002B89r 3  E8                           inx             ; 2DROP
002B8Ar 3  E8                           inx
002B8Br 3  E8                           inx
002B8Cr 3  E8                           inx
002B8Dr 3               
002B8Dr 3  60           z_two_store:    rts
002B8Er 3               
002B8Er 3               
002B8Er 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
002B8Er 3               ; ## "2swap"  auto  ANS core
002B8Er 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
002B8Er 3               xt_two_swap:
002B8Er 3  20 rr rr                     jsr underflow_4
002B91r 3               
002B91r 3                               ; 0 <-> 4
002B91r 3  B5 00                        lda 0,x
002B93r 3  B4 04                        ldy 4,x
002B95r 3  95 04                        sta 4,x
002B97r 3  94 00                        sty 0,x
002B99r 3               
002B99r 3                               ; 1 <-> 5
002B99r 3  B5 01                        lda 1,x
002B9Br 3  B4 05                        ldy 5,x
002B9Dr 3  95 05                        sta 5,x
002B9Fr 3  94 01                        sty 1,x
002BA1r 3               
002BA1r 3                               ; 2 <-> 6
002BA1r 3  B5 02                        lda 2,x
002BA3r 3  B4 06                        ldy 6,x
002BA5r 3  95 06                        sta 6,x
002BA7r 3  94 02                        sty 2,x
002BA9r 3               
002BA9r 3                               ; 3 <-> 7
002BA9r 3  B5 03                        lda 3,x
002BABr 3  B4 07                        ldy 7,x
002BADr 3  95 07                        sta 7,x
002BAFr 3  94 03                        sty 3,x
002BB1r 3               
002BB1r 3  60           z_two_swap:     rts
002BB2r 3               
002BB2r 3               
002BB2r 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
002BB2r 3               ; ## "2>r"  auto  ANS core ext
002BB2r 3                       ; """https://forth-standard.org/standard/core/TwotoR
002BB2r 3                       ; Push top two entries to Return Stack.
002BB2r 3                       ;
002BB2r 3                       ; The same as SWAP >R >R
002BB2r 3                       ; except that if we jumped here, the return address will be in the
002BB2r 3                       ; way. May not be natively compiled unless we're clever and use
002BB2r 3                       ; special routines.
002BB2r 3                       ; """
002BB2r 3               xt_two_to_r:
002BB2r 3                               ; save the return address
002BB2r 3  68                           pla             ; LSB
002BB3r 3  85 rr                        sta tmp1
002BB5r 3  68                           pla             ; MSB
002BB6r 3  85 rr                        sta tmp1+1
002BB8r 3               
002BB8r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002BB8r 3               
002BB8r 3  20 rr rr                     jsr underflow_2
002BBBr 3               
002BBBr 3                               ; now we can move the data
002BBBr 3  B5 03                        lda 3,x         ; MSB
002BBDr 3  48                           pha
002BBEr 3  B5 02                        lda 2,x         ; LSB
002BC0r 3  48                           pha
002BC1r 3               
002BC1r 3                               ; now we can move the data
002BC1r 3  B5 01                        lda 1,x         ; MSB
002BC3r 3  48                           pha
002BC4r 3  B5 00                        lda 0,x         ; LSB
002BC6r 3  48                           pha
002BC7r 3               
002BC7r 3  E8                           inx
002BC8r 3  E8                           inx
002BC9r 3  E8                           inx
002BCAr 3  E8                           inx
002BCBr 3               
002BCBr 3                               ; --- CUT HERE FOR NATIVE CODING ---
002BCBr 3               
002BCBr 3                               ; restore return address
002BCBr 3  A5 rr                        lda tmp1+1      ; MSB
002BCDr 3  48                           pha
002BCEr 3  A5 rr                        lda tmp1        ; LSB
002BD0r 3  48                           pha
002BD1r 3               
002BD1r 3  60           z_two_to_r:     rts
002BD2r 3               
002BD2r 3               
002BD2r 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
002BD2r 3               ; ## "2constant"  auto  ANS double
002BD2r 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
002BD2r 3                       ;
002BD2r 3                       ; Based on the Forth code
002BD2r 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
002BD2r 3                       ; """
002BD2r 3               xt_two_constant:
002BD2r 3  20 rr rr                     jsr underflow_2
002BD5r 3               
002BD5r 3  20 rr rr                     jsr xt_create
002BD8r 3  20 rr rr                     jsr xt_swap
002BDBr 3  20 rr rr                     jsr xt_comma
002BDEr 3  20 rr rr                     jsr xt_comma
002BE1r 3               
002BE1r 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
002BE4r 3  20 rr rr                     jsr dodoes
002BE7r 3               
002BE7r 3  20 rr rr                     jsr xt_dup
002BEAr 3  20 rr rr                     jsr xt_fetch
002BEDr 3  20 rr rr                     jsr xt_swap
002BF0r 3  20 rr rr                     jsr xt_cell_plus
002BF3r 3  20 rr rr                     jsr xt_fetch
002BF6r 3               
002BF6r 3  60           z_two_constant: rts
002BF7r 3               
002BF7r 3               
002BF7r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002BF7r 3               ; ## "2literal"  auto  ANS double
002BF7r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002BF7r 3                       ; Based on the Forth code
002BF7r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002BF7r 3                       ; """
002BF7r 3               xt_two_literal:
002BF7r 3  20 rr rr                     jsr underflow_2 ; double number
002BFAr 3               
002BFAr 3  20 rr rr                     jsr xt_swap
002BFDr 3  20 rr rr                     jsr xt_literal
002C00r 3  20 rr rr                     jsr xt_literal
002C03r 3               
002C03r 3  60           z_two_literal:  rts
002C04r 3               
002C04r 3               
002C04r 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
002C04r 3               ; ## "2variable"  auto  ANS double
002C04r 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
002C04r 3                       ; The variable is not initialized to zero.
002C04r 3                       ;
002C04r 3                       ; This can be realized in Forth as either
002C04r 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
002C04r 3                       ; """
002C04r 3               xt_two_variable:
002C04r 3                               ; We just let CRATE and ALLOT do the heavy lifting
002C04r 3  20 rr rr                     jsr xt_create
002C07r 3               
002C07r 3  CA                           dex
002C08r 3  CA                           dex
002C09r 3  A9 04                        lda #4
002C0Br 3  95 00                        sta 0,x
002C0Dr 3  74 01                        stz 1,x
002C0Fr 3               
002C0Fr 3  20 rr rr                     jsr xt_allot
002C12r 3               
002C12r 3  60           z_two_variable: rts
002C13r 3               
002C13r 3               
002C13r 3               ; ## TYPE ( addr u -- ) "Print string"
002C13r 3               ; ## "type"  auto  ANS core
002C13r 3                       ; """https://forth-standard.org/standard/core/TYPE
002C13r 3                       ; Works through EMIT to allow OUTPUT revectoring.
002C13r 3                       ; """
002C13r 3               
002C13r 3               xt_type:
002C13r 3  20 rr rr                     jsr underflow_2
002C16r 3               
002C16r 3                               ; Save the starting address into tmp1
002C16r 3  B5 02                        lda 2,x
002C18r 3  85 rr                        sta tmp1
002C1Ar 3  B5 03                        lda 3,x
002C1Cr 3  85 rr                        sta tmp1+1
002C1Er 3               @loop:
002C1Er 3                               ; done if length is zero
002C1Er 3  B5 00                        lda 0,x
002C20r 3  15 01                        ora 1,x
002C22r 3  F0 15                        beq @done
002C24r 3               
002C24r 3                               ; Send the current character
002C24r 3  B2 rr                        lda (tmp1)
002C26r 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002C29r 3               
002C29r 3                               ; Move the address along (in tmp1)
002C29r 3  E6 rr                        inc tmp1
002C2Br 3  D0 02                        bne @1
002C2Dr 3  E6 rr                        inc tmp1+1
002C2Fr 3               @1:
002C2Fr 3                               ; Reduce the count (on the data stack)
002C2Fr 3  B5 00                        lda 0,x
002C31r 3  D0 02                        bne @2
002C33r 3  D6 01                        dec 1,x
002C35r 3               @2:
002C35r 3  D6 00                        dec 0,x
002C37r 3               
002C37r 3  80 E5                        bra @loop
002C39r 3               @done:
002C39r 3  E8                           inx
002C3Ar 3  E8                           inx
002C3Br 3  E8                           inx
002C3Cr 3  E8                           inx
002C3Dr 3               
002C3Dr 3  60           z_type:         rts
002C3Er 3               
002C3Er 3               
002C3Er 3               
002C3Er 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
002C3Er 3               ; ## "u."  tested  ANS core
002C3Er 3                       ; """https://forth-standard.org/standard/core/Ud
002C3Er 3                       ;
002C3Er 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
002C3Er 3                       ; We use the internal assembler function print_u followed
002C3Er 3                       ; by a single space
002C3Er 3                       ; """
002C3Er 3               xt_u_dot:
002C3Er 3  20 rr rr                     jsr underflow_1
002C41r 3               
002C41r 3  20 rr rr                     jsr print_u
002C44r 3  A9 20                        lda #AscSP
002C46r 3  20 rr rr                     jsr emit_a
002C49r 3               
002C49r 3  60           z_u_dot:        rts
002C4Ar 3               
002C4Ar 3               
002C4Ar 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
002C4Ar 3               ; ## "u.r"  tested  ANS core ext
002C4Ar 3                       ; """https://forth-standard.org/standard/core/UDotR"""
002C4Ar 3               xt_u_dot_r:
002C4Ar 3  20 rr rr                     jsr underflow_2
002C4Dr 3               
002C4Dr 3  20 rr rr                     jsr xt_to_r
002C50r 3  20 rr rr                     jsr xt_zero
002C53r 3  20 rr rr                     jsr xt_less_number_sign
002C56r 3  20 rr rr                     jsr xt_number_sign_s
002C59r 3  20 rr rr                     jsr xt_number_sign_greater
002C5Cr 3  20 rr rr                     jsr xt_r_from
002C5Fr 3  20 rr rr                     jsr xt_over
002C62r 3  20 rr rr                     jsr xt_minus
002C65r 3  20 rr rr                     jsr xt_spaces
002C68r 3  20 rr rr                     jsr xt_type
002C6Br 3               
002C6Br 3  60           z_u_dot_r:      rts
002C6Cr 3               
002C6Cr 3               
002C6Cr 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
002C6Cr 3               ; ## "u>"  auto  ANS core ext
002C6Cr 3                       ; """https://forth-standard.org/standard/core/Umore"""
002C6Cr 3               xt_u_greater_than:
002C6Cr 3  20 rr rr                     jsr underflow_2
002C6Fr 3               
002C6Fr 3  B5 00                        lda 0,x
002C71r 3  D5 02                        cmp 2,x
002C73r 3  B5 01                        lda 1,x
002C75r 3  F5 03                        sbc 3,x
002C77r 3  E8                           inx
002C78r 3  E8                           inx
002C79r 3               
002C79r 3  A9 00                        lda #0
002C7Br 3  69 FF                        adc #$ff
002C7Dr 3  95 00                        sta 0,x         ; store flag
002C7Fr 3  95 01                        sta 1,x
002C81r 3               
002C81r 3  60           z_u_greater_than:    rts
002C82r 3               
002C82r 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
002C82r 3               ; ## "u<"  auto  ANS core
002C82r 3                       ; """https://forth-standard.org/standard/core/Uless"""
002C82r 3               xt_u_less_than:
002C82r 3  20 rr rr                     jsr underflow_2
002C85r 3               
002C85r 3  B5 02                        lda 2,x
002C87r 3  D5 00                        cmp 0,x
002C89r 3  B5 03                        lda 3,x
002C8Br 3  F5 01                        sbc 1,x
002C8Dr 3  E8                           inx
002C8Er 3  E8                           inx
002C8Fr 3               
002C8Fr 3  A9 00                        lda #0
002C91r 3  69 FF                        adc #$ff
002C93r 3  95 00                        sta 0,x         ; store flag
002C95r 3  95 01                        sta 1,x
002C97r 3               
002C97r 3  60           z_u_less_than:    rts
002C98r 3               
002C98r 3               
002C98r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002C98r 3               ; ## "ud."  auto  Tali double
002C98r 3                       ;
002C98r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002C98r 3                       ; """
002C98r 3               xt_ud_dot:
002C98r 3  20 rr rr                     jsr underflow_2 ; double number
002C9Br 3               
002C9Br 3  20 rr rr                     jsr xt_less_number_sign
002C9Er 3  20 rr rr                     jsr xt_number_sign_s
002CA1r 3  20 rr rr                     jsr xt_number_sign_greater
002CA4r 3  20 rr rr                     jsr xt_type
002CA7r 3  20 rr rr                     jsr xt_space
002CAAr 3               
002CAAr 3  60           z_ud_dot:        rts
002CABr 3               
002CABr 3               
002CABr 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002CABr 3               ; ## "ud.r"  auto  Tali double
002CABr 3                       ;
002CABr 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002CABr 3                       ; """
002CABr 3               xt_ud_dot_r:
002CABr 3  20 rr rr                     jsr underflow_3
002CAEr 3               
002CAEr 3  20 rr rr                     jsr xt_to_r
002CB1r 3  20 rr rr                     jsr xt_less_number_sign
002CB4r 3  20 rr rr                     jsr xt_number_sign_s
002CB7r 3  20 rr rr                     jsr xt_number_sign_greater
002CBAr 3  20 rr rr                     jsr xt_r_from
002CBDr 3  20 rr rr                     jsr xt_over
002CC0r 3  20 rr rr                     jsr xt_minus
002CC3r 3  20 rr rr                     jsr xt_spaces
002CC6r 3  20 rr rr                     jsr xt_type
002CC9r 3               
002CC9r 3  60           z_ud_dot_r:      rts
002CCAr 3               
002CCAr 3               
002CCAr 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002CCAr 3               ; ## "um/mod"  auto  ANS core
002CCAr 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002CCAr 3                       ; Divide double cell number by single cell number, returning the
002CCAr 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002CCAr 3                       ; This is the basic division operation all others use. Based on FIG
002CCAr 3                       ; Forth code, modified by Garth Wilson, see
002CCAr 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002CCAr 3                       ;
002CCAr 3                       ; This uses tmp1, tmp1+1, and tmptos
002CCAr 3                       ; """
002CCAr 3               
002CCAr 3               xt_um_slash_mod:
002CCAr 3  20 rr rr                     jsr underflow_3
002CCDr 3               
002CCDr 3                               ; catch division by zero
002CCDr 3  B5 00                        lda 0,x
002CCFr 3  15 01                        ora 1,x
002CD1r 3  D0 05                        bne @not_zero
002CD3r 3               
002CD3r 3  A9 04                        lda #err_divzero
002CD5r 3  4C rr rr                     jmp error
002CD8r 3               
002CD8r 3               @not_zero:
002CD8r 3                               ; We loop 17 times
002CD8r 3  A9 11                        lda #17
002CDAr 3  85 rr                        sta tmptos
002CDCr 3               
002CDCr 3               @loop:
002CDCr 3                               ; rotate low cell of dividend one bit left (LSB)
002CDCr 3  36 04                        rol 4,x
002CDEr 3  36 05                        rol 5,x
002CE0r 3               
002CE0r 3                               ; loop control
002CE0r 3  C6 rr                        dec tmptos
002CE2r 3  F0 22                        beq @done
002CE4r 3               
002CE4r 3                               ; rotate high cell of dividend one bit left (MSB)
002CE4r 3  36 02                        rol 2,x
002CE6r 3  36 03                        rol 3,x
002CE8r 3               
002CE8r 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
002CEAr 3  26 rr                        rol tmp1
002CECr 3               
002CECr 3                               ; subtract dividend hi cell minus divisor
002CECr 3  38                           sec
002CEDr 3  B5 02                        lda 2,x
002CEFr 3  F5 00                        sbc 0,x
002CF1r 3  85 rr                        sta tmp1+1
002CF3r 3  B5 03                        lda 3,x
002CF5r 3  F5 01                        sbc 1,x
002CF7r 3               
002CF7r 3  A8                           tay
002CF8r 3  A5 rr                        lda tmp1
002CFAr 3  E9 00                        sbc #0
002CFCr 3  90 DE                        bcc @loop
002CFEr 3               
002CFEr 3                               ; make result new dividend high cell
002CFEr 3  A5 rr                        lda tmp1+1
002D00r 3  95 02                        sta 2,x
002D02r 3  94 03                        sty 3,x         ; used as temp storage
002D04r 3               
002D04r 3  80 D6                        bra @loop
002D06r 3               @done:
002D06r 3  E8                           inx
002D07r 3  E8                           inx
002D08r 3               
002D08r 3  20 rr rr                     jsr xt_swap
002D0Br 3               
002D0Br 3  60           z_um_slash_mod: rts
002D0Cr 3               
002D0Cr 3               
002D0Cr 3               
002D0Cr 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002D0Cr 3               ; ## "um*"  auto  ANS core
002D0Cr 3                       ; """https://forth-standard.org/standard/core/UMTimes
002D0Cr 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002D0Cr 3                       ; Old Forth versions such as FIG Forth call this U*
002D0Cr 3                       ;
002D0Cr 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002D0Cr 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002D0Cr 3                       ; discussion.
002D0Cr 3                       ;
002D0Cr 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002D0Cr 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002D0Cr 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002D0Cr 3                       ;
002D0Cr 3                       ; Consider switching to a table-supported version based on
002D0Cr 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002D0Cr 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002D0Cr 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002D0Cr 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002D0Cr 3                       ; """
002D0Cr 3               
002D0Cr 3               xt_um_star:
002D0Cr 3  20 rr rr                     jsr underflow_2
002D0Fr 3               
002D0Fr 3                               ; to eliminate clc inside the loop, the value at
002D0Fr 3                               ; tmp1 is reduced by 1 in advance
002D0Fr 3  18                           clc
002D10r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
002D12r 3  E9 00                        sbc #0
002D14r 3  85 rr                        sta tmp2
002D16r 3               
002D16r 3  B5 01                        lda 1,x
002D18r 3  E9 00                        sbc #0
002D1Ar 3  90 31                        bcc @zero       ; is TOS zero?
002D1Cr 3  85 rr                        sta tmp2+1
002D1Er 3               
002D1Er 3  A9 00                        lda #0
002D20r 3  85 rr                        sta tmp1
002D22r 3  86 rr                        stx tmp3        ; tested for exit from outer loop
002D24r 3  CA                           dex
002D25r 3  CA                           dex
002D26r 3               
002D26r 3               @outer_loop:
002D26r 3  A0 08                        ldy #8          ; counter inner loop
002D28r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002D2Ar 3               
002D2Ar 3               @inner_loop:
002D2Ar 3  90 0C                        bcc @no_add
002D2Cr 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002D2Er 3  A5 rr                        lda tmp1
002D30r 3  65 rr                        adc tmp2
002D32r 3  85 rr                        sta tmp1
002D34r 3  A5 rr                        lda tmp1+1
002D36r 3  65 rr                        adc tmp2+1
002D38r 3               
002D38r 3               @no_add:
002D38r 3  6A                           ror
002D39r 3  66 rr                        ror tmp1
002D3Br 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
002D3Dr 3               
002D3Dr 3  88                           dey
002D3Er 3  D0 EA                        bne @inner_loop ; go back for one more shift?
002D40r 3               
002D40r 3  E8                           inx
002D41r 3  E4 rr                        cpx tmp3
002D43r 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
002D45r 3               
002D45r 3                               ; all done, store high word of result
002D45r 3  95 01                        sta 1,x
002D47r 3  A5 rr                        lda tmp1
002D49r 3  95 00                        sta 0,x
002D4Br 3  80 04                        bra @done
002D4Dr 3               
002D4Dr 3               @zero:
002D4Dr 3  74 02                        stz 2,x
002D4Fr 3  74 03                        stz 3,x
002D51r 3               @done:
002D51r 3  60           z_um_star:      rts
002D52r 3               
002D52r 3               
002D52r 3               
002D52r 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
002D52r 3               ; ## "unloop"  auto  ANS core
002D52r 3                       ; """https://forth-standard.org/standard/core/UNLOOP
002D52r 3                       ;
002D52r 3                       ; Note that 6xPLA uses just as many bytes as a loop would
002D52r 3                       ; """
002D52r 3               xt_unloop:
002D52r 3                               ; Drop fudge number (limit/start from DO/?DO off the
002D52r 3                               ; return stack
002D52r 3  68                           pla
002D53r 3  68                           pla
002D54r 3  68                           pla
002D55r 3  68                           pla
002D56r 3               
002D56r 3                               ; Now drop the LEAVE address that was below them off
002D56r 3                               ; the Return Stack as well
002D56r 3  68                           pla
002D57r 3  68                           pla
002D58r 3               
002D58r 3  60           z_unloop:       rts
002D59r 3               
002D59r 3               
002D59r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
002D59r 3               ; ## "until"  auto  ANS core
002D59r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
002D59r 3               xt_until:
002D59r 3                               ; Compile a 0BRANCH
002D59r 3  A0 rr                        ldy #>zero_branch_runtime
002D5Br 3  A9 rr                        lda #<zero_branch_runtime
002D5Dr 3  20 rr rr                     jsr cmpl_subroutine
002D60r 3               
002D60r 3                               ; The address to loop back to is on the stack.
002D60r 3                               ; Just compile it as the destination for the
002D60r 3                               ; 0branch.
002D60r 3  20 rr rr                     jsr xt_comma
002D63r 3               
002D63r 3  60           z_until:        rts
002D64r 3               
002D64r 3               
002D64r 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
002D64r 3               ; ## "unused"  auto  ANS core ext
002D64r 3                       ; """https://forth-standard.org/standard/core/UNUSED
002D64r 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
002D64r 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
002D64r 3                       ; defaults to $400
002D64r 3                       ; """
002D64r 3               xt_unused:
002D64r 3  CA                           dex
002D65r 3  CA                           dex
002D66r 3               
002D66r 3  A9 FF                        lda #<cp_end
002D68r 3  38                           sec
002D69r 3  E5 rr                        sbc cp
002D6Br 3  95 00                        sta 0,x
002D6Dr 3               
002D6Dr 3  A9 7F                        lda #>cp_end
002D6Fr 3  E5 rr                        sbc cp+1
002D71r 3  95 01                        sta 1,x
002D73r 3               
002D73r 3  60           z_unused:       rts
002D74r 3               
002D74r 3               
002D74r 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
002D74r 3               ; ## "update"  auto  ANS block
002D74r 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
002D74r 3               xt_update:
002D74r 3                               ; Turn on the dirty bit. We can't use TSB here because it only
002D74r 3                               ; has Absolute and Direct Pages addressing modes
002D74r 3  A0 2C                        ldy #buffstatus_offset
002D76r 3  B1 rr                        lda (up),y
002D78r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
002D7Ar 3  91 rr                        sta (up),y
002D7Cr 3               
002D7Cr 3  60           z_update:       rts
002D7Dr 3               
002D7Dr 3               
002D7Dr 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
002D7Dr 3               ; ## "useraddr"  tested  Tali Forth
002D7Dr 3               xt_useraddr:
002D7Dr 3  CA                           dex
002D7Er 3  CA                           dex
002D7Fr 3  A9 rr                        lda #<up
002D81r 3  95 00                        sta 0,x
002D83r 3  A9 rr                        lda #>up
002D85r 3  95 01                        sta 1,x
002D87r 3               
002D87r 3  60           z_useraddr:     rts
002D88r 3               
002D88r 3               
002D88r 3               ; ## VALUE ( n "name" -- ) "Define a value"
002D88r 3               ; ## "value"  auto  ANS core
002D88r 3                       ; """https://forth-standard.org/standard/core/VALUE
002D88r 3                       ;
002D88r 3                       ; This is a dummy header for the WORDLIST. The actual code is
002D88r 3                       ; identical to that of CONSTANT
002D88r 3                       ; """
002D88r 3               
002D88r 3               
002D88r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
002D88r 3               ; ## "variable"  auto  ANS core
002D88r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
002D88r 3                       ; There are various Forth definitions for this word, such as
002D88r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
002D88r 3                       ; second one so the variable is initialized to zero
002D88r 3                       ; """
002D88r 3               xt_variable:
002D88r 3                               ; we let CREATE do the heavy lifting
002D88r 3  20 rr rr                     jsr xt_create
002D8Br 3               
002D8Br 3                               ; there is no "STZ (CP)" so we have to do this the hard
002D8Br 3                               ; way
002D8Br 3  A9 00                        lda #0
002D8Dr 3               
002D8Dr 3  92 rr                        sta (cp)
002D8Fr 3  E6 rr                        inc cp
002D91r 3  D0 02                        bne @1
002D93r 3  E6 rr                        inc cp+1
002D95r 3               @1:
002D95r 3  92 rr                        sta (cp)
002D97r 3  E6 rr                        inc cp
002D99r 3  D0 02                        bne @2
002D9Br 3  E6 rr                        inc cp+1
002D9Dr 3               @2:
002D9Dr 3                               ; Now we need to adjust the length of the complete word by two
002D9Dr 3  20 rr rr                     jsr adjust_z
002DA0r 3               
002DA0r 3  60           z_variable:     rts
002DA1r 3               
002DA1r 3               
002DA1r 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
002DA1r 3               ; ## "while"  auto  ANS core
002DA1r 3                       ; """http://forth-standard.org/standard/core/WHILE"""
002DA1r 3               xt_while:
002DA1r 3                               ; Compile a 0branch
002DA1r 3  A0 rr                        ldy #>zero_branch_runtime
002DA3r 3  A9 rr                        lda #<zero_branch_runtime
002DA5r 3  20 rr rr                     jsr cmpl_subroutine
002DA8r 3               
002DA8r 3                               ; Put the address (here) where the destination
002DA8r 3                               ; address needs to go so it can be put there later.
002DA8r 3  20 rr rr                     jsr xt_here
002DABr 3               
002DABr 3                               ; Fill in the destination address with 0 for now.
002DABr 3  20 rr rr                     jsr xt_zero
002DAEr 3  20 rr rr                     jsr xt_comma
002DB1r 3               
002DB1r 3                               ; Swap the two addresses on the stack.
002DB1r 3  20 rr rr                     jsr xt_swap
002DB4r 3               
002DB4r 3  60           z_while:        rts
002DB5r 3               
002DB5r 3               
002DB5r 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
002DB5r 3               ; ## "within"  auto  ANS core ext
002DB5r 3                       ; """https://forth-standard.org/standard/core/WITHIN
002DB5r 3                       ;
002DB5r 3                       ; This an assembler version of the ANS Forth implementation
002DB5r 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
002DB5r 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
002DB5r 3                       ; ROT TUCK > -ROT > INVERT AND
002DB5r 3                       ; """"
002DB5r 3               xt_within:
002DB5r 3  20 rr rr                     jsr underflow_3
002DB8r 3               
002DB8r 3  20 rr rr                     jsr xt_over
002DBBr 3  20 rr rr                     jsr xt_minus
002DBEr 3  20 rr rr                     jsr xt_to_r
002DC1r 3  20 rr rr                     jsr xt_minus
002DC4r 3  20 rr rr                     jsr xt_r_from
002DC7r 3  20 rr rr                     jsr xt_u_less_than
002DCAr 3               
002DCAr 3  60           z_within:       rts
002DCBr 3               
002DCBr 3               
002DCBr 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002DCBr 3               ; ## "word"  auto  ANS core
002DCBr 3                       ; """https://forth-standard.org/standard/core/WORD
002DCBr 3                       ; Obsolete parsing word included for backwards compatibility only.
002DCBr 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002DCBr 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002DCBr 3                       ; Returns the result as a counted string (requires COUNT to convert
002DCBr 3                       ; to modern format), and inserts a space after the string. See "Forth
002DCBr 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002DCBr 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002DCBr 3                       ; for discussions of why you shouldn't be using WORD anymore.
002DCBr 3                       ;
002DCBr 3                       ; Forth
002DCBr 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002DCBr 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002DCBr 3                       ; """
002DCBr 3               
002DCBr 3               xt_word:
002DCBr 3  20 rr rr                     jsr underflow_1
002DCEr 3               
002DCEr 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
002DCEr 3                               ; but unlike PARSE
002DCEr 3  A4 rr                        ldy toin                ; >IN
002DD0r 3               @loop:
002DD0r 3  C4 rr                        cpy ciblen              ; quit if end of input
002DD2r 3  F0 09                        beq @found_char
002DD4r 3  B1 rr                        lda (cib),y
002DD6r 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002DD8r 3  D0 03                        bne @found_char
002DDAr 3               
002DDAr 3  C8                           iny
002DDBr 3  80 F3                        bra @loop
002DDDr 3               @found_char:
002DDDr 3                               ; Save index of where word starts
002DDDr 3  84 rr                        sty toin
002DDFr 3               
002DDFr 3                               ; The real work is done by parse
002DDFr 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
002DE2r 3               
002DE2r 3                               ; Convert the modern ( addr u ) string format to obsolete
002DE2r 3                               ; ( caddr ) format. We just do this in the Dictionary
002DE2r 3  B5 00                        lda 0,x
002DE4r 3  92 rr                        sta (cp)                ; Save length of string
002DE6r 3  48                           pha                     ; Keep copy of length for later
002DE7r 3               
002DE7r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002DEAr 3  A5 rr                        lda cp
002DECr 3  18                           clc
002DEDr 3  69 01                        adc #1
002DEFr 3  95 02                        sta 2,x                 ; LSB of CP
002DF1r 3  A5 rr                        lda cp+1
002DF3r 3  69 00                        adc #0
002DF5r 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002DF7r 3               
002DF7r 3  20 rr rr                     jsr xt_move
002DFAr 3               
002DFAr 3                               ; Return caddr
002DFAr 3  CA                           dex
002DFBr 3  CA                           dex
002DFCr 3  A5 rr                        lda cp
002DFEr 3  95 00                        sta 0,x
002E00r 3  A5 rr                        lda cp+1
002E02r 3  95 01                        sta 1,x
002E04r 3               
002E04r 3                               ; Adjust CP
002E04r 3  68                           pla                     ; length of string
002E05r 3  18                           clc
002E06r 3  65 rr                        adc cp
002E08r 3  85 rr                        sta cp
002E0Ar 3  A5 rr                        lda cp+1
002E0Cr 3  69 00                        adc #0                  ; we only need the carry
002E0Er 3  85 rr                        sta cp+1
002E10r 3  60           z_word:         rts
002E11r 3               
002E11r 3               
002E11r 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
002E11r 3               ; ## "wordlist" auto ANS search
002E11r 3                       ; """https://forth-standard.org/standard/search/WORDLIST
002E11r 3                       ; See the tutorial on Wordlists and the Search Order for
002E11r 3                       ; more information.
002E11r 3                       ; """
002E11r 3               
002E11r 3               xt_wordlist:
002E11r 3                               ; Get the current number of wordlists
002E11r 3  A0 05                        ldy #num_wordlists_offset
002E13r 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
002E15r 3                                               ; the LSB needs to be checked.
002E15r 3               
002E15r 3                               ; See if we are already at the max.
002E15r 3  C9 0C                        cmp #max_wordlists
002E17r 3  D0 05                        bne @ok
002E19r 3               
002E19r 3                               ; Print an error message if all wordlists used.
002E19r 3  A9 0B                        lda #err_wordlist
002E1Br 3  4C rr rr                     jmp error
002E1Er 3               
002E1Er 3               @ok:
002E1Er 3  1A                           inc             ; Increment the wordlist#
002E1Fr 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
002E21r 3  CA                           dex             ; and put it on the stack.
002E22r 3  CA                           dex
002E23r 3  95 00                        sta 0,x
002E25r 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002E27r 3               
002E27r 3  60           z_wordlist:     rts
002E28r 3               
002E28r 3               
002E28r 3               
002E28r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002E28r 3               ; ## "words"  tested  ANS tools
002E28r 3                       ; """https://forth-standard.org/standard/tools/WORDS
002E28r 3                       ; This is pretty much only used at the command line so we can
002E28r 3                       ; be slow and try to save space.
002E28r 3                       ; """
002E28r 3               
002E28r 3               xt_words:
002E28r 3                               ; we follow Gforth by starting on the next
002E28r 3                               ; line
002E28r 3  20 rr rr                     jsr xt_cr
002E2Br 3               
002E2Br 3                               ; We pretty-format the output by inserting a line break
002E2Br 3                               ; before the end of the line. We can get away with pushing
002E2Br 3                               ; the counter to the stack because this is usually an
002E2Br 3                               ; interactive word and speed is not that important
002E2Br 3  A9 00                        lda #0
002E2Dr 3  48                           pha
002E2Er 3               
002E2Er 3                               ; Set up for traversing the wordlist search order.
002E2Er 3  CA                           dex                     ; Make room on the stack for
002E2Fr 3  CA                           dex                     ; a dictionary pointer.
002E30r 3  64 rr                        stz tmp3                ; Start at the beginning of
002E32r 3                                                       ; the search order.
002E32r 3               @wordlist_loop:
002E32r 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
002E34r 3  A5 rr                        lda tmp3
002E36r 3  D1 rr                        cmp (up),y              ; See if we are done.
002E38r 3  D0 02                        bne @have_wordlist
002E3Ar 3               
002E3Ar 3                               ; We ran out of wordlists to search.
002E3Ar 3  80 44                        bra @words_done
002E3Cr 3               
002E3Cr 3               @have_wordlist:
002E3Cr 3                               ; start with last word in Dictionary
002E3Cr 3                               ; Get the current wordlist id
002E3Cr 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
002E3Dr 3  69 1F                        adc #search_order_offset
002E3Fr 3  A8                           tay
002E40r 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
002E42r 3               
002E42r 3                               ; Get the DP for that wordlist.
002E42r 3  0A                           asl                     ; Turn offset into cells offset.
002E43r 3  18                           clc
002E44r 3  69 06                        adc #wordlists_offset
002E46r 3  A8                           tay
002E47r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
002E49r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
002E4Br 3  C8                           iny
002E4Cr 3  B1 rr                        lda (up),y
002E4Er 3  95 01                        sta 1,x
002E50r 3               
002E50r 3               @loop:
002E50r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
002E53r 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
002E56r 3               
002E56r 3                               ; Insert line break if we're about to go past the end of the
002E56r 3                               ; line
002E56r 3  68                           pla
002E57r 3  18                           clc
002E58r 3  75 00                        adc 0,x
002E5Ar 3  1A                           inc                     ; don't forget the space between words
002E5Br 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
002E5Dr 3  90 05                        bcc @1
002E5Fr 3               
002E5Fr 3  20 rr rr                     jsr xt_cr
002E62r 3  A9 00                        lda #0
002E64r 3               @1:
002E64r 3  48                           pha
002E65r 3  20 rr rr                     jsr xt_type             ; ( nt )
002E68r 3               
002E68r 3  A9 20                        lda #AscSP
002E6Ar 3  20 rr rr                     jsr emit_a
002E6Dr 3               
002E6Dr 3                               ; get next word, which begins two down
002E6Dr 3  20 rr rr                     jsr xt_one_plus         ; 1+
002E70r 3  20 rr rr                     jsr xt_one_plus         ; 1+
002E73r 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
002E76r 3               
002E76r 3                               ; if next address is zero, we're done
002E76r 3  B5 00                        lda 0,x
002E78r 3  15 01                        ora 1,x
002E7Ar 3  D0 D4                        bne @loop
002E7Cr 3               
002E7Cr 3                               ; Move on to the next wordlist in the search order.
002E7Cr 3  E6 rr                        inc tmp3
002E7Er 3  80 B2                        bra @wordlist_loop
002E80r 3               
002E80r 3               @words_done:
002E80r 3  68                           pla                     ; dump counter
002E81r 3               
002E81r 3  E8                           inx
002E82r 3  E8                           inx
002E83r 3               
002E83r 3  60           z_words:        rts
002E84r 3               
002E84r 3               
002E84r 3               
002E84r 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
002E84r 3               ; ## "wordsize"  auto  Tali Forth
002E84r 3                       ; """Given an word's name token (nt), return the size of the
002E84r 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
002E84r 3                       ; count the final RTS.
002E84r 3                       ; """
002E84r 3               xt_wordsize:
002E84r 3  20 rr rr                     jsr underflow_1
002E87r 3               
002E87r 3                               ; We get the start address of the word from its header entry
002E87r 3                               ; for the start of the actual code (execution token, xt)
002E87r 3                               ; which is four bytes down, and the pointer to the end of the
002E87r 3                               ; code (z_word, six bytes down)
002E87r 3  B5 00                        lda 0,x
002E89r 3  85 rr                        sta tmp1
002E8Br 3  B5 01                        lda 1,x
002E8Dr 3  85 rr                        sta tmp1+1
002E8Fr 3               
002E8Fr 3  A0 06                        ldy #6
002E91r 3  B1 rr                        lda (tmp1),y    ; LSB of z
002E93r 3  88                           dey
002E94r 3  88                           dey
002E95r 3               
002E95r 3  38                           sec
002E96r 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
002E98r 3  95 00                        sta 0,x
002E9Ar 3               
002E9Ar 3  A0 07                        ldy #7
002E9Cr 3  B1 rr                        lda (tmp1),y    ; MSB of z
002E9Er 3  88                           dey
002E9Fr 3  88                           dey
002EA0r 3               
002EA0r 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
002EA2r 3  95 01                        sta 1,x
002EA4r 3               
002EA4r 3  60           z_wordsize:     rts
002EA5r 3               
002EA5r 3               
002EA5r 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
002EA5r 3               ; ## "xor"  auto  ANS core
002EA5r 3                       ; """https://forth-standard.org/standard/core/XOR"""
002EA5r 3               xt_xor:
002EA5r 3  20 rr rr                     jsr underflow_2
002EA8r 3               
002EA8r 3  B5 00                        lda 0,x
002EAAr 3  55 02                        eor 2,x
002EACr 3  95 02                        sta 2,x
002EAEr 3               
002EAEr 3  B5 01                        lda 1,x
002EB0r 3  55 03                        eor 3,x
002EB2r 3  95 03                        sta 3,x
002EB4r 3               
002EB4r 3  E8                           inx
002EB5r 3  E8                           inx
002EB6r 3               
002EB6r 3  60           z_xor:          rts
002EB7r 3               
002EB7r 3               
002EB7r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002EB7r 3               ; ## "0"  auto  Tali Forth
002EB7r 3                       ; """The disassembler assumes that this routine does not use Y. Note
002EB7r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002EB7r 3                       ; is 0."""
002EB7r 3               xt_case:
002EB7r 3               xt_forth_wordlist:
002EB7r 3               xt_zero:
002EB7r 3  CA                           dex             ; push
002EB8r 3  CA                           dex
002EB9r 3  74 00                        stz 0,x
002EBBr 3  74 01                        stz 1,x
002EBDr 3               z_case:
002EBDr 3               z_forth_wordlist:
002EBDr 3               z_zero:
002EBDr 3  60                           rts
002EBEr 3               
002EBEr 3               
002EBEr 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
002EBEr 3               ; ## "0="  auto  ANS core
002EBEr 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
002EBEr 3               
002EBEr 3               xt_zero_equal:
002EBEr 3  20 rr rr                     jsr underflow_1
002EC1r 3               
002EC1r 3  B5 00                        lda 0,x
002EC3r 3  15 01                        ora 1,x
002EC5r 3  F0 04                        beq @zero
002EC7r 3               
002EC7r 3                               ; not a zero, so we need a FALSE flag (0)
002EC7r 3  A9 00                        lda #0
002EC9r 3  80 02                        bra @store
002ECBr 3               @zero:
002ECBr 3                               ; We have a zero, so we need a TRUE flag (-1)
002ECBr 3  A9 FF                        lda #$ff
002ECDr 3               @store:
002ECDr 3  95 00                        sta 0,x
002ECFr 3  95 01                        sta 1,x
002ED1r 3               
002ED1r 3  60           z_zero_equal:   rts
002ED2r 3               
002ED2r 3               
002ED2r 3               
002ED2r 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
002ED2r 3               ; ## "0>"  auto  ANS core ext
002ED2r 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
002ED2r 3               
002ED2r 3               xt_zero_greater:
002ED2r 3  20 rr rr                     jsr underflow_1
002ED5r 3               
002ED5r 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002ED7r 3               
002ED7r 3  B5 01                        lda 1,x         ; MSB
002ED9r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002EDBr 3  15 00                        ora 0,x
002EDDr 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
002EDFr 3               
002EDFr 3  88                           dey             ; TOS is postive, make true
002EE0r 3               @done:
002EE0r 3  98                           tya
002EE1r 3  95 00                        sta 0,x
002EE3r 3  95 01                        sta 1,x
002EE5r 3               
002EE5r 3  60           z_zero_greater: rts
002EE6r 3               
002EE6r 3               
002EE6r 3               
002EE6r 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
002EE6r 3               ; ## "0<"  auto  ANS core
002EE6r 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
002EE6r 3               
002EE6r 3               xt_zero_less:
002EE6r 3  20 rr rr                     jsr underflow_1
002EE9r 3               
002EE9r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002EEBr 3               
002EEBr 3  B5 01                        lda 1,x         ; MSB
002EEDr 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
002EEFr 3               
002EEFr 3  88                           dey             ; TOS is negative, make TRUE
002EF0r 3               @done:
002EF0r 3  98                           tya
002EF1r 3  95 00                        sta 0,x
002EF3r 3  95 01                        sta 1,x
002EF5r 3               
002EF5r 3  60           z_zero_less:    rts
002EF6r 3               
002EF6r 3               
002EF6r 3               
002EF6r 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
002EF6r 3               ; ## "0<>"  auto  ANS core ext
002EF6r 3                       ; """https://forth-standard.org/standard/core/Zerone"""
002EF6r 3               
002EF6r 3               xt_zero_unequal:
002EF6r 3  20 rr rr                     jsr underflow_1
002EF9r 3               
002EF9r 3  A0 00                        ldy #0          ; default false
002EFBr 3               
002EFBr 3  B5 00                        lda 0,x
002EFDr 3  15 01                        ora 1,x
002EFFr 3  F0 01                        beq @got_zero
002F01r 3               
002F01r 3  88                           dey
002F02r 3               @got_zero:
002F02r 3  98                           tya
002F03r 3  95 00                        sta 0,x
002F05r 3  95 01                        sta 1,x
002F07r 3               
002F07r 3  60           z_zero_unequal: rts
002F08r 3               
002F08r 3               
002F08r 3               
002F08r 3               ; ==========================================================
002F08r 3               ; EDITOR words
002F08r 3               
002F08r 3               ; This routine is used by both enter-screen and erase-screen
002F08r 3               ; to get a buffer for the given screen number and set SCR to
002F08r 3               ; the given screen number.  This word is not in the dictionary.
002F08r 3               xt_editor_screen_helper:
002F08r 3  20 rr rr                     jsr xt_dup
002F0Br 3  20 rr rr                     jsr xt_scr
002F0Er 3  20 rr rr                     jsr xt_store
002F11r 3  20 rr rr                     jsr xt_buffer
002F14r 3               z_editor_screen_helper:
002F14r 3  60                           rts
002F15r 3               
002F15r 3               
002F15r 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
002F15r 3               ; ## "enter-screen"  auto  Tali Editor
002F15r 3               
002F15r 3               xt_editor_enter_screen:
002F15r 3                               ; Set the variable SCR and get a buffer for the
002F15r 3                               ; given screen number.
002F15r 3  20 rr rr                     jsr xt_editor_screen_helper
002F18r 3               
002F18r 3                               ; Drop the buffer address.
002F18r 3  20 rr rr                     jsr xt_drop
002F1Br 3               
002F1Br 3                               ; Overwrite the lines one at a time.
002F1Br 3  64 rr                        stz editor1
002F1Dr 3               @prompt_loop:
002F1Dr 3                               ; Put the current line number on the stack.
002F1Dr 3  CA                           dex
002F1Er 3  CA                           dex
002F1Fr 3  A5 rr                        lda editor1
002F21r 3  95 00                        sta 0,x
002F23r 3  74 01                        stz 1,x
002F25r 3               
002F25r 3                               ; Use the O word to prompt for overwrite.
002F25r 3  20 rr rr                     jsr xt_editor_o
002F28r 3               
002F28r 3                               ; Move on to the next line.
002F28r 3  E6 rr                        inc editor1
002F2Ar 3  A9 10                        lda #16
002F2Cr 3  C5 rr                        cmp editor1
002F2Er 3  D0 ED                        bne @prompt_loop
002F30r 3               
002F30r 3               z_editor_enter_screen:
002F30r 3  60                           rts
002F31r 3               
002F31r 3               
002F31r 3               
002F31r 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
002F31r 3               ; ## "erase-screen"  tested  Tali Editor
002F31r 3               xt_editor_erase_screen:
002F31r 3                               ; Set the variable SCR and get a buffer for the
002F31r 3                               ; given screen number.
002F31r 3  20 rr rr                     jsr xt_editor_screen_helper
002F34r 3               
002F34r 3                               ; Put 1024 (chars/screen) on stack.
002F34r 3  CA                           dex
002F35r 3  CA                           dex
002F36r 3  74 00                        stz 0,x
002F38r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
002F3Ar 3  95 01                        sta 1,x
002F3Cr 3               
002F3Cr 3                               ; Erase the entire block (fill with spaces).
002F3Cr 3  20 rr rr                     jsr xt_blank
002F3Fr 3               
002F3Fr 3                               ; Mark buffer as updated.
002F3Fr 3  20 rr rr                     jsr xt_update
002F42r 3               
002F42r 3               z_editor_erase_screen:
002F42r 3  60                           rts
002F43r 3               
002F43r 3               
002F43r 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
002F43r 3               ; ## "el"  tested  Tali Editor
002F43r 3               xt_editor_el:
002F43r 3                               ; Turn the line number into buffer offset.
002F43r 3                               ; This also loads the block into the buffer if it's
002F43r 3                               ; not there for some reason.
002F43r 3  20 rr rr                     jsr xt_editor_line
002F46r 3               
002F46r 3                               ; Put 64 (# of chars/line) on the stack.
002F46r 3  CA                           dex
002F47r 3  CA                           dex
002F48r 3  A9 40                        lda #64
002F4Ar 3  95 00                        sta 0,x
002F4Cr 3  74 01                        stz 1,x
002F4Er 3               
002F4Er 3                               ; Fill with spaces.
002F4Er 3  20 rr rr                     jsr xt_blank
002F51r 3               
002F51r 3                               ; Mark buffer as updated.
002F51r 3  20 rr rr                     jsr xt_update
002F54r 3               
002F54r 3  60           z_editor_el:    rts
002F55r 3               
002F55r 3               
002F55r 3               ; ## EDITOR_L ( -- ) "List the current screen"
002F55r 3               ; ## "l"  tested  Tali Editor
002F55r 3               
002F55r 3               xt_editor_l:
002F55r 3                               ; Load the current screen
002F55r 3  CA                           dex             ; Put SCR on the stack.
002F56r 3  CA                           dex
002F57r 3  A0 02                        ldy #scr_offset
002F59r 3  B1 rr                        lda (up),y
002F5Br 3  95 00                        sta 0,x
002F5Dr 3  C8                           iny
002F5Er 3  B1 rr                        lda (up),y
002F60r 3  95 01                        sta 1,x
002F62r 3  20 rr rr                     jsr xt_block    ; Get the current screen.
002F65r 3               
002F65r 3  20 rr rr                     jsr xt_cr
002F68r 3               
002F68r 3                               ; Print the screen number.
002F68r 3                               ; We're using sliteral, so we need to set up the
002F68r 3                               ; appropriate data structure (see sliteral)
002F68r 3  80 08                        bra @after_screen_msg
002F6Ar 3               
002F6Ar 3               @screen_msg:
002F6Ar 3  53 63 72 65                  .byte "Screen #"
002F6Er 3  65 6E 20 23  
002F72r 3               
002F72r 3               @after_screen_msg:
002F72r 3  20 rr rr                     jsr sliteral_runtime
002F75r 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
002F79r 3               
002F79r 3  20 rr rr                     jsr xt_type
002F7Cr 3               
002F7Cr 3                               ; Put the screen number and printed size for u.r on the stack.
002F7Cr 3  20 rr rr                     jsr xt_scr
002F7Fr 3  20 rr rr                     jsr xt_fetch
002F82r 3  CA                           dex
002F83r 3  CA                           dex
002F84r 3  A9 04                        lda #4          ; four spaces
002F86r 3  95 00                        sta 0,x
002F88r 3  74 01                        stz 1,x
002F8Ar 3  20 rr rr                     jsr xt_u_dot_r
002F8Dr 3               
002F8Dr 3                               ; The address of the buffer is currently on the stack.
002F8Dr 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
002F8Dr 3                               ; keep track of the line number in tmp3.
002F8Dr 3  64 rr                        stz tmp3
002F8Fr 3               
002F8Fr 3               @line_loop:
002F8Fr 3  20 rr rr                     jsr xt_cr
002F92r 3               
002F92r 3                               ; Print the line number (2-space fixed width)
002F92r 3  CA                           dex
002F93r 3  CA                           dex
002F94r 3  CA                           dex
002F95r 3  CA                           dex
002F96r 3  74 03                        stz 3,x
002F98r 3  A5 rr                        lda tmp3
002F9Ar 3  95 02                        sta 2,x
002F9Cr 3  74 01                        stz 1,x
002F9Er 3  A9 02                        lda #2
002FA0r 3  95 00                        sta 0,x
002FA2r 3  20 rr rr                     jsr xt_u_dot_r
002FA5r 3  20 rr rr                     jsr xt_space
002FA8r 3               
002FA8r 3                               ; Print one line using the address on the stack.
002FA8r 3  20 rr rr                     jsr xt_dup
002FABr 3  CA                           dex
002FACr 3  CA                           dex
002FADr 3  A9 40                        lda #64
002FAFr 3  95 00                        sta 0,x
002FB1r 3  74 01                        stz 1,x
002FB3r 3  20 rr rr                     jsr xt_type
002FB6r 3               
002FB6r 3                               ; Add 64 to the address on the stack to move to the next line.
002FB6r 3  18                           clc
002FB7r 3  A9 40                        lda #64
002FB9r 3  75 00                        adc 0,x
002FBBr 3  95 00                        sta 0,x
002FBDr 3  B5 01                        lda 1,x
002FBFr 3  69 00                        adc #0      ; Add carry
002FC1r 3  95 01                        sta 1,x
002FC3r 3               
002FC3r 3                               ; Increment the line number (held in tmp3)
002FC3r 3  E6 rr                        inc tmp3
002FC5r 3               
002FC5r 3                               ; See if we are done.
002FC5r 3  A5 rr                        lda tmp3
002FC7r 3  C9 10                        cmp #16
002FC9r 3  D0 C4                        bne @line_loop
002FCBr 3               
002FCBr 3  20 rr rr                     jsr xt_cr
002FCEr 3                               ; Drop the address on the stack.
002FCEr 3  E8                           inx
002FCFr 3  E8                           inx
002FD0r 3               
002FD0r 3  60           z_editor_l:            rts
002FD1r 3               
002FD1r 3               
002FD1r 3               
002FD1r 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
002FD1r 3               ; ## "line"  tested  Tali Editor
002FD1r 3               
002FD1r 3               xt_editor_line:
002FD1r 3  20 rr rr                     jsr underflow_1
002FD4r 3               
002FD4r 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
002FD4r 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
002FD6r 3               @shift_tos_left:
002FD6r 3  16 00                        asl 0,x         ; Shift TOS to the left
002FD8r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
002FDAr 3  88                           dey
002FDBr 3  D0 F9                        bne @shift_tos_left
002FDDr 3                               ; Load the current screen into a buffer
002FDDr 3                               ; and get the buffer address
002FDDr 3  20 rr rr                     jsr xt_scr
002FE0r 3  20 rr rr                     jsr xt_fetch
002FE3r 3  20 rr rr                     jsr xt_block
002FE6r 3               
002FE6r 3                               ; Add the offset to the buffer base address.
002FE6r 3  20 rr rr                     jsr xt_plus
002FE9r 3               
002FE9r 3  60           z_editor_line:  rts
002FEAr 3               
002FEAr 3               
002FEAr 3               
002FEAr 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
002FEAr 3               ; ## "o"  tested  Tali Editor
002FEAr 3               xt_editor_o:
002FEAr 3                               ; Print prompt
002FEAr 3  20 rr rr                     jsr xt_cr
002FEDr 3  20 rr rr                     jsr xt_dup
002FF0r 3  20 rr rr                     jsr xt_two
002FF3r 3  20 rr rr                     jsr xt_u_dot_r
002FF6r 3  20 rr rr                     jsr xt_space
002FF9r 3  A9 2A                        lda #42         ; ASCII for *
002FFBr 3  20 rr rr                     jsr emit_a
002FFEr 3  20 rr rr                     jsr xt_space
003001r 3               
003001r 3                               ; Accept new input (directly into the buffer)
003001r 3  20 rr rr                     jsr xt_editor_line
003004r 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
003007r 3  CA                           dex
003008r 3  CA                           dex
003009r 3  A9 40                        lda #64         ; chars/line
00300Br 3  95 00                        sta 0,x
00300Dr 3  74 01                        stz 1,x
00300Fr 3  20 rr rr                     jsr xt_accept
003012r 3               
003012r 3                               ; Fill the rest with spaces.
003012r 3                               ; Stack is currently ( line_address numchars_from_accept )
003012r 3  20 rr rr                     jsr xt_dup
003015r 3  20 rr rr                     jsr xt_not_rote ; -rot
003018r 3  20 rr rr                     jsr xt_plus
00301Br 3  CA                           dex
00301Cr 3  CA                           dex
00301Dr 3  A9 40                        lda #64         ; chars/line
00301Fr 3  95 00                        sta 0,x
003021r 3  74 01                        stz 1,x
003023r 3  20 rr rr                     jsr xt_rot
003026r 3  20 rr rr                     jsr xt_minus
003029r 3  20 rr rr                     jsr xt_blank
00302Cr 3               
00302Cr 3                               ; Mark buffer as updated.
00302Cr 3  20 rr rr                     jsr xt_update
00302Fr 3               
00302Fr 3  60           z_editor_o:     rts
003030r 3               
003030r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
003030r 3               ; ## "lcdput" coded Custom
003030r 3               xt_lcdput:
003030r 3  20 rr rr                     jsr underflow_1
003033r 3               
003033r 3  B5 00                        lda 0,x
003035r 3                       .ifdef lcd_print
003035r 3                               jsr lcd_print
003035r 3                       .endif
003035r 3  E8                           inx
003036r 3  E8                           inx
003037r 3  60           z_lcdput: rts
003038r 3               
003038r 3               
003038r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
003038r 3               ; ## "lcdprint"  coded Custom
003038r 3               
003038r 3               xt_lcdprint:
003038r 3  20 rr rr                     jsr underflow_2
00303Br 3               
00303Br 3                               ; Save the starting address into tmp1
00303Br 3  B5 02                        lda 2,x
00303Dr 3  85 rr                        sta tmp1
00303Fr 3  B5 03                        lda 3,x
003041r 3  85 rr                        sta tmp1+1
003043r 3               @loop:
003043r 3                               ; done if length is zero
003043r 3  B5 00                        lda 0,x
003045r 3  15 01                        ora 1,x
003047r 3  F0 12                        beq @done
003049r 3               
003049r 3                               ; Send the current character
003049r 3  B2 rr                        lda (tmp1)
00304Br 3                       .ifdef lcd_print
00304Br 3                               jsr lcd_print      ; avoids stack foolery
00304Br 3                       .endif
00304Br 3                               ; Move the address along (in tmp1)
00304Br 3  E6 rr                        inc tmp1
00304Dr 3  D0 02                        bne @1
00304Fr 3  E6 rr                        inc tmp1+1
003051r 3               @1:
003051r 3                               ; Reduce the count (on the data stack)
003051r 3  B5 00                        lda 0,x
003053r 3  D0 02                        bne @2
003055r 3  D6 01                        dec 1,x
003057r 3               @2:
003057r 3  D6 00                        dec 0,x
003059r 3               
003059r 3  80 E8                        bra @loop
00305Br 3               @done:
00305Br 3  E8                           inx
00305Cr 3  E8                           inx
00305Dr 3  E8                           inx
00305Er 3  E8                           inx
00305Fr 3               
00305Fr 3  60           z_lcdprint:         rts
003060r 3               
003060r 3               
003060r 3               
003060r 3               ; ## CLS ( -- ) "clea VGA screen"
003060r 3               ; ## "cls" coded Custom
003060r 3               xt_cls:
003060r 3                       .ifdef vga_clear
003060r 3                               jsr vga_clear
003060r 3                       .endif
003060r 3               
003060r 3  60           z_cls: rts
003061r 3               
003061r 3               
003061r 3               ; ## SPI_INIT ( -- ) "Init SPI system"
003061r 3               ; ## "spi_init" coded Custom
003061r 3               xt_spi_init:
003061r 3                       .ifdef spi_init
003061r 3  20 rr rr                     jsr spi_init
003064r 3                       .endif
003064r 3  60           z_spi_init: rts
003065r 3               
003065r 3               
003065r 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
003065r 3               ; ## "spi_clk_toggle" coded Custom
003065r 3               xt_spi_clk_toggle:
003065r 3                       .ifdef spi_clk_toggle
003065r 3  20 rr rr                     jsr spi_clk_toggle
003068r 3                       .endif
003068r 3  60           z_spi_clk_toggle: rts
003069r 3               
003069r 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
003069r 3               ; ## "spi_select" coded Custom
003069r 3               xt_spi_select:
003069r 3  20 rr rr                     jsr underflow_1
00306Cr 3               
00306Cr 3  B5 00                        lda 0,x
00306Er 3                       .ifdef spi_select
00306Er 3  20 rr rr                     jsr spi_select
003071r 3                       .endif
003071r 3  E8                           inx
003072r 3  E8                           inx
003073r 3  60           z_spi_select: rts
003074r 3               
003074r 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
003074r 3               ; ## "spi_transceive" coded Custom
003074r 3               xt_spi_transceive:
003074r 3  20 rr rr                     jsr underflow_1
003077r 3               
003077r 3  B5 00                        lda 0,x
003079r 3                       .ifdef spi_transceive
003079r 3  20 rr rr                     jsr spi_transceive
00307Cr 3                       .endif
00307Cr 3  95 00                        sta 0,x         ; put return value in TOS
00307Er 3  74 01                        stz 1,X         ;reset value there
003080r 3  60           z_spi_transceive: rts
003081r 3               
003081r 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
003081r 3               ; ## "spi_transceive" coded Custom
003081r 3               xt_sd_init:
003081r 3  20 rr rr                     jsr underflow_1
003084r 3               
003084r 3  B5 00                        lda 0,x
003086r 3                       .ifdef sd_init
003086r 3  20 rr rr                     jsr sd_init
003089r 3                       .endif
003089r 3  95 00                        sta 0,x         ; put return value in TOS
00308Br 3  74 01                        stz 1,X         ;reset value there
00308Dr 3  60           z_sd_init: rts
00308Er 3               
00308Er 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
00308Er 3               ; ## "sd_readsector" coded Custom
00308Er 3               xt_sd_readsector:
00308Er 3  20 rr rr                     jsr underflow_3
003091r 3                       .ifdef sd_readsector
003091r 3                               ; get and save storage address
003091r 3  B5 00                        lda 0,x
003093r 3  85 rr                        sta sd_buffer_address
003095r 3  B5 01                        lda 1, x
003097r 3  85 rr                        sta sd_buffer_address + 1
003099r 3                               ; get and save sector number (32 bit number, double)
003099r 3  B5 02                        lda 2, X
00309Br 3  8D rr rr                     sta SD_ARG + 3
00309Er 3  B5 03                        lda 3, X
0030A0r 3  8D rr rr                     sta SD_ARG + 2
0030A3r 3  B5 04                        lda 4, X
0030A5r 3  8D rr rr                     sta SD_ARG + 1
0030A8r 3  B5 05                        lda 5, X
0030AAr 3  8D rr rr                     sta SD_ARG
0030ADr 3  A9 01                        lda #1
0030AFr 3  8D rr rr                     sta SD_CRC
0030B2r 3               
0030B2r 3  20 rr rr                     jsr sd_readsector
0030B5r 3                       .endif
0030B5r 3  95 00                        sta 0,x         ; put return value in TOS
0030B7r 3  74 01                        stz 1,X         ;reset value there
0030B9r 3               
0030B9r 3  E8                           inx
0030BAr 3  E8                           inx
0030BBr 3  E8                           inx
0030BCr 3  E8                           inx
0030BDr 3               
0030BDr 3  60           z_sd_readsector: rts
0030BEr 3               
0030BEr 3               
0030BEr 3               ; ## FAT32_INIT ( u -- u ) "initialize FAT32 file system on passed spi drive address"
0030BEr 3               ; ## "fat32_init" coded Custom
0030BEr 3               xt_fat32_init:
0030BEr 3  20 rr rr                     jsr underflow_1
0030C1r 3               
0030C1r 3  B5 00                        lda 0,x
0030C3r 3                       .ifdef sd_init
0030C3r 3  20 rr rr                     jsr sd_init
0030C6r 3  D0 05                        bne @error
0030C8r 3                       .endif
0030C8r 3                       .ifdef fat32_init
0030C8r 3  20 rr rr                     jsr fat32_init
0030CBr 3  F0 02                        beq @end
0030CDr 3                       .endif
0030CDr 3                       .ifdef fat32_openroot
0030CDr 3                               ; jsr fat32_openroot
0030CDr 3                               ; beq @end
0030CDr 3                       .endif
0030CDr 3               @error:
0030CDr 3  A9 01                        lda #1
0030CFr 3               @end:
0030CFr 3  95 00                        sta 0,x         ; put return value in TOS
0030D1r 3  74 01                        stz 1,X         ;reset value there
0030D3r 3  60           z_fat32_init: rts
0030D4r 3               
0030D4r 3               
0030D4r 3               ; ## FAT32_ROOT ( -- u ) "initialize FAT32 file system on passed spi drive address"
0030D4r 3               ; ## "fat32_root" coded Custom
0030D4r 3               xt_fat32_root:
0030D4r 3               
0030D4r 3  CA                   dex
0030D5r 3  CA                   dex
0030D6r 3                       .ifdef fat32_openroot
0030D6r 3  20 rr rr                     jsr fat32_openroot
0030D9r 3  F0 02                        beq @end
0030DBr 3                       .endif
0030DBr 3                       ; .ifdef fat32_readdirent
0030DBr 3                       ;         jsr fat32_readdirent
0030DBr 3                       ;         bcc @end
0030DBr 3                       ; .endif
0030DBr 3               
0030DBr 3               @error:
0030DBr 3  A9 01                lda #1
0030DDr 3               @end:
0030DDr 3               
0030DDr 3  95 00                sta 0,x         ; put return value in TOS
0030DFr 3  74 01                stz 1,X         ;reset value there
0030E1r 3  60           z_fat32_root: rts
0030E2r 3               
0030E2r 3               ; ## FAT32_FIND ( addr u -- u ) "Open file from initialized fat32 FS"
0030E2r 3               ; ## "fat32_find" coded Custom
0030E2r 3               xt_fat32_find:
0030E2r 3  46 49 4C 45  textfile:  .byte "FILE.TXT   ", 0
0030E6r 3  2E 54 58 54  
0030EAr 3  20 20 20 00  
0030EEr 3  A9 rr                        lda #<textfile
0030F0r 3  85 rr                        sta fat32_filenamepointer
0030F2r 3  A9 rr                        lda #>textfile
0030F4r 3  85 rr                        sta fat32_filenamepointer+1
0030F6r 3                       .ifdef fat32_finddirent
0030F6r 3  20 rr rr                     jsr fat32_finddirent    ; find the file from its name
0030F9r 3  D0 34                        bne @error
0030FBr 3                       .endif
0030FBr 3  20 rr rr                     jsr fat32_file_read
0030FEr 3  D0 2F                        bne @error
003100r 3  CA                           dex
003101r 3  CA                           dex
003102r 3  A5 rr                        lda sd_buffer_address
003104r 3  95 00                        sta 0,x
003106r 3  A5 rr                        lda sd_buffer_address+1
003108r 3  95 01                        sta 1, x
00310Ar 3               ;                 phy
00310Ar 3               ;         ldy #0
00310Ar 3               ; @printloop:
00310Ar 3               ;         lda (sd_buffer_address),y
00310Ar 3               ;         beq @ex
00310Ar 3               ;         jsr kernel_putc
00310Ar 3               ; @ex:
00310Ar 3               ;         ply
00310Ar 3  4C rr rr             jmp @end
00310Dr 3               
00310Dr 3  4C rr rr                     jmp @end
003110r 3               
003110r 3  20 rr rr                     jsr underflow_2
003113r 3  5A                           phy
003114r 3  B4 00                        ldy 0,x ; length of string
003116r 3  A9 00                        lda #0
003118r 3               @reset_loop:
003118r 3                           .ifdef fat32_finddirent
003118r 3  91 rr                        sta (fat32_filenamepointer),y
00311Ar 3  C8                           iny
00311Br 3  C0 0B                        cpy #11
00311Dr 3  90 F9                        bcc @reset_loop
00311Fr 3                           .endif
00311Fr 3  E8                           inx     ; get address
003120r 3  E8                           inx
003121r 3                           .ifdef fat32_finddirent
003121r 3  B5 00                        lda 0,x
003123r 3  85 rr                        sta fat32_filenamepointer
003125r 3  B5 01                        lda 1,x
003127r 3  85 rr                        sta fat32_filenamepointer+1
003129r 3                           .endif
003129r 3               
003129r 3  7A                           ply
00312Ar 3                           .ifdef fat32_finddirent
00312Ar 3  20 rr rr                     jsr fat32_finddirent    ; find the file from its name
00312Dr 3  F0 02                        beq @end
00312Fr 3                           .endif
00312Fr 3               
00312Fr 3               @error:
00312Fr 3  A9 01                        lda #1
003131r 3               @end:
003131r 3  95 00                        sta 0,x         ; put return value in TOS
003133r 3  74 01                        stz 1,X         ;reset value there
003135r 3  60           z_fat32_find: rts
003136r 3               
003136r 3               ; ## time ( -- addr ) "get time storage address"
003136r 3               ; ## "time" coded Custom
003136r 3               xt_time:
003136r 3                       .ifdef time
003136r 3  A9 rr                lda #time
003138r 3                       .else
003138r 3                       lda #0
003138r 3                       .endif
003138r 3  CA                   dex
003139r 3  CA                   dex
00313Ar 3  95 00                sta 0,x
00313Cr 3  74 01                stz 1,x
00313Er 3               
00313Er 3               
00313Er 3  60           z_time: rts
00313Fr 3               
00313Fr 3               ; TODO add routine to send a block of data in memory via SPI
00313Fr 3               ; similar to lcdprint
00313Fr 3               
00313Fr 3               ; END
00313Fr 3               
00313Fr 3               
00313Fr 2                   .include "headers.s"          ; Headers of native words
00313Fr 3               ; Dictionary Headers for Tali Forth 2
00313Fr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
00313Fr 3               ; First version: 05. Dec 2016 (Liara Forth)
00313Fr 3               ; This version: 29. Dec 2018
00313Fr 3               
00313Fr 3               ; Dictionary headers are kept separately from the code, which allows various
00313Fr 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
00313Fr 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
00313Fr 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
00313Fr 3               ; header in the Dictionary. There the link to the next word in the Dictionary
00313Fr 3               ; is always one cell down from the current word's own nt. In the code itself,
00313Fr 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
00313Fr 3               
00313Fr 3               ; This gives us the following header structure:
00313Fr 3               
00313Fr 3               ;              8 bit     8 bit
00313Fr 3               ;               LSB       MSB
00313Fr 3               ; nt_word ->  +--------+--------+
00313Fr 3               ;          +0 | Length | Status |
00313Fr 3               ;             +--------+--------+
00313Fr 3               ;          +2 | Next Header     | -> nt_next_word
00313Fr 3               ;             +-----------------+
00313Fr 3               ;          +4 | Start of Code   | -> xt_word
00313Fr 3               ;             +-----------------+
00313Fr 3               ;          +6 | End of Code     | -> z_word
00313Fr 3               ;             +--------+--------+
00313Fr 3               ;          +8 | Name   |        |
00313Fr 3               ;             +--------+--------+
00313Fr 3               ;             |        |        |
00313Fr 3               ;             +--------+--------+
00313Fr 3               ;             |        |  ...   | (name string does not end with a zero)
00313Fr 3               ;          +n +--------+--------+
00313Fr 3               
00313Fr 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
00313Fr 3               ; which are:
00313Fr 3               
00313Fr 3               ;       CO - Compile Only
00313Fr 3               ;       IM - Immediate Word
00313Fr 3               ;       NN - Never Native Compile (must always be called by JSR)
00313Fr 3               ;       AN - Always Native Compile (may not be called by JSR)
00313Fr 3               ;       UF - Contains underflow check
00313Fr 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
00313Fr 3               
00313Fr 3               ; Note there are currently two bits unused.
00313Fr 3               
00313Fr 3               ; By default, all existing words can be natively compiled (compiled inline) or
00313Fr 3               ; as a subroutine jump target; the system decides which variant to use based on
00313Fr 3               ; a threshold the user can set. By default, all user-created words are flagged
00313Fr 3               ; never-native. The user can override this by using the always-native word
00313Fr 3               ; just after defining their new word.  The NN flag forbids native compiling,
00313Fr 3               ; the AN flag forces it.
00313Fr 3               
00313Fr 3               ; The last word (top word in code) is always BYE. It is marked as the last word
00313Fr 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
00313Fr 3               ; more common ones first (further down in code) so they are found earlier.
00313Fr 3               ; Anything to do with output comes later (further up) because things will
00313Fr 3               ; always be slow if there is a human involved.
00313Fr 3               
00313Fr 3               ; The initial skeleton of this list was automatically generated by a script
00313Fr 3               ; in the tools folder and then sorted by hand.
00313Fr 3               
00313Fr 3               nt_bye:
00313Fr 3  03                   .byte 3         ; length of word strings
003140r 3  00                   .byte 0         ; status byte
003141r 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
003143r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
003145r 3  rr rr                .word z_bye     ; end of code (RTS)
003147r 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
00314Ar 3               
00314Ar 3               
00314Ar 3               nt_cold:
00314Ar 3  04 00                .byte 4, 0
00314Cr 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
003150r 3  rr rr        
003152r 3  63 6F 6C 64          .byte "cold"
003156r 3               
003156r 3               nt_lcdput:
003156r 3  06 10                .byte 6, UF
003158r 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
00315Cr 3  rr rr        
00315Er 3  6C 63 64 70          .byte "lcdput"
003162r 3  75 74        
003164r 3               
003164r 3               nt_lcdprint:
003164r 3  08 10                .byte 8, UF
003166r 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
00316Ar 3  rr rr        
00316Cr 3  6C 63 64 70          .byte "lcdprint"
003170r 3  72 69 6E 74  
003174r 3               
003174r 3               nt_cls:
003174r 3  03 00                .byte 3, 0
003176r 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
00317Ar 3  rr rr        
00317Cr 3  63 6C 73             .byte "cls"
00317Fr 3               
00317Fr 3               nt_spi_init:
00317Fr 3  08 00                .byte 8, 0
003181r 3  rr rr rr rr          .word nt_cls, xt_spi_init, z_spi_init
003185r 3  rr rr        
003187r 3  73 70 69 5F          .byte "spi_init"
00318Br 3  69 6E 69 74  
00318Fr 3               
00318Fr 3               
00318Fr 3               nt_spi_clk_toggle:
00318Fr 3  0E 00                .byte 14, 0
003191r 3  rr rr rr rr          .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
003195r 3  rr rr        
003197r 3  73 70 69 5F          .byte "spi_clk_toggle"
00319Br 3  63 6C 6B 5F  
00319Fr 3  74 6F 67 67  
0031A5r 3               
0031A5r 3               nt_spi_select:
0031A5r 3  0A 00                .byte 10, 0
0031A7r 3  rr rr rr rr          .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
0031ABr 3  rr rr        
0031ADr 3  73 70 69 5F          .byte "spi_select"
0031B1r 3  73 65 6C 65  
0031B5r 3  63 74        
0031B7r 3               
0031B7r 3               nt_spi_transceive:
0031B7r 3  0E 00                .byte 14, 0
0031B9r 3  rr rr rr rr          .word nt_spi_select, xt_spi_transceive, z_spi_transceive
0031BDr 3  rr rr        
0031BFr 3  73 70 69 5F          .byte "spi_transceive"
0031C3r 3  74 72 61 6E  
0031C7r 3  73 63 65 69  
0031CDr 3               
0031CDr 3               nt_sd_init:
0031CDr 3  07 00                .byte 7, 0
0031CFr 3  rr rr rr rr          .word nt_spi_transceive, xt_sd_init, z_sd_init
0031D3r 3  rr rr        
0031D5r 3  73 64 5F 69          .byte "sd_init"
0031D9r 3  6E 69 74     
0031DCr 3               
0031DCr 3               
0031DCr 3               nt_sd_readsector:
0031DCr 3  0D 00                .byte 13, 0
0031DEr 3  rr rr rr rr          .word nt_sd_init, xt_sd_readsector, z_sd_readsector
0031E2r 3  rr rr        
0031E4r 3  73 64 5F 72          .byte "sd_readsector"
0031E8r 3  65 61 64 73  
0031ECr 3  65 63 74 6F  
0031F1r 3               
0031F1r 3               
0031F1r 3               nt_fat32_init:
0031F1r 3  0A 00                .byte 10, 0
0031F3r 3  rr rr rr rr          .word nt_sd_readsector, xt_fat32_init, z_fat32_init
0031F7r 3  rr rr        
0031F9r 3  66 61 74 33          .byte "fat32_init"
0031FDr 3  32 5F 69 6E  
003201r 3  69 74        
003203r 3               
003203r 3               nt_fat32_root:
003203r 3  0A 00                .byte 10, 0
003205r 3  rr rr rr rr          .word nt_fat32_init, xt_fat32_root, z_fat32_root
003209r 3  rr rr        
00320Br 3  66 61 74 33          .byte "fat32_root"
00320Fr 3  32 5F 72 6F  
003213r 3  6F 74        
003215r 3               
003215r 3               nt_fat32_find:
003215r 3  0A 00                .byte 10, 0
003217r 3  rr rr rr rr          .word nt_fat32_root, xt_fat32_find, z_fat32_find
00321Br 3  rr rr        
00321Dr 3  66 61 74 33          .byte "fat32_find"
003221r 3  32 5F 66 69  
003225r 3  6E 64        
003227r 3               
003227r 3               nt_time:
003227r 3  04 00                .byte 4, 0
003229r 3  rr rr rr rr          .word nt_fat32_find, xt_time, z_time
00322Dr 3  rr rr        
00322Fr 3  74 69 6D 65          .byte "time"
003233r 3               
003233r 3               nt_ed:                  ; ed6502
003233r 3  02 08                .byte 2, NN
003235r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
003239r 3  rr rr        
00323Br 3  65 64                .byte "ed"
00323Dr 3               
00323Dr 3  03 08        nt_see: .byte 3, NN
00323Fr 3  rr rr rr rr          .word nt_ed, xt_see, z_see
003243r 3  rr rr        
003245r 3  73 65 65             .byte "see"
003248r 3               
003248r 3               nt_forth:
003248r 3  05 00                .byte 5, 0
00324Ar 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
00324Er 3  rr rr        
003250r 3  66 6F 72 74          .byte "forth"
003254r 3  68           
003255r 3               
003255r 3               nt_order:
003255r 3  05 00                .byte 5, 0
003257r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
00325Br 3  rr rr        
00325Dr 3  6F 72 64 65          .byte "order"
003261r 3  72           
003262r 3               
003262r 3               nt_to_order:
003262r 3  06 00                .byte 6, 0
003264r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
003268r 3  rr rr        
00326Ar 3  3E 6F 72 64          .byte ">order"
00326Er 3  65 72        
003270r 3               
003270r 3               nt_previous:
003270r 3  08 00                .byte 8, 0
003272r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
003276r 3  rr rr        
003278r 3  70 72 65 76          .byte "previous"
00327Cr 3  69 6F 75 73  
003280r 3               
003280r 3               nt_also:
003280r 3  04 00                .byte 4, 0
003282r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
003286r 3  rr rr        
003288r 3  61 6C 73 6F          .byte "also"
00328Cr 3               
00328Cr 3               nt_only:
00328Cr 3  04 00                .byte 4, 0
00328Er 3  rr rr rr rr          .word nt_also, xt_only, z_only
003292r 3  rr rr        
003294r 3  6F 6E 6C 79          .byte "only"
003298r 3               
003298r 3               nt_forth_wordlist:      ; shares code with ZERO
003298r 3  0E 00                .byte 14, 0
00329Ar 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
00329Er 3  rr rr        
0032A0r 3  66 6F 72 74          .byte "forth-wordlist"
0032A4r 3  68 2D 77 6F  
0032A8r 3  72 64 6C 69  
0032AEr 3               
0032AEr 3               nt_editor_wordlist:     ; shares code with ONE
0032AEr 3  0F 00                .byte 15, 0
0032B0r 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
0032B4r 3  rr rr        
0032B6r 3  65 64 69 74          .byte "editor-wordlist"
0032BAr 3  6F 72 2D 77  
0032BEr 3  6F 72 64 6C  
0032C5r 3               
0032C5r 3               nt_assembler_wordlist:  ; shares code with TWO
0032C5r 3  12 00                .byte 18, 0
0032C7r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
0032CBr 3  rr rr        
0032CDr 3  61 73 73 65          .byte "assembler-wordlist"
0032D1r 3  6D 62 6C 65  
0032D5r 3  72 2D 77 6F  
0032DFr 3               
0032DFr 3               nt_root_wordlist:
0032DFr 3  0D 00                .byte 13, 0
0032E1r 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
0032E5r 3  rr rr        
0032E7r 3  72 6F 6F 74          .byte "root-wordlist"
0032EBr 3  2D 77 6F 72  
0032EFr 3  64 6C 69 73  
0032F4r 3               
0032F4r 3               nt_get_order:
0032F4r 3  09 00                .byte 9, 0
0032F6r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
0032FAr 3  rr rr        
0032FCr 3  67 65 74 2D          .byte "get-order"
003300r 3  6F 72 64 65  
003304r 3  72           
003305r 3               
003305r 3               nt_set_order:
003305r 3  09 00                .byte 9, 0
003307r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
00330Br 3  rr rr        
00330Dr 3  73 65 74 2D          .byte "set-order"
003311r 3  6F 72 64 65  
003315r 3  72           
003316r 3               
003316r 3               nt_get_current:
003316r 3  0B 00                .byte 11, 0
003318r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
00331Cr 3  rr rr        
00331Er 3  67 65 74 2D          .byte "get-current"
003322r 3  63 75 72 72  
003326r 3  65 6E 74     
003329r 3               
003329r 3               nt_set_current:
003329r 3  0B 10                .byte 11, UF
00332Br 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
00332Fr 3  rr rr        
003331r 3  73 65 74 2D          .byte "set-current"
003335r 3  63 75 72 72  
003339r 3  65 6E 74     
00333Cr 3               
00333Cr 3               nt_search_wordlist:
00333Cr 3  0F 10                .byte 15, UF
00333Er 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
003342r 3  rr rr        
003344r 3  73 65 61 72          .byte "search-wordlist"
003348r 3  63 68 2D 77  
00334Cr 3  6F 72 64 6C  
003353r 3               
003353r 3               nt_wordlist:
003353r 3  08 00                .byte 8, 0
003355r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
003359r 3  rr rr        
00335Br 3  77 6F 72 64          .byte "wordlist"
00335Fr 3  6C 69 73 74  
003363r 3               
003363r 3               nt_definitions:
003363r 3  0B 00                .byte 11, 0
003365r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
003369r 3  rr rr        
00336Br 3  64 65 66 69          .byte "definitions"
00336Fr 3  6E 69 74 69  
003373r 3  6F 6E 73     
003376r 3               
003376r 3               nt_block_ramdrive_init:
003376r 3  13 10                .byte 19, UF
003378r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
00337Cr 3  rr rr        
00337Er 3  62 6C 6F 63          .byte "block-ramdrive-init"
003382r 3  6B 2D 72 61  
003386r 3  6D 64 72 69  
003391r 3               
003391r 3               nt_list:
003391r 3  04 10                .byte 4, UF
003393r 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
003397r 3  rr rr        
003399r 3  6C 69 73 74          .byte "list"
00339Dr 3               
00339Dr 3               nt_thru:
00339Dr 3  04 10                .byte 4, UF
00339Fr 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
0033A3r 3  rr rr        
0033A5r 3  74 68 72 75          .byte "thru"
0033A9r 3               
0033A9r 3               nt_load:
0033A9r 3  04 10                .byte 4, UF
0033ABr 3  rr rr rr rr          .word nt_thru, xt_load, z_load
0033AFr 3  rr rr        
0033B1r 3  6C 6F 61 64          .byte "load"
0033B5r 3               
0033B5r 3               nt_flush:
0033B5r 3  05 00                .byte 5, 0
0033B7r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
0033BBr 3  rr rr        
0033BDr 3  66 6C 75 73          .byte "flush"
0033C1r 3  68           
0033C2r 3               
0033C2r 3               nt_empty_buffers:
0033C2r 3  0D 00                .byte 13, 0
0033C4r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
0033C8r 3  rr rr        
0033CAr 3  65 6D 70 74          .byte "empty-buffers"
0033CEr 3  79 2D 62 75  
0033D2r 3  66 66 65 72  
0033D7r 3               
0033D7r 3               nt_buffer:
0033D7r 3  06 00                .byte 6, 0
0033D9r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
0033DDr 3  rr rr        
0033DFr 3  62 75 66 66          .byte "buffer"
0033E3r 3  65 72        
0033E5r 3               
0033E5r 3               nt_update:
0033E5r 3  06 00                .byte 6, 0
0033E7r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
0033EBr 3  rr rr        
0033EDr 3  75 70 64 61          .byte "update"
0033F1r 3  74 65        
0033F3r 3               
0033F3r 3               nt_block:
0033F3r 3  05 00                .byte 5, 0
0033F5r 3  rr rr rr rr          .word nt_update, xt_block, z_block
0033F9r 3  rr rr        
0033FBr 3  62 6C 6F 63          .byte "block"
0033FFr 3  6B           
003400r 3               
003400r 3               nt_save_buffers:
003400r 3  0C 00                .byte 12, 0
003402r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
003406r 3  rr rr        
003408r 3  73 61 76 65          .byte "save-buffers"
00340Cr 3  2D 62 75 66  
003410r 3  66 65 72 73  
003414r 3               
003414r 3               nt_block_read_vector:
003414r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
003416r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
00341Ar 3  rr rr        
00341Cr 3  62 6C 6F 63          .byte "block-read-vector"
003420r 3  6B 2D 72 65  
003424r 3  61 64 2D 76  
00342Dr 3               
00342Dr 3               nt_block_read:
00342Dr 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
00342Fr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
003433r 3  rr rr        
003435r 3  62 6C 6F 63          .byte "block-read"
003439r 3  6B 2D 72 65  
00343Dr 3  61 64        
00343Fr 3               
00343Fr 3               nt_block_write_vector:
00343Fr 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
003441r 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
003445r 3  rr rr        
003447r 3  62 6C 6F 63          .byte "block-write-vector"
00344Br 3  6B 2D 77 72  
00344Fr 3  69 74 65 2D  
003459r 3               
003459r 3               nt_block_write:
003459r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
00345Br 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
00345Fr 3  rr rr        
003461r 3  62 6C 6F 63          .byte "block-write"
003465r 3  6B 2D 77 72  
003469r 3  69 74 65     
00346Cr 3               
00346Cr 3               nt_blk:
00346Cr 3  03 00                .byte 3, 0
00346Er 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
003472r 3  rr rr        
003474r 3  62 6C 6B             .byte "blk"
003477r 3               
003477r 3               nt_scr:
003477r 3  03 00                .byte 3, 0
003479r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
00347Dr 3  rr rr        
00347Fr 3  73 63 72             .byte "scr"
003482r 3               
003482r 3               nt_blkbuffer:
003482r 3  09 00                .byte 9, 0
003484r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
003488r 3  rr rr        
00348Ar 3  62 6C 6B 62          .byte "blkbuffer"
00348Er 3  75 66 66 65  
003492r 3  72           
003493r 3               
003493r 3               nt_buffblocknum:
003493r 3  0C 00                .byte 12, 0
003495r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
003499r 3  rr rr        
00349Br 3  62 75 66 66          .byte "buffblocknum"
00349Fr 3  62 6C 6F 63  
0034A3r 3  6B 6E 75 6D  
0034A7r 3               
0034A7r 3               nt_buffstatus:
0034A7r 3  0A 00                .byte 10, 0
0034A9r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
0034ADr 3  rr rr        
0034AFr 3  62 75 66 66          .byte "buffstatus"
0034B3r 3  73 74 61 74  
0034B7r 3  75 73        
0034B9r 3               
0034B9r 3               nt_buffer_colon:
0034B9r 3  07 00                .byte 7, 0
0034BBr 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
0034BFr 3  rr rr        
0034C1r 3  62 75 66 66          .byte "buffer:"
0034C5r 3  65 72 3A     
0034C8r 3               
0034C8r 3               nt_useraddr:
0034C8r 3  08 00                .byte 8, 0
0034CAr 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
0034CEr 3  rr rr        
0034D0r 3  75 73 65 72          .byte "useraddr"
0034D4r 3  61 64 64 72  
0034D8r 3               
0034D8r 3               nt_action_of:
0034D8r 3  09 04                .byte 9, IM
0034DAr 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
0034DEr 3  rr rr        
0034E0r 3  61 63 74 69          .byte "action-of"
0034E4r 3  6F 6E 2D 6F  
0034E8r 3  66           
0034E9r 3               
0034E9r 3               nt_is:
0034E9r 3  02 04                .byte 2, IM
0034EBr 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
0034EFr 3  rr rr        
0034F1r 3  69 73                .byte "is"
0034F3r 3               
0034F3r 3               nt_defer_store:
0034F3r 3  06 00                .byte 6, 0
0034F5r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
0034F9r 3  rr rr        
0034FBr 3  64 65 66 65          .byte "defer!"
0034FFr 3  72 21        
003501r 3               
003501r 3               nt_defer_fetch:
003501r 3  06 00                .byte 6, 0
003503r 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
003507r 3  rr rr        
003509r 3  64 65 66 65          .byte "defer@"
00350Dr 3  72 40        
00350Fr 3               
00350Fr 3               nt_endcase:
00350Fr 3  07 0D                .byte 7, IM+CO+NN
003511r 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
003515r 3  rr rr        
003517r 3  65 6E 64 63          .byte "endcase"
00351Br 3  61 73 65     
00351Er 3               
00351Er 3               nt_endof:
00351Er 3  05 0D                .byte 5, IM+CO+NN
003520r 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
003524r 3  rr rr        
003526r 3  65 6E 64 6F          .byte "endof"
00352Ar 3  66           
00352Br 3               
00352Br 3               nt_of:
00352Br 3  02 0D                .byte 2, IM+CO+NN
00352Dr 3  rr rr rr rr          .word nt_endof, xt_of, z_of
003531r 3  rr rr        
003533r 3  6F 66                .byte "of"
003535r 3               
003535r 3               nt_case:
003535r 3  04 0D                .byte 4, IM+CO+NN
003537r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
00353Br 3  rr rr        
00353Dr 3  63 61 73 65          .byte "case"
003541r 3               
003541r 3               nt_while:
003541r 3  05 0D                .byte 5, IM+CO+NN
003543r 3  rr rr rr rr          .word nt_case, xt_while, z_while
003547r 3  rr rr        
003549r 3  77 68 69 6C          .byte "while"
00354Dr 3  65           
00354Er 3               
00354Er 3               nt_until:
00354Er 3  05 0D                .byte 5, IM+CO+NN
003550r 3  rr rr rr rr          .word nt_while, xt_until, z_until
003554r 3  rr rr        
003556r 3  75 6E 74 69          .byte "until"
00355Ar 3  6C           
00355Br 3               
00355Br 3               nt_repeat:
00355Br 3  06 0D                .byte 6, IM+CO+NN
00355Dr 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
003561r 3  rr rr        
003563r 3  72 65 70 65          .byte "repeat"
003567r 3  61 74        
003569r 3               
003569r 3               nt_else:
003569r 3  04 0D                .byte 4, IM+CO+NN
00356Br 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
00356Fr 3  rr rr        
003571r 3  65 6C 73 65          .byte "else"
003575r 3               
003575r 3               nt_then:
003575r 3  04 0D                .byte 4, IM+CO+NN
003577r 3  rr rr rr rr          .word nt_else, xt_then, z_then
00357Br 3  rr rr        
00357Dr 3  74 68 65 6E          .byte "then"
003581r 3               
003581r 3               nt_if:
003581r 3  02 0D                .byte 2, IM+CO+NN
003583r 3  rr rr rr rr          .word nt_then, xt_if, z_if
003587r 3  rr rr        
003589r 3  69 66                .byte "if"
00358Br 3               
00358Br 3               nt_dot_paren:
00358Br 3  02 04                .byte 2, IM
00358Dr 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
003591r 3  rr rr        
003593r 3  2E 28                .byte ".("
003595r 3               
003595r 3               nt_paren:
003595r 3  01 04                .byte 1, IM
003597r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
00359Br 3  rr rr        
00359Dr 3  28                   .byte "("
00359Er 3               
00359Er 3               nt_word:
00359Er 3  04 10                .byte 4, UF
0035A0r 3  rr rr rr rr          .word nt_paren, xt_word, z_word
0035A4r 3  rr rr        
0035A6r 3  77 6F 72 64          .byte "word"
0035AAr 3               
0035AAr 3               nt_find:
0035AAr 3  04 10                .byte 4, UF
0035ACr 3  rr rr rr rr          .word nt_word, xt_find, z_find
0035B0r 3  rr rr        
0035B2r 3  66 69 6E 64          .byte "find"
0035B6r 3               
0035B6r 3               nt_environment_q:
0035B6r 3  0C 10                .byte 12, UF
0035B8r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
0035BCr 3  rr rr        
0035BEr 3  65 6E 76 69          .byte "environment?"
0035C2r 3  72 6F 6E 6D  
0035C6r 3  65 6E 74 3F  
0035CAr 3               
0035CAr 3               nt_search:
0035CAr 3  06 18                .byte 6, UF+NN
0035CCr 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
0035D0r 3  rr rr        
0035D2r 3  73 65 61 72          .byte "search"
0035D6r 3  63 68        
0035D8r 3               
0035D8r 3               nt_compare:
0035D8r 3  07 10                .byte 7, UF
0035DAr 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
0035DEr 3  rr rr        
0035E0r 3  63 6F 6D 70          .byte "compare"
0035E4r 3  61 72 65     
0035E7r 3               
0035E7r 3               nt_disasm:
0035E7r 3  06 10                .byte 6, UF
0035E9r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
0035EDr 3  rr rr        
0035EFr 3  64 69 73 61          .byte "disasm"
0035F3r 3  73 6D        
0035F5r 3               
0035F5r 3               nt_dot_s:
0035F5r 3  02 00                .byte 2, 0
0035F7r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
0035FBr 3  rr rr        
0035FDr 3  2E 73                .byte ".s"
0035FFr 3               
0035FFr 3               nt_dump:
0035FFr 3  04 10                .byte 4, UF
003601r 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
003605r 3  rr rr        
003607r 3  64 75 6D 70          .byte "dump"
00360Br 3               
00360Br 3               nt_bell:
00360Br 3  04 00                .byte 4, 0
00360Dr 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
003611r 3  rr rr        
003613r 3  62 65 6C 6C          .byte "bell"
003617r 3               
003617r 3               nt_align:
003617r 3  05 00                .byte 5, 0
003619r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
00361Dr 3  rr rr        
00361Fr 3  61 6C 69 67          .byte "align"
003623r 3  6E           
003624r 3               
003624r 3               nt_aligned:             ; same code as ALIGN
003624r 3  07 00                .byte 7, 0
003626r 3  rr rr rr rr          .word nt_align, xt_align, z_align
00362Ar 3  rr rr        
00362Cr 3  61 6C 69 67          .byte "aligned"
003630r 3  6E 65 64     
003633r 3               
003633r 3               nt_wordsize:
003633r 3  08 10                .byte 8, UF
003635r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
003639r 3  rr rr        
00363Br 3  77 6F 72 64          .byte "wordsize"
00363Fr 3  73 69 7A 65  
003643r 3               
003643r 3               nt_words:
003643r 3  05 00                .byte 5, 0
003645r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
003649r 3  rr rr        
00364Br 3  77 6F 72 64          .byte "words"
00364Fr 3  73           
003650r 3               
003650r 3               nt_marker:
003650r 3  06 04                .byte 6, IM
003652r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
003656r 3  rr rr        
003658r 3  6D 61 72 6B          .byte "marker"
00365Cr 3  65 72        
00365Er 3               
00365Er 3               nt_at_xy:
00365Er 3  05 10                .byte 5, UF
003660r 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
003664r 3  rr rr        
003666r 3  61 74 2D 78          .byte "at-xy"
00366Ar 3  79           
00366Br 3               
00366Br 3               nt_page:
00366Br 3  04 00                .byte 4, 0
00366Dr 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
003671r 3  rr rr        
003673r 3  70 61 67 65          .byte "page"
003677r 3               
003677r 3               nt_cr:
003677r 3  02 00                .byte 2, 0
003679r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
00367Dr 3  rr rr        
00367Fr 3  63 72                .byte "cr"
003681r 3               
003681r 3               nt_input:
003681r 3  05 00                .byte 5, 0
003683r 3  rr rr rr rr          .word nt_cr, xt_input, z_input
003687r 3  rr rr        
003689r 3  69 6E 70 75          .byte "input"
00368Dr 3  74           
00368Er 3               
00368Er 3               nt_output:
00368Er 3  06 00                .byte 6, 0
003690r 3  rr rr rr rr          .word nt_input, xt_output, z_output
003694r 3  rr rr        
003696r 3  6F 75 74 70          .byte "output"
00369Ar 3  75 74        
00369Cr 3               
00369Cr 3               nt_sign:
00369Cr 3  04 10                .byte 4, UF
00369Er 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
0036A2r 3  rr rr        
0036A4r 3  73 69 67 6E          .byte "sign"
0036A8r 3               
0036A8r 3               nt_hold:
0036A8r 3  04 10                .byte 4, UF
0036AAr 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
0036AEr 3  rr rr        
0036B0r 3  68 6F 6C 64          .byte "hold"
0036B4r 3               
0036B4r 3               nt_number_sign_greater:
0036B4r 3  02 10                .byte 2, UF
0036B6r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
0036BAr 3  rr rr        
0036BCr 3  23 3E                .byte "#>"
0036BEr 3               
0036BEr 3               nt_number_sign_s:
0036BEr 3  02 10                .byte 2, UF
0036C0r 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
0036C4r 3  rr rr        
0036C6r 3  23 73                .byte "#s"
0036C8r 3               
0036C8r 3               nt_number_sign:
0036C8r 3  01 10                .byte 1, UF
0036CAr 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
0036CEr 3  rr rr        
0036D0r 3  23                   .byte "#"
0036D1r 3               
0036D1r 3               nt_less_number_sign:
0036D1r 3  02 00                .byte 2, 0
0036D3r 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
0036D7r 3  rr rr        
0036D9r 3  3C 23                .byte "<#"
0036DBr 3               
0036DBr 3               nt_to_in:
0036DBr 3  03 00                .byte 3, 0
0036DDr 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
0036E1r 3  rr rr        
0036E3r 3  3E 69 6E             .byte ">in"
0036E6r 3               
0036E6r 3               nt_within:
0036E6r 3  06 10                .byte 6, UF
0036E8r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
0036ECr 3  rr rr        
0036EEr 3  77 69 74 68          .byte "within"
0036F2r 3  69 6E        
0036F4r 3               
0036F4r 3               nt_hexstore:
0036F4r 3  08 10                .byte 8, UF
0036F6r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
0036FAr 3  rr rr        
0036FCr 3  68 65 78 73          .byte "hexstore"
003700r 3  74 6F 72 65  
003704r 3               
003704r 3               nt_cleave:
003704r 3  06 10                .byte 6, UF
003706r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
00370Ar 3  rr rr        
00370Cr 3  63 6C 65 61          .byte "cleave"
003710r 3  76 65        
003712r 3               
003712r 3               nt_pad:
003712r 3  03 00                .byte 3, 0
003714r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
003718r 3  rr rr        
00371Ar 3  70 61 64             .byte "pad"
00371Dr 3               
00371Dr 3               nt_cmove:
00371Dr 3  05 10                .byte 5, UF
00371Fr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
003723r 3  rr rr        
003725r 3  63 6D 6F 76          .byte "cmove"
003729r 3  65           
00372Ar 3               
00372Ar 3               nt_cmove_up:
00372Ar 3  06 10                .byte 6, UF
00372Cr 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
003730r 3  rr rr        
003732r 3  63 6D 6F 76          .byte "cmove>"
003736r 3  65 3E        
003738r 3               
003738r 3               nt_move:
003738r 3  04 18                .byte 4, NN+UF
00373Ar 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
00373Er 3  rr rr        
003740r 3  6D 6F 76 65          .byte "move"
003744r 3               
003744r 3               nt_backslash:
003744r 3  01 04                .byte 1, IM
003746r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
00374Ar 3  rr rr        
00374Cr 3  5C                   .byte $5c
00374Dr 3               
00374Dr 3               nt_star_slash:
00374Dr 3  02 10                .byte 2, UF
00374Fr 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
003753r 3  rr rr        
003755r 3  2A 2F                .byte "*/"
003757r 3               
003757r 3               nt_star_slash_mod:
003757r 3  05 10                .byte 5, UF
003759r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
00375Dr 3  rr rr        
00375Fr 3  2A 2F 6D 6F          .byte "*/mod"
003763r 3  64           
003764r 3               
003764r 3               nt_mod:
003764r 3  03 10                .byte 3, UF
003766r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
00376Ar 3  rr rr        
00376Cr 3  6D 6F 64             .byte "mod"
00376Fr 3               
00376Fr 3               nt_slash_mod:
00376Fr 3  04 10                .byte 4, UF
003771r 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
003775r 3  rr rr        
003777r 3  2F 6D 6F 64          .byte "/mod"
00377Br 3               
00377Br 3               nt_slash:
00377Br 3  01 10                .byte 1, UF
00377Dr 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
003781r 3  rr rr        
003783r 3  2F                   .byte "/"
003784r 3               
003784r 3               nt_fm_slash_mod:
003784r 3  06 10                .byte 6, UF
003786r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
00378Ar 3  rr rr        
00378Cr 3  66 6D 2F 6D          .byte "fm/mod"
003790r 3  6F 64        
003792r 3               
003792r 3               nt_sm_slash_rem:
003792r 3  06 10                .byte 6, UF
003794r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
003798r 3  rr rr        
00379Ar 3  73 6D 2F 72          .byte "sm/rem"
00379Er 3  65 6D        
0037A0r 3               
0037A0r 3               nt_um_slash_mod:
0037A0r 3  06 10                .byte 6, UF
0037A2r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
0037A6r 3  rr rr        
0037A8r 3  75 6D 2F 6D          .byte "um/mod"
0037ACr 3  6F 64        
0037AEr 3               
0037AEr 3               nt_star:
0037AEr 3  01 10                .byte 1, UF
0037B0r 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
0037B4r 3  rr rr        
0037B6r 3  2A                   .byte "*"
0037B7r 3               
0037B7r 3               nt_um_star:
0037B7r 3  03 10                .byte 3, UF
0037B9r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
0037BDr 3  rr rr        
0037BFr 3  75 6D 2A             .byte "um*"
0037C2r 3               
0037C2r 3               nt_m_star:
0037C2r 3  02 10                .byte 2, UF
0037C4r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
0037C8r 3  rr rr        
0037CAr 3  6D 2A                .byte "m*"
0037CCr 3               
0037CCr 3               nt_count:
0037CCr 3  05 10                .byte 5, UF
0037CEr 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
0037D2r 3  rr rr        
0037D4r 3  63 6F 75 6E          .byte "count"
0037D8r 3  74           
0037D9r 3               
0037D9r 3               nt_decimal:
0037D9r 3  07 00                .byte 7, 0
0037DBr 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
0037DFr 3  rr rr        
0037E1r 3  64 65 63 69          .byte "decimal"
0037E5r 3  6D 61 6C     
0037E8r 3               
0037E8r 3               nt_hex:
0037E8r 3  03 00                .byte 3, 0
0037EAr 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
0037EEr 3  rr rr        
0037F0r 3  68 65 78             .byte "hex"
0037F3r 3               
0037F3r 3               nt_to_number:
0037F3r 3  07 10                .byte 7, UF
0037F5r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
0037F9r 3  rr rr        
0037FBr 3  3E 6E 75 6D          .byte ">number"
0037FFr 3  62 65 72     
003802r 3               
003802r 3               nt_number:
003802r 3  06 10                .byte 6, UF
003804r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
003808r 3  rr rr        
00380Ar 3  6E 75 6D 62          .byte "number"
00380Er 3  65 72        
003810r 3               
003810r 3               nt_digit_question:
003810r 3  06 10                .byte 6, UF
003812r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
003816r 3  rr rr        
003818r 3  64 69 67 69          .byte "digit?"
00381Cr 3  74 3F        
00381Er 3               
00381Er 3               nt_base:
00381Er 3  04 00                .byte 4, 0
003820r 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
003824r 3  rr rr        
003826r 3  62 61 73 65          .byte "base"
00382Ar 3               
00382Ar 3               nt_evaluate:
00382Ar 3  08 10                .byte 8, UF
00382Cr 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
003830r 3  rr rr        
003832r 3  65 76 61 6C          .byte "evaluate"
003836r 3  75 61 74 65  
00383Ar 3               
00383Ar 3               nt_state:
00383Ar 3  05 00                .byte 5, 0
00383Cr 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
003840r 3  rr rr        
003842r 3  73 74 61 74          .byte "state"
003846r 3  65           
003847r 3               
003847r 3               nt_again:
003847r 3  05 17                .byte 5, AN+CO+IM+UF
003849r 3  rr rr rr rr          .word nt_state, xt_again, z_again
00384Dr 3  rr rr        
00384Fr 3  61 67 61 69          .byte "again"
003853r 3  6E           
003854r 3               
003854r 3               nt_begin:
003854r 3  05 07                .byte 5, AN+CO+IM
003856r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
00385Ar 3  rr rr        
00385Cr 3  62 65 67 69          .byte "begin"
003860r 3  6E           
003861r 3               
003861r 3               nt_quit:
003861r 3  04 00                .byte 4, 0
003863r 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
003867r 3  rr rr        
003869r 3  71 75 69 74          .byte "quit"
00386Dr 3               
00386Dr 3               nt_recurse:
00386Dr 3  07 0D                .byte 7, CO+IM+NN
00386Fr 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
003873r 3  rr rr        
003875r 3  72 65 63 75          .byte "recurse"
003879r 3  72 73 65     
00387Cr 3               
00387Cr 3               nt_leave:
00387Cr 3  05 03                .byte 5, AN+CO
00387Er 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
003882r 3  rr rr        
003884r 3  6C 65 61 76          .byte "leave"
003888r 3  65           
003889r 3               
003889r 3               nt_unloop:
003889r 3  06 03                .byte 6, AN+CO
00388Br 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
00388Fr 3  rr rr        
003891r 3  75 6E 6C 6F          .byte "unloop"
003895r 3  6F 70        
003897r 3               
003897r 3               nt_exit:
003897r 3  04 03                .byte 4, AN+CO
003899r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
00389Dr 3  rr rr        
00389Fr 3  65 78 69 74          .byte "exit"
0038A3r 3               
0038A3r 3               nt_plus_loop:
0038A3r 3  05 05                .byte 5, CO+IM
0038A5r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
0038A9r 3  rr rr        
0038ABr 3  2B 6C 6F 6F          .byte "+loop"
0038AFr 3  70           
0038B0r 3               
0038B0r 3               nt_loop:
0038B0r 3  04 05                .byte 4, CO+IM
0038B2r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
0038B6r 3  rr rr        
0038B8r 3  6C 6F 6F 70          .byte "loop"
0038BCr 3               
0038BCr 3               nt_j:
0038BCr 3  01 03                .byte 1, AN+CO
0038BEr 3  rr rr rr rr          .word nt_loop, xt_j, z_j
0038C2r 3  rr rr        
0038C4r 3  6A                   .byte "j"
0038C5r 3               
0038C5r 3               nt_i:
0038C5r 3  01 03                .byte 1, AN+CO
0038C7r 3  rr rr rr rr          .word nt_j, xt_i, z_i
0038CBr 3  rr rr        
0038CDr 3  69                   .byte "i"
0038CEr 3               
0038CEr 3               nt_question_do:
0038CEr 3  03 0D                .byte 3, CO+IM+NN
0038D0r 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
0038D4r 3  rr rr        
0038D6r 3  3F 64 6F             .byte "?do"
0038D9r 3               
0038D9r 3               nt_do:
0038D9r 3  02 0D                .byte 2, CO+IM+NN
0038DBr 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
0038DFr 3  rr rr        
0038E1r 3  64 6F                .byte "do"
0038E3r 3               
0038E3r 3               nt_abort_quote:
0038E3r 3  06 0D                .byte 6, CO+IM+NN
0038E5r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
0038E9r 3  rr rr        
0038EBr 3  61 62 6F 72          .byte "abort", $22
0038EFr 3  74 22        
0038F1r 3               
0038F1r 3               nt_abort:
0038F1r 3  05 00                .byte 5, 0
0038F3r 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
0038F7r 3  rr rr        
0038F9r 3  61 62 6F 72          .byte "abort"
0038FDr 3  74           
0038FEr 3               
0038FEr 3               nt_strip_underflow:
0038FEr 3  0F 00                .byte 15, 0
003900r 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
003904r 3  rr rr        
003906r 3  73 74 72 69          .byte "strip-underflow"
00390Ar 3  70 2D 75 6E  
00390Er 3  64 65 72 66  
003915r 3               
003915r 3               nt_nc_limit:
003915r 3  08 00                .byte 8, 0
003917r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
00391Br 3  rr rr        
00391Dr 3  6E 63 2D 6C          .byte "nc-limit"
003921r 3  69 6D 69 74  
003925r 3               
003925r 3               nt_allow_native:
003925r 3  0C 00                .byte 12, 0
003927r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
00392Br 3  rr rr        
00392Dr 3  61 6C 6C 6F          .byte "allow-native"
003931r 3  77 2D 6E 61  
003935r 3  74 69 76 65  
003939r 3               
003939r 3               nt_always_native:
003939r 3  0D 00                .byte 13, 0
00393Br 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
00393Fr 3  rr rr        
003941r 3  61 6C 77 61          .byte "always-native"
003945r 3  79 73 2D 6E  
003949r 3  61 74 69 76  
00394Er 3               
00394Er 3               nt_never_native:
00394Er 3  0C 00                .byte 12, 0
003950r 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
003954r 3  rr rr        
003956r 3  6E 65 76 65          .byte "never-native"
00395Ar 3  72 2D 6E 61  
00395Er 3  74 69 76 65  
003962r 3               
003962r 3               nt_compile_only:
003962r 3  0C 00                .byte 12, 0
003964r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003968r 3  rr rr        
00396Ar 3  63 6F 6D 70          .byte "compile-only"
00396Er 3  69 6C 65 2D  
003972r 3  6F 6E 6C 79  
003976r 3               
003976r 3               nt_immediate:
003976r 3  09 00                .byte 9, 0
003978r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
00397Cr 3  rr rr        
00397Er 3  69 6D 6D 65          .byte "immediate"
003982r 3  64 69 61 74  
003986r 3  65           
003987r 3               
003987r 3               nt_postpone:
003987r 3  08 05                .byte 8, IM+CO
003989r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
00398Dr 3  rr rr        
00398Fr 3  70 6F 73 74          .byte "postpone"
003993r 3  70 6F 6E 65  
003997r 3               
003997r 3               nt_s_backslash_quote:
003997r 3  03 04                .byte 3, IM
003999r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
00399Dr 3  rr rr        
00399Fr 3  73 5C 22             .byte "s", $5C, $22
0039A2r 3               
0039A2r 3               nt_s_quote:
0039A2r 3  02 0C                .byte 2, IM+NN
0039A4r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
0039A8r 3  rr rr        
0039AAr 3  73 22                .byte "s", $22
0039ACr 3               
0039ACr 3               nt_dot_quote:
0039ACr 3  02 05                .byte 2, CO+IM
0039AEr 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
0039B2r 3  rr rr        
0039B4r 3  2E 22                .byte ".", $22
0039B6r 3               
0039B6r 3               nt_sliteral:
0039B6r 3  08 15                .byte 8, CO+IM+UF
0039B8r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
0039BCr 3  rr rr        
0039BEr 3  73 6C 69 74          .byte "sliteral"
0039C2r 3  65 72 61 6C  
0039C6r 3               
0039C6r 3               nt_literal:
0039C6r 3  07 15                .byte 7, IM+CO+UF
0039C8r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
0039CCr 3  rr rr        
0039CEr 3  6C 69 74 65          .byte "literal"
0039D2r 3  72 61 6C     
0039D5r 3               
0039D5r 3               nt_right_bracket:
0039D5r 3  01 04                .byte 1, IM
0039D7r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
0039DBr 3  rr rr        
0039DDr 3  5D                   .byte "]"
0039DEr 3               
0039DEr 3               nt_left_bracket:
0039DEr 3  01 05                .byte 1, IM+CO
0039E0r 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
0039E4r 3  rr rr        
0039E6r 3  5B                   .byte "["
0039E7r 3               
0039E7r 3               nt_compile_comma:
0039E7r 3  08 18                .byte 8, UF+NN
0039E9r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
0039EDr 3  rr rr        
0039EFr 3  63 6F 6D 70          .byte "compile,"
0039F3r 3  69 6C 65 2C  
0039F7r 3               
0039F7r 3               nt_colon_noname:
0039F7r 3  07 00                .byte 7, 0
0039F9r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
0039FDr 3  rr rr        
0039FFr 3  3A 6E 6F 6E          .byte ":noname"
003A03r 3  61 6D 65     
003A06r 3               
003A06r 3               nt_semicolon:
003A06r 3  01 05                .byte 1, CO+IM
003A08r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
003A0Cr 3  rr rr        
003A0Er 3  3B                   .byte ";"
003A0Fr 3               
003A0Fr 3               nt_colon:
003A0Fr 3  01 00                .byte 1, 0
003A11r 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
003A15r 3  rr rr        
003A17r 3  3A                   .byte ":"
003A18r 3               
003A18r 3               nt_source_id:
003A18r 3  09 00                .byte 9, 0
003A1Ar 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
003A1Er 3  rr rr        
003A20r 3  73 6F 75 72          .byte "source-id"
003A24r 3  63 65 2D 69  
003A28r 3  64           
003A29r 3               
003A29r 3               nt_source:
003A29r 3  06 00                .byte 6, 0
003A2Br 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
003A2Fr 3  rr rr        
003A31r 3  73 6F 75 72          .byte "source"
003A35r 3  63 65        
003A37r 3               
003A37r 3               nt_execute_parsing:
003A37r 3  0F 10                .byte 15, UF
003A39r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
003A3Dr 3  rr rr        
003A3Fr 3  65 78 65 63          .byte "execute-parsing"
003A43r 3  75 74 65 2D  
003A47r 3  70 61 72 73  
003A4Er 3               
003A4Er 3               nt_parse:
003A4Er 3  05 10                .byte 5, UF
003A50r 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
003A54r 3  rr rr        
003A56r 3  70 61 72 73          .byte "parse"
003A5Ar 3  65           
003A5Br 3               
003A5Br 3               nt_parse_name:
003A5Br 3  0A 08                .byte 10, NN
003A5Dr 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
003A61r 3  rr rr        
003A63r 3  70 61 72 73          .byte "parse-name"
003A67r 3  65 2D 6E 61  
003A6Br 3  6D 65        
003A6Dr 3               
003A6Dr 3               nt_latestnt:
003A6Dr 3  08 00                .byte 8, 0
003A6Fr 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
003A73r 3  rr rr        
003A75r 3  6C 61 74 65          .byte "latestnt"
003A79r 3  73 74 6E 74  
003A7Dr 3               
003A7Dr 3               nt_latestxt:
003A7Dr 3  08 00                .byte 8, 0
003A7Fr 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
003A83r 3  rr rr        
003A85r 3  6C 61 74 65          .byte "latestxt"
003A89r 3  73 74 78 74  
003A8Dr 3               
003A8Dr 3               nt_defer:
003A8Dr 3  05 00                .byte 5, 0
003A8Fr 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
003A93r 3  rr rr        
003A95r 3  64 65 66 65          .byte "defer"
003A99r 3  72           
003A9Ar 3               
003A9Ar 3               nt_to_body:
003A9Ar 3  05 10                .byte 5, UF
003A9Cr 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
003AA0r 3  rr rr        
003AA2r 3  3E 62 6F 64          .byte ">body"
003AA6r 3  79           
003AA7r 3               
003AA7r 3               nt_name_to_string:
003AA7r 3  0B 10                .byte 11, UF
003AA9r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
003AADr 3  rr rr        
003AAFr 3  6E 61 6D 65          .byte "name>string"
003AB3r 3  3E 73 74 72  
003AB7r 3  69 6E 67     
003ABAr 3               
003ABAr 3               nt_int_to_name:
003ABAr 3  08 10                .byte 8, UF
003ABCr 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
003AC0r 3  rr rr        
003AC2r 3  69 6E 74 3E          .byte "int>name"
003AC6r 3  6E 61 6D 65  
003ACAr 3               
003ACAr 3               nt_name_to_int:
003ACAr 3  08 10                .byte 8, UF
003ACCr 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
003AD0r 3  rr rr        
003AD2r 3  6E 61 6D 65          .byte "name>int"
003AD6r 3  3E 69 6E 74  
003ADAr 3               
003ADAr 3               nt_bracket_tick:
003ADAr 3  03 05                .byte 3, CO+IM
003ADCr 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
003AE0r 3  rr rr        
003AE2r 3  5B 27 5D             .byte "[']"
003AE5r 3               
003AE5r 3               nt_tick:
003AE5r 3  01 00                .byte 1, 0
003AE7r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
003AEBr 3  rr rr        
003AEDr 3  27                   .byte "'"
003AEEr 3               
003AEEr 3               nt_find_name:
003AEEr 3  09 10                .byte 9, UF
003AF0r 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
003AF4r 3  rr rr        
003AF6r 3  66 69 6E 64          .byte "find-name"
003AFAr 3  2D 6E 61 6D  
003AFEr 3  65           
003AFFr 3               
003AFFr 3               nt_fill:
003AFFr 3  04 10                .byte 4, UF
003B01r 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
003B05r 3  rr rr        
003B07r 3  66 69 6C 6C          .byte "fill"
003B0Br 3               
003B0Br 3               nt_blank:
003B0Br 3  05 00                .byte 5, 0     ; underflow checked by FILL
003B0Dr 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
003B11r 3  rr rr        
003B13r 3  62 6C 61 6E          .byte "blank"
003B17r 3  6B           
003B18r 3               
003B18r 3               nt_erase:
003B18r 3  05 00                .byte 5, 0      ; underflow checked by FILL
003B1Ar 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
003B1Er 3  rr rr        
003B20r 3  65 72 61 73          .byte "erase"
003B24r 3  65           
003B25r 3               
003B25r 3               nt_d_plus:
003B25r 3  02 10                .byte 2, UF
003B27r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
003B2Br 3  rr rr        
003B2Dr 3  64 2B                .byte "d+"
003B2Fr 3               
003B2Fr 3               nt_d_minus:
003B2Fr 3  02 10                .byte 2, UF
003B31r 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
003B35r 3  rr rr        
003B37r 3  64 2D                .byte "d-"
003B39r 3               
003B39r 3               nt_d_to_s:
003B39r 3  03 10                .byte 3, UF
003B3Br 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
003B3Fr 3  rr rr        
003B41r 3  64 3E 73             .byte "d>s"
003B44r 3               
003B44r 3               nt_s_to_d:
003B44r 3  03 10                .byte 3, UF
003B46r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
003B4Ar 3  rr rr        
003B4Cr 3  73 3E 64             .byte "s>d"
003B4Fr 3               
003B4Fr 3               nt_to:
003B4Fr 3  02 0C                .byte 2, NN+IM
003B51r 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
003B55r 3  rr rr        
003B57r 3  74 6F                .byte "to"
003B59r 3               
003B59r 3               nt_value:               ; same code as CONSTANT
003B59r 3  05 10                .byte 5, UF
003B5Br 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
003B5Fr 3  rr rr        
003B61r 3  76 61 6C 75          .byte "value"
003B65r 3  65           
003B66r 3               
003B66r 3               nt_constant:
003B66r 3  08 10                .byte 8, UF
003B68r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
003B6Cr 3  rr rr        
003B6Er 3  63 6F 6E 73          .byte "constant"
003B72r 3  74 61 6E 74  
003B76r 3               
003B76r 3               nt_variable:
003B76r 3  08 00                .byte 8, 0
003B78r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
003B7Cr 3  rr rr        
003B7Er 3  76 61 72 69          .byte "variable"
003B82r 3  61 62 6C 65  
003B86r 3               
003B86r 3               nt_does:
003B86r 3  05 05                .byte 5, CO+IM
003B88r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
003B8Cr 3  rr rr        
003B8Er 3  64 6F 65 73          .byte "does>"
003B92r 3  3E           
003B93r 3               
003B93r 3               nt_create:
003B93r 3  06 00                .byte 6, 0
003B95r 3  rr rr rr rr          .word nt_does, xt_create, z_create
003B99r 3  rr rr        
003B9Br 3  63 72 65 61          .byte "create"
003B9Fr 3  74 65        
003BA1r 3               
003BA1r 3               nt_allot:
003BA1r 3  05 10                .byte 5, UF
003BA3r 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
003BA7r 3  rr rr        
003BA9r 3  61 6C 6C 6F          .byte "allot"
003BADr 3  74           
003BAEr 3               
003BAEr 3               nt_key:
003BAEr 3  03 00                .byte 3, 0
003BB0r 3  rr rr rr rr          .word nt_allot, xt_key, z_key
003BB4r 3  rr rr        
003BB6r 3  6B 65 79             .byte "key"
003BB9r 3               
003BB9r 3               nt_depth:
003BB9r 3  05 00                .byte 5, 0
003BBBr 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
003BBFr 3  rr rr        
003BC1r 3  64 65 70 74          .byte "depth"
003BC5r 3  68           
003BC6r 3               
003BC6r 3               nt_unused:
003BC6r 3  06 00                .byte 6, 0
003BC8r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
003BCCr 3  rr rr        
003BCEr 3  75 6E 75 73          .byte "unused"
003BD2r 3  65 64        
003BD4r 3               
003BD4r 3               nt_r_to_input:
003BD4r 3  07 08                .byte 7, NN
003BD6r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
003BDAr 3  rr rr        
003BDCr 3  72 3E 69 6E          .byte "r>input"
003BE0r 3  70 75 74     
003BE3r 3               
003BE3r 3               nt_input_to_r:
003BE3r 3  07 08                .byte 7, NN
003BE5r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
003BE9r 3  rr rr        
003BEBr 3  69 6E 70 75          .byte "input>r"
003BEFr 3  74 3E 72     
003BF2r 3               
003BF2r 3               nt_accept:
003BF2r 3  06 18                .byte 6, UF+NN
003BF4r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
003BF8r 3  rr rr        
003BFAr 3  61 63 63 65          .byte "accept"
003BFEr 3  70 74        
003C00r 3               
003C00r 3               nt_refill:
003C00r 3  06 00                .byte 6, 0
003C02r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
003C06r 3  rr rr        
003C08r 3  72 65 66 69          .byte "refill"
003C0Cr 3  6C 6C        
003C0Er 3               
003C0Er 3               nt_slash_string:
003C0Er 3  07 10                .byte 7, UF
003C10r 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
003C14r 3  rr rr        
003C16r 3  2F 73 74 72          .byte "/string"
003C1Ar 3  69 6E 67     
003C1Dr 3               
003C1Dr 3               nt_minus_leading:
003C1Dr 3  08 10                .byte 8, UF
003C1Fr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
003C23r 3  rr rr        
003C25r 3  2D 6C 65 61          .byte "-leading"
003C29r 3  64 69 6E 67  
003C2Dr 3               
003C2Dr 3               nt_minus_trailing:
003C2Dr 3  09 10                .byte 9, UF
003C2Fr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
003C33r 3  rr rr        
003C35r 3  2D 74 72 61          .byte "-trailing"
003C39r 3  69 6C 69 6E  
003C3Dr 3  67           
003C3Er 3               
003C3Er 3               nt_bl:
003C3Er 3  02 00                .byte 2, 0
003C40r 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
003C44r 3  rr rr        
003C46r 3  62 6C                .byte "bl"
003C48r 3               
003C48r 3               nt_spaces:
003C48r 3  06 10                .byte 6, UF
003C4Ar 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
003C4Er 3  rr rr        
003C50r 3  73 70 61 63          .byte "spaces"
003C54r 3  65 73        
003C56r 3               
003C56r 3               nt_bounds:
003C56r 3  06 10                .byte 6, UF
003C58r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
003C5Cr 3  rr rr        
003C5Er 3  62 6F 75 6E          .byte "bounds"
003C62r 3  64 73        
003C64r 3               
003C64r 3               nt_c_comma:
003C64r 3  02 10                .byte 2, UF
003C66r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
003C6Ar 3  rr rr        
003C6Cr 3  63 2C                .byte "c,"
003C6Er 3               
003C6Er 3               nt_dnegate:
003C6Er 3  07 10                .byte 7, UF
003C70r 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
003C74r 3  rr rr        
003C76r 3  64 6E 65 67          .byte "dnegate"
003C7Ar 3  61 74 65     
003C7Dr 3               
003C7Dr 3               nt_negate:
003C7Dr 3  06 10                .byte 6, UF
003C7Fr 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
003C83r 3  rr rr        
003C85r 3  6E 65 67 61          .byte "negate"
003C89r 3  74 65        
003C8Br 3               
003C8Br 3               nt_invert:
003C8Br 3  06 10                .byte 6, UF
003C8Dr 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
003C91r 3  rr rr        
003C93r 3  69 6E 76 65          .byte "invert"
003C97r 3  72 74        
003C99r 3               
003C99r 3               nt_two_to_r:
003C99r 3  03 11                .byte 3, CO+UF          ; native is special case
003C9Br 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
003C9Fr 3  rr rr        
003CA1r 3  32 3E 72             .byte "2>r"
003CA4r 3               
003CA4r 3               nt_two_r_from:
003CA4r 3  03 01                .byte 3, CO             ; native is special case
003CA6r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
003CAAr 3  rr rr        
003CACr 3  32 72 3E             .byte "2r>"
003CAFr 3               
003CAFr 3               nt_two_r_fetch:
003CAFr 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
003CB1r 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
003CB5r 3  rr rr        
003CB7r 3  32 72 40             .byte "2r@"
003CBAr 3               
003CBAr 3               nt_two_literal:
003CBAr 3  08 14                .byte 8, UF+IM
003CBCr 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
003CC0r 3  rr rr        
003CC2r 3  32 6C 69 74          .byte "2literal"
003CC6r 3  65 72 61 6C  
003CCAr 3               
003CCAr 3               nt_two_constant:
003CCAr 3  09 10                .byte 9, UF
003CCCr 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
003CD0r 3  rr rr        
003CD2r 3  32 63 6F 6E          .byte "2constant"
003CD6r 3  73 74 61 6E  
003CDAr 3  74           
003CDBr 3               
003CDBr 3               nt_two_variable:
003CDBr 3  09 00                .byte 9, 0
003CDDr 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
003CE1r 3  rr rr        
003CE3r 3  32 76 61 72          .byte "2variable"
003CE7r 3  69 61 62 6C  
003CEBr 3  65           
003CECr 3               
003CECr 3               nt_two_fetch:
003CECr 3  02 10                .byte 2, UF
003CEEr 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
003CF2r 3  rr rr        
003CF4r 3  32 40                .byte "2@"
003CF6r 3               
003CF6r 3               nt_two_store:
003CF6r 3  02 10                .byte 2, UF
003CF8r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
003CFCr 3  rr rr        
003CFEr 3  32 21                .byte "2!"
003D00r 3               
003D00r 3               nt_two_over:
003D00r 3  05 10                .byte 5, UF
003D02r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
003D06r 3  rr rr        
003D08r 3  32 6F 76 65          .byte "2over"
003D0Cr 3  72           
003D0Dr 3               
003D0Dr 3               nt_two_swap:
003D0Dr 3  05 10                .byte 5, UF
003D0Fr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
003D13r 3  rr rr        
003D15r 3  32 73 77 61          .byte "2swap"
003D19r 3  70           
003D1Ar 3               
003D1Ar 3               nt_two_drop:
003D1Ar 3  05 10                .byte 5, UF
003D1Cr 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
003D20r 3  rr rr        
003D22r 3  32 64 72 6F          .byte "2drop"
003D26r 3  70           
003D27r 3               
003D27r 3               nt_max:
003D27r 3  03 10                .byte 3, UF
003D29r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
003D2Dr 3  rr rr        
003D2Fr 3  6D 61 78             .byte "max"
003D32r 3               
003D32r 3               nt_min:
003D32r 3  03 10                .byte 3, UF
003D34r 3  rr rr rr rr          .word nt_max, xt_min, z_min
003D38r 3  rr rr        
003D3Ar 3  6D 69 6E             .byte "min"
003D3Dr 3               
003D3Dr 3               nt_zero_less:
003D3Dr 3  02 10                .byte 2, UF
003D3Fr 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
003D43r 3  rr rr        
003D45r 3  30 3C                .byte "0<"
003D47r 3               
003D47r 3               nt_zero_greater:
003D47r 3  02 10                .byte 2, UF
003D49r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
003D4Dr 3  rr rr        
003D4Fr 3  30 3E                .byte "0>"
003D51r 3               
003D51r 3               nt_zero_unequal:
003D51r 3  03 10                .byte 3, UF
003D53r 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
003D57r 3  rr rr        
003D59r 3  30 3C 3E             .byte "0<>"
003D5Cr 3               
003D5Cr 3               nt_zero_equal:
003D5Cr 3  02 10                .byte 2, UF
003D5Er 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
003D62r 3  rr rr        
003D64r 3  30 3D                .byte "0="
003D66r 3               
003D66r 3               nt_greater_than:
003D66r 3  01 10                .byte 1, UF
003D68r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
003D6Cr 3  rr rr        
003D6Er 3  3E                   .byte ">"
003D6Fr 3               
003D6Fr 3               nt_u_greater_than:
003D6Fr 3  02 10                .byte 2, UF
003D71r 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
003D75r 3  rr rr        
003D77r 3  75 3E                .byte "u>"
003D79r 3               
003D79r 3               nt_u_less_than:
003D79r 3  02 10                .byte 2, UF
003D7Br 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
003D7Fr 3  rr rr        
003D81r 3  75 3C                .byte "u<"
003D83r 3               
003D83r 3               nt_less_than:
003D83r 3  01 10                .byte 1, UF
003D85r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
003D89r 3  rr rr        
003D8Br 3  3C                   .byte "<"
003D8Cr 3               
003D8Cr 3               nt_not_equals:
003D8Cr 3  02 10                .byte 2, UF
003D8Er 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
003D92r 3  rr rr        
003D94r 3  3C 3E                .byte "<>"
003D96r 3               
003D96r 3               nt_equal:
003D96r 3  01 10                .byte 1, UF
003D98r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
003D9Cr 3  rr rr        
003D9Er 3  3D                   .byte "="
003D9Fr 3               
003D9Fr 3               nt_two_slash:
003D9Fr 3  02 10                .byte 2, UF
003DA1r 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
003DA5r 3  rr rr        
003DA7r 3  32 2F                .byte "2/"
003DA9r 3               
003DA9r 3               nt_two_star:
003DA9r 3  02 10                .byte 2, UF
003DABr 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
003DAFr 3  rr rr        
003DB1r 3  32 2A                .byte "2*"
003DB3r 3               
003DB3r 3               nt_one_plus:
003DB3r 3  02 10                .byte 2, UF
003DB5r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
003DB9r 3  rr rr        
003DBBr 3  31 2B                .byte "1+"
003DBDr 3               
003DBDr 3               nt_one_minus:
003DBDr 3  02 10                .byte 2, UF
003DBFr 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
003DC3r 3  rr rr        
003DC5r 3  31 2D                .byte "1-"
003DC7r 3               
003DC7r 3               nt_here:
003DC7r 3  04 00                .byte 4, 0
003DC9r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
003DCDr 3  rr rr        
003DCFr 3  68 65 72 65          .byte "here"
003DD3r 3               
003DD3r 3               nt_cell_plus:
003DD3r 3  05 10                .byte 5, UF
003DD5r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
003DD9r 3  rr rr        
003DDBr 3  63 65 6C 6C          .byte "cell+"
003DDFr 3  2B           
003DE0r 3               
003DE0r 3               nt_cells:
003DE0r 3  05 00                .byte 5, 0
003DE2r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
003DE6r 3  rr rr        
003DE8r 3  63 65 6C 6C          .byte "cells"
003DECr 3  73           
003DEDr 3               
003DEDr 3               nt_chars:
003DEDr 3  05 12                .byte 5, AN+UF   ; deleted during compile
003DEFr 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
003DF3r 3  rr rr        
003DF5r 3  63 68 61 72          .byte "chars"
003DF9r 3  73           
003DFAr 3               
003DFAr 3               nt_char_plus:
003DFAr 3  05 00                .byte 5, 0
003DFCr 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
003E00r 3  rr rr        
003E02r 3  63 68 61 72          .byte "char+"
003E06r 3  2B           
003E07r 3               
003E07r 3               nt_bracket_char:
003E07r 3  06 05                .byte 6, CO+IM
003E09r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
003E0Dr 3  rr rr        
003E0Fr 3  5B 63 68 61          .byte "[char]"
003E13r 3  72 5D        
003E15r 3               
003E15r 3               nt_char:
003E15r 3  04 00                .byte 4, 0
003E17r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
003E1Br 3  rr rr        
003E1Dr 3  63 68 61 72          .byte "char"
003E21r 3               
003E21r 3               nt_pick:
003E21r 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
003E23r 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
003E27r 3  rr rr        
003E29r 3  70 69 63 6B          .byte "pick"
003E2Dr 3               
003E2Dr 3               nt_lshift:
003E2Dr 3  06 10                .byte 6, UF
003E2Fr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
003E33r 3  rr rr        
003E35r 3  6C 73 68 69          .byte "lshift"
003E39r 3  66 74        
003E3Br 3               
003E3Br 3               nt_rshift:
003E3Br 3  06 10                .byte 6, UF
003E3Dr 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
003E41r 3  rr rr        
003E43r 3  72 73 68 69          .byte "rshift"
003E47r 3  66 74        
003E49r 3               
003E49r 3               nt_xor:
003E49r 3  03 10                .byte 3, UF
003E4Br 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
003E4Fr 3  rr rr        
003E51r 3  78 6F 72             .byte "xor"
003E54r 3               
003E54r 3               nt_or:
003E54r 3  02 10                .byte 2, UF
003E56r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
003E5Ar 3  rr rr        
003E5Cr 3  6F 72                .byte "or"
003E5Er 3               
003E5Er 3               nt_and:
003E5Er 3  03 10                .byte 3, UF
003E60r 3  rr rr rr rr          .word nt_or, xt_and, z_and
003E64r 3  rr rr        
003E66r 3  61 6E 64             .byte "and"
003E69r 3               
003E69r 3               nt_dabs:
003E69r 3  04 10                .byte 4, UF
003E6Br 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
003E6Fr 3  rr rr        
003E71r 3  64 61 62 73          .byte "dabs"
003E75r 3               
003E75r 3               nt_abs:
003E75r 3  03 10                .byte 3, UF
003E77r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
003E7Br 3  rr rr        
003E7Dr 3  61 62 73             .byte "abs"
003E80r 3               
003E80r 3               nt_minus:
003E80r 3  01 10                .byte 1, UF
003E82r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
003E86r 3  rr rr        
003E88r 3  2D                   .byte "-"
003E89r 3               
003E89r 3               nt_plus:
003E89r 3  01 10                .byte 1, UF
003E8Br 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
003E8Fr 3  rr rr        
003E91r 3  2B                   .byte "+"
003E92r 3               
003E92r 3               nt_question_dup:
003E92r 3  04 10                .byte 4, UF
003E94r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
003E98r 3  rr rr        
003E9Ar 3  3F 64 75 70          .byte "?dup"
003E9Er 3               
003E9Er 3               nt_two_dup:
003E9Er 3  04 10                .byte 4, UF
003EA0r 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
003EA4r 3  rr rr        
003EA6r 3  32 64 75 70          .byte "2dup"
003EAAr 3               
003EAAr 3               nt_two:
003EAAr 3  01 00                .byte 1, 0
003EACr 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
003EB0r 3  rr rr        
003EB2r 3  32                   .byte "2"
003EB3r 3               
003EB3r 3               nt_one:
003EB3r 3  01 00                .byte 1, 0
003EB5r 3  rr rr rr rr          .word nt_two, xt_one, z_one
003EB9r 3  rr rr        
003EBBr 3  31                   .byte "1"
003EBCr 3               
003EBCr 3               nt_zero:
003EBCr 3  01 00                .byte 1, 0
003EBEr 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
003EC2r 3  rr rr        
003EC4r 3  30                   .byte "0"
003EC5r 3               
003EC5r 3               nt_space:
003EC5r 3  05 00                .byte 5, 0
003EC7r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
003ECBr 3  rr rr        
003ECDr 3  73 70 61 63          .byte "space"
003ED1r 3  65           
003ED2r 3               
003ED2r 3               nt_true:
003ED2r 3  04 00                .byte 4, 0
003ED4r 3  rr rr rr rr          .word nt_space, xt_true, z_true
003ED8r 3  rr rr        
003EDAr 3  74 72 75 65          .byte "true"
003EDEr 3               
003EDEr 3               nt_false:
003EDEr 3  05 00                .byte 5, 0
003EE0r 3  rr rr rr rr          .word nt_true, xt_false, z_false
003EE4r 3  rr rr        
003EE6r 3  66 61 6C 73          .byte "false"
003EEAr 3  65           
003EEBr 3               
003EEBr 3               nt_question:
003EEBr 3  01 00                .byte 1, 0
003EEDr 3  rr rr rr rr          .word nt_false, xt_question, z_question
003EF1r 3  rr rr        
003EF3r 3  3F                   .byte "?"
003EF4r 3               
003EF4r 3               nt_ud_dot_r:
003EF4r 3  04 10                .byte 4, UF
003EF6r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
003EFAr 3  rr rr        
003EFCr 3  75 64 2E 72          .byte "ud.r"
003F00r 3               
003F00r 3               nt_ud_dot:
003F00r 3  03 10                .byte 3, UF
003F02r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
003F06r 3  rr rr        
003F08r 3  75 64 2E             .byte "ud."
003F0Br 3               
003F0Br 3               nt_d_dot_r:
003F0Br 3  03 10                .byte 3, UF
003F0Dr 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
003F11r 3  rr rr        
003F13r 3  64 2E 72             .byte "d.r"
003F16r 3               
003F16r 3               nt_d_dot:
003F16r 3  02 10                .byte 2, UF
003F18r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
003F1Cr 3  rr rr        
003F1Er 3  64 2E                .byte "d."
003F20r 3               
003F20r 3               nt_dot_r:
003F20r 3  02 10                .byte 2, UF
003F22r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
003F26r 3  rr rr        
003F28r 3  2E 72                .byte ".r"
003F2Ar 3               
003F2Ar 3               nt_u_dot_r:
003F2Ar 3  03 10                .byte 3, UF
003F2Cr 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
003F30r 3  rr rr        
003F32r 3  75 2E 72             .byte "u.r"
003F35r 3               
003F35r 3               nt_u_dot:
003F35r 3  02 10                .byte 2, UF
003F37r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
003F3Br 3  rr rr        
003F3Dr 3  75 2E                .byte "u."
003F3Fr 3               
003F3Fr 3               nt_dot:
003F3Fr 3  01 10                .byte 1, UF
003F41r 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
003F45r 3  rr rr        
003F47r 3  2E                   .byte "."
003F48r 3               
003F48r 3               nt_type:
003F48r 3  04 10                .byte 4, UF
003F4Ar 3  rr rr rr rr          .word nt_dot, xt_type, z_type
003F4Er 3  rr rr        
003F50r 3  74 79 70 65          .byte "type"
003F54r 3               
003F54r 3               nt_emit:
003F54r 3  04 18                .byte 4, NN+UF
003F56r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
003F5Ar 3  rr rr        
003F5Cr 3  65 6D 69 74          .byte "emit"
003F60r 3               
003F60r 3               nt_execute:
003F60r 3  07 10                .byte 7, UF
003F62r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
003F66r 3  rr rr        
003F68r 3  65 78 65 63          .byte "execute"
003F6Cr 3  75 74 65     
003F6Fr 3               
003F6Fr 3               nt_plus_store:
003F6Fr 3  02 10                .byte 2, UF
003F71r 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
003F75r 3  rr rr        
003F77r 3  2B 21                .byte "+!"
003F79r 3               
003F79r 3               nt_c_store:
003F79r 3  02 10                .byte 2, UF
003F7Br 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
003F7Fr 3  rr rr        
003F81r 3  63 21                .byte "c!"
003F83r 3               
003F83r 3               nt_c_fetch:
003F83r 3  02 10                .byte 2, UF
003F85r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
003F89r 3  rr rr        
003F8Br 3  63 40                .byte "c@"
003F8Dr 3               
003F8Dr 3               nt_comma:
003F8Dr 3  01 10                .byte 1, UF
003F8Fr 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
003F93r 3  rr rr        
003F95r 3  2C                   .byte ","
003F96r 3               
003F96r 3               nt_tuck:
003F96r 3  04 10                .byte 4, UF
003F98r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
003F9Cr 3  rr rr        
003F9Er 3  74 75 63 6B          .byte "tuck"
003FA2r 3               
003FA2r 3               nt_not_rote:
003FA2r 3  04 10                .byte 4, UF
003FA4r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
003FA8r 3  rr rr        
003FAAr 3  2D 72 6F 74          .byte "-rot"
003FAEr 3               
003FAEr 3               nt_rot:
003FAEr 3  03 10                .byte 3, UF
003FB0r 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
003FB4r 3  rr rr        
003FB6r 3  72 6F 74             .byte "rot"
003FB9r 3               
003FB9r 3               nt_nip:
003FB9r 3  03 10                .byte 3, UF
003FBBr 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
003FBFr 3  rr rr        
003FC1r 3  6E 69 70             .byte "nip"
003FC4r 3               
003FC4r 3               nt_r_fetch:
003FC4r 3  02 01                .byte 2, CO    ; native is special case
003FC6r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
003FCAr 3  rr rr        
003FCCr 3  72 40                .byte "r@"
003FCEr 3               
003FCEr 3               nt_r_from:
003FCEr 3  02 01                .byte 2, CO    ; native is special case
003FD0r 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
003FD4r 3  rr rr        
003FD6r 3  72 3E                .byte "r>"
003FD8r 3               
003FD8r 3               nt_to_r:
003FD8r 3  02 11                .byte 2, CO+UF ; native is special case
003FDAr 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
003FDEr 3  rr rr        
003FE0r 3  3E 72                .byte ">r"
003FE2r 3               
003FE2r 3               nt_over:
003FE2r 3  04 10                .byte 4, UF
003FE4r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
003FE8r 3  rr rr        
003FEAr 3  6F 76 65 72          .byte "over"
003FEEr 3               
003FEEr 3               nt_fetch:
003FEEr 3  01 10                .byte 1, UF
003FF0r 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
003FF4r 3  rr rr        
003FF6r 3  40                   .byte "@"
003FF7r 3               
003FF7r 3               nt_store:
003FF7r 3  01 10                .byte 1, UF
003FF9r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
003FFDr 3  rr rr        
003FFFr 3  21                   .byte "!"
004000r 3               
004000r 3               nt_swap:
004000r 3  04 10                .byte 4, UF
004002r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
004006r 3  rr rr        
004008r 3  73 77 61 70          .byte "swap"
00400Cr 3               
00400Cr 3               nt_dup:
00400Cr 3  03 10                .byte 3, UF
00400Er 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
004012r 3  rr rr        
004014r 3  64 75 70             .byte "dup"
004017r 3               
004017r 3               ; DROP is always the first native word in the Dictionary
004017r 3               dictionary_start:
004017r 3               nt_drop:
004017r 3  04 10                .byte 4, UF
004019r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
00401Dr 3  rr rr        
00401Fr 3  64 72 6F 70          .byte "drop"
004023r 3               
004023r 3               ; END of FORTH-WORDLIST
004023r 3               
004023r 3               
004023r 3               ; ROOT-WORDLIST
004023r 3                       ; This is a short wordlist that has just the words needed to
004023r 3                       ; set the wordlists. These words are also included in the
004023r 3                       ; FORTH-WORDLIST as well.
004023r 3               
004023r 3               nt_root_words:
004023r 3  05 00                .byte 5, 0
004025r 3  00 00 rr rr          .word 0000, xt_words, z_words
004029r 3  rr rr        
00402Br 3  77 6F 72 64          .byte "words"
00402Fr 3  73           
004030r 3               
004030r 3               nt_root_forth_wordlist: ; shares code with ZERO
004030r 3  0E 00                .byte 14, 0
004032r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
004036r 3  rr rr        
004038r 3  66 6F 72 74          .byte "forth-wordlist"
00403Cr 3  68 2D 77 6F  
004040r 3  72 64 6C 69  
004046r 3               
004046r 3               nt_root_forth:
004046r 3  05 00                .byte 5, 0
004048r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
00404Cr 3  rr rr        
00404Er 3  66 6F 72 74          .byte "forth"
004052r 3  68           
004053r 3               
004053r 3               root_dictionary_start:
004053r 3               nt_root_set_order:
004053r 3  09 00                .byte 9, 0
004055r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
004059r 3  rr rr        
00405Br 3  73 65 74 2D          .byte "set-order"
00405Fr 3  6F 72 64 65  
004063r 3  72           
004064r 3               
004064r 3               ; END of ROOT-WORDLIST
004064r 3               
004064r 3               
004064r 3               ; ; EDITOR-WORDLIST
004064r 3               
004064r 3               ; nt_editor_enter_screen:
004064r 3               ;         .byte 12, 0
004064r 3               ;         .word 0000, xt_editor_enter_screen, z_editor_enter_screen
004064r 3               ;         .byte "enter-screen"
004064r 3               
004064r 3               ; nt_editor_erase_screen:
004064r 3               ;         .byte 12, 0
004064r 3               ;         .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
004064r 3               ;         .byte "erase-screen"
004064r 3               
004064r 3               ; nt_editor_el:
004064r 3               ;         .byte 2, 0
004064r 3               ;         .word nt_editor_erase_screen, xt_editor_el, z_editor_el
004064r 3               ;         .byte "el"
004064r 3               
004064r 3               ; nt_editor_l:
004064r 3               ;         .byte 1, 0
004064r 3               ;         .word nt_editor_el, xt_editor_l, z_editor_l
004064r 3               ;         .byte "l"
004064r 3               
004064r 3               ; nt_editor_line:
004064r 3               ;         .byte 4, UF
004064r 3               ;         .word nt_editor_l, xt_editor_line, z_editor_line
004064r 3               ;         .byte "line"
004064r 3               
004064r 3               editor_dictionary_start:
004064r 3               ; nt_editor_o:
004064r 3               ;         .byte 1, 0
004064r 3               ;         .word nt_editor_line, xt_editor_o, z_editor_o
004064r 3               ;         .byte "o"
004064r 3               
004064r 3               ; ; END of EDITOR-WORDLIST
004064r 3               
004064r 3               
004064r 3               ; ; ASSEMBLER-WORDLIST
004064r 3               
004064r 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
004064r 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
004064r 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
004064r 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
004064r 3               assembler_dictionary_start:
004064r 3               ; nt_asm_adc_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_adc_x
004064r 3               ; 		.word xt_asm_adc_h, z_asm_adc_h
004064r 3               ; 		.byte "adc.#"
004064r 3               
004064r 3               ; nt_asm_adc_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_adc_y
004064r 3               ; 		.word xt_asm_adc_x, z_asm_adc_x
004064r 3               ; 		.byte "adc.x"
004064r 3               
004064r 3               ; nt_asm_adc_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_adc_z
004064r 3               ; 		.word xt_asm_adc_y, z_asm_adc_y
004064r 3               ; 		.byte "adc.y"
004064r 3               
004064r 3               ; nt_asm_adc_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_adc_zi
004064r 3               ; 		.word xt_asm_adc_z, z_asm_adc_z
004064r 3               ; 		.byte "adc.z"
004064r 3               
004064r 3               ; nt_asm_adc_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_adc_ziy
004064r 3               ; 		.word xt_asm_adc_zi, z_asm_adc_zi
004064r 3               ; 		.byte "adc.zi"
004064r 3               
004064r 3               ; nt_asm_adc_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_adc_zx
004064r 3               ; 		.word xt_asm_adc_ziy, z_asm_adc_ziy
004064r 3               ; 		.byte "adc.ziy"
004064r 3               
004064r 3               ; nt_asm_adc_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_adc_zxi
004064r 3               ; 		.word xt_asm_adc_zx, z_asm_adc_zx
004064r 3               ; 		.byte "adc.zx"
004064r 3               
004064r 3               ; nt_asm_adc_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_and
004064r 3               ; 		.word xt_asm_adc_zxi, z_asm_adc_zxi
004064r 3               ; 		.byte "adc.zxi"
004064r 3               
004064r 3               ; nt_asm_and:     ; not "and" because of conflicts with Forth word
004064r 3               ; 		.byte 4, IM
004064r 3               ;                 .word nt_asm_and_h
004064r 3               ; 		.word xt_asm_and, z_asm_and
004064r 3               ; 		.byte "and."
004064r 3               
004064r 3               ; nt_asm_and_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_and_x
004064r 3               ; 		.word xt_asm_and_h, z_asm_and_h
004064r 3               ; 		.byte "and.#"
004064r 3               
004064r 3               ; nt_asm_and_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_and_y
004064r 3               ; 		.word xt_asm_and_x, z_asm_and_x
004064r 3               ; 		.byte "and.x"
004064r 3               
004064r 3               ; nt_asm_and_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_and_z
004064r 3               ; 		.word xt_asm_and_y, z_asm_and_y
004064r 3               ; 		.byte "and.y"
004064r 3               
004064r 3               ; nt_asm_and_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_and_zi
004064r 3               ; 		.word xt_asm_and_z, z_asm_and_z
004064r 3               ; 		.byte "and.z"
004064r 3               
004064r 3               ; nt_asm_and_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_and_ziy
004064r 3               ; 		.word xt_asm_and_zi, z_asm_and_zi
004064r 3               ; 		.byte "and.zi"
004064r 3               
004064r 3               ; nt_asm_and_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_and_zx
004064r 3               ; 		.word xt_asm_and_ziy, z_asm_and_ziy
004064r 3               ; 		.byte "and.ziy"
004064r 3               
004064r 3               ; nt_asm_and_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_and_zxi
004064r 3               ; 		.word xt_asm_and_zx, z_asm_and_zx
004064r 3               ; 		.byte "and.zx"
004064r 3               
004064r 3               ; nt_asm_and_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_asl
004064r 3               ; 		.word xt_asm_and_zxi, z_asm_and_zxi
004064r 3               ; 		.byte "and.zxi"
004064r 3               
004064r 3               ; nt_asm_asl:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_asl_a
004064r 3               ; 		.word xt_asm_asl, z_asm_asl
004064r 3               ; 		.byte "asl"
004064r 3               
004064r 3               ; nt_asm_asl_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_asl_x
004064r 3               ; 		.word xt_asm_asl_a, z_asm_asl_a
004064r 3               ; 		.byte "asl.a"
004064r 3               
004064r 3               ; nt_asm_asl_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_asl_z
004064r 3               ; 		.word xt_asm_asl_x, z_asm_asl_x
004064r 3               ; 		.byte "asl.x"
004064r 3               
004064r 3               ; nt_asm_asl_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_asl_zx
004064r 3               ; 		.word xt_asm_asl_z, z_asm_asl_z
004064r 3               ; 		.byte "asl.z"
004064r 3               
004064r 3               ; nt_asm_asl_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_bcc
004064r 3               ; 		.word xt_asm_asl_zx, z_asm_asl_zx
004064r 3               ; 		.byte "asl.zx"
004064r 3               
004064r 3               ; nt_asm_bcc:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bcs
004064r 3               ; 		.word xt_asm_bcc, z_asm_bcc
004064r 3               ; 		.byte "bcc"
004064r 3               
004064r 3               ; nt_asm_bcs:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_beq
004064r 3               ; 		.word xt_asm_bcs, z_asm_bcs
004064r 3               ; 		.byte "bcs"
004064r 3               
004064r 3               ; nt_asm_beq:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bit
004064r 3               ; 		.word xt_asm_beq, z_asm_beq
004064r 3               ; 		.byte "beq"
004064r 3               
004064r 3               ; nt_asm_bit:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bit_h
004064r 3               ; 		.word xt_asm_bit, z_asm_bit
004064r 3               ; 		.byte "bit"
004064r 3               
004064r 3               ; nt_asm_bit_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_bit_x
004064r 3               ; 		.word xt_asm_bit_h, z_asm_bit_h
004064r 3               ; 		.byte "bit.#"
004064r 3               
004064r 3               ; nt_asm_bit_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_bit_z
004064r 3               ; 		.word xt_asm_bit_x, z_asm_bit_x
004064r 3               ; 		.byte "bit.x"
004064r 3               
004064r 3               ; nt_asm_bit_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_bit_zx
004064r 3               ; 		.word xt_asm_bit_z, z_asm_bit_z
004064r 3               ; 		.byte "bit.z"
004064r 3               
004064r 3               ; nt_asm_bit_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_bmi
004064r 3               ; 		.word xt_asm_bit_zx, z_asm_bit_zx
004064r 3               ; 		.byte "bit.zx"
004064r 3               
004064r 3               ; nt_asm_bmi:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bne
004064r 3               ; 		.word xt_asm_bmi, z_asm_bmi
004064r 3               ; 		.byte "bmi"
004064r 3               
004064r 3               ; nt_asm_bne:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bpl
004064r 3               ; 		.word xt_asm_bne, z_asm_bne
004064r 3               ; 		.byte "bne"
004064r 3               
004064r 3               ; nt_asm_bpl:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bra
004064r 3               ; 		.word xt_asm_bpl, z_asm_bpl
004064r 3               ; 		.byte "bpl"
004064r 3               
004064r 3               ; nt_asm_bra:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_brk
004064r 3               ; 		.word xt_asm_bra, z_asm_bra
004064r 3               ; 		.byte "bra"
004064r 3               
004064r 3               ; nt_asm_brk:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bvc
004064r 3               ; 		.word xt_asm_brk, z_asm_brk
004064r 3               ; 		.byte "brk"
004064r 3               
004064r 3               ; nt_asm_bvc:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_bvs
004064r 3               ; 		.word xt_asm_bvc, z_asm_bvc
004064r 3               ; 		.byte "bvc"
004064r 3               
004064r 3               ; nt_asm_bvs:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_clc
004064r 3               ; 		.word xt_asm_bvs, z_asm_bvs
004064r 3               ; 		.byte "bvs"
004064r 3               
004064r 3               ; nt_asm_clc:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cld
004064r 3               ; 		.word xt_asm_clc, z_asm_clc
004064r 3               ; 		.byte "clc"
004064r 3               
004064r 3               ; nt_asm_cld:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cli
004064r 3               ; 		.word xt_asm_cld, z_asm_cld
004064r 3               ; 		.byte "cld"
004064r 3               
004064r 3               ; nt_asm_cli:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_clv
004064r 3               ; 		.word xt_asm_cli, z_asm_cli
004064r 3               ; 		.byte "cli"
004064r 3               
004064r 3               ; nt_asm_clv:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cmp
004064r 3               ; 		.word xt_asm_clv, z_asm_clv
004064r 3               ; 		.byte "clv"
004064r 3               
004064r 3               ; nt_asm_cmp:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cmp_h
004064r 3               ; 		.word xt_asm_cmp, z_asm_cmp
004064r 3               ; 		.byte "cmp"
004064r 3               
004064r 3               ; nt_asm_cmp_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cmp_x
004064r 3               ; 		.word xt_asm_cmp_h, z_asm_cmp_h
004064r 3               ; 		.byte "cmp.#"
004064r 3               
004064r 3               ; nt_asm_cmp_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cmp_y
004064r 3               ; 		.word xt_asm_cmp_x, z_asm_cmp_x
004064r 3               ; 		.byte "cmp.x"
004064r 3               
004064r 3               ; nt_asm_cmp_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cmp_z
004064r 3               ; 		.word xt_asm_cmp_y, z_asm_cmp_y
004064r 3               ; 		.byte "cmp.y"
004064r 3               
004064r 3               ; nt_asm_cmp_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cmp_zi
004064r 3               ; 		.word xt_asm_cmp_z, z_asm_cmp_z
004064r 3               ; 		.byte "cmp.z"
004064r 3               
004064r 3               ; nt_asm_cmp_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_cmp_ziy
004064r 3               ; 		.word xt_asm_cmp_zi, z_asm_cmp_zi
004064r 3               ; 		.byte "cmp.zi"
004064r 3               
004064r 3               ; nt_asm_cmp_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_cmp_zx
004064r 3               ; 		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
004064r 3               ; 		.byte "cmp.ziy"
004064r 3               
004064r 3               ; nt_asm_cmp_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_cmp_zxi
004064r 3               ; 		.word xt_asm_cmp_zx, z_asm_cmp_zx
004064r 3               ; 		.byte "cmp.zx"
004064r 3               
004064r 3               ; nt_asm_cmp_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_cpx
004064r 3               ; 		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
004064r 3               ; 		.byte "cmp.zxi"
004064r 3               
004064r 3               ; nt_asm_cpx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cpx_h
004064r 3               ; 		.word xt_asm_cpx, z_asm_cpx
004064r 3               ; 		.byte "cpx"
004064r 3               
004064r 3               ; nt_asm_cpx_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cpx_z
004064r 3               ; 		.word xt_asm_cpx_h, z_asm_cpx_h
004064r 3               ; 		.byte "cpx.#"
004064r 3               
004064r 3               ; nt_asm_cpx_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cpy
004064r 3               ; 		.word xt_asm_cpx_z, z_asm_cpx_z
004064r 3               ; 		.byte "cpx.z"
004064r 3               
004064r 3               ; nt_asm_cpy:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_cpy_h
004064r 3               ; 		.word xt_asm_cpy, z_asm_cpy
004064r 3               ; 		.byte "cpy"
004064r 3               
004064r 3               ; nt_asm_cpy_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_cpy_z
004064r 3               ; 		.word xt_asm_cpy_h, z_asm_cpy_h
004064r 3               ; 		.byte "cpy.#"
004064r 3               
004064r 3               ; nt_asm_cpy_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_dec
004064r 3               ; 		.word xt_asm_cpy_z, z_asm_cpy_z
004064r 3               ; 		.byte "cpy.z"
004064r 3               
004064r 3               ; nt_asm_dec:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_dec_a
004064r 3               ; 		.word xt_asm_dec, z_asm_dec
004064r 3               ; 		.byte "dec"
004064r 3               
004064r 3               ; nt_asm_dec_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_dec_x
004064r 3               ; 		.word xt_asm_dec_a, z_asm_dec_a
004064r 3               ; 		.byte "dec.a"
004064r 3               
004064r 3               ; nt_asm_dec_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_dec_z
004064r 3               ; 		.word xt_asm_dec_x, z_asm_dec_x
004064r 3               ; 		.byte "dec.x"
004064r 3               
004064r 3               ; nt_asm_dec_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_dec_zx
004064r 3               ; 		.word xt_asm_dec_z, z_asm_dec_z
004064r 3               ; 		.byte "dec.z"
004064r 3               
004064r 3               ; nt_asm_dec_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_dex
004064r 3               ; 		.word xt_asm_dec_zx, z_asm_dec_zx
004064r 3               ; 		.byte "dec.zx"
004064r 3               
004064r 3               ; nt_asm_dex:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_dey
004064r 3               ; 		.word xt_asm_dex, z_asm_dex
004064r 3               ; 		.byte "dex"
004064r 3               
004064r 3               ; nt_asm_dey:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_eor
004064r 3               ; 		.word xt_asm_dey, z_asm_dey
004064r 3               ; 		.byte "dey"
004064r 3               
004064r 3               ; nt_asm_eor:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_eor_h
004064r 3               ; 		.word xt_asm_eor, z_asm_eor
004064r 3               ; 		.byte "eor"
004064r 3               
004064r 3               ; nt_asm_eor_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_eor_x
004064r 3               ; 		.word xt_asm_eor_h, z_asm_eor_h
004064r 3               ; 		.byte "eor.#"
004064r 3               
004064r 3               ; nt_asm_eor_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_eor_y
004064r 3               ; 		.word xt_asm_eor_x, z_asm_eor_x
004064r 3               ; 		.byte "eor.x"
004064r 3               
004064r 3               ; nt_asm_eor_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_eor_z
004064r 3               ; 		.word xt_asm_eor_y, z_asm_eor_y
004064r 3               ; 		.byte "eor.y"
004064r 3               
004064r 3               ; nt_asm_eor_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_eor_zi
004064r 3               ; 		.word xt_asm_eor_z, z_asm_eor_z
004064r 3               ; 		.byte "eor.z"
004064r 3               
004064r 3               ; nt_asm_eor_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_eor_ziy
004064r 3               ; 		.word xt_asm_eor_zi, z_asm_eor_zi
004064r 3               ; 		.byte "eor.zi"
004064r 3               
004064r 3               ; nt_asm_eor_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_eor_zx
004064r 3               ; 		.word xt_asm_eor_ziy, z_asm_eor_ziy
004064r 3               ; 		.byte "eor.ziy"
004064r 3               
004064r 3               ; nt_asm_eor_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_eor_zxi
004064r 3               ; 		.word xt_asm_eor_zx, z_asm_eor_zx
004064r 3               ; 		.byte "eor.zx"
004064r 3               
004064r 3               ; nt_asm_eor_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_inc
004064r 3               ; 		.word xt_asm_eor_zxi, z_asm_eor_zxi
004064r 3               ; 		.byte "eor.zxi"
004064r 3               
004064r 3               ; nt_asm_inc:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_inc_a
004064r 3               ; 		.word xt_asm_inc, z_asm_inc
004064r 3               ; 		.byte "inc"
004064r 3               
004064r 3               ; nt_asm_inc_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_inc_x
004064r 3               ; 		.word xt_asm_inc_a, z_asm_inc_a
004064r 3               ; 		.byte "inc.a"
004064r 3               
004064r 3               ; nt_asm_inc_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_inc_z
004064r 3               ; 		.word xt_asm_inc_x, z_asm_inc_x
004064r 3               ; 		.byte "inc.x"
004064r 3               
004064r 3               ; nt_asm_inc_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_inc_zx
004064r 3               ; 		.word xt_asm_inc_z, z_asm_inc_z
004064r 3               ; 		.byte "inc.z"
004064r 3               
004064r 3               ; nt_asm_inc_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_inx
004064r 3               ; 		.word xt_asm_inc_zx, z_asm_inc_zx
004064r 3               ; 		.byte "inc.zx"
004064r 3               
004064r 3               ; nt_asm_inx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_iny
004064r 3               ; 		.word xt_asm_inx, z_asm_inx
004064r 3               ; 		.byte "inx"
004064r 3               
004064r 3               ; nt_asm_iny:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_jmp
004064r 3               ; 		.word xt_asm_iny, z_asm_iny
004064r 3               ; 		.byte "iny"
004064r 3               
004064r 3               ; nt_asm_jmp:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_jmp_i
004064r 3               ; 		.word xt_asm_jmp, z_asm_jmp
004064r 3               ; 		.byte "jmp"
004064r 3               
004064r 3               ; nt_asm_jmp_i:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_jmp_xi
004064r 3               ; 		.word xt_asm_jmp_i, z_asm_jmp_i
004064r 3               ; 		.byte "jmp.i"
004064r 3               
004064r 3               ; nt_asm_jmp_xi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_jsr
004064r 3               ; 		.word xt_asm_jmp_xi, z_asm_jmp_xi
004064r 3               ; 		.byte "jmp.xi"
004064r 3               
004064r 3               ; nt_asm_jsr:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_lda
004064r 3               ; 		.word xt_asm_jsr, z_asm_jsr
004064r 3               ; 		.byte "jsr"
004064r 3               
004064r 3               ; nt_asm_lda:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_lda_h
004064r 3               ; 		.word xt_asm_lda, z_asm_lda
004064r 3               ; 		.byte "lda"
004064r 3               
004064r 3               ; nt_asm_lda_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lda_x
004064r 3               ; 		.word xt_asm_lda_h, z_asm_lda_h
004064r 3               ; 		.byte "lda.#"
004064r 3               
004064r 3               ; nt_asm_lda_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lda_y
004064r 3               ; 		.word xt_asm_lda_x, z_asm_lda_x
004064r 3               ; 		.byte "lda.x"
004064r 3               
004064r 3               ; nt_asm_lda_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lda_z
004064r 3               ; 		.word xt_asm_lda_y, z_asm_lda_y
004064r 3               ; 		.byte "lda.y"
004064r 3               
004064r 3               ; nt_asm_lda_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lda_zi
004064r 3               ; 		.word xt_asm_lda_z, z_asm_lda_z
004064r 3               ; 		.byte "lda.z"
004064r 3               
004064r 3               ; nt_asm_lda_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_lda_ziy
004064r 3               ; 		.word xt_asm_lda_zi, z_asm_lda_zi
004064r 3               ; 		.byte "lda.zi"
004064r 3               
004064r 3               ; nt_asm_lda_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_lda_zx
004064r 3               ; 		.word xt_asm_lda_ziy, z_asm_lda_ziy
004064r 3               ; 		.byte "lda.ziy"
004064r 3               
004064r 3               ; nt_asm_lda_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_lda_zxi
004064r 3               ; 		.word xt_asm_lda_zx, z_asm_lda_zx
004064r 3               ; 		.byte "lda.zx"
004064r 3               
004064r 3               ; nt_asm_lda_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_ldx
004064r 3               ; 		.word xt_asm_lda_zxi, z_asm_lda_zxi
004064r 3               ; 		.byte "lda.zxi"
004064r 3               
004064r 3               ; nt_asm_ldx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ldx_h
004064r 3               ; 		.word xt_asm_ldx, z_asm_ldx
004064r 3               ; 		.byte "ldx"
004064r 3               
004064r 3               ; nt_asm_ldx_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldx_y
004064r 3               ; 		.word xt_asm_ldx_h, z_asm_ldx_h
004064r 3               ; 		.byte "ldx.#"
004064r 3               
004064r 3               ; nt_asm_ldx_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldx_z
004064r 3               ; 		.word xt_asm_ldx_y, z_asm_ldx_y
004064r 3               ; 		.byte "ldx.y"
004064r 3               
004064r 3               ; nt_asm_ldx_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldx_zy
004064r 3               ; 		.word xt_asm_ldx_z, z_asm_ldx_z
004064r 3               ; 		.byte "ldx.z"
004064r 3               
004064r 3               ; nt_asm_ldx_zy:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_ldy
004064r 3               ; 		.word xt_asm_ldx_zy, z_asm_ldx_zy
004064r 3               ; 		.byte "ldx.zy"
004064r 3               
004064r 3               ; nt_asm_ldy:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ldy_h
004064r 3               ; 		.word xt_asm_ldy, z_asm_ldy
004064r 3               ; 		.byte "ldy"
004064r 3               
004064r 3               ; nt_asm_ldy_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldy_x
004064r 3               ; 		.word xt_asm_ldy_h, z_asm_ldy_h
004064r 3               ; 		.byte "ldy.#"
004064r 3               
004064r 3               ; nt_asm_ldy_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldy_z
004064r 3               ; 		.word xt_asm_ldy_x, z_asm_ldy_x
004064r 3               ; 		.byte "ldy.x"
004064r 3               
004064r 3               ; nt_asm_ldy_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ldy_zx
004064r 3               ; 		.word xt_asm_ldy_z, z_asm_ldy_z
004064r 3               ; 		.byte "ldy.z"
004064r 3               
004064r 3               ; nt_asm_ldy_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_lsr
004064r 3               ; 		.word xt_asm_ldy_zx, z_asm_ldy_zx
004064r 3               ; 		.byte "ldy.zx"
004064r 3               
004064r 3               ; nt_asm_lsr:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_lsr_a
004064r 3               ; 		.word xt_asm_lsr, z_asm_lsr
004064r 3               ; 		.byte "lsr"
004064r 3               
004064r 3               ; nt_asm_lsr_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lsr_x
004064r 3               ; 		.word xt_asm_lsr_a, z_asm_lsr_a
004064r 3               ; 		.byte "lsr.a"
004064r 3               
004064r 3               ; nt_asm_lsr_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lsr_z
004064r 3               ; 		.word xt_asm_lsr_x, z_asm_lsr_x
004064r 3               ; 		.byte "lsr.x"
004064r 3               
004064r 3               ; nt_asm_lsr_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_lsr_zx
004064r 3               ; 		.word xt_asm_lsr_z, z_asm_lsr_z
004064r 3               ; 		.byte "lsr.z"
004064r 3               
004064r 3               ; nt_asm_lsr_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_nop
004064r 3               ; 		.word xt_asm_lsr_zx, z_asm_lsr_zx
004064r 3               ; 		.byte "lsr.zx"
004064r 3               
004064r 3               ; nt_asm_nop:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ora
004064r 3               ; 		.word xt_asm_nop, z_asm_nop
004064r 3               ; 		.byte "nop"
004064r 3               
004064r 3               ; nt_asm_ora:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ora_h
004064r 3               ; 		.word xt_asm_ora, z_asm_ora
004064r 3               ; 		.byte "ora"
004064r 3               
004064r 3               ; nt_asm_ora_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ora_x
004064r 3               ; 		.word xt_asm_ora_h, z_asm_ora_h
004064r 3               ; 		.byte "ora.#"
004064r 3               
004064r 3               ; nt_asm_ora_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ora_y
004064r 3               ; 		.word xt_asm_ora_x, z_asm_ora_x
004064r 3               ; 		.byte "ora.x"
004064r 3               
004064r 3               ; nt_asm_ora_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ora_z
004064r 3               ; 		.word xt_asm_ora_y, z_asm_ora_y
004064r 3               ; 		.byte "ora.y"
004064r 3               
004064r 3               ; nt_asm_ora_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ora_zi
004064r 3               ; 		.word xt_asm_ora_z, z_asm_ora_z
004064r 3               ; 		.byte "ora.z"
004064r 3               
004064r 3               ; nt_asm_ora_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_ora_ziy
004064r 3               ; 		.word xt_asm_ora_zi, z_asm_ora_zi
004064r 3               ; 		.byte "ora.zi"
004064r 3               
004064r 3               ; nt_asm_ora_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_ora_zx
004064r 3               ; 		.word xt_asm_ora_ziy, z_asm_ora_ziy
004064r 3               ; 		.byte "ora.ziy"
004064r 3               
004064r 3               ; nt_asm_ora_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_ora_zxi
004064r 3               ; 		.word xt_asm_ora_zx, z_asm_ora_zx
004064r 3               ; 		.byte "ora.zx"
004064r 3               
004064r 3               ; nt_asm_ora_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_pha
004064r 3               ; 		.word xt_asm_ora_zxi, z_asm_ora_zxi
004064r 3               ; 		.byte "ora.zxi"
004064r 3               
004064r 3               ; nt_asm_pha:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_php
004064r 3               ; 		.word xt_asm_pha, z_asm_pha
004064r 3               ; 		.byte "pha"
004064r 3               
004064r 3               ; nt_asm_php:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_phx
004064r 3               ; 		.word xt_asm_php, z_asm_php
004064r 3               ; 		.byte "php"
004064r 3               
004064r 3               ; nt_asm_phx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_phy
004064r 3               ; 		.word xt_asm_phx, z_asm_phx
004064r 3               ; 		.byte "phx"
004064r 3               
004064r 3               ; nt_asm_phy:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_pla
004064r 3               ; 		.word xt_asm_phy, z_asm_phy
004064r 3               ; 		.byte "phy"
004064r 3               
004064r 3               ; nt_asm_pla:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_plp
004064r 3               ; 		.word xt_asm_pla, z_asm_pla
004064r 3               ; 		.byte "pla"
004064r 3               
004064r 3               ; nt_asm_plp:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_plx
004064r 3               ; 		.word xt_asm_plp, z_asm_plp
004064r 3               ; 		.byte "plp"
004064r 3               
004064r 3               ; nt_asm_plx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ply
004064r 3               ; 		.word xt_asm_plx, z_asm_plx
004064r 3               ; 		.byte "plx"
004064r 3               
004064r 3               ; nt_asm_ply:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_rol
004064r 3               ; 		.word xt_asm_ply, z_asm_ply
004064r 3               ; 		.byte "ply"
004064r 3               
004064r 3               ; nt_asm_rol:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_rol_a
004064r 3               ; 		.word xt_asm_rol, z_asm_rol
004064r 3               ; 		.byte "rol"
004064r 3               
004064r 3               ; nt_asm_rol_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_rol_x
004064r 3               ; 		.word xt_asm_rol_a, z_asm_rol_a
004064r 3               ; 		.byte "rol.a"
004064r 3               
004064r 3               ; nt_asm_rol_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_rol_z
004064r 3               ; 		.word xt_asm_rol_x, z_asm_rol_x
004064r 3               ; 		.byte "rol.x"
004064r 3               
004064r 3               ; nt_asm_rol_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_rol_zx
004064r 3               ; 		.word xt_asm_rol_z, z_asm_rol_z
004064r 3               ; 		.byte "rol.z"
004064r 3               
004064r 3               ; nt_asm_rol_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_ror
004064r 3               ; 		.word xt_asm_rol_zx, z_asm_rol_zx
004064r 3               ; 		.byte "rol.zx"
004064r 3               
004064r 3               ; nt_asm_ror:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_ror_a
004064r 3               ; 		.word xt_asm_ror, z_asm_ror
004064r 3               ; 		.byte "ror"
004064r 3               
004064r 3               ; nt_asm_ror_a:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ror_x
004064r 3               ; 		.word xt_asm_ror_a, z_asm_ror_a
004064r 3               ; 		.byte "ror.a"
004064r 3               
004064r 3               ; nt_asm_ror_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ror_z
004064r 3               ; 		.word xt_asm_ror_x, z_asm_ror_x
004064r 3               ; 		.byte "ror.x"
004064r 3               
004064r 3               ; nt_asm_ror_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_ror_zx
004064r 3               ; 		.word xt_asm_ror_z, z_asm_ror_z
004064r 3               ; 		.byte "ror.z"
004064r 3               
004064r 3               ; nt_asm_ror_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_rti
004064r 3               ; 		.word xt_asm_ror_zx, z_asm_ror_zx
004064r 3               ; 		.byte "ror.zx"
004064r 3               
004064r 3               ; nt_asm_rti:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_rts
004064r 3               ; 		.word xt_asm_rti, z_asm_rti
004064r 3               ; 		.byte "rti"
004064r 3               
004064r 3               ; nt_asm_rts:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sbc
004064r 3               ; 		.word xt_asm_rts, z_asm_rts
004064r 3               ; 		.byte "rts"
004064r 3               
004064r 3               ; nt_asm_sbc:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sbc_h
004064r 3               ; 		.word xt_asm_sbc, z_asm_sbc
004064r 3               ; 		.byte "sbc"
004064r 3               
004064r 3               ; nt_asm_sbc_h:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sbc_x
004064r 3               ; 		.word xt_asm_sbc_h, z_asm_sbc_h
004064r 3               ; 		.byte "sbc.#"
004064r 3               
004064r 3               ; nt_asm_sbc_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sbc_y
004064r 3               ; 		.word xt_asm_sbc_x, z_asm_sbc_x
004064r 3               ; 		.byte "sbc.x"
004064r 3               
004064r 3               ; nt_asm_sbc_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sbc_z
004064r 3               ; 		.word xt_asm_sbc_y, z_asm_sbc_y
004064r 3               ; 		.byte "sbc.y"
004064r 3               
004064r 3               ; nt_asm_sbc_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sbc_zi
004064r 3               ; 		.word xt_asm_sbc_z, z_asm_sbc_z
004064r 3               ; 		.byte "sbc.z"
004064r 3               
004064r 3               ; nt_asm_sbc_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_sbc_ziy
004064r 3               ; 		.word xt_asm_sbc_zi, z_asm_sbc_zi
004064r 3               ; 		.byte "sbc.zi"
004064r 3               
004064r 3               ; nt_asm_sbc_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_sbc_zx
004064r 3               ; 		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
004064r 3               ; 		.byte "sbc.ziy"
004064r 3               
004064r 3               ; nt_asm_sbc_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_sbc_zxi
004064r 3               ; 		.word xt_asm_sbc_zx, z_asm_sbc_zx
004064r 3               ; 		.byte "sbc.zx"
004064r 3               
004064r 3               ; nt_asm_sbc_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_sec
004064r 3               ; 		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
004064r 3               ; 		.byte "sbc.zxi"
004064r 3               
004064r 3               ; nt_asm_sec:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sed
004064r 3               ; 		.word xt_asm_sec, z_asm_sec
004064r 3               ; 		.byte "sec"
004064r 3               
004064r 3               ; nt_asm_sed:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sei
004064r 3               ; 		.word xt_asm_sed, z_asm_sed
004064r 3               ; 		.byte "sed"
004064r 3               
004064r 3               ; nt_asm_sei:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sta
004064r 3               ; 		.word xt_asm_sei, z_asm_sei
004064r 3               ; 		.byte "sei"
004064r 3               
004064r 3               ; nt_asm_sta:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sta_x
004064r 3               ; 		.word xt_asm_sta, z_asm_sta
004064r 3               ; 		.byte "sta"
004064r 3               
004064r 3               ; nt_asm_sta_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sta_y
004064r 3               ; 		.word xt_asm_sta_x, z_asm_sta_x
004064r 3               ; 		.byte "sta.x"
004064r 3               
004064r 3               ; nt_asm_sta_y:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sta_z
004064r 3               ; 		.word xt_asm_sta_y, z_asm_sta_y
004064r 3               ; 		.byte "sta.y"
004064r 3               
004064r 3               ; nt_asm_sta_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sta_zi
004064r 3               ; 		.word xt_asm_sta_z, z_asm_sta_z
004064r 3               ; 		.byte "sta.z"
004064r 3               
004064r 3               ; nt_asm_sta_zi:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_sta_ziy
004064r 3               ; 		.word xt_asm_sta_zi, z_asm_sta_zi
004064r 3               ; 		.byte "sta.zi"
004064r 3               
004064r 3               ; nt_asm_sta_ziy:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_sta_zx
004064r 3               ; 		.word xt_asm_sta_ziy, z_asm_sta_ziy
004064r 3               ; 		.byte "sta.ziy"
004064r 3               
004064r 3               ; nt_asm_sta_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_sta_zxi
004064r 3               ; 		.word xt_asm_sta_zx, z_asm_sta_zx
004064r 3               ; 		.byte "sta.zx"
004064r 3               
004064r 3               ; nt_asm_sta_zxi:
004064r 3               ; 		.byte 7, IM
004064r 3               ;                 .word nt_asm_stx
004064r 3               ; 		.word xt_asm_sta_zxi, z_asm_sta_zxi
004064r 3               ; 		.byte "sta.zxi"
004064r 3               
004064r 3               ; nt_asm_stx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_stx_z
004064r 3               ; 		.word xt_asm_stx, z_asm_stx
004064r 3               ; 		.byte "stx"
004064r 3               
004064r 3               ; nt_asm_stx_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_stx_zy
004064r 3               ; 		.word xt_asm_stx_z, z_asm_stx_z
004064r 3               ; 		.byte "stx.z"
004064r 3               
004064r 3               ; nt_asm_stx_zy:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_sty
004064r 3               ; 		.word xt_asm_stx_zy, z_asm_stx_zy
004064r 3               ; 		.byte "stx.zy"
004064r 3               
004064r 3               ; nt_asm_sty:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_sty_z
004064r 3               ; 		.word xt_asm_sty, z_asm_sty
004064r 3               ; 		.byte "sty"
004064r 3               
004064r 3               ; nt_asm_sty_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_sty_zx
004064r 3               ; 		.word xt_asm_sty_z, z_asm_sty_z
004064r 3               ; 		.byte "sty.z"
004064r 3               
004064r 3               ; nt_asm_sty_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_stz
004064r 3               ; 		.word xt_asm_sty_zx, z_asm_sty_zx
004064r 3               ; 		.byte "sty.zx"
004064r 3               
004064r 3               ; nt_asm_stz:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_stz_x
004064r 3               ; 		.word xt_asm_stz, z_asm_stz
004064r 3               ; 		.byte "stz"
004064r 3               
004064r 3               ; nt_asm_stz_x:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_stz_z
004064r 3               ; 		.word xt_asm_stz_x, z_asm_stz_x
004064r 3               ; 		.byte "stz.x"
004064r 3               
004064r 3               ; nt_asm_stz_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_stz_zx
004064r 3               ; 		.word xt_asm_stz_z, z_asm_stz_z
004064r 3               ; 		.byte "stz.z"
004064r 3               
004064r 3               ; nt_asm_stz_zx:
004064r 3               ; 		.byte 6, IM
004064r 3               ;                 .word nt_asm_tax
004064r 3               ; 		.word xt_asm_stz_zx, z_asm_stz_zx
004064r 3               ; 		.byte "stz.zx"
004064r 3               
004064r 3               ; nt_asm_tax:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_tay
004064r 3               ; 		.word xt_asm_tax, z_asm_tax
004064r 3               ; 		.byte "tax"
004064r 3               
004064r 3               ; nt_asm_tay:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_trb
004064r 3               ; 		.word xt_asm_tay, z_asm_tay
004064r 3               ; 		.byte "tay"
004064r 3               
004064r 3               ; nt_asm_trb:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_trb_z
004064r 3               ; 		.word xt_asm_trb, z_asm_trb
004064r 3               ; 		.byte "trb"
004064r 3               
004064r 3               ; nt_asm_trb_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_tsb
004064r 3               ; 		.word xt_asm_trb_z, z_asm_trb_z
004064r 3               ; 		.byte "trb.z"
004064r 3               
004064r 3               ; nt_asm_tsb:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_tsb_z
004064r 3               ; 		.word xt_asm_tsb, z_asm_tsb
004064r 3               ; 		.byte "tsb"
004064r 3               
004064r 3               ; nt_asm_tsb_z:
004064r 3               ; 		.byte 5, IM
004064r 3               ;                 .word nt_asm_tsx
004064r 3               ; 		.word xt_asm_tsb_z, z_asm_tsb_z
004064r 3               ; 		.byte "tsb.z"
004064r 3               
004064r 3               ; nt_asm_tsx:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_txa
004064r 3               ; 		.word xt_asm_tsx, z_asm_tsx
004064r 3               ; 		.byte "tsx"
004064r 3               
004064r 3               ; nt_asm_txa:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_txs
004064r 3               ; 		.word xt_asm_txa, z_asm_txa
004064r 3               ; 		.byte "txa"
004064r 3               
004064r 3               ; nt_asm_txs:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_tya
004064r 3               ; 		.word xt_asm_txs, z_asm_txs
004064r 3               ; 		.byte "txs"
004064r 3               
004064r 3               ; nt_asm_tya:
004064r 3               ; 		.byte 3, IM
004064r 3               ;                 .word nt_asm_arrow
004064r 3               ; 		.word xt_asm_tya, z_asm_tya
004064r 3               ; 		.byte "tya"
004064r 3               
004064r 3               ; ; Assembler pseudo-instructions, directives and macros
004064r 3               
004064r 3               ; nt_asm_arrow:   ; uses same code as HERE, but immediate
004064r 3               ;                 .byte 3, IM
004064r 3               ;                 .word nt_asm_back_jump
004064r 3               ;                 .word xt_asm_arrow, z_asm_arrow
004064r 3               ;                 .byte "-->"
004064r 3               
004064r 3               
004064r 3               ; nt_asm_back_jump:  ; syntactic sugar, does nothing
004064r 3               ;                 .byte 2, IM
004064r 3               ;                 .word nt_asm_back_branch
004064r 3               ;                 .word xt_asm_back_jump, z_asm_back_jump
004064r 3               ;                 .byte "<j"
004064r 3               
004064r 3               ; nt_asm_back_branch:
004064r 3               ;                 .byte 2, IM
004064r 3               ;                 .word nt_asm_push_a
004064r 3               ;                 .word xt_asm_back_branch, z_asm_back_branch
004064r 3               ;                 .byte "<b"
004064r 3               
004064r 3               ; nt_asm_push_a:
004064r 3               ;                 .byte 6, IM
004064r 3               ;                 .word 0000
004064r 3               ;                 .word xt_asm_push_a, z_asm_push_a
004064r 3               ;                 .byte "push-a"
004064r 3               
004064r 3               
004064r 3               
004064r 3               ; END of ASSEMBLER-WORDLIST
004064r 3               
004064r 3               ; END
004064r 3               
004064r 2                   .include "strings.s"          ; Headers of native words
004064r 3               ; List of Strings for Tali Forth 2
004064r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004064r 3               ; First version: 01. Apr 2016 (for Liara Forth)
004064r 3               ; This version: 28. Dec 2018
004064r 3               
004064r 3               ; This file is included by taliforth.asm
004064r 3               
004064r 3               ; ## GENERAL STRINGS
004064r 3               
004064r 3               ; All general strings must be zero-terminated, names start with "s_",
004064r 3               ; aliases with "str_"
004064r 3               
004064r 3               str_ok =              0
004064r 3               str_compile =         1
004064r 3               str_redefined =       2
004064r 3               str_wid_forth =       3
004064r 3               str_abc_lower =       4
004064r 3               str_abc_upper =       5
004064r 3               str_wid_editor =      6
004064r 3               str_wid_assembler =   7
004064r 3               str_wid_root =        8
004064r 3               str_see_flags =       9
004064r 3               str_see_nt =         10
004064r 3               str_see_xt =         11
004064r 3               str_see_size =       12
004064r 3               
004064r 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
004064r 3               ; to tables as error and string numbers.
004064r 3               string_table:
004064r 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
004068r 3  rr rr rr rr  
00406Cr 3  rr rr        
00406Er 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
004072r 3  rr rr rr rr  
004076r 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
00407Ar 3  rr rr rr rr  
00407Er 3               
00407Er 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
004082r 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
004086r 3  70 69 6C 65  
00408Ar 3  64 00        
00408Cr 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
004090r 3  66 69 6E 65  
004094r 3  64 20 00     
004097r 3               
004097r 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
00409Br 3  34 35 36 37  
00409Fr 3  38 39 61 62  
0040BBr 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
0040BFr 3  34 35 36 37  
0040C3r 3  38 39 41 42  
0040DFr 3               
0040DFr 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
0040E3r 3  6D 62 6C 65  
0040E7r 3  72 20 00     
0040EAr 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
0040EEr 3  6F 72 20 00  
0040F2r 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
0040F6r 3  68 20 00     
0040F9r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
0040FDr 3  20 00        
0040FFr 3               
0040FFr 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
004103r 3  73 20 28 43  
004107r 3  4F 20 41 4E  
00411Br 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
00411Fr 3  00           
004120r 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
004124r 3  00           
004125r 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
004129r 3  20 28 64 65  
00412Dr 3  63 69 6D 61  
004136r 3               
004136r 3               
004136r 3               ; ## ERROR STRINGS
004136r 3               
004136r 3               ; All error strings must be zero-terminated, all names start with "es_",
004136r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
004136r 3               ; as well
004136r 3               
004136r 3               err_allot =        0
004136r 3               err_badsource =    1
004136r 3               err_compileonly =  2
004136r 3               err_defer =        3
004136r 3               err_divzero =      4
004136r 3               err_noname =       5
004136r 3               err_refill =       6
004136r 3               err_state =        7
004136r 3               err_syntax =       8
004136r 3               err_underflow =    9
004136r 3               err_negallot =     10
004136r 3               err_wordlist =     11
004136r 3               err_blockwords =   12
004136r 3               
004136r 3               error_table:
004136r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
00413Ar 3  rr rr rr rr  
00413Er 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
004142r 3  rr rr rr rr  
004146r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
00414Ar 3  rr rr rr rr  
00414Er 3  rr rr                .word es_blockwords                                    ; 12
004150r 3               
004150r 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
004154r 3  54 20 75 73  
004158r 3  69 6E 67 20  
004171r 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
004175r 3  67 61 6C 20  
004179r 3  53 4F 55 52  
004191r 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
004195r 3  72 70 72 65  
004199r 3  74 69 6E 67  
0041B2r 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
0041B6r 3  52 65 64 20  
0041BAr 3  77 6F 72 64  
0041CFr 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
0041D3r 3  73 69 6F 6E  
0041D7r 3  20 62 79 20  
0041E0r 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
0041E4r 3  69 6E 67 20  
0041E8r 3  66 61 69 6C  
0041F0r 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
0041F4r 3  20 63 6F 75  
0041F8r 3  6C 64 20 6E  
00421Er 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
004222r 3  61 64 79 20  
004226r 3  69 6E 20 63  
004236r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
00423Ar 3  66 69 6E 65  
00423Er 3  64 20 77 6F  
004245r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
004249r 3  6B 20 75 6E  
00424Dr 3  64 65 72 66  
004255r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
004259r 3  6D 65 6D 6F  
00425Dr 3  72 79 20 66  
004271r 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
004275r 3  6F 72 64 6C  
004279r 3  69 73 74 73  
004288r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
00428Cr 3  73 65 20 61  
004290r 3  73 73 69 67  
0042C7r 3               
0042C7r 3               ; ## ENVIRONMENT STRINGS
0042C7r 3               
0042C7r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
0042C7r 3               ; Length byte first, then the string itself that is not rpt. not
0042C7r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
0042C7r 3               ; "envs_".
0042C7r 3               
0042C7r 3               ; These return a single-cell number
0042C7r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
0042CBr 3  55 4E 54 45  
0042CFr 3  44 2D 53 54  
0042D7r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
0042DBr 3  4C 44        
0042DDr 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
0042E1r 3  44           
0042E2r 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
0042E6r 3  52 45 53 53  
0042EAr 3  2D 55 4E 49  
0042F4r 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
0042F8r 3  4F 52 45 44  
0042FCr 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
004300r 3  2D 43 48 41  
004304r 3  52           
004305r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
004309r 3  2D 4E        
00430Br 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
00430Fr 3  2D 55        
004311r 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
004315r 3  55 52 4E 2D  
004319r 3  53 54 41 43  
004324r 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
004328r 3  43 4B 2D 43  
00432Cr 3  45 4C 4C 53  
004330r 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
004334r 3  44 4C 49 53  
004338r 3  54 53        
00433Ar 3               
00433Ar 3               ; These return a double-cell number
00433Ar 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
00433Er 3  2D 44        
004340r 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
004344r 3  2D 55 44     
004347r 3               
004347r 3               ; END
004347r 3               
004347r 2               
004347r 2               ; High-level Forth words, see forth_code/README.md
004347r 2               forth_words_start:
004347r 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
00434Br 2  2E 28 20 52  
00434Fr 2  65 61 64 79  
004359r 2               forth_words_end:
004359r 2               
004359r 2               ; User-defined Forth words, see forth_code/README.md
004359r 2               user_words_start:
004359r 2  20 32 30 20  .incbin "forth_code/user_words.asc"
00435Dr 2  63 6F 6E 73  
004361r 2  74 61 6E 74  
004A05r 2               user_words_end:
004A05r 2               
004A05r 2               
004A05r 2               ; =====================================================================
004A05r 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
004A05r 2               
004A05r 2               ; These three routines compile instructions such as "jsr xt_words" into a word
004A05r 2               ; at compile time so they are available at run time. Words that use this
004A05r 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
004A05r 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
004A05r 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
004A05r 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
004A05r 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
004A05r 2               ; Bowie.
004A05r 2               
004A05r 2               ;               ldy #>addr      ; MSB   ; "Young"
004A05r 2               ;               lda #<addr      ; LSB   ; "Americans"
004A05r 2               ;               jsr cmpl_subroutine
004A05r 2               
004A05r 2               ; Also, we keep a routine here to compile a single byte passed through A.
004A05r 2               
004A05r 2               cmpl_subroutine:
004A05r 2                   ; This is the entry point to compile JSR <ADDR>
004A05r 2  48               pha             ; save LSB of address
004A06r 2  A9 20            lda #$20        ; load opcode for JSR
004A08r 2  80 03            bra cmpl_common
004A0Ar 2               cmpl_jump:
004A0Ar 2                   ; This is the entry point to compile JMP <ADDR>
004A0Ar 2  48               pha             ; save LSB of address
004A0Br 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
004A0Dr 2               cmpl_common:
004A0Dr 2                   ; At this point, A contains the opcode to be compiled,
004A0Dr 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
004A0Dr 2                   ; the address is in Y
004A0Dr 2  20 rr rr         jsr cmpl_a      ; compile opcode
004A10r 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
004A11r 2               cmpl_word:
004A11r 2                   ; This is the entry point to compile a word (little-endian)
004A11r 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
004A14r 2  98               tya             ; fall thru for MSB
004A15r 2               cmpl_a:
004A15r 2                   ; This is the entry point to compile a single byte which
004A15r 2                   ; is passed in A. The built-in assembler assumes that this
004A15r 2                   ; routine does not modify Y.
004A15r 2  92 rr            sta (cp)
004A17r 2  E6 rr            inc cp
004A19r 2  D0 02            bne _done
004A1Br 2  E6 rr            inc cp+1
004A1Dr 2               _done:
004A1Dr 2  60               rts
004A1Er 2               
004A1Er 2               
004A1Er 2               
004A1Er 2               ; =====================================================================
004A1Er 2               ; CODE FIELD ROUTINES
004A1Er 2               
004A1Er 2               doconst:
004A1Er 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
004A1Er 2               ; the Data Field onto the Data Stack
004A1Er 2               ; """
004A1Er 2  CA               dex             ; make room for constant
004A1Fr 2  CA               dex
004A20r 2               
004A20r 2                   ; The value we need is stored in the two bytes after the
004A20r 2                   ; JSR return address, which in turn is what is on top of
004A20r 2                   ; the Return Stack
004A20r 2  68               pla             ; LSB of return address
004A21r 2  85 rr            sta tmp1
004A23r 2  68               pla             ; MSB of return address
004A24r 2  85 rr            sta tmp1+1
004A26r 2               
004A26r 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
004A26r 2                   ; the return address on the 65c02
004A26r 2  A0 01            ldy #1
004A28r 2  B1 rr            lda (tmp1),y
004A2Ar 2  95 00            sta 0,x
004A2Cr 2  C8               iny
004A2Dr 2  B1 rr            lda (tmp1),y
004A2Fr 2  95 01            sta 1,x
004A31r 2               
004A31r 2                   ; This takes us back to the original caller, not the
004A31r 2                   ; DOCONST caller
004A31r 2  60               rts
004A32r 2               
004A32r 2               
004A32r 2               dodefer:
004A32r 2               ; """Execute a DEFER statement at runtime: Execute the address we
004A32r 2               ; find after the caller in the Data Field
004A32r 2               ; """
004A32r 2                   ; The xt we need is stored in the two bytes after the JSR
004A32r 2                   ; return address, which is what is on top of the Return
004A32r 2                   ; Stack. So all we have to do is replace our return jump
004A32r 2                   ; with what we find there
004A32r 2  68               pla             ; LSB
004A33r 2  85 rr            sta tmp1
004A35r 2  68               pla             ; MSB
004A36r 2  85 rr            sta tmp1+1
004A38r 2               
004A38r 2  A0 01            ldy #1
004A3Ar 2  B1 rr            lda (tmp1),y
004A3Cr 2  85 rr            sta tmp2
004A3Er 2  C8               iny
004A3Fr 2  B1 rr            lda (tmp1),y
004A41r 2  85 rr            sta tmp2+1
004A43r 2               
004A43r 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004A46r 2               
004A46r 2               defer_error:
004A46r 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004A46r 2  A9 03            lda #err_defer
004A48r 2  4C rr rr         jmp error
004A4Br 2               
004A4Br 2               dodoes:
004A4Br 2               ; """Execute the runtime portion of DOES>. See DOES> and
004A4Br 2               ; docs/create-does.txt for details and
004A4Br 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004A4Br 2               ; """
004A4Br 2                   ; Assumes the address of the CFA of the original defining word
004A4Br 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004A4Br 2                   ; for a later jump, adding one byte because of the way the
004A4Br 2                   ; 6502 works
004A4Br 2  7A               ply             ; LSB
004A4Cr 2  68               pla             ; MSB
004A4Dr 2  C8               iny
004A4Er 2  D0 01            bne @1
004A50r 2  1A               inc
004A51r 2               @1:
004A51r 2  84 rr            sty tmp2
004A53r 2  85 rr            sta tmp2+1
004A55r 2               
004A55r 2                   ; Next on the Return Stack should be the address of the PFA of
004A55r 2                   ; the calling defined word (say, the name of whatever constant we
004A55r 2                   ; just defined). Move this to the Data Stack, again adding one.
004A55r 2  CA               dex
004A56r 2  CA               dex
004A57r 2               
004A57r 2  7A               ply
004A58r 2  68               pla
004A59r 2  C8               iny
004A5Ar 2  D0 01            bne @2
004A5Cr 2  1A               inc
004A5Dr 2               @2:
004A5Dr 2  94 00            sty 0,x         ; LSB
004A5Fr 2  95 01            sta 1,x         ; MSB
004A61r 2               
004A61r 2                   ; This leaves the return address from the original main routine
004A61r 2                   ; on top of the Return Stack. We leave that untouched and jump
004A61r 2                   ; to the special code of the defining word. It's RTS instruction
004A61r 2                   ; will take us back to the main routine
004A61r 2  6C rr rr         jmp (tmp2)
004A64r 2               
004A64r 2               
004A64r 2               dovar:
004A64r 2               ; """Execute a variable: Push the address of the first bytes of
004A64r 2               ; the Data Field onto the stack. This is called with JSR so we
004A64r 2               ; can pick up the address of the calling variable off the 65c02's
004A64r 2               ; stack. The final RTS takes us to the original caller of the
004A64r 2               ; routine that itself called DOVAR. This is the default
004A64r 2               ; routine installed with CREATE.
004A64r 2               ; """
004A64r 2                   ; Pull the return address off the machine's stack, adding
004A64r 2                   ; one because of the way the 65c02 handles subroutines
004A64r 2  7A               ply             ; LSB
004A65r 2  68               pla             ; MSB
004A66r 2  C8               iny
004A67r 2  D0 01            bne @1
004A69r 2  1A               inc
004A6Ar 2               @1:
004A6Ar 2  CA               dex
004A6Br 2  CA               dex
004A6Cr 2               
004A6Cr 2  95 01            sta 1,x
004A6Er 2  98               tya
004A6Fr 2  95 00            sta 0,x
004A71r 2               
004A71r 2  60               rts
004A72r 2               
004A72r 2               ; =====================================================================
004A72r 2               ; LOW LEVEL HELPER FUNCTIONS
004A72r 2               
004A72r 2               byte_to_ascii:
004A72r 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
004A72r 2               .scope
004A72r 2  48               pha
004A73r 2  4A               lsr             ; convert high nibble first
004A74r 2  4A               lsr
004A75r 2  4A               lsr
004A76r 2  4A               lsr
004A77r 2  20 rr rr         jsr _nibble_to_ascii
004A7Ar 2  68               pla
004A7Br 2               
004A7Br 2                   ; fall through to _nibble_to_ascii
004A7Br 2               
004A7Br 2               _nibble_to_ascii:
004A7Br 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004A7Br 2               ; of A and and EMIT it. This does the actual work.
004A7Br 2               ; """
004A7Br 2  29 0F            and #$0F
004A7Dr 2  09 30            ora #'0'
004A7Fr 2  C9 3A            cmp #$3A        ; '9+1
004A81r 2  90 02            bcc @1
004A83r 2  69 06            adc #$06
004A85r 2               
004A85r 2  4C rr rr     @1:               jmp emit_a
004A88r 2               
004A88r 2  60               rts
004A89r 2               .endscope
004A89r 2               
004A89r 2               compare_16bit:
004A89r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004A89r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004A89r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004A89r 2               ; For signed numbers, Z signals equality and N which number is larger:
004A89r 2               ;       if TOS = NOS: Z=1 and N=0
004A89r 2               ;       if TOS > NOS: Z=0 and N=0
004A89r 2               ;       if TOS < NOS: Z=0 and N=1
004A89r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004A89r 2               ;       if TOS = NOS: Z=1 and N=0
004A89r 2               ;       if TOS > NOS: Z=0 and C=1
004A89r 2               ;       if TOS < NOS: Z=0 and C=0
004A89r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004A89r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004A89r 2               ; """
004A89r 2               .scope
004A89r 2                   ; Compare LSB first to set the carry flag
004A89r 2  B5 00            lda 0,x                 ; LSB of TOS
004A8Br 2  D5 02            cmp 2,x                 ; LSB of NOS
004A8Dr 2  F0 0A            beq _equal
004A8Fr 2               
004A8Fr 2                   ; LSBs are not equal, compare MSB
004A8Fr 2  B5 01            lda 1,x                 ; MSB of TOS
004A91r 2  F5 03            sbc 3,x                 ; MSB of NOS
004A93r 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004A95r 2  70 08            bvs _overflow
004A97r 2  80 08            bra _not_equal
004A99r 2               _equal:
004A99r 2                   ; Low bytes are equal, so we compare high bytes
004A99r 2  B5 01            lda 1,x                 ; MSB of TOS
004A9Br 2  F5 03            sbc 3,x                 ; MSB of NOS
004A9Dr 2  50 04            bvc _done
004A9Fr 2               _overflow:
004A9Fr 2                   ; Handle overflow because we use signed numbers
004A9Fr 2  49 80            eor #$80                ; complement negative flag
004AA1r 2               _not_equal:
004AA1r 2  09 01            ora #1                  ; if overflow, we can't be eqal
004AA3r 2               _done:
004AA3r 2  60               rts
004AA4r 2               .endscope
004AA4r 2               
004AA4r 2               current_to_dp:
004AA4r 2               ; """Look up the current (compilation) dictionary pointer
004AA4r 2               ; in the wordlist set and put it into the dp zero-page
004AA4r 2               ; variable. Uses A and Y.
004AA4r 2               ; """
004AA4r 2                   ; Determine which wordlist is current
004AA4r 2  A0 04            ldy #current_offset
004AA6r 2  B1 rr            lda (up),y      ; current is a byte variable
004AA8r 2  0A               asl             ; turn it into an offset (in cells)
004AA9r 2               
004AA9r 2                   ; Get the dictionary pointer for that wordlist.
004AA9r 2  18               clc
004AAAr 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004AACr 2  A8               tay
004AADr 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
004AAFr 2  85 rr            sta dp
004AB1r 2  C8               iny
004AB2r 2  B1 rr            lda (up),y
004AB4r 2  85 rr            sta dp+1
004AB6r 2               
004AB6r 2  60               rts
004AB7r 2               
004AB7r 2               
004AB7r 2               dp_to_current:
004AB7r 2               ; """Look up which wordlist is current and update its pointer
004AB7r 2               ; with the value in dp. Uses A and Y.
004AB7r 2               ; """
004AB7r 2                   ; Determine which wordlist is current
004AB7r 2  A0 04            ldy #current_offset
004AB9r 2  B1 rr            lda (up),y      ; current is a byte variable
004ABBr 2  0A               asl             ; turn it into an offset (in cells)
004ABCr 2               
004ABCr 2                   ; Get the dictionary pointer for that wordlist.
004ABCr 2  18               clc
004ABDr 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004ABFr 2  A8               tay
004AC0r 2  A5 rr            lda dp
004AC2r 2  91 rr            sta (up),y              ; get the dp for that wordlist.
004AC4r 2  C8               iny
004AC5r 2  A5 rr            lda dp+1
004AC7r 2  91 rr            sta (up),y
004AC9r 2               
004AC9r 2  60               rts
004ACAr 2               
004ACAr 2               interpret:
004ACAr 2               .scope
004ACAr 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
004ACAr 2               ; Process one line only. Assumes that the address of name is in
004ACAr 2               ; cib and the length of the whole input line string is in ciblen
004ACAr 2               ; """
004ACAr 2                   ; Normally we would use PARSE here with the SPACE character as
004ACAr 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
004ACAr 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
004ACAr 2                   ; delimiters per default and skips any leading spaces, which
004ACAr 2                   ; PARSE doesn't
004ACAr 2               _loop:
004ACAr 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
004ACDr 2               
004ACDr 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
004ACDr 2                   ; in the line and we need to go get a new line
004ACDr 2  B5 00            lda 0,x
004ACFr 2  15 01            ora 1,x
004AD1r 2  F0 70            beq _line_done
004AD3r 2               
004AD3r 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
004AD3r 2                   ; make a copy of the address in case it isn't a word we know and
004AD3r 2                   ; we have to go see if it is a number
004AD3r 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
004AD6r 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
004AD9r 2               
004AD9r 2                   ; A zero signals that we didn't find a word in the Dictionary
004AD9r 2  B5 00            lda 0,x
004ADBr 2  15 01            ora 1,x
004ADDr 2  D0 28            bne _got_name_token
004ADFr 2               
004ADFr 2                   ; We didn't get any nt we know of, so let's see if this is
004ADFr 2                   ; a number.
004ADFr 2  E8               inx                     ; ( addr u 0 -- addr u )
004AE0r 2  E8               inx
004AE1r 2               
004AE1r 2                   ; If the number conversion doesn't work, NUMBER will do the
004AE1r 2                   ; complaining for us
004AE1r 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
004AE4r 2               
004AE4r 2                   ; Otherweise, if we're interpreting, we're done
004AE4r 2  A5 rr            lda state
004AE6r 2  F0 E2            beq _loop
004AE8r 2               
004AE8r 2                   ; We're compiling, so there is a bit more work.  Check
004AE8r 2                   ; status bit 5 to see if it's a single or double-cell
004AE8r 2                   ; number.
004AE8r 2  A9 20            lda #$20
004AEAr 2  24 rr            bit status
004AECr 2  F0 0D            beq _single_number
004AEEr 2               
004AEEr 2                   ; It's a double cell number.  If we swap the
004AEEr 2                   ; upper and lower half, we can use the literal_runtime twice
004AEEr 2                   ; to compile it into the dictionary.
004AEEr 2  20 rr rr         jsr xt_swap
004AF1r 2  A0 rr            ldy #>literal_runtime
004AF3r 2  A9 rr            lda #<literal_runtime
004AF5r 2  20 rr rr         jsr cmpl_subroutine
004AF8r 2               
004AF8r 2                   ; compile our number
004AF8r 2  20 rr rr         jsr xt_comma
004AFBr 2               
004AFBr 2                   ; Fall into _single_number to process the other half.
004AFBr 2               _single_number:
004AFBr 2  A0 rr            ldy #>literal_runtime
004AFDr 2  A9 rr            lda #<literal_runtime
004AFFr 2  20 rr rr         jsr cmpl_subroutine
004B02r 2               
004B02r 2                   ; compile our number
004B02r 2  20 rr rr         jsr xt_comma
004B05r 2               
004B05r 2                   ; That was so much fun, let's do it again!
004B05r 2  80 C3            bra _loop
004B07r 2               
004B07r 2               _got_name_token:
004B07r 2                   ; We have a known word's nt TOS. We're going to need its xt
004B07r 2                   ; though, which is four bytes father down.
004B07r 2               
004B07r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
004B07r 2  B5 00            lda 0,x
004B09r 2  95 04            sta 4,x
004B0Br 2  B5 01            lda 1,x
004B0Dr 2  95 05            sta 5,x
004B0Fr 2               
004B0Fr 2  E8               inx
004B10r 2  E8               inx
004B11r 2  E8               inx
004B12r 2  E8               inx                     ; ( nt )
004B13r 2               
004B13r 2                   ; Save a version of nt for error handling and compilation stuff
004B13r 2  B5 00            lda 0,x
004B15r 2  85 rr            sta tmpbranch
004B17r 2  B5 01            lda 1,x
004B19r 2  85 rr            sta tmpbranch+1
004B1Br 2               
004B1Br 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
004B1Er 2               
004B1Er 2                   ; See if we are in interpret or compile mode, 0 is interpret
004B1Er 2  A5 rr            lda state
004B20r 2  D0 13            bne _compile
004B22r 2               
004B22r 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
004B22r 2                   ; though, see if this isn't a compile-only word, which would be
004B22r 2                   ; illegal. The status byte is the second one of the header.
004B22r 2  A0 01            ldy #1
004B24r 2  B1 rr            lda (tmpbranch),y
004B26r 2  29 01            and #CO                 ; mask everything but Compile Only bit
004B28r 2  F0 05            beq _interpret
004B2Ar 2               
004B2Ar 2  A9 02            lda #err_compileonly
004B2Cr 2  4C rr rr         jmp error
004B2Fr 2               
004B2Fr 2               _interpret:
004B2Fr 2                   ; We JSR to EXECUTE instead of calling the xt directly because
004B2Fr 2                   ; the RTS of the word we're executing will bring us back here,
004B2Fr 2                   ; skipping EXECUTE completely during RTS. If we were to execute
004B2Fr 2                   ; xt directly, we have to fool around with the Return Stack
004B2Fr 2                   ; instead, which is actually slightly slower
004B2Fr 2  20 rr rr         jsr xt_execute
004B32r 2               
004B32r 2                   ; That's quite enough for this word, let's get the next one
004B32r 2  4C rr rr         jmp _loop
004B35r 2               
004B35r 2               _compile:
004B35r 2                   ; We're compiling! However, we need to see if this is an
004B35r 2                   ; IMMEDIATE word, which would mean we execute it right now even
004B35r 2                   ; during compilation mode. Fortunately, we saved the nt so life
004B35r 2                   ; is easier. The flags are in the second byte of the header
004B35r 2  A0 01            ldy #1
004B37r 2  B1 rr            lda (tmpbranch),y
004B39r 2  29 04            and #IM                 ; Mask all but IM bit
004B3Br 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
004B3Dr 2               
004B3Dr 2                   ; Compile the xt into the Dictionary with COMPILE,
004B3Dr 2  20 rr rr         jsr xt_compile_comma
004B40r 2  4C rr rr         jmp _loop
004B43r 2               
004B43r 2               _line_done:
004B43r 2                   ; drop stuff from PARSE_NAME
004B43r 2  E8               inx
004B44r 2  E8               inx
004B45r 2  E8               inx
004B46r 2  E8               inx
004B47r 2               
004B47r 2  60               rts
004B48r 2               .endscope
004B48r 2               
004B48r 2               
004B48r 2               is_printable:
004B48r 2               .scope
004B48r 2               ; """Given a character in A, check if it is a printable ASCII
004B48r 2               ; character in the range from $20 to $7E inclusive. Returns the
004B48r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004B48r 2               ; is printable. Keeps A. See
004B48r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004B48r 2               ; discussion of various ways to do this
004B48r 2  C9 20            cmp #AscSP              ; $20
004B4Ar 2  90 08            bcc _done
004B4Cr 2  C9 7F            cmp #'~' + 1             ; $7E
004B4Er 2  B0 03            bcs _failed
004B50r 2               
004B50r 2  38               sec
004B51r 2  80 01            bra _done
004B53r 2               _failed:
004B53r 2  18               clc
004B54r 2               _done:
004B54r 2  60               rts
004B55r 2               .endscope
004B55r 2               
004B55r 2               
004B55r 2               is_whitespace:
004B55r 2               .scope
004B55r 2               ; """Given a character in A, check if it is a whitespace
004B55r 2               ; character, that is, an ASCII value from 0 to 32 (where
004B55r 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004B55r 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004B55r 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004B55r 2               ; a discussion of the uses. Does not change A or Y.
004B55r 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004B57r 2  90 08            bcc _done
004B59r 2               
004B59r 2  C9 21            cmp #AscSP+1
004B5Br 2  B0 03            bcs _failed
004B5Dr 2               
004B5Dr 2  38               sec
004B5Er 2  80 01            bra _done
004B60r 2               _failed:
004B60r 2  18               clc
004B61r 2               _done:
004B61r 2  60               rts
004B62r 2               .endscope
004B62r 2               
004B62r 2               
004B62r 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
004B62r 2               ; required for the word. This routine flows into the generic error handling
004B62r 2               ; code
004B62r 2               underflow_1:
004B62r 2               ; """Make sure we have at least one cell on the Data Stack"""
004B62r 2  E0 FE            cpx #dsp0-1
004B64r 2  10 10            bpl underflow_error
004B66r 2  60               rts
004B67r 2               underflow_2:
004B67r 2               ; """Make sure we have at least two cells on the Data Stack"""
004B67r 2  E0 FC            cpx #dsp0-3
004B69r 2  10 0B            bpl underflow_error
004B6Br 2  60               rts
004B6Cr 2               underflow_3:
004B6Cr 2               ; """Make sure we have at least three cells on the Data Stack"""
004B6Cr 2  E0 FA            cpx #dsp0-5
004B6Er 2  10 06            bpl underflow_error
004B70r 2  60               rts
004B71r 2               underflow_4:
004B71r 2               ; """Make sure we have at least four cells on the Data Stack"""
004B71r 2  E0 F8            cpx #dsp0-7
004B73r 2  10 01            bpl underflow_error
004B75r 2  60               rts
004B76r 2               
004B76r 2               underflow_error:
004B76r 2                   ; Entry for COLD/ABORT/QUIT
004B76r 2  A9 09            lda #err_underflow      ; fall through to error
004B78r 2               
004B78r 2               error:
004B78r 2               ; """Given the error number in a, print the associated error string and
004B78r 2               ; call abort. Uses tmp3.
004B78r 2               ; """
004B78r 2  0A               asl
004B79r 2  A8               tay
004B7Ar 2  B9 rr rr         lda error_table,y
004B7Dr 2  85 rr            sta tmp3                ; LSB
004B7Fr 2  C8               iny
004B80r 2  B9 rr rr         lda error_table,y
004B83r 2  85 rr            sta tmp3+1              ; MSB
004B85r 2               
004B85r 2  20 rr rr         jsr print_common
004B88r 2  20 rr rr         jsr xt_cr
004B8Br 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
004B8Er 2               
004B8Er 2               
004B8Er 2               ; =====================================================================
004B8Er 2               ; PRINTING ROUTINES
004B8Er 2               
004B8Er 2               ; We distinguish two types of print calls, both of which take the string number
004B8Er 2               ; (see strings.asm) in A:
004B8Er 2               
004B8Er 2               ;       print_string       - with a line feed
004B8Er 2               ;       print_string_no_lf - without a line feed
004B8Er 2               
004B8Er 2               ; In addition, print_common provides a lower-level alternative for error
004B8Er 2               ; handling and anything else that provides the address of the
004B8Er 2               ; zero-terminated string directly in tmp3. All of those routines assume that
004B8Er 2               ; printing should be more concerned with size than speed, because anything to
004B8Er 2               ; do with humans reading text is going to be slow.
004B8Er 2               
004B8Er 2               print_string_no_lf:
004B8Er 2               ; """Given the number of a zero-terminated string in A, print it to the
004B8Er 2               ; current output without adding a LF. Uses Y and tmp3 by falling
004B8Er 2               ; through to print_common
004B8Er 2               ; """
004B8Er 2                   ; Get the entry from the string table
004B8Er 2  0A               asl
004B8Fr 2  A8               tay
004B90r 2  B9 rr rr         lda string_table,y
004B93r 2  85 rr            sta tmp3                ; LSB
004B95r 2  C8               iny
004B96r 2  B9 rr rr         lda string_table,y
004B99r 2  85 rr            sta tmp3+1              ; MSB
004B9Br 2               
004B9Br 2                   ; fall through to print_common
004B9Br 2               print_common:
004B9Br 2               ; """Common print routine used by both the print functions and
004B9Br 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004B9Br 2               ; Y.
004B9Br 2               ; """
004B9Br 2               .scope
004B9Br 2  A0 00            ldy #0
004B9Dr 2               _loop:
004B9Dr 2  B1 rr            lda (tmp3),y
004B9Fr 2  F0 06            beq _done               ; strings are zero-terminated
004BA1r 2               
004BA1r 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004BA4r 2  C8               iny
004BA5r 2  80 F6            bra _loop
004BA7r 2               _done:
004BA7r 2  60               rts
004BA8r 2               .endscope
004BA8r 2               
004BA8r 2               print_string:
004BA8r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004BA8r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004BA8r 2               ; """
004BA8r 2  20 rr rr         jsr print_string_no_lf
004BABr 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
004BAEr 2               
004BAEr 2               
004BAEr 2               print_u:
004BAEr 2               ; """basic printing routine used by higher-level constructs,
004BAEr 2               ; the equivalent of the forth word  0 <# #s #> type  which is
004BAEr 2               ; basically u. without the space at the end. used for various
004BAEr 2               ; outputs
004BAEr 2               ; """
004BAEr 2  20 rr rr         jsr xt_zero                     ; 0
004BB1r 2  20 rr rr         jsr xt_less_number_sign         ; <#
004BB4r 2  20 rr rr         jsr xt_number_sign_s            ; #S
004BB7r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004BBAr 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
004BBDr 2               
004BBDr 2               ; END
004BBDr 2               
004BBDr 1               
004BBDr 1               kernel_init:
004BBDr 1               v_nmi:
004BBDr 1  A9 FF            lda #$FF
004BBFr 1  8D 82 FF         sta DDRB
004BC2r 1  8D 83 FF         sta DDRA
004BC5r 1  9C 81 FF         stz PORTA
004BC8r 1  9C 80 FF         stz PORTB
004BCBr 1               .ifdef video_init
004BCBr 1                   jsr video_init
004BCBr 1               .endif
004BCBr 1               .ifdef ps2_init
004BCBr 1                   ; jsr ps2_init
004BCBr 1               .endif
004BCBr 1               .ifdef timer_init
004BCBr 1  20 rr rr         jsr timer_init
004BCEr 1               .endif
004BCEr 1  20 rr rr         jsr acia_init
004BD1r 1               .ifdef lcd_init
004BD1r 1                   ; jsr lcd_init
004BD1r 1               .endif
004BD1r 1               .ifdef spi_init
004BD1r 1                   ; jsr spi_init
004BD1r 1               .endif
004BD1r 1               .ifdef kb_init
004BD1r 1  20 rr rr         jsr kb_init
004BD4r 1               .endif
004BD4r 1               
004BD4r 1               
004BD4r 1               
004BD4r 1  A2 00 BD rr      printascii welcome_message
004BD8r 1  rr F0 06 20  
004BDCr 1  rr rr E8 80  
004BE1r 1               
004BE1r 1  4C rr rr         jmp forth
004BE4r 1               
004BE4r 1               platform_bye:
004BE4r 1  4C rr rr         jmp platform_bye
004BE7r 1               
004BE7r 1               
004BE7r 1               kernel_putc:
004BE7r 1                   ; """Print a single character to the console. """
004BE7r 1                   ;; Send_Char - send character in A out serial port.
004BE7r 1                   ;; Uses: A (original value restored)
004BE7r 1               send_char:
004BE7r 1  48               pha
004BE8r 1                   .ifdef char_out
004BE8r 1                   jsr char_out
004BE8r 1                   .endif
004BE8r 1                   .ifdef acia_out
004BE8r 1  20 rr rr         jsr acia_out
004BEBr 1                   .endif
004BEBr 1               send_char_exit:
004BEBr 1               .ifdef lcd_print
004BEBr 1                   jsr lcd_print
004BEBr 1               .endif
004BEBr 1  68               pla
004BECr 1  60               rts
004BEDr 1               
004BEDr 1               
004BEDr 1                       ;; Get_Char - get a character from the serial port into A.
004BEDr 1                       ;; Set the carry flag if char is valid.
004BEDr 1                       ;; Return immediately with carry flag clear if no char available.
004BEDr 1                       ;; Uses: A (return value)
004BEDr 1               
004BEDr 1               Get_Char:
004BEDr 1  20 rr rr         jsr acia_getc
004BF0r 1  90 05            bcc get_ps2_char                ; check keyboard buffer if nothing from ACIA
004BF2r 1  20 rr rr         jsr check_ctrl_c
004BF5r 1  38               sec                             ; Set Carry to show we got a character
004BF6r 1  60               rts                             ; Return
004BF7r 1               
004BF7r 1               get_ps2_char:                       ; no ACIA char available, try to get from KB buffer
004BF7r 1               .ifdef ps2_get_char
004BF7r 1                   jsr ps2_get_char
004BF7r 1               .endif
004BF7r 1  90 02            bcc get_kb_char
004BF9r 1  38               sec
004BFAr 1               
004BFAr 1  60               rts
004BFBr 1               get_kb_char:
004BFBr 1                   .ifdef kb_get_char
004BFBr 1  20 rr rr             jsr kb_get_char
004BFEr 1                   .endif
004BFEr 1  90 02            bcc no_char_available
004C00r 1  38               sec
004C01r 1  60               rts
004C02r 1               no_char_available:
004C02r 1  18               clc                             ; Indicate no char available.
004C03r 1  60               rts                             ; return
004C04r 1               
004C04r 1               
004C04r 1               
004C04r 1               kernel_getc:
004C04r 1                   ; """Get a single character from the keyboard (waits for key).
004C04r 1                   ; """
004C04r 1                   ;; Get_Char_Wait - same as Get_Char only blocking.
004C04r 1                   ;; Uses: A (return value)
004C04r 1               Get_Char_Wait:
004C04r 1  20 rr rr         jsr Get_Char
004C07r 1  90 FB            bcc Get_Char_Wait
004C09r 1  60               rts
004C0Ar 1               
004C0Ar 1               check_ctrl_c:
004C0Ar 1                   ;; Check if we have ctrl-C character, if so jump to nmi
004C0Ar 1  C9 03            cmp #$03
004C0Cr 1  D0 10            bne exit_ctrl_c
004C0Er 1  A2 00 BD rr      printascii abort_message
004C12r 1  rr F0 06 20  
004C16r 1  rr rr E8 80  
004C1Br 1  4C rr rr         jmp xt_abort
004C1Er 1               
004C1Er 1               exit_ctrl_c:
004C1Er 1  60               rts
004C1Fr 1               
004C1Fr 1               
004C1Fr 1               
004C1Fr 1               v_irq:                          ; IRQ handler
004C1Fr 1  48                   pha
004C20r 1  5A                   phy
004C21r 1                       ; check if bit 7 of IFR is set
004C21r 1  AD 8D FF             lda IFR
004C24r 1  10 0B                bpl v_kb_irq  ; Interrupt not from VIA, exit
004C26r 1               
004C26r 1  29 08                and #$08        ; ps2 has priority
004C28r 1  D0 12                bne v_irq_ps2
004C2Ar 1  AD 8D FF             lda IFR
004C2Dr 1  29 40                and #$40
004C2Fr 1  D0 0D                bne v_irq_timer
004C31r 1               v_kb_irq:
004C31r 1  AD 9D FF             lda KB_IFR
004C34r 1  10 19                bpl v_irq_exit
004C36r 1  29 40                and #$40
004C38r 1  D0 0F                bne v_kb_irq_timer
004C3Ar 1  80 13                bra v_irq_exit
004C3Cr 1               
004C3Cr 1               
004C3Cr 1               v_irq_ps2:
004C3Cr 1                   .ifdef ps2_irq
004C3Cr 1                       lda time
004C3Cr 1                       sta last_ps2_time
004C3Cr 1                       lda time+1
004C3Cr 1                       sta last_ps2_time+1
004C3Cr 1                       lda time+2
004C3Cr 1                       sta last_ps2_time+2
004C3Cr 1                       lda time+3
004C3Cr 1                       sta last_ps2_time+3
004C3Cr 1                       ; this delay is here to ensure we prevent desynchronization
004C3Cr 1                       ;ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004C3Cr 1                       ; jsr delay_short
004C3Cr 1               
004C3Cr 1               
004C3Cr 1                       jsr ps2_irq
004C3Cr 1               
004C3Cr 1                       ; ldy #$04         ; correct delay seems to be #$20 at 10Mhz
004C3Cr 1                       ; jsr delay_short
004C3Cr 1                   .endif
004C3Cr 1  80 11                bra v_irq_exit
004C3Er 1               
004C3Er 1               v_irq_timer:
004C3Er 1  AD 84 FF             lda T1CL
004C41r 1                       ; clear timer interrupt
004C41r 1                   .ifdef timer_irq
004C41r 1  20 rr rr             jsr timer_irq
004C44r 1                   .endif
004C44r 1  20 rr rr             jsr Get_Char ; Check if a char is waiting to be able to break on CTRL-C
004C47r 1                       ; check if there is a char waiting to be printed to the lcd
004C47r 1                       ; lda lcd_char
004C47r 1                       ; beq v_exit
004C47r 1                       ; jsr lcd_print
004C47r 1                       ; stz lcd_char
004C47r 1               
004C47r 1               
004C47r 1  80 06                bra v_irq_exit
004C49r 1               v_kb_irq_timer:
004C49r 1  AD 94 FF         lda KB_T1CL ; clear timer interrupt
004C4Cr 1  20 rr rr         jsr kb_scan
004C4Fr 1               v_irq_exit:
004C4Fr 1  7A               ply
004C50r 1  68               pla
004C51r 1  40               rti
004C52r 1               
004C52r 1               .segment "RODATA"
0000FFr 1               
0000FFr 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", $0D, "Type 'words' for available words", 0
000103r 1  6F 6D 65 20  
000107r 1  74 6F 20 50  
000137r 1  0D 0A 00     abort_message: .byte AscCR, AscLF, 0
00013Ar 1               
00013Ar 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
