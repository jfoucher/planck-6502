ca65 V2.18 - N/A
Main file   : platform/planck/boot.s
Current file: platform/planck/boot.s

000000r 1               
000000r 1               .include "../../macros.s"
000000r 2               .macro  printascii   addr
000000r 2               .local @loop
000000r 2               .local @done
000000r 2                   phx
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda addr,x
000000r 2                   beq @done
000000r 2                   jsr kernel_putc
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @done:
000000r 2                   plx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro  cp16   src, dest
000000r 2                   lda src
000000r 2                   sta dest
000000r 2                   lda src + 1
000000r 2                   sta dest + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro printstr addr, len
000000r 2               .repeat len, I
000000r 2               lda addr + I
000000r 2               jsr kernel_putc
000000r 2               .endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl16 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl32 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2                   rol src + 2
000000r 2                   rol src + 3
000000r 2               .endmacro
000000r 2               
000000r 2               .macro lsr16 src
000000r 2                   lsr src + 1
000000r 2                   ror src
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc16 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment the MSB if LSB wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc32 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment next byte if LSB wrapped round
000000r 2                   bne @done
000000r 2                   inc src+2       ;Increment the next byte the previous wrapped round
000000r 2                   bne @done
000000r 2                   inc src+3       ;Increment the MSB if previous wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16 src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, just decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2               @skip:
000000r 2                   dec src
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16zero src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2                   beq @end            ; if high byte is also zero, we reached zero, exit now
000000r 2               @skip:
000000r 2                   dec src
000000r 2                   bne @end            ; if low byte is not zero exit now
000000r 2                   lda src + 1         ; if low byte was zero, load high byte to check if it's also zero
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro add16 first, second, result
000000r 2                   CLC             ;Ensure carry is clear
000000r 2                   LDA first+0       ;Add the two least significant bytes
000000r 2                   ADC second+0
000000r 2                   STA result+0       ;... and store the result
000000r 2                   LDA first+1       ;Add the two most significant bytes
000000r 2                   ADC second+1       ;... and any propagated carry bit
000000r 2                   STA result+1       ;... and store the result
000000r 2               .endmacro
000000r 2               
000000r 2               ; compare data at two adresses for defined length
000000r 2               ; On exit, carry is set if there is a match
000000r 2               ; and unset if no match
000000r 2               ; length of data to check is in X
000000r 2               
000000r 2               .macro memcmp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               .local @exit_fail
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   cmp second, x
000000r 2                   bne @exit_fail
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; check 0th element
000000r 2                   cmp second
000000r 2                   bne @exit_fail
000000r 2                   sec
000000r 2                   bra @exit
000000r 2               @exit_fail:
000000r 2                   clc
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               ; copy data from one address to another for defined length
000000r 2               ; length of data to copy is in X
000000r 2               .macro memcp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   sta second, x
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; copy zeroth item
000000r 2                   sta second
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; calculates length of zero terminated string
000000r 2               ; result is in x
000000r 2               .macro strlen address
000000r 2               .local @loop
000000r 2               .local @exit
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda address, x
000000r 2                   beq @exit
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_axy
000000r 2               	pha		; push accumulator to stack
000000r 2               	phx
000000r 2                   phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro pull_axy
000000r 2               	ply		; pull y from stack
000000r 2               	plx		; pull x from stack
000000r 2               	pla		; pull a from stack
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro push_ax
000000r 2               	pha
000000r 2               	phx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ax
000000r 2               	pla
000000r 2               	plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_ay
000000r 2               	pha
000000r 2               	phy
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ay
000000r 2               	pla
000000r 2               	ply
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro mov32 SRC, DEST
000000r 2               	lda SRC
000000r 2               	sta DEST
000000r 2               	lda SRC+1
000000r 2               	sta DEST+1
000000r 2               	lda SRC+2
000000r 2               	sta DEST+2
000000r 2               	lda SRC+3
000000r 2               	sta DEST+3
000000r 2               .endmacro
000000r 2               
000000r 1               CLOCK_SPEED = 12000000
000000r 1               
000000r 1               RAM_END = $8000
000000r 1               CODE_START= $200
000000r 1               
000000r 1               ; select includes to enable card drivers
000000r 1               
000000r 1               .include "drivers/cf.inc"
000000r 2               
000000r 2               CF_READ_SECTOR_COMMAND = $20
000000r 2               CF_WRITE_SECTOR_COMMAND = $30
000000r 2               CF_ADDRESS = $FFD0
000000r 2               
000000r 1               
000000r 1               
000000r 1               .segment "ZEROPAGE": zeropage
000000r 1  xx xx        IRQ_VEC: .res 2
000002r 1  xx xx        NMI_VEC: .res 2
000004r 1  xx xx        io_buffer_ptr: .res 2
000006r 1               
000006r 1               .segment "BSS"
000000r 1               
000000r 1               .ifdef CF_ADDRESS
000000r 1  xx xx xx xx  IO_SECTOR: .res 4
000004r 1               .endif
000004r 1               
000004r 1               
000004r 1               .segment "CODE"
000000r 1               
000000r 1               .include "drivers/acia.inc"
000000r 2               ACIA_BASE   = $FFE0
000000r 2               ACIA_DATA = ACIA_BASE
000000r 2               ACIA_STATUS = ACIA_BASE + 1
000000r 2               ACIA_CMD = ACIA_BASE + 2
000000r 2               ACIA_CTRL = ACIA_BASE + 3
000000r 2               
000000r 2               
000000r 1               .include "drivers/acia.s"
000000r 2               ACIA_DELAY = CLOCK_SPEED / 500000
000000r 2               
000000r 2               .segment "CODE"
000000r 2               acia_init:
000000r 2  8D E1 FF         sta ACIA_STATUS        ; soft reset (value not important)
000003r 2                                           ; set specific modes and functions
000003r 2  A9 0B            lda #$0B                ; no parity, no echo, no Tx interrupt, NO Rx interrupt, enable Tx/Rx
000005r 2  8D E2 FF         sta ACIA_CMD        ; store to the command register
000008r 2  A9 10            lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 115.200k baud rate
00000Ar 2                   ;lda #$10               ; 1 stop bits, 8 bit word length, internal clock, 1200 baud rate
00000Ar 2  8D E3 FF         sta ACIA_CTRL          ; program the ctl register
00000Dr 2               aa_end:
00000Dr 2  60               rts
00000Er 2               
00000Er 2               acia_out:
00000Er 2  48               pha
00000Fr 2  5A               phy
000010r 2  8D E0 FF         sta ACIA_DATA
000013r 2               .ifndef LCD_BUF                ; if the LCD is in the build, we do not need to delay
000013r 2  A0 18            ldy #ACIA_DELAY            ;minimal delay is $02
000015r 2  20 rr rr         jsr delay_short
000018r 2               .endif
000018r 2  7A               ply
000019r 2  68               pla
00001Ar 2  60               rts
00001Br 2               
00001Br 2               acia_getc:
00001Br 2  AD E1 FF         lda ACIA_STATUS                 ; Read the ACIA status to
00001Er 2  29 08            and #$08                        ; Check if there is character in the receiver
000020r 2  F0 05            beq @no_char      ; Exit now if we don't get one.
000022r 2  AD E0 FF         lda ACIA_DATA
000025r 2  38               sec
000026r 2  60               rts
000027r 2               @no_char:
000027r 2  18               clc
000028r 2  60               rts
000029r 2               
000029r 1               .include "drivers/delayroutines.s"
000029r 2               ; Copyright 2020 Jonathan Foucher
000029r 2               
000029r 2               ; Permission is hereby granted, free of charge, to any person obtaining a copy of this software
000029r 2               ; and associated documentation files (the "Software"), to deal in the Software without restriction,
000029r 2               ; including without limitation the rights to use, copy, modify, merge, publish, distribute,
000029r 2               ; sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
000029r 2               ; is furnished to do so, subject to the following conditions:
000029r 2               
000029r 2               ; The above copyright notice and this permission notice shall be included in all copies or
000029r 2               ; substantial portions of the Software.
000029r 2               
000029r 2               ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
000029r 2               ; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
000029r 2               ; PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
000029r 2               ; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
000029r 2               ; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
000029r 2               ; DEALINGS IN THE SOFTWARE.
000029r 2               
000029r 2               
000029r 2               ; this routine delays by 2304 * y + 23 cycles
000029r 2               delay:
000029r 2  DA             phx       ; 3 cycles
00002Ar 2  5A             phy       ; 3 cycles
00002Br 2               two:
00002Br 2  A2 FF          ldx #$ff  ; 2 cycles
00002Dr 2               one:
00002Dr 2  EA             nop       ; 2 cycles
00002Er 2  EA             nop       ; 2 cycles
00002Fr 2  CA             dex       ; 2 cycles
000030r 2  D0 FB          bne one   ; 3 for all cycles, 2 for last
000032r 2  88             dey       ; 2 cycles
000033r 2  D0 F6          bne two   ; 3 for all cycles, 2 for last
000035r 2  7A             ply       ; 4 cycles
000036r 2  FA             plx       ; 4 cycles
000037r 2  60             rts       ; 6 cycles
000038r 2               
000038r 2               ; delay is in Y register
000038r 2               delay_long:
000038r 2  48             pha
000039r 2  5A             phy
00003Ar 2  DA             phx
00003Br 2  98             tya
00003Cr 2  AA             tax
00003Dr 2               delay_long_loop:
00003Dr 2  A0 FF          ldy #$ff
00003Fr 2  20 rr rr       jsr delay
000042r 2  CA             dex
000043r 2  D0 F8          bne delay_long_loop
000045r 2  FA             plx
000046r 2  7A             ply
000047r 2  68             pla
000048r 2  60             rts
000049r 2               
000049r 2               delay_short:        ; delay Y * 19 cycles
000049r 2  5A             phy
00004Ar 2               delay_short_loop:
00004Ar 2  EA             nop               ; 2 cycles
00004Br 2  EA             nop               ; 2 cycles
00004Cr 2  EA             nop               ; 2 cycles
00004Dr 2  EA             nop               ; 2 cycles
00004Er 2  EA             nop               ; 2 cycles
00004Fr 2  EA             nop               ; 2 cycles
000050r 2  EA             nop               ; 2 cycles
000051r 2               
000051r 2               
000051r 2  88             dey               ; 2 cycles
000052r 2  D0 F6          bne delay_short_loop   ; 2 or 3 cycles
000054r 2  7A             ply
000055r 2  60             rts
000056r 2               
000056r 1               
000056r 1               .ifdef CF_ADDRESS
000056r 1               io_read_sector_address = cf_read_sector
000056r 1               .endif
000056r 1               VIA1_BASE   = $FFD0
000056r 1               PORTB = VIA1_BASE
000056r 1               PORTA  = VIA1_BASE+1
000056r 1               DDRB = VIA1_BASE+2
000056r 1               DDRA = VIA1_BASE+3
000056r 1               
000056r 1               
000056r 1  42 6F 6F 74  boot_msg: .asciiz "Boot Message"
00005Ar 1  20 4D 65 73  
00005Er 1  73 61 67 65  
000063r 1               reset:
000063r 1  78               sei
000064r 1  A9 FF            lda #$FF
000066r 1  8D D3 FF         sta DDRA
000069r 1  8D D2 FF         sta DDRB
00006Cr 1  A9 01            lda #1
00006Er 1  8D D1 FF         sta PORTA
000071r 1  A0 0F            ldy #$0F
000073r 1               @delay_loop:
000073r 1               
000073r 1  20 rr rr         jsr delay
000076r 1  EE D1 FF         inc PORTA
000079r 1  88               dey
00007Ar 1  D0 F7            bne @delay_loop
00007Cr 1  20 rr rr         jsr acia_init
00007Fr 1  A9 02            lda #2
000081r 1  8D D1 FF         sta PORTA
000084r 1  A2 00            ldx #0
000086r 1               @loop1:
000086r 1  BD rr rr         lda boot_msg, x
000089r 1  20 rr rr         jsr acia_out
00008Cr 1  F0 D5            beq reset
00008Er 1  E8               inx
00008Fr 1  80 F5            bra @loop1
000091r 1               @loop_exit1:
000091r 1  20 rr rr         jsr cf_init
000094r 1               
000094r 1                   ; copy data from CF card to RAM
000094r 1               
000094r 1  9C rr rr         stz IO_SECTOR
000097r 1  9C rr rr         stz IO_SECTOR + 1
00009Ar 1  9C rr rr         stz IO_SECTOR + 2
00009Dr 1  9C rr rr         stz IO_SECTOR + 3
0000A0r 1                   ; stz NMI_VEC
0000A0r 1                   ; stz NMI_VEC + 1
0000A0r 1                   ; stz IRQ_VEC
0000A0r 1                   ; stz IRQ_VEC + 1
0000A0r 1               
0000A0r 1  A9 00            lda #<CODE_START
0000A2r 1  85 rr            sta io_buffer_ptr
0000A4r 1  A9 02            lda #>CODE_START
0000A6r 1  85 rr            sta io_buffer_ptr + 1
0000A8r 1               
0000A8r 1  A2 3E            ldx #(((RAM_END-CODE_START)/$200)-1)                 ; number of sectors to read
0000AAr 1               @loop:
0000AAr 1  20 rr rr         jsr io_read_sector
0000ADr 1  E6 rr            inc io_buffer_ptr + 1
0000AFr 1  E6 rr            inc io_buffer_ptr + 1
0000B1r 1  EE rr rr         inc IO_SECTOR
0000B4r 1  CA               dex
0000B5r 1  D0 F3            bne @loop
0000B7r 1               
0000B7r 1  A9 32            lda #'2'
0000B9r 1  20 rr rr         jsr acia_out
0000BCr 1               
0000BCr 1  AD 00 02         lda CODE_START
0000BFr 1  20 rr rr         jsr acia_out
0000C2r 1  AD 01 02         lda CODE_START + 1
0000C5r 1  20 rr rr         jsr acia_out
0000C8r 1  AD 02 02         lda CODE_START + 2
0000CBr 1  20 rr rr         jsr acia_out
0000CEr 1               
0000CEr 1  AD 30 04         lda CODE_START + $230
0000D1r 1  20 rr rr         jsr acia_out
0000D4r 1  AD 31 04         lda CODE_START + $231
0000D7r 1  20 rr rr         jsr acia_out
0000DAr 1  AD 32 04         lda CODE_START + $232
0000DDr 1  20 rr rr         jsr acia_out
0000E0r 1  AD 33 04         lda CODE_START + $233
0000E3r 1  20 rr rr         jsr acia_out
0000E6r 1  AD 34 04         lda CODE_START + $234
0000E9r 1  20 rr rr         jsr acia_out
0000ECr 1  AD 35 04         lda CODE_START + $235
0000EFr 1  20 rr rr         jsr acia_out
0000F2r 1  AD 36 04         lda CODE_START + $236
0000F5r 1  20 rr rr         jsr acia_out
0000F8r 1  AD 19 5F         lda CODE_START + $5D19
0000FBr 1  20 rr rr         jsr acia_out
0000FEr 1  AD 1A 5F         lda CODE_START + $5D1A
000101r 1  20 rr rr         jsr acia_out
000104r 1  AD 1B 5F         lda CODE_START + $5D1B
000107r 1  20 rr rr         jsr acia_out
00010Ar 1  AD 1C 5F         lda CODE_START + $5D1C
00010Dr 1  20 rr rr         jsr acia_out
000110r 1  AD 1D 5F         lda CODE_START + $5D1D
000113r 1  20 rr rr         jsr acia_out
000116r 1               
000116r 1  4C 00 02         jmp CODE_START          ; jump to start of code
000119r 1               
000119r 1               nmi:
000119r 1                   ;pha		; save affected register
000119r 1  A9 C0            lda #$C0
00011Br 1  8D D1 FF         sta PORTA
00011Er 1                   ;pla
00011Er 1  40               rti
00011Fr 1  A5 rr        	lda NMI_VEC	; check if NMI vector is zero
000121r 1  05 rr        	ora NMI_VEC+1
000123r 1  F0 04        	beq nmi_end		; if so, skip
000125r 1               
000125r 1               
000125r 1  68           	pla		; restore register
000126r 1  6C rr rr     	jmp (NMI_VEC)
000129r 1               
000129r 1               nmi_end:    ; should not be called
000129r 1  68           	pla		; restore register
00012Ar 1  40           	rti		; return from interrupt
00012Br 1               
00012Br 1               irq:
00012Br 1               	;pha		; save affected register
00012Br 1  A9 A0            lda #$A0
00012Dr 1  8D D1 FF         sta PORTA
000130r 1                   ;pla
000130r 1  40               rti
000131r 1  A5 rr        	lda IRQ_VEC	; check if IRQ vector is zero
000133r 1  05 rr        	ora IRQ_VEC+1
000135r 1  F0 04        	beq end		; if so, skip
000137r 1               
000137r 1               	; there is no indirect jsr so push return address to stack
000137r 1               	; so the actual IRQ handler code can rts later on
000137r 1  68           	pla		; restore register
000138r 1  6C rr rr     	jmp (IRQ_VEC)
00013Br 1               
00013Br 1               end:
00013Br 1  68           	pla		; restore register
00013Cr 1  40           	rti		; return from interrupt
00013Dr 1               
00013Dr 1               io_read_sector:
00013Dr 1  4C rr rr         jmp io_read_sector_address        ; jump to read sector routine
000140r 1               
000140r 1               
000140r 1               kernel_putc:
000140r 1  60               rts
000141r 1               
000141r 1               cf_init:
000141r 1                   ; phy
000141r 1  A9 04            lda #$4
000143r 1                   ; ldy #7
000143r 1                   ; sta (CF_ADDRESS),y
000143r 1  8D D7 FF         sta CF_ADDRESS + 7
000146r 1  20 rr rr         jsr cf_wait
000149r 1  A9 E0            lda #$E0
00014Br 1  8D D6 FF         sta CF_ADDRESS + 6
00014Er 1  20 rr rr         jsr cf_wait
000151r 1  A9 01            lda #$1
000153r 1  8D D1 FF         sta CF_ADDRESS + 1
000156r 1  20 rr rr         jsr cf_wait
000159r 1  A9 EF            lda #$EF
00015Br 1  8D D7 FF         sta CF_ADDRESS + 7
00015Er 1  20 rr rr         jsr cf_wait
000161r 1  20 rr rr         jsr cf_err
000164r 1                   ; ply
000164r 1  60               rts
000165r 1               
000165r 1               
000165r 1               
000165r 1               
000165r 1               cf_read:
000165r 1  5A               phy
000166r 1  A0 00            ldy #0
000168r 1               @loop:
000168r 1                   ; jsr cf_wait
000168r 1  AD D0 FF         lda CF_ADDRESS
00016Br 1  91 rr            sta (io_buffer_ptr), y
00016Dr 1  C8               iny
00016Er 1  D0 F8            bne @loop
000170r 1  E6 rr            inc io_buffer_ptr + 1
000172r 1  20 rr rr         jsr cf_wait
000175r 1               @loop2:
000175r 1                   ; jsr cf_wait
000175r 1  AD D0 FF         lda CF_ADDRESS
000178r 1  91 rr            sta (io_buffer_ptr), y
00017Ar 1  C8               iny
00017Br 1  D0 F8            bne @loop2
00017Dr 1  C6 rr            dec io_buffer_ptr + 1
00017Fr 1               @loop3:
00017Fr 1  20 rr rr         jsr cf_wait
000182r 1  AD D7 FF         lda CF_ADDRESS + 7
000185r 1  29 08            and #$08
000187r 1  F0 06            beq @exit
000189r 1  AD D0 FF         lda CF_ADDRESS
00018Cr 1  C8               iny
00018Dr 1  D0 F0            bne @loop3
00018Fr 1               @exit:
00018Fr 1  7A               ply
000190r 1  60               rts
000191r 1               
000191r 1               
000191r 1               ; number of sectors to read is in X
000191r 1               cf_read_sector:
000191r 1                   ; sei
000191r 1  20 rr rr         jsr cf_set_lba
000194r 1                   ; ldy #2
000194r 1                   ; sta (CF_ADDRESS), y
000194r 1  A9 01            lda #1
000196r 1  8D D2 FF         sta CF_ADDRESS + 2
000199r 1  20 rr rr         jsr cf_wait
00019Cr 1  A9 20            lda #CF_READ_SECTOR_COMMAND
00019Er 1                   ; ldy #7
00019Er 1                   ; sta (CF_ADDRESS), y
00019Er 1  8D D7 FF         sta CF_ADDRESS + 7
0001A1r 1  20 rr rr         jsr cf_wait
0001A4r 1  20 rr rr         jsr cf_read
0001A7r 1  20 rr rr         jsr cf_err
0001AAr 1                   ; cli
0001AAr 1  60               rts
0001ABr 1               
0001ABr 1               
0001ABr 1               
0001ABr 1               cf_wait:
0001ABr 1                   ; phy
0001ABr 1                   ; ldy #7
0001ABr 1               @wait_loop:
0001ABr 1                   ; lda (CF_ADDRESS), y
0001ABr 1  AD D7 FF         lda CF_ADDRESS + 7
0001AEr 1  29 80            and #$80
0001B0r 1  D0 F9            bne @wait_loop
0001B2r 1                   ; ply
0001B2r 1  60               rts
0001B3r 1               
0001B3r 1               cf_set_lba:
0001B3r 1  AD rr rr         lda IO_SECTOR
0001B6r 1  8D D3 FF         sta CF_ADDRESS + 3
0001B9r 1  20 rr rr         jsr cf_wait
0001BCr 1  AD rr rr         lda IO_SECTOR + 1
0001BFr 1  8D D4 FF         sta CF_ADDRESS + 4
0001C2r 1  20 rr rr         jsr cf_wait
0001C5r 1  AD rr rr         lda IO_SECTOR + 2
0001C8r 1  8D D5 FF         sta CF_ADDRESS + 5
0001CBr 1  20 rr rr         jsr cf_wait
0001CEr 1  AD rr rr         lda IO_SECTOR + 3
0001D1r 1  29 0F            and #$0F
0001D3r 1  09 E0            ora #$E0
0001D5r 1  8D D6 FF         sta CF_ADDRESS + 6
0001D8r 1  20 rr rr         jsr cf_wait
0001DBr 1  60               rts
0001DCr 1               
0001DCr 1               cf_err:
0001DCr 1                   ; phy
0001DCr 1  20 rr rr         jsr cf_wait
0001DFr 1                   ; ldy #7
0001DFr 1                   ; lda (CF_ADDRESS), y
0001DFr 1  AD D7 FF         lda CF_ADDRESS + 7
0001E2r 1  29 01            and #$01
0001E4r 1  F0 05            beq @exit
0001E6r 1               @exit_fail:
0001E6r 1  A9 21            lda #'!'
0001E8r 1  20 rr rr         jsr kernel_putc
0001EBr 1               @exit:
0001EBr 1                   ; ply
0001EBr 1  60               rts
0001ECr 1               
0001ECr 1               .segment "VECTORS"
000000r 1  rr rr        .word nmi
000002r 1  rr rr        .word reset
000004r 1  rr rr        .word irq
000004r 1               
