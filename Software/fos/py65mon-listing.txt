ca65 V2.18 - N/A
Main file   : platform/py65mon/main.s
Current file: platform/py65mon/main.s

000000r 1               .include "../../macros.s"
000000r 2               .macro  printascii   addr
000000r 2               .local @loop
000000r 2               .local @done
000000r 2                   phx
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda addr,x
000000r 2                   beq @done
000000r 2                   jsr kernel_putc
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @done:
000000r 2                   plx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro  cp16   src, dest
000000r 2                   lda src
000000r 2                   sta dest
000000r 2                   lda src + 1
000000r 2                   sta dest + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro printstr addr, len
000000r 2               .repeat len, I
000000r 2               lda addr + I
000000r 2               jsr kernel_putc
000000r 2               .endrepeat
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl16 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2               .endmacro
000000r 2               
000000r 2               .macro asl32 src
000000r 2                   asl src
000000r 2                   rol src + 1
000000r 2                   rol src + 2
000000r 2                   rol src + 3
000000r 2               .endmacro
000000r 2               
000000r 2               .macro lsr16 src
000000r 2                   lsr src + 1
000000r 2                   ror src
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc16 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment the MSB if LSB wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro inc32 src
000000r 2               .local @done
000000r 2                   inc src       ;Increment the LSB
000000r 2                   bne @done       ;If the result was not zero we're done
000000r 2                   inc src+1       ;Increment next byte if LSB wrapped round
000000r 2                   bne @done
000000r 2                   inc src+2       ;Increment the next byte the previous wrapped round
000000r 2                   bne @done
000000r 2                   inc src+3       ;Increment the MSB if previous wrapped round
000000r 2               @done:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16 src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, just decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2               @skip:
000000r 2                   dec src
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro dec16zero src
000000r 2               .local @skip
000000r 2               .local @end
000000r 2                   lda src             ; load low byte
000000r 2                   bne @skip           ; if it's not zero, decrement it
000000r 2                   dec src + 1         ; if low byte is zero decrement high byte
000000r 2                   beq @end            ; if high byte is also zero, we reached zero, exit now
000000r 2               @skip:
000000r 2                   dec src
000000r 2                   bne @end            ; if low byte is not zero exit now
000000r 2                   lda src + 1         ; if low byte was zero, load high byte to check if it's also zero
000000r 2               @end:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro add16 first, second, result
000000r 2                   CLC             ;Ensure carry is clear
000000r 2                   LDA first+0       ;Add the two least significant bytes
000000r 2                   ADC second+0
000000r 2                   STA result+0       ;... and store the result
000000r 2                   LDA first+1       ;Add the two most significant bytes
000000r 2                   ADC second+1       ;... and any propagated carry bit
000000r 2                   STA result+1       ;... and store the result
000000r 2               .endmacro
000000r 2               
000000r 2               ; compare data at two adresses for defined length
000000r 2               ; On exit, carry is set if there is a match
000000r 2               ; and unset if no match
000000r 2               ; length of data to check is in X
000000r 2               
000000r 2               .macro memcmp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               .local @exit_fail
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   cmp second, x
000000r 2                   bne @exit_fail
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; check 0th element
000000r 2                   cmp second
000000r 2                   bne @exit_fail
000000r 2                   sec
000000r 2                   bra @exit
000000r 2               @exit_fail:
000000r 2                   clc
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               ; copy data from one address to another for defined length
000000r 2               ; length of data to copy is in X
000000r 2               .macro memcp first, second
000000r 2               .local @exit
000000r 2               .local @loop
000000r 2               @loop:
000000r 2                   lda first, x
000000r 2                   sta second, x
000000r 2                   dex
000000r 2                   bne @loop
000000r 2                   lda first           ; copy zeroth item
000000r 2                   sta second
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ; calculates length of zero terminated string
000000r 2               ; result is in x
000000r 2               .macro strlen address
000000r 2               .local @loop
000000r 2               .local @exit
000000r 2                   ldx #0
000000r 2               @loop:
000000r 2                   lda address, x
000000r 2                   beq @exit
000000r 2                   inx
000000r 2                   bra @loop
000000r 2               @exit:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_axy
000000r 2               	pha		; push accumulator to stack
000000r 2               	phx
000000r 2                   phy
000000r 2               .endmacro
000000r 2               
000000r 2               .macro pull_axy
000000r 2               	ply		; pull y from stack
000000r 2               	plx		; pull x from stack
000000r 2               	pla		; pull a from stack
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro push_ax
000000r 2               	pha
000000r 2               	phx
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ax
000000r 2               	pla
000000r 2               	plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro push_ay
000000r 2               	pha
000000r 2               	phy
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro pull_ay
000000r 2               	pla
000000r 2               	ply
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .macro mov32 SRC, DEST
000000r 2               	lda SRC
000000r 2               	sta DEST
000000r 2               	lda SRC+1
000000r 2               	sta DEST+1
000000r 2               	lda SRC+2
000000r 2               	sta DEST+2
000000r 2               	lda SRC+3
000000r 2               	sta DEST+3
000000r 2               .endmacro
000000r 2               
000000r 1               ram_end = $8000
000000r 1               TALI_OPTIONAL_ASSEMBLER = 1
000000r 1               
000000r 1               .segment "ZEROPAGE": zeropage
000000r 1  xx xx        stack_p: .res 2
000002r 1  xx xx xx xx  io_current_sector: .res 4
000006r 1  xx xx        io_buffer_ptr: .res 2
000008r 1  xx xx        io_read_location: .res 2
00000Ar 1  xx xx        io_sector_tmp: .res 2
00000Cr 1               
00000Cr 1  xx xx        zp_tmp: .res 2
00000Er 1               
00000Er 1               .segment "BSS"
000000r 1  xx xx        current_sector: .res 2
000002r 1               
000002r 1  xx xx xx xx  IO_BUFFER: .res $400
000006r 1  xx xx xx xx  
00000Ar 1  xx xx xx xx  
000402r 1               
000402r 1               .import    copydata
000402r 1               .import zerobss
000402r 1               .segment "STARTUP"
000000r 1               
000000r 1               v_reset:
000000r 1                   ; printascii welcome_message
000000r 1                   ; jmp v_reset
000000r 1  20 rr rr         JSR     copydata
000003r 1  20 rr rr         jsr zerobss
000006r 1               
000006r 1  4C rr rr         jmp kernel_init
000009r 1               
000009r 1               .segment "CODE"
000000r 1               kernel_putc:
000000r 1                   ; """Print a single character to the console. """
000000r 1                   ;; Send_Char - send character in A out serial port.
000000r 1                   ;; Uses: A (original value restored)
000000r 1  8D 01 F0             sta $f001
000003r 1  60                   rts
000004r 1               
000004r 1               .include "../../forth.s"
000004r 2               
000004r 2               
000004r 2               ; Definitions for Tali Forth 2
000004r 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000004r 2               ; First version: 01. Apr 2016 (Liara Forth)
000004r 2               ; This version: 29. Jan 2020
000004r 2               
000004r 2               ; This file is included by taliforth.asm. These are the general
000004r 2               ; definitions; platform-specific definitions such as the
000004r 2               ; memory map are kept in the platform folder.
000004r 2               
000004r 2               stack0 =    $0100   ; location of the stack
000004r 2               
000004r 2               ; User Variables:
000004r 2               ; Block variables
000004r 2               blk_offset =  0        ; BLK : UP + 0
000004r 2               scr_offset =  2        ; SCR : UP + 2
000004r 2               
000004r 2               ; Wordlists
000004r 2               current_offset =  4    ; CURRENT (byte) : UP + 4 (Compilation wordlist)
000004r 2               num_wordlists_offset =  5
000004r 2                                          ; #WORDLISTS (byte) : UP + 5
000004r 2               wordlists_offset =  6  ; WORDLISTS (cells) : UP + 6 to UP + 29
000004r 2                                          ;          (FORTH, EDITOR, ASSEMBLER, ROOT, +8 more)
000004r 2               num_order_offset =  30 ; #ORDER (byte) : UP + 30
000004r 2                                          ;          (Number of wordlists in search order)
000004r 2               search_order_offset =  31
000004r 2                                          ; SEARCH-ORDER (bytes) : UP + 31 to UP + 39
000004r 2                                          ; Allowing for 9 to keep offsets even.
000004r 2               max_wordlists =  12    ; Maximum number of wordlists supported
000004r 2                                          ; 4 Tali built-ins + 8 user wordlists
000004r 2               
000004r 2               ; Buffer variables
000004r 2               blkbuffer_offset =     40   ; Address of buffer
000004r 2               buffblocknum_offset =  42   ; Block number current in buffer
000004r 2               buffstatus_offset =    44   ; Status of buffer (bit 0 = used, bit 1 = dirty)
000004r 2               
000004r 2               ; Block I/O vectors
000004r 2               blockread_offset =     46   ; Vector to block reading routine
000004r 2               blockwrite_offset =    48   ; Vector to block writing routine
000004r 2               
000004r 2               
000004r 2               ; ASCII CHARACTERS
000004r 2               AscCC =   $03  ; break (CTRL-c)
000004r 2               AscBELL = $07  ; bell sound
000004r 2               AscBS =   $08  ; backspace
000004r 2               AscLF =   $0a  ; line feed
000004r 2               AscCR =   $0d  ; carriage return
000004r 2               AscESC =  $1b  ; escape
000004r 2               AscSP =   $20  ; space
000004r 2               AscDEL =  $7f  ; delete (CTRL-h)
000004r 2               AscCP =   $10  ; CTRL-p (used to recall previous input history)
000004r 2               AscCN =   $0e  ; CTRL-n (used to recall next input history)
000004r 2               
000004r 2               ; DICTIONARY FLAGS
000004r 2               ; The first three bits are currently unused
000004r 2               CO = 1  ; Compile Only
000004r 2               AN = 2  ; Always Native Compile
000004r 2               IM = 4  ; Immediate Word
000004r 2               NN = 8  ; Never Native Compile
000004r 2               UF = 16 ; Includes Underflow Check (RESERVED)
000004r 2               HC = 32 ; Word has Code Field Area (CFA)
000004r 2               
000004r 2               
000004r 2               ; VARIOUS
000004r 2               MAX_LINE_LENGTH =   79      ; assumes 80 character lines
000004r 2               
000004r 2               ; END
000004r 2               
000004r 2               .segment "ZEROPAGE": zeropage
00000Er 2               ; ZERO PAGE ADDRESSES/VARIABLES
00000Er 2               
00000Er 2               ; These are kept at the top of Zero Page, with the most important variables at
00000Er 2               ; the top because the Data Stack grows towards this area from dsp0: If there is
00000Er 2               ; an overflow, the lower, less important variables will be clobbered first,
00000Er 2               ; giving the system a chance to recover. In other words, they are part of the
00000Er 2               ; floodplain.
00000Er 2               
00000Er 2               ; The four variables insrc, cib, ciblen, and toin must stay together in this
00000Er 2               ; sequence for the words INPUT>R and R>INPUT to work correctly.
00000Er 2               
00000Er 2  xx xx        cp: .res 2   ; Compiler Pointer
000010r 2  xx xx        dp: .res 2   ; Dictionary Pointer
000012r 2  xx xx        workword: .res 2   ; nt (not xt!) of word being compiled, except in
000014r 2                                          ; a :NONAME declared word (see status)
000014r 2  xx xx        insrc: .res 2   ; input Source for SOURCE-ID
000016r 2  xx xx        cib: .res 2   ; address of current input buffer
000018r 2  xx xx        ciblen: .res 2  ; length of current input buffer
00001Ar 2  xx xx        toin: .res 2  ; pointer to CIB (>IN in Forth)
00001Cr 2  xx xx        ip: .res 2  ; Instruction Pointer (current xt)
00001Er 2  xx xx        output: .res 2  ; vector for EMIT
000020r 2  xx xx        input: .res 2  ; vector for KEY
000022r 2  xx xx        havekey: .res 2  ; vector for KEY?
000024r 2  xx xx        state: .res 2  ; STATE: -1 compile, 0 interpret
000026r 2  xx xx        base: .res 2  ; number radix, default decimal
000028r 2  xx xx        nc_limit: .res 2  ; limit for Native Compile size
00002Ar 2  xx xx        uf_strip: .res 2  ; flag to strip underflow detection code
00002Cr 2  xx xx        up: .res 2  ; User Pointer (Address of user variables)
00002Er 2  xx xx        status: .res 2  ; internal status information
000030r 2                                          ; (used by : :NONAME ; ACCEPT)
000030r 2                                          ; Bit 7 = Redefined word message postpone
000030r 2                                          ;         When set before calling CREATE, it will
000030r 2                                          ;         not print the "redefined xxxx" message if
000030r 2                                          ;         the word exists. Instead, this bit will
000030r 2                                          ;         be reused and after CREATE has run, it will
000030r 2                                          ;         be set if the word was redefined and 0 if
000030r 2                                          ;         not. This bit should be 0 when not in use.
000030r 2                                          ; Bit 6 = 1 for normal ":" definitions
000030r 2                                          ;         WORKWORD contains nt of word being compiled
000030r 2                                          ;       = 0 for :NONAME definitions
000030r 2                                          ;         WORKWORD contains xt of word being compiled
000030r 2                                          ; Bit 5 = 1 for NUMBER returning a double word
000030r 2                                          ;       = 0 for NUMBER returning a single word
000030r 2                                          ; Bit 3 = 1 makes CTRL-n recall current history
000030r 2                                          ;       = 0 CTRL-n recalls previous history
000030r 2                                          ; Bit 2 = Current history buffer msb
000030r 2                                          ; Bit 1 = Current history buffer (0-7, wraps)
000030r 2                                          ; Bit 0 = Current history buffer lsb
000030r 2                                          ; status+1 is used by ACCEPT to hold history lengths.
000030r 2  xx xx        tmpbranch: .res 2  ; temporary storage for 0BRANCH, BRANCH only
000032r 2  xx xx        tmp1: .res 2  ; temporary storage
000034r 2  xx xx        tmp2: .res 2  ; temporary storage
000036r 2  xx xx        tmp3: .res 2  ; temporary storage (especially for print)
000038r 2  xx xx        tmpdsp: .res 2  ; temporary DSP (X) storage (two bytes)
00003Ar 2  xx xx        tmptos: .res 2  ; temporary TOS storage
00003Cr 2  xx xx        editor1: .res 2  ; temporary for editors
00003Er 2  xx xx        editor2: .res 2  ; temporary for editors
000040r 2  xx xx        editor3: .res 2  ; temporary for editors
000042r 2  xx xx        tohold: .res 2  ; pointer for formatted output
000044r 2  xx xx xx xx  scratch: .res 8  ; 8 byte scratchpad (see UM/MOD)
000048r 2  xx xx xx xx  
00004Cr 2               
00004Cr 2               .segment "DATASTACK": zeropage
000000r 2  xx xx xx xx  dsp_start: .res 127 ; reserve 128 bytes for data stack (64 16 bit cells)
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
00007Fr 2               dsp0:          ; first data stack location. Data stack grows down
00007Fr 2               rsp0:     ; starting stack pointer
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               
00007Fr 2               .segment "BSS"
000402r 2  xx xx xx xx  hist_buff: .res $400
000406r 2  xx xx xx xx  
00040Ar 2  xx xx xx xx  
000802r 2  xx xx xx xx  buffer0: .res $100
000806r 2  xx xx xx xx  
00080Ar 2  xx xx xx xx  
000902r 2               
000902r 2               .segment "DICTIONARY"   ; the dictionary gets its own segment so that it uses all the space left in RAM
000000r 2  xx xx xx xx  dictionary: .res $1000
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
001000r 2               
001000r 2               cp_end = $7FFF          ; the dictionary ends at RAM end (everything else is before)
001000r 2               
001000r 2               cp0 = dictionary
001000r 2               bsize =     $ff
001000r 2               padoffset = $ff
001000r 2               
001000r 2               
001000r 2               
001000r 2               .segment "DATA"
000000r 2               
000000r 2               
000000r 2               
000000r 2               forth:
000000r 2                   .include "native_words.s"     ; Native Forth words. Starts with COLD
000000r 3               ; Low-level Forth word routines
000000r 3               ; Tali Forth 2 for the 65c02
000000r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
000000r 3               ; First version: 19. Jan 2014
000000r 3               ; This version: 03. Jan 2018
000000r 3               
000000r 3               ; This list is ordered alphabetically by the names of the words, not their
000000r 3               ; strings (so "!" is sorted as "STORE"). However, we start off with COLD,
000000r 3               ; ABORT, and QUIT as the natural start sequence. Each word has two special
000000r 3               ; status lines that begins with "; ## ", which allows auto-generation of the
000000r 3               ; WORDLIST.md file and other entries in the docs folder. Status entries are:
000000r 3               
000000r 3               ;       TBA --> fragment --> coded --> tested --> auto
000000r 3               
000000r 3               ; "Auto" means that the word is automatically tested by the test suite (good),
000000r 3               ; "tested" means that it was tested by hand in some way (okay), "coded" means
000000r 3               ; it hasn't been tested at all (bad). See the test suite for more details.
000000r 3               
000000r 3               ; ## COLD ( -- ) "Reset the Forth system"
000000r 3               ; ## "cold"  tested  Tali Forth
000000r 3               ;       """Reset the Forth system. Does not restart the kernel,
000000r 3               ;       use the 65c02 reset for that. Flows into ABORT.
000000r 3               ;       """
000000r 3               xt_cold:
000000r 3  D8                           cld
000001r 3               
000001r 3                               ; Set the OUTPUT vector to the default kernel_putc
000001r 3                               ; We do this really early so we can print error messages
000001r 3                               ; during debugging
000001r 3  A9 rr                        lda #<kernel_putc
000003r 3  85 rr                        sta output
000005r 3  A9 rr                        lda #>kernel_putc
000007r 3  85 rr                        sta output+1
000009r 3               
000009r 3                               ; Load all of the important zero page variables from ROM
000009r 3  A2 21                        ldx #cold_zp_table_end-cold_zp_table-1
00000Br 3               
00000Br 3               @load_zp_loop:
00000Br 3                               ; This loop loads them back to front. We can use X here
00000Br 3                               ; because Tali hasn't started using the stack yet.
00000Br 3  BD rr rr                     lda cold_zp_table,x
00000Er 3  95 rr                        sta cp,x
000010r 3  CA                           dex
000011r 3  D0 F8                        bne @load_zp_loop
000013r 3               
000013r 3                               ; Copy the 0th element.
000013r 3  AD rr rr                     lda cold_zp_table
000016r 3  85 rr                        sta cp
000018r 3                               ; Initialize 65c02 stack (Return Stack)
000018r 3  A2 rr                        ldx #rsp0
00001Ar 3  9A                           txs
00001Br 3               
00001Br 3                               ; Clear Data Stack. This is repeated in ABORT, but this way we
00001Br 3                               ; can load high-level words with EVALUATE
00001Br 3  A2 rr                        ldx #dsp0
00001Dr 3               
00001Dr 3               
00001Dr 3                               ; Initialize the user variables.
00001Dr 3  A0 31                        ldy #cold_user_table_end-cold_user_table-1
00001Fr 3  A9 00                        lda #0
000021r 3               
000021r 3               @load_user_vars_loop:
000021r 3                               ; Like the zero page variables, these are initialized
000021r 3                               ; back to front.
000021r 3  B9 rr rr                     lda cold_user_table,y
000024r 3  91 rr                        sta (up),y
000026r 3  88                           dey
000027r 3  D0 F8                        bne @load_user_vars_loop
000029r 3               
000029r 3                               ; Copy the 0th element.
000029r 3  AD rr rr                     lda cold_user_table
00002Cr 3  92 rr                        sta (up)
00002Er 3  20 rr rr                     jsr xt_cr
000031r 3               
000031r 3                               ; Define high-level words in forth_words.asm via EVALUATE. If
000031r 3                               ; you do not have any high-level words, this part can be
000031r 3                               ; commented out.
000031r 3  CA                           dex
000032r 3  CA                           dex
000033r 3  CA                           dex
000034r 3  CA                           dex
000035r 3               
000035r 3               
000035r 3                               ; start address goes NOS
000035r 3  A9 rr                        lda #<forth_words_start
000037r 3  95 02                        sta 2,x
000039r 3  A9 rr                        lda #>forth_words_start
00003Br 3  95 03                        sta 3,x
00003Dr 3               
00003Dr 3                               ; length goes TOS
00003Dr 3  A9 rr                        lda #<forth_words_end
00003Fr 3  38                           sec
000040r 3  E9 rr                        sbc #<forth_words_start
000042r 3  95 00                        sta 0,x
000044r 3               
000044r 3  A9 rr                        lda #>forth_words_end
000046r 3  E9 rr                        sbc #>forth_words_start
000048r 3  95 01                        sta 1,x
00004Ar 3               
00004Ar 3               
00004Ar 3  20 rr rr                     jsr xt_evaluate
00004Dr 3               
00004Dr 3                               ; Now define any user words via EVALUATE. If you do not have
00004Dr 3                               ; any user-defined words, this part can be commented out as
00004Dr 3                               ; well.
00004Dr 3  CA                           dex
00004Er 3  CA                           dex
00004Fr 3  CA                           dex
000050r 3  CA                           dex
000051r 3               
000051r 3               
000051r 3                               ; start address goes NOS
000051r 3  A9 rr                        lda #<user_words_start
000053r 3  95 02                        sta 2,x
000055r 3  A9 rr                        lda #>user_words_start
000057r 3  95 03                        sta 3,x
000059r 3               
000059r 3                               ; length goes TOS
000059r 3  A9 rr                        lda #<user_words_end
00005Br 3  38                           sec
00005Cr 3  E9 rr                        sbc #<user_words_start
00005Er 3  95 00                        sta 0,x
000060r 3               
000060r 3  A9 rr                        lda #>user_words_end
000062r 3  E9 rr                        sbc #>user_words_start
000064r 3  95 01                        sta 1,x
000066r 3               
000066r 3  20 rr rr                     jsr xt_evaluate
000069r 3               
000069r 3                               ; Initialize all of the history buffers by putting a zero in
000069r 3                               ; each length byte.
000069r 3  9C rr rr                     stz hist_buff
00006Cr 3  9C rr rr                     stz hist_buff+$80
00006Fr 3  9C rr rr                     stz hist_buff+$100
000072r 3  9C rr rr                     stz hist_buff+$180
000075r 3  9C rr rr                     stz hist_buff+$200
000078r 3  9C rr rr                     stz hist_buff+$280
00007Br 3  9C rr rr                     stz hist_buff+$300
00007Er 3  9C rr rr                     stz hist_buff+$380
000081r 3               
000081r 3               
000081r 3                               ; fall through to ABORT
000081r 3               
000081r 3               
000081r 3               ; ## ABORT ( -- ) "Reset the Data Stack and restart the CLI"
000081r 3               ; ## "abort"  tested  ANS core
000081r 3                       ; """https://forth-standard.org/standard/core/ABORT
000081r 3                       ; Clear Data Stack and continue into QUIT. We can jump here via
000081r 3                       ; subroutine if we want to because we are going to reset the 65c02's
000081r 3                       ; stack pointer (the Return Stack) anyway during QUIT. Note we don't
000081r 3                       ; actually delete the stuff on the Data Stack.
000081r 3                       ; """
000081r 3               xt_abort:
000081r 3  A2 rr                        ldx #dsp0
000083r 3               
000083r 3                               ; fall through to QUIT
000083r 3               
000083r 3               
000083r 3               ; ## QUIT ( -- ) "Reset the input and get new input"
000083r 3               ; ## "quit"  tested  ANS core
000083r 3                       ; """https://forth-standard.org/standard/core/QUIT
000083r 3                       ; Rest the input and start command loop
000083r 3                       ; """
000083r 3               
000083r 3               xt_quit:
000083r 3                               ; Clear the Return Stack. This is a little screwed up
000083r 3                               ; because the 65c02 can only set the Return Stack via X,
000083r 3                               ; which is our Data Stack pointer. The ANS specification
000083r 3                               ; demands, however, that ABORT reset the Data Stack pointer
000083r 3  8A                           txa             ; Save the DSP that we just defined
000084r 3  A2 rr                        ldx #rsp0
000086r 3  9A                           txs
000087r 3  AA                           tax             ; Restore the DSP. Dude, seriously.
000088r 3               
000088r 3                               ; make sure instruction pointer is empty
000088r 3  64 rr                        stz ip
00008Ar 3  64 rr                        stz ip+1
00008Cr 3               
00008Cr 3                               ; SOURCE-ID is zero (keyboard input)
00008Cr 3  64 rr                        stz insrc
00008Er 3  64 rr                        stz insrc+1
000090r 3               
000090r 3                               ; STATE is zero (interpret, not compile)
000090r 3  64 rr                        stz state
000092r 3  64 rr                        stz state+1
000094r 3               @get_line:
000094r 3  A9 rr                        lda #<buffer0   ; input buffer, this is paranoid
000096r 3  85 rr                        sta cib
000098r 3  A9 rr                        lda #>buffer0
00009Ar 3  85 rr                        sta cib+1
00009Cr 3               
00009Cr 3                               ; Size of current input buffer (CIB) is zero
00009Cr 3  64 rr                        stz ciblen
00009Er 3  64 rr                        stz ciblen+1
0000A0r 3               
0000A0r 3                               ; Accept a line from the current import source. This is how
0000A0r 3                               ; modern Forths to it.
0000A0r 3  20 rr rr                     jsr xt_refill           ; ( -- f )
0000A3r 3               
0000A3r 3                               ; Test flag: LSB of TOS
0000A3r 3  B5 00                        lda 0,x
0000A5r 3  D0 05                        bne @success
0000A7r 3               
0000A7r 3                               ; If REFILL returned a FALSE flag, something went wrong and we
0000A7r 3                               ; need to print an error message and reset the machine. We
0000A7r 3                               ; don't need to save TOS because we're going to clobber it
0000A7r 3                               ; anyway when we go back to ABORT.
0000A7r 3  A9 06                        lda #err_refill
0000A9r 3  4C rr rr                     jmp error
0000ACr 3               
0000ACr 3               @success:
0000ACr 3                               ; Assume we have successfully accepted a string of input from
0000ACr 3                               ; a source, with address cib and length of input in ciblen. We
0000ACr 3                               ; arrive here still with the TRUE flag from REFILL as TOS
0000ACr 3  E8                           inx                     ; drop
0000ADr 3  E8                           inx
0000AEr 3               
0000AEr 3                               ; Main compile/execute routine
0000AEr 3  20 rr rr                     jsr interpret
0000B1r 3               
0000B1r 3                               ; Test for Data Stack underflow. Tali Forth does not check for
0000B1r 3                               ; overflow because it is so rare
0000B1r 3  E0 rr                        cpx #dsp0
0000B3r 3  F0 05                        beq @stack_ok
0000B5r 3  90 03                        bcc @stack_ok           ; DSP must always be smaller than DSP0
0000B7r 3               
0000B7r 3  4C rr rr                     jmp underflow_error
0000BAr 3               
0000BAr 3               @stack_ok:
0000BAr 3                               ; Display system prompt if all went well. If we're interpreting,
0000BAr 3                               ; this is " ok", if we're compiling, it's " compiled". Note
0000BAr 3                               ; space at beginning of the string.
0000BAr 3  A5 rr                        lda state
0000BCr 3  F0 02                        beq @print
0000BEr 3               
0000BEr 3  A9 01                        lda #1                  ; number for "compile" string
0000C0r 3               @print:
0000C0r 3  20 rr rr                     jsr print_string
0000C3r 3               
0000C3r 3                               ; Awesome line, everybody! Now get the next one.
0000C3r 3  80 CF                        bra @get_line
0000C5r 3               
0000C5r 3               z_cold:
0000C5r 3               z_abort:
0000C5r 3               z_quit:         ; no RTS required
0000C5r 3               
0000C5r 3               
0000C5r 3               
0000C5r 3               ; This table holds all of the initial values for the variables in zero page.
0000C5r 3               ; This table is used by COLD.
0000C5r 3               cold_zp_table:
0000C5r 3  rr rr                .word cp0+256+1024      ; cp moved to make room for user vars and
0000C7r 3                                               ; block buffer
0000C7r 3  rr rr                .word dictionary_start  ; dp
0000C9r 3  00 00                .word 0                 ; workword
0000CBr 3  00 00                .word 0                 ; insrc (SOURCE-ID is 0 for keyboard)
0000CDr 3  rr rr                .word buffer0           ; cib
0000CFr 3  00 00                .word 0                 ; ciblen
0000D1r 3  00 00                .word 0                 ; toin
0000D3r 3  00 00                .word 0                 ; ip
0000D5r 3  rr rr                .word kernel_putc       ; output
0000D7r 3  rr rr                .word kernel_getc       ; input
0000D9r 3  00 00                .word 0                 ; havekey
0000DBr 3  00 00                .word 0                 ; state (0 = interpret)
0000DDr 3  0A 00                .word 10                ; base
0000DFr 3  14 00                .word 20                ; nc-limit
0000E1r 3  00 00                .word 0                 ; uf_strip (off by default)
0000E3r 3  rr rr                .word cp0               ; up (user vars put right at beginning of
0000E5r 3                                               ; available RAM)
0000E5r 3  00 00                .word 0                 ; status
0000E7r 3               cold_zp_table_end:
0000E7r 3               
0000E7r 3               ; No further ZP variables are initialized. The variables past this point are
0000E7r 3               ; all temporaries.
0000E7r 3               
0000E7r 3               ; This table holds the inital values for the user variables. This table is
0000E7r 3               ; used by COLD.
0000E7r 3               cold_user_table:
0000E7r 3  00 00                .word 0                         ; BLK
0000E9r 3  00 00                .word 0                         ; SCR
0000EBr 3  00                   .byte 0                         ; CURRENT = FORTH-WORDLIST
0000ECr 3  04                   .byte 4                         ; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
0000EDr 3  rr rr                .word dictionary_start          ; FORTH-WORDLIST
0000EFr 3  rr rr                .word editor_dictionary_start   ; EDITOR-WORDLIST
0000F1r 3               .ifdef TALI_OPTIONAL_ASSEMBLER
0000F1r 3  rr rr                .word assembler_dictionary_start ; ASSEMBLER-WORDLIST
0000F3r 3               .else
0000F3r 3                       .word 0
0000F3r 3               .endif
0000F3r 3  rr rr                .word root_dictionary_start     ; ROOT-WORDLIST
0000F5r 3  00 00 00 00          .word 0,0,0,0,0,0,0,0           ; User wordlists
0000F9r 3  00 00 00 00  
0000FDr 3  00 00 00 00  
000105r 3  01                   .byte 1                         ; #ORDER
000106r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0         ; search-order
00010Ar 3  00 00 00 00  
00010Er 3  00           
00010Fr 3  rr rr                .word cp0+256                   ; Address of buffer (right after USER vars)
000111r 3  00 00                .word 0                         ; block in buffer
000113r 3  00 00                .word 0                         ; buffer status (not in use)
000115r 3  rr rr                .word xt_block_word_error       ; block-read vector
000117r 3  rr rr                .word xt_block_word_error       ; block-write vector
000119r 3               cold_user_table_end:
000119r 3               
000119r 3               
000119r 3               ; ## ABORT_QUOTE ( "string" -- ) "If flag TOS is true, ABORT with message"
000119r 3               ; ## "abort""  tested  ANS core
000119r 3                       ; """https://forth-standard.org/standard/core/ABORTq
000119r 3                       ; Abort and print a string.
000119r 3                       ; """
000119r 3               
000119r 3               xt_abort_quote:
000119r 3                               ; save the string
000119r 3  20 rr rr                     jsr xt_s_quote          ; S"
00011Cr 3               
00011Cr 3                               ; compile run-time part
00011Cr 3  A0 rr                        ldy #>abort_quote_runtime
00011Er 3  A9 rr                        lda #<abort_quote_runtime
000120r 3  20 rr rr                     jsr cmpl_subroutine     ; may not be JMP as JSR/RTS
000123r 3               
000123r 3  60           z_abort_quote:  rts
000124r 3               
000124r 3               
000124r 3               abort_quote_runtime:
000124r 3                       ; """Runtime aspect of ABORT_QUOTE"""
000124r 3               
000124r 3                               ; We arrive here with ( f addr u )
000124r 3  B5 04                        lda 4,x
000126r 3  15 05                        ora 5,x
000128r 3  F0 09                        beq @done       ; if FALSE, we're done
00012Ar 3               
00012Ar 3                               ; We're true, so print string and ABORT. We follow Gforth
00012Ar 3                               ; in going to a new line after the string
00012Ar 3  20 rr rr                     jsr xt_type
00012Dr 3  20 rr rr                     jsr xt_cr
000130r 3  4C rr rr                     jmp xt_abort    ; not JSR, so never come back
000133r 3               @done:
000133r 3                               ; Drop three entries from the Data Stack
000133r 3  8A                           txa
000134r 3  18                           clc
000135r 3  69 06                        adc #6
000137r 3  AA                           tax
000138r 3               
000138r 3  60                           rts
000139r 3               
000139r 3               
000139r 3               
000139r 3               ; ## ABS ( n -- u ) "Return absolute value of a number"
000139r 3               ; ## "abs"  auto  ANS core
000139r 3                       ; """https://forth-standard.org/standard/core/ABS
000139r 3                       ; Return the absolute value of a number.
000139r 3                       ; """
000139r 3               
000139r 3               xt_abs:
000139r 3  20 rr rr                     jsr underflow_1
00013Cr 3               
00013Cr 3  B5 01                        lda 1,x
00013Er 3  10 0D                        bpl @done       ; positive number, easy money!
000140r 3               
000140r 3                               ; negative: calculate 0 - n
000140r 3  38                           sec
000141r 3  A9 00                        lda #0
000143r 3  F5 00                        sbc 0,x         ; LSB
000145r 3  95 00                        sta 0,x
000147r 3               
000147r 3  A9 00                        lda #0          ; MSB
000149r 3  F5 01                        sbc 1,x
00014Br 3  95 01                        sta 1,x
00014Dr 3               
00014Dr 3               @done:
00014Dr 3  60           z_abs:          rts
00014Er 3               
00014Er 3               
00014Er 3               
00014Er 3               ; ## ACCEPT ( addr n -- n ) "Receive a string of characters from the keyboard"
00014Er 3               ; ## "accept"  auto  ANS core
00014Er 3                       ; """https://forth-standard.org/standard/core/ACCEPT
00014Er 3                       ; Receive a string of at most n1 characters, placing them at
00014Er 3                       ; addr. Return the actual number of characters as n2. Characters
00014Er 3                       ; are echoed as they are received. ACCEPT is called by REFILL in
00014Er 3                       ; modern Forths.
00014Er 3                       ; """
00014Er 3               
00014Er 3               xt_accept:
00014Er 3  20 rr rr                     jsr underflow_2
000151r 3               
000151r 3                               ; Abort if we were asked to receive 0 chars
000151r 3  B5 00                        lda 0,x
000153r 3  15 01                        ora 1,x
000155r 3  D0 09                        bne @not_zero
000157r 3               
000157r 3  E8                           inx
000158r 3  E8                           inx
000159r 3  74 00                        stz 0,x
00015Br 3  74 01                        stz 1,x
00015Dr 3               
00015Dr 3  4C rr rr                     jmp accept_done
000160r 3               
000160r 3               @not_zero:
000160r 3  B5 00                        lda 0,x         ; number of chars to get in tmp2 ...
000162r 3  85 rr                        sta tmp2
000164r 3  64 rr                        stz tmp2+1      ; ... but we only accept max 255 chars
000166r 3               
000166r 3  B5 02                        lda 2,x         ; address of buffer is NOS, to tmp1
000168r 3  85 rr                        sta tmp1
00016Ar 3  B5 03                        lda 3,x
00016Cr 3  85 rr                        sta tmp1+1
00016Er 3               
00016Er 3  E8                           inx
00016Fr 3  E8                           inx
000170r 3               
000170r 3  A0 00                        ldy #0
000172r 3               
000172r 3                               ; Select the next history buffer. Clear bit 3 first (so overflow
000172r 3                               ; from bit 2 to 3 is OK)
000172r 3  A5 rr                        lda status
000174r 3  29 F7                        and #$f7
000176r 3               
000176r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
000176r 3  1A                           inc
000177r 3               
000177r 3                               ; Set bit 3 for detecting if CTRL-n has been pressed the first
000177r 3                               ; time. This bit will be cleared on the first CTRL-n or CTRL-p
000177r 3                               ; received and won't be used to calculate the history buffer
000177r 3                               ; offset.
000177r 3  09 08                        ora #$08
000179r 3  85 rr                        sta status
00017Br 3               
00017Br 3               accept_loop:
00017Br 3                               ; Out of the box, py65mon catches some CTRL sequences such as
00017Br 3                               ; CTRL-c. We also don't need to check for CTRL-l because a
00017Br 3                               ; vt100 terminal clears the screen automatically.
00017Br 3               
00017Br 3                               ; This is the internal version of KEY without all the mucking
00017Br 3                               ; about with the Data Stack while still using the input vector
00017Br 3  20 rr rr                     jsr key_a
00017Er 3               
00017Er 3                               ; We quit on both line feed and carriage return
00017Er 3  C9 0A                        cmp #AscLF
000180r 3  F0 20                        beq @eol
000182r 3  C9 0D                        cmp #AscCR
000184r 3  F0 1C                        beq @eol
000186r 3               
000186r 3                               ; BACKSPACE and DEL do the same thing for the moment
000186r 3  C9 08                        cmp #AscBS
000188r 3  F0 22                        beq @backspace
00018Ar 3  C9 7F                        cmp #AscDEL     ; (CTRL-h)
00018Cr 3  F0 1E                        beq @backspace
00018Er 3               
00018Er 3                               ; Check for CTRL-p and CTRL-n to recall input history
00018Er 3  C9 10                        cmp #AscCP
000190r 3  F0 36                        beq @ctrl_p
000192r 3  C9 0E                        cmp #AscCN
000194r 3  F0 44                        beq @ctrl_n
000196r 3               
000196r 3                               ; That's enough for now. Save and echo character.
000196r 3  91 rr                        sta (tmp1),y
000198r 3  C8                           iny
000199r 3               
000199r 3                               ; EMIT_A sidesteps all the fooling around with the Data Stack
000199r 3  20 rr rr                     jsr emit_a
00019Cr 3               
00019Cr 3  C4 rr                        cpy tmp2        ; reached character limit?
00019Er 3  D0 DB                        bne accept_loop       ; fall through if buffer limit reached
0001A0r 3  80 03                        bra @buffer_full
0001A2r 3               
0001A2r 3               @eol:
0001A2r 3  20 rr rr                     jsr xt_space    ; print final space
0001A5r 3               
0001A5r 3               @buffer_full:
0001A5r 3                               ; REFILL updates ciblen and toin, we don't need to do it here
0001A5r 3  94 00                        sty 0,x         ; Y contains number of chars accepted already
0001A7r 3  74 01                        stz 1,x         ; we only accept 256 chars
0001A9r 3               
0001A9r 3  4C rr rr                     jmp accept_done
0001ACr 3               
0001ACr 3               @backspace:
0001ACr 3                               ; Handle backspace and delete kex, which currently do the same
0001ACr 3                               ; thing
0001ACr 3  C0 00                        cpy #0          ; buffer empty?
0001AEr 3  D0 06                        bne @1
0001B0r 3               
0001B0r 3  A9 07                        lda #AscBELL    ; complain and don't delete beyond the start of line
0001B2r 3  20 rr rr                     jsr emit_a
0001B5r 3  C8                           iny
0001B6r 3               @1:
0001B6r 3  88                           dey
0001B7r 3  A9 08                        lda #AscBS      ; move back one
0001B9r 3  20 rr rr                     jsr emit_a
0001BCr 3  A9 20                        lda #AscSP      ; print a space (rubout)
0001BEr 3  20 rr rr                     jsr emit_a
0001C1r 3  A9 08                        lda #AscBS      ; move back over space
0001C3r 3  20 rr rr                     jsr emit_a
0001C6r 3               
0001C6r 3  80 B3                        bra accept_loop
0001C8r 3               
0001C8r 3               @ctrl_p:
0001C8r 3                               ; CTRL-p was pressed. Recall the previous input buffer.
0001C8r 3               
0001C8r 3                               ; Select the previous buffer
0001C8r 3  A5 rr                        lda status
0001CAr 3               
0001CAr 3                               ; Check for 0 (need to wrap back to 7)
0001CAr 3  29 07                        and #7
0001CCr 3  D0 08                        bne @ctrl_p_dec
0001CEr 3               
0001CEr 3                               ; We need to wrap back to 7.
0001CEr 3  A5 rr                        lda status
0001D0r 3  09 07                        ora #7
0001D2r 3  85 rr                        sta status
0001D4r 3  80 11                        bra @recall_history
0001D6r 3               
0001D6r 3               @ctrl_p_dec:
0001D6r 3                               ; It's safe to decrement the buffer index directly.
0001D6r 3  C6 rr                        dec status
0001D8r 3  80 0D                        bra @recall_history
0001DAr 3               
0001DAr 3               @ctrl_n:
0001DAr 3                               ; CTRL-n was pressed. Recall the next input buffer. Select
0001DAr 3                               ; the next buffer Check bit 3. If it's set, this is the first
0001DAr 3                               ; time CTRL-n has been pressed and we should select the CURRENT
0001DAr 3                               ; history buffer.
0001DAr 3  A9 08                        lda #$8
0001DCr 3  24 rr                        bit status
0001DEr 3  D0 07                        bne @recall_history
0001E0r 3               
0001E0r 3                               ; This isn't the first time CTRL-n has been pressed, select the
0001E0r 3                               ; next history buffer. Clear bit 3 first (so overflow is OK)
0001E0r 3  A5 rr                        lda status
0001E2r 3  29 F7                        and #$f7
0001E4r 3               
0001E4r 3                               ; Increment the buffer number (overflow from 7 to 0 OK)
0001E4r 3  1A                           inc
0001E5r 3               
0001E5r 3                               ; Bit 3 (if it got set by going from buffer 7 to 0) will
0001E5r 3                               ; be cleared below.
0001E5r 3  85 rr                        sta status
0001E7r 3               
0001E7r 3                               ; Falls through to @recall_history
0001E7r 3               
0001E7r 3               @recall_history:
0001E7r 3                               ; Clear bit 3 (first time ctrl-n recall) bit in status
0001E7r 3  A9 08                        lda #%00001000
0001E9r 3  14 rr                        trb status
0001EBr 3               
0001EBr 3  20 rr rr                     jsr total_recall
0001EEr 3               
0001EEr 3                               ; tmp3 now has the address of the previous history buffer.
0001EEr 3                               ; First byte of buffer is length. Clear the line by sending
0001EEr 3                               ; CR, Y spaces, then CR.
0001EEr 3  A9 0D                        lda #AscCR
0001F0r 3  20 rr rr                     jsr emit_a
0001F3r 3               
0001F3r 3               input_clear:
0001F3r 3  C0 00                        cpy #0
0001F5r 3  F0 08                        beq input_cleared
0001F7r 3               
0001F7r 3  A9 20                        lda #AscSP
0001F9r 3  20 rr rr                     jsr emit_a
0001FCr 3  88                           dey
0001FDr 3  80 F4                        bra input_clear
0001FFr 3               
0001FFr 3               input_cleared:
0001FFr 3  A9 0D                        lda #AscCR
000201r 3  20 rr rr                     jsr emit_a
000204r 3               
000204r 3                               ; Save the history length byte into histinfo+1
000204r 3                               ; ldy #0        ; Y is already 0 by clearing the line.
000204r 3  B1 rr                        lda (tmp3),y
000206r 3  85 rr                        sta status+1
000208r 3               
000208r 3                               ; Increment the tmp3 pointer so we can use ,y addressing
000208r 3                               ; on both tmp1 (the input buffer) and tmp3 (the history
000208r 3                               ; buffer)
000208r 3  E6 rr                        inc tmp3
00020Ar 3  D0 02                        bne @2           ; Increment the upper byte on carry.
00020Cr 3  E6 rr                        inc tmp3+1
00020Er 3               @2:
00020Er 3                               ; Copy the history buffer into the input buffer,
00020Er 3                               ; sending the characters to the output as we go.
00020Er 3  A9 0D                        lda #AscCR
000210r 3  20 rr rr                     jsr emit_a
000213r 3               
000213r 3               @history_loop:
000213r 3                               ; See if we have reached the end of the history buffer.
000213r 3  C4 rr                        cpy status+1
000215r 3  D0 03                        bne @3
000217r 3  4C rr rr                     jmp accept_loop       ; Needs a long jump
00021Ar 3               @3:
00021Ar 3                               ; See if we have reached the end of the input buffer.
00021Ar 3                               ; (only comparing to lower byte as we currently limit
00021Ar 3                               ; to 255 characters max)
00021Ar 3  C4 rr                        cpy tmp2
00021Cr 3  F0 0A                        beq @hist_filled_buffer
00021Er 3               
00021Er 3                               ; Copy a character and echo.
00021Er 3  B1 rr                        lda (tmp3),y
000220r 3  91 rr                        sta (tmp1),y
000222r 3  20 rr rr                     jsr emit_a
000225r 3               
000225r 3                               ; Move to the next character.
000225r 3  C8                           iny
000226r 3  80 EB                        bra @history_loop
000228r 3               
000228r 3               @hist_filled_buffer:
000228r 3                               ; We don't want a history recall to EOL our buffer,
000228r 3                               ; so back up one character and return to editing.
000228r 3  88                           dey
000229r 3  4C rr rr                     jmp accept_loop
00022Cr 3               accept_done:
00022Cr 3               @done:
00022Cr 3                               ; Copy the input buffer into the currently
00022Cr 3                               ; selected history buffer.
00022Cr 3  20 rr rr                     jsr total_recall
00022Fr 3  85 rr                        sta status+1
000231r 3               
000231r 3                               ; Also save it in the first buffer byte.
000231r 3  A0 00                        ldy #0
000233r 3  91 rr                        sta (tmp3),y
000235r 3               
000235r 3                               ; Move path the count to the data bytes
000235r 3  E6 rr                        inc tmp3
000237r 3  D0 02                        bne @4           ; Increment the upper byte on carry.
000239r 3  E6 rr                        inc tmp3+1
00023Br 3               @4:
00023Br 3                               ; Copy the characters from the input buffer to the
00023Br 3                               ; history buffer.
00023Br 3               
00023Br 3               @save_history_loop:
00023Br 3  C4 rr                        cpy status+1
00023Dr 3  F0 07                        beq @save_history_done
00023Fr 3               
00023Fr 3  B1 rr                        lda (tmp1),y
000241r 3  91 rr                        sta (tmp3),y
000243r 3  C8                           iny
000244r 3  80 F5                        bra @save_history_loop
000246r 3               
000246r 3               @save_history_done:
000246r 3               z_accept:
000246r 3  60                           rts
000247r 3               
000247r 3               total_recall:
000247r 3                       ; """Internal subroutine for ACCEPT that recalls history entry"""
000247r 3               
000247r 3                               ; Generate the address of the buffer in tmp3. Start with the
000247r 3                               ; base address.
000247r 3  A9 rr                        lda #<hist_buff
000249r 3  85 rr                        sta tmp3
00024Br 3  A9 rr                        lda #>hist_buff
00024Dr 3  85 rr                        sta tmp3+1
00024Fr 3               
00024Fr 3                               ; This is a bit annoying as some bits go into each byte.
00024Fr 3                               ; .....xxx gets put into address like ......xx x.......
00024Fr 3  A5 rr                        lda status
000251r 3  6A                           ror
000252r 3  29 03                        and #3
000254r 3  18                           clc
000255r 3  65 rr                        adc tmp3+1
000257r 3  85 rr                        sta tmp3+1
000259r 3               
000259r 3  A5 rr                        lda status
00025Br 3  6A                           ror             ; Rotate through carry into msb.
00025Cr 3  6A                           ror
00025Dr 3  29 80                        and #$80
00025Fr 3  18                           clc
000260r 3  65 rr                        adc tmp3
000262r 3  85 rr                        sta tmp3
000264r 3  90 02                        bcc @1           ; Increment the upper byte on carry.
000266r 3  E6 rr                        inc tmp3+1
000268r 3               @1:
000268r 3                               ; Save the current length of the input buffer in
000268r 3                               ; histinfo+1 temporarily.  Reduce to 127 if larger.
000268r 3  98                           tya
000269r 3  C9 80                        cmp #$80
00026Br 3  90 02                        bcc @2
00026Dr 3  A9 7F                        lda #$7F
00026Fr 3               @2:
00026Fr 3  60                           rts
000270r 3               
000270r 3               
000270r 3               
000270r 3               
000270r 3               
000270r 3               ; ## ACTION_OF ( "name" -- xt ) "Get named deferred word's xt"
000270r 3               ; ## "action-of"  auto  ANS core ext
000270r 3                       ; """http://forth-standard.org/standard/core/ACTION-OF"""
000270r 3               
000270r 3               xt_action_of:
000270r 3                               ; This is a state aware word with differet behavior
000270r 3                               ; when used while compiling vs interpreting.
000270r 3                               ; Check STATE
000270r 3  A5 rr                        lda state
000272r 3  05 rr                        ora state+1
000274r 3  F0 0C                        beq @interpreting
000276r 3               
000276r 3               @compiling:
000276r 3                               ; Run ['] to compile the xt of the next word
000276r 3                               ; as a literal.
000276r 3  20 rr rr                     jsr xt_bracket_tick
000279r 3               
000279r 3                               ; Postpone DEFER@ by compiling a JSR to it.
000279r 3  A0 rr                        ldy #>xt_defer_fetch
00027Br 3  A9 rr                        lda #<xt_defer_fetch
00027Dr 3  20 rr rr                     jsr cmpl_subroutine
000280r 3  80 06                        bra @done
000282r 3               
000282r 3               @interpreting:
000282r 3  20 rr rr                     jsr xt_tick
000285r 3  20 rr rr                     jsr xt_defer_fetch
000288r 3               
000288r 3               @done:
000288r 3  60           z_action_of:           rts
000289r 3               
000289r 3               
000289r 3               
000289r 3               ; ## AGAIN ( addr -- ) "Code backwards branch to address left by BEGIN"
000289r 3               ; ## "again"  tested  ANS core ext
000289r 3                       ; """https://forth-standard.org/standard/core/AGAIN"""
000289r 3               
000289r 3               xt_again:
000289r 3  20 rr rr                     jsr underflow_1
00028Cr 3               
00028Cr 3                               ; Add the opcode for a JMP. We use JMP instead of BRA
00028Cr 3                               ; so we have the range and don't have to calculate the
00028Cr 3                               ; offset.
00028Cr 3  A0 00                        ldy #0
00028Er 3  A9 4C                        lda #$4C        ; JMP
000290r 3  91 rr                        sta (cp),y
000292r 3  C8                           iny
000293r 3               
000293r 3  B5 00                        lda 0,x         ; LSB of address
000295r 3  91 rr                        sta (cp),y
000297r 3  C8                           iny
000298r 3               
000298r 3  B5 01                        lda 1,x         ; MSB of address
00029Ar 3  91 rr                        sta (cp),y
00029Cr 3  C8                           iny
00029Dr 3               
00029Dr 3                               ; Allot the space we just used
00029Dr 3  98                           tya
00029Er 3  18                           clc
00029Fr 3  65 rr                        adc cp
0002A1r 3  85 rr                        sta cp
0002A3r 3  90 02                        bcc @done
0002A5r 3  E6 rr                        inc cp+1
0002A7r 3               @done:
0002A7r 3  E8                           inx
0002A8r 3  E8                           inx
0002A9r 3               
0002A9r 3  60           z_again:        rts
0002AAr 3               
0002AAr 3               
0002AAr 3               
0002AAr 3               ; ## ALIGN ( -- ) "Make sure CP is aligned on word size"
0002AAr 3               ; ## "align"  auto  ANS core
0002AAr 3                       ; """https://forth-standard.org/standard/core/ALIGN
0002AAr 3                       ; On a 8-bit machine, this does nothing. ALIGNED uses this
0002AAr 3                       ; routine as well, and also does nothing
0002AAr 3                       ; """
0002AAr 3               
0002AAr 3               ; ## ALIGNED ( addr -- addr ) "Return the first aligned address"
0002AAr 3               ; ## "aligned"  auto  ANS core
0002AAr 3                       ; """https://forth-standard.org/standard/core/ALIGNED"""
0002AAr 3               
0002AAr 3               xt_align:
0002AAr 3               xt_aligned:
0002AAr 3               z_align:
0002AAr 3  60           z_aligned:      rts             ; stripped out during native compile
0002ABr 3               
0002ABr 3               
0002ABr 3               
0002ABr 3               ; ## ALLOT ( n -- ) "Reserve or release memory"
0002ABr 3               ; ## "allot"  auto  ANS core
0002ABr 3                       ; """https://forth-standard.org/standard/core/ALLOT
0002ABr 3                       ; Reserve a certain number of bytes (not cells) or release them.
0002ABr 3                       ; If n = 0, do nothing. If n is negative, release n bytes, but only
0002ABr 3                       ; to the beginning of the Dictionary. If n is positive (the most
0002ABr 3                       ; common case), reserve n bytes, but not past the end of the
0002ABr 3                       ; Dictionary. See http://forth-standard.org/standard/core/ALLOT
0002ABr 3                       ; """
0002ABr 3               
0002ABr 3               xt_allot:
0002ABr 3  20 rr rr                     jsr underflow_1
0002AEr 3               
0002AEr 3                               ; Releasing memory is going to be a very rare operation,
0002AEr 3                               ; so we check for it at the beginning and try to make
0002AEr 3                               ; the most common case as fast as possible
0002AEr 3  B5 01                        lda 1,x
0002B0r 3  30 22                        bmi @release
0002B2r 3               
0002B2r 3                               ; Common case: We are reserving memory, not releasing it
0002B2r 3  18                           clc
0002B3r 3  A5 rr                        lda cp
0002B5r 3  75 00                        adc 0,x
0002B7r 3  85 rr                        sta cp
0002B9r 3               
0002B9r 3  A5 rr                        lda cp+1
0002BBr 3  75 01                        adc 1,x
0002BDr 3  85 rr                        sta cp+1
0002BFr 3               
0002BFr 3                               ; Wait, did we just grant more space than we have? This is
0002BFr 3                               ; a check we only do here, not for other situations like cmpl_a
0002BFr 3                               ; where smaller amounts are reserved.
0002BFr 3  A0 FF                        ldy #<cp_end
0002C1r 3  C4 rr                        cpy cp
0002C3r 3  A9 7F                        lda #>cp_end
0002C5r 3  E5 rr                        sbc cp+1
0002C7r 3  B0 48                        bcs @done               ; we're fine.
0002C9r 3               
0002C9r 3                               ; Oops, that was too much, we're beyond the end of
0002C9r 3                               ; legal Dictionary RAM. Reduce to max memory and report
0002C9r 3                               ; an error
0002C9r 3  84 rr                        sty cp                  ; still #<cp_end
0002CBr 3  A9 7F                        lda #>cp_end
0002CDr 3  85 rr                        sta cp+1
0002CFr 3               
0002CFr 3  A9 00                        lda #err_allot
0002D1r 3  4C rr rr                     jmp error
0002D4r 3               
0002D4r 3               @release:
0002D4r 3                  		; The ANS standard doesn't really say what to do if too much
0002D4r 3                               ; memory is freed ("negatively alloted"). In fact, there isn't
0002D4r 3                               ; even an official test. Gforth is little help either. The good
0002D4r 3                               ; news is, this is going to be a rare case. We want to use as
0002D4r 3                               ; few bytes as possible.
0002D4r 3               
0002D4r 3                               ; What we do is let the user free anything up to the beginning
0002D4r 3                               ; of the RAM area assigned to the Dicionary (CP0), but at
0002D4r 3                               ; their own risk. This means that the Dictionary pointer DP
0002D4r 3                               ; might end up pointing to garbage. However, an attempt to
0002D4r 3                               ; free more than RAM than CP0 will lead to CP being set to CP0,
0002D4r 3                               ; the DP pointing to the last word in RAM (should be DROP) and
0002D4r 3                               ; an error message.
0002D4r 3               
0002D4r 3                               ; We arrive here with ( n ) which is negative. First step,
0002D4r 3                               ; subtract the number TOS from the CP for a new CP
0002D4r 3  CA                           dex
0002D5r 3  CA                           dex
0002D6r 3  A5 rr                        lda cp
0002D8r 3  95 00                        sta 0,x
0002DAr 3  A5 rr                        lda cp+1
0002DCr 3  95 01                        sta 1,x
0002DEr 3               
0002DEr 3  20 rr rr                     jsr xt_plus                     ; new CP is now TOS
0002E1r 3               
0002E1r 3                               ; Second step, see if we've gone too far. We compare the new
0002E1r 3                               ; CP on TOS (which, if we've really screwed up, might be
0002E1r 3                               ; negative) with CP0. This is a signed comparison
0002E1r 3  CA                           dex
0002E2r 3  CA                           dex                             ; new CP now NOS
0002E3r 3  A9 rr                        lda #<cp0
0002E5r 3  95 00                        sta 0,x
0002E7r 3  A9 rr                        lda #>cp0
0002E9r 3  95 01                        sta 1,x                         ; CP0 is TOS
0002EBr 3               
0002EBr 3  20 rr rr                     jsr compare_16bit               ; still ( CP CP0 )
0002EEr 3               
0002EEr 3                               ; If CP (NOS) is smaller than CP0 (TOS), we're in trouble.
0002EEr 3                               ; This means we want Z=1 or N=1
0002EEr 3  F0 17                        beq @nega_done
0002F0r 3  30 15                        bmi @nega_done
0002F2r 3               
0002F2r 3                               ; Yep, we're in trouble. Set CP to CP0, set DP to the first
0002F2r 3                               ; word in ROM (should be DROP), and abort with an error
0002F2r 3  A9 rr                        lda #<cp0
0002F4r 3  85 rr                        sta cp
0002F6r 3  A9 rr                        lda #>cp0
0002F8r 3  85 rr                        sta cp+1
0002FAr 3               
0002FAr 3  A9 rr                        lda #<dictionary_start
0002FCr 3  85 rr                        sta dp
0002FEr 3  A9 rr                        lda #>dictionary_start
000300r 3  85 rr                        sta dp+1
000302r 3               
000302r 3  A9 0A                        lda #err_negallot
000304r 3  4C rr rr                     jmp error
000307r 3               
000307r 3               @nega_done:
000307r 3                               ; Save new CP, which is NOS
000307r 3  B5 02                        lda 2,x
000309r 3  85 rr                        sta cp
00030Br 3  B5 03                        lda 3,x
00030Dr 3  85 rr                        sta cp+1
00030Fr 3               
00030Fr 3  E8                           inx
000310r 3  E8                           inx                     ; drop through to @done
000311r 3               @done:
000311r 3  E8                           inx
000312r 3  E8                           inx
000313r 3               z_allot:
000313r 3  60                           rts
000314r 3               
000314r 3               
000314r 3               
000314r 3               ; ## ALLOW_NATIVE ( -- ) "Flag last word to allow native compiling"
000314r 3               ; ## "allow-native"  auto  Tali Forth
000314r 3               xt_allow_native:
000314r 3  20 rr rr                     jsr current_to_dp
000317r 3  A0 01                        ldy #1          ; offset for status byte
000319r 3  B1 rr                        lda (dp),y
00031Br 3  29 F5                        and #$ff-NN-AN  ; AN and NN flag is clear.
00031Dr 3  91 rr                        sta (dp),y
00031Fr 3               z_allow_native:
00031Fr 3  60                           rts
000320r 3               
000320r 3               
000320r 3               ; ## ALSO ( -- ) "Make room in the search order for another wordlist"
000320r 3               ; ## "also"  auto  ANS search ext
000320r 3                       ; """http://forth-standard.org/standard/search/ALSO"""
000320r 3               xt_also:
000320r 3  20 rr rr                     jsr xt_get_order
000323r 3  20 rr rr                     jsr xt_over
000326r 3  20 rr rr                     jsr xt_swap
000329r 3  20 rr rr                     jsr xt_one_plus
00032Cr 3  20 rr rr                     jsr xt_set_order
00032Fr 3               
00032Fr 3  60           z_also:         rts
000330r 3               
000330r 3               
000330r 3               ; ## ALWAYS_NATIVE ( -- ) "Flag last word as always natively compiled"
000330r 3               ; ## "always-native"  auto  Tali Forth
000330r 3               xt_always_native:
000330r 3  20 rr rr                     jsr current_to_dp
000333r 3  A0 01                        ldy #1          ; offset for status byte
000335r 3  B1 rr                        lda (dp),y
000337r 3  09 02                        ora #AN         ; Make sure AN flag is set
000339r 3  29 F7                        and #$ff-NN     ; and NN flag is clear.
00033Br 3  91 rr                        sta (dp),y
00033Dr 3               z_always_native:
00033Dr 3  60                           rts
00033Er 3               
00033Er 3               
00033Er 3               ; ## AND ( n n -- n ) "Logically AND TOS and NOS"
00033Er 3               ; ## "and"  auto  ANS core
00033Er 3                       ; """https://forth-standard.org/standard/core/AND"""
00033Er 3               xt_and:
00033Er 3  20 rr rr                     jsr underflow_2
000341r 3               
000341r 3  B5 00                        lda 0,x
000343r 3  35 02                        and 2,x
000345r 3  95 02                        sta 2,x
000347r 3               
000347r 3  B5 01                        lda 1,x
000349r 3  35 03                        and 3,x
00034Br 3  95 03                        sta 3,x
00034Dr 3               
00034Dr 3  E8                           inx
00034Er 3  E8                           inx
00034Fr 3               
00034Fr 3  60           z_and:          rts
000350r 3               
000350r 3               
000350r 3               ; ## ASSEMBLER_WORDLIST ( -- u ) "WID for the Assembler wordlist"
000350r 3               ; ## "assembler-wordlist"  tested  Tali Assembler
000350r 3                       ; """ Commonly used like `assembler-wordlist >order` to add the
000350r 3                       ; assembler words to the search order so they can be used.
000350r 3                       ; See the tutorial on Wordlists and the Search Order for
000350r 3                       ; more information.
000350r 3                       ;
000350r 3                       ; This is a dummy entry, the code is shared with TWO
000350r 3                       ; """
000350r 3               
000350r 3               
000350r 3               ; ## AT_XY ( n m -- ) "Move cursor to position given"
000350r 3               ; ## "at-xy"  tested  ANS facility
000350r 3                       ; """https://forth-standard.org/standard/facility/AT-XY
000350r 3                       ; On an ANSI compatible terminal, place cursor at row n colum m.
000350r 3                       ; ANSI code is ESC[<n>;<m>H
000350r 3                       ;
000350r 3                       ; Do not use U. to print the numbers because the
000350r 3                       ; trailing space will not work with xterm
000350r 3                       ; """
000350r 3               xt_at_xy:
000350r 3  20 rr rr                     jsr underflow_2
000353r 3               
000353r 3  A9 1B                        lda #AscESC
000355r 3  20 rr rr                     jsr emit_a
000358r 3  A9 5B                        lda #$5B        ; ASCII for "["
00035Ar 3  20 rr rr                     jsr emit_a
00035Dr 3  20 rr rr                     jsr print_u
000360r 3  A9 3B                        lda #$3B        ; ASCII for ";"
000362r 3  20 rr rr                     jsr emit_a
000365r 3  20 rr rr                     jsr print_u
000368r 3  A9 48                        lda #'H'
00036Ar 3  20 rr rr                     jsr emit_a
00036Dr 3               
00036Dr 3  60           z_at_xy:        rts
00036Er 3               
00036Er 3               
00036Er 3               ; ## BACKSLASH ( -- ) "Ignore rest of line"
00036Er 3               ; ## "\"  auto  ANS core ext
00036Er 3                       ; """https://forth-standard.org/standard/core/bs"""
00036Er 3               xt_backslash:
00036Er 3  A5 rr                        lda ciblen
000370r 3  85 rr                        sta toin
000372r 3  A5 rr                        lda ciblen+1
000374r 3  85 rr                        sta toin+1
000376r 3               
000376r 3  60           z_backslash:    rts
000377r 3               
000377r 3               
000377r 3               ; ## BASE ( -- addr ) "Push address of radix base to stack"
000377r 3               ; ## "base"  auto  ANS core
000377r 3                       ; """https://forth-standard.org/standard/core/BASE
000377r 3                       ; The ANS Forth standard sees the base up to 36, so we can cheat and
000377r 3                       ; ingore the MSB
000377r 3                       ; """
000377r 3               xt_base:
000377r 3  CA                           dex
000378r 3  CA                           dex
000379r 3  A9 rr                        lda #<base
00037Br 3  95 00                        sta 0,x         ; LSB
00037Dr 3  74 01                        stz 1,x         ; MSB is always 0
00037Fr 3               
00037Fr 3  60           z_base:         rts
000380r 3               
000380r 3               
000380r 3               ; ## BEGIN ( -- addr ) "Mark entry point for loop"
000380r 3               ; ## "begin"  auto  ANS core
000380r 3                       ; """https://forth-standard.org/standard/core/BEGIN
000380r 3                       ;
000380r 3                       ; This is just an immediate version of here which could just
000380r 3                       ; as well be coded in Forth as
000380r 3                       ;       : BEGIN HERE ; IMMEDIATE COMPILE-ONLY
000380r 3                       ; Since this is a compiling word, we don't care that much about
000380r 3                       ; about speed
000380r 3                       ; """
000380r 3               
000380r 3               xt_begin:
000380r 3  20 rr rr                     jsr xt_here
000383r 3  60           z_begin:        rts
000384r 3               
000384r 3               
000384r 3               
000384r 3               ; ## BELL ( -- ) "Emit ASCII BELL"
000384r 3               ; ## "bell"  tested  Tali Forth
000384r 3               xt_bell:
000384r 3  A9 07                        lda #7          ; ASCII value for BELl
000386r 3  20 rr rr                     jsr emit_a
000389r 3               
000389r 3  60           z_bell:         rts
00038Ar 3               
00038Ar 3               
00038Ar 3               ; ## BL ( -- c ) "Push ASCII value of SPACE to stack"
00038Ar 3               ; ## "bl"  auto  ANS core
00038Ar 3                       ; """https://forth-standard.org/standard/core/BL"""
00038Ar 3               
00038Ar 3               xt_bl:
00038Ar 3  CA                           dex
00038Br 3  CA                           dex
00038Cr 3  A9 20                        lda #AscSP
00038Er 3  95 00                        sta 0,x
000390r 3  74 01                        stz 1,x
000392r 3               
000392r 3  60           z_bl:           rts
000393r 3               
000393r 3               
000393r 3               ; ## BLK ( -- addr ) "Push address of block being interpreted"
000393r 3               ; ## "block"  auto  ANS block
000393r 3                       ; """https://forth-standard.org/standard/block/BLK"""
000393r 3               xt_blk:
000393r 3                               ; BLK is at UP + blk_offset
000393r 3  CA                           dex
000394r 3  CA                           dex
000395r 3  18                           clc
000396r 3  A5 rr                        lda up
000398r 3  69 00                        adc #blk_offset ; Add offset
00039Ar 3  95 00                        sta 0,x
00039Cr 3  A5 rr                        lda up+1
00039Er 3  69 00                        adc #0          ; Adding carry
0003A0r 3  95 01                        sta 1,x
0003A2r 3               
0003A2r 3  60           z_blk:          rts
0003A3r 3               
0003A3r 3               
0003A3r 3               ; ## BLKBUFFER ( -- addr ) "Push address of block buffer"
0003A3r 3               ; ## "blkbuffer"  auto  Tali block
0003A3r 3               xt_blkbuffer:
0003A3r 3                               ; blkbuffer address is at UP + blkbuffer_offset.
0003A3r 3                               ; Unlike some of the other user variables, we actually
0003A3r 3                               ; want to push the address stored here, which will
0003A3r 3                               ; point to somewhere outside of the user variables.
0003A3r 3  CA                           dex
0003A4r 3  CA                           dex
0003A5r 3                               ; Put the address on the stack.
0003A5r 3  A0 28                        ldy #blkbuffer_offset
0003A7r 3  B1 rr                        lda (up),y
0003A9r 3  95 00                        sta 0,x
0003ABr 3  C8                           iny             ; Move along to the next byte
0003ACr 3  B1 rr                        lda (up),y
0003AEr 3  95 01                        sta 1,x
0003B0r 3               
0003B0r 3  60           z_blkbuffer:    rts
0003B1r 3               
0003B1r 3               
0003B1r 3               ; ## BLOCK ( u -- a-addr ) "Fetch a block into a buffer"
0003B1r 3               ; ## "block"  auto  ANS block
0003B1r 3                       ; """https://forth-standard.org/standard/block/BLOCK"""
0003B1r 3               
0003B1r 3               xt_block:
0003B1r 3               
0003B1r 3                               ; See if the block requested is the same as the one we
0003B1r 3                               ; currently have in the buffer. Check the LSB.
0003B1r 3  A0 2A                        ldy #buffblocknum_offset
0003B3r 3  B1 rr                        lda (up),y
0003B5r 3  D5 00                        cmp 0,x
0003B7r 3  D0 0F                        bne @not_in_buffer
0003B9r 3               
0003B9r 3                               ; Check the MSB.
0003B9r 3  C8                           iny
0003BAr 3  B1 rr                        lda (up),y
0003BCr 3  D5 01                        cmp 1,x
0003BEr 3  D0 08                        bne @not_in_buffer
0003C0r 3               
0003C0r 3                               ; The block is in the buffer. See if the buffer is in use.
0003C0r 3  A0 2C                        ldy #buffstatus_offset
0003C2r 3  B1 rr                        lda (up),y
0003C4r 3  29 01                        and #1          ; Check the in-use flag (bit 0)
0003C6r 3  D0 30                        bne @done       ; It's already in the buffer and in use.
0003C8r 3                                               ; @done will replace the block# with the
0003C8r 3                                               ; buffer address.
0003C8r 3               @not_in_buffer:
0003C8r 3                               ; Check the buffer status
0003C8r 3  A0 2C                        ldy #buffstatus_offset
0003CAr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
0003CCr 3  C9 03                        cmp #3          ; LSB is needed.
0003CEr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
0003D0r 3               
0003D0r 3                               ; We need to save the block.
0003D0r 3  20 rr rr                     jsr xt_blkbuffer
0003D3r 3  20 rr rr                     jsr xt_buffblocknum
0003D6r 3  20 rr rr                     jsr xt_fetch
0003D9r 3  20 rr rr                     jsr xt_block_write
0003DCr 3               
0003DCr 3               @buffer_available:
0003DCr 3                               ; Save the block number.
0003DCr 3  A0 2A                        ldy #buffblocknum_offset
0003DEr 3  B5 00                        lda 0,x
0003E0r 3  91 rr                        sta (up),y
0003E2r 3  C8                           iny
0003E3r 3  B5 01                        lda 1,x
0003E5r 3  91 rr                        sta (up),y
0003E7r 3               
0003E7r 3                               ; Get the requested block.
0003E7r 3  20 rr rr                     jsr xt_blkbuffer
0003EAr 3  20 rr rr                     jsr xt_swap
0003EDr 3  20 rr rr                     jsr xt_block_read
0003F0r 3               
0003F0r 3                               ; Mark the buffer as clean and in-use.
0003F0r 3  A9 01                        lda #1
0003F2r 3  A0 2C                        ldy #buffstatus_offset
0003F4r 3  91 rr                        sta (up),y
0003F6r 3               
0003F6r 3                               ; Make room on the stack for the return address.
0003F6r 3  CA                           dex
0003F7r 3  CA                           dex
0003F8r 3               
0003F8r 3               @done:
0003F8r 3                               ; It's in the buffer. Return the buffer address.
0003F8r 3  A0 28                        ldy #blkbuffer_offset
0003FAr 3  B1 rr                        lda (up),y
0003FCr 3  95 00                        sta 0,x
0003FEr 3  C8                           iny
0003FFr 3  B1 rr                        lda (up),y
000401r 3  95 01                        sta 1,x
000403r 3               
000403r 3  60           z_block:        rts
000404r 3               
000404r 3               
000404r 3               
000404r 3               ; ## BLOCK_RAMDRIVE_INIT ( u -- ) "Create a ramdrive for blocks"
000404r 3               ; ## "block-ramdrive-init"  auto  Tali block
000404r 3                       ; """Create a RAM drive, with the given number of
000404r 3                       ; blocks, in the dictionary along with setting up the block words to
000404r 3                       ; use it.  The read/write routines do not provide bounds checking.
000404r 3                       ; Expected use: `4 block-ramdrive-init` ( to create blocks 0-3 )
000404r 3                       ; """
000404r 3               
000404r 3               xt_block_ramdrive_init:
000404r 3  20 rr rr                     jsr underflow_1
000407r 3               
000407r 3                               ; Store the string to run here as a string literal.
000407r 3                               ; See SLITERAL for the format information. This way, we
000407r 3                               ; don't have the words defined below in the Dictionary until
000407r 3                               ; we really use them.
000407r 3  4C rr rr                     jmp @after_ramdrive_code
00040Ar 3               
00040Ar 3               @ramdrive_code:
00040Ar 3  62 61 73 65          .byte "base @ swap decimal"
00040Er 3  20 40 20 73  
000412r 3  77 61 70 20  
00041Dr 3  20 31 30 32          .byte " 1024 *" ; ( Calculate how many bytes are needed for numblocks blocks )
000421r 3  34 20 2A     
000424r 3  20 64 75 70          .byte " dup"    ; ( Save a copy for formatting it at the end )
000428r 3  20 62 75 66          .byte " buffer: ramdrive" ; ( Create ramdrive )
00042Cr 3  66 65 72 3A  
000430r 3  20 72 61 6D  
000439r 3                       ; ( These routines just copy between the buffer and the ramdrive blocks )
000439r 3  20 3A 20 62          .byte " : block-read-ramdrive"  ; ( addr u -- )
00043Dr 3  6C 6F 63 6B  
000441r 3  2D 72 65 61  
00044Fr 3  20 72 61 6D          .byte " ramdrive swap 1024 * + swap 1024 move ;"
000453r 3  64 72 69 76  
000457r 3  65 20 73 77  
000477r 3  20 3A 20 62          .byte " : block-write-ramdrive" ; ( addr u -- )
00047Br 3  6C 6F 63 6B  
00047Fr 3  2D 77 72 69  
00048Er 3  20 72 61 6D          .byte " ramdrive swap 1024 * + 1024 move ;"
000492r 3  64 72 69 76  
000496r 3  65 20 73 77  
0004B1r 3  20 27 20 62          .byte " ' block-read-ramdrive block-read-vector !" ; ( Replace I/O vectors )
0004B5r 3  6C 6F 63 6B  
0004B9r 3  2D 72 65 61  
0004DBr 3  20 27 20 62          .byte " ' block-write-ramdrive block-write-vector !"
0004DFr 3  6C 6F 63 6B  
0004E3r 3  2D 77 72 69  
000507r 3  20 72 61 6D          .byte " ramdrive swap blank base !"
00050Br 3  64 72 69 76  
00050Fr 3  65 20 73 77  
000522r 3               
000522r 3               @after_ramdrive_code:
000522r 3  20 rr rr                     jsr sliteral_runtime
000525r 3               
000525r 3  rr rr 18 01  .word @ramdrive_code, @after_ramdrive_code-@ramdrive_code
000529r 3               
000529r 3                               ; The address and length of the ramdrive code is now on the
000529r 3                               ; stack. Call EVALUATE to run it.
000529r 3  20 rr rr                     jsr xt_evaluate
00052Cr 3               
00052Cr 3               z_block_ramdrive_init:
00052Cr 3  60                           rts
00052Dr 3               
00052Dr 3               
00052Dr 3               
00052Dr 3               ; ## BLOCK_READ ( addr u -- ) "Read a block from storage (deferred word)"
00052Dr 3               ; ## "block-read"  auto  Tali block
00052Dr 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00052Dr 3                       ; with their own version to read a block from storage.
00052Dr 3                       ; The stack parameters are ( buffer_address block# -- ).
00052Dr 3                       ; """
00052Dr 3               xt_block_read:
00052Dr 3                               ; Execute the BLOCK-READ-VECTOR
00052Dr 3  A0 2E                        ldy #blockread_offset
00052Fr 3  B1 rr                        lda (up),y
000531r 3  85 rr                        sta tmp1
000533r 3  C8                           iny
000534r 3  B1 rr                        lda (up),y
000536r 3  85 rr                        sta tmp1+1
000538r 3               
000538r 3  6C rr rr                     jmp (tmp1)
00053Br 3               
00053Br 3               z_block_read:   ; No RTS needed
00053Br 3               
00053Br 3               
00053Br 3               ; ## BLOCK_READ_VECTOR ( -- addr ) "Address of the block-read vector"
00053Br 3               ; ## "block-read-vector"  auto  Tali block
00053Br 3                       ; """BLOCK-READ is a vectored word that the user needs to override
00053Br 3                       ; with their own version to read a block from storage.
00053Br 3                       ; This word gives the address of the vector so it can be replaced.
00053Br 3                       ; """
00053Br 3               xt_block_read_vector:
00053Br 3                               ; Get the BLOCK-READ-VECTOR address
00053Br 3  CA                           dex
00053Cr 3  CA                           dex
00053Dr 3  18                           clc
00053Er 3  A5 rr                        lda up
000540r 3  69 2E                        adc #blockread_offset
000542r 3  95 00                        sta 0,x
000544r 3  A5 rr                        lda up+1
000546r 3  69 00                        adc #0          ; Add carry
000548r 3  95 01                        sta 1,x
00054Ar 3               
00054Ar 3               z_block_read_vector:
00054Ar 3  60                           rts
00054Br 3               
00054Br 3               
00054Br 3               ; This is the default error message the vectored words BLOCK-READ and
00054Br 3               ; BLOCK-WRITE start with. This word is not included in the dictionary.
00054Br 3               xt_block_word_error:
00054Br 3  A9 0C                        lda #err_blockwords
00054Dr 3  4C rr rr                     jmp error       ; no RTS needed
000550r 3               z_block_word_error:
000550r 3               
000550r 3               ; ## BLOCK_WRITE ( addr u -- ) "Write a block to storage (deferred word)"
000550r 3               ; ## "block-write"  auto  Tali block
000550r 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
000550r 3                       ; with their own version to write a block to storage.
000550r 3                       ; The stack parameters are ( buffer_address block# -- ).
000550r 3                       ; """
000550r 3               xt_block_write:
000550r 3                               ; Execute the BLOCK-READ-VECTOR
000550r 3  A0 30                        ldy #blockwrite_offset
000552r 3  B1 rr                        lda (up),y
000554r 3  85 rr                        sta tmp1
000556r 3  C8                           iny
000557r 3  B1 rr                        lda (up),y
000559r 3  85 rr                        sta tmp1+1
00055Br 3  6C rr rr                     jmp (tmp1)
00055Er 3               
00055Er 3               z_block_write:  ; No RTS needed
00055Er 3               
00055Er 3               
00055Er 3               ; ## BLOCK_WRITE_VECTOR ( -- addr ) "Address of the block-write vector"
00055Er 3               ; ## "block-write-vector"  auto  Tali block
00055Er 3                       ; """BLOCK-WRITE is a vectored word that the user needs to override
00055Er 3                       ; with their own version to write a block to storage.
00055Er 3                       ; This word gives the address of the vector so it can be replaced.
00055Er 3                       ; """
00055Er 3               xt_block_write_vector:
00055Er 3                               ; Get the BLOCK-WRITE-VECTOR address
00055Er 3  CA                           dex
00055Fr 3  CA                           dex
000560r 3  18                           clc
000561r 3  A5 rr                        lda up
000563r 3  69 30                        adc #blockwrite_offset
000565r 3  95 00                        sta 0,x
000567r 3  A5 rr                        lda up+1
000569r 3  69 00                        adc #0          ; Add carry
00056Br 3  95 01                        sta 1,x
00056Dr 3               
00056Dr 3               z_block_write_vector:
00056Dr 3  60                           rts
00056Er 3               
00056Er 3               
00056Er 3               ; ## BOUNDS ( addr u -- addr+u addr ) "Prepare address for looping"
00056Er 3               ; ## "bounds"  auto  Gforth
00056Er 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Memory-Blocks.html
00056Er 3                       ; Given a string, return the correct Data Stack parameters for
00056Er 3                       ; a DO/LOOP loop over its characters. This is realized as
00056Er 3                       ; OVER + SWAP in Forth, but we do it a lot faster in assembler
00056Er 3                       ; """
00056Er 3               xt_bounds:
00056Er 3  20 rr rr                     jsr underflow_2
000571r 3               
000571r 3  18                           clc
000572r 3  B5 00                        lda 0,x                 ; LSB u
000574r 3  B4 02                        ldy 2,x                 ; LSB addr
000576r 3  75 02                        adc 2,x
000578r 3  95 02                        sta 2,x                 ; LSB addr+u
00057Ar 3  94 00                        sty 0,x
00057Cr 3               
00057Cr 3  B5 01                        lda 1,x                 ; MSB u
00057Er 3  B4 03                        ldy 3,x                 ; MSB addr
000580r 3  75 03                        adc 3,x
000582r 3  95 03                        sta 3,x                 ; MSB addr+u
000584r 3  94 01                        sty 1,x
000586r 3               
000586r 3  60           z_bounds:       rts
000587r 3               
000587r 3               
000587r 3               ; ## BRACKET_CHAR ( "c" -- ) "Compile character"
000587r 3               ; ## "[char]"  auto  ANS core
000587r 3                       ; """https://forth-standard.org/standard/core/BracketCHAR
000587r 3                       ; Compile the ASCII value of a character as a literal. This is an
000587r 3                       ; immediate, compile-only word.
000587r 3                       ;
000587r 3                       ; A definition given in
000587r 3                       ; http://forth-standard.org/standard/implement is
000587r 3                       ; : [CHAR]  CHAR POSTPONE LITERAL ; IMMEDIATE
000587r 3                       ; """
000587r 3               xt_bracket_char:
000587r 3  20 rr rr                     jsr xt_char
00058Ar 3  20 rr rr                     jsr xt_literal
00058Dr 3  60           z_bracket_char: rts
00058Er 3               
00058Er 3               
00058Er 3               ; ## BRACKET_TICK ( -- ) "Store xt of following word during compilation"
00058Er 3               ; ## "[']"  auto  ANS core
00058Er 3                       ; """https://forth-standard.org/standard/core/BracketTick"""
00058Er 3               xt_bracket_tick:
00058Er 3  20 rr rr                     jsr xt_tick
000591r 3  20 rr rr                     jsr xt_literal
000594r 3  60           z_bracket_tick: rts
000595r 3               
000595r 3               
000595r 3               ; ## BUFFBLOCKNUM ( -- addr ) "Push address of variable holding block in buffer"
000595r 3               ; ## "buffblocknum"  auto  Tali block
000595r 3               xt_buffblocknum:
000595r 3                               ; BUFFBLOCKNUM is at UP + buffblocknum_offset
000595r 3  CA                           dex
000596r 3  CA                           dex
000597r 3  18                           clc
000598r 3  A5 rr                        lda up
00059Ar 3  69 2A                        adc #buffblocknum_offset        ; Add offset
00059Cr 3  95 00                        sta 0,x
00059Er 3  A5 rr                        lda up+1
0005A0r 3  69 00                        adc #0                          ; Adding carry
0005A2r 3  95 01                        sta 1,x
0005A4r 3               
0005A4r 3  60           z_buffblocknum: rts
0005A5r 3               
0005A5r 3               
0005A5r 3               ; ## BUFFER ( u -- a-addr ) "Get a buffer for a block"
0005A5r 3               ; ## "buffer"  auto  ANS block
0005A5r 3                       ; """https://forth-standard.org/standard/block/BUFFER"""
0005A5r 3               
0005A5r 3               xt_buffer:
0005A5r 3                               ; Check the buffer status
0005A5r 3  A0 2C                        ldy #buffstatus_offset
0005A7r 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
0005A9r 3  C9 03                        cmp #3          ; LSB is needed.
0005ABr 3  D0 0C                        bne @buffer_available ; Unused or not dirty = available
0005ADr 3               
0005ADr 3                               ; We need to save the block.
0005ADr 3  20 rr rr                     jsr xt_blkbuffer
0005B0r 3  20 rr rr                     jsr xt_buffblocknum
0005B3r 3  20 rr rr                     jsr xt_fetch
0005B6r 3  20 rr rr                     jsr xt_block_write
0005B9r 3               
0005B9r 3               @buffer_available:
0005B9r 3                               ; Save the block number.
0005B9r 3  A0 2A                        ldy #buffblocknum_offset
0005BBr 3  B5 00                        lda 0,x
0005BDr 3  91 rr                        sta (up),y
0005BFr 3  C8                           iny
0005C0r 3  B5 01                        lda 1,x
0005C2r 3  91 rr                        sta (up),y
0005C4r 3               
0005C4r 3                               ; Mark the buffer as clean and in-use.
0005C4r 3  A9 01                        lda #1
0005C6r 3  A0 2C                        ldy #buffstatus_offset
0005C8r 3  91 rr                        sta (up),y
0005CAr 3               
0005CAr 3               @done:
0005CAr 3                               ; Return the buffer address.
0005CAr 3  A0 28                        ldy #blkbuffer_offset
0005CCr 3  B1 rr                        lda (up),y
0005CEr 3  95 00                        sta 0,x
0005D0r 3  C8                           iny
0005D1r 3  B1 rr                        lda (up),y
0005D3r 3  95 01                        sta 1,x
0005D5r 3               
0005D5r 3  60           z_buffer:       rts
0005D6r 3               
0005D6r 3               
0005D6r 3               
0005D6r 3               ; ## BUFFER_COLON ( u "<name>" -- ; -- addr ) "Create an uninitialized buffer"
0005D6r 3               ; ## "buffer:"  auto  ANS core ext
0005D6r 3                               ; """https://forth-standard.org/standard/core/BUFFERColon
0005D6r 3                               ; Create a buffer of size u that puts its address on the stack
0005D6r 3                               ; when its name is used.
0005D6r 3                               ; """
0005D6r 3               xt_buffer_colon:
0005D6r 3  20 rr rr                     jsr xt_create
0005D9r 3  20 rr rr                     jsr xt_allot
0005DCr 3  60           z_buffer_colon: rts
0005DDr 3               
0005DDr 3               
0005DDr 3               ; ## BUFFSTATUS ( -- addr ) "Push address of variable holding buffer status"
0005DDr 3               ; ## "buffstatus"  auto  Tali block
0005DDr 3               xt_buffstatus:
0005DDr 3                               ; BUFFSTATUS is at UP + buffstatus_offset
0005DDr 3  CA                           dex
0005DEr 3  CA                           dex
0005DFr 3  18                           clc
0005E0r 3  A5 rr                        lda up
0005E2r 3  69 2C                        adc #buffstatus_offset  ; Add offset
0005E4r 3  95 00                        sta 0,x
0005E6r 3  A5 rr                        lda up+1
0005E8r 3  69 00                        adc #0                  ; Adding carry
0005EAr 3  95 01                        sta 1,x
0005ECr 3               
0005ECr 3  60           z_buffstatus:   rts
0005EDr 3               
0005EDr 3               
0005EDr 3               ; ## BYE ( -- ) "Break"
0005EDr 3               ; ## "bye"  tested  ANS tools ext
0005EDr 3                       ; """https://forth-standard.org/standard/tools/BYE"""
0005EDr 3               
0005EDr 3               xt_bye:
0005EDr 3                               ;brk
0005EDr 3  4C rr rr                     jmp platform_bye
0005F0r 3               z_bye:          ;rts             ; never reached
0005F0r 3               
0005F0r 3               
0005F0r 3               
0005F0r 3               ; ## C_COMMA ( c -- ) "Store one byte/char in the Dictionary"
0005F0r 3               ; ## "c,"  auto  ANS core
0005F0r 3                       ; """https://forth-standard.org/standard/core/CComma"""
0005F0r 3               
0005F0r 3               xt_c_comma:
0005F0r 3  20 rr rr                     jsr underflow_1
0005F3r 3               
0005F3r 3  B5 00                        lda 0,x
0005F5r 3  20 rr rr                     jsr cmpl_a
0005F8r 3               
0005F8r 3  E8                           inx
0005F9r 3  E8                           inx
0005FAr 3               
0005FAr 3  60           z_c_comma:      rts
0005FBr 3               
0005FBr 3               
0005FBr 3               
0005FBr 3               ; ## C_FETCH ( addr -- c ) "Get a character/byte from given address"
0005FBr 3               ; ## "c@"  auto  ANS core
0005FBr 3                       ; """https://forth-standard.org/standard/core/CFetch"""
0005FBr 3               xt_c_fetch:
0005FBr 3  20 rr rr                     jsr underflow_1
0005FEr 3               
0005FEr 3  A1 00                        lda (0,x)
000600r 3  95 00                        sta 0,x
000602r 3  74 01                        stz 1,x         ; Ignore LSB
000604r 3               
000604r 3  60           z_c_fetch:      rts
000605r 3               
000605r 3               
000605r 3               ; ## C_STORE ( c addr -- ) "Store character at address given"
000605r 3               ; ## "c!"  auto  ANS core
000605r 3                       ; """https://forth-standard.org/standard/core/CStore"""
000605r 3               xt_c_store:
000605r 3  20 rr rr                     jsr underflow_2
000608r 3               
000608r 3  B5 02                        lda 2,x
00060Ar 3  81 00                        sta (0,x)
00060Cr 3               
00060Cr 3  E8                           inx
00060Dr 3  E8                           inx
00060Er 3  E8                           inx
00060Fr 3  E8                           inx
000610r 3               
000610r 3  60           z_c_store:      rts
000611r 3               
000611r 3               
000611r 3               ; ## CASE (C: -- 0) ( -- ) "Conditional flow control"
000611r 3               ; ## "case"  auto  ANS core ext
000611r 3                       ; """http://forth-standard.org/standard/core/CASE
000611r 3                       ;
000611r 3                       ; This is a dummy header, CASE shares the actual code with ZERO.
000611r 3                       ; """
000611r 3               
000611r 3               
000611r 3               ; ## CELL_PLUS ( u -- u ) "Add cell size in bytes"
000611r 3               ; ## "cell+"  auto  ANS core
000611r 3                       ; """https://forth-standard.org/standard/core/CELLPlus
000611r 3                       ; Add the number of bytes ("address units") that one cell needs.
000611r 3                       ; Since this is an 8 bit machine with 16 bit cells, we add two bytes.
000611r 3                       ; """
000611r 3               
000611r 3               xt_cell_plus:
000611r 3  20 rr rr                     jsr underflow_1
000614r 3               
000614r 3  F6 00                        inc 0,x
000616r 3  D0 02                        bne @1
000618r 3  F6 01                        inc 1,x
00061Ar 3               @1:
00061Ar 3  F6 00                        inc 0,x
00061Cr 3  D0 02                        bne @done
00061Er 3  F6 01                        inc 1,x
000620r 3               @done:
000620r 3  60           z_cell_plus:    rts
000621r 3               
000621r 3               
000621r 3               
000621r 3               ; ## CELLS ( u -- u ) "Convert cells to size in bytes"
000621r 3               ; ## "cells"  auto  ANS core
000621r 3                       ; """https://forth-standard.org/standard/core/CELLS
000621r 3                       ;
000621r 3                       ; Dummy entry for the CELLS word, the code is the same as for
000621r 3                       ; 2*, which is where the header directs us to
000621r 3                       ; """
000621r 3               
000621r 3               
000621r 3               ; ## CHAR ( "c" -- u ) "Convert character to ASCII value"
000621r 3               ; ## "char"  auto  ANS core
000621r 3                       ; """https://forth-standard.org/standard/core/CHAR"""
000621r 3               
000621r 3               xt_char:
000621r 3                               ; get character from string, returns ( addr u )
000621r 3  20 rr rr                     jsr xt_parse_name
000624r 3               
000624r 3                               ; if we got back a zero, we have a problem
000624r 3  B5 00                        lda 0,x
000626r 3  15 01                        ora 1,x
000628r 3  D0 05                        bne @not_empty
00062Ar 3               
00062Ar 3  A9 05                        lda #err_noname
00062Cr 3  4C rr rr                     jmp error
00062Fr 3               
00062Fr 3               @not_empty:
00062Fr 3  E8                           inx             ; drop number of characters, leave addr
000630r 3  E8                           inx
000631r 3  A1 00                        lda (0,x)       ; get character (equivalent to C@)
000633r 3  95 00                        sta 0,x
000635r 3  74 01                        stz 1,x         ; MSB is always zero
000637r 3               
000637r 3  60           z_char:         rts
000638r 3               
000638r 3               
000638r 3               
000638r 3               ; ## CHAR_PLUS ( addr -- addr+1 ) "Add the size of a character unit to address"
000638r 3               ; ## "char+"  auto  ANS core
000638r 3                       ; """https://forth-standard.org/standard/core/CHARPlus
000638r 3                       ;
000638r 3                       ; This is a dummy entry, the code is shared with ONE_PLUS
000638r 3                       ; """
000638r 3               
000638r 3               
000638r 3               ; ## CHARS ( n -- n ) "Number of bytes that n chars need"
000638r 3               ; ## "chars"  auto  ANS core
000638r 3                       ; """https://forth-standard.org/standard/core/CHARS
000638r 3                       ; Return how many address units n chars are. Since this is an 8 bit
000638r 3                       ; machine, this does absolutely nothing and is included for
000638r 3                       ; compatibility with other Forth versions
000638r 3                       ; """
000638r 3               
000638r 3               xt_chars:
000638r 3                               ; Checking for underflow seems a bit stupid because this
000638r 3                               ; routine does nothing on this machine. However, the user
000638r 3                               ; should be warned that there is something wrong with the
000638r 3                               ; code if this occurs.
000638r 3  20 rr rr                     jsr underflow_1
00063Br 3               
00063Br 3  60           z_chars:        rts
00063Cr 3               
00063Cr 3               
00063Cr 3               ; ## CLEAVE ( addr u -- addr2 u2 addr1 u1 ) "Split off word from string"
00063Cr 3               ; ## "cleave"  auto  Tali Forth
00063Cr 3               
00063Cr 3                       ; """Given a range of memory with words delimited by whitespace,return
00063Cr 3                       ; the first word at the top of the stack and the rest of the word
00063Cr 3                       ; following it.
00063Cr 3                       ;
00063Cr 3                       ; Example:
00063Cr 3                       ; s" w1 w2 w3" cleave  -> "w2 w3" "w1"
00063Cr 3                       ; s" w1" cleave        -> "" "w1"
00063Cr 3                       ;
00063Cr 3                       ; Since it will be used in loops a lot, we want it to work in pure
00063Cr 3                       ; assembler and be as fast as we can make it. Calls PARSE-NAME so we
00063Cr 3                       ; strip leading delimiters.
00063Cr 3                       ; """
00063Cr 3               
00063Cr 3               xt_cleave:
00063Cr 3  20 rr rr                     jsr underflow_2
00063Fr 3               
00063Fr 3                               ; We arrive here with ( addr u ). We need to strip any leading
00063Fr 3                               ; spaces by hand: PARSE-NAME does do that, but it doesn't
00063Fr 3                               ; remember how many spaces were stripped. This means we can't
00063Fr 3                               ; calculate the length of the remainder. Fortunately, Tali
00063Fr 3                               ; Forth has just the word we need for this:
00063Fr 3  20 rr rr                     jsr xt_minus_leading    ; -LEADING ( addr u )
000642r 3               
000642r 3                               ; The main part we can turn over to PARSE-NAME, except that we
000642r 3                               ; have a string ( addr u ) and not stuff in the input buffer.
000642r 3                               ; We get around this by cheating: We place ( addr u ) in the
000642r 3                               ; input buffer and then call PARSE-NAME.
000642r 3  20 rr rr                     jsr xt_input_to_r       ; save old imput state
000645r 3               
000645r 3  B5 00                        lda 0,x         ; u is new ciblen
000647r 3  85 rr                        sta ciblen
000649r 3  B5 01                        lda 1,x
00064Br 3  85 rr                        sta ciblen+1
00064Dr 3               
00064Dr 3  B5 02                        lda 2,x         ; addr is new cib
00064Fr 3  85 rr                        sta cib
000651r 3  B5 03                        lda 3,x
000653r 3  85 rr                        sta cib+1
000655r 3               
000655r 3  64 rr                        stz toin        ; >IN pointer is zero
000657r 3  64 rr                        stz toin+1
000659r 3               
000659r 3                               ; PARSE-NAME gives us back the substring of the first word
000659r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u addr-s u-s )
00065Cr 3               
00065Cr 3                               ; If we were given an empty string, then we're done. It's the
00065Cr 3                               ; resposibility of the user to catch this as a sign to end the
00065Cr 3                               ; any loop
00065Cr 3  B5 00                        lda 0,x
00065Er 3  15 01                        ora 1,x
000660r 3  F0 23                        beq @done
000662r 3               
000662r 3                               ; Now we have to adjust the original string
000662r 3  B5 04                        lda 4,x         ; LSB of original u
000664r 3  38                           sec
000665r 3  F5 00                        sbc 0,x
000667r 3  95 04                        sta 4,x
000669r 3               
000669r 3  B5 05                        lda 5,x         ; MSB of original u
00066Br 3  F5 01                        sbc 1,x
00066Dr 3  95 05                        sta 5,x
00066Fr 3               
00066Fr 3  B5 06                        lda 6,x         ; LSB of original addr
000671r 3  18                           clc
000672r 3  75 00                        adc 0,x
000674r 3  95 06                        sta 6,x
000676r 3               
000676r 3  B5 07                        lda 7,x         ; MSB of original addr
000678r 3  75 01                        adc 1,x
00067Ar 3  95 07                        sta 7,x
00067Cr 3               
00067Cr 3                               ; There is one small problem: PARSE-NAME will probably have
00067Cr 3                               ; left the string with the rest of the words with leading
00067Cr 3                               ; delimiters. We use our magic -LEADING again
00067Cr 3  20 rr rr                     jsr xt_two_swap         ; ( addr-s u-s addr u )
00067Fr 3  20 rr rr                     jsr xt_minus_leading
000682r 3  20 rr rr                     jsr xt_two_swap         ; ( addr u addr-s u-s )
000685r 3               @done:
000685r 3                               ; Restore input
000685r 3  20 rr rr                     jsr xt_r_to_input
000688r 3               
000688r 3  60           z_cleave:       rts
000689r 3               
000689r 3               
000689r 3               
000689r 3               ; ## CMOVE ( addr1 addr2 u -- ) "Copy bytes going from low to high"
000689r 3               ; ## "cmove"  auto  ANS string
000689r 3                       ; """https://forth-standard.org/standard/string/CMOVE
000689r 3                       ; Copy u bytes from addr1 to addr2, going low to high (addr2 is
000689r 3                       ; larger than addr1). Based on code in Leventhal, Lance A.
000689r 3                       ; "6502 Assembly Language Routines", p. 201, where it is called
000689r 3                       ; "move left".
000689r 3                       ;
000689r 3                       ; There are no official tests for this word.
000689r 3                       ; """
000689r 3               
000689r 3               xt_cmove:
000689r 3  20 rr rr                     jsr underflow_3
00068Cr 3               
00068Cr 3                               ; move destination address to where we can work with it
00068Cr 3  B5 02                        lda 2,x
00068Er 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
000690r 3  B5 03                        lda 3,x
000692r 3  85 rr                        sta tmp2+1
000694r 3               
000694r 3                               ; move source address to where we can work with it
000694r 3  B5 04                        lda 4,x
000696r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
000698r 3  B5 05                        lda 5,x
00069Ar 3  85 rr                        sta tmp1+1
00069Cr 3               
00069Cr 3  A0 00                        ldy #0
00069Er 3  B5 01                        lda 1,x         ; number of whole pages to move
0006A0r 3  F0 0F                        beq @dopartial
0006A2r 3               
0006A2r 3               @page:
0006A2r 3  B1 rr                        lda (tmp1),y
0006A4r 3  91 rr                        sta (tmp2),y
0006A6r 3  C8                           iny
0006A7r 3  D0 F9                        bne @page
0006A9r 3               
0006A9r 3  E6 rr                        inc tmp1+1
0006ABr 3  E6 rr                        inc tmp2+1
0006ADr 3  D6 01                        dec 1,x
0006AFr 3  D0 F1                        bne @page
0006B1r 3               
0006B1r 3               @dopartial:
0006B1r 3  B5 00                        lda 0,x         ; length of last page
0006B3r 3  F0 09                        beq @done
0006B5r 3               
0006B5r 3               @partial:
0006B5r 3  B1 rr                        lda (tmp1),y
0006B7r 3  91 rr                        sta (tmp2),y
0006B9r 3  C8                           iny
0006BAr 3               
0006BAr 3  D6 00                        dec 0,x
0006BCr 3  D0 F7                        bne @partial
0006BEr 3               
0006BEr 3               @done:          ; clear the stack
0006BEr 3  8A                           txa
0006BFr 3  18                           clc
0006C0r 3  69 06                        adc #6
0006C2r 3  AA                           tax
0006C3r 3               
0006C3r 3  60           z_cmove:        rts
0006C4r 3               
0006C4r 3               
0006C4r 3               
0006C4r 3               ; ## CMOVE_UP ( add1 add2 u -- ) "Copy bytes from high to low"
0006C4r 3               ; ## "cmove>"  auto  ANS string
0006C4r 3                       ; """https://forth-standard.org/standard/string/CMOVEtop
0006C4r 3                       ; Based on code in Leventhal, Lance A. "6502 Assembly Language
0006C4r 3                       ; Routines", p. 201, where it is called "move right".
0006C4r 3                       ;
0006C4r 3                       ; There are no official tests for this word.
0006C4r 3                       ; """
0006C4r 3               
0006C4r 3               xt_cmove_up:
0006C4r 3  20 rr rr                     jsr underflow_3
0006C7r 3               
0006C7r 3                               ; Move destination address to where we can work with it
0006C7r 3  B5 02                        lda 2,x
0006C9r 3  85 rr                        sta tmp2        ; use tmp2 because easier to remember
0006CBr 3  B5 03                        lda 3,x
0006CDr 3  18                           clc
0006CEr 3  75 01                        adc 1,x
0006D0r 3  85 rr                        sta tmp2+1      ; point to last page of destination
0006D2r 3               
0006D2r 3                               ; Move source address to where we can work with it
0006D2r 3  B5 04                        lda 4,x
0006D4r 3  85 rr                        sta tmp1        ; use tmp1 because easier to remember
0006D6r 3  B5 05                        lda 5,x
0006D8r 3  18                           clc
0006D9r 3  75 01                        adc 1,x
0006DBr 3  85 rr                        sta tmp1+1      ; point to last page of source
0006DDr 3  F6 01                        inc 1,x         ; allows us to use bne with dec 1,x below
0006DFr 3               
0006DFr 3                               ; Move the last partial page first
0006DFr 3  B4 00                        ldy 0,x         ; length of last page
0006E1r 3  F0 0E                        beq @nopartial
0006E3r 3               
0006E3r 3               @outerloop:
0006E3r 3  88                           dey
0006E4r 3  F0 07                        beq @finishpage
0006E6r 3               
0006E6r 3               @innerloop:
0006E6r 3  B1 rr                        lda (tmp1),y
0006E8r 3  91 rr                        sta (tmp2),y
0006EAr 3  88                           dey
0006EBr 3  D0 F9                        bne @innerloop
0006EDr 3               
0006EDr 3               @finishpage:
0006EDr 3  B2 rr                        lda (tmp1)      ; handle y = 0 separately
0006EFr 3  92 rr                        sta (tmp2)
0006F1r 3               
0006F1r 3               @nopartial:
0006F1r 3  C6 rr                        dec tmp1+1      ; back up to previous pages
0006F3r 3  C6 rr                        dec tmp2+1
0006F5r 3  D6 01                        dec 1,x
0006F7r 3  D0 EA                        bne @outerloop
0006F9r 3               @done:
0006F9r 3                               ; clear up the stack and leave
0006F9r 3  8A                           txa
0006FAr 3  18                           clc
0006FBr 3  69 06                        adc #6
0006FDr 3  AA                           tax
0006FEr 3               
0006FEr 3  60           z_cmove_up:     rts
0006FFr 3               
0006FFr 3               
0006FFr 3               
0006FFr 3               ; ## COLON ( "name" -- ) "Start compilation of a new word"
0006FFr 3               ; ## ":"  auto  ANS core
0006FFr 3                       ; """https://forth-standard.org/standard/core/Colon
0006FFr 3                       ;
0006FFr 3                       ; Use the CREATE routine and fill in the rest by hand.
0006FFr 3                       ; """
0006FFr 3               
0006FFr 3               xt_colon:
0006FFr 3                               ; If we're already in the compile state, complain
0006FFr 3                               ; and quit
0006FFr 3  A5 rr                        lda state
000701r 3  05 rr                        ora state+1
000703r 3  F0 05                        beq @1
000705r 3               
000705r 3  A9 07                        lda #err_state
000707r 3  4C rr rr                     jmp error
00070Ar 3               @1:
00070Ar 3                               ; switch to compile state
00070Ar 3  C6 rr                        dec state
00070Cr 3  C6 rr                        dec state+1
00070Er 3               
00070Er 3                               ; Set bit 6 in status to tell ";" and RECURSE this is a normal
00070Er 3                               ; word
00070Er 3  A9 40                        lda #%01000000
000710r 3  04 rr                        tsb status
000712r 3               
000712r 3                               ; CREATE is going to change the DP to point to the new word's
000712r 3                               ; header. While this is fine for (say) variables, it would mean
000712r 3                               ; that FIND-NAME etc would find a half-finished word when
000712r 3                               ; looking in the Dictionary. To prevent this, we save the old
000712r 3                               ; version of DP and restore it later. The new DP is placed in
000712r 3                               ; the variable WORKWORD until we're finished with a SEMICOLON.
000712r 3  20 rr rr                     jsr current_to_dp
000715r 3  A5 rr                        lda dp+1            ; CREATE uses a lot of variables
000717r 3  48                           pha
000718r 3  A5 rr                        lda dp
00071Ar 3  48                           pha
00071Br 3               
00071Br 3                               ; Tell create not to print warning for duplicate name.
00071Br 3  A9 80                        lda #%10000000
00071Dr 3  04 rr                        tsb status
00071Fr 3               
00071Fr 3  20 rr rr                     jsr xt_create
000722r 3               
000722r 3                               ; Get the nt (not the xt!) of the new word as described above.
000722r 3                               ; Only COLON, SEMICOLON and RECURSE get to access WORKWORD
000722r 3  20 rr rr                     jsr current_to_dp   ; This might be able to be omitted
000725r 3  A5 rr                        lda dp
000727r 3  85 rr                        sta workword
000729r 3  A5 rr                        lda dp+1
00072Br 3  85 rr                        sta workword+1
00072Dr 3               
00072Dr 3                               ; Restore original DP
00072Dr 3  68                           pla
00072Er 3  85 rr                        sta dp
000730r 3  68                           pla
000731r 3  85 rr                        sta dp+1
000733r 3  20 rr rr                     jsr dp_to_current
000736r 3               
000736r 3                               ; CREATE includes a subroutine jump to DOVAR by default. We
000736r 3                               ; back up three bytes and overwrite that.
000736r 3  A5 rr                        lda cp
000738r 3  38                           sec
000739r 3  E9 03                        sbc #3
00073Br 3  85 rr                        sta cp
00073Dr 3  B0 02                        bcs @done
00073Fr 3  C6 rr                        dec cp+1
000741r 3               @done:
000741r 3  60           z_colon:        rts
000742r 3               
000742r 3               
000742r 3               ; ## COLON_NONAME ( -- ) "Start compilation of a new word""
000742r 3               ; ## ":NONAME"  auto  ANS core
000742r 3                       ; """https://forth-standard.org/standard/core/ColonNONAME
000742r 3                       ; Compile a word with no nt.  ";" will put its xt on the stack.
000742r 3                       ; """
000742r 3               
000742r 3               xt_colon_noname:
000742r 3                               ; If we're already in the compile state, complain
000742r 3                               ; and quit
000742r 3  A5 rr                        lda state
000744r 3  05 rr                        ora state+1
000746r 3  F0 05                        beq @1
000748r 3               
000748r 3  A9 07                        lda #err_state
00074Ar 3  4C rr rr                     jmp error
00074Dr 3               @1:
00074Dr 3                               ; switch to compile state
00074Dr 3  C6 rr                        dec state
00074Fr 3  C6 rr                        dec state+1
000751r 3               
000751r 3                               ; Clear bit 6 in status to tell ";" and RECURSE this is
000751r 3                               ; a :NONAME word.
000751r 3  A9 40                        lda #%01000000
000753r 3  14 rr                        trb status
000755r 3               
000755r 3                               ; Put cp (the xt for this word) in WORKWORD. The flag above
000755r 3                               ; lets both ";" and RECURSE know that is is an xt instead of an
000755r 3                               ; nt and they will modify their behavior.
000755r 3  A5 rr                        lda cp
000757r 3  85 rr                        sta workword
000759r 3  A5 rr                        lda cp+1
00075Br 3  85 rr                        sta workword+1
00075Dr 3               @done:
00075Dr 3  60           z_colon_noname:        rts
00075Er 3               
00075Er 3               
00075Er 3               
00075Er 3               ; ## COMMA ( n -- ) "Allot and store one cell in memory"
00075Er 3               ; ## ","  auto  ANS core
00075Er 3                       ; """https://forth-standard.org/standard/core/Comma
00075Er 3                       ; Store TOS at current place in memory.
00075Er 3                       ;
00075Er 3                       ; Since this an eight-bit machine, we can ignore all alignment issues.
00075Er 3                       ; """
00075Er 3               
00075Er 3               xt_comma:
00075Er 3  20 rr rr                     jsr underflow_1
000761r 3               
000761r 3  B5 00                        lda 0,x
000763r 3  92 rr                        sta (cp)
000765r 3               
000765r 3  E6 rr                        inc cp
000767r 3  D0 02                        bne @1
000769r 3  E6 rr                        inc cp+1
00076Br 3               @1:
00076Br 3  B5 01                        lda 1,x
00076Dr 3  92 rr                        sta (cp)
00076Fr 3               
00076Fr 3  E6 rr                        inc cp
000771r 3  D0 02                        bne @done
000773r 3  E6 rr                        inc cp+1
000775r 3               @done:
000775r 3  E8                           inx
000776r 3  E8                           inx
000777r 3               
000777r 3  60           z_comma:        rts
000778r 3               
000778r 3               
000778r 3               
000778r 3               ; ## COMPARE ( addr1 u1 addr2 u2 -- -1 | 0 | 1) "Compare two strings"
000778r 3               ; ## "compare"   auto  ANS string
000778r 3                       ; """https://forth-standard.org/standard/string/COMPARE
000778r 3                       ; Compare string1 (denoted by addr1 u1) to string2 (denoted by
000778r 3                       ; addr2 u2).  Return -1 if string1 < string2, 0 if string1 = string2
000778r 3                       ; and 1 if string1 > string2 (ASCIIbetical comparison).  A string
000778r 3                       ; that entirely matches the beginning of the other string, but is
000778r 3                       ; shorter, is considered less than the longer string.
000778r 3                       ; """
000778r 3               
000778r 3               xt_compare:
000778r 3  20 rr rr                     jsr underflow_4
00077Br 3               
00077Br 3                               ; Load the two string addresses into tmp1 and tmp2.
00077Br 3  B5 02                        lda 2,x
00077Dr 3  85 rr                        sta tmp2
00077Fr 3  B5 03                        lda 3,x
000781r 3  85 rr                        sta tmp2+1
000783r 3  B5 06                        lda 6,x
000785r 3  85 rr                        sta tmp1
000787r 3  B5 07                        lda 7,x
000789r 3  85 rr                        sta tmp1+1
00078Br 3                               ; The counts will be used in-place on the stack.
00078Br 3               
00078Br 3               @compare_loop:
00078Br 3                               ; Check to see if we are out of letters.
00078Br 3               
00078Br 3                               ; Check string1
00078Br 3  B5 04                        lda 4,x
00078Dr 3  15 05                        ora 5,x
00078Fr 3  F0 2C                        beq @str1_done
000791r 3               
000791r 3                               ; Check string2
000791r 3  B5 00                        lda 0,x
000793r 3  15 01                        ora 1,x
000795r 3  F0 3A                        beq @greater    ; Str2 empty first
000797r 3               
000797r 3               @check_letter:
000797r 3                               ; Both strings have at least one letter left.
000797r 3                               ; Check the letters against each other.
000797r 3  B2 rr                        lda (tmp1)
000799r 3  D2 rr                        cmp (tmp2)
00079Br 3  90 26                        bcc @less
00079Dr 3  D0 32                        bne @greater
00079Fr 3               @next_letter:
00079Fr 3                               ; Move both tmp pointers and decrement the counts
00079Fr 3                               ; on the stack.
00079Fr 3                               ; Increment tmp1
00079Fr 3  E6 rr                        inc tmp1
0007A1r 3  D0 02                        bne @1
0007A3r 3  E6 rr                        inc tmp1+1
0007A5r 3               @1:
0007A5r 3                               ; Increment tmp2
0007A5r 3  E6 rr                        inc tmp2
0007A7r 3  D0 02                        bne @2
0007A9r 3  E6 rr                        inc tmp2+1
0007ABr 3               @2:
0007ABr 3                               ; Decrement count1 on the stack.
0007ABr 3  B5 04                        lda 4,x
0007ADr 3  D0 02                        bne @3
0007AFr 3  D6 05                        dec 5,x
0007B1r 3               @3:
0007B1r 3  D6 04                        dec 4,x
0007B3r 3               
0007B3r 3                               ; Decrement count2 on the stack.
0007B3r 3  B5 00                        lda 0,x
0007B5r 3  D0 02                        bne @4
0007B7r 3  D6 01                        dec 1,x
0007B9r 3               @4:
0007B9r 3  D6 00                        dec 0,x
0007BBr 3               
0007BBr 3                               ; Loop around and check again.
0007BBr 3  80 CE                        bra @compare_loop
0007BDr 3               
0007BDr 3               @str1_done:
0007BDr 3                               ; String 1 is out of letters. Check string 2.
0007BDr 3  B5 00                        lda 0,x
0007BFr 3  15 01                        ora 1,x
0007C1r 3  F0 08                        beq @equal      ; Both out of letters
0007C3r 3               
0007C3r 3                               ; Falls into less (str1 is out but str2 has more)
0007C3r 3               @less:
0007C3r 3                               ; Return -1
0007C3r 3  A9 FF                        lda #$FF
0007C5r 3  95 06                        sta 6,x
0007C7r 3  95 07                        sta 7,x
0007C9r 3  80 0C                        bra @done
0007CBr 3               @equal:
0007CBr 3                               ; Return 0
0007CBr 3  74 06                        stz 6,x
0007CDr 3  74 07                        stz 7,x
0007CFr 3  80 06                        bra @done
0007D1r 3               @greater:
0007D1r 3                               ; Return 1
0007D1r 3  A9 01                        lda #1
0007D3r 3  95 06                        sta 6,x
0007D5r 3  74 07                        stz 7,x
0007D7r 3                               ; Falls into @done
0007D7r 3               @done:
0007D7r 3                               ; Remove all but the result from the stack.
0007D7r 3  8A                           txa
0007D8r 3  18                           clc
0007D9r 3  69 06                        adc #6
0007DBr 3  AA                           tax
0007DCr 3               
0007DCr 3  60           z_compare:      rts
0007DDr 3               
0007DDr 3               
0007DDr 3               
0007DDr 3               ; ## COMPILE_COMMA ( xt -- ) "Compile xt"
0007DDr 3               ; ## "compile,"  auto  ANS core ext
0007DDr 3                       ; """https://forth-standard.org/standard/core/COMPILEComma
0007DDr 3                       ; Compile the given xt in the current word definition. It is an
0007DDr 3                       ; error if we are not in the compile state. Because we are using
0007DDr 3                       ; subroutine threading, we can't use , (COMMA) to compile new words
0007DDr 3                       ; the traditional way. By default, native compiled is allowed, unless
0007DDr 3                       ; there is a NN (Never Native) flag associated. If not, we use the
0007DDr 3                       ; value NC_LIMIT (from definitions.tasm) to decide if the code
0007DDr 3                       ; is too large to be natively coded: If the size is larger than
0007DDr 3                       ; NC_LIMIT, we silently use subroutine coding. If the AN (Always
0007DDr 3                       ; Native) flag is set, the word is always natively compiled.
0007DDr 3                       ; """
0007DDr 3               
0007DDr 3               xt_compile_comma:
0007DDr 3  20 rr rr                     jsr underflow_1
0007E0r 3               
0007E0r 3                               ; See if this is an Always Native (AN) word by checking the
0007E0r 3                               ; AN flag. We need nt for this. First, save a copy of xt to
0007E0r 3                               ; the Return Stack
0007E0r 3  B5 01                        lda 1,x                 ; MSB
0007E2r 3  48                           pha
0007E3r 3  B5 00                        lda 0,x
0007E5r 3  48                           pha                     ; LSB
0007E6r 3               
0007E6r 3  20 rr rr                     jsr xt_int_to_name      ; ( xt -- nt )
0007E9r 3               
0007E9r 3                               ; See if this xt even has an nt.
0007E9r 3  B5 00                        lda 0,x
0007EBr 3  15 01                        ora 1,x
0007EDr 3  D0 03                        bne @check_nt
0007EFr 3               
0007EFr 3                               ; No nt in dictionary. Just compile as a JSR.
0007EFr 3  4C rr rr                     jmp @compile_as_jump
0007F2r 3               
0007F2r 3               @check_nt:
0007F2r 3                               ; put nt away for safe keeping
0007F2r 3  B5 00                        lda 0,x
0007F4r 3  85 rr                        sta tmptos
0007F6r 3  B5 01                        lda 1,x
0007F8r 3  85 rr                        sta tmptos+1
0007FAr 3               
0007FAr 3                               ; status byte is one further down
0007FAr 3  F6 00                        inc 0,x
0007FCr 3  D0 02                        bne @1
0007FEr 3  F6 01                        inc 1,x                 ; ( nt -- nt+1 )
000800r 3               @1:
000800r 3  A1 00                        lda (0,x)
000802r 3  85 rr                        sta tmp3                ; keep copy of status byte for NN
000804r 3  29 02                        and #AN                 ; mask all but Always Native (AN) bit
000806r 3  F0 0D                        beq @compile_check
000808r 3               
000808r 3                               ; We're natively compiling no matter what. Get length and
000808r 3                               ; compile in code. Get the original nt back
000808r 3  A5 rr                        lda tmptos
00080Ar 3  95 00                        sta 0,x
00080Cr 3  A5 rr                        lda tmptos+1
00080Er 3  95 01                        sta 1,x
000810r 3               
000810r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000813r 3               
000813r 3  80 27                        bra @compile_as_code
000815r 3               
000815r 3               @compile_check:
000815r 3                               ; See if Native Compile is even alowed by checking the NN
000815r 3                               ; flag
000815r 3  A5 rr                        lda tmp3
000817r 3  29 08                        and #NN
000819r 3  F0 03                        beq @check_size_limit
00081Br 3               
00081Br 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00081Er 3               
00081Er 3               @check_size_limit:
00081Er 3                               ; Native compile is a legal option, but we need to see what
00081Er 3                               ; limit the user set for size (in nc_limit)
00081Er 3  A5 rr                        lda tmptos
000820r 3  95 00                        sta 0,x
000822r 3  A5 rr                        lda tmptos+1
000824r 3  95 01                        sta 1,x
000826r 3               
000826r 3  20 rr rr                     jsr xt_wordsize         ; ( nt -- u )
000829r 3               
000829r 3                               ; Check the wordsize MSB against the user-defined limit.
000829r 3  B5 01                        lda 1,x
00082Br 3  C5 rr                        cmp nc_limit+1
00082Dr 3  90 0D                        bcc @compile_as_code    ; user-defined limit MSB
00082Fr 3  D0 08                        bne @jumpto_compile_as_jump
000831r 3               
000831r 3                               ; Check the wordsize LSB against the user-defined limit.
000831r 3  B5 00                        lda 0,x
000833r 3  C5 rr                        cmp nc_limit            ; user-defined limit LSB
000835r 3  90 05                        bcc @compile_as_code    ; Allow native compiling for less
000837r 3  F0 03                        beq @compile_as_code    ; than or equal to the limit.
000839r 3               
000839r 3               @jumpto_compile_as_jump:
000839r 3                               ; If the wordsize is greater than the user-defined
000839r 3                               ; limit, it will be compiled as a subroutine jump.
000839r 3  4C rr rr                     jmp @compile_as_jump    ; too far for BRA
00083Cr 3               
00083Cr 3               @compile_as_code:
00083Cr 3                               ; We arrive here with the length of the word's code TOS and
00083Cr 3                               ; xt on top of the Return Stack. MOVE will need ( xt cp u )
00083Cr 3                               ; on the data stack
00083Cr 3  CA                           dex
00083Dr 3  CA                           dex                     ; ( -- u ? )
00083Er 3  CA                           dex
00083Fr 3  CA                           dex                     ; ( -- u ? ? )
000840r 3               
000840r 3  B5 04                        lda 4,x
000842r 3  95 00                        sta 0,x                 ; LSB of u
000844r 3  B5 05                        lda 5,x
000846r 3  95 01                        sta 1,x                 ; ( -- u ? u )
000848r 3               
000848r 3  68                           pla
000849r 3  95 04                        sta 4,x                 ; LSB of xt
00084Br 3  68                           pla
00084Cr 3  95 05                        sta 5,x                 ; ( -- xt ? u )
00084Er 3               
00084Er 3  A5 rr                        lda cp                  ; LSB of cp
000850r 3  95 02                        sta 2,x
000852r 3  A5 rr                        lda cp+1
000854r 3  95 03                        sta 3,x                 ; ( -- xt cp u )
000856r 3               
000856r 3                               ; --- SPECIAL CASE 1: PREVENT RETURN STACK THRASHINIG ---
000856r 3               
000856r 3                               ; Native compiling allows us to strip the stack antics off
000856r 3                               ; a number of words that use the Return Stack such as >R, R>,
000856r 3                               ; 2>R and 2R> (but not 2R@ in this version). We compare the
000856r 3                               ; xt with the contents of the table
000856r 3  A0 00                        ldy #0
000858r 3               
000858r 3               @strip_loop:
000858r 3  B9 rr rr                     lda @strip_table,y      ; LSB of first word
00085Br 3  D5 04                        cmp 4,x                 ; LSB of xt
00085Dr 3  D0 07                        bne @next_entry
00085Fr 3               
00085Fr 3                               ; LSB is the same, test MSB
00085Fr 3  B9 rr rr                     lda @strip_table+1,y
000862r 3  D5 05                        cmp 5,x
000864r 3  F0 0C                        beq @found_entry
000866r 3               
000866r 3                               ; MSB is not equal. Pretend though that we've come from LSB
000866r 3                               ; so we can use the next step for both cases
000866r 3               @next_entry:
000866r 3                               ; Not a word that needs stripping, so check next entry in table
000866r 3                               ; Let's see if we're done with the table (marked by zero entry)
000866r 3  B9 rr rr                     lda @strip_table,y      ; pointing to LSB
000869r 3  19 rr rr                     ora @strip_table+1,y    ; get MSB
00086Cr 3  F0 22                        beq @underflow_strip    ; table done, let's get out of here
00086Er 3               
00086Er 3  C8                           iny
00086Fr 3  C8                           iny
000870r 3  80 E6                        bra @strip_loop
000872r 3               @found_entry:
000872r 3                               ; This word is one of the ones that needs to have its size
000872r 3                               ; adjusted during native compile. We find the values in the
000872r 3                               ; next table with the same index, which is Y. However, Y is
000872r 3                               ; pointing to the MSB, so we need to go back to the LSB and
000872r 3                               ; halve the index before we can use it.
000872r 3  98                           tya
000873r 3  4A                           lsr
000874r 3  A8                           tay
000875r 3               
000875r 3                               ; Get the adjustment out of the size table. We were clever
000875r 3                               ; enough to make sure the cut on both ends of the code is
000875r 3                               ; is the same size.
000875r 3  B9 rr rr                     lda @strip_size,y
000878r 3  85 rr                        sta tmptos              ; save a copy
00087Ar 3               
00087Ar 3                               ; Adjust xt: Start later
00087Ar 3  18                           clc
00087Br 3  75 04                        adc 4,x
00087Dr 3  95 04                        sta 4,x
00087Fr 3  90 02                        bcc @2
000881r 3  F6 05                        inc 5,x                 ; we just care about the carry
000883r 3               @2:
000883r 3               
000883r 3                               ; Adjust u: Quit earlier. Since we cut off the top and the
000883r 3                               ; bottom of the code, we have to double the value
000883r 3  06 rr                        asl tmptos
000885r 3               
000885r 3  38                           sec
000886r 3  B5 00                        lda 0,x
000888r 3  E5 rr                        sbc tmptos
00088Ar 3  95 00                        sta 0,x
00088Cr 3  B0 02                        bcs @3
00088Er 3  D6 01                        dec 1,x                 ; we just care about the borrow
000890r 3               @3:
000890r 3                               ; drop through to underflow check stripping
000890r 3               
000890r 3               @underflow_strip:
000890r 3                               ; --- SPECIAL CASE 2: REMOVE UNDERFLOW CHECKING ---
000890r 3               
000890r 3                               ; The user can choose to remove the unterflow testing in those
000890r 3                               ; words that have the UF flag. This shortens the word by
000890r 3                               ; 3 bytes if there is no underflow.
000890r 3               
000890r 3                               ; See if the user wants underflow stripping turned on
000890r 3  A5 rr                        lda uf_strip
000892r 3  05 rr                        ora uf_strip+1
000894r 3  F0 1C                        beq @specials_done
000896r 3               
000896r 3                               ; See if this word even contains underflow checking
000896r 3  A5 rr                        lda tmp3
000898r 3  29 10                        and #UF
00089Ar 3  F0 16                        beq @specials_done
00089Cr 3               
00089Cr 3                               ; If we arrived here, underflow has to go. It's always 3 bytes
00089Cr 3                               ; long. Note hat PICK is a special case.
00089Cr 3               
00089Cr 3                               ; Adjust xt: Start later
00089Cr 3  18                           clc
00089Dr 3  B5 04                        lda 4,x
00089Fr 3  69 03                        adc #3
0008A1r 3  95 04                        sta 4,x
0008A3r 3  90 02                        bcc @4
0008A5r 3  F6 05                        inc 5,x                  ; we just care about the carry
0008A7r 3               @4:
0008A7r 3                               ; Adjust u: End earlier
0008A7r 3  38                           sec
0008A8r 3  B5 00                        lda 0,x
0008AAr 3  E9 03                        sbc #3
0008ACr 3  95 00                        sta 0,x
0008AEr 3  B0 02                        bcs @5
0008B0r 3  D6 01                        dec 1,x                  ; we just care about the borrow
0008B2r 3               @5:
0008B2r 3               
0008B2r 3                               ; --- END OF SPECIAL CASES ---
0008B2r 3               @specials_done:
0008B2r 3                               ; Store size of area to be copied for calculation of
0008B2r 3                               ; new CP. We have to do this after all of the special cases
0008B2r 3                               ; because they might change the size
0008B2r 3  B5 01                        lda 1,x                 ; MSB
0008B4r 3  48                           pha
0008B5r 3  B5 00                        lda 0,x                 ; LSB
0008B7r 3  48                           pha
0008B8r 3               
0008B8r 3                               ; Enough of this, let's move those bytes already! We have
0008B8r 3                               ; ( xt cp u ) on the stack at this point
0008B8r 3  20 rr rr                     jsr xt_move
0008BBr 3               
0008BBr 3                               ; Update CP
0008BBr 3  18                           clc
0008BCr 3  68                           pla                     ; LSB
0008BDr 3  65 rr                        adc cp
0008BFr 3  85 rr                        sta cp
0008C1r 3               
0008C1r 3  68                           pla                     ; MSB
0008C2r 3  65 rr                        adc cp+1
0008C4r 3  85 rr                        sta cp+1
0008C6r 3               
0008C6r 3  80 2C                        bra @done
0008C8r 3               
0008C8r 3               @strip_table:
0008C8r 3                              ; List of words we strip the Return Stack antics from
0008C8r 3                              ; during native compile, zero terminated. The index here
0008C8r 3                              ; must be the same as for the sizes
0008C8r 3  rr rr rr rr                  .word xt_r_from, xt_r_fetch, xt_to_r    ; R>, R@, >R
0008CCr 3  rr rr        
0008CEr 3  rr rr rr rr                  .word xt_two_to_r, xt_two_r_from, 0000  ; 2>R, 2R>, EOL
0008D2r 3  00 00        
0008D4r 3               
0008D4r 3               @strip_size:
0008D4r 3                               ; List of bytes to be stripped from the words that get their
0008D4r 3                               ; Return Stack antics removed during native compile. Index must
0008D4r 3                               ; be the same as for the xts. Zero terminated.
0008D4r 3  04 04 04 06                  .byte 4, 4, 4, 6, 6, 0          ; R>, R@, >R, 2>R, 2R>, EOL
0008D8r 3  06 00        
0008DAr 3               
0008DAr 3               @compile_as_jump:
0008DAr 3                               ; Compile xt as a subroutine jump
0008DAr 3  A9 20                        lda #$20
0008DCr 3  92 rr                        sta (cp)
0008DEr 3               
0008DEr 3  A0 01                        ldy #1
0008E0r 3  68                           pla             ; LSB
0008E1r 3  91 rr                        sta (cp),y
0008E3r 3  C8                           iny
0008E4r 3  68                           pla             ; MSB
0008E5r 3  91 rr                        sta (cp),y
0008E7r 3               
0008E7r 3                               ; allot space we just used
0008E7r 3  A9 03                        lda #3
0008E9r 3  18                           clc
0008EAr 3  65 rr                        adc cp
0008ECr 3  85 rr                        sta cp
0008EEr 3  90 02                        bcc @6
0008F0r 3  E6 rr                        inc cp+1
0008F2r 3               @6:
0008F2r 3  E8                           inx             ; drop xt
0008F3r 3  E8                           inx
0008F4r 3               @done:
0008F4r 3               z_compile_comma:
0008F4r 3  60                           rts
0008F5r 3               
0008F5r 3               
0008F5r 3               
0008F5r 3               ; ## COMPILE_ONLY ( -- ) "Mark most recent word as COMPILE-ONLY"
0008F5r 3               ; ## "compile-only"  tested  Tali Forth
0008F5r 3                       ; """Set the Compile Only flag (CO) of the most recently defined
0008F5r 3                       ; word.
0008F5r 3                       ;
0008F5r 3                       ; The alternative way to do this is to define a word
0008F5r 3                       ; ?COMPILE that makes sure  we're in compile mode
0008F5r 3                       ; """
0008F5r 3               
0008F5r 3               xt_compile_only:
0008F5r 3  20 rr rr                     jsr current_to_dp
0008F8r 3  A0 01                        ldy #1          ; offset for status byte
0008FAr 3  B1 rr                        lda (dp),y
0008FCr 3  09 01                        ora #CO        ; make sure bit 7 is set
0008FEr 3  91 rr                        sta (dp),y
000900r 3               
000900r 3  60           z_compile_only: rts
000901r 3               
000901r 3               
000901r 3               
000901r 3               ; ## CONSTANT ( n "name" -- ) "Define a constant"
000901r 3               ; ## "constant"  auto  ANS core
000901r 3                       ; """https://forth-standard.org/standard/core/CONSTANT
000901r 3                       ;
000901r 3                       ; Forth equivalent is  CREATE , DOES> @  but we do
000901r 3                       ; more in assembler and let CREATE do the heavy lifting.
000901r 3                       ; See http://www.bradrodriguez.com/papers/moving3.htm for
000901r 3                       ; a primer on how this works in various Forths. This is the
000901r 3                       ; same code as VALUE in our case.
000901r 3                       ; """
000901r 3               xt_value:
000901r 3               xt_constant:
000901r 3  20 rr rr                     jsr underflow_1
000904r 3               
000904r 3  20 rr rr                     jsr xt_create
000907r 3               
000907r 3                           	; CREATE by default installs a subroutine jump to DOVAR,
000907r 3                               ; but we want DOCONST for constants. Go back two bytes and
000907r 3                               ; replace the subroutine jump target
000907r 3  38                           sec
000908r 3  A5 rr                        lda cp
00090Ar 3  E9 02                        sbc #2
00090Cr 3  85 rr                        sta tmp1
00090Er 3  A5 rr                        lda cp+1
000910r 3  E9 00                        sbc #0
000912r 3  85 rr                        sta tmp1+1
000914r 3               
000914r 3  A9 rr                        lda #<doconst           ; LSB of DOCONST
000916r 3  92 rr                        sta (tmp1)
000918r 3  A0 01                        ldy #1
00091Ar 3  A9 rr                        lda #>doconst           ; MSB of DOCONST
00091Cr 3  91 rr                        sta (tmp1),y
00091Er 3               
00091Er 3                               ; Now we save the constant number itself in the next cell
00091Er 3  20 rr rr                     jsr xt_comma            ; drop through to adjust_z
000921r 3               
000921r 3               adjust_z:
000921r 3                               ; Now the length of the complete word (z_word) has increased by
000921r 3                               ; two. We need to update that number or else words such as SEE
000921r 3                               ; will ignore the PFA. We use this same routine for VARIABLE,
000921r 3                               ; VALUE and DEFER
000921r 3  20 rr rr                     jsr xt_latestnt         ; gives us ( -- nt )
000924r 3               
000924r 3                               ; z_word is six bytes further down
000924r 3  B5 00                        lda 0,x
000926r 3  85 rr                        sta tmp1
000928r 3  B5 01                        lda 1,x
00092Ar 3  85 rr                        sta tmp1+1
00092Cr 3               
00092Cr 3  A0 06                        ldy #6
00092Er 3  B1 rr                        lda (tmp1),y
000930r 3  18                           clc
000931r 3  69 02                        adc #2
000933r 3  91 rr                        sta (tmp1),y
000935r 3  C8                           iny
000936r 3  B1 rr                        lda (tmp1),y
000938r 3  69 00                        adc #0                  ; only need carry
00093Ar 3  91 rr                        sta (tmp1),y
00093Cr 3               
00093Cr 3  E8                           inx
00093Dr 3  E8                           inx
00093Er 3               
00093Er 3               z_value:
00093Er 3  60           z_constant:     rts
00093Fr 3               
00093Fr 3               
00093Fr 3               ; ## COUNT ( c-addr -- addr u ) "Convert character string to normal format"
00093Fr 3               ; ## "count"  auto  ANS core
00093Fr 3                       ; """https://forth-standard.org/standard/core/COUNT
00093Fr 3                       ; Convert old-style character string to address-length pair. Note
00093Fr 3                       ; that the length of the string c-addr is stored in character length
00093Fr 3                       ; (8 bit), not cell length (16 bit). This is rarely used these days,
00093Fr 3                       ; though COUNT can also be used to step through a string character by
00093Fr 3                       ; character.
00093Fr 3                       ; """
00093Fr 3               xt_count:
00093Fr 3  20 rr rr                     jsr underflow_1
000942r 3               
000942r 3  A1 00                        lda (0,x)       ; Get number of characters (255 max)
000944r 3  A8                           tay
000945r 3               
000945r 3                               ; move start address up by one
000945r 3  F6 00                        inc 0,x         ; LSB
000947r 3  D0 02                        bne @1
000949r 3  F6 01                        inc 1,x         ; MSB
00094Br 3               
00094Br 3                               ; save number of characters to stack
00094Br 3               @1:
00094Br 3  98                           tya
00094Cr 3  CA                           dex
00094Dr 3  CA                           dex
00094Er 3  95 00                        sta 0,x         ; LSB
000950r 3  74 01                        stz 1,x         ; MSB, always zero
000952r 3               
000952r 3  60           z_count:        rts
000953r 3               
000953r 3               
000953r 3               ; ## CR ( -- ) "Print a line feed"
000953r 3               ; ## "cr"  auto  ANS core
000953r 3                       ; """https://forth-standard.org/standard/core/CR"""
000953r 3               xt_cr:
000953r 3  A9 0A                        lda #AscLF
000955r 3  20 rr rr                     jsr emit_a
000958r 3  60           z_cr:           rts
000959r 3               
000959r 3               
000959r 3               ; ## CREATE ( "name" -- ) "Create Dictionary entry for 'name'"
000959r 3               ; ## "create"  auto  ANS core
000959r 3                       ; """https://forth-standard.org/standard/core/CREATE
000959r 3                       ;
000959r 3                       ; See the drawing in headers.asm for details on the header
000959r 3                       ; """
000959r 3               
000959r 3               xt_create:
000959r 3                               ; get string
000959r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
00095Cr 3               
00095Cr 3                               ; if we were given an empty string, we complain and quit
00095Cr 3  B5 00                        lda 0,x
00095Er 3  15 01                        ora 1,x
000960r 3  D0 05                        bne @got_name
000962r 3               
000962r 3  A9 05                        lda #err_noname
000964r 3  4C rr rr                     jmp error
000967r 3               
000967r 3               @got_name:
000967r 3                               ; Enforce maximal length of string by overwriting the MSB of
000967r 3                               ; the length. There is a possible error here: If the string
000967r 3                               ; is exactly 255 chars long, then a lot of the following
000967r 3                               ; additions will fail because of wrapping
000967r 3  74 01                        stz 1,x
000969r 3               
000969r 3                               ; Check to see if this name already exists.
000969r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u )
00096Cr 3  20 rr rr                     jsr xt_find_name        ; ( addr u flag ) (non-zero nt as flag)
00096Fr 3               
00096Fr 3  B5 00                        lda 0,x
000971r 3  15 01                        ora 1,x
000973r 3  F0 1E                        beq @new_name           ; We haven't seen this one before.
000975r 3               
000975r 3                               ; This name already exists.  See if we are supposed to print
000975r 3                               ; the message for it.
000975r 3  E8                           inx                     ; Drop flag (nt) from find-name.
000976r 3  E8                           inx
000977r 3               
000977r 3                               ; Check bit 7
000977r 3  24 rr                        bit status
000979r 3  10 08                        bpl @redefined_name     ; Bit 7 is zero, so print the message.
00097Br 3               
00097Br 3                               ; We aren't supposed to print the redefined message ourselves,
00097Br 3                               ; but we should indicate that it is redefined (for ; to print
00097Br 3                               ; later).
00097Br 3  A9 80                        lda #$80                ; Set bit 7 to indicate dup
00097Dr 3  05 rr                        ora status
00097Fr 3  85 rr                        sta status
000981r 3  80 18                        bra @process_name
000983r 3               
000983r 3               @redefined_name:
000983r 3                               ; Print the message that the name is redefined.
000983r 3  A9 02                        lda #str_redefined
000985r 3  20 rr rr                     jsr print_string_no_lf
000988r 3               
000988r 3  20 rr rr                     jsr xt_two_dup           ; ( addr u addr u )
00098Br 3  20 rr rr                     jsr xt_type
00098Er 3  20 rr rr                     jsr xt_space
000991r 3               
000991r 3  80 08                        bra @process_name
000993r 3               
000993r 3               @new_name:
000993r 3  E8                           inx                     ; Drop flag (0) from find-name.
000994r 3  E8                           inx
000995r 3  A9 7F                        lda #$7F                ; Clear bit 0 of status to indicate new word.
000997r 3  25 rr                        and status
000999r 3  85 rr                        sta status
00099Br 3               
00099Br 3               @process_name:
00099Br 3  B5 00                        lda 0,x
00099Dr 3  85 rr                        sta tmp2                ; store length of string in tmp2
00099Fr 3               
00099Fr 3                               ; remember the first free byte of memory as the start of
00099Fr 3                               ; the new word
00099Fr 3  A5 rr                        lda cp
0009A1r 3  85 rr                        sta tmp1
0009A3r 3  A5 rr                        lda cp+1
0009A5r 3  85 rr                        sta tmp1+1
0009A7r 3               
0009A7r 3                               ; We need 8 bytes plus the length of the string for our new header.
0009A7r 3                               ; This is also the offset for the start of the code field (the
0009A7r 3                               ; xt_ label) so we need to remember it. Otherwise, we could
0009A7r 3                               ; just allot the space afterwards
0009A7r 3  B5 00                        lda 0,x
0009A9r 3  18                           clc
0009AAr 3  69 08                        adc #8
0009ACr 3  85 rr                        sta tmp3                ; total header length
0009AEr 3               
0009AEr 3                               ; We need three more bytes for for the hardcoded code field
0009AEr 3                               ; area (CFA), the "payload" of the word which by default will
0009AEr 3                               ; be a subroutine jump to DOVAR
0009AEr 3  18                           clc
0009AFr 3  69 03                        adc #3
0009B1r 3               
0009B1r 3                               ; We overwrite the length of the string returned by PARSE-NAME
0009B1r 3                               ; and then call ALLOT
0009B1r 3  95 00                        sta 0,x
0009B3r 3  74 01                        stz 1,x         ; max header size is 255 chars
0009B5r 3  20 rr rr                     jsr xt_allot    ; ( addr )
0009B8r 3               
0009B8r 3                               ; Get the CURRENT dictionary pointer.
0009B8r 3  20 rr rr                     jsr current_to_dp
0009BBr 3               
0009BBr 3                               ; Now we walk through the header with Y as the index, adding
0009BBr 3                               ; information byte-by-byte
0009BBr 3  A0 00                        ldy #0
0009BDr 3               
0009BDr 3                               ; HEADER BYTE 0: Length of string
0009BDr 3  A5 rr                        lda tmp2
0009BFr 3  91 rr                        sta (tmp1),y
0009C1r 3               
0009C1r 3                               ; HEADER BYTE 1: Status byte. By default, we set all new words
0009C1r 3                               ; to "never native", user will have to decide if they should
0009C1r 3                               ; be inlined
0009C1r 3  A9 08                        lda #NN
0009C3r 3               
0009C3r 3                               ; Also, words defined by CREATE are marked in the header has
0009C3r 3                               ; having a Code Field Area (CFA), which is a bit tricky for
0009C3r 3                               ; Subroutine Threaded Code (STC). We do this so >BODY works
0009C3r 3                               ; correctly with DOES> and CREATE. See the discussion at
0009C3r 3                               ; http://forum.6502.org/viewtopic.php?f=9&t=5182 for details
0009C3r 3  09 20                        ora #HC
0009C5r 3  C8                           iny
0009C6r 3  91 rr                        sta (tmp1),y
0009C8r 3  C8                           iny
0009C9r 3               
0009C9r 3                               ; HEADER BYTE 2,3: Next header. This is the current last word
0009C9r 3                               ; in the Dictionary
0009C9r 3  A5 rr                        lda dp
0009CBr 3  91 rr                        sta (tmp1),y
0009CDr 3  C8                           iny
0009CEr 3  A5 rr                        lda dp+1
0009D0r 3  91 rr                        sta (tmp1),y
0009D2r 3  C8                           iny
0009D3r 3               
0009D3r 3                               ; Interlude: Make old CP new DP (new start of Dictionary)
0009D3r 3  A5 rr                        lda tmp1+1
0009D5r 3  85 rr                        sta dp+1
0009D7r 3  A5 rr                        lda tmp1
0009D9r 3  85 rr                        sta dp
0009DBr 3               
0009DBr 3                               ; HEADER BYTE 4,5: Start of the code field ("xt_" of this word).
0009DBr 3                               ; This begins after the header so we take the length of the
0009DBr 3                               ; header, which we cleverly saved in tmp3, and use it as an
0009DBr 3                               ; offset to the address of the start of the word. We come here
0009DBr 3                               ; with tmp1 in A
0009DBr 3  18                           clc
0009DCr 3  65 rr                        adc tmp3        ; add total header length
0009DEr 3  91 rr                        sta (tmp1),y
0009E0r 3  48                           pha             ; we need this in the next step
0009E1r 3  C8                           iny
0009E2r 3               
0009E2r 3  A5 rr                        lda tmp1+1
0009E4r 3  69 00                        adc #0          ; only need the carry
0009E6r 3  91 rr                        sta (tmp1),y
0009E8r 3  C8                           iny
0009E9r 3               
0009E9r 3                               ; HEADER BYTE 6,7: End of code ("z_" of this word). By default,
0009E9r 3                               ; we execute a jump to the DOVAR routine, so we need to move three
0009E9r 3                               ; bytes down, and then one more byte so that the z_ label points
0009E9r 3                               ; to the (still fictional) RTS instruction for correct compilation
0009E9r 3  68                           pla             ; LSB of "z_" address
0009EAr 3  18                           clc
0009EBr 3  69 03                        adc #3
0009EDr 3  91 rr                        sta (tmp1),y
0009EFr 3               
0009EFr 3  88                           dey             ; get the MSB of xt back
0009F0r 3  B1 rr                        lda (tmp1),y
0009F2r 3  69 00                        adc #0          ; only need the carry
0009F4r 3  C8                           iny
0009F5r 3  C8                           iny
0009F6r 3  91 rr                        sta (tmp1),y
0009F8r 3  C8                           iny
0009F9r 3               
0009F9r 3                               ; HEADER BYTE 8: Start of name string. The address is TOS, the
0009F9r 3                               ; length in tmp2. We subtract 8 from the address so we can
0009F9r 3                               ; use the same loop index, which is already 8 byte ahead at
0009F9r 3                               ; this point
0009F9r 3  B5 00                        lda 0,x
0009FBr 3  38                           sec
0009FCr 3  E9 08                        sbc #8
0009FEr 3  85 rr                        sta tmptos
000A00r 3               
000A00r 3  B5 01                        lda 1,x
000A02r 3  E9 00                        sbc #0          ; only need carry
000A04r 3  85 rr                        sta tmptos+1
000A06r 3               
000A06r 3               @name_loop:
000A06r 3  B1 rr                        lda (tmptos),y
000A08r 3               
000A08r 3                               ; Make sure it goes into the dictionary in lower case.
000A08r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
000A0Ar 3  B0 07                        bcs @store_name
000A0Cr 3  C9 41                        cmp #$41        ; ASCII 'A'
000A0Er 3  90 03                        bcc @store_name
000A10r 3               
000A10r 3                               ; An uppercase letter has been located. Make it
000A10r 3                               ; lowercase.
000A10r 3  18                           clc
000A11r 3  69 20                        adc #$20
000A13r 3               
000A13r 3                               ; Fall into @store_name.
000A13r 3               
000A13r 3               @store_name:
000A13r 3  91 rr                        sta (tmp1),y
000A15r 3  C8                           iny
000A16r 3  C6 rr                        dec tmp2
000A18r 3  D0 EC                        bne @name_loop
000A1Ar 3               
000A1Ar 3                               ; After thename string comes the code field, starting at the
000A1Ar 3                               ; current xt of this word, which is initially a jump to the
000A1Ar 3                               ; subroutine to DOVAR. We code this jump by hand
000A1Ar 3  A9 20                        lda #$20        ; opcode of JSR
000A1Cr 3  91 rr                        sta (tmp1),y
000A1Er 3  C8                           iny
000A1Fr 3  A9 rr                        lda #<dovar
000A21r 3  91 rr                        sta (tmp1),y
000A23r 3  C8                           iny
000A24r 3  A9 rr                        lda #>dovar
000A26r 3  91 rr                        sta (tmp1),y
000A28r 3               
000A28r 3                               ; Update the CURRENT wordlist with the new DP.
000A28r 3                               ; We do this down here because this routine uses Y.
000A28r 3  20 rr rr                     jsr dp_to_current
000A2Br 3               
000A2Br 3                               ; And we're done. Restore stack
000A2Br 3  E8                           inx
000A2Cr 3  E8                           inx
000A2Dr 3               
000A2Dr 3  60           z_create:       rts
000A2Er 3               
000A2Er 3               
000A2Er 3               
000A2Er 3               ; ## D_MINUS ( d d -- d ) "Subtract two double-celled numbers"
000A2Er 3               ; ## "d-"  auto  ANS double
000A2Er 3                       ; """https://forth-standard.org/standard/double/DMinus"""
000A2Er 3               
000A2Er 3               xt_d_minus:
000A2Er 3  20 rr rr                     jsr underflow_4 ; two double numbers
000A31r 3               
000A31r 3  38                           sec
000A32r 3               
000A32r 3  B5 06                        lda 6,x         ; LSB of lower word
000A34r 3  F5 02                        sbc 2,x
000A36r 3  95 06                        sta 6,x
000A38r 3               
000A38r 3  B5 07                        lda 7,x         ; MSB of lower word
000A3Ar 3  F5 03                        sbc 3,x
000A3Cr 3  95 07                        sta 7,x
000A3Er 3               
000A3Er 3  B5 04                        lda 4,x         ; LSB of upper word
000A40r 3  F5 00                        sbc 0,x
000A42r 3  95 04                        sta 4,x
000A44r 3               
000A44r 3  B5 05                        lda 5,x         ; MSB of upper word
000A46r 3  F5 01                        sbc 1,x
000A48r 3  95 05                        sta 5,x
000A4Ar 3               
000A4Ar 3  E8                           inx
000A4Br 3  E8                           inx
000A4Cr 3  E8                           inx
000A4Dr 3  E8                           inx
000A4Er 3               
000A4Er 3  60           z_d_minus:      rts
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               
000A4Fr 3               ; ## D_PLUS ( d d -- d ) "Add two double-celled numbers"
000A4Fr 3               ; ## "d+"  auto  ANS double
000A4Fr 3                       ; """https://forth-standard.org/standard/double/DPlus"""
000A4Fr 3               
000A4Fr 3               xt_d_plus:
000A4Fr 3  20 rr rr                     jsr underflow_4 ; two double numbers
000A52r 3               
000A52r 3  18                           clc
000A53r 3  B5 02                        lda 2,x         ; LSB of lower word
000A55r 3  75 06                        adc 6,x
000A57r 3  95 06                        sta 6,x
000A59r 3               
000A59r 3  B5 03                        lda 3,x         ; MSB of lower word
000A5Br 3  75 07                        adc 7,x
000A5Dr 3  95 07                        sta 7,x
000A5Fr 3               
000A5Fr 3  B5 00                        lda 0,x         ; LSB of upper word
000A61r 3  75 04                        adc 4,x
000A63r 3  95 04                        sta 4,x
000A65r 3               
000A65r 3  B5 01                        lda 1,x         ; MSB of upper word
000A67r 3  75 05                        adc 5,x
000A69r 3  95 05                        sta 5,x
000A6Br 3               
000A6Br 3  E8                           inx
000A6Cr 3  E8                           inx
000A6Dr 3  E8                           inx
000A6Er 3  E8                           inx
000A6Fr 3               
000A6Fr 3  60           z_d_plus:       rts
000A70r 3               
000A70r 3               
000A70r 3               
000A70r 3               ; ## D_TO_S ( d -- n ) "Convert a double number to single"
000A70r 3               ; ## "d>s"  auto  ANS double
000A70r 3                       ; """https://forth-standard.org/standard/double/DtoS
000A70r 3                       ; Though this is basically just DROP, we keep it
000A70r 3                       ; separate so we can test for underflow
000A70r 3                       ; """
000A70r 3               
000A70r 3               xt_d_to_s:
000A70r 3  20 rr rr                     jsr underflow_2
000A73r 3               
000A73r 3  E8                           inx
000A74r 3  E8                           inx
000A75r 3               
000A75r 3  60           z_d_to_s:       rts
000A76r 3               
000A76r 3               
000A76r 3               
000A76r 3               ; ## DABS ( d -- d ) "Return the absolute value of a double"
000A76r 3               ; ## "dabs"  auto  ANS double
000A76r 3                       ; """https://forth-standard.org/standard/double/DABS"""
000A76r 3               
000A76r 3               xt_dabs:
000A76r 3  20 rr rr                     jsr underflow_2 ; double number
000A79r 3               
000A79r 3  B5 01                        lda 1,x         ; MSB of high cell
000A7Br 3  10 17                        bpl @done       ; positive, we get off light
000A7Dr 3               
000A7Dr 3                               ; negative, calculate 0 - d
000A7Dr 3  A0 00                        ldy #0
000A7Fr 3  38                           sec
000A80r 3               
000A80r 3  98                           tya
000A81r 3  F5 02                        sbc 2,x         ; LSB of low cell
000A83r 3  95 02                        sta 2,x
000A85r 3               
000A85r 3  98                           tya
000A86r 3  F5 03                        sbc 3,x         ; MSB of low cell
000A88r 3  95 03                        sta 3,x
000A8Ar 3               
000A8Ar 3  98                           tya
000A8Br 3  F5 00                        sbc 0,x         ; LSB of high cell
000A8Dr 3  95 00                        sta 0,x
000A8Fr 3               
000A8Fr 3  98                           tya
000A90r 3  F5 01                        sbc 1,x         ; MSB of high cell
000A92r 3  95 01                        sta 1,x
000A94r 3               @done:
000A94r 3  60           z_dabs:         rts
000A95r 3               
000A95r 3               
000A95r 3               
000A95r 3               ; ## DECIMAL ( -- ) "Change radix base to decimal"
000A95r 3               ; ## "decimal"  auto  ANS core
000A95r 3                       ; """https://forth-standard.org/standard/core/DECIMAL"""
000A95r 3               xt_decimal:
000A95r 3  A9 0A                        lda #10
000A97r 3  85 rr                        sta base
000A99r 3  64 rr                        stz base+1              ; paranoid
000A9Br 3               
000A9Br 3  60           z_decimal:      rts
000A9Cr 3               
000A9Cr 3               
000A9Cr 3               ; ## DEFER ( "name" -- ) "Create a placeholder for words by name"
000A9Cr 3               ; ## "defer"  auto  ANS core ext
000A9Cr 3                       ; """https://forth-standard.org/standard/core/DEFER
000A9Cr 3                       ; Reserve an name that can be linked to various xt by IS.
000A9Cr 3                       ;
000A9Cr 3                       ; The ANS reference implementation is
000A9Cr 3                       ;       CREATE ['] ABORT , DOES> @ EXECUTE ;
000A9Cr 3                       ; But we use this routine as a low-level word so things go faster
000A9Cr 3               
000A9Cr 3               xt_defer:
000A9Cr 3  20 rr rr                     jsr xt_create
000A9Fr 3               
000A9Fr 3                               ; CREATE by default installs a subroutine jump to DOVAR,
000A9Fr 3                               ; but we actually want DODEFER this time. Go back two
000A9Fr 3                               ; bytes and repace the subroutine jump target
000A9Fr 3  A5 rr                        lda cp          ; LSB
000AA1r 3  38                           sec
000AA2r 3  E9 02                        sbc #2
000AA4r 3  85 rr                        sta tmp1
000AA6r 3               
000AA6r 3  A5 rr                        lda cp+1        ; MSB
000AA8r 3  E9 00                        sbc #0          ; we only care about the borrow
000AAAr 3  85 rr                        sta tmp1+1
000AACr 3               
000AACr 3                               ; Save the target address
000AACr 3  A0 00                        ldy #0
000AAEr 3  A9 rr                        lda #<dodefer   ; LSB
000AB0r 3  91 rr                        sta (tmp1),y
000AB2r 3  C8                           iny
000AB3r 3  A9 rr                        lda #>dodefer   ; MSB
000AB5r 3  91 rr                        sta (tmp1),y
000AB7r 3               
000AB7r 3               
000AB7r 3                               ; DODEFER executes the next address it finds after
000AB7r 3                               ; its call. As default, we include the error
000AB7r 3                               ; "Defer not defined"
000AB7r 3  A9 rr                        lda #<defer_error
000AB9r 3  92 rr                        sta (cp)
000ABBr 3  E6 rr                        inc cp
000ABDr 3  D0 02                        bne @1
000ABFr 3  E6 rr                        inc cp+1
000AC1r 3               @1:
000AC1r 3  A9 rr                        lda #>defer_error
000AC3r 3  92 rr                        sta (cp)
000AC5r 3  E6 rr                        inc cp
000AC7r 3  D0 02                        bne @2
000AC9r 3  E6 rr                        inc cp+1
000ACBr 3               @2:
000ACBr 3  20 rr rr                     jsr adjust_z    ; adjust header to correct length
000ACEr 3               
000ACEr 3  60           z_defer:        rts
000ACFr 3               
000ACFr 3               
000ACFr 3               
000ACFr 3               ; ## DEFER_FETCH ( xt1 -- xt2 ) "Get the current XT for a deferred word"
000ACFr 3               ; ## "defer@"  auto  ANS core ext
000ACFr 3                       ; """http://forth-standard.org/standard/core/DEFERFetch"""
000ACFr 3               
000ACFr 3               xt_defer_fetch:
000ACFr 3                               ; No underflow checking as >BODY does it.
000ACFr 3  20 rr rr                     jsr xt_to_body
000AD2r 3  20 rr rr                     jsr xt_fetch
000AD5r 3  60           z_defer_fetch:  rts
000AD6r 3               
000AD6r 3               
000AD6r 3               
000AD6r 3               ; ## DEFER_STORE ( xt2 x1 -- ) "Set xt1 to execute xt2"
000AD6r 3               ; ## "defer!"  auto  ANS core ext
000AD6r 3                       ; """http://forth-standard.org/standard/core/DEFERStore"""
000AD6r 3               
000AD6r 3               xt_defer_store:
000AD6r 3                               ; No underflow checking as >BODY and ! do it.
000AD6r 3  20 rr rr                     jsr xt_to_body
000AD9r 3  20 rr rr                     jsr xt_store
000ADCr 3  60           z_defer_store:  rts
000ADDr 3               
000ADDr 3               
000ADDr 3               
000ADDr 3               ; ## DEFINITIONS ( -- ) "Make first wordlist in search order the current wordlist"
000ADDr 3               ; ## "definitions" auto ANS search
000ADDr 3               xt_definitions:
000ADDr 3  A0 1F                        ldy #search_order_offset    ; Transfer byte variable
000ADFr 3  B1 rr                        lda (up),y                  ; SEARCH_ORDER[0] to
000AE1r 3  A0 04                        ldy #current_offset         ; byte variable CURRENT.
000AE3r 3  91 rr                        sta (up),y
000AE5r 3  60           z_definitions:  rts
000AE6r 3               
000AE6r 3               
000AE6r 3               ; ## DEPTH ( -- u ) "Get number of cells (not bytes) used by stack"
000AE6r 3               ; ## "depth"  auto  ANS core
000AE6r 3                       ; """https://forth-standard.org/standard/core/DEPTH"""
000AE6r 3               xt_depth:
000AE6r 3  A9 rr                        lda #dsp0
000AE8r 3  86 rr                        stx tmpdsp
000AEAr 3  38                           sec
000AEBr 3  E5 rr                        sbc tmpdsp
000AEDr 3               
000AEDr 3                               ; divide by two because each cell is two bytes
000AEDr 3  4A                           lsr
000AEEr 3               
000AEEr 3  CA                           dex
000AEFr 3  CA                           dex
000AF0r 3  95 00                        sta 0,x
000AF2r 3  74 01                        stz 1,x
000AF4r 3               
000AF4r 3  60           z_depth:        rts
000AF5r 3               
000AF5r 3               
000AF5r 3               ; ## DIGIT_QUESTION ( char -- u f | char f ) "Convert ASCII char to number"
000AF5r 3               ; ## "digit?"  auto  Tali Forth
000AF5r 3                       ; """Inspired by the pForth instruction DIGIT, see
000AF5r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
000AF5r 3                       ; Rewritten from DIGIT>NUMBER in Tali Forth. Note in contrast to
000AF5r 3                       ; pForth, we get the base (radix) ourselves instead of having the
000AF5r 3                       ; user provide it. There is no standard name for this routine, which
000AF5r 3                       ; itself is not ANS; we use DIGIT? following pForth and Gforth.
000AF5r 3                       ; """
000AF5r 3               
000AF5r 3               xt_digit_question:
000AF5r 3  20 rr rr                     jsr underflow_1
000AF8r 3               
000AF8r 3                               ; one way or another, we're going to need room for the
000AF8r 3                               ; flag on the stack
000AF8r 3  CA                           dex
000AF9r 3  CA                           dex
000AFAr 3  74 00                        stz 0,x                 ; default flag is failure
000AFCr 3  74 01                        stz 1,x
000AFEr 3  74 03                        stz 3,x                 ; paranoid
000B00r 3               
000B00r 3                               ; Check the character, now in the LSB of NOS. First, make
000B00r 3                               ; sure we're not below the ASCII code for "0"
000B00r 3  B5 02                        lda 2,x
000B02r 3  C9 30                        cmp #'0'
000B04r 3  90 23                        bcc @done               ; failure flag already set
000B06r 3               
000B06r 3                               ; Next, see if we are below "9", because that would make
000B06r 3                               ; this a normal number
000B06r 3  C9 3A                        cmp #'9'+1               ; this is actually ":"
000B08r 3  90 12                        bcc @checkbase
000B0Ar 3               
000B0Ar 3                               ; Well, then let's see if this is the gap between "9" and "A"
000B0Ar 3                               ; so we can treat the whole range as a number
000B0Ar 3  C9 41                        cmp #'A'
000B0Cr 3  90 1B                        bcc @done               ; failure flag is already set
000B0Er 3               
000B0Er 3                               ; probably a letter, so we make sure it is uppercase
000B0Er 3  C9 61                        cmp #'a'
000B10r 3  90 07                        bcc @case_done          ; not lower case, too low
000B12r 3  C9 7B                        cmp #'z'+1
000B14r 3  B0 03                        bcs @case_done          ; not lower case, too high
000B16r 3               
000B16r 3  18                           clc                     ; just right
000B17r 3  69 E0                        adc #$e0                ; offset to upper case (wraps)
000B19r 3               
000B19r 3               @case_done:
000B19r 3                               ; get rid of the gap between "9" and "A" so we can treat
000B19r 3                               ; the whole range as one number
000B19r 3  38                           sec
000B1Ar 3  E9 07                        sbc #7                  ; fall through to @checkbase
000B1Cr 3               
000B1Cr 3               @checkbase:
000B1Cr 3                               ; we have a number, now see if it falls inside the range
000B1Cr 3                               ; provided by BASE
000B1Cr 3  38                           sec
000B1Dr 3  E9 30                        sbc #'0'                 ; this is also the conversion step
000B1Fr 3  C5 rr                        cmp base
000B21r 3  B0 06                        bcs @done               ; already have false flag
000B23r 3               
000B23r 3                               ; Found a legal number
000B23r 3  95 02                        sta 2,x                 ; put number in NOS
000B25r 3  D6 00                        dec 0,x                 ; set success flag
000B27r 3  D6 01                        dec 1,x
000B29r 3               
000B29r 3               @done:
000B29r 3               z_digit_question:
000B29r 3  60                           rts
000B2Ar 3               
000B2Ar 3               
000B2Ar 3               ; ## DISASM ( addr u -- ) "Disassemble a block of memory"
000B2Ar 3               ; ## "disasm"  tested  Tali Forth
000B2Ar 3                       ; """Convert a segment of memory to assembler output. This
000B2Ar 3                       ; word is vectored so people can add their own disassembler.
000B2Ar 3                       ; Natively, this produces Simpler Assembly Notation (SAN)
000B2Ar 3                       ; code, see the section on The Disassembler in the manual and
000B2Ar 3                       ; the file disassembler.asm for more details.
000B2Ar 3                       ; """
000B2Ar 3               xt_disasm:
000B2Ar 3  20 rr rr                     jsr underflow_2
000B2Dr 3                           .ifdef TALI_OPTIONAL_ASSEMBLER
000B2Dr 3  20 rr rr                     jsr disassembler
000B30r 3                           .endif
000B30r 3               
000B30r 3  60           z_disasm:       rts
000B31r 3               
000B31r 3               
000B31r 3               ; ## DNEGATE ( d -- d ) "Negate double cell number"
000B31r 3               ; ## "dnegate"  auto  ANS double
000B31r 3                       ; """https://forth-standard.org/standard/double/DNEGATE"""
000B31r 3               xt_dnegate:
000B31r 3  20 rr rr                     jsr underflow_2 ; double number
000B34r 3               
000B34r 3  A0 00             		ldy #0
000B36r 3  38                           sec
000B37r 3               
000B37r 3  98                           tya
000B38r 3  F5 02                        sbc 2,x         ; LSB of low cell
000B3Ar 3  95 02                        sta 2,x
000B3Cr 3               
000B3Cr 3  98                           tya
000B3Dr 3  F5 03                        sbc 3,x         ; MSB of low cell
000B3Fr 3  95 03                        sta 3,x
000B41r 3               
000B41r 3  98                           tya
000B42r 3  F5 00                        sbc 0,x         ; LSB of high cell
000B44r 3  95 00                        sta 0,x
000B46r 3               
000B46r 3  98                           tya
000B47r 3  F5 01                        sbc 1,x         ; MSB of high cell
000B49r 3  95 01                        sta 1,x
000B4Br 3               
000B4Br 3  60           z_dnegate:      rts
000B4Cr 3               
000B4Cr 3               
000B4Cr 3               ; ## QUESTION_DO ( limit start -- )(R: -- limit start) "Conditional loop start"
000B4Cr 3               ; ## "?do"  auto  ANS core ext
000B4Cr 3                       ; """https://forth-standard.org/standard/core/qDO"""
000B4Cr 3               xt_question_do:
000B4Cr 3                               ; ?DO shares most of its code with DO. We use the tmp1 flag
000B4Cr 3                               ; to mark which is which
000B4Cr 3  A9 FF                        lda #$ff                ; -1 is ?DO, jump to common code
000B4Er 3  85 rr                        sta tmp1
000B50r 3  80 02                        bra do_common           ; skip flag for DO
000B52r 3               
000B52r 3               ; ## DO ( limit start -- )(R: -- limit start)  "Start a loop"
000B52r 3               ; ## "do"  auto  ANS core
000B52r 3                       ; """https://forth-standard.org/standard/core/DO
000B52r 3                       ;
000B52r 3                       ; Compile-time part of DO. Could be realized in Forth as
000B52r 3                       ;       : DO POSTPONE (DO) HERE ; IMMEDIATE COMPILE-ONLY
000B52r 3                       ; but we do it in assembler for speed. To work with LEAVE, we compile
000B52r 3                       ; a routine that pushes the end address to the Return Stack at run
000B52r 3                       ; time. This is based on a suggestion by Garth Wilson, see
000B52r 3                       ; the Control Flow section of the manual for details.
000B52r 3                       ;
000B52r 3                       ; This may not be native compile. Don't check for a stack underflow
000B52r 3                       ; """
000B52r 3               
000B52r 3               xt_do:
000B52r 3                               ; DO and ?DO share most of their code, use tmp1 as a flag.
000B52r 3  64 rr                        stz tmp1                ; 0 is DO, drop through to DO_COMMON
000B54r 3               do_common:
000B54r 3                               ; We push HERE to the Data Stack so LOOP/+LOOP knows where to
000B54r 3                               ; compile the address we need to LDA at runtime
000B54r 3  CA                           dex
000B55r 3  CA                           dex
000B56r 3  A5 rr                        lda cp
000B58r 3  95 00                        sta 0,x                 ; LSB
000B5Ar 3  A5 rr                        lda cp+1
000B5Cr 3  95 01                        sta 1,x                 ; MSB   ( limit start here )
000B5Er 3               
000B5Er 3                               ; now we compile six dummy bytes that LOOP/+LOOP will
000B5Er 3                               ; replace by the actual LDA/PHA instructions
000B5Er 3  A9 05                        lda #5                  ; we don't really care about the value,
000B60r 3  A8                           tay                     ; so we use 5 to be tricky
000B61r 3               @loop:
000B61r 3  91 rr                        sta (cp),y
000B63r 3  88                           dey
000B64r 3  10 FB                        bpl @loop
000B66r 3               
000B66r 3                               ; update CP
000B66r 3  1A                           inc             ; we used 5 as a dummy value, this is why
000B67r 3  18                           clc
000B68r 3  65 rr                        adc cp
000B6Ar 3  85 rr                        sta cp
000B6Cr 3  90 02                        bcc @1
000B6Er 3  E6 rr                        inc cp+1
000B70r 3               @1:
000B70r 3                               ; compile the (?DO) portion of ?DO if appropriate
000B70r 3  A5 rr                        lda tmp1
000B72r 3  F0 17                        beq @compile_do
000B74r 3               
000B74r 3                               ; We came from ?DO, so compile its runtime first. We do
000B74r 3                               ; this with a quick loop because we know it has to be
000B74r 3                               ; Always Native anyway
000B74r 3  A0 14                        ldy #question_do_runtime_end-question_do_runtime
000B76r 3  5A                           phy             ; save counter to calculate new CP
000B77r 3               @2:
000B77r 3  B9 rr rr                     lda question_do_runtime,y
000B7Ar 3  91 rr                        sta (cp),y
000B7Cr 3  88                           dey
000B7Dr 3  10 F8                        bpl @2
000B7Fr 3               
000B7Fr 3                               ; adjust CP
000B7Fr 3  68                           pla             ; retrieve counter
000B80r 3  18                           clc
000B81r 3  65 rr                        adc cp
000B83r 3  85 rr                        sta cp
000B85r 3  A5 rr                        lda cp+1
000B87r 3  69 00                        adc #0          ; only care about carry
000B89r 3  85 rr                        sta cp+1        ; fall through to @compile_do
000B8Br 3               
000B8Br 3               @compile_do:
000B8Br 3                               ; compile runtime part of DO.
000B8Br 3  A0 24                        ldy #do_runtime_end-do_runtime  ; counter
000B8Dr 3  5A                           phy             ; save counter to calculate new CP
000B8Er 3               @3:
000B8Er 3  B9 rr rr                     lda do_runtime,y
000B91r 3  91 rr                        sta (cp),y
000B93r 3  88                           dey
000B94r 3  10 F8                        bpl @3
000B96r 3               
000B96r 3                               ; adjust CP
000B96r 3  68                           pla             ; retrieve counter
000B97r 3  18                           clc
000B98r 3  65 rr                        adc cp
000B9Ar 3  85 rr                        sta cp
000B9Cr 3  A5 rr                        lda cp+1
000B9Er 3  69 00                        adc #0          ; only care about carry
000BA0r 3  85 rr                        sta cp+1
000BA2r 3               
000BA2r 3                               ; HERE, hardcoded for speed. We put it on the Data Stack
000BA2r 3                               ; where LOOP/+LOOP takes it from. Note this has nothing to
000BA2r 3                               ; do with the HERE we're saving for LEAVE
000BA2r 3  CA                           dex
000BA3r 3  CA                           dex
000BA4r 3  A5 rr                        lda cp          ; LSB
000BA6r 3  95 00                        sta 0,x
000BA8r 3  A5 rr                        lda cp+1        ; MSB
000BAAr 3  95 01                        sta 1,x
000BACr 3               z_question_do:
000BACr 3  60           z_do:           rts
000BADr 3               
000BADr 3               
000BADr 3               do_runtime:
000BADr 3                       ; """Runtime routine for DO loop. Note that ANS loops quit when the
000BADr 3                       ; boundry of limit-1 and limit is reached, a different mechanism than
000BADr 3                       ; the FIG Forth loop (you can see which version you have by running
000BADr 3                       ; a loop with start and limit as the same value, for instance
000BADr 3                       ; 0 0 DO -- these will walk through the number space). We use a
000BADr 3                       ; "fudge factor" for the limit that makes the Overflow Flag trip when
000BADr 3                       ; it is reached; see http://forum.6502.org/viewtopic.php?f=9&t=2026
000BADr 3                       ; for further discussion of this. The source given there for
000BADr 3                       ; this idea is Laxen & Perry F83. -- This routine is called (DO)
000BADr 3                       ; in some Forths. Usually, we would define this as a separate word
000BADr 3                       ; and compile it with COMPILE, and the Always Native (AN) flag.
000BADr 3                       ; However, we can do it faster if we just copy the bytes
000BADr 3                       ; of this routine with a simple loop in DO.
000BADr 3                       ; """
000BADr 3                               ; First step: create fudge factor (FUFA) by subtracting the
000BADr 3                               ; limit from $8000, the number that will trip the overflow
000BADr 3                               ; flag
000BADr 3  38                           sec
000BAEr 3  A9 00                        lda #0
000BB0r 3  F5 02                        sbc 2,x         ; LSB of limit
000BB2r 3  95 02                        sta 2,x         ; save FUFA for later use
000BB4r 3               
000BB4r 3  A9 80                        lda #$80
000BB6r 3  F5 03                        sbc 3,x         ; MSB of limit
000BB8r 3  95 03                        sta 3,x         ; save FUFA for later use
000BBAr 3  48                           pha             ; FUFA replaces limit on R stack
000BBBr 3  B5 02                        lda 2,x         ; LSB of limit
000BBDr 3  48                           pha
000BBEr 3               
000BBEr 3                               ; Second step: index is FUFA plus original index
000BBEr 3  18                           clc
000BBFr 3  B5 00                        lda 0,x         ; LSB of original index
000BC1r 3  75 02                        adc 2,x         ; add LSB of FUFA
000BC3r 3  95 00                        sta 0,x
000BC5r 3  B5 01                        lda 1,x         ; MSB of orginal index
000BC7r 3  75 03                        adc 3,x         ; add MSB of FUFA
000BC9r 3  48                           pha
000BCAr 3  B5 00                        lda 0,x         ; LSB of index
000BCCr 3  48                           pha
000BCDr 3               
000BCDr 3                               ; we've saved the FUFA on the NOS of the R stack, so we can
000BCDr 3                               ; use it later. Clean the Data Stack
000BCDr 3  E8                           inx
000BCEr 3  E8                           inx
000BCFr 3  E8                           inx
000BD0r 3  E8                           inx             ; no RTS because this is copied into code
000BD1r 3               do_runtime_end:
000BD1r 3               
000BD1r 3               question_do_runtime:
000BD1r 3               
000BD1r 3                       ; """This is called (?DO) in some Forths. See the explanation at
000BD1r 3                       ; do_runtime for the background on this design
000BD1r 3                       ; """
000BD1r 3                               ; see if TOS and NOS are equal. Change this to assembler
000BD1r 3                               ; for speed
000BD1r 3  20 rr rr                     jsr xt_two_dup          ; ( n1 n2 n1 n2 )
000BD4r 3  20 rr rr                     jsr xt_equal            ; ( -- n1 n2 f )
000BD7r 3               
000BD7r 3  B5 00                        lda 0,x
000BD9r 3  15 01                        ora 1,x
000BDBr 3  F0 06                        beq @do_do
000BDDr 3               
000BDDr 3                               ; We're equal, so dump everything and jump beyond the loop.
000BDDr 3                               ; But first, dump six entries off of the Data Stack
000BDDr 3  8A                           txa
000BDEr 3  18                           clc
000BDFr 3  69 06                        adc #6
000BE1r 3  AA                           tax
000BE2r 3               
000BE2r 3                               ; Then abort the whole loop
000BE2r 3  60                           rts
000BE3r 3               @do_do:
000BE3r 3  E8                           inx             ; clear flag from EQUAL off stack
000BE4r 3  E8                           inx             ; no RTS because this is copied into code
000BE5r 3               question_do_runtime_end:
000BE5r 3               
000BE5r 3               
000BE5r 3               
000BE5r 3               ; ## DOES ( -- ) "Add payload when defining new words"
000BE5r 3               ; ## "does>"  auto  ANS core
000BE5r 3                       ; """https://forth-standard.org/standard/core/DOES
000BE5r 3                       ; Create the payload for defining new defining words. See
000BE5r 3                       ; http://www.bradrodriguez.com/papers/moving3.htm and
000BE5r 3                       ; the Developer Guide in the manual for a discussion of
000BE5r 3                       ; DOES>'s internal workings. This uses tmp1 and tmp2.
000BE5r 3                       ; """
000BE5r 3               
000BE5r 3               xt_does:
000BE5r 3                               ; compile a subroutine jump to runtime of DOES>
000BE5r 3  A0 rr                        ldy #>does_runtime
000BE7r 3  A9 rr                        lda #<does_runtime
000BE9r 3  20 rr rr                     jsr cmpl_subroutine
000BECr 3               
000BECr 3                               ; compile a subroutine jump to DODOES. In traditional
000BECr 3                               ; terms, this is the Code Field Area (CFA) of the new
000BECr 3                               ; word
000BECr 3  A0 rr                        ldy #>dodoes
000BEEr 3  A9 rr                        lda #<dodoes
000BF0r 3  20 rr rr                     jsr cmpl_subroutine
000BF3r 3               
000BF3r 3  60           z_does:         rts
000BF4r 3               
000BF4r 3               
000BF4r 3               does_runtime:
000BF4r 3                       ; """Runtime portion of DOES>. This replaces the subroutine jump
000BF4r 3                       ; to DOVAR that CREATE automatically encodes by a jump to the
000BF4r 3                       ; address that contains a subroutine jump to DODOES. We don't
000BF4r 3                       ; jump to DODOES directly because we need to work our magic with
000BF4r 3                       ; the return addresses. This routine is also known as "(DOES)" in
000BF4r 3                       ; other Forths
000BF4r 3                       ; """
000BF4r 3               
000BF4r 3  7A                           ply             ; LSB
000BF5r 3  68                           pla             ; MSB
000BF6r 3               
000BF6r 3  C8                           iny
000BF7r 3  D0 01                        bne @1
000BF9r 3  1A                           inc
000BFAr 3               @1:
000BFAr 3  84 rr                        sty tmp1
000BFCr 3  85 rr                        sta tmp1+1
000BFEr 3               
000BFEr 3                               ; CREATE has also already modified the DP to point to the new
000BFEr 3                               ; word. We have no idea which instructions followed the CREATE
000BFEr 3                               ; command if there is a DOES> so the CP could point anywhere
000BFEr 3                               ; by now. The address of the word's xt is four bytes down.
000BFEr 3  20 rr rr                     jsr current_to_dp   ; Grab the DP from the CURRENT wordlist.
000C01r 3  A5 rr                        lda dp
000C03r 3  18                           clc
000C04r 3  69 04                        adc #4
000C06r 3  85 rr                        sta tmp2
000C08r 3  A5 rr                        lda dp+1
000C0Ar 3  69 00                        adc #0          ; we only care about the carry
000C0Cr 3  85 rr                        sta tmp2+1
000C0Er 3               
000C0Er 3                               ; Now we get that address and add one byte to skip over the JSR
000C0Er 3                               ; opcode
000C0Er 3  B2 rr                        lda (tmp2)
000C10r 3  18                           clc
000C11r 3  69 01                        adc #1
000C13r 3  85 rr                        sta tmp3
000C15r 3  A0 01                        ldy #1
000C17r 3  B1 rr                        lda (tmp2),y
000C19r 3  69 00                        adc #0          ; we only care about the carry
000C1Br 3  85 rr                        sta tmp3+1
000C1Dr 3               
000C1Dr 3                               ; Replace the DOVAR address with our own
000C1Dr 3  A5 rr                        lda tmp1        ; LSB
000C1Fr 3  92 rr                        sta (tmp3)
000C21r 3  A5 rr                        lda tmp1+1
000C23r 3  91 rr                        sta (tmp3),y    ; Y is still 1
000C25r 3               
000C25r 3                               ; Since we removed the return address that brought us here, we
000C25r 3                               ; go back to whatever the main routine was. Otherwise, we we
000C25r 3                               ; smash into the subroutine jump to DODOES.
000C25r 3  60                           rts
000C26r 3               
000C26r 3               
000C26r 3               
000C26r 3               ; ## DOT ( u -- ) "Print TOS"
000C26r 3               ; ## "."  auto  ANS core
000C26r 3                       ; """https://forth-standard.org/standard/core/d"""
000C26r 3               
000C26r 3               xt_dot:
000C26r 3  20 rr rr                     jsr underflow_1
000C29r 3               
000C29r 3  20 rr rr                     jsr xt_dup                      ; ( n n )
000C2Cr 3  20 rr rr                     jsr xt_abs                      ; ( n u )
000C2Fr 3  20 rr rr                     jsr xt_zero                     ; ( n u 0 )
000C32r 3  20 rr rr                     jsr xt_less_number_sign         ; ( n u 0 )
000C35r 3  20 rr rr                     jsr xt_number_sign_s            ; ( n ud )
000C38r 3  20 rr rr                     jsr xt_rot                      ; ( ud n )
000C3Br 3  20 rr rr                     jsr xt_sign                     ; ( ud )
000C3Er 3  20 rr rr                     jsr xt_number_sign_greater      ; ( addr u )
000C41r 3  20 rr rr                     jsr xt_type
000C44r 3  20 rr rr                     jsr xt_space
000C47r 3               
000C47r 3  60           z_dot:          rts
000C48r 3               
000C48r 3               
000C48r 3               
000C48r 3               ; ## DOT_PAREN ( -- ) "Print input up to close paren .( comment )"
000C48r 3               ; ## ".("  auto  ANS core
000C48r 3                       ; """http://forth-standard.org/standard/core/Dotp"""
000C48r 3               
000C48r 3               xt_dot_paren:
000C48r 3                               ; Put a right paren on the stack.
000C48r 3  CA                           dex
000C49r 3  CA                           dex
000C4Ar 3  A9 29                        lda #41     ; Right parenthesis
000C4Cr 3  95 00                        sta 0,x
000C4Er 3  74 01                        stz 1,x
000C50r 3               
000C50r 3  20 rr rr                     jsr xt_parse
000C53r 3  20 rr rr                     jsr xt_type
000C56r 3               
000C56r 3  60           z_dot_paren:    rts
000C57r 3               
000C57r 3               
000C57r 3               
000C57r 3               ; ## DOT_QUOTE ( "string" -- ) "Print string from compiled word"
000C57r 3               ; ## ".""  auto  ANS core ext
000C57r 3                       ; """https://forth-standard.org/standard/core/Dotq
000C57r 3                       ; Compile string that is printed during run time. ANS Forth wants
000C57r 3                       ; this to be compile-only, even though everybody and their friend
000C57r 3                       ; uses it for everything. We follow the book here, and recommend
000C57r 3                       ; `.(` for general printing.
000C57r 3                       ; """
000C57r 3               
000C57r 3               xt_dot_quote:
000C57r 3                               ; we let S" do the heavy lifting. Since we're in
000C57r 3                               ; compile mode, it will save the string and reproduce it
000C57r 3                               ; during runtime
000C57r 3  20 rr rr                     jsr xt_s_quote
000C5Ar 3               
000C5Ar 3                               ; We then let TYPE do the actual printing
000C5Ar 3  A0 rr                        ldy #>xt_type
000C5Cr 3  A9 rr                        lda #<xt_type
000C5Er 3  20 rr rr                     jsr cmpl_subroutine
000C61r 3               
000C61r 3  60           z_dot_quote:    rts
000C62r 3               
000C62r 3               
000C62r 3               
000C62r 3               ; ## DOT_R ( n u -- ) "Print NOS as unsigned number with TOS with"
000C62r 3               ; ## ".r"  tested  ANS core ext
000C62r 3                       ; """https://forth-standard.org/standard/core/DotR
000C62r 3                       ;
000C62r 3                       ; Based on the Forth code
000C62r 3                       ;  : .R  >R DUP ABS 0 <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
000C62r 3                       ; """
000C62r 3               
000C62r 3               xt_dot_r:
000C62r 3  20 rr rr                     jsr underflow_2
000C65r 3               
000C65r 3  20 rr rr                     jsr xt_to_r
000C68r 3  20 rr rr                     jsr xt_dup
000C6Br 3  20 rr rr                     jsr xt_abs
000C6Er 3  20 rr rr                     jsr xt_zero
000C71r 3  20 rr rr                     jsr xt_less_number_sign
000C74r 3  20 rr rr                     jsr xt_number_sign_s
000C77r 3  20 rr rr                     jsr xt_rot
000C7Ar 3  20 rr rr                     jsr xt_sign
000C7Dr 3  20 rr rr                     jsr xt_number_sign_greater
000C80r 3  20 rr rr                     jsr xt_r_from
000C83r 3  20 rr rr                     jsr xt_over
000C86r 3  20 rr rr                     jsr xt_minus
000C89r 3  20 rr rr                     jsr xt_spaces
000C8Cr 3  20 rr rr                     jsr xt_type
000C8Fr 3               
000C8Fr 3  60           z_dot_r:        rts
000C90r 3               
000C90r 3               
000C90r 3               
000C90r 3               ; ## DOT_S ( -- ) "Print content of Data Stack"
000C90r 3               ; ## ".s"  tested  ANS tools
000C90r 3                       ; """https://forth-standard.org/standard/tools/DotS
000C90r 3                       ; Print content of Data Stack non-distructively. We follow the format
000C90r 3                       ; of Gforth and print the number of elements first in brackets,
000C90r 3                       ; followed by the Data Stack content (if any).
000C90r 3                       ;
000C90r 3                       ; Since this is for humans, we don't have to worry about speed.
000C90r 3                       ; """
000C90r 3               
000C90r 3               xt_dot_s:
000C90r 3  20 rr rr                     jsr xt_depth    ; ( -- u )
000C93r 3               
000C93r 3                               ; Print stack depth in brackets
000C93r 3  A9 3C                        lda #$3c        ; ASCII for "<"
000C95r 3  20 rr rr                     jsr emit_a
000C98r 3               
000C98r 3                               ; We keep a copy of the number of the things on the stack
000C98r 3                               ; to use as a counter later down. This assumes that there
000C98r 3                               ; are less than 255 elements on the stack
000C98r 3  B5 00                        lda 0,x
000C9Ar 3  48                           pha
000C9Br 3               
000C9Br 3                               ; print unsigned number without the trailing space
000C9Br 3  CA                           dex             ; DUP
000C9Cr 3  CA                           dex
000C9Dr 3  95 00                        sta 0,x
000C9Fr 3  74 01                        stz 1,x
000CA1r 3               
000CA1r 3  20 rr rr                     jsr print_u
000CA4r 3               
000CA4r 3  A9 3E                        lda #$3e        ; ASCII for ">"
000CA6r 3  20 rr rr                     jsr emit_a
000CA9r 3  A9 20                        lda #AscSP      ; ASCII for SPACE
000CABr 3  20 rr rr                     jsr emit_a
000CAEr 3               
000CAEr 3  E8                           inx
000CAFr 3  E8                           inx
000CB0r 3               
000CB0r 3                               ; There will be lots of cases where the stack is empty. If that
000CB0r 3                               ; is so, get out of here quickly
000CB0r 3  E0 rr                        cpx #dsp0
000CB2r 3  F0 1E                        beq @done
000CB4r 3               
000CB4r 3               @have_stack:
000CB4r 3                               ; We have at least one element on the stack. The depth of the
000CB4r 3                               ; stack is on the stack, we can use it as a counter. We go
000CB4r 3                               ; from bottom to top
000CB4r 3  7A                           ply
000CB5r 3               
000CB5r 3  A9 rr                        lda #dsp0-1     ; go up one to avoid garbage
000CB7r 3  85 rr                        sta tmp3
000CB9r 3  64 rr                        stz tmp3+1      ; must be zero page on the 65c02
000CBBr 3               @loop:
000CBBr 3  CA                           dex
000CBCr 3  CA                           dex
000CBDr 3               
000CBDr 3  B2 rr                        lda (tmp3)
000CBFr 3  95 01                        sta 1,x
000CC1r 3  C6 rr                        dec tmp3
000CC3r 3               
000CC3r 3  B2 rr                        lda (tmp3)
000CC5r 3  95 00                        sta 0,x
000CC7r 3  C6 rr                        dec tmp3
000CC9r 3  5A                           phy
000CCAr 3               
000CCAr 3  20 rr rr                     jsr xt_dot
000CCDr 3               
000CCDr 3  7A                           ply
000CCEr 3  88                           dey
000CCFr 3  D0 EA                        bne @loop
000CD1r 3               
000CD1r 3  48                           pha             ; dummy to balance stack
000CD2r 3               @done:
000CD2r 3  68                           pla
000CD3r 3  60           z_dot_s:        rts
000CD4r 3               
000CD4r 3               
000CD4r 3               
000CD4r 3               ; ## D_DOT ( d -- ) "Print double"
000CD4r 3               ; ## "d."  tested  ANS double
000CD4r 3                       ; """http://forth-standard.org/standard/double/Dd"""
000CD4r 3                       ;
000CD4r 3                       ; From the Forth code:
000CD4r 3                       ; : D. TUCK DABS <# #S ROT SIGN #> TYPE SPACE ;
000CD4r 3                       ; """
000CD4r 3               
000CD4r 3               xt_d_dot:
000CD4r 3  20 rr rr                     jsr underflow_2
000CD7r 3               
000CD7r 3  20 rr rr                     jsr xt_tuck
000CDAr 3  20 rr rr                     jsr xt_dabs
000CDDr 3  20 rr rr                     jsr xt_less_number_sign
000CE0r 3  20 rr rr                     jsr xt_number_sign_s
000CE3r 3  20 rr rr                     jsr xt_rot
000CE6r 3  20 rr rr                     jsr xt_sign
000CE9r 3  20 rr rr                     jsr xt_number_sign_greater
000CECr 3  20 rr rr                     jsr xt_type
000CEFr 3  20 rr rr                     jsr xt_space
000CF2r 3               
000CF2r 3  60           z_d_dot:        rts
000CF3r 3               
000CF3r 3               
000CF3r 3               
000CF3r 3               ; ## D_DOT_R ( d u -- ) "Print double right-justified u wide"
000CF3r 3               ; ## "d.r"  tested  ANS double
000CF3r 3                       ; """http://forth-standard.org/standard/double/DDotR"""
000CF3r 3                       ; Based on the Forth code
000CF3r 3                       ;  : D.R >R TUCK DABS <# #S ROT SIGN #> R> OVER - SPACES TYPE ;
000CF3r 3                       ; """
000CF3r 3               
000CF3r 3               xt_d_dot_r:
000CF3r 3  20 rr rr                     jsr underflow_3
000CF6r 3                               ; From the forth code:
000CF6r 3  20 rr rr                     jsr xt_to_r
000CF9r 3  20 rr rr                     jsr xt_tuck
000CFCr 3  20 rr rr                     jsr xt_dabs
000CFFr 3  20 rr rr                     jsr xt_less_number_sign
000D02r 3  20 rr rr                     jsr xt_number_sign_s
000D05r 3  20 rr rr                     jsr xt_rot
000D08r 3  20 rr rr                     jsr xt_sign
000D0Br 3  20 rr rr                     jsr xt_number_sign_greater
000D0Er 3  20 rr rr                     jsr xt_r_from
000D11r 3  20 rr rr                     jsr xt_over
000D14r 3  20 rr rr                     jsr xt_minus
000D17r 3  20 rr rr                     jsr xt_spaces
000D1Ar 3  20 rr rr                     jsr xt_type
000D1Dr 3               
000D1Dr 3  60           z_d_dot_r:      rts
000D1Er 3               
000D1Er 3               
000D1Er 3               
000D1Er 3               ; ## DROP ( u -- ) "Pop top entry on Data Stack"
000D1Er 3               ; ## "drop"  auto  ANS core
000D1Er 3                       ; """https://forth-standard.org/standard/core/DROP"""
000D1Er 3               xt_drop:
000D1Er 3  20 rr rr                     jsr underflow_1
000D21r 3               
000D21r 3  E8                           inx
000D22r 3  E8                           inx
000D23r 3               
000D23r 3  60           z_drop:         rts
000D24r 3               
000D24r 3               
000D24r 3               ; ## DUMP ( addr u -- ) "Display a memory region"
000D24r 3               ; ## "dump"  tested  ANS tools
000D24r 3                       ; """https://forth-standard.org/standard/tools/DUMP
000D24r 3                       ;
000D24r 3                       ; DUMP's exact output is defined as "implementation dependent".
000D24r 3                       ; This is in assembler because it is
000D24r 3                       ; useful for testing and development, so we want to have it work
000D24r 3                       ; as soon as possible. Uses TMP2
000D24r 3                       ; """
000D24r 3               
000D24r 3               xt_dump:
000D24r 3  20 rr rr                     jsr underflow_2
000D27r 3               @row:
000D27r 3                               ; start counter for 16 numbers per row
000D27r 3  A0 10                        ldy #16
000D29r 3               
000D29r 3                               ; We use TMP2 as the index for the ASCII characters
000D29r 3                               ; that we print at the and of the hex block. We
000D29r 3                               ; start saving them at HERE (CP)
000D29r 3  64 rr                        stz tmp2
000D2Br 3               
000D2Br 3  20 rr rr                     jsr xt_cr
000D2Er 3               
000D2Er 3                               ; print address number
000D2Er 3  B5 03                        lda 3,x
000D30r 3  20 rr rr                     jsr byte_to_ascii
000D33r 3  B5 02                        lda 2,x
000D35r 3  20 rr rr                     jsr byte_to_ascii
000D38r 3               
000D38r 3  20 rr rr                     jsr xt_space
000D3Br 3  20 rr rr                     jsr xt_space
000D3Er 3               @loop:
000D3Er 3                               ; if there are zero bytes left to display, we're done
000D3Er 3  B5 00                        lda 0,x
000D40r 3  15 01                        ora 1,x
000D42r 3  F0 39                        beq @all_printed
000D44r 3               
000D44r 3                               ; dump the contents
000D44r 3  A1 02                        lda (2,x)
000D46r 3  48                           pha                     ; byte_to_ascii destroys A
000D47r 3  20 rr rr                     jsr byte_to_ascii
000D4Ar 3  20 rr rr                     jsr xt_space
000D4Dr 3  68                           pla
000D4Er 3               
000D4Er 3                               ; Handle ASCII printing
000D4Er 3  20 rr rr                     jsr is_printable
000D51r 3  B0 02                        bcs @printable
000D53r 3  A9 2E                        lda #'.'                 ; Print dot if not printable
000D55r 3               @printable:
000D55r 3  5A                           phy                     ; save counter
000D56r 3  A4 rr                        ldy tmp2
000D58r 3  91 rr                        sta (cp),y
000D5Ar 3  E6 rr                        inc tmp2
000D5Cr 3  7A                           ply
000D5Dr 3               
000D5Dr 3                               ; extra space after eight bytes
000D5Dr 3  C0 09                        cpy #9
000D5Fr 3  D0 03                        bne @next_char
000D61r 3  20 rr rr                     jsr xt_space
000D64r 3               
000D64r 3               @next_char:
000D64r 3  F6 02                        inc 2,x
000D66r 3  D0 02                        bne @counter
000D68r 3  F6 03                        inc 3,x
000D6Ar 3               
000D6Ar 3               @counter:
000D6Ar 3                               ; loop counter
000D6Ar 3  B5 00                        lda 0,x
000D6Cr 3  D0 02                        bne @1
000D6Er 3  D6 01                        dec 1,x
000D70r 3               @1:
000D70r 3  D6 00                        dec 0,x
000D72r 3  88                           dey
000D73r 3  D0 C9                        bne @loop               ; next byte
000D75r 3               
000D75r 3                               ; Done with one line, print the ASCII version of these
000D75r 3                               ; characters
000D75r 3  20 rr rr                     jsr xt_space
000D78r 3  20 rr rr                     jsr print_ascii
000D7Br 3               
000D7Br 3  80 AA                        bra @row                ; new row
000D7Dr 3               
000D7Dr 3               @all_printed:
000D7Dr 3                               ; See if there are any ASCII characters in the buffer
000D7Dr 3                               ; left to print
000D7Dr 3  A5 rr                        lda tmp2
000D7Fr 3  F0 06                        beq @done
000D81r 3               
000D81r 3                               ; In theory, we could try to make the ASCII part line
000D81r 3                               ; up with the line before it. But that is a hassle (we
000D81r 3                               ; use three bytes for each missed hex entry, and
000D81r 3                               ; then there is the gap after eight entries) and it
000D81r 3                               ; makes it harder to read. We settle for one extra
000D81r 3                               ; space instead for the moment
000D81r 3  20 rr rr                     jsr xt_space
000D84r 3  20 rr rr                     jsr print_ascii
000D87r 3               @done:
000D87r 3  20 rr rr                     jsr xt_two_drop         ; one byte less than 4x INX
000D8Ar 3  60           z_dump:         rts
000D8Br 3               
000D8Br 3               
000D8Br 3               print_ascii:
000D8Br 3                               ; Print the ASCII characters that we have saved from
000D8Br 3                               ; HERE (CP) to HERE plus whatever is in TMP2. This routine
000D8Br 3                               ; is not compiled (DUMP is probably never compiled anyway)
000D8Br 3                               ; but we keep it inside the scope of DUMP.
000D8Br 3  A0 00                        ldy #0
000D8Dr 3               @ascii_loop:
000D8Dr 3  B1 rr                        lda (cp),y
000D8Fr 3  20 rr rr                     jsr emit_a
000D92r 3  C8                           iny
000D93r 3               
000D93r 3                               ; extra space after eight chars
000D93r 3  C0 08                        cpy #8
000D95r 3  D0 03                        bne @1
000D97r 3  20 rr rr                     jsr xt_space
000D9Ar 3               @1:
000D9Ar 3  C6 rr                        dec tmp2
000D9Cr 3  D0 EF                        bne @ascii_loop
000D9Er 3               
000D9Er 3  60                           rts
000D9Fr 3               
000D9Fr 3               
000D9Fr 3               
000D9Fr 3               ; ## DUP ( u -- u u ) "Duplicate TOS"
000D9Fr 3               ; ## "dup"  auto  ANS core
000D9Fr 3                       ; """https://forth-standard.org/standard/core/DUP"""
000D9Fr 3               xt_dup:
000D9Fr 3  20 rr rr                     jsr underflow_1
000DA2r 3               
000DA2r 3  CA                           dex
000DA3r 3  CA                           dex
000DA4r 3               
000DA4r 3  B5 02                        lda 2,x         ; LSB
000DA6r 3  95 00                        sta 0,x
000DA8r 3  B5 03                        lda 3,x         ; MSB
000DAAr 3  95 01                        sta 1,x
000DACr 3               
000DACr 3  60           z_dup:          rts
000DADr 3               
000DADr 3               
000DADr 3               ; ## ED ( -- u ) "Line-based editor"
000DADr 3               ; ## "ed"  fragment  Tali Forth
000DADr 3                       ; """Start the line-based editor ed6502. See separate file
000DADr 3                       ; ed.asm or the manual for details.
000DADr 3                       ; """
000DADr 3               xt_ed:
000DADr 3                       .ifdef ed6502
000DADr 3                               jsr ed6502      ; kept in separate file
000DADr 3                       .endif
000DADr 3               
000DADr 3  60           z_ed:           rts
000DAEr 3               
000DAEr 3               
000DAEr 3               ; ## EDITOR_WORDLIST ( -- u ) "WID for the Editor wordlist"
000DAEr 3               ; ## "editor-wordlist"  tested  Tali Editor
000DAEr 3                       ; """ Commonly used like `editor-wordlist >order` to add the editor
000DAEr 3                       ; words to the search order so they can be used.  This will need
000DAEr 3                       ; to be done before any of the words marked "Tali Editor" can be
000DAEr 3                       ; used.  See the tutorial on Wordlists and the Search Order for
000DAEr 3                       ; more information.
000DAEr 3               
000DAEr 3                       ;
000DAEr 3                       ; This is a dummy entry, the code is shared with ONE
000DAEr 3                       ; """
000DAEr 3               
000DAEr 3               
000DAEr 3               ; ## ELSE (C: orig -- orig) ( -- ) "Conditional flow control"
000DAEr 3               ; ## "else"  auto  ANS core
000DAEr 3                       ; """http://forth-standard.org/standard/core/ELSE
000DAEr 3                       ;
000DAEr 3                       ; The code is shared with ENDOF
000DAEr 3                       ; """
000DAEr 3               
000DAEr 3               xt_else:
000DAEr 3               xt_endof:
000DAEr 3                               ; Put an unconditional branch.
000DAEr 3  A0 rr                        ldy #>branch_runtime
000DB0r 3  A9 rr                        lda #<branch_runtime
000DB2r 3  20 rr rr                     jsr cmpl_subroutine
000DB5r 3               
000DB5r 3                               ; Put the address of the branch address on the stack.
000DB5r 3  20 rr rr                     jsr xt_here
000DB8r 3               
000DB8r 3                               ; Use zero for the branch address for now.
000DB8r 3                               ; THEN will fill it in later.
000DB8r 3  20 rr rr                     jsr xt_zero
000DBBr 3  20 rr rr                     jsr xt_comma
000DBEr 3               
000DBEr 3                               ; Get the address to jump to (just after the
000DBEr 3                               ; unconditional branch) for the IF to jump to
000DBEr 3                               ; when false.
000DBEr 3  20 rr rr                     jsr xt_here
000DC1r 3  20 rr rr                     jsr xt_rot
000DC4r 3               
000DC4r 3                               ; Update the original if 0branch address.
000DC4r 3  20 rr rr                     jsr xt_store
000DC7r 3               z_else:
000DC7r 3               z_endof:
000DC7r 3  60                           rts
000DC8r 3               
000DC8r 3               
000DC8r 3               
000DC8r 3               branch_runtime:
000DC8r 3                       ; """Runtime component for a branch. Used by ELSE and ENDOF. This was
000DC8r 3                       ; formally part of a separate word BRANCH which was later removed.
000DC8r 3                       ; """
000DC8r 3               
000DC8r 3                               ; The address on the Return Stack points to the last byte
000DC8r 3                               ; of the JSR address, one byte below the branch literal
000DC8r 3  68                           pla
000DC9r 3  85 rr                        sta tmpbranch
000DCBr 3  68                           pla
000DCCr 3  85 rr                        sta tmpbranch+1
000DCEr 3               
000DCEr 3                               ; Keep in mind: the address we just popped points one byte
000DCEr 3                               ; lower than the branch literal we want to grab
000DCEr 3  A0 01                        ldy #1
000DD0r 3  B1 rr                        lda (tmpbranch),y  ; LSB
000DD2r 3  85 rr                        sta tmp1
000DD4r 3  C8                           iny
000DD5r 3  B1 rr                        lda (tmpbranch),y  ; MSB
000DD7r 3  85 rr                        sta tmp1+1
000DD9r 3               
000DD9r 3  6C rr rr                     jmp (tmp1)
000DDCr 3               
000DDCr 3               
000DDCr 3               
000DDCr 3               ; ## EMIT ( char -- ) "Print character to current output"
000DDCr 3               ; ## "emit"  auto  ANS core
000DDCr 3                       ; """https://forth-standard.org/standard/core/EMIT
000DDCr 3                       ; Run-time default for EMIT. The user can revector this by changing
000DDCr 3                       ; the value of the OUTPUT variable. We ignore the MSB completely, and
000DDCr 3                       ; do not check to see if we have been given a valid ASCII character.
000DDCr 3                       ; Don't make this native compile.
000DDCr 3                       ; """
000DDCr 3               
000DDCr 3               xt_emit:
000DDCr 3  20 rr rr                     jsr underflow_1
000DDFr 3               
000DDFr 3  B5 00                        lda 0,x
000DE1r 3  E8                           inx
000DE2r 3  E8                           inx
000DE3r 3               
000DE3r 3               emit_a:
000DE3r 3                       ; We frequently want to print the character in A without fooling
000DE3r 3                       ; around with the Data Stack. This is emit_a's job, which still
000DE3r 3                       ; allows the output to be vectored. Call it with JSR as you
000DE3r 3                       ; would XT_EMIT
000DE3r 3  6C rr rr                     jmp (output)            ; JSR/RTS
000DE6r 3               
000DE6r 3               z_emit:         ; never reached
000DE6r 3               
000DE6r 3               
000DE6r 3               
000DE6r 3               ; ## EMPTY_BUFFERS ( -- ) "Empty all buffers without saving"
000DE6r 3               ; ## "empty-buffers"  tested  ANS block ext
000DE6r 3                       ; """https://forth-standard.org/standard/block/EMPTY-BUFFERS"""
000DE6r 3               xt_empty_buffers:
000DE6r 3                               ; Set the buffer status to empty.
000DE6r 3  A0 2C                        ldy #buffstatus_offset
000DE8r 3  A9 00                        lda #0
000DEAr 3  91 rr                        sta (up),y      ; Only LSB is used.
000DECr 3               z_empty_buffers:
000DECr 3  60                           rts
000DEDr 3               
000DEDr 3               
000DEDr 3               ; ## ENDCASE (C: case-sys -- ) ( x -- ) "Conditional flow control"
000DEDr 3               ; ## "endcase"  auto  ANS core ext
000DEDr 3                       ; """http://forth-standard.org/standard/core/ENDCASE"""
000DEDr 3               
000DEDr 3               xt_endcase:
000DEDr 3                               ; Postpone DROP to remove the item
000DEDr 3                               ; being checked.
000DEDr 3  A0 rr                        ldy #>xt_drop
000DEFr 3  A9 rr                        lda #<xt_drop
000DF1r 3  20 rr rr                     jsr cmpl_subroutine
000DF4r 3               
000DF4r 3                               ; There are a number of address (of branches that need their
000DF4r 3                               ; jump addressed filled in with the address of right here).
000DF4r 3                               ; Keep calling THEN to deal with them until we reach the
000DF4r 3                               ; 0 that CASE put on the stack at the beginning.
000DF4r 3               @endcase_loop:
000DF4r 3                               ; Check for 0 on the stack.
000DF4r 3  B5 00                        lda 0,x
000DF6r 3  15 01                        ora 1,x
000DF8r 3  F0 05                        beq @done
000DFAr 3               
000DFAr 3  20 rr rr                     jsr xt_then
000DFDr 3  80 F5                        bra @endcase_loop
000DFFr 3               @done:
000DFFr 3                               ; Remove the 0 from the stack.
000DFFr 3  E8                           inx
000E00r 3  E8                           inx
000E01r 3  60           z_endcase:      rts
000E02r 3               
000E02r 3               
000E02r 3               
000E02r 3               ; ## ENDOF (C: case-sys1 of-sys1-- case-sys2) ( -- ) "Conditional flow control"
000E02r 3               ; ## "endof"  auto  ANS core ext
000E02r 3                       ; """http://forth-standard.org/standard/core/ENDOF
000E02r 3                       ; This is a dummy entry, the code is shared with ELSE
000E02r 3                       ; """
000E02r 3               
000E02r 3               
000E02r 3               ; ## ENVIRONMENT_Q  ( addr u -- 0 | i*x true )  "Return system information"
000E02r 3               ; ## "environment?"  auto  ANS core
000E02r 3                       ; """https://forth-standard.org/standard/core/ENVIRONMENTq
000E02r 3                       ;
000E02r 3                       ; By ANS definition, we use upper-case strings here, see the
000E02r 3                       ; string file for details. This can be realized as a high-level
000E02r 3                       ; Forth word as
000E02r 3                       ;
000E02r 3                       ; : STRING_OF POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0=
000E02r 3                       ;    POSTPONE IF POSTPONE 2DROP ; IMMEDIATE COMPILE-ONLY
000E02r 3                       ; HEX
000E02r 3                       ; : ENVIRONMENT? ( C-ADDR U -- FALSE | I*X TRUE )
000E02r 3                       ; CASE
000E02r 3                       ; S" /COUNTED-STRING"    STRING_OF  7FFF TRUE ENDOF
000E02r 3                       ; S" /HOLD"              STRING_OF    FF TRUE ENDOF
000E02r 3                       ; S" /PAD"               STRING_OF    54 TRUE ENDOF ( 84 DECIMAL )
000E02r 3                       ; S" ADDRESS-UNIT-BITS"  STRING_OF     8 TRUE ENDOF
000E02r 3                       ; S" FLOORED"            STRING_OF FALSE TRUE ENDOF ( WE HAVE SYMMETRIC )
000E02r 3                       ; S" MAX-CHAR"           STRING_OF   255 TRUE ENDOF
000E02r 3                       ; S" MAX-D"              STRING_OF
000E02r 3                                                    ; 7FFFFFFF. TRUE ENDOF
000E02r 3                       ; S" MAX-N"              STRING_OF  7FFF TRUE ENDOF
000E02r 3                       ; S" MAX-U"              STRING_OF  FFFF TRUE ENDOF
000E02r 3                       ; S" MAX-UD"             STRING_OF
000E02r 3                                                    ; FFFFFFFF. TRUE ENDOF
000E02r 3                       ; S" RETURN-STACK-CELLS" STRING_OF    80 TRUE ENDOF
000E02r 3                       ; S" STACK-CELLS"        STRING_OF    20 TRUE ENDOF ( FROM DEFINITIONS.ASM )
000E02r 3                       ; ( DEFAULT ) 2DROP FALSE FALSE ( ONE FALSE WILL DROPPED BY ENDCASE )
000E02r 3                       ; ENDCASE ;
000E02r 3                       ;
000E02r 3                       ; but that uses lots of memory and increases the start up time. This
000E02r 3                       ; word is rarely used so we can try to keep it short at the expense
000E02r 3                       ; of speed.
000E02r 3                       ; """
000E02r 3               
000E02r 3               xt_environment_q:
000E02r 3  20 rr rr                     jsr underflow_1
000E05r 3               
000E05r 3                               ; This code is table-driven: We walk through the list of
000E05r 3                               ; strings until we find one that matches, and then we take
000E05r 3                               ; the equivalent data from the results table. This is made
000E05r 3                               ; a bit harder by the fact that some of these return a
000E05r 3                               ; double-cell number and some a single-cell one.
000E05r 3               
000E05r 3                               ; We will walk through the table with variables that return
000E05r 3                               ; a single-cell result
000E05r 3  A0 00                        ldy #00                 ; counter for table
000E07r 3               
000E07r 3                               ; We use a flag on the the stack to signal if we have a single-cell
000E07r 3                               ; or double-cell number. We use 0 to signal single-cell and 1 for
000E07r 3                               ; double-cell.
000E07r 3  5A                           phy
000E08r 3               @table_loop:
000E08r 3                               ; We arrived here with the address of the string to be checked
000E08r 3                               ; on the stack. We make a copy. Index is in Y
000E08r 3  20 rr rr                     jsr xt_two_dup          ; ( addr u addr u ) 2DUP does not use Y
000E0Br 3               
000E0Br 3                               ; We do our work on the TOS to speed things up
000E0Br 3  CA                           dex
000E0Cr 3  CA                           dex                     ; ( addr u addr u ? )
000E0Dr 3               
000E0Dr 3                               ; Get address of string to check from table
000E0Dr 3  B9 rr rr                     lda env_table_single,y
000E10r 3  95 00                        sta 0,x
000E12r 3  C8                           iny
000E13r 3  B9 rr rr                     lda env_table_single,y
000E16r 3  95 01                        sta 1,x                 ; ( addr u addr u addr-t )
000E18r 3  C8                           iny
000E19r 3               
000E19r 3                               ; See if this is the last entry. The LSB is still in A
000E19r 3  15 00                        ora 0,x
000E1Br 3  F0 4D                        beq @table_done
000E1Dr 3               
000E1Dr 3                               ; We have a string entry. The address there is stored in
000E1Dr 3                               ; old-style address format, that is, the first byte is the
000E1Dr 3                               ; length of the string
000E1Dr 3  5A                           phy                     ; save Y, which is used by COUNT
000E1Er 3  20 rr rr                     jsr xt_count            ; ( addr u addr u addr-s u-s )
000E21r 3  20 rr rr                     jsr xt_compare          ; ( addr u f )
000E24r 3  7A                           ply
000E25r 3               
000E25r 3                               ; If we found a match (flag is zero -- COMPARE is weird
000E25r 3                               ; that way), return the result
000E25r 3  B5 00                        lda 0,x
000E27r 3  15 01                        ora 1,x
000E29r 3  F0 04                        beq @got_result
000E2Br 3               
000E2Br 3                               ; Flag is not zero, so not a perfect match, so try next
000E2Br 3                               ; word
000E2Br 3  E8                           inx                     ; DROP, now ( addr u )
000E2Cr 3  E8                           inx
000E2Dr 3               
000E2Dr 3  80 D9                        bra @table_loop
000E2Fr 3               
000E2Fr 3               @got_result:
000E2Fr 3                               ; We arrive here with ( addr u -1 ) and know that we've found
000E2Fr 3                               ; a match. The index of the match+2 is in Y.
000E2Fr 3  E8                           inx                     ; drop flag, now ( addr u )
000E30r 3  E8                           inx
000E31r 3  88                           dey                     ; go back to index we had
000E32r 3  88                           dey
000E33r 3               
000E33r 3                               ; See if this is a single-cell word.
000E33r 3  68                           pla
000E34r 3  D0 0D                        bne @double_result
000E36r 3               
000E36r 3                               ; Single-cell result
000E36r 3  B9 rr rr                     lda env_results_single,y
000E39r 3  95 02                        sta 2,x
000E3Br 3  C8                           iny
000E3Cr 3  B9 rr rr                     lda env_results_single,y
000E3Fr 3  95 03                        sta 3,x                 ; ( res u )
000E41r 3               
000E41r 3  80 1F                        bra @set_flag
000E43r 3               
000E43r 3               @double_result:
000E43r 3                               ; This is a double-celled result, which means we have to
000E43r 3                               ; fool around with the index some more. We also need a
000E43r 3                               ; further cell on the stack
000E43r 3  CA                           dex                     ; ( addr u ? )
000E44r 3  CA                           dex
000E45r 3               
000E45r 3                               ; We have 11 single-cell words we check, plus the 0000 as
000E45r 3                               ; a marker for the end of the table, so we arrive here
000E45r 3                               ; with Y as 22 or more. To get the index for the double-
000E45r 3                               ; cell words, we move the result
000E45r 3  98                           tya
000E46r 3  38                           sec
000E47r 3  E9 18                        sbc #24
000E49r 3               
000E49r 3                               ; We have four bytes per entry in the table, but the index
000E49r 3                               ; keeps increasing by two, so we only have to multiply by
000E49r 3                               ; two (shift left once) to get the right result
000E49r 3  0A                           asl
000E4Ar 3  A8                           tay
000E4Br 3               
000E4Br 3  B9 rr rr                     lda env_results_double,y
000E4Er 3  95 02                        sta 2,x
000E50r 3  C8                           iny
000E51r 3  B9 rr rr                     lda env_results_double,y
000E54r 3  95 03                        sta 3,x                 ; ( res u ? )
000E56r 3  C8                           iny
000E57r 3               
000E57r 3  B9 rr rr                     lda env_results_double,y
000E5Ar 3  95 04                        sta 4,x
000E5Cr 3  C8                           iny
000E5Dr 3  B9 rr rr                     lda env_results_double,y
000E60r 3  95 05                        sta 5,x                 ; ( res res ? )
000E62r 3               
000E62r 3                               ; fall through to @set_flag
000E62r 3               @set_flag:
000E62r 3  A9 FF                        lda #$ff
000E64r 3  95 00                        sta 0,x
000E66r 3  95 01                        sta 1,x                 ; ( res f )
000E68r 3               
000E68r 3  80 14                        bra @done
000E6Ar 3               @table_done:
000E6Ar 3                               ; We're done with a table, because the entry was a zero.
000E6Ar 3                               ; We arrive here with ( addr u addr u 0 )
000E6Ar 3               
000E6Ar 3                               ; We take the flag from stack and increase it by one. If the
000E6Ar 3                               ; flag is zero, we have just completed the single-cell number
000E6Ar 3                               ; strings, so we in increase the flag and try again. Otherwise,
000E6Ar 3                               ; we're done with the double-cell table without having found
000E6Ar 3                               ; a match, and we're done
000E6Ar 3  68                           pla
000E6Br 3  D0 09                        bne @no_match
000E6Dr 3               
000E6Dr 3                               ; Flag is zero, increase it to one and start over to check
000E6Dr 3                               ; double-cell values
000E6Dr 3  1A                           inc
000E6Er 3  48                           pha
000E6Fr 3               
000E6Fr 3  8A                           txa
000E70r 3  18                           clc
000E71r 3  69 06                        adc #6                  ; skip six bytes
000E73r 3  AA                           tax                     ; ( addr u )
000E74r 3               
000E74r 3  80 92                        bra @table_loop
000E76r 3               @no_match:
000E76r 3                               ; Bummer, not found. We arrive here with
000E76r 3                               ; ( addr u addr u 0 ) and need to return just a zero
000E76r 3  8A                           txa
000E77r 3  18                           clc
000E78r 3  69 0A                        adc #10
000E7Ar 3  AA                           tax                     ; ( addr ) - not ( 0 ) !
000E7Br 3               
000E7Br 3  20 rr rr                     jsr xt_false
000E7Er 3               @done:
000E7Er 3               z_environment_q:
000E7Er 3  60                           rts
000E7Fr 3               
000E7Fr 3               
000E7Fr 3               ; Tables for ENVIRONMENT?. We use two separate ones, one for the single-cell
000E7Fr 3               ; results and one for the double-celled results. The zero cell at the
000E7Fr 3               ; end of each table marks its, uh, end. The strings themselves are defined
000E7Fr 3               ; in strings.asm. Note if we add more entries to the single-cell table, we
000E7Fr 3               ; have to adapt the result code for double printout, where we subtract 22
000E7Fr 3               ; (two bytes each single-cell string and two bytes for the end-of-table
000E7Fr 3               ; marker 0000
000E7Fr 3               env_table_single:
000E7Fr 3  rr rr rr rr          .word envs_cs, envs_hold, envs_pad, envs_aub, envs_floored
000E83r 3  rr rr rr rr  
000E87r 3  rr rr        
000E89r 3  rr rr rr rr          .word envs_max_char, envs_max_n, envs_max_u, envs_rsc
000E8Dr 3  rr rr rr rr  
000E91r 3  rr rr rr rr          .word envs_sc, envs_wl, 0000
000E95r 3  00 00        
000E97r 3               
000E97r 3               env_table_double:
000E97r 3  rr rr rr rr          .word envs_max_d, envs_max_ud, 0000
000E9Br 3  00 00        
000E9Dr 3               
000E9Dr 3               env_results_single:
000E9Dr 3  FF 7F                .word $7FFF     ; /COUNTED-STRING
000E9Fr 3  FF 00                .word $00FF     ; /HOLD
000EA1r 3  54 00                .word $0054     ; /PAD (this is 84 decimal)
000EA3r 3  08 00                .word $0008     ; ADDRESS-UNIT-BITS (keep "$" to avoid octal!)
000EA5r 3  00 00                .word 0000      ; FLOORED ("FALSE", we have symmetric)
000EA7r 3  FF 00                .word $00FF     ; MAX-CHAR
000EA9r 3  FF 7F                .word $7FFF     ; MAX-N
000EABr 3  FF FF                .word $FFFF     ; MAX-U
000EADr 3  80 00                .word $0080     ; RETURN-STACK-CELLS
000EAFr 3  20 00                .word $0020     ; STACK-CELLS (from definitions.asm)
000EB1r 3  09 00                .word $0009     ; WORDLISTS
000EB3r 3               
000EB3r 3               env_results_double:
000EB3r 3  FF 7F FF FF          .word $7FFF, $FFFF      ; MAX-D
000EB7r 3  FF FF FF FF          .word $FFFF, $FFFF      ; MAX-UD
000EBBr 3               
000EBBr 3               
000EBBr 3               ; ## EQUAL ( n n -- f ) "See if TOS and NOS are equal"
000EBBr 3               ; ## "="  auto  ANS core
000EBBr 3                       ; """https://forth-standard.org/standard/core/Equal"""
000EBBr 3               
000EBBr 3               xt_equal:
000EBBr 3  20 rr rr                     jsr underflow_2
000EBEr 3               
000EBEr 3  B5 00                        lda 0,x                 ; LSB
000EC0r 3  D5 02                        cmp 2,x
000EC2r 3  D0 0A                        bne @false
000EC4r 3               
000EC4r 3  B5 01                        lda 1,x                 ; MSB
000EC6r 3  D5 03                        cmp 3,x
000EC8r 3  D0 04                        bne @false
000ECAr 3               
000ECAr 3  A9 FF                        lda #$ff
000ECCr 3  80 02                        bra @done
000ECEr 3               
000ECEr 3  A9 00        @false:         lda #0                  ; drop thru to done
000ED0r 3               
000ED0r 3  95 02        @done:          sta 2,x
000ED2r 3  95 03                        sta 3,x
000ED4r 3               
000ED4r 3  E8                           inx
000ED5r 3  E8                           inx
000ED6r 3               
000ED6r 3  60           z_equal:        rts
000ED7r 3               
000ED7r 3               
000ED7r 3               
000ED7r 3               ; ## BLANK ( addr u -- ) "Fill memory region with spaces"
000ED7r 3               ; ## "blank"  auto  ANS string
000ED7r 3                       ; """https://forth-standard.org/standard/string/BLANK"""
000ED7r 3               xt_blank:
000ED7r 3                               ; We don't check for underflow here because
000ED7r 3                               ; we deal with that in FILL
000ED7r 3  CA                           dex
000ED8r 3  CA                           dex
000ED9r 3  A9 20                        lda #AscSP
000EDBr 3  95 00                        sta 0,x
000EDDr 3  74 01                        stz 1,x
000EDFr 3               
000EDFr 3  80 06                        bra xt_fill     ; skip over code for ERASE
000EE1r 3               
000EE1r 3               
000EE1r 3               ; ## ERASE ( addr u -- ) "Fill memory region with zeros"
000EE1r 3               ; ## "erase"  auto  ANS core ext
000EE1r 3                       ; """https://forth-standard.org/standard/core/ERASE
000EE1r 3                       ; Note that ERASE works with "address" units
000EE1r 3                       ; (bytes), not cells.
000EE1r 3                       ; """
000EE1r 3               
000EE1r 3               xt_erase:
000EE1r 3                               ; We don't check for underflow here because
000EE1r 3                               ; we deal with that in FILL
000EE1r 3  CA                           dex
000EE2r 3  CA                           dex
000EE3r 3  74 00                        stz 0,x
000EE5r 3  74 01                        stz 1,x
000EE7r 3               
000EE7r 3                               ; fall through to FILL
000EE7r 3               
000EE7r 3               ; ## FILL ( addr u char -- ) "Fill a memory region with a character"
000EE7r 3               ; ## "fill"  auto  ANS core
000EE7r 3                       ; """https://forth-standard.org/standard/core/FILL
000EE7r 3                       ; Fill u bytes of memory with char starting at addr. Note that
000EE7r 3                       ; this works on bytes, not on cells. On an 8-bit machine such as the
000EE7r 3                       ; 65c02, this is a serious pain in the rear. It is not defined what
000EE7r 3                       ; happens when we reach the end of the address space
000EE7r 3                       ; """
000EE7r 3               xt_fill:
000EE7r 3  20 rr rr                     jsr underflow_3
000EEAr 3               
000EEAr 3                               ; We use tmp1 to hold the address
000EEAr 3  B5 04                        lda 4,x         ; LSB
000EECr 3  85 rr                        sta tmp1
000EEEr 3  B5 05                        lda 5,x
000EF0r 3  85 rr                        sta tmp1+1
000EF2r 3               
000EF2r 3                               ; We use tmp2 to hold the counter
000EF2r 3  B5 02                        lda 2,x
000EF4r 3  85 rr                        sta tmp2
000EF6r 3  B5 03                        lda 3,x
000EF8r 3  85 rr                        sta tmp2+1
000EFAr 3               
000EFAr 3                               ; We use Y to hold the character
000EFAr 3  B5 00                        lda 0,x
000EFCr 3  A8                           tay
000EFDr 3               @loop:
000EFDr 3                               ; Unfortunately, we also need to make sure that we don't
000EFDr 3                               ; write further than the end of the RAM. So RAM_END must
000EFDr 3                               ; be larger or equal to the current address
000EFDr 3  A9 80                        lda #>ram_end           ; MSB
000EFFr 3  C5 rr                        cmp tmp1+1
000F01r 3  90 21                        bcc @done               ; RAM_END < TMP1, so leave
000F03r 3  D0 06                        bne @check_counter      ; RAM_END is not smaller and not equal
000F05r 3               
000F05r 3  A9 00                        lda #<ram_end           ; LSB, because MSBs were equal
000F07r 3  C5 rr                        cmp tmp1
000F09r 3  90 19                        bcc @done               ; RAM_END < TMP1, so leave
000F0Br 3               
000F0Br 3               @check_counter:
000F0Br 3                               ; See if our counter has reached zero
000F0Br 3  A5 rr                        lda tmp2
000F0Dr 3  05 rr                        ora tmp2+1
000F0Fr 3  F0 13                        beq @done
000F11r 3               
000F11r 3                               ; We're not in ROM and we still have stuff on the counter, so
000F11r 3                               ; let's actually do what we came here to do
000F11r 3  98                           tya
000F12r 3  92 rr                        sta (tmp1)
000F14r 3               
000F14r 3                               ; Adjust the counter
000F14r 3  A5 rr                        lda tmp2
000F16r 3  D0 02                        bne @1
000F18r 3  C6 rr                        dec tmp2+1
000F1Ar 3  C6 rr        @1:               dec tmp2
000F1Cr 3               
000F1Cr 3                               ; Next address
000F1Cr 3  E6 rr                        inc tmp1
000F1Er 3  D0 DD                        bne @loop
000F20r 3  E6 rr                        inc tmp1+1
000F22r 3               
000F22r 3  80 D9                        bra @loop
000F24r 3               
000F24r 3               @done:
000F24r 3                               ; Drop three cells off the Data Stack. This uses one byte
000F24r 3                               ; less than six times INX
000F24r 3  8A                           txa
000F25r 3  18                           clc
000F26r 3  69 06                        adc #6
000F28r 3  AA                           tax
000F29r 3               z_blank:
000F29r 3               z_erase:
000F29r 3  60           z_fill:         rts
000F2Ar 3               
000F2Ar 3               
000F2Ar 3               
000F2Ar 3               ; ## EXECUTE ( xt -- ) "Jump to word based on execution token"
000F2Ar 3               ; ## "execute"  auto  ANS core
000F2Ar 3                       ; """https://forth-standard.org/standard/core/EXECUTE"""
000F2Ar 3               xt_execute:
000F2Ar 3  20 rr rr                     jsr underflow_1
000F2Dr 3               
000F2Dr 3  20 rr rr                     jsr doexecute   ; do not combine to JMP (native coding)
000F30r 3               
000F30r 3  60           z_execute:      rts
000F31r 3               
000F31r 3               doexecute:
000F31r 3  B5 00                        lda 0,x
000F33r 3  85 rr                        sta ip
000F35r 3  B5 01                        lda 1,x
000F37r 3  85 rr                        sta ip+1
000F39r 3               
000F39r 3  E8                           inx
000F3Ar 3  E8                           inx
000F3Br 3               
000F3Br 3                               ; we don't need a RTS here because we highjack the RTS of
000F3Br 3                               ; the word we're calling to get back to xt_execute
000F3Br 3  6C rr rr                     jmp (ip)
000F3Er 3               
000F3Er 3               ; end of doexecute
000F3Er 3               
000F3Er 3               
000F3Er 3               ; ## EXECUTE_PARSING ( addr u xt -- ) "Pass a string to a parsing word"
000F3Er 3               ; ## "execute-parsing"  auto  Gforth
000F3Er 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
000F3Er 3                       ; Execute the parsing word defined by the execution token (xt) on the
000F3Er 3                       ; string as if it were passed on the command line. See the file
000F3Er 3                       ; tests/tali.fs for examples.
000F3Er 3                       ;
000F3Er 3                       ; Note that this word is coded completely
000F3Er 3                       ; different in its Gforth version, see the file execute-parsing.fs
000F3Er 3                       ; (in /usr/share/gforth/0.7.3/compat/ on Ubuntu 18.04 LTS) for details.
000F3Er 3                       ; """
000F3Er 3               xt_execute_parsing:
000F3Er 3  20 rr rr                     jsr underflow_3
000F41r 3               
000F41r 3  20 rr rr                     jsr xt_input_to_r       ; save normal input for later
000F44r 3  20 rr rr                     jsr xt_not_rote         ; -ROT ( xt addr u )
000F47r 3               
000F47r 3  B5 00                        lda 0,x                 ; TOS is new ciblen
000F49r 3  85 rr                        sta ciblen
000F4Br 3  B5 01                        lda 1,x
000F4Dr 3  85 rr                        sta ciblen+1
000F4Fr 3               
000F4Fr 3  B5 02                        lda 2,x                 ; NOS is new cib
000F51r 3  85 rr                        sta cib
000F53r 3  B5 03                        lda 3,x
000F55r 3  85 rr                        sta cib+1
000F57r 3               
000F57r 3  64 rr                        stz toin                ; Set >IN to zero
000F59r 3  64 rr                        stz toin+1
000F5Br 3               
000F5Br 3  20 rr rr                     jsr xt_two_drop         ; 2DROP ( xt )
000F5Er 3  20 rr rr                     jsr xt_execute
000F61r 3               
000F61r 3  20 rr rr                     jsr xt_r_to_input
000F64r 3               
000F64r 3               z_execute_parsing:
000F64r 3  60                           rts
000F65r 3               
000F65r 3               
000F65r 3               ; ## EXIT ( -- ) "Return control to the calling word immediately"
000F65r 3               ; ## "exit"  auto  ANS core
000F65r 3                       ; """https://forth-standard.org/standard/core/EXIT
000F65r 3                       ; If we're in a loop, we need to UNLOOP first and get everything
000F65r 3                       ; we we might have put on the Return Stack off as well. This should
000F65r 3                       ; be natively compiled.
000F65r 3                       ; """
000F65r 3               
000F65r 3               xt_exit:
000F65r 3  60                           rts             ; keep before z_exit
000F66r 3               z_exit:                         ; never reached
000F66r 3               
000F66r 3               
000F66r 3               
000F66r 3               ; ## FALSE ( -- f ) "Push flag FALSE to Data Stack"
000F66r 3               ; ## "false"  auto  ANS core ext
000F66r 3                       ; """https://forth-standard.org/standard/core/FALSE"""
000F66r 3               xt_false:
000F66r 3  CA                           dex
000F67r 3  CA                           dex
000F68r 3  74 00                        stz 0,x
000F6Ar 3  74 01                        stz 1,x
000F6Cr 3               
000F6Cr 3  60           z_false:        rts
000F6Dr 3               
000F6Dr 3               
000F6Dr 3               ; ## FETCH ( addr -- n ) "Push cell content from memory to stack"
000F6Dr 3               ; ## "@"  auto  ANS core
000F6Dr 3                       ; """https://forth-standard.org/standard/core/Fetch"""
000F6Dr 3               xt_fetch:
000F6Dr 3  20 rr rr                     jsr underflow_1
000F70r 3               
000F70r 3  A1 00                        lda (0,x)               ; LSB
000F72r 3  A8                           tay
000F73r 3  F6 00                        inc 0,x
000F75r 3  D0 02                        bne @1
000F77r 3  F6 01                        inc 1,x
000F79r 3               @1:
000F79r 3  A1 00                        lda (0,x)               ; MSB
000F7Br 3  95 01                        sta 1,x
000F7Dr 3  94 00                        sty 0,x
000F7Fr 3               
000F7Fr 3  60           z_fetch:        rts
000F80r 3               
000F80r 3               
000F80r 3               ; ## FIND ( caddr -- addr 0 | xt 1 | xt -1 ) "Find word in Dictionary"
000F80r 3               ; ## "find"  auto  ANS core
000F80r 3                       ; """https://forth-standard.org/standard/core/FIND
000F80r 3                       ; Included for backwards compatibility only, because it still
000F80r 3                       ; can be found in so may examples. It should, however, be replaced
000F80r 3                       ; by FIND-NAME. Counted string either returns address with a FALSE
000F80r 3                       ; flag if not found in the Dictionary, or the xt with a flag to
000F80r 3                       ; indicate if this is immediate or not. FIND is a wrapper around
000F80r 3                       ; FIND-NAME, we get this all over with as quickly as possible. See
000F80r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html
000F80r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000F80r 3                       ; """
000F80r 3               
000F80r 3               xt_find:
000F80r 3  20 rr rr                     jsr underflow_1
000F83r 3               
000F83r 3                               ; Save address in case conversion fails. We use the
000F83r 3                               ; Return Stack instead of temporary variables like TMP1
000F83r 3                               ; because this is shorter and anybody still using FIND
000F83r 3                               ; can't be worried about speed anyway
000F83r 3  B5 01                        lda 1,x                 ; MSB
000F85r 3  48                           pha
000F86r 3  B5 00                        lda 0,x                 ; LSB
000F88r 3  48                           pha
000F89r 3               
000F89r 3                               ; Convert ancient-type counted string address to
000F89r 3                               ; modern format
000F89r 3  20 rr rr                     jsr xt_count            ; ( caddr -- addr u )
000F8Cr 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt | 0 )
000F8Fr 3               
000F8Fr 3  B5 00                        lda 0,x
000F91r 3  15 01                        ora 1,x
000F93r 3  D0 0B                        bne @found_word
000F95r 3               
000F95r 3                               ; No word found. Return address of the string and a false
000F95r 3                               ; flag
000F95r 3  20 rr rr                     jsr xt_false            ; ( 0 0 )
000F98r 3               
000F98r 3                               ; The address needs to be restored.
000F98r 3  68                           pla                     ; LSB of address
000F99r 3  95 02                        sta 2,x
000F9Br 3  68                           pla
000F9Cr 3  95 03                        sta 3,x                 ; MSB of address
000F9Er 3               
000F9Er 3  80 27                        bra @done               ; ( addr 0 )
000FA0r 3               
000FA0r 3               @found_word:
000FA0r 3                               ; We don't need the address after all, dump it
000FA0r 3  68                           pla
000FA1r 3  68                           pla
000FA2r 3               
000FA2r 3                               ; We arrive here with ( nt ) on the TOS. Now we have to
000FA2r 3                               ; convert the return values to FIND's format
000FA2r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
000FA5r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
000FA8r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
000FABr 3               
000FABr 3  A0 00                        ldy #0                  ; Prepare flag
000FADr 3               
000FADr 3                               ; The flags are in the second byte of the header
000FADr 3  F6 00                        inc 0,x
000FAFr 3  D0 02                        bne @1
000FB1r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
000FB3r 3               @1:
000FB3r 3  A1 00                        lda (0,x)               ; ( xt char )
000FB5r 3  29 04                        and #IM
000FB7r 3  D0 08                        bne @immediate          ; bit set, we're immediate
000FB9r 3               
000FB9r 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
000FBBr 3  95 00                        sta 0,x
000FBDr 3  95 01                        sta 1,x
000FBFr 3  80 06                        bra @done
000FC1r 3               
000FC1r 3               @immediate:
000FC1r 3  A9 01                        lda #1                  ; We're immediate, return 1
000FC3r 3  95 00                        sta 0,x
000FC5r 3  74 01                        stz 1,x
000FC7r 3               @done:
000FC7r 3  60           z_find:         rts
000FC8r 3               
000FC8r 3               
000FC8r 3               
000FC8r 3               ; ## FIND_NAME ( addr u -- nt|0 ) "Get the name token of input word"
000FC8r 3               ; ## "find-name"  auto  Gforth
000FC8r 3               
000FC8r 3               xt_find_name:
000FC8r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000FC8r 3                       ; Given a string, find the Name Token (nt) of a word or return
000FC8r 3                       ; zero if the word is not in the dictionary. We use this instead of
000FC8r 3                       ; ancient FIND to look up words in the Dictionary passed by
000FC8r 3                       ; PARSE-NAME. Note this returns the nt, not the xt of a word like
000FC8r 3                       ; FIND. To convert, use NAME>INT. This is a Gforth word. See
000FC8r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
000FC8r 3                       ; FIND calls this word
000FC8r 3                       ; """
000FC8r 3  20 rr rr                     jsr underflow_2
000FCBr 3               
000FCBr 3                               ; check for special case of an empty string (length zero)
000FCBr 3  B5 00                        lda 0,x
000FCDr 3  15 01                        ora 1,x
000FCFr 3  D0 03                        bne @nonempty
000FD1r 3               
000FD1r 3  4C rr rr                     jmp @fail_done
000FD4r 3               
000FD4r 3               @nonempty:
000FD4r 3                               ; Set up for traversing the wordlist search order.
000FD4r 3  64 rr                        stz tmp3                ; Start at the beginning
000FD6r 3               
000FD6r 3               @wordlist_loop:
000FD6r 3  A0 1E                        ldy #num_order_offset   ; Compare to byte variable #ORDER
000FD8r 3  A5 rr                        lda tmp3
000FDAr 3  D1 rr                        cmp (up),y              ; Check to see if we are done
000FDCr 3  D0 03                        bne @have_string
000FDEr 3               
000FDEr 3                               ; We ran out of wordlists to search.
000FDEr 3  4C rr rr                     jmp @fail_done
000FE1r 3               
000FE1r 3               @have_string:
000FE1r 3                               ; set up first loop iteration
000FE1r 3               
000FE1r 3                               ; Get the current wordlist id
000FE1r 3  18                           clc             ; SEARCH-ORDER is array of bytes.
000FE2r 3  69 1F                        adc #search_order_offset
000FE4r 3  A8                           tay
000FE5r 3  B1 rr                        lda (up),y      ; Get the id byte, which is the offset
000FE7r 3                                               ; into the cell array WORDLISTS
000FE7r 3               
000FE7r 3                               ; Get the DP for that wordlist.
000FE7r 3  0A                           asl                     ; Turn offset into cells offset.
000FE8r 3  18                           clc
000FE9r 3  69 06                        adc #wordlists_offset
000FEBr 3  A8                           tay
000FECr 3  B1 rr                        lda (up),y
000FEEr 3  85 rr                        sta tmp1
000FF0r 3  C8                           iny
000FF1r 3  B1 rr                        lda (up),y
000FF3r 3  85 rr                        sta tmp1+1
000FF5r 3               
000FF5r 3  B5 02                        lda 2,x                 ; Address of mystery string
000FF7r 3  85 rr                        sta tmp2
000FF9r 3  B5 03                        lda 3,x
000FFBr 3  85 rr                        sta tmp2+1
000FFDr 3               
000FFDr 3               @loop:
000FFDr 3                               ; first quick test: Are strings the same length?
000FFDr 3  B2 rr                        lda (tmp1)
000FFFr 3  D5 00                        cmp 0,x
001001r 3  D0 54                        bne @next_entry
001003r 3               
001003r 3               @compare_string:
001003r 3                               ; are the same length, so we now have to compare each
001003r 3                               ; character
001003r 3               
001003r 3                               ; second quick test: Is the first character the same?
001003r 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001005r 3               
001005r 3                               ; Lowercase the incoming charcter.
001005r 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001007r 3  B0 07                        bcs @compare_first
001009r 3  C9 41                        cmp #$41        ; ASCII 'A'
00100Br 3  90 03                        bcc @compare_first
00100Dr 3               
00100Dr 3                               ; An uppercase letter has been located.  Make it
00100Dr 3                               ; lowercase.
00100Dr 3  18                           clc
00100Er 3  69 20                        adc #$20
001010r 3               
001010r 3               @compare_first:
001010r 3  A0 08                        ldy #8          ; Offset in nt to name
001012r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
001014r 3  D0 41                        bne @next_entry
001016r 3               
001016r 3                               ; String length is the same and the first character is the
001016r 3                               ; same. If the length of the string is 1, we're already done
001016r 3  B5 00                        lda 0,x
001018r 3  3A                           dec
001019r 3  F0 2C                        beq @success
00101Br 3               
00101Br 3                               ; No such luck: The strings are the same length and the first
00101Br 3                               ; char is the same, but the word is more than one char long.
00101Br 3                               ; So we suck it up and compare every single character. We go
00101Br 3                               ; from back to front, because words like CELLS and CELL+ would
00101Br 3                               ; take longer otherwise. We can also shorten the loop by one
00101Br 3                               ; because we've already compared the first char.
00101Br 3               
00101Br 3                               ; The string of the word we're testing against is 8 bytes down
00101Br 3  A5 rr                        lda tmp1
00101Dr 3  48                           pha             ; Preserve tmp1 on the return stack.
00101Er 3  18                           clc
00101Fr 3  69 08                        adc #8
001021r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001023r 3  A5 rr                        lda tmp1+1
001025r 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001026r 3  69 00                        adc #0          ; we only need the carry
001028r 3  85 rr                        sta tmp1+1
00102Ar 3               
00102Ar 3  B4 00                        ldy 0,x         ; index is length of string minus 1
00102Cr 3  88                           dey
00102Dr 3               
00102Dr 3               @string_loop:
00102Dr 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
00102Fr 3               
00102Fr 3                               ; Lowercase the incoming charcter.
00102Fr 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001031r 3  B0 07                        bcs @check_char
001033r 3  C9 41                        cmp #$41        ; ASCII 'A'
001035r 3  90 03                        bcc @check_char
001037r 3               
001037r 3                               ; An uppercase letter has been located.  Make it
001037r 3                               ; lowercase.
001037r 3  18                           clc
001038r 3  69 20                        adc #$20
00103Ar 3               
00103Ar 3               @check_char:
00103Ar 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
00103Cr 3  D0 13                        bne @next_entry_tmp1
00103Er 3               
00103Er 3  88                           dey
00103Fr 3  D0 EC                        bne @string_loop
001041r 3               
001041r 3               @success_tmp1:
001041r 3  68                           pla             ; Restore tmp1 from the return stack.
001042r 3  85 rr                        sta tmp1+1
001044r 3  68                           pla
001045r 3  85 rr                        sta tmp1
001047r 3               
001047r 3               @success:
001047r 3                               ; The strings match. Put correct nt NOS, because we'll drop
001047r 3                               ; TOS before we leave
001047r 3  A5 rr                        lda tmp1
001049r 3  95 02                        sta 2,x
00104Br 3  A5 rr                        lda tmp1+1
00104Dr 3  95 03                        sta 3,x
00104Fr 3               
00104Fr 3  80 20                        bra @done
001051r 3               
001051r 3               @next_entry_tmp1:
001051r 3  68                           pla             ; Restore tmp1 from the return stack.
001052r 3  85 rr                        sta tmp1+1
001054r 3  68                           pla
001055r 3  85 rr                        sta tmp1
001057r 3               
001057r 3               @next_entry:
001057r 3                               ; Not the same, so we get the next word. Next header
001057r 3                               ; address is two bytes down
001057r 3  A0 02                        ldy #2
001059r 3  B1 rr                        lda (tmp1),y
00105Br 3  48                           pha
00105Cr 3  C8                           iny
00105Dr 3  B1 rr                        lda (tmp1),y
00105Fr 3  85 rr                        sta tmp1+1
001061r 3  68                           pla
001062r 3  85 rr                        sta tmp1
001064r 3               
001064r 3                               ; If we got a zero, we've walked the whole Dictionary and
001064r 3                               ; return as a failure, otherwise try again
001064r 3  05 rr                        ora tmp1+1
001066r 3  D0 95                        bne @loop
001068r 3               
001068r 3                               ; Move on to the next wordlist in the search order.
001068r 3  E6 rr                        inc tmp3
00106Ar 3  4C rr rr                     jmp @wordlist_loop
00106Dr 3               
00106Dr 3               @fail_done:
00106Dr 3  74 02                        stz 2,x         ; failure flag
00106Fr 3  74 03                        stz 3,x
001071r 3               @done:
001071r 3  E8                           inx
001072r 3  E8                           inx
001073r 3               
001073r 3  60           z_find_name:    rts
001074r 3               
001074r 3               
001074r 3               
001074r 3               ; ## FLUSH ( -- ) "Save dirty buffers and empty buffers"
001074r 3               ; ## "flush"  auto  ANS block
001074r 3                       ; """https://forth-standard.org/standard/block/FLUSH"""
001074r 3               xt_flush:
001074r 3  20 rr rr                     jsr xt_save_buffers
001077r 3               
001077r 3                               ; Set the buffer status to empty.
001077r 3  A0 2C                        ldy #buffstatus_offset
001079r 3  A9 00                        lda #0
00107Br 3  91 rr                        sta (up),y      ; Only LSB is used.
00107Dr 3               z_flush:
00107Dr 3  60                           rts
00107Er 3               
00107Er 3               
00107Er 3               ; ## FM_SLASH_MOD ( d n1  -- rem n2 ) "Floored signed division"
00107Er 3               ; ## "fm/mod"  auto  ANS core
00107Er 3                       ; """https://forth-standard.org/standard/core/FMDivMOD
00107Er 3                       ; Note that by default, Tali Forth uses SM/REM for most things.
00107Er 3                       ;
00107Er 3                       ; There are various ways to realize this. We follow EForth with
00107Er 3                       ;    DUP 0< DUP >R  IF NEGATE >R DNEGATE R> THEN >R DUP
00107Er 3                       ;    0<  IF R@ + THEN  R> UM/MOD R> IF SWAP NEGATE SWAP THEN
00107Er 3                       ; See (http://www.forth.org/eforth.html). However you can also
00107Er 3                       ; go FM/MOD via SM/REM (http://www.figuk.plus.com/build/arith.htm):
00107Er 3                       ;     DUP >R  SM/REM DUP 0< IF SWAP R> + SWAP 1+ ELSE  R> DROP THEN
00107Er 3                       ; """
00107Er 3               
00107Er 3               xt_fm_slash_mod:
00107Er 3  20 rr rr                     jsr underflow_3
001081r 3               
001081r 3                               ; if sign of n1 is negative, negate both n1 and d
001081r 3  64 rr                        stz tmp2        ; default: n is positive
001083r 3  B5 01                        lda 1,x         ; MSB of n1
001085r 3  10 0E                        bpl @check_d
001087r 3               
001087r 3  E6 rr                        inc tmp2        ; set flag to negative for n1
001089r 3  20 rr rr                     jsr xt_negate   ; NEGATE
00108Cr 3  20 rr rr                     jsr xt_to_r     ; >R
00108Fr 3  20 rr rr                     jsr xt_dnegate  ; DNEGATE
001092r 3  20 rr rr                     jsr xt_r_from   ; R>
001095r 3               
001095r 3               @check_d:
001095r 3                               ; If d is negative, add n1 to high cell of d
001095r 3  B5 03                        lda 3,x         ; MSB of high word of d
001097r 3  10 0D                        bpl @multiply
001099r 3               
001099r 3  18                           clc
00109Ar 3  B5 00                        lda 0,x         ; LSB of n1
00109Cr 3  75 02                        adc 2,x         ; LSB of dh
00109Er 3  95 02                        sta 2,x
0010A0r 3               
0010A0r 3  B5 01                        lda 1,x         ; MSB of n1
0010A2r 3  75 03                        adc 3,x         ; MSB of dh
0010A4r 3  95 03                        sta 3,x
0010A6r 3               
0010A6r 3               @multiply:
0010A6r 3  20 rr rr                     jsr xt_um_slash_mod     ; ( d n1 -- rem n2 )
0010A9r 3               
0010A9r 3                               ; if n was negative, negate the result
0010A9r 3  A5 rr                        lda tmp2
0010ABr 3  F0 07                        beq @done
0010ADr 3               
0010ADr 3  E8                           inx             ; pretend that we SWAP
0010AEr 3  E8                           inx
0010AFr 3  20 rr rr                     jsr xt_negate
0010B2r 3  CA                           dex
0010B3r 3  CA                           dex
0010B4r 3               @done:
0010B4r 3  60           z_fm_slash_mod: rts
0010B5r 3               
0010B5r 3               
0010B5r 3               
0010B5r 3               ; ## FORTH ( -- ) "Replace first WID in search order with Forth-Wordlist"
0010B5r 3               ; ## "forth"  auto  ANS search ext
0010B5r 3                       ; """https://forth-standard.org/standard/search/FORTH"""
0010B5r 3               xt_forth:
0010B5r 3  A0 1F                        ldy #search_order_offset
0010B7r 3  A9 00                        lda #0          ; The WID for Forth is 0.
0010B9r 3               
0010B9r 3  91 rr                        sta (up),y
0010BBr 3               z_forth:
0010BBr 3  60                           rts
0010BCr 3               
0010BCr 3               
0010BCr 3               ; This is a special jsr target to skip the zeroing of BLK at the beginning
0010BCr 3               ; of evaluate.  It's used by LOAD to allow setting BLK while the block is
0010BCr 3               ; being evaluated.  Evaluate's normal behavior is to zero BLK.
0010BCr 3               load_evaluate:
0010BCr 3                               ; Set a flag (using tmp1) to not zero BLK
0010BCr 3  A9 FF                        lda #$FF
0010BEr 3  85 rr                        sta tmp1
0010C0r 3  80 11                        bra load_evaluate_start
0010C2r 3               
0010C2r 3               ; ## EVALUATE ( addr u -- ) "Execute a string"
0010C2r 3               ; ## "evaluate"  auto  ANS core
0010C2r 3                       ; """https://forth-standard.org/standard/core/EVALUATE
0010C2r 3                       ; Set SOURCE-ID to -1, make addr u the input source, set >IN to zero.
0010C2r 3                       ; After processing the line, revert to old input source. We use this
0010C2r 3                       ; to compile high-level Forth words and user-defined words during
0010C2r 3                       ; start up and cold boot. In contrast to ACCEPT, we need to, uh,
0010C2r 3                       ; accept more than 255 characters here, even though it's a pain in
0010C2r 3                       ; the 8-bit.
0010C2r 3                       ; """
0010C2r 3               
0010C2r 3               xt_evaluate:
0010C2r 3  20 rr rr                     jsr underflow_2
0010C5r 3               
0010C5r 3                               ; Clear the flag to zero BLK.  Only LOAD will set the flag,
0010C5r 3                               ; and will set the block number.
0010C5r 3  64 rr                        stz tmp1
0010C7r 3               
0010C7r 3                               ; If u is zero (which can happen a lot for the user-defined
0010C7r 3                               ; words), just leave again
0010C7r 3  B5 00                        lda 0,x
0010C9r 3  15 01                        ora 1,x
0010CBr 3  D0 06                        bne _eval_got_work
0010CDr 3               
0010CDr 3  E8                           inx
0010CEr 3  E8                           inx
0010CFr 3  E8                           inx
0010D0r 3  E8                           inx
0010D1r 3               
0010D1r 3  80 42                        bra _eval_done
0010D3r 3               
0010D3r 3               ; Special entry point for LOAD to bypass the zeroing of BLK.
0010D3r 3               load_evaluate_start:
0010D3r 3               _eval_got_work:
0010D3r 3                               ; Save the current value of BLK on the return stack.
0010D3r 3  A0 01                        ldy #blk_offset+1
0010D5r 3  B1 rr                        lda (up),y
0010D7r 3  48                           pha
0010D8r 3  88                           dey
0010D9r 3  B1 rr                        lda (up),y
0010DBr 3  48                           pha
0010DCr 3               
0010DCr 3                               ; See if we should zero BLK.
0010DCr 3  A5 rr                        lda tmp1
0010DEr 3  D0 05                        bne @nozero
0010E0r 3               
0010E0r 3                               ; Set BLK to zero.
0010E0r 3                               ; lda #0        ; A is already zero from loading tmp1
0010E0r 3  91 rr                        sta (up),y
0010E2r 3  C8                           iny
0010E3r 3  91 rr                        sta (up),y
0010E5r 3               
0010E5r 3               @nozero:
0010E5r 3                               ; Save the input state to the Return Stack
0010E5r 3  20 rr rr                     jsr xt_input_to_r
0010E8r 3               
0010E8r 3                               ; set SOURCE-ID to -1
0010E8r 3  A9 FF                        lda #$ff
0010EAr 3  85 rr                        sta insrc
0010ECr 3  85 rr                        sta insrc+1
0010EEr 3               
0010EEr 3                               ; set >IN to zero
0010EEr 3  64 rr                        stz toin
0010F0r 3  64 rr                        stz toin+1
0010F2r 3               
0010F2r 3                               ; move TOS and NOS to input buffers
0010F2r 3  B5 00                        lda 0,x
0010F4r 3  85 rr                        sta ciblen
0010F6r 3  B5 01                        lda 1,x
0010F8r 3  85 rr                        sta ciblen+1
0010FAr 3               
0010FAr 3  B5 02                        lda 2,x
0010FCr 3  85 rr                        sta cib
0010FEr 3  B5 03                        lda 3,x
001100r 3  85 rr                        sta cib+1
001102r 3               
001102r 3  E8                           inx             ; A clean stack is a clean mind
001103r 3  E8                           inx
001104r 3  E8                           inx
001105r 3  E8                           inx
001106r 3               
001106r 3  20 rr rr                     jsr interpret   ; ( -- )
001109r 3               
001109r 3                               ; restore variables
001109r 3  20 rr rr                     jsr xt_r_to_input
00110Cr 3               
00110Cr 3                               ; Restore BLK from the return stack.
00110Cr 3  A0 00                        ldy #blk_offset
00110Er 3  68                           pla
00110Fr 3  91 rr                        sta (up),y
001111r 3  C8                           iny
001112r 3  68                           pla
001113r 3  91 rr                        sta (up),y
001115r 3               
001115r 3               _eval_done:
001115r 3  60           z_evaluate:     rts
001116r 3               
001116r 3               
001116r 3               
001116r 3               ; ## FORTH_WORDLIST ( -- u ) "WID for the Forth Wordlist"
001116r 3               ; ## "forth-wordlist"  auto  ANS search
001116r 3                       ; """https://forth-standard.org/standard/search/FORTH-WORDLIST"""
001116r 3                       ; This is a dummy entry, the actual code is shared with ZERO.
001116r 3               
001116r 3               
001116r 3               ; ## GET_CURRENT ( -- wid ) "Get the id of the compilation wordlist"
001116r 3               ; ## "get-current" auto ANS search
001116r 3                       ; """https://forth-standard.org/standard/search/GET-CURRENT"""
001116r 3               
001116r 3               xt_get_current:
001116r 3                               ; This is a little different than some of the variables
001116r 3                               ; in the user area as we want the value rather than
001116r 3                               ; the address.
001116r 3  CA                           dex
001117r 3  CA                           dex
001118r 3  A0 04                        ldy #current_offset
00111Ar 3  B1 rr                        lda (up),y
00111Cr 3  95 00                        sta 0,x         ; CURRENT is a byte variable
00111Er 3  74 01                        stz 1,x         ; so the MSB is zero.
001120r 3               
001120r 3  60           z_get_current:  rts
001121r 3               
001121r 3               
001121r 3               
001121r 3               ; ## GET_ORDER ( -- wid_n .. wid_1 n) "Get the current search order"
001121r 3               ; ## "get-order" auto ANS search
001121r 3                       ; """https://forth-standard.org/standard/search/GET-ORDER"""
001121r 3               
001121r 3               xt_get_order:
001121r 3                               ; Get #ORDER - the number of wordlists in the search order.
001121r 3  A0 1E                        ldy #num_order_offset
001123r 3  B1 rr                        lda (up),y
001125r 3  85 rr                        sta tmp1
001127r 3  F0 16                        beq @done       ; If zero, there are no wordlists.
001129r 3               
001129r 3               @loop:
001129r 3                               ; Count down towards the front of the list.
001129r 3                               ; By decrementing first, we also turn the length into an offset.
001129r 3  C6 rr                        dec tmp1        ; Count down by bytes.
00112Br 3               
00112Br 3                               ; Get a pointer to the current wordlist, working back to front.
00112Br 3  A9 1F                        lda #search_order_offset
00112Dr 3  18                           clc
00112Er 3  65 rr                        adc tmp1
001130r 3  A8                           tay
001131r 3               
001131r 3                               ; Put that wordlist id on the stack.
001131r 3  CA                           dex
001132r 3  CA                           dex
001133r 3  B1 rr                        lda (up),y
001135r 3  95 00                        sta 0,x         ; Search order array is bytes, so
001137r 3  74 01                        stz 1,x         ; put a zero in the high byte.
001139r 3               
001139r 3                               ; See if that was the last one to process (first in the list).
001139r 3  A9 00                        lda #0
00113Br 3  C5 rr                        cmp tmp1
00113Dr 3  D0 EA                        bne @loop
00113Fr 3               
00113Fr 3               @done:
00113Fr 3                               ; Put the number of items on the stack.
00113Fr 3  CA                           dex
001140r 3  CA                           dex
001141r 3  A0 1E                        ldy #num_order_offset
001143r 3  B1 rr                        lda (up),y
001145r 3  95 00                        sta 0,x
001147r 3  74 01                        stz 1,x         ; We only support 8 wordlists.
001149r 3               
001149r 3  60           z_get_order:    rts
00114Ar 3               
00114Ar 3               
00114Ar 3               
00114Ar 3               ; ## GREATER_THAN ( n n -- f ) "See if NOS is greater than TOS"
00114Ar 3               ; ## ">"  auto  ANS core
00114Ar 3                       ; """https://forth-standard.org/standard/core/more"""
00114Ar 3               
00114Ar 3               xt_greater_than:
00114Ar 3  20 rr rr                     jsr underflow_2
00114Dr 3               
00114Dr 3  A0 00                        ldy #0          ; default false
00114Fr 3  20 rr rr                     jsr compare_16bit
001152r 3               
001152r 3                               ; for signed numbers, NOS>TOS gives us Z=0 and N=1
001152r 3  F0 03                        beq @false
001154r 3  10 01                        bpl @false
001156r 3               
001156r 3                               ; true
001156r 3  88                           dey
001157r 3               @false:
001157r 3  98                           tya
001158r 3               
001158r 3  E8                           inx
001159r 3  E8                           inx
00115Ar 3  95 00                        sta 0,x
00115Cr 3  95 01                        sta 1,x
00115Er 3               
00115Er 3  60           z_greater_than: rts
00115Fr 3               
00115Fr 3               
00115Fr 3               
00115Fr 3               ; ## HERE ( -- addr ) "Put Compiler Pointer on Data Stack"
00115Fr 3               ; ## "here"  auto  ANS core
00115Fr 3                       ; """https://forth-standard.org/standard/core/HERE
00115Fr 3                       ; This code is also used by the assembler directive ARROW
00115Fr 3                       ; ("->") though as immediate"""
00115Fr 3               xt_here:
00115Fr 3               xt_asm_arrow:
00115Fr 3  CA                           dex
001160r 3  CA                           dex
001161r 3  A5 rr                        lda cp
001163r 3  95 00                        sta 0,x
001165r 3  A5 rr                        lda cp+1
001167r 3  95 01                        sta 1,x
001169r 3               
001169r 3               z_asm_arrow:
001169r 3  60           z_here:         rts
00116Ar 3               
00116Ar 3               
00116Ar 3               ; ## HEX ( -- ) "Change base radix to hexadecimal"
00116Ar 3               ; ## "hex"  auto  ANS core ext
00116Ar 3                       ; """https://forth-standard.org/standard/core/HEX"""
00116Ar 3               xt_hex:
00116Ar 3  A9 10                        lda #16
00116Cr 3  85 rr                        sta base
00116Er 3  64 rr                        stz base+1              ; paranoid
001170r 3               
001170r 3  60           z_hex:          rts
001171r 3               
001171r 3               
001171r 3               ; ## HEXSTORE ( addr1 u1 addr2 -- u2 ) "Store a list of numbers"
001171r 3               ; ## "hexstore"  auto  Tali
001171r 3                       ; """Given a string addr1 u1 with numbers in the current base seperated
001171r 3                       ; by spaces, store the numbers at the address addr2, returning the
001171r 3                       ; number of elements. Non-number elements are skipped, an zero-length
001171r 3                       ; string produces a zero output.
001171r 3                       ; """
001171r 3               
001171r 3               xt_hexstore:
001171r 3  20 rr rr                     jsr underflow_3
001174r 3               
001174r 3  20 rr rr                     jsr xt_dup              ; Save copy of original address
001177r 3  20 rr rr                     jsr xt_two_to_r         ; ( addr1 u1 ) ( R: addr2 addr2 )
00117Ar 3               
00117Ar 3               @loop:
00117Ar 3                               ; Loop until string is totally consumed
00117Ar 3  B5 00                        lda 0,x
00117Cr 3  15 01                        ora 1,x
00117Er 3  F0 36                        beq @done
001180r 3               
001180r 3  20 rr rr                     jsr xt_cleave           ; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
001183r 3               
001183r 3                               ; Prepare the conversion of the number.
001183r 3  20 rr rr                     jsr xt_two_to_r
001186r 3  20 rr rr                     jsr xt_zero
001189r 3  20 rr rr                     jsr xt_zero
00118Cr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
00118Fr 3  20 rr rr                     jsr xt_to_number        ; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
001192r 3               
001192r 3                               ; If u4 is not zero, we have leftover chars and have to do
001192r 3                               ; things differently
001192r 3  B5 00                        lda 0,x
001194r 3  15 01                        ora 1,x
001196r 3  D0 17                        bne @have_chars_left
001198r 3               
001198r 3                               ; Normal case, this number is all done
001198r 3  20 rr rr                     jsr xt_two_drop         ; ( addr1 u1 n n ) ( R: addr2 addr2 )
00119Br 3  20 rr rr                     jsr xt_d_to_s           ; ( addr1 u1 n ) ( R: addr2 addr2 )
00119Er 3               
00119Er 3                               ; Store the new value
00119Er 3  20 rr rr                     jsr xt_r_fetch          ; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
0011A1r 3  20 rr rr                     jsr xt_c_store          ; ( addr1 u1 ) ( R: addr2 addr2 )
0011A4r 3               
0011A4r 3                               ; Increase counter
0011A4r 3  20 rr rr                     jsr xt_r_from           ; R>
0011A7r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0011AAr 3  20 rr rr                     jsr xt_to_r             ; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
0011ADr 3  80 CB                        bra @loop
0011AFr 3               
0011AFr 3               @have_chars_left:
0011AFr 3                               ; Pathological case: Drop the rest of this number off the stack
0011AFr 3                               ; and continue with the next word. Doesn't print a warning. We
0011AFr 3                               ; need to drop four cells, that is, eight bytes
0011AFr 3  8A                           txa
0011B0r 3  18                           clc
0011B1r 3  69 08                        adc #8
0011B3r 3  AA                           tax
0011B4r 3  80 C4                        bra @loop
0011B6r 3               
0011B6r 3               @done:
0011B6r 3                               ; Clean up return stack and calculate number of chars stored
0011B6r 3  E8                           inx
0011B7r 3  E8                           inx
0011B8r 3  E8                           inx
0011B9r 3  E8                           inx                     ; 2DROP
0011BAr 3               
0011BAr 3  20 rr rr                     jsr xt_two_r_from       ; ( addr2+n addr2 )
0011BDr 3  20 rr rr                     jsr xt_swap
0011C0r 3  20 rr rr                     jsr xt_minus            ; ( n )
0011C3r 3               
0011C3r 3  60           z_hexstore:     rts
0011C4r 3               
0011C4r 3               
0011C4r 3               
0011C4r 3               ; ## HOLD ( char -- ) "Insert character at current output"
0011C4r 3               ; ## "hold"  auto  ANS core
0011C4r 3                       ; """https://forth-standard.org/standard/core/HOLD
0011C4r 3                       ; Insert a character at the current position of a pictured numeric
0011C4r 3                       ; output string on
0011C4r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
0011C4r 3                       ;
0011C4r 3                       ; Forth code is : HOLD  -1 HLD +!  HLD @ C! ;  We use the the internal
0011C4r 3                       ; variable tohold instead of HLD.
0011C4r 3                       ; """
0011C4r 3               xt_hold:
0011C4r 3  20 rr rr                     jsr underflow_1
0011C7r 3               
0011C7r 3  A5 rr                        lda tohold
0011C9r 3  D0 02                        bne @1
0011CBr 3  C6 rr                        dec tohold+1
0011CDr 3               @1:
0011CDr 3  C6 rr                        dec tohold
0011CFr 3               
0011CFr 3  B5 00                        lda 0,x
0011D1r 3  92 rr                        sta (tohold)
0011D3r 3  E8                           inx
0011D4r 3  E8                           inx
0011D5r 3               
0011D5r 3  60           z_hold:         rts
0011D6r 3               
0011D6r 3               
0011D6r 3               ; ## I ( -- n )(R: n -- n)  "Copy loop counter to stack"
0011D6r 3               ; ## "i"  auto  ANS core
0011D6r 3                       ; """https://forth-standard.org/standard/core/I
0011D6r 3                       ; Note that this is not the same as R@ because we use a fudge
0011D6r 3                       ; factor for loop control; see the Control Flow section of the
0011D6r 3                       ; manual for details.
0011D6r 3                       ;
0011D6r 3                       ; We should make this native compile for speed.
0011D6r 3                       ; """
0011D6r 3               
0011D6r 3               xt_i:
0011D6r 3  CA                           dex
0011D7r 3  CA                           dex
0011D8r 3               
0011D8r 3                               ; Get the fudged index off of the top of the stack. It's
0011D8r 3                               ; easier to do math on the stack directly than to pop and
0011D8r 3                               ; push stuff around
0011D8r 3  86 rr                        stx tmpdsp
0011DAr 3  BA                           tsx
0011DBr 3               
0011DBr 3  38                           sec
0011DCr 3  BD 01 01                     lda $0101,x     ; LSB
0011DFr 3  FD 03 01                     sbc $0103,x
0011E2r 3  A8                           tay
0011E3r 3               
0011E3r 3  BD 02 01                     lda $0102,x     ; MSB
0011E6r 3  FD 04 01                     sbc $0104,x
0011E9r 3               
0011E9r 3  A6 rr                        ldx tmpdsp
0011EBr 3               
0011EBr 3  95 01                        sta 1,x         ; MSB of de-fudged index
0011EDr 3  94 00                        sty 0,x         ; LSB of de-fudged index
0011EFr 3               
0011EFr 3  60           z_i:            rts
0011F0r 3               
0011F0r 3               
0011F0r 3               
0011F0r 3               ; ## IF (C: -- orig) (flag -- ) "Conditional flow control"
0011F0r 3               ; ## "if"  auto  ANS core
0011F0r 3                       ; """http://forth-standard.org/standard/core/IF"""
0011F0r 3               
0011F0r 3               xt_if:
0011F0r 3                               ; Compile a 0BRANCH
0011F0r 3  A0 rr                        ldy #>zero_branch_runtime
0011F2r 3  A9 rr                        lda #<zero_branch_runtime
0011F4r 3  20 rr rr                     jsr cmpl_subroutine
0011F7r 3               
0011F7r 3                               ; Put the origination address on the stack for else/then
0011F7r 3  20 rr rr                     jsr xt_here
0011FAr 3               
0011FAr 3                               ; Stuff zero in for the branch address right now.
0011FAr 3                               ; THEN or ELSE will fix it later.
0011FAr 3  20 rr rr                     jsr xt_zero
0011FDr 3  20 rr rr                     jsr xt_comma
001200r 3  60           z_if:           rts
001201r 3               
001201r 3               
001201r 3               zero_branch_runtime:
001201r 3                       ; """In some Forths, this is called (0BRANCH). Tali Forth originally
001201r 3                       ; included 0BRANCH as a high-level word that inserted this code at
001201r 3                       ; runtime.
001201r 3                       ; """
001201r 3               
001201r 3                               ; We use the return value on the 65c02 stack to determine
001201r 3                               ; where we want to return to.
001201r 3  68                           pla
001202r 3  85 rr                        sta tmpbranch
001204r 3  68                           pla
001205r 3  85 rr                        sta tmpbranch+1
001207r 3               
001207r 3                               ; See if the flag is zero, which is the whole purpose of
001207r 3                               ; this all
001207r 3  B5 00                        lda 0,x
001209r 3  15 01                        ora 1,x
00120Br 3  F0 0F                        beq @zero
00120Dr 3               
00120Dr 3                               ; Flag is TRUE, so we skip over the next two bytes. This is
00120Dr 3                               ; the part between IF and THEN
00120Dr 3  A5 rr                        lda tmpbranch   ; LSB
00120Fr 3  18                           clc
001210r 3  69 02                        adc #2
001212r 3  85 rr                        sta tmp1
001214r 3  A5 rr                        lda tmpbranch+1 ; MSB
001216r 3  69 00                        adc #0          ; For carry
001218r 3  85 rr                        sta tmp1+1
00121Ar 3               
00121Ar 3  80 13                        bra @done
00121Cr 3               
00121Cr 3               @zero:
00121Cr 3                               ; Flag is FALSE (0) so we take the jump to the address given in
00121Cr 3                               ; the next two bytes. However, the address points to the last
00121Cr 3                               ; byte of the JSR instruction, not to the next byte afterwards
00121Cr 3  A0 01                        ldy #1
00121Er 3  B1 rr                        lda (tmpbranch),y
001220r 3  85 rr                        sta tmp1
001222r 3  C8                           iny
001223r 3  B1 rr                        lda (tmpbranch),y
001225r 3  85 rr                        sta tmp1+1
001227r 3               
001227r 3                               ; Now we have to subtract one byte from the address
001227r 3                               ; given because of the way the 6502 calculates RTS
001227r 3  A5 rr                        lda tmp1
001229r 3  D0 02                        bne @1
00122Br 3  C6 rr                        dec tmp1+1
00122Dr 3               @1:
00122Dr 3  C6 rr                        dec tmp1
00122Fr 3               
00122Fr 3               @done:
00122Fr 3                               ; However we got here, tmp1 has the value we push to jump
00122Fr 3                               ; to
00122Fr 3  A5 rr                        lda tmp1+1
001231r 3  48                           pha             ; MSB first
001232r 3  A5 rr                        lda tmp1
001234r 3  48                           pha
001235r 3               
001235r 3                               ; clean up the stack and jump
001235r 3  E8                           inx
001236r 3  E8                           inx
001237r 3               
001237r 3  60                           rts
001238r 3               
001238r 3               
001238r 3               
001238r 3               ; ## IMMEDIATE ( -- ) "Mark most recent word as IMMEDIATE"
001238r 3               ; ## "immediate"  auto  ANS core
001238r 3                       ; """https://forth-standard.org/standard/core/IMMEDIATE
001238r 3                       ; Make sure the most recently defined word is immediate. Will only
001238r 3                       ; affect the last word in the dictionary. Note that if the word is
001238r 3                       ; defined in ROM, this will have no affect, but will not produce an
001238r 3                       ; error message.
001238r 3                       ; """
001238r 3               xt_immediate:
001238r 3  20 rr rr                     jsr current_to_dp
00123Br 3  A0 01                        ldy #1          ; offset for status byte
00123Dr 3  B1 rr                        lda (dp),y
00123Fr 3  09 04                        ora #IM        ; make sure bit 7 is set
001241r 3  91 rr                        sta (dp),y
001243r 3               
001243r 3  60           z_immediate:    rts
001244r 3               
001244r 3               
001244r 3               ; ## INPUT ( -- addr ) "Return address of input vector"
001244r 3               ; ## "input" tested Tali Forth
001244r 3               
001244r 3               xt_input:
001244r 3  CA                           dex
001245r 3  CA                           dex
001246r 3  A9 rr                        lda #<input
001248r 3  95 00                        sta 0,x
00124Ar 3  A9 rr                        lda #>input
00124Cr 3  95 01                        sta 1,x
00124Er 3               
00124Er 3  60           z_input:        rts
00124Fr 3               
00124Fr 3               
00124Fr 3               
00124Fr 3               ; ## INPUT_TO_R ( -- ) ( R: -- n n n n ) "Save input state to the Return Stack"
00124Fr 3               ; ## "input>r"  tested  Tali Forth
00124Fr 3                  	; """Save the current input state as defined by insrc, cib, ciblen, and
00124Fr 3                       ; toin to the Return Stack. Used by EVALUTE.
00124Fr 3                       ;
00124Fr 3                       ; The naive way of doing
00124Fr 3                       ; this is to push each two-byte variable to the stack in the form of
00124Fr 3                       ;
00124Fr 3                       ;       lda insrc
00124Fr 3                       ;       pha
00124Fr 3                       ;       lda insrc+1
00124Fr 3                       ;       pha
00124Fr 3                       ;
00124Fr 3                       ; for a total of 24 byte of instruction in one direction and later
00124Fr 3                       ; a further 24 bytes to reverse the process. We shorten this at the
00124Fr 3                       ; cost of some speed by assuming the four variables are grouped
00124Fr 3                       ; together on the Zero Page and start with insrc (see definitions.asm
00124Fr 3                       ; for details). The reverse operation is r_to_input. These words must
00124Fr 3                       ; be flagged as Never Native. Uses tmp1
00124Fr 3                       ; """
00124Fr 3               
00124Fr 3               xt_input_to_r:
00124Fr 3                               ; We arrive here with the return address on the top of the
00124Fr 3                               ; 65c02's stack. We need to move it out of the way first
00124Fr 3  68                           pla
001250r 3  85 rr                        sta tmp1
001252r 3  68                           pla
001253r 3  85 rr                        sta tmp1+1
001255r 3               
001255r 3                               ; This assumes that insrc is the first of eight bytes and
001255r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001255r 3                               ; Page.
001255r 3  A0 07                        ldy #7
001257r 3               @loop:
001257r 3  B9 rr rr                     lda insrc,y     ; insrc+7 is toin+1
00125Ar 3  48                           pha
00125Br 3  88                           dey
00125Cr 3  10 F9                        bpl @loop
00125Er 3               
00125Er 3                               ; Restore address for return jump
00125Er 3  A5 rr                        lda tmp1+1
001260r 3  48                           pha
001261r 3  A5 rr                        lda tmp1
001263r 3  48                           pha
001264r 3               
001264r 3  60           z_input_to_r: 	rts
001265r 3               
001265r 3               
001265r 3               
001265r 3               ; ## INT_TO_NAME ( xt -- nt ) "Get name token from execution token"
001265r 3               ; ## "int>name"  auto  Tali Forth
001265r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001265r 3                       ; This is called >NAME in Gforth, but we change it to
001265r 3                       ; INT>NAME to match NAME>INT
001265r 3                       ; """
001265r 3               
001265r 3               xt_int_to_name:
001265r 3  20 rr rr                     jsr underflow_1
001268r 3               
001268r 3                               ; Unfortunately, to find the header, we have to walk through
001268r 3                               ; all of the wordlists. We are running out of tmp variables.
001268r 3                               ; (I'm assuming there is a reason this is avoiding tmp1) so
001268r 3                               ; hold the current wordlist on the data stack. This searches
001268r 3                               ; all of the wordlists in id order.
001268r 3  CA                           dex
001269r 3  CA                           dex
00126Ar 3  74 00                        stz 0,x
00126Cr 3  74 01                        stz 1,x
00126Er 3               
00126Er 3               @wordlist_loop:
00126Er 3                               ; A needs to have the current wordlist id in it at
00126Er 3                               ; the top of this loop.
00126Er 3  B5 00                        lda 0,x                 ; Get the current wordlist.
001270r 3               
001270r 3                               ; Get the DP for that wordlist.
001270r 3  0A                           asl                     ; Turn offset into cells offset.
001271r 3  18                           clc
001272r 3  69 06                        adc #wordlists_offset
001274r 3  A8                           tay
001275r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
001277r 3  85 rr                        sta tmp2                ; into tmp2
001279r 3  C8                           iny
00127Ar 3  B1 rr                        lda (up),y
00127Cr 3  85 rr                        sta tmp2+1
00127Er 3               
00127Er 3                               ; Check for an empty wordlist (DP will be 0)
00127Er 3  A5 rr                        lda tmp2
001280r 3  05 rr                        ora tmp2+1
001282r 3  F0 38                        beq @next_wordlist
001284r 3               
001284r 3  B5 02                        lda 2,x         ; Target xt is now behind wordlist id.
001286r 3  85 rr                        sta tmp3        ; Save target xt in tmp3
001288r 3  B5 03                        lda 3,x
00128Ar 3  85 rr                        sta tmp3+1
00128Cr 3               
00128Cr 3               @loop:
00128Cr 3  A0 04                        ldy #4          ; xt is four bytes down
00128Er 3  B1 rr                        lda (tmp2),y    ; LSB of xt of current nt
001290r 3  C5 rr                        cmp tmp3
001292r 3  D0 07                        bne @no_match
001294r 3               
001294r 3                               ; LSB is the same, now check MSB
001294r 3  C8                           iny
001295r 3  B1 rr                        lda (tmp2),y    ; MSB of xt of current nt
001297r 3  C5 rr                        cmp tmp3+1
001299r 3  F0 32                        beq @match
00129Br 3               
00129Br 3               @no_match:
00129Br 3                               ; no match, so we need to get the next word. Next nt is two
00129Br 3                               ; bytes down
00129Br 3  18                           clc
00129Cr 3  A5 rr                        lda tmp2
00129Er 3  69 02                        adc #2
0012A0r 3  85 rr                        sta tmp2
0012A2r 3  A5 rr                        lda tmp2+1
0012A4r 3  69 00                        adc #0          ; only care about carry
0012A6r 3  85 rr                        sta tmp2+1
0012A8r 3               
0012A8r 3  A0 00                        ldy #0
0012AAr 3  B1 rr                        lda (tmp2),y
0012ACr 3  48                           pha
0012ADr 3  C8                           iny
0012AEr 3  11 rr                        ora (tmp2),y
0012B0r 3  F0 09                        beq @zero
0012B2r 3               
0012B2r 3                               ; Not zero continue
0012B2r 3  B1 rr                        lda (tmp2),y
0012B4r 3  85 rr                        sta tmp2+1
0012B6r 3  68                           pla
0012B7r 3  85 rr                        sta tmp2
0012B9r 3  80 D1                        bra @loop
0012BBr 3               
0012BBr 3               @zero:
0012BBr 3                               ; if next word is zero, the xt has no nt in this wordlist
0012BBr 3  68                           pla             ; Leftover from above loop
0012BCr 3               
0012BCr 3               @next_wordlist:
0012BCr 3                               ; Move on to the next wordlist.
0012BCr 3  B5 00                        lda 0,x
0012BEr 3  1A                           inc
0012BFr 3  95 00                        sta 0,x
0012C1r 3  C9 0C                        cmp #max_wordlists
0012C3r 3  D0 A9                        bne @wordlist_loop
0012C5r 3               
0012C5r 3                               ; We didn't find it in any of the wordlists.
0012C5r 3                               ; Remove the wordlist id from the stack.
0012C5r 3  E8                           inx
0012C6r 3  E8                           inx
0012C7r 3               
0012C7r 3                               ; We return a zero to indicate that we didn't find it.
0012C7r 3  74 00                        stz 0,x
0012C9r 3  74 01                        stz 1,x
0012CBr 3  80 0A                        bra z_int_to_name
0012CDr 3               
0012CDr 3               @match:
0012CDr 3                               ; We found it. Remove wordlist id from stack.
0012CDr 3  E8                           inx
0012CEr 3  E8                           inx
0012CFr 3               
0012CFr 3                               ; It's a match! Replace TOS with nt
0012CFr 3  A5 rr                        lda tmp2
0012D1r 3  95 00                        sta 0,x
0012D3r 3  A5 rr                        lda tmp2+1
0012D5r 3  95 01                        sta 1,x
0012D7r 3               
0012D7r 3  60           z_int_to_name:  rts
0012D8r 3               
0012D8r 3               
0012D8r 3               
0012D8r 3               ; ## INVERT ( n -- n ) "Complement of TOS"
0012D8r 3               ; ## "invert"  auto  ANS core
0012D8r 3                       ; """https://forth-standard.org/standard/core/INVERT"""
0012D8r 3               xt_invert:
0012D8r 3  20 rr rr                     jsr underflow_1
0012DBr 3               
0012DBr 3  A9 FF                        lda #$FF
0012DDr 3  55 00                        eor 0,x         ; LSB
0012DFr 3  95 00                        sta 0,x
0012E1r 3               
0012E1r 3  A9 FF                        lda #$FF
0012E3r 3  55 01                        eor 1,x         ; MSB
0012E5r 3  95 01                        sta 1,x
0012E7r 3               
0012E7r 3  60           z_invert:       rts
0012E8r 3               
0012E8r 3               
0012E8r 3               ; ## IS ( xt "name" -- ) "Set named word to execute xt"
0012E8r 3               ; ## "is"  auto  ANS core ext
0012E8r 3                       ; """http://forth-standard.org/standard/core/IS"""
0012E8r 3               
0012E8r 3               xt_is:
0012E8r 3                               ; This is a state aware word with differet behavior
0012E8r 3                               ; when used while compiling vs interpreting.
0012E8r 3                               ; Check STATE
0012E8r 3  A5 rr                        lda state
0012EAr 3  05 rr                        ora state+1
0012ECr 3  F0 0C                        beq @interpreting
0012EEr 3               
0012EEr 3               @compiling:
0012EEr 3                               ; Run ['] to compile the xt of the next word as a literal.
0012EEr 3  20 rr rr                     jsr xt_bracket_tick
0012F1r 3               
0012F1r 3                               ; Postpone DEFER! by compiling a JSR to it.
0012F1r 3  A0 rr                        ldy #>xt_defer_store
0012F3r 3  A9 rr                        lda #<xt_defer_store
0012F5r 3  20 rr rr                     jsr cmpl_subroutine
0012F8r 3               
0012F8r 3  80 06                        bra @done
0012FAr 3               
0012FAr 3               @interpreting:
0012FAr 3  20 rr rr                     jsr xt_tick
0012FDr 3  20 rr rr                     jsr xt_defer_store
001300r 3               @done:
001300r 3  60           z_is:           rts
001301r 3               
001301r 3               
001301r 3               
001301r 3               ; ## J ( -- n ) (R: n -- n ) "Copy second loop counter to stack"
001301r 3               ; ## "j"  auto  ANS core
001301r 3                       ; """https://forth-standard.org/standard/core/J
001301r 3                       ; Copy second loop counter from Return Stack to stack. Note we use
001301r 3                       ; a fudge factor for loop control; see the Control Flow section of
001301r 3                       ; the manual for more details.
001301r 3                       ; At this point, we have the "I" counter/limit and the LEAVE address
001301r 3                       ; on the stack above this (three entries), whereas the ideal Forth
001301r 3                       ; implementation would just have two.
001301r 3                       ;
001301r 3                       ; Make this native compiled for speed
001301r 3                       ; """
001301r 3               
001301r 3               xt_j:
001301r 3  CA                           dex
001302r 3  CA                           dex
001303r 3               
001303r 3                               ; Get the fudged index off from the stack. It's easier to
001303r 3                               ; do math on the stack directly than to pop and push stuff
001303r 3                               ; around
001303r 3  86 rr                        stx tmpdsp
001305r 3  BA                           tsx
001306r 3               
001306r 3  38                           sec
001307r 3  BD 07 01                     lda $0107,x     ; LSB
00130Ar 3  FD 09 01                     sbc $0109,x
00130Dr 3  A8                           tay
00130Er 3               
00130Er 3  BD 08 01                     lda $0108,x     ; MSB
001311r 3  FD 0A 01                     sbc $010A,x
001314r 3               
001314r 3  A6 rr                        ldx tmpdsp
001316r 3               
001316r 3  95 01                        sta 1,x         ; MSB of de-fudged index
001318r 3  94 00                        sty 0,x         ; LSB of de-fudged index
00131Ar 3               
00131Ar 3  60           z_j:            rts
00131Br 3               
00131Br 3               
00131Br 3               
00131Br 3               ; ## KEY ( -- char ) "Get one character from the input"
00131Br 3               ; ## "key"  tested  ANS core
00131Br 3               xt_key:
00131Br 3                       ; """https://forth-standard.org/standard/core/KEY
00131Br 3                       ; Get a single character of input from the vectored
00131Br 3                       ; input without echoing.
00131Br 3                       ; """
00131Br 3  20 rr rr                     jsr key_a               ; returns char in A
00131Er 3               
00131Er 3  CA                           dex
00131Fr 3  CA                           dex
001320r 3  95 00                        sta 0,x
001322r 3  74 01                        stz 1,x
001324r 3               
001324r 3  60           z_key:          rts
001325r 3               
001325r 3               key_a:
001325r 3                       ; The 65c02 doesn't have a JSR (ADDR,X) instruction like the
001325r 3                       ; 65816, so we have to fake the indirect jump to vector it.
001325r 3                       ; This is depressingly slow. We use this routine internally
001325r 3                       ; to avoid manipulating the Data Stack when we just want a
001325r 3                       ; character
001325r 3  6C rr rr                     jmp (input)             ; JSR/RTS
001328r 3               
001328r 3               
001328r 3               ; ## LATESTNT ( -- nt ) "Push most recent nt to the stack"
001328r 3               ; ## "latestnt"  auto  Tali Forth
001328r 3                       ; """www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
001328r 3                       ; The Gforth version of this word is called LATEST
001328r 3                       ; """
001328r 3               xt_latestnt:
001328r 3  CA                           dex
001329r 3  CA                           dex
00132Ar 3               
00132Ar 3  20 rr rr                     jsr current_to_dp
00132Dr 3               
00132Dr 3  A5 rr                        lda dp
00132Fr 3  95 00                        sta 0,x
001331r 3  A5 rr                        lda dp+1
001333r 3  95 01                        sta 1,x
001335r 3               
001335r 3  60           z_latestnt:     rts
001336r 3               
001336r 3               
001336r 3               ; ## LATESTXT ( -- xt ) "Push most recent xt to the stack"
001336r 3               ; ## "latestxt"  auto  Gforth
001336r 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Anonymous-Definitions.html"""
001336r 3               xt_latestxt:
001336r 3  20 rr rr                     jsr xt_latestnt         ; ( nt )
001339r 3  20 rr rr                     jsr xt_name_to_int      ; ( xt )
00133Cr 3               
00133Cr 3  60           z_latestxt:     rts
00133Dr 3               
00133Dr 3               
00133Dr 3               ; ## LEAVE ( -- ) "Leave DO/LOOP construct"
00133Dr 3               ; ## "leave"  auto  ANS core
00133Dr 3                       ; """https://forth-standard.org/standard/core/LEAVE
00133Dr 3                       ; Note that this does not work with anything but a DO/LOOP in
00133Dr 3                       ; contrast to other versions such as discussed at
00133Dr 3                       ; http://blogs.msdn.com/b/ashleyf/archive/2011/02/06/loopty-do-i-loop.aspx
00133Dr 3                       ;
00133Dr 3                       ;       : LEAVE POSTPONE BRANCH HERE SWAP 0 , ; IMMEDIATE COMPILE-ONLY
00133Dr 3                       ; See the Control Flow section in the manual for details of how this works.
00133Dr 3                       ; This must be native compile and not IMMEDIATE
00133Dr 3                       ; """
00133Dr 3               
00133Dr 3               xt_leave:
00133Dr 3                               ; We dump the limit/start entries off the Return Stack
00133Dr 3                               ; (four bytes)
00133Dr 3  68                           pla
00133Er 3  68                           pla
00133Fr 3  68                           pla
001340r 3  68                           pla
001341r 3               
001341r 3  60                           rts             ; this must be compiled, so keep before z_leave
001342r 3               z_leave:                        ; not reached, not compiled
001342r 3               
001342r 3               
001342r 3               
001342r 3               ; ## LEFT_BRACKET ( -- ) "Enter interpretation state"
001342r 3               ; ## "["  auto  ANS core
001342r 3                       ; """https://forth-standard.org/standard/core/Bracket
001342r 3                       ; This is an immediate and compile-only word
001342r 3                       ; """
001342r 3               xt_left_bracket:
001342r 3  64 rr                        stz state
001344r 3  64 rr                        stz state+1
001346r 3               
001346r 3  60           z_left_bracket: rts
001347r 3               
001347r 3               
001347r 3               ; ## LESS_NUMBER_SIGN ( -- ) "Start number conversion"
001347r 3               ; ## "<#"  auto  ANS core
001347r 3                       ; """https://forth-standard.org/standard/core/num-start
001347r 3                       ; Start the process to create pictured numeric output.
001347r 3                       ;
001347r 3                       ; The new
001347r 3                       ; string is constructed from back to front, saving the new character
001347r 3                       ; at the beginning of the output string. Since we use PAD as a
001347r 3                       ; starting address and work backward (!), the string is constructed
001347r 3                       ; in the space between the end of the Dictionary (as defined by CP)
001347r 3                       ; and the PAD. This allows us to satisfy the ANS Forth condition that
001347r 3                       ; programs don't fool around with the PAD but still use its address.
001347r 3                       ; Based on pForth
001347r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001347r 3                       ; pForth is in the pubic domain. Forth is : <# PAD HLD ! ; we use the
001347r 3                       ; internal variable tohold instead of HLD.
001347r 3                       ; """
001347r 3               xt_less_number_sign:
001347r 3  20 rr rr                     jsr xt_pad      ; ( addr )
00134Ar 3               
00134Ar 3  B5 00                        lda 0,x
00134Cr 3  85 rr                        sta tohold
00134Er 3  B5 01                        lda 1,x
001350r 3  85 rr                        sta tohold+1
001352r 3               
001352r 3  E8                           inx
001353r 3  E8                           inx
001354r 3               
001354r 3               z_less_number_sign:
001354r 3  60                           rts
001355r 3               
001355r 3               ; ## LESS_THAN ( n m -- f ) "Return true if NOS < TOS"
001355r 3               ; ## "<"  auto  ANS core
001355r 3                       ; """https://forth-standard.org/standard/core/less"""
001355r 3               
001355r 3               xt_less_than:
001355r 3  20 rr rr                     jsr underflow_2
001358r 3               
001358r 3  A0 00                        ldy #0          ; default false
00135Ar 3  20 rr rr                     jsr compare_16bit
00135Dr 3               
00135Dr 3                               ; for signed numbers, NOS < TOS if Z=0 and N=0
00135Dr 3  F0 03                        beq @false
00135Fr 3  30 01                        bmi @false
001361r 3               
001361r 3                               ; true
001361r 3  88                           dey
001362r 3               @false:
001362r 3  98                           tya
001363r 3               
001363r 3  E8                           inx
001364r 3  E8                           inx
001365r 3  95 00                        sta 0,x
001367r 3  95 01                        sta 1,x
001369r 3               
001369r 3  60           z_less_than:    rts
00136Ar 3               
00136Ar 3               
00136Ar 3               
00136Ar 3               ; ## LIST ( scr# -- ) "List the given screen"
00136Ar 3               ; ## "list"  tested  ANS block ext
00136Ar 3                       ; """https://forth-standard.org/standard/block/LIST"""
00136Ar 3               
00136Ar 3               xt_list:
00136Ar 3  20 rr rr                     jsr underflow_1
00136Dr 3               
00136Dr 3                               ; Save the screen number in SCR
00136Dr 3  20 rr rr                     jsr xt_scr
001370r 3  20 rr rr                     jsr xt_store
001373r 3               
001373r 3                               ; Use L from the editor-wordlist to display the screen.
001373r 3  20 rr rr                     jsr xt_editor_l
001376r 3               
001376r 3  60           z_list:         rts
001377r 3               
001377r 3               
001377r 3               
001377r 3               ; ## LITERAL ( n -- ) "Store TOS to be push on stack during runtime"
001377r 3               ; ## "literal"  auto  ANS core
001377r 3                       ; """https://forth-standard.org/standard/core/LITERAL
001377r 3                       ; Compile-only word to store TOS so that it is pushed on stack
001377r 3                       ; during runtime. This is a immediate, compile-only word. At runtime,
001377r 3                       ; it works by calling literal_runtime by compling JSR LITERAL_RT.
001377r 3                       ;
001377r 3                       ; Note the cmpl_ routines use TMPTOS
001377r 3                       ; """
001377r 3               xt_literal:
001377r 3  20 rr rr                     jsr underflow_1
00137Ar 3               
00137Ar 3  A0 rr                        ldy #>literal_runtime
00137Cr 3  A9 rr                        lda #<literal_runtime
00137Er 3  20 rr rr                     jsr cmpl_subroutine
001381r 3               
001381r 3                               ; Compile the value that is to be pushed on the Stack during
001381r 3                               ; runtime
001381r 3  20 rr rr                     jsr xt_comma
001384r 3               
001384r 3  60           z_literal:      rts
001385r 3               
001385r 3               literal_runtime:
001385r 3               
001385r 3                               ; During runtime, we push the value following this word back
001385r 3                               ; on the Data Stack. The subroutine jump that brought us
001385r 3                               ; here put the address to return to on the Return Stack -
001385r 3                               ; this points to the data we need to get. This routine is
001385r 3                               ; also called (LITERAL) in some Forths
001385r 3  CA                           dex
001386r 3  CA                           dex
001387r 3               
001387r 3                           	; The 65c02 stores <RETURN-ADDRESS>-1 on the Return Stack,
001387r 3                               ; so we are actually popping the address-1 of the literal
001387r 3  68                           pla             ; LSB
001388r 3  85 rr                        sta tmp1
00138Ar 3  68                           pla             ; MSB
00138Br 3  85 rr                        sta tmp1+1
00138Dr 3               
00138Dr 3                               ; Fetch the actual literal value and push it on Data stack
00138Dr 3  A0 01                        ldy #1
00138Fr 3  B1 rr                        lda (tmp1),y    ; LSB
001391r 3  95 00                        sta 0,x
001393r 3  C8                           iny
001394r 3  B1 rr                        lda (tmp1),y    ; MSB
001396r 3  95 01                        sta 1,x
001398r 3               
001398r 3                               ; Adjust return address and push back on the Return Stack
001398r 3  98                           tya
001399r 3  18                           clc
00139Ar 3  65 rr                        adc tmp1
00139Cr 3  A8                           tay
00139Dr 3  A5 rr                        lda tmp1+1
00139Fr 3  69 00                        adc #0
0013A1r 3  48                           pha
0013A2r 3  5A                           phy
0013A3r 3               
0013A3r 3  60                           rts
0013A4r 3               
0013A4r 3               
0013A4r 3               
0013A4r 3               ; ## LOAD ( scr# -- ) "Load the Forth code in a screen/block"
0013A4r 3               ; ## "load"  auto  ANS block
0013A4r 3                       ; """https://forth-standard.org/standard/block/LOAD
0013A4r 3                       ;
0013A4r 3                       ; Note: LOAD current works because there is only one buffer.
0013A4r 3                       ; If/when multiple buffers are supported, we'll have to deal
0013A4r 3                       ; with the fact that it might re-load the old block into a
0013A4r 3                       ; different buffer.
0013A4r 3                       ; """
0013A4r 3               
0013A4r 3               xt_load:
0013A4r 3  20 rr rr                     jsr underflow_1
0013A7r 3               
0013A7r 3                               ; Save the current value of BLK on the return stack.
0013A7r 3  A0 01                        ldy #blk_offset+1
0013A9r 3  B1 rr                        lda (up),y
0013ABr 3  48                           pha
0013ACr 3  88                           dey
0013ADr 3  B1 rr                        lda (up),y
0013AFr 3  48                           pha
0013B0r 3               
0013B0r 3                               ; Set BLK to the given block/screen number.
0013B0r 3  B5 00                        lda 0,x
0013B2r 3  91 rr                        sta (up),y
0013B4r 3  C8                           iny
0013B5r 3  B5 01                        lda 1,x
0013B7r 3  91 rr                        sta (up),y
0013B9r 3               
0013B9r 3                               ; Load that block into a buffer
0013B9r 3  20 rr rr                     jsr xt_block
0013BCr 3               
0013BCr 3                               ; Put 1024 on the stack for the screen length.
0013BCr 3  CA                           dex
0013BDr 3  CA                           dex
0013BEr 3  A9 04                        lda #4
0013C0r 3  95 01                        sta 1,x
0013C2r 3  74 00                        stz 0,x
0013C4r 3               
0013C4r 3                               ; Jump to a special evluate target. This bypasses the underflow
0013C4r 3                               ; check and skips the zeroing of BLK.
0013C4r 3  20 rr rr                     jsr load_evaluate
0013C7r 3               
0013C7r 3                               ; Restore the value of BLK from before the LOAD command.
0013C7r 3  A0 00                        ldy #blk_offset
0013C9r 3  68                           pla
0013CAr 3  91 rr                        sta (up),y
0013CCr 3  C8                           iny
0013CDr 3  68                           pla
0013CEr 3  91 rr                        sta (up),y
0013D0r 3               
0013D0r 3                               ; If BLK is not zero, read it back into the buffer.
0013D0r 3                               ; A still has MSB
0013D0r 3  88                           dey
0013D1r 3  11 rr                        ora (up),y
0013D3r 3  F0 12                        beq @done
0013D5r 3               
0013D5r 3                               ; The block needs to be read back into the buffer.
0013D5r 3  CA                           dex
0013D6r 3  CA                           dex
0013D7r 3  A0 00                        ldy #blk_offset
0013D9r 3  B1 rr                        lda (up),y
0013DBr 3  95 00                        sta 0,x
0013DDr 3  C8                           iny
0013DEr 3  B1 rr                        lda (up),y
0013E0r 3  95 01                        sta 1,x
0013E2r 3  20 rr rr                     jsr xt_block
0013E5r 3               
0013E5r 3                               ; Drop the buffer address.
0013E5r 3  E8                           inx
0013E6r 3  E8                           inx
0013E7r 3               
0013E7r 3               @done:
0013E7r 3  60           z_load:         rts
0013E8r 3               
0013E8r 3               
0013E8r 3               
0013E8r 3               ; ## LOOP ( -- ) "Finish loop construct"
0013E8r 3               ; ## "loop"  auto  ANS core
0013E8r 3                       ; """https://forth-standard.org/standard/core/LOOP
0013E8r 3                       ; Compile-time part of LOOP. This does nothing more but push 1 on
0013E8r 3                       ; the stack and then call +LOOP.
0013E8r 3                       ;
0013E8r 3                       ; In Forth, this is
0013E8r 3                       ;       : LOOP  POSTPONE 1 POSTPONE (+LOOP) , POSTPONE UNLOOP ;
0013E8r 3                       ;       IMMEDIATE ; COMPILE-ONLY
0013E8r 3                       ; """
0013E8r 3               xt_loop:
0013E8r 3                               ; Have the finished word push 1 on the stack
0013E8r 3  A0 rr                        ldy #>xt_one
0013EAr 3  A9 rr                        lda #<xt_one
0013ECr 3  20 rr rr                     jsr cmpl_subroutine     ; drop through to +LOOP
0013EFr 3               
0013EFr 3               
0013EFr 3               ; ## PLUS_LOOP ( -- ) "Finish loop construct"
0013EFr 3               ; ## "+loop"  auto  ANS core
0013EFr 3                       ; """https://forth-standard.org/standard/core/PlusLOOP
0013EFr 3                       ;
0013EFr 3                       ; Compile-time part of +LOOP, also used for LOOP. Is usually
0013EFr 3                       ;       : +LOOP POSTPONE (+LOOP) , POSTPONE UNLOOP ; IMMEDIATE
0013EFr 3                       ;       COMPILE-ONLY
0013EFr 3                       ; in Forth. LOOP uses this routine as well. We jump here with the
0013EFr 3                       ; address for looping as TOS and the address for aborting the loop
0013EFr 3                       ; (LEAVE) as the second double-byte entry on the Return Stack (see
0013EFr 3                       ; DO and the Control Flow section of the manual for details).
0013EFr 3                       ; """
0013EFr 3               
0013EFr 3               xt_plus_loop:
0013EFr 3                               ; Compile the run-time part. We do this with a short loop
0013EFr 3                               ; and not a call to COMPILE, because it has to be natively
0013EFr 3                               ; coded anyway.
0013EFr 3  A0 11                        ldy #plus_loop_runtime_end-plus_loop_runtime
0013F1r 3  5A                           phy             ; save counter to adjust CP
0013F2r 3               @1:
0013F2r 3  B9 rr rr                     lda plus_loop_runtime,y
0013F5r 3  91 rr                        sta (cp),y
0013F7r 3  88                           dey
0013F8r 3  10 F8                        bpl @1
0013FAr 3               
0013FAr 3                               ; Adjust CP
0013FAr 3  68                           pla
0013FBr 3  18                           clc
0013FCr 3  65 rr                        adc cp
0013FEr 3  85 rr                        sta cp
001400r 3  A5 rr                        lda cp+1
001402r 3  69 00                        adc #0          ; only need carry
001404r 3  85 rr                        sta cp+1
001406r 3               
001406r 3                               ; The address we need to loop back to is TOS. Store it so
001406r 3                               ; the runtime part of +LOOP jumps back up there
001406r 3  20 rr rr                     jsr xt_comma
001409r 3               
001409r 3                               ; Compile an UNLOOP for when we're all done. This is a series
001409r 3                               ; of six PLA, so we just do it here instead jumping around
001409r 3                               ; all over the place
001409r 3  A9 68                        lda #$68                ; opcode for PLA
00140Br 3  A0 06                        ldy #6
00140Dr 3               @2:
00140Dr 3  91 rr                        sta (cp),y
00140Fr 3  88                           dey
001410r 3  10 FB                        bpl @2
001412r 3               
001412r 3                               ; Adjust CP
001412r 3  A9 06                        lda #6
001414r 3  18                           clc
001415r 3  65 rr                        adc cp
001417r 3  85 rr                        sta cp
001419r 3  A5 rr                        lda cp+1
00141Br 3  69 00                        adc #0                  ; only need carry
00141Dr 3  85 rr                        sta cp+1
00141Fr 3               
00141Fr 3                               ; Complete compile of DO/?DO by replacing the six
00141Fr 3                               ; dummy bytes by PHA instructions. The address where
00141Fr 3                               ; they are located is on the Data Stack
00141Fr 3  B5 00                        lda 0,x
001421r 3  85 rr                        sta tmp1
001423r 3  B5 01                        lda 1,x
001425r 3  85 rr                        sta tmp1+1
001427r 3  E8                           inx
001428r 3  E8                           inx
001429r 3               
001429r 3                               ; Because of the way that CP works, we don't have to save
001429r 3                               ; CP, but CP-1
001429r 3  A5 rr                        lda cp
00142Br 3  38                           sec
00142Cr 3  E9 01                        sbc #1
00142Er 3  85 rr                        sta tmp2
001430r 3  A5 rr                        lda cp+1
001432r 3  E9 00                        sbc #0
001434r 3  85 rr                        sta tmp2+1
001436r 3               
001436r 3                               ; now compile this in the DO/?DO routine
001436r 3  A0 00                        ldy #0
001438r 3               
001438r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
00143Ar 3  91 rr                        sta (tmp1),y
00143Cr 3  C8                           iny
00143Dr 3  A5 rr                        lda tmp2+1      ; MSB
00143Fr 3  91 rr                        sta (tmp1),y
001441r 3  C8                           iny
001442r 3  A9 48                        lda #$48        ; Opcode for PHA
001444r 3  91 rr                        sta (tmp1),y
001446r 3  C8                           iny
001447r 3               
001447r 3  A9 A9                        lda #$A9        ; opcode for LDA immediate
001449r 3  91 rr                        sta (tmp1),y
00144Br 3  C8                           iny
00144Cr 3  A5 rr                        lda tmp2        ; LSB
00144Er 3  91 rr                        sta (tmp1),y
001450r 3  C8                           iny
001451r 3  A9 48                        lda #$48        ; Opcode for PHA
001453r 3  91 rr                        sta (tmp1),y
001455r 3               z_loop:
001455r 3  60           z_plus_loop:    rts
001456r 3               
001456r 3               
001456r 3               plus_loop_runtime:
001456r 3                       ; """Runtime compile for loop control. This is used for both +LOOP and
001456r 3                       ; LOOP which are defined at high level. Note we use a fudge factor for
001456r 3                       ; loop control so we can test with the Overflow Flag. See
001456r 3                       ; the Control Flow section of the manual for details.
001456r 3                       ; The step value is TOS in the loop. This
001456r 3                       ; must always be native compiled. In some Forths, this is a separate
001456r 3                       ; word called (+LOOP) or (LOOP)
001456r 3                       ; """
001456r 3               
001456r 3  18                           clc
001457r 3  68                           pla             ; LSB of index
001458r 3  75 00                        adc 0,x         ; LSB of step
00145Ar 3  A8                           tay             ; temporary storage of LSB
00145Br 3               
00145Br 3  B8                           clv
00145Cr 3  68                           pla             ; MSB of index
00145Dr 3  75 01                        adc 1,x         ; MSB of step
00145Fr 3  48                           pha             ; put MSB of index back on stack
001460r 3               
001460r 3  98                           tya             ; put LSB of index back on stack
001461r 3  48                           pha
001462r 3               
001462r 3  E8                           inx             ; dump step from TOS
001463r 3  E8                           inx
001464r 3               
001464r 3                               ; If V flag is set, we're done looping and continue
001464r 3                               ; after the +LOOP instruction
001464r 3  70 03                        bvs @hack+3     ; skip over JMP instruction
001466r 3               
001466r 3               @hack:          ; This is why this routine must be natively compiled: We
001466r 3                               ; compile the opcode for JMP here without an address to
001466r 3                               ; go to, which is added by the next next instruction of
001466r 3                               ; LOOP/+LOOP during compile time
001466r 3  4C                           .byte $4C
001467r 3               
001467r 3               plus_loop_runtime_end:
001467r 3               
001467r 3               
001467r 3               ; ## LSHIFT ( x u -- u ) "Shift TOS left"
001467r 3               ; ## "lshift"  auto  ANS core
001467r 3                       ; """https://forth-standard.org/standard/core/LSHIFT"""
001467r 3               
001467r 3               xt_lshift:
001467r 3  20 rr rr                     jsr underflow_2
00146Ar 3               
00146Ar 3                               ; max shift 16 times
00146Ar 3  B5 00                        lda 0,x
00146Cr 3  29 0F                        and #%00001111
00146Er 3  F0 08                        beq @done
001470r 3               
001470r 3  A8                           tay
001471r 3               
001471r 3               @loop:
001471r 3  16 02                        asl 2,x
001473r 3  36 03                        rol 3,x
001475r 3  88                           dey
001476r 3  D0 F9                        bne @loop
001478r 3               
001478r 3               @done:
001478r 3  E8                           inx
001479r 3  E8                           inx
00147Ar 3               
00147Ar 3  60           z_lshift:       rts
00147Br 3               
00147Br 3               
00147Br 3               
00147Br 3               ; ## M_STAR ( n n -- d ) "16 * 16 --> 32"
00147Br 3               ; ## "m*"  auto  ANS core
00147Br 3                       ; """https://forth-standard.org/standard/core/MTimes
00147Br 3                       ; Multiply two 16 bit numbers, producing a 32 bit result. All
00147Br 3                       ; values are signed. Adapted from FIG Forth for Tali Forth.
00147Br 3                       ;
00147Br 3                       ; The original Forth is : M* OVER OVER XOR >R ABS SWAP ABS UM* R> D+- ;
00147Br 3                       ; with  : D+- O< IF DNEGATE THEN ;
00147Br 3                       ; """
00147Br 3               
00147Br 3               xt_m_star:
00147Br 3  20 rr rr                     jsr underflow_2
00147Er 3               
00147Er 3                               ; figure out the sign
00147Er 3  B5 01                        lda 1,x         ; MSB of n1
001480r 3  55 03                        eor 3,x         ; MSB of n2
001482r 3               
001482r 3                               ; UM* uses all kinds of temporary variables so we don't
001482r 3                               ; risk a conflict but just take the cycle hit and push
001482r 3                               ; this to the stack
001482r 3  48                           pha
001483r 3               
001483r 3                               ; get the absolute value of both numbers so we can feed
001483r 3                               ; them to UM*, which does the real work
001483r 3  20 rr rr                     jsr xt_abs
001486r 3  20 rr rr                     jsr xt_swap
001489r 3  20 rr rr                     jsr xt_abs
00148Cr 3               
00148Cr 3  20 rr rr                     jsr xt_um_star          ; ( d )
00148Fr 3               
00148Fr 3                               ; handle the sign
00148Fr 3  68                           pla
001490r 3  10 03                        bpl @done
001492r 3               
001492r 3  20 rr rr                     jsr xt_dnegate
001495r 3               @done:
001495r 3  60           z_m_star:       rts
001496r 3               
001496r 3               
001496r 3               
001496r 3               ; ## MARKER ( "name" -- ) "Create a deletion boundry"
001496r 3               ; ## "marker"  auto  ANS core ext
001496r 3                       ; """https://forth-standard.org/standard/core/MARKER
001496r 3                       ; This word replaces FORGET in earlier Forths. Old entries are not
001496r 3                       ; actually deleted, but merely overwritten by restoring CP and DP.
001496r 3                       ; Run the named word at a later time to restore all of the wordlists
001496r 3                       ; to their state when the word was created with marker.  Any words
001496r 3                       ; created after the marker (including the marker) will be forgotten.
001496r 3                       ;
001496r 3                       ; To do this, we want to end up with something that jumps to a
001496r 3                       ; run-time component with a link to the original CP and DP values:
001496r 3                       ;
001496r 3                       ;       jsr marker_runtime
001496r 3                       ;       <Original CP MSB>
001496r 3                       ;       <Original CP LSB>
001496r 3                       ;       <Original DP MSB> ( for CURRENT wordlist )
001496r 3                       ;       <Original DP LSB>
001496r 3                       ;       < USER variables from offset 4 to 39 >
001496r 3                       ;
001496r 3                       ;       The user variables include:
001496r 3                       ;       CURRENT (byte variable)
001496r 3                       ;       <All wordlists> (currently 12) (cell array)
001496r 3                       ;       <#ORDER> (byte variable)
001496r 3                       ;       <All search order> (currently 9) (byte array)
001496r 3                       ;
001496r 3                       ; This code uses tmp1 and tmp2
001496r 3                       ; """
001496r 3               
001496r 3               xt_marker:
001496r 3                               ; Before we do anything, we need to save CP, which
001496r 3                               ; after all is the whole point of this operation. CREATE
001496r 3                               ; uses tmp1 and tmp2, so we take the speed hit and push stuff
001496r 3                               ; to the stack
001496r 3  20 rr rr                     jsr current_to_dp
001499r 3               
001499r 3  A5 rr                        lda dp
00149Br 3  48                           pha
00149Cr 3  A5 rr                        lda dp+1
00149Er 3  48                           pha
00149Fr 3               
00149Fr 3  A5 rr                        lda cp
0014A1r 3  48                           pha
0014A2r 3  A5 rr                        lda cp+1
0014A4r 3  48                           pha
0014A5r 3               
0014A5r 3  20 rr rr                     jsr xt_create
0014A8r 3               
0014A8r 3                               ; By default, CREATE installs a subroutine jump to DOVAR, which
0014A8r 3                               ; we have to replace by a jump to marker_runtime. We back up
0014A8r 3                               ; two bytes and then overwrite the address
0014A8r 3  A5 rr                        lda cp          ; LSB
0014AAr 3  38                           sec
0014ABr 3  E9 02                        sbc #2
0014ADr 3  85 rr                        sta cp
0014AFr 3               
0014AFr 3  A5 rr                        lda cp+1        ; MSB
0014B1r 3  E9 00                        sbc #0          ; we only care about the borrow
0014B3r 3  85 rr                        sta cp+1
0014B5r 3               
0014B5r 3                               ; Add the address of the runtime component
0014B5r 3  A0 rr                        ldy #>marker_runtime
0014B7r 3  A9 rr                        lda #<marker_runtime
0014B9r 3  20 rr rr                     jsr cmpl_word
0014BCr 3               
0014BCr 3                               ; Add original CP as payload
0014BCr 3  7A                           ply                     ; MSB
0014BDr 3  68                           pla                     ; LSB
0014BEr 3  20 rr rr                     jsr cmpl_word
0014C1r 3               
0014C1r 3                               ; Add original DP as payload
0014C1r 3  7A                           ply                     ; MSB
0014C2r 3  68                           pla                     ; LSB
0014C3r 3  20 rr rr                     jsr cmpl_word
0014C6r 3               
0014C6r 3                               ; Add the user variables for the wordlists and search order.
0014C6r 3                               ; We're compiling them in byte order.
0014C6r 3  A0 04                        ldy #4                  ; Start at CURRENT
0014C8r 3               @marker_loop:
0014C8r 3  B1 rr                        lda (up),y
0014CAr 3  20 rr rr                     jsr cmpl_a
0014CDr 3  C8                           iny
0014CEr 3  98                           tya
0014CFr 3  C9 28                        cmp #40                 ; One past the end of the search order.
0014D1r 3  D0 F5                        bne @marker_loop
0014D3r 3               
0014D3r 3  60           z_marker:       rts
0014D4r 3               
0014D4r 3               
0014D4r 3               
0014D4r 3               marker_runtime:
0014D4r 3                       ; """Restore Dictionary and memory (DP and CP) to where the were
0014D4r 3                       ; when this marker was defined. We arrive here with the return
0014D4r 3                       ; address on the Return Stack in the usual 65c02 format
0014D4r 3                       ; """
0014D4r 3               
0014D4r 3                               ; Get the address of the string address off the stack and
0014D4r 3                               ; increase by one because of the RTS mechanics
0014D4r 3  68                           pla
0014D5r 3  85 rr                        sta tmp1        ; LSB of address
0014D7r 3  68                           pla
0014D8r 3  85 rr                        sta tmp1+1      ; MSB of address
0014DAr 3               
0014DAr 3  E6 rr                        inc tmp1
0014DCr 3  D0 02                        bne @1
0014DEr 3  E6 rr                        inc tmp1+1
0014E0r 3               @1:
0014E0r 3  A0 00                        ldy #0
0014E2r 3               
0014E2r 3                               ; CP was stored first
0014E2r 3  B1 rr                        lda (tmp1),y
0014E4r 3  85 rr                        sta cp
0014E6r 3  C8                           iny
0014E7r 3  B1 rr                        lda (tmp1),y
0014E9r 3  85 rr                        sta cp+1
0014EBr 3               
0014EBr 3                               ; Next was DP
0014EBr 3  C8                           iny
0014ECr 3  B1 rr                        lda (tmp1),y
0014EEr 3  85 rr                        sta dp
0014F0r 3  C8                           iny
0014F1r 3  B1 rr                        lda (tmp1),y
0014F3r 3  85 rr                        sta dp+1
0014F5r 3               
0014F5r 3                               ; Conveniently, the offset into both tmp1 and UP is 4
0014F5r 3                               ; to start restoring the wordlists and search order.
0014F5r 3  A0 04                        ldy #4
0014F7r 3               
0014F7r 3               @marker_restore_loop:
0014F7r 3                               ; Copy from the dictionary back on top of the wordlists
0014F7r 3                               ; and search order.
0014F7r 3  B1 rr                        lda (tmp1), y
0014F9r 3  91 rr                        sta (up), y
0014FBr 3  C8                           iny
0014FCr 3  98                           tya
0014FDr 3  C9 28                        cmp #40                 ; One past the end of the search order.
0014FFr 3  D0 F6                        bne @marker_restore_loop
001501r 3               
001501r 3  20 rr rr                     jsr dp_to_current       ; Move the CURRENT DP back.
001504r 3               
001504r 3                               ; The return instruction takes us back to the original caller
001504r 3  60                           rts
001505r 3               
001505r 3               
001505r 3               
001505r 3               ; ## MAX ( n n -- n ) "Keep larger of two numbers"
001505r 3               ; ## "max"  auto  ANS core
001505r 3                       ; """https://forth-standard.org/standard/core/MAX
001505r 3                       ; Compare TOS and NOS and keep which one is larger. Adapted from
001505r 3                       ; Lance A. Leventhal "6502 Assembly Language Subroutines". Negative
001505r 3                       ; Flag indicates which number is larger. See also
001505r 3                       ; http://6502.org/tutorials/compare_instructions.html and
001505r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001505r 3                       ; """
001505r 3               
001505r 3               xt_max:
001505r 3  20 rr rr                     jsr underflow_2
001508r 3               
001508r 3                               ; Compare LSB. We do this first to set the carry flag
001508r 3  B5 00                        lda 0,x         ; LSB of TOS
00150Ar 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets the carry
00150Cr 3               
00150Cr 3  B5 01                        lda 1,x         ; MSB of TOS
00150Er 3  F5 03                        sbc 3,x         ; MSB of NOS
001510r 3  50 02                        bvc @no_overflow
001512r 3               
001512r 3                               ; handle overflow, because we use signed numbers
001512r 3  49 80                        eor #$80        ; complement negative flag
001514r 3               
001514r 3               @no_overflow:
001514r 3                               ; if negative, NOS is larger and needs to be kept
001514r 3  30 08                        bmi @keep_nos
001516r 3               
001516r 3                               ; move TOS to NOS
001516r 3  B5 00                        lda 0,x
001518r 3  95 02                        sta 2,x
00151Ar 3  B5 01                        lda 1,x
00151Cr 3  95 03                        sta 3,x
00151Er 3               
00151Er 3               @keep_nos:
00151Er 3  E8                           inx
00151Fr 3  E8                           inx
001520r 3               
001520r 3  60           z_max:          rts
001521r 3               
001521r 3               
001521r 3               
001521r 3               ; ## MIN ( n n -- n ) "Keep smaller of two numbers"
001521r 3               ; ## "min"  auto  ANS core
001521r 3                       ; """https://forth-standard.org/standard/core/MIN
001521r 3                       ; Adapted from Lance A. Leventhal "6502 Assembly Language
001521r 3                       ; Subroutines." Negative Flag indicateds which number is larger. See
001521r 3                       ; http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html
001521r 3                       ; """
001521r 3               
001521r 3               xt_min:
001521r 3  20 rr rr                     jsr underflow_2
001524r 3               
001524r 3                               ; compare LSB. We do this first to set the carry flag
001524r 3  B5 00                        lda 0,x         ; LSB of TOS
001526r 3  D5 02                        cmp 2,x         ; LSB of NOS, this sets carry
001528r 3               
001528r 3  B5 01                        lda 1,x         ; MSB of TOS
00152Ar 3  F5 03                        sbc 3,x         ; MSB of NOS
00152Cr 3  50 02                        bvc @no_overflow
00152Er 3               
00152Er 3                               ; handle overflow because we use signed numbers
00152Er 3  49 80                        eor #$80
001530r 3               
001530r 3               @no_overflow:
001530r 3                               ; if negative, NOS is larger and needs to be dumped
001530r 3  10 08                        bpl @keep_nos
001532r 3               
001532r 3                               ; move TOS to NOS
001532r 3  B5 00                        lda 0,x
001534r 3  95 02                        sta 2,x
001536r 3  B5 01                        lda 1,x
001538r 3  95 03                        sta 3,x
00153Ar 3               
00153Ar 3               @keep_nos:
00153Ar 3  E8                           inx
00153Br 3  E8                           inx
00153Cr 3               
00153Cr 3  60           z_min:          rts
00153Dr 3               
00153Dr 3               
00153Dr 3               
00153Dr 3               ; ## MINUS ( n n -- n ) "Subtract TOS from NOS"
00153Dr 3               ; ## "-"  auto  ANS core
00153Dr 3                       ; """https://forth-standard.org/standard/core/Minus"""
00153Dr 3               xt_minus:
00153Dr 3  20 rr rr                     jsr underflow_2
001540r 3               
001540r 3  38                           sec
001541r 3  B5 02                        lda 2,x         ; LSB
001543r 3  F5 00                        sbc 0,x
001545r 3  95 02                        sta 2,x
001547r 3               
001547r 3  B5 03                        lda 3,x         ; MSB
001549r 3  F5 01                        sbc 1,x
00154Br 3  95 03                        sta 3,x
00154Dr 3               
00154Dr 3  E8                           inx
00154Er 3  E8                           inx
00154Fr 3               
00154Fr 3  60           z_minus:        rts
001550r 3               
001550r 3               
001550r 3               ; ## MINUS_LEADING ( addr1 u1 -- addr2 u2 ) "Remove leading spaces"
001550r 3               ; ## "-leading"  auto  Tali String
001550r 3                       ; """Remove leading whitespace. This is the reverse of -TRAILING
001550r 3                       ; """
001550r 3               
001550r 3               xt_minus_leading:
001550r 3  20 rr rr                     jsr underflow_2
001553r 3               
001553r 3               @loop:
001553r 3                               ; Quit if we were given an empty string. This also terminates
001553r 3                               ; the main loop
001553r 3  B5 00                        lda 0,x
001555r 3  15 01                        ora 1,x
001557r 3  F0 0F                        beq @done
001559r 3               
001559r 3  A1 02                        lda (2,x)               ; get first character
00155Br 3  20 rr rr                     jsr is_whitespace
00155Er 3  90 08                        bcc @done
001560r 3               
001560r 3                               ; It's whitespace, move one down
001560r 3  20 rr rr                     jsr xt_one              ; ( addr u 1 )
001563r 3  20 rr rr                     jsr xt_slash_string     ; ( addr+ u-1 )
001566r 3               
001566r 3  80 EB                        bra @loop
001568r 3               @done:
001568r 3               z_minus_leading:
001568r 3  60                           rts
001569r 3               
001569r 3               
001569r 3               
001569r 3               ; ## MINUS_TRAILING ( addr u1 -- addr u2 ) "Remove trailing spaces"
001569r 3               ; ## "-trailing"  auto  ANS string
001569r 3                       ; """https://forth-standard.org/standard/string/MinusTRAILING
001569r 3                       ; Remove trailing spaces
001569r 3                       ; """
001569r 3               
001569r 3               xt_minus_trailing:
001569r 3  20 rr rr                     jsr underflow_2
00156Cr 3               
00156Cr 3                               ; if length entry is zero, return a zero and leave the
00156Cr 3                               ; address part untouched
00156Cr 3  B5 00                        lda 0,x         ; LSB of n
00156Er 3  15 01                        ora 1,x         ; MSB of n
001570r 3  F0 33                        beq @done
001572r 3               
001572r 3                               ; Compute address of last char in tmp1 as
001572r 3                               ; addr + u1 - 1
001572r 3               
001572r 3                               ; addr + u1
001572r 3  18                           clc
001573r 3  B5 02                        lda 2,x         ; LSB of addr
001575r 3  75 00                        adc 0,x
001577r 3  85 rr                        sta tmp1
001579r 3  B5 03                        lda 3,x         ; MSB of addr
00157Br 3  75 01                        adc 1,x
00157Dr 3  85 rr                        sta tmp1+1
00157Fr 3               
00157Fr 3                               ; - 1
00157Fr 3  A5 rr                        lda tmp1
001581r 3  D0 02                        bne @1
001583r 3  C6 rr                        dec tmp1+1
001585r 3               @1:
001585r 3  C6 rr                        dec tmp1
001587r 3               
001587r 3               @loop:
001587r 3                               ; While spaces are found, move tmp1 backwards and
001587r 3                               ; decrease the count on the data stack.
001587r 3  B2 rr                        lda (tmp1)
001589r 3  C9 20                        cmp #AscSP
00158Br 3  D0 18                        bne @done
00158Dr 3               
00158Dr 3                               ; Move back one address.
00158Dr 3  A5 rr                        lda tmp1
00158Fr 3  D0 02                        bne @2
001591r 3  C6 rr                        dec tmp1+1
001593r 3               @2:
001593r 3  C6 rr                        dec tmp1
001595r 3               
001595r 3                               ; Decrement count by one.
001595r 3  B5 00                        lda 0,x
001597r 3  D0 02                        bne @3
001599r 3  D6 01                        dec 1,x
00159Br 3               @3:
00159Br 3  D6 00                        dec 0,x
00159Dr 3               
00159Dr 3                               ; Check if there are any characters left.
00159Dr 3  B5 00                        lda 0,x
00159Fr 3  15 01                        ora 1,x
0015A1r 3  F0 02                        beq @done       ; Count has reached zero - we're done!
0015A3r 3               
0015A3r 3  80 E2                        bra @loop
0015A5r 3               
0015A5r 3               @done:
0015A5r 3               z_minus_trailing:
0015A5r 3  60                           rts
0015A6r 3               
0015A6r 3               
0015A6r 3               
0015A6r 3               ; ## MOD ( n1 n2 -- n ) "Divide NOS by TOS and return the remainder"
0015A6r 3               ; ## "mod"  auto  ANS core
0015A6r 3                       ; """https://forth-standard.org/standard/core/MOD
0015A6r 3                       ;
0015A6r 3                       ; The Forth definition of this word is  : MOD /MOD DROP ;
0015A6r 3                       ; so we just jump to xt_slash_mod and dump the actual result.
0015A6r 3                       ; """
0015A6r 3               xt_mod:
0015A6r 3  20 rr rr                     jsr underflow_2
0015A9r 3               
0015A9r 3  20 rr rr                     jsr xt_slash_mod
0015ACr 3               
0015ACr 3  E8                           inx             ; DROP
0015ADr 3  E8                           inx
0015AEr 3               z_mod:
0015AEr 3  60                           rts
0015AFr 3               
0015AFr 3               
0015AFr 3               ; ## MOVE ( addr1 addr2 u -- ) "Copy bytes"
0015AFr 3               ; ## "move"  auto  ANS core
0015AFr 3                       ; """https://forth-standard.org/standard/core/MOVE
0015AFr 3                       ; Copy u "address units" from addr1 to addr2. Since our address
0015AFr 3                       ; units are bytes, this is just a front-end for CMOVE and CMOVE>. This
0015AFr 3                       ; is actually the only one of these three words that is in the CORE
0015AFr 3                       ; set.
0015AFr 3                       ;
0015AFr 3                       ; This word must not be natively compiled.
0015AFr 3                       ; """
0015AFr 3               
0015AFr 3               xt_move:
0015AFr 3                               ; We let CMOVE and CMOVE> check if there is underflow or
0015AFr 3                               ; we've been told to copy zero bytes
0015AFr 3               
0015AFr 3                               ; compare MSB first
0015AFr 3  B5 03                        lda 3,x                 ; MSB of addr2
0015B1r 3  D5 05                        cmp 5,x                 ; MSB of addr1
0015B3r 3  F0 05                        beq @lsb                ; wasn't helpful, move to LSB
0015B5r 3  B0 0E                        bcs @to_move_up         ; we want CMOVE>
0015B7r 3               
0015B7r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
0015BAr 3               
0015BAr 3               @lsb:
0015BAr 3                               ; MSB were equal, so do the whole thing over with LSB
0015BAr 3  B5 02                        lda 2,x                 ; LSB of addr2
0015BCr 3  D5 04                        cmp 4,x                 ; LSB of addr1
0015BEr 3  F0 08                        beq @equal              ; LSB is equal as well
0015C0r 3  B0 03                        bcs @to_move_up         ; we want CMOVE>
0015C2r 3               
0015C2r 3  4C rr rr                     jmp xt_cmove            ; JSR/RTS
0015C5r 3               
0015C5r 3               @to_move_up:
0015C5r 3  4C rr rr                     jmp xt_cmove_up         ; JSR/RTS
0015C8r 3               @equal:
0015C8r 3                               ; drop three entries from Data Stack
0015C8r 3  8A                           txa
0015C9r 3  18                           clc
0015CAr 3  69 06                        adc #6
0015CCr 3  AA                           tax
0015CDr 3               
0015CDr 3  60           z_move:         rts
0015CEr 3               
0015CEr 3               
0015CEr 3               
0015CEr 3               ; ## NAME_TO_INT ( nt -- xt ) "Convert Name Token to Execute Token"
0015CEr 3               ; ## "name>int"  tested  Gforth
0015CEr 3                       ; """See
0015CEr 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html
0015CEr 3                       ; """
0015CEr 3               
0015CEr 3               xt_name_to_int:
0015CEr 3  20 rr rr                     jsr underflow_1
0015D1r 3               
0015D1r 3                               ; The xt starts four bytes down from the nt
0015D1r 3  B5 00                        lda 0,x
0015D3r 3  18                           clc
0015D4r 3  69 04                        adc #4
0015D6r 3  85 rr                        sta tmp3
0015D8r 3               
0015D8r 3  B5 01                        lda 1,x
0015DAr 3  90 01                        bcc @done
0015DCr 3  1A                           inc
0015DDr 3               @done:
0015DDr 3  85 rr                        sta tmp3+1
0015DFr 3               
0015DFr 3  A0 00                        ldy #0
0015E1r 3  B1 rr                        lda (tmp3),y
0015E3r 3  95 00                        sta 0,x
0015E5r 3  C8                           iny
0015E6r 3  B1 rr                        lda (tmp3),y
0015E8r 3  95 01                        sta 1,x
0015EAr 3               
0015EAr 3  60           z_name_to_int:  rts
0015EBr 3               
0015EBr 3               
0015EBr 3               
0015EBr 3               ; ## NAME_TO_STRING ( nt -- addr u ) "Given a name token, return string of word"
0015EBr 3               ; ## "name>string"  tested  Gforth
0015EBr 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Name-token.html"""
0015EBr 3               
0015EBr 3               xt_name_to_string:
0015EBr 3  20 rr rr                     jsr underflow_1
0015EEr 3               
0015EEr 3  CA                           dex
0015EFr 3  CA                           dex
0015F0r 3               
0015F0r 3                               ; the length of the string is the first byte of the
0015F0r 3                               ; header pointed to by nt
0015F0r 3  A1 02                        lda (2,x)
0015F2r 3  95 00                        sta 0,x
0015F4r 3  74 01                        stz 1,x
0015F6r 3               
0015F6r 3                               ; the string itself always starts eight bytes down
0015F6r 3  B5 02                        lda 2,x         ; LSB
0015F8r 3  18                           clc
0015F9r 3  69 08                        adc #8
0015FBr 3  A8                           tay
0015FCr 3  B5 03                        lda 3,x         ; MSB
0015FEr 3  69 00                        adc #0          ; just need carry
001600r 3  95 03                        sta 3,x
001602r 3  94 02                        sty 2,x
001604r 3               
001604r 3               z_name_to_string:
001604r 3  60                           rts
001605r 3               
001605r 3               
001605r 3               ; ## NC_LIMIT ( -- addr ) "Return address where NC-LIMIT value is kept"
001605r 3               ; ## "nc-limit"  tested  Tali Forth
001605r 3               
001605r 3               xt_nc_limit:
001605r 3  CA                           dex
001606r 3  CA                           dex
001607r 3  A9 rr                        lda #<nc_limit
001609r 3  95 00                        sta 0,x
00160Br 3  A9 rr                        lda #>nc_limit
00160Dr 3  95 01                        sta 1,x
00160Fr 3               
00160Fr 3  60           z_nc_limit:     rts
001610r 3               
001610r 3               
001610r 3               
001610r 3               ; ## NEGATE ( n -- n ) "Two's complement"
001610r 3               ; ## "negate"  auto  ANS core
001610r 3                       ; """https://forth-standard.org/standard/core/NEGATE"""
001610r 3               xt_negate:
001610r 3  20 rr rr                     jsr underflow_1
001613r 3               
001613r 3  A9 00                	lda #0
001615r 3  38                           sec
001616r 3  F5 00                        sbc 0,x         ; LSB
001618r 3  95 00                        sta 0,x
00161Ar 3               
00161Ar 3  A9 00                        lda #0
00161Cr 3  F5 01                        sbc 1,x         ; MSB
00161Er 3  95 01                        sta 1,x
001620r 3               
001620r 3  60           z_negate:       rts
001621r 3               
001621r 3               
001621r 3               ; ## NEVER_NATIVE ( -- ) "Flag last word as never natively compiled"
001621r 3               ; ## "never-native"  auto  Tali Forth
001621r 3               xt_never_native:
001621r 3  20 rr rr                     jsr current_to_dp
001624r 3  A0 01                        ldy #1          ; offset for status byte
001626r 3  B1 rr                        lda (dp),y
001628r 3  09 08                        ora #NN         ; Make sure NN flag is set
00162Ar 3  29 FD                        and #$ff-AN     ; and AN flag is clear.
00162Cr 3  91 rr                        sta (dp),y
00162Er 3               z_never_native:
00162Er 3  60                           rts
00162Fr 3               
00162Fr 3               
00162Fr 3               ; ## NIP ( b a -- a ) "Delete NOS"
00162Fr 3               ; ## "nip"  auto  ANS core ext
00162Fr 3                       ; """https://forth-standard.org/standard/core/NIP"""
00162Fr 3               xt_nip:
00162Fr 3  20 rr rr                     jsr underflow_2
001632r 3               
001632r 3  B5 00                        lda 0,x         ; LSB
001634r 3  95 02                        sta 2,x
001636r 3  B5 01                        lda 1,x         ; MSB
001638r 3  95 03                        sta 3,x
00163Ar 3               
00163Ar 3  E8                           inx
00163Br 3  E8                           inx
00163Cr 3               
00163Cr 3  60           z_nip:          rts
00163Dr 3               
00163Dr 3               
00163Dr 3               ; ## NOT_EQUALS ( n m -- f ) "Return a true flag if TOS != NOS"
00163Dr 3               ; ## "<>"  auto  ANS core ext
00163Dr 3                       ; """https://forth-standard.org/standard/core/ne
00163Dr 3                       ;
00163Dr 3                       ; This is just a variant of EQUAL, we code it separately
00163Dr 3                       ; for speed.
00163Dr 3                       ; """
00163Dr 3               
00163Dr 3               xt_not_equals:
00163Dr 3  20 rr rr                     jsr underflow_2
001640r 3               
001640r 3  A0 00                        ldy #0                  ; default is true
001642r 3               
001642r 3  B5 00                        lda 0,x                 ; LSB
001644r 3  D5 02                        cmp 2,x
001646r 3  D0 0A                        bne @not_equal
001648r 3               
001648r 3                               ; LSB is equal
001648r 3  B5 01                        lda 1,x                 ; MSB
00164Ar 3  D5 03                        cmp 3,x
00164Cr 3  D0 04                        bne @not_equal
00164Er 3               
00164Er 3  A9 FF                        lda #$FF
001650r 3  80 01                        bra @done
001652r 3               
001652r 3               @not_equal:
001652r 3  88                           dey                     ; drop thru to done
001653r 3               
001653r 3               @done:
001653r 3  98                           tya
001654r 3  E8                           inx
001655r 3  E8                           inx
001656r 3  95 00                        sta 0,x
001658r 3  95 01                        sta 1,x
00165Ar 3               
00165Ar 3  60           z_not_equals:   rts
00165Br 3               
00165Br 3               
00165Br 3               
00165Br 3               ; ## NOT_ROTE ( a b c -- c a b ) "Rotate upwards"
00165Br 3               ; ## "-rot"  auto  Gforth
00165Br 3                       ; """http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Data-stack.html"""
00165Br 3               
00165Br 3               xt_not_rote:
00165Br 3  20 rr rr                     jsr underflow_3
00165Er 3               
00165Er 3  B4 01                        ldy 1,x         ; MSB first
001660r 3  B5 03                        lda 3,x
001662r 3  95 01                        sta 1,x
001664r 3               
001664r 3  B5 05                        lda 5,x
001666r 3  95 03                        sta 3,x
001668r 3  94 05                        sty 5,x
00166Ar 3               
00166Ar 3  B4 00                        ldy 0,x         ; LSB second
00166Cr 3  B5 02                        lda 2,x
00166Er 3  95 00                        sta 0,x
001670r 3               
001670r 3  B5 04                        lda 4,x
001672r 3  95 02                        sta 2,x
001674r 3  94 04                        sty 4,x
001676r 3               
001676r 3  60           z_not_rote:     rts
001677r 3               
001677r 3               
001677r 3               
001677r 3               ; ## NUMBER ( addr u -- u | d ) "Convert a number string"
001677r 3               ; ## "number"  auto  Tali Forth
001677r 3                       ; """Convert a number string to a double or single cell number. This
001677r 3                       ; is a wrapper for >NUMBER and follows the convention set out in the
001677r 3                       ; "Forth Programmer's Handbook" (Conklin & Rather) 3rd edition p. 87.
001677r 3                       ; Based in part on the "Starting Forth" code
001677r 3                       ; https://www.forth.com/starting-forth/10-input-output-operators/
001677r 3                       ; Gforth uses S>NUMBER? and S>UNUMBER? which return numbers and a flag
001677r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Number-Conversion.html
001677r 3                       ; Another difference to Gforth is that we follow ANS Forth that the
001677r 3                       ; dot to signal a double cell number is required to be the last
001677r 3                       ; character of the string.
001677r 3                       ;
001677r 3                       ; Number calls >NUMBER which in turn calls UM*,
001677r 3                       ; which uses tmp1, tmp2, and tmp3, so we can't use them here, which is
001677r 3                       ; a pain.
001677r 3                       ;"""
001677r 3               
001677r 3               xt_number:
001677r 3  20 rr rr                     jsr underflow_2
00167Ar 3               
00167Ar 3                               ; we keep the flags for sign and double in tmpdsp because
00167Ar 3                               ; we've run out of temporary variables
00167Ar 3  64 rr                        stz tmpdsp      ; flag for double
00167Cr 3  64 rr                        stz tmpdsp+1    ; flag for minus
00167Er 3               
00167Er 3                               ; If the first character is a minus, strip it off and set
00167Er 3                               ; the flag
00167Er 3  A1 02                        lda (2,x)
001680r 3  C9 2D                        cmp #$2D        ; ASCII for "-"
001682r 3  D0 0A                        bne @check_dot
001684r 3               
001684r 3                               ; It's a minus
001684r 3  C6 rr                        dec tmpdsp+1
001686r 3  F6 02                        inc 2,x         ; start one character later
001688r 3  D0 02                        bne @1
00168Ar 3  F6 03                        inc 3,x
00168Cr 3               @1:
00168Cr 3  D6 00                        dec 0,x         ; decrease string length by one
00168Er 3               
00168Er 3               @check_dot:
00168Er 3                               ; If the last character is a dot, strip it off and set a
00168Er 3                               ; flag. We can use tmptos as a temporary variable
00168Er 3  B5 02                        lda 2,x         ; LSB of address
001690r 3  18                           clc
001691r 3  75 00                        adc 0,x         ; length of string
001693r 3  85 rr                        sta tmptos
001695r 3  B5 03                        lda 3,x
001697r 3  69 00                        adc #0          ; only need carry
001699r 3  85 rr                        sta tmptos+1
00169Br 3               
00169Br 3                               ; tmptos now points to the first character after the string,
00169Br 3                               ; but we need the last character
00169Br 3  A5 rr                        lda tmptos
00169Dr 3  D0 02                        bne @2
00169Fr 3  C6 rr                        dec tmptos+1
0016A1r 3               @2:
0016A1r 3  C6 rr                        dec tmptos
0016A3r 3               
0016A3r 3  B2 rr                        lda (tmptos)
0016A5r 3  C9 2E                        cmp #'.'
0016A7r 3  D0 04                        bne @main
0016A9r 3               
0016A9r 3                               ; We have a dot, which means this is a double number. Flag
0016A9r 3                               ; the fact and reduce string length by one
0016A9r 3  C6 rr                        dec tmpdsp
0016ABr 3  D6 00                        dec 0,x
0016ADr 3               
0016ADr 3               @main:
0016ADr 3                               ; Set up stack for subroutine jump to >NUMBER, which means
0016ADr 3                               ; we have to go ( addr u --> ud addr u )
0016ADr 3  CA                           dex
0016AEr 3  CA                           dex
0016AFr 3  CA                           dex
0016B0r 3  CA                           dex
0016B1r 3               
0016B1r 3  B5 04                        lda 4,x         ; LSB of length
0016B3r 3  95 00                        sta 0,x
0016B5r 3  74 01                        stz 1,x         ; MSB, max length 255 chars
0016B7r 3               
0016B7r 3  B5 06                        lda 6,x         ; LSB of address
0016B9r 3  95 02                        sta 2,x
0016BBr 3  B5 07                        lda 7,x         ; MSB of address
0016BDr 3  95 03                        sta 3,x
0016BFr 3               
0016BFr 3  74 04                        stz 4,x         ; clear space for ud
0016C1r 3  74 05                        stz 5,x
0016C3r 3  74 06                        stz 6,x
0016C5r 3  74 07                        stz 7,x
0016C7r 3               
0016C7r 3  20 rr rr                     jsr xt_to_number        ; (ud addr u -- ud addr u )
0016CAr 3               
0016CAr 3                               ; test length of returned string, which should be zero
0016CAr 3  B5 00                        lda 0,x
0016CCr 3  F0 15                        beq @all_converted
0016CEr 3               
0016CEr 3                               ; Something went wrong, we still have characters left over,
0016CEr 3                               ; so we print an error and abort. If the NUMBER was called
0016CEr 3                               ; by INTERPRET, we've already checked for Forth words, so
0016CEr 3                               ; we're in deep trouble one way or another
0016CEr 3  A9 3E                        lda #$3E        ; ASCII for ">"
0016D0r 3  20 rr rr                     jsr emit_a
0016D3r 3  20 rr rr                     jsr xt_type
0016D6r 3  A9 3C                        lda #$3C        ; ASCII for "<"
0016D8r 3  20 rr rr                     jsr emit_a
0016DBr 3  20 rr rr                     jsr xt_space
0016DEr 3               
0016DEr 3  A9 08                        lda #err_syntax
0016E0r 3  4C rr rr                     jmp error
0016E3r 3               
0016E3r 3               @all_converted:
0016E3r 3                               ; We can drop the string info
0016E3r 3  E8                           inx
0016E4r 3  E8                           inx
0016E5r 3  E8                           inx
0016E6r 3  E8                           inx
0016E7r 3               
0016E7r 3                               ; We have a double-cell number on the Data Stack that might
0016E7r 3                               ; actually have a minus and might actually be single-cell
0016E7r 3  A5 rr                        lda tmpdsp      ; flag for double
0016E9r 3  F0 0D                        beq @single
0016EBr 3               
0016EBr 3                               ; Set status bit 5 to indicate this is a double number
0016EBr 3  A9 20                        lda #%00100000
0016EDr 3  04 rr                        tsb status
0016EFr 3               
0016EFr 3                               ; This is a double cell number. If it had a minus, we'll have
0016EFr 3                               ; to negate it
0016EFr 3  A5 rr                        lda tmpdsp+1
0016F1r 3  F0 12                        beq @done       ; no minus, all done
0016F3r 3               
0016F3r 3  20 rr rr                     jsr xt_dnegate
0016F6r 3               
0016F6r 3  80 0D                        bra @done
0016F8r 3               
0016F8r 3               @single:
0016F8r 3                               ; This is a single number, so we just drop the top cell
0016F8r 3  E8                           inx
0016F9r 3  E8                           inx
0016FAr 3               
0016FAr 3                               ; Clear status bit 5 to indicate this is a single number
0016FAr 3  A9 20                        lda #%00100000
0016FCr 3  14 rr                        trb status
0016FEr 3               
0016FEr 3                               ; If we had a minus, we'll have to negate it
0016FEr 3  A5 rr                        lda tmpdsp+1
001700r 3  F0 03                        beq @done       ; no minus, all done
001702r 3               
001702r 3  20 rr rr                     jsr xt_negate
001705r 3               @done:
001705r 3  60           z_number:       rts
001706r 3               
001706r 3               
001706r 3               
001706r 3               ; ## NUMBER_SIGN ( ud -- ud ) "Add character to pictured output string"
001706r 3               ; ## "#"  auto  ANS core
001706r 3                       ; """https://forth-standard.org/standard/core/num
001706r 3                       ; Add one char to the beginning of the pictured output string.
001706r 3                       ;
001706r 3                       ; Based on
001706r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
001706r 3                       ; Forth code  BASE @ UD/MOD ROT 9 OVER < IF 7 + THEN [CHAR] 0 + HOLD ;
001706r 3                       ; """
001706r 3               xt_number_sign:
001706r 3  20 rr rr                     jsr underflow_2         ; double number
001709r 3               
001709r 3  20 rr rr                     jsr xt_base
00170Cr 3  20 rr rr                     jsr xt_fetch            ; ( ud1 base )
00170Fr 3               
00170Fr 3                               ; The following code is the ancient Forth word UD/MOD, which in
00170Fr 3                               ; various Forths (including Gforth) lives on under the hood,
00170Fr 3                               ; even though it's not an ANS standard word, it doesn't appear
00170Fr 3                               ; in the docs, it's only used here, and there are no tests for
00170Fr 3                               ; it. This is why we got rid of it. We'll be converting this
00170Fr 3                               ; mess to something more sane in the long run.
00170Fr 3  20 rr rr                     jsr xt_to_r             ; >r
001712r 3  20 rr rr                     jsr xt_zero             ; 0
001715r 3  20 rr rr                     jsr xt_r_fetch          ; r@
001718r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
00171Br 3  20 rr rr                     jsr xt_rot              ; rot
00171Er 3  20 rr rr                     jsr xt_rot              ; rot
001721r 3  20 rr rr                     jsr xt_r_from           ; r>
001724r 3  20 rr rr                     jsr xt_um_slash_mod     ; um/mod
001727r 3  20 rr rr                     jsr xt_rot              ; rot
00172Ar 3                               ; end of UD/MOD ( rem ud )
00172Ar 3               
00172Ar 3  20 rr rr                     jsr xt_rot              ; ( ud rem )
00172Dr 3               
00172Dr 3                               ; Convert the number that is left over to an ASCII character. We
00172Dr 3                               ; use a string lookup for speed. Use either abc_str_lower for
00172Dr 3                               ; lower case or abc_str_upper for upper case (prefered)
00172Dr 3  B5 00                        lda 0,x
00172Fr 3  A8                           tay
001730r 3  B9 rr rr                     lda s_abc_upper,y
001733r 3  95 00                        sta 0,x
001735r 3  74 01                        stz 1,x                 ; paranoid; now ( ud char )
001737r 3               
001737r 3  20 rr rr                     jsr xt_hold
00173Ar 3               
00173Ar 3               z_number_sign:
00173Ar 3  60                           rts
00173Br 3               
00173Br 3               
00173Br 3               ; ## NUMBER_SIGN_GREATER ( d -- addr u ) "Finish pictured number conversion"
00173Br 3               ; ## "#>"  auto  ANS core
00173Br 3                       ; """https://forth-standard.org/standard/core/num-end
00173Br 3                       ; Finish conversion of pictured number string, putting address and
00173Br 3                       ; length on the Data Stack.
00173Br 3                       ;
00173Br 3                       ; Original Fort is  2DROP HLD @ PAD OVER -
00173Br 3                       ; Based on
00173Br 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
00173Br 3                       ; """
00173Br 3               xt_number_sign_greater:
00173Br 3               
00173Br 3  20 rr rr                     jsr underflow_2         ; double number
00173Er 3               
00173Er 3                               ; The start address lives in tohold
00173Er 3  A5 rr                        lda tohold
001740r 3  95 00                        sta 0,x         ; LSB of tohold
001742r 3  95 02                        sta 2,x
001744r 3  A5 rr                        lda tohold+1
001746r 3  95 01                        sta 1,x         ; MSB of addr
001748r 3  95 03                        sta 3,x         ; ( addr addr )
00174Ar 3               
00174Ar 3                               ; The length of the string is pad - addr
00174Ar 3  20 rr rr                     jsr xt_pad      ; ( addr addr pad )
00174Dr 3               
00174Dr 3  38                           sec
00174Er 3  B5 00                        lda 0,x         ; LSB of pad address
001750r 3  F5 02                        sbc 2,x
001752r 3  95 02                        sta 2,x
001754r 3               
001754r 3  B5 01                        lda 1,x         ; MSB, which should always be zero
001756r 3  F5 03                        sbc 3,x
001758r 3  95 03                        sta 3,x         ; ( addr u pad )
00175Ar 3               
00175Ar 3  E8                           inx
00175Br 3  E8                           inx
00175Cr 3               
00175Cr 3               z_number_sign_greater:
00175Cr 3  60                           rts
00175Dr 3               
00175Dr 3               
00175Dr 3               ; ## NUMBER_SIGN_S ( d -- addr u ) "Completely convert pictured output"
00175Dr 3               ; ## "#s"  auto  ANS core
00175Dr 3                       ; """https://forth-standard.org/standard/core/numS
00175Dr 3                       ; Completely convert number for pictured numerical output.
00175Dr 3                       ;
00175Dr 3                       ; Based on
00175Dr 3                       ; https://github.com/philburk/pforth/blob/master/fth/system.fth
00175Dr 3                       ; Original Forth code  BEGIN # 2DUP OR 0= UNTIL
00175Dr 3                       ; """
00175Dr 3               
00175Dr 3               xt_number_sign_s:
00175Dr 3  20 rr rr                     jsr underflow_2
001760r 3               @loop:
001760r 3                               ; convert a single number ("#")
001760r 3  20 rr rr                     jsr xt_number_sign
001763r 3               
001763r 3                               ; stop when double-celled number in TOS is zero:
001763r 3  B5 00                        lda 0,x
001765r 3  15 01                        ora 1,x
001767r 3  15 02                        ora 2,x
001769r 3  15 03                        ora 3,x
00176Br 3  D0 F3                        bne @loop
00176Dr 3               
00176Dr 3               z_number_sign_s:
00176Dr 3  60                           rts
00176Er 3               
00176Er 3               
00176Er 3               
00176Er 3               ; ## OF (C: -- of-sys) (x1 x2 -- |x1) "Conditional flow control"
00176Er 3               ; ## "of"  auto  ANS core ext
00176Er 3                       ; """http://forth-standard.org/standard/core/OF"""
00176Er 3               
00176Er 3               xt_of:
00176Er 3                               ; Check if value is equal to this case.
00176Er 3                               ; Postpone over (eg. compile a jsr to it)
00176Er 3  A0 rr                        ldy #>xt_over
001770r 3  A9 rr                        lda #<xt_over
001772r 3  20 rr rr                     jsr cmpl_subroutine
001775r 3               
001775r 3                               ; Postpone = (EQUAL), that is, compile a jsr to it
001775r 3  A0 rr                        ldy #>xt_equal
001777r 3  A9 rr                        lda #<xt_equal
001779r 3  20 rr rr                     jsr cmpl_subroutine
00177Cr 3               
00177Cr 3  20 rr rr                     jsr xt_if
00177Fr 3               
00177Fr 3                               ; If it's true, consume the original value.
00177Fr 3                               ; Postpone DROP (eg. compile a jsr to it)
00177Fr 3  A0 rr                        ldy #>xt_drop
001781r 3  A9 rr                        lda #<xt_drop
001783r 3  20 rr rr                     jsr cmpl_subroutine
001786r 3               
001786r 3  60           z_of:           rts
001787r 3               
001787r 3               
001787r 3               
001787r 3               ; ## ONE ( -- n ) "Push the number 1 to the Data Stack"
001787r 3               ; ## "1"  auto  Tali Forth
001787r 3                       ; """This is also the code for EDITOR-WORDLIST"""
001787r 3               xt_editor_wordlist:
001787r 3               xt_one:
001787r 3  CA                           dex
001788r 3  CA                           dex
001789r 3  A9 01                        lda #1
00178Br 3  95 00                        sta 0,x
00178Dr 3  74 01                        stz 1,x
00178Fr 3               
00178Fr 3               z_editor_wordlist:
00178Fr 3               z_one:
00178Fr 3  60                           rts
001790r 3               
001790r 3               
001790r 3               ; ## ONE_MINUS ( u -- u-1 ) "Decrease TOS by one"
001790r 3               ; ## "1-"  auto  ANS core
001790r 3                       ; """https://forth-standard.org/standard/core/OneMinus"""
001790r 3               
001790r 3               xt_one_minus:
001790r 3  20 rr rr                     jsr underflow_1
001793r 3               
001793r 3  B5 00                        lda 0,x
001795r 3  D0 02                        bne @1
001797r 3  D6 01                        dec 1,x
001799r 3               @1:
001799r 3  D6 00                        dec 0,x
00179Br 3               
00179Br 3  60           z_one_minus:    rts
00179Cr 3               
00179Cr 3               
00179Cr 3               
00179Cr 3               ; ## ONE_PLUS ( u -- u+1 ) "Increase TOS by one"
00179Cr 3               ; ## "1+"  auto  ANS core
00179Cr 3                       ; """https://forth-standard.org/standard/core/OnePlus
00179Cr 3                       ;
00179Cr 3                       ; Code is shared with CHAR-PLUS
00179Cr 3                       ; """
00179Cr 3               
00179Cr 3               xt_char_plus:
00179Cr 3               xt_one_plus:
00179Cr 3  20 rr rr                     jsr underflow_1
00179Fr 3               
00179Fr 3  F6 00                        inc 0,x
0017A1r 3  D0 02                        bne @done
0017A3r 3  F6 01                        inc 1,x
0017A5r 3               
0017A5r 3               @done:
0017A5r 3               z_char_plus:
0017A5r 3  60           z_one_plus:     rts
0017A6r 3               
0017A6r 3               
0017A6r 3               
0017A6r 3               ; ## ONLY ( -- ) "Set earch order to minimum wordlist"
0017A6r 3               ; ## "only"  auto  ANS search ext
0017A6r 3                       ; """https://forth-standard.org/standard/search/ONLY"""
0017A6r 3               
0017A6r 3               xt_only:
0017A6r 3                               ; Put -1 on data stack.
0017A6r 3  CA                           dex
0017A7r 3  CA                           dex
0017A8r 3  A9 FF                        lda #$FF
0017AAr 3  95 00                        sta 0,x
0017ACr 3  95 01                        sta 1,x
0017AEr 3               
0017AEr 3                               ; Invoke set-order to set the minimum search order.
0017AEr 3  20 rr rr                     jsr xt_set_order
0017B1r 3               
0017B1r 3  60           z_only:         rts
0017B2r 3               
0017B2r 3               
0017B2r 3               
0017B2r 3               ; ## OR ( m n -- n ) "Logically OR TOS and NOS"
0017B2r 3               ; ## "or"  auto  ANS core
0017B2r 3                       ; """https://forth-standard.org/standard/core/OR"
0017B2r 3               xt_or:
0017B2r 3  20 rr rr                     jsr underflow_2
0017B5r 3               
0017B5r 3  B5 00                        lda 0,x
0017B7r 3  15 02                        ora 2,x
0017B9r 3  95 02                        sta 2,x
0017BBr 3               
0017BBr 3  B5 01                        lda 1,x
0017BDr 3  15 03                        ora 3,x
0017BFr 3  95 03                        sta 3,x
0017C1r 3               
0017C1r 3  E8                           inx
0017C2r 3  E8                           inx
0017C3r 3               
0017C3r 3  60           z_or:           rts
0017C4r 3               
0017C4r 3               
0017C4r 3               ; ## ORDER ( -- ) "Print current word order list and current WID"
0017C4r 3               ; ## "order"  auto  ANS core
0017C4r 3                       ; """https://forth-standard.org/standard/search/ORDER
0017C4r 3                       ; Note the search order is displayed from first search to last
0017C4r 3                       ; searched and is therefore exactly the reverse of the order in which
0017C4r 3                       ; Forth stacks are displayed.
0017C4r 3                       ;
0017C4r 3                       ; A Forth implementation of this word is:
0017C4r 3                       ;
0017C4r 3                       ; 	: .wid ( wid -- )
0017C4r 3                       ; 	dup 0=  if ." Forth "  drop    else
0017C4r 3                       ; 	dup 1 = if ." Editor " drop    else
0017C4r 3                       ; 	dup 2 = if ." Assembler " drop else
0017C4r 3                       ; 	dup 3 = if ." Root " drop      else
0017C4r 3                       ; 	           . ( just print the number )
0017C4r 3                       ; 	then then then then ;
0017C4r 3                       ;
0017C4r 3                       ; : ORDER ( -- )
0017C4r 3                       ; 	cr get-order 0 ?do .wid loop
0017C4r 3                       ; 	space space get-current .wid ;
0017C4r 3                       ;
0017C4r 3                       ; This is an interactive program, so speed
0017C4r 3                       ; is not as important as size. We assume we do not have more than 255
0017C4r 3                       ; wordlists.
0017C4r 3                       ; """
0017C4r 3               
0017C4r 3               xt_order:
0017C4r 3  20 rr rr                     jsr xt_cr
0017C7r 3  20 rr rr                     jsr xt_get_order        ; ( wid_n ... wid_1 n )
0017CAr 3               
0017CAr 3                               ; Paranoid: Check if there are no wordlists, a rather
0017CAr 3                               ; pathological case. this would mean ( 0 ) on the stack. In
0017CAr 3                               ; that case, we just drop n and run
0017CAr 3  B5 00                        lda 0,x                 ; assumes no more than 255 wordlists
0017CCr 3  F0 1E                        beq @drop_done
0017CEr 3               
0017CEr 3               @have_wordlists:
0017CEr 3                               ; We arrive here with the LSB of TOS in A, the number of WIDs
0017CEr 3                               ; on the stack
0017CEr 3  A8                           tay
0017CFr 3               @loop:
0017CFr 3  E8                           inx
0017D0r 3  E8                           inx                     ; DROP, now ( wid_n ... wid_1 )
0017D1r 3  B5 00                        lda 0,x
0017D3r 3               
0017D3r 3  5A                           phy
0017D4r 3  20 rr rr                     jsr _print_wid_string   ; internal helper function
0017D7r 3  7A                           ply
0017D8r 3               
0017D8r 3  88                           dey
0017D9r 3  D0 F4                        bne @loop
0017DBr 3               
0017DBr 3                               ; We've printed the wordlists, now we add the current wordlist.
0017DBr 3                               ; This follows the convention of Gforth
0017DBr 3  20 rr rr                     jsr xt_space
0017DEr 3  20 rr rr                     jsr xt_space
0017E1r 3  20 rr rr                     jsr xt_get_current      ; ( wid )
0017E4r 3               
0017E4r 3  B5 00                        lda 0,x
0017E6r 3  20 rr rr                     jsr _print_wid_string
0017E9r 3  20 rr rr                     jsr xt_cr
0017ECr 3               
0017ECr 3               @drop_done:
0017ECr 3  E8                           inx
0017EDr 3  E8                           inx
0017EEr 3               z_order:
0017EEr 3  60                           rts
0017EFr 3               
0017EFr 3               _print_wid_string:
0017EFr 3                       ; """Helper function for ORDER: Given a WID in A, print the
0017EFr 3                       ; corresponding string. If there is no such word list defined, just
0017EFr 3                       ; print the number. Assumes we will not have more than 256 WIDs; also
0017EFr 3                       ; assumes we have just loaded A so Z reflects status of byte.  In
0017EFr 3                       ; theory, we could speed this up by having the WID be the same as the
0017EFr 3                       ; number of the strings. However, ORDER is used rather infrequently and
0017EFr 3                       ; this would make changes to the strings.asm file very dangerous, so we
0017EFr 3                       ; follow the slightly more complicated route with a translation table.
0017EFr 3                       ; """
0017EFr 3                               ; If the WID is larger than 3, we have no string avaliable and
0017EFr 3                               ; just print the number.
0017EFr 3                               ; See http://6502.org/tutorials/compare_instructions.html
0017EFr 3                               ; for details
0017EFr 3  C9 04                        cmp #4
0017F1r 3  90 09                        bcc @output_string      ; less than 4, print a real string
0017F3r 3               
0017F3r 3                               ; Our WID is not less than 4, that is, 4 or larger. We just
0017F3r 3                               ; print the number
0017F3r 3  CA                           dex
0017F4r 3  CA                           dex
0017F5r 3  95 00                        sta 0,x
0017F7r 3  74 01                        stz 1,x
0017F9r 3  4C rr rr                     jmp xt_u_dot            ; JSR/RTS as this routine is not compiled
0017FCr 3               
0017FCr 3               @output_string:
0017FCr 3                               ; Get the string number based on WID 0 to 3
0017FCr 3  A8                           tay
0017FDr 3  B9 rr rr                     lda @wid_data,y
001800r 3               
001800r 3                               ; Print without a line feed
001800r 3  4C rr rr                     jmp print_string_no_lf  ; JSR/RTS as this routine is not compiled
001803r 3               
001803r 3               @wid_data:
001803r 3                       ; Table of string numbers (see strings.asm) indexed by the WID if
001803r 3                       ; less than 4.
001803r 3  03                   .byte str_wid_forth            ; WID 0: "Forth"
001804r 3  06                   .byte str_wid_editor           ; WID 1: "Editor"
001805r 3  07                   .byte str_wid_assembler        ; WID 2: "Assembler"
001806r 3  08                   .byte str_wid_root             ; WID 3: "Root"
001807r 3               
001807r 3               
001807r 3               
001807r 3               ; ## OUTPUT ( -- addr ) "Return the address of the EMIT vector address"
001807r 3               ; ## "output"  tested  Tali Forth
001807r 3               xt_output:
001807r 3                       ; """Return the address where the jump target for EMIT is stored (but
001807r 3                       ; not the vector itself). By default, this will hold the value of
001807r 3                       ; kernel_putc routine, but this can be changed by the user, hence this
001807r 3                       ; routine.
001807r 3                       ; """
001807r 3  CA                           dex
001808r 3  CA                           dex
001809r 3  A9 rr                        lda #<output
00180Br 3  95 00                        sta 0,x
00180Dr 3  A9 rr                        lda #>output
00180Fr 3  95 01                        sta 1,x
001811r 3               
001811r 3  60           z_output:       rts
001812r 3               
001812r 3               
001812r 3               ; ## OVER ( b a -- b a b ) "Copy NOS to TOS"
001812r 3               ; ## "over"  auto  ANS core
001812r 3                       ; """https://forth-standard.org/standard/core/OVER"""
001812r 3               xt_over:
001812r 3  20 rr rr                     jsr underflow_2
001815r 3               
001815r 3  CA                           dex
001816r 3  CA                           dex
001817r 3               
001817r 3  B5 04                        lda 4,x         ; LSB
001819r 3  95 00                        sta 0,x
00181Br 3  B5 05                        lda 5,x         ; MSB
00181Dr 3  95 01                        sta 1,x
00181Fr 3               
00181Fr 3  60           z_over:         rts
001820r 3               
001820r 3               
001820r 3               ; ## PAD ( -- addr ) "Return address of user scratchpad"
001820r 3               ; ## "pad"  auto  ANS core ext
001820r 3                       ; """https://forth-standard.org/standard/core/PAD
001820r 3                       ; Return address to a temporary area in free memory for user. Must
001820r 3                       ; be at least 84 bytes in size (says ANS). It is located relative to
001820r 3                       ; the compile area pointer (CP) and therefore varies in position.
001820r 3                       ; This area is reserved for the user and not used by the system
001820r 3                       ; """
001820r 3               xt_pad:
001820r 3  CA                           dex
001821r 3  CA                           dex
001822r 3               
001822r 3  A5 rr                        lda cp
001824r 3  18                           clc
001825r 3  69 FF                        adc #padoffset  ; assumes padoffset one byte in size
001827r 3  95 00                        sta 0,x
001829r 3               
001829r 3  A5 rr                        lda cp+1
00182Br 3  69 00                        adc #0          ; only need carry
00182Dr 3  95 01                        sta 1,x
00182Fr 3               
00182Fr 3  60           z_pad:          rts
001830r 3               
001830r 3               
001830r 3               ; ## PAGE ( -- ) "Clear the screen"
001830r 3               ; ## "page"  tested  ANS facility
001830r 3                       ; """https://forth-standard.org/standard/facility/PAGE
001830r 3                       ; Clears a page if supported by ANS terminal codes. This is
001830r 3                       ; Clear Screen ("ESC[2J") plus moving the cursor to the top
001830r 3                       ; left of the screen
001830r 3                       ; """
001830r 3               xt_page:
001830r 3  A9 1B                        lda #AscESC
001832r 3  20 rr rr                     jsr emit_a
001835r 3  A9 5B                        lda #$5B        ; ASCII for "["
001837r 3  20 rr rr                     jsr emit_a
00183Ar 3  A9 32                        lda #'2'
00183Cr 3  20 rr rr                     jsr emit_a
00183Fr 3  A9 4A                        lda #'J'
001841r 3  20 rr rr                     jsr emit_a
001844r 3               
001844r 3                               ; move cursor to top left of screen
001844r 3  20 rr rr                     jsr xt_zero
001847r 3  20 rr rr                     jsr xt_zero
00184Ar 3  20 rr rr                     jsr xt_at_xy
00184Dr 3               
00184Dr 3  60           z_page:         rts
00184Er 3               
00184Er 3               
00184Er 3               ; ## PAREN ( -- ) "Discard input up to close paren ( comment )"
00184Er 3               ; ## "("  auto  ANS core
00184Er 3                       ; """http://forth-standard.org/standard/core/p"""
00184Er 3               
00184Er 3               xt_paren:
00184Er 3                               ; Put a right paren on the stack.
00184Er 3  CA                           dex
00184Fr 3  CA                           dex
001850r 3  A9 29                        lda #41     ; Right parenthesis
001852r 3  95 00                        sta 0,x
001854r 3  74 01                        stz 1,x
001856r 3               
001856r 3                               ; Call parse.
001856r 3  20 rr rr                     jsr xt_parse
001859r 3               
001859r 3                               ; Throw away the result.
001859r 3  E8                           inx
00185Ar 3  E8                           inx
00185Br 3  E8                           inx
00185Cr 3  E8                           inx
00185Dr 3               
00185Dr 3  60           z_paren:        rts
00185Er 3               
00185Er 3               
00185Er 3               
00185Er 3               ; ## PARSE_NAME ( "name" -- addr u ) "Parse the input"
00185Er 3               ; ## "parse-name"  auto  ANS core ext
00185Er 3                       ; """https://forth-standard.org/standard/core/PARSE-NAME
00185Er 3                       ; Find next word in input string, skipping leading whitespace. This is
00185Er 3                       ; a special form of PARSE and drops through to that word. See PARSE
00185Er 3                       ; for more detail. We use this word internally for the interpreter
00185Er 3                       ; because it is a lot easier to use. Reference implementations at
00185Er 3                       ; http://forth-standard.org/standard/core/PARSE-NAME and
00185Er 3                       ; http://www.forth200x.org/reference-implementations/parse-name.fs
00185Er 3                       ; Roughly, the word is comparable to BL WORD COUNT. -- Note that
00185Er 3                       ; though the ANS standard talks about skipping "spaces", whitespace
00185Er 3                       ; is actually perfectly legal (see for example
00185Er 3                       ; http://forth-standard.org/standard/usage#subsubsection.3.4.1.1).
00185Er 3                       ; Otherwise, PARSE-NAME chokes on tabs.
00185Er 3                       ; """
00185Er 3               
00185Er 3               xt_parse_name:
00185Er 3                               ; To enable the compilation of the high-level Forth words
00185Er 3                               ; in forth-words.asm and user-words.asm at boot time,
00185Er 3                               ; PARSE-NAME and PARSE must be able to deal with 16-bit string
00185Er 3                               ; lengths. This is a pain on an 8-bit machine. The pointer
00185Er 3                               ; to the current location is in toin (>IN). We need to check,
00185Er 3                               ; worst case, the characters from cib+toin to cib+ciblen, and
00185Er 3                               ; we can't just use Y as an index.
00185Er 3               
00185Er 3                               ; The counter is CIBLEN-TOIN and stored in tmp1
00185Er 3  A5 rr                        lda ciblen              ; LSB of counter
001860r 3  38                           sec
001861r 3  E5 rr                        sbc toin
001863r 3  85 rr                        sta tmp1
001865r 3  A5 rr                        lda ciblen+1            ; MSB
001867r 3  E5 rr                        sbc toin+1
001869r 3  85 rr                        sta tmp1+1
00186Br 3               
00186Br 3                               ; Check the result for zero (TOIN is equal to CIBLEN)
00186Br 3  A5 rr                        lda tmp1
00186Dr 3  05 rr                        ora tmp1+1
00186Fr 3  F0 28                        beq @empty_line
001871r 3               
001871r 3                               ; We walk through the characters starting at CIB+TOIN, so we
001871r 3                               ; save a temp version of that in tmp2
001871r 3  A5 rr                        lda cib
001873r 3  18                           clc
001874r 3  65 rr                        adc toin
001876r 3  85 rr                        sta tmp2                ; LSB of first character
001878r 3  A5 rr                        lda cib+1
00187Ar 3  65 rr                        adc toin+1
00187Cr 3  85 rr                        sta tmp2+1              ; MSB
00187Er 3               
00187Er 3               @skip_loop:
00187Er 3  B2 rr                        lda (tmp2)              ; work copy of cib
001880r 3  20 rr rr                     jsr is_whitespace
001883r 3  90 1F                        bcc @char_found
001885r 3               
001885r 3                               ; Char is still whitespace, continue
001885r 3  E6 rr                        inc tmp2
001887r 3  D0 02                        bne @2
001889r 3  E6 rr                        inc tmp2+1
00188Br 3               @2:
00188Br 3                               ; Adjust counter
00188Br 3  A5 rr                        lda tmp1
00188Dr 3  D0 02                        bne @3
00188Fr 3  C6 rr                        dec tmp1+1
001891r 3               @3:
001891r 3  C6 rr                        dec tmp1
001893r 3               
001893r 3  A5 rr                        lda tmp1
001895r 3  05 rr                        ora tmp1+1
001897r 3  D0 E5                        bne @skip_loop          ; fall through if empty line
001899r 3               
001899r 3               @empty_line:
001899r 3                               ; Neither the ANS Forth nor the Gforth documentation say
001899r 3                               ; what to return as an address if a string with only
001899r 3                               ; spaces is given. For speed reasons, we just return junk
001899r 3                               ; NOS, with the TOS zero as per standard
001899r 3  CA                           dex
00189Ar 3  CA                           dex
00189Br 3  CA                           dex
00189Cr 3  CA                           dex
00189Dr 3               
00189Dr 3  74 00                        stz 0,x                 ; TOS is zero
00189Fr 3  74 01                        stz 1,x
0018A1r 3               
0018A1r 3  4C rr rr                     jmp z_parse_name        ; skip over PARSE
0018A4r 3               
0018A4r 3               @char_found:
0018A4r 3                               ; We arrive here with tmp2 pointing to the first non-space
0018A4r 3                               ; character. This is where the word really starts, so
0018A4r 3                               ; we use it to calculate the new >IN by subtracting
0018A4r 3  A5 rr                        lda tmp2
0018A6r 3  38                           sec
0018A7r 3  E5 rr                        sbc cib
0018A9r 3  85 rr                        sta toin
0018ABr 3  A5 rr                        lda tmp2+1
0018ADr 3  E5 rr                        sbc cib+1
0018AFr 3  85 rr                        sta toin+1
0018B1r 3               
0018B1r 3                               ; prepare Data Stack for PARSE by adding space
0018B1r 3                               ; as the delimiter
0018B1r 3  CA                           dex
0018B2r 3  CA                           dex
0018B3r 3               
0018B3r 3  A9 20                        lda #AscSP
0018B5r 3  95 00                        sta 0,x
0018B7r 3  74 01                        stz 1,x                 ; paranoid, now ( "name" c )
0018B9r 3               
0018B9r 3               
0018B9r 3               ; ## PARSE ( "name" c -- addr u ) "Parse input with delimiter character"
0018B9r 3               ; ## "parse"  tested  ANS core ext
0018B9r 3                       ; """https://forth-standard.org/standard/core/PARSE
0018B9r 3                       ; Find word in input string delimited by character given. Do not
0018B9r 3                       ; skip leading delimiters -- this is the main difference to PARSE-NAME.
0018B9r 3                       ; PARSE and PARSE-NAME replace WORD in modern systems. ANS discussion
0018B9r 3                       ; http://www.forth200x.org/documents/html3/rationale.html#rat:core:PARSE
0018B9r 3                       ;
0018B9r 3                       ;
0018B9r 3                       ;     cib  cib+toin   cib+ciblen
0018B9r 3                       ;      v      v            v
0018B9r 3                       ;     |###################|
0018B9r 3                       ;
0018B9r 3                       ;     |------>|  toin (>IN)
0018B9r 3                       ;     |------------------->|  ciblen
0018B9r 3                       ;
0018B9r 3                       ; The input string is stored starting at the address in the Current
0018B9r 3                       ; Input Buffer (CIB), the length of which is in CIBLEN. While searching
0018B9r 3                       ; for the delimiter, TOIN (>IN) points to the where we currently are.
0018B9r 3                       ; Since PARSE does not skip leading delimiters, we assume we are on a
0018B9r 3                       ; useful string if there are any characters at all. As with
0018B9r 3                       ; PARSE-NAME, we must be able to handle strings with a length of
0018B9r 3                       ; 16-bit for EVALUTE, which is a pain on an 8-bit machine.
0018B9r 3                       ; """
0018B9r 3               
0018B9r 3               xt_parse:
0018B9r 3  20 rr rr                     jsr underflow_1
0018BCr 3               
0018BCr 3                               ; If the input buffer is empty, we just return
0018BCr 3  A5 rr                        lda ciblen
0018BEr 3  05 rr                        ora ciblen+1
0018C0r 3  F0 0C                        beq @abort_parse
0018C2r 3               
0018C2r 3                               ; If the pointer >IN is larger or equal to the length of
0018C2r 3                               ; the input buffer (CIBLEN), the line is done. Put
0018C2r 3                               ; differently, we only continue if >IN is smaller than
0018C2r 3                               ; CIBLEN
0018C2r 3  A5 rr                        lda toin+1              ; MSB
0018C4r 3  C5 rr                        cmp ciblen+1
0018C6r 3  90 0E                        bcc @go_parse           ; unsigned comparison
0018C8r 3               
0018C8r 3  A5 rr                        lda toin                ; LSB
0018CAr 3  C5 rr                        cmp ciblen
0018CCr 3  90 08                        bcc @go_parse
0018CEr 3               
0018CEr 3               @abort_parse:
0018CEr 3                               ; Sorry, this line is over
0018CEr 3  CA                           dex
0018CFr 3  CA                           dex
0018D0r 3  74 00                        stz 0,x
0018D2r 3  74 01                        stz 1,x
0018D4r 3               
0018D4r 3  80 7A                        bra @done
0018D6r 3               @go_parse:
0018D6r 3                               ; We actually have work to do. Save the delimiter in
0018D6r 3                               ; tmptos.
0018D6r 3  B5 00                        lda 0,x
0018D8r 3  85 rr                        sta tmptos
0018DAr 3               
0018DAr 3                               ; We can now prepare the Data Stack for the return value
0018DAr 3  CA                           dex
0018DBr 3  CA                           dex
0018DCr 3               
0018DCr 3                               ; tmp1 is CIB+TOIN, the beginning of the current string
0018DCr 3                               ; tmp2 is initially the same as tmp1, then the work index
0018DCr 3                               ; tmp3 is CIB+CIBLEN, one char past the end of the string
0018DCr 3               
0018DCr 3                               ; Calculate the beginning of the string, which is also the
0018DCr 3                               ; address to return
0018DCr 3  A5 rr                        lda cib
0018DEr 3  18                           clc
0018DFr 3  65 rr                        adc toin        ; LSB
0018E1r 3  85 rr                        sta tmp1
0018E3r 3  85 rr                        sta tmp2
0018E5r 3  95 02                        sta 2,x
0018E7r 3               
0018E7r 3  A5 rr                        lda cib+1
0018E9r 3  65 rr                        adc toin+1      ; MSB
0018EBr 3  85 rr                        sta tmp1+1
0018EDr 3  85 rr                        sta tmp2+1
0018EFr 3  95 03                        sta 3,x
0018F1r 3               
0018F1r 3                               ; Calculate the address where the input buffer ends plus 1, so
0018F1r 3                               ; we can compare it with TOIN, which is an index
0018F1r 3  A5 rr                        lda cib
0018F3r 3  18                           clc
0018F4r 3  65 rr                        adc ciblen
0018F6r 3  85 rr                        sta tmp3
0018F8r 3  A5 rr                        lda cib+1
0018FAr 3  65 rr                        adc ciblen+1
0018FCr 3  85 rr                        sta tmp3+1
0018FEr 3               
0018FEr 3                               ; Initialize the offset we use to adjust EOL or found delimiter
0018FEr 3  64 rr                        stz tmptos+1
001900r 3               @loop:
001900r 3                               ; If we are at the end of the string, quit
001900r 3  A5 rr                        lda tmp2
001902r 3  C5 rr                        cmp tmp3
001904r 3  D0 06                        bne @not_empty
001906r 3               
001906r 3  A5 rr                        lda tmp2+1
001908r 3  C5 rr                        cmp tmp3+1
00190Ar 3  F0 1D                        beq @eol
00190Cr 3               @not_empty:
00190Cr 3                               ; We have to do this the hard way. In fact, it's really
00190Cr 3                               ; hard since if we are dealing with a SPACE, the standard
00190Cr 3                               ; wants us to skip all whitespace, not just spaces. Otherwise,
00190Cr 3                               ; Tali would choke on tabs between words. For details, see
00190Cr 3                               ; http://forth-standard.org/standard/file#subsection.11.3.5
00190Cr 3                               ; In theory, we could make this faster by defining a delimiter
00190Cr 3                               ; that is 00 as the sign that we skip all whitespace, thereby
00190Cr 3                               ; avoiding having to test every time. However, somebody,
00190Cr 3                               ; somewhere might want to parse a zero-delimited list. Since
00190Cr 3                               ; any byte value could be chosen for that, we just test for
00190Cr 3                               ; a space every single time for the moment.
00190Cr 3  B2 rr                        lda (tmp2)
00190Er 3               
00190Er 3  A4 rr                        ldy tmptos
001910r 3  C0 20                        cpy #AscSP
001912r 3  D0 07                        bne @not_whitespace
001914r 3               
001914r 3                               ; The delimiter is a space, so we're looking for all
001914r 3                               ; whitespace
001914r 3  20 rr rr                     jsr is_whitespace
001917r 3  90 02                        bcc @not_whitespace
001919r 3  80 0C                        bra @found_delimiter
00191Br 3               
00191Br 3               @not_whitespace:
00191Br 3                               ; The delimiter is not a space, so we're looking for
00191Br 3                               ; whatever it is
00191Br 3  C5 rr                        cmp tmptos
00191Dr 3  F0 08                        beq @found_delimiter
00191Fr 3               
00191Fr 3                               ; Not a delimiter, next character
00191Fr 3  E6 rr                        inc tmp2
001921r 3  D0 DD                        bne @loop
001923r 3  E6 rr                        inc tmp2+1
001925r 3  80 D9                        bra @loop
001927r 3               
001927r 3               @found_delimiter:
001927r 3                               ; Increase the offset: If we've found a delimiter, we want
001927r 3                               ; TOIN to point to the character after it, not the delimiter
001927r 3                               ; itself
001927r 3  E6 rr                        inc tmptos+1
001929r 3               @eol:
001929r 3                               ; The length of the new string is tmp2-tmp1
001929r 3  A5 rr                        lda tmp2
00192Br 3  38                           sec
00192Cr 3  E5 rr                        sbc tmp1
00192Er 3  95 00                        sta 0,x
001930r 3               
001930r 3  A5 rr                        lda tmp2+1
001932r 3  E5 rr                        sbc tmp1+1
001934r 3  95 01                        sta 1,x
001936r 3               
001936r 3                               ; The new offset is tmp2-cib
001936r 3  A5 rr                        lda tmp2
001938r 3  38                           sec
001939r 3  E5 rr                        sbc cib
00193Br 3  85 rr                        sta toin
00193Dr 3  A5 rr                        lda tmp2+1
00193Fr 3  E5 rr                        sbc cib+1
001941r 3  85 rr                        sta toin+1
001943r 3               
001943r 3                               ; Add in the delimiter
001943r 3  A5 rr                        lda toin
001945r 3  18                           clc
001946r 3  65 rr                        adc tmptos+1
001948r 3  85 rr                        sta toin
00194Ar 3  A5 rr                        lda toin+1
00194Cr 3  69 00                        adc #0          ; we only need the carry
00194Er 3  85 rr                        sta toin+1
001950r 3               @done:
001950r 3               z_parse_name:
001950r 3  60           z_parse:        rts
001951r 3               
001951r 3               
001951r 3               
001951r 3               ; ## PICK ( n n u -- n n n ) "Move element u of the stack to TOS"
001951r 3               ; ## "pick"  auto  ANS core ext
001951r 3                       ; """https://forth-standard.org/standard/core/PICK
001951r 3                       ; Take the u-th element out of the stack and put it on TOS,
001951r 3                       ; overwriting the original TOS. 0 PICK is equivalent to DUP, 1 PICK to
001951r 3                       ; OVER. Note that using PICK is considered poor coding form. Also note
001951r 3                       ; that FIG Forth has a different behavior for PICK than ANS Forth.
001951r 3                       ; """
001951r 3               
001951r 3               xt_pick:
001951r 3                               ; Checking for underflow is difficult because it depends on
001951r 3                               ; which element we want to grab. We could probably figure
001951r 3                               ; something out, but it wouldn't work with underflow stripping
001951r 3                               ; Since using PICK is considered poor form anyway, we just
001951r 3                               ; leave it as it is
001951r 3  16 00                        asl 0,x         ; we assume u < 128 (stack is small)
001953r 3  8A                           txa
001954r 3  75 00                        adc 0,x
001956r 3  A8                           tay
001957r 3               
001957r 3  B9 02 00                     lda 0002,y
00195Ar 3  95 00                        sta 0,x
00195Cr 3  B9 03 00                     lda 0003,y
00195Fr 3  95 01                        sta 1,x
001961r 3               
001961r 3  60           z_pick:         rts
001962r 3               
001962r 3               
001962r 3               
001962r 3               ; ## PLUS ( n n -- n ) "Add TOS and NOS"
001962r 3               ; ## "+"  auto  ANS core
001962r 3                       ; """https://forth-standard.org/standard/core/Plus"""
001962r 3               xt_plus:
001962r 3  20 rr rr                     jsr underflow_2
001965r 3               
001965r 3  18                           clc
001966r 3  B5 00                        lda 0,x         ; LSB
001968r 3  75 02                        adc 2,x
00196Ar 3  95 02                        sta 2,x
00196Cr 3               
00196Cr 3  B5 01                        lda 1,x         ; MSB. No CLC, conserve carry bit
00196Er 3  75 03                        adc 3,x
001970r 3  95 03                        sta 3,x
001972r 3               
001972r 3  E8                           inx
001973r 3  E8                           inx
001974r 3               
001974r 3  60           z_plus:         rts
001975r 3               
001975r 3               
001975r 3               ; ## PLUS_STORE ( n addr -- ) "Add number to value at given address"
001975r 3               ; ## "+!"  auto  ANS core
001975r 3                       ; """https://forth-standard.org/standard/core/PlusStore"""
001975r 3               xt_plus_store:
001975r 3  20 rr rr                     jsr underflow_2
001978r 3               
001978r 3                               ; move address to tmp1 so we can work with it
001978r 3  B5 00                        lda 0,x
00197Ar 3  85 rr                        sta tmp1
00197Cr 3  B5 01                        lda 1,x
00197Er 3  85 rr                        sta tmp1+1
001980r 3               
001980r 3  A0 00                        ldy #0          ; LSB
001982r 3  B1 rr                        lda (tmp1),y
001984r 3  18                           clc
001985r 3  75 02                        adc 2,x
001987r 3  91 rr                        sta (tmp1),y
001989r 3               
001989r 3  C8                           iny             ; MSB
00198Ar 3  B1 rr                        lda (tmp1),y
00198Cr 3  75 03                        adc 3,x
00198Er 3  91 rr                        sta (tmp1),y
001990r 3               
001990r 3  E8                           inx
001991r 3  E8                           inx
001992r 3  E8                           inx
001993r 3  E8                           inx
001994r 3               
001994r 3  60           z_plus_store:   rts
001995r 3               
001995r 3               
001995r 3               ; ## POSTPONE ( -- ) "Change IMMEDIATE status (it's complicated)"
001995r 3               ; ## "postpone"  auto   ANS core
001995r 3                       ; """https://forth-standard.org/standard/core/POSTPONE
001995r 3                       ; Add the compilation behavior of a word to a new word at
001995r 3                       ; compile time. If the word that follows it is immediate, include
001995r 3                       ; it so that it will be compiled when the word being defined is
001995r 3                       ; itself used for a new word. Tricky, but very useful.
001995r 3                       ;
001995r 3                       ; Because POSTPONE expects a word (not an xt) in the input stream (not
001995r 3                       ; on the Data Stack). This means we cannot build words with
001995r 3                       ; "jsr xt_postpone, jsr <word>" directly.
001995r 3                       ; """
001995r 3               
001995r 3               xt_postpone:
001995r 3  20 rr rr                     jsr xt_parse_name               ; ( -- addr n )
001998r 3               
001998r 3                               ; if there was no word provided, complain and quit
001998r 3  B5 00                        lda 0,x
00199Ar 3  15 01                        ora 1,x
00199Cr 3  D0 05                        bne @1
00199Er 3               
00199Er 3  A9 05                        lda #err_noname
0019A0r 3  4C rr rr                     jmp error
0019A3r 3               @1:
0019A3r 3  20 rr rr                     jsr xt_find_name                ; ( -- nt | 0 )
0019A6r 3               
0019A6r 3                               ; if word not in Dictionary, complain and quit
0019A6r 3  D0 05                        bne @2
0019A8r 3  A9 05                        lda #err_noname
0019AAr 3  4C rr rr                     jmp error
0019ADr 3               
0019ADr 3               @2:
0019ADr 3                               ; keep a copy of nt for later
0019ADr 3  B5 00                        lda 0,x
0019AFr 3  85 rr                        sta tmp1
0019B1r 3  B5 01                        lda 1,x
0019B3r 3  85 rr                        sta tmp1+1
0019B5r 3               
0019B5r 3                               ; We need the xt instead of the nt
0019B5r 3  20 rr rr                     jsr xt_name_to_int              ; ( nt -- xt )
0019B8r 3               
0019B8r 3                               ; See if this is an immediate word. This is easier
0019B8r 3                               ; with nt than with xt. The status byte of the word
0019B8r 3                               ; is nt+1
0019B8r 3  E6 rr                        inc tmp1
0019BAr 3  D0 02                        bne @3
0019BCr 3  E6 rr                        inc tmp1+1
0019BEr 3               @3:
0019BEr 3  B2 rr                        lda (tmp1)
0019C0r 3  29 04                        and #IM         ; mask all but Intermediate flag
0019C2r 3  F0 05                        beq @not_immediate
0019C4r 3               
0019C4r 3                               ; We're immediate, so instead of executing it right now, we
0019C4r 3                               ; compile it. xt is TOS, so this is easy. The RTS at the end
0019C4r 3                               ; takes us back to the original caller
0019C4r 3  20 rr rr                     jsr xt_compile_comma
0019C7r 3  80 0A                        bra @done
0019C9r 3               
0019C9r 3               @not_immediate:
0019C9r 3                               ; This is not an immediate word, so we enact "deferred
0019C9r 3                               ; compilation" by including ' <NAME> COMPILE, which we do by
0019C9r 3                               ; compiling the run-time routine of LITERAL, the xt itself, and
0019C9r 3                               ; a subroutine jump to COMPILE,
0019C9r 3  20 rr rr                     jsr xt_literal
0019CCr 3               
0019CCr 3                               ; Last, compile COMPILE,
0019CCr 3  A0 rr                        ldy #>xt_compile_comma
0019CEr 3  A9 rr                        lda #<xt_compile_comma
0019D0r 3  20 rr rr                     jsr cmpl_subroutine
0019D3r 3               @done:
0019D3r 3  60           z_postpone:     rts
0019D4r 3               
0019D4r 3               
0019D4r 3               
0019D4r 3               ; ## PREVIOUS ( -- ) "Remove the first wordlist in the search order"
0019D4r 3               ; ## "previous"  auto  ANS search ext
0019D4r 3                       ; """http://forth-standard.org/standard/search/PREVIOUS"""
0019D4r 3               
0019D4r 3               xt_previous:
0019D4r 3  20 rr rr                     jsr xt_get_order
0019D7r 3  20 rr rr                     jsr xt_nip
0019DAr 3  20 rr rr                     jsr xt_one_minus
0019DDr 3  20 rr rr                     jsr xt_set_order
0019E0r 3               
0019E0r 3  60           z_previous:     rts
0019E1r 3               
0019E1r 3               
0019E1r 3               
0019E1r 3               ; ## QUESTION ( addr -- ) "Print content of a variable"
0019E1r 3               ; ## "?"  tested  ANS tools
0019E1r 3                       ; """https://forth-standard.org/standard/tools/q
0019E1r 3                       ;
0019E1r 3                       ; Only used interactively. Since humans are so slow, we
0019E1r 3                       ; save size and just go for the subroutine jumps
0019E1r 3                       ; """
0019E1r 3               xt_question:
0019E1r 3                               ; FETCH takes care of underflow check
0019E1r 3  20 rr rr                     jsr xt_fetch
0019E4r 3  20 rr rr                     jsr xt_dot
0019E7r 3               
0019E7r 3  60           z_question:     rts
0019E8r 3               
0019E8r 3               
0019E8r 3               ; ## QUESTION_DUP ( n -- 0 | n n ) "Duplicate TOS non-zero"
0019E8r 3               ; ## "?dup"  auto  ANS core
0019E8r 3                       ; """https://forth-standard.org/standard/core/qDUP"""
0019E8r 3               
0019E8r 3               xt_question_dup:
0019E8r 3  20 rr rr                     jsr underflow_1
0019EBr 3               
0019EBr 3                               ; Check if TOS is zero
0019EBr 3  B5 00                        lda 0,x
0019EDr 3  15 01                        ora 1,x
0019EFr 3  F0 0A                        beq @done
0019F1r 3               
0019F1r 3                               ; not zero, duplicate
0019F1r 3  CA                           dex
0019F2r 3  CA                           dex
0019F3r 3  B5 02                        lda 2,x
0019F5r 3  95 00                        sta 0,x
0019F7r 3  B5 03                        lda 3,x
0019F9r 3  95 01                        sta 1,x
0019FBr 3               @done:
0019FBr 3  60           z_question_dup: rts
0019FCr 3               
0019FCr 3               
0019FCr 3               
0019FCr 3               ; ## R_FETCH ( -- n ) "Get copy of top of Return Stack"
0019FCr 3               ; ## "r@"  auto  ANS core
0019FCr 3                       ; """https://forth-standard.org/standard/core/RFetch
0019FCr 3                       ; This word is Compile Only in Tali Forth, though Gforth has it
0019FCr 3                       ; work normally as well
0019FCr 3                       ;
0019FCr 3                       ; An alternative way to write this word
0019FCr 3                       ; would be to access the elements on the stack directly like 2R@
0019FCr 3                       ; does, these versions should be compared at some point.
0019FCr 3                       ; """
0019FCr 3               xt_r_fetch:
0019FCr 3                               ; get the return address
0019FCr 3  7A                           ply             ; LSB
0019FDr 3  84 rr                        sty tmp1
0019FFr 3  7A                           ply             ; MSB
001A00r 3               
001A00r 3                               ; --- CUT FOR NATIVE COMPILE ---
001A00r 3               
001A00r 3                               ; get the actual top of Return Stack
001A00r 3  CA                           dex
001A01r 3  CA                           dex
001A02r 3               
001A02r 3  68                           pla             ; LSB
001A03r 3  95 00                        sta 0,x
001A05r 3  68                           pla             ; MSB
001A06r 3  95 01                        sta 1,x
001A08r 3               
001A08r 3                               ; now we have to put that value back
001A08r 3  48                           pha
001A09r 3  B5 00                        lda 0,x
001A0Br 3  48                           pha
001A0Cr 3               
001A0Cr 3                               ; --- CUT FOR NATIVE COMPILE ---
001A0Cr 3               
001A0Cr 3                               ; restore return value
001A0Cr 3  5A                           phy             ; MSB
001A0Dr 3  A4 rr                        ldy tmp1
001A0Fr 3  5A                           phy             ; LSB
001A10r 3               
001A10r 3  60           z_r_fetch:      rts
001A11r 3               
001A11r 3               
001A11r 3               ; ## R_FROM ( -- n )(R: n --) "Move top of Return Stack to TOS"
001A11r 3               ; ## "r>"  auto  ANS core
001A11r 3                       ; """https://forth-standard.org/standard/core/Rfrom
001A11r 3                       ; Move Top of Return Stack to Top of Data Stack.
001A11r 3                       ;
001A11r 3                       ; We have to move
001A11r 3                       ; the RTS address out of the way first. This word is handled
001A11r 3                       ; differently for native and and subroutine compilation, see COMPILE,
001A11r 3                       ; This is a compile-only word
001A11r 3                       ; """
001A11r 3               
001A11r 3               xt_r_from:
001A11r 3                               ; Rescue the address of the return jump that is currently
001A11r 3                               ; on top of the Return Stack. If this word is natively
001A11r 3                               ; compiled, this is a total waste of time
001A11r 3  68                           pla             ; LSB
001A12r 3  85 rr                        sta tmptos
001A14r 3  7A                           ply             ; MSB
001A15r 3               
001A15r 3                               ; --- CUT FOR NATIVE CODING ---
001A15r 3               
001A15r 3  CA                           dex
001A16r 3  CA                           dex
001A17r 3               
001A17r 3                               ; now we can access the actual data
001A17r 3               
001A17r 3  68                           pla             ; LSB
001A18r 3  95 00                        sta 0,x
001A1Ar 3  68                           pla             ; MSB
001A1Br 3  95 01                        sta 1,x
001A1Dr 3               
001A1Dr 3                               ; --- CUT FOR NATIVE CODING ---
001A1Dr 3               
001A1Dr 3                               ; restore the return address
001A1Dr 3  5A                           phy             ; MSB
001A1Er 3  A5 rr                        lda tmptos
001A20r 3  48                           pha             ; LSB
001A21r 3               
001A21r 3  60           z_r_from:       rts
001A22r 3               
001A22r 3               
001A22r 3               ; ## R_TO_INPUT ( -- ) ( R: n n n n -- ) "Restore input state from Return Stack"
001A22r 3               ; ## "r>input"  tested  Tali Forth
001A22r 3                       ; """Restore the current input state as defined by insrc, cib, ciblen,
001A22r 3                       ; and toin from the Return Stack.
001A22r 3                       ;
001A22r 3                       ; See INPUT_TO_R for a discussion of this word. Uses tmp1
001A22r 3                       ; """
001A22r 3               
001A22r 3               xt_r_to_input:
001A22r 3               
001A22r 3                               ; We arrive here with the return address on the top of the
001A22r 3                               ; 65c02's stack. We need to move it out of the way first
001A22r 3  68                           pla
001A23r 3  85 rr                        sta tmp1
001A25r 3  68                           pla
001A26r 3  85 rr                        sta tmp1+1
001A28r 3               
001A28r 3                               ; This assumes that insrc is the first of eight bytes and
001A28r 3                               ; toin+1 the last in the sequence we want to save from the Zero
001A28r 3                               ; Page. Since we went in reverse order, insrc is now on the top
001A28r 3                               ; of the Return Stack.
001A28r 3  A0 00                        ldy #0
001A2Ar 3               @loop:
001A2Ar 3  68                           pla
001A2Br 3  99 rr rr                     sta insrc,y
001A2Er 3  C8                           iny
001A2Fr 3  C0 08                        cpy #8
001A31r 3  D0 F7                        bne @loop
001A33r 3               
001A33r 3                               ; Restore address for return jump
001A33r 3  A5 rr                        lda tmp1+1
001A35r 3  48                           pha
001A36r 3  A5 rr                        lda tmp1
001A38r 3  48                           pha
001A39r 3               
001A39r 3  60           z_r_to_input: 	rts
001A3Ar 3               
001A3Ar 3               
001A3Ar 3               
001A3Ar 3               ; ## RECURSE ( -- ) "Copy recursive call to word being defined"
001A3Ar 3               ; ## "recurse"  auto  ANS core
001A3Ar 3                       ; """https://forth-standard.org/standard/core/RECURSE
001A3Ar 3                       ;
001A3Ar 3                       ; This word may not be natively compiled
001A3Ar 3                       ; """
001A3Ar 3               
001A3Ar 3               xt_recurse:
001A3Ar 3                               ; The whole routine amounts to compiling a reference to
001A3Ar 3                               ; the word that is being compiled. First, we save the JSR
001A3Ar 3                               ; instruction
001A3Ar 3  A0 00                        ldy #0
001A3Cr 3               
001A3Cr 3  A9 20                        lda #$20        ; opcode for JSR
001A3Er 3  91 rr                        sta (cp),y
001A40r 3  C8                           iny
001A41r 3               
001A41r 3                               ; Next, we save the LSB and MSB of the xt of the word
001A41r 3                               ; we are currently working on. We first need to see if
001A41r 3                               ; WORKWORD has the nt (: started the word) or the
001A41r 3                               ; xt (:NONAME started the word). Bit 6 in status tells us.
001A41r 3  24 rr                        bit status
001A43r 3  70 0C                        bvs @nt_in_workword
001A45r 3               
001A45r 3                               ; This is a special :NONAME word. Just copy the xt
001A45r 3                               ; from WORKWORD into the dictionary.
001A45r 3  A5 rr                        lda workword
001A47r 3  91 rr                        sta (cp),y
001A49r 3  C8                           iny
001A4Ar 3  A5 rr                        lda workword+1
001A4Cr 3  91 rr                        sta (cp),y
001A4Er 3  C8                           iny
001A4Fr 3  80 1B                        bra @update_cp
001A51r 3               
001A51r 3               @nt_in_workword:
001A51r 3                               ; This is a regular : word, so the xt is four bytes down
001A51r 3                               ; from the nt which we saved in WORKWORD. We could probably
001A51r 3                               ; use NAME>INT here but this is going to be faster, and
001A51r 3                               ; fast counts with recursion
001A51r 3  A5 rr                        lda workword            ; LSB
001A53r 3  18                           clc
001A54r 3  69 04                        adc #4
001A56r 3  85 rr                        sta tmp1
001A58r 3  A5 rr                        lda workword+1          ; MSB
001A5Ar 3  69 00                        adc #0
001A5Cr 3  85 rr                        sta tmp1+1
001A5Er 3               
001A5Er 3  B2 rr                        lda (tmp1)
001A60r 3  91 rr                        sta (cp),y
001A62r 3  5A                           phy
001A63r 3  A0 01                        ldy #1
001A65r 3  B1 rr                        lda (tmp1),y
001A67r 3  7A                           ply
001A68r 3  C8                           iny
001A69r 3  91 rr                        sta (cp),y
001A6Br 3  C8                           iny
001A6Cr 3               
001A6Cr 3               @update_cp:
001A6Cr 3  98                           tya
001A6Dr 3  18                           clc
001A6Er 3  65 rr                        adc cp
001A70r 3  85 rr                        sta cp
001A72r 3  90 02                        bcc @done
001A74r 3  E6 rr                        inc cp+1
001A76r 3               @done:
001A76r 3  60           z_recurse:      rts
001A77r 3               
001A77r 3               
001A77r 3               
001A77r 3               ; ## REFILL ( -- f ) "Refill the input buffer"
001A77r 3               ; ## "refill"  tested  ANS core ext
001A77r 3                       ; """https://forth-standard.org/standard/core/REFILL
001A77r 3                       ; Attempt to fill the input buffer from the input source, returning
001A77r 3                       ; a true flag if successful. When the input source is the user input
001A77r 3                       ; device, attempt to receive input into the terminal input buffer. If
001A77r 3                       ; successful, make the result the input buffer, set >IN to zero, and
001A77r 3                       ; return true. Receipt of a line containing no characters is considered
001A77r 3                       ; successful. If there is no input available from the current input
001A77r 3                       ; source, return false. When the input source is a string from EVALUATE,
001A77r 3                       ; return false and perform no other action." See
001A77r 3                       ; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/The-Input-Stream.html
001A77r 3                       ; and Conklin & Rather p. 156. Note we don't have to care about blocks
001A77r 3                       ; because REFILL is never used on blocks - Tali is able to evaluate the
001A77r 3                       ; entire block as a 1024 byte string.
001A77r 3                       ; """"
001A77r 3               
001A77r 3               xt_refill:
001A77r 3                               ; Get input source from SOURCE-ID. This is an
001A77r 3                               ; optimized version of a subroutine jump to SOURCE-ID
001A77r 3  A5 rr                        lda insrc               ; cheat: We only check LSB
001A79r 3  D0 2D                        bne @src_not_kbd
001A7Br 3               
001A7Br 3                               ; SOURCE-ID of zero means we're getting stuff from the keyboard
001A7Br 3                               ; with ACCEPT, which wants the address of the current input
001A7Br 3                               ; buffer NOS and the max number of characters to accept TOS
001A7Br 3  CA                           dex
001A7Cr 3  CA                           dex
001A7Dr 3  CA                           dex
001A7Er 3  CA                           dex
001A7Fr 3               
001A7Fr 3  A5 rr                        lda cib                 ; address of CIB is NOS
001A81r 3  95 02                        sta 2,x
001A83r 3  A5 rr                        lda cib+1
001A85r 3  95 03                        sta 3,x
001A87r 3               
001A87r 3  64 rr                        stz ciblen              ; go in with empty buffer
001A89r 3  64 rr                        stz ciblen+1
001A8Br 3               
001A8Br 3  A9 FF                        lda #bsize              ; max number of chars is TOS
001A8Dr 3  95 00                        sta 0,x
001A8Fr 3  74 01                        stz 1,x                 ; cheat: We only accept max 255
001A91r 3               
001A91r 3  20 rr rr                     jsr xt_accept           ; ( addr n1 -- n2)
001A94r 3               
001A94r 3                               ; ACCEPT returns the number of characters accepted, which
001A94r 3                               ; belong in CIBLEN
001A94r 3  B5 00                        lda 0,x
001A96r 3  85 rr                        sta ciblen
001A98r 3  B5 01                        lda 1,x
001A9Ar 3  85 rr                        sta ciblen+1            ; though we only accept 255 chars
001A9Cr 3               
001A9Cr 3                               ; make >IN point to beginning of buffer
001A9Cr 3  64 rr                        stz toin
001A9Er 3  64 rr                        stz toin+1
001AA0r 3               
001AA0r 3  A9 FF                        lda #$FF                ; overwrite with TRUE flag
001AA2r 3  95 00                        sta 0,x
001AA4r 3  95 01                        sta 1,x
001AA6r 3               
001AA6r 3  80 10                        bra @done
001AA8r 3               
001AA8r 3               @src_not_kbd:
001AA8r 3                               ; If SOURCE-ID doesn't return a zero, it must be a string in
001AA8r 3                               ; memory or a file (remember, no blocks in this version).
001AA8r 3                               ; If source is a string, we were given the flag -1 ($FFFF)
001AA8r 3  1A                           inc
001AA9r 3  D0 08                        bne @src_not_string
001AABr 3               
001AABr 3                               ; Simply return FALSE flag as per specification
001AABr 3  CA                           dex
001AACr 3  CA                           dex
001AADr 3  74 00                        stz 0,x
001AAFr 3  74 01                        stz 1,x
001AB1r 3               
001AB1r 3  80 05                        bra z_refill
001AB3r 3               
001AB3r 3               @src_not_string:
001AB3r 3                               ; Since we don't have blocks, this must mean that we are trying
001AB3r 3                               ; to read from a file. However, we don't have files yet, so we
001AB3r 3                               ; report an error and jump to ABORT.
001AB3r 3  A9 01                        lda #err_badsource
001AB5r 3  4C rr rr                     jmp error
001AB8r 3               @done:
001AB8r 3  60           z_refill:       rts
001AB9r 3               
001AB9r 3               
001AB9r 3               
001AB9r 3               ; ## REPEAT (C: orig dest -- ) ( -- ) "Loop flow control"
001AB9r 3               ; ## "repeat"  auto  ANS core
001AB9r 3                       ; """http://forth-standard.org/standard/core/REPEAT"""
001AB9r 3               
001AB9r 3               xt_repeat:
001AB9r 3                               ; Run again first
001AB9r 3  20 rr rr                     jsr xt_again
001ABCr 3               
001ABCr 3                               ; Stuff HERE in for the branch address
001ABCr 3                               ; to get out of the loop
001ABCr 3  20 rr rr                     jsr xt_here
001ABFr 3  20 rr rr                     jsr xt_swap
001AC2r 3  20 rr rr                     jsr xt_store
001AC5r 3               
001AC5r 3  60           z_repeat:       rts
001AC6r 3               
001AC6r 3               
001AC6r 3               
001AC6r 3               ; ## RIGHT_BRACKET ( -- ) "Enter the compile state"
001AC6r 3               ; ## "]"  auto  ANS core
001AC6r 3                       ; """https://forth-standard.org/standard/right-bracket
001AC6r 3                       ; This is an immediate word.
001AC6r 3                       ; """
001AC6r 3               xt_right_bracket:
001AC6r 3  A9 FF                        lda #$FF
001AC8r 3  85 rr                        sta state
001ACAr 3  85 rr                        sta state+1
001ACCr 3               z_right_bracket:
001ACCr 3  60                           rts
001ACDr 3               
001ACDr 3               
001ACDr 3               ; ## ROOT_WORDLIST ( -- u ) "WID for the Root (minimal) wordlist"
001ACDr 3               ; ## "root-wordlist"  tested  Tali Editor
001ACDr 3               xt_root_wordlist:
001ACDr 3  CA                           dex             ; The WID for the Root wordlist is 3.
001ACEr 3  CA                           dex
001ACFr 3  A9 03                        lda #3
001AD1r 3  95 00                        sta 0,x
001AD3r 3  74 01                        stz 1,x
001AD5r 3               
001AD5r 3               z_root_wordlist:
001AD5r 3  60                           rts
001AD6r 3               
001AD6r 3               
001AD6r 3               ; ## ROT ( a b c -- b c a ) "Rotate first three stack entries downwards"
001AD6r 3               ; ## "rot"  auto  ANS core
001AD6r 3                       ; """https://forth-standard.org/standard/core/ROT
001AD6r 3                       ; Remember "R for 'Revolution'" - the bottom entry comes out
001AD6r 3                       ; on top!
001AD6r 3                       ; """
001AD6r 3               
001AD6r 3               xt_rot:
001AD6r 3  20 rr rr                     jsr underflow_3
001AD9r 3               
001AD9r 3  B4 05                        ldy 5,x         ; MSB first
001ADBr 3  B5 03                        lda 3,x
001ADDr 3  95 05                        sta 5,x
001ADFr 3  B5 01                        lda 1,x
001AE1r 3  95 03                        sta 3,x
001AE3r 3  94 01                        sty 1,x
001AE5r 3               
001AE5r 3  B4 04                        ldy 4,x         ; LSB next
001AE7r 3  B5 02                        lda 2,x
001AE9r 3  95 04                        sta 4,x
001AEBr 3  B5 00                        lda 0,x
001AEDr 3  95 02                        sta 2,x
001AEFr 3  94 00                        sty 0,x
001AF1r 3               
001AF1r 3  60           z_rot:          rts
001AF2r 3               
001AF2r 3               
001AF2r 3               
001AF2r 3               ; ## RSHIFT ( x u -- x ) "Shift TOS to the right"
001AF2r 3               ; ## "rshift"  auto  ANS core
001AF2r 3                       ; """https://forth-standard.org/standard/core/RSHIFT"""
001AF2r 3               xt_rshift:
001AF2r 3  20 rr rr                     jsr underflow_2
001AF5r 3               
001AF5r 3                               ; We shift maximal by 16 bits, mask everything else
001AF5r 3  B5 00                        lda 0,x
001AF7r 3  29 0F                        and #%00001111
001AF9r 3  F0 08                        beq @done               ; if 0 shifts, quit
001AFBr 3               
001AFBr 3  A8                           tay
001AFCr 3               @loop:
001AFCr 3  56 03                        lsr 3,x
001AFEr 3  76 02                        ror 2,x
001B00r 3  88                           dey
001B01r 3  D0 F9                        bne @loop
001B03r 3               @done:
001B03r 3  E8                           inx
001B04r 3  E8                           inx
001B05r 3               
001B05r 3  60           z_rshift:       rts
001B06r 3               
001B06r 3               
001B06r 3               ; ## S_BACKSLASH_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
001B06r 3               ; ## "s\""  auto  ANS core
001B06r 3                       ; """https://forth-standard.org/standard/core/Seq
001B06r 3                       ; Store address and length of string given, returning ( addr u ).
001B06r 3                       ; ANS core claims this is compile-only, but the file set expands it
001B06r 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
001B06r 3                       ; are evil. We follow general usage. This is just like S" except
001B06r 3                       ; that it allows for some special escaped characters.
001B06r 3                       ; """
001B06r 3               
001B06r 3               xt_s_backslash_quote:
001B06r 3                               ; tmp2 will be used to determine if we are handling
001B06r 3                               ; escaped characters or not. In this case, we are,
001B06r 3                               ; so set it to $FF (the upper byte will be used to
001B06r 3                               ; determine if we just had a \ and the next character
001B06r 3                               ; needs to be modifed as an escaped character).
001B06r 3  A9 FF                        lda #$FF
001B08r 3  85 rr                        sta tmp2
001B0Ar 3  64 rr                        stz tmp2+1
001B0Cr 3               
001B0Cr 3                               ; Now that the flag is set, jump into s_quote to process
001B0Cr 3                               ; the string.
001B0Cr 3  20 rr rr                     jsr s_quote_start
001B0Fr 3               @done:
001B0Fr 3               z_s_backslash_quote:
001B0Fr 3  60                           rts
001B10r 3               
001B10r 3               
001B10r 3               ; This is a helper function for s_backslash_quote to convert a character
001B10r 3               ; from ASCII to the corresponding hex value, eg 'F'->15
001B10r 3               convert_hex_value:
001B10r 3               
001B10r 3  C9 41                cmp #'A'
001B12r 3  90 07                bcc @digit
001B14r 3               
001B14r 3                       ; It's A-F
001B14r 3  29 DF                and #$DF                ; Make it uppercase.
001B16r 3  38                   sec
001B17r 3  E9 37                sbc #'7'                 ; gives value 10 for 'A'
001B19r 3  80 03                bra @done
001B1Br 3               
001B1Br 3               @digit:
001B1Br 3                       ; It's 0-9
001B1Br 3  38                   sec
001B1Cr 3  E9 30                sbc #'0'
001B1Er 3               
001B1Er 3               @done:
001B1Er 3  60                   rts
001B1Fr 3               
001B1Fr 3               
001B1Fr 3               
001B1Fr 3               ; ## SEARCH_WORDLIST ( caddr u wid -- 0 | xt 1 | xt -1) "Search for a word in a wordlist"
001B1Fr 3               ; ## "search-wordlist" auto ANS search
001B1Fr 3                       ; """https://forth-standard.org/standard/search/SEARCH_WORDLIST"""
001B1Fr 3               
001B1Fr 3               xt_search_wordlist:
001B1Fr 3  20 rr rr                     jsr underflow_3
001B22r 3               
001B22r 3                               ; Set up tmp1 with the wordlist indicated by wid
001B22r 3                               ; on the stack. Start by putting the base address
001B22r 3                               ; of the wordlists in tmp2.
001B22r 3  A5 rr                        lda up
001B24r 3  18                           clc
001B25r 3  69 06                        adc #wordlists_offset
001B27r 3  85 rr                        sta tmp2
001B29r 3  A5 rr                        lda up+1
001B2Br 3  69 00                        adc #0          ; Adding carry
001B2Dr 3  85 rr                        sta tmp2+1
001B2Fr 3               
001B2Fr 3                               ; Add the wid (in cells) to the base address.
001B2Fr 3  B5 00                        lda 0,x
001B31r 3  0A                           asl             ; Convert wid to offset in cells (x2)
001B32r 3  65 rr                        adc tmp2
001B34r 3  85 rr                        sta tmp2
001B36r 3  90 02                        bcc @1
001B38r 3  E6 rr                        inc tmp2+1      ; Propagate carry if needed.
001B3Ar 3               
001B3Ar 3                               ; tmp2 now holds the address of the dictionary pointer
001B3Ar 3                               ; for the given wordlist.
001B3Ar 3               @1:
001B3Ar 3                               ; Remove the wid from the stack.
001B3Ar 3  E8                           inx
001B3Br 3  E8                           inx
001B3Cr 3               
001B3Cr 3                               ; check for special case of an empty string (length zero)
001B3Cr 3  B5 00                        lda 0,x
001B3Er 3  15 01                        ora 1,x
001B40r 3  D0 03                        bne @check_wordlist
001B42r 3  4C rr rr                     jmp @done
001B45r 3               
001B45r 3               @check_wordlist:
001B45r 3                               ; Check for special case of empty wordlist
001B45r 3                               ; (dictionary pointer, in tmp2, is 0)
001B45r 3  A5 rr                        lda tmp2
001B47r 3  05 rr                        ora tmp2+1
001B49r 3  D0 03                        bne @have_string
001B4Br 3  4C rr rr                     jmp @done
001B4Er 3               
001B4Er 3               @have_string:
001B4Er 3                               ; set up first loop iteration
001B4Er 3  B2 rr                        lda (tmp2)              ; nt of first word in Dictionary
001B50r 3  85 rr                        sta tmp1
001B52r 3               
001B52r 3  E6 rr                        inc tmp2                ; Move to the upper byte
001B54r 3  D0 02                        bne @2
001B56r 3  E6 rr                        inc tmp2+1
001B58r 3               @2:
001B58r 3  B2 rr                        lda (tmp2)
001B5Ar 3  85 rr                        sta tmp1+1
001B5Cr 3               
001B5Cr 3                               ; Reuse tmp2 to hold the address of the mystery string.
001B5Cr 3  B5 02                        lda 2,x                 ; Address of mystery string
001B5Er 3  85 rr                        sta tmp2
001B60r 3  B5 03                        lda 3,x
001B62r 3  85 rr                        sta tmp2+1
001B64r 3               
001B64r 3               @loop:
001B64r 3                               ; first quick test: Are strings the same length?
001B64r 3  B2 rr                        lda (tmp1)
001B66r 3  D5 00                        cmp 0,x
001B68r 3  D0 7B                        bne @next_entry
001B6Ar 3               
001B6Ar 3               @compare_string:
001B6Ar 3                               ; are the same length, so we now have to compare each
001B6Ar 3                               ; character
001B6Ar 3               
001B6Ar 3                               ; second quick test: Is the first character the same?
001B6Ar 3  B2 rr                        lda (tmp2)      ; first character of mystery string
001B6Cr 3               
001B6Cr 3                               ; Lowercase the incoming charcter.
001B6Cr 3  C9 5B                        cmp #$5B        ; ASCII '[' (one past Z)
001B6Er 3  B0 07                        bcs @compare_first
001B70r 3  C9 41                        cmp #$41        ; ASCII 'A'
001B72r 3  90 03                        bcc @compare_first
001B74r 3               
001B74r 3                               ; An uppercase letter has been located.  Make it
001B74r 3                               ; lowercase.
001B74r 3  18                           clc
001B75r 3  69 20                        adc #$20
001B77r 3               
001B77r 3               @compare_first:
001B77r 3  A0 08                        ldy #8          ; Offset in nt to name
001B79r 3  D1 rr                        cmp (tmp1),y    ; first character of current word
001B7Br 3  D0 68                        bne @next_entry
001B7Dr 3               
001B7Dr 3                               ; string length are the same and the first character is the
001B7Dr 3                               ; same. If the length of the string is 1, we're already done
001B7Dr 3  B5 00                        lda 0,x
001B7Fr 3  3A                           dec
001B80r 3  F0 2C                        beq @success
001B82r 3               
001B82r 3                               ; No such luck: The strings are the same length and the first
001B82r 3                               ; char is the same, but the word is more than one char long.
001B82r 3                               ; So we suck it up and compare every single character. We go
001B82r 3                               ; from back to front, because words like CELLS and CELL+ would
001B82r 3                               ; take longer otherwise. We can also shorten the loop by one
001B82r 3                               ; because we've already compared the first char.
001B82r 3               
001B82r 3                               ; The string of the word we're testing against is 8 bytes down
001B82r 3  A5 rr                        lda tmp1
001B84r 3  48                           pha             ; Preserve tmp1 on the return stack.
001B85r 3  18                           clc
001B86r 3  69 08                        adc #8
001B88r 3  85 rr                        sta tmp1        ; Reusing tmp1 temporarily for string check.
001B8Ar 3  A5 rr                        lda tmp1+1
001B8Cr 3  48                           pha             ; Preserve tmp1+1 on the return stack.
001B8Dr 3  69 00                        adc #0          ; we only need the carry
001B8Fr 3  85 rr                        sta tmp1+1
001B91r 3               
001B91r 3  B4 00                        ldy 0,x         ; index is length of string minus 1
001B93r 3  88                           dey
001B94r 3               
001B94r 3               @string_loop:
001B94r 3  B1 rr                        lda (tmp2),y    ; last char of mystery string
001B96r 3               
001B96r 3                               ; Lowercase the incoming charcter.
001B96r 3  C9 5B                        cmp #$5B         ; ASCII '[' (one past Z)
001B98r 3  B0 07                        bcs @check_char
001B9Ar 3  C9 41                        cmp #$41        ; ASCII 'A'
001B9Cr 3  90 03                        bcc @check_char
001B9Er 3               
001B9Er 3                               ; An uppercase letter has been located.  Make it
001B9Er 3                               ; lowercase.
001B9Er 3  18                           clc
001B9Fr 3  69 20                        adc #$20
001BA1r 3               @check_char:
001BA1r 3  D1 rr                        cmp (tmp1),y    ; last char of word we're testing against
001BA3r 3  D0 3A                        bne @next_entry_tmp1
001BA5r 3               
001BA5r 3  88                           dey
001BA6r 3  D0 EC                        bne @string_loop
001BA8r 3               
001BA8r 3               @success_tmp1:
001BA8r 3  68                           pla             ; Restore tmp1 from the return stack.
001BA9r 3  85 rr                        sta tmp1+1
001BABr 3  68                           pla
001BACr 3  85 rr                        sta tmp1
001BAEr 3               
001BAEr 3               @success:
001BAEr 3                               ; The strings match. Drop the count and put correct nt TOS
001BAEr 3  E8                           inx
001BAFr 3  E8                           inx
001BB0r 3  A5 rr                        lda tmp1
001BB2r 3  95 00                        sta 0,x
001BB4r 3  A5 rr                        lda tmp1+1
001BB6r 3  95 01                        sta 1,x
001BB8r 3               
001BB8r 3                               ; Change the nt into an xt, but save a copy of the nt
001BB8r 3                               ; to look up whether the word is immediate or not.
001BB8r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001BBBr 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001BBEr 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001BC1r 3               
001BC1r 3  A0 00                        ldy #0                  ; Prepare flag
001BC3r 3               
001BC3r 3                               ; The flags are in the second byte of the header
001BC3r 3  F6 00                        inc 0,x
001BC5r 3  D0 02                        bne @3
001BC7r 3  F6 01                        inc 1,x                 ; ( xt nt+1 )
001BC9r 3               @3:
001BC9r 3  A1 00                        lda (0,x)               ; ( xt char )
001BCBr 3  29 04                        and #IM
001BCDr 3  D0 08                        bne @immediate          ; bit set, we're immediate
001BCFr 3               
001BCFr 3  A9 FF                        lda #$FF                ; We're not immediate, return -1
001BD1r 3  95 00                        sta 0,x
001BD3r 3  95 01                        sta 1,x
001BD5r 3  80 28                        bra @done_nodrop
001BD7r 3               
001BD7r 3               @immediate:
001BD7r 3  A9 01                        lda #1                  ; We're immediate, return 1
001BD9r 3  95 00                        sta 0,x
001BDBr 3  74 01                        stz 1,x
001BDDr 3               
001BDDr 3  80 20                        bra @done_nodrop
001BDFr 3               
001BDFr 3               @next_entry_tmp1:
001BDFr 3  68                           pla             ; Restore tmp1 from the return stack.
001BE0r 3  85 rr                        sta tmp1+1
001BE2r 3  68                           pla
001BE3r 3  85 rr                        sta tmp1
001BE5r 3               @next_entry:
001BE5r 3                               ; Not the same, so we get the next word. Next header
001BE5r 3                               ; address is two bytes down
001BE5r 3  A0 02                        ldy #2
001BE7r 3  B1 rr                        lda (tmp1),y
001BE9r 3  48                           pha
001BEAr 3  C8                           iny
001BEBr 3  B1 rr                        lda (tmp1),y
001BEDr 3  85 rr                        sta tmp1+1
001BEFr 3  68                           pla
001BF0r 3  85 rr                        sta tmp1
001BF2r 3               
001BF2r 3                               ; If we got a zero, we've walked the whole Dictionary and
001BF2r 3                               ; return as a failure, otherwise try again
001BF2r 3  05 rr                        ora tmp1+1
001BF4r 3  F0 03                        beq @fail_done
001BF6r 3  4C rr rr                     jmp @loop
001BF9r 3               
001BF9r 3               @fail_done:
001BF9r 3  74 02                        stz 2,x         ; failure flag
001BFBr 3  74 03                        stz 3,x
001BFDr 3               @done:
001BFDr 3  E8                           inx
001BFEr 3  E8                           inx
001BFFr 3               @done_nodrop:
001BFFr 3               z_search_wordlist:
001BFFr 3  60                           rts
001C00r 3               
001C00r 3               
001C00r 3               
001C00r 3               ; ## SEE ( "name" -- ) "Print information about a Forth word"
001C00r 3               ; ## "see" tested  ANS tools
001C00r 3                       ; """https://forth-standard.org/standard/tools/SEE
001C00r 3                       ; SEE takes the name of a word and prints its name token (nt),
001C00r 3                       ; execution token (xt), size in bytes, flags used, and then dumps the
001C00r 3                       ; code and disassembles it.
001C00r 3                       ; """
001C00r 3               
001C00r 3               xt_see:
001C00r 3  20 rr rr                     jsr xt_parse_name       ; ( addr u )
001C03r 3  20 rr rr                     jsr xt_find_name        ; ( nt | 0 )
001C06r 3               
001C06r 3                               ; If we got back a zero we don't know that word and so we quit
001C06r 3                               ; with an error
001C06r 3  B5 00                        lda 0,x
001C08r 3  15 01                        ora 1,x
001C0Ar 3  D0 05                        bne @1
001C0Cr 3               
001C0Cr 3  A9 05                        lda #err_noname
001C0Er 3  4C rr rr                     jmp error
001C11r 3               @1:
001C11r 3  20 rr rr                     jsr xt_cr
001C14r 3               
001C14r 3                               ; We have a legal word, so let's get serious. Save the current
001C14r 3                               ; number base and use hexadecimal instead.
001C14r 3  A5 rr                        lda base
001C16r 3  48                           pha
001C17r 3  20 rr rr                     jsr xt_hex
001C1Ar 3               
001C1Ar 3  A9 0A                        lda #str_see_nt
001C1Cr 3  20 rr rr                     jsr print_string_no_lf
001C1Fr 3               
001C1Fr 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001C22r 3  20 rr rr                     jsr xt_u_dot
001C25r 3  20 rr rr                     jsr xt_space            ; ( nt )
001C28r 3               
001C28r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
001C2Br 3  20 rr rr                     jsr xt_name_to_int      ; ( nt xt )
001C2Er 3               
001C2Er 3  A9 0B                        lda #str_see_xt
001C30r 3  20 rr rr                     jsr print_string_no_lf
001C33r 3               
001C33r 3  20 rr rr                     jsr xt_dup              ; ( nt xt xt )
001C36r 3  20 rr rr                     jsr xt_u_dot
001C39r 3  20 rr rr                     jsr xt_cr               ; ( nt xt )
001C3Cr 3               
001C3Cr 3                               ; We print letters for flags and then later follow it with 1 or
001C3Cr 3                               ; 0 to mark if which flag is set
001C3Cr 3  A9 09                        lda #str_see_flags
001C3Er 3  20 rr rr                     jsr print_string_no_lf
001C41r 3               
001C41r 3  20 rr rr                     jsr xt_over             ; ( nt xt nt )
001C44r 3  20 rr rr                     jsr xt_one_plus         ; ( nt xt nt+1 )
001C47r 3  20 rr rr                     jsr xt_fetch            ; ( nt xt flags )
001C4Ar 3               
001C4Ar 3  B5 00                        lda 0,x
001C4Cr 3               
001C4Cr 3                               ; This is crude, but for the moment it is good enough
001C4Cr 3  A0 06                        ldy #6                  ; Not all bits are used
001C4Er 3               @flag_loop:
001C4Er 3  48                           pha
001C4Fr 3  29 01                        and #%00000001
001C51r 3  18                           clc
001C52r 3  69 30                        adc #$30                ; ASCII "0"
001C54r 3  20 rr rr                     jsr emit_a
001C57r 3  20 rr rr                     jsr xt_space
001C5Ar 3               
001C5Ar 3  68                           pla
001C5Br 3  6A                           ror                     ; Next flag
001C5Cr 3               
001C5Cr 3  88                           dey
001C5Dr 3  D0 EF                        bne @flag_loop
001C5Fr 3               
001C5Fr 3  20 rr rr                     jsr xt_cr
001C62r 3               
001C62r 3  E8                           inx
001C63r 3  E8                           inx                     ; ( nt xt )
001C64r 3               
001C64r 3                               ; Figure out the size
001C64r 3  A9 0C                        lda #str_see_size
001C66r 3  20 rr rr                     jsr print_string_no_lf
001C69r 3               
001C69r 3  20 rr rr                     jsr xt_swap             ; ( xt nt )
001C6Cr 3  20 rr rr                     jsr xt_wordsize         ; ( xt u )
001C6Fr 3  20 rr rr                     jsr xt_dup              ; ( xt u u ) for DUMP and DISASM
001C72r 3  20 rr rr                     jsr xt_decimal
001C75r 3  20 rr rr                     jsr xt_u_dot            ; ( xt u )
001C78r 3  20 rr rr                     jsr xt_hex
001C7Br 3  20 rr rr                     jsr xt_cr
001C7Er 3               
001C7Er 3                               ; Dump hex and disassemble
001C7Er 3  20 rr rr                     jsr xt_two_dup          ; ( xt u xt u )
001C81r 3  20 rr rr                     jsr xt_dump
001C84r 3  20 rr rr                     jsr xt_cr
001C87r 3  20 rr rr                     jsr xt_disasm
001C8Ar 3               
001C8Ar 3  68                           pla
001C8Br 3  85 rr                        sta base
001C8Dr 3               
001C8Dr 3  60           z_see:          rts
001C8Er 3               
001C8Er 3               
001C8Er 3               
001C8Er 3               ; ## SET_CURRENT ( wid -- ) "Set the compilation wordlist"
001C8Er 3               ; ## "set-current" auto ANS search
001C8Er 3                       ; """https://forth-standard.org/standard/search/SET-CURRENT"""
001C8Er 3               
001C8Er 3               xt_set_current:
001C8Er 3  20 rr rr                     jsr underflow_1
001C91r 3               
001C91r 3                               ; Save the value from the data stack.
001C91r 3  A0 04                        ldy #current_offset
001C93r 3  B5 00                        lda 0,x         ; CURRENT is byte variable
001C95r 3  91 rr                        sta (up),y      ; so only the LSB is used.
001C97r 3               
001C97r 3  E8                           inx
001C98r 3  E8                           inx
001C99r 3               
001C99r 3  60           z_set_current:  rts
001C9Ar 3               
001C9Ar 3               
001C9Ar 3               
001C9Ar 3               ; ## SET_ORDER ( wid_n .. wid_1 n -- ) "Set the current search order"
001C9Ar 3               ; ## "set-order" auto ANS search
001C9Ar 3                       ; """https://forth-standard.org/standard/search/SET-ORDER"""
001C9Ar 3               
001C9Ar 3               xt_set_order:
001C9Ar 3                               ; Test for -1 TOS
001C9Ar 3  A9 FF                        lda #$FF
001C9Cr 3  D5 01                        cmp 1,x
001C9Er 3  D0 12                        bne @start
001CA0r 3  D5 00                        cmp 0,x
001CA2r 3  D0 0E                        bne @start
001CA4r 3               
001CA4r 3                               ; There is a -1 TOS.  Replace it with the default
001CA4r 3                               ; search order, which is just the FORTH-WORDLIST.
001CA4r 3  CA                           dex             ; Make room for the count.
001CA5r 3  CA                           dex
001CA6r 3  74 03                        stz 3,x         ; ROOT-WORDLIST is 3
001CA8r 3  A9 03                        lda #3
001CAAr 3  95 02                        sta 2,x
001CACr 3  74 01                        stz 1,x         ; Count is 1.
001CAEr 3  A9 01                        lda #1
001CB0r 3  95 00                        sta 0,x
001CB2r 3               
001CB2r 3                               ; Continue processing with ( forth-wordlist 1 -- )
001CB2r 3               @start:
001CB2r 3                               ; Set #ORDER - the number of wordlists in the search order.
001CB2r 3  A0 1E                        ldy #num_order_offset
001CB4r 3  B5 00                        lda 0,x
001CB6r 3  91 rr                        sta (up),y      ; #ORDER is a byte variable.
001CB8r 3  85 rr                        sta tmp1        ; Save a copy for zero check and looping.
001CBAr 3                                               ; Only the low byte is saved in tmp1 as
001CBAr 3                                               ; only 8 wordlists are allowed.
001CBAr 3               
001CBAr 3  E8                           inx             ; Drop the count off the data stack.
001CBBr 3  E8                           inx
001CBCr 3               
001CBCr 3                               ; Check if there are zero wordlists.
001CBCr 3  A5 rr                        lda tmp1
001CBEr 3  F0 0D                        beq @done       ; If zero, there are no wordlists.
001CC0r 3               
001CC0r 3                               ; Move the wordlist ids from the data stack to the search order.
001CC0r 3  A0 1F                        ldy #search_order_offset
001CC2r 3               @loop:
001CC2r 3                               ; Move one wordlist id over into the search order.
001CC2r 3  B5 00                        lda 0,x         ; The search order is a byte array
001CC4r 3  91 rr                        sta (up),y      ; so only save the LSB
001CC6r 3  C8                           iny
001CC7r 3               
001CC7r 3                               ; Remove it from the data stack.
001CC7r 3  E8                           inx
001CC8r 3  E8                           inx
001CC9r 3               
001CC9r 3                               ; See if that was the last one to process (first in the list).
001CC9r 3  C6 rr                        dec tmp1
001CCBr 3  D0 F5                        bne @loop
001CCDr 3               
001CCDr 3               @done:
001CCDr 3  60           z_set_order:    rts
001CCEr 3               
001CCEr 3               
001CCEr 3               
001CCEr 3               
001CCEr 3               ; ## S_QUOTE ( "string" -- )( -- addr u ) "Store string in memory"
001CCEr 3               ; ## "s""  auto  ANS core
001CCEr 3                       ; """https://forth-standard.org/standard/core/Sq
001CCEr 3                       ; Store address and length of string given, returning ( addr u ).
001CCEr 3                       ; ANS core claims this is compile-only, but the file set expands it
001CCEr 3                       ; to be interpreted, so it is a state-sensitive word, which in theory
001CCEr 3                       ; are evil. We follow general usage.
001CCEr 3                       ;
001CCEr 3                       ; Can also be realized as
001CCEr 3                       ;     : S" [CHAR] " PARSE POSTPONE SLITERAL ; IMMEDIATE
001CCEr 3                       ; but it is used so much we want it in code.
001CCEr 3                       ; """
001CCEr 3               
001CCEr 3               xt_s_quote:
001CCEr 3                               ; tmp2 will be used to determine if we are handling
001CCEr 3                               ; escaped characters or not.  In this case, we are
001CCEr 3                               ; not, so set it to zero.
001CCEr 3  64 rr                        stz tmp2
001CD0r 3  64 rr                        stz tmp2+1
001CD2r 3               
001CD2r 3               s_quote_start:
001CD2r 3                               ; Make room on the data stack for the address.
001CD2r 3  CA                           dex
001CD3r 3  CA                           dex
001CD4r 3                               ; Make room on the data stack for the count.
001CD4r 3  CA                           dex
001CD5r 3  CA                           dex
001CD6r 3               
001CD6r 3                               ; Put a jmp over the string data with address to be filled
001CD6r 3                               ; in later.
001CD6r 3  A9 4C                        lda #$4C
001CD8r 3  20 rr rr                     jsr cmpl_a
001CDBr 3               
001CDBr 3                               ; Address to be filled in later, just use $4C for the moment
001CDBr 3  20 rr rr                     jsr cmpl_a
001CDEr 3  20 rr rr                     jsr cmpl_a
001CE1r 3               
001CE1r 3                               ; Save the current value of HERE on the data stack for the
001CE1r 3                               ; address of the string.
001CE1r 3  A5 rr                        lda cp
001CE3r 3  95 02                        sta 2,x
001CE5r 3  A5 rr                        lda cp+1
001CE7r 3  95 03                        sta 3,x
001CE9r 3               
001CE9r 3               @savechars_loop:
001CE9r 3                               ; Start saving the string into the dictionary up to the
001CE9r 3                               ; ending double quote. First, check to see if the input
001CE9r 3                               ; buffer is empty.
001CE9r 3  A5 rr                        lda toin+1              ; MSB
001CEBr 3  C5 rr                        cmp ciblen+1
001CEDr 3  90 2A                        bcc @input_fine         ; unsigned comparison
001CEFr 3               
001CEFr 3  A5 rr                        lda toin                ; LSB
001CF1r 3  C5 rr                        cmp ciblen
001CF3r 3  90 24                        bcc @input_fine
001CF5r 3               
001CF5r 3                               ; Input buffer is empty. Refill it. Refill calls accept,
001CF5r 3                               ; which uses tmp2 and tmp3. Save and restore them.
001CF5r 3  A5 rr                        lda tmp2
001CF7r 3  48                           pha
001CF8r 3  A5 rr                        lda tmp2+1
001CFAr 3  48                           pha
001CFBr 3  A5 rr                        lda tmp3    ; Only tmp3 used, so don't bother with tmp3+1
001CFDr 3  48                           pha
001CFEr 3               
001CFEr 3  20 rr rr                     jsr xt_refill           ; ( -- f )
001D01r 3               
001D01r 3  68                           pla
001D02r 3  85 rr                        sta tmp3
001D04r 3  68                           pla
001D05r 3  85 rr                        sta tmp2+1
001D07r 3  68                           pla
001D08r 3  85 rr                        sta tmp2
001D0Ar 3               
001D0Ar 3                               ; Check result of refill.
001D0Ar 3  B5 00                        lda 0,x
001D0Cr 3  15 01                        ora 1,x
001D0Er 3  D0 05                        bne @refill_ok
001D10r 3               
001D10r 3                               ; Something when wrong with refill.
001D10r 3  A9 06                        lda #err_refill
001D12r 3  4C rr rr                     jmp error
001D15r 3               
001D15r 3               @refill_ok:
001D15r 3                               ; Remove the refill flag from the data stack.
001D15r 3  E8                           inx
001D16r 3  E8                           inx
001D17r 3               
001D17r 3                               ; For refill success, jump back up to the empty check, just in
001D17r 3                               ; case refill gave us an empty buffer (eg. empty/blank line of
001D17r 3                               ; input)
001D17r 3  80 D0                        bra @savechars_loop
001D19r 3               
001D19r 3               @input_fine:
001D19r 3                               ; There should be at least one valid char to use.
001D19r 3                               ; Calculate it's address at CIB+TOIN into tmp1
001D19r 3  A5 rr                        lda cib
001D1Br 3  18                           clc
001D1Cr 3  65 rr                        adc toin        ; LSB
001D1Er 3  85 rr                        sta tmp1
001D20r 3  A5 rr                        lda cib+1
001D22r 3  65 rr                        adc toin+1      ; MSB
001D24r 3  85 rr                        sta tmp1+1
001D26r 3               
001D26r 3                               ; Get the character
001D26r 3  B2 rr                        lda (tmp1)
001D28r 3               
001D28r 3                               ; Check to see if we are handling escaped characters.
001D28r 3  24 rr                        bit tmp2
001D2Ar 3  30 03                        bmi @handle_escapes    ; Only checking bit 7
001D2Cr 3  4C rr rr                     jmp @regular_char
001D2Fr 3               
001D2Fr 3               @handle_escapes:
001D2Fr 3                               ; We are handling escaped characters.  See if we have
001D2Fr 3                               ; already seen the backslash.
001D2Fr 3  24 rr                        bit tmp2+1
001D31r 3  30 03                        bmi @escaped
001D33r 3  4C rr rr                     jmp @not_escaped
001D36r 3               
001D36r 3               @escaped:
001D36r 3               
001D36r 3                               ; We have seen a backslash (previous character). Check to see if
001D36r 3                               ; we are in the middle of a \x sequence (bit 6 of tmp2+1 will
001D36r 3                               ; be clear in that case )
001D36r 3  70 22                        bvs @check_esc_chars
001D38r 3               
001D38r 3                               ; We are in the middle of a \x sequence. Check to see if we
001D38r 3                               ; are on the first or second digit.
001D38r 3  A9 01                        lda #1
001D3Ar 3  24 rr                        bit tmp2+1
001D3Cr 3  D0 10                        bne @esc_x_second_digit
001D3Er 3               
001D3Er 3                               ; First digit.
001D3Er 3  E6 rr                        inc tmp2+1  ; Adjust flag for second digit next time.
001D40r 3  B2 rr                        lda (tmp1)  ; Get the char again.
001D42r 3               
001D42r 3                               ; Convert to hex
001D42r 3  20 rr rr                     jsr convert_hex_value
001D45r 3               
001D45r 3                               ; This is the upper nybble, so move it up.
001D45r 3  0A                           asl
001D46r 3  0A                           asl
001D47r 3  0A                           asl
001D48r 3  0A                           asl
001D49r 3  85 rr                        sta tmp3    ; Save it for later.
001D4Br 3  4C rr rr                     jmp @next_character
001D4Er 3               
001D4Er 3               @esc_x_second_digit:
001D4Er 3               
001D4Er 3                               ; We are on the second hex digit of a \x sequence. Clear the
001D4Er 3                               ; escaped character flag (because we are handling it right
001D4Er 3                               ; here)
001D4Er 3  64 rr                        stz tmp2+1
001D50r 3  B2 rr                        lda (tmp1)
001D52r 3               
001D52r 3                               ; Convert to hex, combine with value in tmp3
001D52r 3  20 rr rr                     jsr convert_hex_value
001D55r 3  05 rr                        ora tmp3
001D57r 3               
001D57r 3  4C rr rr                     jmp @save_character
001D5Ar 3               
001D5Ar 3               @check_esc_chars:
001D5Ar 3                               ; Clear the escaped character flag (because we are
001D5Ar 3                               ; handling it right here)
001D5Ar 3  64 rr                        stz tmp2+1
001D5Cr 3               
001D5Cr 3                               ; Process the escaped character
001D5Cr 3               @check_esc_a:
001D5Cr 3  C9 61                        cmp #'a'
001D5Er 3  D0 05                        bne @check_esc_b
001D60r 3               
001D60r 3                               ; BEL (ASCII value 7)
001D60r 3  A9 07                        lda #7
001D62r 3  4C rr rr                     jmp @save_character
001D65r 3               
001D65r 3               @check_esc_b:
001D65r 3  C9 62                        cmp #'b'
001D67r 3  D0 05                        bne @check_esc_e
001D69r 3               
001D69r 3                               ; Backspace (ASCII value 8)
001D69r 3  A9 08                        lda #8
001D6Br 3  4C rr rr                     jmp @save_character
001D6Er 3               
001D6Er 3               @check_esc_e:
001D6Er 3  C9 65                        cmp #'e'
001D70r 3  D0 04                        bne @check_esc_f
001D72r 3               
001D72r 3                               ; ESC (ASCII value 27)
001D72r 3  A9 1B                        lda #27
001D74r 3  80 75                        bra @save_character
001D76r 3               
001D76r 3               @check_esc_f:
001D76r 3  C9 66                        cmp #'f'
001D78r 3  D0 04                        bne @check_esc_l
001D7Ar 3               
001D7Ar 3                               ; FF (ASCII value 12)
001D7Ar 3  A9 0C                        lda #12
001D7Cr 3  80 6D                        bra @save_character
001D7Er 3               
001D7Er 3               @check_esc_l:
001D7Er 3  C9 6C                        cmp #'l'
001D80r 3  D0 04                        bne @check_esc_m
001D82r 3               
001D82r 3                               ; LF (ASCII value 10)
001D82r 3  A9 0A                        lda #10
001D84r 3  80 65                        bra @save_character
001D86r 3               
001D86r 3               @check_esc_m:
001D86r 3                               ; This one is not like the others because we save two
001D86r 3                               ; characters
001D86r 3  C9 6D                        cmp #'m'
001D88r 3  D0 09                        bne @check_esc_n
001D8Ar 3               
001D8Ar 3                               ; CR/LF pair (ASCII values 13, 10)
001D8Ar 3  A9 0D                        lda #13
001D8Cr 3  20 rr rr                     jsr cmpl_a
001D8Fr 3  A9 0A                        lda #10
001D91r 3  80 58                        bra @save_character
001D93r 3               
001D93r 3               @check_esc_n:
001D93r 3  C9 6E                        cmp #'n'
001D95r 3  D0 04                        bne @check_esc_q
001D97r 3               
001D97r 3                               ; newline, impl. dependant, using LF (ASCII values 10)
001D97r 3  A9 0A                        lda #10
001D99r 3  80 50                        bra @save_character
001D9Br 3               
001D9Br 3               @check_esc_q:
001D9Br 3  C9 71                        cmp #'q'
001D9Dr 3  D0 04                        bne @check_esc_r
001D9Fr 3               
001D9Fr 3                               ; Double quote (ASCII value 34)
001D9Fr 3  A9 22                        lda #34
001DA1r 3  80 48                        bra @save_character
001DA3r 3               
001DA3r 3               @check_esc_r:
001DA3r 3  C9 72                        cmp #'r'
001DA5r 3  D0 04                        bne @check_esc_t
001DA7r 3               
001DA7r 3                               ; CR (ASCII value 13)
001DA7r 3  A9 0D                        lda #13
001DA9r 3  80 40                        bra @save_character
001DABr 3               
001DABr 3               @check_esc_t:
001DABr 3  C9 74                        cmp #'t'
001DADr 3  D0 04                        bne @check_esc_v
001DAFr 3               
001DAFr 3                               ; Horizontal TAB (ASCII value 9)
001DAFr 3  A9 09                        lda #9
001DB1r 3  80 38                        bra @save_character
001DB3r 3               
001DB3r 3               @check_esc_v:
001DB3r 3  C9 76                        cmp #'v'
001DB5r 3  D0 04                        bne @check_esc_z
001DB7r 3               
001DB7r 3                               ; Vertical TAB (ASCII value 11)
001DB7r 3  A9 0B                        lda #11
001DB9r 3  80 30                        bra @save_character
001DBBr 3               
001DBBr 3               @check_esc_z:
001DBBr 3  C9 7A                        cmp #'z'
001DBDr 3  D0 04                        bne @check_esc_quote
001DBFr 3               
001DBFr 3                               ; NULL (ASCII value 0)
001DBFr 3  A9 00                        lda #0
001DC1r 3  80 28                        bra @save_character
001DC3r 3               
001DC3r 3               @check_esc_quote:
001DC3r 3  C9 22                        cmp #$22
001DC5r 3  D0 04                        bne @check_esc_x
001DC7r 3               
001DC7r 3                               ; Double quote (ASCII value 34)
001DC7r 3  A9 22                        lda #34
001DC9r 3  80 20                        bra @save_character
001DCBr 3               
001DCBr 3               @check_esc_x:
001DCBr 3  C9 78                        cmp #'x'
001DCDr 3  D0 06                        bne @check_esc_backslash
001DCFr 3               
001DCFr 3                               ; This one is difficult. We need to get the next TWO
001DCFr 3                               ; characters (which might require a refill in the middle)
001DCFr 3                               ; and combine them as two hex digits. We do this by
001DCFr 3                               ; clearing bit 6 of tmp2+1 to indicate we are in a digit
001DCFr 3                               ; and using bit 0 to keep track of which digit we are on.
001DCFr 3  A9 BE                        lda #$BE        ; Clear bits 6 and 0
001DD1r 3  85 rr                        sta tmp2+1
001DD3r 3  80 19                        bra @next_character
001DD5r 3               
001DD5r 3               @check_esc_backslash:
001DD5r 3  C9 5C                        cmp #$5C
001DD7r 3  D0 04                        bne @not_escaped
001DD9r 3               
001DD9r 3                               ; Backslash (ASCII value 92)
001DD9r 3  A9 5C                        lda #92
001DDBr 3  80 0E                        bra @save_character
001DDDr 3               
001DDDr 3               @not_escaped:
001DDDr 3                               ; Check for the backslash to see if we should escape
001DDDr 3                               ; the next char.
001DDDr 3  C9 5C                        cmp #$5C        ; The backslash char
001DDFr 3  D0 06                        bne @regular_char
001DE1r 3               
001DE1r 3                               ; We found a backslash.  Don't save anyhing, but set
001DE1r 3                               ; a flag (in tmp2+1) to handle the next char. We don't
001DE1r 3                               ; try to get the next char here as it may require a
001DE1r 3                               ; refill of the input buffer.
001DE1r 3  A9 FF                        lda #$FF
001DE3r 3  85 rr                        sta tmp2+1
001DE5r 3  80 07                        bra @next_character
001DE7r 3               
001DE7r 3               @regular_char:
001DE7r 3                               ; Check if the current character is the end of the string.
001DE7r 3  C9 22                        cmp #$22        ; ASCII for "
001DE9r 3  F0 0C                        beq @found_string_end
001DEBr 3               
001DEBr 3               @save_character:
001DEBr 3                               ; If we didn't reach the end of the string, compile this
001DEBr 3                               ; character into the dictionary
001DEBr 3  20 rr rr                     jsr cmpl_a
001DEEr 3               
001DEEr 3               @next_character:
001DEEr 3                               ; Move on to the next character.
001DEEr 3  E6 rr                        inc toin
001DF0r 3  D0 02                        bne @savechars_loop_longjump
001DF2r 3  E6 rr                        inc toin+1
001DF4r 3               
001DF4r 3               @savechars_loop_longjump:
001DF4r 3  4C rr rr                     jmp @savechars_loop
001DF7r 3               
001DF7r 3               @found_string_end:
001DF7r 3                               ; Use up the delimiter.
001DF7r 3  E6 rr                        inc toin
001DF9r 3  D0 02                        bne @1
001DFBr 3  E6 rr                        inc toin+1
001DFDr 3               @1:
001DFDr 3                               ; Calculate the length of the string, which is the
001DFDr 3                               ; difference between cp and the address of the start
001DFDr 3                               ; of the string (currently saved on the stack).
001DFDr 3  A5 rr                        lda cp
001DFFr 3  38                           sec
001E00r 3  F5 02                        sbc 2,x
001E02r 3  95 00                        sta 0,x         ; LSB
001E04r 3  A5 rr                        lda cp+1
001E06r 3  F5 03                        sbc 3,x
001E08r 3  95 01                        sta 1,x         ; MSB
001E0Ar 3               
001E0Ar 3                               ; Update the address of the jump-over jmp instruction.
001E0Ar 3                               ; First determine location of jmp instructions address.
001E0Ar 3                               ; It should be 2 bytes before the start of the string.
001E0Ar 3                               ; Compute it into tmp1, which is no longer being used.
001E0Ar 3  B5 02                        lda 2,x
001E0Cr 3  38                           sec
001E0Dr 3  E9 02                        sbc #2
001E0Fr 3  85 rr                        sta tmp1
001E11r 3  B5 03                        lda 3,x
001E13r 3  E9 00                        sbc #0          ; Propagate borrow
001E15r 3  85 rr                        sta tmp1+1
001E17r 3               
001E17r 3                               ; Update the address of the jump to HERE.
001E17r 3  A5 rr                        lda cp
001E19r 3  92 rr                        sta (tmp1)
001E1Br 3  A0 01                        ldy #1
001E1Dr 3  A5 rr                        lda cp+1
001E1Fr 3  91 rr                        sta (tmp1),y
001E21r 3               
001E21r 3                               ; What happens next depends on the state (which is bad, but
001E21r 3                               ; that's the way it works at the moment). If we are
001E21r 3                               ; interpretating, we save the string to a transient buffer
001E21r 3                               ; and return that address (used for file calls, see
001E21r 3                               ; https://forth-standard.org/standard/file/Sq . If we're
001E21r 3                               ; compiling, we just need SLITERAL
001E21r 3  A5 rr                        lda state
001E23r 3  05 rr                        ora state+1             ; paranoid
001E25r 3  F0 03                        beq @done
001E27r 3               
001E27r 3                               ; Jump into the middle of the sliteral word, after the
001E27r 3                               ; string data has been compiled into the dictionary,
001E27r 3                               ; because we've already done that step.
001E27r 3  20 rr rr                     jsr sliteral_const_str         ; ( addr u -- )
001E2Ar 3               
001E2Ar 3               @done:
001E2Ar 3  60           z_s_quote:      rts
001E2Br 3               
001E2Br 3               
001E2Br 3               
001E2Br 3               ; ## S_TO_D ( u -- d ) "Convert single cell number to double cell"
001E2Br 3               ; ## "s>d"  auto  ANS core
001E2Br 3                       ; """https://forth-standard.org/standard/core/StoD"""
001E2Br 3               
001E2Br 3               xt_s_to_d:
001E2Br 3  20 rr rr                     jsr underflow_1
001E2Er 3               
001E2Er 3  CA                           dex
001E2Fr 3  CA                           dex
001E30r 3  74 00                        stz 0,x
001E32r 3  74 01                        stz 1,x
001E34r 3               
001E34r 3  B5 03                        lda 3,x
001E36r 3  10 04                        bpl @done
001E38r 3               
001E38r 3                               ; negative, extend sign
001E38r 3  D6 00                        dec 0,x
001E3Ar 3  D6 01                        dec 1,x
001E3Cr 3               @done:
001E3Cr 3  60           z_s_to_d:       rts
001E3Dr 3               
001E3Dr 3               
001E3Dr 3               
001E3Dr 3               ; ## SAVE_BUFFERS ( -- ) "Save all dirty buffers to storage"
001E3Dr 3               ; ## "save-buffers"  tested  ANS block
001E3Dr 3                       ; """https://forth-standard.org/standard/block/SAVE-BUFFERS"""
001E3Dr 3               
001E3Dr 3               xt_save_buffers:
001E3Dr 3                               ; Check the buffer status
001E3Dr 3  A0 2C                        ldy #buffstatus_offset
001E3Fr 3  B1 rr                        lda (up),y      ; Only bits 0 and 1 are used, so only
001E41r 3  C9 03                        cmp #3          ; LSB is needed.
001E43r 3  D0 12                        bne @done       ; Either not used or not dirty = done!
001E45r 3               
001E45r 3                               ; We need to save the block.
001E45r 3  20 rr rr                     jsr xt_blkbuffer
001E48r 3  20 rr rr                     jsr xt_buffblocknum
001E4Br 3  20 rr rr                     jsr xt_fetch
001E4Er 3  20 rr rr                     jsr xt_block_write
001E51r 3               
001E51r 3                               ; Mark the buffer as clean now.
001E51r 3  A9 01                        lda #1
001E53r 3  A0 2C                        ldy #buffstatus_offset
001E55r 3  91 rr                        sta (up),y
001E57r 3               
001E57r 3               @done:
001E57r 3  60           z_save_buffers: rts
001E58r 3               
001E58r 3               
001E58r 3               
001E58r 3               ; ## SCR ( -- addr ) "Push address of variable holding last screen listed"
001E58r 3               ; ## "scr"  auto  ANS block ext
001E58r 3                       ; """https://forth-standard.org/standard/block/SCR"""
001E58r 3               xt_scr:
001E58r 3                               ; SCR is at UP + scr_offset
001E58r 3  CA                           dex
001E59r 3  CA                           dex
001E5Ar 3  18                           clc
001E5Br 3  A5 rr                        lda up
001E5Dr 3  69 02                        adc #scr_offset ; Add offset
001E5Fr 3  95 00                        sta 0,x
001E61r 3  A5 rr                        lda up+1
001E63r 3  69 00                        adc #0          ; Adding carry
001E65r 3  95 01                        sta 1,x
001E67r 3               
001E67r 3  60           z_scr:          rts
001E68r 3               
001E68r 3               
001E68r 3               ; ## SEARCH ( addr1 u1 addr2 u2 -- addr3 u3 flag) "Search for a substring"
001E68r 3               ; ## "search"   auto  ANS string
001E68r 3                       ; """https://forth-standard.org/standard/string/SEARCH
001E68r 3                       ; Search for string2 (denoted by addr2 u2) in string1 (denoted by
001E68r 3                       ; addr1 u1). If a match is found the flag will be true and
001E68r 3                       ; addr3 will have the address of the start of the match and u3 will have
001E68r 3                       ; the number of characters remaining from the match point to the end
001E68r 3                       ; of the original string1. If a match is not found, the flag will be
001E68r 3                       ; false and addr3 and u3 will be the original string1's addr1 and u1.
001E68r 3                       ; """
001E68r 3               
001E68r 3               xt_search:
001E68r 3  20 rr rr                     jsr underflow_4
001E6Br 3               
001E6Br 3                               ; ANS says if the second string is a zero-length string it
001E6Br 3                               ; automatically matches.
001E6Br 3  B5 00                        lda 0,x
001E6Dr 3  15 01                        ora 1,x
001E6Fr 3  D0 0B                        bne @start_search
001E71r 3               
001E71r 3                               ; The second string is a zero length string.  Just remove
001E71r 3                               ; the second string and put a true flag.
001E71r 3  E8                           inx             ; Remove u2
001E72r 3  E8                           inx
001E73r 3  A9 FF                        lda #$FF        ; Turn addr2 into a true flag
001E75r 3  95 00                        sta 0,x
001E77r 3  95 01                        sta 1,x
001E79r 3  4C rr rr                     jmp z_search
001E7Cr 3               
001E7Cr 3               @start_search:
001E7Cr 3                               ; Put an offset (starting at zero) on the stack.
001E7Cr 3  20 rr rr                     jsr xt_zero
001E7Fr 3               
001E7Fr 3               @search_loop:
001E7Fr 3                               ; We stop (not found) when u2 + offset > u1
001E7Fr 3                               ; Calculate u2+offset into tmp1
001E7Fr 3  18                           clc
001E80r 3  B5 00                        lda 0,x
001E82r 3  75 02                        adc 2,x
001E84r 3  85 rr                        sta tmp1
001E86r 3  B5 01                        lda 1,x
001E88r 3  75 03                        adc 3,x
001E8Ar 3               
001E8Ar 3               
001E8Ar 3                               ; Compare to u1. Start with the high byte
001E8Ar 3  D5 07                        cmp 7,x
001E8Cr 3  90 12                        bcc @init_comparison ; Obviously less
001E8Er 3  D0 06                        bne @not_found
001E90r 3               
001E90r 3                               ; The upper address byte matched - check the lower byte
001E90r 3                               ; Load u1 first so we can use just a carry to check.
001E90r 3  B5 06                        lda 6,x
001E92r 3  C5 rr                        cmp tmp1
001E94r 3  B0 0A                        bcs @init_comparison
001E96r 3               
001E96r 3               @not_found:
001E96r 3                               ; The substring isn't in the main string.
001E96r 3                               ; Return just the main string and a false flag.
001E96r 3  E8                           inx             ; Remove offset
001E97r 3  E8                           inx
001E98r 3  E8                           inx             ; Remove u2
001E99r 3  E8                           inx
001E9Ar 3  74 00                        stz 0,x         ; Turn addr2 into a false flag
001E9Cr 3  74 01                        stz 1,x
001E9Er 3  80 66                        bra z_search
001EA0r 3               
001EA0r 3               @init_comparison:
001EA0r 3                               ; Use tmp1 to hold address in string 1.
001EA0r 3                               ; Use tmp2 to hold address in string 2.
001EA0r 3                               ; Use tmp3 to hold the number of characters left to check.
001EA0r 3               
001EA0r 3                               ; Compute the starting address in string 1
001EA0r 3                               ; as addr1 + offset
001EA0r 3  18                           clc
001EA1r 3  B5 08                        lda 8,x
001EA3r 3  75 00                        adc 0,x
001EA5r 3  85 rr                        sta tmp1
001EA7r 3  B5 09                        lda 9,x
001EA9r 3  75 01                        adc 1,x
001EABr 3  85 rr                        sta tmp1+1
001EADr 3               
001EADr 3                               ; The starting address in string 2 is just addr2.
001EADr 3  B5 04                        lda 4,x
001EAFr 3  85 rr                        sta tmp2
001EB1r 3  B5 05                        lda 5,x
001EB3r 3  85 rr                        sta tmp2+1
001EB5r 3               
001EB5r 3                               ; The number of characters to check is u2.
001EB5r 3  B5 02                        lda 2,x
001EB7r 3  85 rr                        sta tmp3
001EB9r 3  B5 03                        lda 3,x
001EBBr 3  85 rr                        sta tmp3+1
001EBDr 3               
001EBDr 3               @comparison_loop:
001EBDr 3                               ; Check to see if the current characters match.
001EBDr 3  B2 rr                        lda (tmp1)
001EBFr 3  D2 rr                        cmp (tmp2)
001EC1r 3  F0 05                        beq @letters_match
001EC3r 3               
001EC3r 3                               ; One of the letters didn't match.
001EC3r 3                               ; Increment the offset and try again.
001EC3r 3  20 rr rr                     jsr xt_one_plus
001EC6r 3  80 B7                        bra @search_loop
001EC8r 3               
001EC8r 3               @letters_match:
001EC8r 3                               ; The letters match.  Advance the pointers until the
001EC8r 3                               ; count reaches zero.
001EC8r 3  E6 rr                        inc tmp1
001ECAr 3  D0 02                        bne @1
001ECCr 3  E6 rr                        inc tmp1+1
001ECEr 3               @1:
001ECEr 3  E6 rr                        inc tmp2
001ED0r 3  D0 02                        bne @2
001ED2r 3  E6 rr                        inc tmp2+1
001ED4r 3               @2:
001ED4r 3                               ; Decrement the count of remaining letters to check.
001ED4r 3  A5 rr                        lda tmp3
001ED6r 3  D0 02                        bne @3
001ED8r 3  C6 rr                        dec tmp3+1
001EDAr 3               @3:
001EDAr 3  C6 rr                        dec tmp3
001EDCr 3               
001EDCr 3                               ; Check if we've reached zero.
001EDCr 3  A5 rr                        lda tmp3
001EDEr 3  05 rr                        ora tmp3+1
001EE0r 3  D0 DB                        bne @comparison_loop ; Check the next letter
001EE2r 3               
001EE2r 3                               ; We've run out of letters and they all match!
001EE2r 3                               ; Return (addr1+offset) (u1-offset) true
001EE2r 3                               ; Add offset to addr1.
001EE2r 3  18                           clc
001EE3r 3  B5 00                        lda 0,x
001EE5r 3  75 08                        adc 8,x
001EE7r 3  95 08                        sta 8,x
001EE9r 3  B5 01                        lda 1,x
001EEBr 3  75 09                        adc 9,x
001EEDr 3  95 09                        sta 9,x
001EEFr 3               
001EEFr 3                               ; Subtract offset from u1.
001EEFr 3  38                           sec
001EF0r 3  B5 06                        lda 6,x
001EF2r 3  F5 00                        sbc 0,x
001EF4r 3  95 06                        sta 6,x
001EF6r 3  B5 07                        lda 7,x
001EF8r 3  F5 01                        sbc 1,x
001EFAr 3  95 07                        sta 7,x
001EFCr 3               
001EFCr 3                               ; Replace addr2, u2, and offset with a true flag.
001EFCr 3  E8                           inx             ; drop offset
001EFDr 3  E8                           inx
001EFEr 3  E8                           inx             ; drop u2
001EFFr 3  E8                           inx
001F00r 3  A9 FF                        lda #$FF
001F02r 3  95 00                        sta 0,x         ; Turn addr2 into a true flag.
001F04r 3  95 01                        sta 1,x
001F06r 3               
001F06r 3  60           z_search:       rts
001F07r 3               
001F07r 3               
001F07r 3               
001F07r 3               ; ## SEMICOLON ( -- ) "End compilation of new word"
001F07r 3               ; ## ";"  auto  ANS core
001F07r 3                       ; """https://forth-standard.org/standard/core/Semi
001F07r 3                       ; End the compilation of a new word into the Dictionary.
001F07r 3                       ;
001F07r 3                       ; When we
001F07r 3                       ; enter this, WORKWORD is pointing to the nt_ of this word in the
001F07r 3                       ; Dictionary, DP to the previous word, and CP to the next free byte.
001F07r 3                       ; A Forth definition would be (see "Starting Forth"):
001F07r 3                       ; : POSTPONE EXIT  REVEAL POSTPONE ; [ ; IMMEDIATE  Following the
001F07r 3                       ; practice of Gforth, we warn here if a word has been redefined.
001F07r 3                       ; """
001F07r 3               
001F07r 3               xt_semicolon:
001F07r 3                               ; Check if this is a : word or a :NONAME word.
001F07r 3  24 rr                        bit status
001F09r 3  70 11                        bvs @colonword
001F0Br 3               
001F0Br 3                               ; This is a :NONAME word - just put an RTS on the end and
001F0Br 3                               ; the address (held in workword) on the stack.
001F0Br 3  A9 60                        lda #$60                ; opcode for RTS
001F0Dr 3  20 rr rr                     jsr cmpl_a
001F10r 3               
001F10r 3  CA                           dex
001F11r 3  CA                           dex
001F12r 3  A5 rr                        lda workword
001F14r 3  95 00                        sta 0,x
001F16r 3  A5 rr                        lda workword+1
001F18r 3  95 01                        sta 1,x
001F1Ar 3  80 45                        bra @semicolon_done
001F1Cr 3               
001F1Cr 3               @colonword:
001F1Cr 3                               ; CP is the byte that will be the address we use in the
001F1Cr 3                               ; header as the end-of-compile address (z_word). This is
001F1Cr 3                               ; six bytes down from the header
001F1Cr 3  A0 06                        ldy #6
001F1Er 3  A5 rr                        lda cp
001F20r 3  91 rr                        sta (workword),y
001F22r 3  C8                           iny
001F23r 3  A5 rr                        lda cp+1
001F25r 3  91 rr                        sta (workword),y
001F27r 3               
001F27r 3                               ; Allocate one further byte and save the RTS instruction
001F27r 3                               ; there
001F27r 3  A9 60                        lda #$60                ; opcode for RTS
001F29r 3  20 rr rr                     jsr cmpl_a
001F2Cr 3               
001F2Cr 3                               ; Before we formally add the word to the Dictionary, we
001F2Cr 3                               ; check to see if it is already present, and if yes, we
001F2Cr 3                               ; warn the user.
001F2Cr 3               
001F2Cr 3                               ; See if word already in Dictionary.
001F2Cr 3                               ; (STATUS bit 7 will be high as CREATE already
001F2Cr 3                               ;  checked for us.)
001F2Cr 3  24 rr                        bit status
001F2Er 3  10 26                        bpl @new_word   ; Bit 7 is clear = new word
001F30r 3               
001F30r 3                               ; We start by putting the string of the
001F30r 3                               ; word we're defining on the stack
001F30r 3  CA                           dex
001F31r 3  CA                           dex
001F32r 3  CA                           dex
001F33r 3  CA                           dex
001F34r 3               
001F34r 3                               ; WORKWORD points to the beginning of the head of our new
001F34r 3                               ; word, where the first byte is the length of the string
001F34r 3                               ; We can't use LATESTNT because we haven't added the new
001F34r 3                               ; word to the Dictionary yet
001F34r 3  B2 rr                        lda (workword)
001F36r 3  95 00                        sta 0,x
001F38r 3  74 01                        stz 1,x
001F3Ar 3               
001F3Ar 3                               ; Eight bytes below WORKWORD is the actual beginning of
001F3Ar 3                               ; the string
001F3Ar 3  A5 rr                        lda workword
001F3Cr 3  18                           clc
001F3Dr 3  69 08                        adc #8
001F3Fr 3  95 02                        sta 2,x
001F41r 3  A5 rr                        lda workword+1
001F43r 3  69 00                        adc #0                  ; only want carry
001F45r 3  95 03                        sta 3,x
001F47r 3               
001F47r 3                               ; This word is already in the Dictionary, so we print a
001F47r 3                               ; warning to the user.
001F47r 3  A9 02                        lda #str_redefined       ; address of string "redefined"
001F49r 3  20 rr rr                     jsr print_string_no_lf
001F4Cr 3               
001F4Cr 3                               ; Now we print the offending word.
001F4Cr 3  20 rr rr                     jsr xt_type
001F4Fr 3  20 rr rr                     jsr xt_space
001F52r 3               
001F52r 3                               ; Clear bit 7 of status (so future words will print message
001F52r 3                               ; by defaut)
001F52r 3  A9 80                        lda #%10000000
001F54r 3  14 rr                        trb status
001F56r 3               
001F56r 3               @new_word:
001F56r 3                               ; Let's get this over with. Save beginning of our word
001F56r 3                               ; as new last word in the Dictionary
001F56r 3  A5 rr                        lda workword
001F58r 3  85 rr                        sta dp
001F5Ar 3  A5 rr                        lda workword+1
001F5Cr 3  85 rr                        sta dp+1
001F5Er 3  20 rr rr                     jsr dp_to_current       ; Save the updated DP to the
001F61r 3                                                       ; CURRENT wordlist.
001F61r 3               @semicolon_done:
001F61r 3                               ; Word definition complete. Return compile flag to zero
001F61r 3                               ; to return to interpret mode
001F61r 3  64 rr                        stz state
001F63r 3  64 rr                        stz state+1
001F65r 3               
001F65r 3  60           z_semicolon:    rts
001F66r 3               
001F66r 3               
001F66r 3               
001F66r 3               ; ## SIGN ( n -- ) "Add minus to pictured output"
001F66r 3               ; ## "sign"  auto  ANS core
001F66r 3                       ; """https://forth-standard.org/standard/core/SIGN
001F66r 3                       ;
001F66r 3                       ; Code based on
001F66r 3                       ; http://pforth.googlecode.com/svn/trunk/fth/numberio.fth
001F66r 3                       ; Original Forth code is   0< IF ASCII - HOLD THEN
001F66r 3                       ; """
001F66r 3               
001F66r 3               xt_sign:
001F66r 3  20 rr rr                     jsr underflow_1
001F69r 3               
001F69r 3  B5 01                        lda 1,x         ; check MSB of TOS
001F6Br 3  30 04                        bmi @minus
001F6Dr 3               
001F6Dr 3  E8                           inx
001F6Er 3  E8                           inx
001F6Fr 3  80 09                        bra @done
001F71r 3               @minus:
001F71r 3  A9 2D                        lda #$2D        ; ASCII for "-"
001F73r 3  95 00                        sta 0,x         ; overwrite TOS
001F75r 3  74 01                        stz 1,x         ; paranoid
001F77r 3               
001F77r 3  20 rr rr                     jsr xt_hold
001F7Ar 3               @done:
001F7Ar 3  60           z_sign:         rts
001F7Br 3               
001F7Br 3               
001F7Br 3               
001F7Br 3               ; ## SLASH ( n1 n2 -- n ) "Divide NOS by TOS"
001F7Br 3               ; ## "/"  auto  ANS core
001F7Br 3                       ; """https://forth-standard.org/standard/core/Div
001F7Br 3                       ;
001F7Br 3                       ; Forth code is either  >R S>D R> FM/MOD SWAP DROP
001F7Br 3                       ; or >R S>D R> SM/REM SWAP DROP -- we use SM/REM in Tali Forth.
001F7Br 3                       ; This code is currently unoptimized. This code without the SLASH
001F7Br 3                       ; DROP at the end is /MOD, so we share the code as far as possible.
001F7Br 3                       ; """
001F7Br 3               
001F7Br 3               xt_slash:
001F7Br 3                               ; With all the multiplication going on, it would be hard to
001F7Br 3                               ; make sure that one of our temporary variables is not
001F7Br 3                               ; overwritten. We make sure that doesn't happen by taking the
001F7Br 3                               ; hit of pushing the flag to the 65c02's stack
001F7Br 3  A9 00                        lda #0
001F7Dr 3  48                           pha
001F7Er 3  80 03                        bra _common
001F80r 3               
001F80r 3               xt_slash_mod:
001F80r 3                               ; Note that /MOD accesses this code
001F80r 3  A9 FF                        lda #$FF
001F82r 3  48                           pha             ; falls through to _common
001F83r 3               
001F83r 3               _common:
001F83r 3  20 rr rr                     jsr xt_to_r             ; >R
001F86r 3  20 rr rr                     jsr xt_s_to_d           ; S>D
001F89r 3  20 rr rr                     jsr xt_r_from           ; R>
001F8Cr 3  20 rr rr                     jsr xt_sm_slash_rem     ; SM/REM
001F8Fr 3               
001F8Fr 3                               ; Get the flag back from the 65c02's stack. Zero is SLASH,
001F8Fr 3                               ; $FF is SLASH MOD
001F8Fr 3  68                           pla
001F90r 3  D0 05                        bne @done
001F92r 3               
001F92r 3                               ; The following code is for SLASH only
001F92r 3  20 rr rr                     jsr xt_swap
001F95r 3  E8                           inx             ; DROP
001F96r 3  E8                           inx
001F97r 3               @done:
001F97r 3               z_slash_mod:
001F97r 3  60           z_slash:        rts
001F98r 3               
001F98r 3               
001F98r 3               
001F98r 3               ; ## SLASH_MOD ( n1 n2 -- n3 n4 ) "Divide NOS by TOS with a remainder"
001F98r 3               ; ## "/mod"  auto  ANS core
001F98r 3                       ; """https://forth-standard.org/standard/core/DivMOD
001F98r 3                       ;
001F98r 3                       ; This is a dummy entry, the actual code is shared with SLASH
001F98r 3                       ; """
001F98r 3               
001F98r 3               
001F98r 3               ; ## SLASH_STRING ( addr u n -- addr u ) "Shorten string by n"
001F98r 3               ; ## "/string"  auto  ANS string
001F98r 3                       ; """https://forth-standard.org/standard/string/DivSTRING
001F98r 3                       ;
001F98r 3                       ; Forth code is
001F98r 3                       ; : /STRING ( ADDR U N -- ADDR U ) ROT OVER + ROT ROT - ;
001F98r 3                       ; Put differently, we need to add TOS and 3OS, and subtract
001F98r 3                       ; TOS from NOS, and then drop TOS
001F98r 3                       ; """
001F98r 3               
001F98r 3               xt_slash_string:
001F98r 3  20 rr rr                     jsr underflow_3
001F9Br 3               
001F9Br 3  18                           clc             ; 3OS+TOS
001F9Cr 3  B5 00                        lda 0,x
001F9Er 3  75 04                        adc 4,x
001FA0r 3  95 04                        sta 4,x
001FA2r 3               
001FA2r 3  B5 01                        lda 1,x
001FA4r 3  75 05                        adc 5,x
001FA6r 3  95 05                        sta 5,x
001FA8r 3               
001FA8r 3  38                           sec             ; NOS-TOS
001FA9r 3  B5 02                        lda 2,x
001FABr 3  F5 00                        sbc 0,x
001FADr 3  95 02                        sta 2,x
001FAFr 3               
001FAFr 3  B5 03                        lda 3,x
001FB1r 3  F5 01                        sbc 1,x
001FB3r 3  95 03                        sta 3,x
001FB5r 3               
001FB5r 3  E8                           inx
001FB6r 3  E8                           inx
001FB7r 3               
001FB7r 3  60           z_slash_string: rts
001FB8r 3               
001FB8r 3               
001FB8r 3               
001FB8r 3               ; ## SLITERAL ( addr u -- )( -- addr u ) "Compile a string for runtime"
001FB8r 3               ; ## "sliteral" auto  ANS string
001FB8r 3                       ; """https://forth-standard.org/standard/string/SLITERAL
001FB8r 3                       ; Add the runtime for an existing string.
001FB8r 3                       ; """
001FB8r 3               
001FB8r 3               xt_sliteral:
001FB8r 3  20 rr rr                     jsr underflow_2
001FBBr 3               
001FBBr 3                               ; We can't assume that ( addr u ) of the current string is in
001FBBr 3                               ; a stable area (eg. already in the dictionary.) Copy the
001FBBr 3                               ; string data into the dictionary using move.
001FBBr 3               
001FBBr 3                               ; Put a jmp over the string data with address to be filled
001FBBr 3                               ; in later.
001FBBr 3  A9 4C                        lda #$4C
001FBDr 3  20 rr rr                     jsr cmpl_a
001FC0r 3               
001FC0r 3                               ; Address to be filled in later.
001FC0r 3  20 rr rr                     jsr cmpl_a
001FC3r 3  20 rr rr                     jsr cmpl_a
001FC6r 3               
001FC6r 3                               ; Turn the data stack from ( addr u ) into
001FC6r 3                               ; ( here u addr here u ) so move can be called with
001FC6r 3                               ; the remaining items on the stack ready for processing.
001FC6r 3                               ; Reserve three extra words on the stack.
001FC6r 3  8A                           txa
001FC7r 3  38                           sec
001FC8r 3  E9 06                        sbc #6
001FCAr 3  AA                           tax
001FCBr 3               
001FCBr 3                               ; Move addr down from TOS-4 to TOS-2
001FCBr 3  B5 08                        lda 8,x
001FCDr 3  95 04                        sta 4,x
001FCFr 3  B5 09                        lda 9,x
001FD1r 3  95 05                        sta 5,x
001FD3r 3               
001FD3r 3                               ; Copy u from TOS-3 to TOS
001FD3r 3  B5 06                        lda 6,x
001FD5r 3  95 00                        sta 0,x
001FD7r 3  B5 07                        lda 7,x
001FD9r 3  95 01                        sta 1,x
001FDBr 3               
001FDBr 3                               ; Put HERE into TOS-1 and TOS-4
001FDBr 3  A5 rr                        lda cp
001FDDr 3  95 08                        sta 8,x
001FDFr 3  95 02                        sta 2,x
001FE1r 3  A5 rr                        lda cp+1
001FE3r 3  95 09                        sta 9,x
001FE5r 3  95 03                        sta 3,x
001FE7r 3               
001FE7r 3                               ; Copy the string into the dictionary.
001FE7r 3  20 rr rr                     jsr xt_move
001FEAr 3               
001FEAr 3                               ; Update cp.
001FEAr 3  18                           clc
001FEBr 3  A5 rr                        lda cp
001FEDr 3  75 00                        adc 0,x
001FEFr 3  85 rr                        sta cp
001FF1r 3  A5 rr                        lda cp+1
001FF3r 3  75 01                        adc 1,x
001FF5r 3  85 rr                        sta cp+1
001FF7r 3               
001FF7r 3                               ; Update the address of the jump-over jmp instruction.
001FF7r 3                               ; First determine location of jmp instructions address.
001FF7r 3                               ; It should be 2 bytes before the start of the string.
001FF7r 3               
001FF7r 3                               ; Compute it into tmp1, which is no longer being used.
001FF7r 3  B5 02                        lda 2,x
001FF9r 3  38                           sec
001FFAr 3  E9 02                        sbc #2
001FFCr 3  85 rr                        sta tmp1
001FFEr 3  B5 03                        lda 3,x
002000r 3  E9 00                        sbc #0          ; Propagate borrow
002002r 3  85 rr                        sta tmp1+1
002004r 3               
002004r 3                               ; Update the address of the jump to HERE.
002004r 3  A5 rr                        lda cp
002006r 3  92 rr                        sta (tmp1)
002008r 3  A0 01                        ldy #1
00200Ar 3  A5 rr                        lda cp+1
00200Cr 3  91 rr                        sta (tmp1),y
00200Er 3               
00200Er 3                               ; Stack is now ( addr2 u ) where addr2 is the new
00200Er 3                               ; location in the dictionary.
00200Er 3               
00200Er 3               sliteral_const_str:
00200Er 3                               ; Compile a subroutine jump to the runtime of SLITERAL that
00200Er 3                               ; pushes the new ( addr u ) pair to the Data Stack.
00200Er 3                               ; When we're done, the code will look like this:
00200Er 3               
00200Er 3                               ; xt -->    jmp a
00200Er 3                               ;           <string data bytes>
00200Er 3                               ;  a -->    jsr sliteral_runtime
00200Er 3                               ;           <string address>
00200Er 3                               ;           <string length>
00200Er 3                               ; rts -->
00200Er 3               
00200Er 3                               ; This means we'll have to adjust the return address for two
00200Er 3                               ; cells, not just one
00200Er 3  A0 rr                        ldy #>sliteral_runtime
002010r 3  A9 rr                        lda #<sliteral_runtime
002012r 3  20 rr rr                     jsr cmpl_subroutine
002015r 3               
002015r 3                               ; We want to have the address end up as NOS and the length
002015r 3                               ; as TOS, so we store the address first
002015r 3  B4 03                        ldy 3,x                ; address MSB
002017r 3  B5 02                        lda 2,x                ; address LSB
002019r 3  20 rr rr                     jsr cmpl_word
00201Cr 3               
00201Cr 3  B4 01                        ldy 1,x                ; length MSB
00201Er 3  B5 00                        lda 0,x                ; length LSB
002020r 3  20 rr rr                     jsr cmpl_word
002023r 3               
002023r 3                               ; clean up and leave
002023r 3  E8                           inx
002024r 3  E8                           inx
002025r 3  E8                           inx
002026r 3  E8                           inx
002027r 3               
002027r 3  60           z_sliteral:     rts
002028r 3               
002028r 3               
002028r 3               sliteral_runtime:
002028r 3               
002028r 3                       ; """Run time behaviour of SLITERAL: Push ( addr u ) of string to
002028r 3                       ; the Data Stack. We arrive here with the return address as the
002028r 3                       ; top of Return Stack, which points to the address of the string
002028r 3                       ; """
002028r 3  CA                           dex
002029r 3  CA                           dex
00202Ar 3  CA                           dex
00202Br 3  CA                           dex
00202Cr 3               
00202Cr 3                               ; Get the address of the string address off the stack and
00202Cr 3                               ; increase by one because of the RTS mechanics
00202Cr 3  68                           pla
00202Dr 3  85 rr                        sta tmp1        ; LSB of address
00202Fr 3  68                           pla
002030r 3  85 rr                        sta tmp1+1      ; MSB of address
002032r 3               
002032r 3                               ; Walk through both and save them
002032r 3  A0 01                        ldy #1          ; adjust for JSR/RTS mechanics on 65c02
002034r 3  B1 rr                        lda (tmp1),y
002036r 3  95 02                        sta 2,x         ; LSB of address
002038r 3  C8                           iny
002039r 3               
002039r 3  B1 rr                        lda (tmp1),y
00203Br 3  95 03                        sta 3,x         ; MSB of address
00203Dr 3  C8                           iny
00203Er 3               
00203Er 3  B1 rr                        lda (tmp1),y
002040r 3  95 00                        sta 0,x         ; LSB of length
002042r 3  C8                           iny
002043r 3               
002043r 3  B1 rr                        lda (tmp1),y
002045r 3  95 01                        sta 1,x         ; MSB of length
002047r 3               
002047r 3                               ; restore return address
002047r 3  18                           clc
002048r 3  A5 rr                        lda tmp1
00204Ar 3  69 04                        adc #4
00204Cr 3  A8                           tay             ; LSB
00204Dr 3  A5 rr                        lda tmp1+1
00204Fr 3  69 00                        adc #0          ; we only need carry
002051r 3  48                           pha             ; MSB
002052r 3  5A                           phy
002053r 3               
002053r 3  60                           rts
002054r 3               
002054r 3               
002054r 3               
002054r 3               ; ## SM_SLASH_REM ( d n1 -- n2 n3 ) "Symmetic signed division"
002054r 3               ; ## "sm/rem"  auto  ANS core
002054r 3                       ; """https://forth-standard.org/standard/core/SMDivREM
002054r 3                       ; Symmetic signed division. Compare FM/MOD. Based on F-PC 3.6
002054r 3                       ; by Ulrich Hoffmann. See http://www.xlerb.de/uho/ansi.seq
002054r 3                       ;
002054r 3                       ; Forth:
002054r 3                       ; OVER >R 2DUP XOR 0< >R ABS >R DABS R> UM/MOD R> ?NEGATE SWAP
002054r 3                       ; R> ?NEGATE SWAP
002054r 3                       ; """
002054r 3               
002054r 3               xt_sm_slash_rem:
002054r 3  20 rr rr                     jsr underflow_3 ; contains double number
002057r 3               
002057r 3                               ; push MSB of high cell of d to Data Stack so we can check
002057r 3                               ; its sign later
002057r 3  B5 03                        lda 3,x
002059r 3  48                           pha
00205Ar 3               
00205Ar 3                               ; XOR the MSB of the high cell of d and n1 so we figure out
00205Ar 3                               ; its sign later as well
00205Ar 3  B5 01                        lda 1,x
00205Cr 3  55 03                        eor 3,x
00205Er 3  48                           pha
00205Fr 3               
00205Fr 3                               ; Prepare division by getting absolute of n1 and d
00205Fr 3  20 rr rr                     jsr xt_abs
002062r 3  E8                           inx             ; pretend we pushed n1 to R
002063r 3  E8                           inx
002064r 3               
002064r 3  20 rr rr                     jsr xt_dabs
002067r 3  CA                           dex
002068r 3  CA                           dex
002069r 3               
002069r 3  20 rr rr                     jsr xt_um_slash_mod     ; UM/MOD
00206Cr 3               
00206Cr 3                               ; if the XOR compiled above is negative, negate the
00206Cr 3                               ; quotient (n3)
00206Cr 3  68                           pla
00206Dr 3  10 03                        bpl @1
00206Fr 3  20 rr rr                     jsr xt_negate
002072r 3               @1:
002072r 3                               ; if d was negative, negate the remainder (n2)
002072r 3  68                           pla
002073r 3  10 07                        bpl @done
002075r 3               
002075r 3  E8                           inx             ; pretend we pushed quotient to R
002076r 3  E8                           inx
002077r 3  20 rr rr                     jsr xt_negate
00207Ar 3  CA                           dex
00207Br 3  CA                           dex
00207Cr 3               
00207Cr 3               @done:
00207Cr 3  60           z_sm_slash_rem: rts
00207Dr 3               
00207Dr 3               
00207Dr 3               
00207Dr 3               ; ## SOURCE ( -- addr u ) "Return location and size of input buffer""
00207Dr 3               ; ## "source"  auto  ANS core
00207Dr 3                       ; """https://forth-standard.org/standard/core/SOURCE"""
00207Dr 3               xt_source:
00207Dr 3                               ; add address
00207Dr 3  CA                           dex
00207Er 3  CA                           dex
00207Fr 3  A5 rr                        lda cib
002081r 3  95 00                        sta 0,x
002083r 3  A5 rr                        lda cib+1
002085r 3  95 01                        sta 1,x
002087r 3               
002087r 3                               ; add size
002087r 3  CA                           dex
002088r 3  CA                           dex
002089r 3  A5 rr                        lda ciblen
00208Br 3  95 00                        sta 0,x
00208Dr 3  A5 rr                        lda ciblen+1
00208Fr 3  95 01                        sta 1,x
002091r 3               
002091r 3  60           z_source:       rts
002092r 3               
002092r 3               
002092r 3               ; ## SOURCE_ID ( -- n ) "Return source identifier"
002092r 3               ; ## "source-id"  tested  ANS core ext
002092r 3                       ; """https://forth-standard.org/standard/core/SOURCE-ID Identify the
002092r 3                       ; input source unless it is a block (s. Conklin & Rather p. 156). This
002092r 3                       ; will give the input source: 0 is keyboard, -1 ($FFFF) is character
002092r 3                       ; string, and a text file gives the fileid.
002092r 3                       ; """
002092r 3               xt_source_id:
002092r 3  CA                           dex
002093r 3  CA                           dex
002094r 3               
002094r 3  A5 rr                        lda insrc
002096r 3  95 00                        sta 0,x
002098r 3  A5 rr                        lda insrc+1
00209Ar 3  95 01                        sta 1,x
00209Cr 3               
00209Cr 3  60           z_source_id:    rts
00209Dr 3               
00209Dr 3               
00209Dr 3               ; ## SPACE ( -- ) "Print a single space"
00209Dr 3               ; ## "space"  auto  ANS core
00209Dr 3                       ; """https://forth-standard.org/standard/core/SPACE"""
00209Dr 3               xt_space:
00209Dr 3  A9 20                        lda #AscSP
00209Fr 3  20 rr rr                     jsr emit_a
0020A2r 3               
0020A2r 3  60           z_space:        rts
0020A3r 3               
0020A3r 3               
0020A3r 3               ; ## SPACES ( u -- ) "Print a number of spaces"
0020A3r 3               ; ## "spaces"  auto  ANS core
0020A3r 3                       ; """https://forth-standard.org/standard/core/SPACES"""
0020A3r 3               
0020A3r 3               xt_spaces:
0020A3r 3  20 rr rr                     jsr underflow_1
0020A6r 3               
0020A6r 3                               ; catch any zero in TOS fast
0020A6r 3  B5 00                        lda 0,x
0020A8r 3  15 01                        ora 1,x
0020AAr 3  F0 2A                        beq @done
0020ACr 3               
0020ACr 3                               ; Usually we're only going to print far less than 256 spaces,
0020ACr 3                               ; so we create a quick loop for that. Short loop could be realized
0020ACr 3                               ; as a separate subroutine, but unless we're really pressed for
0020ACr 3                               ; memory at some point, this is faster
0020ACr 3  B4 01                        ldy 1,x
0020AEr 3  D0 0C                        bne @lots_of_spaces
0020B0r 3               
0020B0r 3  B4 00                        ldy 0,x
0020B2r 3               @quick_loop:
0020B2r 3                               ; we reach here knowing that there must be a number that is not
0020B2r 3                               ; zero in the TOS
0020B2r 3  A9 20                        lda #AscSP
0020B4r 3  20 rr rr                     jsr emit_a
0020B7r 3  88                           dey
0020B8r 3  F0 1C                        beq @done
0020BAr 3  80 F6                        bra @quick_loop
0020BCr 3               
0020BCr 3               @lots_of_spaces:
0020BCr 3                               ; We go through the first loop once to get rid of the lower
0020BCr 3                               ; counter byte. This could be zero
0020BCr 3  B4 00                        ldy 0,x
0020BEr 3               
0020BEr 3               @first_slow_loop:
0020BEr 3  F0 08                        beq @slow_outer_loop
0020C0r 3  A9 20                        lda #AscSP
0020C2r 3  20 rr rr                     jsr emit_a
0020C5r 3  88                           dey
0020C6r 3  80 F6                        bra @first_slow_loop
0020C8r 3               
0020C8r 3               @slow_outer_loop:
0020C8r 3                               ; we arrive here knowing that the MSB of TOS cannot be a zero
0020C8r 3  A0 00                        ldy #00
0020CAr 3               
0020CAr 3               @slow_inner_loop:
0020CAr 3  A9 20                        lda #AscSP
0020CCr 3  20 rr rr                     jsr emit_a
0020CFr 3  88                           dey
0020D0r 3  D0 F8                        bne @slow_inner_loop
0020D2r 3               
0020D2r 3  D6 01                        dec 1,x
0020D4r 3  D0 F2                        bne @slow_outer_loop
0020D6r 3               
0020D6r 3               @done:
0020D6r 3  E8                           inx             ; drop
0020D7r 3  E8                           inx
0020D8r 3               
0020D8r 3  60           z_spaces:       rts
0020D9r 3               
0020D9r 3               
0020D9r 3               
0020D9r 3               ; ## STAR ( n n -- n ) "16*16 --> 16 "
0020D9r 3               ; ## "*"  auto  ANS core
0020D9r 3                       ; """https://forth-standard.org/standard/core/Times
0020D9r 3                       ; Multiply two signed 16 bit numbers, returning a 16 bit result.
0020D9r 3                       ;
0020D9r 3                       ; This is nothing  more than UM* DROP
0020D9r 3                       ; """
0020D9r 3               
0020D9r 3               xt_star:
0020D9r 3  20 rr rr                     jsr underflow_2
0020DCr 3               
0020DCr 3  20 rr rr                     jsr xt_um_star
0020DFr 3  E8                           inx
0020E0r 3  E8                           inx
0020E1r 3               
0020E1r 3  60           z_star:         rts
0020E2r 3               
0020E2r 3               
0020E2r 3               
0020E2r 3               ; ## STAR_SLASH  ( n1 n2 n3 -- n4 ) "n1 * n2 / n3 -->  n"
0020E2r 3               ; ## "*/"  auto  ANS core
0020E2r 3                       ; """https://forth-standard.org/standard/core/TimesDiv
0020E2r 3                       ; Multiply n1 by n2 and divide by n3, returning the result
0020E2r 3                       ; without a remainder. This is */MOD without the mod.
0020E2r 3                       ;
0020E2r 3                       ; This word
0020E2r 3                       ; can be defined in Forth as : */  */MOD SWAP DROP ; which is
0020E2r 3                       ; pretty much what we do here
0020E2r 3                       ; """
0020E2r 3               xt_star_slash:
0020E2r 3                               ; We let */MOD check for underflow
0020E2r 3  20 rr rr                     jsr xt_star_slash_mod
0020E5r 3  20 rr rr                     jsr xt_swap
0020E8r 3  E8                           inx
0020E9r 3  E8                           inx
0020EAr 3               z_star_slash:
0020EAr 3  60                           rts
0020EBr 3               
0020EBr 3               
0020EBr 3               ; ## STAR_SLASH_MOD  ( n1 n2 n3 -- n4 n5 ) "n1 * n2 / n3 --> n-mod n"
0020EBr 3               ; ## "*/mod"  auto  ANS core
0020EBr 3                       ; """https://forth-standard.org/standard/core/TimesDivMOD
0020EBr 3                       ; Multiply n1 by n2 producing the intermediate double-cell result d.
0020EBr 3                       ; Divide d by n3 producing the single-cell remainder n4 and the
0020EBr 3                       ; single-cell quotient n5.
0020EBr 3                       ;
0020EBr 3                       ; In Forth, this is
0020EBr 3                       ; : */MOD  >R M* >R SM/REM ;  Note that */ accesses this routine.
0020EBr 3                       ; """
0020EBr 3               xt_star_slash_mod:
0020EBr 3  20 rr rr                     jsr underflow_3
0020EEr 3               
0020EEr 3  20 rr rr                     jsr xt_to_r
0020F1r 3  20 rr rr                     jsr xt_m_star
0020F4r 3  20 rr rr                     jsr xt_r_from
0020F7r 3  20 rr rr                     jsr xt_sm_slash_rem
0020FAr 3               
0020FAr 3               z_star_slash_mod:
0020FAr 3  60                           rts
0020FBr 3               
0020FBr 3               
0020FBr 3               ; ## STATE ( -- addr ) "Return the address of compilation state flag"
0020FBr 3               ; ## "state"  auto  ANS core
0020FBr 3                       ; """https://forth-standard.org/standard/core/STATE
0020FBr 3                       ; STATE is true when in compilation state, false otherwise. Note
0020FBr 3                       ; we do not return the state itself, but only the address where
0020FBr 3                       ; it lives. The state should not be changed directly by the user; see
0020FBr 3                       ; http://forth.sourceforge.net/standard/dpans/dpans6.htm#6.1.2250
0020FBr 3                       ; """
0020FBr 3               xt_state:
0020FBr 3  CA                           dex
0020FCr 3  CA                           dex
0020FDr 3  A9 rr                        lda #<state
0020FFr 3  95 00                        sta 0,x
002101r 3  A9 rr                        lda #>state
002103r 3  95 01                        sta 1,x
002105r 3               
002105r 3  60           z_state:        rts
002106r 3               
002106r 3               
002106r 3               ; ## STORE ( n addr -- ) "Store TOS in memory"
002106r 3               ; ## "!"  auto  ANS core
002106r 3                       ; """https://forth-standard.org/standard/core/Store"""
002106r 3               xt_store:
002106r 3  20 rr rr                     jsr underflow_2
002109r 3               
002109r 3  B5 02                        lda 2,x         ; LSB
00210Br 3  81 00                        sta (0,x)
00210Dr 3               
00210Dr 3  F6 00                        inc 0,x
00210Fr 3  D0 02                        bne @1
002111r 3  F6 01                        inc 1,x
002113r 3               @1:
002113r 3  B5 03                        lda 3,x         ; MSB
002115r 3  81 00                        sta (0,x)
002117r 3               
002117r 3  E8                           inx             ; 2DROP
002118r 3  E8                           inx
002119r 3  E8                           inx
00211Ar 3  E8                           inx
00211Br 3               
00211Br 3  60           z_store:        rts
00211Cr 3               
00211Cr 3               
00211Cr 3               ; ## STRIP_UNDERFLOW ( -- addr ) "Return address where underflow status is kept"
00211Cr 3               ; ## "strip-underflow"  tested  Tali Forth
00211Cr 3                       ; """`STRIP-UNDERFLOW` is a flag variable that determines if underflow
00211Cr 3                       ; checking should be removed during the compilation of new words.
00211Cr 3                       ; Default is false.
00211Cr 3                       ; """
00211Cr 3               xt_strip_underflow:
00211Cr 3  CA                           dex
00211Dr 3  CA                           dex
00211Er 3               
00211Er 3  A9 rr                        lda #<uf_strip
002120r 3  95 00                        sta 0,x
002122r 3  A9 rr                        lda #>uf_strip
002124r 3  95 01                        sta 1,x
002126r 3               
002126r 3               z_strip_underflow:
002126r 3  60                           rts
002127r 3               
002127r 3               
002127r 3               ; ## SWAP ( b a -- a b ) "Exchange TOS and NOS"
002127r 3               ; ## "swap"  auto  ANS core
002127r 3                       ; """https://forth-standard.org/standard/core/SWAP"""
002127r 3               xt_swap:
002127r 3  20 rr rr                     jsr underflow_2
00212Ar 3               
00212Ar 3  B5 00                        lda 0,x         ; LSB
00212Cr 3  B4 02                        ldy 2,x
00212Er 3  95 02                        sta 2,x
002130r 3  94 00                        sty 0,x
002132r 3               
002132r 3  B5 01                        lda 1,x         ; MSB
002134r 3  B4 03                        ldy 3,x
002136r 3  95 03                        sta 3,x
002138r 3  94 01                        sty 1,x
00213Ar 3               
00213Ar 3  60           z_swap:         rts
00213Br 3               
00213Br 3               
00213Br 3               ; ## THEN (C: orig -- ) ( -- ) "Conditional flow control"
00213Br 3               ; ## "then"  auto  ANS core
00213Br 3                       ; """http://forth-standard.org/standard/core/THEN"""
00213Br 3               xt_then:
00213Br 3                               ; Get the address to jump to.
00213Br 3  20 rr rr                     jsr xt_here
00213Er 3               
00213Er 3                               ; Stuff HERE in for the branch address back
00213Er 3                               ; at the IF or ELSE (origination address is on stack).
00213Er 3  20 rr rr                     jsr xt_swap
002141r 3  20 rr rr                     jsr xt_store
002144r 3               
002144r 3  60           z_then:         rts
002145r 3               
002145r 3               
002145r 3               ; ## THRU ( scr# scr# -- ) "Load screens in the given range"
002145r 3               ; ## "thru"  tested  ANS block ext
002145r 3                       ; """https://forth-standard.org/standard/block/THRU"""
002145r 3               
002145r 3               xt_thru:
002145r 3  20 rr rr                     jsr underflow_2
002148r 3               
002148r 3                               ; We need to loop here, and can't use the data stack
002148r 3                               ; because the LOADed screens might use it.  We'll
002148r 3                               ; need to use the same trick that DO loops use, holding
002148r 3                               ; the limit and current index on the return stack.
002148r 3               
002148r 3                               ; Put the ending screen number on the return stack
002148r 3  B5 01                        lda 1,x
00214Ar 3  48                           pha
00214Br 3  B5 00                        lda 0,x
00214Dr 3  48                           pha
00214Er 3  E8                           inx
00214Fr 3  E8                           inx
002150r 3               @thru_loop:
002150r 3                               ; Put the starting screen number on the stack,
002150r 3                               ; but keep a copy
002150r 3  B5 01                        lda 1,x
002152r 3  48                           pha
002153r 3  B5 00                        lda 0,x
002155r 3  48                           pha
002156r 3               
002156r 3                               ; Load this screen.
002156r 3  20 rr rr                     jsr xt_load
002159r 3               
002159r 3                               ; Get the number and limit back off the stack.  Rather than
002159r 3                               ; waste time making room on the stack, just use tmp1 and tmp2.
002159r 3               
002159r 3                               ; Get the screen we just loaded.
002159r 3  68                           pla
00215Ar 3  85 rr                        sta tmp1
00215Cr 3  68                           pla
00215Dr 3  85 rr                        sta tmp1+1
00215Fr 3               
00215Fr 3                               ; Get the ending screen.
00215Fr 3  68                           pla
002160r 3  85 rr                        sta tmp2
002162r 3  68                           pla
002163r 3  85 rr                        sta tmp2+1
002165r 3               
002165r 3                               ; See if we just loaded the last screen.
002165r 3                               ; A already has the MSB of the last screen in it.
002165r 3  C5 rr                        cmp tmp1+1
002167r 3  D0 08                        bne @next_screen
002169r 3  A5 rr                        lda tmp2        ; Compare the LSB
00216Br 3  C5 rr                        cmp tmp1
00216Dr 3  D0 02                        bne @next_screen
00216Fr 3  80 18                        bra @done       ; We just did the last screen.
002171r 3               
002171r 3               @next_screen:
002171r 3                               ; Put the ending screen back on the data stack.
002171r 3  A5 rr                        lda tmp2+1
002173r 3  48                           pha
002174r 3  A5 rr                        lda tmp2
002176r 3  48                           pha
002177r 3               
002177r 3                               ; Increment the current screen.
002177r 3  E6 rr                        inc tmp1
002179r 3  D0 02                        bne @1
00217Br 3  E6 rr                        inc tmp1+1
00217Dr 3               @1:
00217Dr 3                               ; Put the current screen on the stack to prepare for
00217Dr 3                               ; the next loop.
00217Dr 3  CA                           dex
00217Er 3  CA                           dex
00217Fr 3  A5 rr                        lda tmp1
002181r 3  95 00                        sta 0,x
002183r 3  A5 rr                        lda tmp1+1
002185r 3  95 01                        sta 1,x
002187r 3  80 C7                        bra @thru_loop
002189r 3               @done:
002189r 3  60           z_thru:         rts
00218Ar 3               
00218Ar 3               
00218Ar 3               
00218Ar 3               ; ## TICK ( "name" -- xt ) "Return a word's execution token (xt)"
00218Ar 3               ; ## "'"  auto  ANS core
00218Ar 3                       ; """https://forth-standard.org/standard/core/Tick"""
00218Ar 3               
00218Ar 3               xt_tick:
00218Ar 3  20 rr rr                     jsr xt_parse_name       ; ( -- addr u )
00218Dr 3               
00218Dr 3                               ; if we got a zero, there was a problem getting the
00218Dr 3                               ; name of the word
00218Dr 3  B5 00                        lda 0,x
00218Fr 3  15 01                        ora 1,x
002191r 3  D0 05                        bne @1
002193r 3               
002193r 3  A9 05                        lda #err_noname
002195r 3  4C rr rr                     jmp error
002198r 3               @1:
002198r 3  20 rr rr                     jsr xt_find_name        ; ( addr u -- nt )
00219Br 3               
00219Br 3                               ; If we didn't find the word in the Dictionary, abort
00219Br 3  B5 00                        lda 0,x
00219Dr 3  15 01                        ora 1,x
00219Fr 3  D0 05                        bne @2
0021A1r 3               
0021A1r 3  A9 08                        lda #err_syntax
0021A3r 3  4C rr rr                     jmp error
0021A6r 3               @2:
0021A6r 3  20 rr rr                     jsr xt_name_to_int      ; ( nt -- xt )
0021A9r 3               
0021A9r 3  60           z_tick:         rts
0021AAr 3               
0021AAr 3               
0021AAr 3               
0021AAr 3               ; ## TO ( n "name" -- ) or ( "name") "Change a value"
0021AAr 3               ; ## "to"  auto  ANS core ext
0021AAr 3                       ; """https://forth-standard.org/standard/core/TO
0021AAr 3                       ; Gives a new value to a, uh, VALUE.
0021AAr 3                       ;
0021AAr 3                       ; One possible Forth
0021AAr 3                       ; implementation is  ' >BODY !  but given the problems we have
0021AAr 3                       ; with >BODY on STC Forths, we do this the hard way. Since
0021AAr 3                       ; Tali Forth uses the same code for CONSTANTs and VALUEs, you
0021AAr 3                       ; could use this to redefine a CONSTANT, but that is a no-no.
0021AAr 3                       ;
0021AAr 3                       ; Note that the standard has different behaviors for TO depending
0021AAr 3                       ; on the state (https://forth-standard.org/standard/core/TO).
0021AAr 3                       ; This makes TO state-dependent (which is bad) and also rather
0021AAr 3                       ; complex (see the Gforth implementation for comparison). This
0021AAr 3                       ; word may not be natively compiled and must be immediate. Frankly,
0021AAr 3                       ; it would have made more sense to have two words for this.
0021AAr 3                       ; """
0021AAr 3               
0021AAr 3               xt_to:
0021AAr 3                               ; One way or the other, we need the xt of the word after this
0021AAr 3                               ; one. At this point, we don't know if we are interpreted or
0021AAr 3                               ; compile, so we don't know if there is a value n on the stack,
0021AAr 3                               ; so we can't do an underflow check yet
0021AAr 3  20 rr rr                     jsr xt_tick             ; ( [n] xt )
0021ADr 3               
0021ADr 3                               ; The PFA (DFA in this case) is three bytes down,
0021ADr 3                               ; after the jump to DOCONST
0021ADr 3  B5 00                        lda 0,x                 ; LSB
0021AFr 3  18                           clc
0021B0r 3  69 03                        adc #3
0021B2r 3  85 rr                        sta tmp1
0021B4r 3  B5 01                        lda 1,x                 ; MSB
0021B6r 3  69 00                        adc #0                  ; we just want the carry
0021B8r 3  85 rr                        sta tmp1+1
0021BAr 3               
0021BAr 3  E8                           inx
0021BBr 3  E8                           inx                     ; ( [n] )
0021BCr 3               
0021BCr 3                               ; Now it gets ugly. See which state we are in
0021BCr 3  A5 rr                        lda state
0021BEr 3  05 rr                        ora state+1
0021C0r 3  F0 34                        beq @interpret
0021C2r 3               
0021C2r 3                               ; Well, we're compiling. We want to end up with simple
0021C2r 3                               ; code that just takes the number that is TOS and saves
0021C2r 3                               ; it in the address of the xt we were just given. So we
0021C2r 3                               ; want to compile this routine:
0021C2r 3                               ;
0021C2r 3                               ;       lda 0,x                 - B5 00
0021C2r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0021C2r 3                               ;       lda 1,x                 - B5 01
0021C2r 3                               ;       sta <ADDR_LSB>          - 8D LSB MSB
0021C2r 3                               ;       inx                     - E8
0021C2r 3                               ;       inx                     - E8
0021C2r 3                               ;
0021C2r 3                               ; which at least is nice and short. Other than that, we pretty
0021C2r 3                               ; much have to do this the hard and long way, because with the
0021C2r 3                               ; LSBs and MSBs, we can't really put the numbers in a data
0021C2r 3                               ; range and store them with a loop. Sigh.
0021C2r 3               
0021C2r 3  A0 00                        ldy #$00                ; Code for LDA 0,X
0021C4r 3  A9 B5                        lda #$B5
0021C6r 3  20 rr rr                     jsr cmpl_word
0021C9r 3               
0021C9r 3  A9 8D                        lda #$8D                ; Code for STA abs
0021CBr 3  20 rr rr                     jsr cmpl_a
0021CEr 3               
0021CEr 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
0021D0r 3  A5 rr                        lda tmp1
0021D2r 3  20 rr rr                     jsr cmpl_word
0021D5r 3               
0021D5r 3  A0 01                        ldy #$01                ; Code for LDA 1,X
0021D7r 3  A9 B5                        lda #$B5
0021D9r 3  20 rr rr                     jsr cmpl_word
0021DCr 3               
0021DCr 3  A9 8D                        lda #$8D                ; Code for STA abs
0021DEr 3  20 rr rr                     jsr cmpl_a
0021E1r 3               
0021E1r 3  E6 rr                        inc tmp1                ; Calculate MSB
0021E3r 3  D0 02                        bne @1
0021E5r 3  E6 rr                        inc tmp1+1
0021E7r 3               @1:
0021E7r 3  A4 rr                        ldy tmp1+1              ; MSB goes in Y
0021E9r 3  A5 rr                        lda tmp1
0021EBr 3  20 rr rr                     jsr cmpl_word
0021EEr 3               
0021EEr 3  A0 E8                        ldy #$E8                ; Code for INX
0021F0r 3  98                           tya
0021F1r 3  20 rr rr                     jsr cmpl_word
0021F4r 3               
0021F4r 3  80 0F                        bra @done
0021F6r 3               
0021F6r 3               @interpret:
0021F6r 3                               ; We're interpreting, so we arrive here with n
0021F6r 3                               ; on the stack. This is an annoying place to put
0021F6r 3                               ; the underflow check because we can't
0021F6r 3                               ; automatically strip it out
0021F6r 3  20 rr rr                     jsr underflow_1
0021F9r 3               
0021F9r 3                               ; We skip over the jump to DOCONST and store the number
0021F9r 3                               ; in the Program Field Area (PDF, in this case more a
0021F9r 3                               ; Data Field Area
0021F9r 3  B5 00                        lda 0,x
0021FBr 3  92 rr                        sta (tmp1)              ; LSB
0021FDr 3               
0021FDr 3  A0 01                        ldy #1
0021FFr 3  B5 01                        lda 1,x                 ; MSB
002201r 3  91 rr                        sta (tmp1),y            ; fall through to common
002203r 3               
002203r 3  E8                           inx                     ; DROP
002204r 3  E8                           inx
002205r 3               @done:
002205r 3  60           z_to:           rts
002206r 3               
002206r 3               
002206r 3               
002206r 3               ; ## TO_BODY ( xt -- addr ) "Return a word's Code Field Area (CFA)"
002206r 3               ; ## ">body"  auto  ANS core
002206r 3                       ; """https://forth-standard.org/standard/core/toBODY
002206r 3                       ; Given a word's execution token (xt), return the address of the
002206r 3                       ; start of that word's parameter field (PFA). This is defined as the
002206r 3                       ; address that HERE would return right after CREATE.
002206r 3                       ;
002206r 3                       ; This is a
002206r 3                       ; difficult word for STC Forths, because most words don't actually
002206r 3                       ; have a Code Field Area (CFA) to skip. We solve this by having CREATE
002206r 3                       ; add a flag, "has CFA" (HC), in the header so >BODY know to skip
002206r 3                       ; the subroutine jumps to DOVAR, DOCONST, or DODOES
002206r 3                       ; """
002206r 3               
002206r 3               xt_to_body:
002206r 3  20 rr rr                     jsr underflow_1
002209r 3               
002209r 3                               ; Ideally, xt already points to the CFA. We just need to check
002209r 3                               ; the HC flag for special cases
002209r 3  20 rr rr                     jsr xt_dup              ; ( xt xt )
00220Cr 3  20 rr rr                     jsr xt_int_to_name      ; ( xt nt )
00220Fr 3               
00220Fr 3                               ; The status byte is nt+1
00220Fr 3  F6 00                        inc 0,x
002211r 3  D0 02                        bne @1
002213r 3  F6 01                        inc 1,x
002215r 3               @1:
002215r 3  A1 00                        lda (0,x)               ; get status byte
002217r 3  29 20                        and #HC
002219r 3  F0 0D                        beq @no_cfa
00221Br 3               
00221Br 3                               ; We've got a DOVAR, DOCONST, DODEFER, DODOES or whatever,
00221Br 3                               ; so we add three to xt, which is NOS
00221Br 3  18                           clc
00221Cr 3  B5 02                        lda 2,x         ; LSB
00221Er 3  69 03                        adc #3
002220r 3  95 02                        sta 2,x
002222r 3  B5 03                        lda 3,x         ; MSB
002224r 3  69 00                        adc #0          ; we conly care about the carry
002226r 3  95 03                        sta 3,x         ; Fall through to @no_cfa
002228r 3               @no_cfa:
002228r 3  E8                           inx             ; get rid of the nt
002229r 3  E8                           inx
00222Ar 3               @done:
00222Ar 3  60           z_to_body:      rts
00222Br 3               
00222Br 3               
00222Br 3               
00222Br 3               ; ## TO_IN ( -- addr ) "Return address of the input pointer"
00222Br 3               ; ## ">in"  auto  ANS core
00222Br 3               xt_to_in:
00222Br 3  CA                           dex
00222Cr 3  CA                           dex
00222Dr 3               
00222Dr 3  A9 rr                        lda #<toin
00222Fr 3  95 00                        sta 0,x
002231r 3  A9 rr                        lda #>toin      ; paranoid, should be zero
002233r 3  95 01                        sta 1,x
002235r 3               
002235r 3  60           z_to_in:        rts
002236r 3               
002236r 3               
002236r 3               ; ## TO_NUMBER ( ud addr u -- ud addr u ) "Convert a number"
002236r 3               ; ## ">number"  auto  ANS core
002236r 3                       ; """https://forth-standard.org/standard/core/toNUMBER
002236r 3                       ; Convert a string to a double number. Logic here is based on the
002236r 3                       ; routine by Phil Burk of the same name in pForth, see
002236r 3                       ; https://github.com/philburk/pforth/blob/master/fth/numberio.fth
002236r 3                       ; for the original Forth code. We arrive here from NUMBER which has
002236r 3                       ; made sure that we don't have to deal with a sign and we don't have
002236r 3                       ; to deal with a dot as a last character that signalizes double -
002236r 3                       ; this should be a pure number string.
002236r 3                       ;
002236r 3                       ; This routine calles UM*, which uses tmp1, tmp2 and tmp3, so we
002236r 3                       ; cannot access any of those.
002236r 3                       ;
002236r 3                       ; For the math routine, we move the inputs to the scratchpad to
002236r 3                       ; avoid having to fool around with the Data Stack.
002236r 3                       ;
002236r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002236r 3                       ;     |   UD-LO   |   UD-HI   |     N     | UD-HI-LO  |
002236r 3                       ;     |           |           |           |           |
002236r 3                       ;     |  S    S+1 | S+2   S+3 | S+4   S+5 | S+6   S+7 |
002236r 3                       ;     +-----+-----+-----+-----+-----+-----+-----+-----+
002236r 3                       ;
002236r 3                       ; The math routine works by converting one character to its
002236r 3                       ; numerical value (N) via DIGIT? and storing it in S+4 for
002236r 3                       ; the moment. We then multiply the UD-HI value with the radix
002236r 3                       ; (from BASE) using UM*, which returns a double-cell result. We
002236r 3                       ; discard the high cell of that result (UD-HI-HI) and store the
002236r 3                       ; low cell (UD-HI-LO) in S+6 for now. -- The second part is
002236r 3                       ; multiplying UD-LO with the radix. The high cell (UD-LO-HI)
002236r 3                       ; gets put in S+2, the low cell (HD-LO-LO) in S. We then use
002236r 3                       ; a version of D+ to add ( S S+2 ) and ( S+4 S+6) together,
002236r 3                       ; storing the result back in S and S+2, before we start another
002236r 3                       ; round with it as the new UD-LO and UD-HI.
002236r 3                       ; """
002236r 3               
002236r 3               
002236r 3               xt_to_number:
002236r 3  20 rr rr                     jsr underflow_4
002239r 3               
002239r 3                               ; Fill the scratchpad. We arrive with ( ud-lo ud-hi addr u ).
002239r 3                               ; After this step, the original ud-lo and ud-hi will still be on
002239r 3                               ; the Data Stack, but will be ignored and later overwritten
002239r 3                               ; If >NUMBER is called by NUMBER, these should be all zeros
002239r 3  B5 06                        lda 6,x         ; ud-lo LSB
00223Br 3  85 rr                        sta scratch
00223Dr 3  B5 07                        lda 7,x         ; ud-lo MSB
00223Fr 3  85 rr                        sta scratch+1
002241r 3               
002241r 3  B5 04                        lda 4,x         ; ud-hi LSB
002243r 3  85 rr                        sta scratch+2
002245r 3  B5 05                        lda 5,x         ; ud-hi MSB
002247r 3  85 rr                        sta scratch+3
002249r 3               
002249r 3                               ; Push down one on the Data Stack to use TOS for character
002249r 3                               ; conversion ( ud-lo ud-hi addr u x )
002249r 3  CA                           dex
00224Ar 3  CA                           dex
00224Br 3               
00224Br 3               @loop:
00224Br 3                               ; Get one character based on address
00224Br 3  A1 04                        lda (4,x)
00224Dr 3  95 00                        sta 0,x                 ; ( ud-lo ud-hi addr u char )
00224Fr 3  74 01                        stz 1,x                 ; paranoid
002251r 3               
002251r 3  20 rr rr                     jsr xt_digit_question   ; ( char -- n -1 | char 0 )
002254r 3               
002254r 3                               ; This gives us ( ud-lo ud-hi addr u char f | n f ), so we
002254r 3                               ; check the flag. If it is zero, we return what we have and
002254r 3                               ; let the caller (usually NUMBER) complain
002254r 3  B5 00                        lda 0,x
002256r 3  D0 04                        bne @digit_ok
002258r 3               
002258r 3  E8                           inx
002259r 3  E8                           inx
00225Ar 3  80 67                        bra @done       ; ( ud-lo ud-hi addr u char )
00225Cr 3               
00225Cr 3               @digit_ok:
00225Cr 3                               ; Conversion was successful. We arrive here with
00225Cr 3                               ; ( ud-lo ud-hi addr u n -1 ) and can start the
00225Cr 3                               ; math routine
00225Cr 3               
00225Cr 3                               ; Save n so we don't have to fool around with the
00225Cr 3                               ; Data Stack
00225Cr 3  B5 02                        lda 2,x
00225Er 3  85 rr                        sta scratch+4
002260r 3  B5 03                        lda 3,x
002262r 3  85 rr                        sta scratch+5
002264r 3               
002264r 3                               ; Now multiply ud-hi (the one in the scratchpad, not the
002264r 3                               ; original one on the Data Stack) with the radix from BASE.
002264r 3                               ; We can clobber TOS and NOS because we saved n
002264r 3  A5 rr                        lda scratch+2
002266r 3  95 02                        sta 2,x         ; NOS
002268r 3  A5 rr                        lda scratch+3
00226Ar 3  95 03                        sta 3,x
00226Cr 3               
00226Cr 3  A5 rr                        lda base
00226Er 3  95 00                        sta 0,x         ; TOS
002270r 3  74 01                        stz 1,x         ; now ( ud-lo ud-hi addr u ud-hi base)
002272r 3               
002272r 3                               ; UM* returns a double-celled number
002272r 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-hi-lo ud-hi-hi )
002275r 3               
002275r 3                               ; Move ud-hi-lo to safety
002275r 3  B5 02                        lda 2,x         ; ud-hi-lo
002277r 3  85 rr                        sta scratch+6
002279r 3  B5 03                        lda 3,x
00227Br 3  85 rr                        sta scratch+7
00227Dr 3               
00227Dr 3                               ; Now we multiply ud-lo, overwriting the stack entries
00227Dr 3  A5 rr                        lda scratch
00227Fr 3  95 02                        sta 2,x
002281r 3  A5 rr                        lda scratch+1
002283r 3  95 03                        sta 3,x         ; ( ud-lo ud-hi addr u ud-lo ud-hi-hi )
002285r 3               
002285r 3  A5 rr                        lda base
002287r 3  95 00                        sta 0,x
002289r 3  74 01                        stz 1,x         ; ( ud-lo ud-hi addr u ud-lo base )
00228Br 3               
00228Br 3  20 rr rr                     jsr xt_um_star  ; ( ud-lo ud-hi addr u ud-lo-lo ud-lo-hi )
00228Er 3               
00228Er 3  B5 00                        lda 0,x
002290r 3  85 rr                        sta scratch+2
002292r 3  B5 01                        lda 1,x
002294r 3  85 rr                        sta scratch+3
002296r 3               
002296r 3  B5 02                        lda 2,x
002298r 3  85 rr                        sta scratch
00229Ar 3  B5 03                        lda 3,x
00229Cr 3  85 rr                        sta scratch+1
00229Er 3               
00229Er 3                               ; We add ud-lo and n, as well as ud-hi and ud-hi-lo,
00229Er 3                               ; both in the scratch pad
00229Er 3  18                           clc
00229Fr 3  A5 rr                        lda scratch     ; ud-lo LSB
0022A1r 3  65 rr                        adc scratch+4   ; n LSB
0022A3r 3  85 rr                        sta scratch     ; this is the new ud-lo
0022A5r 3  A5 rr                        lda scratch+1   ; ud-lo MSB
0022A7r 3  65 rr                        adc scratch+5   ; n MSB
0022A9r 3  85 rr                        sta scratch+1
0022ABr 3               
0022ABr 3  A5 rr                        lda scratch+2   ; LSB
0022ADr 3  65 rr                        adc scratch+6
0022AFr 3  85 rr                        sta scratch+2   ; this is the new ud-hi
0022B1r 3  A5 rr                        lda scratch+3   ; MSB
0022B3r 3  65 rr                        adc scratch+7
0022B5r 3  85 rr                        sta scratch+3
0022B7r 3               
0022B7r 3                               ; Clean up: Get rid of one of the two top elements on
0022B7r 3                               ; the Data Stack. We don't really care which one
0022B7r 3  E8                           inx
0022B8r 3  E8                           inx             ; ( ud-lo ud-hi addr u ud-lo-lo )
0022B9r 3               
0022B9r 3                               ; One character down. Move address up
0022B9r 3  F6 04                        inc 4,x
0022BBr 3  D0 02                        bne @1
0022BDr 3  F6 05                        inc 5,x
0022BFr 3               @1:
0022BFr 3                               ; Decrease counter
0022BFr 3  D6 02                        dec 2,x
0022C1r 3  D0 88                        bne @loop
0022C3r 3               
0022C3r 3               @done:
0022C3r 3                               ; Counter has reached zero or we have an error. In both
0022C3r 3                               ; cases, we clean up the Data Stack and return. Error gives
0022C3r 3                               ; us ( ud-lo ud-hi addr u char ), regular end is
0022C3r 3                               ; ( ud-lo ud-hi addr u ud-lo )
0022C3r 3  E8                           inx
0022C4r 3  E8                           inx             ; ( ud-lo ud-hi addr u )
0022C5r 3               
0022C5r 3                               ; The new ud-lo and ud-hi are still on the scratch pad
0022C5r 3  A5 rr                        lda scratch     ; new ud-lo
0022C7r 3  95 06                        sta 6,x
0022C9r 3  A5 rr                        lda scratch+1
0022CBr 3  95 07                        sta 7,x
0022CDr 3               
0022CDr 3  A5 rr                        lda scratch+2
0022CFr 3  95 04                        sta 4,x
0022D1r 3  A5 rr                        lda scratch+3
0022D3r 3  95 05                        sta 5,x
0022D5r 3               
0022D5r 3  60           z_to_number:    rts
0022D6r 3               
0022D6r 3               
0022D6r 3               
0022D6r 3               ; ## TO_ORDER ( wid -- ) "Add wordlist at beginning of search order"
0022D6r 3               ; ## ">order"  tested  Gforth search
0022D6r 3                       ; """https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Word-Lists.html"""
0022D6r 3               
0022D6r 3               xt_to_order:
0022D6r 3                               ; Put the wid on the return stack for now.
0022D6r 3  20 rr rr                     jsr xt_to_r
0022D9r 3               
0022D9r 3                               ; Get the current search order.
0022D9r 3  20 rr rr                     jsr xt_get_order
0022DCr 3               
0022DCr 3                               ; Get back the wid and add it to the list.
0022DCr 3  20 rr rr                     jsr xt_r_from
0022DFr 3  20 rr rr                     jsr xt_swap
0022E2r 3  20 rr rr                     jsr xt_one_plus
0022E5r 3               
0022E5r 3                               ; Set the search order with the new list.
0022E5r 3  20 rr rr                     jsr xt_set_order
0022E8r 3               
0022E8r 3  60           z_to_order:     rts
0022E9r 3               
0022E9r 3               
0022E9r 3               
0022E9r 3               ; ## TO_R ( n -- )(R: -- n) "Push TOS to the Return Stack"
0022E9r 3               ; ## ">r"  auto  ANS core
0022E9r 3                       ; """https://forth-standard.org/standard/core/toR
0022E9r 3                       ; This word is handled differently for native and for
0022E9r 3                       ; subroutine coding, see `COMPILE,`. This is a complile-only
0022E9r 3                       ; word.
0022E9r 3                       ; """
0022E9r 3               xt_to_r:
0022E9r 3                               ; Save the return address. If this word is natively
0022E9r 3                               ; coded, this is a complete waste of cycles, but
0022E9r 3                               ; required for subroutine coding
0022E9r 3  68                           pla             ; LSB
0022EAr 3  85 rr                        sta tmptos
0022ECr 3  7A                           ply             ; MSB
0022EDr 3               
0022EDr 3                               ; --- CUT HERE FOR NATIVE CODING ---
0022EDr 3               
0022EDr 3                               ; We check for underflow in the second step, so we can
0022EDr 3                               ; strip off the stack thrashing for native compiling first
0022EDr 3  20 rr rr                     jsr underflow_1
0022F0r 3               
0022F0r 3                               ; now we can do the actual work
0022F0r 3  B5 01                        lda 1,x         ; MSB
0022F2r 3  48                           pha
0022F3r 3  B5 00                        lda 0,x         ; LSB
0022F5r 3  48                           pha
0022F6r 3               
0022F6r 3  E8                           inx
0022F7r 3  E8                           inx
0022F8r 3               
0022F8r 3                               ; --- CUT HERE FOR NATIVE CODING ---
0022F8r 3               
0022F8r 3                               ; restore return address
0022F8r 3  5A                           phy             ; MSB
0022F9r 3  A5 rr                        lda tmptos
0022FBr 3  48                           pha             ; LSB
0022FCr 3               
0022FCr 3  60           z_to_r:         rts
0022FDr 3               
0022FDr 3               
0022FDr 3               ; ## TRUE ( -- f ) "Push TRUE flag to Data Stack"
0022FDr 3               ; ## "true"  auto  ANS core ext
0022FDr 3                       ; """https://forth-standard.org/standard/core/TRUE"""
0022FDr 3               xt_true:
0022FDr 3  CA                           dex
0022FEr 3  CA                           dex
0022FFr 3  A9 FF                        lda #$FF
002301r 3  95 00                        sta 0,x
002303r 3  95 01                        sta 1,x
002305r 3               
002305r 3  60           z_true:         rts
002306r 3               
002306r 3               
002306r 3               ; ## TUCK ( b a -- a b a ) "Copy TOS below NOS"
002306r 3               ; ## "tuck"  auto  ANS core ext
002306r 3                       ; """https://forth-standard.org/standard/core/TUCK"""
002306r 3               xt_tuck:
002306r 3  20 rr rr                     jsr underflow_2
002309r 3               
002309r 3  CA                           dex
00230Ar 3  CA                           dex
00230Br 3               
00230Br 3  B4 04                        ldy 4,x         ; LSB
00230Dr 3  B5 02                        lda 2,x
00230Fr 3  95 04                        sta 4,x
002311r 3  94 02                        sty 2,x
002313r 3  95 00                        sta 0,x
002315r 3               
002315r 3  B4 05                        ldy 5,x         ; MSB
002317r 3  B5 03                        lda 3,x
002319r 3  95 05                        sta 5,x
00231Br 3  94 03                        sty 3,x         ; bba
00231Dr 3  95 01                        sta 1,x         ; baa
00231Fr 3               
00231Fr 3  60           z_tuck:         rts
002320r 3               
002320r 3               
002320r 3               ; ## TWO ( -- u ) "Push the number 2 to stack"
002320r 3               ; ## "2"  auto  Tali Forth
002320r 3                       ;
002320r 3                       ; This code is shared with ASSEMBLER-WORDLIST
002320r 3               xt_assembler_wordlist:
002320r 3               xt_two:
002320r 3  CA                           dex
002321r 3  CA                           dex
002322r 3  A9 02                        lda #2
002324r 3  95 00                        sta 0,x
002326r 3  74 01                        stz 1,x
002328r 3               
002328r 3               z_assembler_wordlist:
002328r 3  60           z_two:          rts
002329r 3               
002329r 3               
002329r 3               ; ## TWO_DROP ( n n -- ) "Drop TOS and NOS"
002329r 3               ; ## "2drop"  auto  ANS core
002329r 3                       ; """https://forth-standard.org/standard/core/TwoDROP"""
002329r 3               xt_two_drop:
002329r 3  20 rr rr                     jsr underflow_2
00232Cr 3               
00232Cr 3  E8                           inx
00232Dr 3  E8                           inx
00232Er 3  E8                           inx
00232Fr 3  E8                           inx
002330r 3               
002330r 3  60           z_two_drop:     rts
002331r 3               
002331r 3               
002331r 3               ; ## TWO_DUP ( a b -- a b a b ) "Duplicate first two stack elements"
002331r 3               ; ## "2dup"  auto  ANS core
002331r 3                       ; """https://forth-standard.org/standard/core/TwoDUP"""
002331r 3               xt_two_dup:
002331r 3  20 rr rr                     jsr underflow_2
002334r 3               
002334r 3  CA                           dex
002335r 3  CA                           dex
002336r 3  CA                           dex
002337r 3  CA                           dex
002338r 3               
002338r 3  B5 04                        lda 4,x         ; TOS
00233Ar 3  95 00                        sta 0,x
00233Cr 3  B5 05                        lda 5,x
00233Er 3  95 01                        sta 1,x
002340r 3               
002340r 3  B5 06                        lda 6,x         ; NOS
002342r 3  95 02                        sta 2,x
002344r 3  B5 07                        lda 7,x
002346r 3  95 03                        sta 3,x
002348r 3               
002348r 3  60           z_two_dup:      rts
002349r 3               
002349r 3               
002349r 3               ; ## TWO_FETCH ( addr -- n1 n2 ) "Fetch the cell pair n1 n2 stored at addr"
002349r 3               ; ## "2@"  auto  ANS core
002349r 3                       ; """https://forth-standard.org/standard/core/TwoFetch
002349r 3                       ; Note n2 stored at addr and n1 in the next cell -- in our case,
002349r 3                       ; the next two bytes. This is equvalent to  `DUP CELL+ @ SWAP @`
002349r 3                       ; """
002349r 3               xt_two_fetch:
002349r 3  20 rr rr                     jsr underflow_1
00234Cr 3               
00234Cr 3  B5 00                        lda 0,x
00234Er 3  85 rr                        sta tmp1
002350r 3  B4 01                        ldy 1,x
002352r 3  84 rr                        sty tmp1+1
002354r 3               
002354r 3  CA                           dex             ; reuse one stack element
002355r 3  CA                           dex
002356r 3               
002356r 3  B2 rr                        lda (tmp1)      ; copy LSB
002358r 3  95 00                        sta 0,x
00235Ar 3  A0 01                        ldy #1          ; copy next
00235Cr 3  B1 rr                        lda (tmp1),y
00235Er 3  95 01                        sta 1,x
002360r 3  C8                           iny             ; copy next
002361r 3  B1 rr                        lda (tmp1),y
002363r 3  95 02                        sta 2,x
002365r 3  C8                           iny             ; copy next
002366r 3  B1 rr                        lda (tmp1),y
002368r 3  95 03                        sta 3,x
00236Ar 3               
00236Ar 3  60           z_two_fetch:    rts
00236Br 3               
00236Br 3               ; ## TWO_OVER ( d1 d2 -- d1 d2 d1 ) "Copy double word NOS to TOS"
00236Br 3               ; ## "2over"  auto  ANS core
00236Br 3                       ; """https://forth-standard.org/standard/core/TwoOVER"""
00236Br 3               xt_two_over:
00236Br 3  20 rr rr                     jsr underflow_4
00236Er 3               
00236Er 3  CA                           dex
00236Fr 3  CA                           dex
002370r 3  CA                           dex
002371r 3  CA                           dex
002372r 3               
002372r 3  B5 08                        lda 8,x
002374r 3  95 00                        sta 0,x
002376r 3               
002376r 3  B5 09                        lda 9,x
002378r 3  95 01                        sta 1,x
00237Ar 3               
00237Ar 3  B5 0A                        lda 10,x
00237Cr 3  95 02                        sta 2,x
00237Er 3               
00237Er 3  B5 0B                        lda 11,x
002380r 3  95 03                        sta 3,x
002382r 3               
002382r 3  60           z_two_over:     rts
002383r 3               
002383r 3               
002383r 3               ; ## TWO_R_FETCH ( -- n n ) "Copy top two entries from Return Stack"
002383r 3               ; ## "2r@"  auto  ANS core ext
002383r 3                       ; """https://forth-standard.org/standard/core/TwoRFetch
002383r 3                       ;
002383r 3                       ; This is R> R> 2DUP >R >R SWAP but we can do it a lot faster in
002383r 3                       ; assembler. We use trickery to access the elements on the Return
002383r 3                       ; Stack instead of pulling the return address first and storing
002383r 3                       ; it somewhere else like for 2R> and 2>R. In this version, we leave
002383r 3                       ; it as Never Native; at some point, we should compare versions to
002383r 3                       ; see if an Always Native version would be better
002383r 3                       ; """
002383r 3               xt_two_r_fetch:
002383r 3               		; make room on the Data Stack
002383r 3  CA                           dex
002384r 3  CA                           dex
002385r 3  CA                           dex
002386r 3  CA                           dex
002387r 3               
002387r 3                               ; Get four bytes off of Return Stack. This assumes that
002387r 3                               ; we took a subroutine jump here so the first two entries
002387r 3                               ; are the return address
002387r 3  8A                           txa
002388r 3  BA                           tsx
002389r 3  DA                           phx             ; 65c02 has no TXY, so do it the hard way
00238Ar 3  7A                           ply
00238Br 3  AA                           tax
00238Cr 3               
00238Cr 3                               ; The Return Stack addreses $0101 and $0102 are occupied by
00238Cr 3                               ; the return address for this word. This is a whole lot
00238Cr 3                               ; easier on the 65816
00238Cr 3  B9 03 01                     lda $0103,y     ; LSB of top entry
00238Fr 3  95 00                        sta 0,x
002391r 3  B9 04 01                     lda $0104,y     ; MSB of top entry
002394r 3  95 01                        sta 1,x
002396r 3  B9 05 01                     lda $0105,y     ; LSB of bottom entry
002399r 3  95 02                        sta 2,x
00239Br 3  B9 06 01                     lda $0106,y     ; MSB of top entry
00239Er 3  95 03                        sta 3,x
0023A0r 3               
0023A0r 3  60           z_two_r_fetch:  rts
0023A1r 3               
0023A1r 3               
0023A1r 3               ; ## TWO_R_FROM ( -- n1 n2 ) (R: n1 n2 -- ) "Pull two cells from Return Stack"
0023A1r 3               ; ## "2r>"  auto  ANS core ext
0023A1r 3               	    ; """https://forth-standard.org/standard/core/TwoRfrom
0023A1r 3                       ; Pull top two entries from Return Stack.
0023A1r 3                       ;
0023A1r 3                       ; Is the same as
0023A1r 3                       ; R> R> SWAP. As with R>, the problem with the is word is that
0023A1r 3                       ; the top value on the ReturnStack for a STC Forth is the
0023A1r 3                       ; return address, which we need to get out of the way first.
0023A1r 3                       ; Native compile needs to be handled as a special case.
0023A1r 3                       ; """
0023A1r 3               xt_two_r_from:
0023A1r 3                               ; save the return address
0023A1r 3  68                           pla                     ; LSB
0023A2r 3  85 rr                        sta tmp1
0023A4r 3  68                           pla                     ; MSB
0023A5r 3  85 rr                        sta tmp1+1
0023A7r 3               
0023A7r 3                               ; --- CUT HERE FOR NATIVE CODING ---
0023A7r 3               
0023A7r 3               		; make room on stack
0023A7r 3  CA                           dex
0023A8r 3  CA                           dex
0023A9r 3  CA                           dex
0023AAr 3  CA                           dex
0023ABr 3               
0023ABr 3                               ; In theory, we should test for underflow on the Return
0023ABr 3                               ; Stack. However, given the traffic there with an STC
0023ABr 3                               ; Forth, that's probably not really useful
0023ABr 3               
0023ABr 3                               ; now we can access the data
0023ABr 3  68                           pla                     ; LSB
0023ACr 3  95 00                        sta 0,x
0023AEr 3  68                           pla                     ; MSB
0023AFr 3  95 01                        sta 1,x
0023B1r 3               
0023B1r 3  68                           pla                     ; LSB
0023B2r 3  95 02                        sta 2,x
0023B4r 3  68                           pla                     ; MSB
0023B5r 3  95 03                        sta 3,x
0023B7r 3               
0023B7r 3                               ; --- CUT HERE FOR NATIVE CODING ---
0023B7r 3               
0023B7r 3                               ; restore return address
0023B7r 3  A5 rr                        lda tmp1+1              ; MSB
0023B9r 3  48                           pha
0023BAr 3  A5 rr                        lda tmp1                ; LSB
0023BCr 3  48                           pha
0023BDr 3               
0023BDr 3  60           z_two_r_from:   rts
0023BEr 3               
0023BEr 3               
0023BEr 3               ; ## TWO_SLASH ( n -- n ) "Divide TOS by two"
0023BEr 3               ; ## "2/"  auto  ANS core
0023BEr 3                       ; """https://forth-standard.org/standard/core/TwoDiv"""
0023BEr 3               xt_two_slash:
0023BEr 3  20 rr rr                     jsr underflow_1
0023C1r 3               
0023C1r 3                               ; We can't just LSR the LSB and ROR the MSB because that
0023C1r 3                               ; would do bad things to the sign
0023C1r 3  B5 01                        lda 1,x
0023C3r 3  0A                           asl                     ; save the sign
0023C4r 3  76 01                        ror 1,x
0023C6r 3  76 00                        ror 0,x
0023C8r 3               
0023C8r 3  60           z_two_slash:    rts
0023C9r 3               
0023C9r 3               
0023C9r 3               ; ## TWO_STAR ( n -- n ) "Multiply TOS by two"
0023C9r 3               ; ## "2*"  auto  ANS core
0023C9r 3                       ; """https://forth-standard.org/standard/core/TwoTimes
0023C9r 3                       ;
0023C9r 3                       ; Also used for CELLS
0023C9r 3                       ; """
0023C9r 3               xt_two_star:
0023C9r 3               xt_cells:
0023C9r 3  20 rr rr                     jsr underflow_1
0023CCr 3               
0023CCr 3  16 00                        asl 0,x
0023CEr 3  36 01                        rol 1,x
0023D0r 3               z_cells:
0023D0r 3  60           z_two_star:     rts
0023D1r 3               
0023D1r 3               
0023D1r 3               ; ## TWO_STORE ( n1 n2 addr -- ) "Store two numbers at given address"
0023D1r 3               ; ## "2!"  auto  ANS core
0023D1r 3                       ; """https://forth-standard.org/standard/core/TwoStore
0023D1r 3                       ; Stores so n2 goes to addr and n1 to the next consecutive cell.
0023D1r 3                       ; Is equivalent to  `SWAP OVER ! CELL+ !`
0023D1r 3                       ; """
0023D1r 3               xt_two_store:
0023D1r 3  20 rr rr                     jsr underflow_3
0023D4r 3               
0023D4r 3  B5 00                        lda 0,x
0023D6r 3  85 rr                        sta tmp1
0023D8r 3  B4 01                        ldy 1,x
0023DAr 3  84 rr                        sty tmp1+1
0023DCr 3               
0023DCr 3  E8                           inx
0023DDr 3  E8                           inx
0023DEr 3               
0023DEr 3  B5 00                        lda 0,x         ; copy MSB
0023E0r 3  92 rr                        sta (tmp1)
0023E2r 3  B5 01                        lda 1,x         ; copy next
0023E4r 3  A0 01                        ldy #1
0023E6r 3  91 rr                        sta (tmp1),y
0023E8r 3  B5 02                        lda 2,x         ; copy next
0023EAr 3  C8                           iny
0023EBr 3  91 rr                        sta (tmp1),y
0023EDr 3  B5 03                        lda 3,x         ; copy MSB
0023EFr 3  C8                           iny
0023F0r 3  91 rr                        sta (tmp1),y
0023F2r 3               
0023F2r 3  E8                           inx             ; 2DROP
0023F3r 3  E8                           inx
0023F4r 3  E8                           inx
0023F5r 3  E8                           inx
0023F6r 3               
0023F6r 3  60           z_two_store:    rts
0023F7r 3               
0023F7r 3               
0023F7r 3               ; ## TWO_SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n1 ) "Exchange two double words"
0023F7r 3               ; ## "2swap"  auto  ANS core
0023F7r 3                       ; """https://forth-standard.org/standard/core/TwoSWAP"""
0023F7r 3               xt_two_swap:
0023F7r 3  20 rr rr                     jsr underflow_4
0023FAr 3               
0023FAr 3                               ; 0 <-> 4
0023FAr 3  B5 00                        lda 0,x
0023FCr 3  B4 04                        ldy 4,x
0023FEr 3  95 04                        sta 4,x
002400r 3  94 00                        sty 0,x
002402r 3               
002402r 3                               ; 1 <-> 5
002402r 3  B5 01                        lda 1,x
002404r 3  B4 05                        ldy 5,x
002406r 3  95 05                        sta 5,x
002408r 3  94 01                        sty 1,x
00240Ar 3               
00240Ar 3                               ; 2 <-> 6
00240Ar 3  B5 02                        lda 2,x
00240Cr 3  B4 06                        ldy 6,x
00240Er 3  95 06                        sta 6,x
002410r 3  94 02                        sty 2,x
002412r 3               
002412r 3                               ; 3 <-> 7
002412r 3  B5 03                        lda 3,x
002414r 3  B4 07                        ldy 7,x
002416r 3  95 07                        sta 7,x
002418r 3  94 03                        sty 3,x
00241Ar 3               
00241Ar 3  60           z_two_swap:     rts
00241Br 3               
00241Br 3               
00241Br 3               ; ## TWO_TO_R ( n1 n2 -- )(R: -- n1 n2 "Push top two entries to Return Stack"
00241Br 3               ; ## "2>r"  auto  ANS core ext
00241Br 3                       ; """https://forth-standard.org/standard/core/TwotoR
00241Br 3                       ; Push top two entries to Return Stack.
00241Br 3                       ;
00241Br 3                       ; The same as SWAP >R >R
00241Br 3                       ; except that if we jumped here, the return address will be in the
00241Br 3                       ; way. May not be natively compiled unless we're clever and use
00241Br 3                       ; special routines.
00241Br 3                       ; """
00241Br 3               xt_two_to_r:
00241Br 3                               ; save the return address
00241Br 3  68                           pla             ; LSB
00241Cr 3  85 rr                        sta tmp1
00241Er 3  68                           pla             ; MSB
00241Fr 3  85 rr                        sta tmp1+1
002421r 3               
002421r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002421r 3               
002421r 3  20 rr rr                     jsr underflow_2
002424r 3               
002424r 3                               ; now we can move the data
002424r 3  B5 03                        lda 3,x         ; MSB
002426r 3  48                           pha
002427r 3  B5 02                        lda 2,x         ; LSB
002429r 3  48                           pha
00242Ar 3               
00242Ar 3                               ; now we can move the data
00242Ar 3  B5 01                        lda 1,x         ; MSB
00242Cr 3  48                           pha
00242Dr 3  B5 00                        lda 0,x         ; LSB
00242Fr 3  48                           pha
002430r 3               
002430r 3  E8                           inx
002431r 3  E8                           inx
002432r 3  E8                           inx
002433r 3  E8                           inx
002434r 3               
002434r 3                               ; --- CUT HERE FOR NATIVE CODING ---
002434r 3               
002434r 3                               ; restore return address
002434r 3  A5 rr                        lda tmp1+1      ; MSB
002436r 3  48                           pha
002437r 3  A5 rr                        lda tmp1        ; LSB
002439r 3  48                           pha
00243Ar 3               
00243Ar 3  60           z_two_to_r:     rts
00243Br 3               
00243Br 3               
00243Br 3               ; ## TWO_CONSTANT (C: d "name" -- ) ( -- d) "Create a constant for a double word"
00243Br 3               ; ## "2constant"  auto  ANS double
00243Br 3                       ; """https://forth-standard.org/standard/double/TwoCONSTANT
00243Br 3                       ;
00243Br 3                       ; Based on the Forth code
00243Br 3                       ; : 2CONSTANT ( D -- )  CREATE SWAP , , DOES> DUP @ SWAP CELL+ @ ;
00243Br 3                       ; """
00243Br 3               xt_two_constant:
00243Br 3  20 rr rr                     jsr underflow_2
00243Er 3               
00243Er 3  20 rr rr                     jsr xt_create
002441r 3  20 rr rr                     jsr xt_swap
002444r 3  20 rr rr                     jsr xt_comma
002447r 3  20 rr rr                     jsr xt_comma
00244Ar 3               
00244Ar 3  20 rr rr                     jsr does_runtime    ; does> turns into these two routines.
00244Dr 3  20 rr rr                     jsr dodoes
002450r 3               
002450r 3  20 rr rr                     jsr xt_dup
002453r 3  20 rr rr                     jsr xt_fetch
002456r 3  20 rr rr                     jsr xt_swap
002459r 3  20 rr rr                     jsr xt_cell_plus
00245Cr 3  20 rr rr                     jsr xt_fetch
00245Fr 3               
00245Fr 3  60           z_two_constant: rts
002460r 3               
002460r 3               
002460r 3               ; ## TWO_LITERAL (C: d -- ) ( -- d) "Compile a literal double word"
002460r 3               ; ## "2literal"  auto  ANS double
002460r 3                       ; """https://forth-standard.org/standard/double/TwoLITERAL"""
002460r 3                       ; Based on the Forth code
002460r 3                       ; : 2LITERAL ( D -- ) SWAP POSTPONE LITERAL POSTPONE LITERAL ; IMMEDIATE
002460r 3                       ; """
002460r 3               xt_two_literal:
002460r 3  20 rr rr                     jsr underflow_2 ; double number
002463r 3               
002463r 3  20 rr rr                     jsr xt_swap
002466r 3  20 rr rr                     jsr xt_literal
002469r 3  20 rr rr                     jsr xt_literal
00246Cr 3               
00246Cr 3  60           z_two_literal:  rts
00246Dr 3               
00246Dr 3               
00246Dr 3               ; ## TWO_VARIABLE ( "name" -- ) "Create a variable for a double word"
00246Dr 3               ; ## "2variable"  auto  ANS double
00246Dr 3                       ; """https://forth-standard.org/standard/double/TwoVARIABLE
00246Dr 3                       ; The variable is not initialized to zero.
00246Dr 3                       ;
00246Dr 3                       ; This can be realized in Forth as either
00246Dr 3                       ; CREATE 2 CELLS ALLOT  or just  CREATE 0 , 0 ,
00246Dr 3                       ; """
00246Dr 3               xt_two_variable:
00246Dr 3                               ; We just let CRATE and ALLOT do the heavy lifting
00246Dr 3  20 rr rr                     jsr xt_create
002470r 3               
002470r 3  CA                           dex
002471r 3  CA                           dex
002472r 3  A9 04                        lda #4
002474r 3  95 00                        sta 0,x
002476r 3  74 01                        stz 1,x
002478r 3               
002478r 3  20 rr rr                     jsr xt_allot
00247Br 3               
00247Br 3  60           z_two_variable: rts
00247Cr 3               
00247Cr 3               
00247Cr 3               ; ## TYPE ( addr u -- ) "Print string"
00247Cr 3               ; ## "type"  auto  ANS core
00247Cr 3                       ; """https://forth-standard.org/standard/core/TYPE
00247Cr 3                       ; Works through EMIT to allow OUTPUT revectoring.
00247Cr 3                       ; """
00247Cr 3               
00247Cr 3               xt_type:
00247Cr 3  20 rr rr                     jsr underflow_2
00247Fr 3               
00247Fr 3                               ; Save the starting address into tmp1
00247Fr 3  B5 02                        lda 2,x
002481r 3  85 rr                        sta tmp1
002483r 3  B5 03                        lda 3,x
002485r 3  85 rr                        sta tmp1+1
002487r 3               @loop:
002487r 3                               ; done if length is zero
002487r 3  B5 00                        lda 0,x
002489r 3  15 01                        ora 1,x
00248Br 3  F0 15                        beq @done
00248Dr 3               
00248Dr 3                               ; Send the current character
00248Dr 3  B2 rr                        lda (tmp1)
00248Fr 3  20 rr rr                     jsr emit_a      ; avoids stack foolery
002492r 3               
002492r 3                               ; Move the address along (in tmp1)
002492r 3  E6 rr                        inc tmp1
002494r 3  D0 02                        bne @1
002496r 3  E6 rr                        inc tmp1+1
002498r 3               @1:
002498r 3                               ; Reduce the count (on the data stack)
002498r 3  B5 00                        lda 0,x
00249Ar 3  D0 02                        bne @2
00249Cr 3  D6 01                        dec 1,x
00249Er 3               @2:
00249Er 3  D6 00                        dec 0,x
0024A0r 3               
0024A0r 3  80 E5                        bra @loop
0024A2r 3               @done:
0024A2r 3  E8                           inx
0024A3r 3  E8                           inx
0024A4r 3  E8                           inx
0024A5r 3  E8                           inx
0024A6r 3               
0024A6r 3  60           z_type:         rts
0024A7r 3               
0024A7r 3               
0024A7r 3               
0024A7r 3               ; ## U_DOT ( u -- ) "Print TOS as unsigned number"
0024A7r 3               ; ## "u."  tested  ANS core
0024A7r 3                       ; """https://forth-standard.org/standard/core/Ud
0024A7r 3                       ;
0024A7r 3                       ; This is : U. 0 <# #S #> TYPE SPACE ; in Forth
0024A7r 3                       ; We use the internal assembler function print_u followed
0024A7r 3                       ; by a single space
0024A7r 3                       ; """
0024A7r 3               xt_u_dot:
0024A7r 3  20 rr rr                     jsr underflow_1
0024AAr 3               
0024AAr 3  20 rr rr                     jsr print_u
0024ADr 3  A9 20                        lda #AscSP
0024AFr 3  20 rr rr                     jsr emit_a
0024B2r 3               
0024B2r 3  60           z_u_dot:        rts
0024B3r 3               
0024B3r 3               
0024B3r 3               ; ## U_DOT_R ( u u -- ) "Print NOS as unsigned number right-justified with TOS width"
0024B3r 3               ; ## "u.r"  tested  ANS core ext
0024B3r 3                       ; """https://forth-standard.org/standard/core/UDotR"""
0024B3r 3               xt_u_dot_r:
0024B3r 3  20 rr rr                     jsr underflow_2
0024B6r 3               
0024B6r 3  20 rr rr                     jsr xt_to_r
0024B9r 3  20 rr rr                     jsr xt_zero
0024BCr 3  20 rr rr                     jsr xt_less_number_sign
0024BFr 3  20 rr rr                     jsr xt_number_sign_s
0024C2r 3  20 rr rr                     jsr xt_number_sign_greater
0024C5r 3  20 rr rr                     jsr xt_r_from
0024C8r 3  20 rr rr                     jsr xt_over
0024CBr 3  20 rr rr                     jsr xt_minus
0024CEr 3  20 rr rr                     jsr xt_spaces
0024D1r 3  20 rr rr                     jsr xt_type
0024D4r 3               
0024D4r 3  60           z_u_dot_r:      rts
0024D5r 3               
0024D5r 3               
0024D5r 3               ; ## U_GREATER_THAN ( n m -- f ) "Return true if NOS > TOS (unsigned)"
0024D5r 3               ; ## "u>"  auto  ANS core ext
0024D5r 3                       ; """https://forth-standard.org/standard/core/Umore"""
0024D5r 3               xt_u_greater_than:
0024D5r 3  20 rr rr                     jsr underflow_2
0024D8r 3               
0024D8r 3  B5 00                        lda 0,x
0024DAr 3  D5 02                        cmp 2,x
0024DCr 3  B5 01                        lda 1,x
0024DEr 3  F5 03                        sbc 3,x
0024E0r 3  E8                           inx
0024E1r 3  E8                           inx
0024E2r 3               
0024E2r 3  A9 00                        lda #0
0024E4r 3  69 FF                        adc #$ff
0024E6r 3  95 00                        sta 0,x         ; store flag
0024E8r 3  95 01                        sta 1,x
0024EAr 3               
0024EAr 3  60           z_u_greater_than:    rts
0024EBr 3               
0024EBr 3               ; ## U_LESS_THAN ( n m -- f ) "Return true if NOS < TOS (unsigned)"
0024EBr 3               ; ## "u<"  auto  ANS core
0024EBr 3                       ; """https://forth-standard.org/standard/core/Uless"""
0024EBr 3               xt_u_less_than:
0024EBr 3  20 rr rr                     jsr underflow_2
0024EEr 3               
0024EEr 3  B5 02                        lda 2,x
0024F0r 3  D5 00                        cmp 0,x
0024F2r 3  B5 03                        lda 3,x
0024F4r 3  F5 01                        sbc 1,x
0024F6r 3  E8                           inx
0024F7r 3  E8                           inx
0024F8r 3               
0024F8r 3  A9 00                        lda #0
0024FAr 3  69 FF                        adc #$ff
0024FCr 3  95 00                        sta 0,x         ; store flag
0024FEr 3  95 01                        sta 1,x
002500r 3               
002500r 3  60           z_u_less_than:    rts
002501r 3               
002501r 3               
002501r 3               ; ## UD_DOT ( d -- ) "Print double as unsigned"
002501r 3               ; ## "ud."  auto  Tali double
002501r 3                       ;
002501r 3                       ; """Based on the Forth code  : UD. <# #S #> TYPE SPACE ;
002501r 3                       ; """
002501r 3               xt_ud_dot:
002501r 3  20 rr rr                     jsr underflow_2 ; double number
002504r 3               
002504r 3  20 rr rr                     jsr xt_less_number_sign
002507r 3  20 rr rr                     jsr xt_number_sign_s
00250Ar 3  20 rr rr                     jsr xt_number_sign_greater
00250Dr 3  20 rr rr                     jsr xt_type
002510r 3  20 rr rr                     jsr xt_space
002513r 3               
002513r 3  60           z_ud_dot:        rts
002514r 3               
002514r 3               
002514r 3               ; ## UD_DOT_R ( d u -- ) "Print unsigned double right-justified u wide"
002514r 3               ; ## "ud.r"  auto  Tali double
002514r 3                       ;
002514r 3                       ; """Based on the Forth code : UD.R  >R <# #S #> R> OVER - SPACES TYPE ;
002514r 3                       ; """
002514r 3               xt_ud_dot_r:
002514r 3  20 rr rr                     jsr underflow_3
002517r 3               
002517r 3  20 rr rr                     jsr xt_to_r
00251Ar 3  20 rr rr                     jsr xt_less_number_sign
00251Dr 3  20 rr rr                     jsr xt_number_sign_s
002520r 3  20 rr rr                     jsr xt_number_sign_greater
002523r 3  20 rr rr                     jsr xt_r_from
002526r 3  20 rr rr                     jsr xt_over
002529r 3  20 rr rr                     jsr xt_minus
00252Cr 3  20 rr rr                     jsr xt_spaces
00252Fr 3  20 rr rr                     jsr xt_type
002532r 3               
002532r 3  60           z_ud_dot_r:      rts
002533r 3               
002533r 3               
002533r 3               ; ## UM_SLASH_MOD ( ud u -- ur u ) "32/16 -> 16 division"
002533r 3               ; ## "um/mod"  auto  ANS core
002533r 3                       ; """https://forth-standard.org/standard/core/UMDivMOD
002533r 3                       ; Divide double cell number by single cell number, returning the
002533r 3                       ; quotient as TOS and any remainder as NOS. All numbers are unsigned.
002533r 3                       ; This is the basic division operation all others use. Based on FIG
002533r 3                       ; Forth code, modified by Garth Wilson, see
002533r 3                       ; http://6502.org/source/integers/ummodfix/ummodfix.htm
002533r 3                       ;
002533r 3                       ; This uses tmp1, tmp1+1, and tmptos
002533r 3                       ; """
002533r 3               
002533r 3               xt_um_slash_mod:
002533r 3  20 rr rr                     jsr underflow_3
002536r 3               
002536r 3                               ; catch division by zero
002536r 3  B5 00                        lda 0,x
002538r 3  15 01                        ora 1,x
00253Ar 3  D0 05                        bne @not_zero
00253Cr 3               
00253Cr 3  A9 04                        lda #err_divzero
00253Er 3  4C rr rr                     jmp error
002541r 3               
002541r 3               @not_zero:
002541r 3                               ; We loop 17 times
002541r 3  A9 11                        lda #17
002543r 3  85 rr                        sta tmptos
002545r 3               
002545r 3               @loop:
002545r 3                               ; rotate low cell of dividend one bit left (LSB)
002545r 3  36 04                        rol 4,x
002547r 3  36 05                        rol 5,x
002549r 3               
002549r 3                               ; loop control
002549r 3  C6 rr                        dec tmptos
00254Br 3  F0 22                        beq @done
00254Dr 3               
00254Dr 3                               ; rotate high cell of dividend one bit left (MSB)
00254Dr 3  36 02                        rol 2,x
00254Fr 3  36 03                        rol 3,x
002551r 3               
002551r 3  64 rr                        stz tmp1        ; store the bit we got from hi cell (MSB)
002553r 3  26 rr                        rol tmp1
002555r 3               
002555r 3                               ; subtract dividend hi cell minus divisor
002555r 3  38                           sec
002556r 3  B5 02                        lda 2,x
002558r 3  F5 00                        sbc 0,x
00255Ar 3  85 rr                        sta tmp1+1
00255Cr 3  B5 03                        lda 3,x
00255Er 3  F5 01                        sbc 1,x
002560r 3               
002560r 3  A8                           tay
002561r 3  A5 rr                        lda tmp1
002563r 3  E9 00                        sbc #0
002565r 3  90 DE                        bcc @loop
002567r 3               
002567r 3                               ; make result new dividend high cell
002567r 3  A5 rr                        lda tmp1+1
002569r 3  95 02                        sta 2,x
00256Br 3  94 03                        sty 3,x         ; used as temp storage
00256Dr 3               
00256Dr 3  80 D6                        bra @loop
00256Fr 3               @done:
00256Fr 3  E8                           inx
002570r 3  E8                           inx
002571r 3               
002571r 3  20 rr rr                     jsr xt_swap
002574r 3               
002574r 3  60           z_um_slash_mod: rts
002575r 3               
002575r 3               
002575r 3               
002575r 3               ; ## UM_STAR ( u u -- ud ) "Multiply 16 x 16 -> 32"
002575r 3               ; ## "um*"  auto  ANS core
002575r 3                       ; """https://forth-standard.org/standard/core/UMTimes
002575r 3                       ; Multiply two unsigned 16 bit numbers, producing a 32 bit result.
002575r 3                       ; Old Forth versions such as FIG Forth call this U*
002575r 3                       ;
002575r 3                       ; This is based on modified FIG Forth code by Dr. Jefyll, see
002575r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689 for a detailed
002575r 3                       ; discussion.
002575r 3                       ;
002575r 3                       ; We don't use the system scratch pad (SYSPAD) for temp
002575r 3                       ; storage because >NUMBER uses it as well, but instead tmp1 to
002575r 3                       ; tmp3 (tmp1 is N in the original code, tmp1+1 is N+1, etc).
002575r 3                       ;
002575r 3                       ; Consider switching to a table-supported version based on
002575r 3                       ; http://codebase64.org/doku.php?id=base:seriously_fast_multiplication
002575r 3                       ; http://codebase64.org/doku.php?id=magazines:chacking16#d_graphics_for_the_masseslib3d>
002575r 3                       ; http://forum.6502.org/viewtopic.php?p=205#p205
002575r 3                       ; http://forum.6502.org/viewtopic.php?f=9&t=689
002575r 3                       ; """
002575r 3               
002575r 3               xt_um_star:
002575r 3  20 rr rr                     jsr underflow_2
002578r 3               
002578r 3                               ; to eliminate clc inside the loop, the value at
002578r 3                               ; tmp1 is reduced by 1 in advance
002578r 3  18                           clc
002579r 3  B5 00                        lda 0,x         ; copy TOS to tmp2
00257Br 3  E9 00                        sbc #0
00257Dr 3  85 rr                        sta tmp2
00257Fr 3               
00257Fr 3  B5 01                        lda 1,x
002581r 3  E9 00                        sbc #0
002583r 3  90 31                        bcc @zero       ; is TOS zero?
002585r 3  85 rr                        sta tmp2+1
002587r 3               
002587r 3  A9 00                        lda #0
002589r 3  85 rr                        sta tmp1
00258Br 3  86 rr                        stx tmp3        ; tested for exit from outer loop
00258Dr 3  CA                           dex
00258Er 3  CA                           dex
00258Fr 3               
00258Fr 3               @outer_loop:
00258Fr 3  A0 08                        ldy #8          ; counter inner loop
002591r 3  56 04                        lsr 4,x         ; think "2,x" then later "3,x"
002593r 3               
002593r 3               @inner_loop:
002593r 3  90 0C                        bcc @no_add
002595r 3  85 rr                        sta tmp1+1      ; save time, don't CLC
002597r 3  A5 rr                        lda tmp1
002599r 3  65 rr                        adc tmp2
00259Br 3  85 rr                        sta tmp1
00259Dr 3  A5 rr                        lda tmp1+1
00259Fr 3  65 rr                        adc tmp2+1
0025A1r 3               
0025A1r 3               @no_add:
0025A1r 3  6A                           ror
0025A2r 3  66 rr                        ror tmp1
0025A4r 3  76 04                        ror 4,x         ; think "2,x" then later "3,x"
0025A6r 3               
0025A6r 3  88                           dey
0025A7r 3  D0 EA                        bne @inner_loop ; go back for one more shift?
0025A9r 3               
0025A9r 3  E8                           inx
0025AAr 3  E4 rr                        cpx tmp3
0025ACr 3  D0 E1                        bne @outer_loop ; go back for eight more shifts?
0025AEr 3               
0025AEr 3                               ; all done, store high word of result
0025AEr 3  95 01                        sta 1,x
0025B0r 3  A5 rr                        lda tmp1
0025B2r 3  95 00                        sta 0,x
0025B4r 3  80 04                        bra @done
0025B6r 3               
0025B6r 3               @zero:
0025B6r 3  74 02                        stz 2,x
0025B8r 3  74 03                        stz 3,x
0025BAr 3               @done:
0025BAr 3  60           z_um_star:      rts
0025BBr 3               
0025BBr 3               
0025BBr 3               
0025BBr 3               ; ## UNLOOP ( -- )(R: n1 n2 n3 ---) "Drop loop control from Return stack"
0025BBr 3               ; ## "unloop"  auto  ANS core
0025BBr 3                       ; """https://forth-standard.org/standard/core/UNLOOP
0025BBr 3                       ;
0025BBr 3                       ; Note that 6xPLA uses just as many bytes as a loop would
0025BBr 3                       ; """
0025BBr 3               xt_unloop:
0025BBr 3                               ; Drop fudge number (limit/start from DO/?DO off the
0025BBr 3                               ; return stack
0025BBr 3  68                           pla
0025BCr 3  68                           pla
0025BDr 3  68                           pla
0025BEr 3  68                           pla
0025BFr 3               
0025BFr 3                               ; Now drop the LEAVE address that was below them off
0025BFr 3                               ; the Return Stack as well
0025BFr 3  68                           pla
0025C0r 3  68                           pla
0025C1r 3               
0025C1r 3  60           z_unloop:       rts
0025C2r 3               
0025C2r 3               
0025C2r 3               ; ## UNTIL (C: dest -- ) ( -- ) "Loop flow control"
0025C2r 3               ; ## "until"  auto  ANS core
0025C2r 3                       ; """http://forth-standard.org/standard/core/UNTIL"""
0025C2r 3               xt_until:
0025C2r 3                               ; Compile a 0BRANCH
0025C2r 3  A0 rr                        ldy #>zero_branch_runtime
0025C4r 3  A9 rr                        lda #<zero_branch_runtime
0025C6r 3  20 rr rr                     jsr cmpl_subroutine
0025C9r 3               
0025C9r 3                               ; The address to loop back to is on the stack.
0025C9r 3                               ; Just compile it as the destination for the
0025C9r 3                               ; 0branch.
0025C9r 3  20 rr rr                     jsr xt_comma
0025CCr 3               
0025CCr 3  60           z_until:        rts
0025CDr 3               
0025CDr 3               
0025CDr 3               ; ## UNUSED ( -- u ) "Return size of space available to Dictionary"
0025CDr 3               ; ## "unused"  auto  ANS core ext
0025CDr 3                       ; """https://forth-standard.org/standard/core/UNUSED
0025CDr 3                       ; UNUSED does not include the ACCEPT history buffers. Total RAM
0025CDr 3                       ; should be HERE + UNUSED + <history buffer size>, the last of which
0025CDr 3                       ; defaults to $400
0025CDr 3                       ; """
0025CDr 3               xt_unused:
0025CDr 3  CA                           dex
0025CEr 3  CA                           dex
0025CFr 3               
0025CFr 3  A9 FF                        lda #<cp_end
0025D1r 3  38                           sec
0025D2r 3  E5 rr                        sbc cp
0025D4r 3  95 00                        sta 0,x
0025D6r 3               
0025D6r 3  A9 7F                        lda #>cp_end
0025D8r 3  E5 rr                        sbc cp+1
0025DAr 3  95 01                        sta 1,x
0025DCr 3               
0025DCr 3  60           z_unused:       rts
0025DDr 3               
0025DDr 3               
0025DDr 3               ; ## UPDATE ( -- ) "Mark current block as dirty"
0025DDr 3               ; ## "update"  auto  ANS block
0025DDr 3                       ; """https://forth-standard.org/standard/block/UPDATE"""
0025DDr 3               xt_update:
0025DDr 3                               ; Turn on the dirty bit. We can't use TSB here because it only
0025DDr 3                               ; has Absolute and Direct Pages addressing modes
0025DDr 3  A0 2C                        ldy #buffstatus_offset
0025DFr 3  B1 rr                        lda (up),y
0025E1r 3  09 02                        ora #2          ; Turn on dirty flag (bit 2)
0025E3r 3  91 rr                        sta (up),y
0025E5r 3               
0025E5r 3  60           z_update:       rts
0025E6r 3               
0025E6r 3               
0025E6r 3               ; ## USERADDR ( -- addr ) "Push address of base address of user variables"
0025E6r 3               ; ## "useraddr"  tested  Tali Forth
0025E6r 3               xt_useraddr:
0025E6r 3  CA                           dex
0025E7r 3  CA                           dex
0025E8r 3  A9 rr                        lda #<up
0025EAr 3  95 00                        sta 0,x
0025ECr 3  A9 rr                        lda #>up
0025EEr 3  95 01                        sta 1,x
0025F0r 3               
0025F0r 3  60           z_useraddr:     rts
0025F1r 3               
0025F1r 3               
0025F1r 3               ; ## VALUE ( n "name" -- ) "Define a value"
0025F1r 3               ; ## "value"  auto  ANS core
0025F1r 3                       ; """https://forth-standard.org/standard/core/VALUE
0025F1r 3                       ;
0025F1r 3                       ; This is a dummy header for the WORDLIST. The actual code is
0025F1r 3                       ; identical to that of CONSTANT
0025F1r 3                       ; """
0025F1r 3               
0025F1r 3               
0025F1r 3               ; ## VARIABLE ( "name" -- ) "Define a variable"
0025F1r 3               ; ## "variable"  auto  ANS core
0025F1r 3                       ; """https://forth-standard.org/standard/core/VARIABLE
0025F1r 3                       ; There are various Forth definitions for this word, such as
0025F1r 3                       ; `CREATE 1 CELLS ALLOT`  or  `CREATE 0 ,`  We use a variant of the
0025F1r 3                       ; second one so the variable is initialized to zero
0025F1r 3                       ; """
0025F1r 3               xt_variable:
0025F1r 3                               ; we let CREATE do the heavy lifting
0025F1r 3  20 rr rr                     jsr xt_create
0025F4r 3               
0025F4r 3                               ; there is no "STZ (CP)" so we have to do this the hard
0025F4r 3                               ; way
0025F4r 3  A9 00                        lda #0
0025F6r 3               
0025F6r 3  92 rr                        sta (cp)
0025F8r 3  E6 rr                        inc cp
0025FAr 3  D0 02                        bne @1
0025FCr 3  E6 rr                        inc cp+1
0025FEr 3               @1:
0025FEr 3  92 rr                        sta (cp)
002600r 3  E6 rr                        inc cp
002602r 3  D0 02                        bne @2
002604r 3  E6 rr                        inc cp+1
002606r 3               @2:
002606r 3                               ; Now we need to adjust the length of the complete word by two
002606r 3  20 rr rr                     jsr adjust_z
002609r 3               
002609r 3  60           z_variable:     rts
00260Ar 3               
00260Ar 3               
00260Ar 3               ; ## WHILE ( C: dest -- orig dest ) ( x -- ) "Loop flow control"
00260Ar 3               ; ## "while"  auto  ANS core
00260Ar 3                       ; """http://forth-standard.org/standard/core/WHILE"""
00260Ar 3               xt_while:
00260Ar 3                               ; Compile a 0branch
00260Ar 3  A0 rr                        ldy #>zero_branch_runtime
00260Cr 3  A9 rr                        lda #<zero_branch_runtime
00260Er 3  20 rr rr                     jsr cmpl_subroutine
002611r 3               
002611r 3                               ; Put the address (here) where the destination
002611r 3                               ; address needs to go so it can be put there later.
002611r 3  20 rr rr                     jsr xt_here
002614r 3               
002614r 3                               ; Fill in the destination address with 0 for now.
002614r 3  20 rr rr                     jsr xt_zero
002617r 3  20 rr rr                     jsr xt_comma
00261Ar 3               
00261Ar 3                               ; Swap the two addresses on the stack.
00261Ar 3  20 rr rr                     jsr xt_swap
00261Dr 3               
00261Dr 3  60           z_while:        rts
00261Er 3               
00261Er 3               
00261Er 3               ; ## WITHIN ( n1 n2 n3 -- ) "See if within a range"
00261Er 3               ; ## "within"  auto  ANS core ext
00261Er 3                       ; """https://forth-standard.org/standard/core/WITHIN
00261Er 3                       ;
00261Er 3                       ; This an assembler version of the ANS Forth implementation
00261Er 3                       ; at https://forth-standard.org/standard/core/WITHIN which is
00261Er 3                       ; OVER - >R - R> U<  note there is an alternative high-level version
00261Er 3                       ; ROT TUCK > -ROT > INVERT AND
00261Er 3                       ; """"
00261Er 3               xt_within:
00261Er 3  20 rr rr                     jsr underflow_3
002621r 3               
002621r 3  20 rr rr                     jsr xt_over
002624r 3  20 rr rr                     jsr xt_minus
002627r 3  20 rr rr                     jsr xt_to_r
00262Ar 3  20 rr rr                     jsr xt_minus
00262Dr 3  20 rr rr                     jsr xt_r_from
002630r 3  20 rr rr                     jsr xt_u_less_than
002633r 3               
002633r 3  60           z_within:       rts
002634r 3               
002634r 3               
002634r 3               ; ## WORD ( char "name " -- caddr ) "Parse input stream"
002634r 3               ; ## "word"  auto  ANS core
002634r 3                       ; """https://forth-standard.org/standard/core/WORD
002634r 3                       ; Obsolete parsing word included for backwards compatibility only.
002634r 3                       ; Do not use this, use `PARSE` or `PARSE-NAME`. Skips leading delimiters
002634r 3                       ; and copies word to storage area for a maximum size of 255 bytes.
002634r 3                       ; Returns the result as a counted string (requires COUNT to convert
002634r 3                       ; to modern format), and inserts a space after the string. See "Forth
002634r 3                       ; Programmer's Handbook" 3rd edition p. 159 and
002634r 3                       ; http://www.forth200x.org/documents/html/rationale.html#rat:core:PARSE
002634r 3                       ; for discussions of why you shouldn't be using WORD anymore.
002634r 3                       ;
002634r 3                       ; Forth
002634r 3                       ; would be   PARSE DUP BUFFER1 C! OUTPUT 1+ SWAP MOVE BUFFER1
002634r 3                       ; We only allow input of 255 chars. Seriously, use PARSE-NAME.
002634r 3                       ; """
002634r 3               
002634r 3               xt_word:
002634r 3  20 rr rr                     jsr underflow_1
002637r 3               
002637r 3                               ; Skip over leading delimiters - this is like PARSE-NAME,
002637r 3                               ; but unlike PARSE
002637r 3  A4 rr                        ldy toin                ; >IN
002639r 3               @loop:
002639r 3  C4 rr                        cpy ciblen              ; quit if end of input
00263Br 3  F0 09                        beq @found_char
00263Dr 3  B1 rr                        lda (cib),y
00263Fr 3  D5 00                        cmp 0,x                 ; ASCII of delimiter
002641r 3  D0 03                        bne @found_char
002643r 3               
002643r 3  C8                           iny
002644r 3  80 F3                        bra @loop
002646r 3               @found_char:
002646r 3                               ; Save index of where word starts
002646r 3  84 rr                        sty toin
002648r 3               
002648r 3                               ; The real work is done by parse
002648r 3  20 rr rr                     jsr xt_parse            ; Returns ( addr u )
00264Br 3               
00264Br 3                               ; Convert the modern ( addr u ) string format to obsolete
00264Br 3                               ; ( caddr ) format. We just do this in the Dictionary
00264Br 3  B5 00                        lda 0,x
00264Dr 3  92 rr                        sta (cp)                ; Save length of string
00264Fr 3  48                           pha                     ; Keep copy of length for later
002650r 3               
002650r 3  20 rr rr                     jsr xt_dup              ; ( addr u u )
002653r 3  A5 rr                        lda cp
002655r 3  18                           clc
002656r 3  69 01                        adc #1
002658r 3  95 02                        sta 2,x                 ; LSB of CP
00265Ar 3  A5 rr                        lda cp+1
00265Cr 3  69 00                        adc #0
00265Er 3  95 03                        sta 3,x                 ; ( addr cp+1 u )
002660r 3               
002660r 3  20 rr rr                     jsr xt_move
002663r 3               
002663r 3                               ; Return caddr
002663r 3  CA                           dex
002664r 3  CA                           dex
002665r 3  A5 rr                        lda cp
002667r 3  95 00                        sta 0,x
002669r 3  A5 rr                        lda cp+1
00266Br 3  95 01                        sta 1,x
00266Dr 3               
00266Dr 3                               ; Adjust CP
00266Dr 3  68                           pla                     ; length of string
00266Er 3  18                           clc
00266Fr 3  65 rr                        adc cp
002671r 3  85 rr                        sta cp
002673r 3  A5 rr                        lda cp+1
002675r 3  69 00                        adc #0                  ; we only need the carry
002677r 3  85 rr                        sta cp+1
002679r 3  60           z_word:         rts
00267Ar 3               
00267Ar 3               
00267Ar 3               ; ## WORDLIST ( -- wid ) "Create new wordlist (from pool of 8)"
00267Ar 3               ; ## "wordlist" auto ANS search
00267Ar 3                       ; """https://forth-standard.org/standard/search/WORDLIST
00267Ar 3                       ; See the tutorial on Wordlists and the Search Order for
00267Ar 3                       ; more information.
00267Ar 3                       ; """
00267Ar 3               
00267Ar 3               xt_wordlist:
00267Ar 3                               ; Get the current number of wordlists
00267Ar 3  A0 05                        ldy #num_wordlists_offset
00267Cr 3  B1 rr                        lda (up),y      ; This is a byte variable, so only
00267Er 3                                               ; the LSB needs to be checked.
00267Er 3               
00267Er 3                               ; See if we are already at the max.
00267Er 3  C9 0C                        cmp #max_wordlists
002680r 3  D0 05                        bne @ok
002682r 3               
002682r 3                               ; Print an error message if all wordlists used.
002682r 3  A9 0B                        lda #err_wordlist
002684r 3  4C rr rr                     jmp error
002687r 3               
002687r 3               @ok:
002687r 3  1A                           inc             ; Increment the wordlist#
002688r 3  91 rr                        sta (up),y      ; Save it into byte variable #wordlists
00268Ar 3  CA                           dex             ; and put it on the stack.
00268Br 3  CA                           dex
00268Cr 3  95 00                        sta 0,x
00268Er 3  74 01                        stz 1,x         ; 12 is the max, so upper byte is always zero.
002690r 3               
002690r 3  60           z_wordlist:     rts
002691r 3               
002691r 3               
002691r 3               
002691r 3               ; ## WORDS ( -- ) "Print known words from Dictionary"
002691r 3               ; ## "words"  tested  ANS tools
002691r 3                       ; """https://forth-standard.org/standard/tools/WORDS
002691r 3                       ; This is pretty much only used at the command line so we can
002691r 3                       ; be slow and try to save space.
002691r 3                       ; """
002691r 3               
002691r 3               xt_words:
002691r 3                               ; we follow Gforth by starting on the next
002691r 3                               ; line
002691r 3  20 rr rr                     jsr xt_cr
002694r 3               
002694r 3                               ; We pretty-format the output by inserting a line break
002694r 3                               ; before the end of the line. We can get away with pushing
002694r 3                               ; the counter to the stack because this is usually an
002694r 3                               ; interactive word and speed is not that important
002694r 3  A9 00                        lda #0
002696r 3  48                           pha
002697r 3               
002697r 3                               ; Set up for traversing the wordlist search order.
002697r 3  CA                           dex                     ; Make room on the stack for
002698r 3  CA                           dex                     ; a dictionary pointer.
002699r 3  64 rr                        stz tmp3                ; Start at the beginning of
00269Br 3                                                       ; the search order.
00269Br 3               @wordlist_loop:
00269Br 3  A0 1E                        ldy #num_order_offset   ; Check against byte variable #ORDER.
00269Dr 3  A5 rr                        lda tmp3
00269Fr 3  D1 rr                        cmp (up),y              ; See if we are done.
0026A1r 3  D0 02                        bne @have_wordlist
0026A3r 3               
0026A3r 3                               ; We ran out of wordlists to search.
0026A3r 3  80 44                        bra @words_done
0026A5r 3               
0026A5r 3               @have_wordlist:
0026A5r 3                               ; start with last word in Dictionary
0026A5r 3                               ; Get the current wordlist id
0026A5r 3  18                           clc                     ; Index into byte array SEARCH-ORDER.
0026A6r 3  69 1F                        adc #search_order_offset
0026A8r 3  A8                           tay
0026A9r 3  B1 rr                        lda (up),y              ; Get the index into array WORDLISTS
0026ABr 3               
0026ABr 3                               ; Get the DP for that wordlist.
0026ABr 3  0A                           asl                     ; Turn offset into cells offset.
0026ACr 3  18                           clc
0026ADr 3  69 06                        adc #wordlists_offset
0026AFr 3  A8                           tay
0026B0r 3  B1 rr                        lda (up),y              ; Save the DP for this wordlist
0026B2r 3  95 00                        sta 0,x                 ; on the stack. ( nt )
0026B4r 3  C8                           iny
0026B5r 3  B1 rr                        lda (up),y
0026B7r 3  95 01                        sta 1,x
0026B9r 3               
0026B9r 3               @loop:
0026B9r 3  20 rr rr                     jsr xt_dup              ; ( nt nt )
0026BCr 3  20 rr rr                     jsr xt_name_to_string   ; ( nt addr u )
0026BFr 3               
0026BFr 3                               ; Insert line break if we're about to go past the end of the
0026BFr 3                               ; line
0026BFr 3  68                           pla
0026C0r 3  18                           clc
0026C1r 3  75 00                        adc 0,x
0026C3r 3  1A                           inc                     ; don't forget the space between words
0026C4r 3  C9 4F                        cmp #MAX_LINE_LENGTH    ; usually 79
0026C6r 3  90 05                        bcc @1
0026C8r 3               
0026C8r 3  20 rr rr                     jsr xt_cr
0026CBr 3  A9 00                        lda #0
0026CDr 3               @1:
0026CDr 3  48                           pha
0026CEr 3  20 rr rr                     jsr xt_type             ; ( nt )
0026D1r 3               
0026D1r 3  A9 20                        lda #AscSP
0026D3r 3  20 rr rr                     jsr emit_a
0026D6r 3               
0026D6r 3                               ; get next word, which begins two down
0026D6r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0026D9r 3  20 rr rr                     jsr xt_one_plus         ; 1+
0026DCr 3  20 rr rr                     jsr xt_fetch            ; @ ( nt+1 )
0026DFr 3               
0026DFr 3                               ; if next address is zero, we're done
0026DFr 3  B5 00                        lda 0,x
0026E1r 3  15 01                        ora 1,x
0026E3r 3  D0 D4                        bne @loop
0026E5r 3               
0026E5r 3                               ; Move on to the next wordlist in the search order.
0026E5r 3  E6 rr                        inc tmp3
0026E7r 3  80 B2                        bra @wordlist_loop
0026E9r 3               
0026E9r 3               @words_done:
0026E9r 3  68                           pla                     ; dump counter
0026EAr 3               
0026EAr 3  E8                           inx
0026EBr 3  E8                           inx
0026ECr 3               
0026ECr 3  60           z_words:        rts
0026EDr 3               
0026EDr 3               
0026EDr 3               
0026EDr 3               ; ## WORDSIZE ( nt -- u ) "Get size of word in bytes"
0026EDr 3               ; ## "wordsize"  auto  Tali Forth
0026EDr 3                       ; """Given an word's name token (nt), return the size of the
0026EDr 3                       ; word's payload size in bytes (CFA plus PFA) in bytes. Does not
0026EDr 3                       ; count the final RTS.
0026EDr 3                       ; """
0026EDr 3               xt_wordsize:
0026EDr 3  20 rr rr                     jsr underflow_1
0026F0r 3               
0026F0r 3                               ; We get the start address of the word from its header entry
0026F0r 3                               ; for the start of the actual code (execution token, xt)
0026F0r 3                               ; which is four bytes down, and the pointer to the end of the
0026F0r 3                               ; code (z_word, six bytes down)
0026F0r 3  B5 00                        lda 0,x
0026F2r 3  85 rr                        sta tmp1
0026F4r 3  B5 01                        lda 1,x
0026F6r 3  85 rr                        sta tmp1+1
0026F8r 3               
0026F8r 3  A0 06                        ldy #6
0026FAr 3  B1 rr                        lda (tmp1),y    ; LSB of z
0026FCr 3  88                           dey
0026FDr 3  88                           dey
0026FEr 3               
0026FEr 3  38                           sec
0026FFr 3  F1 rr                        sbc (tmp1),y    ; LSB of xt
002701r 3  95 00                        sta 0,x
002703r 3               
002703r 3  A0 07                        ldy #7
002705r 3  B1 rr                        lda (tmp1),y    ; MSB of z
002707r 3  88                           dey
002708r 3  88                           dey
002709r 3               
002709r 3  F1 rr                        sbc (tmp1),y    ; MSB of xt
00270Br 3  95 01                        sta 1,x
00270Dr 3               
00270Dr 3  60           z_wordsize:     rts
00270Er 3               
00270Er 3               
00270Er 3               ; ## XOR ( n n -- n ) "Logically XOR TOS and NOS"
00270Er 3               ; ## "xor"  auto  ANS core
00270Er 3                       ; """https://forth-standard.org/standard/core/XOR"""
00270Er 3               xt_xor:
00270Er 3  20 rr rr                     jsr underflow_2
002711r 3               
002711r 3  B5 00                        lda 0,x
002713r 3  55 02                        eor 2,x
002715r 3  95 02                        sta 2,x
002717r 3               
002717r 3  B5 01                        lda 1,x
002719r 3  55 03                        eor 3,x
00271Br 3  95 03                        sta 3,x
00271Dr 3               
00271Dr 3  E8                           inx
00271Er 3  E8                           inx
00271Fr 3               
00271Fr 3  60           z_xor:          rts
002720r 3               
002720r 3               
002720r 3               ; ## ZERO ( -- 0 ) "Push 0 to Data Stack"
002720r 3               ; ## "0"  auto  Tali Forth
002720r 3                       ; """The disassembler assumes that this routine does not use Y. Note
002720r 3                       ; that CASE and FORTH-WORDLIST use the same routine, as the WD for Forth
002720r 3                       ; is 0."""
002720r 3               xt_case:
002720r 3               xt_forth_wordlist:
002720r 3               xt_zero:
002720r 3  CA                           dex             ; push
002721r 3  CA                           dex
002722r 3  74 00                        stz 0,x
002724r 3  74 01                        stz 1,x
002726r 3               z_case:
002726r 3               z_forth_wordlist:
002726r 3               z_zero:
002726r 3  60                           rts
002727r 3               
002727r 3               
002727r 3               ; ## ZERO_EQUAL ( n -- f ) "Check if TOS is zero"
002727r 3               ; ## "0="  auto  ANS core
002727r 3                       ; """https://forth-standard.org/standard/core/ZeroEqual"""
002727r 3               
002727r 3               xt_zero_equal:
002727r 3  20 rr rr                     jsr underflow_1
00272Ar 3               
00272Ar 3  B5 00                        lda 0,x
00272Cr 3  15 01                        ora 1,x
00272Er 3  F0 04                        beq @zero
002730r 3               
002730r 3                               ; not a zero, so we need a FALSE flag (0)
002730r 3  A9 00                        lda #0
002732r 3  80 02                        bra @store
002734r 3               @zero:
002734r 3                               ; We have a zero, so we need a TRUE flag (-1)
002734r 3  A9 FF                        lda #$ff
002736r 3               @store:
002736r 3  95 00                        sta 0,x
002738r 3  95 01                        sta 1,x
00273Ar 3               
00273Ar 3  60           z_zero_equal:   rts
00273Br 3               
00273Br 3               
00273Br 3               
00273Br 3               ; ## ZERO_GREATER ( n -- f ) "Return a TRUE flag if TOS is positive"
00273Br 3               ; ## "0>"  auto  ANS core ext
00273Br 3                       ; """https://forth-standard.org/standard/core/Zeromore"""
00273Br 3               
00273Br 3               xt_zero_greater:
00273Br 3  20 rr rr                     jsr underflow_1
00273Er 3               
00273Er 3  A0 00                        ldy #0          ; Default is FALSE (TOS is negative)
002740r 3               
002740r 3  B5 01                        lda 1,x         ; MSB
002742r 3  30 05                        bmi @done       ; TOS is negative, keep FLASE
002744r 3  15 00                        ora 0,x
002746r 3  F0 01                        beq @done       ; TOS is zero, keep FALSE
002748r 3               
002748r 3  88                           dey             ; TOS is postive, make true
002749r 3               @done:
002749r 3  98                           tya
00274Ar 3  95 00                        sta 0,x
00274Cr 3  95 01                        sta 1,x
00274Er 3               
00274Er 3  60           z_zero_greater: rts
00274Fr 3               
00274Fr 3               
00274Fr 3               
00274Fr 3               ; ## ZERO_LESS ( n -- f ) "Return a TRUE flag if TOS negative"
00274Fr 3               ; ## "0<"  auto  ANS core
00274Fr 3                       ; """https://forth-standard.org/standard/core/Zeroless"""
00274Fr 3               
00274Fr 3               xt_zero_less:
00274Fr 3  20 rr rr                     jsr underflow_1
002752r 3               
002752r 3  A0 00                        ldy #0          ; Default is FALSE (TOS positive)
002754r 3               
002754r 3  B5 01                        lda 1,x         ; MSB
002756r 3  10 01                        bpl @done       ; TOS is positive, so keep FALSE
002758r 3               
002758r 3  88                           dey             ; TOS is negative, make TRUE
002759r 3               @done:
002759r 3  98                           tya
00275Ar 3  95 00                        sta 0,x
00275Cr 3  95 01                        sta 1,x
00275Er 3               
00275Er 3  60           z_zero_less:    rts
00275Fr 3               
00275Fr 3               
00275Fr 3               
00275Fr 3               ; ## ZERO_UNEQUAL ( m -- f ) "Return TRUE flag if not zero"
00275Fr 3               ; ## "0<>"  auto  ANS core ext
00275Fr 3                       ; """https://forth-standard.org/standard/core/Zerone"""
00275Fr 3               
00275Fr 3               xt_zero_unequal:
00275Fr 3  20 rr rr                     jsr underflow_1
002762r 3               
002762r 3  A0 00                        ldy #0          ; default false
002764r 3               
002764r 3  B5 00                        lda 0,x
002766r 3  15 01                        ora 1,x
002768r 3  F0 01                        beq @got_zero
00276Ar 3               
00276Ar 3  88                           dey
00276Br 3               @got_zero:
00276Br 3  98                           tya
00276Cr 3  95 00                        sta 0,x
00276Er 3  95 01                        sta 1,x
002770r 3               
002770r 3  60           z_zero_unequal: rts
002771r 3               
002771r 3               
002771r 3               
002771r 3               ; ==========================================================
002771r 3               ; EDITOR words
002771r 3               
002771r 3               ; This routine is used by both enter-screen and erase-screen
002771r 3               ; to get a buffer for the given screen number and set SCR to
002771r 3               ; the given screen number.  This word is not in the dictionary.
002771r 3               xt_editor_screen_helper:
002771r 3  20 rr rr                     jsr xt_dup
002774r 3  20 rr rr                     jsr xt_scr
002777r 3  20 rr rr                     jsr xt_store
00277Ar 3  20 rr rr                     jsr xt_buffer
00277Dr 3               z_editor_screen_helper:
00277Dr 3  60                           rts
00277Er 3               
00277Er 3               
00277Er 3               ; ## EDITOR_ENTER_SCREEN ( scr# -- ) "Enter all lines for given screen"
00277Er 3               ; ## "enter-screen"  auto  Tali Editor
00277Er 3               
00277Er 3               xt_editor_enter_screen:
00277Er 3                               ; Set the variable SCR and get a buffer for the
00277Er 3                               ; given screen number.
00277Er 3  20 rr rr                     jsr xt_editor_screen_helper
002781r 3               
002781r 3                               ; Drop the buffer address.
002781r 3  20 rr rr                     jsr xt_drop
002784r 3               
002784r 3                               ; Overwrite the lines one at a time.
002784r 3  64 rr                        stz editor1
002786r 3               @prompt_loop:
002786r 3                               ; Put the current line number on the stack.
002786r 3  CA                           dex
002787r 3  CA                           dex
002788r 3  A5 rr                        lda editor1
00278Ar 3  95 00                        sta 0,x
00278Cr 3  74 01                        stz 1,x
00278Er 3               
00278Er 3                               ; Use the O word to prompt for overwrite.
00278Er 3  20 rr rr                     jsr xt_editor_o
002791r 3               
002791r 3                               ; Move on to the next line.
002791r 3  E6 rr                        inc editor1
002793r 3  A9 10                        lda #16
002795r 3  C5 rr                        cmp editor1
002797r 3  D0 ED                        bne @prompt_loop
002799r 3               
002799r 3               z_editor_enter_screen:
002799r 3  60                           rts
00279Ar 3               
00279Ar 3               
00279Ar 3               
00279Ar 3               ; ## EDITOR_ERASE_SCREEN ( scr# -- ) "Erase all lines for given screen"
00279Ar 3               ; ## "erase-screen"  tested  Tali Editor
00279Ar 3               xt_editor_erase_screen:
00279Ar 3                               ; Set the variable SCR and get a buffer for the
00279Ar 3                               ; given screen number.
00279Ar 3  20 rr rr                     jsr xt_editor_screen_helper
00279Dr 3               
00279Dr 3                               ; Put 1024 (chars/screen) on stack.
00279Dr 3  CA                           dex
00279Er 3  CA                           dex
00279Fr 3  74 00                        stz 0,x
0027A1r 3  A9 04                        lda #4          ; 4 in MSB makes 1024 ($400).
0027A3r 3  95 01                        sta 1,x
0027A5r 3               
0027A5r 3                               ; Erase the entire block (fill with spaces).
0027A5r 3  20 rr rr                     jsr xt_blank
0027A8r 3               
0027A8r 3                               ; Mark buffer as updated.
0027A8r 3  20 rr rr                     jsr xt_update
0027ABr 3               
0027ABr 3               z_editor_erase_screen:
0027ABr 3  60                           rts
0027ACr 3               
0027ACr 3               
0027ACr 3               ; ## EDITOR_EL ( line# -- ) "Erase the given line number"
0027ACr 3               ; ## "el"  tested  Tali Editor
0027ACr 3               xt_editor_el:
0027ACr 3                               ; Turn the line number into buffer offset.
0027ACr 3                               ; This also loads the block into the buffer if it's
0027ACr 3                               ; not there for some reason.
0027ACr 3  20 rr rr                     jsr xt_editor_line
0027AFr 3               
0027AFr 3                               ; Put 64 (# of chars/line) on the stack.
0027AFr 3  CA                           dex
0027B0r 3  CA                           dex
0027B1r 3  A9 40                        lda #64
0027B3r 3  95 00                        sta 0,x
0027B5r 3  74 01                        stz 1,x
0027B7r 3               
0027B7r 3                               ; Fill with spaces.
0027B7r 3  20 rr rr                     jsr xt_blank
0027BAr 3               
0027BAr 3                               ; Mark buffer as updated.
0027BAr 3  20 rr rr                     jsr xt_update
0027BDr 3               
0027BDr 3  60           z_editor_el:    rts
0027BEr 3               
0027BEr 3               
0027BEr 3               ; ## EDITOR_L ( -- ) "List the current screen"
0027BEr 3               ; ## "l"  tested  Tali Editor
0027BEr 3               
0027BEr 3               xt_editor_l:
0027BEr 3                               ; Load the current screen
0027BEr 3  CA                           dex             ; Put SCR on the stack.
0027BFr 3  CA                           dex
0027C0r 3  A0 02                        ldy #scr_offset
0027C2r 3  B1 rr                        lda (up),y
0027C4r 3  95 00                        sta 0,x
0027C6r 3  C8                           iny
0027C7r 3  B1 rr                        lda (up),y
0027C9r 3  95 01                        sta 1,x
0027CBr 3  20 rr rr                     jsr xt_block    ; Get the current screen.
0027CEr 3               
0027CEr 3  20 rr rr                     jsr xt_cr
0027D1r 3               
0027D1r 3                               ; Print the screen number.
0027D1r 3                               ; We're using sliteral, so we need to set up the
0027D1r 3                               ; appropriate data structure (see sliteral)
0027D1r 3  80 08                        bra @after_screen_msg
0027D3r 3               
0027D3r 3               @screen_msg:
0027D3r 3  53 63 72 65                  .byte "Screen #"
0027D7r 3  65 6E 20 23  
0027DBr 3               
0027DBr 3               @after_screen_msg:
0027DBr 3  20 rr rr                     jsr sliteral_runtime
0027DEr 3  rr rr 08 00                  .word @screen_msg, @after_screen_msg-@screen_msg
0027E2r 3               
0027E2r 3  20 rr rr                     jsr xt_type
0027E5r 3               
0027E5r 3                               ; Put the screen number and printed size for u.r on the stack.
0027E5r 3  20 rr rr                     jsr xt_scr
0027E8r 3  20 rr rr                     jsr xt_fetch
0027EBr 3  CA                           dex
0027ECr 3  CA                           dex
0027EDr 3  A9 04                        lda #4          ; four spaces
0027EFr 3  95 00                        sta 0,x
0027F1r 3  74 01                        stz 1,x
0027F3r 3  20 rr rr                     jsr xt_u_dot_r
0027F6r 3               
0027F6r 3                               ; The address of the buffer is currently on the stack.
0027F6r 3                               ; Print 64 chars at a time. TYPE uses tmp1, so we'll
0027F6r 3                               ; keep track of the line number in tmp3.
0027F6r 3  64 rr                        stz tmp3
0027F8r 3               
0027F8r 3               @line_loop:
0027F8r 3  20 rr rr                     jsr xt_cr
0027FBr 3               
0027FBr 3                               ; Print the line number (2-space fixed width)
0027FBr 3  CA                           dex
0027FCr 3  CA                           dex
0027FDr 3  CA                           dex
0027FEr 3  CA                           dex
0027FFr 3  74 03                        stz 3,x
002801r 3  A5 rr                        lda tmp3
002803r 3  95 02                        sta 2,x
002805r 3  74 01                        stz 1,x
002807r 3  A9 02                        lda #2
002809r 3  95 00                        sta 0,x
00280Br 3  20 rr rr                     jsr xt_u_dot_r
00280Er 3  20 rr rr                     jsr xt_space
002811r 3               
002811r 3                               ; Print one line using the address on the stack.
002811r 3  20 rr rr                     jsr xt_dup
002814r 3  CA                           dex
002815r 3  CA                           dex
002816r 3  A9 40                        lda #64
002818r 3  95 00                        sta 0,x
00281Ar 3  74 01                        stz 1,x
00281Cr 3  20 rr rr                     jsr xt_type
00281Fr 3               
00281Fr 3                               ; Add 64 to the address on the stack to move to the next line.
00281Fr 3  18                           clc
002820r 3  A9 40                        lda #64
002822r 3  75 00                        adc 0,x
002824r 3  95 00                        sta 0,x
002826r 3  B5 01                        lda 1,x
002828r 3  69 00                        adc #0      ; Add carry
00282Ar 3  95 01                        sta 1,x
00282Cr 3               
00282Cr 3                               ; Increment the line number (held in tmp3)
00282Cr 3  E6 rr                        inc tmp3
00282Er 3               
00282Er 3                               ; See if we are done.
00282Er 3  A5 rr                        lda tmp3
002830r 3  C9 10                        cmp #16
002832r 3  D0 C4                        bne @line_loop
002834r 3               
002834r 3  20 rr rr                     jsr xt_cr
002837r 3                               ; Drop the address on the stack.
002837r 3  E8                           inx
002838r 3  E8                           inx
002839r 3               
002839r 3  60           z_editor_l:            rts
00283Ar 3               
00283Ar 3               
00283Ar 3               
00283Ar 3               ; ## EDITOR_LINE ( line# -- c-addr ) "Turn a line number into address in current screen"
00283Ar 3               ; ## "line"  tested  Tali Editor
00283Ar 3               
00283Ar 3               xt_editor_line:
00283Ar 3  20 rr rr                     jsr underflow_1
00283Dr 3               
00283Dr 3                               ; Multiply the TOS by 64 (chars/line) to compute offset.
00283Dr 3  A0 06                        ldy #6          ; *64 is same as left shift 6 times.
00283Fr 3               @shift_tos_left:
00283Fr 3  16 00                        asl 0,x         ; Shift TOS to the left
002841r 3  36 01                        rol 1,x         ; ROL brings MSb from lower byte.
002843r 3  88                           dey
002844r 3  D0 F9                        bne @shift_tos_left
002846r 3                               ; Load the current screen into a buffer
002846r 3                               ; and get the buffer address
002846r 3  20 rr rr                     jsr xt_scr
002849r 3  20 rr rr                     jsr xt_fetch
00284Cr 3  20 rr rr                     jsr xt_block
00284Fr 3               
00284Fr 3                               ; Add the offset to the buffer base address.
00284Fr 3  20 rr rr                     jsr xt_plus
002852r 3               
002852r 3  60           z_editor_line:  rts
002853r 3               
002853r 3               
002853r 3               
002853r 3               ; ## EDITOR_O ( line# -- ) "Overwrite the given line"
002853r 3               ; ## "o"  tested  Tali Editor
002853r 3               xt_editor_o:
002853r 3                               ; Print prompt
002853r 3  20 rr rr                     jsr xt_cr
002856r 3  20 rr rr                     jsr xt_dup
002859r 3  20 rr rr                     jsr xt_two
00285Cr 3  20 rr rr                     jsr xt_u_dot_r
00285Fr 3  20 rr rr                     jsr xt_space
002862r 3  A9 2A                        lda #42         ; ASCII for *
002864r 3  20 rr rr                     jsr emit_a
002867r 3  20 rr rr                     jsr xt_space
00286Ar 3               
00286Ar 3                               ; Accept new input (directly into the buffer)
00286Ar 3  20 rr rr                     jsr xt_editor_line
00286Dr 3  20 rr rr                     jsr xt_dup      ; Save a copy of the line address for later.
002870r 3  CA                           dex
002871r 3  CA                           dex
002872r 3  A9 40                        lda #64         ; chars/line
002874r 3  95 00                        sta 0,x
002876r 3  74 01                        stz 1,x
002878r 3  20 rr rr                     jsr xt_accept
00287Br 3               
00287Br 3                               ; Fill the rest with spaces.
00287Br 3                               ; Stack is currently ( line_address numchars_from_accept )
00287Br 3  20 rr rr                     jsr xt_dup
00287Er 3  20 rr rr                     jsr xt_not_rote ; -rot
002881r 3  20 rr rr                     jsr xt_plus
002884r 3  CA                           dex
002885r 3  CA                           dex
002886r 3  A9 40                        lda #64         ; chars/line
002888r 3  95 00                        sta 0,x
00288Ar 3  74 01                        stz 1,x
00288Cr 3  20 rr rr                     jsr xt_rot
00288Fr 3  20 rr rr                     jsr xt_minus
002892r 3  20 rr rr                     jsr xt_blank
002895r 3               
002895r 3                               ; Mark buffer as updated.
002895r 3  20 rr rr                     jsr xt_update
002898r 3               
002898r 3  60           z_editor_o:     rts
002899r 3               
002899r 3               ; ## LCDPUT ( s -- ) "Print single character to LCD"
002899r 3               ; ## "lcdput" coded Custom
002899r 3               xt_lcdput:
002899r 3  20 rr rr                     jsr underflow_1
00289Cr 3               
00289Cr 3  B5 00                        lda 0,x
00289Er 3                       .ifdef lcd_print
00289Er 3                               jsr lcd_print
00289Er 3                       .endif
00289Er 3  E8                           inx
00289Fr 3  E8                           inx
0028A0r 3  60           z_lcdput: rts
0028A1r 3               
0028A1r 3               
0028A1r 3               ; ## LCDPRINT ( addr u -- ) "Print string to LCD"
0028A1r 3               ; ## "lcdprint"  coded Custom
0028A1r 3               
0028A1r 3               xt_lcdprint:
0028A1r 3  20 rr rr                     jsr underflow_2
0028A4r 3               
0028A4r 3                               ; Save the starting address into tmp1
0028A4r 3  B5 02                        lda 2,x
0028A6r 3  85 rr                        sta tmp1
0028A8r 3  B5 03                        lda 3,x
0028AAr 3  85 rr                        sta tmp1+1
0028ACr 3               @loop:
0028ACr 3                               ; done if length is zero
0028ACr 3  B5 00                        lda 0,x
0028AEr 3  15 01                        ora 1,x
0028B0r 3  F0 12                        beq @done
0028B2r 3               
0028B2r 3                               ; Send the current character
0028B2r 3  B2 rr                        lda (tmp1)
0028B4r 3                       .ifdef lcd_print
0028B4r 3                               jsr lcd_print      ; avoids stack foolery
0028B4r 3                       .endif
0028B4r 3                               ; Move the address along (in tmp1)
0028B4r 3  E6 rr                        inc tmp1
0028B6r 3  D0 02                        bne @1
0028B8r 3  E6 rr                        inc tmp1+1
0028BAr 3               @1:
0028BAr 3                               ; Reduce the count (on the data stack)
0028BAr 3  B5 00                        lda 0,x
0028BCr 3  D0 02                        bne @2
0028BEr 3  D6 01                        dec 1,x
0028C0r 3               @2:
0028C0r 3  D6 00                        dec 0,x
0028C2r 3               
0028C2r 3  80 E8                        bra @loop
0028C4r 3               @done:
0028C4r 3  E8                           inx
0028C5r 3  E8                           inx
0028C6r 3  E8                           inx
0028C7r 3  E8                           inx
0028C8r 3               
0028C8r 3  60           z_lcdprint:         rts
0028C9r 3               
0028C9r 3               
0028C9r 3               
0028C9r 3               ; ## CLS ( -- ) "clea VGA screen"
0028C9r 3               ; ## "cls" coded Custom
0028C9r 3               xt_cls:
0028C9r 3                       .ifdef vga_clear
0028C9r 3                               jsr vga_clear
0028C9r 3                       .endif
0028C9r 3               
0028C9r 3  60           z_cls: rts
0028CAr 3               
0028CAr 3               
0028CAr 3               ; ## SPI_INIT ( -- ) "Init SPI system"
0028CAr 3               ; ## "spi_init" coded Custom
0028CAr 3               xt_spi_init:
0028CAr 3               .ifdef VIA1_BASE
0028CAr 3                               jsr spi_init
0028CAr 3               .endif
0028CAr 3  60           z_spi_init: rts
0028CBr 3               
0028CBr 3               
0028CBr 3               ; ## SPI_CLK_TOGGLE ( -- ) "Toggle SPI clock"
0028CBr 3               ; ## "spi_clk_toggle" coded Custom
0028CBr 3               xt_spi_clk_toggle:
0028CBr 3               .ifdef VIA1_BASE
0028CBr 3                               jsr spi_clk_toggle
0028CBr 3               .endif
0028CBr 3  60           z_spi_clk_toggle: rts
0028CCr 3               
0028CCr 3               ; ## SPI_SELECT ( s -- ) "Select SPI slave"
0028CCr 3               ; ## "spi_select" coded Custom
0028CCr 3               xt_spi_select:
0028CCr 3               .ifdef VIA1_BASE
0028CCr 3                               jsr underflow_1
0028CCr 3               
0028CCr 3                               lda 0,x
0028CCr 3               
0028CCr 3                               jsr spi_select
0028CCr 3               
0028CCr 3                               inx
0028CCr 3                               inx
0028CCr 3               .endif
0028CCr 3  60           z_spi_select: rts
0028CDr 3               
0028CDr 3               ; ## SPI_TRANSCEIVE ( s -- u ) "Send and receive spi data"
0028CDr 3               ; ## "spi_transceive" coded Custom
0028CDr 3               xt_spi_transceive:
0028CDr 3               .ifdef VIA1_BASE
0028CDr 3                               jsr underflow_1
0028CDr 3               
0028CDr 3                               lda 0,x
0028CDr 3               
0028CDr 3                               jsr spi_transceive
0028CDr 3               
0028CDr 3                               sta 0,x         ; put return value in TOS
0028CDr 3                               stz 1,X         ;reset value there
0028CDr 3               .endif
0028CDr 3  60           z_spi_transceive: rts
0028CEr 3               
0028CEr 3               ; ## SD_INIT ( s -- u ) "Send and receive spi data"
0028CEr 3               ; ## "sd_init" coded Custom
0028CEr 3               xt_sd_init:
0028CEr 3               .ifdef SD
0028CEr 3                               jsr underflow_1
0028CEr 3               
0028CEr 3                               lda 0,x
0028CEr 3                               jsr sd_init
0028CEr 3                               beq @ok
0028CEr 3                               pha
0028CEr 3                               printascii sd_init_error_message
0028CEr 3                               pla
0028CEr 3               @ok:
0028CEr 3                               sta 0,x         ; put return value in TOS
0028CEr 3                               stz 1,X         ;reset value there
0028CEr 3               .endif
0028CEr 3  60           z_sd_init: rts
0028CFr 3               
0028CFr 3               ; ## SD_READSECTOR ( addr d -- u ) "Read SD sector"
0028CFr 3               ; ## "sd_readsector" coded Custom
0028CFr 3               xt_sd_readsector:
0028CFr 3               
0028CFr 3               .ifdef SD
0028CFr 3                               jsr underflow_2
0028CFr 3                               ; get and save sector number (32 bit number, double)
0028CFr 3                               ; most significant part is TOS
0028CFr 3                               lda 0, x
0028CFr 3                               sta IO_SECTOR + 2
0028CFr 3                               lda 1, x
0028CFr 3                               sta IO_SECTOR + 3
0028CFr 3                               ; least significant part is NOS
0028CFr 3                               lda 2, x
0028CFr 3                               sta IO_SECTOR + 0
0028CFr 3                               lda 3, x
0028CFr 3                               sta IO_SECTOR + 1
0028CFr 3                               lda #1
0028CFr 3                               sta SD_CRC
0028CFr 3               
0028CFr 3                               jsr sd_readsector
0028CFr 3                               sta 0,x         ; put return value in TOS
0028CFr 3                               stz 1,X         ;reset value there
0028CFr 3               
0028CFr 3                               inx
0028CFr 3                               inx
0028CFr 3               .endif
0028CFr 3  60           z_sd_readsector: rts
0028D0r 3               
0028D0r 3               
0028D0r 3               ; ## time ( -- addr ) "get time storage address"
0028D0r 3               ; ## "time" coded Custom
0028D0r 3               xt_time:
0028D0r 3                       .ifdef time
0028D0r 3                       lda #time
0028D0r 3                       .else
0028D0r 3  A9 00                lda #0
0028D2r 3                       .endif
0028D2r 3  CA                   dex
0028D3r 3  CA                   dex
0028D4r 3  95 00                sta 0,x
0028D6r 3  74 01                stz 1,x
0028D8r 3               
0028D8r 3               
0028D8r 3  60           z_time: rts
0028D9r 3               
0028D9r 3               
0028D9r 3               xt_cf_info:
0028D9r 3               .ifdef CF_ADDRESS
0028D9r 3                       jsr cf_info
0028D9r 3                       jsr xt_cr
0028D9r 3                       jsr cf_print_id
0028D9r 3                       jsr cf_print_capacity
0028D9r 3               .endif
0028D9r 3               z_cf_info:
0028D9r 3  60                   rts
0028DAr 3               
0028DAr 3               cf_info:
0028DAr 3               ;     jsr cf_init
0028DAr 3               ;     jsr cf_wait
0028DAr 3               ;     lda #$EC
0028DAr 3               ;     sta CF_ADDRESS + 7
0028DAr 3               ;     lda #<IO_BUFFER
0028DAr 3               ;     sta io_buffer_ptr
0028DAr 3               ;     lda #>IO_BUFFER
0028DAr 3               ;     sta io_buffer_ptr + 1
0028DAr 3               ;     jsr cf_read
0028DAr 3  60               rts
0028DBr 3               
0028DBr 3               cf_print_capacity:
0028DBr 3               .ifdef CF_ADDRESS
0028DBr 3                   phy
0028DBr 3               
0028DBr 3                   jsr xt_cr
0028DBr 3               
0028DBr 3                   ldy #120
0028DBr 3                   ; print lba size
0028DBr 3                   lda (io_buffer_ptr), y
0028DBr 3                   sta LBA_SIZE
0028DBr 3                   iny
0028DBr 3                   lda (io_buffer_ptr), y
0028DBr 3                   sta LBA_SIZE + 1
0028DBr 3               
0028DBr 3                   iny
0028DBr 3                   lda (io_buffer_ptr), y
0028DBr 3                   sta LBA_SIZE + 2
0028DBr 3               
0028DBr 3                   iny
0028DBr 3                   lda (io_buffer_ptr), y
0028DBr 3                   sta LBA_SIZE + 3
0028DBr 3               
0028DBr 3                   ldy #9
0028DBr 3               @loop:
0028DBr 3                   asl32 LBA_SIZE
0028DBr 3                   dey
0028DBr 3                   bne @loop
0028DBr 3               
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3               
0028DBr 3                   lda LBA_SIZE
0028DBr 3                   sta 2, x
0028DBr 3                   lda LBA_SIZE + 1
0028DBr 3                   sta 3, x
0028DBr 3                   lda LBA_SIZE + 2
0028DBr 3                   sta 0, x
0028DBr 3                   lda LBA_SIZE + 3
0028DBr 3                   sta 1, x
0028DBr 3               
0028DBr 3                   jsr xt_ud_dot
0028DBr 3               
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3                   dex
0028DBr 3                   lda #6
0028DBr 3                   sta 0, x
0028DBr 3                   stz 1, x
0028DBr 3                   lda #<bytes_msg
0028DBr 3                   sta 2, x
0028DBr 3                   lda #>bytes_msg
0028DBr 3                   sta 3, x
0028DBr 3                   jsr xt_type
0028DBr 3                   jsr xt_cr
0028DBr 3                   ply
0028DBr 3               .endif
0028DBr 3  60               rts
0028DCr 3               
0028DCr 3               
0028DCr 3               
0028DCr 3               
0028DCr 3               cf_print_id:
0028DCr 3                   ; print model number
0028DCr 3  5A               phy
0028DDr 3  A0 37            ldy #55
0028DFr 3               @loop:
0028DFr 3  B1 rr            lda (io_buffer_ptr), y
0028E1r 3  20 rr rr         jsr kernel_putc
0028E4r 3  88               dey
0028E5r 3  B1 rr            lda (io_buffer_ptr), y
0028E7r 3  20 rr rr         jsr kernel_putc
0028EAr 3  C8               iny
0028EBr 3  C8               iny
0028ECr 3  C8               iny
0028EDr 3  C0 5F            cpy #(40+55)
0028EFr 3  90 EE            bcc @loop
0028F1r 3  7A               ply
0028F2r 3  60               rts
0028F3r 3               
0028F3r 3               
0028F3r 3               xt_io_readblock:
0028F3r 3               .ifdef io_read_sector_address
0028F3r 3                       ; block-read ( addr blk# -- )
0028F3r 3                       lda 2, x
0028F3r 3                       sta io_buffer_ptr
0028F3r 3                       lda 3, x
0028F3r 3                       sta io_buffer_ptr + 1
0028F3r 3                       lda 0, x
0028F3r 3                       sta IO_SECTOR
0028F3r 3                       lda 1, x
0028F3r 3                       sta IO_SECTOR + 1
0028F3r 3                       stz IO_SECTOR + 2
0028F3r 3                       stz IO_SECTOR + 3
0028F3r 3               
0028F3r 3                       asl IO_SECTOR                   ; multiply by two to get first sector number
0028F3r 3                       rol IO_SECTOR + 1
0028F3r 3                       rol IO_SECTOR + 2
0028F3r 3               
0028F3r 3                       ; lda io_buffer_ptr
0028F3r 3                       ; sta 0, x
0028F3r 3                       ; lda io_buffer_ptr + 1
0028F3r 3                       ; sta 1, x
0028F3r 3                       ; jsr xt_dot
0028F3r 3               
0028F3r 3                       jsr io_read_sector
0028F3r 3                       inc32 IO_SECTOR
0028F3r 3                       inc io_buffer_ptr + 1
0028F3r 3                       inc io_buffer_ptr + 1
0028F3r 3                       jsr io_read_sector
0028F3r 3                       ; lda io_buffer_ptr
0028F3r 3                       ; sta 0, x
0028F3r 3                       ; lda io_buffer_ptr + 1
0028F3r 3                       ; sta 1, x
0028F3r 3                       ; jsr xt_dot
0028F3r 3               
0028F3r 3                       inx
0028F3r 3                       inx
0028F3r 3               
0028F3r 3               .endif
0028F3r 3               z_io_readblock:
0028F3r 3  60                   rts
0028F4r 3               
0028F4r 3               xt_io_writeblock:
0028F4r 3               .ifdef io_read_sector_address
0028F4r 3                       ; block-write ( addr blk# -- )
0028F4r 3                       lda 2, x
0028F4r 3                       sta io_buffer_ptr
0028F4r 3                       lda 3, x
0028F4r 3                       sta io_buffer_ptr + 1
0028F4r 3                       lda 0, x
0028F4r 3                       sta IO_SECTOR
0028F4r 3                       lda 1, x
0028F4r 3                       sta IO_SECTOR + 1
0028F4r 3                       stz IO_SECTOR + 2
0028F4r 3                       stz IO_SECTOR + 3
0028F4r 3               
0028F4r 3                       asl IO_SECTOR                   ; multiply by two to get first sector number
0028F4r 3                       rol IO_SECTOR + 1
0028F4r 3                       rol IO_SECTOR + 2
0028F4r 3               
0028F4r 3                       jsr io_write_sector
0028F4r 3                       inc32 IO_SECTOR
0028F4r 3                       inc io_buffer_ptr + 1
0028F4r 3                       inc io_buffer_ptr + 1
0028F4r 3                       jsr io_write_sector
0028F4r 3               
0028F4r 3               
0028F4r 3                       ; inc io_buffer_ptr + 1           ; jump two pages forward
0028F4r 3                       ; inc io_buffer_ptr + 1
0028F4r 3                       ; jsr io_write_sector
0028F4r 3                       inx
0028F4r 3                       inx
0028F4r 3                       ; inx
0028F4r 3                       ; inx
0028F4r 3               .endif
0028F4r 3               z_io_writeblock:
0028F4r 3  60                   rts
0028F5r 3               ; END
0028F5r 3               
0028F5r 3               
0028F5r 2                   .include "headers.s"          ; Headers of native words
0028F5r 3               ; Dictionary Headers for Tali Forth 2
0028F5r 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
0028F5r 3               ; First version: 05. Dec 2016 (Liara Forth)
0028F5r 3               ; This version: 29. Dec 2018
0028F5r 3               
0028F5r 3               ; Dictionary headers are kept separately from the code, which allows various
0028F5r 3               ; tricks in the code. We roughly follow the Gforth terminology: The Execution
0028F5r 3               ; Token (xt) is the address of the first byte of a word's code that can be, uh,
0028F5r 3               ; executed; the Name Token (nt) is a pointer to the beginning of the word's
0028F5r 3               ; header in the Dictionary. There the link to the next word in the Dictionary
0028F5r 3               ; is always one cell down from the current word's own nt. In the code itself,
0028F5r 3               ; we use "nt_<WORD>" for the nt and "xt_<WORD>" for the xt.
0028F5r 3               
0028F5r 3               ; This gives us the following header structure:
0028F5r 3               
0028F5r 3               ;              8 bit     8 bit
0028F5r 3               ;               LSB       MSB
0028F5r 3               ; nt_word ->  +--------+--------+
0028F5r 3               ;          +0 | Length | Status |
0028F5r 3               ;             +--------+--------+
0028F5r 3               ;          +2 | Next Header     | -> nt_next_word
0028F5r 3               ;             +-----------------+
0028F5r 3               ;          +4 | Start of Code   | -> xt_word
0028F5r 3               ;             +-----------------+
0028F5r 3               ;          +6 | End of Code     | -> z_word
0028F5r 3               ;             +--------+--------+
0028F5r 3               ;          +8 | Name   |        |
0028F5r 3               ;             +--------+--------+
0028F5r 3               ;             |        |        |
0028F5r 3               ;             +--------+--------+
0028F5r 3               ;             |        |  ...   | (name string does not end with a zero)
0028F5r 3               ;          +n +--------+--------+
0028F5r 3               
0028F5r 3               ; The Status Byte is created by adding the flags defined in definitions.asm,
0028F5r 3               ; which are:
0028F5r 3               
0028F5r 3               ;       CO - Compile Only
0028F5r 3               ;       IM - Immediate Word
0028F5r 3               ;       NN - Never Native Compile (must always be called by JSR)
0028F5r 3               ;       AN - Always Native Compile (may not be called by JSR)
0028F5r 3               ;       UF - Contains underflow check
0028F5r 3               ;       HC - Has CFA (words created by CREATE and DOES> only)
0028F5r 3               
0028F5r 3               ; Note there are currently two bits unused.
0028F5r 3               
0028F5r 3               ; By default, all existing words can be natively compiled (compiled inline) or
0028F5r 3               ; as a subroutine jump target; the system decides which variant to use based on
0028F5r 3               ; a threshold the user can set. By default, all user-created words are flagged
0028F5r 3               ; never-native. The user can override this by using the always-native word
0028F5r 3               ; just after defining their new word.  The NN flag forbids native compiling,
0028F5r 3               ; the AN flag forces it.
0028F5r 3               
0028F5r 3               ; The last word (top word in code) is always BYE. It is marked as the last word
0028F5r 3               ; by its value of 0000 in its Next Header field. The words are sorted with the
0028F5r 3               ; more common ones first (further down in code) so they are found earlier.
0028F5r 3               ; Anything to do with output comes later (further up) because things will
0028F5r 3               ; always be slow if there is a human involved.
0028F5r 3               
0028F5r 3               ; The initial skeleton of this list was automatically generated by a script
0028F5r 3               ; in the tools folder and then sorted by hand.
0028F5r 3               
0028F5r 3               nt_bye:
0028F5r 3  03                   .byte 3         ; length of word strings
0028F6r 3  00                   .byte 0         ; status byte
0028F7r 3  00 00                .word 0000      ; next word in Dictionary, 0000 signals end
0028F9r 3  rr rr                .word xt_bye    ; start of code block (xt of this word)
0028FBr 3  rr rr                .word z_bye     ; end of code (RTS)
0028FDr 3  62 79 65             .byte "bye"     ; word name, always lower case, not zero-terminated
002900r 3               
002900r 3               
002900r 3               nt_cold:
002900r 3  04 00                .byte 4, 0
002902r 3  rr rr rr rr          .word nt_bye, xt_cold, z_cold
002906r 3  rr rr        
002908r 3  63 6F 6C 64          .byte "cold"
00290Cr 3               
00290Cr 3               nt_lcdput:
00290Cr 3  06 10                .byte 6, UF
00290Er 3  rr rr rr rr          .word nt_cold, xt_lcdput, z_lcdput
002912r 3  rr rr        
002914r 3  6C 63 64 70          .byte "lcdput"
002918r 3  75 74        
00291Ar 3               
00291Ar 3               nt_lcdprint:
00291Ar 3  08 10                .byte 8, UF
00291Cr 3  rr rr rr rr          .word nt_lcdput, xt_lcdprint, z_lcdprint
002920r 3  rr rr        
002922r 3  6C 63 64 70          .byte "lcdprint"
002926r 3  72 69 6E 74  
00292Ar 3               
00292Ar 3               nt_cls:
00292Ar 3  03 00                .byte 3, 0
00292Cr 3  rr rr rr rr          .word nt_lcdprint, xt_cls, z_cls
002930r 3  rr rr        
002932r 3  63 6C 73             .byte "cls"
002935r 3               
002935r 3               .ifdef VIA1_BASE
002935r 3               nt_spi_init:
002935r 3                       .byte 8, 0
002935r 3                       .word nt_cls, xt_spi_init, z_spi_init
002935r 3                       .byte "spi_init"
002935r 3               
002935r 3               
002935r 3               nt_spi_clk_toggle:
002935r 3                       .byte 14, 0
002935r 3                       .word nt_spi_init, xt_spi_clk_toggle, z_spi_clk_toggle
002935r 3                       .byte "spi_clk_toggle"
002935r 3               
002935r 3               nt_spi_select:
002935r 3                       .byte 10, 0
002935r 3                       .word nt_spi_clk_toggle, xt_spi_select, z_spi_select
002935r 3                       .byte "spi_select"
002935r 3               
002935r 3               nt_spi_transceive:
002935r 3                       .byte 14, 0
002935r 3                       .word nt_spi_select, xt_spi_transceive, z_spi_transceive
002935r 3                       .byte "spi_transceive"
002935r 3               .endif
002935r 3               
002935r 3               
002935r 3               .ifdef CF_ADDRESS
002935r 3               nt_cf_info:
002935r 3                       .byte 4, 0
002935r 3                       .ifdef VIA1_BASE
002935r 3                       .word nt_spi_select, xt_cf_info, z_cf_info
002935r 3                       .else
002935r 3                       .word nt_cls, xt_cf_info, z_cf_info
002935r 3                       .endif
002935r 3                       .byte "info"
002935r 3               .endif
002935r 3               .ifdef io_read_sector_address
002935r 3               nt_io_readblock:
002935r 3                       .byte 2, 0
002935r 3                       .ifdef CF_ADDRESS
002935r 3                       .word nt_cf_info, xt_io_readblock, z_io_readblock
002935r 3                       .elseif .def(VIA1_BASE)
002935r 3                       .word nt_spi_transceive, xt_io_readblock, z_io_readblock
002935r 3                       .else
002935r 3                       .word nt_cls, xt_io_readblock, z_io_readblock
002935r 3                       .endif
002935r 3                       .byte "rb"
002935r 3               nt_io_writeblock:
002935r 3                       .byte 2, 0
002935r 3                       .word nt_io_readblock, xt_io_writeblock, z_io_writeblock
002935r 3                       .byte "wb"
002935r 3               .endif
002935r 3               nt_time:
002935r 3  04 00                .byte 4, 0
002937r 3               .ifdef io_read_sector_address
002937r 3                       .word nt_io_writeblock, xt_time, z_time
002937r 3               .elseif .def(CF_ADDRESS)
002937r 3                       .word nt_cf_info, xt_time, z_time
002937r 3               .elseif .def(VIA1_BASE)
002937r 3                       .word nt_spi_transceive, xt_time, z_time
002937r 3               .else
002937r 3  rr rr rr rr          .word nt_cls, xt_time, z_time
00293Br 3  rr rr        
00293Dr 3               .endif
00293Dr 3  74 69 6D 65          .byte "time"
002941r 3               
002941r 3               nt_ed:                  ; ed6502
002941r 3  02 08                .byte 2, NN
002943r 3  rr rr rr rr          .word nt_time, xt_ed, z_ed
002947r 3  rr rr        
002949r 3  65 64                .byte "ed"
00294Br 3               
00294Br 3  03 08        nt_see: .byte 3, NN
00294Dr 3  rr rr rr rr          .word nt_ed, xt_see, z_see
002951r 3  rr rr        
002953r 3  73 65 65             .byte "see"
002956r 3               
002956r 3               nt_forth:
002956r 3  05 00                .byte 5, 0
002958r 3  rr rr rr rr          .word nt_see, xt_forth, z_forth
00295Cr 3  rr rr        
00295Er 3  66 6F 72 74          .byte "forth"
002962r 3  68           
002963r 3               
002963r 3               nt_order:
002963r 3  05 00                .byte 5, 0
002965r 3  rr rr rr rr          .word nt_forth, xt_order, z_order
002969r 3  rr rr        
00296Br 3  6F 72 64 65          .byte "order"
00296Fr 3  72           
002970r 3               
002970r 3               nt_to_order:
002970r 3  06 00                .byte 6, 0
002972r 3  rr rr rr rr          .word nt_order, xt_to_order, z_to_order
002976r 3  rr rr        
002978r 3  3E 6F 72 64          .byte ">order"
00297Cr 3  65 72        
00297Er 3               
00297Er 3               nt_previous:
00297Er 3  08 00                .byte 8, 0
002980r 3  rr rr rr rr          .word nt_to_order, xt_previous, z_previous
002984r 3  rr rr        
002986r 3  70 72 65 76          .byte "previous"
00298Ar 3  69 6F 75 73  
00298Er 3               
00298Er 3               nt_also:
00298Er 3  04 00                .byte 4, 0
002990r 3  rr rr rr rr          .word nt_previous, xt_also, z_also
002994r 3  rr rr        
002996r 3  61 6C 73 6F          .byte "also"
00299Ar 3               
00299Ar 3               nt_only:
00299Ar 3  04 00                .byte 4, 0
00299Cr 3  rr rr rr rr          .word nt_also, xt_only, z_only
0029A0r 3  rr rr        
0029A2r 3  6F 6E 6C 79          .byte "only"
0029A6r 3               
0029A6r 3               nt_forth_wordlist:      ; shares code with ZERO
0029A6r 3  0E 00                .byte 14, 0
0029A8r 3  rr rr rr rr          .word nt_only, xt_forth_wordlist, z_forth_wordlist
0029ACr 3  rr rr        
0029AEr 3  66 6F 72 74          .byte "forth-wordlist"
0029B2r 3  68 2D 77 6F  
0029B6r 3  72 64 6C 69  
0029BCr 3               
0029BCr 3               nt_editor_wordlist:     ; shares code with ONE
0029BCr 3  0F 00                .byte 15, 0
0029BEr 3  rr rr rr rr          .word nt_forth_wordlist, xt_editor_wordlist, z_editor_wordlist
0029C2r 3  rr rr        
0029C4r 3  65 64 69 74          .byte "editor-wordlist"
0029C8r 3  6F 72 2D 77  
0029CCr 3  6F 72 64 6C  
0029D3r 3               
0029D3r 3               nt_assembler_wordlist:  ; shares code with TWO
0029D3r 3  12 00                .byte 18, 0
0029D5r 3  rr rr rr rr          .word nt_editor_wordlist, xt_assembler_wordlist, z_assembler_wordlist
0029D9r 3  rr rr        
0029DBr 3  61 73 73 65          .byte "assembler-wordlist"
0029DFr 3  6D 62 6C 65  
0029E3r 3  72 2D 77 6F  
0029EDr 3               
0029EDr 3               nt_root_wordlist:
0029EDr 3  0D 00                .byte 13, 0
0029EFr 3  rr rr rr rr          .word nt_assembler_wordlist, xt_root_wordlist, z_root_wordlist
0029F3r 3  rr rr        
0029F5r 3  72 6F 6F 74          .byte "root-wordlist"
0029F9r 3  2D 77 6F 72  
0029FDr 3  64 6C 69 73  
002A02r 3               
002A02r 3               nt_get_order:
002A02r 3  09 00                .byte 9, 0
002A04r 3  rr rr rr rr          .word nt_root_wordlist, xt_get_order, z_get_order
002A08r 3  rr rr        
002A0Ar 3  67 65 74 2D          .byte "get-order"
002A0Er 3  6F 72 64 65  
002A12r 3  72           
002A13r 3               
002A13r 3               nt_set_order:
002A13r 3  09 00                .byte 9, 0
002A15r 3  rr rr rr rr          .word nt_get_order, xt_set_order, z_set_order
002A19r 3  rr rr        
002A1Br 3  73 65 74 2D          .byte "set-order"
002A1Fr 3  6F 72 64 65  
002A23r 3  72           
002A24r 3               
002A24r 3               nt_get_current:
002A24r 3  0B 00                .byte 11, 0
002A26r 3  rr rr rr rr          .word nt_set_order, xt_get_current, z_get_current
002A2Ar 3  rr rr        
002A2Cr 3  67 65 74 2D          .byte "get-current"
002A30r 3  63 75 72 72  
002A34r 3  65 6E 74     
002A37r 3               
002A37r 3               nt_set_current:
002A37r 3  0B 10                .byte 11, UF
002A39r 3  rr rr rr rr          .word nt_get_current, xt_set_current, z_set_current
002A3Dr 3  rr rr        
002A3Fr 3  73 65 74 2D          .byte "set-current"
002A43r 3  63 75 72 72  
002A47r 3  65 6E 74     
002A4Ar 3               
002A4Ar 3               nt_search_wordlist:
002A4Ar 3  0F 10                .byte 15, UF
002A4Cr 3  rr rr rr rr          .word nt_set_current, xt_search_wordlist, z_search_wordlist
002A50r 3  rr rr        
002A52r 3  73 65 61 72          .byte "search-wordlist"
002A56r 3  63 68 2D 77  
002A5Ar 3  6F 72 64 6C  
002A61r 3               
002A61r 3               nt_wordlist:
002A61r 3  08 00                .byte 8, 0
002A63r 3  rr rr rr rr          .word nt_search_wordlist, xt_wordlist, z_wordlist
002A67r 3  rr rr        
002A69r 3  77 6F 72 64          .byte "wordlist"
002A6Dr 3  6C 69 73 74  
002A71r 3               
002A71r 3               nt_definitions:
002A71r 3  0B 00                .byte 11, 0
002A73r 3  rr rr rr rr          .word nt_wordlist, xt_definitions, z_definitions
002A77r 3  rr rr        
002A79r 3  64 65 66 69          .byte "definitions"
002A7Dr 3  6E 69 74 69  
002A81r 3  6F 6E 73     
002A84r 3               
002A84r 3               nt_block_ramdrive_init:
002A84r 3  13 10                .byte 19, UF
002A86r 3  rr rr rr rr          .word nt_definitions, xt_block_ramdrive_init, z_block_ramdrive_init
002A8Ar 3  rr rr        
002A8Cr 3  62 6C 6F 63          .byte "block-ramdrive-init"
002A90r 3  6B 2D 72 61  
002A94r 3  6D 64 72 69  
002A9Fr 3               
002A9Fr 3               nt_list:
002A9Fr 3  04 10                .byte 4, UF
002AA1r 3  rr rr rr rr          .word nt_block_ramdrive_init, xt_list, z_list
002AA5r 3  rr rr        
002AA7r 3  6C 69 73 74          .byte "list"
002AABr 3               
002AABr 3               nt_thru:
002AABr 3  04 10                .byte 4, UF
002AADr 3  rr rr rr rr          .word nt_list, xt_thru, z_thru
002AB1r 3  rr rr        
002AB3r 3  74 68 72 75          .byte "thru"
002AB7r 3               
002AB7r 3               nt_load:
002AB7r 3  04 10                .byte 4, UF
002AB9r 3  rr rr rr rr          .word nt_thru, xt_load, z_load
002ABDr 3  rr rr        
002ABFr 3  6C 6F 61 64          .byte "load"
002AC3r 3               
002AC3r 3               nt_flush:
002AC3r 3  05 00                .byte 5, 0
002AC5r 3  rr rr rr rr          .word nt_load, xt_flush, z_flush
002AC9r 3  rr rr        
002ACBr 3  66 6C 75 73          .byte "flush"
002ACFr 3  68           
002AD0r 3               
002AD0r 3               nt_empty_buffers:
002AD0r 3  0D 00                .byte 13, 0
002AD2r 3  rr rr rr rr          .word nt_flush, xt_empty_buffers, z_empty_buffers
002AD6r 3  rr rr        
002AD8r 3  65 6D 70 74          .byte "empty-buffers"
002ADCr 3  79 2D 62 75  
002AE0r 3  66 66 65 72  
002AE5r 3               
002AE5r 3               nt_buffer:
002AE5r 3  06 00                .byte 6, 0
002AE7r 3  rr rr rr rr          .word nt_empty_buffers, xt_buffer, z_buffer
002AEBr 3  rr rr        
002AEDr 3  62 75 66 66          .byte "buffer"
002AF1r 3  65 72        
002AF3r 3               
002AF3r 3               nt_update:
002AF3r 3  06 00                .byte 6, 0
002AF5r 3  rr rr rr rr          .word nt_buffer, xt_update, z_update
002AF9r 3  rr rr        
002AFBr 3  75 70 64 61          .byte "update"
002AFFr 3  74 65        
002B01r 3               
002B01r 3               nt_block:
002B01r 3  05 00                .byte 5, 0
002B03r 3  rr rr rr rr          .word nt_update, xt_block, z_block
002B07r 3  rr rr        
002B09r 3  62 6C 6F 63          .byte "block"
002B0Dr 3  6B           
002B0Er 3               
002B0Er 3               nt_save_buffers:
002B0Er 3  0C 00                .byte 12, 0
002B10r 3  rr rr rr rr          .word nt_block, xt_save_buffers, z_save_buffers
002B14r 3  rr rr        
002B16r 3  73 61 76 65          .byte "save-buffers"
002B1Ar 3  2D 62 75 66  
002B1Er 3  66 65 72 73  
002B22r 3               
002B22r 3               nt_block_read_vector:
002B22r 3  11 28                .byte 17, HC+NN ; Deferred words need the HC (Code Field) flag.
002B24r 3  rr rr rr rr          .word nt_save_buffers, xt_block_read_vector, z_block_read_vector
002B28r 3  rr rr        
002B2Ar 3  62 6C 6F 63          .byte "block-read-vector"
002B2Er 3  6B 2D 72 65  
002B32r 3  61 64 2D 76  
002B3Br 3               
002B3Br 3               nt_block_read:
002B3Br 3  0A 28                .byte 10, HC+NN ; Deferred words need the HC (Code Field) flag.
002B3Dr 3  rr rr rr rr          .word nt_block_read_vector, xt_block_read, z_block_read
002B41r 3  rr rr        
002B43r 3  62 6C 6F 63          .byte "block-read"
002B47r 3  6B 2D 72 65  
002B4Br 3  61 64        
002B4Dr 3               
002B4Dr 3               nt_block_write_vector:
002B4Dr 3  12 08                .byte 18, NN ; Deferred words need the HC (Code Field) flag.
002B4Fr 3  rr rr rr rr          .word nt_block_read, xt_block_write_vector, z_block_write_vector
002B53r 3  rr rr        
002B55r 3  62 6C 6F 63          .byte "block-write-vector"
002B59r 3  6B 2D 77 72  
002B5Dr 3  69 74 65 2D  
002B67r 3               
002B67r 3               nt_block_write:
002B67r 3  0B 08                .byte 11, NN ; Deferred words need the HC (Code Field) flag.
002B69r 3  rr rr rr rr          .word nt_block_write_vector, xt_block_write, z_block_write
002B6Dr 3  rr rr        
002B6Fr 3  62 6C 6F 63          .byte "block-write"
002B73r 3  6B 2D 77 72  
002B77r 3  69 74 65     
002B7Ar 3               
002B7Ar 3               nt_blk:
002B7Ar 3  03 00                .byte 3, 0
002B7Cr 3  rr rr rr rr          .word nt_block_write, xt_blk, z_blk
002B80r 3  rr rr        
002B82r 3  62 6C 6B             .byte "blk"
002B85r 3               
002B85r 3               nt_scr:
002B85r 3  03 00                .byte 3, 0
002B87r 3  rr rr rr rr          .word nt_blk, xt_scr, z_scr
002B8Br 3  rr rr        
002B8Dr 3  73 63 72             .byte "scr"
002B90r 3               
002B90r 3               nt_blkbuffer:
002B90r 3  09 00                .byte 9, 0
002B92r 3  rr rr rr rr          .word nt_scr, xt_blkbuffer, z_blkbuffer
002B96r 3  rr rr        
002B98r 3  62 6C 6B 62          .byte "blkbuffer"
002B9Cr 3  75 66 66 65  
002BA0r 3  72           
002BA1r 3               
002BA1r 3               nt_buffblocknum:
002BA1r 3  0C 00                .byte 12, 0
002BA3r 3  rr rr rr rr          .word nt_blkbuffer, xt_buffblocknum, z_buffblocknum
002BA7r 3  rr rr        
002BA9r 3  62 75 66 66          .byte "buffblocknum"
002BADr 3  62 6C 6F 63  
002BB1r 3  6B 6E 75 6D  
002BB5r 3               
002BB5r 3               nt_buffstatus:
002BB5r 3  0A 00                .byte 10, 0
002BB7r 3  rr rr rr rr          .word nt_buffblocknum, xt_buffstatus, z_buffstatus
002BBBr 3  rr rr        
002BBDr 3  62 75 66 66          .byte "buffstatus"
002BC1r 3  73 74 61 74  
002BC5r 3  75 73        
002BC7r 3               
002BC7r 3               nt_buffer_colon:
002BC7r 3  07 00                .byte 7, 0
002BC9r 3  rr rr rr rr          .word nt_buffstatus, xt_buffer_colon, z_buffer_colon
002BCDr 3  rr rr        
002BCFr 3  62 75 66 66          .byte "buffer:"
002BD3r 3  65 72 3A     
002BD6r 3               
002BD6r 3               nt_useraddr:
002BD6r 3  08 00                .byte 8, 0
002BD8r 3  rr rr rr rr          .word nt_buffer_colon, xt_useraddr, z_useraddr
002BDCr 3  rr rr        
002BDEr 3  75 73 65 72          .byte "useraddr"
002BE2r 3  61 64 64 72  
002BE6r 3               
002BE6r 3               nt_action_of:
002BE6r 3  09 04                .byte 9, IM
002BE8r 3  rr rr rr rr          .word nt_useraddr, xt_action_of, z_action_of
002BECr 3  rr rr        
002BEEr 3  61 63 74 69          .byte "action-of"
002BF2r 3  6F 6E 2D 6F  
002BF6r 3  66           
002BF7r 3               
002BF7r 3               nt_is:
002BF7r 3  02 04                .byte 2, IM
002BF9r 3  rr rr rr rr          .word nt_action_of, xt_is, z_is
002BFDr 3  rr rr        
002BFFr 3  69 73                .byte "is"
002C01r 3               
002C01r 3               nt_defer_store:
002C01r 3  06 00                .byte 6, 0
002C03r 3  rr rr rr rr          .word nt_is, xt_defer_store, z_defer_store
002C07r 3  rr rr        
002C09r 3  64 65 66 65          .byte "defer!"
002C0Dr 3  72 21        
002C0Fr 3               
002C0Fr 3               nt_defer_fetch:
002C0Fr 3  06 00                .byte 6, 0
002C11r 3  rr rr rr rr          .word nt_defer_store, xt_defer_fetch, z_defer_fetch
002C15r 3  rr rr        
002C17r 3  64 65 66 65          .byte "defer@"
002C1Br 3  72 40        
002C1Dr 3               
002C1Dr 3               nt_endcase:
002C1Dr 3  07 0D                .byte 7, IM+CO+NN
002C1Fr 3  rr rr rr rr          .word nt_defer_fetch, xt_endcase, z_endcase
002C23r 3  rr rr        
002C25r 3  65 6E 64 63          .byte "endcase"
002C29r 3  61 73 65     
002C2Cr 3               
002C2Cr 3               nt_endof:
002C2Cr 3  05 0D                .byte 5, IM+CO+NN
002C2Er 3  rr rr rr rr          .word nt_endcase, xt_endof, z_endof ; shares code with ELSE
002C32r 3  rr rr        
002C34r 3  65 6E 64 6F          .byte "endof"
002C38r 3  66           
002C39r 3               
002C39r 3               nt_of:
002C39r 3  02 0D                .byte 2, IM+CO+NN
002C3Br 3  rr rr rr rr          .word nt_endof, xt_of, z_of
002C3Fr 3  rr rr        
002C41r 3  6F 66                .byte "of"
002C43r 3               
002C43r 3               nt_case:
002C43r 3  04 0D                .byte 4, IM+CO+NN
002C45r 3  rr rr rr rr          .word nt_of, xt_case, z_case    ; shares code with ZERO
002C49r 3  rr rr        
002C4Br 3  63 61 73 65          .byte "case"
002C4Fr 3               
002C4Fr 3               nt_while:
002C4Fr 3  05 0D                .byte 5, IM+CO+NN
002C51r 3  rr rr rr rr          .word nt_case, xt_while, z_while
002C55r 3  rr rr        
002C57r 3  77 68 69 6C          .byte "while"
002C5Br 3  65           
002C5Cr 3               
002C5Cr 3               nt_until:
002C5Cr 3  05 0D                .byte 5, IM+CO+NN
002C5Er 3  rr rr rr rr          .word nt_while, xt_until, z_until
002C62r 3  rr rr        
002C64r 3  75 6E 74 69          .byte "until"
002C68r 3  6C           
002C69r 3               
002C69r 3               nt_repeat:
002C69r 3  06 0D                .byte 6, IM+CO+NN
002C6Br 3  rr rr rr rr          .word nt_until, xt_repeat, z_repeat
002C6Fr 3  rr rr        
002C71r 3  72 65 70 65          .byte "repeat"
002C75r 3  61 74        
002C77r 3               
002C77r 3               nt_else:
002C77r 3  04 0D                .byte 4, IM+CO+NN
002C79r 3  rr rr rr rr          .word nt_repeat, xt_else, z_else
002C7Dr 3  rr rr        
002C7Fr 3  65 6C 73 65          .byte "else"
002C83r 3               
002C83r 3               nt_then:
002C83r 3  04 0D                .byte 4, IM+CO+NN
002C85r 3  rr rr rr rr          .word nt_else, xt_then, z_then
002C89r 3  rr rr        
002C8Br 3  74 68 65 6E          .byte "then"
002C8Fr 3               
002C8Fr 3               nt_if:
002C8Fr 3  02 0D                .byte 2, IM+CO+NN
002C91r 3  rr rr rr rr          .word nt_then, xt_if, z_if
002C95r 3  rr rr        
002C97r 3  69 66                .byte "if"
002C99r 3               
002C99r 3               nt_dot_paren:
002C99r 3  02 04                .byte 2, IM
002C9Br 3  rr rr rr rr          .word nt_if, xt_dot_paren, z_dot_paren
002C9Fr 3  rr rr        
002CA1r 3  2E 28                .byte ".("
002CA3r 3               
002CA3r 3               nt_paren:
002CA3r 3  01 04                .byte 1, IM
002CA5r 3  rr rr rr rr          .word nt_dot_paren, xt_paren, z_paren
002CA9r 3  rr rr        
002CABr 3  28                   .byte "("
002CACr 3               
002CACr 3               nt_word:
002CACr 3  04 10                .byte 4, UF
002CAEr 3  rr rr rr rr          .word nt_paren, xt_word, z_word
002CB2r 3  rr rr        
002CB4r 3  77 6F 72 64          .byte "word"
002CB8r 3               
002CB8r 3               nt_find:
002CB8r 3  04 10                .byte 4, UF
002CBAr 3  rr rr rr rr          .word nt_word, xt_find, z_find
002CBEr 3  rr rr        
002CC0r 3  66 69 6E 64          .byte "find"
002CC4r 3               
002CC4r 3               nt_environment_q:
002CC4r 3  0C 10                .byte 12, UF
002CC6r 3  rr rr rr rr          .word nt_find, xt_environment_q, z_environment_q
002CCAr 3  rr rr        
002CCCr 3  65 6E 76 69          .byte "environment?"
002CD0r 3  72 6F 6E 6D  
002CD4r 3  65 6E 74 3F  
002CD8r 3               
002CD8r 3               nt_search:
002CD8r 3  06 18                .byte 6, UF+NN
002CDAr 3  rr rr rr rr          .word nt_environment_q, xt_search, z_search
002CDEr 3  rr rr        
002CE0r 3  73 65 61 72          .byte "search"
002CE4r 3  63 68        
002CE6r 3               
002CE6r 3               nt_compare:
002CE6r 3  07 10                .byte 7, UF
002CE8r 3  rr rr rr rr          .word nt_search, xt_compare, z_compare
002CECr 3  rr rr        
002CEEr 3  63 6F 6D 70          .byte "compare"
002CF2r 3  61 72 65     
002CF5r 3               
002CF5r 3               nt_disasm:
002CF5r 3  06 10                .byte 6, UF
002CF7r 3  rr rr rr rr          .word nt_compare, xt_disasm, z_disasm
002CFBr 3  rr rr        
002CFDr 3  64 69 73 61          .byte "disasm"
002D01r 3  73 6D        
002D03r 3               
002D03r 3               nt_dot_s:
002D03r 3  02 00                .byte 2, 0
002D05r 3  rr rr rr rr          .word nt_disasm, xt_dot_s, z_dot_s
002D09r 3  rr rr        
002D0Br 3  2E 73                .byte ".s"
002D0Dr 3               
002D0Dr 3               nt_dump:
002D0Dr 3  04 10                .byte 4, UF
002D0Fr 3  rr rr rr rr          .word nt_dot_s, xt_dump, z_dump
002D13r 3  rr rr        
002D15r 3  64 75 6D 70          .byte "dump"
002D19r 3               
002D19r 3               nt_bell:
002D19r 3  04 00                .byte 4, 0
002D1Br 3  rr rr rr rr          .word nt_dump, xt_bell, z_bell
002D1Fr 3  rr rr        
002D21r 3  62 65 6C 6C          .byte "bell"
002D25r 3               
002D25r 3               nt_align:
002D25r 3  05 00                .byte 5, 0
002D27r 3  rr rr rr rr          .word nt_bell, xt_align, z_align
002D2Br 3  rr rr        
002D2Dr 3  61 6C 69 67          .byte "align"
002D31r 3  6E           
002D32r 3               
002D32r 3               nt_aligned:             ; same code as ALIGN
002D32r 3  07 00                .byte 7, 0
002D34r 3  rr rr rr rr          .word nt_align, xt_align, z_align
002D38r 3  rr rr        
002D3Ar 3  61 6C 69 67          .byte "aligned"
002D3Er 3  6E 65 64     
002D41r 3               
002D41r 3               nt_wordsize:
002D41r 3  08 10                .byte 8, UF
002D43r 3  rr rr rr rr          .word nt_aligned, xt_wordsize, z_wordsize
002D47r 3  rr rr        
002D49r 3  77 6F 72 64          .byte "wordsize"
002D4Dr 3  73 69 7A 65  
002D51r 3               
002D51r 3               nt_words:
002D51r 3  05 00                .byte 5, 0
002D53r 3  rr rr rr rr          .word nt_wordsize, xt_words, z_words
002D57r 3  rr rr        
002D59r 3  77 6F 72 64          .byte "words"
002D5Dr 3  73           
002D5Er 3               
002D5Er 3               nt_marker:
002D5Er 3  06 04                .byte 6, IM
002D60r 3  rr rr rr rr          .word nt_words, xt_marker, z_marker
002D64r 3  rr rr        
002D66r 3  6D 61 72 6B          .byte "marker"
002D6Ar 3  65 72        
002D6Cr 3               
002D6Cr 3               nt_at_xy:
002D6Cr 3  05 10                .byte 5, UF
002D6Er 3  rr rr rr rr          .word nt_marker, xt_at_xy, z_at_xy
002D72r 3  rr rr        
002D74r 3  61 74 2D 78          .byte "at-xy"
002D78r 3  79           
002D79r 3               
002D79r 3               nt_page:
002D79r 3  04 00                .byte 4, 0
002D7Br 3  rr rr rr rr          .word nt_at_xy, xt_page, z_page
002D7Fr 3  rr rr        
002D81r 3  70 61 67 65          .byte "page"
002D85r 3               
002D85r 3               nt_cr:
002D85r 3  02 00                .byte 2, 0
002D87r 3  rr rr rr rr          .word nt_page, xt_cr, z_cr
002D8Br 3  rr rr        
002D8Dr 3  63 72                .byte "cr"
002D8Fr 3               
002D8Fr 3               nt_input:
002D8Fr 3  05 00                .byte 5, 0
002D91r 3  rr rr rr rr          .word nt_cr, xt_input, z_input
002D95r 3  rr rr        
002D97r 3  69 6E 70 75          .byte "input"
002D9Br 3  74           
002D9Cr 3               
002D9Cr 3               nt_output:
002D9Cr 3  06 00                .byte 6, 0
002D9Er 3  rr rr rr rr          .word nt_input, xt_output, z_output
002DA2r 3  rr rr        
002DA4r 3  6F 75 74 70          .byte "output"
002DA8r 3  75 74        
002DAAr 3               
002DAAr 3               nt_sign:
002DAAr 3  04 10                .byte 4, UF
002DACr 3  rr rr rr rr          .word nt_output, xt_sign, z_sign
002DB0r 3  rr rr        
002DB2r 3  73 69 67 6E          .byte "sign"
002DB6r 3               
002DB6r 3               nt_hold:
002DB6r 3  04 10                .byte 4, UF
002DB8r 3  rr rr rr rr          .word nt_sign, xt_hold, z_hold
002DBCr 3  rr rr        
002DBEr 3  68 6F 6C 64          .byte "hold"
002DC2r 3               
002DC2r 3               nt_number_sign_greater:
002DC2r 3  02 10                .byte 2, UF
002DC4r 3  rr rr rr rr          .word nt_hold, xt_number_sign_greater, z_number_sign_greater
002DC8r 3  rr rr        
002DCAr 3  23 3E                .byte "#>"
002DCCr 3               
002DCCr 3               nt_number_sign_s:
002DCCr 3  02 10                .byte 2, UF
002DCEr 3  rr rr rr rr          .word nt_number_sign_greater, xt_number_sign_s, z_number_sign_s
002DD2r 3  rr rr        
002DD4r 3  23 73                .byte "#s"
002DD6r 3               
002DD6r 3               nt_number_sign:
002DD6r 3  01 10                .byte 1, UF
002DD8r 3  rr rr rr rr          .word nt_number_sign_s, xt_number_sign, z_number_sign
002DDCr 3  rr rr        
002DDEr 3  23                   .byte "#"
002DDFr 3               
002DDFr 3               nt_less_number_sign:
002DDFr 3  02 00                .byte 2, 0
002DE1r 3  rr rr rr rr          .word nt_number_sign, xt_less_number_sign, z_less_number_sign
002DE5r 3  rr rr        
002DE7r 3  3C 23                .byte "<#"
002DE9r 3               
002DE9r 3               nt_to_in:
002DE9r 3  03 00                .byte 3, 0
002DEBr 3  rr rr rr rr          .word nt_less_number_sign, xt_to_in, z_to_in
002DEFr 3  rr rr        
002DF1r 3  3E 69 6E             .byte ">in"
002DF4r 3               
002DF4r 3               nt_within:
002DF4r 3  06 10                .byte 6, UF
002DF6r 3  rr rr rr rr          .word nt_to_in, xt_within, z_within
002DFAr 3  rr rr        
002DFCr 3  77 69 74 68          .byte "within"
002E00r 3  69 6E        
002E02r 3               
002E02r 3               nt_hexstore:
002E02r 3  08 10                .byte 8, UF
002E04r 3  rr rr rr rr          .word nt_within, xt_hexstore, z_hexstore
002E08r 3  rr rr        
002E0Ar 3  68 65 78 73          .byte "hexstore"
002E0Er 3  74 6F 72 65  
002E12r 3               
002E12r 3               nt_cleave:
002E12r 3  06 10                .byte 6, UF
002E14r 3  rr rr rr rr          .word nt_hexstore, xt_cleave, z_cleave
002E18r 3  rr rr        
002E1Ar 3  63 6C 65 61          .byte "cleave"
002E1Er 3  76 65        
002E20r 3               
002E20r 3               nt_pad:
002E20r 3  03 00                .byte 3, 0
002E22r 3  rr rr rr rr          .word nt_cleave, xt_pad, z_pad
002E26r 3  rr rr        
002E28r 3  70 61 64             .byte "pad"
002E2Br 3               
002E2Br 3               nt_cmove:
002E2Br 3  05 10                .byte 5, UF
002E2Dr 3  rr rr rr rr          .word nt_pad, xt_cmove, z_cmove
002E31r 3  rr rr        
002E33r 3  63 6D 6F 76          .byte "cmove"
002E37r 3  65           
002E38r 3               
002E38r 3               nt_cmove_up:
002E38r 3  06 10                .byte 6, UF
002E3Ar 3  rr rr rr rr          .word nt_cmove, xt_cmove_up, z_cmove_up
002E3Er 3  rr rr        
002E40r 3  63 6D 6F 76          .byte "cmove>"
002E44r 3  65 3E        
002E46r 3               
002E46r 3               nt_move:
002E46r 3  04 18                .byte 4, NN+UF
002E48r 3  rr rr rr rr          .word nt_cmove_up, xt_move, z_move
002E4Cr 3  rr rr        
002E4Er 3  6D 6F 76 65          .byte "move"
002E52r 3               
002E52r 3               nt_backslash:
002E52r 3  01 04                .byte 1, IM
002E54r 3  rr rr rr rr          .word nt_move, xt_backslash, z_backslash
002E58r 3  rr rr        
002E5Ar 3  5C                   .byte $5c
002E5Br 3               
002E5Br 3               nt_star_slash:
002E5Br 3  02 10                .byte 2, UF
002E5Dr 3  rr rr rr rr          .word nt_backslash, xt_star_slash, z_star_slash
002E61r 3  rr rr        
002E63r 3  2A 2F                .byte "*/"
002E65r 3               
002E65r 3               nt_star_slash_mod:
002E65r 3  05 10                .byte 5, UF
002E67r 3  rr rr rr rr          .word nt_star_slash, xt_star_slash_mod, z_star_slash_mod
002E6Br 3  rr rr        
002E6Dr 3  2A 2F 6D 6F          .byte "*/mod"
002E71r 3  64           
002E72r 3               
002E72r 3               nt_mod:
002E72r 3  03 10                .byte 3, UF
002E74r 3  rr rr rr rr          .word nt_star_slash_mod, xt_mod, z_mod
002E78r 3  rr rr        
002E7Ar 3  6D 6F 64             .byte "mod"
002E7Dr 3               
002E7Dr 3               nt_slash_mod:
002E7Dr 3  04 10                .byte 4, UF
002E7Fr 3  rr rr rr rr          .word nt_mod, xt_slash_mod, z_slash_mod
002E83r 3  rr rr        
002E85r 3  2F 6D 6F 64          .byte "/mod"
002E89r 3               
002E89r 3               nt_slash:
002E89r 3  01 10                .byte 1, UF
002E8Br 3  rr rr rr rr          .word nt_slash_mod, xt_slash, z_slash
002E8Fr 3  rr rr        
002E91r 3  2F                   .byte "/"
002E92r 3               
002E92r 3               nt_fm_slash_mod:
002E92r 3  06 10                .byte 6, UF
002E94r 3  rr rr rr rr          .word nt_slash, xt_fm_slash_mod, z_fm_slash_mod
002E98r 3  rr rr        
002E9Ar 3  66 6D 2F 6D          .byte "fm/mod"
002E9Er 3  6F 64        
002EA0r 3               
002EA0r 3               nt_sm_slash_rem:
002EA0r 3  06 10                .byte 6, UF
002EA2r 3  rr rr rr rr          .word nt_fm_slash_mod, xt_sm_slash_rem, z_sm_slash_rem
002EA6r 3  rr rr        
002EA8r 3  73 6D 2F 72          .byte "sm/rem"
002EACr 3  65 6D        
002EAEr 3               
002EAEr 3               nt_um_slash_mod:
002EAEr 3  06 10                .byte 6, UF
002EB0r 3  rr rr rr rr          .word nt_sm_slash_rem, xt_um_slash_mod, z_um_slash_mod
002EB4r 3  rr rr        
002EB6r 3  75 6D 2F 6D          .byte "um/mod"
002EBAr 3  6F 64        
002EBCr 3               
002EBCr 3               nt_star:
002EBCr 3  01 10                .byte 1, UF
002EBEr 3  rr rr rr rr          .word nt_um_slash_mod, xt_star, z_star
002EC2r 3  rr rr        
002EC4r 3  2A                   .byte "*"
002EC5r 3               
002EC5r 3               nt_um_star:
002EC5r 3  03 10                .byte 3, UF
002EC7r 3  rr rr rr rr          .word nt_star, xt_um_star, z_um_star
002ECBr 3  rr rr        
002ECDr 3  75 6D 2A             .byte "um*"
002ED0r 3               
002ED0r 3               nt_m_star:
002ED0r 3  02 10                .byte 2, UF
002ED2r 3  rr rr rr rr          .word nt_um_star, xt_m_star, z_m_star
002ED6r 3  rr rr        
002ED8r 3  6D 2A                .byte "m*"
002EDAr 3               
002EDAr 3               nt_count:
002EDAr 3  05 10                .byte 5, UF
002EDCr 3  rr rr rr rr          .word nt_m_star, xt_count, z_count
002EE0r 3  rr rr        
002EE2r 3  63 6F 75 6E          .byte "count"
002EE6r 3  74           
002EE7r 3               
002EE7r 3               nt_decimal:
002EE7r 3  07 00                .byte 7, 0
002EE9r 3  rr rr rr rr          .word nt_count, xt_decimal, z_decimal
002EEDr 3  rr rr        
002EEFr 3  64 65 63 69          .byte "decimal"
002EF3r 3  6D 61 6C     
002EF6r 3               
002EF6r 3               nt_hex:
002EF6r 3  03 00                .byte 3, 0
002EF8r 3  rr rr rr rr          .word nt_decimal, xt_hex, z_hex
002EFCr 3  rr rr        
002EFEr 3  68 65 78             .byte "hex"
002F01r 3               
002F01r 3               nt_to_number:
002F01r 3  07 10                .byte 7, UF
002F03r 3  rr rr rr rr          .word nt_hex, xt_to_number, z_to_number
002F07r 3  rr rr        
002F09r 3  3E 6E 75 6D          .byte ">number"
002F0Dr 3  62 65 72     
002F10r 3               
002F10r 3               nt_number:
002F10r 3  06 10                .byte 6, UF
002F12r 3  rr rr rr rr          .word nt_to_number, xt_number, z_number
002F16r 3  rr rr        
002F18r 3  6E 75 6D 62          .byte "number"
002F1Cr 3  65 72        
002F1Er 3               
002F1Er 3               nt_digit_question:
002F1Er 3  06 10                .byte 6, UF
002F20r 3  rr rr rr rr          .word nt_number, xt_digit_question, z_digit_question
002F24r 3  rr rr        
002F26r 3  64 69 67 69          .byte "digit?"
002F2Ar 3  74 3F        
002F2Cr 3               
002F2Cr 3               nt_base:
002F2Cr 3  04 00                .byte 4, 0
002F2Er 3  rr rr rr rr          .word nt_digit_question, xt_base, z_base
002F32r 3  rr rr        
002F34r 3  62 61 73 65          .byte "base"
002F38r 3               
002F38r 3               nt_evaluate:
002F38r 3  08 10                .byte 8, UF
002F3Ar 3  rr rr rr rr          .word nt_base, xt_evaluate, z_evaluate
002F3Er 3  rr rr        
002F40r 3  65 76 61 6C          .byte "evaluate"
002F44r 3  75 61 74 65  
002F48r 3               
002F48r 3               nt_state:
002F48r 3  05 00                .byte 5, 0
002F4Ar 3  rr rr rr rr          .word nt_evaluate, xt_state, z_state
002F4Er 3  rr rr        
002F50r 3  73 74 61 74          .byte "state"
002F54r 3  65           
002F55r 3               
002F55r 3               nt_again:
002F55r 3  05 17                .byte 5, AN+CO+IM+UF
002F57r 3  rr rr rr rr          .word nt_state, xt_again, z_again
002F5Br 3  rr rr        
002F5Dr 3  61 67 61 69          .byte "again"
002F61r 3  6E           
002F62r 3               
002F62r 3               nt_begin:
002F62r 3  05 07                .byte 5, AN+CO+IM
002F64r 3  rr rr rr rr          .word nt_again, xt_begin, z_begin
002F68r 3  rr rr        
002F6Ar 3  62 65 67 69          .byte "begin"
002F6Er 3  6E           
002F6Fr 3               
002F6Fr 3               nt_quit:
002F6Fr 3  04 00                .byte 4, 0
002F71r 3  rr rr rr rr          .word nt_begin, xt_quit, z_quit
002F75r 3  rr rr        
002F77r 3  71 75 69 74          .byte "quit"
002F7Br 3               
002F7Br 3               nt_recurse:
002F7Br 3  07 0D                .byte 7, CO+IM+NN
002F7Dr 3  rr rr rr rr          .word nt_quit, xt_recurse, z_recurse
002F81r 3  rr rr        
002F83r 3  72 65 63 75          .byte "recurse"
002F87r 3  72 73 65     
002F8Ar 3               
002F8Ar 3               nt_leave:
002F8Ar 3  05 03                .byte 5, AN+CO
002F8Cr 3  rr rr rr rr          .word nt_recurse, xt_leave, z_leave
002F90r 3  rr rr        
002F92r 3  6C 65 61 76          .byte "leave"
002F96r 3  65           
002F97r 3               
002F97r 3               nt_unloop:
002F97r 3  06 03                .byte 6, AN+CO
002F99r 3  rr rr rr rr          .word nt_leave, xt_unloop, z_unloop
002F9Dr 3  rr rr        
002F9Fr 3  75 6E 6C 6F          .byte "unloop"
002FA3r 3  6F 70        
002FA5r 3               
002FA5r 3               nt_exit:
002FA5r 3  04 03                .byte 4, AN+CO
002FA7r 3  rr rr rr rr          .word nt_unloop, xt_exit, z_exit
002FABr 3  rr rr        
002FADr 3  65 78 69 74          .byte "exit"
002FB1r 3               
002FB1r 3               nt_plus_loop:
002FB1r 3  05 05                .byte 5, CO+IM
002FB3r 3  rr rr rr rr          .word nt_exit, xt_plus_loop, z_plus_loop
002FB7r 3  rr rr        
002FB9r 3  2B 6C 6F 6F          .byte "+loop"
002FBDr 3  70           
002FBEr 3               
002FBEr 3               nt_loop:
002FBEr 3  04 05                .byte 4, CO+IM
002FC0r 3  rr rr rr rr          .word nt_plus_loop, xt_loop, z_loop
002FC4r 3  rr rr        
002FC6r 3  6C 6F 6F 70          .byte "loop"
002FCAr 3               
002FCAr 3               nt_j:
002FCAr 3  01 03                .byte 1, AN+CO
002FCCr 3  rr rr rr rr          .word nt_loop, xt_j, z_j
002FD0r 3  rr rr        
002FD2r 3  6A                   .byte "j"
002FD3r 3               
002FD3r 3               nt_i:
002FD3r 3  01 03                .byte 1, AN+CO
002FD5r 3  rr rr rr rr          .word nt_j, xt_i, z_i
002FD9r 3  rr rr        
002FDBr 3  69                   .byte "i"
002FDCr 3               
002FDCr 3               nt_question_do:
002FDCr 3  03 0D                .byte 3, CO+IM+NN
002FDEr 3  rr rr rr rr          .word nt_i, xt_question_do, z_question_do
002FE2r 3  rr rr        
002FE4r 3  3F 64 6F             .byte "?do"
002FE7r 3               
002FE7r 3               nt_do:
002FE7r 3  02 0D                .byte 2, CO+IM+NN
002FE9r 3  rr rr rr rr          .word nt_question_do, xt_do, z_do
002FEDr 3  rr rr        
002FEFr 3  64 6F                .byte "do"
002FF1r 3               
002FF1r 3               nt_abort_quote:
002FF1r 3  06 0D                .byte 6, CO+IM+NN
002FF3r 3  rr rr rr rr          .word nt_do, xt_abort_quote, z_abort_quote
002FF7r 3  rr rr        
002FF9r 3  61 62 6F 72          .byte "abort", $22
002FFDr 3  74 22        
002FFFr 3               
002FFFr 3               nt_abort:
002FFFr 3  05 00                .byte 5, 0
003001r 3  rr rr rr rr          .word nt_abort_quote, xt_abort, z_abort
003005r 3  rr rr        
003007r 3  61 62 6F 72          .byte "abort"
00300Br 3  74           
00300Cr 3               
00300Cr 3               nt_strip_underflow:
00300Cr 3  0F 00                .byte 15, 0
00300Er 3  rr rr rr rr          .word nt_abort, xt_strip_underflow, z_strip_underflow
003012r 3  rr rr        
003014r 3  73 74 72 69          .byte "strip-underflow"
003018r 3  70 2D 75 6E  
00301Cr 3  64 65 72 66  
003023r 3               
003023r 3               nt_nc_limit:
003023r 3  08 00                .byte 8, 0
003025r 3  rr rr rr rr          .word nt_strip_underflow, xt_nc_limit, z_nc_limit
003029r 3  rr rr        
00302Br 3  6E 63 2D 6C          .byte "nc-limit"
00302Fr 3  69 6D 69 74  
003033r 3               
003033r 3               nt_allow_native:
003033r 3  0C 00                .byte 12, 0
003035r 3  rr rr rr rr          .word nt_nc_limit, xt_allow_native, z_allow_native
003039r 3  rr rr        
00303Br 3  61 6C 6C 6F          .byte "allow-native"
00303Fr 3  77 2D 6E 61  
003043r 3  74 69 76 65  
003047r 3               
003047r 3               nt_always_native:
003047r 3  0D 00                .byte 13, 0
003049r 3  rr rr rr rr          .word nt_allow_native, xt_always_native, z_always_native
00304Dr 3  rr rr        
00304Fr 3  61 6C 77 61          .byte "always-native"
003053r 3  79 73 2D 6E  
003057r 3  61 74 69 76  
00305Cr 3               
00305Cr 3               nt_never_native:
00305Cr 3  0C 00                .byte 12, 0
00305Er 3  rr rr rr rr          .word nt_always_native, xt_never_native, z_never_native
003062r 3  rr rr        
003064r 3  6E 65 76 65          .byte "never-native"
003068r 3  72 2D 6E 61  
00306Cr 3  74 69 76 65  
003070r 3               
003070r 3               nt_compile_only:
003070r 3  0C 00                .byte 12, 0
003072r 3  rr rr rr rr          .word nt_never_native, xt_compile_only, z_compile_only
003076r 3  rr rr        
003078r 3  63 6F 6D 70          .byte "compile-only"
00307Cr 3  69 6C 65 2D  
003080r 3  6F 6E 6C 79  
003084r 3               
003084r 3               nt_immediate:
003084r 3  09 00                .byte 9, 0
003086r 3  rr rr rr rr          .word nt_compile_only, xt_immediate, z_immediate
00308Ar 3  rr rr        
00308Cr 3  69 6D 6D 65          .byte "immediate"
003090r 3  64 69 61 74  
003094r 3  65           
003095r 3               
003095r 3               nt_postpone:
003095r 3  08 05                .byte 8, IM+CO
003097r 3  rr rr rr rr          .word nt_immediate, xt_postpone, z_postpone
00309Br 3  rr rr        
00309Dr 3  70 6F 73 74          .byte "postpone"
0030A1r 3  70 6F 6E 65  
0030A5r 3               
0030A5r 3               nt_s_backslash_quote:
0030A5r 3  03 04                .byte 3, IM
0030A7r 3  rr rr rr rr          .word nt_postpone, xt_s_backslash_quote, z_s_backslash_quote
0030ABr 3  rr rr        
0030ADr 3  73 5C 22             .byte "s", $5C, $22
0030B0r 3               
0030B0r 3               nt_s_quote:
0030B0r 3  02 0C                .byte 2, IM+NN
0030B2r 3  rr rr rr rr          .word nt_s_backslash_quote, xt_s_quote, z_s_quote
0030B6r 3  rr rr        
0030B8r 3  73 22                .byte "s", $22
0030BAr 3               
0030BAr 3               nt_dot_quote:
0030BAr 3  02 05                .byte 2, CO+IM
0030BCr 3  rr rr rr rr          .word nt_s_quote, xt_dot_quote, z_dot_quote
0030C0r 3  rr rr        
0030C2r 3  2E 22                .byte ".", $22
0030C4r 3               
0030C4r 3               nt_sliteral:
0030C4r 3  08 15                .byte 8, CO+IM+UF
0030C6r 3  rr rr rr rr          .word nt_dot_quote, xt_sliteral, z_sliteral
0030CAr 3  rr rr        
0030CCr 3  73 6C 69 74          .byte "sliteral"
0030D0r 3  65 72 61 6C  
0030D4r 3               
0030D4r 3               nt_literal:
0030D4r 3  07 15                .byte 7, IM+CO+UF
0030D6r 3  rr rr rr rr          .word nt_sliteral, xt_literal, z_literal
0030DAr 3  rr rr        
0030DCr 3  6C 69 74 65          .byte "literal"
0030E0r 3  72 61 6C     
0030E3r 3               
0030E3r 3               nt_right_bracket:
0030E3r 3  01 04                .byte 1, IM
0030E5r 3  rr rr rr rr          .word nt_literal, xt_right_bracket, z_right_bracket
0030E9r 3  rr rr        
0030EBr 3  5D                   .byte "]"
0030ECr 3               
0030ECr 3               nt_left_bracket:
0030ECr 3  01 05                .byte 1, IM+CO
0030EEr 3  rr rr rr rr          .word nt_right_bracket, xt_left_bracket, z_left_bracket
0030F2r 3  rr rr        
0030F4r 3  5B                   .byte "["
0030F5r 3               
0030F5r 3               nt_compile_comma:
0030F5r 3  08 18                .byte 8, UF+NN
0030F7r 3  rr rr rr rr          .word nt_left_bracket, xt_compile_comma, z_compile_comma
0030FBr 3  rr rr        
0030FDr 3  63 6F 6D 70          .byte "compile,"
003101r 3  69 6C 65 2C  
003105r 3               
003105r 3               nt_colon_noname:
003105r 3  07 00                .byte 7, 0
003107r 3  rr rr rr rr          .word nt_compile_comma, xt_colon_noname, z_colon_noname
00310Br 3  rr rr        
00310Dr 3  3A 6E 6F 6E          .byte ":noname"
003111r 3  61 6D 65     
003114r 3               
003114r 3               nt_semicolon:
003114r 3  01 05                .byte 1, CO+IM
003116r 3  rr rr rr rr          .word nt_colon_noname, xt_semicolon, z_semicolon
00311Ar 3  rr rr        
00311Cr 3  3B                   .byte ";"
00311Dr 3               
00311Dr 3               nt_colon:
00311Dr 3  01 00                .byte 1, 0
00311Fr 3  rr rr rr rr          .word nt_semicolon, xt_colon, z_colon
003123r 3  rr rr        
003125r 3  3A                   .byte ":"
003126r 3               
003126r 3               nt_source_id:
003126r 3  09 00                .byte 9, 0
003128r 3  rr rr rr rr          .word nt_colon, xt_source_id, z_source_id
00312Cr 3  rr rr        
00312Er 3  73 6F 75 72          .byte "source-id"
003132r 3  63 65 2D 69  
003136r 3  64           
003137r 3               
003137r 3               nt_source:
003137r 3  06 00                .byte 6, 0
003139r 3  rr rr rr rr          .word nt_source_id, xt_source, z_source
00313Dr 3  rr rr        
00313Fr 3  73 6F 75 72          .byte "source"
003143r 3  63 65        
003145r 3               
003145r 3               nt_execute_parsing:
003145r 3  0F 10                .byte 15, UF
003147r 3  rr rr rr rr          .word nt_source, xt_execute_parsing, z_execute_parsing
00314Br 3  rr rr        
00314Dr 3  65 78 65 63          .byte "execute-parsing"
003151r 3  75 74 65 2D  
003155r 3  70 61 72 73  
00315Cr 3               
00315Cr 3               nt_parse:
00315Cr 3  05 10                .byte 5, UF
00315Er 3  rr rr rr rr          .word nt_execute_parsing, xt_parse, z_parse
003162r 3  rr rr        
003164r 3  70 61 72 73          .byte "parse"
003168r 3  65           
003169r 3               
003169r 3               nt_parse_name:
003169r 3  0A 08                .byte 10, NN
00316Br 3  rr rr rr rr          .word nt_parse, xt_parse_name, z_parse_name
00316Fr 3  rr rr        
003171r 3  70 61 72 73          .byte "parse-name"
003175r 3  65 2D 6E 61  
003179r 3  6D 65        
00317Br 3               
00317Br 3               nt_latestnt:
00317Br 3  08 00                .byte 8, 0
00317Dr 3  rr rr rr rr          .word nt_parse_name, xt_latestnt, z_latestnt
003181r 3  rr rr        
003183r 3  6C 61 74 65          .byte "latestnt"
003187r 3  73 74 6E 74  
00318Br 3               
00318Br 3               nt_latestxt:
00318Br 3  08 00                .byte 8, 0
00318Dr 3  rr rr rr rr          .word nt_latestnt, xt_latestxt, z_latestxt
003191r 3  rr rr        
003193r 3  6C 61 74 65          .byte "latestxt"
003197r 3  73 74 78 74  
00319Br 3               
00319Br 3               nt_defer:
00319Br 3  05 00                .byte 5, 0
00319Dr 3  rr rr rr rr          .word nt_latestxt, xt_defer, z_defer
0031A1r 3  rr rr        
0031A3r 3  64 65 66 65          .byte "defer"
0031A7r 3  72           
0031A8r 3               
0031A8r 3               nt_to_body:
0031A8r 3  05 10                .byte 5, UF
0031AAr 3  rr rr rr rr          .word nt_defer, xt_to_body, z_to_body
0031AEr 3  rr rr        
0031B0r 3  3E 62 6F 64          .byte ">body"
0031B4r 3  79           
0031B5r 3               
0031B5r 3               nt_name_to_string:
0031B5r 3  0B 10                .byte 11, UF
0031B7r 3  rr rr rr rr          .word nt_to_body, xt_name_to_string, z_name_to_string
0031BBr 3  rr rr        
0031BDr 3  6E 61 6D 65          .byte "name>string"
0031C1r 3  3E 73 74 72  
0031C5r 3  69 6E 67     
0031C8r 3               
0031C8r 3               nt_int_to_name:
0031C8r 3  08 10                .byte 8, UF
0031CAr 3  rr rr rr rr          .word nt_name_to_string, xt_int_to_name, z_int_to_name
0031CEr 3  rr rr        
0031D0r 3  69 6E 74 3E          .byte "int>name"
0031D4r 3  6E 61 6D 65  
0031D8r 3               
0031D8r 3               nt_name_to_int:
0031D8r 3  08 10                .byte 8, UF
0031DAr 3  rr rr rr rr          .word nt_int_to_name, xt_name_to_int, z_name_to_int
0031DEr 3  rr rr        
0031E0r 3  6E 61 6D 65          .byte "name>int"
0031E4r 3  3E 69 6E 74  
0031E8r 3               
0031E8r 3               nt_bracket_tick:
0031E8r 3  03 05                .byte 3, CO+IM
0031EAr 3  rr rr rr rr          .word nt_name_to_int, xt_bracket_tick, z_bracket_tick
0031EEr 3  rr rr        
0031F0r 3  5B 27 5D             .byte "[']"
0031F3r 3               
0031F3r 3               nt_tick:
0031F3r 3  01 00                .byte 1, 0
0031F5r 3  rr rr rr rr          .word nt_bracket_tick, xt_tick, z_tick
0031F9r 3  rr rr        
0031FBr 3  27                   .byte "'"
0031FCr 3               
0031FCr 3               nt_find_name:
0031FCr 3  09 10                .byte 9, UF
0031FEr 3  rr rr rr rr          .word nt_tick, xt_find_name, z_find_name
003202r 3  rr rr        
003204r 3  66 69 6E 64          .byte "find-name"
003208r 3  2D 6E 61 6D  
00320Cr 3  65           
00320Dr 3               
00320Dr 3               nt_fill:
00320Dr 3  04 10                .byte 4, UF
00320Fr 3  rr rr rr rr          .word nt_find_name, xt_fill, z_fill
003213r 3  rr rr        
003215r 3  66 69 6C 6C          .byte "fill"
003219r 3               
003219r 3               nt_blank:
003219r 3  05 00                .byte 5, 0     ; underflow checked by FILL
00321Br 3  rr rr rr rr          .word nt_fill, xt_blank, z_blank
00321Fr 3  rr rr        
003221r 3  62 6C 61 6E          .byte "blank"
003225r 3  6B           
003226r 3               
003226r 3               nt_erase:
003226r 3  05 00                .byte 5, 0      ; underflow checked by FILL
003228r 3  rr rr rr rr          .word nt_blank, xt_erase, z_erase
00322Cr 3  rr rr        
00322Er 3  65 72 61 73          .byte "erase"
003232r 3  65           
003233r 3               
003233r 3               nt_d_plus:
003233r 3  02 10                .byte 2, UF
003235r 3  rr rr rr rr          .word nt_erase, xt_d_plus, z_d_plus
003239r 3  rr rr        
00323Br 3  64 2B                .byte "d+"
00323Dr 3               
00323Dr 3               nt_d_minus:
00323Dr 3  02 10                .byte 2, UF
00323Fr 3  rr rr rr rr          .word nt_d_plus, xt_d_minus, z_d_minus
003243r 3  rr rr        
003245r 3  64 2D                .byte "d-"
003247r 3               
003247r 3               nt_d_to_s:
003247r 3  03 10                .byte 3, UF
003249r 3  rr rr rr rr          .word nt_d_minus, xt_d_to_s, z_d_to_s
00324Dr 3  rr rr        
00324Fr 3  64 3E 73             .byte "d>s"
003252r 3               
003252r 3               nt_s_to_d:
003252r 3  03 10                .byte 3, UF
003254r 3  rr rr rr rr          .word nt_d_to_s, xt_s_to_d, z_s_to_d
003258r 3  rr rr        
00325Ar 3  73 3E 64             .byte "s>d"
00325Dr 3               
00325Dr 3               nt_to:
00325Dr 3  02 0C                .byte 2, NN+IM
00325Fr 3  rr rr rr rr          .word nt_s_to_d, xt_to, z_to
003263r 3  rr rr        
003265r 3  74 6F                .byte "to"
003267r 3               
003267r 3               nt_value:               ; same code as CONSTANT
003267r 3  05 10                .byte 5, UF
003269r 3  rr rr rr rr          .word nt_to, xt_constant, z_constant
00326Dr 3  rr rr        
00326Fr 3  76 61 6C 75          .byte "value"
003273r 3  65           
003274r 3               
003274r 3               nt_constant:
003274r 3  08 10                .byte 8, UF
003276r 3  rr rr rr rr          .word nt_value, xt_constant, z_constant
00327Ar 3  rr rr        
00327Cr 3  63 6F 6E 73          .byte "constant"
003280r 3  74 61 6E 74  
003284r 3               
003284r 3               nt_variable:
003284r 3  08 00                .byte 8, 0
003286r 3  rr rr rr rr          .word nt_constant, xt_variable, z_variable
00328Ar 3  rr rr        
00328Cr 3  76 61 72 69          .byte "variable"
003290r 3  61 62 6C 65  
003294r 3               
003294r 3               nt_does:
003294r 3  05 05                .byte 5, CO+IM
003296r 3  rr rr rr rr          .word nt_variable, xt_does, z_does
00329Ar 3  rr rr        
00329Cr 3  64 6F 65 73          .byte "does>"
0032A0r 3  3E           
0032A1r 3               
0032A1r 3               nt_create:
0032A1r 3  06 00                .byte 6, 0
0032A3r 3  rr rr rr rr          .word nt_does, xt_create, z_create
0032A7r 3  rr rr        
0032A9r 3  63 72 65 61          .byte "create"
0032ADr 3  74 65        
0032AFr 3               
0032AFr 3               nt_allot:
0032AFr 3  05 10                .byte 5, UF
0032B1r 3  rr rr rr rr          .word nt_create, xt_allot, z_allot
0032B5r 3  rr rr        
0032B7r 3  61 6C 6C 6F          .byte "allot"
0032BBr 3  74           
0032BCr 3               
0032BCr 3               nt_key:
0032BCr 3  03 00                .byte 3, 0
0032BEr 3  rr rr rr rr          .word nt_allot, xt_key, z_key
0032C2r 3  rr rr        
0032C4r 3  6B 65 79             .byte "key"
0032C7r 3               
0032C7r 3               nt_depth:
0032C7r 3  05 00                .byte 5, 0
0032C9r 3  rr rr rr rr          .word nt_key, xt_depth, z_depth
0032CDr 3  rr rr        
0032CFr 3  64 65 70 74          .byte "depth"
0032D3r 3  68           
0032D4r 3               
0032D4r 3               nt_unused:
0032D4r 3  06 00                .byte 6, 0
0032D6r 3  rr rr rr rr          .word nt_depth, xt_unused, z_unused
0032DAr 3  rr rr        
0032DCr 3  75 6E 75 73          .byte "unused"
0032E0r 3  65 64        
0032E2r 3               
0032E2r 3               nt_r_to_input:
0032E2r 3  07 08                .byte 7, NN
0032E4r 3  rr rr rr rr          .word nt_unused, xt_r_to_input, z_r_to_input
0032E8r 3  rr rr        
0032EAr 3  72 3E 69 6E          .byte "r>input"
0032EEr 3  70 75 74     
0032F1r 3               
0032F1r 3               nt_input_to_r:
0032F1r 3  07 08                .byte 7, NN
0032F3r 3  rr rr rr rr          .word nt_r_to_input, xt_input_to_r, z_input_to_r
0032F7r 3  rr rr        
0032F9r 3  69 6E 70 75          .byte "input>r"
0032FDr 3  74 3E 72     
003300r 3               
003300r 3               nt_accept:
003300r 3  06 18                .byte 6, UF+NN
003302r 3  rr rr rr rr          .word nt_input_to_r, xt_accept, z_accept
003306r 3  rr rr        
003308r 3  61 63 63 65          .byte "accept"
00330Cr 3  70 74        
00330Er 3               
00330Er 3               nt_refill:
00330Er 3  06 00                .byte 6, 0
003310r 3  rr rr rr rr          .word nt_accept, xt_refill, z_refill
003314r 3  rr rr        
003316r 3  72 65 66 69          .byte "refill"
00331Ar 3  6C 6C        
00331Cr 3               
00331Cr 3               nt_slash_string:
00331Cr 3  07 10                .byte 7, UF
00331Er 3  rr rr rr rr          .word nt_refill, xt_slash_string, z_slash_string
003322r 3  rr rr        
003324r 3  2F 73 74 72          .byte "/string"
003328r 3  69 6E 67     
00332Br 3               
00332Br 3               nt_minus_leading:
00332Br 3  08 10                .byte 8, UF
00332Dr 3  rr rr rr rr          .word nt_slash_string, xt_minus_leading, z_minus_leading
003331r 3  rr rr        
003333r 3  2D 6C 65 61          .byte "-leading"
003337r 3  64 69 6E 67  
00333Br 3               
00333Br 3               nt_minus_trailing:
00333Br 3  09 10                .byte 9, UF
00333Dr 3  rr rr rr rr          .word nt_minus_leading, xt_minus_trailing, z_minus_trailing
003341r 3  rr rr        
003343r 3  2D 74 72 61          .byte "-trailing"
003347r 3  69 6C 69 6E  
00334Br 3  67           
00334Cr 3               
00334Cr 3               nt_bl:
00334Cr 3  02 00                .byte 2, 0
00334Er 3  rr rr rr rr          .word nt_minus_trailing, xt_bl, z_bl
003352r 3  rr rr        
003354r 3  62 6C                .byte "bl"
003356r 3               
003356r 3               nt_spaces:
003356r 3  06 10                .byte 6, UF
003358r 3  rr rr rr rr          .word nt_bl, xt_spaces, z_spaces
00335Cr 3  rr rr        
00335Er 3  73 70 61 63          .byte "spaces"
003362r 3  65 73        
003364r 3               
003364r 3               nt_bounds:
003364r 3  06 10                .byte 6, UF
003366r 3  rr rr rr rr          .word nt_spaces, xt_bounds, z_bounds
00336Ar 3  rr rr        
00336Cr 3  62 6F 75 6E          .byte "bounds"
003370r 3  64 73        
003372r 3               
003372r 3               nt_c_comma:
003372r 3  02 10                .byte 2, UF
003374r 3  rr rr rr rr          .word nt_bounds, xt_c_comma, z_c_comma
003378r 3  rr rr        
00337Ar 3  63 2C                .byte "c,"
00337Cr 3               
00337Cr 3               nt_dnegate:
00337Cr 3  07 10                .byte 7, UF
00337Er 3  rr rr rr rr          .word nt_c_comma, xt_dnegate, z_dnegate
003382r 3  rr rr        
003384r 3  64 6E 65 67          .byte "dnegate"
003388r 3  61 74 65     
00338Br 3               
00338Br 3               nt_negate:
00338Br 3  06 10                .byte 6, UF
00338Dr 3  rr rr rr rr          .word nt_dnegate, xt_negate, z_negate
003391r 3  rr rr        
003393r 3  6E 65 67 61          .byte "negate"
003397r 3  74 65        
003399r 3               
003399r 3               nt_invert:
003399r 3  06 10                .byte 6, UF
00339Br 3  rr rr rr rr          .word nt_negate, xt_invert, z_invert
00339Fr 3  rr rr        
0033A1r 3  69 6E 76 65          .byte "invert"
0033A5r 3  72 74        
0033A7r 3               
0033A7r 3               nt_two_to_r:
0033A7r 3  03 11                .byte 3, CO+UF          ; native is special case
0033A9r 3  rr rr rr rr          .word nt_invert, xt_two_to_r, z_two_to_r
0033ADr 3  rr rr        
0033AFr 3  32 3E 72             .byte "2>r"
0033B2r 3               
0033B2r 3               nt_two_r_from:
0033B2r 3  03 01                .byte 3, CO             ; native is special case
0033B4r 3  rr rr rr rr          .word nt_two_to_r, xt_two_r_from, z_two_r_from
0033B8r 3  rr rr        
0033BAr 3  32 72 3E             .byte "2r>"
0033BDr 3               
0033BDr 3               nt_two_r_fetch:
0033BDr 3  03 09                .byte 3, CO+NN          ; native is special case, leave NN for now
0033BFr 3  rr rr rr rr          .word nt_two_r_from, xt_two_r_fetch, z_two_r_fetch
0033C3r 3  rr rr        
0033C5r 3  32 72 40             .byte "2r@"
0033C8r 3               
0033C8r 3               nt_two_literal:
0033C8r 3  08 14                .byte 8, UF+IM
0033CAr 3  rr rr rr rr          .word nt_two_r_fetch, xt_two_literal, z_two_literal
0033CEr 3  rr rr        
0033D0r 3  32 6C 69 74          .byte "2literal"
0033D4r 3  65 72 61 6C  
0033D8r 3               
0033D8r 3               nt_two_constant:
0033D8r 3  09 10                .byte 9, UF
0033DAr 3  rr rr rr rr          .word nt_two_literal, xt_two_constant, z_two_constant
0033DEr 3  rr rr        
0033E0r 3  32 63 6F 6E          .byte "2constant"
0033E4r 3  73 74 61 6E  
0033E8r 3  74           
0033E9r 3               
0033E9r 3               nt_two_variable:
0033E9r 3  09 00                .byte 9, 0
0033EBr 3  rr rr rr rr          .word nt_two_constant, xt_two_variable, z_two_variable
0033EFr 3  rr rr        
0033F1r 3  32 76 61 72          .byte "2variable"
0033F5r 3  69 61 62 6C  
0033F9r 3  65           
0033FAr 3               
0033FAr 3               nt_two_fetch:
0033FAr 3  02 10                .byte 2, UF
0033FCr 3  rr rr rr rr          .word nt_two_variable, xt_two_fetch, z_two_fetch
003400r 3  rr rr        
003402r 3  32 40                .byte "2@"
003404r 3               
003404r 3               nt_two_store:
003404r 3  02 10                .byte 2, UF
003406r 3  rr rr rr rr          .word nt_two_fetch, xt_two_store, z_two_store
00340Ar 3  rr rr        
00340Cr 3  32 21                .byte "2!"
00340Er 3               
00340Er 3               nt_two_over:
00340Er 3  05 10                .byte 5, UF
003410r 3  rr rr rr rr          .word nt_two_store, xt_two_over, z_two_over
003414r 3  rr rr        
003416r 3  32 6F 76 65          .byte "2over"
00341Ar 3  72           
00341Br 3               
00341Br 3               nt_two_swap:
00341Br 3  05 10                .byte 5, UF
00341Dr 3  rr rr rr rr          .word nt_two_over, xt_two_swap, z_two_swap
003421r 3  rr rr        
003423r 3  32 73 77 61          .byte "2swap"
003427r 3  70           
003428r 3               
003428r 3               nt_two_drop:
003428r 3  05 10                .byte 5, UF
00342Ar 3  rr rr rr rr          .word nt_two_swap, xt_two_drop, z_two_drop
00342Er 3  rr rr        
003430r 3  32 64 72 6F          .byte "2drop"
003434r 3  70           
003435r 3               
003435r 3               nt_max:
003435r 3  03 10                .byte 3, UF
003437r 3  rr rr rr rr          .word nt_two_drop, xt_max, z_max
00343Br 3  rr rr        
00343Dr 3  6D 61 78             .byte "max"
003440r 3               
003440r 3               nt_min:
003440r 3  03 10                .byte 3, UF
003442r 3  rr rr rr rr          .word nt_max, xt_min, z_min
003446r 3  rr rr        
003448r 3  6D 69 6E             .byte "min"
00344Br 3               
00344Br 3               nt_zero_less:
00344Br 3  02 10                .byte 2, UF
00344Dr 3  rr rr rr rr          .word nt_min, xt_zero_less, z_zero_less
003451r 3  rr rr        
003453r 3  30 3C                .byte "0<"
003455r 3               
003455r 3               nt_zero_greater:
003455r 3  02 10                .byte 2, UF
003457r 3  rr rr rr rr          .word nt_zero_less, xt_zero_greater, z_zero_greater
00345Br 3  rr rr        
00345Dr 3  30 3E                .byte "0>"
00345Fr 3               
00345Fr 3               nt_zero_unequal:
00345Fr 3  03 10                .byte 3, UF
003461r 3  rr rr rr rr          .word nt_zero_greater, xt_zero_unequal, z_zero_unequal
003465r 3  rr rr        
003467r 3  30 3C 3E             .byte "0<>"
00346Ar 3               
00346Ar 3               nt_zero_equal:
00346Ar 3  02 10                .byte 2, UF
00346Cr 3  rr rr rr rr          .word nt_zero_unequal, xt_zero_equal, z_zero_equal
003470r 3  rr rr        
003472r 3  30 3D                .byte "0="
003474r 3               
003474r 3               nt_greater_than:
003474r 3  01 10                .byte 1, UF
003476r 3  rr rr rr rr          .word nt_zero_equal, xt_greater_than, z_greater_than
00347Ar 3  rr rr        
00347Cr 3  3E                   .byte ">"
00347Dr 3               
00347Dr 3               nt_u_greater_than:
00347Dr 3  02 10                .byte 2, UF
00347Fr 3  rr rr rr rr          .word nt_greater_than, xt_u_greater_than, z_u_greater_than
003483r 3  rr rr        
003485r 3  75 3E                .byte "u>"
003487r 3               
003487r 3               nt_u_less_than:
003487r 3  02 10                .byte 2, UF
003489r 3  rr rr rr rr          .word nt_u_greater_than, xt_u_less_than, z_u_less_than
00348Dr 3  rr rr        
00348Fr 3  75 3C                .byte "u<"
003491r 3               
003491r 3               nt_less_than:
003491r 3  01 10                .byte 1, UF
003493r 3  rr rr rr rr          .word nt_u_less_than, xt_less_than, z_less_than
003497r 3  rr rr        
003499r 3  3C                   .byte "<"
00349Ar 3               
00349Ar 3               nt_not_equals:
00349Ar 3  02 10                .byte 2, UF
00349Cr 3  rr rr rr rr          .word nt_less_than, xt_not_equals, z_not_equals
0034A0r 3  rr rr        
0034A2r 3  3C 3E                .byte "<>"
0034A4r 3               
0034A4r 3               nt_equal:
0034A4r 3  01 10                .byte 1, UF
0034A6r 3  rr rr rr rr          .word nt_not_equals, xt_equal, z_equal
0034AAr 3  rr rr        
0034ACr 3  3D                   .byte "="
0034ADr 3               
0034ADr 3               nt_two_slash:
0034ADr 3  02 10                .byte 2, UF
0034AFr 3  rr rr rr rr          .word nt_equal, xt_two_slash, z_two_slash
0034B3r 3  rr rr        
0034B5r 3  32 2F                .byte "2/"
0034B7r 3               
0034B7r 3               nt_two_star:
0034B7r 3  02 10                .byte 2, UF
0034B9r 3  rr rr rr rr          .word nt_two_slash, xt_two_star, z_two_star
0034BDr 3  rr rr        
0034BFr 3  32 2A                .byte "2*"
0034C1r 3               
0034C1r 3               nt_one_plus:
0034C1r 3  02 10                .byte 2, UF
0034C3r 3  rr rr rr rr          .word nt_two_star, xt_one_plus, z_one_plus
0034C7r 3  rr rr        
0034C9r 3  31 2B                .byte "1+"
0034CBr 3               
0034CBr 3               nt_one_minus:
0034CBr 3  02 10                .byte 2, UF
0034CDr 3  rr rr rr rr          .word nt_one_plus, xt_one_minus, z_one_minus
0034D1r 3  rr rr        
0034D3r 3  31 2D                .byte "1-"
0034D5r 3               
0034D5r 3               nt_here:
0034D5r 3  04 00                .byte 4, 0
0034D7r 3  rr rr rr rr          .word nt_one_minus, xt_here, z_here
0034DBr 3  rr rr        
0034DDr 3  68 65 72 65          .byte "here"
0034E1r 3               
0034E1r 3               nt_cell_plus:
0034E1r 3  05 10                .byte 5, UF
0034E3r 3  rr rr rr rr          .word nt_here, xt_cell_plus, z_cell_plus
0034E7r 3  rr rr        
0034E9r 3  63 65 6C 6C          .byte "cell+"
0034EDr 3  2B           
0034EEr 3               
0034EEr 3               nt_cells:
0034EEr 3  05 00                .byte 5, 0
0034F0r 3  rr rr rr rr          .word nt_cell_plus, xt_two_star, z_two_star  ; same as 2*
0034F4r 3  rr rr        
0034F6r 3  63 65 6C 6C          .byte "cells"
0034FAr 3  73           
0034FBr 3               
0034FBr 3               nt_chars:
0034FBr 3  05 12                .byte 5, AN+UF   ; deleted during compile
0034FDr 3  rr rr rr rr          .word nt_cells, xt_chars, z_chars
003501r 3  rr rr        
003503r 3  63 68 61 72          .byte "chars"
003507r 3  73           
003508r 3               
003508r 3               nt_char_plus:
003508r 3  05 00                .byte 5, 0
00350Ar 3  rr rr rr rr          .word nt_chars, xt_one_plus, z_one_plus ; same as 1+
00350Er 3  rr rr        
003510r 3  63 68 61 72          .byte "char+"
003514r 3  2B           
003515r 3               
003515r 3               nt_bracket_char:
003515r 3  06 05                .byte 6, CO+IM
003517r 3  rr rr rr rr          .word nt_char_plus, xt_bracket_char, z_bracket_char
00351Br 3  rr rr        
00351Dr 3  5B 63 68 61          .byte "[char]"
003521r 3  72 5D        
003523r 3               
003523r 3               nt_char:
003523r 3  04 00                .byte 4, 0
003525r 3  rr rr rr rr          .word nt_bracket_char, xt_char, z_char
003529r 3  rr rr        
00352Br 3  63 68 61 72          .byte "char"
00352Fr 3               
00352Fr 3               nt_pick:
00352Fr 3  04 00                .byte 4, 0    ; underflow check is complicated, leave off here
003531r 3  rr rr rr rr          .word nt_char, xt_pick, z_pick
003535r 3  rr rr        
003537r 3  70 69 63 6B          .byte "pick"
00353Br 3               
00353Br 3               nt_lshift:
00353Br 3  06 10                .byte 6, UF
00353Dr 3  rr rr rr rr          .word nt_pick, xt_lshift, z_lshift
003541r 3  rr rr        
003543r 3  6C 73 68 69          .byte "lshift"
003547r 3  66 74        
003549r 3               
003549r 3               nt_rshift:
003549r 3  06 10                .byte 6, UF
00354Br 3  rr rr rr rr          .word nt_lshift, xt_rshift, z_rshift
00354Fr 3  rr rr        
003551r 3  72 73 68 69          .byte "rshift"
003555r 3  66 74        
003557r 3               
003557r 3               nt_xor:
003557r 3  03 10                .byte 3, UF
003559r 3  rr rr rr rr          .word nt_rshift, xt_xor, z_xor
00355Dr 3  rr rr        
00355Fr 3  78 6F 72             .byte "xor"
003562r 3               
003562r 3               nt_or:
003562r 3  02 10                .byte 2, UF
003564r 3  rr rr rr rr          .word nt_xor, xt_or, z_or
003568r 3  rr rr        
00356Ar 3  6F 72                .byte "or"
00356Cr 3               
00356Cr 3               nt_and:
00356Cr 3  03 10                .byte 3, UF
00356Er 3  rr rr rr rr          .word nt_or, xt_and, z_and
003572r 3  rr rr        
003574r 3  61 6E 64             .byte "and"
003577r 3               
003577r 3               nt_dabs:
003577r 3  04 10                .byte 4, UF
003579r 3  rr rr rr rr          .word nt_and, xt_dabs, z_dabs
00357Dr 3  rr rr        
00357Fr 3  64 61 62 73          .byte "dabs"
003583r 3               
003583r 3               nt_abs:
003583r 3  03 10                .byte 3, UF
003585r 3  rr rr rr rr          .word nt_dabs, xt_abs, z_abs
003589r 3  rr rr        
00358Br 3  61 62 73             .byte "abs"
00358Er 3               
00358Er 3               nt_minus:
00358Er 3  01 10                .byte 1, UF
003590r 3  rr rr rr rr          .word nt_abs, xt_minus, z_minus
003594r 3  rr rr        
003596r 3  2D                   .byte "-"
003597r 3               
003597r 3               nt_plus:
003597r 3  01 10                .byte 1, UF
003599r 3  rr rr rr rr          .word nt_minus, xt_plus, z_plus
00359Dr 3  rr rr        
00359Fr 3  2B                   .byte "+"
0035A0r 3               
0035A0r 3               nt_question_dup:
0035A0r 3  04 10                .byte 4, UF
0035A2r 3  rr rr rr rr          .word nt_plus, xt_question_dup, z_question_dup
0035A6r 3  rr rr        
0035A8r 3  3F 64 75 70          .byte "?dup"
0035ACr 3               
0035ACr 3               nt_two_dup:
0035ACr 3  04 10                .byte 4, UF
0035AEr 3  rr rr rr rr          .word nt_question_dup, xt_two_dup, z_two_dup
0035B2r 3  rr rr        
0035B4r 3  32 64 75 70          .byte "2dup"
0035B8r 3               
0035B8r 3               nt_two:
0035B8r 3  01 00                .byte 1, 0
0035BAr 3  rr rr rr rr          .word nt_two_dup, xt_two, z_two
0035BEr 3  rr rr        
0035C0r 3  32                   .byte "2"
0035C1r 3               
0035C1r 3               nt_one:
0035C1r 3  01 00                .byte 1, 0
0035C3r 3  rr rr rr rr          .word nt_two, xt_one, z_one
0035C7r 3  rr rr        
0035C9r 3  31                   .byte "1"
0035CAr 3               
0035CAr 3               nt_zero:
0035CAr 3  01 00                .byte 1, 0
0035CCr 3  rr rr rr rr          .word nt_one, xt_zero, z_zero
0035D0r 3  rr rr        
0035D2r 3  30                   .byte "0"
0035D3r 3               
0035D3r 3               nt_space:
0035D3r 3  05 00                .byte 5, 0
0035D5r 3  rr rr rr rr          .word nt_zero, xt_space, z_space
0035D9r 3  rr rr        
0035DBr 3  73 70 61 63          .byte "space"
0035DFr 3  65           
0035E0r 3               
0035E0r 3               nt_true:
0035E0r 3  04 00                .byte 4, 0
0035E2r 3  rr rr rr rr          .word nt_space, xt_true, z_true
0035E6r 3  rr rr        
0035E8r 3  74 72 75 65          .byte "true"
0035ECr 3               
0035ECr 3               nt_false:
0035ECr 3  05 00                .byte 5, 0
0035EEr 3  rr rr rr rr          .word nt_true, xt_false, z_false
0035F2r 3  rr rr        
0035F4r 3  66 61 6C 73          .byte "false"
0035F8r 3  65           
0035F9r 3               
0035F9r 3               nt_question:
0035F9r 3  01 00                .byte 1, 0
0035FBr 3  rr rr rr rr          .word nt_false, xt_question, z_question
0035FFr 3  rr rr        
003601r 3  3F                   .byte "?"
003602r 3               
003602r 3               nt_ud_dot_r:
003602r 3  04 10                .byte 4, UF
003604r 3  rr rr rr rr          .word nt_question, xt_ud_dot_r, z_ud_dot_r
003608r 3  rr rr        
00360Ar 3  75 64 2E 72          .byte "ud.r"
00360Er 3               
00360Er 3               nt_ud_dot:
00360Er 3  03 10                .byte 3, UF
003610r 3  rr rr rr rr          .word nt_ud_dot_r, xt_ud_dot, z_ud_dot
003614r 3  rr rr        
003616r 3  75 64 2E             .byte "ud."
003619r 3               
003619r 3               nt_d_dot_r:
003619r 3  03 10                .byte 3, UF
00361Br 3  rr rr rr rr          .word nt_ud_dot, xt_d_dot_r, z_d_dot_r
00361Fr 3  rr rr        
003621r 3  64 2E 72             .byte "d.r"
003624r 3               
003624r 3               nt_d_dot:
003624r 3  02 10                .byte 2, UF
003626r 3  rr rr rr rr          .word nt_d_dot_r, xt_d_dot, z_d_dot
00362Ar 3  rr rr        
00362Cr 3  64 2E                .byte "d."
00362Er 3               
00362Er 3               nt_dot_r:
00362Er 3  02 10                .byte 2, UF
003630r 3  rr rr rr rr          .word nt_d_dot, xt_dot_r, z_dot_r
003634r 3  rr rr        
003636r 3  2E 72                .byte ".r"
003638r 3               
003638r 3               nt_u_dot_r:
003638r 3  03 10                .byte 3, UF
00363Ar 3  rr rr rr rr          .word nt_dot_r, xt_u_dot_r, z_u_dot_r
00363Er 3  rr rr        
003640r 3  75 2E 72             .byte "u.r"
003643r 3               
003643r 3               nt_u_dot:
003643r 3  02 10                .byte 2, UF
003645r 3  rr rr rr rr          .word nt_u_dot_r, xt_u_dot, z_u_dot
003649r 3  rr rr        
00364Br 3  75 2E                .byte "u."
00364Dr 3               
00364Dr 3               nt_dot:
00364Dr 3  01 10                .byte 1, UF
00364Fr 3  rr rr rr rr          .word nt_u_dot, xt_dot, z_dot
003653r 3  rr rr        
003655r 3  2E                   .byte "."
003656r 3               
003656r 3               nt_type:
003656r 3  04 10                .byte 4, UF
003658r 3  rr rr rr rr          .word nt_dot, xt_type, z_type
00365Cr 3  rr rr        
00365Er 3  74 79 70 65          .byte "type"
003662r 3               
003662r 3               nt_emit:
003662r 3  04 18                .byte 4, NN+UF
003664r 3  rr rr rr rr          .word nt_type, xt_emit, z_emit
003668r 3  rr rr        
00366Ar 3  65 6D 69 74          .byte "emit"
00366Er 3               
00366Er 3               nt_execute:
00366Er 3  07 10                .byte 7, UF
003670r 3  rr rr rr rr          .word nt_emit, xt_execute, z_execute
003674r 3  rr rr        
003676r 3  65 78 65 63          .byte "execute"
00367Ar 3  75 74 65     
00367Dr 3               
00367Dr 3               nt_plus_store:
00367Dr 3  02 10                .byte 2, UF
00367Fr 3  rr rr rr rr          .word nt_execute, xt_plus_store, z_plus_store
003683r 3  rr rr        
003685r 3  2B 21                .byte "+!"
003687r 3               
003687r 3               nt_c_store:
003687r 3  02 10                .byte 2, UF
003689r 3  rr rr rr rr          .word nt_plus_store, xt_c_store, z_c_store
00368Dr 3  rr rr        
00368Fr 3  63 21                .byte "c!"
003691r 3               
003691r 3               nt_c_fetch:
003691r 3  02 10                .byte 2, UF
003693r 3  rr rr rr rr          .word nt_c_store, xt_c_fetch, z_c_fetch
003697r 3  rr rr        
003699r 3  63 40                .byte "c@"
00369Br 3               
00369Br 3               nt_comma:
00369Br 3  01 10                .byte 1, UF
00369Dr 3  rr rr rr rr          .word nt_c_fetch, xt_comma, z_comma
0036A1r 3  rr rr        
0036A3r 3  2C                   .byte ","
0036A4r 3               
0036A4r 3               nt_tuck:
0036A4r 3  04 10                .byte 4, UF
0036A6r 3  rr rr rr rr          .word nt_comma, xt_tuck, z_tuck
0036AAr 3  rr rr        
0036ACr 3  74 75 63 6B          .byte "tuck"
0036B0r 3               
0036B0r 3               nt_not_rote:
0036B0r 3  04 10                .byte 4, UF
0036B2r 3  rr rr rr rr          .word nt_tuck, xt_not_rote, z_not_rote
0036B6r 3  rr rr        
0036B8r 3  2D 72 6F 74          .byte "-rot"
0036BCr 3               
0036BCr 3               nt_rot:
0036BCr 3  03 10                .byte 3, UF
0036BEr 3  rr rr rr rr          .word nt_not_rote, xt_rot, z_rot
0036C2r 3  rr rr        
0036C4r 3  72 6F 74             .byte "rot"
0036C7r 3               
0036C7r 3               nt_nip:
0036C7r 3  03 10                .byte 3, UF
0036C9r 3  rr rr rr rr          .word nt_rot, xt_nip, z_nip
0036CDr 3  rr rr        
0036CFr 3  6E 69 70             .byte "nip"
0036D2r 3               
0036D2r 3               nt_r_fetch:
0036D2r 3  02 01                .byte 2, CO    ; native is special case
0036D4r 3  rr rr rr rr          .word nt_nip, xt_r_fetch, z_r_fetch
0036D8r 3  rr rr        
0036DAr 3  72 40                .byte "r@"
0036DCr 3               
0036DCr 3               nt_r_from:
0036DCr 3  02 01                .byte 2, CO    ; native is special case
0036DEr 3  rr rr rr rr          .word nt_r_fetch, xt_r_from, z_r_from
0036E2r 3  rr rr        
0036E4r 3  72 3E                .byte "r>"
0036E6r 3               
0036E6r 3               nt_to_r:
0036E6r 3  02 11                .byte 2, CO+UF ; native is special case
0036E8r 3  rr rr rr rr          .word nt_r_from, xt_to_r, z_to_r
0036ECr 3  rr rr        
0036EEr 3  3E 72                .byte ">r"
0036F0r 3               
0036F0r 3               nt_over:
0036F0r 3  04 10                .byte 4, UF
0036F2r 3  rr rr rr rr          .word nt_to_r, xt_over, z_over
0036F6r 3  rr rr        
0036F8r 3  6F 76 65 72          .byte "over"
0036FCr 3               
0036FCr 3               nt_fetch:
0036FCr 3  01 10                .byte 1, UF
0036FEr 3  rr rr rr rr          .word nt_over, xt_fetch, z_fetch
003702r 3  rr rr        
003704r 3  40                   .byte "@"
003705r 3               
003705r 3               nt_store:
003705r 3  01 10                .byte 1, UF
003707r 3  rr rr rr rr          .word nt_fetch, xt_store, z_store
00370Br 3  rr rr        
00370Dr 3  21                   .byte "!"
00370Er 3               
00370Er 3               nt_swap:
00370Er 3  04 10                .byte 4, UF
003710r 3  rr rr rr rr          .word nt_store, xt_swap, z_swap
003714r 3  rr rr        
003716r 3  73 77 61 70          .byte "swap"
00371Ar 3               
00371Ar 3               nt_dup:
00371Ar 3  03 10                .byte 3, UF
00371Cr 3  rr rr rr rr          .word nt_swap, xt_dup, z_dup
003720r 3  rr rr        
003722r 3  64 75 70             .byte "dup"
003725r 3               
003725r 3               ; DROP is always the first native word in the Dictionary
003725r 3               dictionary_start:
003725r 3               nt_drop:
003725r 3  04 10                .byte 4, UF
003727r 3  rr rr rr rr          .word nt_dup, xt_drop, z_drop
00372Br 3  rr rr        
00372Dr 3  64 72 6F 70          .byte "drop"
003731r 3               
003731r 3               ; END of FORTH-WORDLIST
003731r 3               
003731r 3               
003731r 3               ; ROOT-WORDLIST
003731r 3                       ; This is a short wordlist that has just the words needed to
003731r 3                       ; set the wordlists. These words are also included in the
003731r 3                       ; FORTH-WORDLIST as well.
003731r 3               
003731r 3               nt_root_words:
003731r 3  05 00                .byte 5, 0
003733r 3  00 00 rr rr          .word 0000, xt_words, z_words
003737r 3  rr rr        
003739r 3  77 6F 72 64          .byte "words"
00373Dr 3  73           
00373Er 3               
00373Er 3               nt_root_forth_wordlist: ; shares code with ZERO
00373Er 3  0E 00                .byte 14, 0
003740r 3  rr rr rr rr          .word nt_root_words, xt_forth_wordlist, z_forth_wordlist
003744r 3  rr rr        
003746r 3  66 6F 72 74          .byte "forth-wordlist"
00374Ar 3  68 2D 77 6F  
00374Er 3  72 64 6C 69  
003754r 3               
003754r 3               nt_root_forth:
003754r 3  05 00                .byte 5, 0
003756r 3  rr rr rr rr          .word nt_root_forth_wordlist, xt_forth, z_forth
00375Ar 3  rr rr        
00375Cr 3  66 6F 72 74          .byte "forth"
003760r 3  68           
003761r 3               
003761r 3               root_dictionary_start:
003761r 3               nt_root_set_order:
003761r 3  09 00                .byte 9, 0
003763r 3  rr rr rr rr          .word nt_root_forth, xt_set_order, z_set_order
003767r 3  rr rr        
003769r 3  73 65 74 2D          .byte "set-order"
00376Dr 3  6F 72 64 65  
003771r 3  72           
003772r 3               
003772r 3               ; END of ROOT-WORDLIST
003772r 3               
003772r 3               
003772r 3               ; EDITOR-WORDLIST
003772r 3               
003772r 3               nt_editor_enter_screen:
003772r 3  0C 00                .byte 12, 0
003774r 3  00 00 rr rr          .word 0000, xt_editor_enter_screen, z_editor_enter_screen
003778r 3  rr rr        
00377Ar 3  65 6E 74 65          .byte "enter-screen"
00377Er 3  72 2D 73 63  
003782r 3  72 65 65 6E  
003786r 3               
003786r 3               nt_editor_erase_screen:
003786r 3  0C 00                .byte 12, 0
003788r 3  rr rr rr rr          .word nt_editor_enter_screen, xt_editor_erase_screen, z_editor_erase_screen
00378Cr 3  rr rr        
00378Er 3  65 72 61 73          .byte "erase-screen"
003792r 3  65 2D 73 63  
003796r 3  72 65 65 6E  
00379Ar 3               
00379Ar 3               nt_editor_el:
00379Ar 3  02 00                .byte 2, 0
00379Cr 3  rr rr rr rr          .word nt_editor_erase_screen, xt_editor_el, z_editor_el
0037A0r 3  rr rr        
0037A2r 3  65 6C                .byte "el"
0037A4r 3               
0037A4r 3               nt_editor_l:
0037A4r 3  01 00                .byte 1, 0
0037A6r 3  rr rr rr rr          .word nt_editor_el, xt_editor_l, z_editor_l
0037AAr 3  rr rr        
0037ACr 3  6C                   .byte "l"
0037ADr 3               
0037ADr 3               nt_editor_line:
0037ADr 3  04 10                .byte 4, UF
0037AFr 3  rr rr rr rr          .word nt_editor_l, xt_editor_line, z_editor_line
0037B3r 3  rr rr        
0037B5r 3  6C 69 6E 65          .byte "line"
0037B9r 3               
0037B9r 3               editor_dictionary_start:
0037B9r 3               nt_editor_o:
0037B9r 3  01 00                .byte 1, 0
0037BBr 3  rr rr rr rr          .word nt_editor_line, xt_editor_o, z_editor_o
0037BFr 3  rr rr        
0037C1r 3  6F                   .byte "o"
0037C2r 3               
0037C2r 3               ; END of EDITOR-WORDLIST
0037C2r 3               
0037C2r 3               
0037C2r 3               ; ; ASSEMBLER-WORDLIST
0037C2r 3               
0037C2r 3               ; ; Labels for the opcodes have the format "nt_asm_<OPC>" where a futher
0037C2r 3               ; ; underscore replaces any dot present in the SAN mnemonic. The hash sign for
0037C2r 3               ; ; immediate addressing is replaced by an "h" (for example, the label code for
0037C2r 3               ; ; "lda.#" is "xt_adm_lda_h"). All opcodes are immediate.
0037C2r 3               .ifdef TALI_OPTIONAL_ASSEMBLER
0037C2r 3               assembler_dictionary_start:
0037C2r 3               nt_asm_adc_h:
0037C2r 3  05 04        		.byte 5, IM
0037C4r 3  rr rr                        .word nt_asm_adc_x
0037C6r 3  rr rr rr rr  		.word xt_asm_adc_h, z_asm_adc_h
0037CAr 3  61 64 63 2E  		.byte "adc.#"
0037CEr 3  23           
0037CFr 3               
0037CFr 3               nt_asm_adc_x:
0037CFr 3  05 04        		.byte 5, IM
0037D1r 3  rr rr                        .word nt_asm_adc_y
0037D3r 3  rr rr rr rr  		.word xt_asm_adc_x, z_asm_adc_x
0037D7r 3  61 64 63 2E  		.byte "adc.x"
0037DBr 3  78           
0037DCr 3               
0037DCr 3               nt_asm_adc_y:
0037DCr 3  05 04        		.byte 5, IM
0037DEr 3  rr rr                        .word nt_asm_adc_z
0037E0r 3  rr rr rr rr  		.word xt_asm_adc_y, z_asm_adc_y
0037E4r 3  61 64 63 2E  		.byte "adc.y"
0037E8r 3  79           
0037E9r 3               
0037E9r 3               nt_asm_adc_z:
0037E9r 3  05 04        		.byte 5, IM
0037EBr 3  rr rr                        .word nt_asm_adc_zi
0037EDr 3  rr rr rr rr  		.word xt_asm_adc_z, z_asm_adc_z
0037F1r 3  61 64 63 2E  		.byte "adc.z"
0037F5r 3  7A           
0037F6r 3               
0037F6r 3               nt_asm_adc_zi:
0037F6r 3  06 04        		.byte 6, IM
0037F8r 3  rr rr                        .word nt_asm_adc_ziy
0037FAr 3  rr rr rr rr  		.word xt_asm_adc_zi, z_asm_adc_zi
0037FEr 3  61 64 63 2E  		.byte "adc.zi"
003802r 3  7A 69        
003804r 3               
003804r 3               nt_asm_adc_ziy:
003804r 3  07 04        		.byte 7, IM
003806r 3  rr rr                        .word nt_asm_adc_zx
003808r 3  rr rr rr rr  		.word xt_asm_adc_ziy, z_asm_adc_ziy
00380Cr 3  61 64 63 2E  		.byte "adc.ziy"
003810r 3  7A 69 79     
003813r 3               
003813r 3               nt_asm_adc_zx:
003813r 3  06 04        		.byte 6, IM
003815r 3  rr rr                        .word nt_asm_adc_zxi
003817r 3  rr rr rr rr  		.word xt_asm_adc_zx, z_asm_adc_zx
00381Br 3  61 64 63 2E  		.byte "adc.zx"
00381Fr 3  7A 78        
003821r 3               
003821r 3               nt_asm_adc_zxi:
003821r 3  07 04        		.byte 7, IM
003823r 3  rr rr                        .word nt_asm_and
003825r 3  rr rr rr rr  		.word xt_asm_adc_zxi, z_asm_adc_zxi
003829r 3  61 64 63 2E  		.byte "adc.zxi"
00382Dr 3  7A 78 69     
003830r 3               
003830r 3               nt_asm_and:     ; not "and" because of conflicts with Forth word
003830r 3  04 04        		.byte 4, IM
003832r 3  rr rr                        .word nt_asm_and_h
003834r 3  rr rr rr rr  		.word xt_asm_and, z_asm_and
003838r 3  61 6E 64 2E  		.byte "and."
00383Cr 3               
00383Cr 3               nt_asm_and_h:
00383Cr 3  05 04        		.byte 5, IM
00383Er 3  rr rr                        .word nt_asm_and_x
003840r 3  rr rr rr rr  		.word xt_asm_and_h, z_asm_and_h
003844r 3  61 6E 64 2E  		.byte "and.#"
003848r 3  23           
003849r 3               
003849r 3               nt_asm_and_x:
003849r 3  05 04        		.byte 5, IM
00384Br 3  rr rr                        .word nt_asm_and_y
00384Dr 3  rr rr rr rr  		.word xt_asm_and_x, z_asm_and_x
003851r 3  61 6E 64 2E  		.byte "and.x"
003855r 3  78           
003856r 3               
003856r 3               nt_asm_and_y:
003856r 3  05 04        		.byte 5, IM
003858r 3  rr rr                        .word nt_asm_and_z
00385Ar 3  rr rr rr rr  		.word xt_asm_and_y, z_asm_and_y
00385Er 3  61 6E 64 2E  		.byte "and.y"
003862r 3  79           
003863r 3               
003863r 3               nt_asm_and_z:
003863r 3  05 04        		.byte 5, IM
003865r 3  rr rr                        .word nt_asm_and_zi
003867r 3  rr rr rr rr  		.word xt_asm_and_z, z_asm_and_z
00386Br 3  61 6E 64 2E  		.byte "and.z"
00386Fr 3  7A           
003870r 3               
003870r 3               nt_asm_and_zi:
003870r 3  06 04        		.byte 6, IM
003872r 3  rr rr                        .word nt_asm_and_ziy
003874r 3  rr rr rr rr  		.word xt_asm_and_zi, z_asm_and_zi
003878r 3  61 6E 64 2E  		.byte "and.zi"
00387Cr 3  7A 69        
00387Er 3               
00387Er 3               nt_asm_and_ziy:
00387Er 3  07 04        		.byte 7, IM
003880r 3  rr rr                        .word nt_asm_and_zx
003882r 3  rr rr rr rr  		.word xt_asm_and_ziy, z_asm_and_ziy
003886r 3  61 6E 64 2E  		.byte "and.ziy"
00388Ar 3  7A 69 79     
00388Dr 3               
00388Dr 3               nt_asm_and_zx:
00388Dr 3  06 04        		.byte 6, IM
00388Fr 3  rr rr                        .word nt_asm_and_zxi
003891r 3  rr rr rr rr  		.word xt_asm_and_zx, z_asm_and_zx
003895r 3  61 6E 64 2E  		.byte "and.zx"
003899r 3  7A 78        
00389Br 3               
00389Br 3               nt_asm_and_zxi:
00389Br 3  07 04        		.byte 7, IM
00389Dr 3  rr rr                        .word nt_asm_asl
00389Fr 3  rr rr rr rr  		.word xt_asm_and_zxi, z_asm_and_zxi
0038A3r 3  61 6E 64 2E  		.byte "and.zxi"
0038A7r 3  7A 78 69     
0038AAr 3               
0038AAr 3               nt_asm_asl:
0038AAr 3  03 04        		.byte 3, IM
0038ACr 3  rr rr                        .word nt_asm_asl_a
0038AEr 3  rr rr rr rr  		.word xt_asm_asl, z_asm_asl
0038B2r 3  61 73 6C     		.byte "asl"
0038B5r 3               
0038B5r 3               nt_asm_asl_a:
0038B5r 3  05 04        		.byte 5, IM
0038B7r 3  rr rr                        .word nt_asm_asl_x
0038B9r 3  rr rr rr rr  		.word xt_asm_asl_a, z_asm_asl_a
0038BDr 3  61 73 6C 2E  		.byte "asl.a"
0038C1r 3  61           
0038C2r 3               
0038C2r 3               nt_asm_asl_x:
0038C2r 3  05 04        		.byte 5, IM
0038C4r 3  rr rr                        .word nt_asm_asl_z
0038C6r 3  rr rr rr rr  		.word xt_asm_asl_x, z_asm_asl_x
0038CAr 3  61 73 6C 2E  		.byte "asl.x"
0038CEr 3  78           
0038CFr 3               
0038CFr 3               nt_asm_asl_z:
0038CFr 3  05 04        		.byte 5, IM
0038D1r 3  rr rr                        .word nt_asm_asl_zx
0038D3r 3  rr rr rr rr  		.word xt_asm_asl_z, z_asm_asl_z
0038D7r 3  61 73 6C 2E  		.byte "asl.z"
0038DBr 3  7A           
0038DCr 3               
0038DCr 3               nt_asm_asl_zx:
0038DCr 3  06 04        		.byte 6, IM
0038DEr 3  rr rr                        .word nt_asm_bcc
0038E0r 3  rr rr rr rr  		.word xt_asm_asl_zx, z_asm_asl_zx
0038E4r 3  61 73 6C 2E  		.byte "asl.zx"
0038E8r 3  7A 78        
0038EAr 3               
0038EAr 3               nt_asm_bcc:
0038EAr 3  03 04        		.byte 3, IM
0038ECr 3  rr rr                        .word nt_asm_bcs
0038EEr 3  rr rr rr rr  		.word xt_asm_bcc, z_asm_bcc
0038F2r 3  62 63 63     		.byte "bcc"
0038F5r 3               
0038F5r 3               nt_asm_bcs:
0038F5r 3  03 04        		.byte 3, IM
0038F7r 3  rr rr                        .word nt_asm_beq
0038F9r 3  rr rr rr rr  		.word xt_asm_bcs, z_asm_bcs
0038FDr 3  62 63 73     		.byte "bcs"
003900r 3               
003900r 3               nt_asm_beq:
003900r 3  03 04        		.byte 3, IM
003902r 3  rr rr                        .word nt_asm_bit
003904r 3  rr rr rr rr  		.word xt_asm_beq, z_asm_beq
003908r 3  62 65 71     		.byte "beq"
00390Br 3               
00390Br 3               nt_asm_bit:
00390Br 3  03 04        		.byte 3, IM
00390Dr 3  rr rr                        .word nt_asm_bit_h
00390Fr 3  rr rr rr rr  		.word xt_asm_bit, z_asm_bit
003913r 3  62 69 74     		.byte "bit"
003916r 3               
003916r 3               nt_asm_bit_h:
003916r 3  05 04        		.byte 5, IM
003918r 3  rr rr                        .word nt_asm_bit_x
00391Ar 3  rr rr rr rr  		.word xt_asm_bit_h, z_asm_bit_h
00391Er 3  62 69 74 2E  		.byte "bit.#"
003922r 3  23           
003923r 3               
003923r 3               nt_asm_bit_x:
003923r 3  05 04        		.byte 5, IM
003925r 3  rr rr                        .word nt_asm_bit_z
003927r 3  rr rr rr rr  		.word xt_asm_bit_x, z_asm_bit_x
00392Br 3  62 69 74 2E  		.byte "bit.x"
00392Fr 3  78           
003930r 3               
003930r 3               nt_asm_bit_z:
003930r 3  05 04        		.byte 5, IM
003932r 3  rr rr                        .word nt_asm_bit_zx
003934r 3  rr rr rr rr  		.word xt_asm_bit_z, z_asm_bit_z
003938r 3  62 69 74 2E  		.byte "bit.z"
00393Cr 3  7A           
00393Dr 3               
00393Dr 3               nt_asm_bit_zx:
00393Dr 3  06 04        		.byte 6, IM
00393Fr 3  rr rr                        .word nt_asm_bmi
003941r 3  rr rr rr rr  		.word xt_asm_bit_zx, z_asm_bit_zx
003945r 3  62 69 74 2E  		.byte "bit.zx"
003949r 3  7A 78        
00394Br 3               
00394Br 3               nt_asm_bmi:
00394Br 3  03 04        		.byte 3, IM
00394Dr 3  rr rr                        .word nt_asm_bne
00394Fr 3  rr rr rr rr  		.word xt_asm_bmi, z_asm_bmi
003953r 3  62 6D 69     		.byte "bmi"
003956r 3               
003956r 3               nt_asm_bne:
003956r 3  03 04        		.byte 3, IM
003958r 3  rr rr                        .word nt_asm_bpl
00395Ar 3  rr rr rr rr  		.word xt_asm_bne, z_asm_bne
00395Er 3  62 6E 65     		.byte "bne"
003961r 3               
003961r 3               nt_asm_bpl:
003961r 3  03 04        		.byte 3, IM
003963r 3  rr rr                        .word nt_asm_bra
003965r 3  rr rr rr rr  		.word xt_asm_bpl, z_asm_bpl
003969r 3  62 70 6C     		.byte "bpl"
00396Cr 3               
00396Cr 3               nt_asm_bra:
00396Cr 3  03 04        		.byte 3, IM
00396Er 3  rr rr                        .word nt_asm_brk
003970r 3  rr rr rr rr  		.word xt_asm_bra, z_asm_bra
003974r 3  62 72 61     		.byte "bra"
003977r 3               
003977r 3               nt_asm_brk:
003977r 3  03 04        		.byte 3, IM
003979r 3  rr rr                        .word nt_asm_bvc
00397Br 3  rr rr rr rr  		.word xt_asm_brk, z_asm_brk
00397Fr 3  62 72 6B     		.byte "brk"
003982r 3               
003982r 3               nt_asm_bvc:
003982r 3  03 04        		.byte 3, IM
003984r 3  rr rr                        .word nt_asm_bvs
003986r 3  rr rr rr rr  		.word xt_asm_bvc, z_asm_bvc
00398Ar 3  62 76 63     		.byte "bvc"
00398Dr 3               
00398Dr 3               nt_asm_bvs:
00398Dr 3  03 04        		.byte 3, IM
00398Fr 3  rr rr                        .word nt_asm_clc
003991r 3  rr rr rr rr  		.word xt_asm_bvs, z_asm_bvs
003995r 3  62 76 73     		.byte "bvs"
003998r 3               
003998r 3               nt_asm_clc:
003998r 3  03 04        		.byte 3, IM
00399Ar 3  rr rr                        .word nt_asm_cld
00399Cr 3  rr rr rr rr  		.word xt_asm_clc, z_asm_clc
0039A0r 3  63 6C 63     		.byte "clc"
0039A3r 3               
0039A3r 3               nt_asm_cld:
0039A3r 3  03 04        		.byte 3, IM
0039A5r 3  rr rr                        .word nt_asm_cli
0039A7r 3  rr rr rr rr  		.word xt_asm_cld, z_asm_cld
0039ABr 3  63 6C 64     		.byte "cld"
0039AEr 3               
0039AEr 3               nt_asm_cli:
0039AEr 3  03 04        		.byte 3, IM
0039B0r 3  rr rr                        .word nt_asm_clv
0039B2r 3  rr rr rr rr  		.word xt_asm_cli, z_asm_cli
0039B6r 3  63 6C 69     		.byte "cli"
0039B9r 3               
0039B9r 3               nt_asm_clv:
0039B9r 3  03 04        		.byte 3, IM
0039BBr 3  rr rr                        .word nt_asm_cmp
0039BDr 3  rr rr rr rr  		.word xt_asm_clv, z_asm_clv
0039C1r 3  63 6C 76     		.byte "clv"
0039C4r 3               
0039C4r 3               nt_asm_cmp:
0039C4r 3  03 04        		.byte 3, IM
0039C6r 3  rr rr                        .word nt_asm_cmp_h
0039C8r 3  rr rr rr rr  		.word xt_asm_cmp, z_asm_cmp
0039CCr 3  63 6D 70     		.byte "cmp"
0039CFr 3               
0039CFr 3               nt_asm_cmp_h:
0039CFr 3  05 04        		.byte 5, IM
0039D1r 3  rr rr                        .word nt_asm_cmp_x
0039D3r 3  rr rr rr rr  		.word xt_asm_cmp_h, z_asm_cmp_h
0039D7r 3  63 6D 70 2E  		.byte "cmp.#"
0039DBr 3  23           
0039DCr 3               
0039DCr 3               nt_asm_cmp_x:
0039DCr 3  05 04        		.byte 5, IM
0039DEr 3  rr rr                        .word nt_asm_cmp_y
0039E0r 3  rr rr rr rr  		.word xt_asm_cmp_x, z_asm_cmp_x
0039E4r 3  63 6D 70 2E  		.byte "cmp.x"
0039E8r 3  78           
0039E9r 3               
0039E9r 3               nt_asm_cmp_y:
0039E9r 3  05 04        		.byte 5, IM
0039EBr 3  rr rr                        .word nt_asm_cmp_z
0039EDr 3  rr rr rr rr  		.word xt_asm_cmp_y, z_asm_cmp_y
0039F1r 3  63 6D 70 2E  		.byte "cmp.y"
0039F5r 3  79           
0039F6r 3               
0039F6r 3               nt_asm_cmp_z:
0039F6r 3  05 04        		.byte 5, IM
0039F8r 3  rr rr                        .word nt_asm_cmp_zi
0039FAr 3  rr rr rr rr  		.word xt_asm_cmp_z, z_asm_cmp_z
0039FEr 3  63 6D 70 2E  		.byte "cmp.z"
003A02r 3  7A           
003A03r 3               
003A03r 3               nt_asm_cmp_zi:
003A03r 3  06 04        		.byte 6, IM
003A05r 3  rr rr                        .word nt_asm_cmp_ziy
003A07r 3  rr rr rr rr  		.word xt_asm_cmp_zi, z_asm_cmp_zi
003A0Br 3  63 6D 70 2E  		.byte "cmp.zi"
003A0Fr 3  7A 69        
003A11r 3               
003A11r 3               nt_asm_cmp_ziy:
003A11r 3  07 04        		.byte 7, IM
003A13r 3  rr rr                        .word nt_asm_cmp_zx
003A15r 3  rr rr rr rr  		.word xt_asm_cmp_ziy, z_asm_cmp_ziy
003A19r 3  63 6D 70 2E  		.byte "cmp.ziy"
003A1Dr 3  7A 69 79     
003A20r 3               
003A20r 3               nt_asm_cmp_zx:
003A20r 3  06 04        		.byte 6, IM
003A22r 3  rr rr                        .word nt_asm_cmp_zxi
003A24r 3  rr rr rr rr  		.word xt_asm_cmp_zx, z_asm_cmp_zx
003A28r 3  63 6D 70 2E  		.byte "cmp.zx"
003A2Cr 3  7A 78        
003A2Er 3               
003A2Er 3               nt_asm_cmp_zxi:
003A2Er 3  07 04        		.byte 7, IM
003A30r 3  rr rr                        .word nt_asm_cpx
003A32r 3  rr rr rr rr  		.word xt_asm_cmp_zxi, z_asm_cmp_zxi
003A36r 3  63 6D 70 2E  		.byte "cmp.zxi"
003A3Ar 3  7A 78 69     
003A3Dr 3               
003A3Dr 3               nt_asm_cpx:
003A3Dr 3  03 04        		.byte 3, IM
003A3Fr 3  rr rr                        .word nt_asm_cpx_h
003A41r 3  rr rr rr rr  		.word xt_asm_cpx, z_asm_cpx
003A45r 3  63 70 78     		.byte "cpx"
003A48r 3               
003A48r 3               nt_asm_cpx_h:
003A48r 3  05 04        		.byte 5, IM
003A4Ar 3  rr rr                        .word nt_asm_cpx_z
003A4Cr 3  rr rr rr rr  		.word xt_asm_cpx_h, z_asm_cpx_h
003A50r 3  63 70 78 2E  		.byte "cpx.#"
003A54r 3  23           
003A55r 3               
003A55r 3               nt_asm_cpx_z:
003A55r 3  05 04        		.byte 5, IM
003A57r 3  rr rr                        .word nt_asm_cpy
003A59r 3  rr rr rr rr  		.word xt_asm_cpx_z, z_asm_cpx_z
003A5Dr 3  63 70 78 2E  		.byte "cpx.z"
003A61r 3  7A           
003A62r 3               
003A62r 3               nt_asm_cpy:
003A62r 3  03 04        		.byte 3, IM
003A64r 3  rr rr                        .word nt_asm_cpy_h
003A66r 3  rr rr rr rr  		.word xt_asm_cpy, z_asm_cpy
003A6Ar 3  63 70 79     		.byte "cpy"
003A6Dr 3               
003A6Dr 3               nt_asm_cpy_h:
003A6Dr 3  05 04        		.byte 5, IM
003A6Fr 3  rr rr                        .word nt_asm_cpy_z
003A71r 3  rr rr rr rr  		.word xt_asm_cpy_h, z_asm_cpy_h
003A75r 3  63 70 79 2E  		.byte "cpy.#"
003A79r 3  23           
003A7Ar 3               
003A7Ar 3               nt_asm_cpy_z:
003A7Ar 3  05 04        		.byte 5, IM
003A7Cr 3  rr rr                        .word nt_asm_dec
003A7Er 3  rr rr rr rr  		.word xt_asm_cpy_z, z_asm_cpy_z
003A82r 3  63 70 79 2E  		.byte "cpy.z"
003A86r 3  7A           
003A87r 3               
003A87r 3               nt_asm_dec:
003A87r 3  03 04        		.byte 3, IM
003A89r 3  rr rr                        .word nt_asm_dec_a
003A8Br 3  rr rr rr rr  		.word xt_asm_dec, z_asm_dec
003A8Fr 3  64 65 63     		.byte "dec"
003A92r 3               
003A92r 3               nt_asm_dec_a:
003A92r 3  05 04        		.byte 5, IM
003A94r 3  rr rr                        .word nt_asm_dec_x
003A96r 3  rr rr rr rr  		.word xt_asm_dec_a, z_asm_dec_a
003A9Ar 3  64 65 63 2E  		.byte "dec.a"
003A9Er 3  61           
003A9Fr 3               
003A9Fr 3               nt_asm_dec_x:
003A9Fr 3  05 04        		.byte 5, IM
003AA1r 3  rr rr                        .word nt_asm_dec_z
003AA3r 3  rr rr rr rr  		.word xt_asm_dec_x, z_asm_dec_x
003AA7r 3  64 65 63 2E  		.byte "dec.x"
003AABr 3  78           
003AACr 3               
003AACr 3               nt_asm_dec_z:
003AACr 3  05 04        		.byte 5, IM
003AAEr 3  rr rr                        .word nt_asm_dec_zx
003AB0r 3  rr rr rr rr  		.word xt_asm_dec_z, z_asm_dec_z
003AB4r 3  64 65 63 2E  		.byte "dec.z"
003AB8r 3  7A           
003AB9r 3               
003AB9r 3               nt_asm_dec_zx:
003AB9r 3  06 04        		.byte 6, IM
003ABBr 3  rr rr                        .word nt_asm_dex
003ABDr 3  rr rr rr rr  		.word xt_asm_dec_zx, z_asm_dec_zx
003AC1r 3  64 65 63 2E  		.byte "dec.zx"
003AC5r 3  7A 78        
003AC7r 3               
003AC7r 3               nt_asm_dex:
003AC7r 3  03 04        		.byte 3, IM
003AC9r 3  rr rr                        .word nt_asm_dey
003ACBr 3  rr rr rr rr  		.word xt_asm_dex, z_asm_dex
003ACFr 3  64 65 78     		.byte "dex"
003AD2r 3               
003AD2r 3               nt_asm_dey:
003AD2r 3  03 04        		.byte 3, IM
003AD4r 3  rr rr                        .word nt_asm_eor
003AD6r 3  rr rr rr rr  		.word xt_asm_dey, z_asm_dey
003ADAr 3  64 65 79     		.byte "dey"
003ADDr 3               
003ADDr 3               nt_asm_eor:
003ADDr 3  03 04        		.byte 3, IM
003ADFr 3  rr rr                        .word nt_asm_eor_h
003AE1r 3  rr rr rr rr  		.word xt_asm_eor, z_asm_eor
003AE5r 3  65 6F 72     		.byte "eor"
003AE8r 3               
003AE8r 3               nt_asm_eor_h:
003AE8r 3  05 04        		.byte 5, IM
003AEAr 3  rr rr                        .word nt_asm_eor_x
003AECr 3  rr rr rr rr  		.word xt_asm_eor_h, z_asm_eor_h
003AF0r 3  65 6F 72 2E  		.byte "eor.#"
003AF4r 3  23           
003AF5r 3               
003AF5r 3               nt_asm_eor_x:
003AF5r 3  05 04        		.byte 5, IM
003AF7r 3  rr rr                        .word nt_asm_eor_y
003AF9r 3  rr rr rr rr  		.word xt_asm_eor_x, z_asm_eor_x
003AFDr 3  65 6F 72 2E  		.byte "eor.x"
003B01r 3  78           
003B02r 3               
003B02r 3               nt_asm_eor_y:
003B02r 3  05 04        		.byte 5, IM
003B04r 3  rr rr                        .word nt_asm_eor_z
003B06r 3  rr rr rr rr  		.word xt_asm_eor_y, z_asm_eor_y
003B0Ar 3  65 6F 72 2E  		.byte "eor.y"
003B0Er 3  79           
003B0Fr 3               
003B0Fr 3               nt_asm_eor_z:
003B0Fr 3  05 04        		.byte 5, IM
003B11r 3  rr rr                        .word nt_asm_eor_zi
003B13r 3  rr rr rr rr  		.word xt_asm_eor_z, z_asm_eor_z
003B17r 3  65 6F 72 2E  		.byte "eor.z"
003B1Br 3  7A           
003B1Cr 3               
003B1Cr 3               nt_asm_eor_zi:
003B1Cr 3  06 04        		.byte 6, IM
003B1Er 3  rr rr                        .word nt_asm_eor_ziy
003B20r 3  rr rr rr rr  		.word xt_asm_eor_zi, z_asm_eor_zi
003B24r 3  65 6F 72 2E  		.byte "eor.zi"
003B28r 3  7A 69        
003B2Ar 3               
003B2Ar 3               nt_asm_eor_ziy:
003B2Ar 3  07 04        		.byte 7, IM
003B2Cr 3  rr rr                        .word nt_asm_eor_zx
003B2Er 3  rr rr rr rr  		.word xt_asm_eor_ziy, z_asm_eor_ziy
003B32r 3  65 6F 72 2E  		.byte "eor.ziy"
003B36r 3  7A 69 79     
003B39r 3               
003B39r 3               nt_asm_eor_zx:
003B39r 3  06 04        		.byte 6, IM
003B3Br 3  rr rr                        .word nt_asm_eor_zxi
003B3Dr 3  rr rr rr rr  		.word xt_asm_eor_zx, z_asm_eor_zx
003B41r 3  65 6F 72 2E  		.byte "eor.zx"
003B45r 3  7A 78        
003B47r 3               
003B47r 3               nt_asm_eor_zxi:
003B47r 3  07 04        		.byte 7, IM
003B49r 3  rr rr                        .word nt_asm_inc
003B4Br 3  rr rr rr rr  		.word xt_asm_eor_zxi, z_asm_eor_zxi
003B4Fr 3  65 6F 72 2E  		.byte "eor.zxi"
003B53r 3  7A 78 69     
003B56r 3               
003B56r 3               nt_asm_inc:
003B56r 3  03 04        		.byte 3, IM
003B58r 3  rr rr                        .word nt_asm_inc_a
003B5Ar 3  rr rr rr rr  		.word xt_asm_inc, z_asm_inc
003B5Er 3  69 6E 63     		.byte "inc"
003B61r 3               
003B61r 3               nt_asm_inc_a:
003B61r 3  05 04        		.byte 5, IM
003B63r 3  rr rr                        .word nt_asm_inc_x
003B65r 3  rr rr rr rr  		.word xt_asm_inc_a, z_asm_inc_a
003B69r 3  69 6E 63 2E  		.byte "inc.a"
003B6Dr 3  61           
003B6Er 3               
003B6Er 3               nt_asm_inc_x:
003B6Er 3  05 04        		.byte 5, IM
003B70r 3  rr rr                        .word nt_asm_inc_z
003B72r 3  rr rr rr rr  		.word xt_asm_inc_x, z_asm_inc_x
003B76r 3  69 6E 63 2E  		.byte "inc.x"
003B7Ar 3  78           
003B7Br 3               
003B7Br 3               nt_asm_inc_z:
003B7Br 3  05 04        		.byte 5, IM
003B7Dr 3  rr rr                        .word nt_asm_inc_zx
003B7Fr 3  rr rr rr rr  		.word xt_asm_inc_z, z_asm_inc_z
003B83r 3  69 6E 63 2E  		.byte "inc.z"
003B87r 3  7A           
003B88r 3               
003B88r 3               nt_asm_inc_zx:
003B88r 3  06 04        		.byte 6, IM
003B8Ar 3  rr rr                        .word nt_asm_inx
003B8Cr 3  rr rr rr rr  		.word xt_asm_inc_zx, z_asm_inc_zx
003B90r 3  69 6E 63 2E  		.byte "inc.zx"
003B94r 3  7A 78        
003B96r 3               
003B96r 3               nt_asm_inx:
003B96r 3  03 04        		.byte 3, IM
003B98r 3  rr rr                        .word nt_asm_iny
003B9Ar 3  rr rr rr rr  		.word xt_asm_inx, z_asm_inx
003B9Er 3  69 6E 78     		.byte "inx"
003BA1r 3               
003BA1r 3               nt_asm_iny:
003BA1r 3  03 04        		.byte 3, IM
003BA3r 3  rr rr                        .word nt_asm_jmp
003BA5r 3  rr rr rr rr  		.word xt_asm_iny, z_asm_iny
003BA9r 3  69 6E 79     		.byte "iny"
003BACr 3               
003BACr 3               nt_asm_jmp:
003BACr 3  03 04        		.byte 3, IM
003BAEr 3  rr rr                        .word nt_asm_jmp_i
003BB0r 3  rr rr rr rr  		.word xt_asm_jmp, z_asm_jmp
003BB4r 3  6A 6D 70     		.byte "jmp"
003BB7r 3               
003BB7r 3               nt_asm_jmp_i:
003BB7r 3  05 04        		.byte 5, IM
003BB9r 3  rr rr                        .word nt_asm_jmp_xi
003BBBr 3  rr rr rr rr  		.word xt_asm_jmp_i, z_asm_jmp_i
003BBFr 3  6A 6D 70 2E  		.byte "jmp.i"
003BC3r 3  69           
003BC4r 3               
003BC4r 3               nt_asm_jmp_xi:
003BC4r 3  06 04        		.byte 6, IM
003BC6r 3  rr rr                        .word nt_asm_jsr
003BC8r 3  rr rr rr rr  		.word xt_asm_jmp_xi, z_asm_jmp_xi
003BCCr 3  6A 6D 70 2E  		.byte "jmp.xi"
003BD0r 3  78 69        
003BD2r 3               
003BD2r 3               nt_asm_jsr:
003BD2r 3  03 04        		.byte 3, IM
003BD4r 3  rr rr                        .word nt_asm_lda
003BD6r 3  rr rr rr rr  		.word xt_asm_jsr, z_asm_jsr
003BDAr 3  6A 73 72     		.byte "jsr"
003BDDr 3               
003BDDr 3               nt_asm_lda:
003BDDr 3  03 04        		.byte 3, IM
003BDFr 3  rr rr                        .word nt_asm_lda_h
003BE1r 3  rr rr rr rr  		.word xt_asm_lda, z_asm_lda
003BE5r 3  6C 64 61     		.byte "lda"
003BE8r 3               
003BE8r 3               nt_asm_lda_h:
003BE8r 3  05 04        		.byte 5, IM
003BEAr 3  rr rr                        .word nt_asm_lda_x
003BECr 3  rr rr rr rr  		.word xt_asm_lda_h, z_asm_lda_h
003BF0r 3  6C 64 61 2E  		.byte "lda.#"
003BF4r 3  23           
003BF5r 3               
003BF5r 3               nt_asm_lda_x:
003BF5r 3  05 04        		.byte 5, IM
003BF7r 3  rr rr                        .word nt_asm_lda_y
003BF9r 3  rr rr rr rr  		.word xt_asm_lda_x, z_asm_lda_x
003BFDr 3  6C 64 61 2E  		.byte "lda.x"
003C01r 3  78           
003C02r 3               
003C02r 3               nt_asm_lda_y:
003C02r 3  05 04        		.byte 5, IM
003C04r 3  rr rr                        .word nt_asm_lda_z
003C06r 3  rr rr rr rr  		.word xt_asm_lda_y, z_asm_lda_y
003C0Ar 3  6C 64 61 2E  		.byte "lda.y"
003C0Er 3  79           
003C0Fr 3               
003C0Fr 3               nt_asm_lda_z:
003C0Fr 3  05 04        		.byte 5, IM
003C11r 3  rr rr                        .word nt_asm_lda_zi
003C13r 3  rr rr rr rr  		.word xt_asm_lda_z, z_asm_lda_z
003C17r 3  6C 64 61 2E  		.byte "lda.z"
003C1Br 3  7A           
003C1Cr 3               
003C1Cr 3               nt_asm_lda_zi:
003C1Cr 3  06 04        		.byte 6, IM
003C1Er 3  rr rr                        .word nt_asm_lda_ziy
003C20r 3  rr rr rr rr  		.word xt_asm_lda_zi, z_asm_lda_zi
003C24r 3  6C 64 61 2E  		.byte "lda.zi"
003C28r 3  7A 69        
003C2Ar 3               
003C2Ar 3               nt_asm_lda_ziy:
003C2Ar 3  07 04        		.byte 7, IM
003C2Cr 3  rr rr                        .word nt_asm_lda_zx
003C2Er 3  rr rr rr rr  		.word xt_asm_lda_ziy, z_asm_lda_ziy
003C32r 3  6C 64 61 2E  		.byte "lda.ziy"
003C36r 3  7A 69 79     
003C39r 3               
003C39r 3               nt_asm_lda_zx:
003C39r 3  06 04        		.byte 6, IM
003C3Br 3  rr rr                        .word nt_asm_lda_zxi
003C3Dr 3  rr rr rr rr  		.word xt_asm_lda_zx, z_asm_lda_zx
003C41r 3  6C 64 61 2E  		.byte "lda.zx"
003C45r 3  7A 78        
003C47r 3               
003C47r 3               nt_asm_lda_zxi:
003C47r 3  07 04        		.byte 7, IM
003C49r 3  rr rr                        .word nt_asm_ldx
003C4Br 3  rr rr rr rr  		.word xt_asm_lda_zxi, z_asm_lda_zxi
003C4Fr 3  6C 64 61 2E  		.byte "lda.zxi"
003C53r 3  7A 78 69     
003C56r 3               
003C56r 3               nt_asm_ldx:
003C56r 3  03 04        		.byte 3, IM
003C58r 3  rr rr                        .word nt_asm_ldx_h
003C5Ar 3  rr rr rr rr  		.word xt_asm_ldx, z_asm_ldx
003C5Er 3  6C 64 78     		.byte "ldx"
003C61r 3               
003C61r 3               nt_asm_ldx_h:
003C61r 3  05 04        		.byte 5, IM
003C63r 3  rr rr                        .word nt_asm_ldx_y
003C65r 3  rr rr rr rr  		.word xt_asm_ldx_h, z_asm_ldx_h
003C69r 3  6C 64 78 2E  		.byte "ldx.#"
003C6Dr 3  23           
003C6Er 3               
003C6Er 3               nt_asm_ldx_y:
003C6Er 3  05 04        		.byte 5, IM
003C70r 3  rr rr                        .word nt_asm_ldx_z
003C72r 3  rr rr rr rr  		.word xt_asm_ldx_y, z_asm_ldx_y
003C76r 3  6C 64 78 2E  		.byte "ldx.y"
003C7Ar 3  79           
003C7Br 3               
003C7Br 3               nt_asm_ldx_z:
003C7Br 3  05 04        		.byte 5, IM
003C7Dr 3  rr rr                        .word nt_asm_ldx_zy
003C7Fr 3  rr rr rr rr  		.word xt_asm_ldx_z, z_asm_ldx_z
003C83r 3  6C 64 78 2E  		.byte "ldx.z"
003C87r 3  7A           
003C88r 3               
003C88r 3               nt_asm_ldx_zy:
003C88r 3  06 04        		.byte 6, IM
003C8Ar 3  rr rr                        .word nt_asm_ldy
003C8Cr 3  rr rr rr rr  		.word xt_asm_ldx_zy, z_asm_ldx_zy
003C90r 3  6C 64 78 2E  		.byte "ldx.zy"
003C94r 3  7A 79        
003C96r 3               
003C96r 3               nt_asm_ldy:
003C96r 3  03 04        		.byte 3, IM
003C98r 3  rr rr                        .word nt_asm_ldy_h
003C9Ar 3  rr rr rr rr  		.word xt_asm_ldy, z_asm_ldy
003C9Er 3  6C 64 79     		.byte "ldy"
003CA1r 3               
003CA1r 3               nt_asm_ldy_h:
003CA1r 3  05 04        		.byte 5, IM
003CA3r 3  rr rr                        .word nt_asm_ldy_x
003CA5r 3  rr rr rr rr  		.word xt_asm_ldy_h, z_asm_ldy_h
003CA9r 3  6C 64 79 2E  		.byte "ldy.#"
003CADr 3  23           
003CAEr 3               
003CAEr 3               nt_asm_ldy_x:
003CAEr 3  05 04        		.byte 5, IM
003CB0r 3  rr rr                        .word nt_asm_ldy_z
003CB2r 3  rr rr rr rr  		.word xt_asm_ldy_x, z_asm_ldy_x
003CB6r 3  6C 64 79 2E  		.byte "ldy.x"
003CBAr 3  78           
003CBBr 3               
003CBBr 3               nt_asm_ldy_z:
003CBBr 3  05 04        		.byte 5, IM
003CBDr 3  rr rr                        .word nt_asm_ldy_zx
003CBFr 3  rr rr rr rr  		.word xt_asm_ldy_z, z_asm_ldy_z
003CC3r 3  6C 64 79 2E  		.byte "ldy.z"
003CC7r 3  7A           
003CC8r 3               
003CC8r 3               nt_asm_ldy_zx:
003CC8r 3  06 04        		.byte 6, IM
003CCAr 3  rr rr                        .word nt_asm_lsr
003CCCr 3  rr rr rr rr  		.word xt_asm_ldy_zx, z_asm_ldy_zx
003CD0r 3  6C 64 79 2E  		.byte "ldy.zx"
003CD4r 3  7A 78        
003CD6r 3               
003CD6r 3               nt_asm_lsr:
003CD6r 3  03 04        		.byte 3, IM
003CD8r 3  rr rr                        .word nt_asm_lsr_a
003CDAr 3  rr rr rr rr  		.word xt_asm_lsr, z_asm_lsr
003CDEr 3  6C 73 72     		.byte "lsr"
003CE1r 3               
003CE1r 3               nt_asm_lsr_a:
003CE1r 3  05 04        		.byte 5, IM
003CE3r 3  rr rr                        .word nt_asm_lsr_x
003CE5r 3  rr rr rr rr  		.word xt_asm_lsr_a, z_asm_lsr_a
003CE9r 3  6C 73 72 2E  		.byte "lsr.a"
003CEDr 3  61           
003CEEr 3               
003CEEr 3               nt_asm_lsr_x:
003CEEr 3  05 04        		.byte 5, IM
003CF0r 3  rr rr                        .word nt_asm_lsr_z
003CF2r 3  rr rr rr rr  		.word xt_asm_lsr_x, z_asm_lsr_x
003CF6r 3  6C 73 72 2E  		.byte "lsr.x"
003CFAr 3  78           
003CFBr 3               
003CFBr 3               nt_asm_lsr_z:
003CFBr 3  05 04        		.byte 5, IM
003CFDr 3  rr rr                        .word nt_asm_lsr_zx
003CFFr 3  rr rr rr rr  		.word xt_asm_lsr_z, z_asm_lsr_z
003D03r 3  6C 73 72 2E  		.byte "lsr.z"
003D07r 3  7A           
003D08r 3               
003D08r 3               nt_asm_lsr_zx:
003D08r 3  06 04        		.byte 6, IM
003D0Ar 3  rr rr                        .word nt_asm_nop
003D0Cr 3  rr rr rr rr  		.word xt_asm_lsr_zx, z_asm_lsr_zx
003D10r 3  6C 73 72 2E  		.byte "lsr.zx"
003D14r 3  7A 78        
003D16r 3               
003D16r 3               nt_asm_nop:
003D16r 3  03 04        		.byte 3, IM
003D18r 3  rr rr                        .word nt_asm_ora
003D1Ar 3  rr rr rr rr  		.word xt_asm_nop, z_asm_nop
003D1Er 3  6E 6F 70     		.byte "nop"
003D21r 3               
003D21r 3               nt_asm_ora:
003D21r 3  03 04        		.byte 3, IM
003D23r 3  rr rr                        .word nt_asm_ora_h
003D25r 3  rr rr rr rr  		.word xt_asm_ora, z_asm_ora
003D29r 3  6F 72 61     		.byte "ora"
003D2Cr 3               
003D2Cr 3               nt_asm_ora_h:
003D2Cr 3  05 04        		.byte 5, IM
003D2Er 3  rr rr                        .word nt_asm_ora_x
003D30r 3  rr rr rr rr  		.word xt_asm_ora_h, z_asm_ora_h
003D34r 3  6F 72 61 2E  		.byte "ora.#"
003D38r 3  23           
003D39r 3               
003D39r 3               nt_asm_ora_x:
003D39r 3  05 04        		.byte 5, IM
003D3Br 3  rr rr                        .word nt_asm_ora_y
003D3Dr 3  rr rr rr rr  		.word xt_asm_ora_x, z_asm_ora_x
003D41r 3  6F 72 61 2E  		.byte "ora.x"
003D45r 3  78           
003D46r 3               
003D46r 3               nt_asm_ora_y:
003D46r 3  05 04        		.byte 5, IM
003D48r 3  rr rr                        .word nt_asm_ora_z
003D4Ar 3  rr rr rr rr  		.word xt_asm_ora_y, z_asm_ora_y
003D4Er 3  6F 72 61 2E  		.byte "ora.y"
003D52r 3  79           
003D53r 3               
003D53r 3               nt_asm_ora_z:
003D53r 3  05 04        		.byte 5, IM
003D55r 3  rr rr                        .word nt_asm_ora_zi
003D57r 3  rr rr rr rr  		.word xt_asm_ora_z, z_asm_ora_z
003D5Br 3  6F 72 61 2E  		.byte "ora.z"
003D5Fr 3  7A           
003D60r 3               
003D60r 3               nt_asm_ora_zi:
003D60r 3  06 04        		.byte 6, IM
003D62r 3  rr rr                        .word nt_asm_ora_ziy
003D64r 3  rr rr rr rr  		.word xt_asm_ora_zi, z_asm_ora_zi
003D68r 3  6F 72 61 2E  		.byte "ora.zi"
003D6Cr 3  7A 69        
003D6Er 3               
003D6Er 3               nt_asm_ora_ziy:
003D6Er 3  07 04        		.byte 7, IM
003D70r 3  rr rr                        .word nt_asm_ora_zx
003D72r 3  rr rr rr rr  		.word xt_asm_ora_ziy, z_asm_ora_ziy
003D76r 3  6F 72 61 2E  		.byte "ora.ziy"
003D7Ar 3  7A 69 79     
003D7Dr 3               
003D7Dr 3               nt_asm_ora_zx:
003D7Dr 3  06 04        		.byte 6, IM
003D7Fr 3  rr rr                        .word nt_asm_ora_zxi
003D81r 3  rr rr rr rr  		.word xt_asm_ora_zx, z_asm_ora_zx
003D85r 3  6F 72 61 2E  		.byte "ora.zx"
003D89r 3  7A 78        
003D8Br 3               
003D8Br 3               nt_asm_ora_zxi:
003D8Br 3  07 04        		.byte 7, IM
003D8Dr 3  rr rr                        .word nt_asm_pha
003D8Fr 3  rr rr rr rr  		.word xt_asm_ora_zxi, z_asm_ora_zxi
003D93r 3  6F 72 61 2E  		.byte "ora.zxi"
003D97r 3  7A 78 69     
003D9Ar 3               
003D9Ar 3               nt_asm_pha:
003D9Ar 3  03 04        		.byte 3, IM
003D9Cr 3  rr rr                        .word nt_asm_php
003D9Er 3  rr rr rr rr  		.word xt_asm_pha, z_asm_pha
003DA2r 3  70 68 61     		.byte "pha"
003DA5r 3               
003DA5r 3               nt_asm_php:
003DA5r 3  03 04        		.byte 3, IM
003DA7r 3  rr rr                        .word nt_asm_phx
003DA9r 3  rr rr rr rr  		.word xt_asm_php, z_asm_php
003DADr 3  70 68 70     		.byte "php"
003DB0r 3               
003DB0r 3               nt_asm_phx:
003DB0r 3  03 04        		.byte 3, IM
003DB2r 3  rr rr                        .word nt_asm_phy
003DB4r 3  rr rr rr rr  		.word xt_asm_phx, z_asm_phx
003DB8r 3  70 68 78     		.byte "phx"
003DBBr 3               
003DBBr 3               nt_asm_phy:
003DBBr 3  03 04        		.byte 3, IM
003DBDr 3  rr rr                        .word nt_asm_pla
003DBFr 3  rr rr rr rr  		.word xt_asm_phy, z_asm_phy
003DC3r 3  70 68 79     		.byte "phy"
003DC6r 3               
003DC6r 3               nt_asm_pla:
003DC6r 3  03 04        		.byte 3, IM
003DC8r 3  rr rr                        .word nt_asm_plp
003DCAr 3  rr rr rr rr  		.word xt_asm_pla, z_asm_pla
003DCEr 3  70 6C 61     		.byte "pla"
003DD1r 3               
003DD1r 3               nt_asm_plp:
003DD1r 3  03 04        		.byte 3, IM
003DD3r 3  rr rr                        .word nt_asm_plx
003DD5r 3  rr rr rr rr  		.word xt_asm_plp, z_asm_plp
003DD9r 3  70 6C 70     		.byte "plp"
003DDCr 3               
003DDCr 3               nt_asm_plx:
003DDCr 3  03 04        		.byte 3, IM
003DDEr 3  rr rr                        .word nt_asm_ply
003DE0r 3  rr rr rr rr  		.word xt_asm_plx, z_asm_plx
003DE4r 3  70 6C 78     		.byte "plx"
003DE7r 3               
003DE7r 3               nt_asm_ply:
003DE7r 3  03 04        		.byte 3, IM
003DE9r 3  rr rr                        .word nt_asm_rol
003DEBr 3  rr rr rr rr  		.word xt_asm_ply, z_asm_ply
003DEFr 3  70 6C 79     		.byte "ply"
003DF2r 3               
003DF2r 3               nt_asm_rol:
003DF2r 3  03 04        		.byte 3, IM
003DF4r 3  rr rr                        .word nt_asm_rol_a
003DF6r 3  rr rr rr rr  		.word xt_asm_rol, z_asm_rol
003DFAr 3  72 6F 6C     		.byte "rol"
003DFDr 3               
003DFDr 3               nt_asm_rol_a:
003DFDr 3  05 04        		.byte 5, IM
003DFFr 3  rr rr                        .word nt_asm_rol_x
003E01r 3  rr rr rr rr  		.word xt_asm_rol_a, z_asm_rol_a
003E05r 3  72 6F 6C 2E  		.byte "rol.a"
003E09r 3  61           
003E0Ar 3               
003E0Ar 3               nt_asm_rol_x:
003E0Ar 3  05 04        		.byte 5, IM
003E0Cr 3  rr rr                        .word nt_asm_rol_z
003E0Er 3  rr rr rr rr  		.word xt_asm_rol_x, z_asm_rol_x
003E12r 3  72 6F 6C 2E  		.byte "rol.x"
003E16r 3  78           
003E17r 3               
003E17r 3               nt_asm_rol_z:
003E17r 3  05 04        		.byte 5, IM
003E19r 3  rr rr                        .word nt_asm_rol_zx
003E1Br 3  rr rr rr rr  		.word xt_asm_rol_z, z_asm_rol_z
003E1Fr 3  72 6F 6C 2E  		.byte "rol.z"
003E23r 3  7A           
003E24r 3               
003E24r 3               nt_asm_rol_zx:
003E24r 3  06 04        		.byte 6, IM
003E26r 3  rr rr                        .word nt_asm_ror
003E28r 3  rr rr rr rr  		.word xt_asm_rol_zx, z_asm_rol_zx
003E2Cr 3  72 6F 6C 2E  		.byte "rol.zx"
003E30r 3  7A 78        
003E32r 3               
003E32r 3               nt_asm_ror:
003E32r 3  03 04        		.byte 3, IM
003E34r 3  rr rr                        .word nt_asm_ror_a
003E36r 3  rr rr rr rr  		.word xt_asm_ror, z_asm_ror
003E3Ar 3  72 6F 72     		.byte "ror"
003E3Dr 3               
003E3Dr 3               nt_asm_ror_a:
003E3Dr 3  05 04        		.byte 5, IM
003E3Fr 3  rr rr                        .word nt_asm_ror_x
003E41r 3  rr rr rr rr  		.word xt_asm_ror_a, z_asm_ror_a
003E45r 3  72 6F 72 2E  		.byte "ror.a"
003E49r 3  61           
003E4Ar 3               
003E4Ar 3               nt_asm_ror_x:
003E4Ar 3  05 04        		.byte 5, IM
003E4Cr 3  rr rr                        .word nt_asm_ror_z
003E4Er 3  rr rr rr rr  		.word xt_asm_ror_x, z_asm_ror_x
003E52r 3  72 6F 72 2E  		.byte "ror.x"
003E56r 3  78           
003E57r 3               
003E57r 3               nt_asm_ror_z:
003E57r 3  05 04        		.byte 5, IM
003E59r 3  rr rr                        .word nt_asm_ror_zx
003E5Br 3  rr rr rr rr  		.word xt_asm_ror_z, z_asm_ror_z
003E5Fr 3  72 6F 72 2E  		.byte "ror.z"
003E63r 3  7A           
003E64r 3               
003E64r 3               nt_asm_ror_zx:
003E64r 3  06 04        		.byte 6, IM
003E66r 3  rr rr                        .word nt_asm_rti
003E68r 3  rr rr rr rr  		.word xt_asm_ror_zx, z_asm_ror_zx
003E6Cr 3  72 6F 72 2E  		.byte "ror.zx"
003E70r 3  7A 78        
003E72r 3               
003E72r 3               nt_asm_rti:
003E72r 3  03 04        		.byte 3, IM
003E74r 3  rr rr                        .word nt_asm_rts
003E76r 3  rr rr rr rr  		.word xt_asm_rti, z_asm_rti
003E7Ar 3  72 74 69     		.byte "rti"
003E7Dr 3               
003E7Dr 3               nt_asm_rts:
003E7Dr 3  03 04        		.byte 3, IM
003E7Fr 3  rr rr                        .word nt_asm_sbc
003E81r 3  rr rr rr rr  		.word xt_asm_rts, z_asm_rts
003E85r 3  72 74 73     		.byte "rts"
003E88r 3               
003E88r 3               nt_asm_sbc:
003E88r 3  03 04        		.byte 3, IM
003E8Ar 3  rr rr                        .word nt_asm_sbc_h
003E8Cr 3  rr rr rr rr  		.word xt_asm_sbc, z_asm_sbc
003E90r 3  73 62 63     		.byte "sbc"
003E93r 3               
003E93r 3               nt_asm_sbc_h:
003E93r 3  05 04        		.byte 5, IM
003E95r 3  rr rr                        .word nt_asm_sbc_x
003E97r 3  rr rr rr rr  		.word xt_asm_sbc_h, z_asm_sbc_h
003E9Br 3  73 62 63 2E  		.byte "sbc.#"
003E9Fr 3  23           
003EA0r 3               
003EA0r 3               nt_asm_sbc_x:
003EA0r 3  05 04        		.byte 5, IM
003EA2r 3  rr rr                        .word nt_asm_sbc_y
003EA4r 3  rr rr rr rr  		.word xt_asm_sbc_x, z_asm_sbc_x
003EA8r 3  73 62 63 2E  		.byte "sbc.x"
003EACr 3  78           
003EADr 3               
003EADr 3               nt_asm_sbc_y:
003EADr 3  05 04        		.byte 5, IM
003EAFr 3  rr rr                        .word nt_asm_sbc_z
003EB1r 3  rr rr rr rr  		.word xt_asm_sbc_y, z_asm_sbc_y
003EB5r 3  73 62 63 2E  		.byte "sbc.y"
003EB9r 3  79           
003EBAr 3               
003EBAr 3               nt_asm_sbc_z:
003EBAr 3  05 04        		.byte 5, IM
003EBCr 3  rr rr                        .word nt_asm_sbc_zi
003EBEr 3  rr rr rr rr  		.word xt_asm_sbc_z, z_asm_sbc_z
003EC2r 3  73 62 63 2E  		.byte "sbc.z"
003EC6r 3  7A           
003EC7r 3               
003EC7r 3               nt_asm_sbc_zi:
003EC7r 3  06 04        		.byte 6, IM
003EC9r 3  rr rr                        .word nt_asm_sbc_ziy
003ECBr 3  rr rr rr rr  		.word xt_asm_sbc_zi, z_asm_sbc_zi
003ECFr 3  73 62 63 2E  		.byte "sbc.zi"
003ED3r 3  7A 69        
003ED5r 3               
003ED5r 3               nt_asm_sbc_ziy:
003ED5r 3  07 04        		.byte 7, IM
003ED7r 3  rr rr                        .word nt_asm_sbc_zx
003ED9r 3  rr rr rr rr  		.word xt_asm_sbc_ziy, z_asm_sbc_ziy
003EDDr 3  73 62 63 2E  		.byte "sbc.ziy"
003EE1r 3  7A 69 79     
003EE4r 3               
003EE4r 3               nt_asm_sbc_zx:
003EE4r 3  06 04        		.byte 6, IM
003EE6r 3  rr rr                        .word nt_asm_sbc_zxi
003EE8r 3  rr rr rr rr  		.word xt_asm_sbc_zx, z_asm_sbc_zx
003EECr 3  73 62 63 2E  		.byte "sbc.zx"
003EF0r 3  7A 78        
003EF2r 3               
003EF2r 3               nt_asm_sbc_zxi:
003EF2r 3  07 04        		.byte 7, IM
003EF4r 3  rr rr                        .word nt_asm_sec
003EF6r 3  rr rr rr rr  		.word xt_asm_sbc_zxi, z_asm_sbc_zxi
003EFAr 3  73 62 63 2E  		.byte "sbc.zxi"
003EFEr 3  7A 78 69     
003F01r 3               
003F01r 3               nt_asm_sec:
003F01r 3  03 04        		.byte 3, IM
003F03r 3  rr rr                        .word nt_asm_sed
003F05r 3  rr rr rr rr  		.word xt_asm_sec, z_asm_sec
003F09r 3  73 65 63     		.byte "sec"
003F0Cr 3               
003F0Cr 3               nt_asm_sed:
003F0Cr 3  03 04        		.byte 3, IM
003F0Er 3  rr rr                        .word nt_asm_sei
003F10r 3  rr rr rr rr  		.word xt_asm_sed, z_asm_sed
003F14r 3  73 65 64     		.byte "sed"
003F17r 3               
003F17r 3               nt_asm_sei:
003F17r 3  03 04        		.byte 3, IM
003F19r 3  rr rr                        .word nt_asm_sta
003F1Br 3  rr rr rr rr  		.word xt_asm_sei, z_asm_sei
003F1Fr 3  73 65 69     		.byte "sei"
003F22r 3               
003F22r 3               nt_asm_sta:
003F22r 3  03 04        		.byte 3, IM
003F24r 3  rr rr                        .word nt_asm_sta_x
003F26r 3  rr rr rr rr  		.word xt_asm_sta, z_asm_sta
003F2Ar 3  73 74 61     		.byte "sta"
003F2Dr 3               
003F2Dr 3               nt_asm_sta_x:
003F2Dr 3  05 04        		.byte 5, IM
003F2Fr 3  rr rr                        .word nt_asm_sta_y
003F31r 3  rr rr rr rr  		.word xt_asm_sta_x, z_asm_sta_x
003F35r 3  73 74 61 2E  		.byte "sta.x"
003F39r 3  78           
003F3Ar 3               
003F3Ar 3               nt_asm_sta_y:
003F3Ar 3  05 04        		.byte 5, IM
003F3Cr 3  rr rr                        .word nt_asm_sta_z
003F3Er 3  rr rr rr rr  		.word xt_asm_sta_y, z_asm_sta_y
003F42r 3  73 74 61 2E  		.byte "sta.y"
003F46r 3  79           
003F47r 3               
003F47r 3               nt_asm_sta_z:
003F47r 3  05 04        		.byte 5, IM
003F49r 3  rr rr                        .word nt_asm_sta_zi
003F4Br 3  rr rr rr rr  		.word xt_asm_sta_z, z_asm_sta_z
003F4Fr 3  73 74 61 2E  		.byte "sta.z"
003F53r 3  7A           
003F54r 3               
003F54r 3               nt_asm_sta_zi:
003F54r 3  06 04        		.byte 6, IM
003F56r 3  rr rr                        .word nt_asm_sta_ziy
003F58r 3  rr rr rr rr  		.word xt_asm_sta_zi, z_asm_sta_zi
003F5Cr 3  73 74 61 2E  		.byte "sta.zi"
003F60r 3  7A 69        
003F62r 3               
003F62r 3               nt_asm_sta_ziy:
003F62r 3  07 04        		.byte 7, IM
003F64r 3  rr rr                        .word nt_asm_sta_zx
003F66r 3  rr rr rr rr  		.word xt_asm_sta_ziy, z_asm_sta_ziy
003F6Ar 3  73 74 61 2E  		.byte "sta.ziy"
003F6Er 3  7A 69 79     
003F71r 3               
003F71r 3               nt_asm_sta_zx:
003F71r 3  06 04        		.byte 6, IM
003F73r 3  rr rr                        .word nt_asm_sta_zxi
003F75r 3  rr rr rr rr  		.word xt_asm_sta_zx, z_asm_sta_zx
003F79r 3  73 74 61 2E  		.byte "sta.zx"
003F7Dr 3  7A 78        
003F7Fr 3               
003F7Fr 3               nt_asm_sta_zxi:
003F7Fr 3  07 04        		.byte 7, IM
003F81r 3  rr rr                        .word nt_asm_stx
003F83r 3  rr rr rr rr  		.word xt_asm_sta_zxi, z_asm_sta_zxi
003F87r 3  73 74 61 2E  		.byte "sta.zxi"
003F8Br 3  7A 78 69     
003F8Er 3               
003F8Er 3               nt_asm_stx:
003F8Er 3  03 04        		.byte 3, IM
003F90r 3  rr rr                        .word nt_asm_stx_z
003F92r 3  rr rr rr rr  		.word xt_asm_stx, z_asm_stx
003F96r 3  73 74 78     		.byte "stx"
003F99r 3               
003F99r 3               nt_asm_stx_z:
003F99r 3  05 04        		.byte 5, IM
003F9Br 3  rr rr                        .word nt_asm_stx_zy
003F9Dr 3  rr rr rr rr  		.word xt_asm_stx_z, z_asm_stx_z
003FA1r 3  73 74 78 2E  		.byte "stx.z"
003FA5r 3  7A           
003FA6r 3               
003FA6r 3               nt_asm_stx_zy:
003FA6r 3  06 04        		.byte 6, IM
003FA8r 3  rr rr                        .word nt_asm_sty
003FAAr 3  rr rr rr rr  		.word xt_asm_stx_zy, z_asm_stx_zy
003FAEr 3  73 74 78 2E  		.byte "stx.zy"
003FB2r 3  7A 79        
003FB4r 3               
003FB4r 3               nt_asm_sty:
003FB4r 3  03 04        		.byte 3, IM
003FB6r 3  rr rr                        .word nt_asm_sty_z
003FB8r 3  rr rr rr rr  		.word xt_asm_sty, z_asm_sty
003FBCr 3  73 74 79     		.byte "sty"
003FBFr 3               
003FBFr 3               nt_asm_sty_z:
003FBFr 3  05 04        		.byte 5, IM
003FC1r 3  rr rr                        .word nt_asm_sty_zx
003FC3r 3  rr rr rr rr  		.word xt_asm_sty_z, z_asm_sty_z
003FC7r 3  73 74 79 2E  		.byte "sty.z"
003FCBr 3  7A           
003FCCr 3               
003FCCr 3               nt_asm_sty_zx:
003FCCr 3  06 04        		.byte 6, IM
003FCEr 3  rr rr                        .word nt_asm_stz
003FD0r 3  rr rr rr rr  		.word xt_asm_sty_zx, z_asm_sty_zx
003FD4r 3  73 74 79 2E  		.byte "sty.zx"
003FD8r 3  7A 78        
003FDAr 3               
003FDAr 3               nt_asm_stz:
003FDAr 3  03 04        		.byte 3, IM
003FDCr 3  rr rr                        .word nt_asm_stz_x
003FDEr 3  rr rr rr rr  		.word xt_asm_stz, z_asm_stz
003FE2r 3  73 74 7A     		.byte "stz"
003FE5r 3               
003FE5r 3               nt_asm_stz_x:
003FE5r 3  05 04        		.byte 5, IM
003FE7r 3  rr rr                        .word nt_asm_stz_z
003FE9r 3  rr rr rr rr  		.word xt_asm_stz_x, z_asm_stz_x
003FEDr 3  73 74 7A 2E  		.byte "stz.x"
003FF1r 3  78           
003FF2r 3               
003FF2r 3               nt_asm_stz_z:
003FF2r 3  05 04        		.byte 5, IM
003FF4r 3  rr rr                        .word nt_asm_stz_zx
003FF6r 3  rr rr rr rr  		.word xt_asm_stz_z, z_asm_stz_z
003FFAr 3  73 74 7A 2E  		.byte "stz.z"
003FFEr 3  7A           
003FFFr 3               
003FFFr 3               nt_asm_stz_zx:
003FFFr 3  06 04        		.byte 6, IM
004001r 3  rr rr                        .word nt_asm_tax
004003r 3  rr rr rr rr  		.word xt_asm_stz_zx, z_asm_stz_zx
004007r 3  73 74 7A 2E  		.byte "stz.zx"
00400Br 3  7A 78        
00400Dr 3               
00400Dr 3               nt_asm_tax:
00400Dr 3  03 04        		.byte 3, IM
00400Fr 3  rr rr                        .word nt_asm_tay
004011r 3  rr rr rr rr  		.word xt_asm_tax, z_asm_tax
004015r 3  74 61 78     		.byte "tax"
004018r 3               
004018r 3               nt_asm_tay:
004018r 3  03 04        		.byte 3, IM
00401Ar 3  rr rr                        .word nt_asm_trb
00401Cr 3  rr rr rr rr  		.word xt_asm_tay, z_asm_tay
004020r 3  74 61 79     		.byte "tay"
004023r 3               
004023r 3               nt_asm_trb:
004023r 3  03 04        		.byte 3, IM
004025r 3  rr rr                        .word nt_asm_trb_z
004027r 3  rr rr rr rr  		.word xt_asm_trb, z_asm_trb
00402Br 3  74 72 62     		.byte "trb"
00402Er 3               
00402Er 3               nt_asm_trb_z:
00402Er 3  05 04        		.byte 5, IM
004030r 3  rr rr                        .word nt_asm_tsb
004032r 3  rr rr rr rr  		.word xt_asm_trb_z, z_asm_trb_z
004036r 3  74 72 62 2E  		.byte "trb.z"
00403Ar 3  7A           
00403Br 3               
00403Br 3               nt_asm_tsb:
00403Br 3  03 04        		.byte 3, IM
00403Dr 3  rr rr                        .word nt_asm_tsb_z
00403Fr 3  rr rr rr rr  		.word xt_asm_tsb, z_asm_tsb
004043r 3  74 73 62     		.byte "tsb"
004046r 3               
004046r 3               nt_asm_tsb_z:
004046r 3  05 04        		.byte 5, IM
004048r 3  rr rr                        .word nt_asm_tsx
00404Ar 3  rr rr rr rr  		.word xt_asm_tsb_z, z_asm_tsb_z
00404Er 3  74 73 62 2E  		.byte "tsb.z"
004052r 3  7A           
004053r 3               
004053r 3               nt_asm_tsx:
004053r 3  03 04        		.byte 3, IM
004055r 3  rr rr                        .word nt_asm_txa
004057r 3  rr rr rr rr  		.word xt_asm_tsx, z_asm_tsx
00405Br 3  74 73 78     		.byte "tsx"
00405Er 3               
00405Er 3               nt_asm_txa:
00405Er 3  03 04        		.byte 3, IM
004060r 3  rr rr                        .word nt_asm_txs
004062r 3  rr rr rr rr  		.word xt_asm_txa, z_asm_txa
004066r 3  74 78 61     		.byte "txa"
004069r 3               
004069r 3               nt_asm_txs:
004069r 3  03 04        		.byte 3, IM
00406Br 3  rr rr                        .word nt_asm_tya
00406Dr 3  rr rr rr rr  		.word xt_asm_txs, z_asm_txs
004071r 3  74 78 73     		.byte "txs"
004074r 3               
004074r 3               nt_asm_tya:
004074r 3  03 04        		.byte 3, IM
004076r 3  rr rr                        .word nt_asm_arrow
004078r 3  rr rr rr rr  		.word xt_asm_tya, z_asm_tya
00407Cr 3  74 79 61     		.byte "tya"
00407Fr 3               
00407Fr 3               ; Assembler pseudo-instructions, directives and macros
00407Fr 3               
00407Fr 3               nt_asm_arrow:   ; uses same code as HERE, but immediate
00407Fr 3  03 04                        .byte 3, IM
004081r 3  rr rr                        .word nt_asm_back_jump
004083r 3  rr rr rr rr                  .word xt_asm_arrow, z_asm_arrow
004087r 3  2D 2D 3E                     .byte "-->"
00408Ar 3               
00408Ar 3               
00408Ar 3               nt_asm_back_jump:  ; syntactic sugar, does nothing
00408Ar 3  02 04                        .byte 2, IM
00408Cr 3  rr rr                        .word nt_asm_back_branch
00408Er 3  rr rr rr rr                  .word xt_asm_back_jump, z_asm_back_jump
004092r 3  3C 6A                        .byte "<j"
004094r 3               
004094r 3               nt_asm_back_branch:
004094r 3  02 04                        .byte 2, IM
004096r 3  rr rr                        .word nt_asm_push_a
004098r 3  rr rr rr rr                  .word xt_asm_back_branch, z_asm_back_branch
00409Cr 3  3C 62                        .byte "<b"
00409Er 3               
00409Er 3               nt_asm_push_a:
00409Er 3  06 04                        .byte 6, IM
0040A0r 3  00 00                        .word 0000
0040A2r 3  rr rr rr rr                  .word xt_asm_push_a, z_asm_push_a
0040A6r 3  70 75 73 68                  .byte "push-a"
0040AAr 3  2D 61        
0040ACr 3               
0040ACr 3               .endif
0040ACr 3               
0040ACr 3               ; END of ASSEMBLER-WORDLIST
0040ACr 3               
0040ACr 3               ; END
0040ACr 3               
0040ACr 2                   .include "strings.s"          ; Headers of native words
0040ACr 3               ; List of Strings for Tali Forth 2
0040ACr 3               ; Scot W. Stevenson <scot.stevenson@gmail.com>
0040ACr 3               ; First version: 01. Apr 2016 (for Liara Forth)
0040ACr 3               ; This version: 28. Dec 2018
0040ACr 3               
0040ACr 3               ; This file is included by taliforth.asm
0040ACr 3               
0040ACr 3               ; ## GENERAL STRINGS
0040ACr 3               
0040ACr 3               ; All general strings must be zero-terminated, names start with "s_",
0040ACr 3               ; aliases with "str_"
0040ACr 3               
0040ACr 3               str_ok =              0
0040ACr 3               str_compile =         1
0040ACr 3               str_redefined =       2
0040ACr 3               str_wid_forth =       3
0040ACr 3               str_abc_lower =       4
0040ACr 3               str_abc_upper =       5
0040ACr 3               str_wid_editor =      6
0040ACr 3               str_wid_assembler =   7
0040ACr 3               str_wid_root =        8
0040ACr 3               str_see_flags =       9
0040ACr 3               str_see_nt =         10
0040ACr 3               str_see_xt =         11
0040ACr 3               str_see_size =       12
0040ACr 3               str_disasm_lit     = 13
0040ACr 3               str_disasm_sdc     = 14
0040ACr 3               str_disasm_bra     = 15
0040ACr 3               
0040ACr 3               ; Since we can't fit a 16-bit address in a register, we use indexes as offsets
0040ACr 3               ; to tables as error and string numbers.
0040ACr 3               string_table:
0040ACr 3  rr rr rr rr          .word s_ok, s_compiled, s_redefined, s_wid_forth, s_abc_lower ; 0-4
0040B0r 3  rr rr rr rr  
0040B4r 3  rr rr        
0040B6r 3  rr rr rr rr          .word s_abc_upper, s_wid_editor, s_wid_asm, s_wid_root        ; 5-8
0040BAr 3  rr rr rr rr  
0040BEr 3  rr rr rr rr          .word s_see_flags, s_see_nt, s_see_xt, s_see_size             ; 9-12
0040C2r 3  rr rr rr rr  
0040C6r 3               
0040C6r 3  20 6F 6B 00  s_ok:         .byte " ok", 0         ; note space at beginning
0040CAr 3  20 63 6F 6D  s_compiled:   .byte " compiled", 0   ; note space at beginning
0040CEr 3  70 69 6C 65  
0040D2r 3  64 00        
0040D4r 3  72 65 64 65  s_redefined:  .byte "redefined ", 0  ; note space at end
0040D8r 3  66 69 6E 65  
0040DCr 3  64 20 00     
0040DFr 3               
0040DFr 3  30 31 32 33  s_abc_lower:  .byte "0123456789abcdefghijklmnopqrstuvwxyz"
0040E3r 3  34 35 36 37  
0040E7r 3  38 39 61 62  
004103r 3  30 31 32 33  s_abc_upper:  .byte "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
004107r 3  34 35 36 37  
00410Br 3  38 39 41 42  
004127r 3               
004127r 3  41 73 73 65  s_wid_asm:    .byte "Assembler ", 0  ; Wordlist ID 2, note space at end
00412Br 3  6D 62 6C 65  
00412Fr 3  72 20 00     
004132r 3  45 64 69 74  s_wid_editor: .byte "Editor ", 0     ; Wordlist ID 1, note space at end
004136r 3  6F 72 20 00  
00413Ar 3  46 6F 72 74  s_wid_forth:  .byte "Forth ", 0      ; Wordlist ID 0, note space at end
00413Er 3  68 20 00     
004141r 3  52 6F 6F 74  s_wid_root:   .byte "Root ", 0       ; Wordlist ID 3, note space at end
004145r 3  20 00        
004147r 3               
004147r 3  66 6C 61 67  s_see_flags:  .byte "flags (CO AN IM NN UF HC): ", 0
00414Br 3  73 20 28 43  
00414Fr 3  4F 20 41 4E  
004163r 3  6E 74 3A 20  s_see_nt:     .byte "nt: ", 0
004167r 3  00           
004168r 3  78 74 3A 20  s_see_xt:     .byte "xt: ", 0
00416Cr 3  00           
00416Dr 3  73 69 7A 65  s_see_size:   .byte "size (decimal): ", 0
004171r 3  20 28 64 65  
004175r 3  63 69 6D 61  
00417Er 3  4C 49 54 45  s_disasm_lit: .byte "LITERAL ", 0
004182r 3  52 41 4C 20  
004186r 3  00           
004187r 3  53 54 41 43  s_disasm_sdc: .byte "STACK DEPTH CHECK", 0
00418Br 3  4B 20 44 45  
00418Fr 3  50 54 48 20  
004199r 3  42 52 41 4E  s_disasm_bra: .byte "BRANCH ",0
00419Dr 3  43 48 20 00  
0041A1r 3               
0041A1r 3               
0041A1r 3               ; ## ERROR STRINGS
0041A1r 3               
0041A1r 3               ; All error strings must be zero-terminated, all names start with "es_",
0041A1r 3               ; aliases with "err_". If the string texts are changed, the test suite must be
0041A1r 3               ; as well
0041A1r 3               
0041A1r 3               err_allot =        0
0041A1r 3               err_badsource =    1
0041A1r 3               err_compileonly =  2
0041A1r 3               err_defer =        3
0041A1r 3               err_divzero =      4
0041A1r 3               err_noname =       5
0041A1r 3               err_refill =       6
0041A1r 3               err_state =        7
0041A1r 3               err_syntax =       8
0041A1r 3               err_underflow =    9
0041A1r 3               err_negallot =     10
0041A1r 3               err_wordlist =     11
0041A1r 3               err_blockwords =   12
0041A1r 3               
0041A1r 3               error_table:
0041A1r 3  rr rr rr rr          .word es_allot, es_badsource, es_compileonly, es_defer  ;  0-3
0041A5r 3  rr rr rr rr  
0041A9r 3  rr rr rr rr          .word es_divzero, es_noname, es_refill, es_state        ;  4-7
0041ADr 3  rr rr rr rr  
0041B1r 3  rr rr rr rr          .word es_syntax, es_underflow, es_negallot, es_wordlist ;  8-11
0041B5r 3  rr rr rr rr  
0041B9r 3  rr rr                .word es_blockwords                                    ; 12
0041BBr 3               
0041BBr 3  41 4C 4C 4F  es_allot:       .byte "ALLOT using all available memory", 0
0041BFr 3  54 20 75 73  
0041C3r 3  69 6E 67 20  
0041DCr 3  49 6C 6C 65  es_badsource:   .byte "Illegal SOURCE-ID during REFILL", 0
0041E0r 3  67 61 6C 20  
0041E4r 3  53 4F 55 52  
0041FCr 3  49 6E 74 65  es_compileonly: .byte "Interpreting a compile-only word", 0
004200r 3  72 70 72 65  
004204r 3  74 69 6E 67  
00421Dr 3  44 45 46 45  es_defer:       .byte "DEFERed word not defined yet", 0
004221r 3  52 65 64 20  
004225r 3  77 6F 72 64  
00423Ar 3  44 69 76 69  es_divzero:     .byte "Division by zero", 0
00423Er 3  73 69 6F 6E  
004242r 3  20 62 79 20  
00424Br 3  50 61 72 73  es_noname:      .byte "Parsing failure", 0
00424Fr 3  69 6E 67 20  
004253r 3  66 61 69 6C  
00425Br 3  51 55 49 54  es_refill:      .byte "QUIT could not get input (REFILL returned -1)", 0
00425Fr 3  20 63 6F 75  
004263r 3  6C 64 20 6E  
004289r 3  41 6C 72 65  es_state:       .byte "Already in compile mode", 0
00428Dr 3  61 64 79 20  
004291r 3  69 6E 20 63  
0042A1r 3  55 6E 64 65  es_syntax:      .byte "Undefined word", 0
0042A5r 3  66 69 6E 65  
0042A9r 3  64 20 77 6F  
0042B0r 3  53 74 61 63  es_underflow:   .byte "Stack underflow", 0
0042B4r 3  6B 20 75 6E  
0042B8r 3  64 65 72 66  
0042C0r 3  4D 61 78 20  es_negallot:    .byte "Max memory freed with ALLOT", 0
0042C4r 3  6D 65 6D 6F  
0042C8r 3  72 79 20 66  
0042DCr 3  4E 6F 20 77  es_wordlist:    .byte "No wordlists available", 0
0042E0r 3  6F 72 64 6C  
0042E4r 3  69 73 74 73  
0042F3r 3  50 6C 65 61  es_blockwords:  .byte "Please assign vectors BLOCK-READ-VECTOR and BLOCK-WRITE-VECTOR",0
0042F7r 3  73 65 20 61  
0042FBr 3  73 73 69 67  
004332r 3               
004332r 3               ; ## ENVIRONMENT STRINGS
004332r 3               
004332r 3               ; These are used by the ENVIRONMENT? word and stored in the old string format:
004332r 3               ; Length byte first, then the string itself that is not rpt. not
004332r 3               ; zero-terminated. Note these are uppercase by ANS defintion. All start with
004332r 3               ; "envs_".
004332r 3               
004332r 3               ; These return a single-cell number
004332r 3  0F 2F 43 4F  envs_cs:        .byte 15, "/COUNTED-STRING"
004336r 3  55 4E 54 45  
00433Ar 3  44 2D 53 54  
004342r 3  05 2F 48 4F  envs_hold:      .byte 5, "/HOLD"
004346r 3  4C 44        
004348r 3  04 2F 50 41  envs_pad:       .byte 4, "/PAD"
00434Cr 3  44           
00434Dr 3  11 41 44 44  envs_aub:       .byte 17, "ADDRESS-UNIT-BITS"
004351r 3  52 45 53 53  
004355r 3  2D 55 4E 49  
00435Fr 3  07 46 4C 4F  envs_floored:   .byte 7, "FLOORED"
004363r 3  4F 52 45 44  
004367r 3  08 4D 41 58  envs_max_char:  .byte 8, "MAX-CHAR"
00436Br 3  2D 43 48 41  
00436Fr 3  52           
004370r 3  05 4D 41 58  envs_max_n:     .byte 5, "MAX-N"
004374r 3  2D 4E        
004376r 3  05 4D 41 58  envs_max_u:     .byte 5, "MAX-U"
00437Ar 3  2D 55        
00437Cr 3  12 52 45 54  envs_rsc:       .byte 18, "RETURN-STACK-CELLS"
004380r 3  55 52 4E 2D  
004384r 3  53 54 41 43  
00438Fr 3  0B 53 54 41  envs_sc:        .byte 11, "STACK-CELLS"
004393r 3  43 4B 2D 43  
004397r 3  45 4C 4C 53  
00439Br 3  09 57 4F 52  envs_wl:        .byte 9, "WORDLISTS"
00439Fr 3  44 4C 49 53  
0043A3r 3  54 53        
0043A5r 3               
0043A5r 3               ; These return a double-cell number
0043A5r 3  05 4D 41 58  envs_max_d:     .byte 5, "MAX-D"
0043A9r 3  2D 44        
0043ABr 3  06 4D 41 58  envs_max_ud:    .byte 6, "MAX-UD"
0043AFr 3  2D 55 44     
0043B2r 3               
0043B2r 3               ; END
0043B2r 3               
0043B2r 2               
0043B2r 2               ; High-level Forth words, see forth_code/README.md
0043B2r 2               forth_words_start:
0043B2r 2  20 63 72 20  .incbin "forth_code/forth_words.asc"
0043B6r 2  2E 28 20 52  
0043BAr 2  65 61 64 79  
0043C4r 2               forth_words_end:
0043C4r 2               
0043C4r 2               ; User-defined Forth words, see forth_code/README.md
0043C4r 2               user_words_start:
0043C4r 2  20 32 30 20  .incbin "forth_code/user_words.asc"
0043C8r 2  63 6F 6E 73  
0043CCr 2  74 61 6E 74  
004A7Fr 2               user_words_end:
004A7Fr 2               
004A7Fr 2               
004A7Fr 2               ; =====================================================================
004A7Fr 2               ; COMPILE WORDS, JUMPS and SUBROUTINE JUMPS INTO CODE
004A7Fr 2               
004A7Fr 2               ; These three routines compile instructions such as "jsr xt_words" into a word
004A7Fr 2               ; at compile time so they are available at run time. Words that use this
004A7Fr 2               ; routine may not be natively compiled. We use "cmpl" as not to confuse these
004A7Fr 2               ; routines with the COMPILE, word. Always call this with a subroutine jump.
004A7Fr 2               ; This means combining JSR/RTS to JMP in those cases is not going to work. To
004A7Fr 2               ; use, load the LSB of the address in A and the MSB in Y. You can remember
004A7Fr 2               ; which comes first by thinking of the song "Young Americans" ("YA") by David
004A7Fr 2               ; Bowie.
004A7Fr 2               
004A7Fr 2               ;               ldy #>addr      ; MSB   ; "Young"
004A7Fr 2               ;               lda #<addr      ; LSB   ; "Americans"
004A7Fr 2               ;               jsr cmpl_subroutine
004A7Fr 2               
004A7Fr 2               ; Also, we keep a routine here to compile a single byte passed through A.
004A7Fr 2               
004A7Fr 2               cmpl_subroutine:
004A7Fr 2                   ; This is the entry point to compile JSR <ADDR>
004A7Fr 2  48               pha             ; save LSB of address
004A80r 2  A9 20            lda #$20        ; load opcode for JSR
004A82r 2  80 03            bra cmpl_common
004A84r 2               cmpl_jump:
004A84r 2                   ; This is the entry point to compile JMP <ADDR>
004A84r 2  48               pha             ; save LSB of address
004A85r 2  A9 4C            lda #$4c        ; load opcode for JMP, fall thru to cmpl_common
004A87r 2               cmpl_common:
004A87r 2                   ; At this point, A contains the opcode to be compiled,
004A87r 2                   ; the LSB of the address is on the 65c02 stack, and the MSB of
004A87r 2                   ; the address is in Y
004A87r 2  20 rr rr         jsr cmpl_a      ; compile opcode
004A8Ar 2  68               pla             ; retrieve address LSB; fall thru to cmpl_word
004A8Br 2               cmpl_word:
004A8Br 2                   ; This is the entry point to compile a word (little-endian)
004A8Br 2  20 rr rr         jsr cmpl_a      ; compile LSB of address
004A8Er 2  98               tya             ; fall thru for MSB
004A8Fr 2               cmpl_a:
004A8Fr 2                   ; This is the entry point to compile a single byte which
004A8Fr 2                   ; is passed in A. The built-in assembler assumes that this
004A8Fr 2                   ; routine does not modify Y.
004A8Fr 2  92 rr            sta (cp)
004A91r 2  E6 rr            inc cp
004A93r 2  D0 02            bne _done
004A95r 2  E6 rr            inc cp+1
004A97r 2               _done:
004A97r 2  60               rts
004A98r 2               
004A98r 2               
004A98r 2               
004A98r 2               ; =====================================================================
004A98r 2               ; CODE FIELD ROUTINES
004A98r 2               
004A98r 2               doconst:
004A98r 2               ; """Execute a CONSTANT: Push the data in the first two bytes of
004A98r 2               ; the Data Field onto the Data Stack
004A98r 2               ; """
004A98r 2  CA               dex             ; make room for constant
004A99r 2  CA               dex
004A9Ar 2               
004A9Ar 2                   ; The value we need is stored in the two bytes after the
004A9Ar 2                   ; JSR return address, which in turn is what is on top of
004A9Ar 2                   ; the Return Stack
004A9Ar 2  68               pla             ; LSB of return address
004A9Br 2  85 rr            sta tmp1
004A9Dr 2  68               pla             ; MSB of return address
004A9Er 2  85 rr            sta tmp1+1
004AA0r 2               
004AA0r 2                   ; Start LDY with 1 instead of 0 because of how JSR stores
004AA0r 2                   ; the return address on the 65c02
004AA0r 2  A0 01            ldy #1
004AA2r 2  B1 rr            lda (tmp1),y
004AA4r 2  95 00            sta 0,x
004AA6r 2  C8               iny
004AA7r 2  B1 rr            lda (tmp1),y
004AA9r 2  95 01            sta 1,x
004AABr 2               
004AABr 2                   ; This takes us back to the original caller, not the
004AABr 2                   ; DOCONST caller
004AABr 2  60               rts
004AACr 2               
004AACr 2               
004AACr 2               dodefer:
004AACr 2               ; """Execute a DEFER statement at runtime: Execute the address we
004AACr 2               ; find after the caller in the Data Field
004AACr 2               ; """
004AACr 2                   ; The xt we need is stored in the two bytes after the JSR
004AACr 2                   ; return address, which is what is on top of the Return
004AACr 2                   ; Stack. So all we have to do is replace our return jump
004AACr 2                   ; with what we find there
004AACr 2  68               pla             ; LSB
004AADr 2  85 rr            sta tmp1
004AAFr 2  68               pla             ; MSB
004AB0r 2  85 rr            sta tmp1+1
004AB2r 2               
004AB2r 2  A0 01            ldy #1
004AB4r 2  B1 rr            lda (tmp1),y
004AB6r 2  85 rr            sta tmp2
004AB8r 2  C8               iny
004AB9r 2  B1 rr            lda (tmp1),y
004ABBr 2  85 rr            sta tmp2+1
004ABDr 2               
004ABDr 2  6C rr rr         jmp (tmp2)      ; This is actually a jump to the new target
004AC0r 2               
004AC0r 2               defer_error:
004AC0r 2                   ; """Error routine for undefined DEFER: Complain and abort"""
004AC0r 2  A9 03            lda #err_defer
004AC2r 2  4C rr rr         jmp error
004AC5r 2               
004AC5r 2               dodoes:
004AC5r 2               ; """Execute the runtime portion of DOES>. See DOES> and
004AC5r 2               ; docs/create-does.txt for details and
004AC5r 2               ; http://www.bradrodriguez.com/papers/moving3.htm
004AC5r 2               ; """
004AC5r 2                   ; Assumes the address of the CFA of the original defining word
004AC5r 2                   ; (say, CONSTANT) is on the top of the Return Stack. Save it
004AC5r 2                   ; for a later jump, adding one byte because of the way the
004AC5r 2                   ; 6502 works
004AC5r 2  7A               ply             ; LSB
004AC6r 2  68               pla             ; MSB
004AC7r 2  C8               iny
004AC8r 2  D0 01            bne @1
004ACAr 2  1A               inc
004ACBr 2               @1:
004ACBr 2  84 rr            sty tmp2
004ACDr 2  85 rr            sta tmp2+1
004ACFr 2               
004ACFr 2                   ; Next on the Return Stack should be the address of the PFA of
004ACFr 2                   ; the calling defined word (say, the name of whatever constant we
004ACFr 2                   ; just defined). Move this to the Data Stack, again adding one.
004ACFr 2  CA               dex
004AD0r 2  CA               dex
004AD1r 2               
004AD1r 2  7A               ply
004AD2r 2  68               pla
004AD3r 2  C8               iny
004AD4r 2  D0 01            bne @2
004AD6r 2  1A               inc
004AD7r 2               @2:
004AD7r 2  94 00            sty 0,x         ; LSB
004AD9r 2  95 01            sta 1,x         ; MSB
004ADBr 2               
004ADBr 2                   ; This leaves the return address from the original main routine
004ADBr 2                   ; on top of the Return Stack. We leave that untouched and jump
004ADBr 2                   ; to the special code of the defining word. It's RTS instruction
004ADBr 2                   ; will take us back to the main routine
004ADBr 2  6C rr rr         jmp (tmp2)
004ADEr 2               
004ADEr 2               
004ADEr 2               dovar:
004ADEr 2               ; """Execute a variable: Push the address of the first bytes of
004ADEr 2               ; the Data Field onto the stack. This is called with JSR so we
004ADEr 2               ; can pick up the address of the calling variable off the 65c02's
004ADEr 2               ; stack. The final RTS takes us to the original caller of the
004ADEr 2               ; routine that itself called DOVAR. This is the default
004ADEr 2               ; routine installed with CREATE.
004ADEr 2               ; """
004ADEr 2                   ; Pull the return address off the machine's stack, adding
004ADEr 2                   ; one because of the way the 65c02 handles subroutines
004ADEr 2  7A               ply             ; LSB
004ADFr 2  68               pla             ; MSB
004AE0r 2  C8               iny
004AE1r 2  D0 01            bne @1
004AE3r 2  1A               inc
004AE4r 2               @1:
004AE4r 2  CA               dex
004AE5r 2  CA               dex
004AE6r 2               
004AE6r 2  95 01            sta 1,x
004AE8r 2  98               tya
004AE9r 2  95 00            sta 0,x
004AEBr 2               
004AEBr 2  60               rts
004AECr 2               
004AECr 2               ; =====================================================================
004AECr 2               ; LOW LEVEL HELPER FUNCTIONS
004AECr 2               
004AECr 2               byte_to_ascii:
004AECr 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
004AECr 2               .scope
004AECr 2  48               pha
004AEDr 2  4A               lsr             ; convert high nibble first
004AEEr 2  4A               lsr
004AEFr 2  4A               lsr
004AF0r 2  4A               lsr
004AF1r 2  20 rr rr         jsr _nibble_to_ascii
004AF4r 2  68               pla
004AF5r 2               
004AF5r 2                   ; fall through to _nibble_to_ascii
004AF5r 2               
004AF5r 2               _nibble_to_ascii:
004AF5r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
004AF5r 2               ; of A and and EMIT it. This does the actual work.
004AF5r 2               ; """
004AF5r 2  29 0F            and #$0F
004AF7r 2  09 30            ora #'0'
004AF9r 2  C9 3A            cmp #$3A        ; '9+1
004AFBr 2  90 02            bcc @1
004AFDr 2  69 06            adc #$06
004AFFr 2               
004AFFr 2  4C rr rr     @1:               jmp emit_a
004B02r 2               
004B02r 2  60               rts
004B03r 2               .endscope
004B03r 2               
004B03r 2               compare_16bit:
004B03r 2               ; """Compare TOS/NOS and return results in form of the 65c02 flags
004B03r 2               ; Adapted from Leventhal "6502 Assembly Language Subroutines", see
004B03r 2               ; also http://www.6502.org/tutorials/compare_beyond.html
004B03r 2               ; For signed numbers, Z signals equality and N which number is larger:
004B03r 2               ;       if TOS = NOS: Z=1 and N=0
004B03r 2               ;       if TOS > NOS: Z=0 and N=0
004B03r 2               ;       if TOS < NOS: Z=0 and N=1
004B03r 2               ; For unsigned numbers, Z signals equality and C which number is larger:
004B03r 2               ;       if TOS = NOS: Z=1 and N=0
004B03r 2               ;       if TOS > NOS: Z=0 and C=1
004B03r 2               ;       if TOS < NOS: Z=0 and C=0
004B03r 2               ; Compared to the book routine, WORD1 (MINUED) is TOS
004B03r 2               ;                               WORD2 (SUBTRAHEND) is NOS
004B03r 2               ; """
004B03r 2               .scope
004B03r 2                   ; Compare LSB first to set the carry flag
004B03r 2  B5 00            lda 0,x                 ; LSB of TOS
004B05r 2  D5 02            cmp 2,x                 ; LSB of NOS
004B07r 2  F0 0A            beq _equal
004B09r 2               
004B09r 2                   ; LSBs are not equal, compare MSB
004B09r 2  B5 01            lda 1,x                 ; MSB of TOS
004B0Br 2  F5 03            sbc 3,x                 ; MSB of NOS
004B0Dr 2  09 01            ora #1                  ; Make zero flag 0 because not equal
004B0Fr 2  70 08            bvs _overflow
004B11r 2  80 08            bra _not_equal
004B13r 2               _equal:
004B13r 2                   ; Low bytes are equal, so we compare high bytes
004B13r 2  B5 01            lda 1,x                 ; MSB of TOS
004B15r 2  F5 03            sbc 3,x                 ; MSB of NOS
004B17r 2  50 04            bvc _done
004B19r 2               _overflow:
004B19r 2                   ; Handle overflow because we use signed numbers
004B19r 2  49 80            eor #$80                ; complement negative flag
004B1Br 2               _not_equal:
004B1Br 2  09 01            ora #1                  ; if overflow, we can't be eqal
004B1Dr 2               _done:
004B1Dr 2  60               rts
004B1Er 2               .endscope
004B1Er 2               
004B1Er 2               current_to_dp:
004B1Er 2               ; """Look up the current (compilation) dictionary pointer
004B1Er 2               ; in the wordlist set and put it into the dp zero-page
004B1Er 2               ; variable. Uses A and Y.
004B1Er 2               ; """
004B1Er 2                   ; Determine which wordlist is current
004B1Er 2  A0 04            ldy #current_offset
004B20r 2  B1 rr            lda (up),y      ; current is a byte variable
004B22r 2  0A               asl             ; turn it into an offset (in cells)
004B23r 2               
004B23r 2                   ; Get the dictionary pointer for that wordlist.
004B23r 2  18               clc
004B24r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004B26r 2  A8               tay
004B27r 2  B1 rr            lda (up),y              ; get the dp for that wordlist.
004B29r 2  85 rr            sta dp
004B2Br 2  C8               iny
004B2Cr 2  B1 rr            lda (up),y
004B2Er 2  85 rr            sta dp+1
004B30r 2               
004B30r 2  60               rts
004B31r 2               
004B31r 2               
004B31r 2               dp_to_current:
004B31r 2               ; """Look up which wordlist is current and update its pointer
004B31r 2               ; with the value in dp. Uses A and Y.
004B31r 2               ; """
004B31r 2                   ; Determine which wordlist is current
004B31r 2  A0 04            ldy #current_offset
004B33r 2  B1 rr            lda (up),y      ; current is a byte variable
004B35r 2  0A               asl             ; turn it into an offset (in cells)
004B36r 2               
004B36r 2                   ; Get the dictionary pointer for that wordlist.
004B36r 2  18               clc
004B37r 2  69 06            adc #wordlists_offset   ; add offset to wordlists base.
004B39r 2  A8               tay
004B3Ar 2  A5 rr            lda dp
004B3Cr 2  91 rr            sta (up),y              ; get the dp for that wordlist.
004B3Er 2  C8               iny
004B3Fr 2  A5 rr            lda dp+1
004B41r 2  91 rr            sta (up),y
004B43r 2               
004B43r 2  60               rts
004B44r 2               
004B44r 2               interpret:
004B44r 2               .scope
004B44r 2               ; """Core routine for the interpreter called by EVALUATE and QUIT.
004B44r 2               ; Process one line only. Assumes that the address of name is in
004B44r 2               ; cib and the length of the whole input line string is in ciblen
004B44r 2               ; """
004B44r 2                   ; Normally we would use PARSE here with the SPACE character as
004B44r 2                   ; a parameter (PARSE replaces WORD in modern Forths). However,
004B44r 2                   ; Gforth's PARSE-NAME makes more sense as it uses spaces as
004B44r 2                   ; delimiters per default and skips any leading spaces, which
004B44r 2                   ; PARSE doesn't
004B44r 2               _loop:
004B44r 2  20 rr rr         jsr xt_parse_name       ; ( "string" -- addr u )
004B47r 2               
004B47r 2                   ; If PARSE-NAME returns 0 (empty line), no characters were left
004B47r 2                   ; in the line and we need to go get a new line
004B47r 2  B5 00            lda 0,x
004B49r 2  15 01            ora 1,x
004B4Br 2  F0 70            beq _line_done
004B4Dr 2               
004B4Dr 2                   ; Go to FIND-NAME to see if this is a word we know. We have to
004B4Dr 2                   ; make a copy of the address in case it isn't a word we know and
004B4Dr 2                   ; we have to go see if it is a number
004B4Dr 2  20 rr rr         jsr xt_two_dup          ; ( addr u -- addr u addr u )
004B50r 2  20 rr rr         jsr xt_find_name        ; ( addr u addr u -- addr u nt|0 )
004B53r 2               
004B53r 2                   ; A zero signals that we didn't find a word in the Dictionary
004B53r 2  B5 00            lda 0,x
004B55r 2  15 01            ora 1,x
004B57r 2  D0 28            bne _got_name_token
004B59r 2               
004B59r 2                   ; We didn't get any nt we know of, so let's see if this is
004B59r 2                   ; a number.
004B59r 2  E8               inx                     ; ( addr u 0 -- addr u )
004B5Ar 2  E8               inx
004B5Br 2               
004B5Br 2                   ; If the number conversion doesn't work, NUMBER will do the
004B5Br 2                   ; complaining for us
004B5Br 2  20 rr rr         jsr xt_number           ; ( addr u -- u|d )
004B5Er 2               
004B5Er 2                   ; Otherweise, if we're interpreting, we're done
004B5Er 2  A5 rr            lda state
004B60r 2  F0 E2            beq _loop
004B62r 2               
004B62r 2                   ; We're compiling, so there is a bit more work.  Check
004B62r 2                   ; status bit 5 to see if it's a single or double-cell
004B62r 2                   ; number.
004B62r 2  A9 20            lda #$20
004B64r 2  24 rr            bit status
004B66r 2  F0 0D            beq _single_number
004B68r 2               
004B68r 2                   ; It's a double cell number.  If we swap the
004B68r 2                   ; upper and lower half, we can use the literal_runtime twice
004B68r 2                   ; to compile it into the dictionary.
004B68r 2  20 rr rr         jsr xt_swap
004B6Br 2  A0 rr            ldy #>literal_runtime
004B6Dr 2  A9 rr            lda #<literal_runtime
004B6Fr 2  20 rr rr         jsr cmpl_subroutine
004B72r 2               
004B72r 2                   ; compile our number
004B72r 2  20 rr rr         jsr xt_comma
004B75r 2               
004B75r 2                   ; Fall into _single_number to process the other half.
004B75r 2               _single_number:
004B75r 2  A0 rr            ldy #>literal_runtime
004B77r 2  A9 rr            lda #<literal_runtime
004B79r 2  20 rr rr         jsr cmpl_subroutine
004B7Cr 2               
004B7Cr 2                   ; compile our number
004B7Cr 2  20 rr rr         jsr xt_comma
004B7Fr 2               
004B7Fr 2                   ; That was so much fun, let's do it again!
004B7Fr 2  80 C3            bra _loop
004B81r 2               
004B81r 2               _got_name_token:
004B81r 2                   ; We have a known word's nt TOS. We're going to need its xt
004B81r 2                   ; though, which is four bytes father down.
004B81r 2               
004B81r 2                   ; We arrive here with ( addr u nt ), so we NIP twice
004B81r 2  B5 00            lda 0,x
004B83r 2  95 04            sta 4,x
004B85r 2  B5 01            lda 1,x
004B87r 2  95 05            sta 5,x
004B89r 2               
004B89r 2  E8               inx
004B8Ar 2  E8               inx
004B8Br 2  E8               inx
004B8Cr 2  E8               inx                     ; ( nt )
004B8Dr 2               
004B8Dr 2                   ; Save a version of nt for error handling and compilation stuff
004B8Dr 2  B5 00            lda 0,x
004B8Fr 2  85 rr            sta tmpbranch
004B91r 2  B5 01            lda 1,x
004B93r 2  85 rr            sta tmpbranch+1
004B95r 2               
004B95r 2  20 rr rr         jsr xt_name_to_int      ; ( nt - xt )
004B98r 2               
004B98r 2                   ; See if we are in interpret or compile mode, 0 is interpret
004B98r 2  A5 rr            lda state
004B9Ar 2  D0 13            bne _compile
004B9Cr 2               
004B9Cr 2                   ; We are interpreting, so EXECUTE the xt that is TOS. First,
004B9Cr 2                   ; though, see if this isn't a compile-only word, which would be
004B9Cr 2                   ; illegal. The status byte is the second one of the header.
004B9Cr 2  A0 01            ldy #1
004B9Er 2  B1 rr            lda (tmpbranch),y
004BA0r 2  29 01            and #CO                 ; mask everything but Compile Only bit
004BA2r 2  F0 05            beq _interpret
004BA4r 2               
004BA4r 2  A9 02            lda #err_compileonly
004BA6r 2  4C rr rr         jmp error
004BA9r 2               
004BA9r 2               _interpret:
004BA9r 2                   ; We JSR to EXECUTE instead of calling the xt directly because
004BA9r 2                   ; the RTS of the word we're executing will bring us back here,
004BA9r 2                   ; skipping EXECUTE completely during RTS. If we were to execute
004BA9r 2                   ; xt directly, we have to fool around with the Return Stack
004BA9r 2                   ; instead, which is actually slightly slower
004BA9r 2  20 rr rr         jsr xt_execute
004BACr 2               
004BACr 2                   ; That's quite enough for this word, let's get the next one
004BACr 2  4C rr rr         jmp _loop
004BAFr 2               
004BAFr 2               _compile:
004BAFr 2                   ; We're compiling! However, we need to see if this is an
004BAFr 2                   ; IMMEDIATE word, which would mean we execute it right now even
004BAFr 2                   ; during compilation mode. Fortunately, we saved the nt so life
004BAFr 2                   ; is easier. The flags are in the second byte of the header
004BAFr 2  A0 01            ldy #1
004BB1r 2  B1 rr            lda (tmpbranch),y
004BB3r 2  29 04            and #IM                 ; Mask all but IM bit
004BB5r 2  D0 F2            bne _interpret          ; IMMEDIATE word, execute right now
004BB7r 2               
004BB7r 2                   ; Compile the xt into the Dictionary with COMPILE,
004BB7r 2  20 rr rr         jsr xt_compile_comma
004BBAr 2  4C rr rr         jmp _loop
004BBDr 2               
004BBDr 2               _line_done:
004BBDr 2                   ; drop stuff from PARSE_NAME
004BBDr 2  E8               inx
004BBEr 2  E8               inx
004BBFr 2  E8               inx
004BC0r 2  E8               inx
004BC1r 2               
004BC1r 2  60               rts
004BC2r 2               .endscope
004BC2r 2               
004BC2r 2               
004BC2r 2               is_printable:
004BC2r 2               .scope
004BC2r 2               ; """Given a character in A, check if it is a printable ASCII
004BC2r 2               ; character in the range from $20 to $7E inclusive. Returns the
004BC2r 2               ; result in the Carry Flag: 0 (clear) is not printable, 1 (set)
004BC2r 2               ; is printable. Keeps A. See
004BC2r 2               ; http://www.obelisk.me.uk/6502/algorithms.html for a
004BC2r 2               ; discussion of various ways to do this
004BC2r 2  C9 20            cmp #AscSP              ; $20
004BC4r 2  90 08            bcc _done
004BC6r 2  C9 7F            cmp #'~' + 1             ; $7E
004BC8r 2  B0 03            bcs _failed
004BCAr 2               
004BCAr 2  38               sec
004BCBr 2  80 01            bra _done
004BCDr 2               _failed:
004BCDr 2  18               clc
004BCEr 2               _done:
004BCEr 2  60               rts
004BCFr 2               .endscope
004BCFr 2               
004BCFr 2               
004BCFr 2               is_whitespace:
004BCFr 2               .scope
004BCFr 2               ; """Given a character in A, check if it is a whitespace
004BCFr 2               ; character, that is, an ASCII value from 0 to 32 (where
004BCFr 2               ; 32 is SPACE). Returns the result in the Carry Flag:
004BCFr 2               ; 0 (clear) is no, it isn't whitespace, while 1 (set) means
004BCFr 2               ; that it is whitespace. See PARSE and PARSE-NAME for
004BCFr 2               ; a discussion of the uses. Does not change A or Y.
004BCFr 2  C9 00            cmp #00         ; explicit comparison to leave Y untouched
004BD1r 2  90 08            bcc _done
004BD3r 2               
004BD3r 2  C9 21            cmp #AscSP+1
004BD5r 2  B0 03            bcs _failed
004BD7r 2               
004BD7r 2  38               sec
004BD8r 2  80 01            bra _done
004BDAr 2               _failed:
004BDAr 2  18               clc
004BDBr 2               _done:
004BDBr 2  60               rts
004BDCr 2               .endscope
004BDCr 2               
004BDCr 2               
004BDCr 2               ; Underflow tests. We jump to the label with the number of cells (not: bytes)
004BDCr 2               ; required for the word. This routine flows into the generic error handling
004BDCr 2               ; code
004BDCr 2               underflow_1:
004BDCr 2               ; """Make sure we have at least one cell on the Data Stack"""
004BDCr 2  E0 rr            cpx #dsp0-1
004BDEr 2  10 10            bpl underflow_error
004BE0r 2  60               rts
004BE1r 2               underflow_2:
004BE1r 2               ; """Make sure we have at least two cells on the Data Stack"""
004BE1r 2  E0 rr            cpx #dsp0-3
004BE3r 2  10 0B            bpl underflow_error
004BE5r 2  60               rts
004BE6r 2               underflow_3:
004BE6r 2               ; """Make sure we have at least three cells on the Data Stack"""
004BE6r 2  E0 rr            cpx #dsp0-5
004BE8r 2  10 06            bpl underflow_error
004BEAr 2  60               rts
004BEBr 2               underflow_4:
004BEBr 2               ; """Make sure we have at least four cells on the Data Stack"""
004BEBr 2  E0 rr            cpx #dsp0-7
004BEDr 2  10 01            bpl underflow_error
004BEFr 2  60               rts
004BF0r 2               
004BF0r 2               underflow_error:
004BF0r 2                   ; Entry for COLD/ABORT/QUIT
004BF0r 2  A9 09            lda #err_underflow      ; fall through to error
004BF2r 2               
004BF2r 2               error:
004BF2r 2               ; """Given the error number in a, print the associated error string and
004BF2r 2               ; call abort. Uses tmp3.
004BF2r 2               ; """
004BF2r 2  0A               asl
004BF3r 2  A8               tay
004BF4r 2  B9 rr rr         lda error_table,y
004BF7r 2  85 rr            sta tmp3                ; LSB
004BF9r 2  C8               iny
004BFAr 2  B9 rr rr         lda error_table,y
004BFDr 2  85 rr            sta tmp3+1              ; MSB
004BFFr 2               
004BFFr 2  20 rr rr         jsr print_common
004C02r 2  20 rr rr         jsr xt_cr
004C05r 2  4C rr rr         jmp xt_abort            ; no jsr, as we clobber return stack
004C08r 2               
004C08r 2               
004C08r 2               ; =====================================================================
004C08r 2               ; PRINTING ROUTINES
004C08r 2               
004C08r 2               ; We distinguish two types of print calls, both of which take the string number
004C08r 2               ; (see strings.asm) in A:
004C08r 2               
004C08r 2               ;       print_string       - with a line feed
004C08r 2               ;       print_string_no_lf - without a line feed
004C08r 2               
004C08r 2               ; In addition, print_common provides a lower-level alternative for error
004C08r 2               ; handling and anything else that provides the address of the
004C08r 2               ; zero-terminated string directly in tmp3. All of those routines assume that
004C08r 2               ; printing should be more concerned with size than speed, because anything to
004C08r 2               ; do with humans reading text is going to be slow.
004C08r 2               
004C08r 2               print_string_no_lf:
004C08r 2               ; """Given the number of a zero-terminated string in A, print it to the
004C08r 2               ; current output without adding a LF. Uses Y and tmp3 by falling
004C08r 2               ; through to print_common
004C08r 2               ; """
004C08r 2                   ; Get the entry from the string table
004C08r 2  0A               asl
004C09r 2  A8               tay
004C0Ar 2  B9 rr rr         lda string_table,y
004C0Dr 2  85 rr            sta tmp3                ; LSB
004C0Fr 2  C8               iny
004C10r 2  B9 rr rr         lda string_table,y
004C13r 2  85 rr            sta tmp3+1              ; MSB
004C15r 2               
004C15r 2                   ; fall through to print_common
004C15r 2               print_common:
004C15r 2               ; """Common print routine used by both the print functions and
004C15r 2               ; the error printing routine. Assumes string address is in tmp3. Uses
004C15r 2               ; Y.
004C15r 2               ; """
004C15r 2               .scope
004C15r 2  A0 00            ldy #0
004C17r 2               _loop:
004C17r 2  B1 rr            lda (tmp3),y
004C19r 2  F0 06            beq _done               ; strings are zero-terminated
004C1Br 2               
004C1Br 2  20 rr rr         jsr emit_a              ; allows vectoring via output
004C1Er 2  C8               iny
004C1Fr 2  80 F6            bra _loop
004C21r 2               _done:
004C21r 2  60               rts
004C22r 2               .endscope
004C22r 2               
004C22r 2               print_string:
004C22r 2               ; """Print a zero-terminated string to the console/screen, adding a LF.
004C22r 2               ; We do not check to see if the index is out of range. Uses tmp3.
004C22r 2               ; """
004C22r 2  20 rr rr         jsr print_string_no_lf
004C25r 2  4C rr rr         jmp xt_cr               ; JSR/RTS because never compiled
004C28r 2               
004C28r 2               
004C28r 2               print_u:
004C28r 2               ; """basic printing routine used by higher-level constructs,
004C28r 2               ; the equivalent of the forth word  0 <# #s #> type  which is
004C28r 2               ; basically u. without the space at the end. used for various
004C28r 2               ; outputs
004C28r 2               ; """
004C28r 2  20 rr rr         jsr xt_zero                     ; 0
004C2Br 2  20 rr rr         jsr xt_less_number_sign         ; <#
004C2Er 2  20 rr rr         jsr xt_number_sign_s            ; #S
004C31r 2  20 rr rr         jsr xt_number_sign_greater      ; #>
004C34r 2  4C rr rr         jmp xt_type                     ; JSR/RTS because never compiled
004C37r 2               
004C37r 2               ; END
004C37r 2               
004C37r 1               
004C37r 1               .ifdef TALI_OPTIONAL_ASSEMBLER
004C37r 1               .include "../../assembler.s"
004C37r 2               ; Assembler for Tali Forth 2
004C37r 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004C37r 2               ; First version: 07. Nov 2014 (as tasm65c02)
004C37r 2               ; This version: 03. Jan 2019
004C37r 2               
004C37r 2               ; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
004C37r 2               ; is included with
004C37r 2               
004C37r 2               ;       assembler-wordlist >order
004C37r 2               
004C37r 2               ; the opcodes are available as normal Forth words. The format is Simpler
004C37r 2               ; Assembler Notation (SAN) which separates the opcode completely from the
004C37r 2               ; operand (see https://github.com/scotws/SAN). In this case, the operand is
004C37r 2               ; entered before the opcode in the postfix Forth notation (for example, "2000
004C37r 2               ; lda.#"). See the assembler documenation in the manual for more detail.
004C37r 2               
004C37r 2               ; The code here was originally used in A Typist's Assembler for the 65c02
004C37r 2               ; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
004C37r 2               ; version. Tasm65c02 is in the public domain.
004C37r 2               
004C37r 2               ; This code makes use of the opcode tables stored as part of the disassembler.
004C37r 2               
004C37r 2               ; ==========================================================
004C37r 2               ; MNEMONICS
004C37r 2               
004C37r 2               ; The assembler instructions are realized as individual Forth words with
004C37r 2               ; entries in the assembler wordlist (see header.asm). We pass the opcode in A.
004C37r 2               
004C37r 2               ; An alterantive method would have been along the lines of
004C37r 2               
004C37r 2               ;               jsr asm_common
004C37r 2               ;               .byte $EA
004C37r 2               
004C37r 2               ; where the asm_common then uses the address on the Return Stack to pick up the
004C37r 2               ; opcode and the length. Though this uses fewer resources, the current version
004C37r 2               ; makes up for this by simplifying the code of asm_common.
004C37r 2               
004C37r 2               ; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
004C37r 2               ; SAN and traditional mnemonics are listed after the opcode load instruction.
004C37r 2               ; This list was generated by a Python script in the tools folder, see there for
004C37r 2               ; more detail.
004C37r 2               
004C37r 2               assembler:              ; used to calculate size of assembler code
004C37r 2               .ifdef TALI_OPTIONAL_ASSEMBLER
004C37r 2               xt_asm_adc_h:   ; adc.# \ ADC #nn
004C37r 2  A9 69                        lda #$69
004C39r 2  4C rr rr                     jmp asm_common
004C3Cr 2               z_asm_adc_h:
004C3Cr 2               
004C3Cr 2               xt_asm_adc_x:   ; adc.x \ ADC nnnn,X
004C3Cr 2  A9 7D                        lda #$7D
004C3Er 2  4C rr rr                     jmp asm_common
004C41r 2               z_asm_adc_x:
004C41r 2               
004C41r 2               xt_asm_adc_y:   ; adc.y \ ADC nnnn,Y
004C41r 2  A9 79                        lda #$79
004C43r 2  4C rr rr                     jmp asm_common
004C46r 2               z_asm_adc_y:
004C46r 2               
004C46r 2               xt_asm_adc_z:   ; adc.z \ ADC nn
004C46r 2  A9 65                        lda #$65
004C48r 2  4C rr rr                     jmp asm_common
004C4Br 2               z_asm_adc_z:
004C4Br 2               
004C4Br 2               xt_asm_adc_zi:  ; adc.zi \ ADC (nn)
004C4Br 2  A9 72                        lda #$72
004C4Dr 2  4C rr rr                     jmp asm_common
004C50r 2               z_asm_adc_zi:
004C50r 2               
004C50r 2               xt_asm_adc_ziy: ; adc.ziy \ ADC (nn),Y
004C50r 2  A9 71                        lda #$71
004C52r 2  4C rr rr                     jmp asm_common
004C55r 2               z_asm_adc_ziy:
004C55r 2               
004C55r 2               xt_asm_adc_zx:  ; adc.zx \ ADC nn,X
004C55r 2  A9 75                        lda #$75
004C57r 2  4C rr rr                     jmp asm_common
004C5Ar 2               z_asm_adc_zx:
004C5Ar 2               
004C5Ar 2               xt_asm_adc_zxi: ; adc.zxi \ ADC (nn,X)
004C5Ar 2  A9 61                        lda #$61
004C5Cr 2  4C rr rr                     jmp asm_common
004C5Fr 2               z_asm_adc_zxi:
004C5Fr 2               
004C5Fr 2               xt_asm_and:     ; and. \ AND nnnn
004C5Fr 2  A9 2D                        lda #$2D
004C61r 2  4C rr rr                     jmp asm_common
004C64r 2               z_asm_and:
004C64r 2               
004C64r 2               xt_asm_and_h:   ; and.# \ AND #nn
004C64r 2  A9 29                        lda #$29
004C66r 2  4C rr rr                     jmp asm_common
004C69r 2               z_asm_and_h:
004C69r 2               
004C69r 2               xt_asm_and_x:   ; and.x \ AND nnnn,X
004C69r 2  A9 3D                        lda #$3D
004C6Br 2  4C rr rr                     jmp asm_common
004C6Er 2               z_asm_and_x:
004C6Er 2               
004C6Er 2               xt_asm_and_y:   ; and.y \ AND nnnn,Y
004C6Er 2  A9 39                        lda #$39
004C70r 2  4C rr rr                     jmp asm_common
004C73r 2               z_asm_and_y:
004C73r 2               
004C73r 2               xt_asm_and_z:   ; and.z \ AND nn
004C73r 2  A9 25                        lda #$25
004C75r 2  4C rr rr                     jmp asm_common
004C78r 2               z_asm_and_z:
004C78r 2               
004C78r 2               xt_asm_and_zi:  ; and.zi \ AND (nn)
004C78r 2  A9 32                        lda #$32
004C7Ar 2  4C rr rr                     jmp asm_common
004C7Dr 2               z_asm_and_zi:
004C7Dr 2               
004C7Dr 2               xt_asm_and_ziy: ; and.ziy \ AND (nn),Y
004C7Dr 2  A9 31                        lda #$31
004C7Fr 2  4C rr rr                     jmp asm_common
004C82r 2               z_asm_and_ziy:
004C82r 2               
004C82r 2               xt_asm_and_zx:  ; and.zx \ AND nn,X
004C82r 2  A9 35                        lda #$35
004C84r 2  4C rr rr                     jmp asm_common
004C87r 2               z_asm_and_zx:
004C87r 2               
004C87r 2               xt_asm_and_zxi: ; and.zxi \ AND (nn,X)
004C87r 2  A9 21                        lda #$21
004C89r 2  4C rr rr                     jmp asm_common
004C8Cr 2               z_asm_and_zxi:
004C8Cr 2               
004C8Cr 2               xt_asm_asl:     ; asl \ ASL nnnn
004C8Cr 2  A9 0E                        lda #$0E
004C8Er 2  4C rr rr                     jmp asm_common
004C91r 2               z_asm_asl:
004C91r 2               
004C91r 2               xt_asm_asl_a:   ; asl.a \ ASL
004C91r 2  A9 0A                        lda #$0A
004C93r 2  4C rr rr                     jmp asm_common
004C96r 2               z_asm_asl_a:
004C96r 2               
004C96r 2               xt_asm_asl_x:   ; asl.x \ ASL nnnn,X
004C96r 2  A9 1E                        lda #$1E
004C98r 2  4C rr rr                     jmp asm_common
004C9Br 2               z_asm_asl_x:
004C9Br 2               
004C9Br 2               xt_asm_asl_z:   ; asl.z \ ASL nn
004C9Br 2  A9 06                        lda #$06
004C9Dr 2  4C rr rr                     jmp asm_common
004CA0r 2               z_asm_asl_z:
004CA0r 2               
004CA0r 2               xt_asm_asl_zx:  ; asl.zx \ ASL nn,X
004CA0r 2  A9 16                        lda #$16
004CA2r 2  4C rr rr                     jmp asm_common
004CA5r 2               z_asm_asl_zx:
004CA5r 2               
004CA5r 2               xt_asm_bcc:     ; bcc \ BCC
004CA5r 2  A9 90                        lda #$90
004CA7r 2  4C rr rr                     jmp asm_common
004CAAr 2               z_asm_bcc:
004CAAr 2               
004CAAr 2               xt_asm_bcs:     ; bcs \ BCS
004CAAr 2  A9 B0                        lda #$B0
004CACr 2  A0 02                        ldy #2
004CAEr 2  4C rr rr                     jmp asm_common
004CB1r 2               z_asm_bcs:
004CB1r 2               
004CB1r 2               xt_asm_beq:     ; beq \ BEQ
004CB1r 2  A9 F0                        lda #$F0
004CB3r 2  4C rr rr                     jmp asm_common
004CB6r 2               z_asm_beq:
004CB6r 2               
004CB6r 2               xt_asm_bit:     ; bit \ BIT nnnn
004CB6r 2  A9 2C                        lda #$2C
004CB8r 2  4C rr rr                     jmp asm_common
004CBBr 2               z_asm_bit:
004CBBr 2               
004CBBr 2               xt_asm_bit_h:   ; bit.# \ BIT #nn
004CBBr 2  A9 89                        lda #$89
004CBDr 2  4C rr rr                     jmp asm_common
004CC0r 2               z_asm_bit_h:
004CC0r 2               
004CC0r 2               xt_asm_bit_x:   ; bit.x \ BIT nnnn,X
004CC0r 2  A9 3C                        lda #$3C
004CC2r 2  4C rr rr                     jmp asm_common
004CC5r 2               z_asm_bit_x:
004CC5r 2               
004CC5r 2               xt_asm_bit_z:   ; bit.z \ BIT nn
004CC5r 2  A9 24                        lda #$24
004CC7r 2  4C rr rr                     jmp asm_common
004CCAr 2               z_asm_bit_z:
004CCAr 2               
004CCAr 2               xt_asm_bit_zx:  ; bit.zx \ BIT nn,X
004CCAr 2  A9 34                        lda #$34
004CCCr 2  4C rr rr                     jmp asm_common
004CCFr 2               z_asm_bit_zx:
004CCFr 2               
004CCFr 2               xt_asm_bmi:     ; bmi \ BMI
004CCFr 2  A9 30                        lda #$30
004CD1r 2  4C rr rr                     jmp asm_common
004CD4r 2               z_asm_bmi:
004CD4r 2               
004CD4r 2               xt_asm_bne:     ; bne \ BNE
004CD4r 2  A9 D0                        lda #$D0
004CD6r 2  4C rr rr                     jmp asm_common
004CD9r 2               z_asm_bne:
004CD9r 2               
004CD9r 2               xt_asm_bpl:     ; bpl \ BPL
004CD9r 2  A9 10                        lda #$10
004CDBr 2  4C rr rr                     jmp asm_common
004CDEr 2               z_asm_bpl:
004CDEr 2               
004CDEr 2               xt_asm_bra:     ; bra \ BRA
004CDEr 2  A9 80                        lda #$80
004CE0r 2  4C rr rr                     jmp asm_common
004CE3r 2               z_asm_bra:
004CE3r 2               
004CE3r 2               xt_asm_brk:     ; brk \ BRK
004CE3r 2  A9 00                        lda #$00
004CE5r 2  4C rr rr                     jmp asm_common
004CE8r 2               z_asm_brk:
004CE8r 2               
004CE8r 2               xt_asm_bvc:     ; bvc \ BVC
004CE8r 2  A9 50                        lda #$50
004CEAr 2  4C rr rr                     jmp asm_common
004CEDr 2               z_asm_bvc:
004CEDr 2               
004CEDr 2               xt_asm_bvs:     ; bvs \ BVS
004CEDr 2  A9 70                        lda #$70
004CEFr 2  4C rr rr                     jmp asm_common
004CF2r 2               z_asm_bvs:
004CF2r 2               
004CF2r 2               xt_asm_clc:     ; clc \ CLC
004CF2r 2  A9 18                        lda #$18
004CF4r 2  4C rr rr                     jmp asm_common
004CF7r 2               z_asm_clc:
004CF7r 2               
004CF7r 2               xt_asm_cld:     ; cld \ CLD
004CF7r 2  A9 D8                        lda #$D8
004CF9r 2  4C rr rr                     jmp asm_common
004CFCr 2               z_asm_cld:
004CFCr 2               
004CFCr 2               xt_asm_cli:     ; cli \ CLI
004CFCr 2  A9 58                        lda #$58
004CFEr 2  4C rr rr                     jmp asm_common
004D01r 2               z_asm_cli:
004D01r 2               
004D01r 2               xt_asm_clv:     ; clv \ CLV
004D01r 2  A9 B8                        lda #$B8
004D03r 2  4C rr rr                     jmp asm_common
004D06r 2               z_asm_clv:
004D06r 2               
004D06r 2               xt_asm_cmp:     ; cmp \ CMP nnnn
004D06r 2  A9 CD                        lda #$CD
004D08r 2  4C rr rr                     jmp asm_common
004D0Br 2               z_asm_cmp:
004D0Br 2               
004D0Br 2               xt_asm_cmp_h:   ; cmp.# \ CMP #nn
004D0Br 2  A9 C9                        lda #$C9
004D0Dr 2  4C rr rr                     jmp asm_common
004D10r 2               z_asm_cmp_h:
004D10r 2               
004D10r 2               xt_asm_cmp_x:   ; cmp.x \ CMP nnnn,X
004D10r 2  A9 DD                        lda #$DD
004D12r 2  4C rr rr                     jmp asm_common
004D15r 2               z_asm_cmp_x:
004D15r 2               
004D15r 2               xt_asm_cmp_y:   ; cmp.y \ CMP nnnn,Y
004D15r 2  A9 D9                        lda #$D9
004D17r 2  4C rr rr                     jmp asm_common
004D1Ar 2               z_asm_cmp_y:
004D1Ar 2               
004D1Ar 2               xt_asm_cmp_z:   ; cmp.z \ CMP nn
004D1Ar 2  A9 C5                        lda #$C5
004D1Cr 2  4C rr rr                     jmp asm_common
004D1Fr 2               z_asm_cmp_z:
004D1Fr 2               
004D1Fr 2               xt_asm_cmp_zi:  ; cmp.zi \ CMP (nn)
004D1Fr 2  A9 D2                        lda #$D2
004D21r 2  4C rr rr                     jmp asm_common
004D24r 2               z_asm_cmp_zi:
004D24r 2               
004D24r 2               xt_asm_cmp_ziy: ; cmp.ziy \ CMP (nn),Y
004D24r 2  A9 D1                        lda #$D1
004D26r 2  4C rr rr                     jmp asm_common
004D29r 2               z_asm_cmp_ziy:
004D29r 2               
004D29r 2               xt_asm_cmp_zx:  ; cmp.zx \ CMP nn,X
004D29r 2  A9 D5                        lda #$D5
004D2Br 2  4C rr rr                     jmp asm_common
004D2Er 2               z_asm_cmp_zx:
004D2Er 2               
004D2Er 2               xt_asm_cmp_zxi: ; cmp.zxi \ CMP (nn,X)
004D2Er 2  A9 C1                        lda #$C1
004D30r 2  4C rr rr                     jmp asm_common
004D33r 2               z_asm_cmp_zxi:
004D33r 2               
004D33r 2               xt_asm_cpx:     ; cpx \ CPX nnnn
004D33r 2  A9 EC                        lda #$EC
004D35r 2  4C rr rr                     jmp asm_common
004D38r 2               z_asm_cpx:
004D38r 2               
004D38r 2               xt_asm_cpx_h:   ; cpx.# \ CPX #nn
004D38r 2  A9 E0                        lda #$E0
004D3Ar 2  4C rr rr                     jmp asm_common
004D3Dr 2               z_asm_cpx_h:
004D3Dr 2               
004D3Dr 2               xt_asm_cpx_z:   ; cpx.z \ CPX nn
004D3Dr 2  A9 E4                        lda #$E4
004D3Fr 2  4C rr rr                     jmp asm_common
004D42r 2               z_asm_cpx_z:
004D42r 2               
004D42r 2               xt_asm_cpy:     ; cpy \ CPY
004D42r 2  A9 CC                        lda #$CC
004D44r 2  A0 03                        ldy #3
004D46r 2  4C rr rr                     jmp asm_common
004D49r 2               z_asm_cpy:
004D49r 2               
004D49r 2               xt_asm_cpy_h:   ; cpy.# \ CPY #nn
004D49r 2  A9 C0                        lda #$C0
004D4Br 2  4C rr rr                     jmp asm_common
004D4Er 2               z_asm_cpy_h:
004D4Er 2               
004D4Er 2               xt_asm_cpy_z:   ; cpy.z \ CPY nn
004D4Er 2  A9 C4                        lda #$C4
004D50r 2  4C rr rr                     jmp asm_common
004D53r 2               z_asm_cpy_z:
004D53r 2               
004D53r 2               xt_asm_dec:     ; dec \ DEC nnnn
004D53r 2  A9 CE                        lda #$CE
004D55r 2  4C rr rr                     jmp asm_common
004D58r 2               z_asm_dec:
004D58r 2               
004D58r 2               xt_asm_dec_a:   ; dec.a \ DEC
004D58r 2  A9 3A                        lda #$3A
004D5Ar 2  4C rr rr                     jmp asm_common
004D5Dr 2               z_asm_dec_a:
004D5Dr 2               
004D5Dr 2               xt_asm_dec_x:   ; dec.x \ DEC nnnn,X
004D5Dr 2  A9 DE                        lda #$DE
004D5Fr 2  4C rr rr                     jmp asm_common
004D62r 2               z_asm_dec_x:
004D62r 2               
004D62r 2               xt_asm_dec_z:   ; dec.z \ DEC nn
004D62r 2  A9 C6                        lda #$C6
004D64r 2  4C rr rr                     jmp asm_common
004D67r 2               z_asm_dec_z:
004D67r 2               
004D67r 2               xt_asm_dec_zx:  ; dec.zx \ DEC nn,X
004D67r 2  A9 D6                        lda #$D6
004D69r 2  4C rr rr                     jmp asm_common
004D6Cr 2               z_asm_dec_zx:
004D6Cr 2               
004D6Cr 2               xt_asm_dex:     ; dex \ DEX
004D6Cr 2  A9 CA                        lda #$CA
004D6Er 2  4C rr rr                     jmp asm_common
004D71r 2               z_asm_dex:
004D71r 2               
004D71r 2               xt_asm_dey:     ; dey \ DEY
004D71r 2  A9 88                        lda #$88
004D73r 2  4C rr rr                     jmp asm_common
004D76r 2               z_asm_dey:
004D76r 2               
004D76r 2               xt_asm_eor:     ; eor \ EOR nnnn
004D76r 2  A9 4D                        lda #$4D
004D78r 2  4C rr rr                     jmp asm_common
004D7Br 2               z_asm_eor:
004D7Br 2               
004D7Br 2               xt_asm_eor_h:   ; eor.# \ EOR #nn
004D7Br 2  A9 49                        lda #$49
004D7Dr 2  4C rr rr                     jmp asm_common
004D80r 2               z_asm_eor_h:
004D80r 2               
004D80r 2               xt_asm_eor_x:   ; eor.x \ EOR nnnn,X
004D80r 2  A9 5D                        lda #$5D
004D82r 2  4C rr rr                     jmp asm_common
004D85r 2               z_asm_eor_x:
004D85r 2               
004D85r 2               xt_asm_eor_y:   ; eor.y \ EOR nnnn,Y
004D85r 2  A9 59                        lda #$59
004D87r 2  4C rr rr                     jmp asm_common
004D8Ar 2               z_asm_eor_y:
004D8Ar 2               
004D8Ar 2               xt_asm_eor_z:   ; eor.z \ EOR nn
004D8Ar 2  A9 45                        lda #$45
004D8Cr 2  4C rr rr                     jmp asm_common
004D8Fr 2               z_asm_eor_z:
004D8Fr 2               
004D8Fr 2               xt_asm_eor_zi:  ; eor.zi \ EOR (nn)
004D8Fr 2  A9 52                        lda #$52
004D91r 2  4C rr rr                     jmp asm_common
004D94r 2               z_asm_eor_zi:
004D94r 2               
004D94r 2               xt_asm_eor_ziy: ; eor.ziy \ EOR (nn),Y
004D94r 2  A9 51                        lda #$51
004D96r 2  4C rr rr                     jmp asm_common
004D99r 2               z_asm_eor_ziy:
004D99r 2               
004D99r 2               xt_asm_eor_zx:  ; eor.zx \ EOR nn,X
004D99r 2  A9 55                        lda #$55
004D9Br 2  4C rr rr                     jmp asm_common
004D9Er 2               z_asm_eor_zx:
004D9Er 2               
004D9Er 2               xt_asm_eor_zxi: ; eor.zxi \ EOR (nn,X)
004D9Er 2  A9 41                        lda #$41
004DA0r 2  4C rr rr                     jmp asm_common
004DA3r 2               z_asm_eor_zxi:
004DA3r 2               
004DA3r 2               xt_asm_inc:     ; inc \ INC nnnn
004DA3r 2  A9 EE                        lda #$EE
004DA5r 2  4C rr rr                     jmp asm_common
004DA8r 2               z_asm_inc:
004DA8r 2               
004DA8r 2               xt_asm_inc_a:   ; inc.a \ INC
004DA8r 2  A9 1A                        lda #$1A
004DAAr 2  4C rr rr                     jmp asm_common
004DADr 2               z_asm_inc_a:
004DADr 2               
004DADr 2               xt_asm_inc_x:   ; inc.x \ INC nnnn,X
004DADr 2  A9 FE                        lda #$FE
004DAFr 2  4C rr rr                     jmp asm_common
004DB2r 2               z_asm_inc_x:
004DB2r 2               
004DB2r 2               xt_asm_inc_z:   ; inc.z \ INC nn
004DB2r 2  A9 E6                        lda #$E6
004DB4r 2  4C rr rr                     jmp asm_common
004DB7r 2               z_asm_inc_z:
004DB7r 2               
004DB7r 2               xt_asm_inc_zx:  ; inc.zx \ INC nn,X
004DB7r 2  A9 F6                        lda #$F6
004DB9r 2  4C rr rr                     jmp asm_common
004DBCr 2               z_asm_inc_zx:
004DBCr 2               
004DBCr 2               xt_asm_inx:     ; inx \ INX
004DBCr 2  A9 E8                        lda #$E8
004DBEr 2  4C rr rr                     jmp asm_common
004DC1r 2               z_asm_inx:
004DC1r 2               
004DC1r 2               xt_asm_iny:     ; iny \ INY
004DC1r 2  A9 C8                        lda #$C8
004DC3r 2  4C rr rr                     jmp asm_common
004DC6r 2               z_asm_iny:
004DC6r 2               
004DC6r 2               xt_asm_jmp:     ; jmp \ JMP nnnn
004DC6r 2  A9 4C                        lda #$4C
004DC8r 2  4C rr rr                     jmp asm_common
004DCBr 2               z_asm_jmp:
004DCBr 2               
004DCBr 2               xt_asm_jmp_i:   ; jmp.i \ JMP (nnnn)
004DCBr 2  A9 6C                        lda #$6C
004DCDr 2  4C rr rr                     jmp asm_common
004DD0r 2               z_asm_jmp_i:
004DD0r 2               
004DD0r 2               xt_asm_jmp_xi:  ; jmp.xi \ JMP (nnnn,X)
004DD0r 2  A9 7C                        lda #$7C
004DD2r 2  4C rr rr                     jmp asm_common
004DD5r 2               z_asm_jmp_xi:
004DD5r 2               
004DD5r 2               xt_asm_jsr:     ; jsr \ JSR nnnn
004DD5r 2  A9 20                        lda #$20
004DD7r 2  4C rr rr                     jmp asm_common
004DDAr 2               z_asm_jsr:
004DDAr 2               
004DDAr 2               xt_asm_lda:     ; lda \ LDA nnnn
004DDAr 2  A9 AD                        lda #$AD
004DDCr 2  4C rr rr                     jmp asm_common
004DDFr 2               z_asm_lda:
004DDFr 2               
004DDFr 2               xt_asm_lda_h:   ; lda.# \ LDA #nn
004DDFr 2  A9 A9                        lda #$A9
004DE1r 2  4C rr rr                     jmp asm_common
004DE4r 2               z_asm_lda_h:
004DE4r 2               
004DE4r 2               xt_asm_lda_x:   ; lda.x \ LDA nnnn,X
004DE4r 2  A9 BD                        lda #$BD
004DE6r 2  4C rr rr                     jmp asm_common
004DE9r 2               z_asm_lda_x:
004DE9r 2               
004DE9r 2               xt_asm_lda_y:   ; lda.y \ LDA nnnn,Y
004DE9r 2  A9 B9                        lda #$B9
004DEBr 2  4C rr rr                     jmp asm_common
004DEEr 2               z_asm_lda_y:
004DEEr 2               
004DEEr 2               xt_asm_lda_z:   ; lda.z \ LDA nn
004DEEr 2  A9 A5                        lda #$A5
004DF0r 2  4C rr rr                     jmp asm_common
004DF3r 2               z_asm_lda_z:
004DF3r 2               
004DF3r 2               xt_asm_lda_zi:  ; lda.zi \ LDA (nn)
004DF3r 2  A9 B2                        lda #$B2
004DF5r 2  4C rr rr                     jmp asm_common
004DF8r 2               z_asm_lda_zi:
004DF8r 2               
004DF8r 2               xt_asm_lda_ziy: ; lda.ziy \ LDA (nn),Y
004DF8r 2  A9 B1                        lda #$B1
004DFAr 2  4C rr rr                     jmp asm_common
004DFDr 2               z_asm_lda_ziy:
004DFDr 2               
004DFDr 2               xt_asm_lda_zx:  ; lda.zx \ LDA nn,X
004DFDr 2  A9 B5                        lda #$B5
004DFFr 2  4C rr rr                     jmp asm_common
004E02r 2               z_asm_lda_zx:
004E02r 2               
004E02r 2               xt_asm_lda_zxi: ; lda.zxi \ LDA (nn,X)
004E02r 2  A9 A1                        lda #$A1
004E04r 2  4C rr rr                     jmp asm_common
004E07r 2               z_asm_lda_zxi:
004E07r 2               
004E07r 2               xt_asm_ldx:     ; ldx \ LDX nnnn
004E07r 2  A9 AE                        lda #$AE
004E09r 2  4C rr rr                     jmp asm_common
004E0Cr 2               z_asm_ldx:
004E0Cr 2               
004E0Cr 2               xt_asm_ldx_h:   ; ldx.# \ LDX #nn
004E0Cr 2  A9 A2                        lda #$A2
004E0Er 2  4C rr rr                     jmp asm_common
004E11r 2               z_asm_ldx_h:
004E11r 2               
004E11r 2               xt_asm_ldx_y:   ; ldx.y \ LDX nnnn,Y
004E11r 2  A9 BE                        lda #$BE
004E13r 2  4C rr rr                     jmp asm_common
004E16r 2               z_asm_ldx_y:
004E16r 2               
004E16r 2               xt_asm_ldx_z:   ; ldx.z \ LDX nn
004E16r 2  A9 A6                        lda #$A6
004E18r 2  4C rr rr                     jmp asm_common
004E1Br 2               z_asm_ldx_z:
004E1Br 2               
004E1Br 2               xt_asm_ldx_zy:  ; ldx.zy \ LDX nn,Y
004E1Br 2  A9 B6                        lda #$B6
004E1Dr 2  4C rr rr                     jmp asm_common
004E20r 2               z_asm_ldx_zy:
004E20r 2               
004E20r 2               xt_asm_ldy:     ; ldy \ LDY nnnn
004E20r 2  A9 AC                        lda #$AC
004E22r 2  4C rr rr                     jmp asm_common
004E25r 2               z_asm_ldy:
004E25r 2               
004E25r 2               xt_asm_ldy_h:   ; ldy.# \ LDY #nn
004E25r 2  A9 A0                        lda #$A0
004E27r 2  4C rr rr                     jmp asm_common
004E2Ar 2               z_asm_ldy_h:
004E2Ar 2               
004E2Ar 2               xt_asm_ldy_x:   ; ldy.x \ LDY nnnn,X
004E2Ar 2  A9 BC                        lda #$BC
004E2Cr 2  4C rr rr                     jmp asm_common
004E2Fr 2               z_asm_ldy_x:
004E2Fr 2               
004E2Fr 2               xt_asm_ldy_z:   ; ldy.z \ LDY nn
004E2Fr 2  A9 A4                        lda #$A4
004E31r 2  4C rr rr                     jmp asm_common
004E34r 2               z_asm_ldy_z:
004E34r 2               
004E34r 2               xt_asm_ldy_zx:  ; ldy.zx \ LDY nn,X
004E34r 2  A9 B4                        lda #$B4
004E36r 2  4C rr rr                     jmp asm_common
004E39r 2               z_asm_ldy_zx:
004E39r 2               
004E39r 2               xt_asm_lsr:     ; lsr \ LSR nnnn
004E39r 2  A9 4E                        lda #$4E
004E3Br 2  4C rr rr                     jmp asm_common
004E3Er 2               z_asm_lsr:
004E3Er 2               
004E3Er 2               xt_asm_lsr_a:   ; lsr.a \ LSR
004E3Er 2  A9 4A                        lda #$4A
004E40r 2  4C rr rr                     jmp asm_common
004E43r 2               z_asm_lsr_a:
004E43r 2               
004E43r 2               xt_asm_lsr_x:   ; lsr.x \ LSR nnnn,X
004E43r 2  A9 5E                        lda #$5E
004E45r 2  4C rr rr                     jmp asm_common
004E48r 2               z_asm_lsr_x:
004E48r 2               
004E48r 2               xt_asm_lsr_z:   ; lsr.z \ LSR nn
004E48r 2  A9 46                        lda #$46
004E4Ar 2  4C rr rr                     jmp asm_common
004E4Dr 2               z_asm_lsr_z:
004E4Dr 2               
004E4Dr 2               xt_asm_lsr_zx:  ; lsr.zx \ LSR nn,X
004E4Dr 2  A9 56                        lda #$56
004E4Fr 2  4C rr rr                     jmp asm_common
004E52r 2               z_asm_lsr_zx:
004E52r 2               
004E52r 2               xt_asm_nop:     ; nop \ NOP
004E52r 2  A9 EA                        lda #$EA
004E54r 2  4C rr rr                     jmp asm_common
004E57r 2               z_asm_nop:
004E57r 2               
004E57r 2               xt_asm_ora:     ; ora \ ORA nnnn
004E57r 2  A9 0D                        lda #$0D
004E59r 2  4C rr rr                     jmp asm_common
004E5Cr 2               z_asm_ora:
004E5Cr 2               
004E5Cr 2               xt_asm_ora_h:   ; ora.# \ ORA #nn
004E5Cr 2  A9 09                        lda #$09
004E5Er 2  4C rr rr                     jmp asm_common
004E61r 2               z_asm_ora_h:
004E61r 2               
004E61r 2               xt_asm_ora_x:   ; ora.x \ ORA nnnn,X
004E61r 2  A9 1D                        lda #$1D
004E63r 2  4C rr rr                     jmp asm_common
004E66r 2               z_asm_ora_x:
004E66r 2               
004E66r 2               xt_asm_ora_y:   ; ora.y \ ORA nnnn,Y
004E66r 2  A9 19                        lda #$19
004E68r 2  4C rr rr                     jmp asm_common
004E6Br 2               z_asm_ora_y:
004E6Br 2               
004E6Br 2               xt_asm_ora_z:   ; ora.z \ ORA nn
004E6Br 2  A9 05                        lda #$05
004E6Dr 2  4C rr rr                     jmp asm_common
004E70r 2               z_asm_ora_z:
004E70r 2               
004E70r 2               xt_asm_ora_zi:  ; ora.zi \ ORA.ZI
004E70r 2  A9 12                        lda #$12
004E72r 2  A0 02                        ldy #2
004E74r 2  4C rr rr                     jmp asm_common
004E77r 2               z_asm_ora_zi:
004E77r 2               
004E77r 2               xt_asm_ora_ziy: ; ora.ziy \ ORA (nn),Y
004E77r 2  A9 11                        lda #$11
004E79r 2  4C rr rr                     jmp asm_common
004E7Cr 2               z_asm_ora_ziy:
004E7Cr 2               
004E7Cr 2               xt_asm_ora_zx:  ; ora.zx \ ORA nn,X
004E7Cr 2  A9 15                        lda #$15
004E7Er 2  4C rr rr                     jmp asm_common
004E81r 2               z_asm_ora_zx:
004E81r 2               
004E81r 2               xt_asm_ora_zxi: ; ora.zxi \ ORA (nn,X)
004E81r 2  A9 01                        lda #$01
004E83r 2  4C rr rr                     jmp asm_common
004E86r 2               z_asm_ora_zxi:
004E86r 2               
004E86r 2               xt_asm_pha:     ; pha \ PHA
004E86r 2  A9 48                        lda #$48
004E88r 2  4C rr rr                     jmp asm_common
004E8Br 2               z_asm_pha:
004E8Br 2               
004E8Br 2               xt_asm_php:     ; php \ PHP
004E8Br 2  A9 08                        lda #$08
004E8Dr 2  4C rr rr                     jmp asm_common
004E90r 2               z_asm_php:
004E90r 2               
004E90r 2               xt_asm_phx:     ; phx \ PHX
004E90r 2  A9 DA                        lda #$DA
004E92r 2  4C rr rr                     jmp asm_common
004E95r 2               z_asm_phx:
004E95r 2               
004E95r 2               xt_asm_phy:     ; phy \ PHY
004E95r 2  A9 5A                        lda #$5A
004E97r 2  4C rr rr                     jmp asm_common
004E9Ar 2               z_asm_phy:
004E9Ar 2               
004E9Ar 2               xt_asm_pla:     ; pla \ PLA
004E9Ar 2  A9 68                        lda #$68
004E9Cr 2  4C rr rr                     jmp asm_common
004E9Fr 2               z_asm_pla:
004E9Fr 2               
004E9Fr 2               xt_asm_plp:     ; plp \ PLP
004E9Fr 2  A9 28                        lda #$28
004EA1r 2  4C rr rr                     jmp asm_common
004EA4r 2               z_asm_plp:
004EA4r 2               
004EA4r 2               xt_asm_plx:     ; plx \ PLX
004EA4r 2  A9 FA                        lda #$FA
004EA6r 2  4C rr rr                     jmp asm_common
004EA9r 2               z_asm_plx:
004EA9r 2               
004EA9r 2               xt_asm_ply:     ; ply \ PLY
004EA9r 2  A9 7A                        lda #$7A
004EABr 2  4C rr rr                     jmp asm_common
004EAEr 2               z_asm_ply:
004EAEr 2               
004EAEr 2               xt_asm_rol:     ; rol \ ROL nnnn
004EAEr 2  A9 2E                        lda #$2E
004EB0r 2  4C rr rr                     jmp asm_common
004EB3r 2               z_asm_rol:
004EB3r 2               
004EB3r 2               xt_asm_rol_a:   ; rol.a \ ROL
004EB3r 2  A9 2A                        lda #$2A
004EB5r 2  4C rr rr                     jmp asm_common
004EB8r 2               z_asm_rol_a:
004EB8r 2               
004EB8r 2               xt_asm_rol_x:   ; rol.x \ ROL nnnn,X
004EB8r 2  A9 3E                        lda #$3E
004EBAr 2  4C rr rr                     jmp asm_common
004EBDr 2               z_asm_rol_x:
004EBDr 2               
004EBDr 2               xt_asm_rol_z:   ; rol.z \ ROL nn
004EBDr 2  A9 26                        lda #$26
004EBFr 2  4C rr rr                     jmp asm_common
004EC2r 2               z_asm_rol_z:
004EC2r 2               
004EC2r 2               xt_asm_rol_zx:  ; rol.zx \ ROL nn,X
004EC2r 2  A9 36                        lda #$36
004EC4r 2  4C rr rr                     jmp asm_common
004EC7r 2               z_asm_rol_zx:
004EC7r 2               
004EC7r 2               xt_asm_ror:     ; ror \ ROR nnnn
004EC7r 2  A9 6E                        lda #$6E
004EC9r 2  4C rr rr                     jmp asm_common
004ECCr 2               z_asm_ror:
004ECCr 2               
004ECCr 2               xt_asm_ror_a:   ; ror.a \ ROR
004ECCr 2  A9 6A                        lda #$6A
004ECEr 2  4C rr rr                     jmp asm_common
004ED1r 2               z_asm_ror_a:
004ED1r 2               
004ED1r 2               xt_asm_ror_x:   ; ror.x \ ROR nnnn,X
004ED1r 2  A9 7E                        lda #$7E
004ED3r 2  4C rr rr                     jmp asm_common
004ED6r 2               z_asm_ror_x:
004ED6r 2               
004ED6r 2               xt_asm_ror_z:   ; ror.z \ ROR nn
004ED6r 2  A9 66                        lda #$66
004ED8r 2  4C rr rr                     jmp asm_common
004EDBr 2               z_asm_ror_z:
004EDBr 2               
004EDBr 2               xt_asm_ror_zx:  ; ror.zx \ ROR nn,X
004EDBr 2  A9 76                        lda #$76
004EDDr 2  4C rr rr                     jmp asm_common
004EE0r 2               z_asm_ror_zx:
004EE0r 2               
004EE0r 2               xt_asm_rti:     ; rti \ RTI
004EE0r 2  A9 40                        lda #$40
004EE2r 2  4C rr rr                     jmp asm_common
004EE5r 2               z_asm_rti:
004EE5r 2               
004EE5r 2               xt_asm_rts:     ; rts \ RTS
004EE5r 2  A9 60                        lda #$60
004EE7r 2  4C rr rr                     jmp asm_common
004EEAr 2               z_asm_rts:
004EEAr 2               
004EEAr 2               xt_asm_sbc:     ; sbc \ SBC nnnn
004EEAr 2  A9 ED                        lda #$ED
004EECr 2  4C rr rr                     jmp asm_common
004EEFr 2               z_asm_sbc:
004EEFr 2               
004EEFr 2               xt_asm_sbc_h:   ; sbc.# \ SBC #nn
004EEFr 2  A9 E9                        lda #$E9
004EF1r 2  4C rr rr                     jmp asm_common
004EF4r 2               z_asm_sbc_h:
004EF4r 2               
004EF4r 2               xt_asm_sbc_x:   ; sbc.x \ SBC nnnn,X
004EF4r 2  A9 FD                        lda #$FD
004EF6r 2  4C rr rr                     jmp asm_common
004EF9r 2               z_asm_sbc_x:
004EF9r 2               
004EF9r 2               xt_asm_sbc_y:   ; sbc.y \ SBC nnnn,Y
004EF9r 2  A9 F9                        lda #$F9
004EFBr 2  4C rr rr                     jmp asm_common
004EFEr 2               z_asm_sbc_y:
004EFEr 2               
004EFEr 2               xt_asm_sbc_z:   ; sbc.z \ SBC nn
004EFEr 2  A9 E5                        lda #$E5
004F00r 2  4C rr rr                     jmp asm_common
004F03r 2               z_asm_sbc_z:
004F03r 2               
004F03r 2               xt_asm_sbc_zi:  ; sbc.zi \ SBC (nn)
004F03r 2  A9 F2                        lda #$F2
004F05r 2  4C rr rr                     jmp asm_common
004F08r 2               z_asm_sbc_zi:
004F08r 2               
004F08r 2               xt_asm_sbc_ziy: ; sbc.ziy \ SBC (nn),Y
004F08r 2  A9 F1                        lda #$F1
004F0Ar 2  4C rr rr                     jmp asm_common
004F0Dr 2               z_asm_sbc_ziy:
004F0Dr 2               
004F0Dr 2               xt_asm_sbc_zx:  ; sbc.zx \ SBC nn,X
004F0Dr 2  A9 F5                        lda #$F5
004F0Fr 2  4C rr rr                     jmp asm_common
004F12r 2               z_asm_sbc_zx:
004F12r 2               
004F12r 2               xt_asm_sbc_zxi: ; sbc.zxi \ SBC (nn,X)
004F12r 2  A9 E1                        lda #$E1
004F14r 2  80 7C                        bra asm_common  ; <-- limit for BRA instead of JMP
004F16r 2               z_asm_sbc_zxi:
004F16r 2               
004F16r 2               xt_asm_sec:     ; sec \ SEC
004F16r 2  A9 38                        lda #$38
004F18r 2  80 78                        bra asm_common
004F1Ar 2               z_asm_sec:
004F1Ar 2               
004F1Ar 2               xt_asm_sed:     ; sed \ SED
004F1Ar 2  A9 F8                        lda #$F8
004F1Cr 2  80 74                        bra asm_common
004F1Er 2               z_asm_sed:
004F1Er 2               
004F1Er 2               xt_asm_sei:     ; sei \ SEI
004F1Er 2  A9 78                        lda #$78
004F20r 2  80 70                        bra asm_common
004F22r 2               z_asm_sei:
004F22r 2               
004F22r 2               xt_asm_sta:     ; sta \ STA nnnn
004F22r 2  A9 8D                        lda #$8D
004F24r 2  80 6C                        bra asm_common
004F26r 2               z_asm_sta:
004F26r 2               
004F26r 2               xt_asm_sta_x:   ; sta.x \ STA nnnn,X
004F26r 2  A9 9D                        lda #$9D
004F28r 2  80 68                        bra asm_common
004F2Ar 2               z_asm_sta_x:
004F2Ar 2               
004F2Ar 2               xt_asm_sta_y:   ; sta.y \ STA nnnn,Y
004F2Ar 2  A9 99                        lda #$99
004F2Cr 2  80 64                        bra asm_common
004F2Er 2               z_asm_sta_y:
004F2Er 2               
004F2Er 2               xt_asm_sta_z:   ; sta.z \ STA nn
004F2Er 2  A9 85                        lda #$85
004F30r 2  80 60                        bra asm_common
004F32r 2               z_asm_sta_z:
004F32r 2               
004F32r 2               xt_asm_sta_zi:  ; sta.zi \ STA (nn)
004F32r 2  A9 92                        lda #$92
004F34r 2  80 5C                        bra asm_common
004F36r 2               z_asm_sta_zi:
004F36r 2               
004F36r 2               xt_asm_sta_ziy: ; sta.ziy \ STA (nn),Y
004F36r 2  A9 91                        lda #$91
004F38r 2  80 58                        bra asm_common
004F3Ar 2               z_asm_sta_ziy:
004F3Ar 2               
004F3Ar 2               xt_asm_sta_zx:  ; sta.zx \ STA nn,X
004F3Ar 2  A9 95                        lda #$95
004F3Cr 2  80 54                        bra asm_common
004F3Er 2               z_asm_sta_zx:
004F3Er 2               
004F3Er 2               xt_asm_sta_zxi: ; sta.zxi \ STA (nn,X)
004F3Er 2  A9 81                        lda #$81
004F40r 2  80 50                        bra asm_common
004F42r 2               z_asm_sta_zxi:
004F42r 2               
004F42r 2               xt_asm_stx:     ; stx \ STX nnnn
004F42r 2  A9 8E                        lda #$8E
004F44r 2  80 4C                        bra asm_common
004F46r 2               z_asm_stx:
004F46r 2               
004F46r 2               xt_asm_stx_z:   ; stx.z \ STX nn
004F46r 2  A9 86                        lda #$86
004F48r 2  80 48                        bra asm_common
004F4Ar 2               z_asm_stx_z:
004F4Ar 2               
004F4Ar 2               xt_asm_stx_zy:  ; stx.zy \ STX nn,Y
004F4Ar 2  A9 96                        lda #$96
004F4Cr 2  80 44                        bra asm_common
004F4Er 2               z_asm_stx_zy:
004F4Er 2               
004F4Er 2               xt_asm_sty:     ; sty \ STY nnnn
004F4Er 2  A9 8C                        lda #$8C
004F50r 2  80 40                        bra asm_common
004F52r 2               z_asm_sty:
004F52r 2               
004F52r 2               xt_asm_sty_z:   ; sty.z \ STY nn
004F52r 2  A9 84                        lda #$84
004F54r 2  80 3C                        bra asm_common
004F56r 2               z_asm_sty_z:
004F56r 2               
004F56r 2               xt_asm_sty_zx:  ; sty.zx \ STY nn,X
004F56r 2  A9 94                        lda #$94
004F58r 2  80 38                        bra asm_common
004F5Ar 2               z_asm_sty_zx:
004F5Ar 2               
004F5Ar 2               xt_asm_stz:     ; stz \ STZ nnnn
004F5Ar 2  A9 9C                        lda #$9C
004F5Cr 2  80 34                        bra asm_common
004F5Er 2               z_asm_stz:
004F5Er 2               
004F5Er 2               xt_asm_stz_x:   ; stz.x \ STZ nnnn,X
004F5Er 2  A9 9E                        lda #$9E
004F60r 2  80 30                        bra asm_common
004F62r 2               z_asm_stz_x:
004F62r 2               
004F62r 2               xt_asm_stz_z:   ; stz.z \ STZ nn
004F62r 2  A9 64                        lda #$64
004F64r 2  80 2C                        bra asm_common
004F66r 2               z_asm_stz_z:
004F66r 2               
004F66r 2               xt_asm_stz_zx:  ; stz.zx \ STZ nn,X
004F66r 2  A9 74                        lda #$74
004F68r 2  80 28                        bra asm_common
004F6Ar 2               z_asm_stz_zx:
004F6Ar 2               
004F6Ar 2               xt_asm_tax:     ; tax \ TAX
004F6Ar 2  A9 AA                        lda #$AA
004F6Cr 2  80 24                        bra asm_common
004F6Er 2               z_asm_tax:
004F6Er 2               
004F6Er 2               xt_asm_tay:     ; tay \ TAY
004F6Er 2  A9 A8                        lda #$A8
004F70r 2  80 20                        bra asm_common
004F72r 2               z_asm_tay:
004F72r 2               
004F72r 2               xt_asm_trb:     ; trb \ TRB nnnn
004F72r 2  A9 1C                        lda #$1C
004F74r 2  80 1C                        bra asm_common
004F76r 2               z_asm_trb:
004F76r 2               
004F76r 2               xt_asm_trb_z:   ; trb.z \ TRB nn
004F76r 2  A9 14                        lda #$14
004F78r 2  80 18                        bra asm_common
004F7Ar 2               z_asm_trb_z:
004F7Ar 2               
004F7Ar 2               xt_asm_tsb:     ; tsb \ TSB nnnn
004F7Ar 2  A9 0C                        lda #$0C
004F7Cr 2  80 14                        bra asm_common
004F7Er 2               z_asm_tsb:
004F7Er 2               
004F7Er 2               xt_asm_tsb_z:   ; tsb.z \ TSB nn
004F7Er 2  A9 04                        lda #$04
004F80r 2  80 10                        bra asm_common
004F82r 2               z_asm_tsb_z:
004F82r 2               
004F82r 2               xt_asm_tsx:     ; tsx \ TSX
004F82r 2  A9 BA                        lda #$BA
004F84r 2  80 0C                        bra asm_common
004F86r 2               z_asm_tsx:
004F86r 2               
004F86r 2               xt_asm_txa:     ; txa \ TXA
004F86r 2  A9 8A                        lda #$8A
004F88r 2  80 08                        bra asm_common
004F8Ar 2               z_asm_txa:
004F8Ar 2               
004F8Ar 2               xt_asm_txs:     ; txs \ TXS
004F8Ar 2  A9 9A                        lda #$9A
004F8Cr 2  80 04                        bra asm_common
004F8Er 2               z_asm_txs:
004F8Er 2               
004F8Er 2               xt_asm_tya:     ; tya \ TYA
004F8Er 2  A9 98                        lda #$98
004F90r 2  80 00                        bra asm_common
004F92r 2               z_asm_tya:
004F92r 2               
004F92r 2               
004F92r 2               ; ==========================================================
004F92r 2               ; ASSEMBLER HELPER FUNCTIONS
004F92r 2               
004F92r 2               asm_common:
004F92r 2               
004F92r 2                       ; """Common routine for all opcodes. We arrive here with the opcode in
004F92r 2                       ; A. We do not need to check for the correct values because we are
004F92r 2                       ; coming from the assembler Dictionary and trust our external test
004F92r 2                       ; suite.
004F92r 2                       ; """
004F92r 2                               ; Compile opcode. Note cmpl_a does not use Y
004F92r 2  A8                           tay
004F93r 2  20 rr rr                     jsr cmpl_a
004F96r 2               
004F96r 2                               ; We get the length of the opcode from the table included in
004F96r 2                               ; the disassembler. We use the opcode value as the offset in
004F96r 2                               ; the oc_index_table. We have 256 entries, each two bytes
004F96r 2                               ; long, so we can't just use an index with Y. We use tmp2 for
004F96r 2                               ; this.
004F96r 2  A9 rr                        lda #<oc_index_table
004F98r 2  85 rr                        sta tmp2
004F9Ar 2  A9 rr                        lda #>oc_index_table
004F9Cr 2  85 rr                        sta tmp2+1
004F9Er 2               
004F9Er 2  98                           tya             ; retrieve opcode
004F9Fr 2  0A                           asl             ; times two for offset
004FA0r 2  90 02                        bcc @m
004FA2r 2  E6 rr                        inc tmp2+1
004FA4r 2               @m:
004FA4r 2  A8                           tay             ; use Y as the index
004FA5r 2               
004FA5r 2                               ; Get address of the entry in the opcode table. We put it in
004FA5r 2                               ; tmp3 and push a copy of it to the stack to be able to print
004FA5r 2                               ; the opcode later
004FA5r 2  B1 rr                        lda (tmp2),y    ; LSB
004FA7r 2  85 rr                        sta tmp3
004FA9r 2  C8                           iny
004FAAr 2  B1 rr                        lda (tmp2),y    ; MSB
004FACr 2  85 rr                        sta tmp3+1
004FAEr 2               
004FAEr 2  B2 rr                        lda (tmp3)      ; get "lengths byte"
004FB0r 2               
004FB0r 2                               ; The length of the instruction is stored in bits 7 and 6.
004FB0r 2                               ; Rotate them through the carry flag and mask the rest
004FB0r 2  2A                           rol
004FB1r 2  2A                           rol
004FB2r 2  2A                           rol             ; Three times because we go through Carry
004FB3r 2  29 03                        and #%00000011
004FB5r 2  A8                           tay
004FB6r 2               
004FB6r 2                               ; One byte means no operand, we're done. Use DEY as CPY #1
004FB6r 2  88                           dey
004FB7r 2  F0 12                        beq @done
004FB9r 2               
004FB9r 2                               ; We have an operand which must be TOS
004FB9r 2  20 rr rr                     jsr underflow_1
004FBCr 2               
004FBCr 2                               ; We compile the LSB of TOS as the operand we definitely have
004FBCr 2                               ; before we even test if this is a two- or three-byte
004FBCr 2                               ; instruction. Little endian CPU means we store this byte first
004FBCr 2  B5 00                        lda 0,x
004FBEr 2  20 rr rr                     jsr cmpl_a      ; does not use Y
004FC1r 2               
004FC1r 2                               ; If this is a two-byte instruction, we're done. If we landed
004FC1r 2                               ; here, we've already decremented Y by one, so this is
004FC1r 2                               ; the equivalent to CPY #2
004FC1r 2  88                           dey
004FC2r 2  F0 05                        beq @done_drop
004FC4r 2               
004FC4r 2                               ; This must be a three-byte instruction, get the MSB.
004FC4r 2  B5 01                        lda 1,x
004FC6r 2  20 rr rr                     jsr cmpl_a      ; Fall through to _done_drop
004FC9r 2               
004FC9r 2               @done_drop:
004FC9r 2  E8                           inx
004FCAr 2  E8                           inx             ; Fall through to _done
004FCBr 2               @done:
004FCBr 2  60                           rts             ; Returns to original caller
004FCCr 2               
004FCCr 2               
004FCCr 2               ; ==========================================================
004FCCr 2               ; PSEUDO-INSTRUCTIONS AND MACROS
004FCCr 2               
004FCCr 2               xt_asm_push_a:
004FCCr 2                       ; """push-a puts the content of the 65c02 Accumulator on the Forth
004FCCr 2                       ; data stack as the TOS. This is a convience routine that encodes the
004FCCr 2                       ; instructions  DEX  DEX  STA 0,X  STZ 1,X
004FCCr 2                       ; """
004FCCr 2  A0 00                        ldy #0
004FCEr 2               _loop:
004FCEr 2  B9 rr rr                     lda asm_push_a_data,y
004FD1r 2  C9 FF                        cmp #$FF
004FD3r 2  F0 06                        beq @done
004FD5r 2               
004FD5r 2  20 rr rr                     jsr cmpl_a      ; does not change Y
004FD8r 2  C8                           iny
004FD9r 2  80 F3                        bra _loop
004FDBr 2               @done:
004FDBr 2               z_asm_push_a:
004FDBr 2  60                           rts
004FDCr 2               asm_push_a_data:
004FDCr 2                       ; We can't use 00 as a terminator because STA 0,X assembles to 95 00
004FDCr 2  CA CA 95 00          .byte $CA, $CA, $95, 00, $74, $01
004FE0r 2  74 01        
004FE2r 2  FF                   .byte $FF               ; terminator
004FE3r 2               
004FE3r 2               
004FE3r 2               
004FE3r 2               ; ==========================================================
004FE3r 2               ; DIRECTIVES
004FE3r 2               
004FE3r 2               ; The "<J" directive (back jump) is a dummy instruction (syntactic sugar) to
004FE3r 2               ; make clear that the JMP or JSR instructions are using the address that had
004FE3r 2               ; been placed on the stack by "-->" (the "arrow" directive).
004FE3r 2               xt_asm_back_jump:
004FE3r 2               z_asm_back_jump:
004FE3r 2  60                           rts
004FE4r 2               
004FE4r 2               ; The "<B" directive (back branch) takes an address that was placed on the Data
004FE4r 2               ; Stack by the anonymous label directive "-->" (the "arrow") and the current
004FE4r 2               ; address (via HERE) to calculate a backward branch offset. This is then stored
004FE4r 2               ; by a following branch instruction.
004FE4r 2               xt_asm_back_branch:
004FE4r 2                               ; We arrive here with ( addr-l ) of the label on the stack and
004FE4r 2                               ; then subtract the current address
004FE4r 2  20 rr rr                     jsr xt_here             ; ( addr-l addr-h )
004FE7r 2  20 rr rr                     jsr xt_minus            ; ( offset )
004FEAr 2               
004FEAr 2                               ; We subtract two more because of the branch instruction itself
004FEAr 2  3A                           dea
004FEBr 2  3A                           dea
004FECr 2               
004FECr 2               z_asm_back_branch:
004FECr 2  60                           rts
004FEDr 2               .endif
004FEDr 2               assembler_end:
004FEDr 2               
004FEDr 2               ; END
004FEDr 2               
004FEDr 1               .include "../../disassembler.s"
004FEDr 2               ; Disassembler for Tali Forth 2
004FEDr 2               ; Scot W. Stevenson <scot.stevenson@gmail.com>
004FEDr 2               ; Updated by Sam Colwell
004FEDr 2               ; First version: 28. Apr 2018
004FEDr 2               ; This version: 31. Dec 2022
004FEDr 2               
004FEDr 2               ; This is the default disassembler for Tali Forth 2. Use by passing
004FEDr 2               ; the address and length of the block of memory to be disassembled:
004FEDr 2               ;
004FEDr 2               ;       disasm ( addr x -- )
004FEDr 2               
004FEDr 2               ; The underflow checking is handled by the word's stub in native_words.asm, see
004FEDr 2               ; there for more information.
004FEDr 2               
004FEDr 2               ; The code is disassembled in Simpler Assembler Notation (SAN), because that
004FEDr 2               ; is, uh, simpler. See the documentation and https://github.com/scotws/SAN for
004FEDr 2               ; more information. Because disassemblers are used interactively with slow
004FEDr 2               ; humans, we don't care that much about speed and put the emphasis at being
004FEDr 2               ; small.
004FEDr 2               
004FEDr 2               ; Uses: tmp3, tmp2, tmp1 (xt_u_dot_r uses xt_type which uses tmp1)
004FEDr 2               ;       scratch (used for handling literals and JSRs)
004FEDr 2               
004FEDr 2               disassembler:
004FEDr 2  20 rr rr                     jsr xt_cr       ; ( addr u )
004FF0r 2               _byte_loop:
004FF0r 2                               ; Print address at start of the line. Note we use whatever
004FF0r 2                               ; number base the user has
004FF0r 2  20 rr rr                     jsr xt_over     ; ( addr u addr )
004FF3r 2  20 rr rr                     jsr xt_u_dot    ; ( addr u )
004FF6r 2  20 rr rr                     jsr xt_space
004FF9r 2               
004FF9r 2                               ; We use the opcode value as the offset in the oc_index_table.
004FF9r 2                               ; We have 256 entries, each two bytes long, so we can't just
004FF9r 2                               ; use an index with Y. We use tmp2 for this.
004FF9r 2  A9 rr                        lda #<oc_index_table
004FFBr 2  85 rr                        sta tmp2
004FFDr 2  A9 rr                        lda #>oc_index_table
004FFFr 2  85 rr                        sta tmp2+1
005001r 2               
005001r 2  A1 02                        lda (2,x)       ; get opcode that addr points to
005003r 2  85 rr                        sta scratch     ; Save opcode
005005r 2               
005005r 2  0A                           asl             ; multiply by two for offset
005006r 2  90 02                        bcc @ok
005008r 2  E6 rr                        inc tmp2+1      ; we're on second page
00500Ar 2               @ok:
00500Ar 2  A8                           tay             ; use Y as the index
00500Br 2               
00500Br 2                               ; Get address of the entry in the opcode table. We put it
00500Br 2                               ; in tmp3 and push a copy of it to the stack to be able to
00500Br 2                               ; print the opcode later
00500Br 2  B1 rr                        lda (tmp2),y    ; LSB
00500Dr 2  85 rr                        sta tmp3
00500Fr 2  48                           pha
005010r 2               
005010r 2  C8                           iny
005011r 2               
005011r 2  B1 rr                        lda (tmp2),y    ; MSB
005013r 2  85 rr                        sta tmp3+1
005015r 2  48                           pha
005016r 2               
005016r 2                               ; The first byte is the "lengths byte" which is coded so
005016r 2                               ; that bits 7 to 6 are the length of the instruction (1 to
005016r 2                               ; 3 bytes) and 2 to 0 are the length of the mnemonic.
005016r 2  B2 rr                        lda (tmp3)
005018r 2  A8                           tay                     ; save copy of lengths byte
005019r 2               
005019r 2                               ; Since this is Simpler Assembler Notation (SAN) in a Forth
005019r 2                               ; system, we want to print any operand before we print the
005019r 2                               ; mnemonic ('1000 sta' instead of 'sta 1000'). This allows us
005019r 2                               ; to copy and paste directly from the disassembler to the
005019r 2                               ; assembler.
005019r 2               
005019r 2                               ; What happens next depends on the length of the instruction in
005019r 2                               ; bytes:
005019r 2               
005019r 2                               ;   1 byte:  OPC          -->          OPC  bit sequence: %01
005019r 2                               ;   2 bytes: OPC LSB      -->    0 LSB OPC  bit sequence: %10
005019r 2                               ;   3 bytes: OPC LSB MSB  -->  MSB LSB OPC  bit sequence: %11
005019r 2               
005019r 2                               ; We can distinguish between the first case, where there is
005019r 2                               ; only the mnemonic, and the second and third cases, where we
005019r 2                               ; have an operand. We do this by use of the bit sequence in
005019r 2                               ; bits 7 and 6.
005019r 2  10 3C                        bpl _no_operand         ; bit 7 clear, single-byte instruction
00501Br 2               
00501Br 2                               ; We have an operand. Prepare the Data Stack
00501Br 2  20 rr rr                     jsr xt_zero             ; ( addr u 0 ) ZERO does not use Y
00501Er 2               
00501Er 2                               ; Because of the glory of a little endian CPU, we can start
00501Er 2                               ; with the next byte regardless if this is a one or two byte
00501Er 2                               ; operand, because we'll need the LSB one way or the other.
00501Er 2                               ; We have a copy of the opcode on the stack, so we can now move
00501Er 2                               ; to the next byte
00501Er 2  F6 04                        inc 4,x
005020r 2  D0 02                        bne @l1
005022r 2  F6 05                        inc 5,x                 ; ( addr+1 u 0 )
005024r 2               @l1:
005024r 2  B5 02                        lda 2,x
005026r 2  D0 02                        bne @l2
005028r 2  D6 03                        dec 3,x
00502Ar 2               @l2:
00502Ar 2  D6 02                        dec 2,x                 ; ( addr+1 u-1 0 )
00502Cr 2               
00502Cr 2  A1 04                        lda (4,x)
00502Er 2  95 00                        sta 0,x                 ; LSB of operand ( addr+1 u-1 LSB )
005030r 2  85 rr                        sta scratch+1           ; Save a copy in the scratch buffer
005032r 2               
005032r 2                               ; We still have a copy of the lengths byte in Y, which we use
005032r 2                               ; to see if we have a one-byte operand (and are done already)
005032r 2                               ; or a two-byte operand
005032r 2  98                           tya                     ; retrieve copy of lengths byte
005033r 2  2A                           rol                     ; shift bit 6 to bit 7
005034r 2  10 14                        bpl _print_operand
005036r 2               
005036r 2                               ; We have a three-byte instruction, so we need to get the MSB
005036r 2                               ; of the operand. Move to the next byte
005036r 2  F6 04                        inc 4,x
005038r 2  D0 02                        bne @l3
00503Ar 2  F6 05                        inc 5,x                 ; ( addr+2 u-1 LSB )
00503Cr 2               @l3:
00503Cr 2  B5 02                        lda 2,x
00503Er 2  D0 02                        bne @l4
005040r 2  D6 03                        dec 3,x
005042r 2               @l4:
005042r 2  D6 02                        dec 2,x                 ; ( addr+2 u-2 LSB )
005044r 2               
005044r 2  A1 04                        lda (4,x)
005046r 2  95 01                        sta 1,x                 ; MSB of operand ( addr+2 u-2 opr )
005048r 2  85 rr                        sta scratch+2           ; Save a copy in the scratch buffer
00504Ar 2               
00504Ar 2                               ; fall through to _print_operand
00504Ar 2               
00504Ar 2               _print_operand:
00504Ar 2               
00504Ar 2                               ; We arrive here with the lengths byte in Y, the address of the
00504Ar 2                               ; opcode table entry for the instruction on the stack ( addr+n
00504Ar 2                               ; u-n opr). We want the output to be nicely formatted in
00504Ar 2                               ; columns, so we use U.R. The maximal width of the number in
00504Ar 2                               ; decimal on an 16-bit addressed machine is five characters
00504Ar 2  CA                           dex
00504Br 2  CA                           dex
00504Cr 2  A9 05                        lda #5
00504Er 2  95 00                        sta 0,x
005050r 2  74 01                        stz 1,x                 ; ( addr+n u-n opr 5 )
005052r 2               
005052r 2  20 rr rr                     jsr xt_u_dot_r          ; U.R ( addr+n u-n )
005055r 2               
005055r 2  80 0B                        bra _print_mnemonic
005057r 2               
005057r 2               _no_operand:
005057r 2                               ; We arrive here with the opcode table address on the stack,
005057r 2                               ; the lengths byte in Y and ( addr u ). Since we want to have
005057r 2                               ; a nicely formatted output, we need to indent the mnemonic by
005057r 2                               ; five spaces.
005057r 2  CA                           dex
005058r 2  CA                           dex
005059r 2  A9 05                        lda #5
00505Br 2  95 00                        sta 0,x
00505Dr 2  74 01                        stz 1,x                 ; ( addr u 5 )
00505Fr 2               
00505Fr 2  20 rr rr                     jsr xt_spaces           ; ( addr u )
005062r 2               
005062r 2                               ; fall through to _print_mnemonic
005062r 2               
005062r 2               _print_mnemonic:
005062r 2                               ; We arrive here with the opcode table address on the stack and
005062r 2                               ; ( addr u | addr+n u-n ). Time to print the mnemonic.
005062r 2  20 rr rr                     jsr xt_space
005065r 2               
005065r 2  CA                           dex
005066r 2  CA                           dex                     ; ( addr u ? )
005067r 2  68                           pla                     ; MSB
005068r 2  95 01                        sta 1,x                 ; ( addr u MSB )
00506Ar 2  68                           pla                     ; LSB
00506Br 2  95 00                        sta 0,x                 ; ( addr u addr-o )
00506Dr 2               
00506Dr 2  20 rr rr                     jsr xt_count            ; ( addr u addr-o u-o )
005070r 2               
005070r 2                               ; The length of the mnemnonic string is in bits 2 to 0
005070r 2  74 01                        stz 1,x                 ; paranoid
005072r 2  B5 00                        lda 0,x
005074r 2  29 07                        and #%00000111          ; ( addr u addr-o u-o )
005076r 2  95 00                        sta 0,x
005078r 2               
005078r 2  20 rr rr                     jsr xt_type             ; ( addr u )
00507Br 2               
00507Br 2                               ; Handle JSR by printing name of function, if available.
00507Br 2                               ; scratch has opcode ($20 for JSR)
00507Br 2                               ; scratch+1 and scratch+2 have address if it's a JSR.
00507Br 2  A5 rr                        lda scratch
00507Dr 2  C9 20                        cmp #$20
00507Fr 2  D0 59                        bne _not_jsr
005081r 2               
005081r 2                               ; It's a JSR.  Print 5 spaces as an offset.
005081r 2  CA                           dex
005082r 2  CA                           dex
005083r 2  A9 05                        lda #5
005085r 2  95 00                        sta 0,x
005087r 2  74 01                        stz 1,x
005089r 2  20 rr rr                     jsr xt_spaces
00508Cr 2               
00508Cr 2               ; Special handlers
00508Cr 2                               ; Handle literals specially.
00508Cr 2  A9 rr                        lda #<literal_runtime
00508Er 2  C5 rr                        cmp scratch+1
005090r 2  D0 0C                        bne _not_literal
005092r 2  A9 rr                        lda #>literal_runtime
005094r 2  C5 rr                        cmp scratch+2
005096r 2  D0 06                        bne _not_literal
005098r 2                               ; It's a literal.
005098r 2  20 rr rr                     jsr disasm_literal
00509Br 2  4C rr rr                     jmp _printing_done
00509Er 2               
00509Er 2               _not_literal:
00509Er 2                               ; Handle string literals specially.
00509Er 2  A9 rr                        lda #<sliteral_runtime
0050A0r 2  C5 rr                        cmp scratch+1
0050A2r 2  D0 0C                        bne _not_sliteral
0050A4r 2  A9 rr                        lda #>sliteral_runtime
0050A6r 2  C5 rr                        cmp scratch+2
0050A8r 2  D0 06                        bne _not_sliteral
0050AAr 2                               ; It's a literal.
0050AAr 2  20 rr rr                     jsr disasm_sliteral
0050ADr 2  4C rr rr                     jmp _printing_done
0050B0r 2               _not_sliteral:
0050B0r 2                               ; Handle 0branch
0050B0r 2  A9 rr                        lda #<zero_branch_runtime
0050B2r 2  C5 rr                        cmp scratch+1
0050B4r 2  D0 0C                        bne _not_0branch
0050B6r 2  A9 rr                        lda #>zero_branch_runtime
0050B8r 2  C5 rr                        cmp scratch+2
0050BAr 2  D0 06                        bne _not_0branch
0050BCr 2                               ; It's a 0branch.
0050BCr 2  20 rr rr                     jsr disasm_0branch
0050BFr 2  4C rr rr                     jmp _printing_done
0050C2r 2               _not_0branch:
0050C2r 2                               ; Handle branch
0050C2r 2  A9 rr                        lda #<branch_runtime
0050C4r 2  C5 rr                        cmp scratch+1
0050C6r 2  D0 0C                        bne _not_branch
0050C8r 2  A9 rr                        lda #>branch_runtime
0050CAr 2  C5 rr                        cmp scratch+2
0050CCr 2  D0 06                        bne _not_branch
0050CEr 2                               ; It's a branch.
0050CEr 2  20 rr rr                     jsr disasm_branch
0050D1r 2  4C rr rr                     jmp _printing_done
0050D4r 2               _not_branch:
0050D4r 2                               ; Try the generic JSR handler, which will use the target of the
0050D4r 2                               ; JSR as an XT and print the name if it exists.
0050D4r 2  20 rr rr                     jsr disasm_jsr
0050D7r 2  4C rr rr                     jmp _printing_done
0050DAr 2               
0050DAr 2               _not_jsr:
0050DAr 2                               ; See if the instruction is a jump (instruction still in A)
0050DAr 2                               ; (Strings start with a jump over the data.)
0050DAr 2  C9 4C                        cmp #$4C
0050DCr 2  D0 29                        bne _printing_done
0050DEr 2               
0050DEr 2                               ; We have a branch.  See if it's a string by looking for
0050DEr 2                               ; a JSR sliteral_runtime at the jump target address.
0050DEr 2                               ; The target address is in scratch+1 and scratch+2
0050DEr 2                               ; Use scratch+3 and scratch+4 here as we need to move
0050DEr 2                               ; the pointer.
0050DEr 2  A5 rr                        lda scratch+1   ; Copy the pointer.
0050E0r 2  85 rr                        sta scratch+3
0050E2r 2  A5 rr                        lda scratch+2
0050E4r 2  85 rr                        sta scratch+4
0050E6r 2               
0050E6r 2                               ; Get the first byte at the jmp target address.
0050E6r 2  B2 rr                        lda (scratch+3)
0050E8r 2               
0050E8r 2  C9 20                        cmp #$20 ; check for JSR
0050EAr 2  D0 1B                        bne _printing_done
0050ECr 2                               ; Next byte
0050ECr 2  E6 rr                        inc scratch+3
0050EEr 2  D0 02                        bne @l1
0050F0r 2  E6 rr                        inc scratch+4
0050F2r 2               @l1:
0050F2r 2                               ; Check for string literal runtime
0050F2r 2  B2 rr                        lda (scratch+3)
0050F4r 2               
0050F4r 2  C9 rr                        cmp #<sliteral_runtime
0050F6r 2  D0 0F                        bne _printing_done
0050F8r 2                               ; Next byte
0050F8r 2  E6 rr                        inc scratch+3
0050FAr 2  D0 02                        bne @l2
0050FCr 2  E6 rr                        inc scratch+4
0050FEr 2               @l2:
0050FEr 2  B2 rr                        lda (scratch+3)
005100r 2               
005100r 2  C9 rr                        cmp #>sliteral_runtime
005102r 2  D0 03                        bne _printing_done
005104r 2               
005104r 2                               ; It's a string literal jump.
005104r 2  20 rr rr                     jsr disasm_sliteral_jump
005107r 2               _printing_done:
005107r 2  20 rr rr                     jsr xt_cr
00510Ar 2               
00510Ar 2                               ; Housekeeping: Next byte
00510Ar 2  F6 02                        inc 2,x
00510Cr 2  D0 02                        bne @l3
00510Er 2  F6 03                        inc 3,x                 ; ( addr+1 u )
005110r 2               @l3:
005110r 2  20 rr rr                     jsr xt_one_minus        ; ( addr+1 u-1 )
005113r 2               
005113r 2  B5 00                        lda 0,x                 ; All done?
005115r 2  15 01                        ora 1,x
005117r 2  F0 07                        beq @done
005119r 2               
005119r 2  B5 01                        lda 1,x                 ; Catch mid-instruction ranges
00511Br 2  30 03                        bmi @done
00511Dr 2               
00511Dr 2  4C rr rr                     jmp _byte_loop          ; out of range for BRA
005120r 2               @done:
005120r 2                               ; Clean up and leave
005120r 2  4C rr rr                     jmp xt_two_drop         ; JSR/RTS
005123r 2               
005123r 2               ; Handlers for various special disassembled instructions:
005123r 2               ; String literal handler (both for inline strings and sliteral)
005123r 2               disasm_sliteral_jump:
005123r 2                               ; If we get here, we are at the jump for a constant string.
005123r 2                               ; Strings are compiled into the dictionary like so:
005123r 2                               ;           jmp a
005123r 2                               ;           <string data bytes>
005123r 2                               ;  a -->    jsr sliteral_runtime
005123r 2                               ;           <string address>
005123r 2                               ;           <string length>
005123r 2                               ;
005123r 2                               ; We have ( addr n ) on the stack where addr is the last
005123r 2                               ; byte of the address a in the above jmp instruction.
005123r 2                               ; Address a is in scratch+1 scratch+2.
005123r 2               
005123r 2                               ; Determine the distance of the jump so we end on the byte
005123r 2                               ; just before the JSR (sets us up for SLITERAL on next loop)
005123r 2  20 rr rr                     jsr xt_swap
005126r 2  CA                           dex
005127r 2  CA                           dex
005128r 2  A5 rr                        lda scratch+1
00512Ar 2  95 00                        sta 0,x
00512Cr 2  A5 rr                        lda scratch+2
00512Er 2  95 01                        sta 1,x
005130r 2  20 rr rr                     jsr xt_swap
005133r 2  20 rr rr                     jsr xt_minus
005136r 2  20 rr rr                     jsr xt_one_minus
005139r 2                               ; (n jump_distance)
005139r 2                               ; Subtract the jump distance from the bytes left.
005139r 2  20 rr rr                     jsr xt_minus
00513Cr 2                               ; ( new_n )
00513Cr 2                               ; Move to one byte before the target address
00513Cr 2  CA                           dex
00513Dr 2  CA                           dex
00513Er 2  A5 rr                        lda scratch+1
005140r 2  95 00                        sta 0,x
005142r 2  A5 rr                        lda scratch+2
005144r 2  95 01                        sta 1,x
005146r 2  20 rr rr                     jsr xt_one_minus
005149r 2  20 rr rr                     jsr xt_swap ; ( new_addr new_n )
00514Cr 2  60                           rts
00514Dr 2               
00514Dr 2               ; String literal handler
00514Dr 2               disasm_sliteral:
00514Dr 2  A9 53                        lda #'S'
00514Fr 2  20 rr rr                     jsr emit_a ; Print S before LITERAL so it becomes SLITERAL
005152r 2  A9 0D                        lda #str_disasm_lit     ; "LITERAL "
005154r 2  20 rr rr                     jsr print_string_no_lf
005157r 2               
005157r 2                               ; ( addr u ) address of last byte of JSR address and bytes left on the stack.
005157r 2                               ; We need to print the two values just after addr and move along two bytes
005157r 2                               ; for each value.
005157r 2  20 rr rr                     jsr xt_swap             ; switch to (u addr)
00515Ar 2  20 rr rr                     jsr xt_one_plus
00515Dr 2               
00515Dr 2  20 rr rr                     jsr xt_dup
005160r 2  20 rr rr                     jsr xt_fetch
005163r 2  20 rr rr                     jsr xt_u_dot            ; Print the address of the string
005166r 2                               ; Move along two bytes (already moved address one) to skip over the constant.
005166r 2  20 rr rr                     jsr xt_two
005169r 2  20 rr rr                     jsr xt_plus
00516Cr 2               
00516Cr 2  20 rr rr                     jsr xt_dup
00516Fr 2  20 rr rr                     jsr xt_question         ; Print the length of the string
005172r 2                               ; Move along to the very last byte of the data.
005172r 2  20 rr rr                     jsr xt_one_plus
005175r 2               
005175r 2                               ; ( u addr+4 )
005175r 2                               ; Fix up the number of bytes left.
005175r 2  20 rr rr                     jsr xt_swap            ; ( addr+4 u )
005178r 2  CA                           dex
005179r 2  CA                           dex
00517Ar 2  A9 04                        lda #4
00517Cr 2  95 00                        sta 0,x
00517Er 2  74 01                        stz 1,x
005180r 2  20 rr rr                     jsr xt_minus            ; ( addr+4 u-4 )
005183r 2  60                           rts
005184r 2               
005184r 2               
005184r 2               ; 0BRANCH handler
005184r 2               disasm_0branch:
005184r 2  A9 30                        lda #'0'
005186r 2  20 rr rr                     jsr emit_a ; Print 0 before BRANCH so it becomes 0BRANCH
005189r 2                               ; All other processing is identical, so fall into BRANCH handler
005189r 2               ; BRANCH handler
005189r 2               disasm_branch:
005189r 2  A9 0F                        lda #str_disasm_bra
00518Br 2  20 rr rr                     jsr print_string_no_lf ; "BRANCH "
00518Er 2                               ; The address after the 0BRANCH is handled the same as a literal.
00518Er 2  80 05                        bra disasm_print_literal
005190r 2               
005190r 2               ; Literal handler
005190r 2               disasm_literal:
005190r 2  A9 0D                        lda #str_disasm_lit
005192r 2  20 rr rr                     jsr print_string_no_lf ; "LITERAL "
005195r 2               disasm_print_literal:
005195r 2                               ; ( addr u ) address of last byte of JSR and bytes left on the stack.
005195r 2                               ; We need to print the value just after the address and move along two bytes.
005195r 2  20 rr rr                     jsr xt_swap ; switch to (u addr)
005198r 2  20 rr rr                     jsr xt_one_plus
00519Br 2               
00519Br 2  20 rr rr                     jsr xt_dup
00519Er 2  20 rr rr                     jsr xt_question ; Print the value at the adress
0051A1r 2                               ; Move along two bytes (already moved address one) to skip over the constant.
0051A1r 2  20 rr rr                     jsr xt_one_plus
0051A4r 2  20 rr rr                     jsr xt_swap ; (addr+2 u)
0051A7r 2  20 rr rr                     jsr xt_one_minus
0051AAr 2  20 rr rr                     jsr xt_one_minus ; (addr+2 u-2)
0051ADr 2  60                           rts
0051AEr 2               
0051AEr 2               ; JSR handler
0051AEr 2               disasm_jsr:
0051AEr 2                               ; The address of the JSR is in scratch+1 and scratch+2.
0051AEr 2                               ; The current stack is already ( addr u ) where addr is the address of the last byte of
0051AEr 2                               ; the JSR target address, and we want to leave it like that so moving on to the next byte
0051AEr 2                               ; works properly.
0051AEr 2                               ; Put the target address on the stack and see if it's an XT.
0051AEr 2  CA                           dex
0051AFr 2  CA                           dex
0051B0r 2  A5 rr                        lda scratch+1
0051B2r 2  95 00                        sta 0,x
0051B4r 2  A5 rr                        lda scratch+2
0051B6r 2  95 01                        sta 1,x
0051B8r 2                               ; ( xt )
0051B8r 2  20 rr rr                     jsr xt_int_to_name
0051BBr 2                               ; int>name returns zero if we just don't know.
0051BBr 2  B5 00                        lda 0,x
0051BDr 2  15 01                        ora 1,x
0051BFr 2  F0 07                        beq _disasm_no_nt
0051C1r 2                               ; We now have a name token ( nt ) on the stack.
0051C1r 2                               ; Change it into the name and print it.
0051C1r 2  20 rr rr                     jsr xt_name_to_string
0051C4r 2  20 rr rr                     jsr xt_type
0051C7r 2  60                           rts
0051C8r 2               
0051C8r 2               _disasm_no_nt:
0051C8r 2  20 rr rr                     jsr xt_drop ; the 0 indicating no name token
0051CBr 2                               ; See if the address is between underflow_1 and underflow_4,
0051CBr 2                               ; inclusive.
0051CBr 2  CA                           dex
0051CCr 2  CA                           dex
0051CDr 2  A5 rr                        lda scratch+1
0051CFr 2  95 00                        sta 0,x
0051D1r 2  A5 rr                        lda scratch+2
0051D3r 2  95 01                        sta 1,x
0051D5r 2                               ; ( jsr_address )
0051D5r 2                               ; Compare to lower underflow address
0051D5r 2  CA                           dex
0051D6r 2  CA                           dex
0051D7r 2  A9 rr                        lda #<underflow_1
0051D9r 2  95 00                        sta 0,x
0051DBr 2  A9 rr                        lda #>underflow_1
0051DDr 2  95 01                        sta 1,x
0051DFr 2  20 rr rr                     jsr compare_16bit
0051E2r 2  F0 02                        beq _disasm_jsr_uflow_check_upper
0051E4r 2  B0 14                        bcs _disasm_jsr_unknown
0051E6r 2               _disasm_jsr_uflow_check_upper:
0051E6r 2                               ; Compare to upper underflow addresses
0051E6r 2  A9 rr                        lda #<underflow_4
0051E8r 2  95 00                        sta 0,x
0051EAr 2  A9 rr                        lda #>underflow_4
0051ECr 2  95 01                        sta 1,x
0051EEr 2  20 rr rr                     jsr compare_16bit
0051F1r 2  F0 02                        beq _disasm_jsr_soc
0051F3r 2  90 05                        bcc _disasm_jsr_unknown
0051F5r 2               _disasm_jsr_soc:
0051F5r 2                               ; It's an underflow check.
0051F5r 2  A9 0E                        lda #str_disasm_sdc
0051F7r 2  20 rr rr                     jsr print_string_no_lf  ; "STACK DEPTH CHECK"
0051FAr 2               _disasm_jsr_unknown:
0051FAr 2  20 rr rr                     jsr xt_two_drop
0051FDr 2  60                           rts
0051FEr 2               
0051FEr 2               
0051FEr 2               ; =========================================================
0051FEr 2               oc_index_table:
0051FEr 2                       ; Lookup table for the instruction data (length of instruction in
0051FEr 2                       ; bytes, length of mnemonic in bytes, mnemonic string). This is used by
0051FEr 2                       ; the assembler as well.
0051FEr 2               
0051FEr 2                       ; Opcodes 00-0F
0051FEr 2  rr rr rr rr          .word oc00, oc01, oc__, oc__, oc04, oc05, oc06, oc__
005202r 2  rr rr rr rr  
005206r 2  rr rr rr rr  
00520Er 2  rr rr rr rr          .word oc08, oc09, oc0a, oc__, oc0c, oc0d, oc0e, oc0f
005212r 2  rr rr rr rr  
005216r 2  rr rr rr rr  
00521Er 2               
00521Er 2                       ; Opcodes 10-1F
00521Er 2  rr rr rr rr          .word oc10, oc11, oc12, oc__, oc14, oc15, oc16, oc17
005222r 2  rr rr rr rr  
005226r 2  rr rr rr rr  
00522Er 2  rr rr rr rr          .word oc18, oc19, oc1a, oc__, oc1c, oc1d, oc__, oc1f
005232r 2  rr rr rr rr  
005236r 2  rr rr rr rr  
00523Er 2               
00523Er 2                       ; Opcodes 20-2F
00523Er 2  rr rr rr rr          .word oc20, oc21, oc__, oc__, oc24, oc25, oc26, oc27
005242r 2  rr rr rr rr  
005246r 2  rr rr rr rr  
00524Er 2  rr rr rr rr          .word oc28, oc29, oc2a, oc__, oc2c, oc2d, oc2e, oc2f
005252r 2  rr rr rr rr  
005256r 2  rr rr rr rr  
00525Er 2               
00525Er 2                       ; Opcodes 30-3F
00525Er 2  rr rr rr rr          .word oc30, oc31, oc32, oc__, oc34, oc35, oc36, oc37
005262r 2  rr rr rr rr  
005266r 2  rr rr rr rr  
00526Er 2  rr rr rr rr          .word oc38, oc39, oc3a, oc__, oc3c, oc3d, oc3e, oc0f
005272r 2  rr rr rr rr  
005276r 2  rr rr rr rr  
00527Er 2               
00527Er 2                       ; Opcodes 40-4F
00527Er 2  rr rr rr rr          .word oc40, oc41, oc__, oc__, oc__, oc45, oc46, oc47
005282r 2  rr rr rr rr  
005286r 2  rr rr rr rr  
00528Er 2  rr rr rr rr          .word oc48, oc49, oc4a, oc__, oc4c, oc4d, oc4e, oc4f
005292r 2  rr rr rr rr  
005296r 2  rr rr rr rr  
00529Er 2               
00529Er 2                       ; Opcodes 50-5F
00529Er 2  rr rr rr rr          .word oc50, oc51, oc52, oc__, oc__, oc55, oc56, oc57
0052A2r 2  rr rr rr rr  
0052A6r 2  rr rr rr rr  
0052AEr 2  rr rr rr rr          .word oc58, oc59, oc5a, oc__, oc__, oc__, oc5e, oc5f
0052B2r 2  rr rr rr rr  
0052B6r 2  rr rr rr rr  
0052BEr 2               
0052BEr 2                       ; Opcodes 60-6F
0052BEr 2  rr rr rr rr          .word oc60, oc61, oc__, oc__, oc64, oc65, oc66, oc67
0052C2r 2  rr rr rr rr  
0052C6r 2  rr rr rr rr  
0052CEr 2  rr rr rr rr          .word oc68, oc69, oc6a, oc__, oc6c, oc6d, oc6e, oc6f
0052D2r 2  rr rr rr rr  
0052D6r 2  rr rr rr rr  
0052DEr 2               
0052DEr 2                       ; Opcodes 70-7F
0052DEr 2  rr rr rr rr          .word oc70, oc71, oc72, oc__, oc74, oc75, oc76, oc77
0052E2r 2  rr rr rr rr  
0052E6r 2  rr rr rr rr  
0052EEr 2  rr rr rr rr          .word oc78, oc79, oc7a, oc__, oc7c, oc7d, oc7e, oc7f
0052F2r 2  rr rr rr rr  
0052F6r 2  rr rr rr rr  
0052FEr 2               
0052FEr 2                       ; Opcodes 80-8F
0052FEr 2  rr rr rr rr          .word oc80, oc81, oc__, oc__, oc84, oc85, oc86, oc__
005302r 2  rr rr rr rr  
005306r 2  rr rr rr rr  
00530Er 2  rr rr rr rr          .word oc88, oc89, oc8a, oc__, oc8c, oc8d, oc8e, oc8f
005312r 2  rr rr rr rr  
005316r 2  rr rr rr rr  
00531Er 2               
00531Er 2                       ; Opcodes 90-9F
00531Er 2  rr rr rr rr          .word oc90, oc91, oc92, oc__, oc94, oc95, oc96, oc97
005322r 2  rr rr rr rr  
005326r 2  rr rr rr rr  
00532Er 2  rr rr rr rr          .word oc98, oc99, oc9a, oc__, oc9c, oc9d, oc9e, oc9f
005332r 2  rr rr rr rr  
005336r 2  rr rr rr rr  
00533Er 2               
00533Er 2                       ; Opcodes A0-AF
00533Er 2  rr rr rr rr          .word oca0, oca1, oca2, oc__, oca4, oca5, oca6, oca7
005342r 2  rr rr rr rr  
005346r 2  rr rr rr rr  
00534Er 2  rr rr rr rr          .word oca8, oca9, ocaa, oc__, ocac, ocad, ocae, ocaf
005352r 2  rr rr rr rr  
005356r 2  rr rr rr rr  
00535Er 2               
00535Er 2                       ; Opcodes B0-BF
00535Er 2  rr rr rr rr          .word ocb0, ocb1, ocb2, oc__, ocb4, ocb5, ocb6, ocb7
005362r 2  rr rr rr rr  
005366r 2  rr rr rr rr  
00536Er 2  rr rr rr rr          .word ocb8, ocb9, ocba, oc__, ocbc, ocbd, ocbe, ocbf
005372r 2  rr rr rr rr  
005376r 2  rr rr rr rr  
00537Er 2               
00537Er 2                       ; Opcodes C0-CF
00537Er 2  rr rr rr rr          .word occ0, occ1, oc__, oc__, occ4, occ5, occ6, occ7
005382r 2  rr rr rr rr  
005386r 2  rr rr rr rr  
00538Er 2  rr rr rr rr          .word occ8, occ9, occa, oc__, occc, occd, occe, occf
005392r 2  rr rr rr rr  
005396r 2  rr rr rr rr  
00539Er 2               
00539Er 2                       ; Opcodes D0-DF
00539Er 2  rr rr rr rr          .word ocd0, ocd1, ocd2, oc__, oc__, ocd5, ocd6, ocd7
0053A2r 2  rr rr rr rr  
0053A6r 2  rr rr rr rr  
0053AEr 2  rr rr rr rr          .word ocd8, ocd9, ocda, oc__, oc__, ocdd, ocde, ocdf
0053B2r 2  rr rr rr rr  
0053B6r 2  rr rr rr rr  
0053BEr 2               
0053BEr 2                       ; Opcodes E0-EF
0053BEr 2  rr rr rr rr          .word oce0, oce1, oc__, oc__, oce4, oce5, oce6, oce7
0053C2r 2  rr rr rr rr  
0053C6r 2  rr rr rr rr  
0053CEr 2  rr rr rr rr          .word oce8, oce9, ocea, oc__, ocec, oced, ocee, ocef
0053D2r 2  rr rr rr rr  
0053D6r 2  rr rr rr rr  
0053DEr 2               
0053DEr 2                       ; Opcodes F0-FF
0053DEr 2  rr rr rr rr          .word ocf0, ocf1, ocf2, oc__, oc__, ocf5, ocf6, ocf7
0053E2r 2  rr rr rr rr  
0053E6r 2  rr rr rr rr  
0053EEr 2  rr rr rr rr          .word ocf8, ocf9, ocfa, oc__, oc__, ocfd, ocfe, ocff
0053F2r 2  rr rr rr rr  
0053F6r 2  rr rr rr rr  
0053FEr 2               
0053FEr 2               
0053FEr 2               ; =========================================================
0053FEr 2               oc_table:
0053FEr 2                       ; Opcode data table for the disassember, which is also used by the
0053FEr 2                       ; assembler. Each entry starts with a "lengths byte":
0053FEr 2               
0053FEr 2                       ;       bit 7-6:  Length of instruction in bytes (1 to 3 for the 65c02)
0053FEr 2                       ;       bit 5-3:  unused
0053FEr 2                       ;       bit 2-0:  Length of mnemonic in chars (3 to 7)
0053FEr 2               
0053FEr 2                       ; To convert a line in this table to a Forth string of the mnemonic,
0053FEr 2                       ; use the COUNT word on the address of the lengths byte to get
0053FEr 2                       ; ( addr u ) and then mask all but the bits 2-0 of the TOS.
0053FEr 2               
0053FEr 2                       ; To make debugging easier, we keep the raw numbers for the lengths of
0053FEr 2                       ; the instruction and mnemonicis and let the assembler do the math
0053FEr 2                       ; required to shift and add. The actual mnemonic string follows after
0053FEr 2                       ; and is not zero terminated because we have the length in bits 2 to 0.
0053FEr 2               
0053FEr 2  83 62 72 6B  	oc00:	.byte 2*64+3, "brk"              ; enforce the signature byte
005402r 2  87 6F 72 61  	oc01:	.byte 2*64+7, "ora.zxi"
005406r 2  2E 7A 78 69  
00540Ar 2               ;      (oc02)
00540Ar 2               ;      (oc03)
00540Ar 2  85 74 73 62          oc04:   .byte 2*64+5, "tsb.z"
00540Er 2  2E 7A        
005410r 2  85 6F 72 61  	oc05:	.byte 2*64+5, "ora.z"
005414r 2  2E 7A        
005416r 2  85 61 73 6C  	oc06:	.byte 2*64+5, "asl.z"
00541Ar 2  2E 7A        
00541Cr 2               ;      (oc07)
00541Cr 2  43 70 68 70  	oc08:	.byte 1*64+3, "php"
005420r 2  85 6F 72 61  	oc09:	.byte 2*64+5, "ora.#"
005424r 2  2E 23        
005426r 2  45 61 73 6C  	oc0a:	.byte 1*64+5, "asl.a"
00542Ar 2  2E 61        
00542Cr 2               ;      (oc0b)
00542Cr 2  C3 74 73 62  	oc0c:	.byte 3*64+3, "tsb"
005430r 2  C3 6F 72 61  	oc0d:	.byte 3*64+3, "ora"
005434r 2  C3 61 73 6C  	oc0e:	.byte 3*64+3, "asl"
005438r 2  C4 62 62 72  	oc0f:	.byte 3*64+4, "bbr0"
00543Cr 2  30           
00543Dr 2               
00543Dr 2  83 62 70 6C  	oc10:	.byte 2*64+3, "bpl"
005441r 2  87 6F 72 61  	oc11:	.byte 2*64+7, "ora.ziy"
005445r 2  2E 7A 69 79  
005449r 2  86 6F 72 61  	oc12:	.byte 2*64+6, "ora.zi"
00544Dr 2  2E 7A 69     
005450r 2               ;      (oc13:)
005450r 2  85 74 72 62  	oc14:	.byte 2*64+5, "trb.z"
005454r 2  2E 7A        
005456r 2  86 6F 72 61  	oc15:	.byte 2*64+6, "ora.zx"
00545Ar 2  2E 7A 78     
00545Dr 2  86 61 73 6C  	oc16:	.byte 2*64+6, "asl.zx"
005461r 2  2E 7A 78     
005464r 2  86 72 6D 62  	oc17:	.byte 2*64+6, "rmb1.z"
005468r 2  31 2E 7A     
00546Br 2  43 63 6C 63  	oc18:	.byte 1*64+3, "clc"
00546Fr 2  C5 6F 72 61  	oc19:	.byte 3*64+5, "ora.y"
005473r 2  2E 79        
005475r 2  45 69 6E 63  	oc1a:	.byte 1*64+5, "inc.a"
005479r 2  2E 61        
00547Br 2               ;      (oc1b:)
00547Br 2  C3 74 72 62  	oc1c:	.byte 3*64+3, "trb"
00547Fr 2  C5 6F 72 61  	oc1d:	.byte 3*64+5, "ora.x"
005483r 2  2E 78        
005485r 2               ;      (oc1e:)
005485r 2  C5 61 73 6C  	oc1f:	.byte 3*64+5, "asl.x"
005489r 2  2E 78        
00548Br 2               
00548Br 2  C3 6A 73 72  	oc20:	.byte 3*64+3, "jsr"
00548Fr 2  87 61 6E 64  	oc21:	.byte 2*64+7, "and.zxi"
005493r 2  2E 7A 78 69  
005497r 2               ;      (oc22:)
005497r 2               ;      (oc23:)
005497r 2  85 62 69 74  	oc24:	.byte 2*64+5, "bit.z"
00549Br 2  2E 7A        
00549Dr 2  85 61 6E 64  	oc25:	.byte 2*64+5, "and.z"
0054A1r 2  2E 7A        
0054A3r 2  85 72 6F 6C  	oc26:	.byte 2*64+5, "rol.z"
0054A7r 2  2E 7A        
0054A9r 2  86 72 6D 62  	oc27:	.byte 2*64+6, "rmb2.z"
0054ADr 2  32 2E 7A     
0054B0r 2  43 70 6C 70  	oc28:	.byte 1*64+3, "plp"
0054B4r 2  85 61 6E 64  	oc29:	.byte 2*64+5, "and.#"
0054B8r 2  2E 23        
0054BAr 2  45 72 6F 6C  	oc2a:	.byte 1*64+5, "rol.a"
0054BEr 2  2E 61        
0054C0r 2               ;      (oc2b:)
0054C0r 2  C3 62 69 74  	oc2c:	.byte 3*64+3, "bit"
0054C4r 2  C4 61 6E 64  	oc2d:	.byte 3*64+4, "and."
0054C8r 2  2E           
0054C9r 2  C3 72 6F 6C  	oc2e:	.byte 3*64+3, "rol"
0054CDr 2  C4 62 62 72  	oc2f:	.byte 3*64+4, "bbr2"
0054D1r 2  32           
0054D2r 2               
0054D2r 2  83 62 6D 69  	oc30:	.byte 2*64+3, "bmi"
0054D6r 2  87 61 6E 64  	oc31:	.byte 2*64+7, "and.ziy"
0054DAr 2  2E 7A 69 79  
0054DEr 2  86 61 6E 64  	oc32:	.byte 2*64+6, "and.zi"
0054E2r 2  2E 7A 69     
0054E5r 2               ;      (oc33:)
0054E5r 2  87 62 69 74  	oc34:	.byte 2*64+7, "bit.zxi"
0054E9r 2  2E 7A 78 69  
0054EDr 2  86 61 6E 64  	oc35:	.byte 2*64+6, "and.zx"
0054F1r 2  2E 7A 78     
0054F4r 2  86 72 6F 6C  	oc36:	.byte 2*64+6, "rol.zx"
0054F8r 2  2E 7A 78     
0054FBr 2  86 72 6D 62  	oc37:	.byte 2*64+6, "rmb3.z"
0054FFr 2  33 2E 7A     
005502r 2  43 73 65 63  	oc38:	.byte 1*64+3, "sec"
005506r 2  C5 61 6E 64  	oc39:	.byte 3*64+5, "and.y"
00550Ar 2  2E 79        
00550Cr 2  45 64 65 63  	oc3a:	.byte 1*64+5, "dec.a"
005510r 2  2E 61        
005512r 2               ;      (oc3b:)
005512r 2  C5 62 69 74  	oc3c:	.byte 3*64+5, "bit.x"
005516r 2  2E 78        
005518r 2  C5 61 6E 64  	oc3d:	.byte 3*64+5, "and.x"
00551Cr 2  2E 78        
00551Er 2  C5 72 6F 6C  	oc3e:	.byte 3*64+5, "rol.x"
005522r 2  2E 78        
005524r 2  C4 62 62 72  	oc3f:	.byte 3*64+4, "bbr3"
005528r 2  33           
005529r 2               
005529r 2  43 72 74 69  	oc40:	.byte 1*64+3, "rti"
00552Dr 2  87 65 6F 72  	oc41:	.byte 2*64+7, "eor.zxi"
005531r 2  2E 7A 78 69  
005535r 2               ;      (oc42:)
005535r 2               ;      (oc43:)
005535r 2               ;      (oc44:)
005535r 2  85 65 6F 72  	oc45:	.byte 2*64+5, "eor.z"
005539r 2  2E 7A        
00553Br 2  85 6C 73 72  	oc46:	.byte 2*64+5, "lsr.z"
00553Fr 2  2E 7A        
005541r 2  86 72 62 6D  	oc47:	.byte 2*64+6, "rbm4.z"
005545r 2  34 2E 7A     
005548r 2  43 70 68 61  	oc48:	.byte 1*64+3, "pha"
00554Cr 2  85 65 6F 72  	oc49:	.byte 2*64+5, "eor.#"
005550r 2  2E 23        
005552r 2  45 6C 73 72  	oc4a:	.byte 1*64+5, "lsr.a"
005556r 2  2E 61        
005558r 2               ;      (oc4b:)
005558r 2  C3 6A 6D 70  	oc4c:	.byte 3*64+3, "jmp"
00555Cr 2  C3 65 6F 72  	oc4d:	.byte 3*64+3, "eor"
005560r 2  C3 6C 73 72  	oc4e:	.byte 3*64+3, "lsr"
005564r 2  C4 62 62 72  	oc4f:	.byte 3*64+4, "bbr4"
005568r 2  34           
005569r 2               
005569r 2  83 62 76 63  	oc50:	.byte 2*64+3, "bvc"
00556Dr 2  87 65 6F 72  	oc51:	.byte 2*64+7, "eor.ziy"
005571r 2  2E 7A 69 79  
005575r 2  86 65 6F 72  	oc52:	.byte 2*64+6, "eor.zi"
005579r 2  2E 7A 69     
00557Cr 2               ;      (oc53:)
00557Cr 2               ;      (oc54:)
00557Cr 2  86 65 6F 72  	oc55:	.byte 2*64+6, "eor.zx"
005580r 2  2E 7A 78     
005583r 2  86 6C 73 72  	oc56:	.byte 2*64+6, "lsr.zx"
005587r 2  2E 7A 78     
00558Ar 2  86 72 62 6D  	oc57:	.byte 2*64+6, "rbm5.z"
00558Er 2  35 2E 7A     
005591r 2  43 63 6C 69  	oc58:	.byte 1*64+3, "cli"
005595r 2  C5 65 6F 72  	oc59:	.byte 3*64+5, "eor.y"
005599r 2  2E 79        
00559Br 2  43 70 68 79  	oc5a:	.byte 1*64+3, "phy"
00559Fr 2               ;      (oc5b:)
00559Fr 2               ;      (oc5c:)
00559Fr 2  C5 65 6F 72  	oc5d:	.byte 3*64+5, "eor.x"
0055A3r 2  2E 78        
0055A5r 2  C5 6C 73 72  	oc5e:	.byte 3*64+5, "lsr.x"
0055A9r 2  2E 78        
0055ABr 2  C4 62 62 72  	oc5f:	.byte 3*64+4, "bbr5"
0055AFr 2  35           
0055B0r 2               
0055B0r 2  43 72 74 73  	oc60:	.byte 1*64+3, "rts"
0055B4r 2  87 61 64 63  	oc61:	.byte 2*64+7, "adc.zxi"
0055B8r 2  2E 7A 78 69  
0055BCr 2               ;      (oc62:)
0055BCr 2               ;      (oc63:)
0055BCr 2  85 73 74 7A  	oc64:	.byte 2*64+5, "stz.z"
0055C0r 2  2E 7A        
0055C2r 2  85 61 64 63  	oc65:	.byte 2*64+5, "adc.z"
0055C6r 2  2E 7A        
0055C8r 2  85 72 6F 72  	oc66:	.byte 2*64+5, "ror.z"
0055CCr 2  2E 7A        
0055CEr 2  86 72 6D 62  	oc67:	.byte 2*64+6, "rmb6.z"
0055D2r 2  36 2E 7A     
0055D5r 2  43 70 6C 61  	oc68:	.byte 1*64+3, "pla"
0055D9r 2  85 61 64 63  	oc69:	.byte 2*64+5, "adc.#"
0055DDr 2  2E 23        
0055DFr 2  45 72 6F 72  	oc6a:	.byte 1*64+5, "ror.a"
0055E3r 2  2E 61        
0055E5r 2               ;      (oc6b:)
0055E5r 2  C5 6A 6D 70  	oc6c:	.byte 3*64+5, "jmp.i"
0055E9r 2  2E 69        
0055EBr 2  C3 61 64 63  	oc6d:	.byte 3*64+3, "adc"
0055EFr 2  C3 72 6F 72  	oc6e:	.byte 3*64+3, "ror"
0055F3r 2  C4 62 62 72  	oc6f:	.byte 3*64+4, "bbr6"
0055F7r 2  36           
0055F8r 2               
0055F8r 2  83 62 76 73  	oc70:	.byte 2*64+3, "bvs"
0055FCr 2  87 61 64 63  	oc71:	.byte 2*64+7, "adc.ziy"
005600r 2  2E 7A 69 79  
005604r 2  86 61 64 63  	oc72:	.byte 2*64+6, "adc.zi"
005608r 2  2E 7A 69     
00560Br 2               ;      (oc73:)
00560Br 2  86 73 74 7A  	oc74:	.byte 2*64+6, "stz.zx"
00560Fr 2  2E 7A 78     
005612r 2  86 61 64 63  	oc75:	.byte 2*64+6, "adc.zx"
005616r 2  2E 7A 78     
005619r 2  86 72 6F 72  	oc76:	.byte 2*64+6, "ror.zx"
00561Dr 2  2E 7A 78     
005620r 2  86 72 6D 62  	oc77:	.byte 2*64+6, "rmb7.z"
005624r 2  37 2E 7A     
005627r 2  43 73 65 69  	oc78:	.byte 1*64+3, "sei"
00562Br 2  C5 61 64 63  	oc79:	.byte 3*64+5, "adc.y"
00562Fr 2  2E 79        
005631r 2  43 70 6C 79  	oc7a:	.byte 1*64+3, "ply"
005635r 2               ;      (oc7b:)
005635r 2  C6 6A 6D 70  	oc7c:	.byte 3*64+6, "jmp.xi"
005639r 2  2E 78 69     
00563Cr 2  C5 61 64 63  	oc7d:	.byte 3*64+5, "adc.x"
005640r 2  2E 78        
005642r 2  C5 72 6F 72  	oc7e:	.byte 3*64+5, "ror.x"
005646r 2  2E 78        
005648r 2  C4 62 62 72  	oc7f:	.byte 3*64+4, "bbr7"
00564Cr 2  37           
00564Dr 2               
00564Dr 2  83 62 72 61  	oc80:	.byte 2*64+3, "bra"
005651r 2  87 73 74 61  	oc81:	.byte 2*64+7, "sta.zxi"
005655r 2  2E 7A 78 69  
005659r 2               ;      (oc82:)
005659r 2               ;      (oc83:)
005659r 2  85 73 74 79  	oc84:	.byte 2*64+5, "sty.z"
00565Dr 2  2E 7A        
00565Fr 2  85 73 74 61  	oc85:	.byte 2*64+5, "sta.z"
005663r 2  2E 7A        
005665r 2  85 73 74 78  	oc86:	.byte 2*64+5, "stx.z"
005669r 2  2E 7A        
00566Br 2               ;      (oc87:)
00566Br 2  43 64 65 79  	oc88:	.byte 1*64+3, "dey"
00566Fr 2  85 62 69 74  	oc89:	.byte 2*64+5, "bit.#"
005673r 2  2E 23        
005675r 2  43 74 78 61  	oc8a:	.byte 1*64+3, "txa"
005679r 2               ;      (oc8b:)
005679r 2  C3 73 74 79  	oc8c:	.byte 3*64+3, "sty"
00567Dr 2  C3 73 74 61  	oc8d:	.byte 3*64+3, "sta"
005681r 2  C3 73 74 78  	oc8e:	.byte 3*64+3, "stx"
005685r 2  C4 62 62 73  	oc8f:	.byte 3*64+4, "bbs0"
005689r 2  30           
00568Ar 2               
00568Ar 2  83 62 63 63  	oc90:	.byte 2*64+3, "bcc"
00568Er 2  87 73 74 61  	oc91:	.byte 2*64+7, "sta.ziy"
005692r 2  2E 7A 69 79  
005696r 2  86 73 74 61  	oc92:	.byte 2*64+6, "sta.zi"
00569Ar 2  2E 7A 69     
00569Dr 2               ;      (oc93:)
00569Dr 2  86 73 74 79  	oc94:	.byte 2*64+6, "sty.zx"
0056A1r 2  2E 7A 78     
0056A4r 2  86 73 74 61  	oc95:	.byte 2*64+6, "sta.zx"
0056A8r 2  2E 7A 78     
0056ABr 2  86 73 74 78  	oc96:	.byte 2*64+6, "stx.zy"
0056AFr 2  2E 7A 79     
0056B2r 2  86 73 6D 62  	oc97:	.byte 2*64+6, "smb1.z"
0056B6r 2  31 2E 7A     
0056B9r 2  43 74 79 61  	oc98:	.byte 1*64+3, "tya"
0056BDr 2  C5 73 74 61  	oc99:	.byte 3*64+5, "sta.y"
0056C1r 2  2E 79        
0056C3r 2  43 74 78 73  	oc9a:	.byte 1*64+3, "txs"
0056C7r 2               ;      (oc9b:)
0056C7r 2  C3 73 74 7A  	oc9c:	.byte 3*64+3, "stz"
0056CBr 2  C5 73 74 61  	oc9d:	.byte 3*64+5, "sta.x"
0056CFr 2  2E 78        
0056D1r 2  C5 73 74 7A  	oc9e:	.byte 3*64+5, "stz.x"
0056D5r 2  2E 78        
0056D7r 2  C4 62 62 73  	oc9f:	.byte 3*64+4, "bbs1"
0056DBr 2  31           
0056DCr 2               
0056DCr 2  85 6C 64 79  	oca0:	.byte 2*64+5, "ldy.#"
0056E0r 2  2E 23        
0056E2r 2  87 6C 64 61  	oca1:	.byte 2*64+7, "lda.zxi"
0056E6r 2  2E 7A 78 69  
0056EAr 2  85 6C 64 78  	oca2:	.byte 2*64+5, "ldx.#"
0056EEr 2  2E 23        
0056F0r 2               ;      (oca3:)
0056F0r 2  85 6C 64 79  	oca4:	.byte 2*64+5, "ldy.z"
0056F4r 2  2E 7A        
0056F6r 2  85 6C 64 61  	oca5:	.byte 2*64+5, "lda.z"
0056FAr 2  2E 7A        
0056FCr 2  85 6C 64 78  	oca6:	.byte 2*64+5, "ldx.z"
005700r 2  2E 7A        
005702r 2  86 73 6D 62  	oca7:	.byte 2*64+6, "smb2.z"
005706r 2  32 2E 7A     
005709r 2  43 74 61 79  	oca8:	.byte 1*64+3, "tay"
00570Dr 2  85 6C 64 61  	oca9:	.byte 2*64+5, "lda.#"
005711r 2  2E 23        
005713r 2  43 74 61 78  	ocaa:	.byte 1*64+3, "tax"
005717r 2               ;      (ocab:)
005717r 2  C3 6C 64 79  	ocac:	.byte 3*64+3, "ldy"
00571Br 2  C3 6C 64 61  	ocad:	.byte 3*64+3, "lda"
00571Fr 2  C3 6C 64 78  	ocae:	.byte 3*64+3, "ldx"
005723r 2  C4 62 62 73  	ocaf:	.byte 3*64+4, "bbs2"
005727r 2  32           
005728r 2               
005728r 2  83 62 63 73  	ocb0:	.byte 2*64+3, "bcs"
00572Cr 2  87 6C 64 61  	ocb1:	.byte 2*64+7, "lda.ziy"
005730r 2  2E 7A 69 79  
005734r 2  86 6C 64 61  	ocb2:	.byte 2*64+6, "lda.zi"
005738r 2  2E 7A 69     
00573Br 2               ;      (ocb3:)
00573Br 2  86 6C 64 79  	ocb4:	.byte 2*64+6, "ldy.zx"
00573Fr 2  2E 7A 78     
005742r 2  86 6C 64 61  	ocb5:	.byte 2*64+6, "lda.zx"
005746r 2  2E 7A 78     
005749r 2  86 6C 64 78  	ocb6:	.byte 2*64+6, "ldx.zy"
00574Dr 2  2E 7A 79     
005750r 2  86 73 6D 62  	ocb7:	.byte 2*64+6, "smb3.z"
005754r 2  33 2E 7A     
005757r 2  43 63 6C 76  	ocb8:	.byte 1*64+3, "clv"
00575Br 2  C5 6C 64 61  	ocb9:	.byte 3*64+5, "lda.y"
00575Fr 2  2E 79        
005761r 2  43 74 73 78  	ocba:	.byte 1*64+3, "tsx"
005765r 2               ;      (ocbb:)
005765r 2  C5 6C 64 79  	ocbc:	.byte 3*64+5, "ldy.x"
005769r 2  2E 78        
00576Br 2  C5 6C 64 61  	ocbd:	.byte 3*64+5, "lda.x"
00576Fr 2  2E 78        
005771r 2  C5 6C 64 78  	ocbe:	.byte 3*64+5, "ldx.y"
005775r 2  2E 79        
005777r 2  C4 62 62 73  	ocbf:	.byte 3*64+4, "bbs4"
00577Br 2  34           
00577Cr 2               
00577Cr 2  85 63 70 79  	occ0:	.byte 2*64+5, "cpy.#"
005780r 2  2E 23        
005782r 2  87 63 6D 70  	occ1:	.byte 2*64+7, "cmp.zxi"
005786r 2  2E 7A 78 69  
00578Ar 2               ;      (occ2:)
00578Ar 2               ;      (occ3:)
00578Ar 2  85 63 70 79  	occ4:	.byte 2*64+5, "cpy.z"
00578Er 2  2E 7A        
005790r 2  85 63 6D 70  	occ5:	.byte 2*64+5, "cmp.z"
005794r 2  2E 7A        
005796r 2  85 64 65 63  	occ6:	.byte 2*64+5, "dec.z"
00579Ar 2  2E 7A        
00579Cr 2  86 73 6D 62  	occ7:	.byte 2*64+6, "smb4.z"
0057A0r 2  34 2E 7A     
0057A3r 2  43 69 6E 79  	occ8:	.byte 1*64+3, "iny"
0057A7r 2  85 63 6D 70  	occ9:	.byte 2*64+5, "cmp.#"
0057ABr 2  2E 23        
0057ADr 2  43 64 65 78  	occa:	.byte 1*64+3, "dex"
0057B1r 2               ;      (occb:)
0057B1r 2  C3 63 70 79  	occc:	.byte 3*64+3, "cpy"
0057B5r 2  C3 63 6D 70  	occd:	.byte 3*64+3, "cmp"
0057B9r 2  C3 64 65 63  	occe:	.byte 3*64+3, "dec"
0057BDr 2  C4 62 62 73  	occf:	.byte 3*64+4, "bbs4"
0057C1r 2  34           
0057C2r 2               
0057C2r 2  83 62 6E 65  	ocd0:	.byte 2*64+3, "bne"
0057C6r 2  87 63 6D 70  	ocd1:	.byte 2*64+7, "cmp.ziy"
0057CAr 2  2E 7A 69 79  
0057CEr 2  86 63 6D 70  	ocd2:	.byte 2*64+6, "cmp.zi"
0057D2r 2  2E 7A 69     
0057D5r 2               ;      (ocd3:)
0057D5r 2               ;      (ocd4:)
0057D5r 2  86 63 6D 70  	ocd5:	.byte 2*64+6, "cmp.zx"
0057D9r 2  2E 7A 78     
0057DCr 2  86 64 65 63  	ocd6:	.byte 2*64+6, "dec.zx"
0057E0r 2  2E 7A 78     
0057E3r 2  86 73 6D 62  	ocd7:	.byte 2*64+6, "smb5.z"
0057E7r 2  35 2E 7A     
0057EAr 2  43 63 6C 64  	ocd8:	.byte 1*64+3, "cld"
0057EEr 2  C5 63 6D 70  	ocd9:	.byte 3*64+5, "cmp.y"
0057F2r 2  2E 79        
0057F4r 2  43 70 68 78  	ocda:	.byte 1*64+3, "phx"
0057F8r 2               ;      (ocdb:)
0057F8r 2               ;      (ocdc:)
0057F8r 2  C5 63 6D 70  	ocdd:	.byte 3*64+5, "cmp.x"
0057FCr 2  2E 78        
0057FEr 2  C5 64 65 63  	ocde:	.byte 3*64+5, "dec.x"
005802r 2  2E 78        
005804r 2  C4 62 62 73  	ocdf:	.byte 3*64+4, "bbs5"
005808r 2  35           
005809r 2               
005809r 2  85 63 70 78  	oce0:	.byte 2*64+5, "cpx.#"
00580Dr 2  2E 23        
00580Fr 2  87 73 62 63  	oce1:	.byte 2*64+7, "sbc.zxi"
005813r 2  2E 7A 78 69  
005817r 2               ;      (oce2:)
005817r 2               ;      (oce3:)
005817r 2  85 63 70 78  	oce4:	.byte 2*64+5, "cpx.z"
00581Br 2  2E 7A        
00581Dr 2  85 73 62 63  	oce5:	.byte 2*64+5, "sbc.z"
005821r 2  2E 7A        
005823r 2  85 69 6E 63  	oce6:	.byte 2*64+5, "inc.z"
005827r 2  2E 7A        
005829r 2  86 73 6D 62  	oce7:	.byte 2*64+6, "smb6.z"
00582Dr 2  36 2E 7A     
005830r 2  43 69 6E 78  	oce8:	.byte 1*64+3, "inx"
005834r 2  85 73 62 63  	oce9:	.byte 2*64+5, "sbc.#"
005838r 2  2E 23        
00583Ar 2  43 6E 6F 70  	ocea:	.byte 1*64+3, "nop"
00583Er 2               ;      (oceb:)
00583Er 2  C3 63 70 78  	ocec:	.byte 3*64+3, "cpx"
005842r 2  C3 73 62 63  	oced:	.byte 3*64+3, "sbc"
005846r 2  C3 69 6E 63  	ocee:	.byte 3*64+3, "inc"
00584Ar 2  C4 62 62 73  	ocef:	.byte 3*64+4, "bbs6"
00584Er 2  36           
00584Fr 2               
00584Fr 2  83 62 65 71  	ocf0:	.byte 2*64+3, "beq"
005853r 2  87 73 62 63  	ocf1:	.byte 2*64+7, "sbc.ziy"
005857r 2  2E 7A 69 79  
00585Br 2  86 73 62 63  	ocf2:	.byte 2*64+6, "sbc.zi"
00585Fr 2  2E 7A 69     
005862r 2               ;      (ocf3:)
005862r 2               ;      (ocf4:)
005862r 2  86 73 62 63  	ocf5:	.byte 2*64+6, "sbc.zx"
005866r 2  2E 7A 78     
005869r 2  86 69 6E 63  	ocf6:	.byte 2*64+6, "inc.zx"
00586Dr 2  2E 7A 78     
005870r 2  86 73 6D 62  	ocf7:	.byte 2*64+6, "smb7.z"
005874r 2  37 2E 7A     
005877r 2  43 73 65 64  	ocf8:	.byte 1*64+3, "sed"
00587Br 2  C5 73 62 63  	ocf9:	.byte 3*64+5, "sbc.y"
00587Fr 2  2E 79        
005881r 2  43 70 6C 78  	ocfa:	.byte 1*64+3, "plx"
005885r 2               ;      (ocfb:)
005885r 2               ;      (ocfc:)
005885r 2  C5 73 62 63  	ocfd:	.byte 3*64+5, "sbc.x"
005889r 2  2E 78        
00588Br 2  C5 69 6E 63  	ocfe:	.byte 3*64+5, "inc.x"
00588Fr 2  2E 78        
005891r 2  C4 62 62 73  	ocff:	.byte 3*64+4, "bbs7"
005895r 2  37           
005896r 2               
005896r 2                       ; Common routine for opcodes that are not supported by the 65c02
005896r 2  01 3F        	oc__:	.byte 1, "?"
005898r 2               
005898r 2               ; used to calculate size of assembled disassembler code
005898r 2               disassembler_end:
005898r 2               
005898r 1               .endif
005898r 1               
005898r 1               .segment "DATA"
005898r 1               .include "../../utils.s"
005898r 2               ;  print a 16-bit integer
005898r 2               ; lsb in x, msb in a
005898r 2               
005898r 2               .segment "ZEROPAGE": zeropage
00004Cr 2  xx xx        util_tmp: .res 2
00004Er 2               
00004Er 2               .segment "BSS"
000902r 2  xx xx        util_tmp_var: .res 2
000904r 2  xx xx xx xx  pad: .res 4
000908r 2               
000908r 2               .segment "DATA"
005898r 2               
005898r 2               print16:
005898r 2  8D rr rr         sta acc+1
00589Br 2  8E rr rr         stx acc
00589Er 2               
00589Er 2  A2 04            ldx #4
0058A0r 2               nextdig:
0058A0r 2  20 rr rr         jsr div
0058A3r 2  AD rr rr         lda ext
0058A6r 2  9D rr rr         sta num,x
0058A9r 2  CA               dex
0058AAr 2  10 F4            bpl nextdig
0058ACr 2               
0058ACr 2               firstdig:
0058ACr 2  E8               inx
0058ADr 2  E0 05            cpx #5
0058AFr 2  F0 17            beq print0
0058B1r 2  BD rr rr         lda num,x
0058B4r 2  F0 F6            beq firstdig
0058B6r 2               
0058B6r 2               ptnxtdig:
0058B6r 2  18               clc
0058B7r 2  69 30            adc #'0'
0058B9r 2  20 rr rr         jsr kernel_putc
0058BCr 2  E8               inx
0058BDr 2  E0 05            cpx #5
0058BFr 2  F0 06            beq pt16done
0058C1r 2  BD rr rr         lda num,x
0058C4r 2  4C rr rr         jmp ptnxtdig
0058C7r 2               
0058C7r 2               pt16done:
0058C7r 2  60               rts
0058C8r 2               
0058C8r 2               print0:
0058C8r 2  A9 30            lda #'0'
0058CAr 2  20 rr rr         jsr kernel_putc
0058CDr 2  60               rts
0058CEr 2               
0058CEr 2  00 00 00 00  num: .byte 0,0,0,0,0
0058D2r 2  00           
0058D3r 2               
0058D3r 2               ; 16/16-bit division, from the fridge
0058D3r 2               ; acc/aux -> acc, remainder in ext
0058D3r 2               div:
0058D3r 2  A9 00            lda #0
0058D5r 2  8D rr rr         sta ext+1
0058D8r 2  A0 10            ldy #$10
0058DAr 2               dloop:
0058DAr 2  0E rr rr         asl acc
0058DDr 2  2E rr rr         rol acc+1
0058E0r 2  2A               rol
0058E1r 2  2E rr rr         rol ext+1
0058E4r 2  48               pha
0058E5r 2  CD rr rr         cmp aux
0058E8r 2  AD rr rr         lda ext+1
0058EBr 2  ED rr rr         sbc aux+1
0058EEr 2  90 0B            bcc div2
0058F0r 2  8D rr rr         sta ext+1
0058F3r 2  68               pla
0058F4r 2  ED rr rr         sbc aux
0058F7r 2  48               pha
0058F8r 2  EE rr rr         inc acc
0058FBr 2               div2:
0058FBr 2  68               pla
0058FCr 2  88               dey
0058FDr 2  D0 DB            bne dloop
0058FFr 2  8D rr rr         sta ext
005902r 2  60               rts
005903r 2               
005903r 2  00 00        acc: .word 0
005905r 2  0A 00        aux: .word 10 ; constant
005907r 2  00 00        ext: .word 0
005909r 2               
005909r 2               
005909r 2               
005909r 2               calculate_free_mem:
005909r 2                   ; load dictionary address
005909r 2                   ; fill with $55 until ram_end
005909r 2                   ; read and check same
005909r 2                   ; fill again with zeroes
005909r 2               
005909r 2  9C rr rr         stz util_tmp_var
00590Cr 2  9C rr rr         stz util_tmp_var + 1
00590Fr 2               
00590Fr 2  A0 00            ldy #0
005911r 2               @loop:
005911r 2  A9 55            lda #$55
005913r 2  91 rr            sta (util_tmp), y        ; store to mem address
005915r 2  D1 rr            cmp (util_tmp), y        ; compare to what is now there
005917r 2  D0 19            bne @exit               ; no equal, stop couting and exit
005919r 2  A9 00            lda #0                  ; zero the memory again
00591Br 2  91 rr            sta (util_tmp), y
00591Dr 2  EE rr rr         inc util_tmp_var
005920r 2  D0 03            bne @incok
005922r 2  EE rr rr         inc util_tmp_var + 1
005925r 2               @incok:
005925r 2  C8               iny
005926r 2  D0 E9            bne @loop
005928r 2  A5 rr            lda util_tmp + 1
00592Ar 2  C9 80            cmp #>ram_end
00592Cr 2  B0 04            bcs @exit
00592Er 2  E6 rr            inc util_tmp + 1
005930r 2  80 DF            bra @loop
005932r 2               @exit:
005932r 2  60               rts
005933r 2               
005933r 2               
005933r 2               
005933r 2               print_message:
005933r 2  68           	pla					; get return address from stack
005934r 2  85 rr        	sta util_tmp
005936r 2  68           	pla
005937r 2  85 rr        	sta util_tmp + 1
005939r 2               
005939r 2  80 03        	bra @inc
00593Br 2               @print:
00593Br 2  20 rr rr     	jsr kernel_putc
00593Er 2               
00593Er 2               @inc:
00593Er 2  E6 rr        	inc util_tmp
005940r 2  D0 02        	bne @inced
005942r 2  E6 rr        	inc util_tmp + 1
005944r 2               @inced:
005944r 2  B2 rr        	lda (util_tmp)
005946r 2  D0 F3        	bne @print
005948r 2  A5 rr        	lda util_tmp + 1
00594Ar 2  48           	pha
00594Br 2  A5 rr        	lda util_tmp
00594Dr 2  48           	pha
00594Er 2               print_message_end:
00594Er 2  60           	rts
00594Fr 2               
00594Fr 2               
00594Fr 2               print_zp_index_string:
00594Fr 2               @loop:
00594Fr 2  B1 rr            lda (util_tmp), y
005951r 2  F0 06            beq @exit
005953r 2  20 rr rr         jsr kernel_putc
005956r 2  C8               iny
005957r 2  D0 F6            bne @loop
005959r 2               @exit:
005959r 2  60               rts
00595Ar 2               
00595Ar 2               
00595Ar 2               output_ascii:
00595Ar 2               ; """Convert byte in A to two ASCII hex digits and EMIT them"""
00595Ar 2  48               pha
00595Br 2  4A               lsr             ; convert high nibble first
00595Cr 2  4A               lsr
00595Dr 2  4A               lsr
00595Er 2  4A               lsr
00595Fr 2  20 rr rr         jsr output_ascii_nibble_to_ascii
005962r 2  68               pla
005963r 2               
005963r 2                   ; fall through to _nibble_to_ascii
005963r 2               
005963r 2               output_ascii_nibble_to_ascii:
005963r 2               ; """Private helper function for byte_to_ascii: Print lower nibble
005963r 2               ; of A and and EMIT it. This does the actual work.
005963r 2               ; """
005963r 2  29 0F            and #$0F
005965r 2  09 30            ora #'0'
005967r 2  C9 3A            cmp #$3A        ; '9+1
005969r 2  90 02            bcc @1
00596Br 2  69 06            adc #$06
00596Dr 2               
00596Dr 2               @1:
00596Dr 2  20 rr rr         jsr kernel_putc
005970r 2  60               rts
005971r 2               
005971r 1               
005971r 1               .include "../../minix.s"
005971r 2               
005971r 2               
005971r 2               ; This is a library to use a minix file system on the 65C02 CMOS processor.
005971r 2               ; it requires 2 bytes in zeropage, 100 bytes for variables in RAM
005971r 2               ; and a buffer of 1024 bytes provided by the user of this library.
005971r 2               ; It also requires the caller to provide two subroutines:
005971r 2               ; - an io_read_sector subroutine
005971r 2               ; - an io_write_sector subroutine
005971r 2               ; both with the same two parameters :
005971r 2               ; io_current_sector: a 4 byte variable in RAM to indicate which sector to read/write like LBA addressing
005971r 2               ; io_buffer_ptr: a zeropage pointer to a buffer in RAM where the sector data will be stored
005971r 2               ; or where it will be found to be written to disk
005971r 2               ; The buffer will be overwriten by many routines.
005971r 2               ; The only time it is safe to write to it is just before calling file_write_data
005971r 2               ; This library is designed to be assembled with ca65 but it should be
005971r 2               ; fairly easy to adapt to another assembler.
005971r 2               ; Compatible only with MINIX 1 filesystem with 30 character filenames
005971r 2               
005971r 2               ; References :
005971r 2               ; http://minix1.woodhull.com/faq/filesize.html
005971r 2               ; https://github.com/osxfuse/filesystems/blob/aee39765ffe32b426a1089f617d21bff387f5c91/filesystems-c/unixfs/minixfs/minixfs.c
005971r 2               ; http://ohm.hgesser.de/sp-ss2012/Intro-MinixFS.pdf
005971r 2               ; https://lass.cs.umass.edu/~shenoy/courses/spring20/lectures/Lec18.pdf
005971r 2               ; https://github.com/gdevic/minix1
005971r 2               ; Operating systems - Design and implementation by Andrew S. Tanenbaum
005971r 2               
005971r 2               ; PUBLIC DOMAIN
005971r 2               ; This library for the 65c02 is provided on an "as is" basis without any warranty
005971r 2               ; of any kind, including, without limitation, the implied warranties of
005971r 2               ; merchantability and fitness for a particular purpose and their equivalents
005971r 2               ; under the laws of any jurisdiction. Put briefly, use this at your own risk.
005971r 2               
005971r 2               ; Constants
005971r 2               MINIX_MAGIC_NUMBER = $138F		; minix fs, 30 char names
005971r 2               
005971r 2               ; These are the only two mode flags we care about
005971r 2               MINIX_REGULAR_FILE = $8000
005971r 2               MINIX_DIRECTORY = $4000
005971r 2               
005971r 2               MINIX_ROOT_INODE = 1            ; inodes are 1 indexed, so inode 1 is the first one
005971r 2               
005971r 2               ; zeropage variables, 2 bytes required
005971r 2               .segment "ZEROPAGE": zeropage
00004Er 2  xx xx        MINIX_PTR: .res 2
000050r 2               
000050r 2               .segment "BSS"
000908r 2               ; RAM storage, 100 bytes required
000908r 2               
000908r 2  xx xx        MINIX_CURRENT_BLOCK: .res 2 ; block to read
00090Ar 2  xx xx xx xx  MINIX_SECTOR: .res 4
00090Er 2  xx xx        MINIX_CURRENT_INODE: .res 2
000910r 2  xx xx        MINIX_CURRENT_DIR_INODE: .res 2
000912r 2  xx xx        MINIX_CURRENT_FILE_INODE: .res 2
000914r 2               
000914r 2  xx xx        MINIX_TMP: .res 2
000916r 2  xx xx        MINIX_FILESIZE_COMPARE: .res 2
000918r 2  xx           MINIX_ZONE_TO_READ: .res 1
000919r 2  xx           MINIX_ZONE_TO_WRITE: .res 1
00091Ar 2  xx xx        MINIX_SEARCH_INODE: .res 2
00091Cr 2  xx xx xx xx  MINIX_SEARCH_FILENAME: .res 30
000920r 2  xx xx xx xx  
000924r 2  xx xx xx xx  
00093Ar 2               
00093Ar 2               MINIX_SUPERBLOCK:
00093Ar 2  xx xx        MINIX_N_INODES: .res 2
00093Cr 2  xx xx        MINIX_N_ZONES: .res 2
00093Er 2  xx xx        MINIX_N_INODE_MAP_BLOCKS: .res 2
000940r 2  xx xx        MINIX_N_ZONE_MAP_BLOCKS: .res 2
000942r 2  xx xx        MINIX_FIRST_DATA_ZONE: .res 2       ;
000944r 2  xx xx        MINIX_LOG_ZONE_SIZE: .res 2         ; size of a data zone = 1024 << MINIX_LOG_ZONE_SIZE
000946r 2  xx xx xx xx  MINIX_MAX_FILE_SIZE: .res 4
00094Ar 2  xx xx        MINIX_MAGIC: .res 2
00094Cr 2  xx xx        MINIX_STATE: .res 2
00094Er 2               
00094Er 2               MINIX_DIRENT:
00094Er 2  xx xx        MINIX_INODE_NUMBER: .res 2
000950r 2  xx xx xx xx  MINIX_FILENAME: .res 30
000954r 2  xx xx xx xx  
000958r 2  xx xx xx xx  
00096Er 2               
00096Er 2               MINIX_INODE:
00096Er 2  xx xx        MINIX_INODE_MODE: .res 2
000970r 2  xx xx        MINIX_INODE_UID: .res 2
000972r 2  xx xx xx xx  MINIX_INODE_FILESIZE: .res 4
000976r 2  xx xx xx xx  MINIX_INODE_TIME: .res 4
00097Ar 2  xx           MINIX_INODE_GID: .res 1
00097Br 2  xx           MINIX_INODE_LINKS: .res 1
00097Cr 2  xx xx        MINIX_INODE_ZONE0: .res 2
00097Er 2  xx xx        MINIX_INODE_ZONE1: .res 2
000980r 2  xx xx        MINIX_INODE_ZONE2: .res 2
000982r 2  xx xx        MINIX_INODE_ZONE3: .res 2
000984r 2  xx xx        MINIX_INODE_ZONE4: .res 2
000986r 2  xx xx        MINIX_INODE_ZONE5: .res 2
000988r 2  xx xx        MINIX_INODE_ZONE6: .res 2
00098Ar 2  xx xx        MINIX_INODE_INDIRECT: .res 2
00098Cr 2  xx xx        MINIX_INODE_DOUBLE_INDIRECT: .res 2
00098Er 2               
00098Er 2               .segment "DATA"
005971r 2               
005971r 2  20 00        MINIX_DIRENT_JUMP: .byte $20, $0        ; size of a directory entry
005973r 2               
005973r 2               ; setup MINIX_CURRENT_BLOCK to indicate which block to read
005973r 2               ; the resulting block data will be in the buffer pointed to by io_buffer_ptr
005973r 2               ; he caller is reponsible for setting up io_buffer_ptr
005973r 2               ; returns with carry set on error
005973r 2               minix_read_block:
005973r 2  64 rr            stz io_current_sector                   ; zero current sector to read
005975r 2  64 rr            stz io_current_sector + 1
005977r 2  64 rr            stz io_current_sector + 2
005979r 2  64 rr            stz io_current_sector + 3
00597Br 2  9C rr rr         stz MINIX_SECTOR + 2                    ; zero top bytes of sector to read
00597Er 2  9C rr rr         stz MINIX_SECTOR + 3
005981r 2  AD rr rr 8D      cp16 MINIX_CURRENT_BLOCK, MINIX_SECTOR  ; copy current block number
005985r 2  rr rr AD rr  
005989r 2  rr 8D rr rr  
00598Dr 2  0E rr rr 2E      asl16 MINIX_SECTOR                      ; multiply by two to get first block sector number
005991r 2  rr rr        
005993r 2  90 02            bcc minix_read_block_noinc
005995r 2  E6 rr            inc io_current_sector + 2               ; increase higher byte if previous asl set the carry
005997r 2               minix_read_block_noinc:
005997r 2  AD rr rr 85      cp16  MINIX_SECTOR, io_current_sector  ; copy result to the sector to read
00599Br 2  rr AD rr rr  
00599Fr 2  85 rr        
0059A1r 2               
0059A1r 2  20 rr rr         jsr io_read_sector          ; read first sector
0059A4r 2  E6 rr            inc io_buffer_ptr + 1
0059A6r 2  E6 rr            inc io_buffer_ptr + 1       ; write to next buffer 512 block to get full 1024 block
0059A8r 2  E6 rr            inc io_current_sector       ; setup to read next sector
0059AAr 2  20 rr rr         jsr io_read_sector          ; Read next sector
0059ADr 2  C6 rr            dec io_buffer_ptr + 1       ; put buffer pointer back
0059AFr 2  C6 rr            dec io_buffer_ptr + 1
0059B1r 2                   ; one full block is now in the buffer pointed to by io_buffer_ptr
0059B1r 2  60               rts
0059B2r 2               
0059B2r 2               minix_write_block:
0059B2r 2  64 rr            stz io_current_sector                   ; zero current sector to read
0059B4r 2  64 rr            stz io_current_sector + 1
0059B6r 2  64 rr            stz io_current_sector + 2
0059B8r 2  64 rr            stz io_current_sector + 3
0059BAr 2  9C rr rr         stz MINIX_SECTOR + 2                    ; zero top bytes of sector to read
0059BDr 2  9C rr rr         stz MINIX_SECTOR + 3
0059C0r 2  AD rr rr 8D      cp16 MINIX_CURRENT_BLOCK, MINIX_SECTOR  ; copy current block number
0059C4r 2  rr rr AD rr  
0059C8r 2  rr 8D rr rr  
0059CCr 2  0E rr rr 2E      asl16 MINIX_SECTOR                      ; multiply by two to get first block sector number
0059D0r 2  rr rr        
0059D2r 2  90 02            bcc minix_write_block_noinc
0059D4r 2  E6 rr            inc io_current_sector + 2               ; increase higher byte if previous asl set the carry
0059D6r 2               minix_write_block_noinc:
0059D6r 2  AD rr rr 85      cp16  MINIX_SECTOR, io_current_sector  ; copy result to the sector to read
0059DAr 2  rr AD rr rr  
0059DEr 2  85 rr        
0059E0r 2  20 rr rr         jsr io_write_sector          ; read first sector
0059E3r 2  E6 rr            inc io_buffer_ptr + 1
0059E5r 2  E6 rr            inc io_buffer_ptr + 1       ; read from next buffer 512 block to get full 1024 block
0059E7r 2  E6 rr D0 0A      inc32 io_current_sector       ; setup to write to next sector
0059EBr 2  E6 rr D0 06  
0059EFr 2  E6 rr D0 02  
0059F5r 2  20 rr rr         jsr io_write_sector          ; Write next sector
0059F8r 2  C6 rr            dec io_buffer_ptr + 1       ; put buffer pointer back
0059FAr 2  C6 rr            dec io_buffer_ptr + 1
0059FCr 2                   ; one full block has now been written to disk
0059FCr 2  60               rts
0059FDr 2               
0059FDr 2               ; read the root inode
0059FDr 2               minix_read_root_inode:
0059FDr 2  A9 01            lda #MINIX_ROOT_INODE               ; set inode to root inode
0059FFr 2  8D rr rr         sta MINIX_CURRENT_INODE
005A02r 2  9C rr rr         stz MINIX_CURRENT_INODE + 1
005A05r 2               
005A05r 2  20 rr rr         jsr minix_read_inode                ; read the inode
005A08r 2               
005A08r 2                   ; check that it is a directory
005A08r 2  AD rr rr         lda MINIX_INODE_MODE+1
005A0Br 2  29 40            and #>MINIX_DIRECTORY
005A0Dr 2  F0 0A            beq minix_read_root_inode_fail
005A0Fr 2                   ; we have read root inode successfully
005A0Fr 2  A9 01            lda #MINIX_ROOT_INODE               ; save the root inode number to MINIX_CURRENT_DIR_INODE
005A11r 2  8D rr rr         sta MINIX_CURRENT_DIR_INODE         ; because this is the current directory
005A14r 2  9C rr rr         stz MINIX_CURRENT_DIR_INODE + 1
005A17r 2  18               clc
005A18r 2  60               rts
005A19r 2               minix_read_root_inode_fail:
005A19r 2  38               sec
005A1Ar 2  60               rts
005A1Br 2               
005A1Br 2               ; We read the root directory data into the memory buffer
005A1Br 2               minix_read_root:
005A1Br 2  20 rr rr         jsr minix_read_root_inode
005A1Er 2  B0 05            bcs @exit_fail
005A20r 2  20 rr rr         jsr minix_read_inode_data
005A23r 2  18               clc
005A24r 2  60               rts
005A25r 2               @exit_fail:
005A25r 2  38               sec
005A26r 2  60               rts
005A27r 2               
005A27r 2               minix_read_file:
005A27r 2  AD rr rr 8D      cp16 MINIX_CURRENT_FILE_INODE, MINIX_CURRENT_INODE
005A2Br 2  rr rr AD rr  
005A2Fr 2  rr 8D rr rr  
005A33r 2  20 rr rr         jsr minix_read_inode                ; read the inode
005A36r 2               
005A36r 2                   ; check that it is a file
005A36r 2  AD rr rr         lda MINIX_INODE_MODE+1
005A39r 2  29 80            and #>MINIX_REGULAR_FILE
005A3Br 2  F0 05            beq @exit_fail
005A3Dr 2               
005A3Dr 2  20 rr rr         jsr minix_read_inode_data           ; the first block of data for the file is now in the buffer
005A40r 2  18               clc
005A41r 2  60               rts
005A42r 2               @exit_fail:
005A42r 2  38               sec
005A43r 2  60               rts
005A44r 2               
005A44r 2               ; Find the inode corresponding to the given filename
005A44r 2               minix_find_inode_for_filename:
005A44r 2                   ; get the data for the current dir inode
005A44r 2                   ; to do that, we first set MINIX_CURRENT_INODE to MINIX_CURRENT_DIR_INODE,
005A44r 2                   ; which contains the inode for the current directory
005A44r 2                   ; then we read the inode data
005A44r 2                   ; and loop through it until we find the right filename
005A44r 2                   ; and then we set MINIX_CURRENT_INODE to the found inode
005A44r 2                   ; and set the carry to indicate success
005A44r 2                   ; otherwise, clear the carry to indicate failure
005A44r 2                   ; the filename to look for is in MINIX_SEARCH_FILENAME
005A44r 2                   ; the caller has to zero these 30 bytes before setting the filename to search
005A44r 2                   ; at the beginning of this buffer
005A44r 2               
005A44r 2  AD rr rr 8D      cp16 MINIX_CURRENT_DIR_INODE, MINIX_CURRENT_INODE
005A48r 2  rr rr AD rr  
005A4Cr 2  rr 8D rr rr  
005A50r 2  20 rr rr         jsr minix_read_inode                ; read the inode for the directory
005A53r 2  20 rr rr         jsr minix_read_inode_data           ; the data for the directory is now in the buffer
005A56r 2                   ; loop through the buffer to check the filename
005A56r 2  5A               phy
005A57r 2  A5 rr 85 rr      cp16 io_buffer_ptr, MINIX_PTR       ; copy the current io buffer pointer to our ZP pointer
005A5Br 2  A5 rr 85 rr  
005A5Fr 2                   ; load first entry
005A5Fr 2  A0 00            ldy #0
005A61r 2               @loop:
005A61r 2  B1 rr            lda (MINIX_PTR), y                    ; check low byte of inode number
005A63r 2  D0 07            bne @inode_not_zero                   ; if it's not 0 it means we have a file here
005A65r 2  C8               iny                                   ; check high byte of inode number
005A66r 2  B1 rr            lda (MINIX_PTR), y                    ; if it's not 0 it means we have a file here
005A68r 2  D0 03            bne @inode_not_zero2
005A6Ar 2               
005A6Ar 2  80 35            bra @exit_fail                        ; otherwise, there is nothing here nor beyond, exit now
005A6Cr 2               
005A6Cr 2               @inode_not_zero:
005A6Cr 2  C8               iny             ; we get here without having incremented y, so do it twice
005A6Dr 2               @inode_not_zero2:   ; if we get here directly, y has already been incremented once
005A6Dr 2  C8               iny             ; increment y again to point to start of file
005A6Er 2               
005A6Er 2                   ; and then check if the name corresponds
005A6Er 2               @inner:
005A6Er 2  B1 rr            lda (MINIX_PTR), y
005A70r 2  F0 1F            beq @exit_success                   ; we reached the end of the filename, success
005A72r 2  D9 rr rr         cmp MINIX_SEARCH_FILENAME-2, y
005A75r 2  D0 07            bne @next
005A77r 2  C8               iny                                 ; increase y by one to check next character
005A78r 2  C0 20            cpy #32                             ; check if we reached the end of the filename
005A7Ar 2  90 F2            bcc @inner                          ; if not, keep checking
005A7Cr 2  80 13            bra @exit_success                   ; file found
005A7Er 2               @next:
005A7Er 2                   ; increase MINIX_PTR by $20 to point to start of next entry
005A7Er 2  18 A5 rr 6D      add16 MINIX_PTR, MINIX_DIRENT_JUMP, MINIX_PTR
005A82r 2  rr rr 85 rr  
005A86r 2  A5 rr 6D rr  
005A8Dr 2  A0 00            ldy #0
005A8Fr 2  80 D0            bra @loop
005A91r 2               @exit_success:
005A91r 2  A0 00            ldy #0
005A93r 2  B1 rr            lda (MINIX_PTR), y
005A95r 2  8D rr rr         sta MINIX_CURRENT_FILE_INODE          ; save low byte of inode number to MINIX_CURRENT_FILE_INODE
005A98r 2  C8               iny
005A99r 2  B1 rr            lda (MINIX_PTR), y
005A9Br 2  8D rr rr         sta MINIX_CURRENT_FILE_INODE + 1          ; save high byte of inode number to MINIX_CURRENT_FILE_INODE
005A9Er 2  7A               ply
005A9Fr 2  18               clc
005AA0r 2  60               rts
005AA1r 2               @exit_fail:
005AA1r 2  7A               ply
005AA2r 2  38               sec
005AA3r 2  60               rts
005AA4r 2               
005AA4r 2               
005AA4r 2               
005AA4r 2               ; once an inode is loaded, read the file data
005AA4r 2               ; if the carry is set on exit, it means there is data left to read, so we should call this routine again
005AA4r 2               ; if the carry is unset, we reached the end of the data and should stop reading
005AA4r 2               minix_read_inode_data:
005AA4r 2  5A               phy
005AA5r 2                   ; check if zone to read is zero.
005AA5r 2  AD rr rr         lda MINIX_ZONE_TO_READ
005AA8r 2  D0 0C            bne @getzone
005AAAr 2                   ; if it is, copy the two high bytes of file size to a temporary space
005AAAr 2  AD rr rr 8D      cp16 MINIX_INODE_FILESIZE, MINIX_FILESIZE_COMPARE
005AAEr 2  rr rr AD rr  
005AB2r 2  rr 8D rr rr  
005AB6r 2                   ; to be decremented each time we come here
005AB6r 2               @getzone:
005AB6r 2  AD rr rr         lda MINIX_ZONE_TO_READ
005AB9r 2  C9 07            cmp #7                                      ; we only handle the direct zones for now
005ABBr 2  B0 4F            bcs @exit_end                                   ; so we exit if we are trying to read zone 7 or higher
005ABDr 2  8D rr rr         sta MINIX_TMP                               ; copy current zone to temporary
005AC0r 2  9C rr rr         stz MINIX_TMP + 1
005AC3r 2  0E rr rr         asl MINIX_TMP                               ; multiply by two because we want the byte offset
005AC6r 2  18               clc                                         ; add the zone offset to the address where zone 0 is stored
005AC7r 2  A9 rr            lda #<MINIX_INODE_ZONE0
005AC9r 2  6D rr rr         adc MINIX_TMP
005ACCr 2  85 rr            sta MINIX_PTR
005ACEr 2  A9 rr            lda #>MINIX_INODE_ZONE0
005AD0r 2  6D rr rr         adc MINIX_TMP + 1
005AD3r 2  85 rr            sta MINIX_PTR + 1
005AD5r 2                   ; we now have the address where we will find the zone to read in MINIX_PTR
005AD5r 2  A0 00            ldy #0
005AD7r 2  B1 rr            lda (MINIX_PTR),y                 ; we copy that data to the block to read
005AD9r 2  8D rr rr         sta MINIX_CURRENT_BLOCK
005ADCr 2  C8               iny
005ADDr 2  B1 rr            lda (MINIX_PTR), y
005ADFr 2  8D rr rr         sta MINIX_CURRENT_BLOCK+1
005AE2r 2               
005AE2r 2  20 rr rr         jsr minix_read_block                    ; and we read it
005AE5r 2                   ; add a check for file length
005AE5r 2                   ; we should reduce it by 1024 each time this function is called
005AE5r 2  A0 04            ldy #4
005AE7r 2               @dec_loop:
005AE7r 2  AD rr rr D0      dec16zero MINIX_FILESIZE_COMPARE    ; decrement the two high bytes of the filesize 4 times: this reduces the file size left by 1024
005AEBr 2  05 CE rr rr  
005AEFr 2  F0 08 CE rr  
005AF9r 2  F0 03            beq @end_loop                       ; if we reach zero on the high bytes, we have only one block left to read for the remainder of the file so exit now
005AFBr 2  88               dey
005AFCr 2  D0 E9            bne @dec_loop
005AFEr 2               
005AFEr 2               @end_loop:
005AFEr 2                   ; TODO check Y here to see if we whould read another block or not
005AFEr 2                   ; if y is > 0 then we should read another block
005AFEr 2                   ; otherwise, the end of the data is in the block we just read
005AFEr 2  C0 01            cpy #1
005B00r 2  B0 0A            bcs @exit_end
005B02r 2  EE rr rr D0      inc16 MINIX_ZONE_TO_READ            ; we increment MINIX_ZONE_TO_READ for the next time we get called
005B06r 2  03 EE rr rr  
005B0Ar 2  80 03            bra @exit_continue
005B0Cr 2               @exit_end:
005B0Cr 2  7A               ply
005B0Dr 2  18               clc
005B0Er 2  60               rts
005B0Fr 2               @exit_continue:
005B0Fr 2  7A               ply
005B10r 2  38               sec
005B11r 2  60               rts
005B12r 2               
005B12r 2               ; Node name to create is in MINIX_FILENAME
005B12r 2               ; the directory in which to create it is in MINIX_CURRENT_DIR_INODE
005B12r 2               ; some data can already be set in MINIX_INODE
005B12r 2               ; Node mode should be set in MINIX_INODE_MODE
005B12r 2               ; this will indicate if the node is a file or directory
005B12r 2               minix_mknod:
005B12r 2  5A               phy
005B13r 2  DA               phx
005B14r 2                   ; find a free inode by looking at the bitmap
005B14r 2  9C rr rr         stz MINIX_CURRENT_BLOCK + 1
005B17r 2  A9 02            lda #2                          ; the first block of the inode map is block 2
005B19r 2  8D rr rr         sta MINIX_CURRENT_BLOCK         ; so read that block now
005B1Cr 2  AD rr rr 8D      cp16 MINIX_N_INODE_MAP_BLOCKS, MINIX_TMP    ;save the number of inode map blocks temporarily
005B20r 2  rr rr AD rr  
005B24r 2  rr 8D rr rr  
005B28r 2               @new_block:
005B28r 2  A5 rr 85 rr      cp16 io_buffer_ptr, MINIX_PTR               ; copy the io buffer pointer to our own
005B2Cr 2  A5 rr 85 rr  
005B30r 2  20 rr rr         jsr minix_read_block
005B33r 2  A2 04            ldx #4                          ; set X to 4 (number of pages to read)
005B35r 2               @outer:
005B35r 2  DA               phx                             ; and save to stack
005B36r 2                   ; find the first free inode slot
005B36r 2  A0 00            ldy #0
005B38r 2               @loop:
005B38r 2  A2 00            ldx #0
005B3Ar 2  B1 rr            lda (MINIX_PTR), y              ; load current byte
005B3Cr 2  F0 2F            beq @found                      ; if it is zero, at least the first bit is free
005B3Er 2                   ; otherwise, rotate A until the carry get unset
005B3Er 2               @inner:
005B3Er 2  6A               ror                             ; rotate right
005B3Fr 2  90 2C            bcc @found                      ; if the carry is clear, it means X is now the number of the free bit
005B41r 2  E8               inx                             ; increase X to keep track of which bit we are looking at
005B42r 2  E0 08            cpx #8                          ; if X reaches 8, we went around the byte and found no free slot
005B44r 2  90 F8            bcc @inner                      ; try again with next bit
005B46r 2  C8               iny                             ; increase Y to get next byte
005B47r 2  D0 EF            bne @loop                       ; if Y did not wrap around, do next byte
005B49r 2  E6 rr            inc MINIX_PTR + 1               ; if it did wraparound, do next page
005B4Br 2  FA               plx                             ; get X from stack
005B4Cr 2  CA               dex                             ; decrement X to check number of pages read
005B4Dr 2  D0 E6            bne @outer                      ; X is not zero yet, read another page
005B4Fr 2               
005B4Fr 2                   ; we are at the end of the block, read another one if necessary
005B4Fr 2  AD rr rr D0      dec16zero MINIX_TMP             ; decrement the number of blocks in inode map by one
005B53r 2  05 CE rr rr  
005B57r 2  F0 08 CE rr  
005B61r 2  F0 3D            beq @not_found                  ; if we reached zero, we have not found a free inode
005B63r 2  EE rr rr D0      inc16 MINIX_CURRENT_BLOCK       ; otherwise, increment block to read
005B67r 2  03 EE rr rr  
005B6Br 2  80 BB            bra @new_block                  ; and do the whole circus again
005B6Dr 2               
005B6Dr 2               @found:                             ; we found a free inode
005B6Dr 2                   ; now we need to multiply Y by 8 and add X to find the free inode number
005B6Dr 2                   ; we don't need MINIX_TMP anymore, so use it to pultiply Y by 8
005B6Dr 2  9C rr rr         stz MINIX_TMP + 1           ; set high byte to zero
005B70r 2  8C rr rr         sty MINIX_TMP               ; set low byte to Y
005B73r 2  DA               phx                         ; save X on stack
005B74r 2  A2 03            ldx #3
005B76r 2               @mult_loop:
005B76r 2  0E rr rr 2E      asl16 MINIX_TMP             ; shift left 3 times
005B7Ar 2  rr rr        
005B7Cr 2  CA               dex
005B7Dr 2  D0 F7            bne @mult_loop
005B7Fr 2  68               pla                         ; pull X in A
005B80r 2  6D rr rr         adc MINIX_TMP               ; add low byte of inode number
005B83r 2  8D rr rr         sta MINIX_TMP               ; store to low byte
005B86r 2  90 08            bcc @carry_unset            ; skip next addition if carry was unset
005B88r 2  AD rr rr         lda MINIX_TMP + 1           ; load high byte
005B8Br 2  69 00            adc #0                      ; add carry if there is one
005B8Dr 2  8D rr rr         sta MINIX_TMP + 1           ; store result in high byte
005B90r 2               @carry_unset:
005B90r 2                   ; we now have the inode number in MINIX_TMP
005B90r 2  AD rr rr 8D      cp16 MINIX_TMP, MINIX_CURRENT_INODE         ; copy it to MINIX_CURRENT_INODE to prepare for write
005B94r 2  rr rr AD rr  
005B98r 2  rr 8D rr rr  
005B9Cr 2                   ; we have to generate the inode data
005B9Cr 2               
005B9Cr 2                   ; find a free data zone by looking at the zone bitmap
005B9Cr 2               
005B9Cr 2                   ; create the inode data structure for the new file
005B9Cr 2                   ; with a size of zero
005B9Cr 2                   ; write the inode to disk
005B9Cr 2                   ; get the data for the directory
005B9Cr 2                   ; add a line with the inode number for the new file
005B9Cr 2                   ; and it's filename
005B9Cr 2  18               clc
005B9Dr 2               @exit:
005B9Dr 2  FA               plx
005B9Er 2  7A               ply
005B9Fr 2  60               rts
005BA0r 2               @not_found:
005BA0r 2  38               sec
005BA1r 2  80 FA            bra @exit
005BA3r 2               
005BA3r 2               
005BA3r 2               ; Once an inode has been written, we can write the file data
005BA3r 2               ; This routine only writes one block of data at a time, from the buffer pointed to by io_buffer_ptr
005BA3r 2               ; and in the data zone number MINIX_ZONE_TO_WRITE
005BA3r 2               ; this is a reference to the number of the zone in the inode data structure, which itself contains
005BA3r 2               ; the number of the block to write to.
005BA3r 2               ; there is no check for file length, it is up to  the user to manage that.
005BA3r 2               ; This is to allow read / modify / write per block
005BA3r 2               ; the zone to write is incremented at the end of this routine, though
005BA3r 2               ; so if the file data does not exceed one block it will cause a problem
005BA3r 2               ; if the file data ecxeeds one block, this routine expects
005BA3r 2               ; the zones to be set in the inode data in RAM before being called
005BA3r 2               minix_write_data:
005BA3r 2  5A               phy
005BA4r 2                   ; check if zone to read is zero.
005BA4r 2  AD rr rr         lda MINIX_ZONE_TO_WRITE
005BA7r 2  C9 07            cmp #7                                      ; we only handle the direct zones for now
005BA9r 2  B0 30            bcs @exit_end                               ; so we exit if we are trying to write to zone 7 or higher
005BABr 2  8D rr rr         sta MINIX_TMP                               ; copy current zone to temporary
005BAEr 2  9C rr rr         stz MINIX_TMP + 1
005BB1r 2  0E rr rr         asl MINIX_TMP                               ; multiply by two because we want the byte offset into the inode
005BB4r 2  18               clc                                         ; add the zone byte offset to the address where zone 0 is stored
005BB5r 2  A9 rr            lda #<MINIX_INODE_ZONE0
005BB7r 2  6D rr rr         adc MINIX_TMP
005BBAr 2  85 rr            sta MINIX_PTR
005BBCr 2  A9 rr            lda #>MINIX_INODE_ZONE0
005BBEr 2  6D rr rr         adc MINIX_TMP + 1
005BC1r 2  85 rr            sta MINIX_PTR + 1
005BC3r 2                   ; we now have the address where we will find the zone to read in MINIX_TMP
005BC3r 2  A0 00            ldy #0
005BC5r 2  B1 rr            lda (MINIX_PTR),y                 ; we copy that data to the block to read
005BC7r 2  8D rr rr         sta MINIX_CURRENT_BLOCK
005BCAr 2  C8               iny
005BCBr 2  B1 rr            lda (MINIX_PTR), y
005BCDr 2  8D rr rr         sta MINIX_CURRENT_BLOCK+1
005BD0r 2               
005BD0r 2  20 rr rr         jsr minix_write_block                    ; and we write it
005BD3r 2               
005BD3r 2  EE rr rr D0      inc16 MINIX_ZONE_TO_WRITE            ; we increment MINIX_ZONE_TO_WRITE for the next time we get called
005BD7r 2  03 EE rr rr  
005BDBr 2               @exit_end:
005BDBr 2  7A               ply
005BDCr 2  60               rts
005BDDr 2               
005BDDr 2               
005BDDr 2               
005BDDr 2               ; read one inode entry into RAM data structure
005BDDr 2               ; the number of the inode to read is in MINIX_CURRENT_INODE
005BDDr 2               minix_read_inode:
005BDDr 2  5A               phy
005BDEr 2                   ; MINIX_CURRENT_INODE contains the number of the inode we have to read to find the data zone
005BDEr 2                   ; the blocks with inodes start at block 1 + MINIX_N_INODE_MAP_BLOCKS + MINIX_N_ZONE_MAP_BLOCKS
005BDEr 2  AD rr rr 8D      cp16 MINIX_N_INODE_MAP_BLOCKS, MINIX_CURRENT_BLOCK    ; copy number of inode map blocks to temporary
005BE2r 2  rr rr AD rr  
005BE6r 2  rr 8D rr rr  
005BEAr 2  EE rr rr D0      inc16 MINIX_CURRENT_BLOCK                             ; add 1 to account for superblock
005BEEr 2  03 EE rr rr  
005BF2r 2  EE rr rr D0      inc16 MINIX_CURRENT_BLOCK                             ; add 1 to account for blank root block
005BF6r 2  03 EE rr rr  
005BFAr 2  18 AD rr rr      add16 MINIX_CURRENT_BLOCK, MINIX_N_ZONE_MAP_BLOCKS, MINIX_CURRENT_BLOCK ; add the number of zone map blocks
005BFEr 2  6D rr rr 8D  
005C02r 2  rr rr AD rr  
005C0Dr 2               
005C0Dr 2  AD rr rr D0      dec16 MINIX_CURRENT_INODE       ; since inodes are 1 indexed, we need to decrement it by one
005C11r 2  03 CE rr rr  
005C15r 2  CE rr rr     
005C18r 2               
005C18r 2                   ; we have the first block with inodes in MINIX_CURRENT_BLOCK
005C18r 2                   ; now we have to add the number of blocks necessary to reach the MINIX_CURRENT_INODEth block
005C18r 2                   ; each inode is 32 bytes, which means there are 32 in each block
005C18r 2                   ; so let's divide MINIX_CURRENT_INODE by 32 and add it to the current block to get the real block where that inode is located
005C18r 2               
005C18r 2  AD rr rr 8D      cp16 MINIX_CURRENT_INODE, MINIX_TMP
005C1Cr 2  rr rr AD rr  
005C20r 2  rr 8D rr rr  
005C24r 2  A0 05            ldy #5
005C26r 2               minix_read_inode_loop1:
005C26r 2  4E rr rr 6E      lsr16 MINIX_TMP
005C2Ar 2  rr rr        
005C2Cr 2  88               dey
005C2Dr 2  D0 F7            bne minix_read_inode_loop1
005C2Fr 2               
005C2Fr 2  18 AD rr rr      add16 MINIX_CURRENT_BLOCK, MINIX_TMP, MINIX_CURRENT_BLOCK
005C33r 2  6D rr rr 8D  
005C37r 2  rr rr AD rr  
005C42r 2               
005C42r 2                   ; MINIX_CURRENT_BLOCK is set up, read data
005C42r 2  20 rr rr         jsr minix_read_block            ; read block to buffer
005C45r 2               
005C45r 2                   ; the offset into the block is calculated by taking MINIX_CURRENT_INODE,
005C45r 2                   ; dividing by 32 and taking the remainder
005C45r 2                   ; (which is done by doing and $1F) and then
005C45r 2                   ; multiplying by 32 again to get the byte ofset into the block
005C45r 2  9C rr rr         stz MINIX_TMP + 1
005C48r 2  AD rr rr         lda MINIX_CURRENT_INODE
005C4Br 2  29 1F            and #$1F
005C4Dr 2  8D rr rr         sta MINIX_TMP
005C50r 2  A0 05            ldy #5
005C52r 2               minix_read_inode_loop2:
005C52r 2  0E rr rr 2E      asl16 MINIX_TMP         ; multiply inode remainder by 32 bytes to get byte offset
005C56r 2  rr rr        
005C58r 2  88               dey
005C59r 2  D0 F7            bne minix_read_inode_loop2
005C5Br 2               
005C5Br 2                   ; the byte ofset into the block is now in MINIX_TMP
005C5Br 2                   ; add it to the buffer pointer
005C5Br 2                   ; and save it to our own pointer
005C5Br 2  18 AD rr rr      add16 MINIX_TMP, io_buffer_ptr, MINIX_PTR
005C5Fr 2  65 rr 85 rr  
005C63r 2  AD rr rr 65  
005C6Ar 2               
005C6Ar 2               minix_read_inode_loop3:
005C6Ar 2                   ; copy from buffer to data structure
005C6Ar 2  B1 rr            lda (MINIX_PTR), y
005C6Cr 2  99 rr rr         sta MINIX_INODE, y
005C6Fr 2  88               dey
005C70r 2  D0 F8            bne minix_read_inode_loop3
005C72r 2                   ; the inode is now stored in MINIX_INODE for future reference
005C72r 2                   ; we set the zone to read to zero
005C72r 2                   ; so that when we read the data we start with zone 0
005C72r 2  9C rr rr         stz MINIX_ZONE_TO_READ
005C75r 2  9C rr rr         stz MINIX_ZONE_TO_READ + 1
005C78r 2  EE rr rr D0      inc16 MINIX_CURRENT_INODE       ; put current inode number back to what it was, in case we need ot again
005C7Cr 2  03 EE rr rr  
005C80r 2  7A               ply
005C81r 2  60               rts
005C82r 2               
005C82r 2               ; write an inode
005C82r 2               ; inode data is in MINIX_INODE
005C82r 2               ; inode number is in MINIX_CURRENT_INODE, 1 indexed
005C82r 2               
005C82r 2               minix_write_inode:
005C82r 2  5A               phy
005C83r 2                   ; MINIX_CURRENT_INODE contains the number of the inode we want to write to
005C83r 2                   ; the blocks with inodes start at block 1 + MINIX_N_INODE_MAP_BLOCKS + MINIX_N_ZONE_MAP_BLOCKS
005C83r 2  AD rr rr 8D      cp16 MINIX_N_INODE_MAP_BLOCKS, MINIX_CURRENT_BLOCK    ; copy number of inode map blocks to temporary
005C87r 2  rr rr AD rr  
005C8Br 2  rr 8D rr rr  
005C8Fr 2  EE rr rr D0      inc16 MINIX_CURRENT_BLOCK                             ; add 1 to account for superblock
005C93r 2  03 EE rr rr  
005C97r 2  EE rr rr D0      inc16 MINIX_CURRENT_BLOCK                             ; add 1 to account for blank root block
005C9Br 2  03 EE rr rr  
005C9Fr 2  18 AD rr rr      add16 MINIX_CURRENT_BLOCK, MINIX_N_ZONE_MAP_BLOCKS, MINIX_CURRENT_BLOCK ; add the number of zone map blocks
005CA3r 2  6D rr rr 8D  
005CA7r 2  rr rr AD rr  
005CB2r 2               
005CB2r 2  AD rr rr D0      dec16 MINIX_CURRENT_INODE       ; since inodes are 1 indexed, we need to decrement it by one
005CB6r 2  03 CE rr rr  
005CBAr 2  CE rr rr     
005CBDr 2               
005CBDr 2                   ; we have the first block with inodes in MINIX_CURRENT_BLOCK
005CBDr 2                   ; now we have to add the number of blocks necessary to reach the MINIX_CURRENT_INODEth block
005CBDr 2                   ; each inode is 32 bytes, which means there are 32 in each block
005CBDr 2                   ; so let's divide MINIX_CURRENT_INODE by 32 and add it to the current block to get the real block where that inode is located
005CBDr 2               
005CBDr 2  AD rr rr 8D      cp16 MINIX_CURRENT_INODE, MINIX_TMP
005CC1r 2  rr rr AD rr  
005CC5r 2  rr 8D rr rr  
005CC9r 2  A0 05            ldy #5
005CCBr 2               minix_write_inode_loop1:            ; divide inode number by 32
005CCBr 2  4E rr rr 6E      lsr16 MINIX_TMP
005CCFr 2  rr rr        
005CD1r 2  88               dey
005CD2r 2  D0 F7            bne minix_write_inode_loop1
005CD4r 2               
005CD4r 2  18 AD rr rr      add16 MINIX_CURRENT_BLOCK, MINIX_TMP, MINIX_CURRENT_BLOCK   ; MINIX_CURRENT_BLOCK contains the number of the block where our inode is located
005CD8r 2  6D rr rr 8D  
005CDCr 2  rr rr AD rr  
005CE7r 2               
005CE7r 2                   ; copy data from inode in memory data structure to our buffer
005CE7r 2               
005CE7r 2                   ; the offset into the block is calculated by taking MINIX_CURRENT_INODE,
005CE7r 2                   ; dividing by 32 and taking the remainder
005CE7r 2                   ; (which is done by doing and $1F) and then
005CE7r 2                   ; multiplying by 32 again to get the byte ofset into the block
005CE7r 2  9C rr rr         stz MINIX_TMP + 1
005CEAr 2  AD rr rr         lda MINIX_CURRENT_INODE
005CEDr 2  29 1F            and #$1F
005CEFr 2  8D rr rr         sta MINIX_TMP
005CF2r 2  A0 05            ldy #5
005CF4r 2               minix_write_inode_loop2:
005CF4r 2  0E rr rr 2E      asl16 MINIX_TMP         ; multiply inode remainder by 32 bytes to get byte offset
005CF8r 2  rr rr        
005CFAr 2  88               dey
005CFBr 2  D0 F7            bne minix_write_inode_loop2
005CFDr 2               
005CFDr 2                   ; the byte ofset into the block is now in MINIX_TMP
005CFDr 2                   ; add it to the buffer pointer
005CFDr 2                   ; and save it to our own pointer
005CFDr 2  18 AD rr rr      add16 MINIX_TMP, io_buffer_ptr, MINIX_PTR
005D01r 2  65 rr 85 rr  
005D05r 2  AD rr rr 65  
005D0Cr 2  20 rr rr         jsr minix_read_block            ; read block to make sure we have latest inode from disk in the buffer, ready to be modified
005D0Fr 2               minix_write_inode_loop3:
005D0Fr 2                   ; copy from data structure to buffer
005D0Fr 2  B9 rr rr         lda MINIX_INODE, y
005D12r 2  91 rr            sta (MINIX_PTR), y
005D14r 2               
005D14r 2  88               dey
005D15r 2  D0 F8            bne minix_write_inode_loop3
005D17r 2                   ; MINIX_CURRENT_BLOCK was set up above,
005D17r 2                   ; so we can now write data to disk
005D17r 2  20 rr rr         jsr minix_write_block            ; write block from buffer
005D1Ar 2                   ; we set the zone to write to zero
005D1Ar 2                   ; so that when we want to write some data we start with zone 0
005D1Ar 2  9C rr rr         stz MINIX_ZONE_TO_WRITE
005D1Dr 2  9C rr rr         stz MINIX_ZONE_TO_WRITE + 1
005D20r 2  EE rr rr D0      inc16 MINIX_CURRENT_INODE       ; put current inode number back to what it was, in case we need it again
005D24r 2  03 EE rr rr  
005D28r 2  7A               ply
005D29r 2  60               rts
005D2Ar 2               
005D2Ar 2               
005D2Ar 2               ; read the superblock
005D2Ar 2               ; carry clear on success
005D2Ar 2               ; carry set on error
005D2Ar 2               minix_read_superblock:
005D2Ar 2  5A               phy                             ; save y register just in case
005D2Br 2  A9 01            lda #1                          ; setup to read block 1
005D2Dr 2  8D rr rr         sta MINIX_CURRENT_BLOCK         ; this is the second block on the disk
005D30r 2  9C rr rr         stz MINIX_CURRENT_BLOCK + 1
005D33r 2  20 rr rr         jsr minix_read_block            ; read block to buffer
005D36r 2  A0 14            ldy #20                         ; copy data to RAM
005D38r 2               
005D38r 2               minix_read_superblock_loop:
005D38r 2  B1 rr            lda (io_buffer_ptr), y
005D3Ar 2  99 rr rr         sta MINIX_SUPERBLOCK, y
005D3Dr 2  88               dey
005D3Er 2  D0 F8            bne minix_read_superblock_loop
005D40r 2               
005D40r 2                   ; set current inode to root inode
005D40r 2  9C rr rr         stz MINIX_CURRENT_INODE + 1
005D43r 2  A9 01            lda #MINIX_ROOT_INODE
005D45r 2  8D rr rr         sta MINIX_CURRENT_INODE
005D48r 2               
005D48r 2                   ; check for magic number
005D48r 2  AD rr rr         lda MINIX_MAGIC
005D4Br 2  C9 8F            cmp #<MINIX_MAGIC_NUMBER
005D4Dr 2  D0 14            bne minix_read_superblock_fail
005D4Fr 2  AD rr rr         lda MINIX_MAGIC + 1
005D52r 2  C9 13            cmp #>MINIX_MAGIC_NUMBER
005D54r 2  D0 0D            bne minix_read_superblock_fail
005D56r 2                   ; we only support zones of 1024 bytes, so exit with error if different
005D56r 2  AD rr rr         lda MINIX_LOG_ZONE_SIZE
005D59r 2  D0 08            bne minix_read_superblock_fail
005D5Br 2  AD rr rr         lda MINIX_LOG_ZONE_SIZE + 1
005D5Er 2  D0 03            bne minix_read_superblock_fail
005D60r 2               
005D60r 2  7A               ply
005D61r 2  18               clc
005D62r 2  60               rts
005D63r 2               minix_read_superblock_fail:
005D63r 2  7A               ply
005D64r 2  38               sec
005D65r 2  60               rts
005D66r 2               
005D66r 2               
005D66r 2               
005D66r 2               
005D66r 1               
005D66r 1               
005D66r 1               .segment "DATA"
005D66r 1  30 30 30 30  number_string: .asciiz "000000177777"
005D6Ar 1  30 30 31 37  
005D6Er 1  37 37 37 37  
005D73r 1  44 61 74 61  file_test_string:.asciiz "Data has been written. Did we overwrite the file?"
005D77r 1  20 68 61 73  
005D7Br 1  20 62 65 65  
005DA5r 1  74 65 73 74  test_filename: .asciiz "test.txt"
005DA9r 1  2E 74 78 74  
005DADr 1  00           
005DAEr 1  64 69 72 00  test_filename2: .asciiz "dir"
005DB2r 1               
005DB2r 1               kernel_init:
005DB2r 1               v_nmi:
005DB2r 1               v_irq:                          ; IRQ handler
005DB2r 1               
005DB2r 1  DA A2 00 BD      printascii welcome_message
005DB6r 1  rr rr F0 06  
005DBAr 1  20 rr rr E8  
005DC1r 1               
005DC1r 1  4C rr rr         jmp forth
005DC4r 1               
005DC4r 1  A9 rr            lda #<dictionary
005DC6r 1  85 rr            sta up
005DC8r 1  A9 rr            lda #>dictionary
005DCAr 1  85 rr            sta up + 1
005DCCr 1               
005DCCr 1  20 rr rr         jsr calculate_free_mem
005DCFr 1  AD rr rr         lda util_tmp_var + 1
005DD2r 1  AE rr rr         ldx util_tmp_var
005DD5r 1  20 rr rr         jsr print16
005DD8r 1               
005DD8r 1  DA A2 00 BD      printascii free_message
005DDCr 1  rr rr F0 06  
005DE0r 1  20 rr rr E8  
005DE7r 1               
005DE7r 1               
005DE7r 1  20 rr rr         jsr print_message
005DEAr 1  0D 0A 00         .byte AscCR,AscLF, 0
005DEDr 1               
005DEDr 1                   ; set up buffer pointer
005DEDr 1  A9 rr            lda #<IO_BUFFER
005DEFr 1  85 rr            sta io_buffer_ptr
005DF1r 1  A9 rr            lda #>IO_BUFFER
005DF3r 1  85 rr            sta io_buffer_ptr + 1
005DF5r 1               
005DF5r 1  A9 rr            lda #>IO_BUFFER
005DF7r 1  A2 rr            ldx #<IO_BUFFER
005DF9r 1  20 rr rr         jsr print16
005DFCr 1  20 rr rr         jsr print_message
005DFFr 1  0D 0A 00         .byte AscCR,AscLF, 0
005E02r 1               
005E02r 1  20 rr rr         jsr minix_read_superblock
005E05r 1  90 17            bcc @ok
005E07r 1  20 rr rr         jsr print_message
005E0Ar 1  42 61 64 20      .byte "Bad superblock", AscCR,AscLF, 0
005E0Er 1  73 75 70 65  
005E12r 1  72 62 6C 6F  
005E1Br 1               
005E1Br 1               
005E1Br 1  4C rr rr         jmp @forth
005E1Er 1               @ok:
005E1Er 1                   ; this read the root inode to
005E1Er 1  20 rr rr         jsr minix_read_root
005E21r 1  90 15            bcc @root_ok
005E23r 1  20 rr rr         jsr print_message
005E26r 1  42 61 64 20      .byte "Bad root dir", AscCR,AscLF, 0
005E2Ar 1  72 6F 6F 74  
005E2Er 1  20 64 69 72  
005E35r 1  4C rr rr         jmp forth
005E38r 1               @root_ok:
005E38r 1                   ; jsr minix_ls
005E38r 1               
005E38r 1  20 rr rr         jsr print_message
005E3Br 1  0D 0A 00         .byte AscCR,AscLF, 0
005E3Er 1               
005E3Er 1               
005E3Er 1                   ; fill search filename with zeroes
005E3Er 1  A2 1E            ldx #30
005E40r 1               @l1:
005E40r 1  9E rr rr         stz MINIX_SEARCH_FILENAME, x
005E43r 1  CA               dex
005E44r 1  D0 FA            bne @l1
005E46r 1  A2 1E            ldx #30                 ; length of data to copy
005E48r 1                   ; copy search filename
005E48r 1  BD rr rr 9D      memcp test_filename, MINIX_SEARCH_FILENAME
005E4Cr 1  rr rr CA D0  
005E50r 1  F7 AD rr rr  
005E57r 1  20 rr rr         jsr minix_find_inode_for_filename       ; search filename
005E5Ar 1  90 03            bcc @find_ok
005E5Cr 1  4C rr rr         jmp forth
005E5Fr 1               @find_ok:
005E5Fr 1  20 rr rr         jsr minix_read_file
005E62r 1  90 1B            bcc @file_ok
005E64r 1  20 rr rr         jsr print_message
005E67r 1  4E 6F 74 20      .byte "Not a regular file", AscCR,AscLF, 0
005E6Br 1  61 20 72 65  
005E6Fr 1  67 75 6C 61  
005E7Cr 1  4C rr rr         jmp forth
005E7Fr 1               @file_ok:
005E7Fr 1  20 rr rr         jsr print_message
005E82r 1  66 69 6C 65      .byte "file read", AscCR,AscLF, 0
005E86r 1  20 72 65 61  
005E8Ar 1  64 0D 0A 00  
005E8Er 1               
005E8Er 1                   ; change inode userid
005E8Er 1  A9 55            lda #$55
005E90r 1  8D rr rr         sta MINIX_INODE_UID
005E93r 1  A9 AA            lda #$AA
005E95r 1  8D rr rr         sta MINIX_INODE_UID + 1
005E98r 1  A2 00 BD rr      strlen file_test_string
005E9Cr 1  rr F0 03 E8  
005EA0r 1  80 F8        
005EA2r 1  8E rr rr         stx MINIX_INODE_FILESIZE    ; save new future file size
005EA5r 1  20 rr rr         jsr minix_write_inode
005EA8r 1               
005EA8r 1  20 rr rr         jsr minix_read_file
005EABr 1               
005EABr 1  A2 00            ldx #0
005EADr 1               @wloop:
005EADr 1  BD rr rr         lda file_test_string, x
005EB0r 1  F0 06            beq @wexit
005EB2r 1  9D rr rr         sta IO_BUFFER, x
005EB5r 1  E8               inx
005EB6r 1  80 F5            bra @wloop
005EB8r 1               @wexit:
005EB8r 1  20 rr rr         jsr minix_write_data
005EBBr 1               
005EBBr 1  20 rr rr         jsr print_message
005EBEr 1  0D 0A 00         .byte AscCR,AscLF, 0
005EC1r 1  A2 1E            ldx #30
005EC3r 1               @l2:
005EC3r 1  9E rr rr         stz MINIX_SEARCH_FILENAME, x
005EC6r 1  CA               dex
005EC7r 1  D0 FA            bne @l2
005EC9r 1  A2 1E            ldx #30                 ; length of data to copy
005ECBr 1                   ; copy search filename
005ECBr 1               
005ECBr 1  BD rr rr 9D      memcp test_filename, MINIX_SEARCH_FILENAME
005ECFr 1  rr rr CA D0  
005ED3r 1  F7 AD rr rr  
005EDAr 1               
005EDAr 1  20 rr rr         jsr print_message
005EDDr 1  0D 0A 00         .byte AscCR,AscLF, 0
005EE0r 1  20 rr rr         jsr minix_find_inode_for_filename       ; search filename
005EE3r 1  90 17            bcc @file_ok1
005EE5r 1  20 rr rr         jsr print_message
005EE8r 1  66 69 6C 65      .byte "file find fail", AscCR,AscLF, 0
005EECr 1  20 66 69 6E  
005EF0r 1  64 20 66 61  
005EF9r 1  4C rr rr         jmp forth
005EFCr 1               @file_ok1:
005EFCr 1  20 rr rr         jsr print_message
005EFFr 1  66 69 6C 65      .byte "file find 2", AscCR,AscLF, 0
005F03r 1  20 66 69 6E  
005F07r 1  64 20 32 0D  
005F0Dr 1  20 rr rr         jsr minix_read_file
005F10r 1  90 17            bcc @file_ok2
005F12r 1  20 rr rr         jsr print_message
005F15r 1  66 69 6C 65      .byte "file read fail", AscCR,AscLF, 0
005F19r 1  20 72 65 61  
005F1Dr 1  64 20 66 61  
005F26r 1  4C rr rr         jmp forth
005F29r 1               @file_ok2:
005F29r 1  20 rr rr         jsr print_message
005F2Cr 1  66 69 6C 65      .byte "file read 2", AscCR,AscLF, 0
005F30r 1  20 72 65 61  
005F34r 1  64 20 32 0D  
005F3Ar 1               
005F3Ar 1  80 27            bra @forth
005F3Cr 1               
005F3Cr 1               @find_fail:
005F3Cr 1  20 rr rr         jsr print_message
005F3Fr 1  0D 0A 00         .byte AscCR,AscLF, 0
005F42r 1  20 rr rr         jsr print_message
005F45r 1  44 61 74 61      .byte "Data: ", 0
005F49r 1  3A 20 00     
005F4Cr 1               
005F4Cr 1               
005F4Cr 1  A5 rr            lda io_buffer_ptr + 1
005F4Er 1  A6 rr            ldx io_buffer_ptr
005F50r 1  20 rr rr         jsr print16
005F53r 1               
005F53r 1  20 rr rr         jsr print_message
005F56r 1  0D 0A 4E 46      .byte AscCR,AscLF,"NF", AscCR,AscLF, 0
005F5Ar 1  0D 0A 00     
005F5Dr 1  20 rr rr         jsr print_message
005F60r 1  0D 0A 00         .byte AscCR,AscLF, 0
005F63r 1               
005F63r 1               @forth:
005F63r 1  4C rr rr         jmp forth
005F66r 1               
005F66r 1               
005F66r 1               minix_ls:
005F66r 1  5A               phy
005F67r 1               
005F67r 1                   ; load first entry
005F67r 1  A0 00            ldy #0
005F69r 1               @loop:
005F69r 1  A9 0D            lda #$0D
005F6Br 1  20 rr rr         jsr kernel_putc
005F6Er 1  A9 0A            lda #$0A
005F70r 1  20 rr rr         jsr kernel_putc
005F73r 1  B1 rr            lda (io_buffer_ptr), y
005F75r 1  F0 26            beq @exit                   ; if this points to the 0 inode, exit now, because this file does not exist
005F77r 1                   ; otherwise, the file does exist, print its name
005F77r 1  A5 rr 85 rr      cp16 io_buffer_ptr, util_tmp
005F7Br 1  A5 rr 85 rr  
005F7Fr 1  E6 rr D0 02      inc16 util_tmp
005F83r 1  E6 rr        
005F85r 1  E6 rr D0 02      inc16 util_tmp
005F89r 1  E6 rr        
005F8Br 1  5A               phy
005F8Cr 1  20 rr rr         jsr print_zp_index_string
005F8Fr 1  7A               ply
005F90r 1                   ; increase y by 20 to load next entry
005F90r 1  98               tya
005F91r 1  69 20            adc #$20
005F93r 1  B0 03            bcs @inchigh
005F95r 1  A8               tay
005F96r 1  80 D1            bra @loop
005F98r 1               @inchigh:
005F98r 1  E6 rr            inc io_buffer_ptr + 1
005F9Ar 1  A8               tay
005F9Br 1  80 CC            bra @loop
005F9Dr 1               @exit:
005F9Dr 1  7A               ply
005F9Er 1  60               rts
005F9Fr 1               
005F9Fr 1               
005F9Fr 1               
005F9Fr 1               platform_bye:
005F9Fr 1  4C rr rr         jmp platform_bye
005FA2r 1               
005FA2r 1               
005FA2r 1               kernel_getc:
005FA2r 1                   ; """Get a single character from the keyboard. By default, py65mon
005FA2r 1                   ; is set to $f004, which we just keep. Note that py65mon's getc routine
005FA2r 1                   ; is non-blocking, so it will return '00' even if no key has been
005FA2r 1                   ; pressed. We turn this into a blocking version by waiting for a
005FA2r 1                   ; non-zero character.
005FA2r 1                   ; """
005FA2r 1               
005FA2r 1               getc_loop:
005FA2r 1  AD 04 F0         lda $f004
005FA5r 1  F0 FB            beq getc_loop
005FA7r 1  60               rts
005FA8r 1               
005FA8r 1               io_read_sector:
005FA8r 1                   ; sector to read is in io_current_sector
005FA8r 1  5A               phy
005FA9r 1  A9 rr            lda #<minix_data                ; load the minix data location
005FABr 1  85 rr            sta io_read_location            ; and store it temporarly
005FADr 1  A9 rr            lda #>minix_data
005FAFr 1  85 rr            sta io_read_location + 1
005FB1r 1  A5 rr 85 rr      cp16 io_current_sector, io_sector_tmp   ; copy sector requested to temporary
005FB5r 1  A5 rr 85 rr  
005FB9r 1                   ;multiply requested sector by 512 to get byte offset
005FB9r 1  A0 09            ldy #9
005FBBr 1               @mult:
005FBBr 1  06 rr 26 rr      asl16 io_sector_tmp
005FBFr 1  88               dey
005FC0r 1  D0 F9            bne @mult
005FC2r 1  18 A5 rr 65      add16 io_sector_tmp, io_read_location, io_sector_tmp     ; add minix data address to byte offset
005FC6r 1  rr 85 rr A5  
005FCAr 1  rr 65 rr 85  
005FCFr 1               
005FCFr 1  A0 00            ldy #0
005FD1r 1               @loop1:
005FD1r 1  B1 rr            lda (io_sector_tmp), y
005FD3r 1  91 rr            sta (io_buffer_ptr), y
005FD5r 1  C8               iny
005FD6r 1  D0 F9            bne @loop1
005FD8r 1  E6 rr            inc io_sector_tmp + 1       ; read next page
005FDAr 1  E6 rr            inc io_buffer_ptr + 1       ; write to next page
005FDCr 1               @loop2:
005FDCr 1  B1 rr            lda (io_sector_tmp), y
005FDEr 1  91 rr            sta (io_buffer_ptr), y
005FE0r 1  C8               iny
005FE1r 1  D0 F9            bne @loop2
005FE3r 1  C6 rr            dec io_buffer_ptr + 1       ; point back to the beginning of the buffer
005FE5r 1  7A               ply
005FE6r 1  60               rts
005FE7r 1               
005FE7r 1               io_write_sector:
005FE7r 1                   ; the sector to write to is in io_current_sector
005FE7r 1                   ; the data to write is in the buffer pointed to by io_buffer_ptr
005FE7r 1  5A               phy
005FE8r 1  A9 rr            lda #<minix_data                ; load the minix data location
005FEAr 1  85 rr            sta io_read_location            ; and store it temporarly
005FECr 1  A9 rr            lda #>minix_data
005FEEr 1  85 rr            sta io_read_location + 1
005FF0r 1  A5 rr 85 rr      cp16 io_current_sector, io_sector_tmp   ; copy sector requested to temporary
005FF4r 1  A5 rr 85 rr  
005FF8r 1                   ;multiply requested sector by 512 to get byte offset
005FF8r 1  A0 09            ldy #9
005FFAr 1               @mult:
005FFAr 1  06 rr 26 rr      asl16 io_sector_tmp
005FFEr 1  88               dey
005FFFr 1  D0 F9            bne @mult
006001r 1  18 A5 rr 65      add16 io_sector_tmp, io_read_location, io_sector_tmp     ; add minix data address to byte offset
006005r 1  rr 85 rr A5  
006009r 1  rr 65 rr 85  
00600Er 1               
00600Er 1  A0 00            ldy #0
006010r 1               @loop1:
006010r 1  B1 rr            lda (io_buffer_ptr), y
006012r 1  91 rr            sta (io_sector_tmp), y
006014r 1  C8               iny
006015r 1  D0 F9            bne @loop1
006017r 1  E6 rr            inc io_sector_tmp + 1       ; read next page
006019r 1  E6 rr            inc io_buffer_ptr + 1       ; write to next page
00601Br 1               @loop2:
00601Br 1  B1 rr            lda (io_buffer_ptr), y
00601Dr 1  91 rr            sta (io_sector_tmp), y
00601Fr 1  C8               iny
006020r 1  D0 F9            bne @loop2
006022r 1  C6 rr            dec io_buffer_ptr + 1       ; point back to the beginning of the buffer
006024r 1  7A               ply
006025r 1  60               rts
006026r 1               
006026r 1               .segment "RODATA"
000000r 1               minix_data:
000000r 1               .align $100
000000r 1               ; .incbin "minix.img"
000000r 1  20 62 79 74  free_message: .byte " bytes free", $0D, 0
000004r 1  65 73 20 66  
000008r 1  72 65 65 0D  
00000Dr 1  57 65 6C 63  welcome_message: .byte "Welcome to Planck 6502", AscCR, AscLF, AscCR,AscLF, "Type 'words' for available words",AscCR, AscLF,  0
000011r 1  6F 6D 65 20  
000015r 1  74 6F 20 50  
00004Ar 1               
00004Ar 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr        .word v_nmi
000002r 1  rr rr        .word v_reset
000004r 1  rr rr        .word v_irq
000004r 1               
